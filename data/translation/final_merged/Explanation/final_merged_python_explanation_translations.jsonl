{"task_id": "Python/1", "prompt": {"en": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "sq": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa\n    pragu i dhënë.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "hy": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Ստուգել, արդյոք տրված թվերի ցուցակում կան երկու թվեր, որոնք ավելի մոտ են միմյանց, քան\n    տրված շեմը։\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "bn": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা পরস্পরের চেয়ে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "bg": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Проверете дали в дадения списък от числа има две числа, които са по-близо едно до друго от\n    дадения праг.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "zh": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "fr": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Vérifie si, dans la liste donnée de nombres, il existe deux nombres plus proches l'un de l'autre que\n    le seuil donné.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "de": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n    der gegebene Schwellenwert.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "ha": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Duba idan a cikin jerin lambobi da aka bayar, akwai wasu lambobi biyu da ke kusa da juna fiye da\n    iyaka da aka bayar.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "hi": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" दिए गए संख्याओं की सूची में जाँच करें, क्या कोई दो संख्याएँ एक-दूसरे के जितना करीब हैं\n    दिए गए सीमा से।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "hu": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám, amely közelebb van egymáshoz, mint a megadott küszöbérték.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "es": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Verifica si en la lista dada de números, hay dos números más cercanos entre sí que\n    el umbral dado.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "arb": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" التحقق مما إذا كان في قائمة الأرقام المعطاة، يوجد أي رقمين أقرب إلى بعضهما من العتبة المعطاة.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "sw": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Angalia kama katika orodha iliyotolewa ya namba, kuna namba zozote mbili zilizo karibu zaidi kuliko\n    kizingiti kilichotolewa.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "tr": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Verilen sayı listesindeki herhangi iki sayının birbirine\n    verilen eşikten daha yakın olup olmadığını kontrol et.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "vi": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn\n    ngưỡng đã cho không.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "id": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Periksa apakah dalam daftar angka yang diberikan, ada dua angka yang lebih dekat satu sama lain daripada\n    ambang batas yang diberikan.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "ja": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 与えられた数値のリストの中で、任意の2つの数値が指定された閾値よりも近いかどうかを確認します。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "ko": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 주어진 숫자 목록에서 두 숫자가 주어진 임계값보다 더 가까운지 확인합니다.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "ml": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" നൽകിയ ലിസ്റ്റിലുള്ള സംഖ്യകളിൽ, ഏതെങ്കിലും രണ്ട് സംഖ്യകൾ തമ്മിൽ നൽകിയ ത്രെഷ്ഹോൾഡിനേക്കാൾ അടുത്തതായി ഉണ്ടോ എന്ന് പരിശോധിക്കുക.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "fa": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" بررسی کنید که آیا در لیست داده شده از اعداد، دو عدد وجود دارند که به یکدیگر نزدیک‌تر از\n    آستانه داده شده باشند.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\""}, "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False", "instruction": {"en": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nՏվեք Python կոդի կարճ բնութագրական նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।", "bg": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben.", "es": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nToa maelezo mafupi kwa lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\n以下のPythonコードの自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\n다음 Python 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 사용 가능합니다.", "ml": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഉപയോഗിക്കാതെ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def check(has_close_elements):\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n \ncheck(has_close_elements)", "entry_point": "has_close_elements", "signature": "def has_close_elements(numbers: List[float], threshold: float) -> bool:", "docstring": {"en": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "sq": "Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "hy": "Ստուգեք, արդյոք տրված թվերի ցուցակում կա՞ն երկու թիվ, որոնք ավելի մոտ են միմյանց, քան տրված շեմը։  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue", "bn": "প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue", "bg": "Проверете дали в даден списък от числа има две числа, които са по-близо едно до друго от дадения праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "zh": "检查给定数字列表中是否有任意两个数字之间的距离小于给定的阈值。  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue", "fr": "Vérifiez si, dans une liste donnée de nombres, deux nombres sont plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "de": "Prüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "ha": "Duba idan a cikin jerin lambobin da aka bayar, akwai kowanne lambobi biyu da suka fi kusa da juna fiye da ƙayyadadden tazara.  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue", "hi": "दिए गए संख्याओं की सूची में जांचें कि क्या कोई दो संख्याएं एक-दूसरे के करीब हैं दिए गए सीमा से अधिक नहीं।\n\nArgs:\n    numbers (List[float]): संख्याओं की सूची।\n    threshold (float): निकटता की सीमा।\n\nReturns:\n    bool: यदि कोई दो संख्याएं दी गई सीमा से अधिक निकट हैं तो True, अन्यथा False।\n\nExamples:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "hu": "Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám közelebb egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "es": "Verifica si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "arb": "التحقق مما إذا كان في قائمة الأرقام المعطاة، يوجد أي رقمين أقرب إلى بعضهما البعض من العتبة المحددة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "sw": "Angalia kama katika orodha iliyotolewa ya nambari, kuna nambari mbili zozote zilizo karibu zaidi kuliko kizingiti kilichotolewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "vi": "Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không.  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue  ", "id": "Periksa apakah dalam daftar angka yang diberikan, ada dua angka yang lebih dekat satu sama lain daripada ambang batas yang diberikan.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "ja": "与えられた数値のリストにおいて、任意の2つの数値が指定された閾値よりも互いに近いかどうかを確認します。\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "ko": "주어진 숫자 목록에서 두 숫자가 주어진 임계값보다 더 가까운지 확인합니다.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "ml": "നൽകിയ ലിസ്റ്റിലുള്ള സംഖ്യകളിൽ ഏതെങ്കിലും രണ്ട് സംഖ്യകൾ നൽകിയ പരിധിയേക്കാൾ അടുത്തതായി ഉണ്ടോ എന്ന് പരിശോധിക്കുക.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "fa": "بررسی کنید که آیا در لیست داده شده از اعداد، دو عدد نزدیک‌تر از حد آستانه داده شده به یکدیگر هستند یا خیر.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"}}
{"task_id": "Python/2", "prompt": {"en": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "sq": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Hyrja për këtë funksion është një varg që përmban grupe të shumta të kllapave të brendashkruara. Qëllimi juaj është të\n    ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre.\n    Grupet e ndara janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të brendashkruara brenda njëra-tjetrës.\n    Injoroni çdo hapësirë në vargun e hyrjes.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "hy": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Այս ֆունկցիայի մուտքը տող է, որը պարունակում է փակագծերի մի քանի խմբեր։ Ձեր նպատակը\n    այդ խմբերը առանձին տողերի բաժանելն է և վերադարձնել դրանց ցուցակը։\n    Առանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակված է) և միմյանց մեջ չեն ներդրված։\n    Անտեսեք մուտքային տողի ցանկացած բացատ։\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "bn": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" এই ফাংশনের ইনপুট একটি স্ট্রিং যা একাধিক গ্রুপের নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল\n    সেই গ্রুপগুলোকে আলাদা স্ট্রিংয়ে বিভক্ত করা এবং সেইগুলোর তালিকা ফেরত দেওয়া।\n    আলাদা গ্রুপগুলো সুষম (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়\n    ইনপুট স্ট্রিংয়ে কোনো স্পেস উপেক্ষা করুন।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "bg": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Входът за тази функция е низ, съдържащ множество групи от вложени скоби. Вашата цел е да\n    разделите тези групи на отделни низове и да върнете списък с тях.\n    Отделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\n    Игнорирайте всички интервали в низа на входа.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "zh": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" 此函数的输入是一个包含多个嵌套括号组的字符串。你的目标是将这些组分离成独立的字符串，并返回这些字符串的列表。\n    分离的组是平衡的（每个打开的括号都有正确的闭合）且不相互嵌套。\n    忽略输入字符串中的任何空格。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "fr": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de\n    séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci.\n    Les groupes séparés sont équilibrés (chaque parenthèse ouvrante est correctement fermée) et ne sont pas imbriqués les uns dans les autres.\n    Ignorez les espaces dans la chaîne d'entrée.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "de": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Die Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es,\n    diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben.\n    Separate Gruppen sind ausgeglichen (jede öffnende Klammer wird ordnungsgemäß geschlossen) und nicht ineinander verschachtelt.\n    Ignorieren Sie alle Leerzeichen im Eingabestring.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "ha": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Shigar da wannan aikin shi ne wani igiya mai dauke da kungiyoyi masu yawa na baka-baka masu cike da juna. Manufarka ita ce\n    raba waɗannan ƙungiyoyi zuwa igiyoyi daban-daban kuma dawo da jerin waɗannan.\n    Kungiyoyi daban-daban sun daidaita (kowace buɗaɗɗiyar baka an rufe ta daidai) kuma ba a cike da juna ba\n    Yi watsi da duk wani sarari a cikin igiyar shigarwa.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "hi": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों में नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य है कि\n    उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करें और उनकी सूची लौटाएं।\n    अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।\n    इनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "hu": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Ennek a függvénynek a bemenete egy olyan karakterlánc, amely több, egymásba ágyazott zárójelet tartalmazó csoportot tartalmaz. A cél az,\n    hogy ezeket a csoportokat külön karakterláncokká válasszuk szét, és visszaadjuk ezek listáját.\n    A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva.\n    Figyelmen kívül kell hagyni a bemeneti karakterláncban lévő szóközöket.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "es": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es\n    separar esos grupos en cadenas separadas y devolver la lista de estas.\n    Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí.\n    Ignora cualquier espacio en la cadena de entrada.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "arb": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" الإدخال لهذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو\n    فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بتلك السلاسل.\n    المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض\n    تجاهل أي مسافات في سلسلة الإدخال.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "sw": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Ingizo kwa kazi hii ni kamba inayo na makundi mengi ya mabano yaliyopachikwa. Lengo lako ni\n    kutenganisha makundi hayo katika kamba tofauti na kurudisha orodha ya hizo.\n    Makundi tofauti yamebalansishwa (kila kufungua brace imefungwa ipasavyo) na hayajapachikwa ndani ya kila mmoja\n    Puuzia nafasi zozote kwenye kamba ya ingizo.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "tr": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Bu fonksiyona giriş, birden fazla iç içe parantez grubunu içeren bir dizedir. Amacınız bu grupları\n    ayrı dizelere ayırmak ve bunların listesini döndürmektir.\n    Ayrı gruplar dengelidir (her açık parantez düzgün bir şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir.\n    Giriş dizesindeki boşlukları göz ardı edin.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "vi": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Đầu vào của hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là\n    tách những nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó.\n    Các nhóm riêng biệt là cân bằng (mỗi dấu mở đều được đóng đúng cách) và không lồng vào nhau\n    Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "id": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input untuk fungsi ini adalah sebuah string yang mengandung beberapa grup tanda kurung bersarang. Tujuan Anda adalah\n    memisahkan grup-grup tersebut menjadi string terpisah dan mengembalikan daftar dari string-string tersebut.\n    Grup-grup terpisah adalah seimbang (setiap kurung buka ditutup dengan benar) dan tidak bersarang satu sama lain.\n    Abaikan spasi apapun dalam string input.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "ja": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" この関数への入力は、複数のグループのネストされた括弧を含む文字列です。あなたの目標は、\n    それらのグループを別々の文字列に分け、それらのリストを返すことです。\n    別々のグループはバランスが取れており（各開き括弧は適切に閉じられている）、互いにネストされていません。\n    入力文字列のスペースは無視してください。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "ko": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" 이 함수의 입력은 여러 그룹의 중첩된 괄호를 포함하는 문자열입니다. 목표는 이러한 그룹을 개별 문자열로 분리하고 그 목록을 반환하는 것입니다.\n    개별 그룹은 균형이 잡혀 있으며(각 열린 괄호는 제대로 닫혀 있음) 서로 중첩되지 않습니다.\n    입력 문자열의 공백은 무시합니다.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "ml": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" ഈ ഫംഗ്ഷനിലേക്ക് നൽകുന്ന ഇൻപുട്ട് ഒന്നിലധികം ഗ്രൂപ്പുകളിലായി നെസ്റ്റുചെയ്തിരിക്കുന്ന വക്രകൗതുകങ്ങൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് ആണ്. \n    നിങ്ങളുടെ ലക്ഷ്യം ആ ഗ്രൂപ്പുകളെ വേർതിരിച്ച് വ്യത്യസ്ത സ്ട്രിംഗുകളാക്കി മാറ്റുകയും അവയുടെ ലിസ്റ്റ് തിരികെ നൽകുകയും ചെയ്യുക എന്നതാണ്.\n    വേർതിരിച്ച ഗ്രൂപ്പുകൾ സുതാര്യമാണ് (ഓരോ തുറന്ന ബ്രേസ് ശരിയായി അടച്ചിരിക്കുന്നു) കൂടാതെ പരസ്പരം നെസ്റ്റുചെയ്തിട്ടില്ല.\n    ഇൻപുട്ട് സ്ട്രിംഗിലെ ഏതെങ്കിലും സ്പേസുകൾ അവഗണിക്കുക.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "fa": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" ورودی این تابع یک رشته است که شامل چندین گروه از پرانتزهای تو در تو می‌باشد. هدف شما این است که\n    این گروه‌ها را به رشته‌های جداگانه تقسیم کرده و لیستی از آن‌ها را برگردانید.\n    گروه‌های جداگانه متوازن هستند (هر پرانتز باز به درستی بسته می‌شود) و درون یکدیگر تو در تو نیستند.\n    هرگونه فضای خالی در رشته ورودی را نادیده بگیرید.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\""}, "canonical_solution": "    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result", "instruction": {"en": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nПредоставете кратко описание на Python кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で記述し、500文字以内に収めてください。", "ko": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ദൈർഘ്യമില്ലാത്ത ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def check(separate_paren_groups):\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n    '(()())', '((()))', '()', '((())()())'\n    ]\n    assert separate_paren_groups('() (()) ((())) (((())))') == [\n    '()', '(())', '((()))', '(((())))'\n    ]\n    assert separate_paren_groups('(()(())((())))') == [\n    '(()(())((())))'\n    ]\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n \ncheck(separate_paren_groups)", "entry_point": "separate_paren_groups", "signature": "def separate_paren_groups(paren_string: str) -> List[str]:", "docstring": {"en": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "sq": "Inputi për këtë funksion është një varg që përmban disa grupe të kllapave të folezuara. Qëllimi juaj është të ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre. Grupet e ndara janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të folezuara brenda njëra-tjetrës. Injoroni çdo hapësirë në vargun e hyrjes.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "hy": "Այս ֆունկցիայի մուտքը տող է, որը պարունակում է փակագծերի մի քանի խմբեր: Ձեր նպատակն է\nայդ խմբերը առանձնացնել առանձին տողերի մեջ և վերադարձնել դրանց ցանկը:\nԱռանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակվում է) և չեն ներդրված միմյանց մեջ:\nԱնտեսեք մուտքային տողի ցանկացած բացատ:\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "bn": "এই ফাংশনের ইনপুট হল একটি স্ট্রিং যা একাধিক গোষ্ঠীর নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল সেই গোষ্ঠীগুলিকে পৃথক স্ট্রিংয়ে বিভক্ত করা এবং সেগুলির তালিকা ফেরত দেওয়া। পৃথক গোষ্ঠীগুলি ভারসাম্যপূর্ণ (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়। ইনপুট স্ট্রিংয়ে যেকোনো স্পেস উপেক্ষা করুন।\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "bg": "Входът за тази функция е низ, съдържащ множество групи вложени скоби. Вашата цел е да\nразделите тези групи на отделни низове и да върнете списък с тях.\nОтделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\nИгнорирайте всички интервали в низа на входа.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "zh": "输入此函数的是一个包含多个嵌套括号组的字符串。你的目标是将这些组分离成单独的字符串，并返回这些字符串的列表。  \n分离的组是平衡的（每个开括号都有正确的闭合）并且不相互嵌套。  \n忽略输入字符串中的任何空格。  \n>>> separate_paren_groups('( ) (( )) (( )( ))')  \n['()', '(())', '(()())']  ", "fr": "La saisie de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci. Les groupes séparés sont équilibrés (chaque parenthèse ouvrante est correctement fermée) et ne sont pas imbriqués les uns dans les autres. Ignorez tous les espaces dans la chaîne d'entrée.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "de": "Eingabe für diese Funktion ist ein String, der mehrere Gruppen von geschachtelten Klammern enthält. Ihr Ziel ist es, diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben. \nSeparate Gruppen sind ausgeglichen (jede öffnende Klammer wird ordnungsgemäß geschlossen) und nicht ineinander verschachtelt. \nIgnorieren Sie alle Leerzeichen im Eingabestring.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "ha": "Shigar da wannan aikin shine wani igiyar rubutu da ke dauke da kungiyoyi da yawa na baka-baka masu hade. Manufarka ita ce raba wadannan kungiyoyin zuwa igiyoyi daban-daban kuma dawo da jerin wadannan.\nKungiyoyi daban-daban suna daidaita (kowace baka-baka mai bude tana da rufewa daidai) kuma ba a hade cikin juna ba.\nYi watsi da duk wani sarari a cikin igiyar shigarwa.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "hi": "इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों के नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करना और उनकी सूची लौटाना है।  \nअलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।  \nइनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।  \n>>> separate_paren_groups('( ) (( )) (( )( ))')  \n['()', '(())', '(()())']", "hu": "A függvény bemenete egy olyan karakterlánc, amely több csoportot tartalmaz egymásba ágyazott zárójelekből. A cél az, hogy ezeket a csoportokat külön karakterláncokra bontsuk, és visszaadjuk ezek listáját. A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva. Figyelmen kívül kell hagyni az esetleges szóközöket a bemeneti karakterláncban.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "es": "La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es separar esos grupos en cadenas separadas y devolver la lista de estos. Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí. Ignora cualquier espacio en la cadena de entrada.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "arb": "مدخل هذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بتلك السلاسل. المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض. تجاهل أي مسافات في سلسلة المدخلات.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "sw": "Pembejeo kwa kazi hii ni kamba inayojumuisha vikundi vingi vya mabano yaliyopachikwa. Lengo lako ni\nkutenganisha vikundi hivyo kuwa kamba tofauti na kurudisha orodha ya hivyo.\nVikundi vilivyotenganishwa vina uwiano (kila mabano ya kufungua yanafungwa ipasavyo) na havijapachikwa ndani ya kila kimoja\nPuuza nafasi zozote kwenye kamba ya pembejeo.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "tr": "Bu fonksiyonun girdisi, birden fazla iç içe geçmiş parantez grubunu içeren bir stringdir. Amacınız, bu grupları ayrı stringlere ayırmak ve bunların listesini döndürmektir.\nAyrı gruplar dengelidir (her açık parantez düzgün bir şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir.\nGirdi stringindeki boşlukları yok sayın.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "vi": "Đầu vào của hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là tách các nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó. Các nhóm riêng biệt là cân bằng (mỗi dấu ngoặc mở được đóng đúng cách) và không lồng nhau. Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "id": "Input untuk fungsi ini adalah string yang mengandung beberapa grup tanda kurung bersarang. Tujuan Anda adalah untuk memisahkan grup-grup tersebut menjadi string terpisah dan mengembalikan daftar dari string-string tersebut. Grup yang terpisah seimbang (setiap kurung buka ditutup dengan benar) dan tidak bersarang satu sama lain. Abaikan spasi apapun dalam string input.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "ja": "この関数への入力は、複数のグループのネストされた括弧を含む文字列です。あなたの目標は、それらのグループを別々の文字列に分け、それらのリストを返すことです。\n別々のグループはバランスが取れており（各開き括弧は適切に閉じられている）、互いにネストされていません。\n入力文字列内のスペースは無視します。\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "ko": "입력으로 주어지는 문자열은 여러 그룹의 중첩된 괄호를 포함하고 있습니다. 목표는 이러한 그룹을 개별 문자열로 분리하고 그 목록을 반환하는 것입니다.\n각 그룹은 균형이 잡혀 있으며(각 열린 괄호는 적절히 닫혀 있음) 서로 중첩되지 않습니다.\n입력 문자열의 공백은 무시합니다.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "ml": "ഈ ഫംഗ്ഷനിലേക്ക് നൽകുന്ന ഇൻപുട്ട് ഒന്നിലധികം ഗ്രൂപ്പുകളായി നിക്ഷിപ്തമായ വക്രകക്ഷികകൂടുകളുള്ള ഒരു സ്ട്രിംഗാണ്. നിങ്ങളുടെ ലക്ഷ്യം ആ ഗ്രൂപ്പുകൾ വ്യത്യസ്ത സ്ട്രിംഗുകളായി വേർതിരിച്ച് അവയുടെ ലിസ്റ്റ് മടക്കിനൽകുക എന്നതാണ്. വേർതിരിച്ച ഗ്രൂപ്പുകൾ സമതുലിതമാണ് (ഓരോ തുറക്കൽ കക്ഷികവും ശരിയായി അടച്ചിരിക്കുന്നു) കൂടാതെ പരസ്പരം നിക്ഷിപ്തമായിട്ടില്ല. ഇൻപുട്ട് സ്ട്രിംഗിലെ ഏതെങ്കിലും സ്പേസുകൾ അവഗണിക്കുക.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "fa": "ورودی این تابع یک رشته است که شامل چندین گروه از پرانتزهای تو در تو می‌باشد. هدف شما این است که این گروه‌ها را به رشته‌های جداگانه تقسیم کرده و لیستی از آن‌ها را برگردانید.  \nگروه‌های جداگانه متوازن هستند (هر پرانتز باز به درستی بسته شده است) و درون یکدیگر تو در تو نیستند.  \nهر گونه فضای خالی در رشته ورودی را نادیده بگیرید.  \n>>> separate_paren_groups('( ) (( )) (( )( ))')  \n['()', '(())', '(()())']"}}
{"task_id": "Python/3", "prompt": {"en": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "sq": "def truncate_number(number: float) -> float:\n    \"\"\" Duke pasur një numër pozitiv me presje dhjetore, ai mund të dekompozohet në\n    një pjesë të plotë (numri i plotë më i madh më i vogël se numri i dhënë) dhe dhjetore\n    (pjesa e mbetur gjithmonë më e vogël se 1).\n    \n    Kthen pjesën dhjetore të numrit.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "hy": "def truncate_number(number: float) -> float:\n    \"\"\" Տրված դրական տասնորդական կետով թիվը կարող է բաժանվել\n    ամբողջ թվային մասի (տրված թվից փոքրագույն ամբողջ թիվը) և տասնորդական մասի\n    (միշտ 1-ից փոքր մնացորդային մաս):\n    \n    Վերադարձնել թվի տասնորդական մասը:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "bn": "def truncate_number(number: float) -> float:\n    \"\"\" একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা দেওয়া হলে, এটি বিভক্ত করা যেতে পারে\n    একটি পূর্ণসংখ্যা অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে\n    (সবসময় 1 এর চেয়ে ছোট অবশিষ্ট অংশ)।\n\n    সংখ্যার দশমিক অংশ ফেরত দিন।\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "bg": "def truncate_number(number: float) -> float:\n    \"\"\" Дадено е положително число с плаваща запетая, което може да бъде\n    разложено на цяла част (най-голямото цяло число, по-малко от даденото число) и десетични\n    (оставаща част, винаги по-малка от 1).\n    \n    Връща десетичната част на числото.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "zh": "def truncate_number(number: float) -> float:\n    \"\"\" 给定一个正浮点数，它可以分解为整数部分（小于给定数字的最大整数）和小数部分（始终小于1的剩余部分）。\n    \n    返回数字的小数部分。\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "fr": "def truncate_number(number: float) -> float:\n    \"\"\" Étant donné un nombre flottant positif, il peut être décomposé en\n    une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales\n    (partie restante toujours inférieure à 1).\n    \n    Retourne la partie décimale du nombre.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "de": "def truncate_number(number: float) -> float:\n    \"\"\" Gegeben eine positive Gleitkommazahl, kann sie in einen\n    ganzzahligen Teil (größte ganze Zahl kleiner als die gegebene Zahl) und Dezimalstellen\n    (Restteil immer kleiner als 1) zerlegt werden.\n    \n    Gibt den Dezimalteil der Zahl zurück.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "ha": "def truncate_number(number: float) -> float:\n    \"\"\" Idan aka ba da lamba mai yuwuwa mai kyau, za a iya raba ta zuwa\n    wani ɓangare na lamba (mafi girman lamba ƙasa da lambar da aka bayar) da kuma ragowar\n    (ɓangaren da ya rage koyaushe ƙasa da 1).\n    \n    Mayar da ɓangaren ragowar na lambar.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "hi": "def truncate_number(number: float) -> float:\n    \"\"\" दिए गए एक सकारात्मक फ्लोटिंग पॉइंट संख्या को, इसे एक पूर्णांक भाग (दिए गए संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलवों में विभाजित किया जा सकता है\n    (हमेशा 1 से छोटा बचा हुआ भाग)।\n    \n    संख्या के दशमलव भाग को लौटाएं।\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "hu": "def truncate_number(number: float) -> float:\n    \"\"\" Adott egy pozitív lebegőpontos szám, amely felbontható egy\n    egész részre (a megadott számnál kisebb legnagyobb egész) és tizedesjegyekre\n    (mindig 1-nél kisebb maradék rész).\n    \n    Visszaadja a szám tizedesjegy részét.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "es": "def truncate_number(number: float) -> float:\n    \"\"\" Dado un número de punto flotante positivo, puede descomponerse en\n    una parte entera (el entero más grande menor que el número dado) y decimales\n    (parte restante siempre menor que 1).\n    \n    Devuelve la parte decimal del número.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "arb": "def truncate_number(number: float) -> float:\n    \"\"\" بالنظر إلى رقم عشري موجب، يمكن تقسيمه إلى جزء صحيح (أكبر عدد صحيح أصغر من الرقم المعطى) \n    وعشري (الجزء المتبقي الذي يكون دائماً أصغر من 1).\n    \n    إرجاع الجزء العشري من الرقم.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "sw": "def truncate_number(number: float) -> float:\n    \"\"\" Ukipewa namba chanya ya nukta, inaweza kugawanywa katika\n    sehemu ya namba kamili (namba kamili kubwa zaidi ndogo kuliko namba iliyotolewa) na desimali\n    (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n    \n    Rudisha sehemu ya desimali ya namba.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "tr": "def truncate_number(number: float) -> float:\n    \"\"\" Pozitif bir kayan nokta sayısı verildiğinde, bu sayı bir\n    tam sayı kısmına (verilen sayıdan küçük en büyük tam sayı) ve ondalık\n    kısma (her zaman 1'den küçük kalan kısım) ayrılabilir.\n    \n    Sayının ondalık kısmını döndür.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "vi": "def truncate_number(number: float) -> float:\n    \"\"\" Cho một số thực dương, nó có thể được phân tách thành\n    phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n    (phần còn lại luôn nhỏ hơn 1).\n    \n    Trả về phần thập phân của số.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "id": "def truncate_number(number: float) -> float:\n    \"\"\" Diberikan sebuah bilangan floating point positif, bilangan tersebut dapat diuraikan menjadi\n    bagian bilangan bulat (bilangan bulat terbesar yang lebih kecil dari bilangan yang diberikan) dan desimal\n    (bagian sisa yang selalu lebih kecil dari 1).\n    \n    Mengembalikan bagian desimal dari bilangan tersebut.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "ja": "def truncate_number(number: float) -> float:\n    \"\"\" 正の浮動小数点数が与えられた場合、それは整数部分（与えられた数より小さい最大の整数）と\n    小数部分（常に1より小さい残りの部分）に分解できます。\n    \n    数の小数部分を返します。\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "ko": "def truncate_number(number: float) -> float:\n    \"\"\" 양의 부동 소수점 숫자가 주어지면, 이는 정수 부분(주어진 숫자보다 작은 가장 큰 정수)과 소수 부분(항상 1보다 작은 나머지 부분)으로 분해될 수 있습니다.\n    \n    숫자의 소수 부분을 반환합니다.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "ml": "def truncate_number(number: float) -> float:\n    \"\"\" ഒരു പോസിറ്റീവ് ഫ്ലോട്ടിംഗ് പോയിന്റ് സംഖ്യ നൽകിയാൽ, അത് \n    ഒരു പൂർണ്ണസംഖ്യാ ഭാഗത്തിലും (നൽകിയ സംഖ്യയേക്കാൾ ചെറിയ ഏറ്റവും വലിയ പൂർണ്ണസംഖ്യ) \n    ദശാംശങ്ങളിലും (എപ്പോഴും 1-ലേക്കാൾ ചെറിയ ശേഷിക്കുന്ന ഭാഗം) വിഭജിക്കാം.\n    \n    സംഖ്യയുടെ ദശാംശ ഭാഗം മടക്കിനൽകുക.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "fa": "def truncate_number(number: float) -> float:\n    \"\"\" با توجه به یک عدد اعشاری مثبت، می‌توان آن را به یک بخش صحیح \n    (بزرگترین عدد صحیح کوچکتر از عدد داده شده) و اعشار \n    (بخش باقی‌مانده که همیشه کوچکتر از ۱ است) تجزیه کرد.\n    \n    بخش اعشاری عدد را برگردانید.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\""}, "canonical_solution": "    return number % 1.0", "instruction": {"en": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nՏվեք Python կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nনিচে প্রদত্ত পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben.", "es": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil tanımı (docstring) sağlayın.", "vi": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) tentang kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\n以下のPythonコードに対して、500文字以内で簡潔な日本語の説明（ドックストリング）を提供してください。", "ko": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഉപയോഗിക്കാതെ ഒരു സംക്ഷിപ്ത നാച്ചുറൽ ലാംഗ്വേജ് വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def check(truncate_number):\n    assert truncate_number(3.5) == 0.5\n    assert abs(truncate_number(1.33) - 0.33) < 1e-6\n    assert abs(truncate_number(123.456) - 0.456) < 1e-6\n \ncheck(truncate_number)", "entry_point": "truncate_number", "signature": "def truncate_number(number: float) -> float:", "docstring": {"en": "Given a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.\n>>> truncate_number(3.5)\n0.5", "sq": "Duke pasur një numër pozitiv me presje dhjetore, ai mund të dekompozohet në një pjesë të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetore (pjesa e mbetur gjithmonë më e vogël se 1).\n\nKthen pjesën dhjetore të numrit.\n>>> truncate_number(3.5)\n0.5", "hy": "Դրված դրական լողացող կետով թիվը կարելի է բաժանել ամբողջ մասի (տրված թվից փոքրագույն ամբողջ թիվ) և տասնորդական մասի (մնացորդային մասը միշտ փոքր է 1-ից):\n\nՎերադարձնում է թվի տասնորդական մասը.\n>>> truncate_number(3.5)\n0.5", "bn": "প্রদত্ত একটি ধনাত্মক ফ্লোটিং পয়েন্ট সংখ্যা, এটি একটি পূর্ণসংখ্যা অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্ট অংশ সর্বদা ১ এর চেয়ে ছোট) বিভক্ত করা যেতে পারে।\n\nসংখ্যার দশমিক অংশটি ফেরত দিন।\n>>> truncate_number(3.5)\n0.5", "bg": "Дадено е положително число с плаваща запетая, което може да бъде разложено на\nцяла част (най-голямото цяло число, по-малко от даденото число) и десетични\n(остатъчната част винаги е по-малка от 1).\n\nВръща десетичната част на числото.", "zh": "给定一个正浮点数，它可以被分解为一个整数部分（小于给定数字的最大整数）和小数部分（剩余部分总是小于1）。\n\n返回数字的小数部分。  \n>>> truncate_number(3.5)  \n0.5", "fr": "Étant donné un nombre flottant positif, il peut être décomposé en une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales (la partie restante toujours plus petite que 1).\n\nRetourne la partie décimale du nombre.\n>>> truncate_number(3.5)\n0.5", "de": "Given eine positive Gleitkommazahl, kann sie in einen ganzzahligen Teil (größte ganze Zahl kleiner als die gegebene Zahl) und Dezimalstellen (übrig bleibender Teil immer kleiner als 1) zerlegt werden.\n\nGibt den Dezimalteil der Zahl zurück.\n>>> truncate_number(3.5)\n0.5", "ha": "An ba da lamba mai iyo mai kyau, za a iya rarraba ta zuwa\nsashi na cikakken lamba (babban cikakken lamba da ya fi ƙaramin lambar da aka bayar) da kuma ragowar\n(sashi mai saura koyaushe ƙasa da 1).\n\nMayar da sashin ragowar lambar.\n>>> truncate_number(3.5)\n0.5", "hi": "दिए गए एक धनात्मक फ्लोटिंग पॉइंट संख्या को इसके पूर्णांक भाग (दी गई संख्या से छोटी सबसे बड़ी पूर्णांक) और दशमलव में विभाजित किया जा सकता है (शेष भाग हमेशा 1 से छोटा होता है)।\n\nसंख्या के दशमलव भाग को लौटाएँ।\n>>> truncate_number(3.5)\n0.5", "hu": "Adott egy pozitív lebegőpontos szám, amely felbontható egy egész részre (a megadott számnál kisebb legnagyobb egész) és tizedesekre (a maradék rész mindig kisebb, mint 1).\n\nVisszaadja a szám tizedes részét.", "es": "Dado un número de punto flotante positivo, se puede descomponer en una parte entera (el entero más grande menor que el número dado) y decimales (la parte restante siempre menor que 1).\n\nDevuelve la parte decimal del número.\n>>> truncate_number(3.5)\n0.5", "arb": "بالنظر إلى رقم عشري موجب، يمكن تقسيمه إلى جزء صحيح (أكبر عدد صحيح أصغر من الرقم المعطى) وأجزاء عشرية (الجزء المتبقي دائمًا أصغر من 1).\n\nإرجاع الجزء العشري من الرقم.\n>>> truncate_number(3.5)\n0.5", "sw": "Kwa kuzingatia nambari chanya ya nukta ya kuelea, inaweza kugawanywa katika sehemu ya nambari kamili (nambari kamili kubwa zaidi ndogo kuliko nambari iliyotolewa) na desimali (sehemu iliyobaki ambayo kila mara ni ndogo kuliko 1).\n\nRudisha sehemu ya desimali ya nambari.\n>>> truncate_number(3.5)\n0.5", "tr": "Verilen pozitif bir kayan noktalı sayı, bir tamsayı kısmına (verilen sayıdan küçük en büyük tamsayı) ve ondalık kısımlara (her zaman 1'den küçük kalan kısım) ayrılabilir.\n\nSayının ondalık kısmını döndürün.\n>>> truncate_number(3.5)\n0.5", "vi": "Đưa ra một số thực dương, nó có thể được phân tách thành\nphần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n(phần còn lại luôn nhỏ hơn 1).\n\nTrả về phần thập phân của số.\n>>> truncate_number(3.5)\n0.5", "id": "Diberikan sebuah bilangan floating point positif, bilangan tersebut dapat diuraikan menjadi bagian bilangan bulat (bilangan bulat terbesar yang lebih kecil dari bilangan yang diberikan) dan desimal (bagian sisa yang selalu lebih kecil dari 1).\n\nMengembalikan bagian desimal dari bilangan.\n>>> truncate_number(3.5)\n0.5", "ja": "与えられた正の浮動小数点数は、整数部（与えられた数より小さい最大の整数）と小数部（常に1未満の残りの部分）に分解できます。\n\n数の小数部を返します。\n>>> truncate_number(3.5)\n0.5", "ko": "주어진 양의 부동 소수점 숫자는 정수 부분(주어진 숫자보다 작은 가장 큰 정수)과 소수 부분(항상 1보다 작은 나머지 부분)으로 분해될 수 있습니다.\n\n숫자의 소수 부분을 반환합니다.\n>>> truncate_number(3.5)\n0.5", "ml": "ഒരു പോസിറ്റീവ് ഫ്ലോട്ടിംഗ് പോയിന്റ് സംഖ്യ നൽകിയാൽ, അത് ഒരു പൂർണ്ണസംഖ്യാ ഭാഗത്തിലും (നൽകിയ സംഖ്യയേക്കാൾ ചെറിയ ഏറ്റവും വലിയ പൂർണ്ണസംഖ്യ) ദശാംശങ്ങളിലും (എപ്പോഴും 1-ൽ കുറവായ ശേഷിക്കുന്ന ഭാഗം) വിഭജിക്കാം.\n\nസംഖ്യയുടെ ദശാംശ ഭാഗം മടക്കിനൽകുക.\n>>> truncate_number(3.5)\n0.5", "fa": "با توجه به یک عدد اعشاری مثبت، می‌توان آن را به دو بخش تقسیم کرد:\nیک بخش صحیح (بزرگ‌ترین عدد صحیح کوچکتر از عدد داده شده) و بخش اعشاری\n(بخش باقی‌مانده که همیشه کوچکتر از 1 است).\n\nبخش اعشاری عدد را برگردانید.\n>>> truncate_number(3.5)\n0.5"}}
{"task_id": "Python/4", "prompt": {"en": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "sq": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Ju jepet një listë e operacioneve të depozitave dhe tërheqjeve në një llogari bankare që fillon me\n    bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe\n    në atë pikë funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "hy": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Ձեզ տրված է բանկային հաշվի վրա ավանդների և դուրսբերումների գործողությունների ցուցակ, որը սկսվում է\n    զրոյական մնացորդով։ Ձեր խնդիրն է հայտնաբերել, թե արդյոք որևէ պահի հաշվի մնացորդը ընկնում է զրոյից ցածր, և\n    այդ պահին ֆունկցիան պետք է վերադարձնի True։ Հակառակ դեպքում այն պետք է վերադարձնի False։\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "bn": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" আপনার কাছে একটি ব্যাংক অ্যাকাউন্টে জমা এবং উত্তোলনের কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়।\n    আপনার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে পড়ে কিনা, এবং সেই সময়ে ফাংশনটি True রিটার্ন করবে।\n    অন্যথায় এটি False রিটার্ন করবে।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "bg": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Даден ви е списък с операции за депозити и тегления от банкова сметка, която започва с\n    нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нула, и\n    в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "zh": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" 给定一个银行账户的存款和取款操作列表，该账户初始余额为零。你的任务是检测账户余额是否在任何时候低于零，\n    如果是，函数应返回True。否则应返回False。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "fr": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" On vous donne une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec\n    un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et\n    à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "de": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sie erhalten eine Liste von Einzahlungs- und Abhebungsoperationen auf einem Bankkonto, das mit\n    einem Kontostand von null beginnt. Ihre Aufgabe ist es, zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und\n    in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "ha": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" An ba ku jerin ajiya da cire kudi a kan asusun banki wanda ya fara da\n    sifili a matsayin ma'auni. Aikin ku shine gano ko a kowane lokaci ma'aunin asusun ya fadi kasa da sifili, kuma\n    a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "hi": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" आपको जमा और निकासी संचालन की एक सूची दी गई है जो एक बैंक खाते पर होती है जो शून्य शेष के साथ शुरू होती है। \n    आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते का शेष शून्य से नीचे गिरता है, और उस बिंदु पर \n    फ़ंक्शन को True लौटाना चाहिए। अन्यथा इसे False लौटाना चाहिए।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "hu": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Adott egy lista a banki számlán végzett befizetési és kifizetési műveletekről, amely nulla egyenleggel kezdődik.\n    Az a feladat, hogy észleljük, ha bármelyik ponton a számla egyenlege nulla alá csökken, és ebben az esetben a függvénynek True értéket kell visszaadnia.\n    Egyébként False értéket kell visszaadnia.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "es": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con\n    saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y\n    en ese momento la función debe devolver True. De lo contrario, debe devolver False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "arb": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" لديك قائمة من عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفر. مهمتك هي اكتشاف ما إذا كان في أي نقطة \n    ينخفض رصيد الحساب إلى ما دون الصفر، وعند هذه النقطة يجب أن تُرجع الدالة True. وإلا يجب أن تُرجع False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "sw": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na\n    salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti litashuka chini ya sifuri, na\n    wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "tr": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sıfır bakiye ile başlayan bir banka hesabı üzerinde yapılan para yatırma ve çekme işlemlerinin\n    bir listesini veriliyor. Göreviniz, hesabın bakiyesinin herhangi bir noktada sıfırın altına düşüp düşmediğini\n    tespit etmektir ve bu durumda fonksiyon True döndürmelidir. Aksi takdirde False döndürmelidir.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "vi": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Bạn được cung cấp một danh sách các giao dịch nạp và rút tiền trên một tài khoản ngân hàng bắt đầu với\n    số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ thời điểm nào số dư của tài khoản có giảm xuống dưới không hay không, và\n    tại thời điểm đó hàm nên trả về True. Ngược lại, nó nên trả về False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "id": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Anda diberikan daftar operasi setoran dan penarikan pada rekening bank yang dimulai dengan\n    saldo nol. Tugas Anda adalah mendeteksi apakah pada titik mana pun saldo rekening jatuh di bawah nol, dan\n    pada titik itu fungsi harus mengembalikan True. Jika tidak, fungsi harus mengembalikan False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "ja": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" あなたは、ゼロ残高で始まる銀行口座の預金と引き出し操作のリストを与えられます。\n    あなたのタスクは、口座の残高がゼロを下回るかどうかを検出し、その時点で関数がTrueを返すようにすることです。\n    そうでなければ、Falseを返すべきです。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "ko": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" 은행 계좌의 입금 및 출금 작업 목록이 주어지며, 계좌는 0의 잔액으로 시작합니다.\n    계좌의 잔액이 어느 시점에서든 0보다 떨어지는지 감지하는 것이 과제이며,\n    그 시점에서 함수는 True를 반환해야 합니다. 그렇지 않으면 False를 반환해야 합니다.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "ml": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" നിങ്ങൾക്ക് ശൂന്യ ബാലൻസിൽ ആരംഭിക്കുന്ന ഒരു ബാങ്ക് അക്കൗണ്ടിലെ നിക്ഷേപവും പിന്‍വലിക്കുകയും ചെയ്യുന്ന പ്രവർത്തനങ്ങളുടെ ഒരു പട്ടിക നൽകിയിരിക്കുന്നു.\n    ഏതെങ്കിലും സമയത്ത് അക്കൗണ്ടിന്റെ ബാലൻസ് ശൂന്യത്തിന് താഴെയാണോ എന്ന് കണ്ടെത്തുക, അപ്പോൾ ഫംഗ്ഷൻ True മടക്കണം.\n    അല്ലെങ്കിൽ അത് False മടക്കണം.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "fa": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" به شما لیستی از عملیات واریز و برداشت در یک حساب بانکی داده شده است که با\n    موجودی صفر شروع می‌شود. وظیفه شما این است که تشخیص دهید آیا در هر نقطه‌ای موجودی حساب به زیر صفر می‌رسد یا خیر، و\n    در آن نقطه تابع باید True را برگرداند. در غیر این صورت باید False را برگرداند.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\""}, "canonical_solution": "    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False", "instruction": {"en": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nՏվեք Python կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nПредоставете кратко описание на Python кода на български език, използвайки максимум 500 знака.", "zh": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nGeben Sie eine prägnante Beschreibung (Docstring) des Python-Codes in deutscher Sprache mit maximal 500 Zeichen an.", "ha": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.", "sw": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nAşağıdaki Python kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を、日本語で500文字以内で提供してください。", "ko": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nPython 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 500자 이내로 제공하세요.", "ml": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ നീളമില്ലാത്ത ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nتوضیحی مختصر و طبیعی (docstring) از کد پایتون به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def check(below_zero):\n    assert below_zero([]) == False\n    assert below_zero([1, 2, -3, 1, 2, -3]) == False\n    assert below_zero([1, 2, -4, 5, 6]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True\n \ncheck(below_zero)", "entry_point": "below_zero", "signature": "def below_zero(operations: List[int]) -> bool:", "docstring": {"en": "You're given a list of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account fallls below zero, and\nat that point function should return True. Otherwise it should return False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "sq": "Ju jepet një listë e operacioneve të depozitimit dhe tërheqjes në një llogari bankare që fillon me bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe në atë pikë funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "hy": "Ձեզ տրված է բանկային հաշվի վրա կատարված ավանդների և հանումների գործողությունների ցուցակը, որը սկսվում է զրոյական մնացորդով: Ձեր խնդիրն է հայտնաբերել, արդյոք որևէ պահի հաշվի մնացորդը ընկնում է զրոյից ցածր, և այդ պահին ֆունկցիան պետք է վերադարձնի True: Հակառակ դեպքում այն պետք է վերադարձնի False:\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "bn": "আপনাকে একটি ব্যাংক অ্যাকাউন্টের জমা এবং উত্তোলন কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। আপনার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই সময়ে ফাংশনটি True ফেরত দেওয়া উচিত। অন্যথায় এটি False ফেরত দেওয়া উচিত।\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "bg": "Даден ви е списък с операции за депозити и тегления по банкова сметка, която започва с нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нула, и в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "zh": "你有一个银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候低于零，并在那时函数应返回True。否则，它应返回False。\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "fr": "Vous avez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "de": "Du hast eine Liste von Einzahlungs- und Abhebungsvorgängen auf einem Bankkonto, das mit einem Kontostand von null beginnt. Deine Aufgabe ist es zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "ha": "An ba ku jerin ayyukan ajiya da cire kudi a kan asusun banki wanda ya fara da sifili. Aikinku shine gano ko a kowane lokaci ma'aunin asusun ya fadi kasa da sifili, kuma a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "hi": "आपको जमा और निकासी ऑपरेशनों की एक सूची दी गई है जो एक बैंक खाते पर की जाती हैं, जो शून्य शेष राशि से शुरू होता है। आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते की शेष राशि शून्य से नीचे गिरती है, और उस बिंदु पर फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "hu": "Egy bankszámlán végrehajtott befizetési és kifizetési műveletek listáját kapod, amely kezdetben nulla egyenleggel rendelkezik. A feladatod az, hogy észleld, ha bármely ponton a számla egyenlege nulla alá csökken, és ebben az esetben a függvénynek True értéket kell visszaadnia. Ellenkező esetben False értéket kell visszaadnia.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "es": "Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con un saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y en ese momento la función debería devolver True. De lo contrario, debería devolver False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "arb": "أنت مُعطى قائمة من عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفري. مهمتك هي اكتشاف ما إذا كان في أي لحظة ينخفض رصيد الحساب إلى ما دون الصفر، وعند تلك النقطة يجب أن تُرجع الدالة True. وإلا، يجب أن تُرجع False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "sw": "Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki inayoanza na salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti linashuka chini ya sifuri, na wakati huo kazi inapaswa kurudi True. Vinginevyo inapaswa kurudi False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "tr": "Verilen bir banka hesabı üzerinde sıfır bakiye ile başlayan para yatırma ve çekme işlemlerinin bir listesidir. Göreviniz, herhangi bir noktada hesabın bakiyesinin sıfırın altına düşüp düşmediğini tespit etmektir ve bu noktada fonksiyon True döndürmelidir. Aksi takdirde, False döndürmelidir.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "vi": "Bạn được cung cấp một danh sách các giao dịch nạp và rút tiền trên một tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ thời điểm nào số dư của tài khoản có rơi xuống dưới không hay không, và tại thời điểm đó hàm nên trả về True. Nếu không, nó nên trả về False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "id": "Anda diberikan daftar operasi setoran dan penarikan pada rekening bank yang dimulai dengan saldo nol. Tugas Anda adalah mendeteksi apakah pada titik mana pun saldo rekening jatuh di bawah nol, dan pada titik itu fungsi harus mengembalikan True. Jika tidak, fungsi harus mengembalikan False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "ja": "銀行口座に対する入金および出金操作のリストが与えられています。この口座はゼロ残高から始まります。あなたのタスクは、口座の残高がゼロを下回るかどうかを検出し、その時点で関数はTrueを返すべきです。そうでない場合はFalseを返すべきです。\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "ko": "은행 계좌에 대한 입금 및 출금 작업 목록이 주어지며, 계좌는 0의 잔액으로 시작합니다. 계좌의 잔액이 어느 시점에서든 0보다 떨어지는지 감지하는 것이 과제입니다. 이 경우 함수는 True를 반환해야 합니다. 그렇지 않으면 False를 반환해야 합니다.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "ml": "നിങ്ങൾക്ക് ഒരു ബാങ്ക് അക്കൗണ്ടിലെ നിക്ഷേപ, പിന്‍വലിക്കല്‍ പ്രവര്‍ത്തനങ്ങളുടെ ഒരു പട്ടിക നല്‍കിയിരിക്കുന്നു, ഇത് ശൂന്യ ബാലന്‍സില്‍ ആരംഭിക്കുന്നു. അക്കൗണ്ടിന്റെ ബാലന്‍സ് ഏതെങ്കിലും ഘട്ടത്തില്‍ ശൂന്യത്തിന് താഴെയായി വീഴുന്നുണ്ടോ എന്ന് കണ്ടെത്തുകയാണ് നിങ്ങളുടെ ദൗത്യം, അപ്പോള്‍ ഫങ്ഷന്‍ True മടക്കണം. അല്ലാത്ത പക്ഷം അത് False മടക്കണം.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "fa": "شما یک لیست از عملیات واریز و برداشت در یک حساب بانکی دارید که با موجودی صفر شروع می‌شود. وظیفه شما این است که تشخیص دهید آیا در هر نقطه‌ای موجودی حساب به زیر صفر می‌رسد یا خیر، و در آن نقطه تابع باید True را برگرداند. در غیر این صورت باید False را برگرداند.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue"}}
{"task_id": "Python/5", "prompt": {"en": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "sq": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Për një listë të dhënë të numrave hyrës, llogaritni Devijimin Absolut Mesatar\n    rreth mesatares së këtij grupi të dhënash.\n    Devijimi Absolut Mesatar është diferenca mesatare absolute midis secilit\n    element dhe një pikë qendrore (mesatarja në këtë rast):\n    MAD = mesatarja | x - x_mesatarja |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "hy": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Տրված մուտքային թվերի ցուցակի համար հաշվարկել Միջին բացարձակ շեղումը\n    այս տվյալների հավաքածուի միջինի շուրջ:\n    Միջին բացարձակ շեղումը միջին բացարձակ տարբերությունն է յուրաքանչյուր\n    տարրի և կենտրոնական կետի (այս դեպքում միջինի) միջև:\n    MAD = միջին | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "bn": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি\n    হিসাব করুন।\n    গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য:\n    MAD = গড় | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "bg": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" За даден списък от входни числа, изчислете Средно Абсолютно Отклонение\n    около средната стойност на този набор от данни.\n    Средното Абсолютно Отклонение е средната абсолютна разлика между всеки\n    елемент и централната точка (в случая средната стойност):\n    MAD = средно | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "zh": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" 对于给定的输入数字列表，计算该数据集的平均绝对偏差。\n    平均绝对偏差是每个元素与中心点（在此情况下为平均值）之间的平均绝对差：\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "fr": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Pour une liste donnée de nombres en entrée, calculer la Déviation Moyenne Absolue\n    autour de la moyenne de cet ensemble de données.\n    La Déviation Moyenne Absolue est la différence absolue moyenne entre chaque\n    élément et un point central (la moyenne dans ce cas) :\n    MAD = moyenne | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "de": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Für eine gegebene Liste von Eingabezahlen die mittlere absolute Abweichung\n    um den Mittelwert dieses Datensatzes berechnen.\n    Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n    Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n    MAD = Durchschnitt | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "ha": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Don wani jerin lambobi na shigarwa, ƙididdige Matsakaicin Bambancin Gaskiya\n    a kusa da matsakaicin wannan bayanan.\n    Matsakaicin Bambancin Gaskiya shine matsakaicin bambancin gaskiya tsakanin kowanne\n    abu da wani wuri na tsakiya (matsakaici a wannan yanayin):\n    MAD = matsakaici | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "hi": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटा सेट के औसत के चारों ओर\n    औसत निरपेक्ष विचलन की गणना करें।\n    औसत निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्र बिंदु (इस मामले में औसत)\n    के बीच औसत निरपेक्ष अंतर है:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "hu": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Adott számok listájára számítsa ki az átlagos abszolút eltérést\n    a dataset átlagához képest.\n    Az átlagos abszolút eltérés az egyes elemek és egy középpont (jelen esetben az átlag)\n    közötti átlagos abszolút különbség:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "es": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Para una lista dada de números de entrada, calcular la Desviación Media Absoluta\n    alrededor de la media de este conjunto de datos.\n    La Desviación Media Absoluta es la diferencia absoluta promedio entre cada\n    elemento y un punto central (media en este caso):\n    MAD = promedio | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "arb": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" لحساب الانحراف المطلق المتوسط لقائمة معينة من الأرقام المدخلة\n    حول متوسط هذه المجموعة من البيانات.\n    الانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل عنصر ونقطة مركزية\n    (المتوسط في هذه الحالة):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "sw": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Kwa orodha iliyotolewa ya namba za ingizo, hesabu Mkengeuko wa Wastani wa \n    Kiasi kuzunguka wastani wa seti hii ya data.\n    Mkengeuko wa Wastani wa Kiasi ni tofauti ya wastani ya kiasi kati ya kila \n    kipengele na kituo (wastani katika kesi hii):\n    MAD = wastani | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "tr": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Verilen bir sayı listesi için, bu veri kümesinin ortalaması etrafında\n    Ortalama Mutlak Sapma'yı hesaplayın.\n    Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama)\n    arasındaki ortalama mutlak farktır:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "vi": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Đối với một danh sách các số đầu vào, tính Độ lệch tuyệt đối trung bình\n    xung quanh giá trị trung bình của tập dữ liệu này.\n    Độ lệch tuyệt đối trung bình là trung bình của sự khác biệt tuyệt đối giữa mỗi\n    phần tử và một điểm trung tâm (trong trường hợp này là giá trị trung bình):\n    MAD = trung bình | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "id": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Untuk daftar angka masukan yang diberikan, hitung Deviasi Absolut Rata-rata\n    sekitar rata-rata dari kumpulan data ini.\n    Deviasi Absolut Rata-rata adalah rata-rata perbedaan absolut antara setiap\n    elemen dan titik pusat (rata-rata dalam kasus ini):\n    MAD = rata-rata | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "ja": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" 与えられた入力数値のリストに対して、データセットの平均を中心とした平均絶対偏差を計算します。\n    平均絶対偏差は、各要素と中心点（この場合は平均）との間の平均絶対差です：\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "ko": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" 주어진 입력 숫자 목록에 대해, 이 데이터셋의 평균을 중심으로 평균 절대 편차를 계산합니다.\n    평균 절대 편차는 각 요소와 중심점(이 경우 평균) 사이의 평균 절대 차이입니다:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "ml": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" നൽകിയ ലിസ്റ്റ് ഇൻപുട്ട് നംബറുകൾക്കായി, ഈ ഡാറ്റാസെറ്റിന്റെ ശരാശരിയുടെ ചുറ്റുമുള്ള ശരാശരി പരമാവധി വ്യതിയാനം\n    കണക്കാക്കുക.\n    ശരാശരി പരമാവധി വ്യതിയാനം എന്നത് ഓരോ ഘടകവും ഒരു കേന്ദ്രബിന്ദുവുമായുള്ള (ഈ സാഹചര്യത്തിൽ ശരാശരി) ശരാശരി പരമാവധി വ്യത്യാസമാണ്:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "fa": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" برای یک لیست داده شده از اعداد ورودی، انحراف مطلق میانگین را\n    حول میانگین این مجموعه داده محاسبه کنید.\n    انحراف مطلق میانگین، میانگین تفاوت مطلق بین هر عنصر و یک نقطه مرکزی\n    (در اینجا میانگین) است:\n    MAD = میانگین | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\""}, "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "instruction": {"en": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nՏվեք Python կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben.", "es": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n最大 500 文字を使用して、英語で Python コードの簡潔な自然言語説明 (docstring) を提供します。", "ko": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nPython 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def check(mean_absolute_deviation):\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n    \ncheck(mean_absolute_deviation)", "entry_point": "mean_absolute_deviation", "signature": "def mean_absolute_deviation(numbers: List[float]) -> float:", "docstring": {"en": "For a given list of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0", "sq": "Për një listë të dhënë të numrave të hyrjes, llogaritni Devijimin Absolut Mesatar rreth mesatares së këtij grupi të dhënash. Devijimi Absolut Mesatar është diferenca mesatare absolute midis secilit element dhe një pikë qendrore (mesatarja në këtë rast): DAM = mesatarja | x - x_mesatare |", "hy": "Տրված մուտքային թվերի ցուցակի համար հաշվարկեք միջին բացարձակ շեղումը տվյալների այս հավաքածուի միջինից։  \nՄիջին բացարձակ շեղումը յուրաքանչյուր տարրի և կենտրոնական կետի (այս դեպքում՝ միջինը) միջև միջին բացարձակ տարբերությունն է։  \nMAD = միջին | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0", "bn": "প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি গণনা করুন। গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য: MAD = গড় | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0", "bg": "За даден списък от входни числа, изчислете Средно Абсолютно Отклонение около средната стойност на този набор от данни. Средно Абсолютно Отклонение е средната абсолютна разлика между всеки елемент и централната точка (в този случай средната стойност): MAD = средно | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0", "zh": "对于给定的输入数字列表，计算该数据集均值的平均绝对偏差。  \n平均绝对偏差是每个元素与中心点（在此情况下为均值）之间的平均绝对差：  \nMAD = average | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0", "fr": "Pour une liste donnée de nombres d'entrée, calculez la Déviation Absolue Moyenne autour de la moyenne de cet ensemble de données.  \nLa Déviation Absolue Moyenne est la différence absolue moyenne entre chaque élément et un point central (la moyenne dans ce cas) :  \nMAD = moyenne | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0", "de": "Für eine gegebene Liste von Eingabezahlen berechnen Sie die mittlere absolute Abweichung um den Mittelwert dieses Datensatzes. Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem Element und einem Mittelpunkt (in diesem Fall der Mittelwert): MAD = durchschnittlich | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0", "ha": "Don jerin lambobin shigarwa da aka bayar, ƙididdige Matsakaicin Bambancin Gaskiya a kusa da matsakaicin wannan bayanan. Matsakaicin Bambancin Gaskiya shine matsakaicin bambancin gaskiya tsakanin kowane abu da wata cibiyar (matsakaici a wannan yanayin): MAD = matsakaici | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0", "hi": "दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटा सेट के औसत के चारों ओर माध्य निरपेक्ष विचलन की गणना करें।  \nमाध्य निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्र बिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:  \nMAD = औसत | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0", "hu": "Egy adott bemeneti számok listájára számítsa ki az átlagos abszolút eltérést az adathalmaz átlagához képest.  \nAz átlagos abszolút eltérés az egyes elemek és egy középpont (jelen esetben az átlag) közötti átlagos abszolút különbség:  \nMAD = average | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0", "es": "Para una lista dada de números de entrada, calcular la Desviación Absoluta Media alrededor de la media de este conjunto de datos.  \nLa Desviación Absoluta Media es la diferencia absoluta promedio entre cada elemento y un punto central (la media en este caso):  \nMAD = promedio | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0", "arb": "لحساب الانحراف المطلق المتوسط لقائمة معينة من الأرقام المدخلة حول متوسط هذه المجموعة من البيانات.  \nالانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل عنصر ونقطة مركزية (المتوسط في هذه الحالة):  \nMAD = المتوسط | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0", "sw": "Kwa orodha iliyotolewa ya nambari za pembejeo, hesabu Mkengeuko Wastani wa Kawaida\nkuhusu wastani wa seti hii ya data.\nMkengeuko Wastani wa Kawaida ni tofauti ya wastani ya kawaida kati ya kila\nkipengele na kituo (wastani katika kesi hii):\nMAD = wastani | x - x_mean |\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0", "tr": "Verilen bir sayı listesi için, bu veri kümesinin ortalaması etrafında Ortalama Mutlak Sapma'yı hesaplayın.  \nOrtalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:  \nMAD = ortalama | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0  ", "vi": "Đối với một danh sách các số đầu vào đã cho, tính Độ lệch tuyệt đối trung bình xung quanh giá trị trung bình của tập dữ liệu này.  \nĐộ lệch tuyệt đối trung bình là trung bình của sự khác biệt tuyệt đối giữa mỗi phần tử và một điểm trung tâm (trong trường hợp này là trung bình):  \nMAD = trung bình | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0", "id": "Untuk daftar angka masukan yang diberikan, hitung Deviasi Absolut Rata-rata di sekitar rata-rata dari dataset ini. Deviasi Absolut Rata-rata adalah rata-rata perbedaan absolut antara setiap elemen dan titik pusat (rata-rata dalam kasus ini): MAD = rata-rata | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0", "ja": "与えられた入力数値のリストに対して、このデータセットの平均を中心とした平均絶対偏差を計算します。  \n平均絶対偏差は、各要素と中心点（この場合は平均）との平均絶対差です。  \nMAD = average | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0", "ko": "주어진 입력 숫자 목록에 대해, 이 데이터셋의 평균을 중심으로 한 평균 절대 편차를 계산합니다.\n평균 절대 편차는 각 요소와 중심점(이 경우 평균) 간의 절대 차이의 평균입니다:\nMAD = 평균 | x - x_mean |\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0", "ml": "നൽകിയിരിക്കുന്ന ഇൻപുട്ട് നമ്പറുകളുടെ പട്ടികയ്ക്കായി, ഈ ഡാറ്റാസെറ്റിന്റെ ശരാശരിയിലുമുള്ള ശരാശരി പരമാവധി വ്യതിചലനം കണക്കാക്കുക.  \nശരാശരി പരമാവധി വ്യതിചലനം ഓരോ ഘടകവും ഒരു കേന്ദ്രബിന്ദുവുമായുള്ള ശരാശരി പരമാവധി വ്യത്യാസമാണ് (ഈ കേസിൽ ശരാശരി):  \nMAD = ശരാശരി | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0", "fa": "برای یک لیست داده شده از اعداد ورودی، انحراف مطلق میانگین را در اطراف میانگین این مجموعه داده محاسبه کنید.  \nانحراف مطلق میانگین، میانگین تفاوت مطلق بین هر عنصر و یک نقطه مرکزی (در اینجا میانگین) است:  \nMAD = میانگین | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0  "}}
{"task_id": "Python/6", "prompt": {"en": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    \"\"\"", "sq": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Shton dy numra të plotë së bashku.\n\n    Parametrat:\n    a (int): Numri i parë që do të shtohet.\n    b (int): Numri i dytë që do të shtohet.\n\n    Kthen:\n    int: Shuma e dy numrave.\n    \"\"\"", "hy": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Գումարում է երկու ամբողջ թիվ իրար։\n\n    Պարամետրեր:\n    a (int): Առաջին թիվը, որը պետք է գումարվի։\n    b (int): Երկրորդ թիվը, որը պետք է գումարվի։\n\n    Վերադարձնում է:\n    int: Երկու թվերի գումարը։\n    \"\"\"", "bn": "def add(a: int, b: int) -> int:\n    \"\"\"\n    দুটি পূর্ণসংখ্যা একসাথে যোগ করে।\n\n    প্যারামিটারসমূহ:\n    a (int): যোগ করার জন্য প্রথম সংখ্যা।\n    b (int): যোগ করার জন্য দ্বিতীয় সংখ্যা।\n\n    রিটার্নস:\n    int: দুটি সংখ্যার যোগফল।\n    \"\"\"", "bg": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Събира две цели числа.\n\n    Параметри:\n    a (int): Първото число, което ще бъде събрано.\n    b (int): Второто число, което ще бъде събрано.\n\n    Връща:\n    int: Сумата на двете числа.\n    \"\"\"", "zh": "def add(a: int, b: int) -> int:\n    \"\"\"\n    将两个整数相加。\n\n    参数:\n    a (int): 要相加的第一个数字。\n    b (int): 要相加的第二个数字。\n\n    返回:\n    int: 两个数字的和。\n    \"\"\"", "fr": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Ajoute deux nombres entiers ensemble.\n\n    Paramètres:\n    a (int): Le premier nombre à ajouter.\n    b (int): Le deuxième nombre à ajouter.\n\n    Renvoie:\n    int: La somme des deux nombres.\n    \"\"\"", "de": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Addiert zwei ganze Zahlen miteinander.\n\n    Parameter:\n    a (int): Die erste Zahl, die addiert werden soll.\n    b (int): Die zweite Zahl, die addiert werden soll.\n\n    Rückgabe:\n    int: Die Summe der beiden Zahlen.\n    \"\"\"", "ha": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Ƙara lambobi guda biyu na integer tare.\n\n    Sigogi:\n    a (int): Lamba ta farko da za a ƙara.\n    b (int): Lamba ta biyu da za a ƙara.\n\n    Komawa:\n    int: Jimillar lambobin biyu.\n    \"\"\"", "hi": "def add(a: int, b: int) -> int:\n    \"\"\"\n    दो पूर्णांक संख्याओं को एक साथ जोड़ता है।\n\n    पैरामीटर्स:\n    a (int): पहली संख्या जो जोड़ी जाएगी।\n    b (int): दूसरी संख्या जो जोड़ी जाएगी।\n\n    रिटर्न्स:\n    int: दोनों संख्याओं का योग।\n    \"\"\"", "hu": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Két egész számot ad össze.\n\n    Paraméterek:\n    a (int): Az első szám, amelyet hozzáadunk.\n    b (int): A második szám, amelyet hozzáadunk.\n\n    Visszatérési érték:\n    int: A két szám összege.\n    \"\"\"", "es": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Suma dos números enteros.\n\n    Parámetros:\n    a (int): El primer número a sumar.\n    b (int): El segundo número a sumar.\n\n    Devuelve:\n    int: La suma de los dos números.\n    \"\"\"", "arb": "def add(a: int, b: int) -> int:\n    \"\"\"\n    يجمع عددين صحيحين معًا.\n\n    المعاملات:\n    a (int): الرقم الأول الذي سيتم إضافته.\n    b (int): الرقم الثاني الذي سيتم إضافته.\n\n    يعيد:\n    int: مجموع الرقمين.\n    \"\"\"", "sw": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Huongeza namba mbili za mzima pamoja.\n\n    Vigezo:\n    a (int): Namba ya kwanza ya kuongezwa.\n    b (int): Namba ya pili ya kuongezwa.\n\n    Inarejesha:\n    int: Jumla ya namba hizo mbili.\n    \"\"\"", "tr": "def add(a: int, b: int) -> int:\n    \"\"\"\n    İki tam sayıyı toplar.\n\n    Parametreler:\n    a (int): Toplanacak ilk sayı.\n    b (int): Toplanacak ikinci sayı.\n\n    Döndürür:\n    int: İki sayının toplamı.\n    \"\"\"", "vi": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Cộng hai số nguyên lại với nhau.\n\n    Tham số:\n    a (int): Số thứ nhất để cộng.\n    b (int): Số thứ hai để cộng.\n\n    Trả về:\n    int: Tổng của hai số.\n    \"\"\"", "id": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Menambahkan dua angka integer bersama-sama.\n\n    Parameter:\n    a (int): Angka pertama yang akan ditambahkan.\n    b (int): Angka kedua yang akan ditambahkan.\n\n    Mengembalikan:\n    int: Jumlah dari dua angka tersebut.\n    \"\"\"", "ja": "def add(a: int, b: int) -> int:\n    \"\"\"\n    2つの整数を加算します。\n\n    パラメータ:\n    a (int): 加算される最初の数。\n    b (int): 加算される2番目の数。\n\n    戻り値:\n    int: 2つの数の合計。\n    \"\"\"", "ko": "def add(a: int, b: int) -> int:\n    \"\"\"\n    두 정수 숫자를 더합니다.\n\n    매개변수:\n    a (int): 더할 첫 번째 숫자.\n    b (int): 더할 두 번째 숫자.\n\n    반환값:\n    int: 두 숫자의 합.\n    \"\"\"", "ml": "def add(a: int, b: int) -> int:\n    \"\"\"\n    രണ്ട് പൂർണ്ണസംഖ്യകളെ തമ്മിൽ ചേർക്കുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    a (int): ചേർക്കാനുള്ള ആദ്യ സംഖ്യ.\n    b (int): ചേർക്കാനുള്ള രണ്ടാം സംഖ്യ.\n\n    മടക്കുന്നു:\n    int: രണ്ട് സംഖ്യകളുടെയും മൊത്തം.\n    \"\"\"", "fa": "def add(a: int, b: int) -> int:\n    \"\"\"\n    دو عدد صحیح را با هم جمع می‌کند.\n\n    پارامترها:\n    a (int): عدد اول برای جمع شدن.\n    b (int): عدد دوم برای جمع شدن.\n\n    بازگشت:\n    int: مجموع دو عدد.\n    \"\"\""}, "canonical_solution": "    return a + b", "instruction": {"en": "def add(a: int, b: int) -> int:\n    return a + b\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def add(a: int, b: int) -> int:\n    return a + b\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def add(a: int, b: int) -> int:\n    return a + b\n\nՏվյալ Python կոդի համար տրամադրել կարճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def add(a: int, b: int) -> int:\n    return a + b\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def add(a: int, b: int) -> int:\n    return a + b\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def add(a: int, b: int) -> int:\n    return a + b\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），不超过500个字符。", "fr": "def add(a: int, b: int) -> int:\n    return a + b\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def add(a: int, b: int) -> int:\n    return a + b\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def add(a: int, b: int) -> int:\n    return a + b\n\nBa da wani takaitaccen bayani na yanayi (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def add(a: int, b: int) -> int:\n    return a + b\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में वर्णन (डॉकस्ट्रिंग) हिंदी में करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def add(a: int, b: int) -> int:\n    return a + b\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben.", "es": "def add(a: int, b: int) -> int:\n    return a + b\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español usando como máximo 500 caracteres.", "arb": "def add(a: int, b: int) -> int:\n    return a + b\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def add(a: int, b: int) -> int:\n    return a + b\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def add(a: int, b: int) -> int:\n    return a + b\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def add(a: int, b: int) -> int:\n    return a + b\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt với tối đa 500 ký tự.", "id": "def add(a: int, b: int) -> int:\n    return a + b\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) untuk kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def add(a: int, b: int) -> int:\n    return a + b\n\nPythonコードのdocstringを日本語で簡潔に説明し、最大500文字で記述してください。", "ko": "def add(a: int, b: int) -> int:\n    return a + b\n\n다음 Python 코드의 동작을 설명하는 간결한 자연어 설명(독스트링)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "def add(a: int, b: int) -> int:\n    return a + b\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "def add(a: int, b: int) -> int:\n    return a + b\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "# Test cases:\n# The following lines are not part of the function's implementation but are provided\n# for testing purposes.\n\n# Test case 1: Positive integers\nassert add(2, 3) == 5\n\n# Test case 2: A positive and a negative integer\nassert add(-1, 1) == 0\n\n# Test case 3: Two negative integers\nassert add(-4, -5) == -9\n\n# Test case 4: Zeroes\nassert add(0, 0) == 0\n\n# Test case 5: Large integers\nassert add(123456, 654321) == 777777\n\nprint(\"All test cases passed.\")", "entry_point": "add", "signature": "def add(a: int, b: int) -> int:", "docstring": {"en": "Adds two integer numbers together.\n\nParameters:\na (int): The first number to be added.\nb (int): The second number to be added.\n\nReturns:\nint: The sum of the two numbers.", "sq": "Shton dy numra të plotë së bashku.\n\nParametrat:\na (int): Numri i parë që do të shtohet.\nb (int): Numri i dytë që do të shtohet.\n\nKthen:\nint: Shuma e dy numrave.", "hy": "Երկու ամբողջ թիվ գումարում է իրար։\n\nՊարամետրեր:\na (int): Առաջին թիվը, որը պետք է գումարվի։\nb (int): Երկրորդ թիվը, որը պետք է գումարվի։\n\nՎերադարձնում է:\nint: Երկու թվերի գումարը։", "bn": "দুটি পূর্ণসংখ্যা একসাথে যোগ করে।\n\nপ্যারামিটারসমূহ:\na (int): যোগ করার জন্য প্রথম সংখ্যা।\nb (int): যোগ করার জন্য দ্বিতীয় সংখ্যা।\n\nফেরত দেয়:\nint: দুটি সংখ্যার যোগফল।", "bg": "Събира две цели числа заедно.\n\nПараметри:\na (int): Първото число, което ще бъде събрано.\nb (int): Второто число, което ще бъде събрано.\n\nВръща:\nint: Сумата на двете числа.", "zh": "将两个整数相加。\n\n参数：\na (int): 要相加的第一个数字。\nb (int): 要相加的第二个数字。\n\n返回：\nint: 两个数字的和。", "fr": "Ajoute deux nombres entiers ensemble.\n\nParamètres :\na (int) : Le premier nombre à ajouter.\nb (int) : Le deuxième nombre à ajouter.\n\nRenvoie :\nint : La somme des deux nombres.", "de": "Addiert zwei ganze Zahlen miteinander.\n\nParameter:\na (int): Die erste Zahl, die addiert werden soll.\nb (int): Die zweite Zahl, die addiert werden soll.\n\nRückgabewert:\nint: Die Summe der beiden Zahlen.", "ha": "Ƙara lambobi guda biyu na integer tare.\n\nSigogi:\na (int): Lambar farko da za a kara.\nb (int): Lambar biyu da za a kara.\n\nDawowa:\nint: Jimillar lambobin biyu.", "hi": "दो पूर्णांक संख्याओं को जोड़ता है।\n\nपैरामीटर्स:\na (int): जोड़ने के लिए पहली संख्या।\nb (int): जोड़ने के लिए दूसरी संख्या।\n\nवापसी:\nint: दोनों संख्याओं का योग।", "hu": "Két egész számot ad össze.\n\nParaméterek:\na (int): Az első szám, amelyet hozzáadunk.\nb (int): A második szám, amelyet hozzáadunk.\n\nVisszatér:\nint: A két szám összege.", "es": "Añade dos números enteros juntos.\n\nParámetros:\na (int): El primer número a sumar.\nb (int): El segundo número a sumar.\n\nDevuelve:\nint: La suma de los dos números.", "arb": "يجمع عددين صحيحين معًا.\n\nالمعلمات:\na (int): الرقم الأول الذي سيتم إضافته.\nb (int): الرقم الثاني الذي سيتم إضافته.\n\nالقيم المعادة:\nint: مجموع الرقمين.", "sw": "Huongeza namba mbili za mzima pamoja.\n\nVigezo:\na (int): Namba ya kwanza ya kuongezwa.\nb (int): Namba ya pili ya kuongezwa.\n\nInarejesha:\nint: Jumla ya namba hizo mbili.", "tr": "İki tam sayıyı toplar.\n\nParametreler:\na (int): Toplanacak ilk sayı.\nb (int): Toplanacak ikinci sayı.\n\nDöndürülenler:\nint: İki sayının toplamı.", "vi": "Cộng hai số nguyên với nhau.\n\nTham số:\na (int): Số thứ nhất cần cộng.\nb (int): Số thứ hai cần cộng.\n\nTrả về:\nint: Tổng của hai số.", "id": "Menambahkan dua angka integer bersama-sama.\n\nParameter:\na (int): Angka pertama yang akan ditambahkan.\nb (int): Angka kedua yang akan ditambahkan.\n\nMengembalikan:\nint: Jumlah dari kedua angka tersebut.", "ja": "2つの整数を加算します。\n\nパラメータ:\na (int): 加算される最初の数。\nb (int): 加算される2番目の数。\n\n戻り値:\nint: 2つの数の合計。", "ko": "두 개의 정수를 더합니다.\n\n매개변수:\na (int): 더할 첫 번째 숫자입니다.\nb (int): 더할 두 번째 숫자입니다.\n\n반환값:\nint: 두 숫자의 합입니다.", "ml": "രണ്ട് പൂർണ്ണസംഖ്യകളെ ചേർക്കുന്നു.\n\nപാരാമീറ്ററുകൾ:\na (int): ചേർക്കേണ്ട ആദ്യ സംഖ്യ.\nb (int): ചേർക്കേണ്ട രണ്ടാം സംഖ്യ.\n\nമടക്കം:\nint: ഈ രണ്ട് സംഖ്യകളുടെ ആകെ.", "fa": "دو عدد صحیح را با هم جمع می‌کند.\n\nپارامترها:\na (int): عدد اول برای جمع شدن.\nb (int): عدد دوم برای جمع شدن.\n\nبازگشت:\nint: مجموع دو عدد."}}
{"task_id": "Python/7", "prompt": {"en": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "sq": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Gjen qilimin më të sipërm që mbulon një pikë të dhënë në planin koordinativ.\n\n    Args:\n    n (int): Numri total i qilimave.\n    carpets (list of tuples): Një listë që përmban n tufa, secila përfaqëson informacionin e një qilimi.\n                              Çdo tufë përmban katër numra të plotë (a, b, g, k) ku (a, b) janë\n                              koordinatat e këndit të poshtëm të majtë të qilimit dhe (g, k) janë\n                              gjatësitë e qilimit përgjatë boshtit x dhe y përkatësisht.\n    point (tuple): Një tufë që përmban dy numra të plotë (x, y), koordinatat e pikës për të kontrolluar.\n\n    Returns:\n    int: Numri i qilimit më të sipërm që mbulon pikën (x, y), ose -1 nëse asnjë qilim nuk e mbulon atë.\n\n    Shembuj:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "hy": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Գտնում է տրված կետը ծածկող ամենավերին գորգը կոորդինատային հարթության վրա:\n\n    Արգումենտներ:\n    n (int): Գորգերի ընդհանուր քանակը:\n    carpets (list of tuples): Ցանկ, որը պարունակում է n թյուպլ, յուրաքանչյուրը ներկայացնում է գորգի մասին տեղեկություն:\n                              Յուրաքանչյուր թյուպլ պարունակում է չորս ամբողջ թիվ (a, b, g, k), որտեղ (a, b) \n                              գորգի ներքևի ձախ անկյունի կոորդինատներն են, իսկ (g, k) գորգի երկարություններն են \n                              համապատասխանաբար x և y առանցքների երկայնքով:\n    point (tuple): Թյուպլ, որը պարունակում է երկու ամբողջ թիվ (x, y), կոորդինատները այն կետի, որը պետք է ստուգել:\n\n    Վերադարձնում է:\n    int: Ամենավերին գորգի համարը, որը ծածկում է կետը (x, y), կամ -1, եթե ոչ մի գորգ չի ծածկում այն:\n\n    Օրինակներ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "bn": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    প্রদত্ত বিন্দুতে সমন্বয় সমতলে কোন কার্পেটটি সর্বোচ্চ অবস্থানে রয়েছে তা খুঁজে বের করে।\n\n    Args:\n    n (int): মোট কার্পেটের সংখ্যা।\n    carpets (list of tuples): একটি তালিকা যা n টুপল ধারণ করে, প্রতিটি টুপল একটি কার্পেটের তথ্য উপস্থাপন করে।\n                              প্রতিটি টুপলে চারটি পূর্ণসংখ্যা (a, b, g, k) থাকে যেখানে (a, b) হল\n                              কার্পেটের নিচের-বাম কোণের স্থানাঙ্ক এবং (g, k) হল\n                              x এবং y অক্ষ বরাবর কার্পেটের দৈর্ঘ্য।\n    point (tuple): একটি টুপল যা দুটি পূর্ণসংখ্যা (x, y) ধারণ করে, চেক করার জন্য বিন্দুর স্থানাঙ্ক।\n\n    Returns:\n    int: বিন্দু (x, y) কে আচ্ছাদনকারী সর্বোচ্চ কার্পেটের সংখ্যা, অথবা যদি কোন কার্পেট এটিকে আচ্ছাদন না করে তবে -1।\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "bg": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Намира най-горния килим, покриващ дадена точка в координатната равнина.\n\n    Аргументи:\n    n (int): Общият брой на килимите.\n    carpets (list of tuples): Списък, съдържащ n кортежа, всеки представляващ информация за килим.\n                              Всеки кортеж съдържа четири цели числа (a, b, g, k), където (a, b) са\n                              координатите на долния ляв ъгъл на килима и (g, k) са\n                              дължините на килима по оста x и y съответно.\n    point (tuple): Кортеж, съдържащ две цели числа (x, y), координатите на точката за проверка.\n\n    Връща:\n    int: Номерът на най-горния килим, покриващ точката (x, y), или -1, ако няма килим, който да я покрива.\n\n    Примери:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "zh": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    查找覆盖坐标平面上给定点的最上层地毯。\n\n    参数:\n    n (int): 地毯的总数量。\n    carpets (list of tuples): 包含 n 个元组的列表，每个元组表示一个地毯的信息。\n                              每个元组包含四个整数 (a, b, g, k)，其中 (a, b) 是地毯左下角的坐标，\n                              (g, k) 是地毯在 x 和 y 轴上的长度。\n    point (tuple): 包含两个整数 (x, y) 的元组，要检查的点的坐标。\n\n    返回:\n    int: 覆盖点 (x, y) 的最上层地毯的编号，如果没有地毯覆盖该点，则返回 -1。\n\n    示例:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "fr": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Trouve le tapis le plus haut couvrant un point donné sur le plan de coordonnées.\n\n    Args:\n    n (int): Le nombre total de tapis.\n    carpets (list of tuples): Une liste contenant n tuples, chacun représentant les informations d'un tapis.\n                              Chaque tuple contient quatre entiers (a, b, g, k) où (a, b) sont les\n                              coordonnées du coin inférieur gauche du tapis et (g, k) sont\n                              les longueurs du tapis le long de l'axe x et y respectivement.\n    point (tuple): Un tuple contenant deux entiers (x, y), les coordonnées du point à vérifier.\n\n    Returns:\n    int: Le numéro du tapis le plus haut couvrant le point (x, y), ou -1 si aucun tapis ne le couvre.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "de": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Findet den obersten Teppich, der einen gegebenen Punkt auf der Koordinatenebene bedeckt.\n\n    Args:\n    n (int): Die Gesamtanzahl der Teppiche.\n    carpets (list of tuples): Eine Liste, die n Tupel enthält, von denen jedes die Informationen eines Teppichs darstellt.\n                              Jedes Tupel enthält vier ganze Zahlen (a, b, g, k), wobei (a, b) die\n                              Koordinaten der unteren linken Ecke des Teppichs sind und (g, k) die\n                              Längen des Teppichs entlang der x- und y-Achse sind.\n    point (tuple): Ein Tupel, das zwei ganze Zahlen (x, y) enthält, die Koordinaten des zu überprüfenden Punktes.\n\n    Returns:\n    int: Die Nummer des obersten Teppichs, der den Punkt (x, y) bedeckt, oder -1, wenn kein Teppich ihn bedeckt.\n\n    Beispiele:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "ha": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Nemi tabarma mafi sama da ke rufe wani maki a kan tsarin daidaitawa.\n\n    Args:\n    n (int): Jimillar adadin tabarmai.\n    carpets (list of tuples): Jerin da ke dauke da n tuples, kowanne yana wakiltar bayanin tabarma.\n                              Kowanne tuple yana dauke da lambobi hudu (a, b, g, k) inda (a, b) suke\n                              daidaitawar kusurwar kasa-hagu na tabarma kuma (g, k) su ne\n                              tsawon tabarma a kan x da y axis bi da bi.\n    point (tuple): Tuple da ke dauke da lambobi biyu (x, y), daidaitawar maki da za a duba.\n\n    Returns:\n    int: Lambar tabarma mafi sama da ke rufe maki (x, y), ko -1 idan babu tabarma da ta rufe shi.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "hi": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    दिए गए बिंदु पर समन्वय तल पर कवर करने वाले सबसे ऊपरी कालीन को खोजता है।\n\n    Args:\n    n (int): कुल कालीनों की संख्या।\n    carpets (list of tuples): एक सूची जिसमें n ट्यूपल होते हैं, प्रत्येक एक कालीन की जानकारी का प्रतिनिधित्व करता है।\n                              प्रत्येक ट्यूपल में चार पूर्णांक (a, b, g, k) होते हैं जहाँ (a, b)\n                              कालीन के निचले-बाएँ कोने के समन्वय होते हैं और (g, k) क्रमशः x और y अक्ष पर\n                              कालीन की लंबाई होती है।\n    point (tuple): एक ट्यूपल जिसमें दो पूर्णांक (x, y) होते हैं, जाँचने के लिए बिंदु के समन्वय।\n\n    Returns:\n    int: सबसे ऊपरी कालीन की संख्या जो बिंदु (x, y) को कवर करता है, या -1 यदि कोई कालीन इसे कवर नहीं करता।\n\n    उदाहरण:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "hu": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Megkeresi a koordináta síkon egy adott pontot lefedő legfelső szőnyeget.\n\n    Args:\n    n (int): A szőnyegek teljes száma.\n    carpets (list of tuples): Egy lista, amely n darab tuple-t tartalmaz, mindegyik egy szőnyeg információit képviseli.\n                              Minden tuple négy egész számot tartalmaz (a, b, g, k), ahol (a, b) a\n                              szőnyeg bal alsó sarkának koordinátái, és (g, k) a szőnyeg hossza az x és y tengely mentén.\n    point (tuple): Egy tuple, amely két egész számot tartalmaz (x, y), a vizsgálandó pont koordinátái.\n\n    Returns:\n    int: Annak a legfelső szőnyegnek a száma, amely lefedi az (x, y) pontot, vagy -1, ha egyetlen szőnyeg sem fedi le.\n\n    Példák:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "es": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Encuentra la alfombra más alta que cubre un punto dado en el plano de coordenadas.\n\n    Argümanlar:\n    n (int): El número total de alfombras.\n    carpets (list of tuples): Una lista que contiene n tuplas, cada una representando la información de una alfombra.\n                              Cada tupla contiene cuatro enteros (a, b, g, k) donde (a, b) son las\n                              coordenadas de la esquina inferior izquierda de la alfombra y (g, k) son\n                              las longitudes de la alfombra a lo largo del eje x y y respectivamente.\n    point (tuple): Una tupla que contiene dos enteros (x, y), las coordenadas del punto a verificar.\n\n    Devuelve:\n    int: El número de la alfombra más alta que cubre el punto (x, y), o -1 si ninguna alfombra lo cubre.\n\n    Ejemplos:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "arb": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    يجد السجادة العلوية التي تغطي نقطة معينة على مستوى الإحداثيات.\n\n    يعيدالحجج:\n    n (int): العدد الإجمالي للسجاد.\n    carpets (list of tuples): قائمة تحتوي على n من الأزواج، كل منها يمثل معلومات السجادة.\n                              يحتوي كل زوج على أربعة أعداد صحيحة (a, b, g, k) حيث (a, b) هي\n                              إحداثيات الزاوية السفلية اليسرى للسجادة و (g, k) هي\n                              أطوال السجادة على المحور السيني والصادي على التوالي.\n    point (tuple): زوج يحتوي على عددين صحيحين (x, y)، إحداثيات النقطة المراد التحقق منها.\n\n    يعيد:\n    int: رقم السجادة العلوية التي تغطي النقطة (x, y)، أو -1 إذا لم تغطيها أي سجادة.\n\n    امثله:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "sw": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Inapata zulia la juu zaidi linalofunika nukta fulani kwenye ndege ya kuratibu.\n\n    Hoja:\n    n (int): Jumla ya idadi ya mazulia.\n    carpets (list of tuples): Orodha inayojumuisha n tuples, kila moja ikiwakilisha taarifa ya zulia.\n                              Kila tuple ina integer nne (a, b, g, k) ambapo (a, b) ni\n                              kuratibu za kona ya chini-kushoto ya zulia na (g, k) ni\n                              urefu wa zulia kando ya mhimili wa x na y mtawalia.\n    point (tuple): Tuple inayojumuisha integer mbili (x, y), kuratibu za nukta ya kukagua.\n\n    Inarejesha:\n    int: Nambari ya zulia la juu zaidi linalofunika nukta (x, y), au -1 ikiwa hakuna zulia linaloifunika.\n\n    Mifano:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "tr": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Koordinat düzleminde verilen bir noktayı kaplayan en üstteki halıyı bulur.\n\n    Argümanlar:\n    n (int): Toplam halı sayısı.\n    carpets (list of tuples): Her biri bir halının bilgisini temsil eden n adet demet içeren bir liste.\n                              Her demet dört tamsayı (a, b, g, k) içerir, burada (a, b) halının\n                              sol alt köşesinin koordinatlarıdır ve (g, k) halının x ve y ekseni\n                              boyunca olan uzunluklarıdır.\n    point (tuple): Kontrol edilecek noktanın koordinatlarını içeren iki tamsayıdan oluşan bir demet (x, y).\n\n    Döndürür:\n    int: Nokta (x, y) üzerindeki en üstteki halının numarası veya hiçbir halı kaplamıyorsa -1.\n\n    Örnekler:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "vi": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Tìm tấm thảm trên cùng phủ lên một điểm cho trước trên mặt phẳng tọa độ.\n\n    Tham số:\n    n (int): Tổng số lượng thảm.\n    carpets (list of tuples): Một danh sách chứa n bộ giá trị, mỗi bộ đại diện cho thông tin của một tấm thảm.\n                              Mỗi bộ chứa bốn số nguyên (a, b, g, k) trong đó (a, b) là tọa độ của góc dưới bên trái\n                              của tấm thảm và (g, k) là chiều dài của tấm thảm theo trục x và y tương ứng.\n    point (tuple): Một bộ chứa hai số nguyên (x, y), tọa độ của điểm cần kiểm tra.\n\n    Trả về:\n    int: Số của tấm thảm trên cùng phủ lên điểm (x, y), hoặc -1 nếu không có tấm thảm nào phủ lên.\n\n    Ví dụ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "id": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Menemukan karpet paling atas yang menutupi titik tertentu pada bidang koordinat.\n\n    Argumen:\n    n (int): Jumlah total karpet.\n    carpets (list of tuples): Daftar yang berisi n tuple, masing-masing mewakili informasi karpet.\n                              Setiap tuple berisi empat bilangan bulat (a, b, g, k) di mana (a, b) adalah\n                              koordinat sudut kiri bawah karpet dan (g, k) adalah\n                              panjang karpet sepanjang sumbu x dan y masing-masing.\n    point (tuple): Sebuah tuple yang berisi dua bilangan bulat (x, y), koordinat titik yang akan diperiksa.\n\n    Mengembalikan:\n    int: Nomor karpet paling atas yang menutupi titik (x, y), atau -1 jika tidak ada karpet yang menutupinya.\n\n    Contoh:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "ja": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    座標平面上の指定された点を覆う最上のカーペットを見つけます。\n\n    引数:\n    n (int): カーペットの総数。\n    carpets (list of tuples): 各カーペットの情報を表すn個のタプルを含むリスト。\n                              各タプルは4つの整数 (a, b, g, k) を含み、(a, b) はカーペットの左下隅の座標、\n                              (g, k) はそれぞれx軸とy軸に沿ったカーペットの長さです。\n    point (tuple): チェックする点の座標を含む2つの整数 (x, y) のタプル。\n\n    戻り値:\n    int: 点 (x, y) を覆う最上のカーペットの番号、またはカーペットがない場合は -1。\n\n    例:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "ko": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    주어진 좌표 평면의 점을 덮고 있는 가장 위에 있는 카펫을 찾습니다.\n\n    Args:\n    n (int): 카펫의 총 개수.\n    carpets (list of tuples): 각 카펫의 정보를 나타내는 n개의 튜플을 포함하는 리스트.\n                              각 튜플은 네 개의 정수 (a, b, g, k)로 구성되며, (a, b)는\n                              카펫의 왼쪽 아래 모서리의 좌표이고, (g, k)는 각각 x축과 y축을 따라\n                              카펫의 길이입니다.\n    point (tuple): 확인할 점의 좌표인 두 개의 정수 (x, y)를 포함하는 튜플.\n\n    Returns:\n    int: 점 (x, y)를 덮고 있는 가장 위에 있는 카펫의 번호, 또는 어떤 카펫도 덮고 있지 않으면 -1.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "ml": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    കൊഓർഡിനേറ്റ് പ്ലെയിനിലെ ഒരു നിർദ്ദിഷ്ട ബിന്ദുവിൽ മുകളിൽ ഉള്ള കർപ്പറ്റ് കണ്ടെത്തുന്നു.\n\n    Args:\n    n (int): കർപ്പറ്റുകളുടെ ആകെ എണ്ണം.\n    carpets (list of tuples): ഓരോ കർപ്പറ്റിന്റെയും വിവരങ്ങൾ പ്രതിനിധീകരിക്കുന്ന n ട്യൂപ്പിളുകൾ അടങ്ങിയ ഒരു പട്ടിക.\n                              ഓരോ ട്യൂപ്പിളിലും നാല് ഇന്റീജറുകൾ (a, b, g, k) അടങ്ങിയിരിക്കും, ഇവിടെ (a, b) ആണ്\n                              കർപ്പറ്റിന്റെ താഴത്തെ ഇടത് കോണിന്റെ കൊഓർഡിനേറ്റുകൾ, (g, k) യഥാക്രമം x, y അക്ഷങ്ങളിലായുള്ള\n                              കർപ്പറ്റിന്റെ നീളങ്ങളാണ്.\n    point (tuple): പരിശോധിക്കേണ്ട ബിന്ദുവിന്റെ കൊഓർഡിനേറ്റുകൾ അടങ്ങിയ രണ്ട് ഇന്റീജറുകൾ (x, y) അടങ്ങിയ ഒരു ട്യൂപ്പിൾ.\n\n    Returns:\n    int: ബിന്ദു (x, y) മൂടുന്ന മുകളിൽ ഉള്ള കർപ്പറ്റിന്റെ നമ്പർ, അല്ലെങ്കിൽ ഒരു കർപ്പറ്റും മൂടുന്നില്ലെങ്കിൽ -1.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "fa": "python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    بالاترین فرش پوشاننده یک نقطه خاص در صفحه مختصات را پیدا می‌کند.\n\n    Args:\n    n (int): تعداد کل فرش‌ها.\n    carpets (list of tuples): لیستی شامل n تاپل، که هر کدام اطلاعات یک فرش را نشان می‌دهد.\n                              هر تاپل شامل چهار عدد صحیح (a, b, g, k) است که (a, b) مختصات\n                              گوشه پایین-چپ فرش و (g, k) طول‌های فرش در امتداد محورهای x و y\n                              به ترتیب هستند.\n    point (tuple): یک تاپل شامل دو عدد صحیح (x, y)، مختصات نقطه‌ای که باید بررسی شود.\n\n    Returns:\n    int: شماره بالاترین فرش پوشاننده نقطه (x, y)، یا -1 اگر هیچ فرشی آن را نپوشاند.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"\n"}, "canonical_solution": "    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point", "instruction": {"en": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nԱպահովեք հակիրճ բնութագրություն (docstring) Python կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nBada takaitaccen bayanin harshen halitta (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.", "vi": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\n最大 500 文字を使用して、英語で Python コードの簡潔な自然言語説明 (docstring) を提供します。", "ko": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 작성하되 최대 500자 이내로 작성하세요.", "ml": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nപൈതൺ കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def check_find_topmost_carpet():\n    # Test case 1: Point is on topmost carpet (carpet 3)\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2)) == 3\n\n    # Test case 2: Point is not covered by any carpet\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5)) == -1\n\n    # Test case 3: Point is on the edge of the carpet (carpet 1)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (4, 1)) == 1\n\n    # Test case 4: Point is at the corner of the carpet (carpet 2)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (6, 4)) == 2\n\n    # Test case 5: Multiple carpets cover the point, but the last one is on top (carpet 4)\n    assert find_topmost_carpet(4, [(0, 0, 5, 5), (1, 1, 5, 5), (2, 2, 5, 5), (3, 3, 5, 5)], (4, 4)) == 4\n\n    # Test case 6: No carpets at all, should return -1\n    assert find_topmost_carpet(0, [], (0, 0)) == -1\n\n    # Test case 8: Point is covered by the first carpet and no others (carpet 1)\n    assert find_topmost_carpet(3, [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)], (1, 1)) == 1\n\n    print(\"All test cases passed!\")\n\n\n# Run the test cases to ensure the function works as expected\ncheck_find_topmost_carpet()", "entry_point": "find_topmost_carpet", "signature": "def find_topmost_carpet(n, carpets, point) -> int:", "docstring": {"en": "Finds the topmost carpet covering a given point on the coordinate plane.\n\nArgs:\nn (int): The total number of carpets.\ncarpets (list of tuples): A list containing n tuples, each representing a carpet's information.\nEach tuple contains four integers (a, b, g, k) where (a, b) is the\ncoordinates of the bottom-left corner of the carpet and (g, k) are\nthe lengths of the carpet along the x and y axis respectively.\npoint (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\nReturns:\nint: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "sq": "Gjen qilimin më të sipërm që mbulon një pikë të dhënë në planin e koordinatave.\n\nArgumentet:\nn (int): Numri total i qilimave.\ncarpets (list of tuples): Një listë që përmban n tufa, secila që përfaqëson informacionin e një qilimi.\nÇdo tufë përmban katër numra të plotë (a, b, g, k) ku (a, b) janë\nkoordinatat e këndit të poshtëm të majtë të qilimit dhe (g, k) janë\ngjatësitë e qilimit përgjatë boshtit x dhe y përkatësisht.\npoint (tuple): Një tufë që përmban dy numra të plotë (x, y), koordinatat e pikës për të kontrolluar.\n\nKthen:\nint: Numri i qilimit më të sipërm që mbulon pikën (x, y), ose -1 nëse asnjë qilim nuk e mbulon atë.\n\nShembuj:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "hy": "Գտնում է տրված կետի վրա գտնվող ամենավերին գորգը կոորդինատների հարթության վրա:\n\nԱրգումենտներ:\nn (int): Գորգերի ընդհանուր քանակը:\ncarpets (ցանկ տուփլերի): Ցանկ, որը պարունակում է n տուփլեր, որոնցից յուրաքանչյուրը ներկայացնում է գորգի մասին տեղեկատվությունը:\nՅուրաքանչյուր տուփլ պարունակում է չորս ամբողջ թիվ (a, b, g, k), որտեղ (a, b) գորգի ձախ-ստորին անկյունի կոորդինատներն են, իսկ (g, k) գորգի երկարություններն են x և y առանցքների երկայնքով:\npoint (տուփլ): Տուփլ, որը պարունակում է երկու ամբողջ թիվ (x, y), կոորդինատները կետի, որը պետք է ստուգել:\n\nՎերադարձնում է:\nint: Ամենավերին գորգի համարը, որը ծածկում է կետը (x, y), կամ -1, եթե ոչ մի գորգ չի ծածկում այն:\n\nՕրինակներ:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "bn": "একটি নির্দিষ্ট বিন্দুতে সমন্বয় সমতলে আবৃত শীর্ষস্থানীয় কার্পেট খুঁজে বের করে।\n\nআর্গস:\nn (int): মোট কার্পেটের সংখ্যা।\ncarpets (list of tuples): একটি তালিকা যা n টুপল ধারণ করে, প্রতিটি টুপল একটি কার্পেটের তথ্য উপস্থাপন করে।\nপ্রতিটি টুপলে চারটি পূর্ণসংখ্যা (a, b, g, k) থাকে যেখানে (a, b) হল\nকার্পেটের নিচের-বাম কোণের স্থানাঙ্ক এবং (g, k) হল\nx এবং y অক্ষ বরাবর কার্পেটের দৈর্ঘ্য।\npoint (tuple): একটি টুপল যা দুটি পূর্ণসংখ্যা (x, y) ধারণ করে, যাচাই করার বিন্দুর স্থানাঙ্ক।\n\nরিটার্নস:\nint: বিন্দু (x, y) আবৃত শীর্ষস্থানীয় কার্পেটের সংখ্যা, অথবা -1 যদি কোনো কার্পেট এটি আবৃত না করে।\n\nউদাহরণ:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "bg": "Намира най-горния килим, покриващ дадена точка на координатната равнина.\n\nАргументи:\nn (int): Общият брой на килимите.\ncarpets (списък от кортежи): Списък, съдържащ n кортежа, всеки представляващ информация за килим.\nВсеки кортеж съдържа четири цели числа (a, b, g, k), където (a, b) са\nкоординатите на долния ляв ъгъл на килима и (g, k) са\nдължините на килима по оста x и y съответно.\npoint (кортеж): Кортеж, съдържащ две цели числа (x, y), координатите на точката за проверка.\n\nВръща:\nint: Номера на най-горния килим, покриващ точката (x, y), или -1 ако няма килим, който да я покрива.\n\nПримери:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "zh": "在坐标平面上找到覆盖给定点的最上层地毯。\n\n参数：\nn (int): 地毯的总数量。\ncarpets (list of tuples): 包含 n 个元组的列表，每个元组代表一个地毯的信息。\n每个元组包含四个整数 (a, b, g, k)，其中 (a, b) 是地毯左下角的坐标，(g, k) 是地毯在 x 和 y 轴上的长度。\npoint (tuple): 一个包含两个整数 (x, y) 的元组，要检查的点的坐标。\n\n返回：\nint: 覆盖点 (x, y) 的最上层地毯的编号，如果没有地毯覆盖该点，则返回 -1。\n\n示例：\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "fr": "Trouve le tapis le plus haut couvrant un point donné sur le plan de coordonnées.\n\nArgs:\nn (int): Le nombre total de tapis.\ncarpets (list of tuples): Une liste contenant n tuples, chacun représentant les informations d'un tapis.\nChaque tuple contient quatre entiers (a, b, g, k) où (a, b) sont les\ncoordonnées du coin inférieur gauche du tapis et (g, k) sont\nles longueurs du tapis le long de l'axe x et y respectivement.\npoint (tuple): Un tuple contenant deux entiers (x, y), les coordonnées du point à vérifier.\n\nReturns:\nint: Le numéro du tapis le plus haut couvrant le point (x, y), ou -1 si aucun tapis ne le couvre.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "de": "Findet den obersten Teppich, der einen gegebenen Punkt auf der Koordinatenebene bedeckt.\n\nArgs:\nn (int): Die Gesamtanzahl der Teppiche.\ncarpets (list of tuples): Eine Liste, die n Tupel enthält, von denen jedes die Informationen eines Teppichs darstellt.\nJedes Tupel enthält vier ganze Zahlen (a, b, g, k), wobei (a, b) die\nKoordinaten der unteren linken Ecke des Teppichs sind und (g, k) die\nLängen des Teppichs entlang der x- und y-Achse sind.\npoint (tuple): Ein Tupel, das zwei ganze Zahlen (x, y) enthält, die Koordinaten des zu überprüfenden Punktes.\n\nReturns:\nint: Die Nummer des obersten Teppichs, der den Punkt (x, y) bedeckt, oder -1, wenn kein Teppich ihn bedeckt.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "ha": "Nemi tabarma mafi sama da ke rufe wani maki a kan tsarin daidaitawa.\n\nArgs:\nn (int): Jimillar adadin kafet.\ncarpets (list of tuples): Jerin da ke dauke da n tuples, kowanne yana wakiltar bayanin kafet.\nKowane tuple yana dauke da lambobi hudu (a, b, g, k) inda (a, b) suke\ndaidaitawar kusurwar kasa-hagu na kafet kuma (g, k) sune\ntsawon kafet a kan x da y axis bi da bi.\npoint (tuple): Tuple da ke dauke da lambobi biyu (x, y), daidaitawar wurin da za a duba.\n\nReturns:\nint: Lambar kafet mafi sama da ke rufe wurin (x, y), ko -1 idan babu kafet da ke rufe shi.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "hi": "दिए गए बिंदु पर निर्देशांक तल पर सबसे ऊपर की कालीन को ढूंढता है।\n\nआर्ग्स:\nn (int): कालीनों की कुल संख्या।\ncarpets (list of tuples): n ट्यूपल्स की एक सूची, जिसमें प्रत्येक ट्यूपल एक कालीन की जानकारी का प्रतिनिधित्व करता है।\nप्रत्येक ट्यूपल में चार पूर्णांक (a, b, g, k) होते हैं जहाँ (a, b)\nकालीन के निचले-बाएँ कोने के निर्देशांक हैं और (g, k) क्रमशः x और y अक्ष के साथ कालीन की लंबाई है।\npoint (tuple): एक ट्यूपल जिसमें दो पूर्णांक (x, y) होते हैं, जाँचने के लिए बिंदु के निर्देशांक।\n\nवापसी:\nint: सबसे ऊपर की कालीन की संख्या जो बिंदु (x, y) को ढकती है, या -1 यदि कोई कालीन इसे नहीं ढकती।\n\nउदाहरण:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "hu": "Megkeresi a legfelső szőnyeget, amely lefedi a megadott pontot a koordináta síkon.\n\nArgs:\nn (int): A szőnyegek teljes száma.\ncarpets (list of tuples): Egy lista, amely n darab tuple-t tartalmaz, mindegyik egy szőnyeg információit képviseli.\nMinden tuple négy egész számot tartalmaz (a, b, g, k), ahol (a, b) a szőnyeg bal alsó sarkának\nkoordinátái, és (g, k) a szőnyeg hosszai az x és y tengely mentén.\npoint (tuple): Egy tuple, amely két egész számot tartalmaz (x, y), a pont koordinátái, amelyet ellenőrizni kell.\n\nReturns:\nint: A legfelső szőnyeg száma, amely lefedi a pontot (x, y), vagy -1, ha egyetlen szőnyeg sem fedi le.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "es": "Encuentra la alfombra más superior que cubre un punto dado en el plano de coordenadas.\n\nArgumentos:\nn (int): El número total de alfombras.\ncarpets (list of tuples): Una lista que contiene n tuplas, cada una representando la información de una alfombra.\nCada tupla contiene cuatro enteros (a, b, g, k) donde (a, b) son las\ncoordenadas de la esquina inferior izquierda de la alfombra y (g, k) son\nlas longitudes de la alfombra a lo largo del eje x y y respectivamente.\npoint (tuple): Una tupla que contiene dos enteros (x, y), las coordenadas del punto a verificar.\n\nDevuelve:\nint: El número de la alfombra más superior que cubre el punto (x, y), o -1 si ninguna alfombra lo cubre.\n\nEjemplos:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "arb": "يجد السجادة العليا التي تغطي نقطة معينة على مستوى الإحداثيات.\n\nالمعطيات:\nn (int): العدد الإجمالي للسجاد.\ncarpets (list of tuples): قائمة تحتوي على n من الأزواج المرتبة، كل منها يمثل معلومات عن سجادة.\nكل زوج يحتوي على أربعة أعداد صحيحة (a, b, g, k) حيث (a, b) هي\nإحداثيات الزاوية السفلى اليسرى للسجادة و(g, k) هي\nأطوال السجادة على طول محور x و y على التوالي.\npoint (tuple): زوج مرتب يحتوي على عددين صحيحين (x, y)، إحداثيات النقطة المراد التحقق منها.\n\nالقيم المعادة:\nint: رقم السجادة العليا التي تغطي النقطة (x, y)، أو -1 إذا لم تغطيها أي سجادة.\n\nأمثلة:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "sw": "Inapata zulia la juu zaidi linalofunika nukta fulani kwenye ndege ya kuratibu.\n\nHoja:\nn (int): Jumla ya idadi ya mazulia.\ncarpets (orodha ya jozi): Orodha inayo na jozi n, kila moja ikiwakilisha taarifa ya zulia.\nKila jozi ina namba nne za mzima (a, b, g, k) ambapo (a, b) ni\nkuratibu za kona ya chini-kushoto ya zulia na (g, k) ni\nurefu wa zulia kando ya mhimili x na y mtawalia.\npoint (jozi): Jozi inayo na namba mbili za mzima (x, y), kuratibu za nukta ya kukagua.\n\nInarejesha:\nint: Nambari ya zulia la juu zaidi linalofunika nukta (x, y), au -1 ikiwa hakuna zulia linalofunika.\n\nMifano:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "tr": "Verilen bir noktayı koordinat düzleminde örten en üstteki halıyı bulur.\n\nArgümanlar:\nn (int): Toplam halı sayısı.\ncarpets (list of tuples): Her biri bir halının bilgilerini temsil eden n adet demet içeren bir liste.\nHer demet dört tamsayı (a, b, g, k) içerir, burada (a, b)\nhalının sol alt köşesinin koordinatlarıdır ve (g, k)\nhalının x ve y eksenleri boyunca olan uzunluklarıdır.\npoint (tuple): İki tamsayı (x, y) içeren bir demet, kontrol edilecek noktanın koordinatları.\n\nDöndürür:\nint: Nokta (x, y)'yi örten en üstteki halının numarası veya hiçbir halı örtmüyorsa -1.\n\nÖrnekler:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "vi": "Tìm tấm thảm trên cùng phủ một điểm nhất định trên mặt phẳng tọa độ.\n\nTham số:\nn (int): Tổng số thảm.\ncarpets (list of tuples): Một danh sách chứa n bộ giá trị, mỗi bộ đại diện cho thông tin của một tấm thảm.\nMỗi bộ chứa bốn số nguyên (a, b, g, k) trong đó (a, b) là tọa độ của góc dưới bên trái của tấm thảm và (g, k) là\nchiều dài của tấm thảm theo trục x và y tương ứng.\npoint (tuple): Một bộ chứa hai số nguyên (x, y), tọa độ của điểm cần kiểm tra.\n\nTrả về:\nint: Số của tấm thảm trên cùng phủ điểm (x, y), hoặc -1 nếu không có tấm thảm nào phủ nó.\n\nVí dụ:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "id": "Menemukan karpet teratas yang menutupi titik tertentu pada bidang koordinat.\n\nArgumen:\nn (int): Jumlah total karpet.\ncarpets (list of tuples): Daftar yang berisi n tuple, masing-masing mewakili informasi karpet.\nSetiap tuple berisi empat bilangan bulat (a, b, g, k) di mana (a, b) adalah\nkoordinat sudut kiri bawah karpet dan (g, k) adalah\npanjang karpet sepanjang sumbu x dan y masing-masing.\npoint (tuple): Sebuah tuple yang berisi dua bilangan bulat (x, y), koordinat titik yang akan diperiksa.\n\nMengembalikan:\nint: Nomor karpet teratas yang menutupi titik (x, y), atau -1 jika tidak ada karpet yang menutupinya.\n\nContoh:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "ja": "指定された座標平面上の点を覆う最上位のカーペットを見つけます。\n\n引数:\nn (int): カーペットの総数。\ncarpets (list of tuples): 各カーペットの情報を表すn個のタプルを含むリスト。\n各タプルは4つの整数 (a, b, g, k) を含み、(a, b) はカーペットの左下隅の座標であり、\n(g, k) はそれぞれx軸とy軸に沿ったカーペットの長さです。\npoint (tuple): 2つの整数 (x, y) を含むタプルで、チェックする点の座標です。\n\n戻り値:\nint: 点 (x, y) を覆う最上位のカーペットの番号、またはカーペットがない場合は -1。\n\n例:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "ko": "주어진 좌표 평면의 점을 덮고 있는 가장 위쪽의 카펫을 찾습니다.\n\n인수:\nn (int): 카펫의 총 개수.\ncarpets (list of tuples): 각 카펫의 정보를 나타내는 n개의 튜플을 포함하는 리스트.\n각 튜플은 네 개의 정수 (a, b, g, k)를 포함하며, 여기서 (a, b)는\n카펫의 왼쪽 아래 모서리의 좌표이고 (g, k)는\nx축과 y축을 따라 카펫의 길이입니다.\npoint (tuple): 확인할 점의 좌표인 두 개의 정수 (x, y)를 포함하는 튜플.\n\n반환:\nint: 점 (x, y)를 덮고 있는 가장 위쪽의 카펫 번호, 또는 어떤 카펫도 덮고 있지 않으면 -1.\n\n예제:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "ml": "ഒരു കൊഓർഡിനേറ്റ് പ്ലെയിനിൽ നൽകിയ ഒരു ബിന്ദുവിൽ മുകളിൽ മൂടുന്ന പായയെ കണ്ടെത്തുന്നു.\n\nആർഗ്സ്:\nn (int): പായകളുടെ ആകെ എണ്ണം.\ncarpets (list of tuples): ഓരോ പായയുടെ വിവരങ്ങൾ പ്രതിനിധീകരിക്കുന്ന n ട്യൂപ്പിളുകൾ അടങ്ങിയ ഒരു പട്ടിക.\nഓരോ ട്യൂപ്പിളും നാല് പൂർണ്ണസംഖ്യകൾ (a, b, g, k) ഉൾക്കൊള്ളുന്നു, ഇവിടെ (a, b) ആണ് പായയുടെ ഇടത്-താഴത്തെ കോണിന്റെ\nകൊഓർഡിനേറ്റുകൾ, (g, k) യഥാക്രമം x, y അക്ഷങ്ങളിലായി പായയുടെ നീളങ്ങളാണ്.\npoint (tuple): പരിശോധിക്കേണ്ട ബിന്ദുവിന്റെ കൊഓർഡിനേറ്റുകൾ ആയ രണ്ട് പൂർണ്ണസംഖ്യകൾ (x, y) അടങ്ങിയ ഒരു ട്യൂപ്പിൾ.\n\nമടക്കം:\nint: ബിന്ദു (x, y) മൂടുന്ന മുകളിൽ പായയുടെ നമ്പർ, അല്ലെങ്കിൽ ഒരു പായയും മൂടുന്നില്ലെങ്കിൽ -1.\n\nഉദാഹരണങ്ങൾ:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "fa": "پیدا کردن فرش بالایی که نقطه‌ای مشخص روی صفحه مختصات را پوشش می‌دهد.\n\nآرگومان‌ها:\nn (int): تعداد کل فرش‌ها.\ncarpets (list of tuples): لیستی شامل n تاپل که هر کدام اطلاعات یک فرش را نشان می‌دهند.\nهر تاپل شامل چهار عدد صحیح (a, b, g, k) است که در آن (a, b) مختصات گوشه پایین-چپ فرش و (g, k) طول‌های فرش در امتداد محور x و y به ترتیب هستند.\npoint (tuple): یک تاپل شامل دو عدد صحیح (x, y)، مختصات نقطه‌ای که باید بررسی شود.\n\nبازگشت:\nint: شماره فرش بالایی که نقطه (x, y) را پوشش می‌دهد، یا -1 اگر هیچ فرشی آن را پوشش ندهد.\n\nمثال‌ها:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1"}}
{"task_id": "Python/8", "prompt": {"en": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "sq": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Llogarit shumën maksimale të vlerave të mbledhura në dy shtigje në një rrjetë N x N.\n\n    Kjo funksion përdor programimin dinamik për të gjetur dy shtigje nga këndi i sipërm i majtë\n    deri në këndin e poshtëm të djathtë të rrjetës që maksimizojnë shumën e vlerave të mbledhura. \n    Çdo vlerë mund të mblidhet maksimumi një herë, edhe nëse të dy shtigjet kalojnë përmes saj.\n\n    Argumentet:\n    - N (int): Madhësia e rrjetës (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Një listë tuples ku çdo tuple përmban\n      koordinatën x, koordinatën y, dhe vlerën që do të vendoset në rrjetë në atë pozicion.\n      Lista përfundon me një tuple me të gjitha zerot.\n\n    Kthen:\n    - int: Shuma maksimale e vlerave të mbledhura në dy shtigjet.\n\n    Shembuj:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "hy": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Հաշվել արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիներով N x N ցանցում:\n\n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ գտնելու համար երկու ուղիներ ցանցի վերին ձախ անկյունից\n    ցանցի ներքևի աջ անկյուն, որոնք առավելագույնացնում են հավաքված արժեքների գումարը: Յուրաքանչյուր\n    արժեք կարող է հավաքվել առավելագույնը մեկ անգամ, նույնիսկ եթե երկու ուղիներն անցնում են դրա միջով:\n\n    Արգումենտներ:\n    - N (int): Ցանցի չափը (N x N):\n    - grid_values (List[Tuple[int, int, int]]): Կոորդինատների և արժեքների ցուցակ, որտեղ յուրաքանչյուր տուփ\n      պարունակում է x-կոորդինատը, y-կոորդինատը և արժեքը, որը պետք է տեղադրվի ցանցում այդ դիրքում:\n      Ցուցակը ավարտվում է զրոներով տուփով:\n\n    Վերադարձնում է:\n    - int: Երկու ուղիներով հավաքված արժեքների առավելագույն գումարը:\n\n    Օրինակներ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "bn": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    একটি N x N গ্রিডে দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল গণনা করুন।\n\n    এই ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে গ্রিডের উপরের-বাম কোণ থেকে\n    নীচের-ডান কোণে দুটি পথ খুঁজে বের করে যা সংগৃহীত মানগুলির যোগফল সর্বাধিক করে। প্রতিটি\n    মান সর্বাধিক একবার সংগৃহীত হতে পারে, এমনকি যদি উভয় পথ এর মধ্য দিয়ে যায়।\n\n    আর্গুমেন্টসমূহ:\n    - N (int): গ্রিডের আকার (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপলে\n      গ্রিডের নির্দিষ্ট স্থানে স্থাপন করার জন্য x-সমন্বয়, y-সমন্বয় এবং মান থাকে।\n      তালিকাটি সব শূন্য সহ একটি টুপল দ্বারা শেষ হয়।\n\n    রিটার্নস:\n    - int: দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল।\n\n    উদাহরণসমূহ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "bg": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Изчислете максималната сума от стойности, събрани по два пътя в мрежа N x N.\n\n    Тази функция използва динамично програмиране, за да намери два пътя от горния ляв ъгъл до\n    долния десен ъгъл на мрежата, които максимизират сумата на събраните стойности. Всяка\n    стойност може да бъде събрана най-много веднъж, дори ако и двата пътя минават през нея.\n\n    Аргументи:\n    - N (int): Размерът на мрежата (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Списък от кортежи, където всеки кортеж съдържа\n      x-координата, y-координата и стойност, която да бъде поставена на мрежата на тази позиция.\n      Списъкът се завършва с кортеж с всички нули.\n\n    Връща:\n    - int: Максималната сума от стойности, събрани по двата пътя.\n\n    Примери:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "zh": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    计算在 N x N 网格上收集的两个路径的最大值总和。\n\n    此函数利用动态规划来找到从网格左上角到右下角的两条路径，\n    以最大化收集的值的总和。即使两条路径经过同一个位置，每个值最多只能被收集一次。\n\n    参数:\n    - N (int): 网格的大小 (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 一个元组的列表，每个元组包含\n      x 坐标、y 坐标，以及在该位置放置在网格上的值。\n      列表以一个全为零的元组结束。\n\n    返回:\n    - int: 在两条路径上收集的值的最大总和。\n\n    示例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "fr": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculer la somme maximale des valeurs collectées sur deux chemins dans une grille N x N.\n\n    Cette fonction utilise la programmation dynamique pour trouver deux chemins du coin supérieur gauche\n    au coin inférieur droit de la grille qui maximisent la somme des valeurs collectées. Chaque\n    valeur peut être collectée au plus une fois, même si les deux chemins la traversent.\n\n    Arguments:\n    - N (int) : La taille de la grille (N x N).\n    - grid_values (List[Tuple[int, int, int]]) : Une liste de tuples où chaque tuple contient\n      la coordonnée x, la coordonnée y, et la valeur à placer sur la grille à cette position.\n      La liste est terminée par un tuple avec tous les zéros.\n\n    Retourne:\n    - int : La somme maximale des valeurs collectées sur les deux chemins.\n\n    Exemples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "de": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Berechne die maximale Summe der gesammelten Werte auf zwei Pfaden in einem N x N Raster.\n\n    Diese Funktion verwendet dynamische Programmierung, um zwei Pfade vom oberen linken\n    Eckpunkt zum unteren rechten Eckpunkt des Rasters zu finden, die die Summe der gesammelten\n    Werte maximieren. Jeder Wert kann höchstens einmal gesammelt werden, selbst wenn beide\n    Pfade ihn durchqueren.\n\n    Argumente:\n    - N (int): Die Größe des Rasters (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die\n      x-Koordinate, y-Koordinate und den Wert enthält, der an dieser Position auf das Raster\n      gesetzt werden soll. Die Liste wird durch ein Tupel mit lauter Nullen beendet.\n\n    Rückgabewert:\n    - int: Die maximale Summe der auf den beiden Pfaden gesammelten Werte.\n\n    Beispiele:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "ha": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Lissafi mafi girman jimlar ƙimomi da aka tattara a kan hanyoyi biyu a cikin grid ɗin N x N.\n\n    Wannan aikin yana amfani da shirye-shiryen motsi don nemo hanyoyi biyu daga saman-hagu zuwa\n    ƙasan-dama na grid ɗin wanda ke haɓaka jimlar ƙimomin da aka tattara. Kowace\n    ƙima za a iya tattarawa sau ɗaya kawai, ko da kuwa duk hanyoyin sun wuce ta cikinta.\n\n    Args:\n    - N (int): Girman grid ɗin (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Jerin tuples inda kowanne tuple ke ɗauke da\n      x-coordinate, y-coordinate, da ƙima da za a sanya a kan grid a wannan matsayi.\n      Jerin yana ƙarewa da tuple tare da duk sifili.\n\n    Returns:\n    - int: Mafi girman jimlar ƙimomi da aka tattara a kan hanyoyi biyu.\n\n    Misalai:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "hi": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    एक N x N ग्रिड में दो पथों पर एकत्रित मूल्यों के अधिकतम योग की गणना करें।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके ग्रिड के शीर्ष-बाएँ कोने से\n    निचले-दाएँ कोने तक दो पथों को खोजता है जो एकत्रित मूल्यों के योग को अधिकतम करते हैं। प्रत्येक\n    मूल्य को अधिकतम एक बार एकत्रित किया जा सकता है, भले ही दोनों पथ इसके माध्यम से गुजरें।\n\n    तर्क:\n    - N (int): ग्रिड का आकार (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल में\n      x-निर्देशांक, y-निर्देशांक, और उस स्थिति पर ग्रिड पर रखे जाने वाले मूल्य होते हैं।\n      सूची एक ट्यूपल के साथ समाप्त होती है जिसमें सभी शून्य होते हैं।\n\n    लौटाता है:\n    - int: दो पथों पर एकत्रित मूल्यों का अधिकतम योग।\n\n    उदाहरण:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "hu": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Számítsa ki a maximális összegét az értékeknek, amelyeket két útvonalon gyűjtünk össze egy N x N-es rácson.\n\n    Ez a függvény dinamikus programozást használ annak érdekében, hogy megtalálja a rács bal felső sarkából\n    a jobb alsó sarokba vezető két útvonalat, amelyek maximalizálják az összegyűjtött értékek összegét. Minden\n    érték legfeljebb egyszer gyűjthető össze, még akkor is, ha mindkét útvonal áthalad rajta.\n\n    Argumentumok:\n    - N (int): A rács mérete (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Egy listája a tuple-öknek, ahol minden tuple tartalmazza\n      az x-koordinátát, y-koordinátát, és az értéket, amelyet a rács adott pozíciójára kell helyezni.\n      A lista egy minden eleme nulla tuple-lel zárul.\n\n    Visszatér:\n    - int: A két útvonalon összegyűjtött értékek maximális összege.\n\n    Példák:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "es": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calcular la suma máxima de valores recogidos en dos caminos en una cuadrícula de N x N.\n\n    Esta función utiliza programación dinámica para encontrar dos caminos desde la esquina\n    superior izquierda hasta la esquina inferior derecha de la cuadrícula que maximizan la\n    suma de los valores recogidos. Cada valor puede ser recogido como máximo una vez, incluso\n    si ambos caminos pasan por él.\n\n    Argumentos:\n    - N (int): El tamaño de la cuadrícula (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Una lista de tuplas donde cada tupla contiene\n      la coordenada x, la coordenada y, y el valor que se colocará en la cuadrícula en esa\n      posición. La lista termina con una tupla con todos ceros.\n\n    Devuelve:\n    - int: La suma máxima de valores recogidos en los dos caminos.\n\n    Ejemplos:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "arb": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    حساب مجموع القيم الأقصى التي تم جمعها على مسارين في شبكة بحجم N x N.\n\n    تستخدم هذه الدالة البرمجة الديناميكية للعثور على مسارين من الزاوية العلوية اليسرى إلى\n    الزاوية السفلية اليمنى للشبكة والتي تزيد من مجموع القيم التي تم جمعها. يمكن جمع كل\n    قيمة مرة واحدة على الأكثر، حتى إذا مر كلا المسارين من خلالها.\n\n    يعيدالحجج:\n    - N (int): حجم الشبكة (N x N).\n    - grid_values (List[Tuple[int, int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على\n      الإحداثي السيني، الإحداثي الصادي، والقيمة التي سيتم وضعها على الشبكة في ذلك الموقع.\n      تنتهي القائمة بزوج يحتوي على جميع الأصفار.\n\n    يعيد:\n    - int: مجموع القيم الأقصى التي تم جمعها على المسارين.\n\n    أمثلة:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "sw": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Kuhesabu jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili katika gridi ya N x N.\n\n    Kazi hii inatumia programu ya nguvu ili kupata njia mbili kutoka kona ya juu-kushoto hadi\n    kona ya chini-kulia ya gridi ambayo huongeza jumla ya thamani zilizokusanywa. Kila\n    thamani inaweza kukusanywa mara moja tu, hata kama njia zote mbili zinapita kupitia hiyo.\n\n    Hoja:\n    - N (int): Ukubwa wa gridi (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Orodha ya jozi ambapo kila jozi ina\n      x-kiwiko, y-kiwiko, na thamani ya kuwekwa kwenye gridi katika nafasi hiyo.\n      Orodha inakamilishwa na jozi yenye sifuri zote.\n\n    Inarejesha:\n    - int: Jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili.\n\n    Mifano:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "tr": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    N x N boyutundaki bir ızgarada iki yolda toplanan değerlerin maksimum toplamını hesaplayın.\n\n    Bu fonksiyon, dinamik programlama kullanarak ızgaranın sol üst köşesinden sağ alt köşesine\n    kadar olan iki yolu bulur ve toplanan değerlerin toplamını maksimize eder. Her bir değer,\n    her iki yol da üzerinden geçse bile en fazla bir kez toplanabilir.\n\n    Argümanlar:\n    - N (int): Izgara boyutu (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Her bir demetin x-koordinatı, y-koordinatı ve\n      o konumda ızgaraya yerleştirilecek değeri içerdiği demetlerin listesi. Liste, tüm elemanları\n      sıfır olan bir demet ile sonlandırılır.\n\n    Döndürür:\n    - int: İki yolda toplanan değerlerin maksimum toplamı.\n\n    Örnekler:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "vi": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Tính tổng giá trị lớn nhất thu thập được trên hai đường đi trong lưới N x N.\n\n    Hàm này sử dụng lập trình động để tìm hai đường đi từ góc trên bên trái đến\n    góc dưới bên phải của lưới sao cho tối đa hóa tổng giá trị thu thập được. Mỗi\n    giá trị có thể được thu thập tối đa một lần, ngay cả khi cả hai đường đi qua nó.\n\n    Tham số:\n    - N (int): Kích thước của lưới (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Một danh sách các bộ ba mà mỗi bộ ba chứa\n      tọa độ x, tọa độ y, và giá trị được đặt trên lưới tại vị trí đó.\n      Danh sách kết thúc bằng một bộ ba với tất cả các giá trị bằng không.\n\n    Trả về:\n    - int: Tổng giá trị lớn nhất thu thập được trên hai đường đi.\n\n    Ví dụ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "id": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Hitung jumlah maksimum nilai yang dikumpulkan pada dua jalur dalam grid N x N.\n\n    Fungsi ini menggunakan pemrograman dinamis untuk menemukan dua jalur dari sudut kiri atas\n    ke sudut kanan bawah dari grid yang memaksimalkan jumlah nilai yang dikumpulkan. Setiap\n    nilai dapat dikumpulkan paling banyak sekali, bahkan jika kedua jalur melewatinya.\n\n    Argumen:\n    - N (int): Ukuran grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Daftar tuple di mana setiap tuple berisi\n      koordinat x, koordinat y, dan nilai yang akan ditempatkan pada grid di posisi tersebut.\n      Daftar diakhiri dengan tuple yang berisi semua nol.\n\n    Mengembalikan:\n    - int: Jumlah maksimum nilai yang dikumpulkan pada dua jalur.\n\n    Contoh:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "ja": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    N x N グリッド内の2つの経路で収集される値の最大合計を計算します。\n\n    この関数は動的計画法を利用して、グリッドの左上隅から右下隅までの2つの経路を見つけ、\n    収集される値の合計を最大化します。各値は、両方の経路がそれを通過しても、最大で1回しか\n    収集できません。\n\n    引数:\n    - N (int): グリッドのサイズ (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 各タプルがグリッドのその位置に配置される\n      x座標、y座標、および値を含むタプルのリスト。リストはすべてゼロのタプルで終了します。\n\n    戻り値:\n    - int: 2つの経路で収集される値の最大合計。\n\n    例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "ko": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    N x N 그리드에서 두 경로에서 수집된 값의 최대 합을 계산합니다.\n\n    이 함수는 동적 프로그래밍을 활용하여 그리드의 왼쪽 상단 모서리에서 오른쪽 하단 모서리로의\n    두 경로를 찾아 수집된 값의 합을 최대화합니다. 각 값은 두 경로가 이를 통과하더라도 최대 한 번만\n    수집될 수 있습니다.\n\n    매개변수:\n    - N (int): 그리드의 크기 (N x N).\n    - grid_values (List[Tuple[int, int, int]]): 각 튜플이 그리드의 해당 위치에 배치될\n      x좌표, y좌표, 값을 포함하는 튜플의 리스트입니다. 리스트는 모든 값이 0인 튜플로 종료됩니다.\n\n    반환값:\n    - int: 두 경로에서 수집된 값의 최대 합.\n\n    예제:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "ml": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    N x N ഗ്രിഡിൽ രണ്ട് പാതകളിൽ ശേഖരിച്ച മൂല്യങ്ങളുടെ പരമാവധി തുക കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് ഗ്രിഡിന്റെ മുകളിൽ-ഇടതുകോണിൽ നിന്ന്\n    താഴെ-വലതുകോണിലേക്ക് രണ്ട് പാതകൾ കണ്ടെത്തുന്നു, ശേഖരിച്ച മൂല്യങ്ങളുടെ തുക പരമാവധി\n    ആക്കുന്നു. ഓരോ മൂല്യവും പരമാവധി ഒരിക്കൽ മാത്രമേ ശേഖരിക്കാവൂ, ഇരു പാതകളും\n    അതിലൂടെ കടന്നുപോയാലും.\n\n    Args:\n    - N (int): ഗ്രിഡിന്റെ വലിപ്പം (N x N).\n    - grid_values (List[Tuple[int, int, int]]): ഓരോ ട്യൂപ്പിളും\n      x-കോഓർഡിനേറ്റ്, y-കോഓർഡിനേറ്റ്, ആ സ്ഥാനത്ത് ഗ്രിഡിൽ വെക്കേണ്ട മൂല്യം\n      അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക. പട്ടിക മുഴുവനായും 0-കളുള്ള ഒരു\n      ട്യൂപ്പിള്‍ ഉപയോഗിച്ച് അവസാനിപ്പിക്കുന്നു.\n\n    Returns:\n    - int: രണ്ട് പാതകളിൽ ശേഖരിച്ച മൂല്യങ്ങളുടെ പരമാവധി തുക.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "fa": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    محاسبه حداکثر مجموع مقادیر جمع‌آوری‌شده در دو مسیر در یک شبکه N x N.\n\n    این تابع از برنامه‌ریزی پویا برای یافتن دو مسیر از گوشه بالا-چپ به\n    گوشه پایین-راست شبکه استفاده می‌کند که مجموع مقادیر جمع‌آوری‌شده را به حداکثر برساند. هر\n    مقدار می‌تواند حداکثر یک‌بار جمع‌آوری شود، حتی اگر هر دو مسیر از آن عبور کنند.\n\n    آرگومان‌ها:\n    - N (int): اندازه شبکه (N x N).\n    - grid_values (List[Tuple[int, int, int]]): لیستی از تاپل‌ها که هر تاپل شامل\n      مختصات x، مختصات y و مقدار قرار داده شده در شبکه در آن موقعیت است.\n      لیست با یک تاپل که همه مقادیر آن صفر است خاتمه می‌یابد.\n\n    بازگشت:\n    - int: حداکثر مجموع مقادیر جمع‌آوری‌شده در دو مسیر.\n\n    مثال‌ها:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\""}, "canonical_solution": "# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]", "instruction": {"en": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nՏրամադրել կարճ բնութագիր (docstring) այս Python կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nBayar da taƙaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nदिए गए Python कोड का एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.", "sw": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt với tối đa 500 ký tự.", "id": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\n以下のPythonコードのドキュメンテーション文字列（docstring）を、日本語で500文字以内で簡潔に説明してください。", "ko": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nPython 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെയായി നൽകുക.", "fa": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_max_value_on_paths():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_max_value_on_paths()", "entry_point": "max_value_on_paths", "signature": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:", "docstring": {"en": "Calculate the maximum sum of values collected on two paths in an N x N grid.\n\nThis function utilizes dynamic programming to find two paths from the top-left corner to\nthe bottom-right corner of the grid which maximize the sum of the values collected. Each\nvalue can be collected at most once, even if both paths pass through it.\n\nArgs:\n- N (int): The size of the grid (N x N).\n- grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\nthe x-coordinate, y-coordinate, and value to be placed on the grid at that position.\nThe list is terminated by a tuple with all zeros.\n\nReturns:\n- int: The maximum sum of values collected on the two paths.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "sq": "Llogarit shumën maksimale të vlerave të mbledhura në dy rrugë në një rrjetë N x N.\n\nKjo funksion përdor programimin dinamik për të gjetur dy rrugë nga këndi i sipërm i majtë deri në këndin e poshtëm të djathtë të rrjetës që maksimizojnë shumën e vlerave të mbledhura. Çdo vlerë mund të mblidhet maksimumi një herë, edhe nëse të dyja rrugët kalojnë nëpër të.\n\nArgumentet:\n- N (int): Madhësia e rrjetës (N x N).\n- grid_values (List[Tuple[int, int, int]]): Një listë tuples ku çdo tuple përmban\nkoordinatën x, koordinatën y, dhe vlerën që do të vendoset në rrjetë në atë pozicion.\nLista përfundon me një tuple me të gjitha zerot.\n\nKthen:\n- int: Shuma maksimale e vlerave të mbledhura në dy rrugët.\n\nShembuj:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "hy": "Հաշվարկել արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիների վրա N x N ցանցում:\n\nԱյս ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ գտնելու համար երկու ուղի ցանցի վերին ձախ անկյունից դեպի\nցանցի ներքևի աջ անկյունը, որոնք առավելագույնի են հասցնում հավաքված արժեքների գումարը։ Յուրաքանչյուր\nարժեք կարող է հավաքվել առավելագույնը մեկ անգամ, նույնիսկ եթե երկու ուղիներն անցնում են դրա միջով։\n\nԱրգումենտներ:\n- N (int): Ցանցի չափը (N x N)։\n- grid_values (List[Tuple[int, int, int]]): Թվերի ցուցակ, որտեղ յուրաքանչյուր տուփ պարունակում է\nx-կոորդինատը, y-կոորդինատը և արժեքը, որը պետք է տեղադրվի ցանցում այդ դիրքում։\nՑուցակը ավարտվում է զրոներով տուփով։\n\nՎերադարձնում է:\n- int: Երկու ուղիների վրա հավաքված արժեքների առավելագույն գումարը։\n\nՕրինակներ:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "bn": "N x N গ্রিডে দুটি পথের উপর সংগৃহীত মানগুলির সর্বাধিক যোগফল গণনা করুন।\n\nএই ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে গ্রিডের উপরের-বাম কোণ থেকে\nনিচের-ডান কোণে দুটি পথ খুঁজে বের করে যা সংগৃহীত মানগুলির যোগফল সর্বাধিক করে। প্রতিটি\nমান সর্বাধিক একবার সংগৃহীত হতে পারে, এমনকি যদি উভয় পথ এর মধ্য দিয়ে যায়।\n\nআর্গস:\n- N (int): গ্রিডের আকার (N x N)।\n- grid_values (List[Tuple[int, int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপলে\nগ্রিডের নির্দিষ্ট অবস্থানে স্থাপন করার জন্য x-সমন্বয়, y-সমন্বয়, এবং মান থাকে।\nতালিকাটি সব শূন্য সহ একটি টুপল দ্বারা শেষ হয়।\n\nরিটার্নস:\n- int: দুটি পথের উপর সংগৃহীত মানগুলির সর্বাধিক যোগফল।\n\nউদাহরণ:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "bg": "Изчисляване на максималната сума от стойности, събрани по два пътя в мрежа N x N.\n\nТази функция използва динамично програмиране, за да намери два пътя от горния ляв ъгъл до долния десен ъгъл на мрежата, които максимизират сумата от събраните стойности. Всяка стойност може да бъде събрана най-много веднъж, дори ако и двата пътя минават през нея.\n\nАргументи:\n- N (int): Размерът на мрежата (N x N).\n- grid_values (List[Tuple[int, int, int]]): Списък от кортежи, където всеки кортеж съдържа\nx-координата, y-координата и стойност, която да бъде поставена на мрежата на тази позиция.\nСписъкът е завършен с кортеж с всички нули.\n\nВръща:\n- int: Максималната сума от стойности, събрани по двата пътя.\n\nПримери:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "zh": "计算在一个 N x N 网格中两条路径上收集的最大值总和。\n\n此函数利用动态规划在网格中找到从左上角到右下角的两条路径，以最大化收集的值总和。即使两条路径经过同一个位置，每个值最多只能被收集一次。\n\n参数:\n- N (int): 网格的大小 (N x N)。\n- grid_values (List[Tuple[int, int, int]]): 一个元组列表，其中每个元组包含网格中某个位置的 x 坐标、y 坐标和要放置的值。列表以一个全为零的元组结束。\n\n返回:\n- int: 在两条路径上收集的最大值总和。\n\n示例:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "fr": "Calculer la somme maximale des valeurs collectées sur deux chemins dans une grille N x N.\n\nCette fonction utilise la programmation dynamique pour trouver deux chemins du coin supérieur gauche au coin inférieur droit de la grille qui maximisent la somme des valeurs collectées. Chaque valeur peut être collectée au plus une fois, même si les deux chemins la traversent.\n\nArgs:\n- N (int): La taille de la grille (N x N).\n- grid_values (List[Tuple[int, int, int]]): Une liste de tuples où chaque tuple contient\nles coordonnées x, y, et la valeur à placer sur la grille à cette position.\nLa liste est terminée par un tuple avec tous les zéros.\n\nReturns:\n- int: La somme maximale des valeurs collectées sur les deux chemins.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "de": "Berechne die maximale Summe der Werte, die auf zwei Pfaden in einem N x N Raster gesammelt werden.\n\nDiese Funktion verwendet dynamische Programmierung, um zwei Pfade vom oberen linken Eckpunkt zum unteren rechten Eckpunkt des Rasters zu finden, die die Summe der gesammelten Werte maximieren. Jeder Wert kann höchstens einmal gesammelt werden, selbst wenn beide Pfade ihn durchqueren.\n\nArgumente:\n- N (int): Die Größe des Rasters (N x N).\n- grid_values (List[Tuple[int, int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die x-Koordinate, y-Koordinate und den Wert enthält, der an dieser Position im Raster platziert werden soll. Die Liste endet mit einem Tupel, das nur Nullen enthält.\n\nRückgabewert:\n- int: Die maximale Summe der auf den beiden Pfaden gesammelten Werte.\n\nBeispiele:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "ha": "Lissafi mafi girman jimlar ƙimomi da aka tattara a kan hanyoyi biyu a cikin grid ɗin N x N.\n\nWannan aikin yana amfani da shirye-shiryen motsi don nemo hanyoyi biyu daga saman hagu zuwa\nƙasan dama na grid wanda ke ƙara yawan adadin ƙimomin da aka tattara. Kowace\nƙima za a iya tattara ta sau ɗaya kawai, ko da kuwa duka hanyoyin sun wuce ta.\n\nArgs:\n- N (int): Girman grid (N x N).\n- grid_values (List[Tuple[int, int, int]]): Jerin tuples inda kowanne tuple yana dauke da\nx-coordinate, y-coordinate, da ƙima da za a sanya akan grid a wannan matsayi.\nJerin yana ƙarewa da tuple tare da duk sifili.\n\nReturns:\n- int: Mafi girman adadin ƙimomin da aka tattara akan hanyoyi biyu.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "hi": "एक N x N ग्रिड में दो पथों पर एकत्रित मूल्यों के अधिकतम योग की गणना करें।\n\nयह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करता है ताकि ग्रिड के शीर्ष-बाएँ कोने से\nग्रिड के निचले-दाएँ कोने तक दो रास्ते खोजे जा सकें जो एकत्रित मूल्यों के योग को अधिकतम करें। प्रत्येक\nमूल्य को अधिकतम एक बार एकत्र किया जा सकता है, भले ही दोनों रास्ते इसके माध्यम से गुजरें।\n\nआर्ग्स:\n- N (int): ग्रिड का आकार (N x N)।\n- grid_values (List[Tuple[int, int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल में\nx-निर्देशांक, y-निर्देशांक, और उस स्थिति पर ग्रिड पर रखे जाने वाले मूल्य होते हैं।\nसूची को सभी शून्य वाले ट्यूपल द्वारा समाप्त किया जाता है।\n\nरिटर्न्स:\n- int: दो रास्तों पर एकत्रित मूल्यों का अधिकतम योग।\n\nउदाहरण:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "hu": "Számítsa ki az összegyűjtött értékek maximális összegét két útvonalon egy N x N rácsban.\n\nEz a függvény dinamikus programozást alkalmaz, hogy megtalálja a rács bal felső sarkából a jobb alsó sarkába vezető két útvonalat, amelyek maximalizálják az összegyűjtött értékek összegét. Minden érték legfeljebb egyszer gyűjthető össze, még akkor is, ha mindkét útvonal áthalad rajta.\n\nArgok:\n- N (int): A rács mérete (N x N).\n- grid_values (List[Tuple[int, int, int]]): Egy listája a hármasoknak, ahol minden hármas tartalmazza az x-koordinátát, y-koordinátát és az értéket, amelyet a rács adott pozíciójára kell helyezni. A listát egy minden nullát tartalmazó hármas zárja le.\n\nVisszatér:\n- int: Az összegyűjtött értékek maximális összege a két útvonalon.\n\nPéldák:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "es": "Calcular la suma máxima de valores recogidos en dos caminos en una cuadrícula de N x N.\n\nEsta función utiliza programación dinámica para encontrar dos caminos desde la esquina superior izquierda hasta la esquina inferior derecha de la cuadrícula que maximizan la suma de los valores recogidos. Cada valor puede ser recogido como máximo una vez, incluso si ambos caminos pasan por él.\n\nArgumentos:\n- N (int): El tamaño de la cuadrícula (N x N).\n- grid_values (List[Tuple[int, int, int]]): Una lista de tuplas donde cada tupla contiene\nla coordenada x, la coordenada y, y el valor a colocar en la cuadrícula en esa posición.\nLa lista termina con una tupla con todos ceros.\n\nDevuelve:\n- int: La suma máxima de valores recogidos en los dos caminos.\n\nEjemplos:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "arb": "احسب الحد الأقصى لمجموع القيم المجمعة على مسارين في شبكة بحجم N x N.\n\nتستخدم هذه الدالة البرمجة الديناميكية لإيجاد مسارين من الزاوية العلوية اليسرى إلى\nالزاوية السفلية اليمنى من الشبكة والتي تزيد من مجموع القيم المجمعة. يمكن جمع كل\nقيمة مرة واحدة فقط، حتى إذا مر كلا المسارين من خلالها.\n\nالمعطيات:\n- N (int): حجم الشبكة (N x N).\n- grid_values (List[Tuple[int, int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على\nالإحداثي السيني، الإحداثي الصادي، والقيمة التي سيتم وضعها على الشبكة في ذلك الموضع.\nتنتهي القائمة بزوج يحتوي على جميع الأصفار.\n\nالقيم المعادة:\n- int: الحد الأقصى لمجموع القيم المجمعة على المسارين.\n\nأمثلة:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "sw": "Hesabu jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili katika gridi ya N x N.\n\nKazi hii inatumia programu ya nguvu ili kupata njia mbili kutoka kona ya juu kushoto hadi\nkona ya chini kulia ya gridi ambayo huongeza jumla ya thamani zilizokusanywa. Kila\nthamani inaweza kukusanywa mara moja tu, hata kama njia zote mbili zinapita kupitia hapo.\n\nHoja:\n- N (int): Ukubwa wa gridi (N x N).\n- grid_values (List[Tuple[int, int, int]]): Orodha ya jozi ambapo kila jozi ina\nx-kiwianishi, y-kiwianishi, na thamani ya kuwekwa kwenye gridi katika nafasi hiyo.\nOrodha inamalizika na jozi yenye sifuri zote.\n\nInarejesha:\n- int: Jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili.\n\nMifano:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "tr": "N x N boyutundaki bir ızgarada iki yolda toplanan değerlerin maksimum toplamını hesaplayın.\n\nBu fonksiyon, dinamik programlama kullanarak ızgaranın sol üst köşesinden sağ alt köşesine\nkadar iki yol bulur ve toplanan değerlerin toplamını maksimize eder. Her bir değer en fazla bir kez toplanabilir, her iki yol da aynı yerden geçse bile.\n\nArgümanlar:\n- N (int): Izgaranın boyutu (N x N).\n- grid_values (List[Tuple[int, int, int]]): Her bir demetin, ızgaradaki bir konuma yerleştirilecek\nx-koordinatı, y-koordinatı ve değeri içerdiği demetlerin bir listesi.\nListe, tüm elemanları sıfır olan bir demet ile sonlandırılır.\n\nDöndürür:\n- int: İki yolda toplanan değerlerin maksimum toplamı.\n\nÖrnekler:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "vi": "Tính tổng giá trị lớn nhất thu thập được trên hai đường đi trong lưới N x N.\n\nHàm này sử dụng lập trình động để tìm hai đường đi từ góc trên bên trái đến góc dưới bên phải của lưới, nhằm tối đa hóa tổng giá trị thu thập được. Mỗi giá trị có thể được thu thập nhiều nhất một lần, ngay cả khi cả hai đường đi đều đi qua nó.\n\nTham số:\n- N (int): Kích thước của lưới (N x N).\n- grid_values (List[Tuple[int, int, int]]): Một danh sách các bộ ba, trong đó mỗi bộ ba chứa tọa độ x, tọa độ y, và giá trị sẽ được đặt trên lưới tại vị trí đó. Danh sách kết thúc bằng một bộ ba với tất cả các giá trị bằng không.\n\nTrả về:\n- int: Tổng giá trị lớn nhất thu thập được trên hai đường đi.\n\nVí dụ:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "id": "Hitung jumlah maksimum nilai yang dikumpulkan pada dua jalur dalam grid N x N.\n\nFungsi ini menggunakan pemrograman dinamis untuk menemukan dua jalur dari sudut kiri atas ke\nsudut kanan bawah grid yang memaksimalkan jumlah nilai yang dikumpulkan. Setiap\nnilai dapat dikumpulkan paling banyak sekali, bahkan jika kedua jalur melewatinya.\n\nArgs:\n- N (int): Ukuran grid (N x N).\n- grid_values (List[Tuple[int, int, int]]): Daftar tuple di mana setiap tuple berisi\nkoordinat x, koordinat y, dan nilai yang akan ditempatkan pada grid di posisi tersebut.\nDaftar diakhiri dengan tuple yang berisi semua nol.\n\nReturns:\n- int: Jumlah maksimum nilai yang dikumpulkan pada dua jalur.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "ja": "2つのパスで収集される値の最大合計をN x Nグリッドで計算します。\n\nこの関数は動的プログラミングを利用して、グリッドの左上隅から右下隅までの2つのパスを見つけ、収集される値の合計を最大化します。各値は、たとえ両方のパスがそれを通過しても、最大1回しか収集できません。\n\n引数:\n- N (int): グリッドのサイズ (N x N)。\n- grid_values (List[Tuple[int, int, int]]): 各タプルがグリッド上の位置に配置されるx座標、y座標、および値を含むタプルのリスト。このリストは、すべてがゼロのタプルで終了します。\n\n戻り値:\n- int: 2つのパスで収集される値の最大合計。\n\n例:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "ko": "N x N 그리드에서 두 경로에서 수집된 값의 최대 합을 계산합니다.\n\n이 함수는 동적 프로그래밍을 활용하여 그리드의 왼쪽 상단 모서리에서 오른쪽 하단 모서리까지 두 경로를 찾아 수집된 값의 합을 최대화합니다. 각 값은 두 경로가 그 값을 지나가더라도 최대 한 번만 수집될 수 있습니다.\n\n인수:\n- N (int): 그리드의 크기 (N x N).\n- grid_values (List[Tuple[int, int, int]]): 각 튜플이 그리드의 특정 위치에 배치될 x좌표, y좌표 및 값을 포함하는 튜플의 목록입니다.\n목록은 모든 값이 0인 튜플로 종료됩니다.\n\n반환:\n- int: 두 경로에서 수집된 값의 최대 합.\n\n예제:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "ml": "N x N ഗ്രിഡിലെ രണ്ട് പാതകളിൽ ശേഖരിച്ച മൂല്യങ്ങളുടെ പരമാവധി തുക കണക്കാക്കുക.\n\nഗ്രിഡിന്റെ മുകളിലെ ഇടത് കോണിൽ നിന്ന് താഴത്തെ വലത് കോണിലേക്ക് രണ്ട് പാതകൾ കണ്ടെത്താൻ ഈ ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിക്കുന്നു, ശേഖരിച്ച മൂല്യങ്ങളുടെ തുക പരമാവധി ആക്കുന്നു. ഓരോ മൂല്യവും പരമാവധി ഒരിക്കൽ മാത്രമേ ശേഖരിക്കാവൂ, രണ്ട് പാതകളും അതിലൂടെ കടന്നുപോയാലും.\n\nആർഗുകൾ:\n- N (int): ഗ്രിഡിന്റെ വലിപ്പം (N x N).\n- grid_values (List[Tuple[int, int, int]]): ഓരോ ട്യൂപ്പിളും x-കോഓർഡിനേറ്റ്, y-കോഓർഡിനേറ്റ്, ആ സ്ഥാനത്ത് ഗ്രിഡിൽ വയ്ക്കേണ്ട മൂല്യം എന്നിവ അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക. പട്ടിക മുഴുവൻ ശൂന്യങ്ങളുള്ള ഒരു ട്യൂപ്പിള്‍ കൊണ്ട് അവസാനിക്കുന്നു.\n\nമടക്കൽ:\n- int: രണ്ട് പാതകളിൽ ശേഖരിച്ച മൂല്യങ്ങളുടെ പരമാവധി തുക.\n\nഉദാഹരണങ്ങൾ:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "fa": "محاسبه حداکثر مجموع مقادیر جمع‌آوری شده در دو مسیر در یک شبکه N x N.\n\nاین تابع از برنامه‌ریزی پویا برای یافتن دو مسیر از گوشه بالا-چپ به گوشه پایین-راست شبکه استفاده می‌کند که مجموع مقادیر جمع‌آوری شده را به حداکثر می‌رساند. هر مقدار می‌تواند حداکثر یک بار جمع‌آوری شود، حتی اگر هر دو مسیر از آن عبور کنند.\n\nپارامترها:\n- N (int): اندازه شبکه (N x N).\n- grid_values (List[Tuple[int, int, int]]): لیستی از تاپل‌ها که هر تاپل شامل مختصات x، مختصات y و مقداری است که باید در آن موقعیت روی شبکه قرار گیرد. لیست با یک تاپل که همه عناصر آن صفر هستند خاتمه می‌یابد.\n\nبازگشت:\n- int: حداکثر مجموع مقادیر جمع‌آوری شده در دو مسیر.\n\nمثال‌ها:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67"}}
{"task_id": "Python/9", "prompt": {"en": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "sq": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Gjenero të gjitha kombinimet unike të tre numrave, secili i formuar nga shifrat 1 deri në 9 pa përsëritje,\n    në mënyrë që numri i dytë të jetë dy herë i pari dhe i treti të jetë tre herë i pari.\n\n    Kthen:\n        list of tuples: Një listë e renditur e tupleve, ku secila tuple përmban tre numra të plotë që përfaqësojnë\n                        kombinimet e vlefshme të numrave në rend rritës bazuar në numrin e parë.\n\n    Shembull:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "hy": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Գեներացնել երեք թվերի բոլոր եզակի կոմբինացիաները, որոնցից յուրաքանչյուրը կազմված է 1-ից 9 թվանշաններից առանց կրկնության,\n    այնպես, որ երկրորդ թիվը լինի առաջինի կրկնապատիկը, իսկ երրորդը՝ առաջինի եռապատիկը:\n\n    Վերադարձնում է:\n        list of tuples: Կարգավորված tuples-ի ցուցակ, որտեղ յուրաքանչյուր tuple պարունակում է երեք ամբողջ թվեր,\n                        որոնք ներկայացնում են վավեր թվային կոմբինացիաները աճման կարգով՝ հիմնված առաջին թվի վրա:\n\n    Օրինակ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "bn": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    ১ থেকে ৯ পর্যন্ত অঙ্কগুলি থেকে পুনরাবৃত্তি ছাড়াই গঠিত তিনটি সংখ্যার সমস্ত অনন্য সংমিশ্রণ তৈরি করুন,\n    যাতে দ্বিতীয় সংখ্যা প্রথমটির দ্বিগুণ এবং তৃতীয়টি প্রথমটির তিনগুণ হয়।\n\n    রিটার্ন:\n        তালিকা টাপলসের: একটি সাজানো টাপলসের তালিকা, যেখানে প্রতিটি টাপল তিনটি পূর্ণসংখ্যা ধারণ করে যা \n                        প্রথম সংখ্যার উপর ভিত্তি করে ক্রমবর্ধমান ক্রমে বৈধ সংখ্যা সংমিশ্রণ উপস্থাপন করে।\n\n    উদাহরণ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "bg": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Генерира всички уникални комбинации от три числа, всяко от които е съставено от цифрите от 1 до 9 без повторение,\n    така че второто число да е два пъти първото, а третото да е три пъти първото.\n\n    Връща:\n        списък от кортежи: Сортиран списък от кортежи, където всеки кортеж съдържа три цели числа, представляващи\n                           валидните числови комбинации във възходящ ред спрямо първото число.\n\n    Пример:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "zh": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    生成所有由1到9的数字组成的三个数字的唯一组合，每个数字不重复，\n    使得第二个数字是第一个数字的两倍，第三个数字是第一个数字的三倍。\n\n    返回:\n        list of tuples: 一个排序的元组列表，其中每个元组包含三个整数，\n                        代表根据第一个数字升序排列的有效数字组合。\n\n    示例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "fr": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Générer toutes les combinaisons uniques de trois nombres, chacun formé à partir des chiffres 1 à 9 sans répétition,\n    de telle sorte que le deuxième nombre soit le double du premier et le troisième soit le triple du premier.\n\n    Retourne:\n        liste de tuples : Une liste triée de tuples, où chaque tuple contient trois entiers représentant les\n                          combinaisons de nombres valides dans l'ordre croissant basé sur le premier nombre.\n\n    Exemple:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "de": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Erzeuge alle eindeutigen Kombinationen von drei Zahlen, die jeweils aus den Ziffern 1 bis 9 ohne Wiederholung gebildet werden,\n    sodass die zweite Zahl das Doppelte der ersten und die dritte das Dreifache der ersten ist.\n\n    Rückgabe:\n        Liste von Tupeln: Eine sortierte Liste von Tupeln, wobei jedes Tupel drei ganze Zahlen enthält, die die\n                          gültigen Zahlenkombinationen in aufsteigender Reihenfolge basierend auf der ersten Zahl darstellen.\n\n    Beispiel:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "ha": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Samar da dukkan haɗe-haɗe na musamman na lambobi uku, kowanne an kafa shi daga lambobin 1 zuwa 9 ba tare da maimaitawa ba,\n    ta yadda lamba ta biyu sau biyu ce ta farko kuma ta uku sau uku ce ta farko.\n\n    Komawa:\n        jerin tuples: Jerin tuples da aka tsara, inda kowanne tuple ya ƙunshi lambobi uku da ke wakiltar\n                      ingantattun haɗe-haɗe na lambobi a cikin tsari mai tashi dangane da lamba ta farko.\n\n    Misali:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "hi": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    अंक 1 से 9 तक से बिना पुनरावृत्ति के बने तीन अंकों के सभी अद्वितीय संयोजनों को उत्पन्न करें,\n    ताकि दूसरा अंक पहले का दोगुना हो और तीसरा अंक पहले का तीन गुना हो।\n\n    वापसी:\n        list of tuples: एक क्रमबद्ध सूची जो tuples को शामिल करती है, जहाँ प्रत्येक tuple तीन पूर्णांकों को दर्शाता है\n                        जो पहले अंक के आधार पर आरोही क्रम में मान्य संख्या संयोजन हैं।\n\n    उदाहरण:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "hu": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generálja az összes egyedi kombinációját három számnak, amelyeket az 1-től 9-ig terjedő számjegyekből képeznek ismétlés nélkül,\n    úgy, hogy a második szám kétszerese az elsőnek, és a harmadik háromszorosa az elsőnek.\n\n    Visszatér:\n        list of tuples: Egy rendezett lista a tuple-ökről, ahol minden tuple három egész számot tartalmaz, amelyek\n                        érvényes számsorozatokat képviselnek növekvő sorrendben az első szám alapján.\n\n    Példa:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "es": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Genera todas las combinaciones únicas de tres números, cada uno formado por los dígitos del 1 al 9 sin repetición,\n    tal que el segundo número es el doble del primero y el tercero es el triple del primero.\n\n    Devuelve:\n        lista de tuplas: Una lista ordenada de tuplas, donde cada tupla contiene tres enteros que representan las\n                         combinaciones de números válidas en orden ascendente basado en el primer número.\n\n    Ejemplo:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "arb": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    توليد جميع التوليفات الفريدة من ثلاثة أرقام، كل منها مكون من الأرقام من 1 إلى 9 دون تكرار،\n    بحيث يكون الرقم الثاني ضعف الأول والثالث ثلاثة أضعاف الأول.\n\n    يعيد:\n        list of tuples: قائمة مرتبة من المجموعات، حيث تحتوي كل مجموعة على ثلاثة أعداد صحيحة تمثل\n                        توليفات الأرقام الصحيحة بترتيب تصاعدي بناءً على الرقم الأول.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "sw": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Tengeneza mchanganyiko wote wa kipekee wa namba tatu, kila moja ikiwa imetengenezwa kutoka kwa tarakimu 1 hadi 9 bila kurudia,\n    kiasi kwamba namba ya pili ni mara mbili ya ya kwanza na ya tatu ni mara tatu ya ya kwanza.\n\n    Inarudisha:\n        orodha ya tuples: Orodha iliyopangwa ya tuples, ambapo kila tuple ina namba tatu za mzima zinazowakilisha\n                          mchanganyiko sahihi wa namba katika mpangilio wa kupanda kulingana na namba ya kwanza.\n\n    Mfano:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "tr": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    1'den 9'a kadar olan rakamlardan tekrar etmeden oluşturulan üç sayının tüm benzersiz kombinasyonlarını üret,\n    öyle ki ikinci sayı birincinin iki katı ve üçüncü sayı birincinin üç katı olsun.\n\n    Döndürür:\n        list of tuples: Her bir tuple'ın üç tamsayı içerdiği ve geçerli sayı kombinasyonlarını birinci sayıya göre\n                        artan sırayla temsil ettiği sıralı bir tuple listesi.\n\n    Örnek:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "vi": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Tạo tất cả các tổ hợp duy nhất của ba số, mỗi số được tạo từ các chữ số từ 1 đến 9 mà không lặp lại,\n    sao cho số thứ hai gấp đôi số thứ nhất và số thứ ba gấp ba lần số thứ nhất.\n\n    Trả về:\n        list of tuples: Một danh sách đã sắp xếp của các bộ ba, trong đó mỗi bộ ba chứa ba số nguyên đại diện cho\n                        các tổ hợp số hợp lệ theo thứ tự tăng dần dựa trên số thứ nhất.\n\n    Ví dụ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "id": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Menghasilkan semua kombinasi unik dari tiga angka, masing-masing dibentuk dari digit 1 hingga 9 tanpa pengulangan,\n    sedemikian rupa sehingga angka kedua adalah dua kali lipat dari yang pertama dan yang ketiga adalah tiga kali lipat dari yang pertama.\n\n    Mengembalikan:\n        list of tuples: Daftar tuple yang diurutkan, di mana setiap tuple berisi tiga bilangan bulat yang\n                        mewakili kombinasi angka yang valid dalam urutan menaik berdasarkan angka pertama.\n\n    Contoh:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "ja": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    1から9までの数字を使って、重複なしで形成された3つの数字のすべてのユニークな組み合わせを生成します。\n    2番目の数字は1番目の数字の2倍であり、3番目の数字は1番目の数字の3倍であること。\n\n    戻り値:\n        list of tuples: 各タプルが昇順で有効な数字の組み合わせを表す3つの整数を含む、\n                        タプルのソートされたリスト。\n\n    例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "ko": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    숫자 1부터 9까지의 숫자로 구성된 세 자리 수의 모든 고유 조합을 생성합니다. 각 숫자는 반복 없이 사용되며,\n    두 번째 숫자는 첫 번째 숫자의 두 배이고 세 번째 숫자는 첫 번째 숫자의 세 배입니다.\n\n    반환값:\n        list of tuples: 각 튜플이 첫 번째 숫자를 기준으로 오름차순으로 유효한 숫자 조합을 나타내는 세 개의 정수를 포함하는\n                        정렬된 튜플 목록입니다.\n\n    예시:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "ml": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    1 മുതൽ 9 വരെ ഉള്ള അക്കങ്ങളിൽ നിന്ന് ആവർത്തനമില്ലാതെ രൂപീകരിച്ച മൂന്ന് അക്കങ്ങളുടെ എല്ലാ അപൂർവമായ സംയോജനങ്ങളും സൃഷ്ടിക്കുക,\n    രണ്ടാമത്തെ സംഖ്യ ഒന്നാമത്തെ സംഖ്യയുടെ ഇരട്ടിയാണ്, മൂന്നാമത്തെ സംഖ്യ ഒന്നാമത്തെ സംഖ്യയുടെ മൂന്നു മടങ്ങാണ്.\n\n    തിരികെ നൽകുന്നു:\n        list of tuples: ഓരോ tuple-ലും മൂന്നു പൂർണ്ണസംഖ്യകൾ അടങ്ങിയിരിക്കുന്ന, സാധുവായ സംഖ്യാ സംയോജനങ്ങൾ ഒന്നാമത്തെ സംഖ്യയുടെ ക്രമത്തിൽ\n                        ഉയർന്ന ക്രമത്തിൽ അടങ്ങിയ ഒരു ക്രമീകരിച്ച പട്ടിക.\n\n    ഉദാഹരണം:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "fa": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    تولید تمام ترکیب‌های منحصر به فرد از سه عدد، هر یک تشکیل شده از ارقام 1 تا 9 بدون تکرار،\n    به طوری که عدد دوم دو برابر اولی و عدد سوم سه برابر اولی باشد.\n\n    بازگشت:\n        list of tuples: یک لیست مرتب از تاپل‌ها، که هر تاپل شامل سه عدد صحیح است که ترکیب‌های\n                        معتبر اعداد را به ترتیب صعودی بر اساس عدد اول نشان می‌دهد.\n\n    مثال:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\""}, "canonical_solution": "# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])", "instruction": {"en": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nAşağıdaki Python kodunun Türkçe olarak en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.", "vi": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\n以下のPythonコードに対する簡潔な自然言語の説明（ドックストリング）を、日本語で500文字以内で提供してください。", "ko": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 작성하시오. 최대 500자까지 가능합니다.", "ml": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഇല്ലാത്ത ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_find_number_combinations():\n    # Call the function to get the combinations\n    combinations = find_number_combinations()\n\n    # Check that we have at least one valid combination\n    assert len(combinations) > 0, \"There should be at least one valid combination.\"\n\n    # Iterate over each combination to perform further checks\n    for combo in combinations:\n        # Each combination should have exactly three numbers\n        assert len(combo) == 3, \"Each combination should have three numbers.\"\n\n        # Check if numbers are 3-digit numbers\n        for num in combo:\n            assert 100 <= num <= 999, f\"Each number should be a 3-digit number, got {num}.\"\n\n        # Check the 1:2:3 ratio\n        assert combo[1] == 2 * combo[0] and combo[2] == 3 * combo[0], \"The numbers should be in a 1:2:3 ratio.\"\n\n    print(\"All test cases passed!\")", "entry_point": "find_number_combinations", "signature": "def find_number_combinations():", "docstring": {"en": "Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\nsuch that the second number is twice the first and the third is three times the first.\n\nReturns:\nlist of tuples: A sorted list of tuples, where each tuple contains three integers representing the\nvalid number combinations in ascending order based on the first number.\n\nExample:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "sq": "Gjeneroni të gjitha kombinimet unike të tre numrave, secili i formuar nga shifrat 1 deri në 9 pa përsëritje,\ntë tilla që numri i dytë është dy herë i pari dhe i treti është tre herë i pari.\n\nKthen:\nlist of tuples: Një listë e renditur tuples, ku secili tuple përmban tre numra të plotë që përfaqësojnë\nkombinimet e vlefshme të numrave në rend rritës bazuar në numrin e parë.\n\nShembull:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "hy": "Գեներացնել երեք թվերի բոլոր եզակի համակցությունները, որոնցից յուրաքանչյուրը կազմված է 1-ից 9 թվանշաններից առանց կրկնության, այնպես, որ երկրորդ թիվը առաջինի կրկնապատիկն է, իսկ երրորդը՝ առաջինի եռապատիկը:\n\nՎերադարձնում է:\nցանկ(tuple-ների): Դասավորված ցանկ tuple-ների, որտեղ յուրաքանչյուր tuple պարունակում է երեք ամբողջ թիվ, որոնք ներկայացնում են վավեր թվային համակցությունները աճման կարգով՝ հիմնված առաջին թվի վրա:\n\nՕրինակ:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "bn": "তিনটি সংখ্যার সমস্ত অনন্য সংমিশ্রণ তৈরি করুন, প্রতিটি 1 থেকে 9 পর্যন্ত অঙ্ক থেকে পুনরাবৃত্তি ছাড়া গঠিত,\nযাতে দ্বিতীয় সংখ্যা প্রথম সংখ্যার দ্বিগুণ এবং তৃতীয়টি প্রথম সংখ্যার তিনগুণ হয়।\n\nপ্রত্যাবর্তন:\nlist of tuples: একটি সাজানো টুপলের তালিকা, যেখানে প্রতিটি টুপলে তিনটি পূর্ণসংখ্যা থাকে যা প্রথম সংখ্যার উপর ভিত্তি করে ক্রমবর্ধমান ক্রমে বৈধ সংখ্যা সংমিশ্রণগুলি উপস্থাপন করে।\n\nউদাহরণ:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "bg": "Генерира всички уникални комбинации от три числа, всяко образувано от цифрите от 1 до 9 без повторение, така че второто число да е два пъти първото, а третото да е три пъти първото.\n\nВръща:\nсписък от кортежи: Сортиран списък от кортежи, където всеки кортеж съдържа три цели числа, представляващи валидните комбинации от числа във възходящ ред на базата на първото число.\n\nПример:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "zh": "生成所有由数字1到9组成的三个数字的唯一组合，且不重复，\n使得第二个数字是第一个数字的两倍，第三个数字是第一个数字的三倍。\n\n返回：\nlist of tuples: 一个排序后的元组列表，其中每个元组包含三个整数，表示基于第一个数字按升序排列的有效数字组合。\n\n示例：\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "fr": "Générer toutes les combinaisons uniques de trois nombres, chacun formé à partir des chiffres de 1 à 9 sans répétition, de telle sorte que le deuxième nombre soit le double du premier et le troisième soit le triple du premier.\n\nRenvoie :\nliste de tuples : Une liste triée de tuples, où chaque tuple contient trois entiers représentant les combinaisons de nombres valides dans l'ordre croissant basé sur le premier nombre.\n\nExemple :\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "de": "Erzeuge alle einzigartigen Kombinationen von drei Zahlen, die jeweils aus den Ziffern 1 bis 9 ohne Wiederholung gebildet werden, sodass die zweite Zahl das Doppelte der ersten und die dritte das Dreifache der ersten ist.\n\nRückgabe:\nListe von Tupeln: Eine sortierte Liste von Tupeln, wobei jedes Tupel drei ganze Zahlen enthält, die die gültigen Zahlenkombinationen in aufsteigender Reihenfolge basierend auf der ersten Zahl darstellen.\n\nBeispiel:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "ha": "Generate dukkan haɗuwa na musamman na lambobi uku, kowanne an kafa shi daga lambobi 1 zuwa 9 ba tare da maimaitawa ba, \nta yadda lamba ta biyu tana ninki biyu na ta farko kuma ta uku tana ninki uku na ta farko.\n\nReturns:\njerin tuples: Jerin tuples da aka tsara, inda kowanne tuple ya ƙunshi lambobi uku da ke wakiltar\nsahihan haɗuwa na lambobi a cikin tsari mai hawa bisa ga lamba ta farko.\n\nExample:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "hi": "तीन संख्याओं के सभी अद्वितीय संयोजनों को उत्पन्न करें, प्रत्येक को 1 से 9 तक के अंकों से बिना पुनरावृत्ति के बनाया गया है, इस प्रकार कि दूसरी संख्या पहली का दोगुना है और तीसरी संख्या पहली का तीन गुना है।\n\nवापसी:\nlist of tuples: ट्यूपल्स की एक क्रमबद्ध सूची, जहाँ प्रत्येक ट्यूपल में तीन पूर्णांक होते हैं जो पहले नंबर के आधार पर आरोही क्रम में मान्य संख्या संयोजनों का प्रतिनिधित्व करते हैं।\n\nउदाहरण:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "hu": "Generáljon minden egyedi kombinációt három számból, amelyek az 1-től 9-ig terjedő számjegyekből állnak ismétlés nélkül, úgy, hogy a második szám kétszerese az elsőnek, és a harmadik háromszorosa az elsőnek.\n\nVisszatérési érték:\nlist of tuples: Egy rendezett lista tuple-ökkel, ahol minden tuple három egész számot tartalmaz, amelyek a\nérvényes számkombinációkat ábrázolják növekvő sorrendben az első szám alapján.\n\nPélda:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "es": "Generar todas las combinaciones únicas de tres números, cada uno formado por los dígitos del 1 al 9 sin repetición, de tal manera que el segundo número sea el doble del primero y el tercero sea el triple del primero.\n\nDevuelve:\nlista de tuplas: Una lista ordenada de tuplas, donde cada tupla contiene tres enteros que representan las combinaciones de números válidas en orden ascendente basado en el primer número.\n\nEjemplo:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "arb": "توليد جميع التوليفات الفريدة من ثلاثة أرقام، كل منها يتكون من الأرقام من 1 إلى 9 بدون تكرار، بحيث يكون الرقم الثاني ضعف الأول والرقم الثالث ثلاثة أضعاف الأول.\n\nيعيد:\nقائمة من المجموعات: قائمة مرتبة من المجموعات، حيث تحتوي كل مجموعة على ثلاثة أعداد صحيحة تمثل التوليفات العددية الصالحة بترتيب تصاعدي بناءً على الرقم الأول.\n\nExample:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "sw": "Tengeneza mchanganyiko wote wa kipekee wa namba tatu, kila moja ikiwa imetengenezwa kutoka kwa tarakimu 1 hadi 9 bila kurudia, \nambapo namba ya pili ni mara mbili ya ya kwanza na ya tatu ni mara tatu ya ya kwanza.\n\nRudisha:\norodha ya jozi: Orodha iliyopangwa ya jozi, ambapo kila jozi ina nambari tatu zinazoashiria \nmchanganyiko sahihi wa nambari kwa mpangilio wa kupanda kulingana na namba ya kwanza.\n\nMfano:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "tr": "Üç sayının her birinin 1'den 9'a kadar olan rakamlardan tekrar etmeden oluştuğu tüm benzersiz kombinasyonları oluşturun,\nöyle ki ikinci sayı birincinin iki katı ve üçüncü sayı birincinin üç katı olsun.\n\nDöndürür:\nlist of tuples: Her bir demetin, birinci sayıya göre artan sırada geçerli sayı kombinasyonlarını temsil eden üç tam sayı içerdiği sıralı bir demet listesi.\n\nÖrnek:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "vi": "Tạo tất cả các tổ hợp duy nhất của ba số, mỗi số được tạo từ các chữ số từ 1 đến 9 mà không lặp lại, sao cho số thứ hai gấp đôi số thứ nhất và số thứ ba gấp ba lần số thứ nhất.\n\nTrả về:\ndanh sách các bộ giá trị: Một danh sách đã được sắp xếp của các bộ giá trị, trong đó mỗi bộ chứa ba số nguyên đại diện cho các tổ hợp số hợp lệ theo thứ tự tăng dần dựa trên số thứ nhất.\n\nVí dụ:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "id": "Hasilkan semua kombinasi unik dari tiga angka, masing-masing dibentuk dari digit 1 hingga 9 tanpa pengulangan, sedemikian rupa sehingga angka kedua adalah dua kali angka pertama dan angka ketiga adalah tiga kali angka pertama.\n\nMengembalikan:\ndaftar dari tuple: Daftar tuple yang diurutkan, di mana setiap tuple berisi tiga bilangan bulat yang mewakili kombinasi angka yang valid dalam urutan menaik berdasarkan angka pertama.\n\nContoh:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "ja": "3つの数字のすべてのユニークな組み合わせを生成します。各数字は1から9の数字から重複なしで形成され、2番目の数字は1番目の数字の2倍、3番目の数字は1番目の数字の3倍である必要があります。\n\n戻り値:\nlist of tuples: 各タプルが3つの整数を含むタプルのソートされたリストで、1番目の数字に基づいて昇順で有効な数字の組み合わせを表します。\n\n例:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "ko": "세 숫자의 모든 고유 조합을 생성합니다. 각 숫자는 1부터 9까지의 숫자로 구성되며 반복 없이 사용됩니다. 두 번째 숫자는 첫 번째 숫자의 두 배이고, 세 번째 숫자는 첫 번째 숫자의 세 배입니다.\n\n반환:\nlist of tuples: 각 튜플이 첫 번째 숫자를 기준으로 오름차순으로 정렬된 유효한 숫자 조합을 나타내는 세 개의 정수를 포함하는 튜플의 정렬된 리스트입니다.\n\n예제:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "ml": "മൂന്ന് സംഖ്യകളുടെ എല്ലാ അനന്യമായ സംയോജനങ്ങളും സൃഷ്ടിക്കുക, ഓരോന്നും 1 മുതൽ 9 വരെയുള്ള അക്കങ്ങളിൽ നിന്ന് ആവർത്തനമില്ലാതെ രൂപീകരിക്കപ്പെടുന്നു, രണ്ടാമത്തെ സംഖ്യ ആദ്യത്തേതിന്റെ ഇരട്ടിയും മൂന്നാമത്തെ സംഖ്യ ആദ്യത്തേതിന്റെ മൂന്നു മടങ്ങും ആയിരിക്കണം.\n\nമടക്കം:\nlist of tuples: ഓരോ ട്യൂപ്പിളും മൂന്നു പൂർണ്ണസംഖ്യകൾ അടങ്ങിയിരിക്കുന്ന, ആദ്യ സംഖ്യയുടെ അടിസ്ഥാനത്തിൽ ഉയർന്ന ക്രമത്തിൽ സാധുവായ സംഖ്യാ സംയോജനങ്ങൾ അടങ്ങിയ ഒരു ക്രമീകരിച്ച ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\nഉദാഹരണം:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "fa": "تولید تمام ترکیب‌های منحصر به فرد از سه عدد، که هر کدام از ارقام 1 تا 9 بدون تکرار تشکیل شده‌اند، به گونه‌ای که عدد دوم دو برابر اولی و عدد سوم سه برابر اولی باشد.\n\nبازگرداندن:\nفهرستی از تاپل‌ها: یک فهرست مرتب شده از تاپل‌ها، که هر تاپل شامل سه عدد صحیح است که نشان‌دهنده ترکیب‌های معتبر اعداد به ترتیب صعودی بر اساس عدد اول هستند.\n\nمثال:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]"}}
{"task_id": "Python/10", "prompt": {"en": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "sq": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Llogarit shumën kumulative të vlerave faktoriel nga 1 deri te një numër i specifikuar n.\n\n    Kjo funksion përdor një metodë më efikase për të llogaritur faktorielët duke shumëzuar\n    në mënyrë iterative numrin aktual me rezultatin e mëparshëm të faktorielit, duke shmangur\n    kështu llogaritjet e panevojshme. Më pas akumulon faktorielin e secilit numër nga 1 deri te n përfshirë.\n\n    Argumentet:\n    n (int): Kufiri i sipërm i intervalit për të cilin do të llogaritet shuma e faktorielit.\n             Vlera e n duhet të jetë në intervalin nga 1 deri në 50, përfshirë.\n\n    Kthen:\n    int: Shuma e të gjitha vlerave faktoriel nga 1! deri te n!.\n\n    Shembuj:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "hy": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Հաշվել ֆակտորիալ արժեքների կումուլյատիվ գումարը 1-ից մինչև նշված ամբողջ n թվի համար:\n\n    Այս ֆունկցիան օգտագործում է ավելի արդյունավետ մեթոդ ֆակտորիալները հաշվելու համար՝\n    հերթական թվին բազմապատկելով նախորդ ֆակտորիալի արդյունքին, այսպիսով խուսափելով ավելորդ\n    հաշվարկներից: Այնուհետև այն կումուլացնում է յուրաքանչյուր թվի ֆակտորիալը 1-ից մինչև n ներառյալ:\n\n    Արգումենտներ:\n    n (int): Շարքի վերին սահմանը, որի համար ֆակտորիալ գումարը պետք է հաշվարկվի:\n             n-ի արժեքը պետք է լինի 1-ից 50 միջակայքում, ներառյալ:\n\n    Վերադարձնում է:\n    int: Բոլոր ֆակտորիալ արժեքների գումարը 1!-ից մինչև n!:\n\n    Օրինակներ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "bn": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    ১ থেকে শুরু করে একটি নির্দিষ্ট পূর্ণসংখ্যা n পর্যন্ত ফ্যাক্টোরিয়াল মানগুলির সমষ্টি গণনা করুন।\n\n    এই ফাংশনটি ফ্যাক্টোরিয়াল গণনার জন্য একটি আরও দক্ষ পদ্ধতি ব্যবহার করে, যা পূর্ববর্তী ফ্যাক্টোরিয়াল ফলাফলের সাথে বর্তমান সংখ্যাকে গুণ করে\n    অতিরিক্ত গণনা এড়ায়। এটি ১ থেকে n পর্যন্ত প্রতিটি সংখ্যার ফ্যাক্টোরিয়ালকে জমা করে।\n\n    Args:\n    n (int): ফ্যাক্টোরিয়াল সমষ্টি গণনার জন্য পরিসরের উপরের সীমা।\n             n এর মান ১ থেকে ৫০ এর মধ্যে হওয়া উচিত, অন্তর্ভুক্ত।\n\n    Returns:\n    int: ১! থেকে n! পর্যন্ত সমস্ত ফ্যাক্টোরিয়াল মানের সমষ্টি।\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "bg": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Изчислява кумулативната сума на факториелните стойности от 1 до дадено цяло число n.\n\n    Тази функция използва по-ефективен метод за изчисляване на факториели чрез итеративно\n    умножение на текущото число с предишния резултат от факториела, като по този начин се избягват\n    излишни изчисления. След това натрупва факториела на всяко число от 1 до n включително.\n\n    Аргументи:\n    n (int): Горната граница на диапазона, за който трябва да се изчисли сумата на факториелите.\n             Стойността на n трябва да бъде в диапазона от 1 до 50, включително.\n\n    Връща:\n    int: Сумата на всички факториелни стойности от 1! до n!.\n\n    Примери:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "zh": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    计算从1到指定整数n的阶乘值的累积和。\n\n    此函数采用更高效的方法计算阶乘，通过迭代地将当前数字乘以前一个阶乘结果，从而避免冗余计算。\n    然后累加从1到n（包括n）的每个数字的阶乘。\n\n    参数:\n    n (int): 要计算阶乘和的范围上限。\n             n的值应在1到50之间，包括1和50。\n\n    返回:\n    int: 从1!到n!的所有阶乘值的和。\n\n    示例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "fr": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Calculer la somme cumulative des valeurs factorielles de 1 jusqu'à un entier spécifié n.\n\n    Cette fonction utilise une méthode plus efficace pour calculer les factorielles en multipliant\n    itérativement le nombre actuel par le résultat factoriel précédent, évitant ainsi des calculs\n    redondants. Elle accumule ensuite la factorielle de chaque nombre de 1 à n inclusivement.\n\n    Args:\n    n (int): La limite supérieure de la plage pour laquelle la somme factorielle doit être calculée.\n             La valeur de n doit être comprise entre 1 et 50, inclusivement.\n\n    Returns:\n    int: La somme de toutes les valeurs factorielles de 1! à n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "de": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Berechne die kumulative Summe der Fakultätswerte von 1 bis zu einer angegebenen ganzen Zahl n.\n\n    Diese Funktion verwendet eine effizientere Methode zur Berechnung von Fakultäten, indem sie\n    die aktuelle Zahl iterativ mit dem vorherigen Fakultätsergebnis multipliziert, um so redundante\n    Berechnungen zu vermeiden. Anschließend wird die Fakultät jeder Zahl von 1 bis n inklusive akkumuliert.\n\n    Args:\n    n (int): Die obere Grenze des Bereichs, für den die Fakultätssumme berechnet werden soll.\n             Der Wert von n sollte im Bereich von 1 bis 50 liegen, inklusive.\n\n    Returns:\n    int: Die Summe aller Fakultätswerte von 1! bis n!.\n\n    Beispiele:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "ha": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Lissafa jimillar darajar factorial daga 1 har zuwa wani adadi n da aka kayyade.\n\n    Wannan aikin yana amfani da wata hanya mai inganci don lissafin factorial ta hanyar\n    ninka adadin yanzu da sakamakon factorial na baya, don haka gujewa lissafi mara amfani.\n    Sannan yana tara factorial na kowanne adadi daga 1 zuwa n har da shi.\n\n    Args:\n    n (int): Iyakar kewayon da za a lissafa jimillar factorial.\n             Darajar n ya kamata ta kasance a cikin kewayon 1 zuwa 50, har da su.\n\n    Returns:\n    int: Jimillar dukkan darajar factorial daga 1! zuwa n!.\n\n    Misalai:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "hi": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1 से एक निर्दिष्ट पूर्णांक n तक के फैक्टोरियल मानों का संचयी योग गणना करें।\n\n    यह फ़ंक्शन फैक्टोरियल की गणना के लिए एक अधिक कुशल विधि का उपयोग करता है,\n    जो वर्तमान संख्या को पिछले फैक्टोरियल परिणाम से गुणा करता है, इस प्रकार\n    अनावश्यक गणनाओं से बचता है। फिर यह 1 से n तक प्रत्येक संख्या के फैक्टोरियल\n    को शामिल करते हुए जोड़ता है।\n\n    Args:\n    n (int): उस सीमा का ऊपरी मान जिसके लिए फैक्टोरियल योग की गणना की जानी है।\n             n का मान 1 से 50 की सीमा में होना चाहिए, समावेशी।\n\n    Returns:\n    int: 1! से n! तक के सभी फैक्टोरियल मानों का योग।\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "hu": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Számítsa ki a faktoriális értékek kumulatív összegét 1-től egy megadott n egész számig.\n\n    Ez a függvény egy hatékonyabb módszert alkalmaz a faktoriálisok kiszámítására azáltal, hogy\n    iteratívan megszorozza az aktuális számot az előző faktoriális eredménnyel, így elkerülve\n    a felesleges számításokat. Ezután felhalmozza az 1-től n-ig terjedő számok faktoriálisát, beleértve n-t is.\n\n    Args:\n    n (int): A tartomány felső határa, amelyre a faktoriális összeg kiszámítandó.\n             Az n értékének 1 és 50 között kell lennie, beleértve.\n\n    Returns:\n    int: Az összes faktoriális érték összege 1! és n! között.\n\n    Példák:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "es": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Calcula la suma acumulativa de los valores factoriales desde 1 hasta un entero especificado n.\n\n    Esta función emplea un método más eficiente para calcular factoriales multiplicando\n    iterativamente el número actual por el resultado factorial anterior, evitando así cálculos\n    redundantes. Luego acumula el factorial de cada número desde 1 hasta n inclusive.\n\n    Argumentos:\n    n (int): El límite superior del rango para el cual se va a calcular la suma de factoriales.\n             El valor de n debe estar en el rango de 1 a 50, inclusive.\n\n    Devuelve:\n    int: La suma de todos los valores factoriales desde 1! hasta n!.\n\n    Ejemplos:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "arb": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    حساب المجموع التراكمي لقيم المضروب من 1 حتى عدد صحيح محدد n.\n\n    تستخدم هذه الدالة طريقة أكثر كفاءة لحساب المضروبات عن طريق ضرب الرقم الحالي في نتيجة المضروب السابقة،\n    وبالتالي تجنب الحسابات المتكررة. ثم تجمع مضروب كل رقم من 1 إلى n بشكل شامل.\n\n    يعيدالحجج:\n    n (int): الحد الأعلى للنطاق الذي سيتم حساب مجموع المضروب له.\n             يجب أن تكون قيمة n في النطاق من 1 إلى 50، شاملًا.\n\n    يعيد:\n    int: مجموع جميع قيم المضروب من 1! إلى n!.\n\n    امثله:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "sw": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Hesabu jumla ya thamani za factorial kutoka 1 hadi n iliyobainishwa.\n\n    Kazi hii inatumia mbinu bora zaidi ya kuhesabu factorial kwa kuzidisha\n    namba ya sasa na matokeo ya factorial ya awali, hivyo kuepuka mahesabu\n    yasiyo ya lazima. Kisha inakusanya factorial ya kila namba kutoka 1 hadi n ikijumuisha.\n\n    Hoja:\n    n (int): Kikomo cha juu cha safu ambayo jumla ya factorial inapaswa kuhesabiwa.\n             Thamani ya n inapaswa kuwa katika safu ya 1 hadi 50, ikijumuisha.\n\n    Inarejesha:\n    int: Jumla ya thamani zote za factorial kutoka 1! hadi n!.\n\n    Mifano:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "tr": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1'den belirtilen bir tamsayı n'e kadar olan faktöriyel değerlerinin kümülatif toplamını hesaplayın.\n\n    Bu fonksiyon, faktöriyel hesaplamak için daha verimli bir yöntem kullanır ve\n    önceki faktöriyel sonucuna mevcut sayıyı iteratif olarak çarparak gereksiz\n    hesaplamalardan kaçınır. Daha sonra 1'den n'e kadar her sayının faktöriyelini toplar.\n\n    Argümanlar:\n    n (int): Faktöriyel toplamının hesaplanacağı aralığın üst sınırı.\n             n değeri 1 ile 50 arasında olmalıdır, her iki değer de dahil.\n\n    Döndürür:\n    int: 1!'den n!'e kadar olan tüm faktöriyel değerlerinin toplamı.\n\n    Örnekler:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "vi": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Tính tổng tích lũy của các giá trị giai thừa từ 1 đến một số nguyên n được chỉ định.\n\n    Hàm này sử dụng một phương pháp hiệu quả hơn để tính giai thừa bằng cách nhân \n    số hiện tại với kết quả giai thừa trước đó, do đó tránh được các tính toán dư thừa. \n    Sau đó, nó tích lũy giai thừa của mỗi số từ 1 đến n bao gồm cả n.\n\n    Tham số:\n    n (int): Giới hạn trên của phạm vi mà tổng giai thừa cần được tính toán.\n             Giá trị của n nên nằm trong khoảng từ 1 đến 50, bao gồm cả 1 và 50.\n\n    Trả về:\n    int: Tổng của tất cả các giá trị giai thừa từ 1! đến n!.\n\n    Ví dụ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "id": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Hitung jumlah kumulatif dari nilai faktorial dari 1 hingga bilangan bulat n yang ditentukan.\n\n    Fungsi ini menggunakan metode yang lebih efisien untuk menghitung faktorial dengan cara\n    mengalikan bilangan saat ini dengan hasil faktorial sebelumnya secara iteratif, sehingga\n    menghindari perhitungan yang berlebihan. Kemudian mengakumulasi faktorial dari setiap\n    bilangan dari 1 hingga n secara inklusif.\n\n    Argumen:\n    n (int): Batas atas rentang untuk mana jumlah faktorial akan dihitung.\n             Nilai n harus dalam rentang 1 hingga 50, inklusif.\n\n    Mengembalikan:\n    int: Jumlah dari semua nilai faktorial dari 1! hingga n!.\n\n    Contoh:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "ja": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1から指定された整数nまでの階乗値の累積和を計算します。\n\n    この関数は、現在の数を前の階乗の結果に反復的に掛けることで、より効率的に\n    階乗を計算し、冗長な計算を避けます。そして、1からnまでの各数の階乗を累積します。\n\n    引数:\n    n (int): 階乗の合計を計算する範囲の上限。\n             nの値は1から50の範囲であるべきです。\n\n    戻り値:\n    int: 1!からn!までのすべての階乗値の合計。\n\n    例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "ko": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1부터 지정된 정수 n까지의 팩토리얼 값의 누적 합을 계산합니다.\n\n    이 함수는 이전 팩토리얼 결과에 현재 숫자를 반복적으로 곱하여\n    팩토리얼을 계산하는 보다 효율적인 방법을 사용하여 불필요한\n    계산을 피합니다. 그런 다음 1부터 n까지 각각의 숫자의 팩토리얼을\n    누적합니다.\n\n    Args:\n    n (int): 팩토리얼 합을 계산할 범위의 상한선입니다.\n             n의 값은 1에서 50 사이여야 합니다.\n\n    Returns:\n    int: 1!부터 n!까지 모든 팩토리얼 값의 합입니다.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "ml": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1 മുതൽ ഒരു നിർദ്ദിഷ്ടമായ പൂർണ്ണസംഖ്യ n വരെ ഫാക്ടോറിയൽ മൂല്യങ്ങളുടെ ഏകോപന സമാഹാരം കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ഫാക്ടോറിയലുകൾ കണക്കാക്കാൻ കൂടുതൽ കാര്യക്ഷമമായ രീതിയാണ് ഉപയോഗിക്കുന്നത്, \n    അതായത് നിലവിലെ സംഖ്യയെ മുമ്പത്തെ ഫാക്ടോറിയൽ ഫലത്തിൽ ഗുണിച്ച് ആവർത്തനാത്മകമായി \n    കണക്കാക്കുന്നു, അതുവഴി ആവർത്തന കണക്കാക്കലുകൾ ഒഴിവാക്കുന്നു. \n    തുടർന്ന് 1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ ഫാക്ടോറിയൽ കൂടി സമാഹരിക്കുന്നു.\n\n    Args:\n    n (int): ഫാക്ടോറിയൽ സമാഹാരം കണക്കാക്കേണ്ട പരിധിയുടെ മുകളിൽ പരിധി.\n             nയുടെ മൂല്യം 1 മുതൽ 50 വരെയുള്ള പരിധിയിൽ ആയിരിക്കണം.\n\n    Returns:\n    int: 1! മുതൽ n! വരെ എല്ലാ ഫാക്ടോറിയൽ മൂല്യങ്ങളുടെ സമാഹാരം.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "fa": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    محاسبه مجموع تجمعی مقادیر فاکتوریل از 1 تا یک عدد صحیح مشخص n.\n\n    این تابع از یک روش کارآمدتر برای محاسبه فاکتوریل‌ها استفاده می‌کند که با ضرب عدد فعلی\n    در نتیجه فاکتوریل قبلی، از محاسبات تکراری جلوگیری می‌کند. سپس فاکتوریل هر عدد از 1 تا n\n    را به صورت فراگیر جمع می‌کند.\n\n    آرگومان‌ها:\n    n (int): حد بالای بازه‌ای که مجموع فاکتوریل برای آن محاسبه می‌شود.\n             مقدار n باید در بازه 1 تا 50 باشد، شامل.\n\n    بازگشت:\n    int: مجموع تمام مقادیر فاکتوریل از 1! تا n!.\n\n    مثال‌ها:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\""}, "canonical_solution": "    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials", "instruction": {"en": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nBa da takaitaccen bayanin harshen dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.", "vi": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt với tối đa 500 ký tự.", "id": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\n以下のPythonコードに対する簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടാതെയായി നൽകുക.", "fa": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nتوضیحی مختصر به زبان طبیعی (docstring) از کد پایتون به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_sum_of_factorials_optimized():\n    assert sum_of_factorials_optimized(1) == 1, \"Test case 1 failed: sum_of_factorials_optimized(1) should be 1.\"\n    assert sum_of_factorials_optimized(3) == 9, \"Test case 2 failed: sum_of_factorials_optimized(3) should be 9.\"\n    assert sum_of_factorials_optimized(4) == 33, \"Test case 3 failed: sum_of_factorials_optimized(4) should be 33.\"\n    assert sum_of_factorials_optimized(5) == 153, \"Test case 4 failed: sum_of_factorials_optimized(5) should be 153.\"\n    assert sum_of_factorials_optimized(6) == 873, \"Test case 5 failed: sum_of_factorials_optimized(6) should be 873.\"\n    assert sum_of_factorials_optimized(10) == 4037913, \"Test case 6 failed: sum_of_factorials_optimized(10) should be 4037913.\"\n    print(\"All test cases passed.\")\n\n# Call the test function to run the test cases\ntest_sum_of_factorials_optimized()", "entry_point": "sum_of_factorials_optimized", "signature": "def sum_of_factorials_optimized(n: int) -> int:", "docstring": {"en": "Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\nThis function employs a more efficient method to calculate factorials by iteratively\nmultiplying the current number to the previous factorial result, thus avoiding redundant\ncalculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\nArgs:\nn (int): The upper limit of the range for which the factorial sum is to be calculated.\nThe value of n should be in the range of 1 to 50, inclusive.\n\nReturns:\nint: The sum of all factorial values from 1! to n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "sq": "Llogarit shumën kumulative të vlerave faktoriel nga 1 deri te një numër i specifikuar n.\n\nKjo funksion përdor një metodë më efikase për të llogaritur faktorielët duke shumëzuar në mënyrë iterative numrin aktual me rezultatin e mëparshëm të faktorielit, duke shmangur kështu llogaritjet e panevojshme. Pastaj akumulon faktorielin e secilit numër nga 1 deri te n përfshirë.\n\nArgumentet:\nn (int): Kufiri i sipërm i intervalit për të cilin do të llogaritet shuma e faktorielit.\nVlera e n duhet të jetë në intervalin nga 1 deri në 50, përfshirë.\n\nKthen:\nint: Shuma e të gjitha vlerave faktoriel nga 1! deri te n!.\n\nShembuj:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "hy": "Հաշվել ֆակտորիալ արժեքների կումուլյատիվ գումարը 1-ից մինչև նշված ամբողջ թիվ n:\n\nԱյս ֆունկցիան օգտագործում է ավելի արդյունավետ մեթոդ ֆակտորիալները հաշվարկելու համար՝ իտերատիվ կերպով բազմապատկելով ընթացիկ թիվը նախորդ ֆակտորիալ արդյունքի հետ, այդպիսով խուսափելով ավելորդ հաշվարկներից: Այնուհետև այն կուտակում է 1-ից մինչև n ներառյալ յուրաքանչյուր թվի ֆակտորիալը:\n\nԱրգումենտներ:\nn (int): Շարքի վերին սահմանը, որի համար պետք է հաշվարկվի ֆակտորիալների գումարը:\nn-ի արժեքը պետք է լինի 1-ից 50 միջակայքում, ներառյալ:\n\nՎերադարձնում է:\nint: Բոլոր ֆակտորիալ արժեքների գումարը 1!-ից մինչև n!:\n\nՕրինակներ:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "bn": "ফ্যাক্টোরিয়াল মানগুলির ক্রমবর্ধমান যোগফল 1 থেকে একটি নির্দিষ্ট পূর্ণসংখ্যা n পর্যন্ত গণনা করুন।\n\nএই ফাংশনটি ফ্যাক্টোরিয়াল গণনা করার জন্য একটি আরও দক্ষ পদ্ধতি ব্যবহার করে যা পূর্ববর্তী ফ্যাক্টোরিয়াল ফলাফলের সাথে বর্তমান সংখ্যাকে গুণ করে, ফলে অপ্রয়োজনীয় গণনা এড়ানো যায়। এটি তারপর 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার ফ্যাক্টোরিয়ালকে অন্তর্ভুক্তভাবে যোগ করে।\n\nArgs:\nn (int): সেই পরিসরের উপরের সীমা যার জন্য ফ্যাক্টোরিয়াল যোগফল গণনা করা হবে।\nn এর মান 1 থেকে 50 এর মধ্যে হওয়া উচিত, অন্তর্ভুক্ত।\n\nReturns:\nint: 1! থেকে n! পর্যন্ত সমস্ত ফ্যাক্টোরিয়াল মানের যোগফল।\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "bg": "Изчислява кумулативната сума на факториелните стойности от 1 до зададено цяло число n.\n\nТази функция използва по-ефективен метод за изчисляване на факториели чрез итеративно\nумножаване на текущото число с предишния резултат от факториела, като по този начин се избягват излишни\nизчисления. След това натрупва факториела на всяко число от 1 до n включително.\n\nАргументи:\nn (int): Горната граница на диапазона, за който трябва да се изчисли сумата на факториелите.\nСтойността на n трябва да бъде в диапазона от 1 до 50, включително.\n\nВръща:\nint: Сумата на всички факториелни стойности от 1! до n!.\n\nПримери:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "zh": "计算从 1 到指定整数 n 的阶乘值的累积和。\n\n此函数采用更高效的方法来计算阶乘，通过迭代地将当前数字乘以前一个阶乘结果，从而避免冗余计算。然后累加从 1 到 n 的每个数字的阶乘值。\n\n参数：\nn (int): 要计算阶乘和的范围上限。n 的值应在 1 到 50 之间（包括 1 和 50）。\n\n返回：\nint: 从 1! 到 n! 的所有阶乘值的和。\n\n示例：\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "fr": "Calculer la somme cumulative des valeurs factorielles de 1 jusqu'à un entier spécifié n.\n\nCette fonction utilise une méthode plus efficace pour calculer les factorielles en multipliant\nitérativement le nombre actuel par le résultat factoriel précédent, évitant ainsi les calculs\nredondants. Elle accumule ensuite la factorielle de chaque nombre de 1 à n inclusivement.\n\nArgs:\nn (int): La limite supérieure de la plage pour laquelle la somme factorielle doit être calculée.\nLa valeur de n doit être comprise entre 1 et 50, inclusivement.\n\nReturns:\nint: La somme de toutes les valeurs factorielles de 1! à n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "de": "Berechne die kumulative Summe der Fakultätswerte von 1 bis zu einer angegebenen Ganzzahl n.\n\nDiese Funktion verwendet eine effizientere Methode zur Berechnung von Fakultäten, indem sie iterativ die aktuelle Zahl mit dem vorherigen Fakultätsergebnis multipliziert, um so redundante Berechnungen zu vermeiden. Anschließend akkumuliert sie die Fakultät jeder Zahl von 1 bis n einschließlich.\n\nArgs:\nn (int): Die obere Grenze des Bereichs, für den die Fakultätssumme berechnet werden soll.\nDer Wert von n sollte im Bereich von 1 bis 50 liegen, einschließlich.\n\nReturns:\nint: Die Summe aller Fakultätswerte von 1! bis n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "ha": "Lissafa jimillar darajar factorial daga 1 har zuwa wani adadi n da aka kayyade.\n\nWannan aikin yana amfani da wata hanya mai inganci don lissafin factorials ta hanyar\nnuna lamba ta yanzu zuwa sakamakon factorial na baya, don haka yana guje wa lissafi\nna maimaitawa. Sannan yana tara factorial na kowace lamba daga 1 zuwa n cikin haɗin kai.\n\nArgs:\nn (int): Iyakar sama na zangon wanda za a lissafa jimlar factorial.\nDarajar n ya kamata ta kasance a cikin zangon 1 zuwa 50, ciki har da.\n\nReturns:\nint: Jimlar dukkan darajar factorial daga 1! zuwa n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "hi": "गणना करें 1 से एक निर्दिष्ट पूर्णांक n तक फैक्टरियल मानों का संचयी योग।\n\nयह फ़ंक्शन फैक्टरियल की गणना के लिए एक अधिक कुशल विधि का उपयोग करता है, जो वर्तमान संख्या को पिछले फैक्टरियल परिणाम से गुणा करके, इस प्रकार अनावश्यक गणनाओं से बचता है। यह तब 1 से n तक प्रत्येक संख्या के फैक्टरियल को संचय करता है।\n\nआर्ग्स:\nn (int): उस श्रेणी की ऊपरी सीमा जिसके लिए फैक्टरियल योग की गणना की जानी है।\nn का मान 1 से 50 की सीमा में होना चाहिए, समावेशी।\n\nरिटर्न्स:\nint: 1! से n! तक के सभी फैक्टरियल मानों का योग।\n\nउदाहरण:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "hu": "Számítsa ki a faktoriális értékek kumulatív összegét 1-től egy megadott n egész számig.\n\nEz a függvény egy hatékonyabb módszert alkalmaz a faktoriálisok kiszámítására azáltal, hogy iteratívan\nszorozza a jelenlegi számot az előző faktoriális eredménnyel, így elkerülve a felesleges\nszámításokat. Ezután felhalmozza az 1-től n-ig terjedő számok faktoriálisát, beleértve n-t is.\n\nArgs:\nn (int): Az a felső határ, amelynek tartományára a faktoriális összeg kiszámítandó.\nAz n értékének 1 és 50 között kell lennie, beleértve.\n\nReturns:\nint: Az összes faktoriális érték összege 1!-től n!-ig.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "es": "Calcular la suma acumulativa de los valores factoriales desde 1 hasta un entero especificado n.\n\nEsta función emplea un método más eficiente para calcular factoriales multiplicando iterativamente\nel número actual por el resultado factorial anterior, evitando así cálculos redundantes. Luego acumula el factorial de cada número desde 1 hasta n inclusive.\n\nArgumentos:\nn (int): El límite superior del rango para el cual se va a calcular la suma de factoriales.\nEl valor de n debe estar en el rango de 1 a 50, inclusive.\n\nDevuelve:\nint: La suma de todos los valores factoriales desde 1! hasta n!.\n\nEjemplos:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "arb": "احسب المجموع التراكمي لقيم المضاعفات من 1 حتى عدد صحيح محدد n.\n\nتستخدم هذه الدالة طريقة أكثر كفاءة لحساب المضاعفات عن طريق ضرب العدد الحالي في نتيجة المضاعف السابقة بشكل تكراري، مما يتجنب الحسابات الزائدة. ثم تجمع مضاعف كل عدد من 1 إلى n بشكل شامل.\n\nالمعطيات:\nn (int): الحد الأعلى للنطاق الذي سيتم حساب مجموع المضاعفات له. يجب أن تكون قيمة n في النطاق من 1 إلى 50، شاملًا.\n\nالقيم المعادة:\nint: مجموع جميع قيم المضاعفات من 1! إلى n!.\n\nأمثلة:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "sw": "Hesabu jumla ya thamani za factorial kutoka 1 hadi n iliyobainishwa.\n\nKazi hii hutumia njia bora zaidi ya kuhesabu factorials kwa kuzidisha iteratively\nnambari ya sasa na matokeo ya factorial ya awali, hivyo kuepuka mahesabu ya mara kwa mara.\nKisha hujumlisha factorial ya kila nambari kutoka 1 hadi n kwa ujumla.\n\nHoja:\nn (int): Kikomo cha juu cha safu ambayo jumla ya factorial inapaswa kuhesabiwa.\nThamani ya n inapaswa kuwa katika safu ya 1 hadi 50, kwa ujumla.\n\nInarejesha:\nint: Jumla ya thamani zote za factorial kutoka 1! hadi n!.\n\nMifano:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "tr": "1'den belirtilen bir tamsayı n'ye kadar olan faktöriyel değerlerinin kümülatif toplamını hesaplayın.\n\nBu fonksiyon, faktöriyel hesaplamalarını daha verimli bir yöntemle gerçekleştirir; önceki faktöriyel sonucuna mevcut sayıyı çarparak yinelemeli bir şekilde hesaplar ve böylece gereksiz hesaplamalardan kaçınılır. Daha sonra 1'den n'ye kadar olan her sayının faktöriyelini toplar.\n\nArgümanlar:\nn (int): Faktöriyel toplamının hesaplanacağı aralığın üst sınırı.\nn'nin değeri 1 ile 50 arasında, her iki değer de dahil olmak üzere, olmalıdır.\n\nDöndürür:\nint: 1!'den n!'ye kadar olan tüm faktöriyel değerlerinin toplamı.\n\nÖrnekler:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "vi": "Tính tổng tích lũy của các giá trị giai thừa từ 1 đến một số nguyên n được chỉ định.\n\nHàm này sử dụng một phương pháp hiệu quả hơn để tính giai thừa bằng cách nhân liên tục số hiện tại với kết quả giai thừa trước đó, do đó tránh được các tính toán dư thừa. Sau đó, nó tích lũy giai thừa của mỗi số từ 1 đến n bao gồm cả n.\n\nTham số:\nn (int): Giới hạn trên của phạm vi mà tổng giai thừa sẽ được tính toán. Giá trị của n nên nằm trong khoảng từ 1 đến 50, bao gồm cả 1 và 50.\n\nTrả về:\nint: Tổng của tất cả các giá trị giai thừa từ 1! đến n!.\n\nVí dụ:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "id": "Hitung jumlah kumulatif dari nilai faktorial dari 1 hingga bilangan bulat n yang ditentukan.\n\nFungsi ini menggunakan metode yang lebih efisien untuk menghitung faktorial dengan cara mengalikan angka saat ini secara iteratif dengan hasil faktorial sebelumnya, sehingga menghindari perhitungan yang berlebihan. Kemudian mengakumulasi faktorial dari setiap angka dari 1 hingga n secara inklusif.\n\nArgs:\nn (int): Batas atas dari rentang untuk mana jumlah faktorial akan dihitung.\nNilai n harus dalam rentang 1 hingga 50, inklusif.\n\nReturns:\nint: Jumlah dari semua nilai faktorial dari 1! hingga n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "ja": "1から指定された整数nまでの階乗値の累積和を計算します。\n\nこの関数は、より効率的な方法で階乗を計算するために、現在の数を前の階乗結果に反復的に掛けることで、冗長な計算を避けています。そして、1からnまでの各数の階乗を累積します。\n\n引数:\nn (int): 階乗の合計を計算する範囲の上限。\nnの値は1から50の範囲内である必要があります（両端を含む）。\n\n戻り値:\nint: 1!からn!までのすべての階乗値の合計。\n\n例:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "ko": "1부터 지정된 정수 n까지의 팩토리얼 값의 누적 합을 계산합니다.\n\n이 함수는 이전 팩토리얼 결과에 현재 숫자를 반복적으로 곱하여 팩토리얼을 계산하는 보다 효율적인 방법을 사용하여 불필요한 계산을 피합니다. 그런 다음 1부터 n까지 각 숫자의 팩토리얼을 포함하여 누적합니다.\n\nArgs:\nn (int): 팩토리얼 합을 계산할 범위의 상한. n의 값은 1에서 50 사이여야 합니다.\n\nReturns:\nint: 1!부터 n!까지의 모든 팩토리얼 값의 합.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "ml": "1 മുതൽ നിശ്ചിതമായ n എന്ന പൂർണ്ണസംഖ്യ വരെ ഫാക്ടോറിയൽ മൂല്യങ്ങളുടെ സംയോജിത കൂട്ടം കണക്കാക്കുക.\n\nഈ ഫംഗ്ഷൻ ഫാക്ടോറിയലുകൾ കണക്കാക്കാൻ കൂടുതൽ കാര്യക്ഷമമായ ഒരു രീതി ഉപയോഗിക്കുന്നു, അതായത് ആവർത്തനമായി നിലവിലെ സംഖ്യയെ മുൻ ഫാക്ടോറിയൽ ഫലത്തിൽ ഗുണിച്ച് ആവർത്തന കണക്കുകൾ ഒഴിവാക്കുന്നു. തുടർന്ന് 1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ ഫാക്ടോറിയലും കൂട്ടിച്ചേർക്കുന്നു.\n\nആർഗുകൾ:\nn (int): ഫാക്ടോറിയൽ കൂട്ടം കണക്കാക്കേണ്ട പരിധിയുടെ മുകളിലെ പരിധി. \nn എന്ന മൂല്യം 1 മുതൽ 50 വരെയുള്ള പരിധിയിൽ ആയിരിക്കണം.\n\nമടക്കം:\nint: 1! മുതൽ n! വരെയുള്ള എല്ലാ ഫാക്ടോറിയൽ മൂല്യങ്ങളുടെ കൂട്ടം.\n\nഉദാഹരണങ്ങൾ:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "fa": "محاسبه مجموع تجمعی مقادیر فاکتوریل از 1 تا یک عدد صحیح مشخص n.\n\nاین تابع از یک روش کارآمدتر برای محاسبه فاکتوریل‌ها استفاده می‌کند که با ضرب کردن عدد فعلی در نتیجه فاکتوریل قبلی به صورت تکراری، از محاسبات تکراری جلوگیری می‌کند. سپس فاکتوریل هر عدد از 1 تا n به صورت فراگیر جمع می‌شود.\n\nآرگومان‌ها:\nn (int): حد بالای بازه‌ای که مجموع فاکتوریل برای آن محاسبه می‌شود.\nمقدار n باید در بازه 1 تا 50، شامل هر دو، باشد.\n\nبرگشتی:\nint: مجموع تمام مقادیر فاکتوریل از 1! تا n!.\n\nمثال‌ها:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873"}}
{"task_id": "Python/11", "prompt": {"en": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    \"\"\"", "sq": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Përcakton numëruesin dhe emëruesin e termit të N-të në tabelën e Cantor-it.\n\n    Argumentet:\n    - N (int): Pozicioni në tabelën e Cantor-it për të gjetur thyesën përkatëse.\n\n    Kthen:\n    - str: Një përfaqësim me varg i thyesës në pozicionin e N-të në tabelën e Cantor-it.\n    \"\"\"", "hy": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Սահմանում է Կանտորի աղյուսակի N-րդ անդամի համարիչն ու հայտարարը։\n\n    Արգումենտներ:\n    - N (int): Կանտորի աղյուսակում գտնվելու դիրքը, որի համար անհրաժեշտ է գտնել համապատասխան կոտորակը։\n\n    Վերադարձնում է:\n    - str: Կանտորի աղյուսակի N-րդ դիրքում գտնվող կոտորակի տողային ներկայացումը։\n    \"\"\"", "bn": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    ক্যান্টর টেবিলের N-তম পদের লব ও হর নির্ধারণ করে।\n\n    আর্গুমেন্টসমূহ:\n    - N (int): ক্যান্টর টেবিলে যে অবস্থানে ভগ্নাংশ খুঁজতে হবে তার অবস্থান।\n\n    রিটার্নস:\n    - str: ক্যান্টর টেবিলের N-তম অবস্থানে থাকা ভগ্নাংশের একটি স্ট্রিং উপস্থাপনা।\n    \"\"\"", "bg": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Определя числителя и знаменателя на N-тия член в таблицата на Кантор.\n\n    Аргументи:\n    - N (int): Позицията в таблицата на Кантор, за която да се намери съответната дроб.\n\n    Връща:\n    - str: Стринг представяне на дробта на N-тата позиция в таблицата на Кантор.\n    \"\"\"", "zh": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    确定康托表中第 N 项的分子和分母。\n\n    参数:\n    - N (int): 康托表中要查找对应分数的位置。\n\n    返回:\n    - str: 康托表中第 N 个位置的分数的字符串表示。\n    \"\"\"", "fr": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Détermine le numérateur et le dénominateur du N-ième terme dans le tableau de Cantor.\n\n    Args:\n    - N (int): La position dans le tableau de Cantor pour laquelle trouver la fraction correspondante.\n\n    Returns:\n    - str: Une représentation sous forme de chaîne de la fraction à la position N dans le tableau de Cantor.\n    \"\"\"", "de": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Bestimmt den Zähler und Nenner des N-ten Terms in der Cantor-Tabelle.\n\n    Argumente:\n    - N (int): Die Position in der Cantor-Tabelle, für die der entsprechende Bruch gefunden werden soll.\n\n    Rückgabewert:\n    - str: Eine Zeichenketten-Darstellung des Bruchs an der N-ten Position in der Cantor-Tabelle.\n    \"\"\"", "ha": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Yana tantance maki da maki na N-awa a cikin teburin Cantor.\n\n    Args:\n    - N (int): Matsayi a cikin teburin Cantor don nemo rabon da ya dace da shi.\n\n    Returns:\n    - str: Wakilcin kirtani na rabon a matsayi na N a cikin teburin Cantor.\n    \"\"\"", "hi": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    कैन्टर तालिका में N-वें पद के अंश और हर के मान को निर्धारित करता है।\n\n    तर्क:\n    - N (int): कैन्टर तालिका में वह स्थिति जिसके लिए संबंधित भिन्न को खोजना है।\n\n    वापसी:\n    - str: कैन्टर तालिका में N-वें स्थान पर भिन्न का स्ट्रिंग प्रतिनिधित्व।\n    \"\"\"", "hu": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Meghatározza az N-edik elem számlálóját és nevezőjét a Cantor táblázatban.\n\n    Args:\n    - N (int): A Cantor táblázatban elfoglalt pozíció, amelyhez a megfelelő törtet meg kell találni.\n\n    Returns:\n    - str: A tört sztring reprezentációja az N-edik pozícióban a Cantor táblázatban.\n    \"\"\"", "es": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determina el numerador y el denominador del término N-ésimo en la tabla de Cantor.\n\n    Argumentos:\n    - N (int): La posición en la tabla de Cantor para encontrar la fracción correspondiente.\n\n    Devuelve:\n    - str: Una representación en cadena de la fracción en la posición N-ésima en la tabla de Cantor.\n    \"\"\"", "arb": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    يحدد البسط والمقام للحد N في جدول كانتور.\n\n    يعيدالحجج:\n    - N (int): الموضع في جدول كانتور للعثور على الكسر المقابل له.\n\n    يعيد:\n    - str: تمثيل نصي للكسر في الموضع N في جدول كانتور.\n    \"\"\"", "sw": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Huamua kigezo na kipatanishi cha neno la N katika jedwali la Cantor.\n\n    Hoja:\n    - N (int): Nafasi katika jedwali la Cantor ili kupata sehemu inayolingana nayo.\n\n    Inarejesha:\n    - str: Uwiano wa sehemu katika nafasi ya N katika jedwali la Cantor.\n    \"\"\"", "tr": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Cantor tablosundaki N'inci terimin pay ve paydasını belirler.\n\n    Argümanlar:\n    - N (int): Cantor tablosundaki karşılık gelen kesiri bulmak için pozisyon.\n\n    Döndürür:\n    - str: Cantor tablosundaki N'inci pozisyondaki kesirin string gösterimi.\n    \"\"\"", "vi": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Xác định tử số và mẫu số của số hạng thứ N trong bảng Cantor.\n\n    Tham số:\n    - N (int): Vị trí trong bảng Cantor để tìm phân số tương ứng.\n\n    Trả về:\n    - str: Một chuỗi biểu diễn phân số tại vị trí thứ N trong bảng Cantor.\n    \"\"\"", "id": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Menentukan pembilang dan penyebut dari suku ke-N dalam tabel Cantor.\n\n    Argumen:\n    - N (int): Posisi dalam tabel Cantor untuk menemukan pecahan yang sesuai.\n\n    Mengembalikan:\n    - str: Representasi string dari pecahan pada posisi ke-N dalam tabel Cantor.\n    \"\"\"", "ja": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    カントール表のN番目の項の分子と分母を決定します。\n\n    引数:\n    - N (int): 対応する分数を見つけるためのカントール表の位置。\n\n    戻り値:\n    - str: カントール表のN番目の位置にある分数の文字列表現。\n    \"\"\"", "ko": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Cantor 테이블에서 N번째 항의 분자와 분모를 결정합니다.\n\n    Args:\n    - N (int): 해당하는 분수를 찾기 위한 Cantor 테이블의 위치.\n\n    Returns:\n    - str: Cantor 테이블에서 N번째 위치의 분수를 문자열로 표현한 것.\n    \"\"\"", "ml": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    കാന്റർ പട്ടികയിലെ N-ആം പദത്തിന്റെ ലബ്ധവും ഹരവും നിർണ്ണയിക്കുന്നു.\n\n    Args:\n    - N (int): കാന്റർ പട്ടികയിലെ സ്ഥാനത്തെ കണ്ടെത്താൻ അനുയോജ്യമായ ഭിന്നം.\n\n    Returns:\n    - str: കാന്റർ പട്ടികയിലെ N-ആം സ്ഥാനത്തെ ഭിന്നത്തിന്റെ ഒരു സ്ട്രിംഗ് പ്രതിനിധാനം.\n    \"\"\"", "fa": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    صورت و مخرج جمله N-ام در جدول کانتور را تعیین می‌کند.\n\n    آرگومان‌ها:\n    - N (int): موقعیت در جدول کانتور برای یافتن کسر متناظر.\n\n    بازگشت:\n    - str: یک نمایش رشته‌ای از کسر در موقعیت N-ام در جدول کانتور.\n    \"\"\""}, "canonical_solution": "    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"", "instruction": {"en": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\n请用中文为以下Python代码提供一个简洁的自然语言描述（文档字符串），最多使用500个字符。", "fr": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nBada takaitaccen bayanin yanayi (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nPython kodunun işlevselliğini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 500자 이내로 제공하세요.", "ml": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഉപയോഗിക്കാതെ നൽകുക.", "fa": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_cantor_numbering():\n    # Test case 1: N = 1, the first element, should be \"1/1\"\n    assert cantor_numbering(1)==\"1/1\"\n\n    # Test case 2: N = 2, the second element, should be \"1/2\"\n    assert cantor_numbering(2)==\"1/2\"\n\n    # Test case 3: N = 6, the sixth element, should be \"1/3\"\n    assert cantor_numbering(6)==\"1/3\"\n\n    # Corrected test case: N = 7, the seventh element, should be \"1/4\"\n    assert cantor_numbering(7) == \"1/4\"\n\n    # Additional test case: N = 8, the eighth element, should be \"2/3\"\n    assert cantor_numbering(8) == \"2/3\"\n\n\ntest_cantor_numbering()", "entry_point": "cantor_numbering", "signature": "def cantor_numbering(N: int) -> str:", "docstring": {"en": "Determines the numerator and denominator of the N-th term in the Cantor table.\n\nArgs:\n- N (int): The position in the Cantor table to find the corresponding fraction for.\n\nReturns:\n- str: A string representation of the fraction at the N-th position in the Cantor table.", "sq": "Përcakton numëruesin dhe emëruesin e termit të N-të në tabelën e Cantor-it.\n\nArgumentet:\n- N (int): Pozicioni në tabelën e Cantor-it për të gjetur thyesën përkatëse.\n\nKthen:\n- str: Një përfaqësim si varg i thyesës në pozicionin e N-të në tabelën e Cantor-it.", "hy": "N-երորդ անդամի համար որոշում է համարիչը և հայտարարը Կանտորի աղյուսակում:\n\nԱրգումենտներ:\n- N (int): Կանտորի աղյուսակում գտնվելու դիրքը, որի համար պետք է գտնել համապատասխան կոտորակը:\n\nՎերադարձնում է:\n- str: Կանտորի աղյուսակում N-երորդ դիրքում գտնվող կոտորակի տողի ներկայացումը:", "bn": "N-তম পদে ক্যান্টর টেবিলের লব ও হর নির্ধারণ করে।\n\nআর্গস:\n- N (int): ক্যান্টর টেবিলের অবস্থান যা থেকে সংশ্লিষ্ট ভগ্নাংশ খুঁজে বের করতে হবে।\n\nরিটার্নস:\n- str: ক্যান্টর টেবিলের N-তম অবস্থানে ভগ্নাংশের একটি স্ট্রিং উপস্থাপনা।", "bg": "Определя числителя и знаменателя на N-тия член в таблицата на Кантор.\n\nАргументи:\n- N (int): Позицията в таблицата на Кантор, за която да се намери съответната дроб.\n\nВръща:\n- str: Стринг представяне на дробта на N-тата позиция в таблицата на Кантор.", "zh": "确定康托表中第 N 项的分子和分母。\n\n参数:\n- N (int): 康托表中要查找对应分数的位置。\n\n返回:\n- str: 康托表中第 N 个位置的分数的字符串表示形式。", "fr": "Détermine le numérateur et le dénominateur du N-ième terme dans la table de Cantor.\n\nArgs:\n- N (int): La position dans la table de Cantor pour laquelle trouver la fraction correspondante.\n\nReturns:\n- str: Une représentation sous forme de chaîne de la fraction à la position N dans la table de Cantor.", "de": "Bestimmt den Zähler und Nenner des N-ten Terms in der Cantor-Tabelle.\n\nArgumente:\n- N (int): Die Position in der Cantor-Tabelle, für die der entsprechende Bruch gefunden werden soll.\n\nRückgabewert:\n- str: Eine Zeichenketten-Darstellung des Bruchs an der N-ten Position in der Cantor-Tabelle.", "ha": "Yana tantance mai rarrabawa da mai kasa na kalma ta N a cikin teburin Cantor.\n\nArgs:\n- N (int): Matsayin a cikin teburin Cantor don nemo rabon da ya dace.\n\nReturns:\n- str: Wakilcin kirtani na rabon a matsayi na N a cikin teburin Cantor.", "hi": "N-th पद में कैन्टर तालिका के अंश और हर के मान निर्धारित करता है।\n\nआर्ग्स:\n- N (int): कैन्टर तालिका में वह स्थिति जिसके लिए संबंधित भिन्न को खोजना है।\n\nवापसी:\n- str: कैन्टर तालिका में N-th स्थिति पर भिन्न का स्ट्रिंग प्रतिनिधित्व।", "hu": "Meghatározza az N-edik tétel számlálóját és nevezőjét a Cantor-táblázatban.\n\nArgs:\n- N (int): A Cantor-táblázatban lévő pozíció, amelyhez a megfelelő törtet meg kell találni.\n\nReturns:\n- str: A Cantor-táblázat N-edik pozíciójában lévő tört karakterlánc ábrázolása.", "es": "Determina el numerador y el denominador del término N-ésimo en la tabla de Cantor.\n\nArgumentos:\n- N (int): La posición en la tabla de Cantor para encontrar la fracción correspondiente.\n\nDevuelve:\n- str: Una representación en cadena de la fracción en la posición N-ésima en la tabla de Cantor.", "arb": "يحدد البسط والمقام للحد N في جدول كانتور.\n\nالمعطيات:\n- N (int): الموضع في جدول كانتور للعثور على الكسر المقابل له.\n\nالقيم المعادة:\n- str: تمثيل نصي للكسر في الموضع N في جدول كانتور.", "sw": "Inabainisha numerator na denominator ya neno la N katika jedwali la Cantor.\n\nHoja:\n- N (int): Nafasi katika jedwali la Cantor kupata sehemu inayolingana.\n\nRudisha:\n- str: Uwakilishi wa kamba wa sehemu katika nafasi ya N katika jedwali la Cantor.", "tr": "N'inci terimin Cantor tablosundaki pay ve paydasını belirler.\n\nArgümanlar:\n- N (int): Cantor tablosundaki karşılık gelen kesiri bulmak için pozisyon.\n\nDöndürür:\n- str: Cantor tablosundaki N'inci pozisyondaki kesirin string gösterimi.", "vi": "Xác định tử số và mẫu số của số hạng thứ N trong bảng Cantor.\n\nTham số:\n- N (int): Vị trí trong bảng Cantor để tìm phân số tương ứng.\n\nTrả về:\n- str: Một chuỗi biểu diễn phân số tại vị trí thứ N trong bảng Cantor.", "id": "Menentukan pembilang dan penyebut dari suku ke-N dalam tabel Cantor.\n\nArgumen:\n- N (int): Posisi dalam tabel Cantor untuk menemukan pecahan yang sesuai.\n\nMengembalikan:\n- str: Representasi string dari pecahan pada posisi ke-N dalam tabel Cantor.", "ja": "カントール表のN番目の項の分子と分母を決定します。\n\n引数:\n- N (int): カントール表で対応する分数を見つける位置。\n\n戻り値:\n- str: カントール表のN番目の位置にある分数の文字列表現。", "ko": "Cantor 테이블에서 N번째 항의 분자와 분모를 결정합니다.\n\nArgs:\n- N (int): 해당하는 분수를 찾기 위한 Cantor 테이블의 위치입니다.\n\nReturns:\n- str: Cantor 테이블의 N번째 위치에 있는 분수의 문자열 표현입니다.", "ml": "N-ആം പദത്തിലെ ന്യുമറേറ്ററും ഡിനോമിനേറ്ററും കാന്റർ പട്ടികയിൽ നിർണ്ണയിക്കുന്നു.\n\nആർഗുകൾ:\n- N (int): കാന്റർ പട്ടികയിലെ സ്ഥാനത്തിൽ അനുബന്ധമായ ഭിന്നം കണ്ടെത്തുക.\n\nമടങ്ങിവരവ്:\n- str: കാന്റർ പട്ടികയിലെ N-ആം സ്ഥാനത്തിലുള്ള ഭിന്നത്തിന്റെ ഒരു സ്ട്രിംഗ് പ്രതിനിധാനം.", "fa": "تعیین‌کننده صورت و مخرج جمله Nام در جدول کانتور.\n\nآرگومان‌ها:\n- N (int): موقعیت در جدول کانتور برای یافتن کسر متناظر.\n\nبازگشت:\n- str: یک نمایش رشته‌ای از کسر در موقعیت Nام در جدول کانتور."}}
{"task_id": "Python/12", "prompt": {"en": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    \"\"\"", "sq": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Emri i funksionit: max_product\n    Argumentet:\n    num_str (str): Një varg që përfaqëson vargun e numrave.\n    N (int): Një numër i plotë që përfaqëson gjatësinë e vargut të numrave.\n    K (int): Një numër i plotë që përfaqëson numrin e shenjave të shumëzimit për t'u futur.\n    Lloji i kthimit: int (Funksioni kthen produktin maksimal që mund të merret duke futur K shenja të shumëzimit në vargun e numrave.)\n    \"\"\"", "hy": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Ֆունկցիայի անունը: max_product\n    Արգումենտներ:\n    num_str (str): Տող, որը ներկայացնում է թիվը որպես տող։\n    N (int): Ամբողջ թիվ, որը ներկայացնում է թվի տողի երկարությունը։\n    K (int): Ամբողջ թիվ, որը ներկայացնում է բազմապատկման նշանների քանակը, որոնք պետք է տեղադրել։\n    Վերադարձի տիպը: int (Ֆունկցիան վերադարձնում է առավելագույն արտադրյալը, որը հնարավոր է ստանալ տեղադրելով K բազմապատկման նշաններ թվի տողի մեջ։)\n    \"\"\"", "bn": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    ফাংশনের নাম: max_product\n    আর্গুমেন্টসমূহ:\n    num_str (str): একটি স্ট্রিং যা সংখ্যার স্ট্রিংকে উপস্থাপন করে।\n    N (int): একটি পূর্ণসংখ্যা যা সংখ্যার স্ট্রিংয়ের দৈর্ঘ্যকে উপস্থাপন করে।\n    K (int): একটি পূর্ণসংখ্যা যা প্রবেশ করাতে হবে এমন গুণফল চিহ্নের সংখ্যা উপস্থাপন করে।\n    রিটার্ন টাইপ: int (ফাংশনটি সর্বাধিক গুণফল প্রদান করে যা সংখ্যার স্ট্রিংয়ে K গুণফল চিহ্ন প্রবেশ করিয়ে প্রাপ্ত হতে পারে।)\n    \"\"\"", "bg": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Име на функцията: max_product\n    Аргументи:\n    num_str (str): Низ, представляващ числовия низ.\n    N (int): Цяло число, представляващо дължината на числовия низ.\n    K (int): Цяло число, представляващо броя на знаците за умножение, които да се вмъкнат.\n    Тип на връщане: int (Функцията връща максималния продукт, който може да се получи чрез вмъкване на K знаци за умножение в числовия низ.)\n    \"\"\"", "zh": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    函数名称: max_product\n    参数:\n    num_str (str): 表示数字字符串的字符串。\n    N (int): 表示数字字符串长度的整数。\n    K (int): 表示要插入的乘号数量的整数。\n    返回类型: int (函数返回通过在数字字符串中插入K个乘号可以获得的最大乘积。)\n    \"\"\"", "fr": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Nom de la fonction : max_product\n    Arguments :\n    num_str (str) : Une chaîne représentant la chaîne de chiffres.\n    N (int) : Un entier représentant la longueur de la chaîne de chiffres.\n    K (int) : Un entier représentant le nombre de signes de multiplication à insérer.\n    Type de retour : int (La fonction renvoie le produit maximum qui peut être obtenu en insérant K signes de multiplication dans la chaîne de chiffres.)\n    \"\"\"", "de": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Funktionsname: max_product\n    Argumente:\n    num_str (str): Ein String, der die Zahlenfolge darstellt.\n    N (int): Eine ganze Zahl, die die Länge der Zahlenfolge darstellt.\n    K (int): Eine ganze Zahl, die die Anzahl der einzufügenden Multiplikationszeichen darstellt.\n    Rückgabetyp: int (Die Funktion gibt das maximale Produkt zurück, das durch das Einfügen von K Multiplikationszeichen in die Zahlenfolge erzielt werden kann.)\n    \"\"\"", "ha": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Sunan aiki: max_product\n    Huɗɗa:\n    num_str (str): Wani kirtani da ke wakiltar kirtanin lambobi.\n    N (int): Wani cikakken lamba da ke wakiltar tsawon kirtanin lambobi.\n    K (int): Wani cikakken lamba da ke wakiltar adadin alamar ninkawa da za a saka.\n    Nau'in dawowa: int (Aikin yana dawowa mafi girman samfurin da za a iya samu ta hanyar saka alamar ninkawa K a cikin kirtanin lambobi.)\n    \"\"\"", "hi": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    फ़ंक्शन का नाम: max_product\n    तर्क:\n    num_str (str): संख्या स्ट्रिंग का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    N (int): संख्या स्ट्रिंग की लंबाई का प्रतिनिधित्व करने वाला एक पूर्णांक।\n    K (int): डालने के लिए गुणा चिह्नों की संख्या का प्रतिनिधित्व करने वाला एक पूर्णांक।\n    रिटर्न प्रकार: int (यह फ़ंक्शन अधिकतम उत्पाद लौटाता है जो संख्या स्ट्रिंग में K गुणा चिह्न डालकर प्राप्त किया जा सकता है।)\n    \"\"\"", "hu": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Funkció neve: max_product\n    Argumentumok:\n    num_str (str): Egy karakterlánc, amely a szám karakterláncot reprezentálja.\n    N (int): Egy egész szám, amely a szám karakterlánc hosszát jelenti.\n    K (int): Egy egész szám, amely a beszúrandó szorzásjelek számát jelenti.\n    Visszatérési típus: int (A függvény visszaadja a maximális szorzatot, amelyet elérhetünk K szorzásjel beszúrásával a szám karakterláncba.)\n    \"\"\"", "es": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Nombre de la función: max_product\n    Argumentos:\n    num_str (str): Una cadena que representa la cadena de números.\n    N (int): Un entero que representa la longitud de la cadena de números.\n    K (int): Un entero que representa el número de signos de multiplicación a insertar.\n    Tipo de retorno: int (La función devuelve el producto máximo que se puede obtener insertando K signos de multiplicación en la cadena de números.)\n    \"\"\"", "arb": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    اسم الدالة: max_product\n    الوسائط:\n    num_str (str): سلسلة تمثل سلسلة الأرقام.\n    N (int): عدد صحيح يمثل طول سلسلة الأرقام.\n    K (int): عدد صحيح يمثل عدد علامات الضرب التي سيتم إدراجها.\n    نوع القيمة المعادة: int (تعيد الدالة أكبر حاصل ضرب يمكن الحصول عليه بإدراج K علامات ضرب في سلسلة الأرقام.)\n    \"\"\"", "sw": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Jina la kazi: max_product\n    Hoja:\n    num_str (str): Mfuatano wa herufi unaowakilisha mfuatano wa nambari.\n    N (int): Nambari nzima inayowakilisha urefu wa mfuatano wa nambari.\n    K (int): Nambari nzima inayowakilisha idadi ya alama za kuzidisha kuingiza.\n    Aina ya kurudi: int (Kazi inarudisha bidhaa kubwa zaidi inayoweza kupatikana kwa kuingiza alama za kuzidisha K katika mfuatano wa nambari.)\n    \"\"\"", "tr": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Fonksiyon adı: max_product\n    Argümanlar:\n    num_str (str): Sayı dizgisini temsil eden bir dizgi.\n    N (int): Sayı dizgisinin uzunluğunu temsil eden bir tamsayı.\n    K (int): Eklenecek çarpma işareti sayısını temsil eden bir tamsayı.\n    Dönüş tipi: int (Fonksiyon, sayı dizgisine K çarpma işareti ekleyerek elde edilebilecek maksimum çarpımı döndürür.)\n    \"\"\"", "vi": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Tên hàm: max_product\n    Tham số:\n    num_str (str): Một chuỗi đại diện cho chuỗi số.\n    N (int): Một số nguyên đại diện cho độ dài của chuỗi số.\n    K (int): Một số nguyên đại diện cho số dấu nhân cần chèn vào.\n    Kiểu trả về: int (Hàm trả về tích lớn nhất có thể đạt được bằng cách chèn K dấu nhân vào chuỗi số.)\n    \"\"\"", "id": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Nama fungsi: max_product\n    Argumen:\n    num_str (str): Sebuah string yang mewakili string angka.\n    N (int): Sebuah bilangan bulat yang mewakili panjang string angka.\n    K (int): Sebuah bilangan bulat yang mewakili jumlah tanda perkalian yang akan disisipkan.\n    Tipe pengembalian: int (Fungsi mengembalikan hasil perkalian maksimum yang dapat diperoleh dengan menyisipkan K tanda perkalian ke dalam string angka.)\n    \"\"\"", "ja": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    関数名: max_product\n    引数:\n    num_str (str): 数字列を表す文字列。\n    N (int): 数字列の長さを表す整数。\n    K (int): 挿入する乗算記号の数を表す整数。\n    戻り値の型: int (関数は、数字列にK個の乗算記号を挿入することで得られる最大の積を返します。)\n    \"\"\"", "ko": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    함수 이름: max_product\n    인수:\n    num_str (str): 숫자 문자열을 나타내는 문자열.\n    N (int): 숫자 문자열의 길이를 나타내는 정수.\n    K (int): 삽입할 곱셈 기호의 수를 나타내는 정수.\n    반환 유형: int (함수는 숫자 문자열에 K개의 곱셈 기호를 삽입하여 얻을 수 있는 최대 곱을 반환합니다.)\n    \"\"\"", "ml": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    ഫംഗ്ഷൻ പേര്: max_product\n    ആർഗ്യുമെന്റുകൾ:\n    num_str (str): നമ്പർ സ്ട്രിംഗ് പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    N (int): നമ്പർ സ്ട്രിംഗിന്റെ നീളം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n    K (int): ചേർക്കാനുള്ള ഗുണന ചിഹ്നങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n    റിട്ടേൺ തരം: int (ഫംഗ്ഷൻ നമ്പർ സ്ട്രിംഗിലേക്ക് K ഗുണന ചിഹ്നങ്ങൾ ചേർത്ത് നേടാവുന്ന പരമാവധി ഗുണഫലം തിരികെ നൽകുന്നു.)\n    \"\"\"", "fa": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    نام تابع: max_product\n    آرگومان‌ها:\n    num_str (str): یک رشته که نمایانگر رشته عددی است.\n    N (int): یک عدد صحیح که نمایانگر طول رشته عددی است.\n    K (int): یک عدد صحیح که نمایانگر تعداد علامت‌های ضربی است که باید درج شوند.\n    نوع بازگشتی: int (تابع حداکثر حاصل‌ضربی را که می‌توان با درج K علامت ضرب در رشته عددی به دست آورد، برمی‌گرداند.)\n    \"\"\""}, "canonical_solution": "    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]", "instruction": {"en": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nՏվեք Python կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي المكتوب بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\n以下のPythonコードの説明を日本語で簡潔に記述してください。500文字以内でお願いします。", "ko": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\n다음 Python 코드의 동작을 설명하는 간결한 자연어 설명(도크스트링)을 한국어로 제공하세요. 최대 500자까지 작성할 수 있습니다.", "ml": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nتوضیح مختصر و طبیعی (docstring) از کد Python را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_max_product():\n    # Test case 1\n    num_str1 = \"123\"\n    N1 = 3\n    K1 = 1\n    expected_result1 = 36  # Corrected expected result: 1*23 = 23 or 12*3 = 36, max is 36\n    assert max_product(num_str1, N1,\n                       K1) == expected_result1, f\"Test case 1 failed. Expected {expected_result1}, got {max_product(num_str1, N1, K1)}\"\n\n    # Test case 2\n    num_str2 = \"1234\"\n    N2 = 4\n    K2 = 2\n    expected_result2 = 144  # Corrected expected result: 1*2*34 = 68 or 12*3*4 = 144, max is 144\n    assert max_product(num_str2, N2,\n                       K2) == expected_result2, f\"Test case 2 failed. Expected {expected_result2}, got {max_product(num_str2, N2, K2)}\"\n\n    # Test case 3\n    num_str3 = \"051\"\n    N3 = 3\n    K3 = 1\n    expected_result3 = 5  # 0*51 = 0 or 05*1 = 5, max is 5\n    assert max_product(num_str3, N3,\n                       K3) == expected_result3, f\"Test case 3 failed. Expected {expected_result3}, got {max_product(num_str3, N3, K3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\ntest_max_product()", "entry_point": "max_product", "signature": "def max_product(num_str: str, N: int, K: int) -> int:", "docstring": {"en": "Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)", "sq": "Emri i funksionit: max_product\n    Argumentet:\n    num_str (str): Një varg që përfaqëson vargun e numrave.\n    N (int): Një numër i plotë që përfaqëson gjatësinë e vargut të numrave.\n    K (int): Një numër i plotë që përfaqëson numrin e shenjave të shumëzimit për t'u futur.\n    Lloji i kthimit: int (Funksioni kthen produktin maksimal që mund të merret duke futur K shenja shumëzimi në vargun e numrave.)", "hy": "Գործառույթի անունը: max_product\n    Փոփոխականներ:\n    num_str (str): Թել, որը ներկայացնում է թվային տողը։\n    N (int): Ամբողջ թիվ, որը ներկայացնում է թվային տողի երկարությունը։\n    K (int): Ամբողջ թիվ, որը ներկայացնում է բազմապատկման նշանների քանակը, որոնք պետք է տեղադրվեն։\n    Վերադարձի տեսակը: int (Ֆունկցիան վերադարձնում է առավելագույն արտադրյալը, որը կարելի է ստանալ՝ տեղադրելով K բազմապատկման նշանները թվային տողի մեջ։)", "bn": "ফাংশনের নাম: max_product\n    আর্গুমেন্টসমূহ:\n    num_str (str): সংখ্যা স্ট্রিং উপস্থাপনকারী একটি স্ট্রিং।\n    N (int): সংখ্যা স্ট্রিংয়ের দৈর্ঘ্য উপস্থাপনকারী একটি পূর্ণসংখ্যা।\n    K (int): সন্নিবেশ করার জন্য গুণচিহ্নের সংখ্যা উপস্থাপনকারী একটি পূর্ণসংখ্যা।\n    রিটার্ন টাইপ: int (ফাংশনটি সংখ্যার স্ট্রিংয়ে Kটি গুণচিহ্ন সন্নিবেশ করে প্রাপ্ত সর্বাধিক গুণফল প্রদান করে।)", "bg": "Име на функция: max_product\n    Аргументи:\n    num_str (str): Низ, представляващ числовия низ.\n    N (int): Цяло число, представляващо дължината на числовия низ.\n    K (int): Цяло число, представляващо броя на знаците за умножение, които да се вмъкнат.\n    Тип на връщане: int (Функцията връща максималния произведение, което може да се получи чрез вмъкване на K знаци за умножение в числовия низ.)", "zh": "函数名称: max_product\n    参数:\n    num_str (str): 表示数字字符串的字符串。\n    N (int): 表示数字字符串长度的整数。\n    K (int): 表示要插入的乘号数量的整数。\n    返回类型: int (函数返回通过在数字字符串中插入K个乘号可以获得的最大乘积。)", "fr": "Nom de la fonction: max_product\n    Arguments:\n    num_str (str): Une chaîne représentant la chaîne de chiffres.\n    N (int): Un entier représentant la longueur de la chaîne de chiffres.\n    K (int): Un entier représentant le nombre de signes de multiplication à insérer.\n    Type de retour: int (La fonction renvoie le produit maximum qui peut être obtenu en insérant K signes de multiplication dans la chaîne de chiffres.)", "de": "Funktionsname: max_product\n    Argumente:\n    num_str (str): Ein String, der die Zahlenfolge darstellt.\n    N (int): Eine ganze Zahl, die die Länge der Zahlenfolge darstellt.\n    K (int): Eine ganze Zahl, die die Anzahl der einzufügenden Multiplikationszeichen darstellt.\n    Rückgabetyp: int (Die Funktion gibt das maximale Produkt zurück, das durch das Einfügen von K Multiplikationszeichen in die Zahlenfolge erzielt werden kann.)", "ha": "Sunan aiki: max_product\n    Huɗa:\n    num_str (str): Wani kirtani da ke wakiltar lambar kirtani.\n    N (int): Wani cikakken lamba da ke wakiltar tsawon lambar kirtani.\n    K (int): Wani cikakken lamba da ke wakiltar adadin alamomin ninkawa da za a saka.\n    Nau'in dawowa: int (Aikin yana dawowa da mafi girman samfurin da za a iya samu ta hanyar saka alamomin ninkawa K cikin lambar kirtani.)", "hi": "फ़ंक्शन का नाम: max_product\n    तर्क:\n    num_str (str): एक स्ट्रिंग जो संख्या स्ट्रिंग का प्रतिनिधित्व करती है।\n    N (int): एक पूर्णांक जो संख्या स्ट्रिंग की लंबाई का प्रतिनिधित्व करता है।\n    K (int): एक पूर्णांक जो डालने के लिए गुणा चिह्नों की संख्या का प्रतिनिधित्व करता है।\n    लौटाने का प्रकार: int (यह फ़ंक्शन अधिकतम गुणनफल लौटाता है जो संख्या स्ट्रिंग में K गुणा चिह्न डालकर प्राप्त किया जा सकता है।)", "hu": "A függvény neve: max_product\n    Argumentumok:\n    num_str (str): Egy karakterlánc, amely a szám karakterláncot jelöli.\n    N (int): Egy egész szám, amely a szám karakterlánc hosszát jelöli.\n    K (int): Egy egész szám, amely a beszúrandó szorzásjelek számát jelöli.\n    Visszatérési típus: int (A függvény visszaadja a maximális szorzatot, amelyet elérhetünk K szorzásjel beszúrásával a szám karakterláncba.)", "es": "Nombre de la función: max_product\n    Argumentos:\n    num_str (str): Una cadena que representa la cadena de números.\n    N (int): Un entero que representa la longitud de la cadena de números.\n    K (int): Un entero que representa el número de signos de multiplicación a insertar.\n    Tipo de retorno: int (La función devuelve el producto máximo que se puede obtener insertando K signos de multiplicación en la cadena de números.)", "arb": "اسم الدالة: max_product\n    الوسائط:\n    num_str (str): سلسلة تمثل سلسلة الأرقام.\n    N (int): عدد صحيح يمثل طول سلسلة الأرقام.\n    K (int): عدد صحيح يمثل عدد علامات الضرب التي يجب إدراجها.\n    نوع القيمة المعادة: int (تعيد الدالة أكبر حاصل ضرب يمكن الحصول عليه عن طريق إدراج K علامات ضرب في سلسلة الأرقام.)", "sw": "Jina la kazi: max_product\n    Hoja:\n    num_str (str): Kamba inayoashiria mfuatano wa namba.\n    N (int): Nambari kamili inayowakilisha urefu wa mfuatano wa namba.\n    K (int): Nambari kamili inayowakilisha idadi ya alama za kuzidisha za kuingiza.\n    Aina ya kurudi: int (Kazi inarudisha bidhaa kubwa zaidi inayoweza kupatikana kwa kuingiza alama za kuzidisha K kwenye mfuatano wa namba.)", "tr": "Fonksiyon adı: max_product\n    Argümanlar:\n    num_str (str): Sayı dizisini temsil eden bir dize.\n    N (int): Sayı dizisinin uzunluğunu temsil eden bir tamsayı.\n    K (int): Eklenecek çarpma işaretlerinin sayısını temsil eden bir tamsayı.\n    Dönüş tipi: int (Fonksiyon, sayı dizisine K çarpma işareti ekleyerek elde edilebilecek maksimum çarpımı döndürür.)", "vi": "Tên hàm: max_product\n    Tham số:\n    num_str (str): Một chuỗi đại diện cho chuỗi số.\n    N (int): Một số nguyên đại diện cho độ dài của chuỗi số.\n    K (int): Một số nguyên đại diện cho số dấu nhân cần chèn.\n    Kiểu trả về: int (Hàm trả về tích lớn nhất có thể đạt được bằng cách chèn K dấu nhân vào chuỗi số.)", "id": "Function name: max_product\n    Arguments:\n    num_str (str): Sebuah string yang mewakili string angka.\n    N (int): Sebuah bilangan bulat yang mewakili panjang dari string angka.\n    K (int): Sebuah bilangan bulat yang mewakili jumlah tanda perkalian yang akan disisipkan.\n    Return type: int (Fungsi mengembalikan hasil perkalian maksimum yang dapat diperoleh dengan menyisipkan K tanda perkalian ke dalam string angka.)", "ja": "Function name: max_product\n    Arguments:\n    num_str (str): 数字列を表す文字列。\n    N (int): 数字列の長さを表す整数。\n    K (int): 挿入する掛け算記号の数を表す整数。\n    Return type: int (この関数は、数字列にK個の掛け算記号を挿入することで得られる最大の積を返します。)", "ko": "Function name: max_product\n    Arguments:\n    num_str (str): 숫자 문자열을 나타내는 문자열입니다.\n    N (int): 숫자 문자열의 길이를 나타내는 정수입니다.\n    K (int): 삽입할 곱셈 기호의 수를 나타내는 정수입니다.\n    Return type: int (함수는 숫자 문자열에 K개의 곱셈 기호를 삽입하여 얻을 수 있는 최대 곱을 반환합니다.)", "ml": "Function name: max_product\n    Arguments:\n    num_str (str): നമ്പർ സ്ട്രിംഗ് പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    N (int): നമ്പർ സ്ട്രിംഗിന്റെ നീളം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n    K (int): ചേർക്കാനുള്ള ഗുണന ചിഹ്നങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n    Return type: int (നമ്പർ സ്ട്രിംഗിലേക്ക് K ഗുണന ചിഹ്നങ്ങൾ ചേർത്തുകൊണ്ട് ലഭിക്കാവുന്ന പരമാവധി ഗുണഫലം ഫംഗ്ഷൻ മടക്കുന്നു.)", "fa": "Function name: max_product\n    Arguments:\n    num_str (str): رشته‌ای که نمایانگر رشته عددی است.\n    N (int): یک عدد صحیح که طول رشته عددی را نشان می‌دهد.\n    K (int): یک عدد صحیح که تعداد علامت‌های ضربی که باید درج شود را نشان می‌دهد.\n    Return type: int (این تابع حداکثر حاصل‌ضربی را که می‌توان با درج K علامت ضرب در رشته عددی به دست آورد، برمی‌گرداند.)"}}
{"task_id": "Python/13", "prompt": {"en": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Calculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\n    The function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\n    Scholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    The first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\n    who is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\n    would receive a total of 4850 units of currency.\n\n    In the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\n    is from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.\n    \"\"\"", "sq": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Llogarit shumën totale të bursës për një student bazuar në arritjet akademike dhe jashtëshkollore.\n\n    Funksioni përdor një grup kushtesh për të përcaktuar shumën totale të parave të bursës për të cilën studenti ka të drejtë.\n    Bursat jepen bazuar në notat akademike, rolet drejtuese, prejardhjen rajonale dhe kontributet kërkimore.\n\n    Parametrat:\n    grades (list of int): Një listë me dy elemente që përmban notat akademike të studentit [mesatarja e fundvitit, vlerësimi i klasës].\n    leader (str): Një varg ('Y' ose 'N') që tregon nëse studenti është drejtues klase.\n    west (str): Një varg ('Y' ose 'N') që tregon nëse studenti është nga një provincë perëndimore.\n    papers (int): Një numër i plotë që përfaqëson numrin e artikujve kërkimorë të publikuar nga studenti.\n\n    Kthen:\n    int: Shuma totale e bursës për të cilën studenti ka të drejtë.\n\n    Shembuj:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Shembulli i parë llogarit një bursë për një student me një notë mesatare prej 87, një notë vlerësimi prej 82,\n    i cili është drejtues klase ('Y'), jo nga provinca perëndimore ('N'), dhe pa artikuj të publikuar (0). Ky student\n    do të merrte një total prej 4850 njësive monetare.\n\n    Në shembullin e dytë, studenti ka një notë mesatare prej 88, një notë vlerësimi prej 78, nuk është drejtues klase ('N'),\n    është nga provinca perëndimore ('Y'), dhe ka publikuar 1 artikull. Ky student do të merrte një total prej 9000 njësive monetare.\n    \"\"\"", "hy": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Հաշվել ուսանողի ընդհանուր կրթաթոշակի չափը՝ հիմնված ակադեմիական և արտադասարանային նվաճումների վրա:\n\n    Ֆունկցիան օգտագործում է պայմանների մի շարք՝ որոշելու ուսանողի համար նախատեսված ընդհանուր կրթաթոշակի գումարը:\n    Կրթաթոշակները շնորհվում են՝ հիմնված ակադեմիական գնահատականների, առաջնորդության դերերի, տարածաշրջանային ծագման և հետազոտական ներդրումների վրա:\n\n    Պարամետրեր:\n    grades (list of int): Երկու տարրերից բաղկացած ցուցակ, որը պարունակում է ուսանողի ակադեմիական գնահատականները [տարեվերջի միջին, դասի գնահատում]:\n    leader (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս՝ արդյոք ուսանողը դասի առաջնորդ է:\n    west (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս՝ արդյոք ուսանողը արևմտյան մարզից է:\n    papers (int): Ամբողջ թիվ, որը ներկայացնում է ուսանողի կողմից հրատարակված հետազոտական հոդվածների քանակը:\n\n    Վերադարձնում է:\n    int: Ընդհանուր կրթաթոշակի գումարը, որին ուսանողը իրավունք ունի:\n\n    Օրինակներ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Առաջին օրինակում հաշվարկվում է կրթաթոշակ ուսանողի համար, որի միջին գնահատականը 87 է, գնահատման գնահատականը՝ 82,\n    ով դասի առաջնորդ է ('Y'), արևմտյան մարզից չէ ('N') և չունի հրատարակված հոդվածներ (0): Այս ուսանողը\n    կստանա ընդհանուր 4850 արժույթի միավոր:\n\n    Երկրորդ օրինակում ուսանողը ունի միջին գնահատական՝ 88, գնահատման գնահատական՝ 78, դասի առաջնորդ չէ ('N'),\n    արևմտյան մարզից է ('Y') և ունի 1 հրատարակված հոդված: Այս ուսանողը կստանա ընդհանուր 9000 արժույթի միավոր:\n    \"\"\"", "bn": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    শিক্ষার্থীকে একাডেমিক এবং অতিরিক্ত পাঠক্রমিক কৃতিত্বের উপর ভিত্তি করে মোট বৃত্তির পরিমাণ গণনা করুন।\n\n    ফাংশনটি শিক্ষার্থী কত টাকা বৃত্তি পাওয়ার যোগ্য তা নির্ধারণ করতে বিভিন্ন শর্তাবলী ব্যবহার করে।\n    একাডেমিক গ্রেড, নেতৃত্বের ভূমিকা, আঞ্চলিক পটভূমি এবং গবেষণা অবদানের উপর ভিত্তি করে বৃত্তি প্রদান করা হয়।\n\n    প্যারামিটারসমূহ:\n    grades (list of int): শিক্ষার্থীর একাডেমিক গ্রেডের একটি দুই-উপাদান বিশিষ্ট তালিকা [টার্মের শেষের গড়, শ্রেণির মূল্যায়ন]।\n    leader (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী শ্রেণির নেতা কিনা।\n    west (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী পশ্চিম প্রদেশ থেকে কিনা।\n    papers (int): একটি পূর্ণসংখ্যা যা শিক্ষার্থীর প্রকাশিত গবেষণা পত্রের সংখ্যা নির্দেশ করে।\n\n    রিটার্নস:\n    int: শিক্ষার্থী যে মোট বৃত্তির পরিমাণের জন্য যোগ্য তা।\n\n    উদাহরণ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    প্রথম উদাহরণটি এমন একজন শিক্ষার্থীর জন্য বৃত্তি গণনা করে যার গড় গ্রেড 87, মূল্যায়ন গ্রেড 82,\n    যিনি শ্রেণির নেতা ('Y'), পশ্চিম প্রদেশ থেকে নয় ('N'), এবং কোনো প্রকাশিত পত্র নেই (0)। এই শিক্ষার্থী\n    মোট 4850 মুদ্রা একক পাবে।\n\n    দ্বিতীয় উদাহরণে, শিক্ষার্থীর গড় গ্রেড 88, মূল্যায়ন গ্রেড 78, শ্রেণির নেতা নয় ('N'),\n    পশ্চিম প্রদেশ থেকে ('Y'), এবং 1টি পত্র প্রকাশিত হয়েছে। এই শিক্ষার্থী মোট 9000 মুদ্রা একক পাবে।\n    \"\"\"", "bg": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Изчислява общата сума на стипендията за студент въз основа на академични и извънкласни постижения.\n\n    Функцията използва набор от условия, за да определи общата сума на стипендията, на която студентът има право.\n    Стипендиите се отпускат въз основа на академични оценки, лидерски роли, регионален произход и научни приноси.\n\n    Параметри:\n    grades (list of int): Двуелементен списък, съдържащ академичните оценки на студента [среден успех в края на срока, класова оценка].\n    leader (str): Низ ('Y' или 'N'), указващ дали студентът е класен лидер.\n    west (str): Низ ('Y' или 'N'), указващ дали студентът е от западна провинция.\n    papers (int): Цяло число, представляващо броя на научните публикации на студента.\n\n    Връща:\n    int: Общата сума на стипендията, за която студентът има право.\n\n    Примери:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Първият пример изчислява стипендия за студент със средна оценка 87, оценка от класова оценка 82,\n    който е класен лидер ('Y'), не е от западна провинция ('N') и няма публикувани статии (0). Този студент\n    ще получи общо 4850 единици валута.\n\n    Във втория пример студентът има средна оценка 88, оценка от класова оценка 78, не е класен лидер ('N'),\n    е от западна провинция ('Y') и има публикувана 1 статия. Този студент ще получи общо 9000 единици валута.\n    \"\"\"", "zh": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    根据学术和课外成就计算学生的总奖学金金额。\n\n    该函数使用一组条件来确定学生有权获得的奖学金总金额。\n    奖学金根据学术成绩、领导角色、地区背景和研究贡献来颁发。\n\n    参数:\n    grades (list of int): 一个包含学生学术成绩的两元素列表 [期末平均分, 班级评估]。\n    leader (str): 一个字符串 ('Y' 或 'N')，指示学生是否是班级领导。\n    west (str): 一个字符串 ('Y' 或 'N')，指示学生是否来自西部省份。\n    papers (int): 一个整数，表示学生发表的研究论文数量。\n\n    返回:\n    int: 学生有资格获得的总奖学金金额。\n\n    示例:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    第一个示例计算了一个平均成绩为87，评估成绩为82的学生的奖学金，\n    该学生是班级领导 ('Y')，不来自西部省份 ('N')，且没有发表论文 (0)。该学生\n    将获得总计4850单位的货币。\n\n    在第二个示例中，学生的平均成绩为88，评估成绩为78，不是班级领导 ('N')，\n    来自西部省份 ('Y')，并且发表了1篇论文。该学生将获得总计9000单位的货币。\n    \"\"\"", "fr": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Calculer le montant total de la bourse pour un étudiant basé sur les réalisations académiques et extrascolaires.\n\n    La fonction utilise un ensemble de conditions pour déterminer le montant total de la bourse auquel un étudiant a droit.\n    Les bourses sont attribuées en fonction des notes académiques, des rôles de leadership, de l'origine régionale et des contributions à la recherche.\n\n    Paramètres:\n    grades (list of int): Une liste de deux éléments contenant les notes académiques de l'étudiant [moyenne de fin de trimestre, évaluation de classe].\n    leader (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est un leader de classe.\n    west (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant vient d'une province de l'ouest.\n    papers (int): Un entier représentant le nombre de publications de recherche de l'étudiant.\n\n    Renvoie:\n    int: Le montant total de la bourse auquel l'étudiant est éligible.\n\n    Exemples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Le premier exemple calcule une bourse pour un étudiant avec une moyenne de 87, une note d'évaluation de 82,\n    qui est un leader de classe ('Y'), ne venant pas de la province de l'ouest ('N'), et sans publications (0). Cet étudiant\n    recevrait un total de 4850 unités de monnaie.\n\n    Dans le deuxième exemple, l'étudiant a une moyenne de 88, une note d'évaluation de 78, n'est pas un leader de classe ('N'),\n    vient de la province de l'ouest ('Y'), et a publié 1 article. Cet étudiant recevrait un total de 9000 unités de monnaie.\n    \"\"\"", "de": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Berechne den gesamten Stipendienbetrag für einen Studenten basierend auf akademischen und außerschulischen Leistungen.\n\n    Die Funktion verwendet eine Reihe von Bedingungen, um den gesamten Betrag an Stipendiengeld zu bestimmen, auf den ein Student Anspruch hat.\n    Stipendien werden basierend auf akademischen Noten, Führungsrollen, regionalem Hintergrund und Forschungsbeiträgen vergeben.\n\n    Parameter:\n    grades (list von int): Eine Liste mit zwei Elementen, die die akademischen Noten des Studenten enthält [Endjahresdurchschnitt, Klassenbewertung].\n    leader (str): Ein String ('Y' oder 'N'), der angibt, ob der Student ein Klassensprecher ist.\n    west (str): Ein String ('Y' oder 'N'), der angibt, ob der Student aus einer westlichen Provinz stammt.\n    papers (int): Eine ganze Zahl, die die Anzahl der vom Studenten veröffentlichten Forschungsarbeiten darstellt.\n\n    Rückgabewert:\n    int: Der gesamte Stipendienbetrag, für den der Student berechtigt ist.\n\n    Beispiele:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Im ersten Beispiel wird ein Stipendium für einen Studenten berechnet, der einen Durchschnitt von 87, eine Bewertungsnote von 82 hat,\n    Klassensprecher ist ('Y'), nicht aus der westlichen Provinz stammt ('N') und keine veröffentlichten Arbeiten hat (0). Dieser Student\n    würde insgesamt 4850 Währungseinheiten erhalten.\n\n    Im zweiten Beispiel hat der Student einen Durchschnitt von 88, eine Bewertungsnote von 78, ist kein Klassensprecher ('N'),\n    stammt aus der westlichen Provinz ('Y') und hat 1 Arbeit veröffentlicht. Dieser Student würde insgesamt 9000 Währungseinheiten erhalten.\n    \"\"\"", "ha": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Lissafi jimillar adadin tallafin karatu ga ɗalibi bisa la'akari da nasarorin ilimi da na ƙarin karatu.\n\n    Aikin yana amfani da saitin yanayi don tantance jimillar adadin kuɗin tallafin karatu da ɗalibi zai samu.\n    Ana bayar da tallafin karatu bisa la'akari da maki na ilimi, rawar jagoranci, asalin yanki, da gudunmawar bincike.\n\n    Sigogi:\n    grades (jerin int): Jerin abubuwa biyu da ke ƙunshe da maki na ilimi na ɗalibi [matsakaicin ƙarshen zangon, kimantawa aji].\n    leader (str): Wani rubutu ('Y' ko 'N') da ke nuna idan ɗalibi jagoran aji ne.\n    west (str): Wani rubutu ('Y' ko 'N') da ke nuna idan ɗalibi daga lardin yamma ne.\n    papers (int): Wani lamba da ke wakiltar adadin takardun bincike da ɗalibi ya wallafa.\n\n    Abin da ake dawowa da shi:\n    int: Jimillar adadin tallafin karatu da ɗalibi ya cancanci samu.\n\n    Misalai:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Misali na farko yana lissafin tallafin karatu ga ɗalibi da ke da matsakaicin maki na 87, maki na kimantawa na 82,\n    wanda jagoran aji ne ('Y'), ba daga lardin yamma ba ('N'), kuma ba tare da takardun da aka wallafa ba (0). Wannan ɗalibin\n    zai samu jimillar 4850 na kuɗi.\n\n    A misali na biyu, ɗalibin yana da matsakaicin maki na 88, maki na kimantawa na 78, ba jagoran aji ba ne ('N'),\n    daga lardin yamma ne ('Y'), kuma yana da takarda 1 da aka wallafa. Wannan ɗalibin zai samu jimillar 9000 na kuɗi.\n    \"\"\"", "hi": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    एक छात्र के लिए शैक्षणिक और अतिरिक्त पाठ्यचर्या उपलब्धियों के आधार पर कुल छात्रवृत्ति राशि की गणना करें।\n\n    यह फ़ंक्शन कुछ शर्तों का उपयोग करके यह निर्धारित करता है कि छात्र को कुल कितनी छात्रवृत्ति राशि मिलनी चाहिए।\n    छात्रवृत्तियां शैक्षणिक ग्रेड, नेतृत्व भूमिकाओं, क्षेत्रीय पृष्ठभूमि, और शोध योगदानों के आधार पर प्रदान की जाती हैं।\n\n    पैरामीटर्स:\n    grades (int की सूची): छात्र के शैक्षणिक ग्रेड्स की दो-तत्वों वाली सूची [अवधि के अंत का औसत, कक्षा मूल्यांकन]।\n    leader (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र कक्षा का नेता है या नहीं।\n    west (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र पश्चिमी प्रांत से है या नहीं।\n    papers (int): एक पूर्णांक जो छात्र द्वारा प्रकाशित शोध पत्रों की संख्या को दर्शाता है।\n\n    रिटर्न्स:\n    int: कुल छात्रवृत्ति राशि जो छात्र के लिए पात्र है।\n\n    उदाहरण:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    पहले उदाहरण में, एक छात्र के लिए छात्रवृत्ति की गणना की जाती है जिसका औसत ग्रेड 87 है, मूल्यांकन ग्रेड 82 है,\n    जो कक्षा का नेता है ('Y'), पश्चिमी प्रांत से नहीं है ('N'), और कोई प्रकाशित पत्र नहीं है (0)। इस छात्र को\n    कुल 4850 मुद्रा इकाइयाँ प्राप्त होंगी।\n\n    दूसरे उदाहरण में, छात्र का औसत ग्रेड 88 है, मूल्यांकन ग्रेड 78 है, कक्षा का नेता नहीं है ('N'),\n    पश्चिमी प्रांत से है ('Y'), और 1 पेपर प्रकाशित किया है। इस छात्र को कुल 9000 मुद्रा इकाइयाँ प्राप्त होंगी।\n    \"\"\"", "hu": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Számítsa ki a hallgató ösztöndíjának teljes összegét a tanulmányi és tanórán kívüli eredmények alapján.\n\n    A függvény egy sor feltételt használ annak meghatározására, hogy a hallgató mennyi ösztöndíjra jogosult.\n    Az ösztöndíjak tanulmányi jegyek, vezetői szerepek, regionális háttér és kutatási hozzájárulások alapján kerülnek odaítélésre.\n\n    Paraméterek:\n    grades (list of int): Egy két elemből álló lista, amely a hallgató tanulmányi jegyeit tartalmazza [félév végi átlag, osztályértékelés].\n    leader (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a hallgató osztályvezető-e.\n    west (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a hallgató nyugati tartományból származik-e.\n    papers (int): Egy egész szám, amely a hallgató által publikált kutatási cikkek számát jelzi.\n\n    Visszatérési érték:\n    int: Az összes ösztöndíj összege, amelyre a hallgató jogosult.\n\n    Példák:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Az első példa egy olyan hallgató ösztöndíját számítja ki, akinek az átlagjegye 87, az értékelési jegye 82,\n    osztályvezető ('Y'), nem nyugati tartományból származik ('N'), és nincs publikált cikke (0). Ez a hallgató\n    összesen 4850 pénzegység ösztöndíjat kapna.\n\n    A második példában a hallgató átlagjegye 88, az értékelési jegye 78, nem osztályvezető ('N'),\n    nyugati tartományból származik ('Y'), és 1 publikált cikke van. Ez a hallgató összesen 9000 pénzegység ösztöndíjat kapna.\n    \"\"\"", "es": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Calcular el monto total de la beca para un estudiante basado en logros académicos y extracurriculares.\n\n    La función utiliza un conjunto de condiciones para determinar el monto total de dinero de beca al que un estudiante tiene derecho.\n    Las becas se otorgan en función de las calificaciones académicas, roles de liderazgo, origen regional y contribuciones de investigación.\n\n    Parámetros:\n    grades (list of int): Una lista de dos elementos que contiene las calificaciones académicas del estudiante [promedio de fin de curso, evaluación de clase].\n    leader (str): Una cadena ('Y' o 'N') que indica si el estudiante es líder de clase.\n    west (str): Una cadena ('Y' o 'N') que indica si el estudiante es de una provincia occidental.\n    papers (int): Un entero que representa el número de artículos de investigación publicados por el estudiante.\n\n    Devuelve:\n    int: El monto total de la beca para el que el estudiante es elegible.\n\n    Ejemplos:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    El primer ejemplo calcula una beca para un estudiante con una calificación promedio de 87, una calificación de evaluación de 82,\n    que es líder de clase ('Y'), no es de la provincia occidental ('N'), y sin artículos publicados (0). Este estudiante\n    recibiría un total de 4850 unidades de moneda.\n\n    En el segundo ejemplo, el estudiante tiene una calificación promedio de 88, una calificación de evaluación de 78, no es líder de clase ('N'),\n    es de la provincia occidental ('Y'), y ha publicado 1 artículo. Este estudiante recibiría un total de 9000 unidades de moneda.\n    \"\"\"", "arb": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    حساب إجمالي مبلغ المنحة الدراسية لطالب بناءً على الإنجازات الأكاديمية واللامنهجية.\n\n    تستخدم الدالة مجموعة من الشروط لتحديد إجمالي مبلغ المنحة الدراسية الذي يحق للطالب الحصول عليه.\n    تُمنح المنح الدراسية بناءً على الدرجات الأكاديمية، الأدوار القيادية، الخلفية الإقليمية، والمساهمات البحثية.\n\n    المعاملات:\n    grades (list of int): قائمة تحتوي على عنصرين تمثل الدرجات الأكاديمية للطالب [متوسط نهاية الفصل، تقييم الصف].\n    leader (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب قائد الصف.\n    west (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب من مقاطعة غربية.\n    papers (int): عدد صحيح يمثل عدد الأوراق البحثية المنشورة من قبل الطالب.\n\n    يعيد:\n    int: إجمالي مبلغ المنحة الدراسية الذي يحق للطالب الحصول عليه.\n\n    امثله:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    المثال الأول يحسب منحة دراسية لطالب لديه متوسط درجات 87، ودرجة تقييم 82،\n    وهو قائد الصف ('Y')، وليس من المقاطعة الغربية ('N')، وليس لديه أوراق منشورة (0). سيحصل هذا الطالب\n    على إجمالي 4850 وحدة من العملة.\n\n    في المثال الثاني، الطالب لديه متوسط درجات 88، ودرجة تقييم 78، ليس قائد الصف ('N')،\n    وهو من المقاطعة الغربية ('Y')، ولديه ورقة بحثية منشورة واحدة. سيحصل هذا الطالب على إجمالي 9000 وحدة من العملة.\n    \"\"\"", "sw": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Kuhesabu jumla ya kiasi cha udhamini kwa mwanafunzi kulingana na mafanikio ya kitaaluma na ya ziada.\n\n    Kazi hii inatumia seti ya masharti kuamua jumla ya kiasi cha pesa za udhamini ambacho mwanafunzi anastahili.\n    Udhamini hutolewa kulingana na alama za kitaaluma, majukumu ya uongozi, asili ya kikanda, na michango ya utafiti.\n\n    Vigezo:\n    grades (orodha ya int): Orodha ya vipengele viwili inayoonyesha alama za kitaaluma za mwanafunzi [mwisho wa wastani wa muhula, tathmini ya darasa].\n    leader (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi ni kiongozi wa darasa.\n    west (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi anatoka mkoa wa magharibi.\n    papers (int): Nambari inayoonyesha idadi ya makala za utafiti zilizochapishwa na mwanafunzi.\n\n    Inarejesha:\n    int: Jumla ya kiasi cha udhamini ambacho mwanafunzi anastahili.\n\n    Mifano:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Mfano wa kwanza unahesabu udhamini kwa mwanafunzi mwenye wastani wa alama 87, alama ya tathmini ya 82,\n    ambaye ni kiongozi wa darasa ('Y'), si kutoka mkoa wa magharibi ('N'), na hana makala zilizochapishwa (0). Mwanafunzi huyu\n    atapokea jumla ya vitengo 4850 vya sarafu.\n\n    Katika mfano wa pili, mwanafunzi ana wastani wa alama 88, alama ya tathmini ya 78, si kiongozi wa darasa ('N'),\n    anatoka mkoa wa magharibi ('Y'), na amechapisha makala 1. Mwanafunzi huyu atapokea jumla ya vitengo 9000 vya sarafu.\n    \"\"\"", "tr": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Akademik ve ders dışı başarılar temelinde bir öğrenci için toplam burs miktarını hesaplayın.\n\n    Fonksiyon, bir öğrencinin hak kazandığı toplam burs miktarını belirlemek için bir dizi koşul kullanır.\n    Burslar, akademik notlar, liderlik rolleri, bölgesel geçmiş ve araştırma katkılarına göre verilir.\n\n    Parametreler:\n    grades (list of int): Öğrencinin akademik notlarını içeren iki elemanlı bir liste [dönem sonu ortalaması, sınıf değerlendirmesi].\n    leader (str): Öğrencinin sınıf lideri olup olmadığını belirten bir dize ('Y' veya 'N').\n    west (str): Öğrencinin batı bölgesinden olup olmadığını belirten bir dize ('Y' veya 'N').\n    papers (int): Öğrencinin yayımladığı araştırma makalelerinin sayısını temsil eden bir tamsayı.\n\n    Döndürür:\n    int: Öğrencinin hak kazandığı toplam burs miktarı.\n\n    Örnekler:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    İlk örnek, ortalama notu 87, değerlendirme notu 82 olan, sınıf lideri ('Y'), batı bölgesinden olmayan ('N'),\n    ve yayımlanmış makalesi olmayan (0) bir öğrenci için burs hesaplar. Bu öğrenci toplamda 4850 birim para alacaktır.\n\n    İkinci örnekte, öğrenci ortalama notu 88, değerlendirme notu 78, sınıf lideri değil ('N'),\n    batı bölgesinden ('Y') ve 1 makale yayımlamış. Bu öğrenci toplamda 9000 birim para alacaktır.\n    \"\"\"", "vi": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Tính tổng số tiền học bổng cho một sinh viên dựa trên thành tích học tập và hoạt động ngoại khóa.\n\n    Hàm này sử dụng một tập hợp các điều kiện để xác định tổng số tiền học bổng mà sinh viên được nhận.\n    Học bổng được trao dựa trên điểm học tập, vai trò lãnh đạo, xuất thân vùng miền, và đóng góp nghiên cứu.\n\n    Tham số:\n    grades (list of int): Một danh sách hai phần tử chứa điểm học tập của sinh viên [điểm trung bình cuối kỳ, đánh giá lớp].\n    leader (str): Một chuỗi ('Y' hoặc 'N') chỉ ra liệu sinh viên có phải là lớp trưởng hay không.\n    west (str): Một chuỗi ('Y' hoặc 'N') chỉ ra liệu sinh viên có xuất thân từ tỉnh miền Tây hay không.\n    papers (int): Một số nguyên biểu thị số lượng bài báo nghiên cứu đã được sinh viên công bố.\n\n    Trả về:\n    int: Tổng số tiền học bổng mà sinh viên đủ điều kiện nhận.\n\n    Ví dụ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Ví dụ đầu tiên tính toán học bổng cho một sinh viên có điểm trung bình là 87, điểm đánh giá là 82,\n    là lớp trưởng ('Y'), không xuất thân từ tỉnh miền Tây ('N'), và không có bài báo nào được công bố (0). Sinh viên này\n    sẽ nhận được tổng cộng 4850 đơn vị tiền tệ.\n\n    Trong ví dụ thứ hai, sinh viên có điểm trung bình là 88, điểm đánh giá là 78, không phải là lớp trưởng ('N'),\n    xuất thân từ tỉnh miền Tây ('Y'), và đã công bố 1 bài báo. Sinh viên này sẽ nhận được tổng cộng 9000 đơn vị tiền tệ.\n    \"\"\"", "id": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Menghitung jumlah total beasiswa untuk seorang siswa berdasarkan prestasi akademik dan ekstrakurikuler.\n\n    Fungsi ini menggunakan serangkaian kondisi untuk menentukan jumlah total uang beasiswa yang berhak diterima oleh seorang siswa.\n    Beasiswa diberikan berdasarkan nilai akademik, peran kepemimpinan, latar belakang regional, dan kontribusi penelitian.\n\n    Parameter:\n    grades (list of int): Daftar dua elemen yang berisi nilai akademik siswa [rata-rata akhir semester, evaluasi kelas].\n    leader (str): Sebuah string ('Y' atau 'N') yang menunjukkan apakah siswa adalah pemimpin kelas.\n    west (str): Sebuah string ('Y' atau 'N') yang menunjukkan apakah siswa berasal dari provinsi barat.\n    papers (int): Sebuah bilangan bulat yang mewakili jumlah makalah penelitian yang diterbitkan oleh siswa.\n\n    Mengembalikan:\n    int: Jumlah total beasiswa yang berhak diterima oleh siswa.\n\n    Contoh:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Contoh pertama menghitung beasiswa untuk siswa dengan nilai rata-rata 87, nilai evaluasi 82,\n    yang merupakan pemimpin kelas ('Y'), bukan dari provinsi barat ('N'), dan tidak memiliki makalah yang diterbitkan (0). Siswa ini\n    akan menerima total 4850 unit mata uang.\n\n    Dalam contoh kedua, siswa memiliki nilai rata-rata 88, nilai evaluasi 78, bukan pemimpin kelas ('N'),\n    berasal dari provinsi barat ('Y'), dan telah menerbitkan 1 makalah. Siswa ini akan menerima total 9000 unit mata uang.\n    \"\"\"", "ja": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    学業および課外活動の成果に基づいて、学生の奨学金の総額を計算します。\n\n    この関数は、一連の条件を使用して、学生が受け取る資格のある奨学金の総額を決定します。\n    奨学金は、学業成績、リーダーシップの役割、地域の背景、研究の貢献に基づいて授与されます。\n\n    パラメータ:\n    grades (list of int): 学生の学業成績を含む2要素のリスト [学期末平均, クラス評価]。\n    leader (str): 学生がクラスリーダーであるかを示す文字列 ('Y' または 'N')。\n    west (str): 学生が西部の州出身であるかを示す文字列 ('Y' または 'N')。\n    papers (int): 学生が発表した研究論文の数を表す整数。\n\n    戻り値:\n    int: 学生が受け取る資格のある奨学金の総額。\n\n    例:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    最初の例では、平均成績が87、評価成績が82の学生で、クラスリーダー ('Y') であり、西部の州出身ではない ('N')、発表した論文がない (0) 場合の奨学金を計算します。この学生は合計で4850単位の通貨を受け取ります。\n\n    2番目の例では、平均成績が88、評価成績が78で、クラスリーダーではない ('N')、西部の州出身 ('Y')、1つの論文を発表した学生の奨学金を計算します。この学生は合計で9000単位の通貨を受け取ります。\n    \"\"\"", "ko": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    학생의 학업 및 과외 활동 성과를 기반으로 총 장학금 금액을 계산합니다.\n\n    이 함수는 일련의 조건을 사용하여 학생이 받을 수 있는 총 장학금 금액을 결정합니다.\n    장학금은 학업 성적, 리더십 역할, 지역 배경 및 연구 기여도에 따라 수여됩니다.\n\n    매개변수:\n    grades (list of int): 학생의 학업 성적을 포함하는 두 요소 리스트 [학기말 평균, 수업 평가].\n    leader (str): 학생이 반장인지 여부를 나타내는 문자열 ('Y' 또는 'N').\n    west (str): 학생이 서부 지방 출신인지 여부를 나타내는 문자열 ('Y' 또는 'N').\n    papers (int): 학생이 발표한 연구 논문의 수를 나타내는 정수.\n\n    반환값:\n    int: 학생이 받을 수 있는 총 장학금 금액.\n\n    예시:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    첫 번째 예시는 평균 성적이 87이고, 평가 성적이 82인 학생에 대한 장학금을 계산합니다.\n    이 학생은 반장('Y')이며, 서부 지방 출신이 아니고('N'), 발표한 논문이 없습니다(0). 이 학생은\n    총 4850 단위의 통화를 받게 됩니다.\n\n    두 번째 예시에서는 학생의 평균 성적이 88이고, 평가 성적이 78이며, 반장이 아니고('N'),\n    서부 지방 출신이며('Y'), 1개의 논문을 발표했습니다. 이 학생은 총 9000 단위의 통화를 받게 됩니다.\n    \"\"\"", "ml": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    ഒരു വിദ്യാർത്ഥിയുടെ അക്കാദമിക്, സഹപാഠിക നേട്ടങ്ങളെ അടിസ്ഥാനമാക്കി മൊത്തം സ്കോളർഷിപ്പ് തുക കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ഒരു വിദ്യാർത്ഥിക്ക് ലഭിക്കാവുന്ന മൊത്തം സ്കോളർഷിപ്പ് തുക നിർണ്ണയിക്കാൻ ഒരു സജ്ജീകരണങ്ങൾ ഉപയോഗിക്കുന്നു.\n    അക്കാദമിക് ഗ്രേഡുകൾ, നേതൃപാടവങ്ങൾ, പ്രാദേശിക പശ്ചാത്തലം, ഗവേഷണ സംഭാവനകൾ എന്നിവയെ അടിസ്ഥാനമാക്കിയുള്ള സ്കോളർഷിപ്പുകൾ.\n\n    പാരാമീറ്ററുകൾ:\n    grades (list of int): വിദ്യാർത്ഥിയുടെ അക്കാദമിക് ഗ്രേഡുകൾ [കാലാവധി അവസാനത്തെ ശരാശരി, ക്ലാസ് മൂല്യനിർണ്ണയം] അടങ്ങിയ രണ്ട് ഘടകങ്ങളുള്ള പട്ടിക.\n    leader (str): വിദ്യാർത്ഥി ക്ലാസ് ലീഡറാണോ എന്നത് സൂചിപ്പിക്കുന്ന ഒരു സ്ട്രിംഗ് ('Y' അല്ലെങ്കിൽ 'N').\n    west (str): വിദ്യാർത്ഥി പടിഞ്ഞാറൻ പ്രവിശ്യയിൽ നിന്നാണോ എന്നത് സൂചിപ്പിക്കുന്ന ഒരു സ്ട്രിംഗ് ('Y' അല്ലെങ്കിൽ 'N').\n    papers (int): വിദ്യാർത്ഥി പ്രസിദ്ധീകരിച്ച ഗവേഷണ പ്രബന്ധങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\n    മടക്കങ്ങൾ:\n    int: വിദ്യാർത്ഥിക്ക് അർഹമായ മൊത്തം സ്കോളർഷിപ്പ് തുക.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    ആദ്യ ഉദാഹരണം ശരാശരി ഗ്രേഡ് 87, മൂല്യനിർണ്ണയ ഗ്രേഡ് 82, ക്ലാസ് ലീഡറാണ് ('Y'), പടിഞ്ഞാറൻ പ്രവിശ്യയിൽ നിന്നല്ല ('N'), പ്രസിദ്ധീകരിച്ച പ്രബന്ധങ്ങൾ ഇല്ല (0) എന്ന വിദ്യാർത്ഥിക്ക് സ്കോളർഷിപ്പ് കണക്കാക്കുന്നു. ഈ വിദ്യാർത്ഥിക്ക് 4850 കറൻസി യൂണിറ്റുകളുടെ മൊത്തം തുക ലഭിക്കും.\n\n    രണ്ടാം ഉദാഹരണത്തിൽ, വിദ്യാർത്ഥിക്ക് ശരാശരി ഗ്രേഡ് 88, മൂല്യനിർണ്ണയ ഗ്രേഡ് 78, ക്ലാസ് ലീഡറല്ല ('N'), പടിഞ്ഞാറൻ പ്രവിശ്യയിൽ നിന്നാണ് ('Y'), 1 പ്രബന്ധം പ്രസിദ്ധീകരിച്ചിട്ടുണ്ട്. ഈ വിദ്യാർത്ഥിക്ക് 9000 കറൻസി യൂണിറ്റുകളുടെ മൊത്തം തുക ലഭിക്കും.\n    \"\"\"", "fa": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    محاسبه مقدار کل بورسیه برای یک دانش‌آموز بر اساس دستاوردهای تحصیلی و فوق‌برنامه.\n\n    این تابع از مجموعه‌ای از شرایط برای تعیین مقدار کل پول بورسیه‌ای که یک دانش‌آموز مستحق آن است استفاده می‌کند.\n    بورسیه‌ها بر اساس نمرات تحصیلی، نقش‌های رهبری، پیشینه منطقه‌ای و مشارکت‌های پژوهشی اعطا می‌شوند.\n\n    پارامترها:\n    grades (لیستی از اعداد صحیح): یک لیست دو عنصری که نمرات تحصیلی دانش‌آموز را شامل می‌شود [میانگین پایان ترم، ارزیابی کلاسی].\n    leader (رشته): یک رشته ('Y' یا 'N') که نشان می‌دهد آیا دانش‌آموز رهبر کلاس است یا خیر.\n    west (رشته): یک رشته ('Y' یا 'N') که نشان می‌دهد آیا دانش‌آموز از استان‌های غربی است یا خیر.\n    papers (عدد صحیح): یک عدد صحیح که نشان‌دهنده تعداد مقالات پژوهشی منتشر شده توسط دانش‌آموز است.\n\n    بازگشت:\n    int: مقدار کل بورسیه‌ای که دانش‌آموز واجد شرایط آن است.\n\n    مثال‌ها:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    در مثال اول، بورسیه برای دانش‌آموزی با میانگین نمره 87، نمره ارزیابی 82،\n    که رهبر کلاس است ('Y')، از استان‌های غربی نیست ('N')، و هیچ مقاله‌ای منتشر نکرده است (0) محاسبه می‌شود. این دانش‌آموز\n    مجموعاً 4850 واحد پول دریافت می‌کند.\n\n    در مثال دوم، دانش‌آموز میانگین نمره 88، نمره ارزیابی 78 دارد، رهبر کلاس نیست ('N')،\n    از استان‌های غربی است ('Y')، و 1 مقاله منتشر کرده است. این دانش‌آموز مجموعاً 9000 واحد پول دریافت می‌کند.\n    \"\"\""}, "canonical_solution": "    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship", "instruction": {"en": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nՏվեք Python կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nBa da takaitaccen bayanin harshen dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılacak şekilde olmalıdır.", "vi": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nPythonコードの内容を日本語で簡潔に説明するドキュメンテーション文字列（docstring）を、最大500文字で提供してください。", "ko": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nPython കോഡിന് 500 അക്ഷരങ്ങൾക്കുള്ളിൽ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_calculate_scholarship():\n    # Test case 1: Student meets multiple scholarship criteria\n    grades1 = [90, 85]  # Both grades are high\n    leader1 = 'Y'  # Is a leader\n    west1 = 'Y'  # Is from the West\n    papers1 = 2  # Has published papers\n    expected_scholarship1 = 13850  # Should receive multiple scholarships\n    assert calculate_scholarship(grades1, leader1, west1,\n                                 papers1) == expected_scholarship1, f\"Test case 1 failed. Expected {expected_scholarship1}, got {calculate_scholarship(grades1, leader1, west1, papers1)}\"\n\n    # Test case 2: Student meets one scholarship criteria\n    grades2 = [82, 70]  # Only the first grade is high enough\n    leader2 = 'N'  # Is not a leader\n    west2 = 'N'  # Is not from the West\n    papers2 = 1  # Has published papers\n    expected_scholarship2 = 8000  # Should receive scholarship for first grade and papers\n    assert calculate_scholarship(grades2, leader2, west2,\n                                 papers2) == expected_scholarship2, f\"Test case 2 failed. Expected {expected_scholarship2}, got {calculate_scholarship(grades2, leader2, west2, papers2)}\"\n\n    # Test case 3: Student does not meet any scholarship criteria\n    grades3 = [75, 75]  # Both grades are below the threshold\n    leader3 = 'N'  # Is not a leader\n    west3 = 'N'  # Is not from the West\n    papers3 = 0  # Has no published papers\n    expected_scholarship3 = 0  # Should not receive any scholarships\n    assert calculate_scholarship(grades3, leader3, west3,\n                                 papers3) == expected_scholarship3, f\"Test case 3 failed. Expected {expected_scholarship3}, got {calculate_scholarship(grades3, leader3, west3, papers3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\n\n\ntest_calculate_scholarship()", "entry_point": "calculate_scholarship", "signature": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:", "docstring": {"en": "Calculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\nThe function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\nScholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\nParameters:\ngrades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\nleader (str): A string ('Y' or 'N') indicating if the student is a class leader.\nwest (str): A string ('Y' or 'N') indicating if the student is from a western province.\npapers (int): An integer representing the number of research papers published by the student.\n\nReturns:\nint: The total scholarship amount the student is eligible for.\n\nExamples:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nThe first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\nwho is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\nwould receive a total of 4850 units of currency.\n\nIn the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\nis from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.", "sq": "Llogarit shumën totale të bursës për një student bazuar në arritjet akademike dhe jashtëshkollore.\n\nFunksioni përdor një grup kushtesh për të përcaktuar shumën totale të parave të bursës që një student ka të drejtë të marrë.\nBursat jepen bazuar në notat akademike, rolet drejtuese, prejardhjen rajonale dhe kontributet në kërkime.\n\nParametrat:\ngrades (list of int): Një listë me dy elemente që përmban notat akademike të studentit [mesatarja në fund të periudhës, vlerësimi i klasës].\nleader (str): Një varg ('Y' ose 'N') që tregon nëse studenti është drejtues i klasës.\nwest (str): Një varg ('Y' ose 'N') që tregon nëse studenti është nga një provincë perëndimore.\npapers (int): Një numër i plotë që përfaqëson numrin e punimeve kërkimore të publikuara nga studenti.\n\nKthen:\nint: Shuma totale e bursës për të cilën studenti ka të drejtë.\n\nShembuj:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nShembulli i parë llogarit një bursë për një student me një notë mesatare prej 87, një notë vlerësimi prej 82,\ni cili është drejtues i klasës ('Y'), nuk është nga provinca perëndimore ('N'), dhe pa punime të publikuara (0). Ky student\ndo të merrte një total prej 4850 njësi monetare.\n\nNë shembullin e dytë, studenti ka një notë mesatare prej 88, një notë vlerësimi prej 78, nuk është drejtues i klasës ('N'),\nështë nga provinca perëndimore ('Y'), dhe ka publikuar 1 punim. Ky student do të merrte një total prej 9000 njësi monetare.", "hy": "Հաշվարկել ուսանողի ընդհանուր կրթաթոշակի գումարը՝ հիմնված ակադեմիական և արտադասարանական նվաճումների վրա։\n\nՖունկցիան օգտագործում է պայմանների մի շարք՝ որոշելու համար ուսանողի իրավունք ունեցող կրթաթոշակի ընդհանուր գումարը։ Կրթաթոշակները շնորհվում են՝ հիմնված ակադեմիական գնահատականների, առաջնորդական դերերի, տարածաշրջանային ծագման և հետազոտական ներդրումների վրա։\n\nՊարամետրեր:\ngrades (ցանկ int): Երկու տարրից բաղկացած ցանկ, որը պարունակում է ուսանողի ակադեմիական գնահատականները [կիսամյակի վերջի միջին, դասի գնահատում]։\nleader (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, արդյոք ուսանողը դասի առաջնորդ է։\nwest (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, արդյոք ուսանողը արևմտյան մարզից է։\npapers (int): Ամբողջ թիվ, որը ներկայացնում է ուսանողի կողմից հրապարակված հետազոտական հոդվածների քանակը։\n\nՎերադարձնում է:\nint: Կրթաթոշակի ընդհանուր գումարը, որի համար ուսանողը իրավունք ունի։\n\nՕրինակներ:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nԱռաջին օրինակում հաշվարկվում է կրթաթոշակ այն ուսանողի համար, որի միջին գնահատականը 87 է, գնահատման գնահատականը՝ 82,\nով դասի առաջնորդ է ('Y'), արևմտյան մարզից չէ ('N') և չունի հրապարակված հոդվածներ (0)։ Այս ուսանողը\nկստանա ընդհանուր 4850 արժույթի միավոր։\n\nԵրկրորդ օրինակում ուսանողը ունի միջին գնահատական 88, գնահատման գնահատական 78, դասի առաջնորդ չէ ('N'),\nարևմտյան մարզից է ('Y') և ունի 1 հրապարակված հոդված։ Այս ուսանողը կստանա ընդհանուր 9000 արժույթի միավոր։", "bn": "একজন শিক্ষার্থীর জন্য একাডেমিক এবং অতিরিক্ত পাঠক্রমিক অর্জনের ভিত্তিতে মোট বৃত্তির পরিমাণ গণনা করুন।\n\nফাংশনটি শিক্ষার্থী কতটা বৃত্তির অর্থ পাওয়ার যোগ্য তা নির্ধারণ করতে একটি শর্তের সেট ব্যবহার করে।\nএকাডেমিক গ্রেড, নেতৃত্বের ভূমিকা, আঞ্চলিক পটভূমি এবং গবেষণা অবদানের ভিত্তিতে বৃত্তি প্রদান করা হয়।\n\nপ্যারামিটারসমূহ:\ngrades (list of int): শিক্ষার্থীর একাডেমিক গ্রেডের একটি দুই-উপাদান তালিকা [টার্মের শেষের গড়, শ্রেণীর মূল্যায়ন]।\nleader (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী শ্রেণীর নেতা কিনা।\nwest (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী পশ্চিম প্রদেশের কিনা।\npapers (int): শিক্ষার্থীর দ্বারা প্রকাশিত গবেষণাপত্রের সংখ্যা নির্দেশকারী একটি পূর্ণসংখ্যা।\n\nরিটার্নস:\nint: শিক্ষার্থী যে মোট বৃত্তির পরিমাণের জন্য যোগ্য তা।\n\nউদাহরণসমূহ:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nপ্রথম উদাহরণটি এমন একজন শিক্ষার্থীর জন্য বৃত্তি গণনা করে যার গড় গ্রেড 87, মূল্যায়ন গ্রেড 82,\nযিনি শ্রেণীর নেতা ('Y'), পশ্চিম প্রদেশের নন ('N'), এবং কোন প্রকাশিত পত্র নেই (0)। এই শিক্ষার্থী\nমোট 4850 মুদ্রার ইউনিট পাবেন।\n\nদ্বিতীয় উদাহরণে, শিক্ষার্থীর গড় গ্রেড 88, মূল্যায়ন গ্রেড 78, শ্রেণীর নেতা নন ('N'),\nপশ্চিম প্রদেশের ('Y'), এবং 1টি পত্র প্রকাশ করেছেন। এই শিক্ষার্থী মোট 9000 মুদ্রার ইউনিট পাবেন।", "bg": "Изчисляване на общата сума на стипендията за студент въз основа на академични и извънкласни постижения.\n\nФункцията използва набор от условия, за да определи общата сума на стипендията, на която студентът има право.\nСтипендиите се отпускат въз основа на академични оценки, лидерски роли, регионален произход и научни приноси.\n\nПараметри:\ngrades (list of int): Двуелементен списък, съдържащ академичните оценки на студента [среден успех в края на срока, оценка от клас].\nleader (str): Низ ('Y' или 'N'), указващ дали студентът е класен лидер.\nwest (str): Низ ('Y' или 'N'), указващ дали студентът е от западна провинция.\npapers (int): Цяло число, представляващо броя на публикуваните научни статии от студента.\n\nВръща:\nint: Общата сума на стипендията, за която студентът има право.\n\nПримери:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nПървият пример изчислява стипендия за студент със средна оценка 87, оценка от оценяване 82,\nкойто е класен лидер ('Y'), не е от западна провинция ('N') и няма публикувани статии (0). Този студент\nще получи общо 4850 единици валута.\n\nВъв втория пример студентът има средна оценка 88, оценка от оценяване 78, не е класен лидер ('N'),\nе от западна провинция ('Y') и има публикувана 1 статия. Този студент ще получи общо 9000 единици валута.", "zh": "计算学生基于学术和课外成就的总奖学金金额。\n\n该函数使用一组条件来确定学生有权获得的奖学金总金额。奖学金根据学术成绩、领导角色、地区背景和研究贡献授予。\n\n参数：\ngrades (list of int): 一个包含学生学术成绩的两元素列表 [学期末平均分, 班级评估分]。\nleader (str): 一个字符串 ('Y' 或 'N')，表示学生是否是班级领导。\nwest (str): 一个字符串 ('Y' 或 'N')，表示学生是否来自西部省份。\npapers (int): 一个整数，表示学生发表的研究论文数量。\n\n返回：\nint: 学生有资格获得的奖学金总金额。\n\n例子：\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\n第一个例子计算了一个平均成绩为87，评估成绩为82的学生的奖学金，该学生是班级领导 ('Y')，不来自西部省份 ('N')，且没有发表论文 (0)。该学生将获得总计4850单位的货币。\n\n在第二个例子中，学生的平均成绩为88，评估成绩为78，不是班级领导 ('N')，来自西部省份 ('Y')，并发表了1篇论文。该学生将获得总计9000单位的货币。", "fr": "Calculer le montant total de la bourse pour un étudiant en fonction des réalisations académiques et extrascolaires.\n\nLa fonction utilise un ensemble de conditions pour déterminer le montant total de la bourse auquel un étudiant a droit. Les bourses sont attribuées en fonction des notes académiques, des rôles de leadership, de l'origine régionale et des contributions à la recherche.\n\nParamètres :\ngrades (list of int): Une liste de deux éléments contenant les notes académiques de l'étudiant [moyenne de fin de trimestre, évaluation de classe].\nleader (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est un leader de classe.\nwest (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est originaire d'une province de l'ouest.\npapers (int): Un entier représentant le nombre de publications de recherche de l'étudiant.\n\nRetourne :\nint: Le montant total de la bourse auquel l'étudiant est éligible.\n\nExemples :\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nLe premier exemple calcule une bourse pour un étudiant avec une moyenne de 87, une note d'évaluation de 82,\nqui est un leader de classe ('Y'), n'est pas originaire de la province de l'ouest ('N'), et n'a pas de publications (0). Cet étudiant\nrecevrait un total de 4850 unités de monnaie.\n\nDans le deuxième exemple, l'étudiant a une moyenne de 88, une note d'évaluation de 78, n'est pas un leader de classe ('N'),\nest originaire de la province de l'ouest ('Y'), et a publié 1 article. Cet étudiant recevrait un total de 9000 unités de monnaie.", "de": "Berechnen Sie den gesamten Stipendienbetrag für einen Studenten basierend auf akademischen und außerschulischen Leistungen.\n\nDie Funktion verwendet eine Reihe von Bedingungen, um den Gesamtbetrag des Stipendiengeldes zu bestimmen, auf den ein Student Anspruch hat. Stipendien werden basierend auf akademischen Noten, Führungsrollen, regionalem Hintergrund und Forschungsbeiträgen vergeben.\n\nParameter:\ngrades (list von int): Eine Liste mit zwei Elementen, die die akademischen Noten des Studenten enthält [Endjahresdurchschnitt, Klassenbewertung].\nleader (str): Ein String ('Y' oder 'N'), der angibt, ob der Student ein Klassenleiter ist.\nwest (str): Ein String ('Y' oder 'N'), der angibt, ob der Student aus einer westlichen Provinz stammt.\npapers (int): Eine ganze Zahl, die die Anzahl der vom Studenten veröffentlichten Forschungsarbeiten darstellt.\n\nRückgabewert:\nint: Der gesamte Stipendienbetrag, für den der Student berechtigt ist.\n\nBeispiele:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nIm ersten Beispiel wird ein Stipendium für einen Studenten mit einem Durchschnitt von 87, einer Bewertungsnote von 82,\nder ein Klassenleiter ist ('Y'), nicht aus der westlichen Provinz stammt ('N') und keine veröffentlichten Arbeiten hat (0), berechnet. Dieser Student\nwürde insgesamt 4850 Währungseinheiten erhalten.\n\nIm zweiten Beispiel hat der Student einen Durchschnitt von 88, eine Bewertungsnote von 78, ist kein Klassenleiter ('N'),\nstammt aus der westlichen Provinz ('Y') und hat 1 Arbeit veröffentlicht. Dieser Student würde insgesamt 9000 Währungseinheiten erhalten.", "ha": "Ƙididdige jimillar adadin tallafin karatu ga ɗalibi bisa nasarorin karatu da na ƙarin ayyuka.\n\nAikin yana amfani da saitin yanayi don tantance jimillar adadin kuɗin tallafin karatu da ɗalibi zai cancanci samu. Ana bayar da tallafin karatu bisa ga maki na karatu, rawar jagoranci, asalin yanki, da gudummawar bincike.\n\nSigogi:\ngrades (jerin int): Jerin abubuwa guda biyu da ke ƙunshe da maki na karatun ɗalibi [matsakaicin ƙarshen zangon, kimantawar aji].\nleader (str): Wani kirtani ('Y' ko 'N') da ke nuna ko ɗalibin jagoran aji ne.\nwest (str): Wani kirtani ('Y' ko 'N') da ke nuna ko ɗalibin daga yanki na yamma ne.\npapers (int): Wani lamba da ke wakiltar adadin takardun bincike da ɗalibin ya wallafa.\n\nDawowa:\nint: Jimillar adadin tallafin karatu da ɗalibin ya cancanci samu.\n\nMisalai:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nMisalin farko yana ƙididdige tallafin karatu ga ɗalibi da ke da matsakaicin maki na 87, maki na kimantawa na 82,\nwanda jagoran aji ne ('Y'), ba daga yanki na yamma ba ('N'), kuma ba tare da takardun da aka wallafa ba (0). Wannan ɗalibin\nzai sami jimillar 4850 raka'a na kuɗi.\n\nA cikin misali na biyu, ɗalibin yana da matsakaicin maki na 88, maki na kimantawa na 78, ba jagoran aji ba ne ('N'),\ndaga yanki na yamma ('Y'), kuma ya wallafa takarda 1. Wannan ɗalibin zai sami jimillar 9000 raka'a na kuɗi.", "hi": "छात्र के अकादमिक और अतिरिक्त पाठ्यचर्या उपलब्धियों के आधार पर कुल छात्रवृत्ति राशि की गणना करें।\n\nयह फ़ंक्शन यह निर्धारित करने के लिए कुछ शर्तों का उपयोग करता है कि छात्र को कुल कितनी छात्रवृत्ति राशि मिलनी चाहिए। छात्रवृत्तियां अकादमिक ग्रेड, नेतृत्व भूमिकाओं, क्षेत्रीय पृष्ठभूमि, और अनुसंधान योगदान के आधार पर प्रदान की जाती हैं।\n\nपैरामीटर्स:\ngrades (list of int): छात्र के अकादमिक ग्रेड की एक दो-तत्वों वाली सूची [अंतिम अवधि का औसत, कक्षा मूल्यांकन]।\nleader (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र कक्षा नेता है या नहीं।\nwest (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र पश्चिमी प्रांत से है या नहीं।\npapers (int): एक पूर्णांक जो छात्र द्वारा प्रकाशित शोध पत्रों की संख्या का प्रतिनिधित्व करता है।\n\nवापसी:\nint: कुल छात्रवृत्ति राशि जो छात्र के लिए पात्र है।\n\nउदाहरण:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nपहले उदाहरण में, एक छात्र के लिए छात्रवृत्ति की गणना की जाती है जिसका औसत ग्रेड 87 है, मूल्यांकन ग्रेड 82 है, जो कक्षा नेता है ('Y'), जो पश्चिमी प्रांत से नहीं है ('N'), और जिसके कोई प्रकाशित पत्र नहीं हैं (0)। इस छात्र को कुल 4850 मुद्रा इकाइयां प्राप्त होंगी।\n\nदूसरे उदाहरण में, छात्र का औसत ग्रेड 88 है, मूल्यांकन ग्रेड 78 है, वह कक्षा नेता नहीं है ('N'), वह पश्चिमी प्रांत से है ('Y'), और उसने 1 पत्र प्रकाशित किया है। इस छात्र को कुल 9000 मुद्रा इकाइयां प्राप्त होंगी।", "hu": "Számítsa ki a hallgató összes ösztöndíj összegét tanulmányi és tanórán kívüli eredmények alapján.\n\nA függvény egy sor feltételt használ annak meghatározására, hogy a hallgató mennyi ösztöndíjra jogosult.\nAz ösztöndíjakat tanulmányi eredmények, vezetői szerepek, regionális háttér és kutatási hozzájárulások alapján ítélik oda.\n\nParaméterek:\ngrades (list of int): Egy kételemű lista, amely tartalmazza a hallgató tanulmányi eredményeit [félév végi átlag, osztályértékelés].\nleader (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a hallgató osztályvezető-e.\nwest (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a hallgató nyugati tartományból származik-e.\npapers (int): Egy egész szám, amely a hallgató által publikált kutatási cikkek számát jelöli.\n\nVisszatérési érték:\nint: Az összes ösztöndíj összeg, amelyre a hallgató jogosult.\n\nPéldák:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nAz első példa egy olyan hallgató ösztöndíját számítja ki, akinek az átlaga 87, az értékelési jegye 82,\nosztályvezető ('Y'), nem nyugati tartományból származik ('N'), és nincs publikált cikke (0). Ez a hallgató\nösszesen 4850 pénzegységet kapna.\n\nA második példában a hallgató átlaga 88, az értékelési jegye 78, nem osztályvezető ('N'),\nnyugati tartományból származik ('Y'), és 1 publikált cikke van. Ez a hallgató összesen 9000 pénzegységet kapna.", "es": "Calcular la cantidad total de beca para un estudiante basado en logros académicos y extracurriculares.\n\nLa función utiliza un conjunto de condiciones para determinar la cantidad total de dinero de beca a la que un estudiante tiene derecho.\nLas becas se otorgan en función de las calificaciones académicas, roles de liderazgo, origen regional y contribuciones a la investigación.\n\nParámetros:\ngrades (list of int): Una lista de dos elementos que contiene las calificaciones académicas del estudiante [promedio de fin de curso, evaluación de clase].\nleader (str): Una cadena ('Y' o 'N') que indica si el estudiante es líder de clase.\nwest (str): Una cadena ('Y' o 'N') que indica si el estudiante es de una provincia occidental.\npapers (int): Un entero que representa el número de artículos de investigación publicados por el estudiante.\n\nDevuelve:\nint: La cantidad total de beca para la que el estudiante es elegible.\n\nEjemplos:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nEl primer ejemplo calcula una beca para un estudiante con una calificación promedio de 87, una calificación de evaluación de 82,\nque es líder de clase ('Y'), no es de la provincia occidental ('N'), y sin artículos publicados (0). Este estudiante\nrecibiría un total de 4850 unidades de moneda.\n\nEn el segundo ejemplo, el estudiante tiene una calificación promedio de 88, una calificación de evaluación de 78, no es líder de clase ('N'),\nes de la provincia occidental ('Y'), y ha publicado 1 artículo. Este estudiante recibiría un total de 9000 unidades de moneda.", "arb": "حساب إجمالي مبلغ المنحة الدراسية لطالب بناءً على الإنجازات الأكاديمية واللامنهجية.\n\nتستخدم الدالة مجموعة من الشروط لتحديد إجمالي مبلغ المنحة الدراسية الذي يحق للطالب الحصول عليه. تُمنح المنح الدراسية بناءً على الدرجات الأكاديمية، الأدوار القيادية، الخلفية الإقليمية، والمساهمات البحثية.\n\nالمعلمات:\ngrades (list of int): قائمة تحتوي على عنصرين تحتوي على الدرجات الأكاديمية للطالب [متوسط نهاية الفصل، تقييم الصف].\nleader (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب قائدًا للصف.\nwest (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب من مقاطعة غربية.\npapers (int): عدد صحيح يمثل عدد الأبحاث المنشورة من قبل الطالب.\n\nالقيم المعادة:\nint: إجمالي مبلغ المنحة الدراسية الذي يحق للطالب الحصول عليه.\n\nأمثلة:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nالمثال الأول يحسب منحة دراسية لطالب لديه متوسط درجة 87، ودرجة تقييم 82، وهو قائد للصف ('Y')، وليس من المقاطعة الغربية ('N')، وليس لديه أبحاث منشورة (0). هذا الطالب سيحصل على إجمالي 4850 وحدة من العملة.\n\nفي المثال الثاني، الطالب لديه متوسط درجة 88، ودرجة تقييم 78، ليس قائدًا للصف ('N')، من المقاطعة الغربية ('Y')، ولديه بحث منشور واحد. هذا الطالب سيحصل على إجمالي 9000 وحدة من العملة.", "sw": "Hesabu jumla ya kiasi cha udhamini kwa mwanafunzi kulingana na mafanikio ya kitaaluma na ya ziada.\n\nKazi hii inatumia seti ya masharti kuamua jumla ya kiasi cha pesa za udhamini ambacho mwanafunzi anastahili.\nUdhamini hutolewa kulingana na alama za kitaaluma, nafasi za uongozi, asili ya kikanda, na michango ya utafiti.\n\nVigezo:\ngrades (list of int): Orodha ya vipengele viwili inayoonyesha alama za kitaaluma za mwanafunzi [wastani wa mwisho wa muhula, tathmini ya darasa].\nleader (str): Mfuatano wa herufi ('Y' au 'N') unaoonyesha kama mwanafunzi ni kiongozi wa darasa.\nwest (str): Mfuatano wa herufi ('Y' au 'N') unaoonyesha kama mwanafunzi anatoka mkoa wa magharibi.\npapers (int): Nambari inayoonyesha idadi ya makala za utafiti zilizochapishwa na mwanafunzi.\n\nRudisha:\nint: Jumla ya kiasi cha udhamini ambacho mwanafunzi anastahili.\n\nMifano:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nMfano wa kwanza unahesabu udhamini kwa mwanafunzi mwenye wastani wa alama 87, alama ya tathmini 82,\nambaye ni kiongozi wa darasa ('Y'), si kutoka mkoa wa magharibi ('N'), na hana makala zilizochapishwa (0). Mwanafunzi huyu\nangepokea jumla ya vitengo 4850 vya sarafu.\n\nKatika mfano wa pili, mwanafunzi ana wastani wa alama 88, alama ya tathmini 78, si kiongozi wa darasa ('N'),\nanatoka mkoa wa magharibi ('Y'), na amechapisha makala 1. Mwanafunzi huyu angepokea jumla ya vitengo 9000 vya sarafu.", "tr": "Bir öğrencinin akademik ve ders dışı başarılarına dayalı toplam burs miktarını hesaplayın.\n\nFonksiyon, bir öğrencinin hak kazandığı toplam burs miktarını belirlemek için bir dizi koşul kullanır.\nBurslar akademik notlar, liderlik rolleri, bölgesel geçmiş ve araştırma katkılarına göre verilir.\n\nParametreler:\ngrades (list of int): Öğrencinin akademik notlarını içeren iki elemanlı bir liste [dönem sonu ortalaması, sınıf değerlendirmesi].\nleader (str): Öğrencinin sınıf lideri olup olmadığını belirten bir dize ('Y' veya 'N').\nwest (str): Öğrencinin batı bölgesinden olup olmadığını belirten bir dize ('Y' veya 'N').\npapers (int): Öğrencinin yayımladığı araştırma makalelerinin sayısını temsil eden bir tamsayı.\n\nDöndürülenler:\nint: Öğrencinin hak kazandığı toplam burs miktarı.\n\nÖrnekler:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nİlk örnek, ortalama notu 87, değerlendirme notu 82 olan, sınıf lideri ('Y'), batı bölgesinden olmayan ('N') ve yayımlanmış makalesi olmayan (0) bir öğrenci için burs hesaplar. Bu öğrenci toplamda 4850 birim para alacaktır.\n\nİkinci örnekte, öğrenci ortalama notu 88, değerlendirme notu 78, sınıf lideri değil ('N'), batı bölgesinden ('Y') ve 1 makale yayımlamış. Bu öğrenci toplamda 9000 birim para alacaktır.", "vi": "Tính tổng số tiền học bổng cho một sinh viên dựa trên thành tích học tập và hoạt động ngoại khóa.\n\nHàm sử dụng một tập hợp các điều kiện để xác định tổng số tiền học bổng mà sinh viên được hưởng. Học bổng được trao dựa trên điểm số học tập, vai trò lãnh đạo, xuất thân vùng miền và đóng góp nghiên cứu.\n\nTham số:\ngrades (list of int): Một danh sách hai phần tử chứa điểm số học tập của sinh viên [trung bình cuối kỳ, đánh giá lớp].\nleader (str): Một chuỗi ('Y' hoặc 'N') chỉ ra nếu sinh viên là lớp trưởng.\nwest (str): Một chuỗi ('Y' hoặc 'N') chỉ ra nếu sinh viên đến từ một tỉnh miền Tây.\npapers (int): Một số nguyên đại diện cho số lượng bài báo nghiên cứu được sinh viên công bố.\n\nTrả về:\nint: Tổng số tiền học bổng mà sinh viên đủ điều kiện nhận.\n\nVí dụ:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nVí dụ đầu tiên tính toán học bổng cho một sinh viên có điểm trung bình là 87, điểm đánh giá là 82,\nlà lớp trưởng ('Y'), không đến từ tỉnh miền Tây ('N'), và không có bài báo công bố (0). Sinh viên này\nsẽ nhận được tổng cộng 4850 đơn vị tiền tệ.\n\nTrong ví dụ thứ hai, sinh viên có điểm trung bình là 88, điểm đánh giá là 78, không phải là lớp trưởng ('N'),\nđến từ tỉnh miền Tây ('Y'), và đã công bố 1 bài báo. Sinh viên này sẽ nhận được tổng cộng 9000 đơn vị tiền tệ.", "id": "Hitung jumlah total beasiswa untuk seorang siswa berdasarkan prestasi akademik dan ekstrakurikuler.\n\nFungsi ini menggunakan serangkaian kondisi untuk menentukan jumlah total uang beasiswa yang berhak diterima oleh seorang siswa. Beasiswa diberikan berdasarkan nilai akademik, peran kepemimpinan, latar belakang regional, dan kontribusi penelitian.\n\nParameter:\ngrades (list of int): Daftar dua elemen yang berisi nilai akademik siswa [rata-rata akhir semester, evaluasi kelas].\nleader (str): Sebuah string ('Y' atau 'N') yang menunjukkan apakah siswa tersebut adalah pemimpin kelas.\nwest (str): Sebuah string ('Y' atau 'N') yang menunjukkan apakah siswa tersebut berasal dari provinsi barat.\npapers (int): Sebuah bilangan bulat yang mewakili jumlah makalah penelitian yang diterbitkan oleh siswa.\n\nMengembalikan:\nint: Jumlah total beasiswa yang berhak diterima oleh siswa.\n\nContoh:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nContoh pertama menghitung beasiswa untuk seorang siswa dengan nilai rata-rata 87, nilai evaluasi 82,\nyang merupakan pemimpin kelas ('Y'), bukan dari provinsi barat ('N'), dan tanpa makalah yang diterbitkan (0). Siswa ini\nakan menerima total 4850 unit mata uang.\n\nDalam contoh kedua, siswa memiliki nilai rata-rata 88, nilai evaluasi 78, bukan pemimpin kelas ('N'),\nberasal dari provinsi barat ('Y'), dan telah menerbitkan 1 makalah. Siswa ini akan menerima total 9000 unit mata uang.", "ja": "学生の学業および課外活動の成果に基づいて、奨学金の総額を計算します。\n\nこの関数は、一連の条件を使用して、学生が受け取る権利のある奨学金の総額を決定します。\n奨学金は、学業成績、リーダーシップの役割、地域的背景、研究への貢献に基づいて授与されます。\n\n引数:\ngrades (list of int): 学生の学業成績を含む2要素のリスト [学期末平均, クラス評価]。\nleader (str): 学生がクラスリーダーであるかどうかを示す文字列 ('Y' または 'N')。\nwest (str): 学生が西部の州出身であるかどうかを示す文字列 ('Y' または 'N')。\npapers (int): 学生が発表した研究論文の数を表す整数。\n\n戻り値:\nint: 学生が受け取る資格のある奨学金の総額。\n\n例:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\n最初の例では、平均成績が87、評価成績が82の学生について奨学金を計算します。\nこの学生はクラスリーダー ('Y') であり、西部の州出身ではなく ('N')、発表論文はありません (0)。この学生は合計4850通貨単位を受け取ります。\n\n2番目の例では、平均成績が88、評価成績が78の学生についてです。この学生はクラスリーダーではなく ('N')、西部の州出身で ('Y')、1本の論文を発表しています。この学生は合計9000通貨単位を受け取ります。", "ko": "학생의 학업 및 과외 활동 성과를 기반으로 총 장학금 금액을 계산합니다.\n\n이 함수는 학생이 받을 수 있는 총 장학금 금액을 결정하기 위해 일련의 조건을 사용합니다. 장학금은 학업 성적, 리더십 역할, 지역 배경 및 연구 기여도를 기반으로 수여됩니다.\n\n매개변수:\ngrades (list of int): 학생의 학업 성적을 포함하는 두 요소 리스트 [학기말 평균, 수업 평가].\nleader (str): 학생이 반장인지 여부를 나타내는 문자열 ('Y' 또는 'N').\nwest (str): 학생이 서부 지방 출신인지 여부를 나타내는 문자열 ('Y' 또는 'N').\npapers (int): 학생이 발표한 연구 논문 수를 나타내는 정수.\n\n반환값:\nint: 학생이 받을 수 있는 총 장학금 금액.\n\n예시:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\n첫 번째 예시는 평균 성적 87, 평가 성적 82, 반장 ('Y'), 서부 지방 출신이 아님 ('N'), 발표된 논문이 없는 (0) 학생의 장학금을 계산합니다. 이 학생은 총 4850 단위의 통화를 받게 됩니다.\n\n두 번째 예시에서는 평균 성적 88, 평가 성적 78, 반장이 아님 ('N'), 서부 지방 출신 ('Y'), 1개의 논문을 발표한 학생입니다. 이 학생은 총 9000 단위의 통화를 받게 됩니다.", "ml": "വിദ്യാർത്ഥിയുടെ അക്കാദമിക്, സഹപാഠി പ്രവർത്തനങ്ങളിലെ നേട്ടങ്ങളെ അടിസ്ഥാനമാക്കി മൊത്തം സ്‌കോളർഷിപ്പ് തുക കണക്കാക്കുക.\n\nഫംഗ്ഷൻ വിദ്യാർത്ഥിക്ക് ലഭിക്കാവുന്ന മൊത്തം സ്‌കോളർഷിപ്പ് തുക നിർണയിക്കാൻ ഒരു സെറ്റ് നിബന്ധനകൾ ഉപയോഗിക്കുന്നു. അക്കാദമിക് ഗ്രേഡുകൾ, നേതൃപദവികൾ, പ്രാദേശിക പശ്ചാത്തലം, ഗവേഷണ സംഭാവനകൾ എന്നിവയെ അടിസ്ഥാനമാക്കി സ്‌കോളർഷിപ്പുകൾ നൽകുന്നു.\n\nപാരാമീറ്ററുകൾ:\ngrades (list of int): വിദ്യാർത്ഥിയുടെ അക്കാദമിക് ഗ്രേഡുകൾ [കാലാവധി അവസാനത്തെ ശരാശരി, ക്ലാസ് മൂല്യനിർണയം] അടങ്ങിയ രണ്ട് ഘടകങ്ങളുടെ പട്ടിക.\nleader (str): വിദ്യാർത്ഥി ക്ലാസ് ലീഡറാണോ എന്ന് സൂചിപ്പിക്കുന്ന ഒരു സ്ട്രിംഗ് ('Y' അല്ലെങ്കിൽ 'N').\nwest (str): വിദ്യാർത്ഥി പടിഞ്ഞാറൻ പ്രവിശ്യയിൽ നിന്നാണോ എന്ന് സൂചിപ്പിക്കുന്ന ഒരു സ്ട്രിംഗ് ('Y' അല്ലെങ്കിൽ 'N').\npapers (int): വിദ്യാർത്ഥി പ്രസിദ്ധീകരിച്ച ഗവേഷണ പ്രബന്ധങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\nമടങ്ങിവരവ്:\nint: വിദ്യാർത്ഥിക്ക് അർഹമായ മൊത്തം സ്‌കോളർഷിപ്പ് തുക.\n\nഉദാഹരണങ്ങൾ:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nആദ്യ ഉദാഹരണത്തിൽ, ശരാശരി ഗ്രേഡ് 87, മൂല്യനിർണയ ഗ്രേഡ് 82, ക്ലാസ് ലീഡർ ('Y'), പടിഞ്ഞാറൻ പ്രവിശ്യയിൽ നിന്നല്ല ('N'), പ്രസിദ്ധീകരിച്ച പ്രബന്ധങ്ങൾ ഇല്ല (0) എന്ന വിദ്യാർത്ഥിക്ക് സ്‌കോളർഷിപ്പ് കണക്കാക്കുന്നു. ഈ വിദ്യാർത്ഥിക്ക് മൊത്തം 4850 യൂണിറ്റ് കറൻസി ലഭിക്കും.\n\nരണ്ടാമത്തെ ഉദാഹരണത്തിൽ, ശരാശരി ഗ്രേഡ് 88, മൂല്യനിർണയ ഗ്രേഡ് 78, ക്ലാസ് ലീഡർ അല്ല ('N'), പടിഞ്ഞാറൻ പ്രവിശ്യയിൽ നിന്നാണ് ('Y'), 1 പ്രബന്ധം പ്രസിദ്ധീകരിച്ചിട്ടുണ്ട്. ഈ വിദ്യാർത്ഥിക്ക് മൊത്തം 9000 യൂണിറ്റ് കറൻസി ലഭിക്കും.", "fa": "محاسبه کل مبلغ بورسیه برای یک دانش‌آموز بر اساس دستاوردهای تحصیلی و فوق برنامه.\n\nاین تابع از مجموعه‌ای از شرایط برای تعیین کل مبلغ بورسیه‌ای که یک دانش‌آموز مستحق آن است، استفاده می‌کند. بورسیه‌ها بر اساس نمرات تحصیلی، نقش‌های رهبری، پیشینه منطقه‌ای و مشارکت‌های پژوهشی اعطا می‌شوند.\n\nپارامترها:\ngrades (list of int): یک لیست دو عنصری که نمرات تحصیلی دانش‌آموز را شامل می‌شود [میانگین پایان ترم، ارزیابی کلاسی].\nleader (str): یک رشته ('Y' یا 'N') که نشان می‌دهد آیا دانش‌آموز رهبر کلاس است یا خیر.\nwest (str): یک رشته ('Y' یا 'N') که نشان می‌دهد آیا دانش‌آموز از یک استان غربی است یا خیر.\npapers (int): یک عدد صحیح که تعداد مقالات پژوهشی منتشر شده توسط دانش‌آموز را نشان می‌دهد.\n\nبرمی‌گرداند:\nint: کل مبلغ بورسیه‌ای که دانش‌آموز واجد شرایط آن است.\n\nمثال‌ها:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nدر مثال اول، بورسیه برای دانش‌آموزی با میانگین نمره 87، نمره ارزیابی 82، که رهبر کلاس است ('Y')، از استان غربی نیست ('N') و هیچ مقاله منتشر شده‌ای ندارد (0) محاسبه می‌شود. این دانش‌آموز مجموعاً 4850 واحد پول دریافت می‌کند.\n\nدر مثال دوم، دانش‌آموز میانگین نمره 88، نمره ارزیابی 78 دارد، رهبر کلاس نیست ('N')، از استان غربی است ('Y') و 1 مقاله منتشر کرده است. این دانش‌آموز مجموعاً 9000 واحد پول دریافت می‌کند."}}
{"task_id": "Python/14", "prompt": {"en": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    The second example shows the correction of the ISBN number where the checksum digit is calculated\n    to be '4' instead of the provided '0', thus the corrected ISBN is returned.\n    \"\"\"\n    # Function implementation goes here.", "sq": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verifikon saktësinë e një numri të dhënë ISBN dhe e korrigjon atë nëse është e nevojshme.\n\n    Funksioni kontrollon numrin e dhënë ISBN kundrejt llogaritjes standarde të kontrollit të ISBN.\n    Nëse kontrolli është i saktë, funksioni kthen \"Right\". Nëse kontrolli është i pasaktë,\n    funksioni kthen numrin e korrigjuar ISBN.\n\n    Argumentet:\n    isbn: Një varg që përfaqëson numrin ISBN që do të verifikohet. Formati duhet të jetë 'x-xxx-xxxxx-x',\n          ku 'x' është një shifër, dhe 'x' i fundit mund të jetë gjithashtu 'X' që përfaqëson shifrën e kontrollit.\n\n    Kthen:\n    Një varg që është ose \"Right\" nëse kontrolli i ISBN është i saktë, ose numri i korrigjuar ISBN\n    në të njëjtin format si hyrja nëse kontrolli është i pasaktë.\n\n    Shembuj:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Shembulli i dytë tregon korrigjimin e numrit ISBN ku shifra e kontrollit llogaritet\n    të jetë '4' në vend të '0' të dhënë, kështu që kthehet ISBN i korrigjuar.\n    \"\"\"\n    # Zbatimi i funksionit shkon këtu.", "hy": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Ստուգել տրված ISBN համարի ճշգրտությունը և անհրաժեշտության դեպքում ուղղել այն:\n\n    Ֆունկցիան ստուգում է տրամադրված ISBN համարը ըստ ISBN ստանդարտի ստուգման գումարի հաշվարկի:\n    Եթե ստուգման գումարը ճիշտ է, ֆունկցիան վերադարձնում է \"Right\": Եթե ստուգման գումարը սխալ է,\n    ֆունկցիան վերադարձնում է ուղղված ISBN համարը:\n\n    Արգումենտներ:\n    isbn: Տող, որը ներկայացնում է ստուգվող ISBN համարը: Ֆորմատը պետք է լինի 'x-xxx-xxxxx-x',\n          որտեղ 'x'-ը թիվ է, իսկ վերջին 'x'-ը կարող է լինել նաև 'X', որը ներկայացնում է ստուգման գումարի թիվը:\n\n    Վերադարձնում է:\n    Տող, որը կամ \"Right\" է, եթե ISBN ստուգման գումարը ճիշտ է, կամ ուղղված ISBN համարը\n    նույն ֆորմատով, ինչպես մուտքայինը, եթե ստուգման գումարը սխալ է:\n\n    Օրինակներ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Երկրորդ օրինակը ցույց է տալիս ISBN համարի ուղղումը, որտեղ ստուգման գումարի թիվը հաշվարկվում է\n    որպես '4' փոխարեն տրված '0'-ի, հետևաբար վերադարձվում է ուղղված ISBN համարը:\n    \"\"\"\n    # Ֆունկցիայի իրականացումը այստեղ է:", "bn": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    প্রদত্ত একটি ISBN নম্বরের সঠিকতা যাচাই করুন এবং প্রয়োজন হলে এটি সংশোধন করুন।\n\n    ফাংশনটি প্রদত্ত ISBN নম্বরটি ISBN মানক চেকসাম গণনার সাথে যাচাই করে।\n    যদি চেকসাম সঠিক হয়, তাহলে ফাংশনটি \"Right\" ফেরত দেয়। যদি চেকসাম ভুল হয়,\n    তাহলে ফাংশনটি সংশোধিত ISBN নম্বর ফেরত দেয়।\n\n    Args:\n    isbn: একটি স্ট্রিং যা যাচাই করার জন্য ISBN নম্বর উপস্থাপন করে। ফরম্যাটটি হওয়া উচিত 'x-xxx-xxxxx-x',\n          যেখানে 'x' একটি সংখ্যা, এবং শেষের 'x' ও 'X' হতে পারে যা চেকসাম ডিজিট উপস্থাপন করে।\n\n    Returns:\n    একটি স্ট্রিং যা হয় \"Right\" যদি ISBN চেকসাম সঠিক হয়, অথবা সংশোধিত ISBN নম্বর\n    ইনপুটের মতো একই ফরম্যাটে যদি চেকসাম ভুল হয়।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    দ্বিতীয় উদাহরণটি দেখায় যে ISBN নম্বরের সংশোধন যেখানে চেকসাম ডিজিট '4' হিসেবে গণনা করা হয়\n    প্রদত্ত '0' এর পরিবর্তে, ফলে সংশোধিত ISBN ফেরত দেওয়া হয়।\n    \"\"\"\n    # Function implementation goes here.", "bg": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Проверете коректността на даден ISBN номер и го коригирайте, ако е необходимо.\n\n    Функцията проверява предоставения ISBN номер спрямо стандартното изчисление на контролна сума на ISBN.\n    Ако контролната сума е правилна, функцията връща \"Right\". Ако контролната сума е неправилна,\n    функцията връща коригирания ISBN номер.\n\n    Аргументи:\n    isbn: Низ, представляващ ISBN номера, който трябва да бъде проверен. Форматът трябва да бъде 'x-xxx-xxxxx-x',\n          където 'x' е цифра, а последното 'x' може също да бъде 'X', представляващо контролна цифра.\n\n    Връща:\n    Низ, който е или \"Right\", ако контролната сума на ISBN е правилна, или коригирания ISBN номер\n    в същия формат като входния, ако контролната сума е неправилна.\n\n    Примери:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Вторият пример показва корекцията на ISBN номера, където контролната цифра се изчислява\n    да бъде '4' вместо предоставената '0', следователно се връща коригираният ISBN.\n    \"\"\"\n    # Function implementation goes here.", "zh": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    验证给定的ISBN号码的正确性，并在必要时进行更正。\n\n    该函数根据ISBN标准校验和计算检查提供的ISBN号码。\n    如果校验和正确，函数返回\"Right\"。如果校验和不正确，\n    函数返回更正后的ISBN号码。\n\n    参数:\n    isbn: 一个表示要验证的ISBN号码的字符串。格式应为'x-xxx-xxxxx-x'，\n          其中'x'是一个数字，最后一个'x'也可以是代表校验和数字的'X'。\n\n    返回:\n    一个字符串，如果ISBN校验和正确则为\"Right\"，如果校验和不正确则为更正后的ISBN号码，\n    格式与输入相同。\n\n    示例:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    第二个示例显示了ISBN号码的更正，其中校验和数字被计算为'4'而不是提供的'0'，因此返回更正后的ISBN。\n    \"\"\"\n    # Function implementation goes here.", "fr": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Vérifiez la validité d'un numéro ISBN donné et corrigez-le si nécessaire.\n\n    La fonction vérifie le numéro ISBN fourni selon le calcul de la somme de contrôle standard ISBN.\n    Si la somme de contrôle est correcte, la fonction renvoie \"Right\". Si la somme de contrôle est incorrecte,\n    la fonction renvoie le numéro ISBN corrigé.\n\n    Args:\n    isbn: Une chaîne représentant le numéro ISBN à vérifier. Le format doit être 'x-xxx-xxxxx-x',\n          où 'x' est un chiffre, et le dernier 'x' pourrait également être 'X' représentant le chiffre de contrôle.\n\n    Returns:\n    Une chaîne qui est soit \"Right\" si la somme de contrôle de l'ISBN est correcte, soit le numéro ISBN corrigé\n    dans le même format que l'entrée si la somme de contrôle est incorrecte.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Le deuxième exemple montre la correction du numéro ISBN où le chiffre de contrôle est calculé\n    pour être '4' au lieu du '0' fourni, ainsi le numéro ISBN corrigé est renvoyé.\n    \"\"\"\n    # L'implémentation de la fonction va ici.", "de": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Überprüfen Sie die Korrektheit einer gegebenen ISBN-Nummer und korrigieren Sie sie bei Bedarf.\n\n    Die Funktion überprüft die angegebene ISBN-Nummer anhand der ISBN-Standard-Prüfsummenberechnung.\n    Wenn die Prüfsumme korrekt ist, gibt die Funktion \"Right\" zurück. Wenn die Prüfsumme falsch ist,\n    gibt die Funktion die korrigierte ISBN-Nummer zurück.\n\n    Argumente:\n    isbn: Ein String, der die zu überprüfende ISBN-Nummer darstellt. Das Format sollte 'x-xxx-xxxxx-x' sein,\n          wobei 'x' eine Ziffer ist und das letzte 'x' auch 'X' sein könnte, das die Prüfziffer darstellt.\n\n    Rückgabewerte:\n    Ein String, der entweder \"Right\" ist, wenn die ISBN-Prüfsumme korrekt ist, oder die korrigierte ISBN-Nummer\n    im gleichen Format wie die Eingabe, wenn die Prüfsumme falsch ist.\n\n    Beispiele:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Das zweite Beispiel zeigt die Korrektur der ISBN-Nummer, wobei die Prüfziffer als '4' berechnet wird\n    anstelle der angegebenen '0', daher wird die korrigierte ISBN zurückgegeben.\n    \"\"\"\n    # Function implementation goes here.", "ha": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Tabbatar da daidaiton lambar ISBN da aka bayar kuma gyara idan ya cancanta.\n\n    Aikin yana duba lambar ISBN da aka bayar daidai da lissafin daidaitaccen lissafin ISBN.\n    Idan lissafin daidaito ya yi daidai, aikin yana mayar da \"Right\". Idan lissafin daidaito bai yi daidai ba,\n    aikin yana mayar da lambar ISBN da aka gyara.\n\n    Args:\n    isbn: Wani kirtani da ke wakiltar lambar ISBN da za a tabbatar. Tsarin ya kamata ya zama 'x-xxx-xxxxx-x',\n          inda 'x' yake wakiltar lamba, kuma 'x' na ƙarshe na iya zama 'X' wanda ke wakiltar lambar daidaito.\n\n    Returns:\n    Wani kirtani wanda ko dai \"Right\" idan lissafin daidaito na ISBN ya yi daidai, ko lambar ISBN da aka gyara\n    a cikin tsarin daidai da wanda aka shigar idan lissafin daidaito bai yi daidai ba.\n\n    Misalai:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Misali na biyu yana nuna gyaran lambar ISBN inda aka lissafa lambar daidaito\n    don zama '4' maimakon '0' da aka bayar, don haka an mayar da lambar ISBN da aka gyara.\n    \"\"\"\n    # Function implementation goes here.", "hi": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    दिए गए ISBN नंबर की शुद्धता की जाँच करें और यदि आवश्यक हो तो इसे सही करें।\n\n    यह फ़ंक्शन प्रदान किए गए ISBN नंबर की ISBN मानक चेकसम गणना के खिलाफ जाँच करता है।\n    यदि चेकसम सही है, तो फ़ंक्शन \"Right\" लौटाता है। यदि चेकसम गलत है,\n    तो फ़ंक्शन सही किया गया ISBN नंबर लौटाता है।\n\n    Args:\n    isbn: एक स्ट्रिंग जो सत्यापित किए जाने वाले ISBN नंबर का प्रतिनिधित्व करती है। प्रारूप 'x-xxx-xxxxx-x' होना चाहिए,\n          जहाँ 'x' एक अंक है, और अंतिम 'x' भी 'X' हो सकता है जो चेकसम अंक का प्रतिनिधित्व करता है।\n\n    Returns:\n    एक स्ट्रिंग जो या तो \"Right\" है यदि ISBN चेकसम सही है, या सही किया गया ISBN नंबर\n    उसी प्रारूप में जैसा कि इनपुट में है, यदि चेकसम गलत है।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    दूसरा उदाहरण ISBN नंबर के सुधार को दिखाता है जहाँ चेकसम अंक '4' के रूप में गणना की जाती है\n    बजाय प्रदान किए गए '0' के, इस प्रकार सही किया गया ISBN लौटाया जाता है।\n    \"\"\"\n    # Function implementation goes here.", "hu": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Ellenőrzi a megadott ISBN szám helyességét, és szükség esetén kijavítja azt.\n\n    A függvény ellenőrzi a megadott ISBN számot az ISBN szabvány ellenőrzőösszeg számításának megfelelően.\n    Ha az ellenőrzőösszeg helyes, a függvény \"Right\"-ot ad vissza. Ha az ellenőrzőösszeg helytelen,\n    a függvény a javított ISBN számot adja vissza.\n\n    Args:\n    isbn: Egy string, amely az ellenőrizendő ISBN számot képviseli. A formátumnak 'x-xxx-xxxxx-x' kell lennie,\n          ahol 'x' egy számjegy, és az utolsó 'x' lehet 'X' is, amely az ellenőrző számjegyet jelenti.\n\n    Returns:\n    Egy string, amely vagy \"Right\", ha az ISBN ellenőrzőösszeg helyes, vagy a javított ISBN szám\n    ugyanabban a formátumban, mint a bemenet, ha az ellenőrzőösszeg helytelen.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    A második példa az ISBN szám javítását mutatja, ahol az ellenőrző számjegy '4'-re van számítva a megadott '0' helyett, így a javított ISBN kerül visszaadásra.\n    \"\"\"\n    # Function implementation goes here.", "es": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verificar la corrección de un número ISBN dado y corregirlo si es necesario.\n\n    La función verifica el número ISBN proporcionado contra el cálculo de suma de verificación estándar de ISBN.\n    Si la suma de verificación es correcta, la función devuelve \"Right\". Si la suma de verificación es incorrecta,\n    la función devuelve el número ISBN corregido.\n\n    Argumentos:\n    isbn: Una cadena que representa el número ISBN a verificar. El formato debe ser 'x-xxx-xxxxx-x',\n          donde 'x' es un dígito, y el último 'x' también podría ser 'X' representando el dígito de suma de verificación.\n\n    Devuelve:\n    Una cadena que es \"Right\" si la suma de verificación del ISBN es correcta, o el número ISBN corregido\n    en el mismo formato que la entrada si la suma de verificación es incorrecta.\n\n    Ejemplos:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    El segundo ejemplo muestra la corrección del número ISBN donde se calcula que el dígito de suma de verificación es '4'\n    en lugar del '0' proporcionado, por lo tanto, se devuelve el ISBN corregido.\n    \"\"\"\n    # La implementación de la función va aquí.", "arb": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    التحقق من صحة رقم ISBN المعطى وتصحيحه إذا لزم الأمر.\n\n    تقوم الدالة بفحص رقم ISBN المقدم مقابل حساب التحقق القياسي لـ ISBN.\n    إذا كان حساب التحقق صحيحًا، تعيد الدالة \"Right\". إذا كان حساب التحقق غير صحيح،\n    تعيد الدالة رقم ISBN المصحح.\n\n    يعيدالحجج:\n    isbn: سلسلة تمثل رقم ISBN المراد التحقق منه. يجب أن يكون التنسيق 'x-xxx-xxxxx-x',\n          حيث 'x' هو رقم، و'X' يمكن أن تمثل رقم التحقق الأخير.\n\n    يعيد:\n    سلسلة تكون إما \"Right\" إذا كان حساب التحقق لـ ISBN صحيحًا، أو رقم ISBN المصحح\n    بنفس تنسيق الإدخال إذا كان حساب التحقق غير صحيح.\n\n    امثله:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    المثال الثاني يوضح تصحيح رقم ISBN حيث تم حساب رقم التحقق ليكون '4' بدلاً من '0' المقدم،\n    وبالتالي يتم إرجاع ISBN المصحح.\n    \"\"\"\n    # Function implementation goes here.", "sw": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Thibitisha usahihi wa nambari ya ISBN iliyotolewa na uirekebishe ikiwa ni lazima.\n\n    Kazi hii inakagua nambari ya ISBN iliyotolewa dhidi ya hesabu ya checksum ya kiwango cha ISBN.\n    Ikiwa checksum ni sahihi, kazi inarudisha \"Right\". Ikiwa checksum si sahihi,\n    kazi inarudisha nambari ya ISBN iliyorekebishwa.\n\n    Hoja:\n    isbn: Kamba inayowakilisha nambari ya ISBN inayopaswa kuthibitishwa. Muundo unapaswa kuwa 'x-xxx-xxxxx-x',\n          ambapo 'x' ni tarakimu, na 'x' ya mwisho inaweza pia kuwa 'X' inayowakilisha tarakimu ya checksum.\n\n    Inarejesha:\n    Kamba ambayo ni \"Right\" ikiwa checksum ya ISBN ni sahihi, au nambari ya ISBN iliyorekebishwa\n    katika muundo ule ule kama pembejeo ikiwa checksum si sahihi.\n\n    Mifano:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Mfano wa pili unaonyesha marekebisho ya nambari ya ISBN ambapo tarakimu ya checksum inahesabiwa\n    kuwa '4' badala ya '0' iliyotolewa, hivyo nambari ya ISBN iliyorekebishwa inarudishwa.\n    \"\"\"\n    # Utekelezaji wa kazi unaenda hapa.", "tr": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verilen ISBN numarasının doğruluğunu kontrol edin ve gerekirse düzeltin.\n\n    Fonksiyon, sağlanan ISBN numarasını ISBN standart kontrol toplamı hesaplamasına karşı kontrol eder.\n    Eğer kontrol toplamı doğruysa, fonksiyon \"Right\" döndürür. Eğer kontrol toplamı yanlışsa,\n    fonksiyon düzeltilmiş ISBN numarasını döndürür.\n\n    Argümanlar:\n    isbn: Doğrulanacak ISBN numarasını temsil eden bir string. Format 'x-xxx-xxxxx-x' şeklinde olmalıdır,\n          burada 'x' bir rakamdır ve son 'x' kontrol toplamı rakamını temsil eden 'X' de olabilir.\n\n    Döndürür:\n    Kontrol toplamı doğruysa \"Right\" olan bir string veya kontrol toplamı yanlışsa\n    girişle aynı formatta düzeltilmiş ISBN numarasını döndüren bir string.\n\n    Örnekler:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    İkinci örnek, kontrol toplamı rakamının sağlanan '0' yerine '4' olarak hesaplandığı\n    ISBN numarasının düzeltilmesini gösterir, bu nedenle düzeltilmiş ISBN döndürülür.\n    \"\"\"\n    # Fonksiyonun uygulanması burada yapılır.", "vi": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Xác minh tính đúng đắn của một số ISBN được cung cấp và sửa nó nếu cần thiết.\n\n    Hàm kiểm tra số ISBN được cung cấp theo tính toán tổng kiểm tra chuẩn của ISBN.\n    Nếu tổng kiểm tra đúng, hàm trả về \"Right\". Nếu tổng kiểm tra sai,\n    hàm trả về số ISBN đã được sửa.\n\n    Tham số:\n    isbn: Một chuỗi đại diện cho số ISBN cần được xác minh. Định dạng nên là 'x-xxx-xxxxx-x',\n          trong đó 'x' là một chữ số, và 'x' cuối cùng cũng có thể là 'X' đại diện cho chữ số tổng kiểm tra.\n\n    Trả về:\n    Một chuỗi là \"Right\" nếu tổng kiểm tra ISBN đúng, hoặc số ISBN đã được sửa\n    theo cùng định dạng như đầu vào nếu tổng kiểm tra sai.\n\n    Ví dụ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Ví dụ thứ hai cho thấy sự sửa chữa của số ISBN nơi chữ số tổng kiểm tra được tính\n    là '4' thay vì '0' được cung cấp, do đó số ISBN đã được sửa được trả về.\n    \"\"\"\n    # Triển khai hàm ở đây.", "id": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verifikasi kebenaran nomor ISBN yang diberikan dan koreksi jika perlu.\n\n    Fungsi ini memeriksa nomor ISBN yang diberikan terhadap perhitungan checksum standar ISBN.\n    Jika checksum benar, fungsi mengembalikan \"Right\". Jika checksum salah,\n    fungsi mengembalikan nomor ISBN yang telah dikoreksi.\n\n    Argumen:\n    isbn: Sebuah string yang mewakili nomor ISBN yang akan diverifikasi. Formatnya harus 'x-xxx-xxxxx-x',\n          di mana 'x' adalah digit, dan 'x' terakhir juga bisa 'X' yang mewakili digit checksum.\n\n    Mengembalikan:\n    Sebuah string yang berupa \"Right\" jika checksum ISBN benar, atau nomor ISBN yang telah dikoreksi\n    dalam format yang sama dengan input jika checksum salah.\n\n    Contoh:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Contoh kedua menunjukkan koreksi nomor ISBN di mana digit checksum dihitung\n    menjadi '4' alih-alih '0' yang diberikan, sehingga ISBN yang dikoreksi dikembalikan.\n    \"\"\"\n    # Implementasi fungsi ada di sini.", "ja": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    与えられたISBN番号の正しさを検証し、必要に応じて修正します。\n\n    この関数は、提供されたISBN番号をISBN標準のチェックサム計算に基づいて確認します。\n    チェックサムが正しい場合、関数は \"Right\" を返します。チェックサムが間違っている場合、\n    関数は修正されたISBN番号を返します。\n\n    引数:\n    isbn: 検証するISBN番号を表す文字列。形式は 'x-xxx-xxxxx-x' で、\n          'x' は数字であり、最後の 'x' はチェックサム桁を表す 'X' である可能性もあります。\n\n    戻り値:\n    ISBNチェックサムが正しい場合は \"Right\"、チェックサムが間違っている場合は\n    入力と同じ形式で修正されたISBN番号を返します。\n\n    例:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    2番目の例は、提供された '0' の代わりにチェックサム桁が '4' と計算され、\n    修正されたISBNが返されることを示しています。\n    \"\"\"\n    # 関数の実装はここに記述します。", "ko": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    주어진 ISBN 번호의 정확성을 확인하고 필요시 수정합니다.\n\n    이 함수는 제공된 ISBN 번호를 ISBN 표준 체크섬 계산과 비교합니다.\n    체크섬이 정확하면 함수는 \"Right\"를 반환합니다. 체크섬이 틀리면,\n    함수는 수정된 ISBN 번호를 반환합니다.\n\n    Args:\n    isbn: 확인할 ISBN 번호를 나타내는 문자열입니다. 형식은 'x-xxx-xxxxx-x'이어야 하며,\n          여기서 'x'는 숫자이고, 마지막 'x'는 체크섬 숫자를 나타내는 'X'일 수 있습니다.\n\n    Returns:\n    ISBN 체크섬이 정확하면 \"Right\" 문자열을 반환하고, 체크섬이 틀리면\n    입력과 동일한 형식의 수정된 ISBN 번호를 반환합니다.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    두 번째 예시는 제공된 '0' 대신 계산된 체크섬 숫자가 '4'인 경우\n    ISBN 번호의 수정을 보여주며, 따라서 수정된 ISBN이 반환됩니다.\n    \"\"\"\n    # Function implementation goes here.", "ml": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    നൽകിയ ISBN നമ്പറിന്റെ ശരിതായതും ആവശ്യമെങ്കിൽ ശരിയാക്കുന്നതുമായ പരിശോധന നടത്തുക.\n\n    ISBN സ്റ്റാൻഡേർഡ് ചെക്സം കാൽക്കുലേഷൻ ഉപയോഗിച്ച് നൽകിയ ISBN നമ്പർ പരിശോധിക്കുന്നു.\n    ചെക്സം ശരിയാണെങ്കിൽ, ഫംഗ്ഷൻ \"Right\" എന്നത് തിരികെ നൽകുന്നു. ചെക്സം തെറ്റാണെങ്കിൽ,\n    ഫംഗ്ഷൻ ശരിയായ ISBN നമ്പർ തിരികെ നൽകുന്നു.\n\n    Args:\n    isbn: പരിശോധിക്കേണ്ട ISBN നമ്പർ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. ഫോർമാറ്റ് 'x-xxx-xxxxx-x' ആയിരിക്കണം,\n          ഇവിടെ 'x' ഒരു അക്കമാണ്, അവസാനത്തെ 'x' ചെക്സം അക്കം പ്രതിനിധീകരിക്കുന്ന 'X' ആയിരിക്കാം.\n\n    Returns:\n    ഒരു സ്ട്രിംഗ്, ചെക്സം ശരിയാണെങ്കിൽ \"Right\" അല്ലെങ്കിൽ ചെക്സം തെറ്റാണെങ്കിൽ\n    ഇൻപുട്ട് ഫോർമാറ്റിൽ തന്നെ ശരിയായ ISBN നമ്പർ.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    രണ്ടാം ഉദാഹരണം ചെക്സം അക്കം '0' എന്നതിനു പകരം '4' ആയി കണക്കാക്കപ്പെടുന്ന ISBN നമ്പറിന്റെ\n    ശരിയാക്കൽ കാണിക്കുന്നു, അതിനാൽ ശരിയായ ISBN തിരികെ നൽകുന്നു.\n    \"\"\"\n    # ഫംഗ്ഷൻ നടപ്പാക്കൽ ഇവിടെ വരുന്നു.", "fa": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    صحت یک شماره ISBN داده شده را بررسی کرده و در صورت لزوم آن را تصحیح می‌کند.\n\n    این تابع شماره ISBN ارائه شده را با محاسبه چکسام استاندارد ISBN بررسی می‌کند.\n    اگر چکسام صحیح باشد، تابع \"Right\" را برمی‌گرداند. اگر چکسام نادرست باشد،\n    تابع شماره ISBN تصحیح شده را برمی‌گرداند.\n\n    آرگومان‌ها:\n    isbn: یک رشته که شماره ISBN برای بررسی را نشان می‌دهد. قالب باید به صورت 'x-xxx-xxxxx-x' باشد،\n          که در آن 'x' یک رقم است و آخرین 'x' می‌تواند 'X' باشد که نشان‌دهنده رقم چکسام است.\n\n    بازگشت:\n    یک رشته که یا \"Right\" است اگر چکسام ISBN صحیح باشد، یا شماره ISBN تصحیح شده\n    در همان قالب ورودی اگر چکسام نادرست باشد.\n\n    مثال‌ها:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    مثال دوم نشان می‌دهد که شماره ISBN تصحیح شده است که در آن رقم چکسام به جای '0' ارائه شده به '4' محاسبه شده است، بنابراین شماره ISBN تصحیح شده برگردانده می‌شود.\n    \"\"\"\n    # پیاده‌سازی تابع در اینجا قرار می‌گیرد."}, "canonical_solution": "    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit", "instruction": {"en": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nՏվեք Python կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nДайте кратко описание на Python кода на български език, използвайки максимум 500 знака.", "zh": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\n请用中文为以下Python代码提供一个简洁的自然语言描述（文档字符串），最多使用500个字符。", "fr": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben.", "es": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nVerilen Python kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.", "vi": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) untuk kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\n다음 Python 코드에 대한 간결한 자연어 설명(문서 문자열)을 한국어로 500자 이내로 제공하세요.", "ml": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഇല്ലാത്ത ഒരു സംക്ഷിപ്ത വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nتوضیحی مختصر و طبیعی (docstring) از کد پایتون به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_verify_isbn():\n    # Test case 1: Correct ISBN number\n    assert verify_isbn(\"0-670-82162-4\") == \"Right\", \"Test case 1 failed\"\n\n    # Test case 2: Incorrect ISBN number with wrong checksum digit\n    assert verify_isbn(\"0-670-82162-0\") == \"0-670-82162-4\", \"Test case 2 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_verify_isbn()", "entry_point": "verify_isbn", "signature": "def verify_isbn(isbn: str) -> str:", "docstring": {"en": "Verify the correctness of a given ISBN number and correct it if necessary.\n\nThe function checks the provided ISBN number against the ISBN standard checksum calculation.\nIf the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\nthe function returns the corrected ISBN number.\n\nArgs:\nisbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\nwhere 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\nReturns:\nA string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\nin the same format as the input if the checksum is incorrect.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nThe second example shows the correction of the ISBN number where the checksum digit is calculated\nto be '4' instead of the provided '0', thus the corrected ISBN is returned.", "sq": "Verifikoni saktësinë e një numri të dhënë ISBN dhe korrigjojeni atë nëse është e nevojshme.\n\nFunksioni kontrollon numrin e dhënë ISBN kundrejt llogaritjes standarde të kontrollit të ISBN.\nNëse kontrolli është i saktë, funksioni kthen \"Right\". Nëse kontrolli është i pasaktë,\nfunksioni kthen numrin e korrigjuar ISBN.\n\nArgs:\nisbn: Një varg që përfaqëson numrin ISBN që do të verifikohet. Formati duhet të jetë 'x-xxx-xxxxx-x',\nku 'x' është një shifër, dhe 'x' i fundit mund të jetë gjithashtu 'X' që përfaqëson shifrën e kontrollit.\n\nReturns:\nNjë varg që është ose \"Right\" nëse kontrolli i ISBN është i saktë, ose numri i korrigjuar ISBN\nnë të njëjtin format si hyrja nëse kontrolli është i pasaktë.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nShembulli i dytë tregon korrigjimin e numrit ISBN ku shifra e kontrollit llogaritet\ntë jetë '4' në vend të '0' të dhënë, kështu që kthehet ISBN i korrigjuar.", "hy": "Ստուգել տրված ISBN համարի ճշտությունը և անհրաժեշտության դեպքում ուղղել այն։\n\nՖունկցիան ստուգում է տրված ISBN համարը ISBN ստանդարտի ստուգման գումարի հաշվարկի դեմ։\nԵթե ստուգման գումարը ճիշտ է, ֆունկցիան վերադարձնում է \"Right\"։ Եթե ստուգման գումարը սխալ է,\nֆունկցիան վերադարձնում է ուղղված ISBN համարը։\n\nԱրձանագրություններ:\nisbn: Տող, որը ներկայացնում է ստուգման ենթակա ISBN համարը։ Ֆորմատը պետք է լինի 'x-xxx-xxxxx-x',\nորտեղ 'x'-ը թիվ է, և վերջին 'x'-ը կարող է լինել նաև 'X', որը ներկայացնում է ստուգման գումարի թիվը։\n\nՎերադարձնում է:\nՏող, որը կամ \"Right\" է, եթե ISBN ստուգման գումարը ճիշտ է, կամ ուղղված ISBN համարը\nնույն ֆորմատով, ինչ մուտքագրումը, եթե ստուգման գումարը սխալ է։\n\nՕրինակներ:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nԵրկրորդ օրինակը ցույց է տալիս ISBN համարի ուղղումը, որտեղ ստուգման գումարի թիվը հաշվարկվել է\nորպես '4'՝ փոխարենը տրված '0'-ի, ուստի վերադարձվում է ուղղված ISBN-ը։", "bn": "একটি প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করুন এবং প্রয়োজন হলে এটি সংশোধন করুন।\n\nফাংশনটি প্রদত্ত ISBN নম্বরটি ISBN মানদণ্ডের চেকসাম গণনার সাথে মিলিয়ে পরীক্ষা করে।\nযদি চেকসাম সঠিক হয়, ফাংশনটি \"Right\" ফেরত দেয়। যদি চেকসাম ভুল হয়,\nফাংশনটি সংশোধিত ISBN নম্বর ফেরত দেয়।\n\nArgs:\nisbn: একটি স্ট্রিং যা যাচাই করার জন্য ISBN নম্বর উপস্থাপন করে। ফরম্যাটটি 'x-xxx-xxxxx-x' হওয়া উচিত,\nযেখানে 'x' একটি সংখ্যা, এবং শেষের 'x' চেকসাম সংখ্যাকে উপস্থাপন করতে 'X'ও হতে পারে।\n\nReturns:\nএকটি স্ট্রিং যা হয় \"Right\" যদি ISBN চেকসাম সঠিক হয়, অথবা সংশোধিত ISBN নম্বর\nইনপুটের মতো একই ফরম্যাটে যদি চেকসাম ভুল হয়।\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nদ্বিতীয় উদাহরণটি ISBN নম্বরের সংশোধন দেখায় যেখানে চেকসাম সংখ্যা '0' এর পরিবর্তে '4' হিসাবে গণনা করা হয়,\nফলে সংশোধিত ISBN ফেরত দেওয়া হয়।", "bg": "Проверете коректността на даден ISBN номер и го коригирайте, ако е необходимо.\n\nФункцията проверява предоставения ISBN номер спрямо стандартното изчисление на контролна сума на ISBN.\nАко контролната сума е правилна, функцията връща \"Right\". Ако контролната сума е неправилна,\nфункцията връща коригирания ISBN номер.\n\nАргументи:\nisbn: Низ, представляващ ISBN номера, който трябва да бъде проверен. Форматът трябва да бъде 'x-xxx-xxxxx-x',\nкъдето 'x' е цифра, а последното 'x' може също да бъде 'X', представляващо контролна цифра.\n\nВръща:\nНиз, който е или \"Right\", ако контролната сума на ISBN е правилна, или коригирания ISBN номер\nв същия формат като входа, ако контролната сума е неправилна.\n\nПримери:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nВторият пример показва корекцията на ISBN номера, където контролната цифра е изчислена\nда бъде '4' вместо предоставената '0', следователно се връща коригираният ISBN.", "zh": "验证给定的 ISBN 号码的正确性，并在必要时进行更正。\n\n该函数根据 ISBN 标准校验和计算检查提供的 ISBN 号码。\n如果校验和正确，函数返回 \"Right\"。如果校验和不正确，\n函数返回更正后的 ISBN 号码。\n\n参数：\nisbn: 一个表示要验证的 ISBN 号码的字符串。格式应为 'x-xxx-xxxxx-x'，\n其中 'x' 是一个数字，最后一个 'x' 也可以是代表校验和数字的 'X'。\n\n返回：\n一个字符串，如果 ISBN 校验和正确，则为 \"Right\"；如果校验和不正确，\n则为与输入格式相同的更正后的 ISBN 号码。\n\n示例：\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\n第二个示例显示了 ISBN 号码的更正，其中校验和数字计算为 '4' 而不是提供的 '0'，因此返回更正后的 ISBN。", "fr": "Vérifiez la validité d'un numéro ISBN donné et corrigez-le si nécessaire.\n\nLa fonction vérifie le numéro ISBN fourni par rapport au calcul standard de la somme de contrôle ISBN.\nSi la somme de contrôle est correcte, la fonction retourne \"Right\". Si la somme de contrôle est incorrecte,\nla fonction retourne le numéro ISBN corrigé.\n\nArgs:\nisbn: Une chaîne de caractères représentant le numéro ISBN à vérifier. Le format doit être 'x-xxx-xxxxx-x',\noù 'x' est un chiffre, et le dernier 'x' pourrait aussi être 'X' représentant le chiffre de la somme de contrôle.\n\nReturns:\nUne chaîne de caractères qui est soit \"Right\" si la somme de contrôle ISBN est correcte, soit le numéro ISBN corrigé\ndans le même format que l'entrée si la somme de contrôle est incorrecte.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nLe deuxième exemple montre la correction du numéro ISBN où le chiffre de la somme de contrôle est calculé\npour être '4' au lieu de '0' fourni, ainsi le numéro ISBN corrigé est retourné.", "de": "Überprüfen Sie die Korrektheit einer gegebenen ISBN-Nummer und korrigieren Sie sie bei Bedarf.\n\nDie Funktion überprüft die angegebene ISBN-Nummer anhand der ISBN-Standard-Prüfziffernberechnung. Wenn die Prüfziffer korrekt ist, gibt die Funktion \"Right\" zurück. Wenn die Prüfziffer falsch ist, gibt die Funktion die korrigierte ISBN-Nummer zurück.\n\nArgs:\nisbn: Ein String, der die zu überprüfende ISBN-Nummer darstellt. Das Format sollte 'x-xxx-xxxxx-x' sein, wobei 'x' eine Ziffer ist und das letzte 'x' auch 'X' sein könnte, was die Prüfziffer darstellt.\n\nReturns:\nEin String, der entweder \"Right\" ist, wenn die ISBN-Prüfziffer korrekt ist, oder die korrigierte ISBN-Nummer im gleichen Format wie die Eingabe, wenn die Prüfziffer falsch ist.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nDas zweite Beispiel zeigt die Korrektur der ISBN-Nummer, bei der die Prüfziffer als '4' berechnet wird, anstatt der angegebenen '0', sodass die korrigierte ISBN zurückgegeben wird.", "ha": "Tabbatar da daidaiton lambar ISBN da aka bayar kuma gyara idan ya cancanta.\n\nAikin yana duba lambar ISBN da aka bayar daidai da lissafin duba daidaito na ma'aunin ISBN.\nIdan duba daidaito ya yi daidai, aikin yana mayar da \"Right\". Idan duba daidaito bai yi daidai ba,\naikin yana mayar da lambar ISBN da aka gyara.\n\nArgs:\nisbn: Wani kirtani da ke wakiltar lambar ISBN da za a tabbatar. Tsarin ya kamata ya zama 'x-xxx-xxxxx-x',\ninda 'x' yake wakiltar lamba, kuma 'x' na ƙarshe na iya zama 'X' wanda ke wakiltar lambar duba daidaito.\n\nReturns:\nWani kirtani wanda ko dai \"Right\" idan duba daidaito na ISBN ya yi daidai, ko kuma lambar ISBN da aka gyara\na cikin tsarin daidai da shigarwar idan duba daidaito bai yi daidai ba.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nMisalin na biyu yana nuna gyaran lambar ISBN inda aka lissafa lambar duba daidaito\nya zama '4' maimakon '0' da aka bayar, don haka an mayar da lambar ISBN da aka gyara.", "hi": "एक दिए गए ISBN नंबर की शुद्धता की जाँच करें और यदि आवश्यक हो तो इसे सही करें।\n\nयह फ़ंक्शन दिए गए ISBN नंबर को ISBN मानक चेकसम गणना के विरुद्ध जाँचता है।\nयदि चेकसम सही है, तो फ़ंक्शन \"Right\" लौटाता है। यदि चेकसम गलत है,\nतो फ़ंक्शन सही किया गया ISBN नंबर लौटाता है।\n\nआर्ग्स:\nisbn: एक स्ट्रिंग जो सत्यापित किए जाने वाले ISBN नंबर का प्रतिनिधित्व करती है। प्रारूप 'x-xxx-xxxxx-x' होना चाहिए,\nजहाँ 'x' एक अंक है, और अंतिम 'x' चेकसम अंक का प्रतिनिधित्व करने वाला 'X' भी हो सकता है।\n\nरिटर्न्स:\nएक स्ट्रिंग जो या तो \"Right\" है यदि ISBN चेकसम सही है, या सही किया गया ISBN नंबर\nउसी प्रारूप में जैसा इनपुट है यदि चेकसम गलत है।\n\nउदाहरण:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nदूसरा उदाहरण दिखाता है कि ISBN नंबर का सुधार किया गया है जहाँ चेकसम अंक '0' के बजाय '4' गणना किया गया है, इस प्रकार सही किया गया ISBN लौटाया जाता है।", "hu": "Ellenőrizze egy adott ISBN szám helyességét, és szükség esetén javítsa ki.\n\nA függvény ellenőrzi a megadott ISBN számot az ISBN szabvány ellenőrzőösszeg számításával szemben.\nHa az ellenőrzőösszeg helyes, a függvény \"Right\"-ot ad vissza. Ha az ellenőrzőösszeg helytelen,\na függvény a javított ISBN számot adja vissza.\n\nArgok:\nisbn: Egy karakterlánc, amely az ellenőrizendő ISBN számot képviseli. A formátum 'x-xxx-xxxxx-x' legyen,\nahol 'x' egy számjegy, és az utolsó 'x' lehet 'X' is, amely az ellenőrző számjegyet képviseli.\n\nVisszatér:\nEgy karakterlánc, amely vagy \"Right\", ha az ISBN ellenőrzőösszeg helyes, vagy a javított ISBN szám\nugyanabban a formátumban, mint a bemenet, ha az ellenőrzőösszeg helytelen.\n\nPéldák:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nA második példa bemutatja az ISBN szám javítását, ahol az ellenőrző számjegy '4'-nek van kiszámítva a megadott '0' helyett, így a javított ISBN kerül visszaadásra.", "es": "Verificar la corrección de un número ISBN dado y corregirlo si es necesario.\n\nLa función verifica el número ISBN proporcionado contra el cálculo estándar del checksum del ISBN. Si el checksum es correcto, la función devuelve \"Right\". Si el checksum es incorrecto, la función devuelve el número ISBN corregido.\n\nArgumentos:\nisbn: Una cadena que representa el número ISBN a verificar. El formato debe ser 'x-xxx-xxxxx-x', donde 'x' es un dígito, y el último 'x' también podría ser 'X' representando el dígito del checksum.\n\nDevuelve:\nUna cadena que es \"Right\" si el checksum del ISBN es correcto, o el número ISBN corregido en el mismo formato que la entrada si el checksum es incorrecto.\n\nEjemplos:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nEl segundo ejemplo muestra la corrección del número ISBN donde se calcula que el dígito del checksum es '4' en lugar del '0' proporcionado, por lo tanto, se devuelve el ISBN corregido.", "arb": "التحقق من صحة رقم ISBN المعطى وتصحيحه إذا لزم الأمر.\n\nتتحقق الدالة من رقم ISBN المقدم وفقًا لحساب التحقق القياسي لـ ISBN. إذا كان التحقق صحيحًا، تُرجع الدالة \"Right\". إذا كان التحقق غير صحيح، تُرجع الدالة رقم ISBN المصحح.\n\nالمعطيات:\nisbn: سلسلة تمثل رقم ISBN المراد التحقق منه. يجب أن يكون التنسيق 'x-xxx-xxxxx-x'، حيث 'x' هو رقم، ويمكن أن يكون 'x' الأخير أيضًا 'X' لتمثيل رقم التحقق.\n\nالقيم المعادة:\nسلسلة إما \"Right\" إذا كان تحقق ISBN صحيحًا، أو رقم ISBN المصحح بنفس تنسيق الإدخال إذا كان التحقق غير صحيح.\n\nأمثلة:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nيظهر المثال الثاني تصحيح رقم ISBN حيث تم حساب رقم التحقق ليكون '4' بدلاً من '0' المقدم، وبالتالي يتم إرجاع ISBN المصحح.", "sw": "Thibitisha usahihi wa nambari ya ISBN iliyotolewa na uirekebishe ikiwa ni lazima.\n\nKazi hii inakagua nambari ya ISBN iliyotolewa dhidi ya hesabu ya kawaida ya checksum ya ISBN.\nIkiwa checksum ni sahihi, kazi inarudisha \"Right\". Ikiwa checksum si sahihi,\nkazi inarudisha nambari ya ISBN iliyorekebishwa.\n\nHoja:\nisbn: Kamba inayowakilisha nambari ya ISBN inayohitaji kuthibitishwa. Muundo unapaswa kuwa 'x-xxx-xxxxx-x',\nambapo 'x' ni tarakimu, na 'x' ya mwisho inaweza pia kuwa 'X' inayowakilisha tarakimu ya checksum.\n\nInarejesha:\nKamba ambayo ni \"Right\" ikiwa checksum ya ISBN ni sahihi, au nambari ya ISBN iliyorekebishwa\nkatika muundo sawa na ingizo ikiwa checksum si sahihi.\n\nMifano:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nMfano wa pili unaonyesha marekebisho ya nambari ya ISBN ambapo tarakimu ya checksum inahesabiwa\nkuwa '4' badala ya '0' iliyotolewa, hivyo nambari ya ISBN iliyorekebishwa inarudishwa.", "tr": "Verilen bir ISBN numarasının doğruluğunu kontrol edin ve gerekirse düzeltin.\n\nFonksiyon, sağlanan ISBN numarasını ISBN standart kontrol toplamı hesaplamasına karşı kontrol eder.\nEğer kontrol toplamı doğruysa, fonksiyon \"Right\" döndürür. Eğer kontrol toplamı yanlışsa,\nfonksiyon düzeltilmiş ISBN numarasını döndürür.\n\nArgümanlar:\nisbn: Doğrulanacak ISBN numarasını temsil eden bir string. Format 'x-xxx-xxxxx-x' şeklinde olmalıdır,\nburada 'x' bir rakamdır ve son 'x' kontrol toplamı rakamını temsil eden 'X' de olabilir.\n\nDöndürür:\nBir string döndürür, eğer ISBN kontrol toplamı doğruysa \"Right\", eğer kontrol toplamı yanlışsa\ngirdinin formatında düzeltilmiş ISBN numarası döndürülür.\n\nÖrnekler:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nİkinci örnek, kontrol toplamı rakamının sağlanan '0' yerine '4' olarak hesaplandığı ISBN numarasının düzeltilmesini gösterir, bu nedenle düzeltilmiş ISBN döndürülür.", "vi": "Xác minh tính chính xác của một số ISBN được cung cấp và sửa nó nếu cần thiết.\n\nHàm kiểm tra số ISBN được cung cấp theo tính toán tổng kiểm tra tiêu chuẩn ISBN. Nếu tổng kiểm tra đúng, hàm trả về \"Right\". Nếu tổng kiểm tra sai, hàm trả về số ISBN đã được sửa.\n\nTham số:\nisbn: Một chuỗi đại diện cho số ISBN cần được xác minh. Định dạng nên là 'x-xxx-xxxxx-x', trong đó 'x' là một chữ số, và 'x' cuối cùng cũng có thể là 'X' đại diện cho chữ số tổng kiểm tra.\n\nTrả về:\nMột chuỗi là \"Right\" nếu tổng kiểm tra ISBN đúng, hoặc số ISBN đã được sửa trong cùng định dạng như đầu vào nếu tổng kiểm tra sai.\n\nVí dụ:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nVí dụ thứ hai cho thấy sự sửa chữa của số ISBN nơi chữ số tổng kiểm tra được tính là '4' thay vì '0' được cung cấp, do đó số ISBN đã được sửa được trả về.", "id": "Memverifikasi kebenaran nomor ISBN yang diberikan dan memperbaikinya jika diperlukan.\n\nFungsi memeriksa nomor ISBN yang diberikan terhadap perhitungan checksum standar ISBN. Jika checksum benar, fungsi mengembalikan \"Right\". Jika checksum salah, fungsi mengembalikan nomor ISBN yang telah dikoreksi.\n\nArgs:\nisbn: Sebuah string yang mewakili nomor ISBN yang akan diverifikasi. Formatnya harus 'x-xxx-xxxxx-x',\ndi mana 'x' adalah digit, dan 'x' terakhir juga bisa 'X' yang mewakili digit checksum.\n\nReturns:\nSebuah string yang berupa \"Right\" jika checksum ISBN benar, atau nomor ISBN yang telah dikoreksi\ndalam format yang sama dengan input jika checksum salah.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nContoh kedua menunjukkan koreksi nomor ISBN di mana digit checksum dihitung menjadi '4' alih-alih '0' yang diberikan, sehingga ISBN yang dikoreksi dikembalikan.", "ja": "与えられたISBN番号の正確性を確認し、必要に応じて修正します。\n\n関数は、提供されたISBN番号をISBN標準のチェックサム計算に基づいて確認します。\nチェックサムが正しい場合、関数は「Right」を返します。チェックサムが間違っている場合、\n関数は修正されたISBN番号を返します。\n\n引数:\nisbn: 確認するISBN番号を表す文字列。形式は 'x-xxx-xxxxx-x' である必要があります。\nここで 'x' は数字を表し、最後の 'x' はチェックサム桁を表す 'X' である可能性もあります。\n\n戻り値:\n文字列で、ISBNチェックサムが正しい場合は「Right」、チェックサムが間違っている場合は\n入力と同じ形式で修正されたISBN番号を返します。\n\n例:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\n2番目の例は、チェックサム桁が提供された '0' ではなく '4' と計算されるISBN番号の修正を示しており、\nそのため修正されたISBNが返されます。", "ko": "주어진 ISBN 번호의 정확성을 확인하고 필요하면 수정합니다.\n\n이 함수는 제공된 ISBN 번호를 ISBN 표준 체크섬 계산과 비교합니다.\n체크섬이 올바르면 함수는 \"Right\"를 반환합니다. 체크섬이 올바르지 않으면,\n함수는 수정된 ISBN 번호를 반환합니다.\n\n인수:\nisbn: 확인할 ISBN 번호를 나타내는 문자열입니다. 형식은 'x-xxx-xxxxx-x'이어야 하며,\n여기서 'x'는 숫자이고, 마지막 'x'는 체크섬 숫자를 나타내는 'X'일 수도 있습니다.\n\n반환:\n문자열로, ISBN 체크섬이 올바르면 \"Right\"를 반환하고, 체크섬이 올바르지 않으면 입력과 동일한 형식의 수정된 ISBN 번호를 반환합니다.\n\n예제:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\n두 번째 예제는 제공된 '0' 대신 체크섬 숫자가 '4'로 계산되어 수정된 ISBN 번호가 반환되는 것을 보여줍니다.", "ml": "ഒരു നൽകിയ ISBN നമ്പറിന്റെ ശരിതമ്മത്വം പരിശോധിക്കുകയും ആവശ്യമെങ്കിൽ അത് ശരിയാക്കുകയും ചെയ്യുക.\n\nഫങ്ഷൻ നൽകിയ ISBN നമ്പർ ISBN സ്റ്റാൻഡേർഡ് ചെക്സം കണക്കുകൂട്ടലിനെതിരെ പരിശോധിക്കുന്നു. ചെക്സം ശരിയാണെങ്കിൽ, ഫങ്ഷൻ \"Right\" എന്നത് തിരികെ നൽകുന്നു. ചെക്സം തെറ്റാണെങ്കിൽ, ഫങ്ഷൻ ശരിയായ ISBN നമ്പർ തിരികെ നൽകുന്നു.\n\nആർഗുകൾ:\nisbn: പരിശോധിക്കേണ്ട ISBN നമ്പർ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. ഫോർമാറ്റ് 'x-xxx-xxxxx-x' ആകണം, ഇവിടെ 'x' ഒരു അക്കമാണ്, അവസാനത്തെ 'x' ചെക്സം അക്കത്തെ പ്രതിനിധീകരിക്കുന്ന 'X' ആയിരിക്കാം.\n\nമടക്കങ്ങൾ:\nഒരു സ്ട്രിംഗ്, ISBN ചെക്സം ശരിയാണെങ്കിൽ \"Right\" അല്ലെങ്കിൽ ചെക്സം തെറ്റാണെങ്കിൽ ഇൻപുട്ടിന്റെ അതേ ഫോർമാറ്റിൽ ശരിയായ ISBN നമ്പർ.\n\nഉദാഹരണങ്ങൾ:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nരണ്ടാമത്തെ ഉദാഹരണം ചെക്സം അക്കം നൽകിയ '0' എന്നതിനു പകരം '4' ആയി കണക്കാക്കപ്പെടുന്ന ISBN നമ്പറിന്റെ ശരിയാക്കൽ കാണിക്കുന്നു, അതിനാൽ ശരിയായ ISBN തിരികെ നൽകുന്നു.", "fa": "درستی یک شماره ISBN داده شده را بررسی کرده و در صورت لزوم آن را تصحیح کنید.\n\nتابع شماره ISBN ارائه شده را با محاسبه استاندارد چکسام ISBN بررسی می‌کند.\nاگر چکسام درست باشد، تابع \"Right\" را برمی‌گرداند. اگر چکسام نادرست باشد،\nتابع شماره ISBN تصحیح شده را برمی‌گرداند.\n\nآرگومان‌ها:\nisbn: رشته‌ای که شماره ISBN برای بررسی را نشان می‌دهد. قالب باید به صورت 'x-xxx-xxxxx-x' باشد،\nکه در آن 'x' یک رقم است و آخرین 'x' می‌تواند 'X' باشد که نشان‌دهنده رقم چکسام است.\n\nبازگشت:\nرشته‌ای که یا \"Right\" است اگر چکسام ISBN درست باشد، یا شماره ISBN تصحیح شده\nدر همان قالب ورودی اگر چکسام نادرست باشد.\n\nمثال‌ها:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nمثال دوم نشان‌دهنده تصحیح شماره ISBN است که در آن رقم چکسام به جای '0' ارائه شده به '4' محاسبه می‌شود، بنابراین ISBN تصحیح شده برگردانده می‌شود."}}
{"task_id": "Python/15", "prompt": {"en": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.\n    \"\"\"", "sq": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimizoni vendosjen e korridoreve në një klasë për të minimizuar sasinë e bisedave midis nxënësve.\n\n    Args:\n    M (int): Numri i rreshtave në klasë.\n    N (int): Numri i kolonave në klasë.\n    K (int): Numri i korridoreve horizontale për t'u shtuar.\n    L (int): Numri i korridoreve vertikale për t'u shtuar.\n    D (int): Numri i çifteve që bisedojnë në klasë.\n    chatting_pairs (list of tuples): Një listë tuples, secila që përmban pozicionet (Xi, Yi) dhe (Pi, Qi) të një çifti që bisedon.\n\n    Returns:\n    (str, str): Dy vargje të ndara me hapësirë që përfaqësojnë indekset optimale të rreshtave dhe kolonave për korridoret.\n\n    Funksioni punon duke numëruar numrin e çifteve që bisedojnë që mund të ndahen duke shtuar një korridor në secilën pozicion të mundshëm.\n    Pastaj zgjedh pozicionet më efektive për korridoret, duke synuar të ndajë sa më shumë çifte që bisedojnë të jetë e mundur.\n\n    Shembuj:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Kthen: ('2', '2 4'), duke treguar se vendosja e një korridori pas rreshtit 2 dhe kolonave 2 dhe 4 do të ishte optimale.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Kthen: ('2', '2'), duke treguar se vendosja e një korridori pas rreshtit 2 dhe kolonës 2 do të ishte optimale.\n    \"\"\"", "hy": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Օպտիմալացնել միջանցքների տեղադրումը դասարանում՝ նվազեցնելու համար ուսանողների միջև զրուցելու քանակը:\n\n    Արգումենտներ:\n    M (int): Դասարանի շարքերի քանակը:\n    N (int): Դասարանի սյուների քանակը:\n    K (int): Ավելացվող հորիզոնական միջանցքների քանակը:\n    L (int): Ավելացվող ուղղահայաց միջանցքների քանակը:\n    D (int): Դասարանում զրուցող զույգերի քանակը:\n    chatting_pairs (ցուցակ տուփերով): Տուփերի ցուցակ, որոնցից յուրաքանչյուրը պարունակում է զրուցող զույգի դիրքերը (Xi, Yi) և (Pi, Qi):\n\n    Վերադարձնում է:\n    (str, str): Երկու տարածքով բաժանված տողեր, որոնք ներկայացնում են միջանցքների օպտիմալ շարքի և սյունակի ինդեքսները:\n\n    Ֆունկցիան աշխատում է հաշվելով զրուցող զույգերի քանակը, որոնք կարող են բաժանվել՝ ավելացնելով միջանցք յուրաքանչյուր հնարավոր դիրքում:\n    Այնուհետև ընտրում է միջանցքների ամենաարդյունավետ դիրքերը՝ նպատակ ունենալով բաժանել որքան հնարավոր է շատ զրուցող զույգեր:\n\n    Օրինակներ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Վերադարձնում է: ('2', '2 4'), ցույց տալով, որ միջանցք տեղադրելը 2-րդ շարքի և 2-րդ ու 4-րդ սյունակների հետևում օպտիմալ կլինի:\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Վերադարձնում է: ('2', '2'), ցույց տալով, որ միջանցք տեղադրելը 2-րդ շարքի և 2-րդ սյունակի հետևում օպտիմալ կլինի:\n    \"\"\"", "bn": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    শ্রেণীকক্ষে শিক্ষার্থীদের মধ্যে আলাপচারিতা কমানোর জন্য আসন বিন্যাসের পথগুলির অবস্থান অপ্টিমাইজ করুন।\n\n    Args:\n    M (int): শ্রেণীকক্ষে সারির সংখ্যা।\n    N (int): শ্রেণীকক্ষে কলামের সংখ্যা।\n    K (int): যোগ করার জন্য অনুভূমিক পথের সংখ্যা।\n    L (int): যোগ করার জন্য উল্লম্ব পথের সংখ্যা।\n    D (int): শ্রেণীকক্ষে আলাপচারিতার জোড়ার সংখ্যা।\n    chatting_pairs (list of tuples): একটি তালিকা যা প্রতিটি জোড়ার অবস্থান (Xi, Yi) এবং (Pi, Qi) ধারণ করে।\n\n    Returns:\n    (str, str): দুটি স্থান-বিচ্ছিন্ন স্ট্রিং যা পথগুলির জন্য সর্বোত্তম সারি এবং কলামের সূচকগুলি উপস্থাপন করে।\n\n    ফাংশনটি প্রতিটি সম্ভাব্য অবস্থানে একটি পথ যোগ করার মাধ্যমে আলাপচারিতার জোড়াগুলিকে আলাদা করার সংখ্যা গণনা করে কাজ করে।\n    এটি তারপর পথগুলির জন্য সবচেয়ে কার্যকর অবস্থানগুলি নির্বাচন করে, যতটা সম্ভব আলাপচারিতার জোড়াগুলিকে আলাদা করার লক্ষ্যে।\n\n    উদাহরণ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), যা নির্দেশ করে যে সারি 2 এবং কলাম 2 এবং 4 এর পরে একটি পথ স্থাপন করা সর্বোত্তম হবে।\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), যা নির্দেশ করে যে সারি 2 এবং কলাম 2 এর পরে একটি পথ স্থাপন করা সর্বোত্তম হবে।\n    \"\"\"", "bg": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Оптимизирайте разположението на пътеките в класната стая, за да минимизирате количеството на разговорите между учениците.\n\n    Args:\n    M (int): Броят на редовете в класната стая.\n    N (int): Броят на колоните в класната стая.\n    K (int): Броят на хоризонталните пътеки, които да се добавят.\n    L (int): Броят на вертикалните пътеки, които да се добавят.\n    D (int): Броят на двойките, които разговарят в класната стая.\n    chatting_pairs (list of tuples): Списък от кортежи, всеки съдържащ позициите (Xi, Yi) и (Pi, Qi) на двойка, която разговаря.\n\n    Returns:\n    (str, str): Два низа, разделени с интервал, представляващи оптималните индекси на редовете и колоните за пътеките.\n\n    Функцията работи, като брои броя на двойките, които могат да бъдат разделени чрез добавяне на пътека във всяка възможна позиция.\n    След това избира най-ефективните позиции за пътеки, с цел да се разделят възможно най-много двойки, които разговарят.\n\n    Примери:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Връща: ('2', '2 4'), което показва, че поставянето на пътека след ред 2 и колони 2 и 4 би било оптимално.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Връща: ('2', '2'), което показва, че поставянето на пътека след ред 2 и колона 2 би било оптимално.\n    \"\"\"", "zh": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    优化教室中过道的布置，以尽量减少学生之间的聊天。\n\n    参数:\n    M (int): 教室中的行数。\n    N (int): 教室中的列数。\n    K (int): 要添加的水平过道数。\n    L (int): 要添加的垂直过道数。\n    D (int): 教室中聊天对的数量。\n    chatting_pairs (list of tuples): 一个包含元组的列表，每个元组包含一个聊天对的位置 (Xi, Yi) 和 (Pi, Qi)。\n\n    返回:\n    (str, str): 两个用空格分隔的字符串，表示过道的最佳行和列索引。\n\n    该函数通过计算可以通过在每个可能的位置添加过道来分隔的聊天对的数量来工作。\n    然后选择最有效的过道位置，目标是尽可能多地分隔聊天对。\n\n    例子:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    返回: ('2', '2 4')，表示在第2行和第2列及第4列后放置过道是最佳的。\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    返回: ('2', '2')，表示在第2行和第2列后放置过道是最佳的。\n    \"\"\"", "fr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimiser le placement des allées dans une salle de classe pour minimiser la quantité de bavardage entre les élèves.\n\n    Args:\n    M (int): Le nombre de rangées dans la salle de classe.\n    N (int): Le nombre de colonnes dans la salle de classe.\n    K (int): Le nombre d'allées horizontales à ajouter.\n    L (int): Le nombre d'allées verticales à ajouter.\n    D (int): Le nombre de paires bavardantes dans la salle de classe.\n    chatting_pairs (list of tuples): Une liste de tuples, chacun contenant les positions (Xi, Yi) et (Pi, Qi) d'une paire bavardante.\n\n    Returns:\n    (str, str): Deux chaînes séparées par des espaces représentant les indices optimaux des rangées et colonnes pour les allées.\n\n    La fonction fonctionne en comptant le nombre de paires bavardantes qui peuvent être séparées en ajoutant une allée à chaque position possible.\n    Elle sélectionne ensuite les positions les plus efficaces pour les allées, visant à séparer autant de paires bavardantes que possible.\n\n    Exemples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), indiquant que placer une allée après la rangée 2 et les colonnes 2 et 4 serait optimal.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), indiquant que placer une allée après la rangée 2 et la colonne 2 serait optimal.\n    \"\"\"", "de": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimieren Sie die Platzierung von Gängen in einem Klassenzimmer, um die Menge an Gesprächen zwischen Schülern zu minimieren.\n\n    Argumente:\n    M (int): Die Anzahl der Reihen im Klassenzimmer.\n    N (int): Die Anzahl der Spalten im Klassenzimmer.\n    K (int): Die Anzahl der hinzuzufügenden horizontalen Gänge.\n    L (int): Die Anzahl der hinzuzufügenden vertikalen Gänge.\n    D (int): Die Anzahl der Gesprächspaare im Klassenzimmer.\n    chatting_pairs (Liste von Tupeln): Eine Liste von Tupeln, die jeweils die Positionen (Xi, Yi) und (Pi, Qi) eines Gesprächspaares enthalten.\n\n    Rückgabewerte:\n    (str, str): Zwei durch Leerzeichen getrennte Zeichenfolgen, die die optimalen Reihen- und Spaltenindizes für die Gänge darstellen.\n\n    Die Funktion arbeitet, indem sie die Anzahl der Gesprächspaare zählt, die durch das Hinzufügen eines Gangs an jeder möglichen Position getrennt werden können.\n    Anschließend wählt sie die effektivsten Positionen für Gänge aus, um möglichst viele Gesprächspaare zu trennen.\n\n    Beispiele:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Gibt zurück: ('2', '2 4'), was anzeigt, dass das Platzieren eines Gangs nach Reihe 2 und den Spalten 2 und 4 optimal wäre.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Gibt zurück: ('2', '2'), was anzeigt, dass das Platzieren eines Gangs nach Reihe 2 und Spalte 2 optimal wäre.\n    \"\"\"", "ha": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Inganta sanya hanyoyi a cikin aji don rage yawan hira tsakanin ɗalibai.\n\n    Args:\n    M (int): Yawan layuka a cikin aji.\n    N (int): Yawan ginshiƙai a cikin aji.\n    K (int): Yawan hanyoyi a kwance da za a ƙara.\n    L (int): Yawan hanyoyi a tsaye da za a ƙara.\n    D (int): Yawan ma'aurata masu hira a cikin aji.\n    chatting_pairs (list of tuples): Jerin tuples, kowanne yana ɗauke da wurare (Xi, Yi) da (Pi, Qi) na ma'aurata masu hira.\n\n    Returns:\n    (str, str): Haruffa guda biyu masu sarari suna wakiltar mafi kyawun layi da ginshiƙai don hanyoyin.\n\n    Aikin yana aiki ta hanyar ƙididdige yawan ma'aurata masu hira da za a iya raba ta hanyar ƙara hanya a kowane yuwuwar wuri.\n    Sannan yana zaɓar mafi kyawun wurare don hanyoyi, yana nufin raba ma'aurata masu hira da yawa gwargwadon iko.\n\n    Misalai:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), yana nuna cewa sanya hanya bayan layi na 2 da ginshiƙai na 2 da 4 zai zama mafi kyau.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), yana nuna cewa sanya hanya bayan layi na 2 da ginshiƙi na 2 zai zama mafi kyau.\n    \"\"\"", "hi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    कक्षा में छात्रों के बीच बातचीत की मात्रा को कम करने के लिए गलियारों की व्यवस्था को अनुकूलित करें।\n\n    Args:\n    M (int): कक्षा में पंक्तियों की संख्या।\n    N (int): कक्षा में स्तंभों की संख्या।\n    K (int): जोड़ने के लिए क्षैतिज गलियारों की संख्या।\n    L (int): जोड़ने के लिए लंबवत गलियारों की संख्या।\n    D (int): कक्षा में बातचीत करने वाले जोड़ों की संख्या।\n    chatting_pairs (list of tuples): एक सूची जिसमें प्रत्येक तत्व एक युग्म है, जिसमें बातचीत करने वाले जोड़े की स्थिति (Xi, Yi) और (Pi, Qi) होती है।\n\n    Returns:\n    (str, str): दो स्पेस सेपरेटेड स्ट्रिंग्स जो गलियारों के लिए अनुकूलतम पंक्ति और स्तंभ सूचकांक का प्रतिनिधित्व करती हैं।\n\n    यह फ़ंक्शन प्रत्येक संभावित स्थिति में गलियारा जोड़कर अलग किए जा सकने वाले बातचीत करने वाले जोड़ों की संख्या की गणना करके काम करता है।\n    फिर यह गलियारों के लिए सबसे प्रभावी स्थानों का चयन करता है, जिसका उद्देश्य जितना संभव हो सके उतने बातचीत करने वाले जोड़ों को अलग करना है।\n\n    उदाहरण:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), यह इंगित करता है कि पंक्ति 2 और स्तंभ 2 और 4 के बाद गलियारा रखना अनुकूल होगा।\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), यह इंगित करता है कि पंक्ति 2 और स्तंभ 2 के बाद गलियारा रखना अनुकूल होगा।\n    \"\"\"", "hu": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimalizálja a folyosók elhelyezését egy osztályteremben annak érdekében, hogy minimalizálja a diákok közötti beszélgetések mennyiségét.\n\n    Args:\n    M (int): Az osztályterem sorainak száma.\n    N (int): Az osztályterem oszlopainak száma.\n    K (int): A hozzáadandó vízszintes folyosók száma.\n    L (int): A hozzáadandó függőleges folyosók száma.\n    D (int): A beszélgető párok száma az osztályteremben.\n    chatting_pairs (list of tuples): Egy lista, amely minden egyes beszélgető pár pozícióját (Xi, Yi) és (Pi, Qi) tartalmazza.\n\n    Returns:\n    (str, str): Két szóközzel elválasztott karakterlánc, amelyek a folyosók optimális sor- és oszlopindexeit képviselik.\n\n    A függvény úgy működik, hogy megszámolja a beszélgető párokat, amelyeket el lehet választani egy folyosó hozzáadásával minden lehetséges pozícióban.\n    Ezután kiválasztja a leghatékonyabb pozíciókat a folyosók számára, azzal a céllal, hogy a lehető legtöbb beszélgető párt elválassza.\n\n    Példák:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Visszatér: ('2', '2 4'), ami azt jelzi, hogy a 2. sor és a 2. és 4. oszlop után elhelyezett folyosó lenne optimális.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Visszatér: ('2', '2'), ami azt jelzi, hogy a 2. sor és a 2. oszlop után elhelyezett folyosó lenne optimális.\n    \"\"\"", "es": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimizar la colocación de pasillos en un aula para minimizar la cantidad de conversaciones entre estudiantes.\n\n    Argumentos:\n    M (int): El número de filas en el aula.\n    N (int): El número de columnas en el aula.\n    K (int): El número de pasillos horizontales a añadir.\n    L (int): El número de pasillos verticales a añadir.\n    D (int): El número de pares que conversan en el aula.\n    chatting_pairs (list of tuples): Una lista de tuplas, cada una contiene las posiciones (Xi, Yi) y (Pi, Qi) de un par que conversa.\n\n    Devuelve:\n    (str, str): Dos cadenas separadas por espacios que representan los índices óptimos de filas y columnas para los pasillos.\n\n    La función funciona contando el número de pares que conversan que pueden ser separados añadiendo un pasillo en cada posición posible.\n    Luego selecciona las posiciones más efectivas para los pasillos, con el objetivo de separar la mayor cantidad posible de pares que conversan.\n\n    Ejemplos:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Devuelve: ('2', '2 4'), indicando que colocar un pasillo después de la fila 2 y las columnas 2 y 4 sería óptimo.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Devuelve: ('2', '2'), indicando que colocar un pasillo después de la fila 2 y la columna 2 sería óptimo.\n    \"\"\"", "arb": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    تحسين وضع الممرات في الفصل الدراسي لتقليل كمية الدردشة بين الطلاب.\n\n    يعيدالحجج:\n    M (int): عدد الصفوف في الفصل الدراسي.\n    N (int): عدد الأعمدة في الفصل الدراسي.\n    K (int): عدد الممرات الأفقية التي سيتم إضافتها.\n    L (int): عدد الممرات الرأسية التي سيتم إضافتها.\n    D (int): عدد أزواج الدردشة في الفصل الدراسي.\n    chatting_pairs (list of tuples): قائمة من الأزواج، كل منها يحتوي على المواقع (Xi, Yi) و (Pi, Qi) لزوج دردشة.\n\n    يعيد:\n    (str, str): سلسلتان مفصولتان بمسافة تمثلان مؤشرات الصفوف والأعمدة المثلى للممرات.\n\n    تعمل الدالة عن طريق حساب عدد أزواج الدردشة التي يمكن فصلها بإضافة ممر في كل موقع ممكن.\n    ثم تختار المواقع الأكثر فعالية للممرات، بهدف فصل أكبر عدد ممكن من أزواج الدردشة.\n\n    أمثلة:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    يعيد: ('2', '2 4'), مما يشير إلى أن وضع ممر بعد الصف 2 والأعمدة 2 و4 سيكون الأمثل.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    يعيد: ('2', '2'), مما يشير إلى أن وضع ممر بعد الصف 2 والعمود 2 سيكون الأمثل.\n    \"\"\"", "sw": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Boresha uwekaji wa njia za kupita darasani ili kupunguza mazungumzo kati ya wanafunzi.\n\n    Hoja:\n    M (int): Idadi ya mistari katika darasa.\n    N (int): Idadi ya safu katika darasa.\n    K (int): Idadi ya njia za mlalo za kuongeza.\n    L (int): Idadi ya njia za wima za kuongeza.\n    D (int): Idadi ya wanandoa wanaozungumza katika darasa.\n    chatting_pairs (list of tuples): Orodha ya jozi, kila moja ikiwa na nafasi (Xi, Yi) na (Pi, Qi) ya wanandoa wanaozungumza.\n\n    Inarejesha:\n    (str, str): Kamba mbili zilizotenganishwa na nafasi zinazoonyesha mistari na safu bora kwa njia za kupita.\n\n    Kazi hii inafanya kazi kwa kuhesabu idadi ya wanandoa wanaozungumza ambao wanaweza kutenganishwa kwa kuongeza njia ya kupita katika kila nafasi inayowezekana.\n    Kisha inachagua nafasi bora zaidi za njia za kupita, ikilenga kutenganisha wanandoa wengi wanaozungumza iwezekanavyo.\n\n    Mifano:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Inarejesha: ('2', '2 4'), ikionyesha kuwa kuweka njia ya kupita baada ya mstari wa 2 na safu ya 2 na 4 itakuwa bora.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Inarejesha: ('2', '2'), ikionyesha kuwa kuweka njia ya kupita baada ya mstari wa 2 na safu ya 2 itakuwa bora.\n    \"\"\"", "tr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Bir sınıfta öğrenciler arasındaki sohbet miktarını en aza indirmek için koridorların yerleştirilmesini optimize edin.\n\n    Argümanlar:\n    M (int): Sınıftaki sıra sayısı.\n    N (int): Sınıftaki sütun sayısı.\n    K (int): Eklenmesi gereken yatay koridor sayısı.\n    L (int): Eklenmesi gereken dikey koridor sayısı.\n    D (int): Sınıftaki sohbet eden çiftlerin sayısı.\n    chatting_pairs (list of tuples): Her biri bir sohbet eden çiftin (Xi, Yi) ve (Pi, Qi) pozisyonlarını içeren bir demet listesi.\n\n    Döndürür:\n    (str, str): Koridorlar için en uygun sıra ve sütun indekslerini temsil eden iki boşlukla ayrılmış string.\n\n    Fonksiyon, her olası pozisyonda bir koridor ekleyerek ayrılabilecek sohbet eden çiftlerin sayısını sayarak çalışır.\n    Daha sonra, mümkün olduğunca çok sohbet eden çifti ayırmayı hedefleyerek koridorlar için en etkili pozisyonları seçer.\n\n    Örnekler:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Döndürür: ('2', '2 4'), bu da sıra 2'den sonra ve sütunlar 2 ve 4'ten sonra bir koridor yerleştirmenin optimal olacağını belirtir.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Döndürür: ('2', '2'), bu da sıra 2'den sonra ve sütun 2'den sonra bir koridor yerleştirmenin optimal olacağını belirtir.\n    \"\"\"", "vi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Tối ưu hóa việc bố trí lối đi trong lớp học để giảm thiểu số lượng học sinh nói chuyện với nhau.\n\n    Tham số:\n    M (int): Số hàng trong lớp học.\n    N (int): Số cột trong lớp học.\n    K (int): Số lối đi ngang cần thêm.\n    L (int): Số lối đi dọc cần thêm.\n    D (int): Số cặp học sinh nói chuyện trong lớp.\n    chatting_pairs (list of tuples): Danh sách các bộ giá trị, mỗi bộ chứa vị trí (Xi, Yi) và (Pi, Qi) của một cặp học sinh nói chuyện.\n\n    Trả về:\n    (str, str): Hai chuỗi cách nhau bởi dấu cách đại diện cho chỉ số hàng và cột tối ưu để đặt lối đi.\n\n    Hàm hoạt động bằng cách đếm số lượng cặp học sinh nói chuyện có thể bị ngăn cách bằng cách thêm một lối đi ở mỗi vị trí có thể.\n    Sau đó, nó chọn các vị trí hiệu quả nhất cho lối đi, nhằm mục đích ngăn cách càng nhiều cặp học sinh nói chuyện càng tốt.\n\n    Ví dụ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Trả về: ('2', '2 4'), cho thấy rằng đặt một lối đi sau hàng 2 và các cột 2 và 4 sẽ là tối ưu.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Trả về: ('2', '2'), cho thấy rằng đặt một lối đi sau hàng 2 và cột 2 sẽ là tối ưu.\n    \"\"\"", "id": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimalkan penempatan lorong di dalam kelas untuk meminimalkan jumlah percakapan antara siswa.\n\n    Argumen:\n    M (int): Jumlah baris di dalam kelas.\n    N (int): Jumlah kolom di dalam kelas.\n    K (int): Jumlah lorong horizontal yang akan ditambahkan.\n    L (int): Jumlah lorong vertikal yang akan ditambahkan.\n    D (int): Jumlah pasangan yang bercakap-cakap di dalam kelas.\n    chatting_pairs (list of tuples): Daftar tuple, masing-masing berisi posisi (Xi, Yi) dan (Pi, Qi) dari pasangan yang bercakap-cakap.\n\n    Mengembalikan:\n    (str, str): Dua string yang dipisahkan oleh spasi yang mewakili indeks baris dan kolom optimal untuk lorong.\n\n    Fungsi ini bekerja dengan menghitung jumlah pasangan yang bercakap-cakap yang dapat dipisahkan dengan menambahkan lorong di setiap posisi yang mungkin.\n    Kemudian memilih posisi yang paling efektif untuk lorong, dengan tujuan memisahkan sebanyak mungkin pasangan yang bercakap-cakap.\n\n    Contoh:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Mengembalikan: ('2', '2 4'), menunjukkan bahwa menempatkan lorong setelah baris 2 dan kolom 2 dan 4 akan optimal.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Mengembalikan: ('2', '2'), menunjukkan bahwa menempatkan lorong setelah baris 2 dan kolom 2 akan optimal.\n    \"\"\"", "ja": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    教室内の生徒間の会話を最小限に抑えるために、通路の配置を最適化します。\n\n    Args:\n    M (int): 教室の行数。\n    N (int): 教室の列数。\n    K (int): 追加する水平通路の数。\n    L (int): 追加する垂直通路の数。\n    D (int): 教室内の会話ペアの数。\n    chatting_pairs (list of tuples): 会話ペアの位置 (Xi, Yi) と (Pi, Qi) を含むタプルのリスト。\n\n    Returns:\n    (str, str): 最適な行と列のインデックスを表す2つのスペース区切りの文字列。\n\n    この関数は、各可能な位置に通路を追加することで分離できる会話ペアの数を数えることによって機能します。\n    その後、できるだけ多くの会話ペアを分離することを目指して、通路の最も効果的な位置を選択します。\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.\n    \"\"\"", "ko": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    교실에서 학생들 간의 대화를 최소화하기 위해 통로의 배치를 최적화합니다.\n\n    Args:\n    M (int): 교실의 행 수.\n    N (int): 교실의 열 수.\n    K (int): 추가할 수평 통로의 수.\n    L (int): 추가할 수직 통로의 수.\n    D (int): 교실에서 대화하는 쌍의 수.\n    chatting_pairs (list of tuples): 대화하는 쌍의 위치 (Xi, Yi)와 (Pi, Qi)를 포함하는 튜플의 리스트.\n\n    Returns:\n    (str, str): 통로의 최적 행 및 열 인덱스를 나타내는 두 개의 공백으로 구분된 문자열.\n\n    이 함수는 각 가능한 위치에 통로를 추가하여 분리할 수 있는 대화 쌍의 수를 계산합니다.\n    그런 다음 가능한 한 많은 대화 쌍을 분리하기 위해 가장 효과적인 통로 위치를 선택합니다.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), 이는 행 2와 열 2 및 4 뒤에 통로를 배치하는 것이 최적임을 나타냅니다.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), 이는 행 2와 열 2 뒤에 통로를 배치하는 것이 최적임을 나타냅니다.\n    \"\"\"", "ml": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    ക്ലാസ്സ്‌റൂമിൽ വിദ്യാർത്ഥികൾ തമ്മിലുള്ള സംസാരത്തിന്റെ അളവ് കുറയ്ക്കുന്നതിനായി പാതകളുടെ സ്ഥാനം മെച്ചപ്പെടുത്തുക.\n\n    Args:\n    M (int): ക്ലാസ്സ്‌റൂമിലെ നിരകളുടെ എണ്ണം.\n    N (int): ക്ലാസ്സ്‌റൂമിലെ നിരകളുടെ എണ്ണം.\n    K (int): ചേർക്കേണ്ട കിടക്കുന്ന പാതകളുടെ എണ്ണം.\n    L (int): ചേർക്കേണ്ട ലംബ പാതകളുടെ എണ്ണം.\n    D (int): ക്ലാസ്സ്‌റൂമിലെ സംസാരിക്കുന്ന ജോഡികളുടെ എണ്ണം.\n    chatting_pairs (list of tuples): ഓരോന്നും സംസാരിക്കുന്ന ജോഡിയുടെ സ്ഥാനങ്ങൾ (Xi, Yi) and (Pi, Qi) ഉൾക്കൊള്ളുന്ന ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\n    Returns:\n    (str, str): പാതകൾക്കായി ഏറ്റവും അനുയോജ്യമായ നിര, നിര നിരക്കുകൾ പ്രതിനിധീകരിക്കുന്ന രണ്ട് സ്പേസ്-വേരിട്ട സ്ട്രിംഗുകൾ.\n\n    ഓരോ സാധ്യതയുള്ള സ്ഥാനത്തും പാത ചേർക്കുന്നതിലൂടെ വേർതിരിക്കാവുന്ന സംസാരിക്കുന്ന ജോഡികളുടെ എണ്ണം എണ്ണുന്നതിനാൽ ഫംഗ്ഷൻ പ്രവർത്തിക്കുന്നു.\n    തുടർന്ന് όσο കൂടുതൽ സംസാരിക്കുന്ന ജോഡികളെ വേർതിരിക്കാൻ കഴിയുന്ന സ്ഥാനങ്ങൾ തിരഞ്ഞെടുക്കുന്നു.\n\n    ഉദാഹരണങ്ങൾ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), നിര 2-ന്റെ ശേഷം പാതയും നിരകൾ 2, 4 എന്നിവയുടെ ശേഷം പാതയും സ്ഥാപിക്കുന്നത് ഏറ്റവും അനുയോജ്യമായിരിക്കും എന്ന് സൂചിപ്പിക്കുന്നു.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), നിര 2-ന്റെ ശേഷം പാതയും നിര 2-ന്റെ ശേഷം പാതയും സ്ഥാപിക്കുന്നത് ഏറ്റവും അനുയോജ്യമായിരിക്കും എന്ന് സൂചിപ്പിക്കുന്നു.\n    \"\"\"", "fa": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    بهینه‌سازی قرارگیری راهروها در یک کلاس درس برای به حداقل رساندن میزان صحبت کردن بین دانش‌آموزان.\n\n    Args:\n    M (int): تعداد ردیف‌ها در کلاس درس.\n    N (int): تعداد ستون‌ها در کلاس درس.\n    K (int): تعداد راهروهای افقی که باید اضافه شوند.\n    L (int): تعداد راهروهای عمودی که باید اضافه شوند.\n    D (int): تعداد زوج‌های صحبت‌کننده در کلاس درس.\n    chatting_pairs (list of tuples): لیستی از زوج‌ها که هر کدام شامل موقعیت‌های (Xi, Yi) و (Pi, Qi) یک زوج صحبت‌کننده است.\n\n    Returns:\n    (str, str): دو رشته جدا شده با فاصله که نمایانگر شاخص‌های ردیف و ستون بهینه برای راهروها هستند.\n\n    این تابع با شمارش تعداد زوج‌های صحبت‌کننده که می‌توان با افزودن یک راهرو در هر موقعیت ممکن جدا کرد، کار می‌کند.\n    سپس مؤثرترین موقعیت‌ها برای راهروها را انتخاب می‌کند، با هدف جدا کردن هر چه بیشتر زوج‌های صحبت‌کننده.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), که نشان می‌دهد قرار دادن یک راهرو بعد از ردیف 2 و ستون‌های 2 و 4 بهینه خواهد بود.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), که نشان می‌دهد قرار دادن یک راهرو بعد از ردیف 2 و ستون 2 بهینه خواهد بود.\n    \"\"\""}, "canonical_solution": "# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)", "instruction": {"en": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nBa da taƙaitaccen bayani a cikin yare na halitta (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\n以下のPythonコードに対する簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nPython 코드에 대한 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nPython കോഡിന് 500 അക്ഷരങ്ങൾക്കുള്ളിൽ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nتوضیحی مختصر به زبان طبیعی (docstring) از کد پایتون به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_optimize_seating():\n    test_cases = [\n        # Test case 1 from the provided example\n        {\n            'M': 4, 'N': 5, 'K': 1, 'L': 2, 'D': 3,\n            'chatting_pairs': [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)],\n            'expected': ('2', '2 4')\n        },\n        # Corrected Test case 2\n        {\n            'M': 5, 'N': 6, 'K': 2, 'L': 3, 'D': 4,\n            'chatting_pairs': [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 6), (5, 1, 5, 2)],\n            'expected': ('1 2', '1 2 5')  # Corrected expected output\n        },\n        # Test case 3\n        {\n            'M': 3, 'N': 3, 'K': 1, 'L': 1, 'D': 2,\n            'chatting_pairs': [(1, 2, 1, 3), (2, 1, 3, 1)],\n            'expected': ('2', '2')\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        row_output, col_output = optimize_seating(\n            test['M'], test['N'], test['K'], test['L'], test['D'], test['chatting_pairs']\n        )\n        assert row_output == test['expected'][0], f\"Test case {i} failed: row_output {row_output} does not match expected {test['expected'][0]}\"\n        assert col_output == test['expected'][1], f\"Test case {i} failed: col_output {col_output} does not match expected {test['expected'][1]}\"\n        print(f\"Test case {i} passed.\")\n\n# Run the test function\ntest_optimize_seating()", "entry_point": "optimize_seating", "signature": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):", "docstring": {"en": "Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\nArgs:\nM (int): The number of rows in the classroom.\nN (int): The number of columns in the classroom.\nK (int): The number of horizontal aisles to add.\nL (int): The number of vertical aisles to add.\nD (int): The number of chatting pairs in the classroom.\nchatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\nReturns:\n(str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\nThe function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\nIt then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.", "sq": "Optimizoni vendosjen e korridoreve në një klasë për të minimizuar sasinë e bisedave midis studentëve.\n\nArgumentet:\nM (int): Numri i rreshtave në klasë.\nN (int): Numri i kolonave në klasë.\nK (int): Numri i korridoreve horizontale për të shtuar.\nL (int): Numri i korridoreve vertikale për të shtuar.\nD (int): Numri i çifteve që bisedojnë në klasë.\nchatting_pairs (list of tuples): Një listë tuples, secila që përmban pozicionet (Xi, Yi) dhe (Pi, Qi) të një çifti që bisedon.\n\nKthen:\n(str, str): Dy vargje të ndara me hapësirë që përfaqësojnë indeksat optimalë të rreshtave dhe kolonave për korridoret.\n\nFunksioni punon duke numëruar numrin e çifteve që bisedojnë që mund të ndahen duke shtuar një korridor në secilën pozicion të mundshëm.\nPastaj zgjedh pozicionet më efektive për korridoret, duke synuar të ndajë sa më shumë çifte që bisedojnë të jetë e mundur.\n\nShembuj:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nKthen: ('2', '2 4'), duke treguar se vendosja e një korridori pas rreshtit 2 dhe kolonave 2 dhe 4 do të ishte optimale.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nKthen: ('2', '2'), duke treguar se vendosja e një korridori pas rreshtit 2 dhe kolonës 2 do të ishte optimale.", "hy": "Դասարանում անցուղիների տեղադրումը օպտիմալացնել՝ նվազեցնելու ուսանողների միջև զրույցների քանակը:\n\nԱրգումենտներ:\nM (int): Դասարանի շարքերի քանակը:\nN (int): Դասարանի սյուների քանակը:\nK (int): Ավելացվող հորիզոնական անցուղիների քանակը:\nL (int): Ավելացվող ուղղահայաց անցուղիների քանակը:\nD (int): Դասարանում զրուցող զույգերի քանակը:\nchatting_pairs (ցանկ տուփլերի): Տուփլերի ցանկ, որոնցից յուրաքանչյուրը պարունակում է զրուցող զույգի դիրքերը (Xi, Yi) և (Pi, Qi):\n\nՎերադարձնում է:\n(str, str): Երկու բացատով բաժանված տողեր, որոնք ներկայացնում են անցուղիների օպտիմալ շարքի և սյունակի ինդեքսները:\n\nՖունկցիան աշխատում է՝ հաշվելով զրուցող զույգերի քանակը, որոնք կարող են բաժանվել՝ յուրաքանչյուր հնարավոր դիրքում անցուղի ավելացնելով:\nԱյնուհետև ընտրում է անցուղիների ամենաարդյունավետ դիրքերը՝ նպատակ ունենալով բաժանել որքան հնարավոր է շատ զրուցող զույգեր:\n\nՕրինակներ:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nՎերադարձնում է: ('2', '2 4'), որը ցույց է տալիս, որ 2-րդ շարքից և 2 և 4 սյուներից հետո անցուղի տեղադրելը օպտիմալ կլինի:\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nՎերադարձնում է: ('2', '2'), որը ցույց է տալիս, որ 2-րդ շարքից և 2-րդ սյունից հետո անցուղի տեղադրելը օպտիմալ կլինի:", "bn": "শ্রেণীকক্ষে আইলগুলির অবস্থান অপ্টিমাইজ করুন যাতে শিক্ষার্থীদের মধ্যে আলাপচারিতা কমানো যায়।\n\nআর্গস:\nM (int): শ্রেণীকক্ষে সারির সংখ্যা।\nN (int): শ্রেণীকক্ষে কলামের সংখ্যা।\nK (int): যোগ করার জন্য অনুভূমিক আইলের সংখ্যা।\nL (int): যোগ করার জন্য উল্লম্ব আইলের সংখ্যা।\nD (int): শ্রেণীকক্ষে আলাপচারিতার জোড়ার সংখ্যা।\nchatting_pairs (list of tuples): একটি তালিকা যার প্রতিটি টুপলে একটি আলাপচারিতার জোড়ার অবস্থান (Xi, Yi) এবং (Pi, Qi) অন্তর্ভুক্ত।\n\nরিটার্নস:\n(str, str): দুটি স্পেস-আলাদা স্ট্রিং যা আইলগুলির জন্য সর্বোত্তম সারি এবং কলামের সূচকগুলি উপস্থাপন করে।\n\nএই ফাংশনটি প্রতিটি সম্ভাব্য অবস্থানে একটি আইল যোগ করার মাধ্যমে কতগুলি আলাপচারিতার জোড়া আলাদা করা যেতে পারে তা গণনা করে কাজ করে।\nএরপর এটি আইলগুলির জন্য সবচেয়ে কার্যকর অবস্থানগুলি নির্বাচন করে, যতটা সম্ভব আলাপচারিতার জোড়া আলাদা করার লক্ষ্য নিয়ে।\n\nউদাহরণ:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nরিটার্নস: ('2', '2 4'), যা নির্দেশ করে যে সারি 2 এবং কলাম 2 এবং 4 এর পরে একটি আইল স্থাপন করা সর্বোত্তম হবে।\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nরিটার্নস: ('2', '2'), যা নির্দেশ করে যে সারি 2 এবং কলাম 2 এর পরে একটি আইল স্থাপন করা সর্বোত্তম হবে।", "bg": "Оптимизирайте разположението на пътеките в класната стая, за да минимизирате количеството разговори между учениците.\n\nАргументи:\nM (int): Броят на редовете в класната стая.\nN (int): Броят на колоните в класната стая.\nK (int): Броят на хоризонталните пътеки за добавяне.\nL (int): Броят на вертикалните пътеки за добавяне.\nD (int): Броят на двойките, които разговарят в класната стая.\nchatting_pairs (списък от кортежи): Списък от кортежи, всеки от които съдържа позициите (Xi, Yi) и (Pi, Qi) на двойка, която разговаря.\n\nВръща:\n(str, str): Два разделени с интервал низа, представляващи оптималните индекси на редовете и колоните за пътеките.\n\nФункцията работи, като брои броя на двойките, които разговарят и които могат да бъдат разделени чрез добавяне на пътека на всяка възможна позиция.\nСлед това избира най-ефективните позиции за пътеки, с цел да раздели възможно най-много двойки, които разговарят.\n\nПримери:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nВръща: ('2', '2 4'), което означава, че поставянето на пътека след ред 2 и колони 2 и 4 би било оптимално.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nВръща: ('2', '2'), което означава, че поставянето на пътека след ред 2 и колона 2 би било оптимално.", "zh": "优化教室中走道的布局，以最小化学生之间的聊天量。\n\n参数：\nM (int): 教室中的行数。\nN (int): 教室中的列数。\nK (int): 要添加的水平走道数量。\nL (int): 要添加的垂直走道数量。\nD (int): 教室中聊天对的数量。\nchatting_pairs (list of tuples): 一个元组列表，每个元组包含一个聊天对的位置 (Xi, Yi) 和 (Pi, Qi)。\n\n返回：\n(str, str): 两个以空格分隔的字符串，表示走道的最佳行和列索引。\n\n该函数通过计算可以通过在每个可能位置添加走道来分隔的聊天对数量来工作。\n然后选择最有效的走道位置，旨在尽可能多地分隔聊天对。\n\n示例：\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n返回: ('2', '2 4')，表示在第2行之后和第2列及第4列之后放置走道是最佳选择。\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n返回: ('2', '2')，表示在第2行之后和第2列之后放置走道是最佳选择。", "fr": "Optimiser le placement des allées dans une salle de classe pour minimiser la quantité de bavardage entre les étudiants.\n\nArgs:\nM (int): Le nombre de rangées dans la salle de classe.\nN (int): Le nombre de colonnes dans la salle de classe.\nK (int): Le nombre d'allées horizontales à ajouter.\nL (int): Le nombre d'allées verticales à ajouter.\nD (int): Le nombre de paires bavardes dans la salle de classe.\nchatting_pairs (list of tuples): Une liste de tuples, chacun contenant les positions (Xi, Yi) et (Pi, Qi) d'une paire bavarde.\n\nReturns:\n(str, str): Deux chaînes séparées par des espaces représentant les indices optimaux des rangées et colonnes pour les allées.\n\nLa fonction fonctionne en comptant le nombre de paires bavardes qui peuvent être séparées en ajoutant une allée à chaque position possible.\nElle sélectionne ensuite les positions les plus efficaces pour les allées, visant à séparer autant de paires bavardes que possible.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), indiquant que placer une allée après la rangée 2 et les colonnes 2 et 4 serait optimal.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), indiquant que placer une allée après la rangée 2 et la colonne 2 serait optimal.", "de": "Optimieren Sie die Platzierung von Gängen in einem Klassenzimmer, um die Menge an Gesprächen zwischen Schülern zu minimieren.\n\nArgs:\nM (int): Die Anzahl der Reihen im Klassenzimmer.\nN (int): Die Anzahl der Spalten im Klassenzimmer.\nK (int): Die Anzahl der hinzuzufügenden horizontalen Gänge.\nL (int): Die Anzahl der hinzuzufügenden vertikalen Gänge.\nD (int): Die Anzahl der plaudernden Paare im Klassenzimmer.\nchatting_pairs (list of tuples): Eine Liste von Tupeln, die jeweils die Positionen (Xi, Yi) und (Pi, Qi) eines plaudernden Paares enthalten.\n\nReturns:\n(str, str): Zwei durch Leerzeichen getrennte Zeichenfolgen, die die optimalen Reihen- und Spaltenindizes für die Gänge darstellen.\n\nDie Funktion arbeitet, indem sie die Anzahl der plaudernden Paare zählt, die durch das Hinzufügen eines Gangs an jeder möglichen Position getrennt werden können.\nAnschließend wählt sie die effektivsten Positionen für Gänge aus, um möglichst viele plaudernde Paare zu trennen.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), was anzeigt, dass das Platzieren eines Gangs nach Reihe 2 und den Spalten 2 und 4 optimal wäre.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), was anzeigt, dass das Platzieren eines Gangs nach Reihe 2 und Spalte 2 optimal wäre.", "ha": "Inganta wuraren da aka sanya hanyoyin a cikin aji don rage yawan hira tsakanin ɗalibai.\n\nArgs:\nM (int): Yawan layuka a cikin aji.\nN (int): Yawan ginshiƙai a cikin aji.\nK (int): Yawan hanyoyin kwance da za a ƙara.\nL (int): Yawan hanyoyin tsaye da za a ƙara.\nD (int): Yawan ma'auratan hira a cikin aji.\nchatting_pairs (jerin tuples): Jerin tuples, kowanne yana ɗauke da wuraren (Xi, Yi) da (Pi, Qi) na ma'auratan hira.\n\nReturns:\n(str, str): Kalmomi biyu da aka raba da sarari suna wakiltar mafi kyawun layi da ginshiƙai don hanyoyin.\n\nAikin yana aiki ta hanyar ƙidaya yawan ma'auratan hira da za a iya raba ta hanyar ƙara hanya a kowane matsayi mai yiwuwa.\nSannan yana zaɓar mafi ingantattun wurare don hanyoyin, yana nufin raba yawan ma'auratan hira kamar yadda zai yiwu.\n\nMisalai:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), yana nuna cewa sanya hanya bayan layi na 2 da ginshiƙai na 2 da 4 zai zama mafi kyau.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), yana nuna cewa sanya hanya bayan layi na 2 da ginshiƙi na 2 zai zama mafi kyau.", "hi": "कक्षा में गलियारों के स्थान को इस प्रकार अनुकूलित करें कि छात्रों के बीच बातचीत की मात्रा न्यूनतम हो सके।\n\nआर्ग्स:\nM (int): कक्षा में पंक्तियों की संख्या।\nN (int): कक्षा में स्तंभों की संख्या।\nK (int): जोड़ने के लिए क्षैतिज गलियारों की संख्या।\nL (int): जोड़ने के लिए लंबवत गलियारों की संख्या।\nD (int): कक्षा में बातचीत करने वाले जोड़ों की संख्या।\nchatting_pairs (list of tuples): ट्यूपल्स की एक सूची, जिसमें प्रत्येक में बातचीत करने वाले जोड़े की स्थिति (Xi, Yi) और (Pi, Qi) होती है।\n\nरिटर्न्स:\n(str, str): दो स्पेस से अलग किए गए स्ट्रिंग्स जो गलियारों के लिए अनुकूलतम पंक्ति और स्तंभ सूचकांक का प्रतिनिधित्व करते हैं।\n\nयह फ़ंक्शन प्रत्येक संभावित स्थिति में गलियारा जोड़कर अलग किए जा सकने वाले बातचीत करने वाले जोड़ों की संख्या की गणना करता है। फिर यह गलियारों के लिए सबसे प्रभावी स्थानों का चयन करता है, जिसका उद्देश्य जितना संभव हो उतने बातचीत करने वाले जोड़ों को अलग करना है।\n\nउदाहरण:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nरिटर्न करता है: ('2', '2 4'), जो इंगित करता है कि पंक्ति 2 के बाद और स्तंभ 2 और 4 के बाद गलियारा रखना अनुकूलतम होगा।\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nरिटर्न करता है: ('2', '2'), जो इंगित करता है कि पंक्ति 2 के बाद और स्तंभ 2 के बाद गलियारा रखना अनुकूलतम होगा।", "hu": "Optimalizálja a folyosók elhelyezését egy tanteremben, hogy minimalizálja a diákok közötti beszélgetések mennyiségét.\n\nArgs:\nM (int): A tanterem sorainak száma.\nN (int): A tanterem oszlopainak száma.\nK (int): A hozzáadandó vízszintes folyosók száma.\nL (int): A hozzáadandó függőleges folyosók száma.\nD (int): A tanteremben lévő beszélgető párok száma.\nchatting_pairs (list of tuples): Egy listája a tuple-öknek, amelyek mindegyike tartalmazza egy beszélgető pár pozícióit (Xi, Yi) és (Pi, Qi).\n\nReturns:\n(str, str): Két szóközzel elválasztott karakterlánc, amelyek a folyosók optimális sor- és oszlopindexeit képviselik.\n\nA függvény úgy működik, hogy megszámolja a beszélgető párok számát, amelyeket el lehet választani egy folyosó hozzáadásával minden lehetséges pozícióban.\nEzután kiválasztja a leghatékonyabb pozíciókat a folyosók számára, azzal a céllal, hogy a lehető legtöbb beszélgető párt elválassza.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), ami azt jelzi, hogy a 2. sor és a 2. és 4. oszlop után elhelyezett folyosó optimális lenne.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), ami azt jelzi, hogy a 2. sor és a 2. oszlop után elhelyezett folyosó optimális lenne.", "es": "Optimizar la colocación de los pasillos en un aula para minimizar la cantidad de charlas entre estudiantes.\n\nArgumentos:\nM (int): El número de filas en el aula.\nN (int): El número de columnas en el aula.\nK (int): El número de pasillos horizontales a añadir.\nL (int): El número de pasillos verticales a añadir.\nD (int): El número de pares que charlan en el aula.\nchatting_pairs (list of tuples): Una lista de tuplas, cada una conteniendo las posiciones (Xi, Yi) y (Pi, Qi) de un par que charla.\n\nDevuelve:\n(str, str): Dos cadenas separadas por espacios que representan los índices óptimos de filas y columnas para los pasillos.\n\nLa función trabaja contando el número de pares que charlan y que pueden ser separados añadiendo un pasillo en cada posición posible.\nLuego selecciona las posiciones más efectivas para los pasillos, con el objetivo de separar la mayor cantidad de pares que charlan posible.\n\nEjemplos:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nDevuelve: ('2', '2 4'), indicando que colocar un pasillo después de la fila 2 y las columnas 2 y 4 sería óptimo.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nDevuelve: ('2', '2'), indicando que colocar un pasillo después de la fila 2 y la columna 2 sería óptimo.", "arb": "تحسين وضع الممرات في الفصل الدراسي لتقليل كمية الدردشة بين الطلاب.\n\nيعيدالحجج:\nM (int): عدد الصفوف في الفصل الدراسي.\nN (int): عدد الأعمدة في الفصل الدراسي.\nK (int): عدد الممرات الأفقية التي يجب إضافتها.\nL (int): عدد الممرات العمودية التي يجب إضافتها.\nD (int): عدد أزواج الدردشة في الفصل الدراسي.\nchatting_pairs (list of tuples): قائمة من الأزواج، كل منها يحتوي على المواقع (Xi, Yi) و (Pi, Qi) لزوج دردشة.\n\nيعيد:\n(str, str): سلسلتان مفصولتان بمسافة تمثلان مؤشرات الصفوف والأعمدة المثلى للممرات.\n\nتعمل الدالة عن طريق حساب عدد أزواج الدردشة التي يمكن فصلها بإضافة ممر في كل موضع ممكن.\nثم تختار المواضع الأكثر فعالية للممرات، بهدف فصل أكبر عدد ممكن من أزواج الدردشة.\n\nامثله:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nيعيد: ('2', '2 4')، مما يشير إلى أن وضع ممر بعد الصف 2 والأعمدة 2 و 4 سيكون الأمثل.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nيعيد: ('2', '2')، مما يشير إلى أن وضع ممر بعد الصف 2 والعمود 2 سيكون الأمثل.", "sw": "Optimize uwekaji wa njia za kupita darasani ili kupunguza mazungumzo kati ya wanafunzi.\n\nHoja:\nM (int): Idadi ya safu katika darasa.\nN (int): Idadi ya safu wima katika darasa.\nK (int): Idadi ya njia za kupita za usawa za kuongeza.\nL (int): Idadi ya njia za kupita za wima za kuongeza.\nD (int): Idadi ya jozi za wanaozungumza darasani.\nchatting_pairs (list of tuples): Orodha ya jozi, kila moja ikiwa na nafasi (Xi, Yi) na (Pi, Qi) ya jozi inayozungumza.\n\nInarejesha:\n(str, str): Mistari miwili iliyotenganishwa na nafasi inayoonyesha faharasa bora za safu na safu wima kwa ajili ya njia za kupita.\n\nKazi hii inafanya kazi kwa kuhesabu idadi ya jozi za wanaozungumza ambazo zinaweza kutenganishwa kwa kuongeza njia ya kupita katika kila nafasi inayowezekana. Kisha inachagua nafasi bora zaidi za njia za kupita, ikilenga kutenganisha jozi nyingi za wanaozungumza iwezekanavyo.\n\nMifano:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nInarejesha: ('2', '2 4'), ikionyesha kwamba kuweka njia ya kupita baada ya safu ya 2 na safu wima 2 na 4 itakuwa bora.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nInarejesha: ('2', '2'), ikionyesha kwamba kuweka njia ya kupita baada ya safu ya 2 na safu wima ya 2 itakuwa bora.", "tr": "Sınıfta koridorların yerleşimini optimize ederek öğrenciler arasındaki konuşma miktarını en aza indirin.\n\nArgümanlar:\nM (int): Sınıftaki sıra sayısı.\nN (int): Sınıftaki sütun sayısı.\nK (int): Eklenecek yatay koridor sayısı.\nL (int): Eklenecek dikey koridor sayısı.\nD (int): Sınıftaki konuşan çiftlerin sayısı.\nchatting_pairs (list of tuples): Her biri bir konuşan çiftin pozisyonlarını (Xi, Yi) ve (Pi, Qi) içeren bir demet listesi.\n\nDöndürür:\n(str, str): Koridorlar için en uygun sıra ve sütun indekslerini temsil eden iki boşlukla ayrılmış string.\n\nFonksiyon, her olası pozisyonda bir koridor ekleyerek ayrılabilecek konuşan çiftlerin sayısını sayarak çalışır.\nDaha sonra, mümkün olduğunca çok konuşan çifti ayırmayı hedefleyerek koridorlar için en etkili pozisyonları seçer.\n\nÖrnekler:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nDöndürür: ('2', '2 4'), bu, sıra 2'den sonra ve sütunlar 2 ve 4'ten sonra bir koridor yerleştirmenin optimal olacağını belirtir.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nDöndürür: ('2', '2'), bu, sıra 2'den sonra ve sütun 2'den sonra bir koridor yerleştirmenin optimal olacağını belirtir.", "vi": "Tối ưu hóa việc bố trí lối đi trong một lớp học để giảm thiểu lượng trò chuyện giữa các học sinh.\n\nTham số:\nM (int): Số hàng trong lớp học.\nN (int): Số cột trong lớp học.\nK (int): Số lối đi ngang cần thêm.\nL (int): Số lối đi dọc cần thêm.\nD (int): Số cặp trò chuyện trong lớp học.\nchatting_pairs (list of tuples): Một danh sách các bộ giá trị, mỗi bộ chứa vị trí (Xi, Yi) và (Pi, Qi) của một cặp trò chuyện.\n\nTrả về:\n(str, str): Hai chuỗi cách nhau bởi dấu cách đại diện cho chỉ số hàng và cột tối ưu cho các lối đi.\n\nHàm hoạt động bằng cách đếm số cặp trò chuyện có thể được tách ra bằng cách thêm một lối đi ở mỗi vị trí có thể.\nSau đó, nó chọn các vị trí hiệu quả nhất cho các lối đi, nhằm tách ra càng nhiều cặp trò chuyện càng tốt.\n\nVí dụ:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nTrả về: ('2', '2 4'), chỉ ra rằng việc đặt một lối đi sau hàng 2 và các cột 2 và 4 sẽ là tối ưu.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nTrả về: ('2', '2'), chỉ ra rằng việc đặt một lối đi sau hàng 2 và cột 2 sẽ là tối ưu.", "id": "Optimalkan penempatan lorong di dalam kelas untuk meminimalkan jumlah percakapan antara siswa.\n\nArgs:\nM (int): Jumlah baris di dalam kelas.\nN (int): Jumlah kolom di dalam kelas.\nK (int): Jumlah lorong horizontal yang akan ditambahkan.\nL (int): Jumlah lorong vertikal yang akan ditambahkan.\nD (int): Jumlah pasangan yang bercakap-cakap di dalam kelas.\nchatting_pairs (list of tuples): Daftar tuple, masing-masing berisi posisi (Xi, Yi) dan (Pi, Qi) dari pasangan yang bercakap-cakap.\n\nReturns:\n(str, str): Dua string yang dipisahkan oleh spasi yang mewakili indeks baris dan kolom optimal untuk lorong.\n\nFungsi ini bekerja dengan menghitung jumlah pasangan yang bercakap-cakap yang dapat dipisahkan dengan menambahkan lorong di setiap posisi yang mungkin.\nKemudian memilih posisi yang paling efektif untuk lorong, dengan tujuan memisahkan sebanyak mungkin pasangan yang bercakap-cakap.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), menunjukkan bahwa menempatkan lorong setelah baris 2 dan kolom 2 dan 4 akan menjadi optimal.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), menunjukkan bahwa menempatkan lorong setelah baris 2 dan kolom 2 akan menjadi optimal.", "ja": "教室内の通路の配置を最適化し、生徒間の会話を最小限に抑えます。\n\nArgs:\nM (int): 教室の行数。\nN (int): 教室の列数。\nK (int): 追加する水平通路の数。\nL (int): 追加する垂直通路の数。\nD (int): 教室内の会話ペアの数。\nchatting_pairs (list of tuples): 会話ペアの位置 (Xi, Yi) と (Pi, Qi) を含むタプルのリスト。\n\nReturns:\n(str, str): 通路の最適な行と列のインデックスを表す2つのスペース区切りの文字列。\n\nこの関数は、各可能な位置に通路を追加することで分離できる会話ペアの数をカウントすることによって機能します。\nその後、可能な限り多くの会話ペアを分離することを目指して、通路の最も効果的な位置を選択します。\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), これは、行2の後と列2および4の後に通路を配置することが最適であることを示しています。\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), これは、行2の後と列2の後に通路を配置することが最適であることを示しています。", "ko": "교실에서 학생들 간의 대화를 최소화하기 위해 통로의 배치를 최적화합니다.\n\nArgs:\nM (int): 교실의 행 수.\nN (int): 교실의 열 수.\nK (int): 추가할 수평 통로의 수.\nL (int): 추가할 수직 통로의 수.\nD (int): 교실 내 대화 쌍의 수.\nchatting_pairs (list of tuples): 각 대화 쌍의 위치 (Xi, Yi)와 (Pi, Qi)를 포함하는 튜플의 리스트.\n\nReturns:\n(str, str): 통로의 최적 행 및 열 인덱스를 나타내는 두 개의 공백으로 구분된 문자열.\n\n이 함수는 각 가능한 위치에 통로를 추가하여 분리할 수 있는 대화 쌍의 수를 계산합니다.\n그런 다음 가능한 한 많은 대화 쌍을 분리하기 위해 가장 효과적인 통로 위치를 선택합니다.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), 이는 행 2와 열 2 및 4 뒤에 통로를 배치하는 것이 최적임을 나타냅니다.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), 이는 행 2와 열 2 뒤에 통로를 배치하는 것이 최적임을 나타냅니다.", "ml": "ക്ലാസ് മുറിയിലെ വിദ്യാർത്ഥികൾ തമ്മിലുള്ള സംഭാഷണം കുറയ്ക്കുന്നതിനായി പാതകളുടെ സ്ഥാനം മെച്ചപ്പെടുത്തുക.\n\nആർഗ്സ്:\nM (int): ക്ലാസ് മുറിയിലെ നിരകളുടെ എണ്ണം.\nN (int): ക്ലാസ് മുറിയിലെ നിരകളുടെ എണ്ണം.\nK (int): ചേർക്കേണ്ട തിരശ്ചീന പാതകളുടെ എണ്ണം.\nL (int): ചേർക്കേണ്ട ലംബ പാതകളുടെ എണ്ണം.\nD (int): ക്ലാസ് മുറിയിലെ സംഭാഷണ ജോഡികളുടെ എണ്ണം.\nchatting_pairs (list of tuples): ഓരോന്നും ഒരു സംഭാഷണ ജോഡിയുടെ സ്ഥാനങ്ങൾ (Xi, Yi) and (Pi, Qi) അടങ്ങിയ ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\nറിട്ടേൺസ്:\n(str, str): പാതകൾക്കായി ഏറ്റവും അനുയോജ്യമായ നിര, നിര സൂചികകൾ പ്രതിനിധീകരിക്കുന്ന രണ്ട് സ്പേസ്-വേർപ്പെടുത്തിയ സ്ട്രിംഗുകൾ.\n\nപ്രതിയോഗ്യമായ ഓരോ സ്ഥാനത്തും ഒരു പാത ചേർക്കുന്നതിലൂടെ വേർതിരിക്കാവുന്ന സംഭാഷണ ജോഡികളുടെ എണ്ണം എണ്ണുന്നതിലൂടെ ഫംഗ്ഷൻ പ്രവർത്തിക്കുന്നു. \nഅതിനുശേഷം, സാധ്യമായത്ര സംഭാഷണ ജോഡികളെ വേർതിരിക്കാൻ ലക്ഷ്യമിട്ട് പാതകൾക്കായി ഏറ്റവും ഫലപ്രദമായ സ്ഥാനങ്ങൾ തിരഞ്ഞെടുക്കുന്നു.\n\nഉദാഹരണങ്ങൾ:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nറിട്ടേൺസ്: ('2', '2 4'), നിര 2-നും നിര 2, 4-നും ശേഷം ഒരു പാത സ്ഥാപിക്കുന്നത് ഏറ്റവും അനുയോജ്യമാണെന്ന് സൂചിപ്പിക്കുന്നു.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nറിട്ടേൺസ്: ('2', '2'), നിര 2-നും നിര 2-നും ശേഷം ഒരു പാത സ്ഥാപിക്കുന്നത് ഏറ്റവും അനുയോജ്യമാണെന്ന് സൂചിപ്പിക്കുന്നു.", "fa": "بهینه‌سازی جای‌گذاری راهروها در یک کلاس درس به منظور کاهش میزان صحبت کردن بین دانش‌آموزان.\n\nآرگومان‌ها:\nM (int): تعداد ردیف‌ها در کلاس درس.\nN (int): تعداد ستون‌ها در کلاس درس.\nK (int): تعداد راهروهای افقی که باید اضافه شوند.\nL (int): تعداد راهروهای عمودی که باید اضافه شوند.\nD (int): تعداد زوج‌های صحبت‌کننده در کلاس درس.\nchatting_pairs (list of tuples): لیستی از زوج‌ها، که هر کدام شامل موقعیت‌های (Xi, Yi) و (Pi, Qi) یک زوج صحبت‌کننده هستند.\n\nبازگشت:\n(str, str): دو رشته جدا شده با فاصله که نمایانگر شاخص‌های ردیف و ستون بهینه برای راهروها هستند.\n\nاین تابع با شمارش تعداد زوج‌های صحبت‌کننده که می‌توانند با اضافه کردن یک راهرو در هر موقعیت ممکن جدا شوند، کار می‌کند.\nسپس مؤثرترین موقعیت‌ها برای راهروها را انتخاب می‌کند، با هدف جدا کردن هر چه بیشتر زوج‌های صحبت‌کننده.\n\nمثال‌ها:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nبازگشت: ('2', '2 4')، نشان‌دهنده این است که قرار دادن یک راهرو بعد از ردیف 2 و ستون‌های 2 و 4 بهینه خواهد بود.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nبازگشت: ('2', '2')، نشان‌دهنده این است که قرار دادن یک راهرو بعد از ردیف 2 و ستون 2 بهینه خواهد بود."}}
{"task_id": "Python/16", "prompt": {"en": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    Case 1:\n    For n = 3 students and m = 3 passes, the function should return 2.\n    There are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\n    Case 2:\n    For n = 4 students and m = 2 passes, the function should return 2.\n    There are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\n    Case 3:\n    For n = 5 students and m = 4 passes, the function should return 6.\n    The sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    and 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # The code implementation would go here.", "sq": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Numëron numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve të rregulluar në një rreth\n    në mënyrë që pas 'm' kalimesh, topi të kthehet te studenti fillestar.\n\n    Funksioni përdor programimin dinamik për të përcaktuar numrin e sekuencave të kalimit. Çdo student\n    mund ta kalojë topin ose te fqinji i majtë ose te fqinji i djathtë.\n\n    Argumentet:\n    n: Numri i studentëve që qëndrojnë në një rreth.\n    m: Numri i herëve që topi kalohet.\n\n    Kthen:\n    Një numër i plotë që përfaqëson numrin e mënyrave të dallueshme të kalimit që rezultojnë në kthimin e topit\n    te studenti fillestar pas 'm' kalimesh.\n\n    Rastet:\n    Rasti 1:\n    Për n = 3 studentë dhe m = 3 kalime, funksioni duhet të kthejë 2.\n    Ka dy sekuenca: 1 -> 2 -> 3 -> 1 dhe 1 -> 3 -> 2 -> 1.\n\n    Rasti 2:\n    Për n = 4 studentë dhe m = 2 kalime, funksioni duhet të kthejë 2.\n    Ka dy sekuenca: 1 -> 2 -> 1 dhe 1 -> 4 -> 1.\n\n    Rasti 3:\n    Për n = 5 studentë dhe m = 4 kalime, funksioni duhet të kthejë 6.\n    Sekuencat përfshijnë: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    dhe 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Implementimi i kodit do të shkojë këtu.", "hy": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Հաշվում է գնդակը 'n' ուսանողների միջև շրջանաձև դասավորված փոխանցելու տարբեր եղանակների քանակը,\n    այնպես, որ 'm' փոխանցումից հետո գնդակը վերադառնա մեկնարկային ուսանողին։\n\n    Ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ փոխանցման հաջորդականությունների քանակը որոշելու համար։ \n    Յուրաքանչյուր ուսանող կարող է գնդակը փոխանցել կամ ձախ հարևանին, կամ աջ հարևանին։\n\n    Պարամետրեր:\n    n: Ուսանողների քանակը, որոնք կանգնած են շրջանաձև։\n    m: Գնդակի փոխանցումների քանակը։\n\n    Վերադարձնում է:\n    Թվային արժեք, որը ներկայացնում է փոխանցման տարբեր եղանակների քանակը, \n    որոնք հանգեցնում են նրան, որ գնդակը 'm' փոխանցումից հետո վերադառնա մեկնարկային ուսանողին։\n\n    Դեպքեր:\n    Դեպք 1:\n    n = 3 ուսանողների և m = 3 փոխանցումների դեպքում ֆունկցիան պետք է վերադարձնի 2։\n    Կան երկու հաջորդականություններ՝ 1 -> 2 -> 3 -> 1 և 1 -> 3 -> 2 -> 1։\n\n    Դեպք 2:\n    n = 4 ուսանողների և m = 2 փոխանցումների դեպքում ֆունկցիան պետք է վերադարձնի 2։\n    Կան երկու հաջորդականություններ՝ 1 -> 2 -> 1 և 1 -> 4 -> 1։\n\n    Դեպք 3:\n    n = 5 ուսանողների և m = 4 փոխանցումների դեպքում ֆունկցիան պետք է վերադարձնի 6։\n    Հաջորդականությունները ներառում են՝ 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    և 1 -> 4 -> 5 -> 2 -> 1։\n    \"\"\"\n    # Այստեղ կգրվի կոդի իրականացումը։", "bn": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' জন ছাত্রদের একটি বৃত্তে সাজানো অবস্থায় বলটি পাস করার বিভিন্ন উপায়ের সংখ্যা গণনা করে \n    যাতে 'm' বার পাস করার পর, বলটি শুরু ছাত্রের কাছে ফিরে আসে।\n\n    ফাংশনটি বল পাস করার ক্রমগুলির সংখ্যা নির্ধারণ করতে ডাইনামিক প্রোগ্রামিং ব্যবহার করে। প্রতিটি ছাত্র\n    বলটি হয় বাম পাশের প্রতিবেশীকে বা ডান পাশের প্রতিবেশীকে পাস করতে পারে।\n\n    Args:\n    n: বৃত্তে দাঁড়িয়ে থাকা ছাত্রদের সংখ্যা।\n    m: বলটি পাস করার সংখ্যা।\n\n    Returns:\n    একটি পূর্ণসংখ্যা যা বলের শুরু ছাত্রের কাছে 'm' বার পাস করার পর ফিরে আসার জন্য \n    বিভিন্ন পাসিং উপায়ের সংখ্যা উপস্থাপন করে।\n\n    কেসসমূহ:\n    কেস 1:\n    n = 3 ছাত্র এবং m = 3 পাসের জন্য, ফাংশনটি 2 ফেরত দেবে।\n    দুটি ক্রম রয়েছে: 1 -> 2 -> 3 -> 1 এবং 1 -> 3 -> 2 -> 1।\n\n    কেস 2:\n    n = 4 ছাত্র এবং m = 2 পাসের জন্য, ফাংশনটি 2 ফেরত দেবে।\n    দুটি ক্রম রয়েছে: 1 -> 2 -> 1 এবং 1 -> 4 -> 1।\n\n    কেস 3:\n    n = 5 ছাত্র এবং m = 4 পাসের জন্য, ফাংশনটি 6 ফেরত দেবে।\n    ক্রমগুলির মধ্যে রয়েছে: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    এবং 1 -> 4 -> 5 -> 2 -> 1।\n    \"\"\"\n    # কোড বাস্তবায়ন এখানে যাবে।", "bg": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Брои броя на различните начини за подаване на топка между 'n' ученици, подредени в кръг,\n    така че след 'm' подавания топката да се върне при началния ученик.\n\n    Функцията използва динамично програмиране, за да определи броя на последователностите на подаване. Всеки ученик\n    може да подаде топката или на левия съсед, или на десния съсед.\n\n    Аргументи:\n    n: Броят на учениците, стоящи в кръг.\n    m: Броят на пъти, когато топката се подава.\n\n    Връща:\n    Цяло число, представляващо броя на различните начини на подаване, които водят до това\n    топката да се върне при началния ученик след 'm' подавания.\n\n    Случаи:\n    Случай 1:\n    За n = 3 ученици и m = 3 подавания, функцията трябва да върне 2.\n    Има две последователности: 1 -> 2 -> 3 -> 1 и 1 -> 3 -> 2 -> 1.\n\n    Случай 2:\n    За n = 4 ученици и m = 2 подавания, функцията трябва да върне 2.\n    Има две последователности: 1 -> 2 -> 1 и 1 -> 4 -> 1.\n\n    Случай 3:\n    За n = 5 ученици и m = 4 подавания, функцията трябва да върне 6.\n    Последователностите включват: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    и 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # The code implementation would go here.", "zh": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    计算在'n'个学生围成的圈中传球的不同方式数量，使得经过'm'次传球后，球返回到起始学生。\n\n    该函数使用动态规划来确定传球序列的数量。每个学生可以将球传给左边的邻居或右边的邻居。\n\n    参数:\n    n: 围成一圈的学生数量。\n    m: 球被传递的次数。\n\n    返回:\n    一个整数，表示在'm'次传球后球返回到起始学生的不同传球方式的数量。\n\n    情况:\n    情况 1:\n    对于 n = 3 个学生和 m = 3 次传球，函数应返回 2。\n    有两种序列：1 -> 2 -> 3 -> 1 和 1 -> 3 -> 2 -> 1。\n\n    情况 2:\n    对于 n = 4 个学生和 m = 2 次传球，函数应返回 2。\n    有两种序列：1 -> 2 -> 1 和 1 -> 4 -> 1。\n\n    情况 3:\n    对于 n = 5 个学生和 m = 4 次传球，函数应返回 6。\n    序列包括：1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    和 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # 代码实现将在这里编写。", "fr": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Compte le nombre de façons différentes de faire passer un ballon parmi 'n' étudiants disposés en cercle\n    de telle sorte qu'après 'm' passes, le ballon retourne à l'étudiant de départ.\n\n    La fonction utilise la programmation dynamique pour déterminer le nombre de séquences de passes. Chaque étudiant\n    peut passer le ballon soit au voisin de gauche, soit au voisin de droite.\n\n    Args:\n    n: Le nombre d'étudiants se tenant en cercle.\n    m: Le nombre de fois que le ballon est passé.\n\n    Returns:\n    Un entier représentant le nombre de façons distinctes de passer le ballon qui aboutissent à ce que le ballon\n    retourne à l'étudiant de départ après 'm' passes.\n\n    Cas:\n    Cas 1:\n    Pour n = 3 étudiants et m = 3 passes, la fonction doit retourner 2.\n    Il y a deux séquences : 1 -> 2 -> 3 -> 1 et 1 -> 3 -> 2 -> 1.\n\n    Cas 2:\n    Pour n = 4 étudiants et m = 2 passes, la fonction doit retourner 2.\n    Il y a deux séquences : 1 -> 2 -> 1 et 1 -> 4 -> 1.\n\n    Cas 3:\n    Pour n = 5 étudiants et m = 4 passes, la fonction doit retourner 6.\n    Les séquences incluent : 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    et 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # L'implémentation du code irait ici.", "de": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Zählt die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern, die im Kreis stehen, \n    so zu passen, dass nach 'm' Pässen der Ball zum startenden Schüler zurückkehrt.\n\n    Die Funktion verwendet dynamische Programmierung, um die Anzahl der Passsequenzen zu bestimmen. Jeder Schüler\n    kann den Ball entweder an den linken oder den rechten Nachbarn weitergeben.\n\n    Argumente:\n    n: Die Anzahl der Schüler, die im Kreis stehen.\n    m: Die Anzahl der Male, die der Ball gepasst wird.\n\n    Rückgabe:\n    Eine ganze Zahl, die die Anzahl der unterschiedlichen Passmöglichkeiten darstellt, bei denen der Ball\n    nach 'm' Pässen zum startenden Schüler zurückkehrt.\n\n    Fälle:\n    Fall 1:\n    Für n = 3 Schüler und m = 3 Pässe sollte die Funktion 2 zurückgeben.\n    Es gibt zwei Sequenzen: 1 -> 2 -> 3 -> 1 und 1 -> 3 -> 2 -> 1.\n\n    Fall 2:\n    Für n = 4 Schüler und m = 2 Pässe sollte die Funktion 2 zurückgeben.\n    Es gibt zwei Sequenzen: 1 -> 2 -> 1 und 1 -> 4 -> 1.\n\n    Fall 3:\n    Für n = 5 Schüler und m = 4 Pässe sollte die Funktion 6 zurückgeben.\n    Die Sequenzen umfassen: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    und 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Die Code-Implementierung würde hier erfolgen.", "ha": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Yana ƙidaya adadin hanyoyin daban-daban na wuce ƙwallo tsakanin 'n' ɗalibai da aka tsara a cikin \n    da'ira ta yadda bayan 'm' wucewa, ƙwallon zai koma ga ɗalibin da ya fara.\n\n    Aikin yana amfani da shirye-shiryen motsi don tantance adadin jerin wucewa. Kowane ɗalibi\n    na iya wuce ƙwallon ko dai ga makwabcin hagu ko ga makwabcin dama.\n\n    Args:\n    n: Adadin ɗalibai da ke tsaye a cikin da'ira.\n    m: Adadin lokutan da aka wuce ƙwallon.\n\n    Returns:\n    Lamba mai nuna adadin hanyoyin wucewa daban-daban da ke haifar da ƙwallon\n    dawowa ga ɗalibin da ya fara bayan 'm' wucewa.\n\n    Lokuta:\n    Lokaci 1:\n    Ga n = 3 ɗalibai da m = 3 wucewa, aikin ya kamata ya dawo da 2.\n    Akwai jerin guda biyu: 1 -> 2 -> 3 -> 1 da 1 -> 3 -> 2 -> 1.\n\n    Lokaci 2:\n    Ga n = 4 ɗalibai da m = 2 wucewa, aikin ya kamata ya dawo da 2.\n    Akwai jerin guda biyu: 1 -> 2 -> 1 da 1 -> 4 -> 1.\n\n    Lokaci 3:\n    Ga n = 5 ɗalibai da m = 4 wucewa, aikin ya kamata ya dawo da 6.\n    Jerin sun haɗa da: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    da 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Anan za a sanya aiwatar da lambar.", "hi": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' छात्रों के बीच एक गोला पास करने के विभिन्न तरीकों की संख्या गिनता है \n    ताकि 'm' पास के बाद, गोला प्रारंभिक छात्र के पास वापस आ जाए।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके पासिंग अनुक्रमों की संख्या निर्धारित करता है। प्रत्येक छात्र\n    गोला या तो बाएँ पड़ोसी को या दाएँ पड़ोसी को पास कर सकता है।\n\n    तर्क:\n    n: एक वृत्त में खड़े छात्रों की संख्या।\n    m: गोला पास करने की संख्या।\n\n    लौटाता है:\n    एक पूर्णांक जो गोला पास करने के विशिष्ट तरीकों की संख्या का प्रतिनिधित्व करता है\n    जो 'm' पास के बाद प्रारंभिक छात्र के पास वापस आता है।\n\n    मामले:\n    मामला 1:\n    n = 3 छात्रों और m = 3 पास के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\n    दो अनुक्रम हैं: 1 -> 2 -> 3 -> 1 और 1 -> 3 -> 2 -> 1।\n\n    मामला 2:\n    n = 4 छात्रों और m = 2 पास के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\n    दो अनुक्रम हैं: 1 -> 2 -> 1 और 1 -> 4 -> 1।\n\n    मामला 3:\n    n = 5 छात्रों और m = 4 पास के लिए, फ़ंक्शन को 6 लौटाना चाहिए।\n    अनुक्रमों में शामिल हैं: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    और 1 -> 4 -> 5 -> 2 -> 1।\n    \"\"\"\n    # यहाँ कोड कार्यान्वयन होगा।", "hu": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Megszámolja, hány különböző módon lehet egy labdát passzolni 'n' diák között, akik körben állnak úgy,\n    hogy 'm' passz után a labda visszatér a kiindulási diákhoz.\n\n    A függvény dinamikus programozást használ a passzolási sorozatok számának meghatározásához. Minden diák\n    vagy a bal szomszédjának, vagy a jobb szomszédjának adhatja tovább a labdát.\n\n    Args:\n    n: A körben álló diákok száma.\n    m: A labda passzolásának száma.\n\n    Returns:\n    Egy egész szám, amely a különböző passzolási módok számát jelenti, amelyek eredményeként a labda\n    'm' passz után visszatér a kiindulási diákhoz.\n\n    Esetek:\n    1. eset:\n    Ha n = 3 diák és m = 3 passz, a függvénynek 2-t kell visszaadnia.\n    Két sorozat van: 1 -> 2 -> 3 -> 1 és 1 -> 3 -> 2 -> 1.\n\n    2. eset:\n    Ha n = 4 diák és m = 2 passz, a függvénynek 2-t kell visszaadnia.\n    Két sorozat van: 1 -> 2 -> 1 és 1 -> 4 -> 1.\n\n    3. eset:\n    Ha n = 5 diák és m = 4 passz, a függvénynek 6-ot kell visszaadnia.\n    A sorozatok közé tartozik: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    és 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # A kód megvalósítása itt lenne.", "es": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Cuenta el número de diferentes maneras de pasar una pelota entre 'n' estudiantes dispuestos en un círculo\n    de tal manera que después de 'm' pases, la pelota regrese al estudiante inicial.\n\n    La función utiliza programación dinámica para determinar el número de secuencias de pases. Cada estudiante\n    puede pasar la pelota ya sea al vecino de la izquierda o al vecino de la derecha.\n\n    Argumentos:\n    n: El número de estudiantes de pie en un círculo.\n    m: El número de veces que se pasa la pelota.\n\n    Devuelve:\n    Un entero que representa el número de maneras distintas de pasar que resultan en que la pelota\n    regrese al estudiante inicial después de 'm' pases.\n\n    Casos:\n    Caso 1:\n    Para n = 3 estudiantes y m = 3 pases, la función debería devolver 2.\n    Hay dos secuencias: 1 -> 2 -> 3 -> 1 y 1 -> 3 -> 2 -> 1.\n\n    Caso 2:\n    Para n = 4 estudiantes y m = 2 pases, la función debería devolver 2.\n    Hay dos secuencias: 1 -> 2 -> 1 y 1 -> 4 -> 1.\n\n    Caso 3:\n    Para n = 5 estudiantes y m = 4 pases, la función debería devolver 6.\n    Las secuencias incluyen: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    y 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # La implementación del código iría aquí.", "arb": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' طلاب مرتبين في دائرة\n    بحيث بعد 'm' تمريرات، تعود الكرة إلى الطالب الذي بدأ التمرير.\n\n    تستخدم الدالة البرمجة الديناميكية لتحديد عدد تسلسلات التمرير. يمكن لكل طالب\n    تمرير الكرة إما إلى الجار الأيسر أو إلى الجار الأيمن.\n\n    يعيدالحجج:\n    n: عدد الطلاب الواقفين في دائرة.\n    m: عدد المرات التي يتم فيها تمرير الكرة.\n\n    يعيد:\n    عدد صحيح يمثل عدد طرق التمرير المميزة التي تؤدي إلى\n    عودة الكرة إلى الطالب الذي بدأ التمرير بعد 'm' تمريرات.\n\n    الحالات:\n    الحالة 1:\n    بالنسبة لـ n = 3 طلاب و m = 3 تمريرات، يجب أن تعيد الدالة 2.\n    هناك تسلسلان: 1 -> 2 -> 3 -> 1 و 1 -> 3 -> 2 -> 1.\n\n    الحالة 2:\n    بالنسبة لـ n = 4 طلاب و m = 2 تمريرات، يجب أن تعيد الدالة 2.\n    هناك تسلسلان: 1 -> 2 -> 1 و 1 -> 4 -> 1.\n\n    الحالة 3:\n    بالنسبة لـ n = 5 طلاب و m = 4 تمريرات، يجب أن تعيد الدالة 6.\n    تشمل التسلسلات: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    و 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # سيتم وضع تنفيذ الكود هنا.", "sw": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Inahesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliopangwa katika duara \n    kiasi kwamba baada ya kupitisha 'm', mpira unarudi kwa mwanafunzi wa kuanzia.\n\n    Kazi hii inatumia programu ya nguvu ili kubaini idadi ya mfuatano wa kupitisha. Kila mwanafunzi\n    anaweza kupitisha mpira kwa jirani wa kushoto au kwa jirani wa kulia.\n\n    Hoja:\n    n: Idadi ya wanafunzi waliokuwa wamesimama katika duara.\n    m: Idadi ya mara ambazo mpira unapita.\n\n    Inarejesha:\n    Namba kamili inayowakilisha idadi ya njia tofauti za kupitisha ambazo zinasababisha mpira\n    kurudi kwa mwanafunzi wa kuanzia baada ya kupitisha 'm'.\n\n    Kesi:\n    Kesi 1:\n    Kwa n = wanafunzi 3 na m = kupitisha 3, kazi inapaswa kurudisha 2.\n    Kuna mfuatano miwili: 1 -> 2 -> 3 -> 1 na 1 -> 3 -> 2 -> 1.\n\n    Kesi 2:\n    Kwa n = wanafunzi 4 na m = kupitisha 2, kazi inapaswa kurudisha 2.\n    Kuna mfuatano miwili: 1 -> 2 -> 1 na 1 -> 4 -> 1.\n\n    Kesi 3:\n    Kwa n = wanafunzi 5 na m = kupitisha 4, kazi inapaswa kurudisha 6.\n    Mfuatano unajumuisha: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    na 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Utekelezaji wa msimbo ungekuwa hapa.", "tr": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' öğrencinin bir daire şeklinde dizildiği bir durumda, topun 'm' pas sonrasında\n    başlangıçtaki öğrenciye geri dönmesi için farklı pas verme yollarının sayısını sayar.\n\n    Fonksiyon, pas verme dizilerinin sayısını belirlemek için dinamik programlama kullanır.\n    Her öğrenci topu ya sol komşusuna ya da sağ komşusuna verebilir.\n\n    Argümanlar:\n    n: Bir dairede duran öğrenci sayısı.\n    m: Topun kaç kez paslandığı.\n\n    Döndürür:\n    'm' pas sonrasında topun başlangıçtaki öğrenciye geri dönmesiyle sonuçlanan\n    farklı pas verme yollarının sayısını temsil eden bir tamsayı.\n\n    Durumlar:\n    Durum 1:\n    n = 3 öğrenci ve m = 3 pas için, fonksiyon 2 döndürmelidir.\n    İki dizi vardır: 1 -> 2 -> 3 -> 1 ve 1 -> 3 -> 2 -> 1.\n\n    Durum 2:\n    n = 4 öğrenci ve m = 2 pas için, fonksiyon 2 döndürmelidir.\n    İki dizi vardır: 1 -> 2 -> 1 ve 1 -> 4 -> 1.\n\n    Durum 3:\n    n = 5 öğrenci ve m = 4 pas için, fonksiyon 6 döndürmelidir.\n    Diziler şunları içerir: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    ve 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Kod uygulaması burada yer alacaktır.", "vi": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Đếm số cách khác nhau để chuyền bóng giữa 'n' học sinh được sắp xếp thành một vòng tròn \n    sao cho sau 'm' lần chuyền, bóng trở lại học sinh bắt đầu.\n\n    Hàm sử dụng lập trình động để xác định số lượng chuỗi chuyền bóng. Mỗi học sinh\n    có thể chuyền bóng cho người bên trái hoặc người bên phải.\n\n    Tham số:\n    n: Số lượng học sinh đứng thành vòng tròn.\n    m: Số lần bóng được chuyền.\n\n    Trả về:\n    Một số nguyên đại diện cho số cách chuyền bóng khác nhau mà kết quả là bóng\n    trở lại học sinh bắt đầu sau 'm' lần chuyền.\n\n    Các trường hợp:\n    Trường hợp 1:\n    Với n = 3 học sinh và m = 3 lần chuyền, hàm sẽ trả về 2.\n    Có hai chuỗi: 1 -> 2 -> 3 -> 1 và 1 -> 3 -> 2 -> 1.\n\n    Trường hợp 2:\n    Với n = 4 học sinh và m = 2 lần chuyền, hàm sẽ trả về 2.\n    Có hai chuỗi: 1 -> 2 -> 1 và 1 -> 4 -> 1.\n\n    Trường hợp 3:\n    Với n = 5 học sinh và m = 4 lần chuyền, hàm sẽ trả về 6.\n    Các chuỗi bao gồm: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    và 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Phần triển khai mã sẽ được đặt ở đây.", "id": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Menghitung jumlah cara berbeda untuk mengoper bola di antara 'n' siswa yang diatur dalam lingkaran\n    sedemikian rupa sehingga setelah 'm' operan, bola kembali ke siswa awal.\n\n    Fungsi ini menggunakan pemrograman dinamis untuk menentukan jumlah urutan operan. Setiap siswa\n    dapat mengoper bola baik ke tetangga kiri atau ke tetangga kanan.\n\n    Argumen:\n    n: Jumlah siswa yang berdiri dalam lingkaran.\n    m: Jumlah kali bola dioper.\n\n    Mengembalikan:\n    Sebuah bilangan bulat yang mewakili jumlah cara operan yang berbeda yang menghasilkan bola\n    kembali ke siswa awal setelah 'm' operan.\n\n    Kasus:\n    Kasus 1:\n    Untuk n = 3 siswa dan m = 3 operan, fungsi harus mengembalikan 2.\n    Ada dua urutan: 1 -> 2 -> 3 -> 1 dan 1 -> 3 -> 2 -> 1.\n\n    Kasus 2:\n    Untuk n = 4 siswa dan m = 2 operan, fungsi harus mengembalikan 2.\n    Ada dua urutan: 1 -> 2 -> 1 dan 1 -> 4 -> 1.\n\n    Kasus 3:\n    Untuk n = 5 siswa dan m = 4 operan, fungsi harus mengembalikan 6.\n    Urutannya termasuk: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    dan 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Implementasi kode akan ditempatkan di sini.", "ja": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' 人の学生が円形に配置されている中で、ボールを 'm' 回パスした後に\n    ボールが開始した学生に戻る異なる方法の数を数えます。\n\n    この関数は動的プログラミングを使用してパスシーケンスの数を決定します。各学生は\n    ボールを左隣または右隣の学生にパスすることができます。\n\n    引数:\n    n: 円形に立っている学生の数。\n    m: ボールがパスされる回数。\n\n    戻り値:\n    'm' 回のパスの後にボールが開始した学生に戻る異なるパス方法の数を表す整数。\n\n    ケース:\n    ケース 1:\n    n = 3 人の学生と m = 3 回のパスの場合、関数は 2 を返すべきです。\n    2 つのシーケンスがあります: 1 -> 2 -> 3 -> 1 および 1 -> 3 -> 2 -> 1。\n\n    ケース 2:\n    n = 4 人の学生と m = 2 回のパスの場合、関数は 2 を返すべきです。\n    2 つのシーケンスがあります: 1 -> 2 -> 1 および 1 -> 4 -> 1。\n\n    ケース 3:\n    n = 5 人の学生と m = 4 回のパスの場合、関数は 6 を返すべきです。\n    シーケンスには以下が含まれます: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    および 1 -> 4 -> 5 -> 2 -> 1。\n    \"\"\"\n    # コードの実装はここに記述されます。", "ko": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n'명의 학생이 원형으로 배열되어 있을 때, 공을 'm'번 패스하여 공이 시작 학생에게 돌아오는 \n    서로 다른 방법의 수를 계산합니다.\n\n    이 함수는 동적 프로그래밍을 사용하여 패스 시퀀스의 수를 결정합니다. 각 학생은 공을 \n    왼쪽 이웃이나 오른쪽 이웃에게 패스할 수 있습니다.\n\n    Args:\n    n: 원형으로 서 있는 학생의 수.\n    m: 공이 패스되는 횟수.\n\n    Returns:\n    'm'번의 패스 후 공이 시작 학생에게 돌아오는 서로 다른 패스 방법의 수를 나타내는 정수.\n\n    사례:\n    사례 1:\n    n = 3명의 학생과 m = 3번의 패스일 때, 함수는 2를 반환해야 합니다.\n    두 가지 시퀀스가 있습니다: 1 -> 2 -> 3 -> 1 및 1 -> 3 -> 2 -> 1.\n\n    사례 2:\n    n = 4명의 학생과 m = 2번의 패스일 때, 함수는 2를 반환해야 합니다.\n    두 가지 시퀀스가 있습니다: 1 -> 2 -> 1 및 1 -> 4 -> 1.\n\n    사례 3:\n    n = 5명의 학생과 m = 4번의 패스일 때, 함수는 6을 반환해야 합니다.\n    시퀀스에는 다음이 포함됩니다: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    및 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # 코드 구현은 여기에 작성됩니다.", "ml": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' വിദ്യാർത്ഥികളെ ഒരു വൃത്തത്തിൽ ക്രമീകരിച്ച് 'm' തവണ പാസ്സുകൾക്ക് ശേഷം പന്ത് ആരംഭിക്കുന്ന വിദ്യാർത്ഥിയിലേക്ക് മടങ്ങി വരുന്നതിനുള്ള വ്യത്യസ്ത മാർഗ്ഗങ്ങളുടെ എണ്ണം എണ്ണുന്നു.\n\n    ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് പാസ്സിംഗ് സീക്വൻസുകളുടെ എണ്ണം നിർണ്ണയിക്കുന്നു. ഓരോ വിദ്യാർത്ഥിയും പന്ത് ഇടത് അയൽക്കാരനോ വലത് അയൽക്കാരനോക്ക് പാസ്സ് ചെയ്യാം.\n\n    Args:\n    n: ഒരു വൃത്തത്തിൽ നിൽക്കുന്ന വിദ്യാർത്ഥികളുടെ എണ്ണം.\n    m: പന്ത് പാസ്സ് ചെയ്യുന്ന തവണകളുടെ എണ്ണം.\n\n    Returns:\n    'm' പാസ്സുകൾക്ക് ശേഷം പന്ത് ആരംഭിക്കുന്ന വിദ്യാർത്ഥിയിലേക്ക് മടങ്ങി വരുന്നതിന് ഫലമായ വ്യത്യസ്ത പാസ്സിംഗ് മാർഗ്ഗങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\n    കേസുകൾ:\n    കേസ് 1:\n    n = 3 വിദ്യാർത്ഥികൾക്കും m = 3 പാസ്സുകൾക്കും, ഫംഗ്ഷൻ 2 മടക്കണം.\n    രണ്ട് സീക്വൻസുകൾ ഉണ്ട്: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\n    കേസ് 2:\n    n = 4 വിദ്യാർത്ഥികൾക്കും m = 2 പാസ്സുകൾക്കും, ഫംഗ്ഷൻ 2 മടക്കണം.\n    രണ്ട് സീക്വൻസുകൾ ഉണ്ട്: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\n    കേസ് 3:\n    n = 5 വിദ്യാർത്ഥികൾക്കും m = 4 പാസ്സുകൾക്കും, ഫംഗ്ഷൻ 6 മടക്കണം.\n    സീക്വൻസുകൾ ഉൾപ്പെടുന്നു: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    and 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # കോഡ് നടപ്പാക്കൽ ഇവിടെ വരും.", "fa": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    تعداد راه‌های مختلف برای پاس دادن توپ بین 'n' دانش‌آموز که به صورت دایره‌ای ایستاده‌اند\n    را می‌شمارد به طوری که بعد از 'm' پاس، توپ به دانش‌آموز شروع‌کننده برگردد.\n\n    این تابع از برنامه‌نویسی پویا برای تعیین تعداد دنباله‌های پاس استفاده می‌کند. هر دانش‌آموز\n    می‌تواند توپ را به همسایه چپ یا همسایه راست پاس دهد.\n\n    آرگومان‌ها:\n    n: تعداد دانش‌آموزانی که به صورت دایره‌ای ایستاده‌اند.\n    m: تعداد دفعاتی که توپ پاس داده می‌شود.\n\n    بازگشت:\n    یک عدد صحیح که نشان‌دهنده تعداد راه‌های مختلف پاس دادن است که منجر به بازگشت توپ\n    به دانش‌آموز شروع‌کننده پس از 'm' پاس می‌شود.\n\n    موارد:\n    مورد 1:\n    برای n = 3 دانش‌آموز و m = 3 پاس، تابع باید 2 را برگرداند.\n    دو دنباله وجود دارد: 1 -> 2 -> 3 -> 1 و 1 -> 3 -> 2 -> 1.\n\n    مورد 2:\n    برای n = 4 دانش‌آموز و m = 2 پاس، تابع باید 2 را برگرداند.\n    دو دنباله وجود دارد: 1 -> 2 -> 1 و 1 -> 4 -> 1.\n\n    مورد 3:\n    برای n = 5 دانش‌آموز و m = 4 پاس، تابع باید 6 را برگرداند.\n    دنباله‌ها شامل: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    و 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # پیاده‌سازی کد در اینجا قرار می‌گیرد."}, "canonical_solution": "    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]", "instruction": {"en": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nBada takaitaccen bayanin harshen halitta (docstring) na lambar Python cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben.", "es": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt với tối đa 500 ký tự.", "id": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\n以下のPythonコードの説明を日本語で500文字以内の簡潔なドキュメンテーション文字列（docstring）として提供してください。", "ko": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത വിധത്തിൽ നൽകുക.", "fa": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_count_passing_ways():\n    test_cases = [\n        # Test case 1: simple case\n        {\n            'n': 3,\n            'm': 1,\n            'expected': 0\n        },\n        # Test case 2: another simple case\n        {\n            'n': 4,\n            'm': 2,\n            'expected': 2\n        },\n        # Test case 3: larger number of students and passes\n        {\n            'n': 5,\n            'm': 3,\n            'expected': 0\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = count_passing_ways(test['n'], test['m'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_count_passing_ways()", "entry_point": "count_passing_ways", "signature": "def count_passing_ways(n: int, m: int) -> int:", "docstring": {"en": "Counts the number of different ways to pass a ball among 'n' students arranged in a circle\nsuch that after 'm' passes, the ball returns to the starting student.\n\nThe function uses dynamic programming to determine the number of passing sequences. Each student\ncan pass the ball either to the left neighbor or to the right neighbor.\n\nArgs:\nn: The number of students standing in a circle.\nm: The number of times the ball is passed.\n\nReturns:\nAn integer representing the number of distinct passing ways that result in the ball\nreturning to the starting student after 'm' passes.\n\nCases:\nCase 1:\nFor n = 3 students and m = 3 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\nCase 2:\nFor n = 4 students and m = 2 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\nCase 3:\nFor n = 5 students and m = 4 passes, the function should return 6.\nThe sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nand 1 -> 4 -> 5 -> 2 -> 1.", "sq": "Numëron numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve të rregulluar në një rreth\ntë tillë që pas 'm' kalimesh, topi të kthehet te studenti fillestar.\n\nFunksioni përdor programimin dinamik për të përcaktuar numrin e sekuencave të kalimit. Çdo student\nmund ta kalojë topin ose te fqinji në të majtë ose te fqinji në të djathtë.\n\nArgs:\nn: Numri i studentëve që qëndrojnë në një rreth.\nm: Numri i herëve që topi kalohet.\n\nReturns:\nNjë numër i plotë që përfaqëson numrin e mënyrave të veçanta të kalimit që rezultojnë në\nkthimin e topit te studenti fillestar pas 'm' kalimesh.\n\nCases:\nRasti 1:\nPër n = 3 studentë dhe m = 3 kalime, funksioni duhet të kthejë 2.\nKa dy sekuenca: 1 -> 2 -> 3 -> 1 dhe 1 -> 3 -> 2 -> 1.\n\nRasti 2:\nPër n = 4 studentë dhe m = 2 kalime, funksioni duhet të kthejë 2.\nKa dy sekuenca: 1 -> 2 -> 1 dhe 1 -> 4 -> 1.\n\nRasti 3:\nPër n = 5 studentë dhe m = 4 kalime, funksioni duhet të kthejë 6.\nSekuencat përfshijnë: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\ndhe 1 -> 4 -> 5 -> 2 -> 1.", "hy": "Հաշվում է գնդակը 'n' ուսանողների միջև շրջանաձև դասավորված փոխանցելու տարբեր եղանակների քանակը այնպես, որ 'm' փոխանցումներից հետո գնդակը վերադառնա մեկնարկային ուսանողին:\n\nՖունկցիան օգտագործում է դինամիկ ծրագրավորում՝ փոխանցման հաջորդականությունների քանակը որոշելու համար։ Յուրաքանչյուր ուսանող կարող է գնդակը փոխանցել կամ ձախ հարևանին, կամ աջ հարևանին։\n\nԱրգումենտներ:\nn: Շրջանաձև կանգնած ուսանողների քանակը։\nm: Գնդակի փոխանցման քանակը։\n\nՎերադարձնում է:\nԱմբողջ թիվ, որը ներկայացնում է փոխանցման տարբեր եղանակների քանակը, որոնց արդյունքում գնդակը 'm' փոխանցումներից հետո վերադառնում է մեկնարկային ուսանողին։\n\nԴեպքեր:\nԴեպք 1:\nԵրբ n = 3 ուսանող և m = 3 փոխանցում, ֆունկցիան պետք է վերադարձնի 2։\nԿան երկու հաջորդականություններ՝ 1 -> 2 -> 3 -> 1 և 1 -> 3 -> 2 -> 1։\n\nԴեպք 2:\nԵրբ n = 4 ուսանող և m = 2 փոխանցում, ֆունկցիան պետք է վերադարձնի 2։\nԿան երկու հաջորդականություններ՝ 1 -> 2 -> 1 և 1 -> 4 -> 1։\n\nԴեպք 3:\nԵրբ n = 5 ուսանող և m = 4 փոխանցում, ֆունկցիան պետք է վերադարձնի 6։\nՀաջորդականությունները ներառում են՝ 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nև 1 -> 4 -> 5 -> 2 -> 1։", "bn": "'ন' জন ছাত্র একটি বৃত্তে সাজানো অবস্থায় বলটি পাস করার বিভিন্ন উপায়ের সংখ্যা গণনা করে যাতে 'ম' বার পাস করার পর, বলটি শুরুর ছাত্রের কাছে ফিরে আসে।\n\nফাংশনটি বল পাস করার ক্রমগুলির সংখ্যা নির্ধারণ করতে গতিশীল প্রোগ্রামিং ব্যবহার করে। প্রতিটি ছাত্র বলটি বাম প্রতিবেশী বা ডান প্রতিবেশীর কাছে পাস করতে পারে।\n\nArgs:\nn: একটি বৃত্তে দাঁড়িয়ে থাকা ছাত্রদের সংখ্যা।\nm: বলটি পাস করার সংখ্যা।\n\nReturns:\nএকটি পূর্ণসংখ্যা যা বলটি 'ম' বার পাস করার পর শুরুর ছাত্রের কাছে ফিরে আসার ফলাফল হিসাবে পৃথক পাসিং উপায়ের সংখ্যা উপস্থাপন করে।\n\nCases:\nCase 1:\nn = 3 জন ছাত্র এবং m = 3 পাসের জন্য, ফাংশনটি 2 ফেরত দেবে।\nদুটি ক্রম আছে: 1 -> 2 -> 3 -> 1 এবং 1 -> 3 -> 2 -> 1।\n\nCase 2:\nn = 4 জন ছাত্র এবং m = 2 পাসের জন্য, ফাংশনটি 2 ফেরত দেবে।\nদুটি ক্রম আছে: 1 -> 2 -> 1 এবং 1 -> 4 -> 1।\n\nCase 3:\nn = 5 জন ছাত্র এবং m = 4 পাসের জন্য, ফাংশনটি 6 ফেরত দেবে।\nক্রমগুলির মধ্যে রয়েছে: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nএবং 1 -> 4 -> 5 -> 2 -> 1।", "bg": "Брои броя на различните начини за предаване на топка между 'n' ученици, подредени в кръг,\nтака че след 'm' предавания топката да се върне при началния ученик.\n\nФункцията използва динамично програмиране, за да определи броя на последователностите на предаване. Всеки ученик\nможе да предаде топката или на левия съсед, или на десния съсед.\n\nArgs:\nn: Броят на учениците, стоящи в кръг.\nm: Броят на пъти, когато топката се предава.\n\nReturns:\nЦяло число, представляващо броя на различните начини на предаване, които водят до това, че топката\nсе връща при началния ученик след 'm' предавания.\n\nCases:\nCase 1:\nЗа n = 3 ученици и m = 3 предавания, функцията трябва да върне 2.\nИма две последователности: 1 -> 2 -> 3 -> 1 и 1 -> 3 -> 2 -> 1.\n\nCase 2:\nЗа n = 4 ученици и m = 2 предавания, функцията трябва да върне 2.\nИма две последователности: 1 -> 2 -> 1 и 1 -> 4 -> 1.\n\nCase 3:\nЗа n = 5 ученици и m = 4 предавания, функцията трябва да върне 6.\nПоследователностите включват: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nи 1 -> 4 -> 5 -> 2 -> 1.", "zh": "计算在'n'个学生围成的圆圈中传球的不同方式数量，使得经过'm'次传球后，球返回到起始学生。\n\n该函数使用动态规划来确定传球序列的数量。每个学生可以将球传给左边的邻居或右边的邻居。\n\n参数:\nn: 站成圆圈的学生数量。\nm: 球被传递的次数。\n\n返回:\n一个整数，表示在'm'次传球后，球返回到起始学生的不同传球方式的数量。\n\n案例:\n案例 1:\n对于n = 3个学生和m = 3次传球，函数应返回2。\n有两种序列：1 -> 2 -> 3 -> 1 和 1 -> 3 -> 2 -> 1。\n\n案例 2:\n对于n = 4个学生和m = 2次传球，函数应返回2。\n有两种序列：1 -> 2 -> 1 和 1 -> 4 -> 1。\n\n案例 3:\n对于n = 5个学生和m = 4次传球，函数应返回6。\n序列包括：1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n和 1 -> 4 -> 5 -> 2 -> 1。", "fr": "Compte le nombre de façons différentes de faire passer une balle entre 'n' étudiants disposés en cercle\nde telle sorte qu'après 'm' passes, la balle revienne à l'étudiant de départ.\n\nLa fonction utilise la programmation dynamique pour déterminer le nombre de séquences de passes. Chaque étudiant\npeut passer la balle soit à son voisin de gauche, soit à son voisin de droite.\n\nArgs:\nn: Le nombre d'étudiants disposés en cercle.\nm: Le nombre de fois que la balle est passée.\n\nReturns:\nUn entier représentant le nombre de façons distinctes de passer la balle qui aboutissent à ce que la balle\nrevienne à l'étudiant de départ après 'm' passes.\n\nCas:\nCas 1:\nPour n = 3 étudiants et m = 3 passes, la fonction doit retourner 2.\nIl y a deux séquences : 1 -> 2 -> 3 -> 1 et 1 -> 3 -> 2 -> 1.\n\nCas 2:\nPour n = 4 étudiants et m = 2 passes, la fonction doit retourner 2.\nIl y a deux séquences : 1 -> 2 -> 1 et 1 -> 4 -> 1.\n\nCas 3:\nPour n = 5 étudiants et m = 4 passes, la fonction doit retourner 6.\nLes séquences incluent : 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\net 1 -> 4 -> 5 -> 2 -> 1.", "de": "Zählt die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern anzuwerfen, die in einem Kreis angeordnet sind, sodass nach 'm' Würfen der Ball zum startenden Schüler zurückkehrt.\n\nDie Funktion verwendet dynamische Programmierung, um die Anzahl der Wurfsequenzen zu bestimmen. Jeder Schüler kann den Ball entweder an den linken oder den rechten Nachbarn weitergeben.\n\nArgs:\nn: Die Anzahl der Schüler, die im Kreis stehen.\nm: Die Anzahl der Male, die der Ball geworfen wird.\n\nReturns:\nEine ganze Zahl, die die Anzahl der unterschiedlichen Wurfmöglichkeiten darstellt, bei denen der Ball nach 'm' Würfen zum startenden Schüler zurückkehrt.\n\nFälle:\nFall 1:\nFür n = 3 Schüler und m = 3 Würfe sollte die Funktion 2 zurückgeben.\nEs gibt zwei Sequenzen: 1 -> 2 -> 3 -> 1 und 1 -> 3 -> 2 -> 1.\n\nFall 2:\nFür n = 4 Schüler und m = 2 Würfe sollte die Funktion 2 zurückgeben.\nEs gibt zwei Sequenzen: 1 -> 2 -> 1 und 1 -> 4 -> 1.\n\nFall 3:\nFür n = 5 Schüler und m = 4 Würfe sollte die Funktion 6 zurückgeben.\nDie Sequenzen umfassen: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nund 1 -> 4 -> 5 -> 2 -> 1.", "ha": "Yana ƙidaya adadin hanyoyin daban-daban na wuce ƙwallo tsakanin 'n' ɗalibai da aka tsara a cikin \nda'ira ta yadda bayan 'm' wucewa, ƙwallon zai koma ga ɗalibin da ya fara.\n\nAikin yana amfani da shirye-shiryen motsi don tantance adadin hanyoyin wucewa. Kowanne ɗalibi\nna iya wuce ƙwallon ko dai ga makwabcin hagu ko ga makwabcin dama.\n\nArgs:\nn: Adadin ɗalibai da ke tsaye a cikin da'ira.\nm: Adadin lokutan da aka wuce ƙwallon.\n\nReturns:\nWani cikakken lamba da ke wakiltar adadin hanyoyin wucewa daban-daban da ke haifar da ƙwallon\nkomawa ga ɗalibin da ya fara bayan 'm' wucewa.\n\nCases:\nCase 1:\nGa n = 3 ɗalibai da m = 3 wucewa, aikin ya kamata ya dawo da 2.\nAkwai hanyoyi guda biyu: 1 -> 2 -> 3 -> 1 da 1 -> 3 -> 2 -> 1.\n\nCase 2:\nGa n = 4 ɗalibai da m = 2 wucewa, aikin ya kamata ya dawo da 2.\nAkwai hanyoyi guda biyu: 1 -> 2 -> 1 da 1 -> 4 -> 1.\n\nCase 3:\nGa n = 5 ɗalibai da m = 4 wucewa, aikin ya kamata ya dawo da 6.\nHanyoyin sun haɗa da: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nda 1 -> 4 -> 5 -> 2 -> 1.", "hi": "गेंद को 'n' छात्रों के बीच एक वृत्त में पास करने के विभिन्न तरीकों की संख्या की गणना करता है\nताकि 'm' पास के बाद, गेंद प्रारंभिक छात्र के पास वापस आ जाए।\n\nयह फ़ंक्शन पासिंग अनुक्रमों की संख्या निर्धारित करने के लिए डायनेमिक प्रोग्रामिंग का उपयोग करता है। प्रत्येक छात्र\nगेंद को या तो बाएं पड़ोसी को या दाएं पड़ोसी को पास कर सकता है।\n\nआर्ग्स:\nn: एक वृत्त में खड़े छात्रों की संख्या।\nm: गेंद पास करने की संख्या।\n\nवापसी:\nएक पूर्णांक जो गेंद को प्रारंभिक छात्र के पास 'm' पास के बाद वापस लाने वाले\nविभिन्न पासिंग तरीकों की संख्या का प्रतिनिधित्व करता है।\n\nमामले:\nमामला 1:\nn = 3 छात्रों और m = 3 पास के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\nदो अनुक्रम हैं: 1 -> 2 -> 3 -> 1 और 1 -> 3 -> 2 -> 1।\n\nमामला 2:\nn = 4 छात्रों और m = 2 पास के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\nदो अनुक्रम हैं: 1 -> 2 -> 1 और 1 -> 4 -> 1।\n\nमामला 3:\nn = 5 छात्रों और m = 4 पास के लिए, फ़ंक्शन को 6 लौटाना चाहिए।\nअनुक्रमों में शामिल हैं: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nऔर 1 -> 4 -> 5 -> 2 -> 1।", "hu": "Számolja meg, hány különböző módon lehet egy labdát átadni 'n' diák között, akik körben állnak úgy, hogy 'm' passz után a labda visszatér a kiinduló diákhoz.\n\nA függvény dinamikus programozást használ a passzolási sorozatok számának meghatározásához. Minden diák vagy a bal szomszédjának, vagy a jobb szomszédjának adhatja át a labdát.\n\nArgs:\nn: A körben álló diákok száma.\nm: Az átadások száma.\n\nReturns:\nEgy egész szám, amely a különböző passzolási módok számát jelenti, amelyek eredményeként a labda 'm' passz után visszatér a kiinduló diákhoz.\n\nEsetek:\n1. eset:\nHa n = 3 diák és m = 3 passz, a függvénynek 2-t kell visszaadnia.\nKét sorozat van: 1 -> 2 -> 3 -> 1 és 1 -> 3 -> 2 -> 1.\n\n2. eset:\nHa n = 4 diák és m = 2 passz, a függvénynek 2-t kell visszaadnia.\nKét sorozat van: 1 -> 2 -> 1 és 1 -> 4 -> 1.\n\n3. eset:\nHa n = 5 diák és m = 4 passz, a függvénynek 6-ot kell visszaadnia.\nA sorozatok közé tartozik: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nés 1 -> 4 -> 5 -> 2 -> 1.", "es": "Cuenta el número de diferentes maneras de pasar una pelota entre 'n' estudiantes dispuestos en un círculo de tal manera que después de 'm' pases, la pelota regrese al estudiante inicial.\n\nLa función utiliza programación dinámica para determinar el número de secuencias de pases. Cada estudiante puede pasar la pelota ya sea al vecino de la izquierda o al vecino de la derecha.\n\nArgumentos:\nn: El número de estudiantes parados en un círculo.\nm: El número de veces que se pasa la pelota.\n\nDevuelve:\nUn entero que representa el número de maneras distintas de pasar la pelota que resultan en que la pelota regrese al estudiante inicial después de 'm' pases.\n\nCases:\nCase 1:\nPara n = 3 estudiantes y m = 3 pases, la función debería devolver 2.\nHay dos secuencias: 1 -> 2 -> 3 -> 1 y 1 -> 3 -> 2 -> 1.\n\nCase 2:\nPara n = 4 estudiantes y m = 2 pases, la función debería devolver 2.\nHay dos secuencias: 1 -> 2 -> 1 y 1 -> 4 -> 1.\n\nCase 3:\nPara n = 5 estudiantes y m = 4 pases, la función debería devolver 6.\nLas secuencias incluyen: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\ny 1 -> 4 -> 5 -> 2 -> 1.", "arb": "يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' طلاب مرتبين في دائرة بحيث بعد 'm' تمريرات، تعود الكرة إلى الطالب الذي بدأ التمرير.\n\nتستخدم الدالة البرمجة الديناميكية لتحديد عدد تسلسلات التمرير. يمكن لكل طالب تمرير الكرة إما إلى الجار الأيسر أو إلى الجار الأيمن.\n\nالمعطيات:\nn: عدد الطلاب الواقفين في دائرة.\nm: عدد المرات التي يتم فيها تمرير الكرة.\n\nالقيم المعادة:\nعدد صحيح يمثل عدد الطرق المختلفة للتمرير التي تؤدي إلى عودة الكرة إلى الطالب الذي بدأ التمرير بعد 'm' تمريرات.\n\nالحالات:\nالحالة 1:\nبالنسبة لعدد n = 3 طلاب و m = 3 تمريرات، يجب أن تعيد الدالة 2.\nهناك تسلسلان: 1 -> 2 -> 3 -> 1 و 1 -> 3 -> 2 -> 1.\n\nالحالة 2:\nبالنسبة لعدد n = 4 طلاب و m = 2 تمريرات، يجب أن تعيد الدالة 2.\nهناك تسلسلان: 1 -> 2 -> 1 و 1 -> 4 -> 1.\n\nالحالة 3:\nبالنسبة لعدد n = 5 طلاب و m = 4 تمريرات، يجب أن تعيد الدالة 6.\nتشمل التسلسلات: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nو 1 -> 4 -> 5 -> 2 -> 1.", "sw": "Hesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliopangwa katika mduara\nhivyo kwamba baada ya kupitisha 'm', mpira unarudi kwa mwanafunzi wa kuanzia.\n\nKazi hii inatumia programu ya nguvu kuamua idadi ya mfuatano wa kupitisha. Kila mwanafunzi\nanaweza kupitisha mpira ama kwa jirani wa kushoto au kwa jirani wa kulia.\n\nHoja:\nn: Idadi ya wanafunzi waliopo katika mduara.\nm: Idadi ya mara ambazo mpira unapita.\n\nInarejesha:\nNambari kamili inayowakilisha idadi ya njia tofauti za kupitisha ambazo zinasababisha mpira\nkurudi kwa mwanafunzi wa kuanzia baada ya kupitisha 'm'.\n\nCases:\nCase 1:\nKwa n = wanafunzi 3 na m = kupitisha 3, kazi inapaswa kurudisha 2.\nKuna mfuatano miwili: 1 -> 2 -> 3 -> 1 na 1 -> 3 -> 2 -> 1.\n\nCase 2:\nKwa n = wanafunzi 4 na m = kupitisha 2, kazi inapaswa kurudisha 2.\nKuna mfuatano miwili: 1 -> 2 -> 1 na 1 -> 4 -> 1.\n\nCase 3:\nKwa n = wanafunzi 5 na m = kupitisha 4, kazi inapaswa kurudisha 6.\nMfuatano unajumuisha: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nna 1 -> 4 -> 5 -> 2 -> 1.", "tr": "Farklı sayıda topu, bir daire içinde düzenlenmiş 'n' öğrenci arasında\nöyle bir şekilde geçirme yollarını sayar ki, 'm' paslaşmadan sonra top başlangıçtaki öğrenciye geri döner.\n\nFonksiyon, paslaşma dizilerinin sayısını belirlemek için dinamik programlama kullanır. Her öğrenci\ntopu ya sol komşusuna ya da sağ komşusuna geçirebilir.\n\nArgümanlar:\nn: Bir daire içinde duran öğrenci sayısı.\nm: Topun kaç kez paslandığı.\n\nDöndürür:\n'm' paslaşmadan sonra topun başlangıçtaki öğrenciye geri dönmesiyle sonuçlanan\nfarklı paslaşma yollarının sayısını temsil eden bir tamsayı.\n\nDurumlar:\nDurum 1:\nn = 3 öğrenci ve m = 3 pas için, fonksiyon 2 döndürmelidir.\nİki dizi vardır: 1 -> 2 -> 3 -> 1 ve 1 -> 3 -> 2 -> 1.\n\nDurum 2:\nn = 4 öğrenci ve m = 2 pas için, fonksiyon 2 döndürmelidir.\nİki dizi vardır: 1 -> 2 -> 1 ve 1 -> 4 -> 1.\n\nDurum 3:\nn = 5 öğrenci ve m = 4 pas için, fonksiyon 6 döndürmelidir.\nDiziler şunları içerir: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nve 1 -> 4 -> 5 -> 2 -> 1.", "vi": "Đếm số cách khác nhau để chuyền một quả bóng giữa 'n' học sinh được sắp xếp thành một vòng tròn\nsao cho sau 'm' lần chuyền, quả bóng trở về học sinh bắt đầu.\n\nHàm sử dụng lập trình động để xác định số lượng chuỗi chuyền bóng. Mỗi học sinh\ncó thể chuyền bóng cho người bên trái hoặc người bên phải.\n\nTham số:\nn: Số lượng học sinh đứng thành vòng tròn.\nm: Số lần quả bóng được chuyền.\n\nTrả về:\nMột số nguyên đại diện cho số cách chuyền khác nhau mà kết quả là quả bóng\ntrở về học sinh bắt đầu sau 'm' lần chuyền.\n\nCases:\nCase 1:\nVới n = 3 học sinh và m = 3 lần chuyền, hàm sẽ trả về 2.\nCó hai chuỗi: 1 -> 2 -> 3 -> 1 và 1 -> 3 -> 2 -> 1.\n\nCase 2:\nVới n = 4 học sinh và m = 2 lần chuyền, hàm sẽ trả về 2.\nCó hai chuỗi: 1 -> 2 -> 1 và 1 -> 4 -> 1.\n\nCase 3:\nVới n = 5 học sinh và m = 4 lần chuyền, hàm sẽ trả về 6.\nCác chuỗi bao gồm: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nvà 1 -> 4 -> 5 -> 2 -> 1.", "id": "Menghitung jumlah cara berbeda untuk mengoper bola di antara 'n' siswa yang diatur dalam lingkaran sedemikian rupa sehingga setelah 'm' operan, bola kembali ke siswa awal.\n\nFungsi ini menggunakan pemrograman dinamis untuk menentukan jumlah urutan operan. Setiap siswa dapat mengoper bola baik ke tetangga kiri atau ke tetangga kanan.\n\nArgs:\nn: Jumlah siswa yang berdiri dalam lingkaran.\nm: Jumlah kali bola dioper.\n\nReturns:\nSebuah bilangan bulat yang mewakili jumlah cara operan yang berbeda yang mengakibatkan bola kembali ke siswa awal setelah 'm' operan.\n\nKasus:\nKasus 1:\nUntuk n = 3 siswa dan m = 3 operan, fungsi harus mengembalikan 2.\nAda dua urutan: 1 -> 2 -> 3 -> 1 dan 1 -> 3 -> 2 -> 1.\n\nKasus 2:\nUntuk n = 4 siswa dan m = 2 operan, fungsi harus mengembalikan 2.\nAda dua urutan: 1 -> 2 -> 1 dan 1 -> 4 -> 1.\n\nKasus 3:\nUntuk n = 5 siswa dan m = 4 operan, fungsi harus mengembalikan 6.\nUrutannya termasuk: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\ndan 1 -> 4 -> 5 -> 2 -> 1.", "ja": "'n' 人の学生が円形に並んでいる中で、ボールを渡す異なる方法の数を数えます。'm' 回のパスの後に、ボールが開始した学生に戻るようにします。\n\nこの関数は動的計画法を使用して、パスのシーケンスの数を決定します。各学生はボールを左隣の学生または右隣の学生に渡すことができます。\n\n引数:\nn: 円形に立っている学生の数。\nm: ボールが渡される回数。\n\n戻り値:\nボールが 'm' 回のパスの後に開始した学生に戻る結果となる、異なるパスの方法の数を表す整数。\n\nケース:\nケース 1:\nn = 3 人の学生と m = 3 回のパスの場合、関数は 2 を返すべきです。\n2 つのシーケンスがあります: 1 -> 2 -> 3 -> 1 と 1 -> 3 -> 2 -> 1。\n\nケース 2:\nn = 4 人の学生と m = 2 回のパスの場合、関数は 2 を返すべきです。\n2 つのシーケンスがあります: 1 -> 2 -> 1 と 1 -> 4 -> 1。\n\nケース 3:\nn = 5 人の学生と m = 4 回のパスの場合、関数は 6 を返すべきです。\nシーケンスには以下が含まれます: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nおよび 1 -> 4 -> 5 -> 2 -> 1。", "ko": "'n'명의 학생이 원형으로 배열된 상태에서 공을 전달하는 서로 다른 방법의 수를 계산하여 'm'번의 패스 후에 공이 시작 학생에게 돌아오도록 합니다.\n\n이 함수는 동적 프로그래밍을 사용하여 전달 시퀀스의 수를 결정합니다. 각 학생은 공을 왼쪽 이웃이나 오른쪽 이웃에게 전달할 수 있습니다.\n\nArgs:\nn: 원형으로 서 있는 학생의 수.\nm: 공이 전달되는 횟수.\n\nReturns:\n'm'번의 패스 후에 공이 시작 학생에게 돌아오게 하는 서로 다른 전달 방법의 수를 나타내는 정수.\n\nCases:\nCase 1:\nn = 3명의 학생과 m = 3번의 패스에 대해, 함수는 2를 반환해야 합니다.\n두 가지 시퀀스가 있습니다: 1 -> 2 -> 3 -> 1과 1 -> 3 -> 2 -> 1.\n\nCase 2:\nn = 4명의 학생과 m = 2번의 패스에 대해, 함수는 2를 반환해야 합니다.\n두 가지 시퀀스가 있습니다: 1 -> 2 -> 1과 1 -> 4 -> 1.\n\nCase 3:\nn = 5명의 학생과 m = 4번의 패스에 대해, 함수는 6을 반환해야 합니다.\n시퀀스에는 다음이 포함됩니다: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n그리고 1 -> 4 -> 5 -> 2 -> 1.", "ml": "'n' വിദ്യാർത്ഥികളെ ഒരു വൃത്തത്തിൽ നിരത്തി, 'm' തവണ പന്ത് കൈമാറിയ ശേഷം പന്ത് ആരംഭിക്കുന്ന വിദ്യാർത്ഥിയിലേക്ക് മടങ്ങിയെത്തുന്ന വ്യത്യസ്ത മാർഗ്ഗങ്ങളുടെ എണ്ണം എണ്ണുന്നു.\n\nഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് പന്ത് കൈമാറ്റത്തിന്റെ എണ്ണം നിർണ്ണയിക്കുന്നതിനുള്ള ഫംഗ്ഷൻ. ഓരോ വിദ്യാർത്ഥിയും പന്ത് ഇടത് അയൽക്കാരനോ വലത് അയൽക്കാരനോക്ക് കൈമാറാം.\n\nArgs:\nn: ഒരു വൃത്തത്തിൽ നിൽക്കുന്ന വിദ്യാർത്ഥികളുടെ എണ്ണം.\nm: പന്ത് കൈമാറുന്ന തവണകളുടെ എണ്ണം.\n\nReturns:\n'm' തവണ കൈമാറിയ ശേഷം പന്ത് ആരംഭിക്കുന്ന വിദ്യാർത്ഥിയിലേക്ക് മടങ്ങിയെത്തുന്ന വ്യത്യസ്തമായ പന്ത് കൈമാറ്റ മാർഗ്ഗങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\nCases:\nകേസ് 1:\nn = 3 വിദ്യാർത്ഥികൾക്കും m = 3 പന്ത് കൈമാറ്റങ്ങൾക്കുമായി, ഫംഗ്ഷൻ 2 മടക്കണം.\nരണ്ട് ക്രമങ്ങളുണ്ട്: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\nകേസ് 2:\nn = 4 വിദ്യാർത്ഥികൾക്കും m = 2 പന്ത് കൈമാറ്റങ്ങൾക്കുമായി, ഫംഗ്ഷൻ 2 മടക്കണം.\nരണ്ട് ക്രമങ്ങളുണ്ട്: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\nകേസ് 3:\nn = 5 വിദ്യാർത്ഥികൾക്കും m = 4 പന്ത് കൈമാറ്റങ്ങൾക്കുമായി, ഫംഗ്ഷൻ 6 മടക്കണം.\nക്രമങ്ങളിൽ ഉൾപ്പെടുന്നു: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nand 1 -> 4 -> 5 -> 2 -> 1.", "fa": "تعداد روش‌های مختلف برای پاس دادن توپ بین 'n' دانش‌آموز که به صورت دایره‌ای چیده شده‌اند را می‌شمارد\nبه طوری که پس از 'm' پاس، توپ به دانش‌آموز شروع‌کننده برگردد.\n\nاین تابع از برنامه‌ریزی پویا برای تعیین تعداد توالی‌های پاس استفاده می‌کند. هر دانش‌آموز\nمی‌تواند توپ را به همسایه چپ یا همسایه راست پاس دهد.\n\nآرگومان‌ها:\nn: تعداد دانش‌آموزانی که در یک دایره ایستاده‌اند.\nm: تعداد دفعاتی که توپ پاس داده می‌شود.\n\nبازگشت:\nیک عدد صحیح که نشان‌دهنده تعداد روش‌های متمایز پاس دادن است که منجر به\nبازگشت توپ به دانش‌آموز شروع‌کننده پس از 'm' پاس می‌شود.\n\nموارد:\nمورد 1:\nبرای n = 3 دانش‌آموز و m = 3 پاس، تابع باید 2 را برگرداند.\nدو توالی وجود دارد: 1 -> 2 -> 3 -> 1 و 1 -> 3 -> 2 -> 1.\n\nمورد 2:\nبرای n = 4 دانش‌آموز و m = 2 پاس، تابع باید 2 را برگرداند.\nدو توالی وجود دارد: 1 -> 2 -> 1 و 1 -> 4 -> 1.\n\nمورد 3:\nبرای n = 5 دانش‌آموز و m = 4 پاس، تابع باید 6 را برگرداند.\nتوالی‌ها شامل: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nو 1 -> 4 -> 5 -> 2 -> 1."}}
{"task_id": "Python/17", "prompt": {"en": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "sq": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Hiq numrat e përsëritur nga lista e dhënë dhe kthe numrat unik të renditur.\n\n    Funksioni fillimisht konverton listën e numrave të dhënë në një set për të hequr çdo përsëritje,\n    pastaj rendit setin rezultues të numrave unik. Ai kthen një tuple që përmban numrin\n    e numrave unik dhe një listë të këtyre numrave unik të renditur në rend rritës.\n\n    Args:\n    numbers (List[int]): Një listë e numrave të plotë, e cila mund të përmbajë përsëritje.\n\n    Returns:\n    Tuple[int, List[int]]: Një tuple me dy elemente:\n        - Një numër i plotë që përfaqëson numrin e numrave unik.\n        - Një listë e numrave unik të renditur në rend rritës.\n\n    Shembuj:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "hy": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Հեռացնել կրկնվող ամբողջ թվերը մուտքային ցուցակից և վերադարձնել դասավորված եզակի թվերը:\n\n    Ֆունկցիան նախ փոխակերպում է մուտքային ցուցակը ամբողջ թվերի մեջ հավաքածուի՝ հեռացնելու համար կրկնօրինակները,\n    այնուհետև դասավորում է ստացված եզակի թվերի հավաքածուն։ Այն վերադարձնում է տուփ, որը պարունակում է\n    եզակի թվերի քանակը և այս եզակի թվերի ցուցակը աճման կարգով։\n\n    Արձանագրություններ:\n    numbers (List[int]): Ամբողջ թվերի ցուցակ, որը կարող է պարունակել կրկնօրինակներ:\n\n    Վերադարձնում է:\n    Tuple[int, List[int]]: Տուփ երկու տարրերով:\n        - Ամբողջ թիվ, որը ներկայացնում է եզակի թվերի քանակը:\n        - Եզակի թվերի ցուցակ, դասավորված աճման կարգով:\n\n    Օրինակներ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "bn": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    ইনপুট তালিকা থেকে সদৃশ পূর্ণসংখ্যা সরান এবং বাছাইকৃত অনন্য সংখ্যাগুলি ফেরত দিন।\n\n    ফাংশনটি প্রথমে ইনপুট তালিকার সংখ্যাগুলিকে একটি সেটে রূপান্তর করে যাতে কোনো সদৃশ সংখ্যা না থাকে,\n    তারপর অনন্য সংখ্যাগুলির সেটটি সাজানো হয়। এটি একটি টিউপল ফেরত দেয় যা অন্তর্ভুক্ত করে\n    অনন্য সংখ্যাগুলির সংখ্যা এবং এই অনন্য সংখ্যাগুলির একটি তালিকা ক্রমবর্ধমান ক্রমে।\n\n    Args:\n    numbers (List[int]): পূর্ণসংখ্যার একটি তালিকা, যা সদৃশ থাকতে পারে।\n\n    Returns:\n    Tuple[int, List[int]]: একটি টিউপল যার দুটি উপাদান রয়েছে:\n        - একটি পূর্ণসংখ্যা যা অনন্য সংখ্যাগুলির সংখ্যা নির্দেশ করে।\n        - অনন্য সংখ্যাগুলির একটি তালিকা যা ক্রমবর্ধমান ক্রমে সাজানো।\n\n    উদাহরণ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "bg": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Премахване на дублиращи се цели числа от входния списък и връщане на сортираните уникални числа.\n\n    Функцията първо преобразува входния списък от числа в множество, за да премахне дубликатите,\n    след това сортира полученото множество от уникални числа. Връща кортеж, съдържащ броя\n    на уникалните числа и списък с тези уникални числа в нарастващ ред.\n\n    Аргументи:\n    numbers (List[int]): Списък от цели числа, който може да съдържа дубликати.\n\n    Връща:\n    Tuple[int, List[int]]: Кортеж с два елемента:\n        - Цяло число, представляващо броя на уникалните числа.\n        - Списък с уникалните числа, сортирани в нарастващ ред.\n\n    Примери:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "zh": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    从输入列表中移除重复的整数，并返回排序后的唯一数字。\n\n    该函数首先将输入的数字列表转换为集合以去除任何重复项，\n    然后对结果中的唯一数字集合进行排序。它返回一个包含两个元素的元组，\n    其中包括唯一数字的数量和按升序排列的唯一数字列表。\n\n    参数:\n    numbers (List[int]): 一个可能包含重复项的整数列表。\n\n    返回:\n    Tuple[int, List[int]]: 一个包含两个元素的元组：\n        - 一个整数，表示唯一数字的数量。\n        - 一个按升序排列的唯一数字列表。\n\n    示例:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "fr": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Supprime les entiers dupliqués de la liste d'entrée et retourne les nombres uniques triés.\n\n    La fonction convertit d'abord la liste d'entrée de nombres en un ensemble pour supprimer les doublons,\n    puis trie l'ensemble résultant de nombres uniques. Elle retourne un tuple contenant le nombre\n    de nombres uniques et une liste de ces nombres uniques dans l'ordre croissant.\n\n    Args:\n    numbers (List[int]): Une liste d'entiers, qui peut contenir des doublons.\n\n    Returns:\n    Tuple[int, List[int]]: Un tuple avec deux éléments :\n        - Un entier représentant le nombre de nombres uniques.\n        - Une liste des nombres uniques triés dans l'ordre croissant.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "de": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Entferne doppelte Ganzzahlen aus der Eingabeliste und gib die sortierten einzigartigen Zahlen zurück.\n\n    Die Funktion konvertiert zuerst die Eingabeliste von Zahlen in eine Menge, um Duplikate zu entfernen,\n    und sortiert dann die resultierende Menge von einzigartigen Zahlen. Sie gibt ein Tupel zurück, das die Anzahl\n    der einzigartigen Zahlen und eine Liste dieser einzigartigen Zahlen in aufsteigender Reihenfolge enthält.\n\n    Argumente:\n    numbers (List[int]): Eine Liste von Ganzzahlen, die Duplikate enthalten kann.\n\n    Rückgabewerte:\n    Tuple[int, List[int]]: Ein Tupel mit zwei Elementen:\n        - Eine Ganzzahl, die die Anzahl der einzigartigen Zahlen darstellt.\n        - Eine Liste der einzigartigen Zahlen, sortiert in aufsteigender Reihenfolge.\n\n    Beispiele:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "ha": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Cire lambobin maimaitawa daga jerin shigarwa kuma dawo da lambobin da ba su maimaita ba a tsare su.\n\n    Aiki na farko yana canza jerin lambobin shigarwa zuwa saitin don cire duk wani maimaitawa,\n    sannan yana tsara saitin lambobin da ba su maimaita ba. Yana dawowa da tuple wanda ke dauke da adadin\n    lambobin da ba su maimaita ba da kuma jerin wadannan lambobin da ba su maimaita ba a tsare su.\n\n    Args:\n    numbers (List[int]): Jerin lambobi, wanda zai iya dauke da maimaitawa.\n\n    Returns:\n    Tuple[int, List[int]]: Tuple mai dauke da abubuwa biyu:\n        - Lamba daya da ke nuna adadin lambobin da ba su maimaita ba.\n        - Jerin lambobin da ba su maimaita ba a tsare su.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "hi": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    इनपुट सूची से डुप्लिकेट पूर्णांकों को हटाएं और क्रमबद्ध अद्वितीय संख्याएँ लौटाएं।\n\n    यह फ़ंक्शन पहले संख्याओं की इनपुट सूची को एक सेट में परिवर्तित करता है ताकि कोई भी डुप्लिकेट हट जाए,\n    फिर अद्वितीय संख्याओं के परिणामी सेट को क्रमबद्ध करता है। यह एक ट्यूपल लौटाता है जिसमें अद्वितीय संख्याओं की गिनती\n    और इन अद्वितीय संख्याओं की एक सूची आरोही क्रम में होती है।\n\n    Args:\n    numbers (List[int]): पूर्णांकों की एक सूची, जिसमें डुप्लिकेट हो सकते हैं।\n\n    Returns:\n    Tuple[int, List[int]]: एक ट्यूपल जिसमें दो तत्व होते हैं:\n        - एक पूर्णांक जो अद्वितीय संख्याओं की गिनती का प्रतिनिधित्व करता है।\n        - अद्वितीय संख्याओं की एक सूची जो आरोही क्रम में क्रमबद्ध होती है।\n\n    उदाहरण:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "hu": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Távolítsa el a duplikált egész számokat a bemeneti listából, és adja vissza a rendezett, egyedi számokat.\n\n    A függvény először a bemeneti számok listáját halmazzá alakítja, hogy eltávolítsa a duplikátumokat,\n    majd rendezi az így kapott egyedi számok halmazát. Egy olyan tuple-t ad vissza, amely tartalmazza\n    az egyedi számok számát és az egyedi számok listáját növekvő sorrendben.\n\n    Args:\n    numbers (List[int]): Egy egész számokat tartalmazó lista, amely tartalmazhat duplikátumokat.\n\n    Returns:\n    Tuple[int, List[int]]: Egy tuple két elemmel:\n        - Egy egész szám, amely az egyedi számok számát jelöli.\n        - Egy lista az egyedi számokról növekvő sorrendben.\n\n    Példák:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "es": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Elimina los enteros duplicados de la lista de entrada y devuelve los números únicos ordenados.\n\n    La función primero convierte la lista de números de entrada en un conjunto para eliminar cualquier duplicado,\n    luego ordena el conjunto resultante de números únicos. Devuelve una tupla que contiene el conteo\n    de números únicos y una lista de estos números únicos en orden ascendente.\n\n    Argumentos:\n    numbers (List[int]): Una lista de enteros, que puede contener duplicados.\n\n    Devuelve:\n    Tuple[int, List[int]]: Una tupla con dos elementos:\n        - Un entero que representa el conteo de números únicos.\n        - Una lista de los números únicos ordenados en orden ascendente.\n\n    Ejemplos:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "arb": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    إزالة الأعداد الصحيحة المكررة من قائمة الإدخال وإرجاع الأرقام الفريدة المرتبة.\n\n    تقوم الدالة أولاً بتحويل قائمة الأرقام المدخلة إلى مجموعة لإزالة أي تكرارات،\n    ثم تقوم بترتيب مجموعة الأرقام الفريدة الناتجة. تُرجع الدالة زوجًا يحتوي على عدد\n    الأرقام الفريدة وقائمة بهذه الأرقام الفريدة بترتيب تصاعدي.\n\n    يعيدالحجج:\n    numbers (List[int]): قائمة من الأعداد الصحيحة، والتي قد تحتوي على تكرارات.\n\n    يعيد:\n    Tuple[int, List[int]]: زوج يحتوي على عنصرين:\n        - عدد صحيح يمثل عدد الأرقام الفريدة.\n        - قائمة من الأرقام الفريدة مرتبة بترتيب تصاعدي.\n\n    امثله:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "sw": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Ondoa namba za kurudiarudia kutoka kwenye orodha ya pembejeo na rudisha namba za kipekee zilizopangwa.\n\n    Kazi hii kwanza inabadilisha orodha ya pembejeo ya namba kuwa seti ili kuondoa nakala,\n    kisha inapanga seti inayotokana ya namba za kipekee. Inarudisha jozi inayoelezea idadi\n    ya namba za kipekee na orodha ya namba hizi za kipekee kwa mpangilio wa kupanda.\n\n    Hoja:\n    numbers (List[int]): Orodha ya namba za mzima, ambayo inaweza kuwa na nakala.\n\n    Inarejesha:\n    Tuple[int, List[int]]: Jozi yenye vipengele viwili:\n        - Namba ya mzima inayowakilisha idadi ya namba za kipekee.\n        - Orodha ya namba za kipekee zilizopangwa kwa mpangilio wa kupanda.\n\n    Mifano:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "tr": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Girdi listesinden tekrar eden tamsayıları kaldır ve sıralanmış benzersiz sayıları döndür.\n\n    Fonksiyon, ilk olarak girdi listesindeki sayıları bir kümeye dönüştürerek tekrar edenleri kaldırır,\n    ardından benzersiz sayıların bulunduğu kümeyi sıralar. Benzersiz sayıların sayısını ve bu sayıların\n    artan sırayla listelendiği bir liste içeren bir demet döndürür.\n\n    Argümanlar:\n    numbers (List[int]): Tekrar edenleri içerebilecek bir tamsayı listesi.\n\n    Döndürür:\n    Tuple[int, List[int]]: İki elemanlı bir demet:\n        - Benzersiz sayıların sayısını temsil eden bir tamsayı.\n        - Benzersiz sayıların artan sırayla sıralandığı bir liste.\n\n    Örnekler:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "vi": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Loại bỏ các số nguyên trùng lặp khỏi danh sách đầu vào và trả về các số duy nhất đã được sắp xếp.\n\n    Hàm này trước tiên chuyển đổi danh sách số đầu vào thành một tập hợp để loại bỏ bất kỳ số trùng lặp nào,\n    sau đó sắp xếp tập hợp các số duy nhất thu được. Nó trả về một bộ giá trị chứa số lượng\n    các số duy nhất và một danh sách các số duy nhất này theo thứ tự tăng dần.\n\n    Tham số:\n    numbers (List[int]): Một danh sách các số nguyên, có thể chứa các số trùng lặp.\n\n    Trả về:\n    Tuple[int, List[int]]: Một bộ giá trị với hai phần tử:\n        - Một số nguyên đại diện cho số lượng các số duy nhất.\n        - Một danh sách các số duy nhất được sắp xếp theo thứ tự tăng dần.\n\n    Ví dụ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "id": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Hapus bilangan bulat duplikat dari daftar input dan kembalikan angka unik yang sudah diurutkan.\n\n    Fungsi ini pertama mengubah daftar angka input menjadi satu set untuk menghapus duplikat,\n    kemudian mengurutkan set angka unik yang dihasilkan. Fungsi ini mengembalikan tuple yang berisi\n    jumlah angka unik dan daftar angka unik tersebut dalam urutan menaik.\n\n    Args:\n    numbers (List[int]): Daftar bilangan bulat, yang mungkin mengandung duplikat.\n\n    Returns:\n    Tuple[int, List[int]]: Sebuah tuple dengan dua elemen:\n        - Sebuah bilangan bulat yang mewakili jumlah angka unik.\n        - Daftar angka unik yang diurutkan dalam urutan menaik.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "ja": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    入力リストから重複する整数を削除し、ソートされたユニークな数字を返します。\n\n    この関数は、まず入力された数字のリストをセットに変換して重複を削除し、\n    次にユニークな数字のセットをソートします。ユニークな数字の数と、\n    昇順にソートされたユニークな数字のリストを含むタプルを返します。\n\n    引数:\n    numbers (List[int]): 重複を含む可能性のある整数のリスト。\n\n    戻り値:\n    Tuple[int, List[int]]: 2つの要素を持つタプル:\n        - ユニークな数字の数を表す整数。\n        - 昇順にソートされたユニークな数字のリスト。\n\n    例:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "ko": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    입력 리스트에서 중복된 정수를 제거하고 정렬된 고유 숫자를 반환합니다.\n\n    이 함수는 먼저 입력된 숫자 리스트를 집합으로 변환하여 중복을 제거한 후,\n    고유 숫자의 집합을 정렬합니다. 고유 숫자의 개수와 오름차순으로 정렬된\n    고유 숫자의 리스트를 포함하는 튜플을 반환합니다.\n\n    Args:\n    numbers (List[int]): 중복이 포함될 수 있는 정수 리스트.\n\n    Returns:\n    Tuple[int, List[int]]: 두 개의 요소를 가진 튜플:\n        - 고유 숫자의 개수를 나타내는 정수.\n        - 오름차순으로 정렬된 고유 숫자의 리스트.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "ml": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    ഇൻപുട്ട് ലിസ്റ്റിൽ നിന്ന് പുനരാവൃത സംഖ്യകൾ നീക്കംചെയ്ത് ക്രമീകരിച്ച ഏകീകൃത സംഖ്യകൾ മടക്കിനൽകുക.\n\n    ഫംഗ്ഷൻ ആദ്യം പുനരാവൃതികൾ നീക്കംചെയ്യാൻ സംഖ്യകളുടെ ഇൻപുട്ട് ലിസ്റ്റിനെ ഒരു സെറ്റായി മാറ്റുന്നു,\n    തുടർന്ന് ഏകീകൃത സംഖ്യകളുടെ സെറ്റ് ക്രമീകരിക്കുന്നു. ഇത് ഏകീകൃത സംഖ്യകളുടെ എണ്ണം അടങ്ങിയ ഒരു ട്യൂപ്പിൾ മടക്കിനൽകുന്നു\n    കൂടാതെ ഉയരുന്ന ക്രമത്തിൽ ക്രമീകരിച്ച ഈ ഏകീകൃത സംഖ്യകളുടെ ഒരു ലിസ്റ്റും.\n\n    Args:\n    numbers (List[int]): പുനരാവൃതികൾ അടങ്ങിയിരിക്കാവുന്ന സംഖ്യകളുടെ ഒരു ലിസ്റ്റ്.\n\n    Returns:\n    Tuple[int, List[int]]: രണ്ട് ഘടകങ്ങളുള്ള ഒരു ട്യൂപ്പിൾ:\n        - ഏകീകൃത സംഖ്യകളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n        - ഉയരുന്ന ക്രമത്തിൽ ക്രമീകരിച്ച ഏകീകൃത സംഖ്യകളുടെ ഒരു ലിസ്റ്റ്.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "fa": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    اعداد صحیح تکراری را از لیست ورودی حذف کرده و اعداد منحصر به فرد مرتب شده را برگردانید.\n\n    این تابع ابتدا لیست ورودی اعداد را به یک مجموعه تبدیل می‌کند تا هرگونه تکرار را حذف کند،\n    سپس مجموعه حاصل از اعداد منحصر به فرد را مرتب می‌کند. این تابع یک تاپل شامل تعداد\n    اعداد منحصر به فرد و لیستی از این اعداد منحصر به فرد به ترتیب صعودی برمی‌گرداند.\n\n    آرگومان‌ها:\n    numbers (List[int]): لیستی از اعداد صحیح که ممکن است شامل تکرار باشد.\n\n    بازگشت:\n    Tuple[int, List[int]]: یک تاپل با دو عنصر:\n        - یک عدد صحیح که نشان‌دهنده تعداد اعداد منحصر به فرد است.\n        - لیستی از اعداد منحصر به فرد که به ترتیب صعودی مرتب شده‌اند.\n\n    مثال‌ها:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\""}, "canonical_solution": "# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers", "instruction": {"en": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nՏրամադրել կարճ բնութագրություն (docstring) Python կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），不超过500个字符。", "fr": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.", "vi": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\n다음 Python 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ പ്രകൃതിദത്ത ഭാഷാ വിവരണം (docstring) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر داشته باشد."}, "level": "", "test": "def test_process_random_numbers():\n    # Test case 1: Basic example with duplicates\n    assert process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15]) == (8, [15, 20, 32, 40, 67, 89, 300, 400]), \"Test case 1 failed\"\n\n    # Test case 2: All elements are the same\n    assert process_random_numbers([1, 1, 1, 1]) == (1, [1]), \"Test case 2 failed\"\n\n    # Test case 3: No duplicates\n    assert process_random_numbers([3, 1, 4, 2]) == (4, [1, 2, 3, 4]), \"Test case 3 failed\"\n\n    # Test case 4: Random numbers with single element\n    assert process_random_numbers([42]) == (1, [42]), \"Test case 4 failed\"\n\n    # Test case 5: Empty list\n    assert process_random_numbers([]) == (0, []), \"Test case 5 failed\"\n\n    # Test case 6: Random numbers with negatives and zero\n    assert process_random_numbers([0, -1, -2, -1, 0, 3]) == (4, [-2, -1, 0, 3]), \"Test case 6 failed\"\n\n    # Test case 7: Large range of numbers\n    assert process_random_numbers(list(range(1000, 0, -1))) == (1000, list(range(1, 1001))), \"Test case 7 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_process_random_numbers()", "entry_point": "process_random_numbers", "signature": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:", "docstring": {"en": "Remove duplicate integers from the input list and return the sorted unique numbers.\n\nThe function first converts the input list of numbers into a set to remove any duplicates,\nthen sorts the resulting set of unique numbers. It returns a tuple containing the count\nof unique numbers and a list of these unique numbers in ascending order.\n\nArgs:\nnumbers (List[int]): A list of integers, which may contain duplicates.\n\nReturns:\nTuple[int, List[int]]: A tuple with two elements:\n- An integer representing the count of unique numbers.\n- A list of the unique numbers sorted in ascending order.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "sq": "Hiqni numrat e përsëritur nga lista hyrëse dhe ktheni numrat unik të renditur.\n\nFunksioni fillimisht konverton listën hyrëse të numrave në një set për të hequr çdo përsëritje,\npastaj rendit setin e rezultuar të numrave unik. Ai kthen një tuple që përmban numrin\ne numrave unik dhe një listë të këtyre numrave unik në rend rritës.\n\nArgumentet:\nnumbers (List[int]): Një listë e numrave të plotë, e cila mund të përmbajë përsëritje.\n\nKthen:\nTuple[int, List[int]]: Një tuple me dy elemente:\n- Një numër i plotë që përfaqëson numrin e numrave unik.\n- Një listë e numrave unik të renditur në rend rritës.\n\nShembuj:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "hy": "Հեռացնել կրկնվող ամբողջ թվերը մուտքային ցուցակից և վերադարձնել դասավորված եզակի թվերը:\n\nՖունկցիան նախ փոխակերպում է մուտքային ցուցակը ամբողջ թվերի հավաքածուի՝ հեռացնելու համար ցանկացած կրկնօրինակ, այնուհետև դասավորում է ստացված եզակի թվերի հավաքածուն: Այն վերադարձնում է տապլիկ, որը պարունակում է եզակի թվերի քանակը և այս եզակի թվերի ցուցակը աճման կարգով:\n\nԱրձագանքներ:\nnumbers (List[int]): Ամբողջ թվերի ցուցակ, որը կարող է պարունակել կրկնօրինակներ:\n\nՎերադարձնում է:\nTuple[int, List[int]]: Տապլիկ երկու տարրերով:\n- Ամբողջ թիվ, որը ներկայացնում է եզակի թվերի քանակը:\n- Եզակի թվերի ցուցակ, դասավորված աճման կարգով:\n\nՕրինակներ:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "bn": "ইনপুট তালিকা থেকে সদৃশ পূর্ণসংখ্যাগুলি সরিয়ে ফেলুন এবং বাছাইকৃত অনন্য সংখ্যাগুলি ফেরত দিন।\n\nফাংশনটি প্রথমে ইনপুট তালিকার সংখ্যাগুলিকে একটি সেটে রূপান্তর করে যাতে কোনো সদৃশ সংখ্যা না থাকে, তারপর অনন্য সংখ্যাগুলির সেটটিকে সাজায়। এটি একটি টিউপল ফেরত দেয় যা অনন্য সংখ্যাগুলির গণনা এবং এই অনন্য সংখ্যাগুলির একটি তালিকা উর্ধ্বক্রমে সাজানো অবস্থায় ধারণ করে।\n\nআর্গস:\nnumbers (List[int]): পূর্ণসংখ্যার একটি তালিকা, যা সদৃশ সংখ্যা ধারণ করতে পারে।\n\nরিটার্নস:\nTuple[int, List[int]]: একটি টিউপল যার দুটি উপাদান রয়েছে:\n- একটি পূর্ণসংখ্যা যা অনন্য সংখ্যাগুলির গণনা উপস্থাপন করে।\n- উর্ধ্বক্রমে সাজানো অনন্য সংখ্যাগুলির একটি তালিকা।\n\nউদাহরণ:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "bg": "Премахнете дублиращите се цели числа от входния списък и върнете сортираните уникални числа.\n\nФункцията първо преобразува входния списък от числа в множество, за да премахне всички дубликати, след което сортира полученото множество от уникални числа. Тя връща кортеж, съдържащ броя на уникалните числа и списък с тези уникални числа в нарастващ ред.\n\nАргументи:\nnumbers (List[int]): Списък от цели числа, който може да съдържа дубликати.\n\nВръща:\nTuple[int, List[int]]: Кортеж с два елемента:\n- Цяло число, представляващо броя на уникалните числа.\n- Списък с уникалните числа, сортирани в нарастващ ред.\n\nПримери:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "zh": "从输入列表中移除重复的整数，并返回排序后的唯一数字。\n\n该函数首先将输入的数字列表转换为集合以去除任何重复项，\n然后对所得的唯一数字集合进行排序。它返回一个包含唯一数字计数的元组\n和一个按升序排列的唯一数字列表。\n\n参数:\nnumbers (List[int]): 一个整数列表，可能包含重复项。\n\n返回:\nTuple[int, List[int]]: 一个包含两个元素的元组：\n- 一个整数，表示唯一数字的数量。\n- 一个按升序排序的唯一数字列表。\n\n示例:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "fr": "Supprimer les entiers dupliqués de la liste d'entrée et retourner les nombres uniques triés.\n\nLa fonction convertit d'abord la liste d'entiers en un ensemble pour supprimer les doublons, puis trie l'ensemble résultant de nombres uniques. Elle retourne un tuple contenant le nombre de nombres uniques et une liste de ces nombres uniques dans l'ordre croissant.\n\nArgs:\nnumbers (List[int]): Une liste d'entiers, qui peut contenir des doublons.\n\nReturns:\nTuple[int, List[int]]: Un tuple avec deux éléments :\n- Un entier représentant le nombre de nombres uniques.\n- Une liste des nombres uniques triés dans l'ordre croissant.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "de": "Entfernen Sie doppelte Ganzzahlen aus der Eingabeliste und geben Sie die sortierten eindeutigen Zahlen zurück.\n\nDie Funktion konvertiert zuerst die Eingabeliste von Zahlen in eine Menge, um Duplikate zu entfernen, und sortiert dann die resultierende Menge eindeutiger Zahlen. Sie gibt ein Tupel zurück, das die Anzahl der eindeutigen Zahlen und eine Liste dieser eindeutigen Zahlen in aufsteigender Reihenfolge enthält.\n\nArgumente:\nnumbers (List[int]): Eine Liste von Ganzzahlen, die Duplikate enthalten kann.\n\nRückgabewerte:\nTuple[int, List[int]]: Ein Tupel mit zwei Elementen:\n- Eine Ganzzahl, die die Anzahl der eindeutigen Zahlen darstellt.\n- Eine Liste der eindeutigen Zahlen, sortiert in aufsteigender Reihenfolge.\n\nBeispiele:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "ha": "Cire lambobin maimaitawa daga jerin shigarwa kuma dawo da lambobin da ba su maimaita ba a tsararru.\n\nAikin yana fara canza jerin lambobin shigarwa zuwa saitin don cire duk wani maimaitawa, sannan yana tsara saitin lambobin da ba su maimaita ba. Yana dawowa da tubalan da ke dauke da adadin lambobin da ba su maimaita ba da kuma jerin wadannan lambobin da ba su maimaita ba a tsari mai hawa.\n\nArgs:\nnumbers (List[int]): Jerin lambobi, wanda zai iya dauke da maimaitawa.\n\nReturns:\nTuple[int, List[int]]: Tubalan da ke da abubuwa biyu:\n- Lamba mai nuna adadin lambobin da ba su maimaita ba.\n- Jerin lambobin da ba su maimaita ba a tsari mai hawa.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "hi": "इनपुट सूची से डुप्लिकेट पूर्णांकों को हटाएं और क्रमबद्ध अद्वितीय संख्याएँ लौटाएं।\n\nयह फ़ंक्शन पहले संख्याओं की इनपुट सूची को एक सेट में परिवर्तित करता है ताकि कोई भी डुप्लिकेट हट जाए,\nफिर अद्वितीय संख्याओं के परिणामी सेट को क्रमबद्ध करता है। यह एक ट्यूपल लौटाता है जिसमें अद्वितीय संख्याओं की गिनती\nऔर इन अद्वितीय संख्याओं की एक सूची आरोही क्रम में होती है।\n\nआर्ग्स:\nnumbers (List[int]): पूर्णांकों की एक सूची, जिसमें डुप्लिकेट हो सकते हैं।\n\nरिटर्न्स:\nTuple[int, List[int]]: एक ट्यूपल जिसमें दो तत्व होते हैं:\n- एक पूर्णांक जो अद्वितीय संख्याओं की गिनती का प्रतिनिधित्व करता है।\n- अद्वितीय संख्याओं की एक सूची जो आरोही क्रम में होती है।\n\nउदाहरण:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "hu": "Távolítsa el a duplikált egész számokat a bemeneti listából, és adja vissza a rendezett egyedi számokat.\n\nA függvény először a bemeneti számok listáját halmazzá alakítja, hogy eltávolítsa az esetleges duplikátumokat,\nmajd rendezi az így kapott egyedi számok halmazát. Visszaad egy tuple-t, amely tartalmazza az egyedi számok számát\nés az egyedi számok listáját növekvő sorrendben.\n\nArgs:\nnumbers (List[int]): Egy egész számokat tartalmazó lista, amely tartalmazhat duplikátumokat.\n\nReturns:\nTuple[int, List[int]]: Egy tuple két elemmel:\n- Egy egész szám, amely az egyedi számok számát jelöli.\n- Egy lista az egyedi számokról növekvő sorrendben.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "es": "Eliminar los enteros duplicados de la lista de entrada y devolver los números únicos ordenados.\n\nLa función primero convierte la lista de números de entrada en un conjunto para eliminar cualquier duplicado, luego ordena el conjunto resultante de números únicos. Devuelve una tupla que contiene el conteo de números únicos y una lista de estos números únicos en orden ascendente.\n\nArgumentos:\nnumbers (List[int]): Una lista de enteros, que puede contener duplicados.\n\nDevuelve:\nTuple[int, List[int]]: Una tupla con dos elementos:\n- Un entero que representa el conteo de números únicos.\n- Una lista de los números únicos ordenados en orden ascendente.\n\nEjemplos:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "arb": "إزالة الأعداد الصحيحة المكررة من قائمة المدخلات وإرجاع الأرقام الفريدة المرتبة.\n\nتقوم الدالة أولاً بتحويل قائمة الأرقام المدخلة إلى مجموعة لإزالة أي تكرارات، ثم تقوم بترتيب المجموعة الناتجة من الأرقام الفريدة. وتعيد دالة تحتوي على عدد الأرقام الفريدة وقائمة بهذه الأرقام الفريدة بترتيب تصاعدي.\n\nالمعطيات:\nnumbers (List[int]): قائمة من الأعداد الصحيحة، والتي قد تحتوي على تكرارات.\n\nالقيم المعادة:\nTuple[int, List[int]]: دالة تحتوي على عنصرين:\n- عدد صحيح يمثل عدد الأرقام الفريدة.\n- قائمة بالأرقام الفريدة مرتبة بترتيب تصاعدي.\n\nأمثلة:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "sw": "Ondoa namba za kurudiarudia kutoka kwenye orodha ya ingizo na rudisha namba za kipekee zilizopangwa.\n\nKazi hii kwanza inabadilisha orodha ya namba za ingizo kuwa seti ili kuondoa nakala zozote, kisha inapanga seti inayotokana na namba za kipekee. Inarudisha jozi inayojumuisha idadi ya namba za kipekee na orodha ya namba hizi za kipekee kwa mpangilio wa kupanda.\n\nHoja:\nnumbers (List[int]): Orodha ya namba za mzima, ambazo zinaweza kuwa na nakala.\n\nInarejesha:\nTuple[int, List[int]]: Jozi yenye vipengele viwili:\n- Namba ya mzima inayowakilisha idadi ya namba za kipekee.\n- Orodha ya namba za kipekee zilizopangwa kwa mpangilio wa kupanda.\n\nMifano:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "tr": "Girdi listesinden yinelenen tamsayıları kaldırın ve sıralanmış benzersiz sayıları döndürün.\n\nFonksiyon, önce girdi listesindeki sayıları bir kümeye dönüştürerek yinelenenleri kaldırır, ardından benzersiz sayıların bulunduğu kümeyi sıralar. Benzersiz sayıların sayısını ve bu benzersiz sayıların artan sırayla bulunduğu bir listeyi içeren bir demet döndürür.\n\nArgümanlar:\nnumbers (List[int]): Yinelenenleri içerebilecek bir tamsayı listesi.\n\nDöndürür:\nTuple[int, List[int]]: İki elemanlı bir demet:\n- Benzersiz sayıların sayısını temsil eden bir tamsayı.\n- Benzersiz sayıların artan sırayla sıralandığı bir liste.\n\nÖrnekler:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "vi": "Loại bỏ các số nguyên trùng lặp khỏi danh sách đầu vào và trả về các số duy nhất đã được sắp xếp.\n\nHàm này đầu tiên chuyển đổi danh sách số đầu vào thành một tập hợp để loại bỏ bất kỳ trùng lặp nào, sau đó sắp xếp tập hợp các số duy nhất kết quả. Nó trả về một bộ chứa số lượng các số duy nhất và một danh sách các số duy nhất này theo thứ tự tăng dần.\n\nTham số:\nnumbers (List[int]): Một danh sách các số nguyên, có thể chứa các phần tử trùng lặp.\n\nTrả về:\nTuple[int, List[int]]: Một bộ với hai phần tử:\n- Một số nguyên đại diện cho số lượng các số duy nhất.\n- Một danh sách các số duy nhất được sắp xếp theo thứ tự tăng dần.\n\nVí dụ:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "id": "Hapus bilangan bulat yang duplikat dari daftar masukan dan kembalikan angka unik yang telah diurutkan.\n\nFungsi ini pertama-tama mengubah daftar angka masukan menjadi sebuah set untuk menghapus duplikat,\nkemudian mengurutkan set angka unik yang dihasilkan. Fungsi ini mengembalikan sebuah tuple yang berisi jumlah\nangka unik dan daftar angka-angka unik ini dalam urutan menaik.\n\nArgs:\nnumbers (List[int]): Daftar bilangan bulat, yang mungkin mengandung duplikat.\n\nReturns:\nTuple[int, List[int]]: Sebuah tuple dengan dua elemen:\n- Sebuah bilangan bulat yang mewakili jumlah angka unik.\n- Sebuah daftar angka unik yang diurutkan dalam urutan menaik.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "ja": "入力リストから重複する整数を削除し、ソートされたユニークな数値を返します。\n\nこの関数は最初に、重複を削除するために入力された数値のリストをセットに変換し、\nその後、ユニークな数値のセットをソートします。ユニークな数値の数と、\n昇順にソートされたこれらのユニークな数値のリストを含むタプルを返します。\n\n引数:\nnumbers (List[int]): 重複を含む可能性のある整数のリスト。\n\n戻り値:\nTuple[int, List[int]]: 2つの要素を持つタプル:\n- ユニークな数値の数を表す整数。\n- 昇順にソートされたユニークな数値のリスト。\n\n例:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "ko": "입력 리스트에서 중복된 정수를 제거하고 정렬된 고유 숫자를 반환합니다.\n\n이 함수는 먼저 입력된 숫자 리스트를 집합으로 변환하여 중복을 제거한 후, 고유 숫자 집합을 정렬합니다. 그런 다음 고유 숫자의 개수와 오름차순으로 정렬된 이 고유 숫자들의 리스트를 포함하는 튜플을 반환합니다.\n\nArgs:\nnumbers (List[int]): 중복이 포함될 수 있는 정수 리스트.\n\nReturns:\nTuple[int, List[int]]: 두 개의 요소를 가진 튜플:\n- 고유 숫자의 개수를 나타내는 정수.\n- 오름차순으로 정렬된 고유 숫자들의 리스트.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "ml": "ഇൻപുട്ട് ലിസ്റ്റിൽ നിന്ന് പുനരാവൃത整数കളെ നീക്കം ചെയ്ത് ക്രമീകരിച്ച അനന്യ സംഖ്യകൾ മടക്കിനൽകുക.\n\nഫംഗ്ഷൻ ആദ്യം പുനരാവൃതങ്ങൾ നീക്കംചെയ്യാൻ സംഖ്യകളുടെ ഇൻപുട്ട് ലിസ്റ്റിനെ ഒരു സെറ്റാക്കി മാറ്റുന്നു, തുടർന്ന് അനന്യ സംഖ്യകളുടെ ഫലസമുച്ചയം ക്രമീകരിക്കുന്നു. അനന്യ സംഖ്യകളുടെ എണ്ണം ഉൾക്കൊള്ളുന്ന ഒരു ട്യൂപ്പിൾ, കൂടാതെ ഈ അനന്യ സംഖ്യകളുടെ ഒരു ലിസ്റ്റ് ഉയർന്ന ക്രമത്തിൽ മടക്കിനൽകുന്നു.\n\nആർഗുകൾ:\nnumbers (List[int]): പുനരാവൃതങ്ങൾ ഉൾക്കൊള്ളാവുന്ന ഒരു整数ങ്ങളുടെ ലിസ്റ്റ്.\n\nമടക്കിനൽകുന്നു:\nTuple[int, List[int]]: രണ്ട് ഘടകങ്ങളുള്ള ഒരു ട്യൂപ്പിൾ:\n- അനന്യ സംഖ്യകളുടെ എണ്ണത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു整数.\n- ഉയർന്ന ക്രമത്തിൽ ക്രമീകരിച്ച അനന്യ സംഖ്യകളുടെ ഒരു ലിസ്റ്റ്.\n\nഉദാഹരണങ്ങൾ:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "fa": "حذف اعداد تکراری از لیست ورودی و بازگرداندن اعداد یکتای مرتب‌شده.\n\nاین تابع ابتدا لیست ورودی اعداد را به یک مجموعه تبدیل می‌کند تا هرگونه تکرار را حذف کند،\nسپس مجموعه حاصل از اعداد یکتا را مرتب می‌کند. این تابع یک تاپل شامل تعداد\nاعداد یکتا و لیستی از این اعداد یکتا به ترتیب صعودی را بازمی‌گرداند.\n\nآرگومان‌ها:\nnumbers (List[int]): لیستی از اعداد صحیح که ممکن است شامل تکرار باشد.\n\nبازگشت:\nTuple[int, List[int]]: یک تاپل با دو عنصر:\n- یک عدد صحیح که نشان‌دهنده تعداد اعداد یکتا است.\n- لیستی از اعداد یکتا که به ترتیب صعودی مرتب شده‌اند.\n\nمثال‌ها:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])"}}
{"task_id": "Python/18", "prompt": {"en": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    The first example represents a budget of 1000 units with 5 items to choose from. The function \n    returns 3900, which is the maximum importance value sum achievable within the budget.\n    \n    The second example has a smaller budget of 50 units and 3 items. The function returns 80, \n    which is the maximum sum of importance values for the chosen items within the budget.\n    \"\"\"", "sq": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit vlerën maksimale totale të rëndësisë së artikujve që mund të blihen brenda një buxheti të caktuar.\n    \n    Kjo funksion zgjidh një variant të problemit të çantës 0-1 ku secili artikull ka një çmim dhe një \n    vlerë rëndësie të lidhur. Qëllimi është të maksimizohet shuma e vlerave të rëndësisë së një \n    përzgjedhjeje të artikujve pa e tejkaluar çmimin total buxhetin.\n    \n    Argumentet:\n    n (int): Buxheti total i disponueshëm për blerjen e artikujve.\n    m (int): Numri i artikujve të ndryshëm për të zgjedhur.\n    items (List[Tuple[int, int]]): Një listë tuplesh, ku secili tuple përmban dy numra të plotë:\n        - Numri i parë përfaqëson çmimin e artikullit.\n        - Numri i dytë përfaqëson vlerën e rëndësisë së artikullit.\n    \n    Kthen:\n    int: Vlera maksimale totale e rëndësisë që mund të arrihet pa e tejkaluar buxhetin.\n    \n    Shembuj:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Shembulli i parë përfaqëson një buxhet prej 1000 njësive me 5 artikuj për të zgjedhur. Funksioni \n    kthen 3900, që është shuma maksimale e vlerës së rëndësisë që arrihet brenda buxhetit.\n    \n    Shembulli i dytë ka një buxhet më të vogël prej 50 njësive dhe 3 artikuj. Funksioni kthen 80, \n    që është shuma maksimale e vlerave të rëndësisë për artikujt e zgjedhur brenda buxhetit.\n    \"\"\"", "hy": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվում է իրերի առավելագույն ընդհանուր կարևորության արժեքը, որոնք կարելի է գնել տրված բյուջեի սահմաններում:\n    \n    Այս ֆունկցիան լուծում է 0-1 պայուսակի խնդրի տարբերակը, որտեղ յուրաքանչյուր իր ունի գին և \n    կապված կարևորության արժեք: Նպատակն է առավելագույնացնել իրերի ընտրության կարևորության արժեքների \n    գումարը՝ առանց ընդհանուր գինը գերազանցելու բյուջեն:\n    \n    Արգումենտներ:\n    n (int): Ընդհանուր բյուջեն, որը հասանելի է իրեր գնելու համար:\n    m (int): Ընտրելու տարբեր իրերի քանակը:\n    items (List[Tuple[int, int]]): Կրկնապակետների ցուցակ, որտեղ յուրաքանչյուր կրկնապակետ պարունակում է երկու ամբողջ թիվ.\n        - Առաջին ամբողջ թիվը ներկայացնում է իրի գինը:\n        - Երկրորդ ամբողջ թիվը ներկայացնում է իրի կարևորության արժեքը:\n    \n    Վերադարձնում է:\n    int: Առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է հասնել առանց բյուջեն գերազանցելու:\n    \n    Օրինակներ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Առաջին օրինակը ներկայացնում է 1000 միավոր բյուջե 5 ընտրելու իրերով: Ֆունկցիան \n    վերադարձնում է 3900, որը առավելագույն կարևորության արժեքների գումարն է, որը կարելի է հասնել բյուջեի սահմաններում:\n    \n    Երկրորդ օրինակը ունի ավելի փոքր բյուջե՝ 50 միավոր և 3 իր: Ֆունկցիան վերադարձնում է 80, \n    որը առավելագույն կարևորության արժեքների գումարն է ընտրած իրերի համար բյուջեի սահմաններում:\n    \"\"\"", "bn": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    প্রদত্ত বাজেটের মধ্যে ক্রয় করা যেতে পারে এমন আইটেমগুলির সর্বাধিক মোট গুরুত্ব মান গণনা করে।\n    \n    এই ফাংশনটি 0-1 ন্যাপকস্যাক সমস্যার একটি প্রকরণ সমাধান করে যেখানে প্রতিটি আইটেমের একটি মূল্য এবং একটি \n    সংশ্লিষ্ট গুরুত্ব মান থাকে। লক্ষ্য হল এমন আইটেমগুলির একটি নির্বাচন থেকে গুরুত্ব মানগুলির যোগফল সর্বাধিক করা \n    যাতে মোট মূল্য বাজেট অতিক্রম না করে।\n    \n    Args:\n    n (int): আইটেম ক্রয়ের জন্য উপলব্ধ মোট বাজেট।\n    m (int): নির্বাচন করার জন্য বিভিন্ন আইটেমের সংখ্যা।\n    items (List[Tuple[int, int]]): একটি টাপল তালিকা, যেখানে প্রতিটি টাপলে দুটি পূর্ণসংখ্যা থাকে:\n        - প্রথম পূর্ণসংখ্যাটি আইটেমের মূল্য উপস্থাপন করে।\n        - দ্বিতীয় পূর্ণসংখ্যাটি আইটেমের গুরুত্ব মান উপস্থাপন করে।\n    \n    Returns:\n    int: বাজেট অতিক্রম না করে অর্জনযোগ্য সর্বাধিক মোট গুরুত্ব মান।\n    \n    উদাহরণ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    প্রথম উদাহরণটি 1000 ইউনিটের বাজেট এবং 5টি আইটেম নির্বাচন করার জন্য উপস্থাপন করে। ফাংশনটি \n    3900 ফেরত দেয়, যা বাজেটের মধ্যে অর্জনযোগ্য সর্বাধিক গুরুত্ব মানের যোগফল।\n    \n    দ্বিতীয় উদাহরণে 50 ইউনিটের একটি ছোট বাজেট এবং 3টি আইটেম রয়েছে। ফাংশনটি 80 ফেরত দেয়, \n    যা বাজেটের মধ্যে নির্বাচিত আইটেমগুলির জন্য সর্বাধিক গুরুত্ব মানের যোগফল।\n    \"\"\"", "bg": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислява максималната обща стойност на важност на предметите, които могат да бъдат закупени в рамките на даден бюджет.\n    \n    Тази функция решава вариант на проблема с раницата 0-1, където всеки предмет има цена и \n    свързана стойност на важност. Целта е да се максимизира сумата от стойностите на важност на \n    избраните предмети, без общата цена да надвишава бюджета.\n    \n    Аргументи:\n    n (int): Общият бюджет, наличен за закупуване на предмети.\n    m (int): Броят на различните предмети, от които може да се избира.\n    items (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа две цели числа:\n        - Първото число представлява цената на предмета.\n        - Второто число представлява стойността на важност на предмета.\n    \n    Връща:\n    int: Максималната обща стойност на важност, която може да бъде постигната без да се надвишава бюджета.\n    \n    Примери:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Първият пример представлява бюджет от 1000 единици с 5 предмета за избор. Функцията \n    връща 3900, което е максималната сума на стойностите на важност, постижима в рамките на бюджета.\n    \n    Вторият пример има по-малък бюджет от 50 единици и 3 предмета. Функцията връща 80, \n    което е максималната сума на стойностите на важност за избраните предмети в рамките на бюджета.\n    \"\"\"", "zh": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在给定预算内可以购买的物品的最大总重要性值。\n    \n    这个函数解决了0-1背包问题的一个变体，其中每个物品都有一个价格和一个相关的重要性值。目标是最大化所选物品的重要性值之和，同时总价格不超过预算。\n    \n    参数：\n    n (int): 可用于购买物品的总预算。\n    m (int): 可选择的不同物品的数量。\n    items (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数：\n        - 第一个整数表示物品的价格。\n        - 第二个整数表示物品的重要性值。\n    \n    返回：\n    int: 在不超过预算的情况下可以达到的最大总重要性值。\n    \n    示例：\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    第一个示例表示预算为1000单位，有5个物品可供选择。函数返回3900，这是在预算内可以实现的最大重要性值总和。\n    \n    第二个示例的预算较小，为50单位，有3个物品。函数返回80，这是在预算内选择的物品的重要性值的最大总和。\n    \"\"\"", "fr": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcule la valeur totale maximale d'importance des articles qui peuvent être achetés dans un budget donné.\n    \n    Cette fonction résout une variante du problème du sac à dos 0-1 où chaque article a un prix et une \n    valeur d'importance associée. L'objectif est de maximiser la somme des valeurs d'importance d'une \n    sélection d'articles sans que le prix total ne dépasse le budget.\n    \n    Args:\n    n (int): Le budget total disponible pour l'achat d'articles.\n    m (int): Le nombre d'articles différents parmi lesquels choisir.\n    items (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers :\n        - Le premier entier représente le prix de l'article.\n        - Le deuxième entier représente la valeur d'importance de l'article.\n    \n    Returns:\n    int: La valeur totale maximale d'importance qui peut être atteinte sans dépasser le budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Le premier exemple représente un budget de 1000 unités avec 5 articles parmi lesquels choisir. La fonction \n    renvoie 3900, ce qui est la somme maximale de valeurs d'importance réalisable dans le budget.\n    \n    Le deuxième exemple a un budget plus petit de 50 unités et 3 articles. La fonction renvoie 80, \n    ce qui est la somme maximale des valeurs d'importance pour les articles choisis dans le budget.\n    \"\"\"", "de": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechnet den maximalen Gesamtwert der Wichtigkeit von Gegenständen, die innerhalb eines gegebenen Budgets gekauft werden können.\n    \n    Diese Funktion löst eine Variante des 0-1 Rucksackproblems, bei dem jeder Gegenstand einen Preis und einen \n    zugehörigen Wichtigkeitswert hat. Das Ziel ist es, die Summe der Wichtigkeitswerte einer Auswahl von Gegenständen \n    zu maximieren, ohne dass der Gesamtpreis das Budget überschreitet.\n    \n    Args:\n    n (int): Das verfügbare Gesamtbudget für den Kauf von Gegenständen.\n    m (int): Die Anzahl der verschiedenen zur Auswahl stehenden Gegenstände.\n    items (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält:\n        - Die erste ganze Zahl repräsentiert den Preis des Gegenstands.\n        - Die zweite ganze Zahl repräsentiert den Wichtigkeitswert des Gegenstands.\n    \n    Returns:\n    int: Der maximale Gesamtwert der Wichtigkeit, der erreicht werden kann, ohne das Budget zu überschreiten.\n    \n    Beispiele:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Das erste Beispiel repräsentiert ein Budget von 1000 Einheiten mit 5 zur Auswahl stehenden Gegenständen. Die Funktion \n    gibt 3900 zurück, was die maximal erreichbare Summe der Wichtigkeitswerte innerhalb des Budgets ist.\n    \n    Das zweite Beispiel hat ein kleineres Budget von 50 Einheiten und 3 Gegenstände. Die Funktion gibt 80 zurück, \n    was die maximale Summe der Wichtigkeitswerte für die gewählten Gegenstände innerhalb des Budgets ist.\n    \"\"\"", "ha": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafa mafi girman jimillar darajar muhimmanci na abubuwan da za a iya saya cikin kasafin kudi da aka bayar.\n    \n    Wannan aikin yana warware wani bambanci na matsalar 0-1 knapsack inda kowane abu yana da farashi da \n    darajar muhimmanci da aka danganta. Manufar ita ce a kara yawan jimillar darajar muhimmanci na \n    zaɓin abubuwa ba tare da jimillar farashi ta wuce kasafin kudin ba.\n    \n    Args:\n    n (int): Jimillar kasafin kudi da ake da shi don siyan abubuwa.\n    m (int): Yawan abubuwa daban-daban da za a zaɓa daga.\n    items (List[Tuple[int, int]]): Jerin tuples, inda kowane tuple ya ƙunshi lambobi biyu:\n        - Na farko yana wakiltar farashin abu.\n        - Na biyu yana wakiltar darajar muhimmancin abu.\n    \n    Returns:\n    int: Mafi girman jimillar darajar muhimmanci da za a iya samu ba tare da wuce kasafin kudin ba.\n    \n    Misalai:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Misali na farko yana wakiltar kasafin kudi na raka'a 1000 tare da abubuwa 5 da za a zaɓa daga. Aikin \n    yana dawowa da 3900, wanda shine mafi girman jimillar darajar muhimmanci da za a iya samu cikin kasafin kudin.\n    \n    Misali na biyu yana da ƙaramin kasafin kudi na raka'a 50 da abubuwa 3. Aikin yana dawowa da 80, \n    wanda shine mafi girman jimillar darajar muhimmanci na abubuwan da aka zaɓa cikin kasafin kudin.\n    \"\"\"", "hi": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    उन वस्तुओं के अधिकतम कुल महत्व मान की गणना करता है जिन्हें दिए गए बजट के भीतर खरीदा जा सकता है।\n    \n    यह फ़ंक्शन 0-1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ प्रत्येक वस्तु की एक कीमत और एक \n    संबंधित महत्व मान होता है। लक्ष्य वस्तुओं के चयन के महत्व मानों के योग को अधिकतम करना है \n    बिना कुल कीमत बजट से अधिक हुए।\n    \n    Args:\n    n (int): वस्तुओं की खरीदारी के लिए उपलब्ध कुल बजट।\n    m (int): चुनने के लिए विभिन्न वस्तुओं की संख्या।\n    items (List[Tuple[int, int]]): टपल की एक सूची, जहाँ प्रत्येक टपल में दो पूर्णांक होते हैं:\n        - पहला पूर्णांक वस्तु की कीमत को दर्शाता है।\n        - दूसरा पूर्णांक वस्तु के महत्व मान को दर्शाता है।\n    \n    Returns:\n    int: अधिकतम कुल महत्व मान जो बजट से अधिक हुए बिना प्राप्त किया जा सकता है।\n    \n    उदाहरण:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    पहला उदाहरण 1000 इकाइयों के बजट का प्रतिनिधित्व करता है जिसमें 5 वस्तुओं को चुनने के लिए है। \n    फ़ंक्शन 3900 लौटाता है, जो बजट के भीतर प्राप्त करने योग्य अधिकतम महत्व मान योग है।\n    \n    दूसरा उदाहरण 50 इकाइयों के छोटे बजट और 3 वस्तुओं का है। फ़ंक्शन 80 लौटाता है, \n    जो बजट के भीतर चुनी गई वस्तुओं के महत्व मानों का अधिकतम योग है।\n    \"\"\"", "hu": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Kiszámítja a tárgyak maximális összesített fontossági értékét, amelyeket meg lehet vásárolni egy adott költségvetésen belül.\n    \n    Ez a függvény a 0-1 hátizsák probléma egy változatát oldja meg, ahol minden tárgynak van egy ára és egy \n    hozzá tartozó fontossági értéke. A cél az, hogy maximalizáljuk a kiválasztott tárgyak fontossági értékeinek \n    összegét úgy, hogy a teljes ár ne haladja meg a költségvetést.\n    \n    Args:\n    n (int): A tárgyak vásárlására rendelkezésre álló teljes költségvetés.\n    m (int): A választható különböző tárgyak száma.\n    items (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy kételemű tuple:\n        - Az első egész szám a tárgy árát jelöli.\n        - A második egész szám a tárgy fontossági értékét jelöli.\n    \n    Returns:\n    int: A maximális összesített fontossági érték, amely elérhető anélkül, hogy túllépnénk a költségvetést.\n    \n    Példák:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Az első példa egy 1000 egységnyi költségvetést képvisel, 5 választható tárggyal. A függvény \n    3900-at ad vissza, ami a költségvetésen belül elérhető maximális fontossági érték összeg.\n    \n    A második példa egy kisebb, 50 egységnyi költségvetéssel és 3 tárggyal rendelkezik. A függvény 80-at ad vissza, \n    ami a költségvetésen belül a kiválasztott tárgyak fontossági értékeinek maximális összege.\n    \"\"\"", "es": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcula el valor máximo total de importancia de los artículos que se pueden comprar dentro de un presupuesto dado.\n    \n    Esta función resuelve una variante del problema de la mochila 0-1 donde cada artículo tiene un precio y un \n    valor de importancia asociado. El objetivo es maximizar la suma de los valores de importancia de una \n    selección de artículos sin que el precio total exceda el presupuesto.\n    \n    Argumentos:\n    n (int): El presupuesto total disponible para la compra de artículos.\n    m (int): El número de diferentes artículos para elegir.\n    items (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros:\n        - El primer entero representa el precio del artículo.\n        - El segundo entero representa el valor de importancia del artículo.\n    \n    Devuelve:\n    int: El valor máximo total de importancia que se puede lograr sin exceder el presupuesto.\n    \n    Ejemplos:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    El primer ejemplo representa un presupuesto de 1000 unidades con 5 artículos para elegir. La función \n    devuelve 3900, que es la suma máxima de valores de importancia alcanzable dentro del presupuesto.\n    \n    El segundo ejemplo tiene un presupuesto más pequeño de 50 unidades y 3 artículos. La función devuelve 80, \n    que es la suma máxima de valores de importancia para los artículos elegidos dentro del presupuesto.\n    \"\"\"", "arb": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    يحسب أقصى قيمة إجمالية للأهمية يمكن تحقيقها من العناصر التي يمكن شراؤها ضمن ميزانية معينة.\n    \n    تحل هذه الدالة نوعًا من مشكلة حقيبة الظهر 0-1 حيث أن لكل عنصر سعر وقيمة أهمية مرتبطة به. \n    الهدف هو تعظيم مجموع قيم الأهمية لمجموعة من العناصر دون أن يتجاوز السعر الإجمالي الميزانية.\n    \n    يعيدالحجج:\n    n (int): الميزانية الإجمالية المتاحة لشراء العناصر.\n    m (int): عدد العناصر المختلفة للاختيار من بينها.\n    items (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين:\n        - العدد الأول يمثل سعر العنصر.\n        - العدد الثاني يمثل قيمة الأهمية للعنصر.\n    \n    يعيد:\n    int: أقصى قيمة إجمالية للأهمية يمكن تحقيقها دون تجاوز الميزانية.\n    \n    أمثلة:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    المثال الأول يمثل ميزانية قدرها 1000 وحدة مع 5 عناصر للاختيار منها. تعيد الدالة 3900، \n    وهو مجموع قيمة الأهمية القصوى الممكن تحقيقها ضمن الميزانية.\n    \n    المثال الثاني لديه ميزانية أصغر قدرها 50 وحدة و3 عناصر. تعيد الدالة 80، \n    وهو مجموع قيمة الأهمية القصوى للعناصر المختارة ضمن الميزانية.\n    \"\"\"", "sw": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Inahesabu thamani ya juu kabisa ya umuhimu wa jumla wa vitu vinavyoweza kununuliwa ndani ya bajeti iliyotolewa.\n    \n    Kazi hii inatatua aina ya tatizo la 0-1 knapsack ambapo kila kipengee kina bei na thamani ya umuhimu \n    inayohusishwa. Lengo ni kuongeza jumla ya thamani za umuhimu za uteuzi wa vitu bila bei ya jumla \n    kuzidi bajeti.\n    \n    Hoja:\n    n (int): Bajeti ya jumla inayopatikana kwa ajili ya kununua vitu.\n    m (int): Idadi ya vitu tofauti vya kuchagua.\n    items (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina nambari mbili:\n        - Nambari ya kwanza inawakilisha bei ya kipengee.\n        - Nambari ya pili inawakilisha thamani ya umuhimu wa kipengee.\n    \n    Inarejesha:\n    int: Thamani ya juu kabisa ya umuhimu inayoweza kupatikana bila kuzidi bajeti.\n    \n    Mifano:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Mfano wa kwanza unawakilisha bajeti ya vitengo 1000 na vitu 5 vya kuchagua. Kazi \n    inarudisha 3900, ambayo ni jumla ya juu kabisa ya thamani ya umuhimu inayoweza kupatikana ndani ya bajeti.\n    \n    Mfano wa pili una bajeti ndogo ya vitengo 50 na vitu 3. Kazi inarudisha 80, \n    ambayo ni jumla ya juu kabisa ya thamani za umuhimu kwa vitu vilivyochaguliwa ndani ya bajeti.\n    \"\"\"", "tr": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli bir bütçe dahilinde satın alınabilecek eşyaların maksimum toplam önem değerini hesaplar.\n    \n    Bu fonksiyon, her bir öğenin bir fiyatı ve ilişkili bir önem değeri olduğu 0-1 sırt çantası probleminin \n    bir varyantını çözer. Amaç, toplam fiyat bütçeyi aşmadan, bir öğe seçiminin önem değerlerinin toplamını \n    maksimize etmektir.\n    \n    Argümanlar:\n    n (int): Eşyaları satın almak için mevcut toplam bütçe.\n    m (int): Seçilecek farklı eşya sayısı.\n    items (List[Tuple[int, int]]): Her bir demetin iki tamsayı içerdiği demetlerin listesi:\n        - İlk tamsayı, eşyanın fiyatını temsil eder.\n        - İkinci tamsayı, eşyanın önem değerini temsil eder.\n    \n    Döndürür:\n    int: Bütçeyi aşmadan elde edilebilecek maksimum toplam önem değeri.\n    \n    Örnekler:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    İlk örnek, 5 eşya ile 1000 birimlik bir bütçeyi temsil eder. Fonksiyon, bütçe dahilinde \n    elde edilebilecek maksimum önem değeri toplamı olan 3900'ü döndürür.\n    \n    İkinci örnek, 50 birimlik daha küçük bir bütçeye ve 3 eşyaya sahiptir. Fonksiyon, bütçe dahilinde \n    seçilen eşyaların önem değerlerinin maksimum toplamı olan 80'i döndürür.\n    \"\"\"", "vi": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính toán tổng giá trị quan trọng tối đa của các mặt hàng có thể mua trong một ngân sách cho trước.\n    \n    Hàm này giải quyết một biến thể của bài toán cái túi 0-1, trong đó mỗi mặt hàng có một giá và một \n    giá trị quan trọng liên quan. Mục tiêu là tối đa hóa tổng giá trị quan trọng của một \n    lựa chọn các mặt hàng mà không để tổng giá vượt quá ngân sách.\n    \n    Tham số:\n    n (int): Tổng ngân sách có sẵn để mua các mặt hàng.\n    m (int): Số lượng các mặt hàng khác nhau để lựa chọn.\n    items (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên:\n        - Số nguyên đầu tiên đại diện cho giá của mặt hàng.\n        - Số nguyên thứ hai đại diện cho giá trị quan trọng của mặt hàng.\n    \n    Trả về:\n    int: Tổng giá trị quan trọng tối đa có thể đạt được mà không vượt quá ngân sách.\n    \n    Ví dụ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Ví dụ đầu tiên đại diện cho một ngân sách 1000 đơn vị với 5 mặt hàng để lựa chọn. Hàm \n    trả về 3900, là tổng giá trị quan trọng tối đa có thể đạt được trong ngân sách.\n    \n    Ví dụ thứ hai có ngân sách nhỏ hơn là 50 đơn vị và 3 mặt hàng. Hàm trả về 80, \n    là tổng giá trị quan trọng tối đa cho các mặt hàng được chọn trong ngân sách.\n    \"\"\"", "id": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Menghitung nilai total kepentingan maksimum dari barang-barang yang dapat dibeli dalam anggaran yang diberikan.\n    \n    Fungsi ini menyelesaikan varian dari masalah knapsack 0-1 di mana setiap barang memiliki harga dan \n    nilai kepentingan yang terkait. Tujuannya adalah untuk memaksimalkan jumlah nilai kepentingan dari \n    pilihan barang tanpa total harga melebihi anggaran.\n    \n    Args:\n    n (int): Total anggaran yang tersedia untuk membeli barang.\n    m (int): Jumlah barang berbeda yang dapat dipilih.\n    items (List[Tuple[int, int]]): Daftar tuple, di mana setiap tuple berisi dua bilangan bulat:\n        - Bilangan bulat pertama mewakili harga barang.\n        - Bilangan bulat kedua mewakili nilai kepentingan barang.\n    \n    Returns:\n    int: Nilai total kepentingan maksimum yang dapat dicapai tanpa melebihi anggaran.\n    \n    Contoh:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Contoh pertama mewakili anggaran sebesar 1000 unit dengan 5 barang yang dapat dipilih. Fungsi \n    mengembalikan 3900, yang merupakan jumlah nilai kepentingan maksimum yang dapat dicapai dalam anggaran.\n    \n    Contoh kedua memiliki anggaran lebih kecil sebesar 50 unit dan 3 barang. Fungsi mengembalikan 80, \n    yang merupakan jumlah maksimum nilai kepentingan untuk barang yang dipilih dalam anggaran.\n    \"\"\"", "ja": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    与えられた予算内で購入できるアイテムの最大合計重要度値を計算します。\n    \n    この関数は、各アイテムに価格と関連する重要度値がある0-1ナップサック問題の変種を解決します。目標は、\n    総価格が予算を超えないようにアイテムの重要度値の合計を最大化することです。\n    \n    引数:\n    n (int): アイテムを購入するために利用可能な総予算。\n    m (int): 選択できる異なるアイテムの数。\n    items (List[Tuple[int, int]]): 各タプルが2つの整数を含むタプルのリスト:\n        - 最初の整数はアイテムの価格を表します。\n        - 2番目の整数はアイテムの重要度値を表します。\n    \n    戻り値:\n    int: 予算を超えずに達成できる最大合計重要度値。\n    \n    例:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    最初の例は、5つのアイテムを選択できる1000単位の予算を表しています。関数は3900を返します。\n    これは、予算内で達成可能な最大の重要度値の合計です。\n    \n    2番目の例は、50単位の小さな予算と3つのアイテムを持っています。関数は80を返します。\n    これは、予算内で選択されたアイテムの重要度値の最大合計です。\n    \"\"\"", "ko": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    주어진 예산 내에서 구매할 수 있는 물품의 최대 총 중요도 값을 계산합니다.\n    \n    이 함수는 각 물품이 가격과 관련된 중요도 값을 가지는 0-1 배낭 문제의 변형을 해결합니다. \n    목표는 선택한 물품의 중요도 값의 합계를 최대화하는 것이며, 총 가격이 예산을 초과하지 않도록 해야 합니다.\n    \n    매개변수:\n    n (int): 물품 구매를 위한 총 예산.\n    m (int): 선택할 수 있는 다양한 물품의 수.\n    items (List[Tuple[int, int]]): 각 튜플이 두 개의 정수를 포함하는 튜플의 리스트:\n        - 첫 번째 정수는 물품의 가격을 나타냅니다.\n        - 두 번째 정수는 물품의 중요도 값을 나타냅니다.\n    \n    반환값:\n    int: 예산을 초과하지 않고 달성할 수 있는 최대 총 중요도 값.\n    \n    예시:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    첫 번째 예시는 1000 단위의 예산과 선택할 수 있는 5개의 물품을 나타냅니다. \n    함수는 예산 내에서 달성 가능한 최대 중요도 값의 합계인 3900을 반환합니다.\n    \n    두 번째 예시는 50 단위의 더 작은 예산과 3개의 물품을 가지고 있습니다. \n    함수는 예산 내에서 선택한 물품의 최대 중요도 값의 합계인 80을 반환합니다.\n    \"\"\"", "ml": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    നൽകിയിരിക്കുന്ന ബജറ്റിനുള്ളിൽ വാങ്ങാൻ കഴിയുന്ന വസ്തുക്കളുടെ പരമാവധി ആകെ പ്രാധാന്യ മൂല്യം കണക്കാക്കുന്നു.\n    \n    ഓരോ വസ്തുവിനും ഒരു വിലയും ബന്ധപ്പെട്ട പ്രാധാന്യ മൂല്യവും ഉള്ള 0-1 നാപ്സാക്ക് പ്രശ്നത്തിന്റെ ഒരു വകഭേദം ഈ ഫംഗ്ഷൻ പരിഹരിക്കുന്നു. \n    ആകെ വില ബജറ്റിനെ കടക്കാതെ വസ്തുക്കളുടെ ഒരു തിരഞ്ഞെടുപ്പിന്റെ പ്രാധാന്യ മൂല്യങ്ങളുടെ തുക പരമാവധി ആക്കുകയാണ് ലക്ഷ്യം.\n    \n    Args:\n    n (int): വസ്തുക്കൾ വാങ്ങുന്നതിനുള്ള മൊത്തം ലഭ്യമായ ബജറ്റ്.\n    m (int): തിരഞ്ഞെടുക്കാനുള്ള വ്യത്യസ്ത വസ്തുക്കളുടെ എണ്ണം.\n    items (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും രണ്ട് പൂർണ്ണസംഖ്യകൾ അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക:\n        - ആദ്യ പൂർണ്ണസംഖ്യ വസ്തുവിന്റെ വിലയെ പ്രതിനിധീകരിക്കുന്നു.\n        - രണ്ടാം പൂർണ്ണസംഖ്യ വസ്തുവിന്റെ പ്രാധാന്യ മൂല്യത്തെ പ്രതിനിധീകരിക്കുന്നു.\n    \n    Returns:\n    int: ബജറ്റിനെ കടക്കാതെ കൈവരിക്കാവുന്ന പരമാവധി ആകെ പ്രാധാന്യ മൂല്യം.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    ആദ്യ ഉദാഹരണം 5 വസ്തുക്കൾ തിരഞ്ഞെടുക്കാനുള്ള 1000 യൂണിറ്റുകളുടെ ബജറ്റിനെ പ്രതിനിധീകരിക്കുന്നു. \n    ഫംഗ്ഷൻ 3900 മടക്കുന്നു, ഇത് ബജറ്റിനുള്ളിൽ കൈവരിക്കാവുന്ന പരമാവധി പ്രാധാന്യ മൂല്യ തുകയാണ്.\n    \n    രണ്ടാം ഉദാഹരണം 50 യൂണിറ്റുകളുടെ ചെറിയ ബജറ്റും 3 വസ്തുക്കളും ഉണ്ട്. \n    ഫംഗ്ഷൻ 80 മടക്കുന്നു, ഇത് ബജറ്റിനുള്ളിൽ തിരഞ്ഞെടുക്കപ്പെട്ട വസ്തുക്കളുടെ പ്രാധാന്യ മൂല്യങ്ങളുടെ പരമാവധി തുകയാണ്.\n    \"\"\"", "fa": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    حداکثر مقدار کل اهمیت آیتم‌هایی را که می‌توان در یک بودجه معین خریداری کرد محاسبه می‌کند.\n    \n    این تابع یک نوع از مسئله کوله‌پشتی 0-1 را حل می‌کند که در آن هر آیتم دارای یک قیمت و یک \n    مقدار اهمیت مرتبط است. هدف این است که مجموع مقادیر اهمیت انتخابی از آیتم‌ها را بدون اینکه \n    مجموع قیمت‌ها از بودجه تجاوز کند، به حداکثر برسانیم.\n    \n    آرگومان‌ها:\n    n (int): کل بودجه موجود برای خرید آیتم‌ها.\n    m (int): تعداد آیتم‌های مختلف برای انتخاب.\n    items (List[Tuple[int, int]]): لیستی از زوج‌ها، که هر زوج شامل دو عدد صحیح است:\n        - عدد صحیح اول نمایانگر قیمت آیتم است.\n        - عدد صحیح دوم نمایانگر مقدار اهمیت آیتم است.\n    \n    بازگشت:\n    int: حداکثر مقدار کل اهمیت که می‌تواند بدون تجاوز از بودجه به دست آید.\n    \n    مثال‌ها:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    مثال اول نمایانگر بودجه‌ای به مقدار 1000 واحد با 5 آیتم برای انتخاب است. تابع \n    3900 را برمی‌گرداند، که حداکثر مجموع مقدار اهمیت قابل دستیابی در بودجه است.\n    \n    مثال دوم دارای بودجه کمتری به مقدار 50 واحد و 3 آیتم است. تابع 80 را برمی‌گرداند، \n    که حداکثر مجموع مقادیر اهمیت برای آیتم‌های انتخاب شده در بودجه است.\n    \"\"\""}, "canonical_solution": "# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]", "instruction": {"en": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nՏվեք Python կոդի կարճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত স্বাভাবিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nПредоставете кратко описание на Python кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben.", "es": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nPythonコードのdocstringを日本語で記述し、500文字以内で簡潔に説明してください。", "ko": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\n다음 Python 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_max_happiness():\n    # Test case 1: Sample provided in the problem\n    assert max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)]) == 3900, \"Test case 1 failed\"\n\n    # Test case 2: Small budget with one item\n    assert max_happiness(50, 1, [(60, 3)]) == 0, \"Test case 2 failed\"\n\n    # Test case 4: Exact budget\n    assert max_happiness(100, 2, [(50, 2), (50, 3)]) == 250, \"Test case 4 failed\"\n\n    # Test case 5: No items\n    assert max_happiness(100, 0, []) == 0, \"Test case 5 failed\"\n\n    # Test case 6: All items exceed the budget\n    assert max_happiness(10, 3, [(20, 1), (30, 2), (40, 3)]) == 0, \"Test case 6 failed\"\n\n    # Test case 7: Multiple items with the same price and importance\n    assert max_happiness(100, 4, [(25, 2), (25, 2), (25, 2), (25, 2)]) == 200, \"Test case 7 failed\"\n\n    # Test case 8: Large number of items\n    assert max_happiness(1000, 10, [(100, i) for i in range(1, 11)]) == 5500, \"Test case 8 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_max_happiness()", "entry_point": "max_happiness", "signature": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:", "docstring": {"en": "Calculates the maximum total importance value of items that can be bought within a given budget.\n\nThis function solves a variant of the 0-1 knapsack problem where each item has a price and an\nassociated importance value. The goal is to maximize the sum of the importance values of a\nselection of items without the total price exceeding the budget.\n\nArgs:\nn (int): The total budget available for purchasing items.\nm (int): The number of different items to choose from.\nitems (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n- The first integer represents the price of the item.\n- The second integer represents the importance value of the item.\n\nReturns:\nint: The maximum total importance value that can be achieved without exceeding the budget.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nThe first example represents a budget of 1000 units with 5 items to choose from. The function\nreturns 3900, which is the maximum importance value sum achievable within the budget.\n\nThe second example has a smaller budget of 50 units and 3 items. The function returns 80,\nwhich is the maximum sum of importance values for the chosen items within the budget.", "sq": "Llogarit vlerën maksimale totale të rëndësisë së artikujve që mund të blihen brenda një buxheti të caktuar.\n\nKjo funksion zgjidh një variant të problemit të çantës 0-1 ku secili artikull ka një çmim dhe një vlerë të lidhur rëndësie. Qëllimi është të maksimizohet shuma e vlerave të rëndësisë së një përzgjedhjeje të artikujve pa e tejkaluar çmimin total të buxhetit.\n\nArgs:\nn (int): Buxheti total i disponueshëm për blerjen e artikujve.\nm (int): Numri i artikujve të ndryshëm për të zgjedhur.\nitems (List[Tuple[int, int]]): Një listë tuplesh, ku secili tuple përmban dy numra të plotë:\n- Numri i parë përfaqëson çmimin e artikullit.\n- Numri i dytë përfaqëson vlerën e rëndësisë së artikullit.\n\nReturns:\nint: Vlera maksimale totale e rëndësisë që mund të arrihet pa e tejkaluar buxhetin.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nShembulli i parë përfaqëson një buxhet prej 1000 njësish me 5 artikuj për të zgjedhur. Funksioni kthen 3900, që është shuma maksimale e vlerës së rëndësisë që mund të arrihet brenda buxhetit.\n\nShembulli i dytë ka një buxhet më të vogël prej 50 njësish dhe 3 artikuj. Funksioni kthen 80, që është shuma maksimale e vlerave të rëndësisë për artikujt e zgjedhur brenda buxhetit.", "hy": "Հաշվում է առարկաների առավելագույն ընդհանուր կարևորության արժեքը, որոնք կարելի է գնել տրված բյուջեի սահմաններում:\n\nԱյս ֆունկցիան լուծում է 0-1 դարակաշարային խնդրի տարբերակը, որտեղ յուրաքանչյուր առարկա ունի գին և\nկապակցված կարևորության արժեք: Նպատակն է առավելագույնացնել առարկաների ընտրության կարևորության արժեքների գումարը՝ առանց ընդհանուր գինը գերազանցելու բյուջեն:\n\nԱրձագանքներ:\nn (int): Ընդհանուր բյուջեն, որը հասանելի է առարկաներ գնելու համար:\nm (int): Ընտրելու համար տարբեր առարկաների քանակը:\nitems (List[Tuple[int, int]]): Ցանկ, որը պարունակում է զույգերի ցանկ, որտեղ յուրաքանչյուր զույգ պարունակում է երկու ամբողջ թիվ:\n- Առաջին ամբողջ թիվը ներկայացնում է առարկայի գինը:\n- Երկրորդ ամբողջ թիվը ներկայացնում է առարկայի կարևորության արժեքը:\n\nՎերադարձնում է:\nint: Առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է հասնել առանց բյուջեն գերազանցելու:\n\nՕրինակներ:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nԱռաջին օրինակը ներկայացնում է 1000 միավոր բյուջե 5 ընտրելու առարկաներով: Ֆունկցիան վերադարձնում է 3900, որը առավելագույն կարևորության արժեքի գումարն է, որը կարելի է հասնել բյուջեի սահմաններում:\n\nԵրկրորդ օրինակը ունի 50 միավոր փոքր բյուջե և 3 առարկա: Ֆունկցիան վերադարձնում է 80, որը առավելագույն կարևորության արժեքների գումարն է ընտրված առարկաների համար բյուջեի սահմաններում:", "bn": "দেওয়া বাজেটের মধ্যে কেনাকাটা করা যেতে পারে এমন আইটেমগুলির সর্বাধিক মোট গুরুত্ব মান গণনা করে।\n\nএই ফাংশনটি 0-1 ন্যাপকস্যাক সমস্যার একটি বৈকল্পিক সমাধান করে যেখানে প্রতিটি আইটেমের একটি মূল্য এবং একটি সংশ্লিষ্ট গুরুত্ব মান থাকে। লক্ষ্য হল, বাজেট অতিক্রম না করে আইটেমগুলির একটি নির্বাচনের গুরুত্ব মানগুলির যোগফল সর্বাধিক করা।\n\nআর্গস:\nn (int): আইটেম কেনার জন্য উপলব্ধ মোট বাজেট।\nm (int): নির্বাচন করার জন্য বিভিন্ন আইটেমের সংখ্যা।\nitems (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে:\n- প্রথম পূর্ণসংখ্যাটি আইটেমের মূল্য উপস্থাপন করে।\n- দ্বিতীয় পূর্ণসংখ্যাটি আইটেমের গুরুত্ব মান উপস্থাপন করে।\n\nরিটার্নস:\nint: সর্বাধিক মোট গুরুত্ব মান যা বাজেট অতিক্রম না করেই অর্জন করা যেতে পারে।\n\nউদাহরণ:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nপ্রথম উদাহরণটি 1000 ইউনিটের বাজেট এবং 5টি আইটেমের নির্বাচনকে উপস্থাপন করে। ফাংশনটি 3900 ফেরত দেয়, যা বাজেটের মধ্যে অর্জনযোগ্য সর্বাধিক গুরুত্ব মানের যোগফল।\n\nদ্বিতীয় উদাহরণে 50 ইউনিটের একটি ছোট বাজেট এবং 3টি আইটেম রয়েছে। ফাংশনটি 80 ফেরত দেয়, যা বাজেটের মধ্যে নির্বাচিত আইটেমগুলির জন্য সর্বাধিক গুরুত্ব মানের যোগফল।", "bg": "Изчислява максималната обща стойност на важността на предметите, които могат да бъдат закупени в рамките на даден бюджет.\n\nТази функция решава вариант на проблема с раницата 0-1, където всеки предмет има цена и свързана стойност на важността. Целта е да се максимизира сумата на стойностите на важността на избраните предмети, без общата цена да надвишава бюджета.\n\nArgs:\nn (int): Общият бюджет, наличен за закупуване на предмети.\nm (int): Броят на различните предмети, от които може да се избира.\nitems (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа два цели числа:\n- Първото цяло число представлява цената на предмета.\n- Второто цяло число представлява стойността на важността на предмета.\n\nReturns:\nint: Максималната обща стойност на важността, която може да бъде постигната, без да се надвишава бюджетът.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nПървият пример представлява бюджет от 1000 единици с 5 предмета, от които може да се избира. Функцията връща 3900, което е максималната сума на стойностите на важността, постижима в рамките на бюджета.\n\nВторият пример има по-малък бюджет от 50 единици и 3 предмета. Функцията връща 80, което е максималната сума на стойностите на важността за избраните предмети в рамките на бюджета.", "zh": "计算在给定预算内可以购买的物品的最大总重要性值。\n\n此函数解决了一种0-1背包问题的变体，其中每个物品都有一个价格和一个相关的重要性值。目标是在不超过预算的情况下，最大化所选物品的重要性值之和。\n\n参数：\nn (int): 可用于购买物品的总预算。\nm (int): 可选择的不同物品数量。\nitems (List[Tuple[int, int]]): 一个元组列表，每个元组包含两个整数：\n- 第一个整数表示物品的价格。\n- 第二个整数表示物品的重要性值。\n\n返回：\nint: 在不超过预算的情况下可以达到的最大总重要性值。\n\n示例：\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\n第一个示例表示预算为1000单位，有5个物品可供选择。函数返回3900，这是在预算内可以实现的最大重要性值之和。\n\n第二个示例预算较小，为50单位，有3个物品。函数返回80，这是在预算内所选物品的重要性值的最大和。", "fr": "Calcule la valeur d'importance totale maximale des articles pouvant être achetés dans un budget donné.\n\nCette fonction résout une variante du problème du sac à dos 0-1 où chaque article a un prix et une\nvaleur d'importance associée. L'objectif est de maximiser la somme des valeurs d'importance d'une\nsélection d'articles sans que le prix total ne dépasse le budget.\n\nArgs:\nn (int): Le budget total disponible pour l'achat d'articles.\nm (int): Le nombre d'articles différents parmi lesquels choisir.\nitems (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers :\n- Le premier entier représente le prix de l'article.\n- Le deuxième entier représente la valeur d'importance de l'article.\n\nReturns:\nint: La valeur d'importance totale maximale pouvant être atteinte sans dépasser le budget.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nLe premier exemple représente un budget de 1000 unités avec 5 articles parmi lesquels choisir. La fonction\nrenvoie 3900, qui est la somme maximale des valeurs d'importance atteignable dans le budget.\n\nLe deuxième exemple a un budget plus petit de 50 unités et 3 articles. La fonction renvoie 80,\nqui est la somme maximale des valeurs d'importance pour les articles choisis dans le budget.", "de": "Berechnet den maximalen Gesamtwert der Wichtigkeit von Gegenständen, die innerhalb eines gegebenen Budgets gekauft werden können.\n\nDiese Funktion löst eine Variante des 0-1-Rucksackproblems, bei dem jeder Gegenstand einen Preis und einen zugehörigen Wichtigkeitswert hat. Das Ziel ist es, die Summe der Wichtigkeitswerte einer Auswahl von Gegenständen zu maximieren, ohne dass der Gesamtpreis das Budget überschreitet.\n\nArgs:\nn (int): Das insgesamt verfügbare Budget für den Kauf von Gegenständen.\nm (int): Die Anzahl der verschiedenen zur Auswahl stehenden Gegenstände.\nitems (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält:\n- Die erste ganze Zahl repräsentiert den Preis des Gegenstands.\n- Die zweite ganze Zahl repräsentiert den Wichtigkeitswert des Gegenstands.\n\nReturns:\nint: Der maximale Gesamtwert der Wichtigkeit, der erreicht werden kann, ohne das Budget zu überschreiten.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nDas erste Beispiel repräsentiert ein Budget von 1000 Einheiten mit 5 zur Auswahl stehenden Gegenständen. Die Funktion gibt 3900 zurück, was die maximale Summe der Wichtigkeitswerte ist, die innerhalb des Budgets erreicht werden kann.\n\nDas zweite Beispiel hat ein kleineres Budget von 50 Einheiten und 3 Gegenstände. Die Funktion gibt 80 zurück, was die maximale Summe der Wichtigkeitswerte für die innerhalb des Budgets ausgewählten Gegenstände ist.", "ha": "Yana ƙididdige matsakaicin jimillar ƙimar muhimmanci na abubuwan da za a iya saya a cikin kasafin kuɗi da aka bayar.\n\nWannan aikin yana warware bambancin matsalar jakar 0-1 inda kowanne abu yana da farashi da kuma\nƙimar muhimmanci da aka haɗa. Manufar ita ce a ƙara yawan jimillar ƙimar muhimmancin zaɓi na abubuwa ba tare da farashin jimlar ya wuce kasafin kuɗi ba.\n\nArgs:\nn (int): Jimillar kasafin kuɗi da ake da shi don siyan abubuwa.\nm (int): Yawan abubuwa daban-daban da za a zaɓa daga.\nitems (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple yana ɗauke da lambobi guda biyu:\n- Lamba ta farko tana wakiltar farashin abu.\n- Lamba ta biyu tana wakiltar ƙimar muhimmancin abu.\n\nReturns:\nint: Matsakaicin jimillar ƙimar muhimmanci da za a iya samu ba tare da wuce kasafin kuɗi ba.\n\nMisalai:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nMisali na farko yana wakiltar kasafin kuɗi na raka'a 1000 tare da abubuwa 5 da za a zaɓa daga. Aikin yana dawowa 3900, wanda shine matsakaicin jimillar ƙimar muhimmanci da za a iya samu a cikin kasafin kuɗi.\n\nMisali na biyu yana da ƙaramin kasafin kuɗi na raka'a 50 da abubuwa 3. Aikin yana dawowa 80, wanda shine matsakaicin jimillar ƙimar muhimmanci na abubuwan da aka zaɓa a cikin kasafin kuɗi.", "hi": "दी गई बजट के भीतर खरीदे जा सकने वाले वस्तुओं के अधिकतम कुल महत्व मान की गणना करता है।\n\nयह फ़ंक्शन 0-1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ प्रत्येक वस्तु की एक कीमत और एक संबंधित महत्व मान होता है। लक्ष्य यह है कि वस्तुओं के चयन के महत्व मानों के योग को अधिकतम किया जाए बिना कुल कीमत बजट से अधिक हुए।\n\nआर्ग्स:\nn (int): वस्तुओं की खरीदारी के लिए उपलब्ध कुल बजट।\nm (int): चुनने के लिए विभिन्न वस्तुओं की संख्या।\nitems (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं:\n- पहला पूर्णांक वस्तु की कीमत को दर्शाता है।\n- दूसरा पूर्णांक वस्तु के महत्व मान को दर्शाता है।\n\nरिटर्न्स:\nint: अधिकतम कुल महत्व मान जो बजट से अधिक हुए बिना प्राप्त किया जा सकता है।\n\nउदाहरण:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nपहला उदाहरण 1000 इकाइयों के बजट का प्रतिनिधित्व करता है जिसमें 5 वस्तुओं को चुनने के लिए है। फ़ंक्शन 3900 लौटाता है, जो बजट के भीतर प्राप्त किया जा सकने वाला अधिकतम महत्व मान योग है।\n\nदूसरे उदाहरण में 50 इकाइयों का छोटा बजट और 3 वस्तुएं हैं। फ़ंक्शन 80 लौटाता है, जो बजट के भीतर चुनी गई वस्तुओं के महत्व मानों का अधिकतम योग है।", "hu": "Kiszámítja a megvásárolható tárgyak maximális összesített fontossági értékét egy adott költségvetésen belül.\n\nEz a függvény a 0-1 hátizsák probléma egy változatát oldja meg, ahol minden tárgynak van egy ára és egy hozzá tartozó fontossági értéke. A cél az, hogy maximalizáljuk a kiválasztott tárgyak fontossági értékeinek összegét anélkül, hogy a teljes ár meghaladná a költségvetést.\n\nArgs:\nn (int): Az összes rendelkezésre álló költségvetés a tárgyak megvásárlására.\nm (int): A választható különböző tárgyak száma.\nitems (List[Tuple[int, int]]): Egy listája a tuple-öknek, ahol minden tuple két egész számot tartalmaz:\n- Az első egész szám a tárgy árát jelenti.\n- A második egész szám a tárgy fontossági értékét jelenti.\n\nReturns:\nint: A maximális összesített fontossági érték, amely elérhető anélkül, hogy meghaladná a költségvetést.\n\nPéldák:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nAz első példa egy 1000 egységnyi költségvetést képvisel 5 választható tárggyal. A függvény 3900-at ad vissza, ami a költségvetésen belül elérhető maximális fontossági érték összeg.\n\nA második példa egy kisebb, 50 egységnyi költségvetéssel és 3 tárggyal rendelkezik. A függvény 80-at ad vissza, ami a költségvetésen belül a kiválasztott tárgyak maximális fontossági értékének összege.", "es": "Calcula el valor máximo total de importancia de los artículos que se pueden comprar dentro de un presupuesto dado.\n\nEsta función resuelve una variante del problema de la mochila 0-1 donde cada artículo tiene un precio y un valor de importancia asociado. El objetivo es maximizar la suma de los valores de importancia de una selección de artículos sin que el precio total exceda el presupuesto.\n\nArgumentos:\nn (int): El presupuesto total disponible para la compra de artículos.\nm (int): El número de diferentes artículos para elegir.\nitems (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros:\n- El primer entero representa el precio del artículo.\n- El segundo entero representa el valor de importancia del artículo.\n\nDevuelve:\nint: El valor máximo total de importancia que se puede lograr sin exceder el presupuesto.\n\nEjemplos:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nEl primer ejemplo representa un presupuesto de 1000 unidades con 5 artículos para elegir. La función devuelve 3900, que es la suma máxima de valores de importancia alcanzable dentro del presupuesto.\n\nEl segundo ejemplo tiene un presupuesto más pequeño de 50 unidades y 3 artículos. La función devuelve 80, que es la suma máxima de valores de importancia para los artículos elegidos dentro del presupuesto.", "arb": "يحسب القيمة القصوى لإجمالي الأهمية للعناصر التي يمكن شراؤها ضمن ميزانية معينة.\n\nتحل هذه الدالة نوعًا من مشكلة الحقيبة 0-1 حيث أن لكل عنصر سعر وقيمة أهمية مرتبطة به. الهدف هو تعظيم مجموع قيم الأهمية لمجموعة مختارة من العناصر دون أن يتجاوز السعر الإجمالي الميزانية.\n\nالمعطيات:\nn (int): الميزانية الإجمالية المتاحة لشراء العناصر.\nm (int): عدد العناصر المختلفة للاختيار من بينها.\nitems (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين:\n- العدد الأول يمثل سعر العنصر.\n- العدد الثاني يمثل قيمة الأهمية للعنصر.\n\nالقيم المعادة:\nint: القيمة القصوى لإجمالي الأهمية التي يمكن تحقيقها دون تجاوز الميزانية.\n\nأمثلة:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nيمثل المثال الأول ميزانية قدرها 1000 وحدة مع 5 عناصر للاختيار من بينها. تعيد الدالة 3900، وهي مجموع قيمة الأهمية القصوى التي يمكن تحقيقها ضمن الميزانية.\n\nالمثال الثاني لديه ميزانية أصغر قدرها 50 وحدة و3 عناصر. تعيد الدالة 80، وهي مجموع قيمة الأهمية القصوى للعناصر المختارة ضمن الميزانية.", "sw": "Inakokotoa thamani ya juu kabisa ya umuhimu wa jumla wa vitu vinavyoweza kununuliwa ndani ya bajeti iliyotolewa.\n\nKazi hii inatatua aina ya tatizo la 0-1 knapsack ambapo kila kipengee kina bei na thamani ya umuhimu inayohusiana. Lengo ni kuongeza jumla ya thamani za umuhimu wa uteuzi wa vitu bila bei ya jumla kuzidi bajeti.\n\nHoja:\nn (int): Bajeti ya jumla inayopatikana kwa ajili ya kununua vitu.\nm (int): Idadi ya vitu tofauti vya kuchagua.\nitems (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina nambari mbili:\n- Nambari ya kwanza inawakilisha bei ya kipengee.\n- Nambari ya pili inawakilisha thamani ya umuhimu wa kipengee.\n\nInarejesha:\nint: Thamani ya juu kabisa ya umuhimu wa jumla inayoweza kupatikana bila kuzidi bajeti.\n\nMifano:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nMfano wa kwanza unawakilisha bajeti ya vitengo 1000 na vitu 5 vya kuchagua. Kazi inarudisha 3900, ambayo ni jumla ya juu kabisa ya thamani za umuhimu inayoweza kupatikana ndani ya bajeti.\n\nMfano wa pili una bajeti ndogo ya vitengo 50 na vitu 3. Kazi inarudisha 80, ambayo ni jumla ya juu kabisa ya thamani za umuhimu kwa vitu vilivyochaguliwa ndani ya bajeti.", "tr": "Eşyaların belirli bir bütçe dahilinde satın alınabileceği maksimum toplam önem değerini hesaplar.\n\nBu fonksiyon, her bir öğenin bir fiyatı ve ilişkili bir önem değeri olan 0-1 knapsack probleminin bir varyantını çözer. Amaç, toplam fiyat bütçeyi aşmadan, seçilen öğelerin önem değerlerinin toplamını maksimize etmektir.\n\nArgümanlar:\nn (int): Eşyaları satın almak için mevcut toplam bütçe.\nm (int): Seçilebilecek farklı eşya sayısı.\nitems (List[Tuple[int, int]]): Her bir demetin iki tam sayı içerdiği demetlerin listesi:\n- İlk tam sayı, eşyanın fiyatını temsil eder.\n- İkinci tam sayı, eşyanın önem değerini temsil eder.\n\nDöndürür:\nint: Bütçeyi aşmadan elde edilebilecek maksimum toplam önem değeri.\n\nÖrnekler:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nİlk örnek, 1000 birimlik bir bütçeyi ve seçilebilecek 5 öğeyi temsil eder. Fonksiyon, bütçe dahilinde elde edilebilecek maksimum önem değeri toplamı olan 3900'ü döndürür.\n\nİkinci örnek, 50 birimlik daha küçük bir bütçe ve 3 öğe içerir. Fonksiyon, bütçe dahilinde seçilen öğeler için maksimum önem değerleri toplamı olan 80'i döndürür.", "vi": "Tính tổng giá trị quan trọng tối đa của các mặt hàng có thể mua trong một ngân sách cho trước.\n\nHàm này giải quyết một biến thể của bài toán ba lô 0-1, trong đó mỗi mặt hàng có một giá và một giá trị quan trọng liên quan. Mục tiêu là tối đa hóa tổng giá trị quan trọng của một lựa chọn các mặt hàng mà không để tổng giá vượt quá ngân sách.\n\nTham số:\nn (int): Tổng ngân sách có sẵn để mua các mặt hàng.\nm (int): Số lượng mặt hàng khác nhau để lựa chọn.\nitems (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên:\n- Số nguyên đầu tiên đại diện cho giá của mặt hàng.\n- Số nguyên thứ hai đại diện cho giá trị quan trọng của mặt hàng.\n\nTrả về:\nint: Tổng giá trị quan trọng tối đa có thể đạt được mà không vượt quá ngân sách.\n\nVí dụ:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nVí dụ đầu tiên đại diện cho một ngân sách 1000 đơn vị với 5 mặt hàng để lựa chọn. Hàm trả về 3900, là tổng giá trị quan trọng tối đa có thể đạt được trong ngân sách.\n\nVí dụ thứ hai có ngân sách nhỏ hơn là 50 đơn vị và 3 mặt hàng. Hàm trả về 80, là tổng giá trị quan trọng tối đa cho các mặt hàng được chọn trong ngân sách.", "id": "Menghitung nilai total maksimum dari kepentingan barang-barang yang dapat dibeli dalam anggaran yang diberikan.\n\nFungsi ini menyelesaikan varian dari masalah knapsack 0-1 di mana setiap barang memiliki harga dan nilai kepentingan yang terkait. Tujuannya adalah untuk memaksimalkan jumlah nilai kepentingan dari pilihan barang-barang tanpa total harga melebihi anggaran.\n\nArgs:\nn (int): Total anggaran yang tersedia untuk membeli barang-barang.\nm (int): Jumlah barang berbeda yang dapat dipilih.\nitems (List[Tuple[int, int]]): Daftar tuple, di mana setiap tuple berisi dua bilangan bulat:\n- Bilangan bulat pertama mewakili harga barang.\n- Bilangan bulat kedua mewakili nilai kepentingan barang.\n\nReturns:\nint: Nilai total maksimum dari kepentingan yang dapat dicapai tanpa melebihi anggaran.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nContoh pertama mewakili anggaran sebesar 1000 unit dengan 5 barang untuk dipilih. Fungsi mengembalikan 3900, yang merupakan jumlah nilai kepentingan maksimum yang dapat dicapai dalam anggaran tersebut.\n\nContoh kedua memiliki anggaran yang lebih kecil sebesar 50 unit dan 3 barang. Fungsi mengembalikan 80, yang merupakan jumlah maksimum dari nilai kepentingan untuk barang-barang yang dipilih dalam anggaran tersebut.", "ja": "与えられた予算内で購入できるアイテムの最大合計重要度値を計算します。\n\nこの関数は、各アイテムに価格と関連する重要度値がある0-1ナップサック問題の変種を解きます。目標は、総価格が予算を超えないようにしながら、アイテムの選択の重要度値の合計を最大化することです。\n\nArgs:\nn (int): アイテム購入のために利用可能な総予算。\nm (int): 選択可能な異なるアイテムの数。\nitems (List[Tuple[int, int]]): タプルのリストで、各タプルは2つの整数を含みます:\n- 最初の整数はアイテムの価格を表します。\n- 2番目の整数はアイテムの重要度値を表します。\n\nReturns:\nint: 予算を超えずに達成できる最大合計重要度値。\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\n最初の例は、5つのアイテムを選択できる1000単位の予算を表しています。関数は3900を返し、これは予算内で達成可能な最大の重要度値の合計です。\n\n2番目の例は、50単位の小さな予算と3つのアイテムがあります。関数は80を返し、これは予算内で選択されたアイテムの重要度値の最大合計です。", "ko": "주어진 예산 내에서 구매할 수 있는 항목의 최대 총 중요도 값을 계산합니다.\n\n이 함수는 각 항목에 가격과 관련된 중요도 값이 있는 0-1 배낭 문제의 변형을 해결합니다. 목표는 총 가격이 예산을 초과하지 않도록 하면서 항목 선택의 중요도 값 합계를 최대화하는 것입니다.\n\nArgs:\nn (int): 항목 구매에 사용할 수 있는 총 예산.\nm (int): 선택할 수 있는 다양한 항목의 수.\nitems (List[Tuple[int, int]]): 각 튜플이 두 개의 정수를 포함하는 튜플 목록:\n- 첫 번째 정수는 항목의 가격을 나타냅니다.\n- 두 번째 정수는 항목의 중요도 값을 나타냅니다.\n\nReturns:\nint: 예산을 초과하지 않고 달성할 수 있는 최대 총 중요도 값.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\n첫 번째 예는 5개의 항목을 선택할 수 있는 1000 단위의 예산을 나타냅니다. 함수는 예산 내에서 달성할 수 있는 최대 중요도 값 합계인 3900을 반환합니다.\n\n두 번째 예는 50 단위의 더 작은 예산과 3개의 항목을 가지고 있습니다. 함수는 예산 내에서 선택한 항목의 중요도 값의 최대 합계인 80을 반환합니다.", "ml": "വ്യവസ്ഥിതമായ ബജറ്റിനുള്ളിൽ വാങ്ങാൻ കഴിയുന്ന വസ്തുക്കളുടെ പരമാവധി ആകെ പ്രാധാന്യ മൂല്യം കണക്കാക്കുന്നു.\n\nഓരോ വസ്തുവിനും വിലയും അനുബന്ധമായ പ്രാധാന്യ മൂല്യവും ഉള്ള 0-1 ക്നാപ്സാക്ക് പ്രശ്നത്തിന്റെ വ്യത്യസ്ത രൂപം ഈ ഫംഗ്ഷൻ പരിഹരിക്കുന്നു. ബജറ്റ് കവിയാതെ വസ്തുക്കളുടെ തിരഞ്ഞെടുപ്പിന്റെ പ്രാധാന്യ മൂല്യങ്ങളുടെ ആകെ തുക പരമാവധി ആക്കുക എന്നതാണ് ലക്ഷ്യം.\n\nആർഗുകൾ:\nn (int): വസ്തുക്കൾ വാങ്ങുന്നതിനുള്ള മൊത്തം ലഭ്യമായ ബജറ്റ്.\nm (int): തിരഞ്ഞെടുക്കാൻ ഉള്ള വ്യത്യസ്ത വസ്തുക്കളുടെ എണ്ണം.\nitems (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളിലും രണ്ട് പൂർണ്ണസംഖ്യകൾ അടങ്ങിയ ട്യൂപ്പിളുകളുടെ പട്ടിക:\n- ആദ്യ പൂർണ്ണസംഖ്യ വസ്തുവിന്റെ വിലയെ പ്രതിനിധീകരിക്കുന്നു.\n- രണ്ടാം പൂർണ്ണസംഖ്യ വസ്തുവിന്റെ പ്രാധാന്യ മൂല്യത്തെ പ്രതിനിധീകരിക്കുന്നു.\n\nമടക്കം:\nint: ബജറ്റ് കവിയാതെ നേടാൻ കഴിയുന്ന പരമാവധി ആകെ പ്രാധാന്യ മൂല്യം.\n\nഉദാഹരണങ്ങൾ:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nആദ്യ ഉദാഹരണം 1000 യൂണിറ്റുകളുടെ ബജറ്റും 5 വസ്തുക്കളും തിരഞ്ഞെടുക്കാൻ ഉള്ളതും പ്രതിനിധീകരിക്കുന്നു. ഫംഗ്ഷൻ 3900 മടക്കുന്നു, ഇത് ബജറ്റിനുള്ളിൽ നേടാൻ കഴിയുന്ന പരമാവധി പ്രാധാന്യ മൂല്യ തുകയാണ്.\n\nരണ്ടാമത്തെ ഉദാഹരണത്തിൽ 50 യൂണിറ്റുകളുടെ ചെറിയ ബജറ്റും 3 വസ്തുക്കളും ഉണ്ട്. ഫംഗ്ഷൻ 80 മടക്കുന്നു, ഇത് ബജറ്റിനുള്ളിൽ തിരഞ്ഞെടുക്കപ്പെട്ട വസ്തുക്കളുടെ പ്രാധാന്യ മൂല്യങ്ങളുടെ പരമാവധി തുകയാണ്.", "fa": "محاسبه حداکثر مقدار کل اهمیت اقلامی که می‌توان با بودجه مشخص خریداری کرد.\n\nاین تابع یک نوع از مسئله کوله‌پشتی 0-1 را حل می‌کند که در آن هر آیتم دارای یک قیمت و یک مقدار اهمیت مرتبط است. هدف این است که مجموع مقادیر اهمیت انتخابی از آیتم‌ها را حداکثر کنیم بدون اینکه مجموع قیمت از بودجه تجاوز کند.\n\nآرگومان‌ها:\nn (int): بودجه کل موجود برای خرید اقلام.\nm (int): تعداد آیتم‌های مختلف برای انتخاب.\nitems (List[Tuple[int, int]]): لیستی از تاپل‌ها، که هر تاپل شامل دو عدد صحیح است:\n- عدد صحیح اول قیمت آیتم را نشان می‌دهد.\n- عدد صحیح دوم مقدار اهمیت آیتم را نشان می‌دهد.\n\nبازگشت:\nint: حداکثر مقدار کل اهمیت که می‌تواند بدون تجاوز از بودجه به دست آید.\n\nمثال‌ها:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nمثال اول بودجه‌ای معادل 1000 واحد با 5 آیتم برای انتخاب را نشان می‌دهد. تابع 3900 را برمی‌گرداند که حداکثر مجموع مقدار اهمیت قابل دستیابی در بودجه است.\n\nمثال دوم بودجه کوچکتری معادل 50 واحد و 3 آیتم دارد. تابع 80 را برمی‌گرداند که حداکثر مجموع مقادیر اهمیت برای آیتم‌های انتخابی در بودجه است."}}
{"task_id": "Python/19", "prompt": {"en": "\ndef max_energy(beads):\n    \"\"\"\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        This sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\n        released by merging them in the optimal order is 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        This sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\n        released by merging them in the optimal order is 48.\n    \"\"\"", "sq": "def max_energy(beads):\n    \"\"\"\n    Llogarit energjinë maksimale që mund të lirohet duke bashkuar rruazat në një gjerdan.\n\n    Funksioni merr një listë të numrave të plotë që përfaqësojnë rruazat e energjisë në një gjerdan, ku\n    secila rruazë ka një vlerë koke dhe një vlerë bishti. Vlera e kokës së secilës rruazë duhet të përputhet\n    me vlerën e bishtit të rruazës së ardhshme në sekuencë. Gjerdani është rrethor, dhe bashkimi i dy rruazave\n    ngjitur liron energji të barabartë me produktin e vlerës së kokës së rruazës së parë, vlerës së përputhshme,\n    dhe vlerës së bishtit të rruazës së dytë.\n\n    Për të gjetur lirimin maksimal të energjisë, funksioni konsideron të gjitha renditjet e mundshme të bashkimit\n    të rruazave dhe përdor programimin dinamik për të llogaritur energjinë maksimale të arritshme.\n\n    Args:\n        beads: Një listë e numrave të plotë ku secili numër përfaqëson vlerën e kokës së një rruaze dhe\n               vlerën e bishtit të rruazës së mëparshme. Vlera e bishtit të rruazës së fundit supozohet\n               të përputhet me vlerën e kokës së rruazës së parë për shkak të natyrës rrethore të gjerdanit.\n\n    Returns:\n        Një numër i plotë që përfaqëson energjinë maksimale që mund të merret duke bashkuar në mënyrë optimale të gjitha rruazat.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Kjo sekuencë përfaqëson rruaza me vlera (2,3), (3,5), (5,10), (10,2). Energjia maksimale\n        e liruar duke i bashkuar ato në rendin optimal është 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Kjo sekuencë përfaqëson rruaza me vlera (1,2), (2,3), (3,4), (4,1). Energjia maksimale\n        e liruar duke i bashkuar ato në rendin optimal është 48.\n    \"\"\"", "hy": "def max_energy(beads):\n    \"\"\"\n    Հաշվել առավելագույն էներգիան, որը կարող է ազատվել մարգարիտների միաձուլմամբ վզնոցում:\n\n    Ֆունկցիան ընդունում է ամբողջ թվերի ցանկ, որը ներկայացնում է վզնոցի վրա էներգիայի մարգարիտները, որտեղ\n    յուրաքանչյուր մարգարիտ ունի գլուխ և պոչ արժեք: Յուրաքանչյուր մարգարիտի գլուխ արժեքը պետք է համընկնի հաջորդ մարգարիտի պոչ\n    արժեքի հետ հաջորդականության մեջ: Վզնոցը շրջանաձև է, և երկու հարակից\n    մարգարիտների միաձուլումը ազատում է էներգիա, որը հավասար է առաջին մարգարիտի գլուխ արժեքի, համընկնող\n    արժեքի և երկրորդ մարգարիտի պոչ արժեքի արտադրյալին:\n\n    Առավելագույն էներգիայի ազատումը գտնելու համար ֆունկցիան հաշվի է առնում մարգարիտների միաձուլման բոլոր հնարավոր կարգերը\n    և օգտագործում է դինամիկ ծրագրավորում առավելագույն էներգիան հաշվարկելու համար:\n\n    Արգումենտներ:\n        beads: Ամբողջ թվերի ցանկ, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է մարգարիտի գլուխ արժեքը և\n               նախորդ մարգարիտի պոչ արժեքը: Վերջին մարգարիտի պոչ արժեքը ենթադրվում է\n               համընկնել առաջին մարգարիտի գլուխ արժեքի հետ վզնոցի շրջանաձև բնույթի պատճառով:\n\n    Վերադարձնում է:\n        Ամբողջ թիվ, որը ներկայացնում է առավելագույն էներգիան, որը կարող է ստացվել բոլոր մարգարիտների օպտիմալ միաձուլմամբ:\n\n    Օրինակներ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Այս հաջորդականությունը ներկայացնում է մարգարիտներ արժեքներով (2,3), (3,5), (5,10), (10,2): Առավելագույն էներգիան,\n        որը ազատվում է նրանց օպտիմալ կարգով միաձուլմամբ, 710 է:\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Այս հաջորդականությունը ներկայացնում է մարգարիտներ արժեքներով (1,2), (2,3), (3,4), (4,1): Առավելագույն էներգիան,\n        որը ազատվում է նրանց օպտիմալ կարգով միաձուլմամբ, 48 է.\n    \"\"\"", "bn": "def max_energy(beads):\n    \"\"\"\n    একটি নেকলেসের মুক্তোগুলিকে একত্রিত করে যে সর্বাধিক শক্তি মুক্তি পেতে পারে তা গণনা করুন।\n\n    ফাংশনটি একটি পূর্ণসংখ্যার তালিকা নেয় যা নেকলেসের মুক্তোগুলির শক্তি উপস্থাপন করে, যেখানে\n    প্রতিটি মুক্তোর একটি মাথা এবং একটি লেজ মান থাকে। প্রতিটি মুক্তোর মাথা মান অবশ্যই পরবর্তী মুক্তোর\n    লেজ মানের সাথে মেলে। নেকলেসটি বৃত্তাকার, এবং দুটি সংলগ্ন মুক্তো একত্রিত করলে যে শক্তি মুক্তি পায়\n    তা প্রথম মুক্তোর মাথা মান, মিলিত মান, এবং দ্বিতীয় মুক্তোর লেজ মানের গুণফলের সমান।\n\n    সর্বাধিক শক্তি মুক্তি পেতে, ফাংশনটি মুক্তোগুলিকে একত্রিত করার সমস্ত সম্ভাব্য ক্রম বিবেচনা করে\n    এবং সর্বাধিক শক্তি প্রাপ্তির জন্য গতিশীল প্রোগ্রামিং ব্যবহার করে।\n\n    Args:\n        beads: পূর্ণসংখ্যার একটি তালিকা যেখানে প্রতিটি পূর্ণসংখ্যা একটি মুক্তোর মাথা মান এবং\n               পূর্ববর্তী মুক্তোর লেজ মান উপস্থাপন করে। নেকলেসের বৃত্তাকার প্রকৃতির কারণে\n               শেষ মুক্তোর লেজ মান প্রথম মুক্তোর মাথা মানের সাথে মেলে বলে ধরা হয়।\n\n    Returns:\n        একটি পূর্ণসংখ্যা যা সমস্ত মুক্তোকে সর্বোত্তমভাবে একত্রিত করে প্রাপ্ত সর্বাধিক শক্তি উপস্থাপন করে।\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        এই ক্রমটি (2,3), (3,5), (5,10), (10,2) মানের মুক্তো উপস্থাপন করে। সর্বোত্তম ক্রমে\n        তাদের একত্রিত করে মুক্তি পাওয়া সর্বাধিক শক্তি 710।\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        এই ক্রমটি (1,2), (2,3), (3,4), (4,1) মানের মুক্তো উপস্থাপন করে। সর্বোত্তম ক্রমে\n        তাদের একত্রিত করে মুক্তি পাওয়া সর্বাধিক শক্তি 48।\n    \"\"\"", "bg": "def max_energy(beads):\n    \"\"\"\n    Изчислява максималната енергия, която може да бъде освободена чрез сливане на мъниста на огърлица.\n\n    Функцията приема списък от цели числа, представляващи енергийните мъниста на огърлица, където\n    всяко мънисто има стойност на глава и опашка. Стойността на главата на всяко мънисто трябва да съвпада\n    със стойността на опашката на следващото мънисто в последователността. Огърлицата е кръгова, и сливането\n    на две съседни мъниста освобождава енергия, равна на произведението от стойността на главата на първото мънисто,\n    съвпадащата стойност и стойността на опашката на второто мънисто.\n\n    За да се намери максималното освобождаване на енергия, функцията разглежда всички възможни редове на сливане на мънистата\n    и използва динамично програмиране, за да изчисли максималната енергия, която може да бъде получена.\n\n    Аргументи:\n        beads: Списък от цели числа, където всяко цяло число представлява стойността на главата на мънисто и\n               стойността на опашката на предишното мънисто. Стойността на опашката на последното мънисто се приема,\n               че съвпада със стойността на главата на първото мънисто поради кръговата природа на огърлицата.\n\n    Връща:\n        Цяло число, представляващо максималната енергия, която може да бъде получена чрез оптимално сливане на всички мъниста.\n\n    Примери:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Тази последователност представлява мъниста със стойности (2,3), (3,5), (5,10), (10,2). Максималната енергия,\n        освободена чрез сливането им в оптимален ред, е 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Тази последователност представлява мъниста със стойности (1,2), (2,3), (3,4), (4,1). Максималната енергия,\n        освободена чрез сливането им в оптимален ред, е 48.\n    \"\"\"", "zh": "def max_energy(beads):\n    \"\"\"\n    计算通过合并项链上的珠子可以释放的最大能量。\n\n    该函数接受一个整数列表，表示项链上的能量珠子，其中每个珠子有一个头部和尾部值。\n    每个珠子的头部值必须与序列中下一个珠子的尾部值匹配。项链是环形的，合并两个相邻\n    的珠子释放的能量等于第一个珠子的头部值、匹配值和第二个珠子的尾部值的乘积。\n\n    为了找到最大能量释放，函数考虑所有可能的珠子合并顺序，并使用动态规划计算可获得的最大能量。\n\n    参数:\n        beads: 一个整数列表，其中每个整数表示一个珠子的头部值和前一个珠子的尾部值。\n               由于项链的环形特性，假设最后一个珠子的尾部值与第一个珠子的头部值匹配。\n\n    返回:\n        一个整数，表示通过最佳合并所有珠子可以获得的最大能量。\n\n    示例:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        该序列表示值为 (2,3), (3,5), (5,10), (10,2) 的珠子。通过以最佳顺序合并它们释放的最大能量是 710。\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        该序列表示值为 (1,2), (2,3), (3,4), (4,1) 的珠子。通过以最佳顺序合并它们释放的最大能量是 48。\n    \"\"\"", "fr": "def max_energy(beads):\n    \"\"\"\n    Calculer l'énergie maximale qui peut être libérée en fusionnant des perles sur un collier.\n\n    La fonction prend une liste d'entiers représentant les perles d'énergie sur un collier, où\n    chaque perle a une valeur de tête et une valeur de queue. La valeur de tête de chaque perle doit correspondre à la valeur de queue\n    de la perle suivante dans la séquence. Le collier est circulaire, et fusionner deux perles adjacentes\n    libère une énergie égale au produit de la valeur de tête de la première perle, de la valeur correspondante,\n    et de la valeur de queue de la seconde perle.\n\n    Pour trouver la libération d'énergie maximale, la fonction considère tous les ordres possibles de fusion des perles\n    et utilise la programmation dynamique pour calculer l'énergie maximale obtenable.\n\n    Args:\n        beads: Une liste d'entiers où chaque entier représente la valeur de tête d'une perle et\n               la valeur de queue de la perle précédente. La valeur de queue de la dernière perle est supposée\n               correspondre à la valeur de tête de la première perle en raison de la nature circulaire du collier.\n\n    Returns:\n        Un entier représentant l'énergie maximale qui peut être obtenue en fusionnant de manière optimale toutes les perles.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Cette séquence représente des perles avec des valeurs (2,3), (3,5), (5,10), (10,2). L'énergie maximale\n        libérée en les fusionnant dans l'ordre optimal est 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Cette séquence représente des perles avec des valeurs (1,2), (2,3), (3,4), (4,1). L'énergie maximale\n        libérée en les fusionnant dans l'ordre optimal est 48.\n    \"\"\"", "de": "def max_energy(beads):\n    \"\"\"\n    Berechne die maximale Energie, die durch das Verschmelzen von Perlen auf einer Halskette freigesetzt werden kann.\n\n    Die Funktion nimmt eine Liste von ganzen Zahlen, die die Energieperlen auf einer Halskette darstellen, wobei\n    jede Perle einen Kopf- und einen Schwanzwert hat. Der Kopfwert jeder Perle muss mit dem Schwanzwert\n    der nächsten Perle in der Sequenz übereinstimmen. Die Halskette ist kreisförmig, und das Verschmelzen zweier\n    benachbarter Perlen setzt Energie frei, die dem Produkt des Kopfwerts der ersten Perle, dem übereinstimmenden\n    Wert und dem Schwanzwert der zweiten Perle entspricht.\n\n    Um die maximale Energiefreisetzung zu finden, berücksichtigt die Funktion alle möglichen Reihenfolgen des Verschmelzens\n    von Perlen und verwendet dynamische Programmierung, um die maximal erreichbare Energie zu berechnen.\n\n    Argumente:\n        beads: Eine Liste von ganzen Zahlen, wobei jede ganze Zahl den Kopfwert einer Perle und\n               den Schwanzwert der vorherigen Perle darstellt. Der Schwanzwert der letzten Perle wird\n               aufgrund der kreisförmigen Natur der Halskette als übereinstimmend mit dem Kopfwert der ersten Perle angenommen.\n\n    Rückgabewert:\n        Eine ganze Zahl, die die maximale Energie darstellt, die durch optimales Verschmelzen aller Perlen erreicht werden kann.\n\n    Beispiele:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Diese Sequenz repräsentiert Perlen mit Werten (2,3), (3,5), (5,10), (10,2). Die maximale Energie,\n        die durch das Verschmelzen in optimaler Reihenfolge freigesetzt wird, beträgt 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Diese Sequenz repräsentiert Perlen mit Werten (1,2), (2,3), (3,4), (4,1). Die maximale Energie,\n        die durch das Verschmelzen in optimaler Reihenfolge freigesetzt wird, beträgt 48.\n    \"\"\"", "ha": "def max_energy(beads):\n    \"\"\"\n    Lissafi mafi yawan kuzari da za a iya saki ta hanyar hade beads a kan abin wuya.\n\n    Aikin yana daukar jerin lambobi masu wakiltar beads na kuzari a kan abin wuya, inda\n    kowane bead yana da kima ta gaba da kuma kima ta baya. Kima ta gaba na kowane bead dole ne ya dace da kima ta baya\n    na bead na gaba a jerin. Abin wuya yana zagaye, kuma hade beads biyu masu makwabtaka\n    yana sakin kuzari daidai da samfurin kima ta gaba na bead na farko, kimar da ta dace,\n    da kima ta baya na bead na biyu.\n\n    Don samun mafi yawan sakin kuzari, aikin yana la'akari da dukkan yiwuwar jere na hade beads\n    kuma yana amfani da shirye-shiryen motsi don lissafi mafi yawan kuzari da za a iya samu.\n\n    Args:\n        beads: Jerin lambobi inda kowane lamba yana wakiltar kima ta gaba na bead da\n               kima ta baya na bead na baya. Ana daukar kima ta baya na bead na karshe\n               ya dace da kima ta gaba na bead na farko saboda yanayin zagaye na abin wuya.\n\n    Returns:\n        Lamba mai wakiltar mafi yawan kuzari da za a iya samu ta hanyar hade duk beads din cikin hikima.\n\n    Misalai:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Wannan jerin yana wakiltar beads da kimomi (2,3), (3,5), (5,10), (10,2). Mafi yawan kuzari\n        da aka saki ta hanyar hade su a cikin jere mafi kyau shine 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Wannan jerin yana wakiltar beads da kimomi (1,2), (2,3), (3,4), (4,1). Mafi yawan kuzari\n        da aka saki ta hanyar hade su a cikin jere mafi kyau shine 48.\n    \"\"\"", "hi": "def max_energy(beads):\n    \"\"\"\n    मोतियों को एक हार पर मिलाकर जारी की जा सकने वाली अधिकतम ऊर्जा की गणना करें।\n\n    यह फ़ंक्शन एक पूर्णांकों की सूची लेता है जो हार पर ऊर्जा मोतियों का प्रतिनिधित्व करता है, जहाँ\n    प्रत्येक मोती का एक सिर और एक पूंछ मान होता है। प्रत्येक मोती का सिर मान अनुक्रम में अगले मोती के\n    पूंछ मान से मेल खाना चाहिए। हार वृत्ताकार है, और दो आसन्न मोतियों को मिलाने से ऊर्जा जारी होती है जो\n    पहले मोती के सिर मान, मिलान मान, और दूसरे मोती के पूंछ मान के गुणनफल के बराबर होती है।\n\n    अधिकतम ऊर्जा रिलीज़ खोजने के लिए, फ़ंक्शन मोतियों को मिलाने के सभी संभावित क्रमों पर विचार करता है\n    और अधिकतम प्राप्त की जा सकने वाली ऊर्जा की गणना करने के लिए गतिशील प्रोग्रामिंग का उपयोग करता है।\n\n    Args:\n        beads: पूर्णांकों की एक सूची जहाँ प्रत्येक पूर्णांक एक मोती के सिर मान का प्रतिनिधित्व करता है और\n               पिछले मोती का पूंछ मान। हार की वृत्ताकार प्रकृति के कारण अंतिम मोती का पूंछ मान पहले मोती के\n               सिर मान से मेल खाने की कल्पना की जाती है।\n\n    Returns:\n        एक पूर्णांक जो सभी मोतियों को अनुकूल रूप से मिलाकर प्राप्त की जा सकने वाली अधिकतम ऊर्जा का प्रतिनिधित्व करता है।\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        यह अनुक्रम (2,3), (3,5), (5,10), (10,2) मानों के साथ मोतियों का प्रतिनिधित्व करता है। उन्हें अनुकूल क्रम में\n        मिलाकर जारी की गई अधिकतम ऊर्जा 710 है।\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        यह अनुक्रम (1,2), (2,3), (3,4), (4,1) मानों के साथ मोतियों का प्रतिनिधित्व करता है। उन्हें अनुकूल क्रम में\n        मिलाकर जारी की गई अधिकतम ऊर्जा 48 है।\n    \"\"\"", "hu": "def max_energy(beads):\n    \"\"\"\n    Számítsa ki a maximális energiát, amely felszabadulhat a gyöngyök összeolvasztásával egy nyakláncon.\n\n    A függvény egy egész számok listáját veszi, amely a nyaklánc gyöngyeinek energiáját képviseli, ahol\n    minden gyöngynek van egy fej- és egy farokértéke. Minden gyöngy fejértékének meg kell egyeznie a\n    következő gyöngy farokértékével a sorozatban. A nyaklánc kör alakú, és két szomszédos gyöngy összeolvasztása\n    olyan energiát szabadít fel, amely egyenlő az első gyöngy fejértékének, a megfelelő értéknek és a második\n    gyöngy farokértékének szorzatával.\n\n    A maximális energia felszabadításának megtalálásához a függvény figyelembe veszi a gyöngyök összeolvasztásának\n    összes lehetséges sorrendjét, és dinamikus programozást használ a maximálisan elérhető energia kiszámításához.\n\n    Args:\n        beads: Egy egész számok listája, ahol minden egész szám egy gyöngy fejértékét és az előző gyöngy\n               farokértékét képviseli. Az utolsó gyöngy farokértéke a nyaklánc körkörös jellege miatt\n               feltételezhetően megegyezik az első gyöngy fejértékével.\n\n    Returns:\n        Egy egész szám, amely a gyöngyök optimális összeolvasztásával elérhető maximális energiát képviseli.\n\n    Példák:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Ez a sorozat a (2,3), (3,5), (5,10), (10,2) értékű gyöngyöket képviseli. Az optimális sorrendben\n        történő összeolvasztásuk által felszabadított maximális energia 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Ez a sorozat a (1,2), (2,3), (3,4), (4,1) értékű gyöngyöket képviseli. Az optimális sorrendben\n        történő összeolvasztásuk által felszabadított maximális energia 48.\n    \"\"\"", "es": "def max_energy(beads):\n    \"\"\"\n    Calcula la energía máxima que se puede liberar al fusionar cuentas en un collar.\n\n    La función toma una lista de enteros que representan las cuentas de energía en un collar, donde\n    cada cuenta tiene un valor de cabeza y un valor de cola. El valor de cabeza de cada cuenta debe coincidir\n    con el valor de cola de la siguiente cuenta en la secuencia. El collar es circular, y fusionar dos cuentas adyacentes\n    libera energía igual al producto del valor de cabeza de la primera cuenta, el valor coincidente,\n    y el valor de cola de la segunda cuenta.\n\n    Para encontrar la liberación máxima de energía, la función considera todos los posibles órdenes de fusión de cuentas\n    y utiliza programación dinámica para calcular la energía máxima obtenible.\n\n    Argumentos:\n        beads: Una lista de enteros donde cada entero representa el valor de cabeza de una cuenta y\n               el valor de cola de la cuenta anterior. Se asume que el valor de cola de la última cuenta\n               coincide con el valor de cabeza de la primera cuenta debido a la naturaleza circular del collar.\n\n    Devuelve:\n        Un entero que representa la energía máxima que se puede obtener fusionando todas las cuentas de manera óptima.\n\n    Ejemplos:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Esta secuencia representa cuentas con valores (2,3), (3,5), (5,10), (10,2). La energía máxima\n        liberada al fusionarlas en el orden óptimo es 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Esta secuencia representa cuentas con valores (1,2), (2,3), (3,4), (4,1). La energía máxima\n        liberada al fusionarlas en el orden óptimo es 48.\n    \"\"\"", "arb": "def max_energy(beads):\n    \"\"\"\n    حساب الطاقة القصوى التي يمكن إطلاقها عن طريق دمج الخرزات في قلادة.\n\n    تأخذ الدالة قائمة من الأعداد الصحيحة التي تمثل خرزات الطاقة في قلادة، حيث\n    يحتوي كل خرزة على قيمة رأس وقيمة ذيل. يجب أن تتطابق قيمة الرأس لكل خرزة مع قيمة الذيل\n    للخرزة التالية في التسلسل. القلادة دائرية، ودمج خرزتين متجاورتين يطلق طاقة تساوي حاصل ضرب قيمة الرأس للخرزة الأولى،\n    والقيمة المطابقة، وقيمة الذيل للخرزة الثانية.\n\n    لإيجاد إطلاق الطاقة الأقصى، تأخذ الدالة في الاعتبار جميع أوامر دمج الخرزات الممكنة\n    وتستخدم البرمجة الديناميكية لحساب الطاقة القصوى الممكن الحصول عليها.\n\n    يعيدالحجج:\n        beads: قائمة من الأعداد الصحيحة حيث يمثل كل عدد صحيح قيمة الرأس لخرزة و\n               قيمة الذيل للخرزة السابقة. يُفترض أن قيمة الذيل للخرزة الأخيرة تتطابق\n               مع قيمة الرأس للخرزة الأولى بسبب الطبيعة الدائرية للقلادة.\n\n    يعيد:\n        عدد صحيح يمثل الطاقة القصوى التي يمكن الحصول عليها عن طريق دمج جميع الخرزات بشكل مثالي.\n\n    أمثلة:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        تمثل هذه السلسلة خرزات بالقيم (2,3)، (3,5)، (5,10)، (10,2). الطاقة القصوى\n        التي يتم إطلاقها عن طريق دمجها بالترتيب الأمثل هي 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        تمثل هذه السلسلة خرزات بالقيم (1,2)، (2,3)، (3,4)، (4,1). الطاقة القصوى\n        التي يتم إطلاقها عن طريق دمجها بالترتيب الأمثل هي 48.\n    \"\"\"", "sw": "def max_energy(beads):\n    \"\"\"\n    Kuhesabu nishati ya juu zaidi inayoweza kutolewa kwa kuunganisha shanga kwenye mkufu.\n\n    Kazi inachukua orodha ya nambari za mzima zinazoashiria shanga za nishati kwenye mkufu, ambapo\n    kila shanga ina thamani ya kichwa na mkia. Thamani ya kichwa ya kila shanga lazima ilingane na thamani ya mkia\n    wa shanga inayofuata katika mlolongo. Mkufu ni wa mviringo, na kuunganisha shanga mbili zilizo karibu\n    hutolewa nishati sawa na bidhaa ya thamani ya kichwa ya shanga ya kwanza, thamani inayolingana,\n    na thamani ya mkia wa shanga ya pili.\n\n    Ili kupata nishati ya juu zaidi inayotolewa, kazi inazingatia maagizo yote yanayowezekana ya kuunganisha shanga\n    na hutumia programu ya nguvu kuhesabu nishati ya juu inayoweza kupatikana.\n\n    Hoja:\n        beads: Orodha ya nambari za mzima ambapo kila nambari inawakilisha thamani ya kichwa ya shanga na\n               thamani ya mkia wa shanga iliyotangulia. Thamani ya mkia wa shanga ya mwisho inadhaniwa\n               kulingana na thamani ya kichwa ya shanga ya kwanza kutokana na asili ya mviringo ya mkufu.\n\n    Inarejesha:\n        Nambari ya mzima inayowakilisha nishati ya juu zaidi inayoweza kupatikana kwa kuunganisha shanga zote kwa njia bora.\n\n    Mifano:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Mlolongo huu unawakilisha shanga zenye thamani (2,3), (3,5), (5,10), (10,2). Nishati ya juu zaidi\n        inayotolewa kwa kuziunganisha kwa mpangilio bora ni 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Mlolongo huu unawakilisha shanga zenye thamani (1,2), (2,3), (3,4), (4,1). Nishati ya juu zaidi\n        inayotolewa kwa kuziunganisha kwa mpangilio bora ni 48.\n    \"\"\"", "tr": "def max_energy(beads):\n    \"\"\"\n    Bir kolyedeki boncukları birleştirerek açığa çıkabilecek maksimum enerjiyi hesaplayın.\n\n    Fonksiyon, bir kolyede enerji boncuklarını temsil eden bir tamsayı listesi alır, burada\n    her boncuğun bir baş ve bir kuyruk değeri vardır. Her boncuğun baş değeri, dizideki bir sonraki\n    boncuğun kuyruk değeriyle eşleşmelidir. Kolyenin yapısı daireseldir ve iki bitişik boncuğun\n    birleştirilmesi, ilk boncuğun baş değeri, eşleşen değer ve ikinci boncuğun kuyruk değerinin\n    çarpımına eşit enerji açığa çıkarır.\n\n    Maksimum enerji açığa çıkışını bulmak için, fonksiyon boncukları birleştirmenin tüm olası\n    sıralarını dikkate alır ve dinamik programlama kullanarak elde edilebilecek maksimum enerjiyi\n    hesaplar.\n\n    Argümanlar:\n        beads: Her tamsayının bir boncuğun baş değerini ve önceki boncuğun kuyruk değerini\n               temsil ettiği bir tamsayı listesi. Kolyenin dairesel yapısından dolayı son\n               boncuğun kuyruk değerinin ilk boncuğun baş değeriyle eşleştiği varsayılır.\n\n    Döndürür:\n        Tüm boncukları optimal bir şekilde birleştirerek elde edilebilecek maksimum enerjiyi\n        temsil eden bir tamsayı.\n\n    Örnekler:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Bu dizi, (2,3), (3,5), (5,10), (10,2) değerlerine sahip boncukları temsil eder. Onları\n        optimal sırayla birleştirerek açığa çıkan maksimum enerji 710'dur.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Bu dizi, (1,2), (2,3), (3,4), (4,1) değerlerine sahip boncukları temsil eder. Onları\n        optimal sırayla birleştirerek açığa çıkan maksimum enerji 48'dir.\n    \"\"\"", "vi": "def max_energy(beads):\n    \"\"\"\n    Tính toán năng lượng tối đa có thể được giải phóng bằng cách hợp nhất các hạt trên một vòng cổ.\n\n    Hàm nhận một danh sách các số nguyên đại diện cho năng lượng của các hạt trên một vòng cổ, \n    trong đó mỗi hạt có một giá trị đầu và một giá trị đuôi. Giá trị đầu của mỗi hạt phải khớp \n    với giá trị đuôi của hạt tiếp theo trong chuỗi. Vòng cổ là hình tròn, và việc hợp nhất hai hạt \n    liền kề giải phóng năng lượng bằng tích của giá trị đầu của hạt thứ nhất, giá trị khớp, và \n    giá trị đuôi của hạt thứ hai.\n\n    Để tìm năng lượng giải phóng tối đa, hàm xem xét tất cả các thứ tự hợp nhất hạt có thể có và \n    sử dụng lập trình động để tính toán năng lượng tối đa có thể đạt được.\n\n    Tham số:\n        beads: Một danh sách các số nguyên trong đó mỗi số nguyên đại diện cho giá trị đầu của \n               một hạt và giá trị đuôi của hạt trước đó. Giá trị đuôi của hạt cuối cùng được giả \n               định là khớp với giá trị đầu của hạt đầu tiên do tính chất hình tròn của vòng cổ.\n\n    Trả về:\n        Một số nguyên đại diện cho năng lượng tối đa có thể đạt được bằng cách hợp nhất tối ưu \n        tất cả các hạt.\n\n    Ví dụ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Dãy này đại diện cho các hạt có giá trị (2,3), (3,5), (5,10), (10,2). Năng lượng tối đa \n        được giải phóng bằng cách hợp nhất chúng theo thứ tự tối ưu là 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Dãy này đại diện cho các hạt có giá trị (1,2), (2,3), (3,4), (4,1). Năng lượng tối đa \n        được giải phóng bằng cách hợp nhất chúng theo thứ tự tối ưu là 48.\n    \"\"\"", "id": "def max_energy(beads):\n    \"\"\"\n    Menghitung energi maksimum yang dapat dilepaskan dengan menggabungkan manik-manik pada sebuah kalung.\n\n    Fungsi ini menerima daftar bilangan bulat yang mewakili energi manik-manik pada sebuah kalung, di mana\n    setiap manik memiliki nilai kepala dan ekor. Nilai kepala dari setiap manik harus sesuai dengan nilai ekor\n    dari manik berikutnya dalam urutan. Kalung tersebut bersifat melingkar, dan menggabungkan dua manik yang berdekatan\n    melepaskan energi yang sama dengan hasil kali dari nilai kepala manik pertama, nilai yang sesuai,\n    dan nilai ekor dari manik kedua.\n\n    Untuk menemukan pelepasan energi maksimum, fungsi ini mempertimbangkan semua urutan penggabungan manik-manik\n    yang mungkin dan menggunakan pemrograman dinamis untuk menghitung energi maksimum yang dapat diperoleh.\n\n    Argumen:\n        beads: Daftar bilangan bulat di mana setiap bilangan bulat mewakili nilai kepala dari sebuah manik dan\n               nilai ekor dari manik sebelumnya. Nilai ekor dari manik terakhir diasumsikan\n               sesuai dengan nilai kepala dari manik pertama karena sifat melingkar dari kalung tersebut.\n\n    Mengembalikan:\n        Sebuah bilangan bulat yang mewakili energi maksimum yang dapat diperoleh dengan menggabungkan semua manik secara optimal.\n\n    Contoh:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Urutan ini mewakili manik-manik dengan nilai (2,3), (3,5), (5,10), (10,2). Energi maksimum\n        yang dilepaskan dengan menggabungkan mereka dalam urutan optimal adalah 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Urutan ini mewakili manik-manik dengan nilai (1,2), (2,3), (3,4), (4,1). Energi maksimum\n        yang dilepaskan dengan menggabungkan mereka dalam urutan optimal adalah 48.\n    \"\"\"", "ja": "def max_energy(beads):\n    \"\"\"\n    ネックレスのビーズを合体させることで放出される最大エネルギーを計算します。\n\n    この関数は、ネックレス上のエネルギービーズを表す整数のリストを受け取り、\n    各ビーズにはヘッドとテールの値があります。各ビーズのヘッド値は、次のビーズの\n    テール値と一致する必要があります。ネックレスは円形であり、隣接する2つのビーズを\n    合体させると、最初のビーズのヘッド値、マッチング値、および2番目のビーズのテール値の\n    積に等しいエネルギーが放出されます。\n\n    最大エネルギー放出を見つけるために、関数はビーズを合体させるすべての可能な順序を考慮し、\n    動的プログラミングを使用して得られる最大エネルギーを計算します。\n\n    引数:\n        beads: 各整数がビーズのヘッド値と前のビーズのテール値を表す整数のリスト。\n               ネックレスの円形の性質により、最後のビーズのテール値は最初のビーズの\n               ヘッド値と一致すると仮定されます。\n\n    戻り値:\n        すべてのビーズを最適に合体させることで得られる最大エネルギーを表す整数。\n\n    例:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        このシーケンスは、値が (2,3), (3,5), (5,10), (10,2) のビーズを表します。\n        最適な順序で合体させることで放出される最大エネルギーは 710 です。\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        このシーケンスは、値が (1,2), (2,3), (3,4), (4,1) のビーズを表します。\n        最適な順序で合体させることで放出される最大エネルギーは 48 です。\n    \"\"\"", "ko": "def max_energy(beads):\n    \"\"\"\n    목걸이의 구슬을 합쳐서 방출할 수 있는 최대 에너지를 계산합니다.\n\n    이 함수는 목걸이의 에너지 구슬을 나타내는 정수 리스트를 받습니다. 각 구슬은 머리와 꼬리 값을 가지고 있으며,\n    각 구슬의 머리 값은 다음 구슬의 꼬리 값과 일치해야 합니다. 목걸이는 원형이며, 인접한 두 구슬을 합치면\n    첫 번째 구슬의 머리 값, 일치하는 값, 두 번째 구슬의 꼬리 값의 곱에 해당하는 에너지가 방출됩니다.\n\n    최대 에너지 방출을 찾기 위해, 함수는 구슬을 합치는 모든 가능한 순서를 고려하고\n    동적 프로그래밍을 사용하여 얻을 수 있는 최대 에너지를 계산합니다.\n\n    인자:\n        beads: 각 정수가 구슬의 머리 값을 나타내며, 이전 구슬의 꼬리 값을 나타내는 정수 리스트입니다.\n               목걸이의 원형 특성 때문에 마지막 구슬의 꼬리 값은 첫 번째 구슬의 머리 값과 일치한다고 가정합니다.\n\n    반환값:\n        모든 구슬을 최적으로 합쳐서 얻을 수 있는 최대 에너지를 나타내는 정수입니다.\n\n    예제:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        이 시퀀스는 값이 (2,3), (3,5), (5,10), (10,2)인 구슬을 나타냅니다. 최적의 순서로 합쳤을 때 방출되는 최대 에너지는 710입니다.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        이 시퀀스는 값이 (1,2), (2,3), (3,4), (4,1)인 구슬을 나타냅니다. 최적의 순서로 합쳤을 때 방출되는 최대 에너지는 48입니다.\n    \"\"\"", "ml": "def max_energy(beads):\n    \"\"\"\n    മാലയിലെ മണികൾ ലയിപ്പിക്കുന്നതിലൂടെ പുറത്തുവരുന്ന പരമാവധി ഊർജ്ജം കണക്കാക്കുക.\n\n    ഫംഗ്ഷൻ ഒരു പട്ടികയിലുള്ള മുഴുവൻ ഇന്റീജറുകളെയും സ്വീകരിക്കുന്നു, അവ മാലയിലെ\n    ഊർജ്ജ മണികളെ പ്രതിനിധീകരിക്കുന്നു, ഓരോ മണിക്കും ഒരു തലയും വാലുമുള്ള മൂല്യം ഉണ്ട്.\n    ഓരോ മണിയുടെ തല മൂല്യം പരമ്പരയിലെ അടുത്ത മണിയുടെ വാൽ മൂല്യവുമായി പൊരുത്തപ്പെടണം.\n    മാല വൃത്താകൃതിയിലുള്ളതാണ്, കൂടെ ചേർന്നിരിക്കുന്ന രണ്ട് മണികളെ ലയിപ്പിക്കുന്നത്\n    ആദ്യ മണിയുടെ തല മൂല്യത്തിന്റെ ഉൽപ്പന്നത്തിന് തുല്യമായ ഊർജ്ജം പുറത്തുവിടുന്നു,\n    പൊരുത്തപ്പെടുന്ന മൂല്യം, രണ്ടാമത്തെ മണിയുടെ വാൽ മൂല്യം.\n\n    പരമാവധി ഊർജ്ജം പുറത്തുവരുന്നത് കണ്ടെത്താൻ, ഫംഗ്ഷൻ മണികളെ ലയിപ്പിക്കുന്ന എല്ലാ\n    സാധ്യതയുള്ള ക്രമങ്ങളും പരിഗണിക്കുന്നു, ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് പരമാവധി\n    ലഭ്യമായ ഊർജ്ജം കണക്കാക്കുന്നു.\n\n    Args:\n        beads: ഒരു പട്ടികയിലുള്ള മുഴുവൻ ഇന്റീജറുകളെ പ്രതിനിധീകരിക്കുന്നു, ഓരോ\n               ഇന്റീജറും ഒരു മണിയുടെ തല മൂല്യവും മുമ്പത്തെ മണിയുടെ വാൽ മൂല്യവും\n               പ്രതിനിധീകരിക്കുന്നു. മാലയുടെ വൃത്താകൃതിയുള്ള സ്വഭാവം കാരണം അവസാന\n               മണിയുടെ വാൽ മൂല്യം ആദ്യ മണിയുടെ തല മൂല്യവുമായി പൊരുത്തപ്പെടുന്നു എന്ന്\n               കരുതുന്നു.\n\n    Returns:\n        എല്ലാ മണികളെയും ലയിപ്പിക്കുന്നതിലൂടെ പരമാവധി ലഭ്യമായ ഊർജ്ജത്തെ പ്രതിനിധീകരിക്കുന്ന\n        ഒരു ഇന്റീജർ.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        ഈ പരമ്പര (2,3), (3,5), (5,10), (10,2) മൂല്യമുള്ള മണികളെ പ്രതിനിധീകരിക്കുന്നു.\n        അവയെ പരമാവധി ലയിപ്പിക്കുന്നതിലൂടെ പുറത്തുവരുന്ന പരമാവധി ഊർജ്ജം 710 ആണ്.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        ഈ പരമ്പര (1,2), (2,3), (3,4), (4,1) മൂല്യമുള്ള മണികളെ പ്രതിനിധീകരിക്കുന്നു.\n        അവയെ പരമാവധി ലയിപ്പിക്കുന്നതിലൂടെ പുറത്തുവരുന്ന പരമാവധി ഊർജ്ജം 48 ആണ്.\n    \"\"\"", "fa": "def max_energy(beads):\n    \"\"\"\n    حداکثر انرژی که می‌تواند با ادغام مهره‌ها در یک گردنبند آزاد شود را محاسبه کنید.\n\n    این تابع یک لیست از اعداد صحیح را می‌گیرد که نمایانگر مهره‌های انرژی روی یک گردنبند هستند، \n    جایی که هر مهره دارای یک مقدار سر و یک مقدار دم است. مقدار سر هر مهره باید با مقدار دم \n    مهره بعدی در دنباله مطابقت داشته باشد. گردنبند دایره‌ای است و ادغام دو مهره مجاور انرژی \n    برابر با حاصل‌ضرب مقدار سر مهره اول، مقدار مطابقت و مقدار دم مهره دوم آزاد می‌کند.\n\n    برای یافتن حداکثر آزادسازی انرژی، تابع تمامی ترتیب‌های ممکن ادغام مهره‌ها را در نظر می‌گیرد \n    و از برنامه‌ریزی پویا برای محاسبه حداکثر انرژی قابل دستیابی استفاده می‌کند.\n\n    آرگومان‌ها:\n        beads: یک لیست از اعداد صحیح که هر عدد نمایانگر مقدار سر یک مهره و مقدار دم مهره \n               قبلی است. مقدار دم آخرین مهره به دلیل ماهیت دایره‌ای گردنبند فرض می‌شود که \n               با مقدار سر اولین مهره مطابقت دارد.\n\n    بازگشت:\n        یک عدد صحیح که نمایانگر حداکثر انرژی قابل دستیابی با ادغام بهینه همه مهره‌ها است.\n\n    مثال‌ها:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        این دنباله نمایانگر مهره‌هایی با مقادیر (2,3)، (3,5)، (5,10)، (10,2) است. حداکثر انرژی \n        آزاد شده با ادغام آنها در ترتیب بهینه 710 است.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        این دنباله نمایانگر مهره‌هایی با مقادیر (1,2)، (2,3)، (3,4)، (4,1) است. حداکثر انرژی \n        آزاد شده با ادغام آنها در ترتیب بهینه 48 است.\n    \"\"\""}, "canonical_solution": "    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))", "instruction": {"en": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\n请用中文为以下Python代码提供一个简洁的自然语言描述（文档字符串），最多使用500个字符。", "fr": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nGeben Sie eine prägnante Beschreibung (Docstring) des Python-Codes in deutscher Sprache mit maximal 500 Zeichen.", "ha": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Python باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.", "vi": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_max_energy():\n    assert max_energy([2, 3, 5, 10]) == 710, \"Testcase 1 failed\"\n    assert max_energy([1, 2, 3, 4]) == 80, \"Testcase 2 failed\"\n    assert max_energy([4, 4, 4, 4]) == 192, \"Testcase 3 failed\"\n    assert max_energy([30, 40, 50, 60]) == 372000, \"Testcase 4 failed\"\n    print(\"All testcases passed\")\n\n# Call the test function\ntest_max_energy()", "entry_point": "max_energy", "signature": "def max_energy(beads):", "docstring": {"en": "Calculate the maximum energy that can be released by merging beads on a necklace.\n\nThe function takes a list of integers representing the energy beads on a necklace, where\neach bead has a head and a tail value. The head value of each bead must match the tail\nvalue of the next bead in the sequence. The necklace is circular, and merging two adjacent\nbeads releases energy equal to the product of the head value of the first bead, the matching\nvalue, and the tail value of the second bead.\n\nTo find the maximum energy release, the function considers all possible orders of merging beads\nand uses dynamic programming to compute the maximum energy obtainable.\n\nArgs:\nbeads: A list of integers where each integer represents the head value of a bead and\nthe tail value of the previous bead. The tail value of the last bead is assumed\nto match the head value of the first bead due to the circular nature of the necklace.\n\nReturns:\nAn integer representing the maximum energy that can be obtained by optimally merging all beads.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nThis sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\nreleased by merging them in the optimal order is 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nThis sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\nreleased by merging them in the optimal order is 48.", "sq": "Llogarit energjinë maksimale që mund të lirohet duke bashkuar rruazat në një varëse.\n\nFunksioni merr një listë të numrave të plotë që përfaqësojnë rruazat e energjisë në një varëse, ku\nçdo rruazë ka një vlerë koke dhe një vlerë bishti. Vlera e kokës së çdo rruaze duhet të përputhet me vlerën e bishtit\ntë rruazës tjetër në sekuencë. Varësja është rrethore, dhe bashkimi i dy rruazave ngjitur liron energji të barabartë me produktin e vlerës së kokës së rruazës së parë, vlerës përputhëse, dhe vlerës së bishtit të rruazës së dytë.\n\nPër të gjetur lirimin maksimal të energjisë, funksioni konsideron të gjitha renditjet e mundshme të bashkimit të rruazave\ndhe përdor programimin dinamik për të llogaritur energjinë maksimale të arritshme.\n\nArgumentet:\nbeads: Një listë e numrave të plotë ku çdo numër përfaqëson vlerën e kokës së një rruaze dhe\nvlerën e bishtit të rruazës së mëparshme. Vlera e bishtit të rruazës së fundit supozohet\ntë përputhet me vlerën e kokës së rruazës së parë për shkak të natyrës rrethore të varëses.\n\nKthen:\nNjë numër i plotë që përfaqëson energjinë maksimale që mund të merret duke bashkuar në mënyrë optimale të gjitha rruazat.\n\nShembuj:\n>>> max_energy([2, 3, 5, 10])\n710\nKjo sekuencë përfaqëson rruaza me vlera (2,3), (3,5), (5,10), (10,2). Energjia maksimale\ne liruar duke i bashkuar ato në rendin optimal është 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nKjo sekuencë përfaqëson rruaza me vlera (1,2), (2,3), (3,4), (4,1). Energjia maksimale\ne liruar duke i bashkuar ato në rendin optimal është 48.", "hy": "Հաշվարկել առավելագույն էներգիան, որը կարող է ազատվել մարգարիտներ միացնելիս վզնոցի վրա:\n\nՖունկցիան ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է վզնոցի վրա գտնվող էներգիայի մարգարիտները, որտեղ\nյուրաքանչյուր մարգարիտ ունի գլուխ և պոչ արժեք: Յուրաքանչյուր մարգարիտի գլուխ արժեքը պետք է համընկնի հաջորդ մարգարիտի\nպոչ արժեքի հետ հաջորդականության մեջ: Վզնոցը շրջանաձև է, և երկու հարակից մարգարիտների միացումը ազատում է էներգիա,\nորը հավասար է առաջին մարգարիտի գլուխ արժեքի, համընկնող արժեքի և երկրորդ մարգարիտի պոչ արժեքի արտադրյալին:\n\nԱռավելագույն էներգիայի ազատումը գտնելու համար ֆունկցիան հաշվի է առնում մարգարիտների միացման բոլոր հնարավոր կարգերը\nև օգտագործում է դինամիկ ծրագրավորում առավելագույն էներգիան հաշվելու համար:\n\nԱրձանագրություններ:\nbeads: Ամբողջ թվերի ցուցակ, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է մարգարիտի գլուխ արժեքը և\nնախորդ մարգարիտի պոչ արժեքը: Վերջին մարգարիտի պոչ արժեքը ենթադրվում է, որ համընկնում է առաջին մարգարիտի գլուխ արժեքի հետ\nվզնոցի շրջանաձև բնույթի պատճառով:\n\nՎերադարձնում է:\nԱմբողջ թիվ, որը ներկայացնում է առավելագույն էներգիան, որը կարող է ստացվել բոլոր մարգարիտները օպտիմալ միացնելով:\n\nՕրինակներ:\n>>> max_energy([2, 3, 5, 10])\n710\nԱյս հաջորդականությունը ներկայացնում է մարգարիտներ արժեքներով (2,3), (3,5), (5,10), (10,2): Առավելագույն էներգիան,\nորն ազատվում է նրանց օպտիմալ կարգով միացնելիս, 710 է:\n\n>>> max_energy([1, 2, 3, 4])\n48\nԱյս հաջորդականությունը ներկայացնում է մարգարիտներ արժեքներով (1,2), (2,3), (3,4), (4,1): Առավելագույն էներգիան,\nորն ազատվում է նրանց օպտիմալ կարգով միացնելիս, 48 է:", "bn": "নেকলেসের মুক্তো একত্রিত করে যে সর্বাধিক শক্তি মুক্তি পেতে পারে তা গণনা করুন।\n\nফাংশনটি একটি পূর্ণসংখ্যার তালিকা গ্রহণ করে যা নেকলেসের মুক্তোগুলির শক্তি উপস্থাপন করে, যেখানে প্রতিটি মুক্তোর একটি মাথা এবং একটি লেজের মান থাকে। প্রতিটি মুক্তোর মাথার মান অবশ্যই পরবর্তী মুক্তোর লেজের মানের সাথে মিলে যেতে হবে। নেকলেসটি বৃত্তাকার, এবং দুটি সংলগ্ন মুক্তো একত্রিত করলে যে শক্তি মুক্তি পায় তা প্রথম মুক্তোর মাথার মান, মিলের মান এবং দ্বিতীয় মুক্তোর লেজের মানের গুণফলের সমান।\n\nসর্বাধিক শক্তি মুক্তি পেতে, ফাংশনটি মুক্তো একত্রিত করার সমস্ত সম্ভাব্য ক্রম বিবেচনা করে এবং গতিশীল প্রোগ্রামিং ব্যবহার করে সর্বাধিক শক্তি অর্জনযোগ্যতা গণনা করে।\n\nআর্গস:\nbeads: পূর্ণসংখ্যার একটি তালিকা যেখানে প্রতিটি পূর্ণসংখ্যা একটি মুক্তোর মাথার মান এবং পূর্ববর্তী মুক্তোর লেজের মান উপস্থাপন করে। নেকলেসের বৃত্তাকার প্রকৃতির কারণে শেষ মুক্তোর লেজের মান প্রথম মুক্তোর মাথার মানের সাথে মিলে যাওয়া অনুমান করা হয়।\n\nরিটার্নস:\nএকটি পূর্ণসংখ্যা যা সমস্ত মুক্তোকে সর্বোত্তমভাবে একত্রিত করে প্রাপ্ত সর্বাধিক শক্তি উপস্থাপন করে।\n\nউদাহরণ:\n>>> max_energy([2, 3, 5, 10])\n710\nএই ক্রমটি (2,3), (3,5), (5,10), (10,2) মানের মুক্তো উপস্থাপন করে। তাদের সর্বোত্তম ক্রমে একত্রিত করে মুক্তি পাওয়া সর্বাধিক শক্তি 710।\n\n>>> max_energy([1, 2, 3, 4])\n48\nএই ক্রমটি (1,2), (2,3), (3,4), (4,1) মানের মুক্তো উপস্থাপন করে। তাদের সর্বোত্তম ক্রমে একত্রিত করে মুক্তি পাওয়া সর্বাধিক শক্তি 48।", "bg": "Изчислете максималната енергия, която може да бъде освободена чрез сливане на мъниста на огърлица.\n\nФункцията приема списък от цели числа, представляващи енергийните мъниста на огърлица, където\nвсяко мънисто има стойност на глава и опашка. Стойността на главата на всяко мънисто трябва да съвпада със стойността на опашката\nна следващото мънисто в последователността. Огърлицата е кръгова, и сливането на две съседни\nмъниста освобождава енергия, равна на произведението от стойността на главата на първото мънисто, съвпадащата\nстойност и стойността на опашката на второто мънисто.\n\nЗа да се намери максималното освобождаване на енергия, функцията разглежда всички възможни редове на сливане на мънистата\nи използва динамично програмиране за изчисляване на максималната енергия, която може да бъде получена.\n\nАргументи:\nbeads: Списък от цели числа, където всяко цяло число представлява стойността на главата на мънисто и\nстойността на опашката на предишното мънисто. Стойността на опашката на последното мънисто се предполага,\nче съвпада със стойността на главата на първото мънисто поради кръговата природа на огърлицата.\n\nВръща:\nЦяло число, представляващо максималната енергия, която може да бъде получена чрез оптимално сливане на всички мъниста.\n\nПримери:\n>>> max_energy([2, 3, 5, 10])\n710\nТази последователност представлява мъниста със стойности (2,3), (3,5), (5,10), (10,2). Максималната енергия,\nосвободена чрез сливането им в оптимален ред, е 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nТази последователност представлява мъниста със стойности (1,2), (2,3), (3,4), (4,1). Максималната енергия,\nосвободена чрез сливането им в оптимален ред, е 48.", "zh": "计算通过合并项链上的珠子可以释放的最大能量。\n\n该函数接受一个整数列表，表示项链上的能量珠子，其中每个珠子都有一个头部和尾部值。每个珠子的头部值必须与序列中下一个珠子的尾部值匹配。项链是环形的，合并两个相邻的珠子释放的能量等于第一个珠子的头部值、匹配值和第二个珠子的尾部值的乘积。\n\n为了找到最大能量释放，函数考虑合并珠子的所有可能顺序，并使用动态规划计算可获得的最大能量。\n\n参数：\nbeads: 一个整数列表，其中每个整数表示一个珠子的头部值和前一个珠子的尾部值。由于项链的环形特性，假定最后一个珠子的尾部值与第一个珠子的头部值匹配。\n\n返回：\n一个整数，表示通过最佳合并所有珠子可以获得的最大能量。\n\n示例：\n>>> max_energy([2, 3, 5, 10])\n710\n这个序列表示值为 (2,3), (3,5), (5,10), (10,2) 的珠子。通过以最佳顺序合并它们释放的最大能量是 710。\n\n>>> max_energy([1, 2, 3, 4])\n48\n这个序列表示值为 (1,2), (2,3), (3,4), (4,1) 的珠子。通过以最佳顺序合并它们释放的最大能量是 48。", "fr": "Calculer l'énergie maximale pouvant être libérée en fusionnant des perles sur un collier.\n\nLa fonction prend une liste d'entiers représentant les perles d'énergie sur un collier, où\nchaque perle a une valeur de tête et de queue. La valeur de tête de chaque perle doit correspondre à la valeur de queue\nde la perle suivante dans la séquence. Le collier est circulaire, et la fusion de deux perles adjacentes\nlibère une énergie égale au produit de la valeur de tête de la première perle, de la valeur correspondante,\net de la valeur de queue de la seconde perle.\n\nPour trouver la libération d'énergie maximale, la fonction considère tous les ordres possibles de fusion des perles\net utilise la programmation dynamique pour calculer l'énergie maximale obtenable.\n\nArgs:\nbeads: Une liste d'entiers où chaque entier représente la valeur de tête d'une perle et\nla valeur de queue de la perle précédente. La valeur de queue de la dernière perle est supposée\ncorrespondre à la valeur de tête de la première perle en raison de la nature circulaire du collier.\n\nReturns:\nUn entier représentant l'énergie maximale pouvant être obtenue en fusionnant de manière optimale toutes les perles.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nCette séquence représente des perles avec des valeurs (2,3), (3,5), (5,10), (10,2). L'énergie maximale\nlibérée en les fusionnant dans l'ordre optimal est 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nCette séquence représente des perles avec des valeurs (1,2), (2,3), (3,4), (4,1). L'énergie maximale\nlibérée en les fusionnant dans l'ordre optimal est 48.", "de": "Berechne die maximale Energie, die durch das Zusammenführen von Perlen auf einer Halskette freigesetzt werden kann.\n\nDie Funktion nimmt eine Liste von ganzen Zahlen, die die Energieperlen auf einer Halskette darstellen, wobei jede Perle einen Kopf- und einen Schwanzwert hat. Der Kopfwert jeder Perle muss mit dem Schwanzwert der nächsten Perle in der Sequenz übereinstimmen. Die Halskette ist kreisförmig, und das Zusammenführen von zwei benachbarten Perlen setzt Energie frei, die dem Produkt des Kopfwerts der ersten Perle, dem passenden Wert und dem Schwanzwert der zweiten Perle entspricht.\n\nUm die maximale Energiefreisetzung zu finden, berücksichtigt die Funktion alle möglichen Reihenfolgen des Zusammenführens von Perlen und verwendet dynamische Programmierung, um die maximal erreichbare Energie zu berechnen.\n\nArgs:\nbeads: Eine Liste von ganzen Zahlen, wobei jede ganze Zahl den Kopfwert einer Perle und den Schwanzwert der vorherigen Perle darstellt. Der Schwanzwert der letzten Perle wird aufgrund der kreisförmigen Natur der Halskette als passend zum Kopfwert der ersten Perle angenommen.\n\nReturns:\nEine ganze Zahl, die die maximale Energie darstellt, die durch optimales Zusammenführen aller Perlen gewonnen werden kann.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nDiese Sequenz repräsentiert Perlen mit Werten (2,3), (3,5), (5,10), (10,2). Die maximale Energie, die durch das Zusammenführen in optimaler Reihenfolge freigesetzt wird, beträgt 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nDiese Sequenz repräsentiert Perlen mit Werten (1,2), (2,3), (3,4), (4,1). Die maximale Energie, die durch das Zusammenführen in optimaler Reihenfolge freigesetzt wird, beträgt 48.", "ha": "Ƙididdige mafi ƙarancin kuzari da za a iya saki ta hanyar haɗa beads a kan abin wuya.\n\nAikin yana ɗaukar jerin lambobi masu wakiltar beads na kuzari a kan abin wuya, inda\nkowanne bead yana da ƙimar kai da ƙimar wutsiya. Dole ne ƙimar kai ta kowanne bead ta dace da ƙimar wutsiya\nna bead na gaba a jerin. Abin wuya yana da zagaye, kuma haɗa beads guda biyu masu makwabtaka\nyana sakin kuzari daidai da samfurin ƙimar kai na bead na farko, ƙimar da ta dace, da ƙimar wutsiya na bead na biyu.\n\nDon nemo mafi ƙarancin sakin kuzari, aikin yana la'akari da dukkan yiwuwar jeri na haɗa beads\nkuma yana amfani da shirye-shiryen motsi don ƙididdige mafi ƙarancin kuzari da za a iya samu.\n\nArgs:\nbeads: Jerin lambobi inda kowanne lamba yana wakiltar ƙimar kai na bead da\nƙimar wutsiya na bead na baya. Ana ɗauka cewa ƙimar wutsiya na bead na ƙarshe tana dacewa\nda ƙimar kai na bead na farko saboda yanayin zagaye na abin wuya.\n\nReturns:\nWani lamba wanda ke wakiltar mafi ƙarancin kuzari da za a iya samu ta hanyar haɗa duk beads cikin hikima.\n\nMisalai:\n>>> max_energy([2, 3, 5, 10])\n710\nWannan jerin yana wakiltar beads tare da ƙimar (2,3), (3,5), (5,10), (10,2). Mafi ƙarancin kuzari\nda aka saki ta hanyar haɗa su cikin jeri mafi kyau shine 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nWannan jerin yana wakiltar beads tare da ƙimar (1,2), (2,3), (3,4), (4,1). Mafi ƙarancin kuzari\nda aka saki ta hanyar haɗa su cikin jeri mafi kyau shine 48.", "hi": "माला पर मोतियों को मिलाने से जारी की जा सकने वाली अधिकतम ऊर्जा की गणना करें।\n\nयह फ़ंक्शन एक पूर्णांकों की सूची लेता है जो माला पर ऊर्जा मोतियों का प्रतिनिधित्व करती है, जहाँ प्रत्येक मोती का एक सिर और एक पूंछ मान होता है। प्रत्येक मोती का सिर मान अनुक्रम में अगले मोती के पूंछ मान से मेल खाना चाहिए। माला वृत्ताकार है, और दो आसन्न मोतियों को मिलाने से जारी ऊर्जा पहले मोती के सिर मान, मिलान मान, और दूसरे मोती के पूंछ मान के गुणनफल के बराबर होती है।\n\nअधिकतम ऊर्जा जारी करने के लिए, फ़ंक्शन मोतियों को मिलाने के सभी संभावित क्रमों पर विचार करता है और गतिशील प्रोग्रामिंग का उपयोग करके प्राप्त की जा सकने वाली अधिकतम ऊर्जा की गणना करता है।\n\nआर्ग्स:\nbeads: पूर्णांकों की एक सूची जहाँ प्रत्येक पूर्णांक एक मोती के सिर मान और पिछले मोती के पूंछ मान का प्रतिनिधित्व करता है। माला की वृत्ताकार प्रकृति के कारण अंतिम मोती का पूंछ मान पहले मोती के सिर मान से मेल खाने वाला माना जाता है।\n\nवापसी:\nएक पूर्णांक जो सभी मोतियों को अनुकूल रूप से मिलाकर प्राप्त की जा सकने वाली अधिकतम ऊर्जा का प्रतिनिधित्व करता है।\n\nउदाहरण:\n>>> max_energy([2, 3, 5, 10])\n710\nयह अनुक्रम (2,3), (3,5), (5,10), (10,2) मानों वाले मोतियों का प्रतिनिधित्व करता है। उन्हें अनुकूल क्रम में मिलाने से जारी अधिकतम ऊर्जा 710 है।\n\n>>> max_energy([1, 2, 3, 4])\n48\nयह अनुक्रम (1,2), (2,3), (3,4), (4,1) मानों वाले मोतियों का प्रतिनिधित्व करता है। उन्हें अनुकूल क्रम में मिलाने से जारी अधिकतम ऊर्जा 48 है।", "hu": "Számítsa ki a maximális energiát, amely a gyöngyök összeolvasztásával szabadulhat fel egy nyakláncon.\n\nA függvény egy egész számokból álló listát vesz át, amely a nyaklánc gyöngyeinek energiáját képviseli, ahol minden gyöngynek van egy fej- és egy farokértéke. Minden gyöngy fejértékének meg kell egyeznie a következő gyöngy farokértékével a sorozatban. A nyaklánc körkörös, és két szomszédos gyöngy összeolvasztása energiát szabadít fel, amely megegyezik az első gyöngy fejértékének, az egyező értéknek és a második gyöngy farokértékének szorzatával.\n\nA maximális energiafelszabadulás megtalálásához a függvény figyelembe veszi a gyöngyök összeolvasztásának összes lehetséges sorrendjét, és dinamikus programozást használ a maximálisan elérhető energia kiszámításához.\n\nArgs:\nbeads: Egy egész számokból álló lista, ahol minden egész szám egy gyöngy fejértékét és az előző gyöngy farokértékét képviseli. Az utolsó gyöngy farokértéke feltételezhetően megegyezik az első gyöngy fejértékével a nyaklánc körkörös jellege miatt.\n\nReturns:\nEgy egész szám, amely az összes gyöngy optimális összeolvasztásával elérhető maximális energiát képviseli.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nEz a sorozat a (2,3), (3,5), (5,10), (10,2) értékű gyöngyöket képviseli. Az optimális sorrendben történő összeolvasztásuk által felszabadított maximális energia 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nEz a sorozat a (1,2), (2,3), (3,4), (4,1) értékű gyöngyöket képviseli. Az optimális sorrendben történő összeolvasztásuk által felszabadított maximális energia 48.", "es": "Calcular la energía máxima que se puede liberar al fusionar cuentas en un collar.\n\nLa función toma una lista de enteros que representan las cuentas de energía en un collar, donde\ncada cuenta tiene un valor de cabeza y un valor de cola. El valor de cabeza de cada cuenta debe coincidir con el valor de cola de la siguiente cuenta en la secuencia. El collar es circular, y fusionar dos cuentas adyacentes libera energía igual al producto del valor de cabeza de la primera cuenta, el valor coincidente y el valor de cola de la segunda cuenta.\n\nPara encontrar la liberación máxima de energía, la función considera todos los órdenes posibles de fusión de cuentas y utiliza programación dinámica para calcular la energía máxima obtenible.\n\nArgumentos:\nbeads: Una lista de enteros donde cada entero representa el valor de cabeza de una cuenta y\nel valor de cola de la cuenta anterior. Se supone que el valor de cola de la última cuenta coincide\ncon el valor de cabeza de la primera cuenta debido a la naturaleza circular del collar.\n\nDevuelve:\nUn entero que representa la energía máxima que se puede obtener al fusionar óptimamente todas las cuentas.\n\nEjemplos:\n>>> max_energy([2, 3, 5, 10])\n710\nEsta secuencia representa cuentas con valores (2,3), (3,5), (5,10), (10,2). La energía máxima\nliberada al fusionarlas en el orden óptimo es 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nEsta secuencia representa cuentas con valores (1,2), (2,3), (3,4), (4,1). La energía máxima\nliberada al fusionarlas en el orden óptimo es 48.", "arb": "حساب الحد الأقصى للطاقة التي يمكن إطلاقها عن طريق دمج الخرزات في عقد.\n\nتأخذ الدالة قائمة من الأعداد الصحيحة التي تمثل خرزات الطاقة على العقد، حيث\nكل خرزة لها قيمة رأس وقيمة ذيل. يجب أن تتطابق قيمة الرأس لكل خرزة مع قيمة الذيل\nللخرزة التالية في التسلسل. العقد دائري، ودمج خرزتين متجاورتين يطلق طاقة تساوي حاصل ضرب قيمة الرأس للخرزة الأولى، والقيمة المطابقة، وقيمة الذيل للخرزة الثانية.\n\nلإيجاد الحد الأقصى لإطلاق الطاقة، تأخذ الدالة في الاعتبار جميع أوامر دمج الخرزات الممكنة\nوتستخدم البرمجة الديناميكية لحساب الحد الأقصى للطاقة الممكن الحصول عليها.\n\nالمعطيات:\nbeads: قائمة من الأعداد الصحيحة حيث يمثل كل عدد صحيح قيمة الرأس لخرزة و\nقيمة الذيل للخرزة السابقة. يُفترض أن تتطابق قيمة الذيل للخرزة الأخيرة\nمع قيمة الرأس للخرزة الأولى بسبب الطبيعة الدائرية للعقد.\n\nالقيم المعادة:\nعدد صحيح يمثل الحد الأقصى للطاقة التي يمكن الحصول عليها عن طريق دمج جميع الخرزات بشكل مثالي.\n\nأمثلة:\n>>> max_energy([2, 3, 5, 10])\n710\nيمثل هذا التسلسل خرزات بقيم (2,3)، (3,5)، (5,10)، (10,2). الحد الأقصى للطاقة\nالتي يتم إطلاقها عن طريق دمجها بالترتيب الأمثل هو 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nيمثل هذا التسلسل خرزات بقيم (1,2)، (2,3)، (3,4)، (4,1). الحد الأقصى للطاقة\nالتي يتم إطلاقها عن طريق دمجها بالترتيب الأمثل هو 48.", "sw": "Hesabu nishati ya juu inayoweza kutolewa kwa kuunganisha shanga kwenye mkufu.\n\nKazi hii inachukua orodha ya nambari za mzima zinazowakilisha shanga za nishati kwenye mkufu, ambapo\nkila shanga ina thamani ya kichwa na mkia. Thamani ya kichwa ya kila shanga lazima ilingane na thamani ya mkia\nya shanga inayofuata katika mlolongo. Mkufu ni wa mviringo, na kuunganisha shanga mbili zilizo karibu\nhutoa nishati sawa na bidhaa ya thamani ya kichwa ya shanga ya kwanza, thamani inayolingana, na thamani ya mkia ya shanga ya pili.\n\nIli kupata utoaji wa nishati ya juu, kazi inazingatia mpangilio wote unaowezekana wa kuunganisha shanga\nna hutumia programu ya nguvu kuhesabu nishati ya juu inayoweza kupatikana.\n\nHoja:\nbeads: Orodha ya nambari za mzima ambapo kila nambari inawakilisha thamani ya kichwa ya shanga na\nthamani ya mkia ya shanga iliyotangulia. Thamani ya mkia ya shanga ya mwisho inachukuliwa\nkulingana na thamani ya kichwa ya shanga ya kwanza kutokana na asili ya mviringo ya mkufu.\n\nInarejesha:\nNambari ya mzima inayowakilisha nishati ya juu inayoweza kupatikana kwa kuunganisha shanga zote kwa njia bora.\n\nMifano:\n>>> max_energy([2, 3, 5, 10])\n710\nMlolongo huu unawakilisha shanga zenye thamani (2,3), (3,5), (5,10), (10,2). Nishati ya juu\ninayotolewa kwa kuziunganisha kwa mpangilio bora ni 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nMlolongo huu unawakilisha shanga zenye thamani (1,2), (2,3), (3,4), (4,1). Nishati ya juu\ninayotolewa kwa kuziunganisha kwa mpangilio bora ni 48.", "tr": "Boncukları bir kolyede birleştirerek serbest bırakılabilecek maksimum enerjiyi hesaplayın.\n\nFonksiyon, bir kolyedeki enerji boncuklarını temsil eden bir tamsayı listesini alır, burada\nher boncuğun bir baş ve bir kuyruk değeri vardır. Her boncuğun baş değeri, dizideki bir sonraki\nboncuğun kuyruk değeriyle eşleşmelidir. Kolyenin yapısı daireseldir ve iki bitişik boncuğun\nbirleştirilmesi, ilk boncuğun baş değeri, eşleşen değer ve ikinci boncuğun kuyruk değerinin\nçarpımına eşit enerji serbest bırakır.\n\nMaksimum enerji salınımını bulmak için, fonksiyon boncukları birleştirmenin tüm olası sıralarını\ndüşünür ve elde edilebilecek maksimum enerjiyi hesaplamak için dinamik programlama kullanır.\n\nArgümanlar:\nbeads: Her tamsayının bir boncuğun baş değerini ve\nönceki boncuğun kuyruk değerini temsil ettiği bir tamsayı listesi. Kolye yapısının\ndairesel doğası nedeniyle son boncuğun kuyruk değerinin ilk boncuğun baş değeriyle eşleştiği varsayılır.\n\nDöndürür:\nTüm boncukları optimal bir şekilde birleştirerek elde edilebilecek maksimum enerjiyi temsil eden bir tamsayı.\n\nÖrnekler:\n>>> max_energy([2, 3, 5, 10])\n710\nBu dizi, değerleri (2,3), (3,5), (5,10), (10,2) olan boncukları temsil eder. Bunları optimal sırayla\nbirleştirerek serbest bırakılan maksimum enerji 710'dur.\n\n>>> max_energy([1, 2, 3, 4])\n48\nBu dizi, değerleri (1,2), (2,3), (3,4), (4,1) olan boncukları temsil eder. Bunları optimal sırayla\nbirleştirerek serbest bırakılan maksimum enerji 48'dir.", "vi": "Tính toán năng lượng tối đa có thể được giải phóng bằng cách hợp nhất các hạt trên một chuỗi hạt.\n\nHàm nhận vào một danh sách các số nguyên đại diện cho các hạt năng lượng trên một chuỗi hạt, trong đó\nmỗi hạt có một giá trị đầu và một giá trị đuôi. Giá trị đầu của mỗi hạt phải khớp với giá trị đuôi\ncủa hạt tiếp theo trong chuỗi. Chuỗi hạt là vòng tròn, và việc hợp nhất hai hạt liền kề\ngiải phóng năng lượng bằng tích của giá trị đầu của hạt thứ nhất, giá trị khớp, và giá trị đuôi của hạt thứ hai.\n\nĐể tìm năng lượng giải phóng tối đa, hàm xem xét tất cả các thứ tự hợp nhất hạt có thể có\nvà sử dụng lập trình động để tính toán năng lượng tối đa có thể đạt được.\n\nTham số:\nbeads: Một danh sách các số nguyên trong đó mỗi số nguyên đại diện cho giá trị đầu của một hạt và\ngiá trị đuôi của hạt trước đó. Giá trị đuôi của hạt cuối cùng được giả định\nkhớp với giá trị đầu của hạt đầu tiên do tính chất vòng tròn của chuỗi hạt.\n\nTrả về:\nMột số nguyên đại diện cho năng lượng tối đa có thể đạt được bằng cách hợp nhất tối ưu tất cả các hạt.\n\nVí dụ:\n>>> max_energy([2, 3, 5, 10])\n710\nChuỗi này đại diện cho các hạt có giá trị (2,3), (3,5), (5,10), (10,2). Năng lượng tối đa\nđược giải phóng bằng cách hợp nhất chúng theo thứ tự tối ưu là 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nChuỗi này đại diện cho các hạt có giá trị (1,2), (2,3), (3,4), (4,1). Năng lượng tối đa\nđược giải phóng bằng cách hợp nhất chúng theo thứ tự tối ưu là 48.", "id": "Hitung energi maksimum yang dapat dilepaskan dengan menggabungkan manik-manik pada kalung.\n\nFungsi ini menerima daftar bilangan bulat yang mewakili manik-manik energi pada kalung, di mana setiap manik memiliki nilai kepala dan ekor. Nilai kepala dari setiap manik harus sesuai dengan nilai ekor dari manik berikutnya dalam urutan. Kalung ini berbentuk melingkar, dan menggabungkan dua manik yang berdekatan melepaskan energi yang setara dengan hasil kali dari nilai kepala manik pertama, nilai yang cocok, dan nilai ekor manik kedua.\n\nUntuk menemukan pelepasan energi maksimum, fungsi ini mempertimbangkan semua urutan penggabungan manik-manik yang mungkin dan menggunakan pemrograman dinamis untuk menghitung energi maksimum yang dapat diperoleh.\n\nArgs:\nbeads: Daftar bilangan bulat di mana setiap bilangan bulat mewakili nilai kepala dari sebuah manik dan nilai ekor dari manik sebelumnya. Nilai ekor dari manik terakhir diasumsikan cocok dengan nilai kepala dari manik pertama karena sifat melingkar dari kalung.\n\nReturns:\nSebuah bilangan bulat yang mewakili energi maksimum yang dapat diperoleh dengan menggabungkan semua manik secara optimal.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nUrutan ini mewakili manik-manik dengan nilai (2,3), (3,5), (5,10), (10,2). Energi maksimum yang dilepaskan dengan menggabungkannya dalam urutan optimal adalah 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nUrutan ini mewakili manik-manik dengan nilai (1,2), (2,3), (3,4), (4,1). Energi maksimum yang dilepaskan dengan menggabungkannya dalam urutan optimal adalah 48.", "ja": "ネックレスのビーズを合体させることで放出される最大エネルギーを計算します。\n\nこの関数はネックレス上のエネルギービーズを表す整数のリストを受け取ります。各ビーズはヘッドとテールの値を持ち、各ビーズのヘッド値は次のビーズのテール値と一致する必要があります。ネックレスは円形であり、隣接する2つのビーズを合体させると、最初のビーズのヘッド値、マッチング値、2番目のビーズのテール値の積に等しいエネルギーが放出されます。\n\n最大エネルギー放出を見つけるために、関数はビーズを合体させるすべての可能な順序を考慮し、動的計画法を使用して得られる最大エネルギーを計算します。\n\nArgs:\nbeads: 各整数がビーズのヘッド値および前のビーズのテール値を表す整数のリスト。\nネックレスの円形の性質により、最後のビーズのテール値は最初のビーズのヘッド値と一致すると仮定されます。\n\nReturns:\nすべてのビーズを最適に合体させることで得られる最大エネルギーを表す整数。\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nこのシーケンスは、値が (2,3), (3,5), (5,10), (10,2) のビーズを表します。最適な順序で合体させることで放出される最大エネルギーは 710 です。\n\n>>> max_energy([1, 2, 3, 4])\n48\nこのシーケンスは、値が (1,2), (2,3), (3,4), (4,1) のビーズを表します。最適な順序で合体させることで放出される最大エネルギーは 48 です。", "ko": "구슬을 합쳐서 방출할 수 있는 최대 에너지를 계산합니다.\n\n이 함수는 목걸이에 있는 에너지 구슬을 나타내는 정수 리스트를 입력으로 받습니다. 각 구슬은 머리와 꼬리 값을 가지고 있으며, 각 구슬의 머리 값은 다음 구슬의 꼬리 값과 일치해야 합니다. 목걸이는 원형이며, 인접한 두 구슬을 합치면 첫 번째 구슬의 머리 값, 일치하는 값, 두 번째 구슬의 꼬리 값의 곱에 해당하는 에너지가 방출됩니다.\n\n최대 에너지 방출을 찾기 위해, 함수는 구슬을 합치는 모든 가능한 순서를 고려하고 동적 프로그래밍을 사용하여 얻을 수 있는 최대 에너지를 계산합니다.\n\n인수:\nbeads: 각 정수가 구슬의 머리 값을 나타내고 이전 구슬의 꼬리 값을 나타내는 정수 리스트입니다. 목걸이의 원형 특성 때문에 마지막 구슬의 꼬리 값은 첫 번째 구슬의 머리 값과 일치한다고 가정합니다.\n\n반환:\n모든 구슬을 최적으로 합쳐서 얻을 수 있는 최대 에너지를 나타내는 정수입니다.\n\n예제:\n>>> max_energy([2, 3, 5, 10])\n710\n이 시퀀스는 값이 (2,3), (3,5), (5,10), (10,2)인 구슬을 나타냅니다. 최적의 순서로 합쳐서 방출되는 최대 에너지는 710입니다.\n\n>>> max_energy([1, 2, 3, 4])\n48\n이 시퀀스는 값이 (1,2), (2,3), (3,4), (4,1)인 구슬을 나타냅니다. 최적의 순서로 합쳐서 방출되는 최대 에너지는 48입니다.", "ml": "മാലയിലെ മണികൾ ലയിപ്പിച്ച്‌ പുറത്തുവരുന്ന പരമാവധി ഊർജ്ജം കണക്കാക്കുക.\n\nഫങ്ഷൻ ഒരു ലിസ്റ്റ് പാരാമീറ്ററായി സ്വീകരിക്കുന്നു, ഇത് മാലയിലെ ഊർജ്ജ മണികളെ പ്രതിനിധീകരിക്കുന്നു, ഇവിടെ ഓരോ മണിക്കും ഒരു തലയും വാലുമുണ്ട്. ഓരോ മണിയുടെ തല മൂല്യം അടുത്ത മണിയുടെ വാൽ മൂല്യവുമായി പൊരുത്തപ്പെടണം. മാല വൃത്താകൃതിയിലുള്ളതാണ്, കൂടെ ചേർന്നിരിക്കുന്ന രണ്ട് മണികളെ ലയിപ്പിക്കുമ്പോൾ പുറപ്പെടുന്ന ഊർജ്ജം ആദ്യ മണിയുടെ തല മൂല്യത്തിന്റെ, പൊരുത്തപ്പെടുന്ന മൂല്യത്തിന്റെ, രണ്ടാം മണിയുടെ വാൽ മൂല്യത്തിന്റെ ഗുണഫലത്തിനും തുല്യമാണ്.\n\nപരമാവധി ഊർജ്ജം പുറത്തെടുക്കാൻ, ഫങ്ഷൻ എല്ലാ възмож്യമായ ലയിപ്പിക്കൽ ക്രമങ്ങളും പരിഗണിക്കുന്നു, ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് പരമാവധി ലഭ്യമായ ഊർജ്ജം കണക്കാക്കുന്നു.\n\nആർഗ്ഗുകൾ:\nbeads: ഒരു ലിസ്റ്റ് ഇന്റീജറുകൾ, ഓരോ ഇന്റീജറും ഒരു മണിയുടെ തല മൂല്യവും മുൻ മണിയുടെ വാൽ മൂല്യവും പ്രതിനിധീകരിക്കുന്നു. മാലയുടെ വൃത്താകൃതിയുടെ സ്വഭാവം കാരണം അവസാന മണിയുടെ വാൽ മൂല്യം ആദ്യ മണിയുടെ തല മൂല്യവുമായി പൊരുത്തപ്പെടുന്നുവെന്ന് കരുതുന്നു.\n\nമടക്കം:\nമണികളെ ഒപ്റ്റിമൽ ക്രമത്തിൽ ലയിപ്പിച്ച്‌ ലഭിക്കാവുന്ന പരമാവധി ഊർജ്ജത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു ഇന്റീജർ.\n\nഉദാഹരണങ്ങൾ:\n>>> max_energy([2, 3, 5, 10])\n710\nഈ ക്രമം (2,3), (3,5), (5,10), (10,2) മൂല്യങ്ങളുള്ള മണികളെ പ്രതിനിധീകരിക്കുന്നു. അവയെ ഒപ്റ്റിമൽ ക്രമത്തിൽ ലയിപ്പിച്ച്‌ പുറത്തുവരുന്ന പരമാവധി ഊർജ്ജം 710 ആണ്.\n\n>>> max_energy([1, 2, 3, 4])\n48\nഈ ക്രമം (1,2), (2,3), (3,4), (4,1) മൂല്യങ്ങളുള്ള മണികളെ പ്രതിനിധീകരിക്കുന്നു. അവയെ ഒപ്റ്റിമൽ ക്രമത്തിൽ ലയിപ്പിച്ച്‌ പുറത്തുവരുന്ന പരമാവധി ഊർജ്ജം 48 ആണ്.", "fa": "محاسبه حداکثر انرژی که می‌تواند با ترکیب مهره‌ها در یک گردنبند آزاد شود.\n\nتابع یک لیست از اعداد صحیح را می‌گیرد که نشان‌دهنده مهره‌های انرژی در یک گردنبند هستند، به طوری که هر مهره دارای یک مقدار سر و یک مقدار دم است. مقدار سر هر مهره باید با مقدار دم مهره بعدی در دنباله مطابقت داشته باشد. گردنبند دایره‌ای است و ترکیب دو مهره مجاور انرژی‌ای برابر با حاصل‌ضرب مقدار سر مهره اول، مقدار مطابقت و مقدار دم مهره دوم آزاد می‌کند.\n\nبرای یافتن حداکثر آزادسازی انرژی، تابع تمام ترتیب‌های ممکن ترکیب مهره‌ها را در نظر می‌گیرد و از برنامه‌نویسی پویا برای محاسبه حداکثر انرژی قابل دستیابی استفاده می‌کند.\n\nArgs:\nbeads: لیستی از اعداد صحیح که هر عدد نشان‌دهنده مقدار سر یک مهره و مقدار دم مهره قبلی است. مقدار دم آخرین مهره به دلیل طبیعت دایره‌ای گردنبند فرض می‌شود که با مقدار سر اولین مهره مطابقت دارد.\n\nReturns:\nیک عدد صحیح که نشان‌دهنده حداکثر انرژی است که می‌توان با ترکیب بهینه تمام مهره‌ها به دست آورد.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nاین دنباله نشان‌دهنده مهره‌هایی با مقادیر (2,3)، (3,5)، (5,10)، (10,2) است. حداکثر انرژی آزاد شده با ترکیب آنها به ترتیب بهینه 710 است.\n\n>>> max_energy([1, 2, 3, 4])\n48\nاین دنباله نشان‌دهنده مهره‌هایی با مقادیر (1,2)، (2,3)، (3,4)، (4,1) است. حداکثر انرژی آزاد شده با ترکیب آنها به ترتیب بهینه 48 است."}}
{"task_id": "Python/20", "prompt": {"en": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "sq": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Konverton një listë të koeficientëve të polinomit në një përfaqësim të formatuar si varg.\n\n    Funksioni merr shkallën më të lartë `n` të polinomit dhe një listë të koeficientëve `coeffs`,\n    të cilët janë të renditur nga termi me shkallën më të lartë deri te termi konstant. Ai kthen një varg që\n    përfaqëson polinomin me rregullat e mëposhtme:\n    - Termat me një koeficient zero janë të lënë jashtë.\n    - Shenja e secilit term përcaktohet (+ për pozitiv, - për negativ), pa '+' në fillim për termi i parë.\n    - Vlera absolute e koeficientit tregohet përveç nëse është 1 dhe termi përfshin variablën `x`.\n    - Pjesa e variablës formatohet bazuar në shkallën e saj; `x^degree` për shkallë > 1, `x` për shkallë 1, dhe\n      asgjë për shkallë 0 (termi konstant).\n    - Termat janë të bashkuar pa hapësira shtesë, duke filluar me termi me shkallën më të lartë.\n\n    Args:\n        n (int): Shkalla më e lartë e polinomit.\n        coeffs (List[int]): Një listë e koeficientëve, duke filluar me koeficientin e termit me shkallën më të lartë.\n\n    Returns:\n        str: Përfaqësimi si varg i polinomit.\n\n    Shembuj:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "hy": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Փոխակերպում է բազմանդամի գործակիցների ցուցակը ձևաչափված տողային ներկայացման:\n\n    Ֆունկցիան ընդունում է բազմանդամի ամենաբարձր աստիճանը `n` և գործակիցների ցուցակը `coeffs`,\n    որոնք դասավորված են ամենաբարձր աստիճանի անդամից մինչև հաստատուն անդամ: Այն վերադարձնում է տող, որը\n    ներկայացնում է բազմանդամը հետևյալ կանոններով.\n    - Գործակիցը զրո ունեցող անդամները բաց են թողնվում:\n    - Յուրաքանչյուր անդամի նշանը որոշվում է (+ դրականների համար, - բացասականների համար), առաջին անդամի համար առանց առաջատար '+' նշանի:\n    - Գործակցի բացարձակ արժեքը ցուցադրվում է, եթե այն 1 չէ և անդամը ներառում է փոփոխական `x`:\n    - Փոփոխականի մասը ձևաչափվում է ըստ նրա աստիճանի; `x^աստիճան` աստիճան > 1-ի համար, `x` 1-ի համար, և\n      ոչինչ 0 աստիճանի համար (հաստատուն անդամ):\n    - Անդամները միացվում են առանց լրացուցիչ բացատների, սկսելով ամենաբարձր աստիճանի անդամից:\n\n    Արգումենտներ:\n        n (int): Բազմանդամի ամենաբարձր աստիճանը:\n        coeffs (List[int]): Գործակիցների ցուցակ, սկսած ամենաբարձր աստիճանի անդամի գործակցից:\n\n    Վերադարձնում է.\n        str: Բազմանդամի տողային ներկայացումը:\n\n    Օրինակներ.\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "bn": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    পলিনোমিয়াল সহগের একটি তালিকাকে একটি বিন্যাসিত স্ট্রিং প্রতিনিধিত্বে রূপান্তর করে।\n\n    ফাংশনটি পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি `n` এবং একটি সহগের তালিকা `coeffs` গ্রহণ করে,\n    যা সর্বোচ্চ ডিগ্রি টার্ম থেকে ধ্রুবক টার্ম পর্যন্ত সাজানো থাকে। এটি একটি স্ট্রিং ফেরত দেয় যা\n    নিম্নলিখিত নিয়মগুলির সাথে পলিনোমিয়ালকে উপস্থাপন করে:\n    - সহগ শূন্য হলে টার্মগুলি বাদ দেওয়া হয়।\n    - প্রতিটি টার্মের চিহ্ন নির্ধারিত হয় (+ ধনাত্মক জন্য, - ঋণাত্মক জন্য), প্রথম টার্মের জন্য কোন নেতৃস্থানীয় '+' নেই।\n    - সহগের পরম মান দেখানো হয় যদি না এটি 1 হয় এবং টার্মটিতে ভেরিয়েবল `x` অন্তর্ভুক্ত থাকে।\n    - ভেরিয়েবল অংশটি তার ডিগ্রির উপর ভিত্তি করে বিন্যাসিত হয়; ডিগ্রি > 1 এর জন্য `x^degree`, ডিগ্রি 1 এর জন্য `x`, এবং\n      ডিগ্রি 0 (ধ্রুবক টার্ম) এর জন্য কিছুই নয়।\n    - টার্মগুলি অতিরিক্ত স্পেস ছাড়াই যোগ করা হয়, সর্বোচ্চ ডিগ্রি টার্ম দিয়ে শুরু হয়।\n\n    Args:\n        n (int): পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি।\n        coeffs (List[int]): সহগের একটি তালিকা, সর্বোচ্চ ডিগ্রি টার্মের সহগ দিয়ে শুরু হয়।\n\n    Returns:\n        str: পলিনোমিয়ালের স্ট্রিং প্রতিনিধিত্ব।\n\n    উদাহরণ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "bg": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Преобразува списък от коефициенти на полином в форматирано текстово представяне.\n\n    Функцията приема най-високата степен `n` на полинома и списък с коефициенти `coeffs`,\n    които са подредени от термина с най-висока степен до константния термин. Връща низ, който\n    представлява полинома със следните правила:\n    - Термини с коефициент нула се пропускат.\n    - Знакът на всеки термин се определя (+ за положителен, - за отрицателен), без водещ '+' за първия термин.\n    - Показва се абсолютната стойност на коефициента, освен ако не е 1 и терминът включва променливата `x`.\n    - Частта с променливата се форматира според степента; `x^степен` за степен > 1, `x` за степен 1 и\n      нищо за степен 0 (константен термин).\n    - Термините се съединяват без допълнителни интервали, започвайки с термина с най-висока степен.\n\n    Args:\n        n (int): Най-високата степен на полинома.\n        coeffs (List[int]): Списък с коефициенти, започващ с коефициента на термина с най-висока степен.\n\n    Returns:\n        str: Текстовото представяне на полинома.\n\n    Примери:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "zh": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    将多项式系数列表转换为格式化的字符串表示。\n\n    该函数接收多项式的最高次数 `n` 和一个系数列表 `coeffs`，\n    系数按从最高次数项到常数项的顺序排列。它返回一个表示多项式的字符串，规则如下：\n    - 系数为零的项被省略。\n    - 每项的符号由其正负决定（正为+，负为-），首项不带前导'+'。\n    - 除非系数为1且该项包含变量`x`，否则显示系数的绝对值。\n    - 变量部分根据其次数进行格式化；对于次数大于1的项为`x^degree`，次数为1的项为`x`，\n      常数项不显示变量。\n    - 项之间没有额外的空格，按从最高次数项开始连接。\n\n    参数：\n        n (int): 多项式的最高次数。\n        coeffs (List[int]): 系数列表，从最高次数项的系数开始。\n\n    返回：\n        str: 多项式的字符串表示。\n\n    示例：\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "fr": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Convertit une liste de coefficients de polynôme en une représentation sous forme de chaîne formatée.\n\n    La fonction prend en entrée le degré le plus élevé `n` du polynôme et une liste de coefficients `coeffs`,\n    qui sont ordonnés du terme de degré le plus élevé au terme constant. Elle renvoie une chaîne qui\n    représente le polynôme avec les règles suivantes :\n    - Les termes avec un coefficient de zéro sont omis.\n    - Le signe de chaque terme est déterminé (+ pour positif, - pour négatif), sans '+' initial pour le premier terme.\n    - La valeur absolue du coefficient est affichée sauf si elle est 1 et que le terme inclut la variable `x`.\n    - La partie variable est formatée en fonction de son degré ; `x^degree` pour degree > 1, `x` pour degree 1, et\n      rien pour degree 0 (terme constant).\n    - Les termes sont joints sans espaces supplémentaires, en commençant par le terme de degré le plus élevé.\n\n    Args:\n        n (int): Le degré le plus élevé du polynôme.\n        coeffs (List[int]): Une liste de coefficients, en commençant par le coefficient du terme de degré le plus élevé.\n\n    Returns:\n        str: La représentation sous forme de chaîne du polynôme.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "de": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Konvertiert eine Liste von Polynomkoeffizienten in eine formatierte Zeichenfolgenrepräsentation.\n\n    Die Funktion nimmt den höchsten Grad `n` des Polynoms und eine Liste von Koeffizienten `coeffs` entgegen,\n    die von dem höchsten Grad-Term bis zum konstanten Term geordnet sind. Sie gibt eine Zeichenfolge zurück, die\n    das Polynom mit den folgenden Regeln darstellt:\n    - Terme mit einem Koeffizienten von Null werden weggelassen.\n    - Das Vorzeichen jedes Terms wird bestimmt (+ für positiv, - für negativ), ohne führendes '+' für den ersten Term.\n    - Der Absolutwert des Koeffizienten wird angezeigt, es sei denn, er ist 1 und der Term enthält die Variable `x`.\n    - Der Variablenteil wird basierend auf seinem Grad formatiert; `x^degree` für Grad > 1, `x` für Grad 1 und\n      nichts für Grad 0 (konstanter Term).\n    - Terme werden ohne zusätzliche Leerzeichen verbunden, beginnend mit dem höchsten Grad-Term.\n\n    Args:\n        n (int): Der höchste Grad des Polynoms.\n        coeffs (List[int]): Eine Liste von Koeffizienten, beginnend mit dem Koeffizienten des höchsten Grad-Terms.\n\n    Returns:\n        str: Die Zeichenfolgenrepräsentation des Polynoms.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "ha": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Canza jerin ƙididdigar polynomial zuwa tsarin rubutu mai tsari.\n\n    Aikin yana karɓar mafi girman darajar `n` na polynomial da jerin ƙididdiga `coeffs`,\n    waɗanda aka tsara daga mafi girman darajar zuwa ƙimar dindindin. Yana mayar da rubutu wanda\n    ke wakiltar polynomial tare da waɗannan ƙa'idojin:\n    - Ana cire sharuɗɗan da ke da ƙididdiga na sifili.\n    - Ana tantance alamar kowanne sharadi (+ don tabbatacce, - don korau), ba tare da '+' na farko ba don sharadi na farko.\n    - Ana nuna ƙimar cikakkiyar ƙididdiga sai dai idan yana da 1 kuma sharadin ya haɗa da canji `x`.\n    - Ana tsara ɓangaren canji bisa ga darajarsa; `x^degree` don degree > 1, `x` don degree 1, kuma\n      babu komai don degree 0 (sharadi na dindindin).\n    - Ana haɗa sharuɗɗan ba tare da ƙarin sarari ba, farawa da sharadi mafi girman daraja.\n\n    Args:\n        n (int): Mafi girman darajar polynomial.\n        coeffs (List[int]): Jerin ƙididdiga, farawa da ƙididdigar sharadi mafi girman daraja.\n\n    Returns:\n        str: Wakilcin rubutu na polynomial.\n\n    Misalai:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "hi": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    बहुपद गुणांक की एक सूची को स्वरूपित स्ट्रिंग प्रतिनिधित्व में परिवर्तित करता है।\n\n    फ़ंक्शन बहुपद की उच्चतम डिग्री `n` और गुणांक `coeffs` की एक सूची लेता है,\n    जो उच्चतम डिग्री पद से स्थिरांक पद तक क्रमबद्ध होते हैं। यह एक स्ट्रिंग लौटाता है जो\n    निम्नलिखित नियमों के साथ बहुपद का प्रतिनिधित्व करता है:\n    - शून्य गुणांक वाले पद छोड़ दिए जाते हैं।\n    - प्रत्येक पद का चिह्न निर्धारित होता है (+ सकारात्मक के लिए, - नकारात्मक के लिए), पहले पद के लिए कोई अग्रणी '+' नहीं होता।\n    - गुणांक का परिमाण दिखाया जाता है जब तक कि यह 1 न हो और पद में चर `x` शामिल हो।\n    - चर भाग को उसकी डिग्री के आधार पर स्वरूपित किया जाता है; `x^degree` डिग्री > 1 के लिए, `x` डिग्री 1 के लिए, और\n      कुछ नहीं डिग्री 0 (स्थिरांक पद) के लिए।\n    - पद बिना अतिरिक्त रिक्तियों के जोड़े जाते हैं, उच्चतम डिग्री पद से शुरू होते हैं।\n\n    Args:\n        n (int): बहुपद की उच्चतम डिग्री।\n        coeffs (List[int]): गुणांकों की एक सूची, उच्चतम डिग्री पद के गुणांक से शुरू होती है।\n\n    Returns:\n        str: बहुपद का स्ट्रिंग प्रतिनिधित्व।\n\n    उदाहरण:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "hu": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Egy polinomiális együtthatók listáját formázott sztring reprezentációvá alakítja.\n\n    A függvény a polinom legmagasabb fokszámát `n` és egy együtthatók listáját `coeffs` veszi be,\n    amelyeket a legmagasabb fokszámú tagtól a konstans tagig rendez. Visszaad egy sztringet, amely\n    a polinomot a következő szabályok szerint ábrázolja:\n    - A nulla együtthatójú tagok elhagyásra kerülnek.\n    - Minden tag előjele meghatározásra kerül (+ a pozitív, - a negatív esetén), az első tagnál nincs vezető '+'.\n    - Az együttható abszolút értéke megjelenik, kivéve ha 1 és a tag tartalmazza az `x` változót.\n    - A változó rész a fokszám alapján formázott; `x^degree` ha a fokszám > 1, `x` ha a fokszám 1, és\n      semmi ha a fokszám 0 (konstans tag).\n    - A tagok további szóközök nélkül kapcsolódnak össze, a legmagasabb fokszámú taggal kezdve.\n\n    Paraméterek:\n        n (int): A polinom legmagasabb fokszáma.\n        coeffs (List[int]): Egy együtthatók listája, a legmagasabb fokszámú tag együtthatójával kezdve.\n\n    Visszatér:\n        str: A polinom sztring reprezentációja.\n\n    Példák:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "es": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Convierte una lista de coeficientes de un polinomio en una representación de cadena formateada.\n\n    La función recibe el grado más alto `n` del polinomio y una lista de coeficientes `coeffs`,\n    que están ordenados desde el término de mayor grado hasta el término constante. Devuelve una cadena que\n    representa el polinomio con las siguientes reglas:\n    - Se omiten los términos con un coeficiente de cero.\n    - El signo de cada término se determina (+ para positivo, - para negativo), sin un '+' inicial para el primer término.\n    - Se muestra el valor absoluto del coeficiente a menos que sea 1 y el término incluya la variable `x`.\n    - La parte variable se formatea según su grado; `x^grado` para grado > 1, `x` para grado 1, y\n      nada para grado 0 (término constante).\n    - Los términos se unen sin espacios adicionales, comenzando con el término de mayor grado.\n\n    Argumentos:\n        n (int): El grado más alto del polinomio.\n        coeffs (List[int]): Una lista de coeficientes, comenzando con el coeficiente del término de mayor grado.\n\n    Devuelve:\n        str: La representación en cadena del polinomio.\n\n    Ejemplos:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "arb": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    يحول قائمة من معاملات متعددة الحدود إلى تمثيل سلسلة منسق.\n\n    تأخذ الدالة أعلى درجة `n` لمتعددة الحدود وقائمة من المعاملات `coeffs`,\n    التي تكون مرتبة من الحد ذو الدرجة الأعلى إلى الحد الثابت. تعيد سلسلة\n    تمثل متعددة الحدود بالقواعد التالية:\n    - يتم حذف الحدود ذات المعامل الصفري.\n    - يتم تحديد إشارة كل حد (+ للإيجابي، - للسلبي)، بدون '+' في البداية للحد الأول.\n    - يتم عرض القيمة المطلقة للمعامل إلا إذا كانت 1 والحد يتضمن المتغير `x`.\n    - يتم تنسيق الجزء المتغير بناءً على درجته؛ `x^degree` للدرجة > 1، `x` للدرجة 1، ولا شيء للدرجة 0 (الحد الثابت).\n    - يتم ربط الحدود بدون مسافات إضافية، بدءًا من الحد ذو الدرجة الأعلى.\n\n    يعيدالحجج:\n        n (int): أعلى درجة لمتعددة الحدود.\n        coeffs (List[int]): قائمة بالمعاملات، بدءًا من معامل الحد ذو الدرجة الأعلى.\n\n    يعيد:\n        str: تمثيل السلسلة لمتعددة الحدود.\n\n    أمثلة:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "sw": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Hubadilisha orodha ya vigezo vya polinomu kuwa mwakilishi wa maandishi uliopangwa.\n\n    Kazi inachukua kiwango cha juu `n` cha polinomu na orodha ya vigezo `coeffs`,\n    ambavyo vimepangwa kutoka kwa kiwango cha juu cha neno hadi neno la mara kwa mara. Inarudisha kamba ambayo\n    inawakilisha polinomu kwa sheria zifuatazo:\n    - Maneno yenye kigezo cha sifuri hayajumuishwi.\n    - Alama ya kila neno imedhamiriwa (+ kwa chanya, - kwa hasi), bila '+' inayoongoza kwa neno la kwanza.\n    - Thamani kamili ya kigezo inaonyeshwa isipokuwa ni 1 na neno linajumuisha kigezo `x`.\n    - Sehemu ya kigezo imepangwa kulingana na kiwango chake; `x^degree` kwa degree > 1, `x` kwa degree 1, na\n      hakuna kitu kwa degree 0 (neno la mara kwa mara).\n    - Maneno yanaunganishwa bila nafasi za ziada, kuanzia na neno la kiwango cha juu zaidi.\n\n    Hoja:\n        n (int): Kiwango cha juu cha polinomu.\n        coeffs (List[int]): Orodha ya vigezo, kuanzia na kigezo cha neno la kiwango cha juu zaidi.\n\n    Inarejesha:\n        str: Mwakilishi wa maandishi wa polinomu.\n\n    Mifano:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "tr": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Bir polinom katsayıları listesini biçimlendirilmiş bir string gösterimine dönüştürür.\n\n    Fonksiyon, polinomun en yüksek derecesi `n` ve en yüksek dereceli terimden sabit terime kadar sıralanmış\n    bir katsayılar listesi `coeffs` alır. Aşağıdaki kurallarla polinomu temsil eden bir string döndürür:\n    - Katsayısı sıfır olan terimler atlanır.\n    - Her terimin işareti belirlenir (+ pozitif için, - negatif için), ilk terim için başta '+' yoktur.\n    - Katsayının mutlak değeri gösterilir, ancak katsayı 1 ise ve terim `x` değişkenini içeriyorsa gösterilmez.\n    - Değişken kısmı derecesine göre biçimlendirilir; derece > 1 için `x^degree`, derece 1 için `x` ve\n      derece 0 (sabit terim) için hiçbir şey.\n    - Terimler ek boşluk olmadan birleştirilir, en yüksek dereceli terimle başlar.\n\n    Argümanlar:\n        n (int): Polinomun en yüksek derecesi.\n        coeffs (List[int]): En yüksek dereceli terimin katsayısı ile başlayan bir katsayılar listesi.\n\n    Döndürür:\n        str: Polinomun string gösterimi.\n\n    Örnekler:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "vi": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Chuyển đổi một danh sách các hệ số đa thức thành một chuỗi định dạng biểu diễn.\n\n    Hàm nhận vào bậc cao nhất `n` của đa thức và một danh sách các hệ số `coeffs`,\n    được sắp xếp từ hạng tử có bậc cao nhất đến hạng tử hằng số. Nó trả về một chuỗi\n    biểu diễn đa thức với các quy tắc sau:\n    - Các hạng tử có hệ số bằng không sẽ bị bỏ qua.\n    - Dấu của mỗi hạng tử được xác định (+ cho dương, - cho âm), không có dấu '+' dẫn đầu cho hạng tử đầu tiên.\n    - Giá trị tuyệt đối của hệ số được hiển thị trừ khi nó là 1 và hạng tử bao gồm biến `x`.\n    - Phần biến được định dạng dựa trên bậc của nó; `x^degree` cho bậc > 1, `x` cho bậc 1, và\n      không có gì cho bậc 0 (hạng tử hằng số).\n    - Các hạng tử được nối với nhau mà không có khoảng trắng bổ sung, bắt đầu với hạng tử có bậc cao nhất.\n\n    Tham số:\n        n (int): Bậc cao nhất của đa thức.\n        coeffs (List[int]): Một danh sách các hệ số, bắt đầu với hệ số của hạng tử có bậc cao nhất.\n\n    Trả về:\n        str: Chuỗi biểu diễn của đa thức.\n\n    Ví dụ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "id": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Mengonversi daftar koefisien polinomial menjadi representasi string yang diformat.\n\n    Fungsi ini menerima derajat tertinggi `n` dari polinomial dan daftar koefisien `coeffs`,\n    yang diurutkan dari suku dengan derajat tertinggi hingga suku konstanta. Fungsi ini mengembalikan string yang\n    mewakili polinomial dengan aturan berikut:\n    - Suku dengan koefisien nol dihilangkan.\n    - Tanda setiap suku ditentukan (+ untuk positif, - untuk negatif), tanpa '+' di depan untuk suku pertama.\n    - Nilai absolut dari koefisien ditampilkan kecuali jika nilainya 1 dan suku tersebut termasuk variabel `x`.\n    - Bagian variabel diformat berdasarkan derajatnya; `x^degree` untuk derajat > 1, `x` untuk derajat 1, dan\n      tidak ada apa-apa untuk derajat 0 (suku konstanta).\n    - Suku-suku digabungkan tanpa spasi tambahan, dimulai dengan suku derajat tertinggi.\n\n    Args:\n        n (int): Derajat tertinggi dari polinomial.\n        coeffs (List[int]): Daftar koefisien, dimulai dengan koefisien dari suku dengan derajat tertinggi.\n\n    Returns:\n        str: Representasi string dari polinomial.\n\n    Contoh:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "ja": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    多項式の係数のリストをフォーマットされた文字列表現に変換します。\n\n    この関数は、多項式の最高次数 `n` と、最高次数の項から定数項まで順に並んだ係数のリスト `coeffs` を受け取り、\n    以下のルールに従って多項式を表す文字列を返します:\n    - 係数がゼロの項は省略されます。\n    - 各項の符号は決定されます（正の場合は +、負の場合は -）、最初の項には先頭の '+' はありません。\n    - 係数の絶対値は、係数が1で変数 `x` を含む項でない限り表示されます。\n    - 変数部分は次数に基づいてフォーマットされます。次数が1より大きい場合は `x^degree`、次数が1の場合は `x`、\n      定数項の場合は何も表示されません。\n    - 項は追加のスペースなしで結合され、最高次数の項から始まります。\n\n    Args:\n        n (int): 多項式の最高次数。\n        coeffs (List[int]): 最高次数の項の係数から始まる係数のリスト。\n\n    Returns:\n        str: 多項式の文字列表現。\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "ko": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    다항식 계수 목록을 형식화된 문자열 표현으로 변환합니다.\n\n    이 함수는 다항식의 최고 차수 `n`과 계수 목록 `coeffs`를 입력으로 받아,\n    최고 차수 항부터 상수 항까지 정렬된 계수 목록을 제공합니다. 다음 규칙에 따라 다항식을 나타내는 문자열을 반환합니다:\n    - 계수가 0인 항은 생략됩니다.\n    - 각 항의 부호는 결정됩니다 (+는 양수, -는 음수), 첫 번째 항에는 선행 '+'가 없습니다.\n    - 계수의 절대값은 표시되지만, 계수가 1이고 항에 변수 `x`가 포함된 경우는 제외됩니다.\n    - 변수 부분은 차수에 따라 형식화됩니다; 차수가 1보다 큰 경우 `x^degree`, 차수가 1인 경우 `x`, 차수가 0인 경우 아무것도 표시되지 않습니다 (상수 항).\n    - 항은 추가 공백 없이 결합되며, 최고 차수 항부터 시작합니다.\n\n    Args:\n        n (int): 다항식의 최고 차수.\n        coeffs (List[int]): 최고 차수 항의 계수부터 시작하는 계수 목록.\n\n    Returns:\n        str: 다항식의 문자열 표현.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "ml": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    പദഘടകങ്ങളുടെ പട്ടികയെ ഫോർമാറ്റുചെയ്ത സ്ട്രിംഗ് പ്രതിനിധാനമായി മാറ്റുന്നു.\n\n    ഫംഗ്ഷൻ പോളിനോമിയലിന്റെ ഏറ്റവും ഉയർന്ന ഡിഗ്രിയായ `n` നെയും പദഘടകങ്ങളുടെ പട്ടികയായ `coeffs` നെയും\n    സ്വീകരിക്കുന്നു, ഇവയെ ഏറ്റവും ഉയർന്ന ഡിഗ്രി പദം മുതൽ സ്ഥിരമായ പദം വരെ ക്രമീകരിച്ചിരിക്കുന്നു. \n    ഇത് പോളിനോമിയലിനെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് തിരികെ നൽകുന്നു, താഴെ പറയുന്ന നിയമങ്ങൾക്കനുസരിച്ച്:\n    - പദഘടകം പൂജ്യം ആയ പദങ്ങൾ ഒഴിവാക്കപ്പെടുന്നു.\n    - ഓരോ പദത്തിന്റെ ചിഹ്നവും നിർണ്ണയിക്കപ്പെടുന്നു (+ സാന്നിദ്ധ്യം, - നെഗറ്റീവ്), ആദ്യ പദത്തിന് മുന്നിൽ '+' ഇല്ലാതെ.\n    - പദഘടകത്തിന്റെ പരമാവധി മൂല്യം കാണിക്കുന്നു, ഇത് 1 ആണെങ്കിൽ മാത്രമേ പദം `x` എന്ന വ്യത്യാസം ഉൾക്കൊള്ളുന്നുവെങ്കിൽ.\n    - വ്യത്യാസഭാഗം അതിന്റെ ഡിഗ്രി അടിസ്ഥാനമാക്കി ഫോർമാറ്റുചെയ്യുന്നു; ഡിഗ്രി > 1 ആയാൽ `x^degree`, ഡിഗ്രി 1 ആണെങ്കിൽ `x`, \n      ഡിഗ്രി 0 (സ്ഥിര പദം) ആണെങ്കിൽ ഒന്നുമില്ല.\n    - പദങ്ങൾ അധിക ഇടവിടങ്ങളില്ലാതെ ചേർക്കുന്നു, ഏറ്റവും ഉയർന്ന ഡിഗ്രി പദം കൊണ്ട് ആരംഭിക്കുന്നു.\n\n    Args:\n        n (int): പോളിനോമിയലിന്റെ ഏറ്റവും ഉയർന്ന ഡിഗ്രി.\n        coeffs (List[int]): ഏറ്റവും ഉയർന്ന ഡിഗ്രി പദത്തിന്റെ പദഘടകം മുതൽ ആരംഭിക്കുന്ന പദഘടകങ്ങളുടെ പട്ടിക.\n\n    Returns:\n        str: പോളിനോമിയലിന്റെ സ്ട്രിംഗ് പ്രതിനിധാനം.\n\n    ഉദാഹരണങ്ങൾ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "fa": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    لیستی از ضرایب چندجمله‌ای را به یک نمایش رشته‌ای قالب‌بندی‌شده تبدیل می‌کند.\n\n    این تابع درجه بالاترین `n` چندجمله‌ای و لیستی از ضرایب `coeffs` را می‌گیرد،\n    که از جمله با بالاترین درجه تا جمله ثابت مرتب شده‌اند. این تابع رشته‌ای را برمی‌گرداند که\n    چندجمله‌ای را با قوانین زیر نمایش می‌دهد:\n    - جملاتی که ضریب آن‌ها صفر است حذف می‌شوند.\n    - علامت هر جمله تعیین می‌شود (+ برای مثبت، - برای منفی)، بدون '+' اولیه برای جمله اول.\n    - مقدار مطلق ضریب نشان داده می‌شود مگر اینکه 1 باشد و جمله شامل متغیر `x` باشد.\n    - بخش متغیر بر اساس درجه آن قالب‌بندی می‌شود؛ `x^degree` برای درجه > 1، `x` برای درجه 1، و\n      هیچ چیز برای درجه 0 (جمله ثابت).\n    - جملات بدون فاصله اضافی به هم متصل می‌شوند، شروع با جمله با بالاترین درجه.\n\n    آرگومان‌ها:\n        n (int): بالاترین درجه چندجمله‌ای.\n        coeffs (List[int]): لیستی از ضرایب، شروع با ضریب جمله با بالاترین درجه.\n\n    بازگشت:\n        str: نمایش رشته‌ای چندجمله‌ای.\n\n    مثال‌ها:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\""}, "canonical_solution": "    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)", "instruction": {"en": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nՏվեք Python կոդի հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nBa da takaitaccen bayanin yanayi na dabi'a (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\n最大 500 文字を使用して、英語で Python コードの簡潔な自然言語説明 (docstring) を提供します。", "ko": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 500자 이내로 작성해야 합니다.", "ml": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nപൈതൺ കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെയായി നൽകുക.", "fa": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_polynomial_to_string():\n    test_cases = [\n        (4, [3, -2, 0, 1, -5], \"3x^4-2x^3+x-5\"),\n        (2, [0, 4, -1], \"+4x-1\"),\n        (0, [7], \"7\"),\n        (3, [1, -1, 0, 1], \"x^3-x^2+1\"),\n    ]\n\n    for i, (n, coeffs, expected) in enumerate(test_cases):\n        result = polynomial_to_string(n, coeffs)\n\n        assert result == expected, f\"Test case {i + 1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i + 1} passed: expected {expected}, got {result}\")\n\n\ntest_polynomial_to_string()", "entry_point": "polynomial_to_string", "signature": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:", "docstring": {"en": "Converts a list of polynomial coefficients into a formatted string representation.\n\nThe function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\nwhich are ordered from the highest degree term to the constant term. It returns a string that\nrepresents the polynomial with the following rules:\n- Terms with a coefficient of zero are omitted.\n- The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n- The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n- The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\nnothing for degree 0 (constant term).\n- Terms are joined without additional spaces, starting with the highest degree term.\n\nArgs:\nn (int): The highest degree of the polynomial.\ncoeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\nReturns:\nstr: The string representation of the polynomial.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "sq": "Konverton një listë të koeficientëve të polinomit në një paraqitje të formatuar si varg.\n\nFunksioni merr shkallën më të lartë `n` të polinomit dhe një listë të koeficientëve `coeffs`,\ntë cilët janë të renditur nga termi me shkallën më të lartë deri te termi konstant. Ai kthen një varg që\npërfaqëson polinomin me rregullat e mëposhtme:\n- Termat me një koeficient zero janë të lënë jashtë.\n- Shenja e çdo termi përcaktohet (+ për pozitiv, - për negativ), pa '+' në fillim për termi i parë.\n- Vlera absolute e koeficientit tregohet përveç nëse është 1 dhe termi përfshin variablin `x`.\n- Pjesa e variablit formatohet bazuar në shkallën e tij; `x^shkalla` për shkallë > 1, `x` për shkallë 1, dhe\nasgjë për shkallë 0 (termi konstant).\n- Termat bashkohen pa hapësira shtesë, duke filluar me termin me shkallën më të lartë.\n\nArgumentet:\nn (int): Shkalla më e lartë e polinomit.\ncoeffs (List[int]): Një listë e koeficientëve, duke filluar me koeficientin e termit me shkallën më të lartë.\n\nKthen:\nstr: Paraqitja si varg e polinomit.\n\nShembuj:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "hy": "Փոխակերպում է բազմանդամի գործակիցների ցուցակը ձևաչափված տողային ներկայացման:\n\nՖունկցիան ընդունում է բազմանդամի ամենաբարձր աստիճանը `n` և գործակիցների ցուցակը `coeffs`,\nորոնք դասավորված են ամենաբարձր աստիճանի անդամից մինչև հաստատուն անդամ: Այն վերադարձնում է տող, որը\nներկայացնում է բազմանդամը հետևյալ կանոններով.\n- Զրոյական գործակցով անդամները բաց են թողնվում:\n- Յուրաքանչյուր անդամի նշանը որոշվում է (+ դրականների համար, - բացասականների համար), առանց առաջին անդամի համար '+' նշանի:\n- Գործակցի բացարձակ արժեքը ցուցադրվում է, եթե այն 1 չէ և անդամը պարունակում է փոփոխական `x`:\n- Փոփոխականի մասը ձևաչափվում է ըստ նրա աստիճանի; `x^աստիճան` աստիճան > 1-ի համար, `x` 1-ի համար, և\nոչինչ 0-ի համար (հաստատուն անդամ):\n- Անդամները միացվում են առանց լրացուցիչ բացատների, սկսելով ամենաբարձր աստիճանի անդամից:\n\nԱրգումենտներ:\nn (int): Բազմանդամի ամենաբարձր աստիճանը:\ncoeffs (List[int]): Գործակիցների ցուցակ, սկսած ամենաբարձր աստիճանի անդամի գործակցից:\n\nՎերադարձնում է:\nstr: Բազմանդամի տողային ներկայացումը:\n\nՕրինակներ:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "bn": "পলিনোমিয়াল সহগের একটি তালিকাকে একটি বিন্যাসিত স্ট্রিং উপস্থাপনায় রূপান্তর করে।\n\nফাংশনটি পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি `n` এবং একটি সহগের তালিকা `coeffs` গ্রহণ করে,\nযা সর্বোচ্চ ডিগ্রি টার্ম থেকে ধ্রুবক টার্ম পর্যন্ত ক্রমানুসারে সাজানো থাকে। এটি একটি স্ট্রিং প্রদান করে যা\nনিম্নলিখিত নিয়মগুলির সাথে পলিনোমিয়ালকে উপস্থাপন করে:\n- শূন্য সহগযুক্ত টার্মগুলি বাদ দেওয়া হয়।\n- প্রতিটি টার্মের চিহ্ন নির্ধারিত হয় (+ ধনাত্মক, - ঋণাত্মক), প্রথম টার্মের জন্য কোনো প্রাথমিক '+' নেই।\n- সহগের পরম মান দেখানো হয় যদি না এটি 1 হয় এবং টার্মে ভেরিয়েবল `x` অন্তর্ভুক্ত থাকে।\n- ভেরিয়েবল অংশটি তার ডিগ্রির উপর ভিত্তি করে বিন্যাসিত হয়; ডিগ্রি > 1 এর জন্য `x^degree`, ডিগ্রি 1 এর জন্য `x`, এবং\nডিগ্রি 0 (ধ্রুবক টার্ম) এর জন্য কিছুই নয়।\n- টার্মগুলি অতিরিক্ত স্পেস ছাড়াই যোগ করা হয়, সর্বোচ্চ ডিগ্রি টার্ম দিয়ে শুরু হয়।\n\nআর্গস:\nn (int): পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি।\ncoeffs (List[int]): সহগের একটি তালিকা, সর্বোচ্চ ডিগ্রি টার্মের সহগ দিয়ে শুরু।\n\nরিটার্নস:\nstr: পলিনোমিয়ালের স্ট্রিং উপস্থাপনা।\n\nউদাহরণ:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "bg": "Преобразува списък от коефициенти на полином в форматирано текстово представяне.\n\nФункцията приема най-високата степен `n` на полинома и списък от коефициенти `coeffs`, които са подредени от термина с най-висока степен до константния термин. Тя връща низ, който представя полинома със следните правила:\n- Термини с коефициент нула се пропускат.\n- Знакът на всеки термин се определя (+ за положителен, - за отрицателен), без водещ '+' за първия термин.\n- Абсолютната стойност на коефициента се показва, освен ако не е 1 и терминът включва променливата `x`.\n- Частта с променливата се форматира в зависимост от степента й; `x^степен` за степен > 1, `x` за степен 1 и нищо за степен 0 (константен термин).\n- Термините се свързват без допълнителни интервали, започвайки с термина с най-висока степен.\n\nАргументи:\nn (int): Най-високата степен на полинома.\ncoeffs (List[int]): Списък от коефициенти, започващ с коефициента на термина с най-висока степен.\n\nВръща:\nstr: Текстовото представяне на полинома.\n\nПримери:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "zh": "将多项式系数列表转换为格式化的字符串表示。\n\n该函数接收多项式的最高次数 `n` 和一个系数列表 `coeffs`，这些系数按从最高次项到常数项的顺序排列。它返回一个表示多项式的字符串，遵循以下规则：\n- 系数为零的项被省略。\n- 每项的符号由其正负决定（正数为 +，负数为 -），首项不带前导 '+'。\n- 系数的绝对值显示，除非系数为 1 且该项包含变量 `x`。\n- 变量部分根据其次数进行格式化；次数大于 1 时为 `x^degree`，次数为 1 时为 `x`，次数为 0（常数项）时不显示。\n- 各项之间没有额外的空格，从最高次项开始连接。\n\n参数：\nn (int): 多项式的最高次数。\ncoeffs (List[int]): 系数列表，从最高次项的系数开始。\n\n返回：\nstr: 多项式的字符串表示。\n\n示例：\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "fr": "Convertit une liste de coefficients de polynôme en une représentation sous forme de chaîne formatée.\n\nLa fonction prend en entrée le degré le plus élevé `n` du polynôme et une liste de coefficients `coeffs`,\nqui sont ordonnés du terme de degré le plus élevé au terme constant. Elle renvoie une chaîne qui\nreprésente le polynôme avec les règles suivantes :\n- Les termes avec un coefficient de zéro sont omis.\n- Le signe de chaque terme est déterminé (+ pour positif, - pour négatif), sans '+' initial pour le premier terme.\n- La valeur absolue du coefficient est affichée sauf si elle est 1 et que le terme inclut la variable `x`.\n- La partie variable est formatée en fonction de son degré ; `x^degree` pour un degré > 1, `x` pour un degré 1, et\nrien pour un degré 0 (terme constant).\n- Les termes sont joints sans espaces supplémentaires, en commençant par le terme de degré le plus élevé.\n\nArgs:\nn (int): Le degré le plus élevé du polynôme.\ncoeffs (List[int]): Une liste de coefficients, en commençant par le coefficient du terme de degré le plus élevé.\n\nReturns:\nstr: La représentation sous forme de chaîne du polynôme.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "de": "Konvertiert eine Liste von Polynomkoeffizienten in eine formatierte Zeichenfolgenrepräsentation.\n\nDie Funktion nimmt den höchsten Grad `n` des Polynoms und eine Liste von Koeffizienten `coeffs` entgegen, die vom höchsten Grad-Term bis zum konstanten Term geordnet sind. Sie gibt eine Zeichenfolge zurück, die das Polynom mit den folgenden Regeln darstellt:\n- Terme mit einem Koeffizienten von Null werden weggelassen.\n- Das Vorzeichen jedes Terms wird bestimmt (+ für positiv, - für negativ), ohne führendes '+' für den ersten Term.\n- Der absolute Wert des Koeffizienten wird angezeigt, es sei denn, er ist 1 und der Term enthält die Variable `x`.\n- Der Variablenteil wird basierend auf seinem Grad formatiert; `x^degree` für Grad > 1, `x` für Grad 1 und nichts für Grad 0 (konstanter Term).\n- Terme werden ohne zusätzliche Leerzeichen verbunden, beginnend mit dem höchsten Grad-Term.\n\nArgs:\nn (int): Der höchste Grad des Polynoms.\ncoeffs (List[int]): Eine Liste von Koeffizienten, beginnend mit dem Koeffizienten des höchsten Grad-Terms.\n\nReturns:\nstr: Die Zeichenfolgenrepräsentation des Polynoms.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "ha": "Canza jerin ƙididdigar polynomial zuwa tsarin rubutu mai tsari.\n\nAikin yana karɓar mafi girman digiri `n` na polynomial da jerin abubuwan `coeffs`, waɗanda aka tsara daga mafi girman digiri zuwa kalmar akai-akai. Yana dawo da kirtani wanda ke wakiltar polynomial tare da waɗannan ƙa'idodin:\n- Ana barin kalmomi tare da ƙimar coefficient na sifili.\n- Ana ƙayyade alamar kowace kalma (+ don tabbatacce, - don korau), ba tare da jagorar '+' don kalma ta farko ba.\n- Ana nuna ƙimar coefficient sai dai idan yana da 1 kuma kalmar tana haɗa da canji `x`.\n- Ana tsara ɓangaren canji bisa ga digirinsa; `x^degree` don digiri > 1, `x` don digiri 1, kuma babu komai don digiri 0 (kalmar akai-akai).\n- Ana haɗa kalmomi ba tare da ƙarin sarari ba, farawa da mafi girman digiri.\n\nArgs:\nn (int): Mafi girman digiri na polynomial.\ncoeffs (List[int]): Jerin coefficients, farawa da coefficient na mafi girman digiri.\n\nReturns:\nstr: Wakilcin kirtani na polynomial.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "hi": "पॉलीनोमियल गुणांक की सूची को एक स्वरूपित स्ट्रिंग प्रतिनिधित्व में परिवर्तित करता है।\n\nयह फ़ंक्शन पॉलीनोमियल की उच्चतम डिग्री `n` और गुणांक `coeffs` की एक सूची लेता है, जो उच्चतम डिग्री पद से लेकर स्थिरांक पद तक क्रमबद्ध होते हैं। यह एक स्ट्रिंग लौटाता है जो निम्नलिखित नियमों के साथ पॉलीनोमियल का प्रतिनिधित्व करता है:\n- शून्य गुणांक वाले पदों को छोड़ दिया जाता है।\n- प्रत्येक पद का चिह्न निर्धारित होता है (+ सकारात्मक के लिए, - नकारात्मक के लिए), पहले पद के लिए कोई अग्रणी '+' नहीं होता।\n- गुणांक का परिमाण दिखाया जाता है जब तक कि यह 1 न हो और पद में चर `x` शामिल हो।\n- चर भाग को उसकी डिग्री के आधार पर स्वरूपित किया जाता है; `x^degree` डिग्री > 1 के लिए, `x` डिग्री 1 के लिए, और कुछ नहीं डिग्री 0 (स्थिरांक पद) के लिए।\n- पदों को बिना अतिरिक्त स्थान के जोड़ा जाता है, उच्चतम डिग्री पद से शुरू होकर।\n\nआर्ग्स:\nn (int): पॉलीनोमियल की उच्चतम डिग्री।\ncoeffs (List[int]): गुणांक की एक सूची, उच्चतम डिग्री पद के गुणांक से शुरू होती है।\n\nरिटर्न्स:\nstr: पॉलीनोमियल का स्ट्रिंग प्रतिनिधित्व।\n\nउदाहरण:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "hu": "Konvertál egy polinomiális együtthatólistát egy formázott karakterlánc reprezentációvá.\n\nA függvény a polinom legmagasabb fokszámát, `n`-t és egy `coeffs` együtthatólistát vesz be, amely a legmagasabb fokú tagtól a konstans tagig van rendezve. Egy karakterláncot ad vissza, amely a polinomot az alábbi szabályok szerint ábrázolja:\n- A nulla együtthatójú tagok elhagyásra kerülnek.\n- Minden tag előjele meghatározott (+ a pozitív, - a negatív esetén), az első tagnál nincs vezető '+' jel.\n- Az együttható abszolút értéke megjelenik, kivéve ha 1 és a tag tartalmazza az `x` változót.\n- A változó rész a fokszám alapján van formázva; `x^degree` ha a fokszám > 1, `x` ha a fokszám 1, és semmi ha a fokszám 0 (konstans tag).\n- A tagok további szóközök nélkül vannak összekapcsolva, a legmagasabb fokú taggal kezdve.\n\nArgs:\nn (int): A polinom legmagasabb fokszáma.\ncoeffs (List[int]): Egy együtthatólista, a legmagasabb fokú tag együtthatójával kezdve.\n\nReturns:\nstr: A polinom karakterlánc reprezentációja.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "es": "Convierte una lista de coeficientes de un polinomio en una representación de cadena formateada.\n\nLa función toma el grado más alto `n` del polinomio y una lista de coeficientes `coeffs`,\nque están ordenados desde el término de mayor grado hasta el término constante. Devuelve una cadena que\nrepresenta el polinomio con las siguientes reglas:\n- Se omiten los términos con un coeficiente de cero.\n- El signo de cada término se determina (+ para positivo, - para negativo), sin un '+' inicial para el primer término.\n- Se muestra el valor absoluto del coeficiente a menos que sea 1 y el término incluya la variable `x`.\n- La parte variable se formatea según su grado; `x^degree` para grado > 1, `x` para grado 1, y\nnada para grado 0 (término constante).\n- Los términos se unen sin espacios adicionales, comenzando con el término de mayor grado.\n\nArgumentos:\nn (int): El grado más alto del polinomio.\ncoeffs (List[int]): Una lista de coeficientes, comenzando con el coeficiente del término de mayor grado.\n\nDevuelve:\nstr: La representación en cadena del polinomio.\n\nEjemplos:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "arb": "يقوم بتحويل قائمة من معاملات متعددة الحدود إلى تمثيل سلسلة نصية منسقة.\n\nتأخذ الدالة الدرجة الأعلى `n` لمتعددة الحدود وقائمة من المعاملات `coeffs`،\nالتي تكون مرتبة من الحد ذو الدرجة الأعلى إلى الحد الثابت. تُرجع سلسلة نصية\nتمثل متعددة الحدود بالقواعد التالية:\n- يتم حذف الحدود التي معاملها يساوي صفر.\n- يتم تحديد إشارة كل حد (+ للموجب، - للسالب)، بدون '+' في البداية للحد الأول.\n- يتم عرض القيمة المطلقة للمعامل إلا إذا كانت 1 والحد يشمل المتغير `x`.\n- يتم تنسيق الجزء المتغير بناءً على درجته؛ `x^degree` للدرجة > 1، `x` للدرجة 1، ولا شيء للدرجة 0 (الحد الثابت).\n- يتم ربط الحدود بدون مسافات إضافية، بدءًا من الحد ذو الدرجة الأعلى.\n\nالمعطيات:\nn (int): الدرجة الأعلى لمتعددة الحدود.\ncoeffs (List[int]): قائمة من المعاملات، تبدأ بمعامل الحد ذو الدرجة الأعلى.\n\nالقيم المعادة:\nstr: تمثيل سلسلة نصية لمتعددة الحدود.\n\nأمثلة:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "sw": "Inabadilisha orodha ya vigezo vya polinomu kuwa mwakilishi wa maandishi uliopangwa.\n\nKazi inachukua kiwango cha juu `n` cha polinomu na orodha ya vigezo `coeffs`,\nambavyo vimepangwa kutoka kwa neno la kiwango cha juu hadi neno la mara kwa mara. Inarudisha kamba ambayo\ninaonyesha polinomu kwa sheria zifuatazo:\n- Maneno yenye kigezo cha sifuri hayatajwi.\n- Alama ya kila neno inaamuliwa (+ kwa chanya, - kwa hasi), bila '+' inayoongoza kwa neno la kwanza.\n- Thamani kamili ya kigezo inaonyeshwa isipokuwa ni 1 na neno linajumuisha kigezo `x`.\n- Sehemu ya kigezo imepangwa kulingana na kiwango chake; `x^degree` kwa kiwango > 1, `x` kwa kiwango 1, na\nhakuna kwa kiwango 0 (neno la mara kwa mara).\n- Maneno yanaunganishwa bila nafasi za ziada, kuanzia na neno la kiwango cha juu zaidi.\n\nHoja:\nn (int): Kiwango cha juu cha polinomu.\ncoeffs (List[int]): Orodha ya vigezo, kuanzia na kigezo cha neno la kiwango cha juu zaidi.\n\nInarudisha:\nstr: Mwakilishi wa kamba wa polinomu.\n\nMifano:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "tr": "Bir liste halinde verilen polinom katsayılarını biçimlendirilmiş bir string gösterimine dönüştürür.\n\nFonksiyon, polinomun en yüksek derecesi `n` ve en yüksek dereceli terimden sabit terime kadar sıralanmış bir katsayılar listesi `coeffs` alır. Aşağıdaki kurallarla polinomu temsil eden bir string döndürür:\n- Katsayısı sıfır olan terimler atlanır.\n- Her terimin işareti belirlenir (pozitif için +, negatif için -), ilk terim için başta '+' yoktur.\n- Katsayının mutlak değeri gösterilir, ancak katsayı 1 ise ve terim `x` değişkenini içeriyorsa gösterilmez.\n- Değişken kısmı derecesine göre biçimlendirilir; derece > 1 için `x^degree`, derece 1 için `x` ve derece 0 için (sabit terim) hiçbir şey.\n- Terimler, en yüksek dereceli terimden başlayarak ek boşluk olmadan birleştirilir.\n\nArgümanlar:\nn (int): Polinomun en yüksek derecesi.\ncoeffs (List[int]): En yüksek dereceli terimin katsayısından başlayarak bir katsayılar listesi.\n\nDöndürür:\nstr: Polinomun string gösterimi.\n\nÖrnekler:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "vi": "Chuyển đổi một danh sách các hệ số đa thức thành một chuỗi định dạng.\n\nHàm nhận vào bậc cao nhất `n` của đa thức và một danh sách các hệ số `coeffs`, được sắp xếp từ hạng tử bậc cao nhất đến hạng tử hằng số. Nó trả về một chuỗi đại diện cho đa thức với các quy tắc sau:\n- Các hạng tử có hệ số bằng không sẽ bị bỏ qua.\n- Dấu của mỗi hạng tử được xác định (+ cho dương, - cho âm), không có dấu '+' dẫn đầu cho hạng tử đầu tiên.\n- Giá trị tuyệt đối của hệ số được hiển thị trừ khi nó là 1 và hạng tử bao gồm biến `x`.\n- Phần biến được định dạng dựa trên bậc của nó; `x^degree` cho bậc > 1, `x` cho bậc 1, và không có gì cho bậc 0 (hạng tử hằng số).\n- Các hạng tử được nối liền mà không có khoảng trắng bổ sung, bắt đầu với hạng tử bậc cao nhất.\n\nTham số:\nn (int): Bậc cao nhất của đa thức.\ncoeffs (List[int]): Một danh sách các hệ số, bắt đầu với hệ số của hạng tử bậc cao nhất.\n\nTrả về:\nstr: Chuỗi đại diện cho đa thức.\n\nVí dụ:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "id": "Mengonversi daftar koefisien polinomial menjadi representasi string yang diformat.\n\nFungsi ini menerima derajat tertinggi `n` dari polinomial dan daftar koefisien `coeffs`,\nyang diurutkan dari suku dengan derajat tertinggi hingga suku konstanta. Fungsi ini mengembalikan string yang\nmewakili polinomial dengan aturan sebagai berikut:\n- Suku dengan koefisien nol dihilangkan.\n- Tanda setiap suku ditentukan (+ untuk positif, - untuk negatif), tanpa '+' di depan untuk suku pertama.\n- Nilai absolut dari koefisien ditampilkan kecuali jika 1 dan suku tersebut termasuk variabel `x`.\n- Bagian variabel diformat berdasarkan derajatnya; `x^degree` untuk derajat > 1, `x` untuk derajat 1, dan\ntidak ada untuk derajat 0 (suku konstanta).\n- Suku-suku digabungkan tanpa spasi tambahan, dimulai dengan suku derajat tertinggi.\n\nArgs:\nn (int): Derajat tertinggi dari polinomial.\ncoeffs (List[int]): Daftar koefisien, dimulai dengan koefisien dari suku dengan derajat tertinggi.\n\nReturns:\nstr: Representasi string dari polinomial.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "ja": "多項式の係数のリストをフォーマットされた文字列表現に変換します。\n\nこの関数は、多項式の最高次数 `n` と、最高次数の項から定数項まで順に並べられた係数のリスト `coeffs` を受け取ります。以下のルールに従って多項式を表す文字列を返します:\n- 係数がゼロの項は省略されます。\n- 各項の符号は決定されます（正の場合は +、負の場合は -）、最初の項には先頭の '+' は付きません。\n- 係数の絶対値は、変数 `x` を含む項で係数が 1 でない限り表示されます。\n- 変数部分はその次数に基づいてフォーマットされます。次数が 1 より大きい場合は `x^degree`、次数が 1 の場合は `x`、次数が 0 の場合（定数項）は何も表示されません。\n- 項は追加のスペースなしで結合され、最高次数の項から始まります。\n\n引数:\nn (int): 多項式の最高次数。\ncoeffs (List[int]): 最高次数の項の係数から始まる係数のリスト。\n\n戻り値:\nstr: 多項式の文字列表現。\n\n例:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "ko": "다항식 계수 목록을 형식화된 문자열 표현으로 변환합니다.\n\n이 함수는 다항식의 최고 차수 `n`과 계수 목록 `coeffs`를 입력으로 받습니다. 이 목록은 최고 차수 항부터 상수 항까지 순서대로 정렬되어 있습니다. 함수는 다음 규칙에 따라 다항식을 나타내는 문자열을 반환합니다:\n- 계수가 0인 항은 생략됩니다.\n- 각 항의 부호는 결정됩니다 (+는 양수, -는 음수), 첫 번째 항에는 선행 '+'가 없습니다.\n- 계수의 절대값은 표시되지만, 계수가 1이고 항에 변수 `x`가 포함된 경우는 제외됩니다.\n- 변수 부분은 차수에 따라 형식화됩니다; 차수가 1보다 큰 경우 `x^degree`, 차수가 1인 경우 `x`, 차수가 0인 경우(상수 항) 아무것도 표시되지 않습니다.\n- 항은 추가적인 공백 없이 결합되며, 최고 차수 항부터 시작합니다.\n\n인수:\nn (int): 다항식의 최고 차수.\ncoeffs (List[int]): 최고 차수 항의 계수부터 시작하는 계수 목록.\n\n반환:\nstr: 다항식의 문자열 표현.\n\n예제:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "ml": "പൊളിനോമിയൽ സഹഗണകങ്ങളുടെ പട്ടിക ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗ് പ്രതിനിധാനത്തിലേക്ക് പരിവർത്തനം ചെയ്യുന്നു.\n\nഫങ്ഷൻ പൊളിനോമിയലിന്റെ ഏറ്റവും ഉയർന്ന ബാഹുല്യം `n`യും ഏറ്റവും ഉയർന്ന ബാഹുല്യം മുതൽ സ്ഥിരാങ്ക ബാഹുല്യം വരെ ക്രമീകരിച്ചിരിക്കുന്ന സഹഗണകങ്ങളുടെ പട്ടികയായ `coeffs`ഉം സ്വീകരിക്കുന്നു. ഇത് താഴെപ്പറയുന്ന നിയമങ്ങളോടുകൂടിയ പൊളിനോമിയൽ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് തിരികെ നൽകുന്നു:\n- പൂജ്യം സഹഗണകമുള്ള പദങ്ങൾ ഒഴിവാക്കപ്പെടുന്നു.\n- ഓരോ പദത്തിന്റെ ചിഹ്നവും നിശ്ചയിക്കുന്നു (+ ധനാത്മകമായതിനും - ঋണാത്മകമായതിനും), ആദ്യ പദത്തിന് മുൻപിൽ '+' ഇല്ലാതെ.\n- സഹഗണകത്തിന്റെ പരമാവധി മൂല്യം കാണിക്കുന്നു, അത് 1 ആണെങ്കിൽ മാത്രമേ പദം വ്യത്യാസം `x` ഉൾക്കൊള്ളുന്നുണ്ടെങ്കിൽ.\n- ബാഹുല്യത്തെ അടിസ്ഥാനമാക്കി വ്യത്യാസഭാഗം ഫോർമാറ്റ് ചെയ്യുന്നു; ബാഹുല്യം > 1 ആണെങ്കിൽ `x^degree`, ബാഹുല്യം 1 ആണെങ്കിൽ `x`, ബാഹുല്യം 0 (സ്ഥിരാങ്ക പദം) ആണെങ്കിൽ ഒന്നുമില്ല.\n- പദങ്ങൾ അധിക ഇടവിടങ്ങളില്ലാതെ ചേർക്കുന്നു, ഏറ്റവും ഉയർന്ന ബാഹുല്യം പദം കൊണ്ടാണ് തുടങ്ങുന്നത്.\n\nആർഗുകൾ:\nn (int): പൊളിനോമിയലിന്റെ ഏറ്റവും ഉയർന്ന ബാഹുല്യം.\ncoeffs (List[int]): ഏറ്റവും ഉയർന്ന ബാഹുല്യം പദത്തിന്റെ സഹഗണകത്തോടെ ആരംഭിക്കുന്ന സഹഗണകങ്ങളുടെ പട്ടിക.\n\nമടക്കങ്ങൾ:\nstr: പൊളിനോമിയലിന്റെ സ്ട്രിംഗ് പ്രതിനിധാനം.\n\nഉദാഹരണങ്ങൾ:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "fa": "تبدیل یک لیست از ضرایب چندجمله‌ای به یک نمایش رشته‌ای قالب‌بندی‌شده.\n\nتابع، بالاترین درجه `n` چندجمله‌ای و یک لیست از ضرایب `coeffs` را دریافت می‌کند که به ترتیب از جمله با بالاترین درجه تا جمله ثابت مرتب شده‌اند. این تابع یک رشته را برمی‌گرداند که چندجمله‌ای را با قوانین زیر نمایش می‌دهد:\n- جملاتی که ضریب آن‌ها صفر است حذف می‌شوند.\n- علامت هر جمله تعیین می‌شود (+ برای مثبت، - برای منفی)، بدون '+' پیشرو برای جمله اول.\n- مقدار مطلق ضریب نشان داده می‌شود مگر اینکه 1 باشد و جمله شامل متغیر `x` باشد.\n- بخش متغیر بر اساس درجه آن قالب‌بندی می‌شود؛ `x^degree` برای درجه > 1، `x` برای درجه 1، و هیچ‌چیز برای درجه 0 (جمله ثابت).\n- جملات بدون فاصله اضافی به هم پیوسته می‌شوند، با شروع از جمله با بالاترین درجه.\n\nآرگومان‌ها:\nn (int): بالاترین درجه چندجمله‌ای.\ncoeffs (List[int]): لیستی از ضرایب، با شروع از ضریب جمله با بالاترین درجه.\n\nبازگشتی:\nstr: نمایش رشته‌ای چندجمله‌ای.\n\nمثال‌ها:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'"}}
{"task_id": "Python/21", "prompt": {"en": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    This means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n    90, 88, and 88, and their respective registration numbers are listed alongside their scores.\n    \"\"\"", "sq": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Zgjedh dhe përcakton pragun e pikëve të intervistës dhe listën e aplikantëve që kualifikohen për procesin e intervistës.\n    \n    Funksioni rendit aplikantët bazuar në pikët e tyre të testit në rend zbritës. Nëse disa aplikantë kanë të njëjtat pikë,\n    ata pastaj renditen sipas numrit të tyre të regjistrimit në rend rritës. Pragu i pikëve të intervistës llogaritet bazuar në 150%\n    të numrit të planifikuar të rekrutimeve, i rrumbullakosur poshtë. Të gjithë aplikantët me pikë të barabarta ose më të larta se pragu konsiderohen\n    të kualifikuar për intervistën.\n    \n    Argumentet:\n    - n (int): Numri total i aplikantëve.\n    - m (int): Numri i planifikuar i vullnetarëve për t'u rekrutuar.\n    - applicants (List[Tuple[int, int]]): Një listë tuples ku çdo tuple përmban numrin e regjistrimit dhe pikët e testit të një aplikanti.\n    \n    Kthen:\n    - Tuple[int, List[Tuple[int, int]]]: Një tuple që përmban pragun e pikëve të intervistës dhe një listë tuples, secila prej të cilave përfshin\n      numrin e regjistrimit dhe pikët e testit të aplikantëve të kualifikuar.\n    \n    Shembuj:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Kjo do të thotë se pragu i pikëve të intervistës është 88, dhe ka 5 aplikantë që kualifikohen për intervistë, me pikë 95, 95,\n    90, 88, dhe 88, dhe numrat e tyre përkatës të regjistrimit janë listuar së bashku me pikët e tyre.\n    \"\"\"", "hy": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Ընտրում է և որոշում հարցազրույցի միավորների շեմը և դիմորդների ցուցակը, ովքեր որակավորվում են հարցազրույցի գործընթացի համար։\n    \n    Ֆունկցիան դասավորում է դիմորդներին նրանց թեստային միավորների հիման վրա նվազման կարգով։ Եթե մի քանի դիմորդներ ունեն նույն միավորը,\n    ապա նրանք դասավորվում են ըստ իրենց գրանցման համարի աճման կարգով։ Հարցազրույցի միավորների շեմը հաշվարկվում է ըստ նախատեսված\n    հավաքագրման 150%-ի, կլորացված ներքև։ Բոլոր դիմորդները, ովքեր ունեն միավորներ, որոնք հավասար են կամ բարձր են շեմից, համարվում են\n    որակավորված հարցազրույցի համար։\n    \n    Արգումենտներ:\n    - n (int): Դիմորդների ընդհանուր քանակը։\n    - m (int): Նախատեսված հավաքագրվող կամավորների քանակը։\n    - applicants (List[Tuple[int, int]]): Ցուցակ, որտեղ յուրաքանչյուր տուփ պարունակում է դիմորդի գրանցման համարը և թեստային միավորը։\n    \n    Վերադարձնում է:\n    - Tuple[int, List[Tuple[int, int]]]: Տուփ, որը պարունակում է հարցազրույցի միավորների շեմը և տուփերի ցուցակ, որոնցից յուրաքանչյուրը ներառում է\n      որակավորված դիմորդների գրանցման համարը և թեստային միավորը։\n    \n    Օրինակներ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Սա նշանակում է, որ հարցազրույցի միավորների շեմը 88 է, և կա 5 դիմորդ, ովքեր որակավորվում են հարցազրույցի համար, միավորներով՝ 95, 95,\n    90, 88 և 88, և նրանց համապատասխան գրանցման համարները նշված են իրենց միավորների կողքին։\n    \"\"\"", "bn": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    সাক্ষাৎকারের জন্য প্রার্থী নির্বাচন করে এবং সাক্ষাৎকারের স্কোরের কাটঅফ নির্ধারণ করে এবং যে প্রার্থীরা সাক্ষাৎকার প্রক্রিয়ার জন্য যোগ্য তাদের তালিকা প্রদান করে।\n\n    ফাংশনটি প্রার্থীদের তাদের পরীক্ষার স্কোর অনুযায়ী অবতরণ ক্রমে সাজায়। যদি একাধিক প্রার্থীর একই স্কোর থাকে, তবে তাদের রেজিস্ট্রেশন নম্বর অনুযায়ী আরোহী ক্রমে সাজানো হয়। সাক্ষাৎকারের স্কোর কাটঅফ পরিকল্পিত নিয়োগের সংখ্যার 150% এর ভিত্তিতে গণনা করা হয়, যা নিচের দিকে পূর্ণসংখ্যায় পরিণত করা হয়। সমস্ত প্রার্থী যারা কাটঅফের সমান বা তার বেশি স্কোর পায় তাদের সাক্ষাৎকারের জন্য যোগ্য বিবেচনা করা হয়।\n\n    Args:\n    - n (int): মোট প্রার্থীর সংখ্যা।\n    - m (int): পরিকল্পিত স্বেচ্ছাসেবকদের সংখ্যা যারা নিয়োগ করা হবে।\n    - applicants (List[Tuple[int, int]]): একটি তালিকা যেখানে প্রতিটি টুপলে একটি প্রার্থীর রেজিস্ট্রেশন নম্বর এবং পরীক্ষার স্কোর থাকে।\n\n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: একটি টুপল যা সাক্ষাৎকারের স্কোর কাটঅফ এবং একটি টুপলের তালিকা ধারণ করে, প্রতিটি টুপলে যোগ্য প্রার্থীদের রেজিস্ট্রেশন নম্বর এবং পরীক্ষার স্কোর অন্তর্ভুক্ত থাকে।\n\n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    এর অর্থ হল সাক্ষাৎকারের স্কোর কাটঅফ 88, এবং 5 জন প্রার্থী সাক্ষাৎকারের জন্য যোগ্য, যাদের স্কোর 95, 95, 90, 88, এবং 88, এবং তাদের সংশ্লিষ্ট রেজিস্ট্রেশন নম্বরগুলি তাদের স্কোরের সাথে তালিকাভুক্ত করা হয়েছে।\n    \"\"\"", "bg": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Избира и определя прага на оценките за интервю и списъка с кандидати, които се класират за интервюто.\n    \n    Функцията сортира кандидатите въз основа на техните тестови оценки в низходящ ред. Ако няколко кандидати имат една и съща оценка,\n    те се сортират по регистрационния си номер във възходящ ред. Прагът на оценките за интервю се изчислява въз основа на 150%\n    от планирания брой на набиране, закръглен надолу. Всички кандидати с оценки, равни или по-високи от прага, се считат за\n    класирани за интервюто.\n    \n    Args:\n    - n (int): Общият брой на кандидатите.\n    - m (int): Планираният брой доброволци за набиране.\n    - applicants (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа регистрационния номер и тестовата оценка на кандидат.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Кортеж, съдържащ прага на оценките за интервю и списък от кортежи, всеки от които включва\n      регистрационния номер и тестовата оценка на класираните кандидати.\n    \n    Примери:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Това означава, че прагът на оценките за интервю е 88, и има 5 кандидати, които се класират за интервюто, с оценки 95, 95,\n    90, 88 и 88, и съответните им регистрационни номера са изброени заедно с техните оценки.\n    \"\"\"", "zh": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    选择并确定面试分数线以及符合面试流程的申请人名单。\n    \n    该函数根据申请人的测试成绩按降序排序。如果多个申请人的成绩相同，则按注册号升序排序。面试分数线是基于计划招募人数的150%计算的，并向下取整。所有成绩等于或高于分数线的申请人被认为符合面试资格。\n    \n    参数:\n    - n (int): 申请人的总人数。\n    - m (int): 计划招募的志愿者人数。\n    - applicants (List[Tuple[int, int]]): 一个包含元组的列表，每个元组包含申请人的注册号和测试成绩。\n    \n    返回:\n    - Tuple[int, List[Tuple[int, int]]]: 一个包含面试分数线和一个元组列表的元组，每个元组包括符合资格的申请人的注册号和测试成绩。\n    \n    示例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    这意味着面试分数线是88，有5名申请人符合面试资格，他们的成绩分别是95, 95, 90, 88和88，他们的注册号与成绩一起列出。\n    \"\"\"", "fr": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Sélectionne et détermine le seuil de score d'entretien et la liste des candidats qui se qualifient pour le processus d'entretien.\n    \n    La fonction trie les candidats en fonction de leurs scores de test par ordre décroissant. Si plusieurs candidats ont le même score,\n    ils sont ensuite triés par leur numéro d'inscription par ordre croissant. Le seuil de score d'entretien est calculé sur la base de 150%\n    du nombre prévu de recrues, arrondi à l'inférieur. Tous les candidats avec des scores égaux ou supérieurs au seuil sont considérés\n    comme qualifiés pour l'entretien.\n    \n    Args:\n    - n (int): Le nombre total de candidats.\n    - m (int): Le nombre prévu de volontaires à recruter.\n    - applicants (List[Tuple[int, int]]): Une liste de tuples où chaque tuple contient le numéro d'inscription et le score de test d'un candidat.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Un tuple contenant le seuil de score d'entretien et une liste de tuples, chacun incluant\n      le numéro d'inscription et le score de test des candidats qualifiés.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Cela signifie que le seuil de score d'entretien est de 88, et il y a 5 candidats qui se qualifient pour l'entretien, avec des scores de 95, 95,\n    90, 88 et 88, et leurs numéros d'inscription respectifs sont listés à côté de leurs scores.\n    \"\"\"", "de": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Wählt aus und bestimmt die Interview-Punktzahlgrenze und die Liste der Bewerber, die sich für den Interviewprozess qualifizieren.\n    \n    Die Funktion sortiert die Bewerber basierend auf ihren Testergebnissen in absteigender Reihenfolge. Wenn mehrere Bewerber die gleiche Punktzahl haben,\n    werden sie dann nach ihrer Registrierungsnummer in aufsteigender Reihenfolge sortiert. Die Interview-Punktzahlgrenze wird basierend auf 150%\n    der geplanten Anzahl von Rekruten berechnet, abgerundet. Alle Bewerber mit Punktzahlen, die gleich oder höher als die Grenze sind, werden als\n    qualifiziert für das Interview betrachtet.\n    \n    Argumente:\n    - n (int): Die Gesamtzahl der Bewerber.\n    - m (int): Die geplante Anzahl der zu rekrutierenden Freiwilligen.\n    - applicants (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die Registrierungsnummer und die Testergebnisse eines Bewerbers enthält.\n    \n    Rückgabewerte:\n    - Tuple[int, List[Tuple[int, int]]]: Ein Tupel, das die Interview-Punktzahlgrenze und eine Liste von Tupeln enthält, von denen jedes die\n      Registrierungsnummer und die Testergebnisse der qualifizierten Bewerber umfasst.\n    \n    Beispiele:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Dies bedeutet, dass die Interview-Punktzahlgrenze 88 beträgt und es 5 Bewerber gibt, die sich für das Interview qualifizieren, mit Punktzahlen von 95, 95,\n    90, 88 und 88, und ihre jeweiligen Registrierungsnummern sind zusammen mit ihren Punktzahlen aufgeführt.\n    \"\"\"", "ha": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Zaɓi kuma kayyade yawan maki na hira da jerin masu nema waɗanda suka cancanci shiga tsarin hira.\n    \n    Aikin yana tsara masu nema bisa ga maki na gwaji daga mafi girma zuwa ƙasa. Idan masu nema da yawa suna da maki iri ɗaya,\n    to za a tsara su bisa ga lambar rajista daga ƙasa zuwa sama. Ana ƙididdige yawan maki na hira bisa ga kashi 150%\n    na yawan masu son daukar aiki da aka shirya, an zagaye ƙasa. Duk masu nema da maki daidai ko mafi girma fiye da yawan maki na hira ana ɗaukar su\n    sun cancanci shiga hirar.\n    \n    Args:\n    - n (int): Jimillar yawan masu nema.\n    - m (int): Yawan masu son daukar aiki da aka shirya.\n    - applicants (List[Tuple[int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi lambar rajista da maki na gwaji na mai nema.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Tuple mai ɗauke da yawan maki na hira da jerin tuples, kowannensu ya haɗa da\n      lambar rajista da maki na gwaji na masu nema da suka cancanta.\n    \n    Misalai:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Wannan yana nufin cewa yawan maki na hira shine 88, kuma akwai masu nema 5 waɗanda suka cancanci shiga hirar, tare da maki na 95, 95,\n    90, 88, da 88, kuma lambobin rajistarsu suna tare da makinsu.\n    \"\"\"", "hi": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    साक्षात्कार स्कोर कटऑफ और उन आवेदकों की सूची का चयन करता है जो साक्षात्कार प्रक्रिया के लिए योग्य हैं।\n\n    यह फ़ंक्शन आवेदकों को उनके टेस्ट स्कोर के आधार पर अवरोही क्रम में छांटता है। यदि कई आवेदकों के पास समान स्कोर है,\n    तो उन्हें उनके पंजीकरण संख्या के आधार पर आरोही क्रम में छांटा जाता है। साक्षात्कार स्कोर कटऑफ नियोजित भर्ती संख्या के\n    150% के आधार पर गणना की जाती है, जिसे नीचे की ओर गोल किया जाता है। सभी आवेदक जिनके स्कोर कटऑफ के बराबर या उससे अधिक हैं,\n    उन्हें साक्षात्कार के लिए योग्य माना जाता है।\n\n    तर्क:\n    - n (int): कुल आवेदकों की संख्या।\n    - m (int): नियोजित स्वयंसेवकों की संख्या जिन्हें भर्ती किया जाना है।\n    - applicants (List[Tuple[int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल में एक आवेदक की पंजीकरण संख्या और टेस्ट स्कोर शामिल होता है।\n\n    लौटाता है:\n    - Tuple[int, List[Tuple[int, int]]]: एक ट्यूपल जिसमें साक्षात्कार स्कोर कटऑफ और ट्यूपल की एक सूची शामिल होती है, जिनमें से प्रत्येक में\n      योग्य आवेदकों की पंजीकरण संख्या और टेस्ट स्कोर शामिल होता है।\n\n    उदाहरण:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    इसका अर्थ है कि साक्षात्कार स्कोर कटऑफ 88 है, और 5 आवेदक हैं जो साक्षात्कार के लिए योग्य हैं, जिनके स्कोर 95, 95,\n    90, 88, और 88 हैं, और उनके संबंधित पंजीकरण संख्या उनके स्कोर के साथ सूचीबद्ध हैं।\n    \"\"\"", "hu": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Kiválasztja és meghatározza az interjú ponthatárt és azon jelentkezők listáját, akik megfelelnek az interjú folyamatára.\n\n    A függvény csökkenő sorrendbe rendezi a jelentkezőket a tesztpontszámaik alapján. Ha több jelentkezőnek azonos a pontszáma,\n    akkor regisztrációs számuk alapján növekvő sorrendbe kerülnek. Az interjú ponthatárt a tervezett toborzási létszám 150%-a\n    alapján számítják ki, lefelé kerekítve. Minden jelentkező, akinek a pontszáma eléri vagy meghaladja a ponthatárt, alkalmasnak\n    minősül az interjúra.\n\n    Args:\n    - n (int): A jelentkezők teljes száma.\n    - m (int): A tervezett önkéntesek száma, akiket toborozni kívánnak.\n    - applicants (List[Tuple[int, int]]): Egy lista, amelyben minden egyes elem egy tuple, amely tartalmazza a jelentkező\n      regisztrációs számát és tesztpontszámát.\n\n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Egy tuple, amely tartalmazza az interjú ponthatárt és egy listát a tuple-ökkel,\n      amelyek mindegyike tartalmazza a regisztrációs számot és a megfelelő jelentkezők tesztpontszámát.\n\n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Ez azt jelenti, hogy az interjú ponthatár 88, és 5 jelentkező van, aki megfelel az interjúra, 95, 95, 90, 88 és 88 pontszámmal,\n    és a megfelelő regisztrációs számuk a pontszámok mellett van feltüntetve.\n    \"\"\"", "es": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selecciona y determina el puntaje de corte para la entrevista y la lista de solicitantes que califican para el proceso de entrevista.\n    \n    La función ordena a los solicitantes en base a sus puntajes de prueba en orden descendente. Si varios solicitantes tienen el mismo puntaje,\n    se ordenan luego por su número de registro en orden ascendente. El puntaje de corte para la entrevista se calcula en base al 150%\n    del número planeado de reclutas, redondeado hacia abajo. Todos los solicitantes con puntajes iguales o superiores al corte se consideran\n    calificados para la entrevista.\n    \n    Argumentos:\n    - n (int): El número total de solicitantes.\n    - m (int): El número planeado de voluntarios a reclutar.\n    - applicants (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla contiene el número de registro y el puntaje de prueba de un solicitante.\n    \n    Devuelve:\n    - Tuple[int, List[Tuple[int, int]]]: Una tupla que contiene el puntaje de corte para la entrevista y una lista de tuplas, cada una de las cuales incluye\n      el número de registro y el puntaje de prueba de los solicitantes calificados.\n    \n    Ejemplos:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Esto significa que el puntaje de corte para la entrevista es 88, y hay 5 solicitantes que califican para la entrevista, con puntajes de 95, 95,\n    90, 88, y 88, y sus respectivos números de registro se enumeran junto a sus puntajes.\n    \"\"\"", "arb": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    يختار ويحدد درجة المقابلة والحد الأدنى لقائمة المتقدمين الذين يتأهلون لعملية المقابلة.\n    \n    تقوم الدالة بترتيب المتقدمين بناءً على درجاتهم في الاختبار بترتيب تنازلي. إذا كان هناك عدة متقدمين لديهم نفس الدرجة،\n    يتم ترتيبهم بعد ذلك حسب رقم التسجيل بترتيب تصاعدي. يتم حساب درجة المقابلة بناءً على 150%\n    من العدد المخطط للمتطوعين، ويتم تقريبها إلى الأسفل. جميع المتقدمين الذين لديهم درجات تساوي أو أعلى من الحد الأدنى يعتبرون\n    مؤهلين للمقابلة.\n    \n    يعيدالحجج:\n    - n (int): العدد الإجمالي للمتقدمين.\n    - m (int): العدد المخطط للمتطوعين الذين سيتم تجنيدهم.\n    - applicants (List[Tuple[int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على رقم التسجيل ودرجة الاختبار للمتقدم.\n    \n    يعيد:\n    - Tuple[int, List[Tuple[int, int]]]: زوج يحتوي على درجة المقابلة وقائمة من الأزواج، يحتوي كل منها على\n      رقم التسجيل ودرجة الاختبار للمتقدمين المؤهلين.\n    \n    أمثلة:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    هذا يعني أن درجة المقابلة هي 88، وهناك 5 متقدمين يتأهلون للمقابلة، بدرجات 95، 95،\n    90، 88، و88، وأرقام تسجيلهم مذكورة بجانب درجاتهم.\n    \"\"\"", "sw": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Huchagua na kuamua alama ya mahojiano na orodha ya waombaji wanaostahili kwa mchakato wa mahojiano.\n    \n    Kazi hii hupanga waombaji kulingana na alama zao za mtihani kwa mpangilio wa kushuka. Ikiwa waombaji kadhaa wana alama sawa,\n    basi hupangwa kulingana na namba zao za usajili kwa mpangilio wa kupanda. Alama ya mahojiano huhesabiwa kulingana na 150%\n    ya idadi iliyopangwa ya walioajiriwa, ikipunguzwa chini. Waombaji wote wenye alama sawa au juu kuliko alama ya mahojiano wanachukuliwa\n    kuwa wanastahili kwa mahojiano.\n    \n    Hoja:\n    - n (int): Jumla ya idadi ya waombaji.\n    - m (int): Idadi iliyopangwa ya watu wa kujitolea watakaoajiriwa.\n    - applicants (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi ina namba ya usajili na alama ya mtihani ya mwombaji.\n    \n    Inarejesha:\n    - Tuple[int, List[Tuple[int, int]]]: Jozi inayojumuisha alama ya mahojiano na orodha ya jozi, kila moja ikiwa na\n      namba ya usajili na alama ya mtihani ya waombaji waliostahili.\n    \n    Mifano:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Hii inamaanisha kuwa alama ya mahojiano ni 88, na kuna waombaji 5 wanaostahili kwa mahojiano, wakiwa na alama za 95, 95,\n    90, 88, na 88, na namba zao za usajili zimeorodheshwa pamoja na alama zao.\n    \"\"\"", "tr": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Mülakat puanı barajını ve mülakat sürecine hak kazanan başvuru sahiplerinin listesini seçer ve belirler.\n    \n    Fonksiyon, başvuru sahiplerini test puanlarına göre azalan sırayla sıralar. Birden fazla başvuru sahibi aynı puana sahipse,\n    kayıt numaralarına göre artan sırayla sıralanırlar. Mülakat puanı barajı, planlanan işe alınacak gönüllü sayısının %150'si\n    üzerinden hesaplanır ve aşağı yuvarlanır. Baraj puanına eşit veya daha yüksek puan alan tüm başvuru sahipleri mülakata hak kazanmış\n    kabul edilir.\n    \n    Argümanlar:\n    - n (int): Toplam başvuru sayısı.\n    - m (int): Planlanan işe alınacak gönüllü sayısı.\n    - applicants (List[Tuple[int, int]]): Her bir demetin bir başvuru sahibinin kayıt numarasını ve test puanını içerdiği demetlerin listesi.\n    \n    Dönüş Değeri:\n    - Tuple[int, List[Tuple[int, int]]]: Mülakat puanı barajını ve her birinin kayıt numarası ve test puanını içeren,\n      mülakata hak kazanan başvuru sahiplerinin demetlerinden oluşan bir liste içeren bir demet.\n    \n    Örnekler:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Bu, mülakat puanı barajının 88 olduğunu ve mülakata hak kazanan 5 başvuru sahibinin 95, 95, 90, 88 ve 88 puanlarına sahip olduğunu,\n    ve ilgili kayıt numaralarının puanlarıyla birlikte listelendiğini ifade eder.\n    \"\"\"", "vi": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Lựa chọn và xác định điểm phỏng vấn tối thiểu và danh sách các ứng viên đủ điều kiện cho quá trình phỏng vấn.\n    \n    Hàm này sắp xếp các ứng viên dựa trên điểm kiểm tra của họ theo thứ tự giảm dần. Nếu nhiều ứng viên có cùng điểm số,\n    họ sẽ được sắp xếp theo số đăng ký theo thứ tự tăng dần. Điểm phỏng vấn tối thiểu được tính dựa trên 150%\n    của số lượng tuyển dụng dự kiến, làm tròn xuống. Tất cả các ứng viên có điểm số bằng hoặc cao hơn điểm tối thiểu được coi là\n    đủ điều kiện cho phỏng vấn.\n    \n    Tham số:\n    - n (int): Tổng số lượng ứng viên.\n    - m (int): Số lượng tình nguyện viên dự kiến sẽ được tuyển dụng.\n    - applicants (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa số đăng ký và điểm kiểm tra của một ứng viên.\n    \n    Trả về:\n    - Tuple[int, List[Tuple[int, int]]]: Một bộ giá trị chứa điểm phỏng vấn tối thiểu và danh sách các bộ giá trị, mỗi bộ bao gồm\n      số đăng ký và điểm kiểm tra của các ứng viên đủ điều kiện.\n    \n    Ví dụ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Điều này có nghĩa là điểm phỏng vấn tối thiểu là 88, và có 5 ứng viên đủ điều kiện cho phỏng vấn, với điểm số là 95, 95,\n    90, 88, và 88, và số đăng ký của họ được liệt kê cùng với điểm số của họ.\n    \"\"\"", "id": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Memilih dan menentukan batas skor wawancara dan daftar pelamar yang memenuhi syarat untuk proses wawancara.\n    \n    Fungsi ini mengurutkan pelamar berdasarkan skor tes mereka dalam urutan menurun. Jika beberapa pelamar memiliki skor yang sama,\n    mereka kemudian diurutkan berdasarkan nomor registrasi mereka dalam urutan naik. Batas skor wawancara dihitung berdasarkan 150%\n    dari jumlah rekrutmen yang direncanakan, dibulatkan ke bawah. Semua pelamar dengan skor sama atau lebih tinggi dari batas dianggap\n    memenuhi syarat untuk wawancara.\n    \n    Args:\n    - n (int): Jumlah total pelamar.\n    - m (int): Jumlah relawan yang direncanakan untuk direkrut.\n    - applicants (List[Tuple[int, int]]): Daftar tuple di mana setiap tuple berisi nomor registrasi dan skor tes dari seorang pelamar.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Sebuah tuple yang berisi batas skor wawancara dan daftar tuple, masing-masing mencakup\n      nomor registrasi dan skor tes dari pelamar yang memenuhi syarat.\n    \n    Contoh:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Ini berarti bahwa batas skor wawancara adalah 88, dan ada 5 pelamar yang memenuhi syarat untuk wawancara, dengan skor 95, 95,\n    90, 88, dan 88, dan nomor registrasi mereka tercantum di samping skor mereka.\n    \"\"\"", "ja": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    面接のスコアカットオフと面接プロセスに適格な応募者のリストを選定し決定します。\n    \n    この関数は、応募者をテストスコアに基づいて降順でソートします。複数の応募者が同じスコアを持つ場合は、\n    登録番号で昇順にソートされます。面接スコアのカットオフは、計画された採用人数の150%に基づいて計算され、\n    切り捨てられます。カットオフ以上のスコアを持つすべての応募者は、面接に適格と見なされます。\n    \n    引数:\n    - n (int): 応募者の総数。\n    - m (int): 採用予定のボランティアの人数。\n    - applicants (List[Tuple[int, int]]): 各タプルが応募者の登録番号とテストスコアを含むタプルのリスト。\n    \n    戻り値:\n    - Tuple[int, List[Tuple[int, int]]]: 面接スコアのカットオフと、適格な応募者の登録番号とテストスコアを含む\n      タプルのリストを含むタプル。\n    \n    例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    これは、面接スコアのカットオフが88であり、面接に適格な応募者が5人いることを意味します。スコアは95, 95,\n    90, 88, 88であり、それぞれの登録番号がスコアと共に記載されています。\n    \"\"\"", "ko": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    면접 점수 컷오프와 면접 과정에 적합한 지원자 목록을 선택하고 결정합니다.\n    \n    이 함수는 지원자들을 시험 점수를 기준으로 내림차순으로 정렬합니다. 여러 지원자가 동일한 점수를 가진 경우,\n    그들은 등록 번호를 기준으로 오름차순으로 정렬됩니다. 면접 점수 컷오프는 계획된 모집 인원의 150%를 기준으로 계산되며,\n    내림 처리됩니다. 컷오프 이상 점수를 가진 모든 지원자는 면접에 적합한 것으로 간주됩니다.\n    \n    매개변수:\n    - n (int): 지원자의 총 수.\n    - m (int): 모집할 계획인 자원봉사자의 수.\n    - applicants (List[Tuple[int, int]]): 각 튜플이 지원자의 등록 번호와 시험 점수를 포함하는 튜플의 목록.\n    \n    반환값:\n    - Tuple[int, List[Tuple[int, int]]]: 면접 점수 컷오프와 각 튜플이 적합한 지원자의 등록 번호와 시험 점수를 포함하는 튜플의 목록을 포함하는 튜플.\n    \n    예시:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    이는 면접 점수 컷오프가 88이며, 5명의 지원자가 면접에 적합하다는 것을 의미합니다. 그들의 점수는 95, 95, 90, 88, 88이며,\n    각각의 등록 번호가 점수와 함께 나열되어 있습니다.\n    \"\"\"", "ml": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    അഭിമുഖ സ്കോർ പരിധിയും അഭിമുഖ പ്രക്രിയയ്ക്ക് യോഗ്യത നേടുന്ന അപേക്ഷകരുടെ പട്ടികയും തിരഞ്ഞെടുക്കുന്നു.\n\n    അപേക്ഷകരെ അവരുടെ ടെസ്റ്റ് സ്കോറുകൾ അനുസരിച്ച് ഇറങ്ങുന്ന ക്രമത്തിൽ ക്രമീകരിക്കുന്നു. ഒരേ സ്കോർ ഉള്ള നിരവധി അപേക്ഷകർ ഉണ്ടെങ്കിൽ,\n    അവർക്ക് ശേഷം അവരുടെ രജിസ്ട്രേഷൻ നമ്പർ ഉയർന്ന ക്രമത്തിൽ ക്രമീകരിക്കും. അഭിമുഖ സ്കോർ പരിധി 150% അടിസ്ഥാനമാക്കി കണക്കാക്കപ്പെടുന്നു\n    പദ്ധതി പ്രകാരം റിക്രൂട്ട് ചെയ്യേണ്ടവരുടെ എണ്ണം, താഴേക്ക് വട്ടമിട്ട്. പരിധിയേക്കാൾ തുല്യമായോ അതിലധികമോ സ്കോറുള്ള എല്ലാ അപേക്ഷകരും\n    അഭിമുഖത്തിന് യോഗ്യരായി കണക്കാക്കപ്പെടുന്നു.\n\n    Args:\n    - n (int): അപേക്ഷകരുടെ മൊത്തം എണ്ണം.\n    - m (int): റിക്രൂട്ട് ചെയ്യാൻ ഉദ്ദേശിക്കുന്ന സ്വയംസേവകരുടെ എണ്ണം.\n    - applicants (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും അപേക്ഷകന്റെ രജിസ്ട്രേഷൻ നമ്പറും ടെസ്റ്റ് സ്കോറും അടങ്ങിയ ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: അഭിമുഖ സ്കോർ പരിധിയും ട്യൂപ്പിളുകളുടെ പട്ടികയും അടങ്ങിയ ട്യൂപ്പിൾ, ഓരോന്നും ഉൾപ്പെടുന്നു\n      യോഗ്യത നേടിയ അപേക്ഷകരുടെ രജിസ്ട്രേഷൻ നമ്പറും ടെസ്റ്റ് സ്കോറും.\n\n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    ഇത് അഭിമുഖ സ്കോർ പരിധി 88 ആണെന്ന് അർത്ഥമാക്കുന്നു, 5 അപേക്ഷകർ അഭിമുഖത്തിന് യോഗ്യത നേടുന്നു, 95, 95 എന്നിങ്ങനെയുള്ള സ്കോറുകളുള്ള,\n    90, 88, 88, അവരുടെ അനുബന്ധ രജിസ്ട്രേഷൻ നമ്പറുകൾ അവരുടെ സ്കോറിനൊപ്പം പട്ടികപ്പെടുത്തിയിരിക്കുന്നു.\n    \"\"\"", "fa": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    انتخاب و تعیین حد نصاب نمره مصاحبه و لیست متقاضیانی که برای فرآیند مصاحبه واجد شرایط هستند.\n\n    این تابع متقاضیان را بر اساس نمرات آزمون آنها به ترتیب نزولی مرتب می‌کند. اگر چندین متقاضی نمره یکسانی داشته باشند،\n    سپس بر اساس شماره ثبت‌نام آنها به ترتیب صعودی مرتب می‌شوند. حد نصاب نمره مصاحبه بر اساس 150% از تعداد برنامه‌ریزی‌شده\n    استخدام‌ها محاسبه می‌شود و به پایین گرد می‌شود. تمام متقاضیانی که نمراتشان برابر یا بیشتر از حد نصاب است، واجد شرایط\n    برای مصاحبه در نظر گرفته می‌شوند.\n\n    آرگومان‌ها:\n    - n (int): تعداد کل متقاضیان.\n    - m (int): تعداد برنامه‌ریزی‌شده داوطلبانی که باید استخدام شوند.\n    - applicants (List[Tuple[int, int]]): لیستی از تاپل‌ها که هر تاپل شامل شماره ثبت‌نام و نمره آزمون یک متقاضی است.\n\n    بازگشت:\n    - Tuple[int, List[Tuple[int, int]]]: یک تاپل شامل حد نصاب نمره مصاحبه و لیستی از تاپل‌ها، که هر کدام شامل شماره ثبت‌نام و نمره آزمون\n      متقاضیان واجد شرایط است.\n\n    مثال‌ها:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\n    این به این معناست که حد نصاب نمره مصاحبه 88 است و 5 متقاضی وجود دارند که برای مصاحبه واجد شرایط هستند، با نمرات 95، 95،\n    90، 88 و 88، و شماره‌های ثبت‌نام مربوطه آنها در کنار نمراتشان فهرست شده‌اند.\n    \"\"\""}, "canonical_solution": "    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants", "instruction": {"en": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nՏվեք Python կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\n请用不超过500个字符的中文，为以下Python代码提供一个简洁的自然语言描述（文档字符串）。", "fr": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nBada takaitaccen bayani a cikin harshen Hausa (docstring) na lambar Python da bai wuce haruffa 500 ba.", "hi": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 अक्षर हों।", "hu": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil tanımı (docstring) sağlayın.", "vi": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nപൈതൺ കോഡ് സംബന്ധിച്ച സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_select_volunteers():\n    # Define test cases\n    test_cases = [\n        (6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)],\n         (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])),\n        (5, 3, [(2000, 70), (2001, 80), (2002, 90), (2003, 85), (2004, 90)],\n         (80, [(2002, 90), (2004, 90), (2003, 85), (2001, 80)])),\n        (8, 4, [(1234, 60), (2345, 75), (3456, 85), (4567, 85), (5678, 90), (6789, 100), (7890, 65), (8901, 70)],\n         (70, [(6789, 100), (5678, 90), (3456, 85), (4567, 85), (2345, 75), (8901, 70)])),\n    ]\n\n    # Run test cases\n    for i, (n, m, applicants, expected) in enumerate(test_cases):\n        interview_line_score, final_applicants = select_volunteers(n, m, applicants)\n        assert (interview_line_score, final_applicants) == expected, f\"Test case {i + 1} failed\"\n        print(f\"Test case {i + 1} passed\")\n\n# Run the test function\ntest_select_volunteers()", "entry_point": "select_volunteers", "signature": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:", "docstring": {"en": "Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n\nThe function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\nthey are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\nof the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\nqualified for the interview.\n\nArgs:\n- n (int): The total number of applicants.\n- m (int): The planned number of volunteers to be recruited.\n- applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\nthe registration number and test score of qualified applicants.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nThis means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n90, 88, and 88, and their respective registration numbers are listed alongside their scores.", "sq": "Përzgjedh dhe përcakton pragun e pikëve të intervistës dhe listën e aplikantëve që kualifikohen për procesin e intervistës.\n\nFunksioni rendit aplikantët bazuar në pikët e tyre të testit në rend zbritës. Nëse disa aplikantë kanë të njëjtën pikë,\nata pastaj renditen sipas numrit të tyre të regjistrimit në rend rritës. Pragu i pikëve të intervistës llogaritet bazuar në 150%\ntë numrit të planifikuar të rekrutimeve, i rrumbullakosur poshtë. Të gjithë aplikantët me pikë të barabarta ose më të larta se pragu konsiderohen\ntë kualifikuar për intervistë.\n\nArgs:\n- n (int): Numri total i aplikantëve.\n- m (int): Numri i planifikuar i vullnetarëve që do të rekrutohen.\n- applicants (List[Tuple[int, int]]): Një listë tuples ku çdo tuple përmban numrin e regjistrimit dhe pikët e testit të një aplikanti.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Një tuple që përmban pragun e pikëve të intervistës dhe një listë tuples, secila prej të cilave përfshin\nnumrin e regjistrimit dhe pikët e testit të aplikantëve të kualifikuar.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nKjo do të thotë që pragu i pikëve të intervistës është 88, dhe ka 5 aplikantë që kualifikohen për intervistë, me pikë 95, 95,\n90, 88, dhe 88, dhe numrat e tyre përkatës të regjistrimit janë të listuar së bashku me pikët e tyre.", "hy": "Ընտրում և որոշում է հարցազրույցի միավորների շեմը և դիմորդների ցուցակը, ովքեր որակավորվում են հարցազրույցի գործընթացի համար։\n\nՖունկցիան դասավորում է դիմորդներին ըստ իրենց թեստային միավորների նվազման կարգով։ Եթե մի քանի դիմորդներ ունեն նույն միավորը, ապա նրանք դասավորվում են ըստ իրենց գրանցման համարի աճման կարգով։ Հարցազրույցի միավորների շեմը հաշվարկվում է ըստ նախատեսված հավաքագրվող կամավորների 150%-ի, կլորացված ներքև։ Բոլոր դիմորդները, որոնց միավորները հավասար են կամ բարձր են շեմից, համարվում են որակավորված հարցազրույցի համար։\n\nԱրգումենտներ:\n- n (int): Դիմորդների ընդհանուր քանակը։\n- m (int): Նախատեսված հավաքագրվող կամավորների քանակը։\n- applicants (List[Tuple[int, int]]): Ցուցակ, որը պարունակում է տուփեր, որտեղ յուրաքանչյուր տուփ պարունակում է դիմորդի գրանցման համարը և թեստային միավորը։\n\nՎերադարձնում է:\n- Tuple[int, List[Tuple[int, int]]]: Տուփ, որը պարունակում է հարցազրույցի միավորների շեմը և տուփերի ցուցակ, որոնցից յուրաքանչյուրը ներառում է որակավորված դիմորդների գրանցման համարը և թեստային միավորը։\n\nՕրինակներ:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nՍա նշանակում է, որ հարցազրույցի միավորների շեմը 88 է, և կա 5 դիմորդ, ովքեր որակավորվում են հարցազրույցի համար՝ ունենալով 95, 95, 90, 88 և 88 միավորներ, և նրանց համապատասխան գրանցման համարները նշված են իրենց միավորների կողքին։", "bn": "সাক্ষাৎকারের স্কোরের কাটঅফ এবং সাক্ষাৎকার প্রক্রিয়ার জন্য যোগ্য আবেদনকারীদের তালিকা নির্বাচন এবং নির্ধারণ করে।\n\nফাংশনটি আবেদনকারীদের তাদের পরীক্ষার স্কোরের উপর ভিত্তি করে অবতরণী ক্রমে সাজায়। যদি একাধিক আবেদনকারীর একই স্কোর থাকে, তবে তাদেরকে তাদের নিবন্ধন নম্বরের উপর ভিত্তি করে আরোহী ক্রমে সাজানো হয়। সাক্ষাৎকারের স্কোরের কাটঅফ পরিকল্পিত নিয়োগের সংখ্যার 150% ভিত্তিতে গণনা করা হয়, যা নিচের দিকে পূর্ণসংখ্যায় গোল করা হয়। সকল আবেদনকারী যাদের স্কোর কাটঅফের সমান বা তার চেয়ে বেশি, তাদের সাক্ষাৎকারের জন্য যোগ্য বলে বিবেচনা করা হয়।\n\nআর্গস:\n- n (int): মোট আবেদনকারীর সংখ্যা।\n- m (int): পরিকল্পিত স্বেচ্ছাসেবকদের সংখ্যা যাদের নিয়োগ করা হবে।\n- applicants (List[Tuple[int, int]]): একটি তালিকা যেখানে প্রতিটি টুপলে একটি আবেদনকারীর নিবন্ধন নম্বর এবং পরীক্ষার স্কোর থাকে।\n\nরিটার্নস:\n- Tuple[int, List[Tuple[int, int]]]: একটি টুপল যা সাক্ষাৎকারের স্কোরের কাটঅফ এবং একটি টুপল তালিকা ধারণ করে, যেখানে প্রতিটি টুপলে যোগ্য আবেদনকারীদের নিবন্ধন নম্বর এবং পরীক্ষার স্কোর অন্তর্ভুক্ত থাকে।\n\nউদাহরণ:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nএর অর্থ হল সাক্ষাৎকারের স্কোরের কাটঅফ 88, এবং 5 জন আবেদনকারী সাক্ষাৎকারের জন্য যোগ্য, যাদের স্কোর 95, 95, 90, 88, এবং 88, এবং তাদের সংশ্লিষ্ট নিবন্ধন নম্বর তাদের স্কোরের সাথে তালিকাভুক্ত।", "bg": "Избира и определя прага на оценката за интервю и списъка с кандидати, които се квалифицират за процеса на интервю.\n\nФункцията сортира кандидатите въз основа на техните тестови оценки в низходящ ред. Ако няколко кандидати имат еднаква оценка,\nте се сортират по регистрационния си номер във възходящ ред. Прагът на оценката за интервю се изчислява въз основа на 150%\nот планирания брой наемания, закръглено надолу. Всички кандидати с оценки, равни или по-високи от прага, се считат за\nквалифицирани за интервюто.\n\nАргументи:\n- n (int): Общият брой на кандидатите.\n- m (int): Планираният брой доброволци, които ще бъдат наети.\n- applicants (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа регистрационния номер и тестовата оценка на кандидат.\n\nВръща:\n- Tuple[int, List[Tuple[int, int]]]: Кортеж, съдържащ прага на оценката за интервю и списък от кортежи, всеки от които включва\nрегистрационния номер и тестовата оценка на квалифицираните кандидати.\n\nПримери:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nТова означава, че прагът на оценката за интервю е 88, и има 5 кандидати, които се квалифицират за интервюто, с оценки 95, 95,\n90, 88 и 88, и техните съответни регистрационни номера са изброени заедно с техните оценки.", "zh": "选择并确定面试分数线以及符合面试流程的申请人名单。\n\n该函数根据申请人的测试分数按降序排序。如果多个申请人的分数相同，则按注册号升序排序。面试分数线是基于计划招募人数的150%计算的，向下取整。所有分数等于或高于分数线的申请人都被认为符合面试资格。\n\n参数:\n- n (int): 申请人的总数。\n- m (int): 计划招募的志愿者人数。\n- applicants (List[Tuple[int, int]]): 一个包含元组的列表，每个元组包含申请人的注册号和测试分数。\n\n返回:\n- Tuple[int, List[Tuple[int, int]]]: 一个包含面试分数线和符合资格的申请人元组列表的元组，每个元组包括注册号和测试分数。\n\n示例:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\n这意味着面试分数线是88，有5名申请人符合面试资格，他们的分数分别是95, 95, 90, 88和88，他们的注册号与分数一起列出。", "fr": "Sélectionne et détermine le seuil de score d'entretien et la liste des candidats qui se qualifient pour le processus d'entretien.\n\nLa fonction trie les candidats en fonction de leurs scores de test par ordre décroissant. Si plusieurs candidats ont le même score,\nils sont ensuite triés par leur numéro d'inscription par ordre croissant. Le seuil de score d'entretien est calculé sur la base de 150%\ndu nombre prévu de recrues, arrondi à l'inférieur. Tous les candidats avec des scores égaux ou supérieurs au seuil sont considérés\ncomme qualifiés pour l'entretien.\n\nArgs:\n- n (int): Le nombre total de candidats.\n- m (int): Le nombre prévu de volontaires à recruter.\n- applicants (List[Tuple[int, int]]): Une liste de tuples où chaque tuple contient le numéro d'inscription et le score de test d'un candidat.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Un tuple contenant le seuil de score d'entretien et une liste de tuples, chacun incluant\nle numéro d'inscription et le score de test des candidats qualifiés.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nCela signifie que le seuil de score d'entretien est de 88, et il y a 5 candidats qui se qualifient pour l'entretien, avec des scores de 95, 95,\n90, 88, et 88, et leurs numéros d'inscription respectifs sont listés à côté de leurs scores.", "de": "Wählt aus und bestimmt die Interview-Punktzahlgrenze und die Liste der Bewerber, die sich für den Interviewprozess qualifizieren.\n\nDie Funktion sortiert die Bewerber basierend auf ihren Testergebnissen in absteigender Reihenfolge. Wenn mehrere Bewerber die gleiche Punktzahl haben, werden sie anschließend nach ihrer Registrierungsnummer in aufsteigender Reihenfolge sortiert. Die Interview-Punktzahlgrenze wird basierend auf 150% der geplanten Anzahl von Rekruten berechnet, abgerundet. Alle Bewerber mit Punktzahlen, die gleich oder höher als die Grenze sind, gelten als qualifiziert für das Interview.\n\nArgs:\n- n (int): Die Gesamtzahl der Bewerber.\n- m (int): Die geplante Anzahl der Freiwilligen, die rekrutiert werden sollen.\n- applicants (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die Registrierungsnummer und die Testergebnisse eines Bewerbers enthält.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Ein Tupel, das die Interview-Punktzahlgrenze und eine Liste von Tupeln enthält, von denen jedes die Registrierungsnummer und die Testergebnisse der qualifizierten Bewerber umfasst.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nDies bedeutet, dass die Interview-Punktzahlgrenze 88 ist und es 5 Bewerber gibt, die sich für das Interview qualifizieren, mit Punktzahlen von 95, 95, 90, 88 und 88, und ihre jeweiligen Registrierungsnummern sind zusammen mit ihren Punktzahlen aufgeführt.", "ha": "Zabi da ƙayyade ƙimar yanke maki na hira da jerin masu nema waɗanda suka cancanci shiga tsarin hira.\n\nAikin yana jera masu nema bisa ga maki na gwaji a cikin tsari mai sauka. Idan masu nema da yawa suna da irin wannan maki, za a jera su bisa ga lambar rajista a cikin tsari mai hawa. Ana ƙididdige ƙimar yanke maki na hira bisa ga kashi 150% na adadin masu son shiga aikin, an zagaye ƙasa. Duk masu nema da maki daidai ko mafi girma fiye da yanke maki ana ɗaukar su cancanta don hira.\n\nArgs:\n- n (int): Jimillar adadin masu nema.\n- m (int): Adadin masu son shiga aikin da aka tsara.\n- applicants (List[Tuple[int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi lambar rajista da maki na gwajin mai nema.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Tuple wanda ya ƙunshi ƙimar yanke maki na hira da jerin tuples, kowanne daga cikinsu ya haɗa da lambar rajista da maki na gwajin masu nema da suka cancanta.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nWannan yana nufin cewa ƙimar yanke maki na hira shine 88, kuma akwai masu nema 5 waɗanda suka cancanci shiga hirar, tare da maki na 95, 95, 90, 88, da 88, kuma lambobin rajistarsu suna tare da makinsu.", "hi": "साक्षात्कार स्कोर कटऑफ और उन आवेदकों की सूची का चयन और निर्धारण करता है जो साक्षात्कार प्रक्रिया के लिए योग्य हैं।\n\nयह फ़ंक्शन आवेदकों को उनके टेस्ट स्कोर के आधार पर अवरोही क्रम में क्रमबद्ध करता है। यदि कई आवेदकों के स्कोर समान हैं, तो उन्हें उनके पंजीकरण संख्या के आधार पर आरोही क्रम में क्रमबद्ध किया जाता है। साक्षात्कार स्कोर कटऑफ नियोजित भर्ती संख्या के 150% के आधार पर गणना की जाती है, जिसे नीचे की ओर पूर्णांकित किया जाता है। सभी आवेदक जिनके स्कोर कटऑफ के बराबर या उससे अधिक हैं, उन्हें साक्षात्कार के लिए योग्य माना जाता है।\n\nआर्ग्स:\n- n (int): कुल आवेदकों की संख्या।\n- m (int): भर्ती किए जाने वाले स्वयंसेवकों की नियोजित संख्या।\n- applicants (List[Tuple[int, int]]): ट्यूपल की एक सूची जहाँ प्रत्येक ट्यूपल में एक आवेदक की पंजीकरण संख्या और टेस्ट स्कोर होता है।\n\nरिटर्न्स:\n- Tuple[int, List[Tuple[int, int]]]: एक ट्यूपल जिसमें साक्षात्कार स्कोर कटऑफ और ट्यूपल की एक सूची शामिल होती है, जिनमें से प्रत्येक में योग्य आवेदकों की पंजीकरण संख्या और टेस्ट स्कोर शामिल होते हैं।\n\nउदाहरण:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nइसका अर्थ है कि साक्षात्कार स्कोर कटऑफ 88 है, और 5 आवेदक साक्षात्कार के लिए योग्य हैं, जिनके स्कोर 95, 95, 90, 88, और 88 हैं, और उनके संबंधित पंजीकरण संख्या उनके स्कोर के साथ सूचीबद्ध हैं।", "hu": "Kiválasztja és meghatározza az interjú pontszám küszöböt és azon jelentkezők listáját, akik megfelelnek az interjú folyamatára.\n\nA függvény a jelentkezőket a tesztpontszámaik alapján csökkenő sorrendbe rendezi. Ha több jelentkezőnek azonos a pontszáma, akkor a regisztrációs számuk alapján növekvő sorrendbe kerülnek. Az interjú pontszám küszöb a tervezett toborzandó önkéntesek számának 150%-a alapján kerül kiszámításra, lefelé kerekítve. Minden jelentkező, akinek a pontszáma eléri vagy meghaladja a küszöböt, alkalmasnak tekintendő az interjúra.\n\nArgs:\n- n (int): A jelentkezők teljes száma.\n- m (int): A tervezett toborzandó önkéntesek száma.\n- applicants (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy tuple, amely tartalmazza a jelentkező regisztrációs számát és tesztpontszámát.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Egy tuple, amely tartalmazza az interjú pontszám küszöböt és egy listát a tuple-ökkel, amelyek mindegyike tartalmazza a regisztrációs számot és a tesztpontszámot az alkalmas jelentkezőknél.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nEz azt jelenti, hogy az interjú pontszám küszöb 88, és 5 jelentkező van, aki megfelel az interjúra, pontszámaik 95, 95, 90, 88 és 88, és a megfelelő regisztrációs számuk a pontszámaik mellett van feltüntetve.", "es": "Selecciona y determina el puntaje de corte para la entrevista y la lista de solicitantes que califican para el proceso de entrevista.\n\nLa función ordena a los solicitantes en función de sus puntajes de prueba en orden descendente. Si varios solicitantes tienen el mismo puntaje, luego se ordenan por su número de registro en orden ascendente. El puntaje de corte para la entrevista se calcula en base al 150% del número planeado de reclutas, redondeado hacia abajo. Todos los solicitantes con puntajes iguales o superiores al corte se consideran calificados para la entrevista.\n\nArgumentos:\n- n (int): El número total de solicitantes.\n- m (int): El número planeado de voluntarios a reclutar.\n- applicants (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla contiene el número de registro y el puntaje de prueba de un solicitante.\n\nDevuelve:\n- Tuple[int, List[Tuple[int, int]]]: Una tupla que contiene el puntaje de corte para la entrevista y una lista de tuplas, cada una de las cuales incluye el número de registro y el puntaje de prueba de los solicitantes calificados.\n\nEjemplos:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nEsto significa que el puntaje de corte para la entrevista es 88, y hay 5 solicitantes que califican para la entrevista, con puntajes de 95, 95, 90, 88 y 88, y sus respectivos números de registro se enumeran junto a sus puntajes.", "arb": "يحدد ويحدد حد درجة المقابلة وقائمة المتقدمين الذين يتأهلون لعملية المقابلة.\n\nتقوم الدالة بترتيب المتقدمين بناءً على درجات اختبارهم بترتيب تنازلي. إذا كان هناك عدة متقدمين لديهم نفس الدرجة، يتم ترتيبهم بعد ذلك حسب رقم التسجيل بترتيب تصاعدي. يتم حساب حد درجة المقابلة بناءً على 150% من العدد المخطط للمتطوعين، مع التقريب للأسفل. جميع المتقدمين الذين لديهم درجات مساوية أو أعلى من الحد يعتبرون مؤهلين للمقابلة.\n\nالمعطيات:\n- n (int): العدد الإجمالي للمتقدمين.\n- m (int): العدد المخطط للمتطوعين ليتم تجنيدهم.\n- applicants (List[Tuple[int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على رقم التسجيل ودرجة الاختبار لمتقدم.\n\nالقيم المعادة:\n- Tuple[int, List[Tuple[int, int]]]: زوج يحتوي على حد درجة المقابلة وقائمة من الأزواج، كل منها يتضمن رقم التسجيل ودرجة الاختبار للمتقدمين المؤهلين.\n\nأمثلة:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nهذا يعني أن حد درجة المقابلة هو 88، وهناك 5 متقدمين يتأهلون للمقابلة، بدرجات 95، 95، 90، 88، و88، وأرقام تسجيلهم مذكورة بجانب درجاتهم.", "sw": "Huchagua na kuamua kiwango cha alama za mahojiano na orodha ya waombaji wanaostahili mchakato wa mahojiano.\n\nKazi hii hupanga waombaji kulingana na alama zao za mtihani kwa mpangilio wa kushuka. Ikiwa waombaji kadhaa wana alama sawa, basi wanapangwa kulingana na nambari zao za usajili kwa mpangilio wa kupanda. Kiwango cha alama za mahojiano huhesabiwa kulingana na 150% ya idadi iliyopangwa ya wanaojitolea, ikipunguzwa chini. Waombaji wote wenye alama sawa au zaidi ya kiwango hicho wanachukuliwa kuwa wanastahili mahojiano.\n\nHoja:\n- n (int): Jumla ya idadi ya waombaji.\n- m (int): Idadi iliyopangwa ya wanaojitolea watakaoajiriwa.\n- applicants (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi ina nambari ya usajili na alama ya mtihani ya mwombaji.\n\nInarejesha:\n- Tuple[int, List[Tuple[int, int]]]: Jozi inayojumuisha kiwango cha alama za mahojiano na orodha ya jozi, kila moja ikiwa na nambari ya usajili na alama ya mtihani ya waombaji waliostahili.\n\nMifano:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nHii inamaanisha kuwa kiwango cha alama za mahojiano ni 88, na kuna waombaji 5 wanaostahili mahojiano, wakiwa na alama za 95, 95, 90, 88, na 88, na nambari zao za usajili zimetajwa pamoja na alama zao.", "tr": "Mülakat puanı barajını ve mülakat sürecine hak kazanan başvuru sahiplerinin listesini seçer ve belirler.\n\nFonksiyon, başvuru sahiplerini test puanlarına göre azalan sırayla sıralar. Birden fazla başvuru sahibinin aynı puana sahip olması durumunda, kayıt numaralarına göre artan sırayla sıralanırlar. Mülakat puanı barajı, planlanan işe alınacak gönüllü sayısının %150'si temel alınarak hesaplanır ve aşağı yuvarlanır. Baraj puanına eşit veya daha yüksek puana sahip tüm başvuru sahipleri mülakata hak kazanmış kabul edilir.\n\nArgümanlar:\n- n (int): Toplam başvuru sayısı.\n- m (int): Planlanan işe alınacak gönüllü sayısı.\n- applicants (List[Tuple[int, int]]): Her bir demetin bir başvuru sahibinin kayıt numarası ve test puanını içerdiği demetlerin listesi.\n\nDöndürür:\n- Tuple[int, List[Tuple[int, int]]]: Mülakat puanı barajını ve her birinin kayıt numarası ve test puanını içeren, mülakata hak kazanan başvuru sahiplerinin demetlerinden oluşan bir liste içeren bir demet.\n\nÖrnekler:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nBu, mülakat puanı barajının 88 olduğunu ve 95, 95, 90, 88 ve 88 puanlarına sahip 5 başvuru sahibinin mülakata hak kazandığını, ve puanlarının yanında kayıt numaralarının listelendiğini ifade eder.", "vi": "Chọn và xác định điểm phỏng vấn ngưỡng và danh sách ứng viên đủ điều kiện cho quá trình phỏng vấn.\n\nHàm sắp xếp các ứng viên dựa trên điểm kiểm tra của họ theo thứ tự giảm dần. Nếu nhiều ứng viên có cùng điểm số,\nhọ sẽ được sắp xếp theo số đăng ký theo thứ tự tăng dần. Điểm phỏng vấn ngưỡng được tính dựa trên 150%\nsố lượng tuyển dụng dự kiến, làm tròn xuống. Tất cả các ứng viên có điểm số bằng hoặc cao hơn ngưỡng được coi là\nđủ điều kiện cho phỏng vấn.\n\nTham số:\n- n (int): Tổng số ứng viên.\n- m (int): Số lượng tình nguyện viên dự kiến sẽ được tuyển dụng.\n- applicants (List[Tuple[int, int]]): Một danh sách các bộ giá trị, mỗi bộ chứa số đăng ký và điểm kiểm tra của một ứng viên.\n\nTrả về:\n- Tuple[int, List[Tuple[int, int]]]: Một bộ giá trị chứa điểm phỏng vấn ngưỡng và danh sách các bộ giá trị, mỗi bộ bao gồm\nsố đăng ký và điểm kiểm tra của các ứng viên đủ điều kiện.\n\nVí dụ:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nĐiều này có nghĩa là điểm phỏng vấn ngưỡng là 88, và có 5 ứng viên đủ điều kiện cho phỏng vấn, với điểm số là 95, 95,\n90, 88, và 88, và số đăng ký tương ứng của họ được liệt kê cùng với điểm số của họ.", "id": "Memilih dan menentukan batas skor wawancara serta daftar pelamar yang memenuhi syarat untuk proses wawancara.\n\nFungsi ini mengurutkan pelamar berdasarkan skor tes mereka dalam urutan menurun. Jika beberapa pelamar memiliki skor yang sama, mereka kemudian diurutkan berdasarkan nomor registrasi mereka dalam urutan naik. Batas skor wawancara dihitung berdasarkan 150% dari jumlah perekrutan yang direncanakan, dibulatkan ke bawah. Semua pelamar dengan skor yang sama atau lebih tinggi dari batas dianggap memenuhi syarat untuk wawancara.\n\nArgs:\n- n (int): Jumlah total pelamar.\n- m (int): Jumlah sukarelawan yang direncanakan untuk direkrut.\n- applicants (List[Tuple[int, int]]): Daftar tuple di mana setiap tuple berisi nomor registrasi dan skor tes seorang pelamar.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Sebuah tuple yang berisi batas skor wawancara dan daftar tuple, masing-masing termasuk nomor registrasi dan skor tes pelamar yang memenuhi syarat.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nIni berarti bahwa batas skor wawancara adalah 88, dan ada 5 pelamar yang memenuhi syarat untuk wawancara, dengan skor 95, 95, 90, 88, dan 88, dan nomor registrasi mereka masing-masing tercantum di samping skor mereka.", "ja": "面接のスコアのカットオフと面接プロセスに適格な応募者のリストを選択し決定します。\n\nこの関数は、応募者をテストスコアに基づいて降順でソートします。複数の応募者が同じスコアを持っている場合は、登録番号で昇順にソートされます。面接のスコアのカットオフは、計画された採用人数の150%に基づいて計算され、切り捨てられます。カットオフ以上のスコアを持つすべての応募者は、面接に適格と見なされます。\n\n引数:\n- n (int): 応募者の総数。\n- m (int): 採用予定のボランティア数。\n- applicants (List[Tuple[int, int]]): 各タプルが応募者の登録番号とテストスコアを含むタプルのリスト。\n\n戻り値:\n- Tuple[int, List[Tuple[int, int]]]: 面接スコアのカットオフと、適格な応募者の登録番号とテストスコアを含むタプルのリストを含むタプル。\n\n例:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nこれは、面接スコアのカットオフが88であり、面接に適格な応募者が5人いることを意味します。彼らのスコアは95, 95, 90, 88, 88であり、それぞれの登録番号がスコアとともに示されています。", "ko": "인터뷰 점수 컷오프와 인터뷰 과정에 적합한 지원자 목록을 선택하고 결정합니다.\n\n이 함수는 지원자들을 그들의 시험 점수를 기준으로 내림차순으로 정렬합니다. 여러 지원자가 동일한 점수를 가진 경우, 그들은 등록 번호를 기준으로 오름차순으로 정렬됩니다. 인터뷰 점수 컷오프는 계획된 모집 인원의 150%를 기준으로 계산되며, 내림으로써 계산됩니다. 컷오프 점수 이상인 모든 지원자는 인터뷰에 적합한 것으로 간주됩니다.\n\nArgs:\n- n (int): 지원자의 총 수.\n- m (int): 모집할 계획인 자원봉사자의 수.\n- applicants (List[Tuple[int, int]]): 각 튜플이 지원자의 등록 번호와 시험 점수를 포함하는 튜플의 목록.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: 인터뷰 점수 컷오프와 각 튜플이 적합한 지원자의 등록 번호와 시험 점수를 포함하는 튜플 목록을 포함하는 튜플.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\n이는 인터뷰 점수 컷오프가 88이며, 인터뷰에 적합한 지원자가 5명 있으며, 그들의 점수는 95, 95, 90, 88, 88이고, 각각의 등록 번호가 점수와 함께 나열되어 있음을 의미합니다.", "ml": "സാക്ഷാത്കാരത്തിനുള്ള സ്കോർ പരിധിയും സാക്ഷാത്കാര പ്രക്രിയയ്ക്ക് യോഗ്യതയുള്ള അപേക്ഷകരുടെ പട്ടികയും തിരഞ്ഞെടുക്കുകയും നിർണ്ണയിക്കുകയും ചെയ്യുന്നു.\n\nഫംഗ്ഷൻ അപേക്ഷകരെ അവരുടെ പരീക്ഷാ സ്കോറിന്റെ അടിസ്ഥാനത്തിൽ ഇറക്കിയ ക്രമത്തിൽ ക്രമീകരിക്കുന്നു. ഒരേ സ്കോർ ഉള്ള നിരവധി അപേക്ഷകരുണ്ടെങ്കിൽ, അവർ അവരുടെ രജിസ്ട്രേഷൻ നമ്പറിന്റെ ഉയർന്ന ക്രമത്തിൽ ക്രമീകരിക്കപ്പെടുന്നു. नियोजിത റിക്രൂട്ട്‌മന്റ്‌ സംഖ്യയുടെ 150% അടിസ്ഥാനമാക്കി സാക്ഷാത്കാര സ്കോർ പരിധി കണക്കാക്കുന്നു, താഴേക്ക് ചുരുക്കി. പരിധിയേക്കാൾ തുല്യമായ അല്ലെങ്കിൽ ഉയർന്ന സ്കോർ ഉള്ള എല്ലാ അപേക്ഷകരും സാക്ഷാത്കാരത്തിന് യോഗ്യരായി കണക്കാക്കപ്പെടുന്നു.\n\nആർഗുകൾ:\n- n (int): മൊത്തം അപേക്ഷകരുടെ എണ്ണം.\n- m (int): नियोजിത റിക്രൂട്ട് ചെയ്യേണ്ട സന്നദ്ധപ്രവർത്തകരുടെ എണ്ണം.\n- applicants (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും ഒരു അപേക്ഷകന്റെ രജിസ്ട്രേഷൻ നമ്പറും പരീക്ഷാ സ്കോറും ഉൾക്കൊള്ളുന്ന ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\nമടക്കങ്ങൾ:\n- Tuple[int, List[Tuple[int, int]]]: സാക്ഷാത്കാര സ്കോർ പരിധിയും ട്യൂപ്പിളുകളുടെ പട്ടികയും ഉൾക്കൊള്ളുന്ന ഒരു ട്യൂപ്പിൾ, ഓരോന്നും\nയോഗ്യതയുള്ള അപേക്ഷകരുടെ രജിസ്ട്രേഷൻ നമ്പറും പരീക്ഷാ സ്കോറും ഉൾക്കൊള്ളുന്നു.\n\nഉദാഹരണങ്ങൾ:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nഇത് സാക്ഷാത്കാര സ്കോർ പരിധി 88 ആണെന്ന് അർത്ഥമാക്കുന്നു, 5 അപേക്ഷകർ സാക്ഷാത്കാരത്തിന് യോഗ്യതയുള്ളവരാണ്, അവരുടെ സ്കോറുകൾ 95, 95, 90, 88, 88 എന്നിവയാണ്, അവരുടെ ബന്ധപ്പെട്ട രജിസ്ട്രേഷൻ നമ്പറുകൾ അവരുടെ സ്കോറിനൊപ്പം പട്ടികപ്പെടുത്തിയിരിക്കുന്നു.", "fa": "انتخاب و تعیین حد نصاب امتیاز مصاحبه و لیست متقاضیانی که برای فرآیند مصاحبه واجد شرایط هستند.\n\nتابع متقاضیان را بر اساس امتیازات آزمون آنها به ترتیب نزولی مرتب می‌کند. اگر چندین متقاضی امتیاز یکسانی داشته باشند،\nسپس بر اساس شماره ثبت نام آنها به ترتیب صعودی مرتب می‌شوند. حد نصاب امتیاز مصاحبه بر اساس 150%\nاز تعداد برنامه‌ریزی شده برای جذب محاسبه می‌شود و به پایین گرد می‌شود. تمامی متقاضیانی که امتیازشان برابر یا بالاتر از حد نصاب است، به عنوان\nواجد شرایط برای مصاحبه در نظر گرفته می‌شوند.\n\nآرگومان‌ها:\n- n (int): تعداد کل متقاضیان.\n- m (int): تعداد برنامه‌ریزی شده داوطلبان برای جذب.\n- applicants (List[Tuple[int, int]]): لیستی از زوج‌ها که هر زوج شامل شماره ثبت نام و امتیاز آزمون یک متقاضی است.\n\nبازگشتی:\n- Tuple[int, List[Tuple[int, int]]]: یک زوج شامل حد نصاب امتیاز مصاحبه و لیستی از زوج‌ها، که هر کدام شامل\nشماره ثبت نام و امتیاز آزمون متقاضیان واجد شرایط است.\n\nمثال‌ها:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nاین بدان معناست که حد نصاب امتیاز مصاحبه 88 است و 5 متقاضی واجد شرایط برای مصاحبه هستند، با امتیازات 95، 95،\n90، 88 و 88، و شماره‌های ثبت نام مربوطه آنها در کنار امتیازاتشان فهرست شده است."}}
{"task_id": "Python/22", "prompt": {"en": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "sq": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Dekodon një mesazh të koduar duke përdorur një kod të nxjerrë nga një palë e njohur e koduar-origjinale.\n    \n    Funksioni ndërton një hartë nga shkronjat e koduara te shkronjat e tyre origjinale dhe përdor këtë\n    hartë për të dekoduar një mesazh të dhënë të koduar. Nëse gjendet një kontradiktë gjatë ndërtimit të hartës,\n    ose nëse jo të gjitha shkronjat janë të përfaqësuara në hartë, funksioni kthen \"Failed\".\n    \n    Argumentet:\n    encoded (str): Një varg që përfaqëson informacionin e koduar.\n    original (str): Një varg që përfaqëson informacionin origjinal që korrespondon me vargun e koduar.\n    message (str): Një varg që përfaqëson mesazhin e koduar që do të dekodohet.\n    \n    Kthen:\n    str: Mesazhi i dekoduar nëse është i suksesshëm, ose \"Failed\" nëse dekodimi nuk është i mundur.\n    \n    Shembuj:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "hy": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Վերծանում է կոդավորված հաղորդագրությունը, օգտագործելով հայտնի կոդավորված-բնօրինակ զույգից ստացված ծածկագիրը:\n    \n    Ֆունկցիան կառուցում է համապատասխանություն կոդավորված տառերից դեպի իրենց բնօրինակ տառերը և օգտագործում է այս\n    համապատասխանությունը՝ տրված կոդավորված հաղորդագրությունը վերծանելու համար: Եթե համապատասխանության կառուցման ընթացքում հակասություն է հայտնաբերվում,\n    կամ բոլոր տառերը ներկայացված չեն համապատասխանության մեջ, ֆունկցիան վերադարձնում է \"Failed\":\n    \n    Արգումենտներ:\n    encoded (str): Տող, որը ներկայացնում է կոդավորված տեղեկատվությունը:\n    original (str): Տող, որը ներկայացնում է բնօրինակ տեղեկատվությունը, որը համապատասխանում է կոդավորված տողին:\n    message (str): Տող, որը ներկայացնում է կոդավորված հաղորդագրությունը, որը պետք է վերծանել:\n    \n    Վերադարձնում է:\n    str: Վերծանված հաղորդագրությունը, եթե հաջող է, կամ \"Failed\", եթե վերծանումը հնարավոր չէ:\n    \n    Օրինակներ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "bn": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    একটি সাইফার ব্যবহার করে একটি এনক্রিপ্টেড বার্তা ডিকোড করে যা একটি পরিচিত এনকোডেড-অরিজিনাল জোড়া থেকে উদ্ভূত হয়।\n\n    ফাংশনটি এনকোডেড অক্ষরগুলি থেকে তাদের মূল অক্ষরগুলিতে একটি ম্যাপিং তৈরি করে এবং এই\n    ম্যাপিংটি ব্যবহার করে একটি প্রদত্ত এনক্রিপ্টেড বার্তাকে ডিকোড করে। যদি ম্যাপিং নির্মাণের সময় কোনও বিরোধ পাওয়া যায়,\n    অথবা ম্যাপিংয়ে সমস্ত অক্ষর উপস্থাপিত না হয়, তাহলে ফাংশনটি \"Failed\" রিটার্ন করে।\n\n    Args:\n    encoded (str): এনকোডেড তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    original (str): এনকোডেড স্ট্রিংয়ের সাথে সম্পর্কিত মূল তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    message (str): ডিকোড করার জন্য এনক্রিপ্টেড বার্তা উপস্থাপনকারী একটি স্ট্রিং।\n\n    Returns:\n    str: সফল হলে ডিকোড করা বার্তা, অথবা ডিকোড করা সম্ভব না হলে \"Failed\"।\n\n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "bg": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Декодира криптирано съобщение, използвайки шифър, получен от известна двойка кодирано-оригинално.\n\n    Функцията изгражда съответствие от кодирани букви към техните оригинални букви и използва това\n    съответствие за декодиране на дадено криптирано съобщение. Ако се намери противоречие по време на изграждането\n    на съответствието или не всички букви са представени в съответствието, функцията връща \"Failed\".\n\n    Аргументи:\n    encoded (str): Низ, представляващ кодираната информация.\n    original (str): Низ, представляващ оригиналната информация, съответстваща на кодирания низ.\n    message (str): Низ, представляващ криптираното съобщение, което трябва да бъде декодирано.\n\n    Връща:\n    str: Декодираното съобщение, ако е успешно, или \"Failed\", ако декодирането не е възможно.\n\n    Примери:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "zh": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    使用从已知的编码-原始对派生的密码解码加密消息。\n    \n    该函数构建一个从编码字母到其原始字母的映射，并使用此映射解码给定的加密消息。\n    如果在构建映射过程中发现矛盾，或者映射中未表示所有字母，函数返回“Failed”。\n    \n    参数:\n    encoded (str): 表示编码信息的字符串。\n    original (str): 表示与编码字符串对应的原始信息的字符串。\n    message (str): 表示要解码的加密消息的字符串。\n    \n    返回:\n    str: 如果解码成功则返回解码后的消息，如果解码不可能则返回“Failed”。\n    \n    示例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "fr": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Décode un message chiffré en utilisant un chiffrement dérivé d'une paire codée-originale connue.\n    \n    La fonction construit une correspondance des lettres codées vers leurs lettres originales et utilise cette\n    correspondance pour décoder un message chiffré donné. Si une contradiction est trouvée lors de la construction de la correspondance,\n    ou si toutes les lettres ne sont pas représentées dans la correspondance, la fonction renvoie \"Failed\".\n    \n    Args:\n    encoded (str): Une chaîne représentant l'information codée.\n    original (str): Une chaîne représentant l'information originale correspondant à la chaîne codée.\n    message (str): Une chaîne représentant le message chiffré à décoder.\n    \n    Returns:\n    str: Le message décodé si réussi, ou \"Failed\" si le décodage n'est pas possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "de": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Entschlüsselt eine verschlüsselte Nachricht mit Hilfe eines Chiffres, der aus einem bekannten Paar von kodierten und originalen Zeichenfolgen abgeleitet wird.\n    \n    Die Funktion erstellt eine Zuordnung von kodierten Buchstaben zu ihren originalen Buchstaben und verwendet diese\n    Zuordnung, um eine gegebene verschlüsselte Nachricht zu entschlüsseln. Wenn während der Erstellung der Zuordnung ein Widerspruch gefunden wird oder nicht alle Buchstaben in der Zuordnung vertreten sind, gibt die Funktion \"Failed\" zurück.\n    \n    Argumente:\n    encoded (str): Ein String, der die kodierte Information darstellt.\n    original (str): Ein String, der die originale Information darstellt, die der kodierten Zeichenfolge entspricht.\n    message (str): Ein String, der die verschlüsselte Nachricht darstellt, die entschlüsselt werden soll.\n    \n    Rückgabewert:\n    str: Die entschlüsselte Nachricht, wenn erfolgreich, oder \"Failed\", wenn die Entschlüsselung nicht möglich ist.\n    \n    Beispiele:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "ha": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Yana fassara saƙon da aka ɓoye ta amfani da wata hanyar ɓoye wa da aka samo daga sanannen haɗin encoded-original.\n\n    Aikin yana gina taswira daga haruffan da aka ɓoye zuwa ga haruffan asali kuma yana amfani da wannan\n    taswira don fassara saƙon da aka ɓoye. Idan aka samu sabani yayin gina taswira,\n    ko kuma ba dukkan haruffa suna cikin taswirar ba, aikin yana dawowa da \"Failed\".\n\n    Args:\n    encoded (str): Wani kirtani da ke wakiltar bayanin da aka ɓoye.\n    original (str): Wani kirtani da ke wakiltar bayanin asali da ya dace da kirtanin da aka ɓoye.\n    message (str): Wani kirtani da ke wakiltar saƙon da aka ɓoye da za a fassara.\n\n    Returns:\n    str: Saƙon da aka fassara idan an yi nasara, ko \"Failed\" idan ba zai yiwu a fassara ba.\n\n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "hi": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    एक ज्ञात एन्कोडेड-ओरिजिनल जोड़ी से व्युत्पन्न सिफर का उपयोग करके एक एन्क्रिप्टेड संदेश को डिकोड करता है।\n\n    यह फ़ंक्शन एन्कोडेड अक्षरों से उनके मूल अक्षरों तक एक मैपिंग बनाता है और इस\n    मैपिंग का उपयोग एक दिए गए एन्क्रिप्टेड संदेश को डिकोड करने के लिए करता है। यदि मैपिंग\n    निर्माण के दौरान कोई विरोधाभास पाया जाता है, या मैपिंग में सभी अक्षर प्रतिनिधित्व नहीं करते हैं,\n    तो फ़ंक्शन \"Failed\" लौटाता है।\n\n    तर्क:\n    encoded (str): एन्कोडेड जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    original (str): एन्कोडेड स्ट्रिंग के अनुरूप मूल जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    message (str): डिकोड किए जाने वाले एन्क्रिप्टेड संदेश का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n\n    लौटाता है:\n    str: डिकोड किया गया संदेश यदि सफल होता है, या \"Failed\" यदि डिकोडिंग संभव नहीं है।\n\n    उदाहरण:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "hu": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Dekódol egy titkosított üzenetet egy ismert kódolt-eredeti párból származtatott rejtjel segítségével.\n    \n    A függvény egy leképezést épít a kódolt betűk és az eredeti betűk között, és ezt a leképezést\n    használja egy adott titkosított üzenet dekódolására. Ha ellentmondás található a leképezés\n    építése során, vagy nem minden betű van képviselve a leképezésben, a függvény \"Failed\" értéket ad vissza.\n    \n    Args:\n    encoded (str): Egy string, amely a kódolt információt képviseli.\n    original (str): Egy string, amely az eredeti információt képviseli, amely megfelel a kódolt stringnek.\n    message (str): Egy string, amely a dekódolandó titkosított üzenetet képviseli.\n    \n    Returns:\n    str: A dekódolt üzenet, ha sikeres, vagy \"Failed\", ha a dekódolás nem lehetséges.\n    \n    Példák:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "es": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodifica un mensaje encriptado utilizando un cifrado derivado de un par conocido de codificado-original.\n    \n    La función construye un mapeo de letras codificadas a sus letras originales y utiliza este\n    mapeo para decodificar un mensaje encriptado dado. Si se encuentra una contradicción durante la construcción del mapeo, o no todas las letras están representadas en el mapeo, la función devuelve \"Failed\".\n    \n    Argumentos:\n    encoded (str): Una cadena que representa la información codificada.\n    original (str): Una cadena que representa la información original correspondiente a la cadena codificada.\n    message (str): Una cadena que representa el mensaje encriptado a decodificar.\n    \n    Devuelve:\n    str: El mensaje decodificado si tiene éxito, o \"Failed\" si la decodificación no es posible.\n    \n    Ejemplos:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "arb": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    يفك تشفير رسالة مشفرة باستخدام شيفرة مشتقة من زوج معروف من المشفر-الأصلي.\n    \n    تبني الدالة خريطة من الحروف المشفرة إلى حروفها الأصلية وتستخدم هذه الخريطة\n    لفك تشفير رسالة مشفرة معينة. إذا تم العثور على تناقض أثناء بناء الخريطة،\n    أو لم تكن جميع الحروف ممثلة في الخريطة، فإن الدالة تعيد \"Failed\".\n    \n    يعيدالحجج:\n    encoded (str): سلسلة تمثل المعلومات المشفرة.\n    original (str): سلسلة تمثل المعلومات الأصلية المقابلة للسلسلة المشفرة.\n    message (str): سلسلة تمثل الرسالة المشفرة التي يجب فك تشفيرها.\n    \n    يعيد:\n    str: الرسالة المفكوكة إذا كانت ناجحة، أو \"Failed\" إذا لم يكن فك التشفير ممكنًا.\n    \n    أمثلة:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "sw": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Hufungua ujumbe uliofichwa kwa kutumia msimbo uliotokana na jozi inayojulikana ya encoded-original.\n    \n    Kazi hii inajenga ramani kutoka kwa herufi zilizofichwa hadi herufi zao za awali na kutumia ramani hii\n    kufungua ujumbe uliofichwa uliotolewa. Ikiwa upinzani utapatikana wakati wa ujenzi wa ramani,\n    au ikiwa si herufi zote zinawakilishwa katika ramani, kazi hii inarejesha \"Failed\".\n    \n    Hoja:\n    encoded (str): Kamba inayowakilisha taarifa iliyofichwa.\n    original (str): Kamba inayowakilisha taarifa ya awali inayolingana na kamba iliyofichwa.\n    message (str): Kamba inayowakilisha ujumbe uliofichwa ambao unapaswa kufunguliwa.\n    \n    Inarejesha:\n    str: Ujumbe uliofunguliwa ikiwa umefanikiwa, au \"Failed\" ikiwa kufungua hakuezekani.\n    \n    Mifano:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "tr": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Bilinen bir kodlanmış-orijinal çiftinden türetilmiş bir şifre kullanarak şifrelenmiş bir mesajı çözer.\n    \n    Fonksiyon, kodlanmış harflerden orijinal harflere bir eşleme oluşturur ve bu\n    eşlemeyi verilen şifreli mesajı çözmek için kullanır. Eşleme oluşturma sırasında bir çelişki bulunursa\n    veya tüm harfler eşlemede temsil edilmezse, fonksiyon \"Failed\" döndürür.\n    \n    Argümanlar:\n    encoded (str): Kodlanmış bilgiyi temsil eden bir dize.\n    original (str): Kodlanmış dizeye karşılık gelen orijinal bilgiyi temsil eden bir dize.\n    message (str): Çözülecek şifreli mesajı temsil eden bir dize.\n    \n    Döndürür:\n    str: Başarılıysa çözülen mesaj veya çözme mümkün değilse \"Failed\".\n    \n    Örnekler:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "vi": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Giải mã một thông điệp được mã hóa bằng cách sử dụng một mật mã được tạo ra từ một cặp mã hóa-gốc đã biết.\n    \n    Hàm này xây dựng một ánh xạ từ các chữ cái mã hóa đến các chữ cái gốc của chúng và sử dụng ánh xạ này\n    để giải mã một thông điệp đã được mã hóa. Nếu tìm thấy một mâu thuẫn trong quá trình xây dựng ánh xạ,\n    hoặc không phải tất cả các chữ cái đều được đại diện trong ánh xạ, hàm sẽ trả về \"Failed\".\n    \n    Tham số:\n    encoded (str): Một chuỗi đại diện cho thông tin đã được mã hóa.\n    original (str): Một chuỗi đại diện cho thông tin gốc tương ứng với chuỗi đã mã hóa.\n    message (str): Một chuỗi đại diện cho thông điệp đã được mã hóa cần giải mã.\n    \n    Trả về:\n    str: Thông điệp đã được giải mã nếu thành công, hoặc \"Failed\" nếu không thể giải mã.\n    \n    Ví dụ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "id": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Mendekripsi pesan terenkripsi menggunakan sandi yang berasal dari pasangan encoded-original yang diketahui.\n    \n    Fungsi ini membangun pemetaan dari huruf-huruf terenkripsi ke huruf-huruf aslinya dan menggunakan\n    pemetaan ini untuk mendekripsi pesan terenkripsi yang diberikan. Jika ditemukan kontradiksi selama\n    konstruksi pemetaan, atau tidak semua huruf terwakili dalam pemetaan, fungsi ini mengembalikan \"Failed\".\n    \n    Argumen:\n    encoded (str): Sebuah string yang mewakili informasi terenkripsi.\n    original (str): Sebuah string yang mewakili informasi asli yang sesuai dengan string terenkripsi.\n    message (str): Sebuah string yang mewakili pesan terenkripsi yang akan didekripsi.\n    \n    Mengembalikan:\n    str: Pesan yang telah didekripsi jika berhasil, atau \"Failed\" jika dekripsi tidak memungkinkan.\n    \n    Contoh:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "ja": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    既知のエンコード済み-オリジナルペアから派生した暗号を使用して暗号化されたメッセージをデコードします。\n    \n    この関数は、エンコードされた文字からオリジナルの文字へのマッピングを構築し、この\n    マッピングを使用して与えられた暗号化メッセージをデコードします。マッピングの構築中に矛盾が見つかった場合、\n    またはすべての文字がマッピングに表現されていない場合、関数は \"Failed\" を返します。\n    \n    引数:\n    encoded (str): エンコードされた情報を表す文字列。\n    original (str): エンコードされた文字列に対応するオリジナルの情報を表す文字列。\n    message (str): デコードする暗号化されたメッセージを表す文字列。\n    \n    戻り値:\n    str: 成功した場合はデコードされたメッセージ、デコードが不可能な場合は \"Failed\"。\n    \n    例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "ko": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    알려진 인코딩-원본 쌍에서 파생된 암호를 사용하여 암호화된 메시지를 해독합니다.\n    \n    이 함수는 인코딩된 문자에서 원본 문자로의 매핑을 구축하고, 이 매핑을 사용하여 주어진 암호화된 메시지를 해독합니다. \n    매핑 구축 중 모순이 발견되거나, 매핑에 모든 문자가 포함되지 않는 경우 함수는 \"Failed\"를 반환합니다.\n    \n    인수:\n    encoded (str): 인코딩된 정보를 나타내는 문자열.\n    original (str): 인코딩된 문자열에 해당하는 원본 정보를 나타내는 문자열.\n    message (str): 해독할 암호화된 메시지를 나타내는 문자열.\n    \n    반환:\n    str: 성공 시 해독된 메시지, 해독이 불가능한 경우 \"Failed\".\n    \n    예제:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "ml": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    ഒരു അറിയപ്പെടുന്ന എൻകോഡഡ്-ഒറിജിനൽ ജോഡിയിൽ നിന്ന് വ്യുത്പന്നമായ സൈഫർ ഉപയോഗിച്ച് എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശം ഡികോഡ് ചെയ്യുന്നു.\n    \n    ഫംഗ്ഷൻ എൻകോഡഡ് അക്ഷരങ്ങളിൽ നിന്ന് അവയുടെ ഒറിജിനൽ അക്ഷരങ്ങളിലേക്കുള്ള ഒരു മാപ്പിംഗ് നിർമ്മിക്കുന്നു, \n    ഈ മാപ്പിംഗ് ഉപയോഗിച്ച് നൽകിയ എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശം ഡികോഡ് ചെയ്യുന്നു. മാപ്പിംഗ് നിർമ്മാണത്തിനിടെ ഒരു വിരുദ്ധാഭാസം കണ്ടെത്തുകയോ,\n    അല്ലെങ്കിൽ എല്ലാ അക്ഷരങ്ങളും മാപ്പിംഗിൽ പ്രതിനിധീകരിക്കപ്പെടുന്നില്ലെങ്കിൽ, ഫംഗ്ഷൻ \"Failed\" തിരികെ നൽകുന്നു.\n    \n    Args:\n    encoded (str): എൻകോഡഡ് വിവരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    original (str): എൻകോഡഡ് സ്ട്രിംഗിനോട് അനുബന്ധിക്കുന്ന ഒറിജിനൽ വിവരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    message (str): ഡികോഡ് ചെയ്യേണ്ട എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    \n    Returns:\n    str: വിജയകരമായാൽ ഡികോഡ് ചെയ്ത സന്ദേശം, അല്ലെങ്കിൽ ഡികോഡിംഗ് സാധ്യമല്ലെങ്കിൽ \"Failed\".\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "fa": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    رمزگشایی یک پیام رمزگذاری شده با استفاده از یک رمز که از یک جفت رمزگذاری شده-اصلی شناخته شده به دست آمده است.\n    \n    این تابع یک نگاشت از حروف رمزگذاری شده به حروف اصلی آن‌ها می‌سازد و از این\n    نگاشت برای رمزگشایی یک پیام رمزگذاری شده استفاده می‌کند. اگر در طول ساخت نگاشت تناقضی پیدا شود،\n    یا اگر همه حروف در نگاشت نمایانده نشده باشند، تابع \"Failed\" را برمی‌گرداند.\n    \n    آرگومان‌ها:\n    encoded (str): یک رشته که اطلاعات رمزگذاری شده را نشان می‌دهد.\n    original (str): یک رشته که اطلاعات اصلی مربوط به رشته رمزگذاری شده را نشان می‌دهد.\n    message (str): یک رشته که پیام رمزگذاری شده‌ای که باید رمزگشایی شود را نشان می‌دهد.\n    \n    بازگشت:\n    str: پیام رمزگشایی شده در صورت موفقیت، یا \"Failed\" اگر رمزگشایی ممکن نباشد.\n    \n    مثال‌ها:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\""}, "canonical_solution": "    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message", "instruction": {"en": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nՏվեք Python կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত স্বাভাবিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nBa da takaitaccen bayanin yare na dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nPython kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\n다음 Python 코드에 대한 간결한 자연어 설명(독스트링)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nتوضیح مختصر به زبان طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_decode():\n    # Test case 1: Contradiction in mapping\n    assert decode(\"AA\", \"AB\", \"EOWIE\") == \"Failed\", \"Test case 1 failed\"\n\n    # Test case 2: Not all letters are represented\n    assert decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\") == \"Failed\", \"Test case 2 failed\"\n\n    # Test case 3: Successful decoding\n    assert decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\", \"Test case 3 failed\"\n    \n    # Test case 4: Character in message not in mapping\n    assert decode(\"ABCDEFGHIJKLM\", \"NOPQRSTUVWXYZ\", \"UVWXYZ\") == \"Failed\", \"Test case 4 failed\"\n\n    # Test case 5: Empty strings\n    assert decode(\"\", \"\", \"\") == \"Failed\", \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function to run the test cases\ntest_decode()", "entry_point": "decode", "signature": "def decode(encoded: str, original: str, message: str) -> str:", "docstring": {"en": "Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n\nThe function builds a mapping from encoded letters to their original letters and uses this\nmapping to decode a given encrypted message. If a contradiction is found during mapping\nconstruction, or not all letters are represented in the mapping, the function returns \"Failed\".\n\nArgs:\nencoded (str): A string representing the encoded information.\noriginal (str): A string representing the original information corresponding to the encoded string.\nmessage (str): A string representing the encrypted message to be decoded.\n\nReturns:\nstr: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "sq": "Dekodon një mesazh të koduar duke përdorur një çelës të nxjerrë nga një çift i njohur i koduar-original.\n\nFunksioni ndërton një hartë nga shkronjat e koduara te shkronjat e tyre origjinale dhe përdor këtë\nhartë për të dekoduar një mesazh të dhënë të koduar. Nëse gjendet një kontradiktë gjatë ndërtimit të hartës,\nose nëse jo të gjitha shkronjat janë të përfaqësuara në hartë, funksioni kthen \"Dështoi\".\n\nArgumentet:\nencoded (str): Një varg që përfaqëson informacionin e koduar.\noriginal (str): Një varg që përfaqëson informacionin origjinal që korrespondon me vargun e koduar.\nmessage (str): Një varg që përfaqëson mesazhin e koduar që do të dekodohet.\n\nKthen:\nstr: Mesazhi i dekoduar nëse është i suksesshëm, ose \"Dështoi\" nëse dekodimi nuk është i mundur.\n\nShembuj:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "hy": "Վերծանում է կոդավորված հաղորդագրությունը՝ օգտագործելով հայտնի կոդավորված-բնօրինակ զույգից ստացված գաղտնագիրը:\n\nՖունկցիան ստեղծում է համապատասխանություն կոդավորված տառերից դեպի իրենց բնօրինակ տառերը և օգտագործում է այս\nհամապատասխանությունը՝ տրված կոդավորված հաղորդագրությունը վերծանելու համար: Եթե հակասություն է հայտնաբերվում համապատասխանության\nստեղծման ընթացքում, կամ բոլոր տառերը չեն ներկայացված համապատասխանության մեջ, ֆունկցիան վերադարձնում է \"Failed\":\n\nԱրձագանքներ:\nencoded (str): Տող, որը ներկայացնում է կոդավորված տեղեկատվությունը:\noriginal (str): Տող, որը ներկայացնում է կոդավորված տողին համապատասխանող բնօրինակ տեղեկատվությունը:\nmessage (str): Տող, որը ներկայացնում է վերծանման ենթակա կոդավորված հաղորդագրությունը:\n\nՎերադարձնում է:\nstr: Վերծանված հաղորդագրությունը, եթե հաջող է, կամ \"Failed\", եթե վերծանումը հնարավոր չէ:\n\nՕրինակներ:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "bn": "একটি পরিচিত এনকোডেড-মূল জোড়া থেকে প্রাপ্ত সাইফার ব্যবহার করে একটি এনক্রিপ্টেড বার্তা ডিকোড করে।\n\nফাংশনটি এনকোডেড অক্ষর থেকে তাদের মূল অক্ষরে একটি ম্যাপিং তৈরি করে এবং এই ম্যাপিং ব্যবহার করে প্রদত্ত এনক্রিপ্টেড বার্তাটি ডিকোড করে। যদি ম্যাপিং নির্মাণের সময় কোনো বিরোধ পাওয়া যায়, বা ম্যাপিংয়ে সমস্ত অক্ষর উপস্থাপিত না হয়, তাহলে ফাংশনটি \"Failed\" রিটার্ন করে।\n\nArgs:\nencoded (str): এনকোডেড তথ্য উপস্থাপনকারী একটি স্ট্রিং।\noriginal (str): এনকোডেড স্ট্রিংয়ের সাথে সম্পর্কিত মূল তথ্য উপস্থাপনকারী একটি স্ট্রিং।\nmessage (str): ডিকোড করার জন্য এনক্রিপ্টেড বার্তা উপস্থাপনকারী একটি স্ট্রিং।\n\nReturns:\nstr: সফল হলে ডিকোড করা বার্তা, অথবা ডিকোড করা সম্ভব না হলে \"Failed\"।\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "bg": "Декодира криптирано съобщение, използвайки шифър, получен от известна двойка кодирано-оригинално.\n\nФункцията изгражда съответствие от кодирани букви към техните оригинални букви и използва това\nсъответствие, за да декодира дадено криптирано съобщение. Ако се намери противоречие по време на изграждането на съответствието или не всички букви са представени в съответствието, функцията връща \"Failed\".\n\nАргументи:\nencoded (str): Низ, представляващ кодираната информация.\noriginal (str): Низ, представляващ оригиналната информация, съответстваща на кодирания низ.\nmessage (str): Низ, представляващ криптираното съобщение, което трябва да бъде декодирано.\n\nВръща:\nstr: Декодираното съобщение, ако е успешно, или \"Failed\", ако декодирането не е възможно.\n\nПримери:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "zh": "解码使用已知编码-原始对派生的密码加密的消息。\n\n该函数从编码字母到其原始字母构建映射，并使用此映射解码给定的加密消息。如果在构建映射过程中发现矛盾，或者映射中并未代表所有字母，则函数返回“Failed”。\n\n参数：\nencoded (str): 表示编码信息的字符串。\noriginal (str): 表示与编码字符串对应的原始信息的字符串。\nmessage (str): 表示要解码的加密消息的字符串。\n\n返回：\nstr: 如果成功则返回解码后的消息，如果解码不可能则返回“Failed”。\n\n示例：\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "fr": "Décode un message chiffré en utilisant un chiffrement dérivé d'une paire encodée-originale connue.\n\nLa fonction construit une correspondance des lettres encodées vers leurs lettres originales et utilise cette\ncorrespondance pour décoder un message chiffré donné. Si une contradiction est trouvée lors de la construction de la correspondance, ou si toutes les lettres ne sont pas représentées dans la correspondance, la fonction retourne \"Échec\".\n\nArgs:\nencoded (str): Une chaîne représentant l'information encodée.\noriginal (str): Une chaîne représentant l'information originale correspondant à la chaîne encodée.\nmessage (str): Une chaîne représentant le message chiffré à décoder.\n\nReturns:\nstr: Le message décodé si réussi, ou \"Échec\" si le décodage n'est pas possible.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "de": "Decodiert eine verschlüsselte Nachricht mithilfe eines Chiffres, der aus einem bekannten kodierten-originalen Paar abgeleitet wird.\n\nDie Funktion erstellt eine Zuordnung von kodierten Buchstaben zu ihren ursprünglichen Buchstaben und verwendet diese Zuordnung, um eine gegebene verschlüsselte Nachricht zu dekodieren. Wenn während der Erstellung der Zuordnung ein Widerspruch gefunden wird oder nicht alle Buchstaben in der Zuordnung vertreten sind, gibt die Funktion \"Failed\" zurück.\n\nArgs:\nencoded (str): Ein String, der die kodierte Information darstellt.\noriginal (str): Ein String, der die ursprüngliche Information darstellt, die dem kodierten String entspricht.\nmessage (str): Ein String, der die zu dekodierende verschlüsselte Nachricht darstellt.\n\nReturns:\nstr: Die dekodierte Nachricht, falls erfolgreich, oder \"Failed\", wenn die Dekodierung nicht möglich ist.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "ha": "Yana fassara saƙon da aka ɓoye ta amfani da wata hanyar ɓoye wa da aka samo daga sanannen haɗin encoded-original.\n\nAikin yana gina taswira daga haruffan da aka koda zuwa ga asalin haruffan kuma yana amfani da wannan taswira don warware saƙon da aka koda. Idan an sami sabani yayin gina taswira, ko kuma ba dukkan haruffa ba a wakilta a cikin taswira, aikin yana dawowa da \"Failed\".\n\nArgs:\nencoded (str): Wani kirtani da ke wakiltar bayanan da aka koda.\noriginal (str): Wani kirtani da ke wakiltar bayanan asali da suka dace da kirtanin da aka koda.\nmessage (str): Wani kirtani da ke wakiltar saƙon da aka koda da za a warware.\n\nReturns:\nstr: Saƙon da aka warware idan an yi nasara, ko \"Failed\" idan ba zai yiwu a warware ba.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "hi": "एक ज्ञात एन्कोडेड-ओरिजिनल जोड़ी से व्युत्पन्न सिफर का उपयोग करके एक एन्क्रिप्टेड संदेश को डिकोड करता है।\n\nयह फ़ंक्शन एन्कोडेड अक्षरों से उनके मूल अक्षरों तक एक मैपिंग बनाता है और इस मैपिंग का उपयोग करके दिए गए एन्क्रिप्टेड संदेश को डिकोड करता है। यदि मैपिंग निर्माण के दौरान कोई विरोधाभास पाया जाता है, या मैपिंग में सभी अक्षर प्रतिनिधित्व नहीं करते हैं, तो फ़ंक्शन \"Failed\" लौटाता है।\n\nआर्ग्स:\nencoded (str): एन्कोडेड जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\noriginal (str): एन्कोडेड स्ट्रिंग के अनुरूप मूल जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\nmessage (str): डिकोड किए जाने वाले एन्क्रिप्टेड संदेश का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n\nरिटर्न्स:\nstr: यदि सफल हो तो डिकोड किया गया संदेश, या यदि डिकोडिंग संभव नहीं है तो \"Failed\"।\n\nउदाहरण:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "hu": "Dekódol egy titkosított üzenetet egy ismert kódolt-eredeti párból származó rejtjel segítségével.\n\nA függvény egy leképezést épít a kódolt betűk és az eredeti betűk között, és ezt a leképezést használja egy adott titkosított üzenet dekódolására. Ha ellentmondás található a leképezés készítése során, vagy nem minden betű van képviselve a leképezésben, a függvény \"Failed\" értéket ad vissza.\n\nArgs:\nencoded (str): Egy karakterlánc, amely a kódolt információt képviseli.\noriginal (str): Egy karakterlánc, amely az eredeti információt képviseli, amely megfelel a kódolt karakterláncnak.\nmessage (str): Egy karakterlánc, amely a dekódolandó titkosított üzenetet képviseli.\n\nReturns:\nstr: A dekódolt üzenet, ha sikeres, vagy \"Failed\", ha a dekódolás nem lehetséges.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "es": "Decodifica un mensaje encriptado usando un cifrado derivado de un par conocido codificado-original.\n\nLa función construye un mapeo de letras codificadas a sus letras originales y utiliza este\nmapeo para decodificar un mensaje encriptado dado. Si se encuentra una contradicción durante la construcción del mapeo, o no todas las letras están representadas en el mapeo, la función devuelve \"Failed\".\n\nArgumentos:\nencoded (str): Una cadena que representa la información codificada.\noriginal (str): Una cadena que representa la información original correspondiente a la cadena codificada.\nmessage (str): Una cadena que representa el mensaje encriptado que se va a decodificar.\n\nDevuelve:\nstr: El mensaje decodificado si tiene éxito, o \"Failed\" si la decodificación no es posible.\n\nEjemplos:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "arb": "يفك تشفير رسالة مشفرة باستخدام شفرة مستمدة من زوج معروف من الشفرة الأصلية.\n\nتبني الدالة خريطة من الحروف المشفرة إلى حروفها الأصلية وتستخدم هذه الخريطة لفك تشفير رسالة مشفرة معينة. إذا تم العثور على تناقض أثناء بناء الخريطة، أو لم يتم تمثيل جميع الحروف في الخريطة، فإن الدالة تعيد \"فشل\".\n\nالمعطيات:\nencoded (str): سلسلة تمثل المعلومات المشفرة.\noriginal (str): سلسلة تمثل المعلومات الأصلية المقابلة للسلسلة المشفرة.\nmessage (str): سلسلة تمثل الرسالة المشفرة المراد فك تشفيرها.\n\nالقيم المعادة:\nstr: الرسالة المفككة إذا كانت ناجحة، أو \"فشل\" إذا لم يكن فك التشفير ممكنًا.\n\nأمثلة:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "sw": "Husimbua ujumbe uliofichwa kwa kutumia msimbo uliotokana na jozi inayojulikana ya iliyosimbwa-asili.\n\nKazi hii hujenga ramani kutoka kwa herufi zilizofichwa hadi kwa herufi zao asili na hutumia ramani hii kusimbua ujumbe uliofichwa uliotolewa. Ikiwa upinzani utapatikana wakati wa ujenzi wa ramani, au ikiwa si herufi zote zinawakilishwa katika ramani, kazi hii itarudisha \"Imeshindikana\".\n\nHoja:\nencoded (str): Kamba inayowakilisha taarifa iliyosimbwa.\noriginal (str): Kamba inayowakilisha taarifa asili inayolingana na kamba iliyosimbwa.\nmessage (str): Kamba inayowakilisha ujumbe uliofichwa unaotakiwa kusimbuliwa.\n\nInarejesha:\nstr: Ujumbe uliosimbuliwa ikiwa umefanikiwa, au \"Imeshindikana\" ikiwa usimbuaji hauwezekani.\n\nMifano:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "tr": "Şifreli bir mesajı, bilinen bir kodlanmış-orijinal çiftinden türetilen bir şifre kullanarak çözer.\n\nFonksiyon, kodlanmış harflerden orijinal harflere bir eşleme oluşturur ve bu eşlemeyi verilen şifreli mesajı çözmek için kullanır. Eşleme oluşturma sırasında bir çelişki bulunursa veya tüm harfler eşlemede temsil edilmezse, fonksiyon \"Başarısız\" döner.\n\nArgümanlar:\nencoded (str): Kodlanmış bilgiyi temsil eden bir dize.\noriginal (str): Kodlanmış dizeye karşılık gelen orijinal bilgiyi temsil eden bir dize.\nmessage (str): Çözülecek şifreli mesajı temsil eden bir dize.\n\nDöndürür:\nstr: Başarılıysa çözülen mesaj veya çözme mümkün değilse \"Başarısız\".\n\nÖrnekler:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "vi": "Giải mã một thông điệp đã được mã hóa bằng một mật mã được tạo ra từ một cặp mã hóa-gốc đã biết.\n\nHàm này xây dựng một ánh xạ từ các chữ cái đã mã hóa đến các chữ cái gốc của chúng và sử dụng ánh xạ này để giải mã một thông điệp đã mã hóa cho trước. Nếu một mâu thuẫn được tìm thấy trong quá trình xây dựng ánh xạ, hoặc không phải tất cả các chữ cái đều được đại diện trong ánh xạ, hàm sẽ trả về \"Failed\".\n\nTham số:\nencoded (str): Một chuỗi đại diện cho thông tin đã mã hóa.\noriginal (str): Một chuỗi đại diện cho thông tin gốc tương ứng với chuỗi đã mã hóa.\nmessage (str): Một chuỗi đại diện cho thông điệp đã mã hóa cần được giải mã.\n\nTrả về:\nstr: Thông điệp đã giải mã nếu thành công, hoặc \"Failed\" nếu không thể giải mã.\n\nVí dụ:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "id": "Mendekode pesan terenkripsi menggunakan sandi yang berasal dari pasangan yang dikenal antara yang sudah dikodekan dan aslinya.\n\nFungsi ini membangun pemetaan dari huruf yang sudah dikodekan ke huruf aslinya dan menggunakan pemetaan ini untuk mendekode pesan terenkripsi yang diberikan. Jika ditemukan kontradiksi selama konstruksi pemetaan, atau tidak semua huruf terwakili dalam pemetaan, fungsi ini mengembalikan \"Gagal\".\n\nArgs:\nencoded (str): Sebuah string yang mewakili informasi yang sudah dikodekan.\noriginal (str): Sebuah string yang mewakili informasi asli yang sesuai dengan string yang sudah dikodekan.\nmessage (str): Sebuah string yang mewakili pesan terenkripsi yang akan didekodekan.\n\nReturns:\nstr: Pesan yang telah didekodekan jika berhasil, atau \"Gagal\" jika dekoding tidak memungkinkan.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "ja": "暗号化されたメッセージを、既知のエンコードされたオリジナルペアから派生した暗号を使用してデコードします。\n\nこの関数は、エンコードされた文字から元の文字へのマッピングを構築し、このマッピングを使用して与えられた暗号化されたメッセージをデコードします。マッピングの構築中に矛盾が見つかった場合、またはマッピングにすべての文字が表されていない場合、関数は「Failed」を返します。\n\n引数:\nencoded (str): エンコードされた情報を表す文字列。\noriginal (str): エンコードされた文字列に対応する元の情報を表す文字列。\nmessage (str): デコードする暗号化されたメッセージを表す文字列。\n\n戻り値:\nstr: 成功した場合はデコードされたメッセージ、デコードが不可能な場合は「Failed」。\n\n例:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "ko": "암호화된 메시지를 알려진 인코딩-원본 쌍에서 파생된 암호를 사용하여 디코딩합니다.\n\n이 함수는 인코딩된 문자에서 원본 문자로의 매핑을 생성하고, 이 매핑을 사용하여 주어진 암호화된 메시지를 디코딩합니다. 매핑 생성 중 모순이 발견되거나 모든 문자가 매핑에 포함되지 않으면 함수는 \"Failed\"를 반환합니다.\n\nArgs:\nencoded (str): 인코딩된 정보를 나타내는 문자열입니다.\noriginal (str): 인코딩된 문자열에 해당하는 원본 정보를 나타내는 문자열입니다.\nmessage (str): 디코딩할 암호화된 메시지를 나타내는 문자열입니다.\n\nReturns:\nstr: 성공 시 디코딩된 메시지, 디코딩이 불가능한 경우 \"Failed\"를 반환합니다.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "ml": "എൻ‌ക്രിപ്റ്റ് ചെയ്ത സന്ദേശം ഒരു എൻ‌കോഡ്-ഒറിജിനൽ ജോഡിയിൽ നിന്ന് വ്യുത്പന്നമായ സൈഫർ ഉപയോഗിച്ച് ഡികോഡ് ചെയ്യുന്നു.\n\nഫംഗ്ഷൻ എൻ‌കോഡ് ചെയ്ത അക്ഷരങ്ങളിൽ നിന്ന് അവയുടെ യഥാർത്ഥ അക്ഷരങ്ങളിലേക്കുള്ള ഒരു മാപ്പിംഗ് നിർമ്മിക്കുന്നു, ഈ മാപ്പിംഗ് ഉപയോഗിച്ച് നൽകിയ എൻ‌ക്രിപ്റ്റ് ചെയ്ത സന്ദേശം ഡികോഡ് ചെയ്യുന്നു. മാപ്പിംഗ് നിർമ്മാണത്തിനിടെ ഒരു വൈരുദ്ധ്യം കണ്ടെത്തുകയോ, മാപ്പിംഗിൽ എല്ലാ അക്ഷരങ്ങളും പ്രതിനിധീകരിക്കപ്പെടാത്തതായിരിക്കുകയോ ചെയ്താൽ, ഫംഗ്ഷൻ \"Failed\" തിരികെ നൽകുന്നു.\n\nArgs:\nencoded (str): എൻ‌കോഡ് ചെയ്ത വിവരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\noriginal (str): എൻ‌കോഡ് ചെയ്ത സ്ട്രിംഗിനോട് അനുബന്ധിക്കുന്ന യഥാർത്ഥ വിവരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\nmessage (str): ഡികോഡ് ചെയ്യേണ്ട എൻ‌ക്രിപ്റ്റ് ചെയ്ത സന്ദേശത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n\nReturns:\nstr: വിജയകരമായാൽ ഡികോഡ് ചെയ്ത സന്ദേശം, അല്ലെങ്കിൽ ഡികോഡിംഗ് സാധ്യമല്ലെങ്കിൽ \"Failed\".\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "fa": "رمزگذاری یک پیام رمزگذاری شده با استفاده از یک رمز که از یک جفت اصلی-رمزگذاری شده شناخته شده مشتق شده است.\n\nاین تابع یک نگاشت از حروف رمزگذاری شده به حروف اصلی آن‌ها ایجاد می‌کند و از این نگاشت برای رمزگشایی یک پیام رمزگذاری شده استفاده می‌کند. اگر در طول ساخت نگاشت تناقضی پیدا شود، یا اگر همه حروف در نگاشت نمایانده نشوند، تابع \"Failed\" را برمی‌گرداند.\n\nآرگومان‌ها:\nencoded (str): رشته‌ای که اطلاعات رمزگذاری شده را نشان می‌دهد.\noriginal (str): رشته‌ای که اطلاعات اصلی مربوط به رشته رمزگذاری شده را نشان می‌دهد.\nmessage (str): رشته‌ای که پیام رمزگذاری شده‌ای را که باید رمزگشایی شود نشان می‌دهد.\n\nبازگشت:\nstr: پیام رمزگشایی شده در صورت موفقیت، یا \"Failed\" اگر رمزگشایی ممکن نباشد.\n\nمثال‌ها:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'"}}
{"task_id": "Python/23", "prompt": {"en": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "sq": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Gjej faktorin më të madh prim të një numri të dhënë pozitiv.\n    \n    Numri supozohet të jetë prodhimi i saktësisht dy numrave të ndryshëm prim. \n    Funksioni iteron përmes faktorëve të mundshëm duke filluar nga primi më i vogël (2) \n    dhe kontrollon nëse ata janë faktorë të 'n'. Nëse gjendet një faktor, funksioni kthen \n    pjesëtimin e 'n' me këtë faktor, i cili është faktori më i madh prim. Nëse nuk gjenden \n    faktorë deri në rrënjën katrore të 'n', atëherë 'n' vetë është një numër prim dhe kthehet \n    si faktori më i madh prim.\n    \n    Args:\n    n (int): Numri pozitiv për të faktorizuar, i cili është prodhimi i dy numrave të ndryshëm prim.\n    \n    Returns:\n    int: Më i madhi nga dy faktorët prim të 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "hy": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Գտնել տրված դրական ամբողջ թվի ամենամեծ պարզ բաժանարարը։\n    \n    Ենթադրվում է, որ ամբողջ թիվը երկու տարբեր պարզ թվերի արտադրյալն է։ \n    Ֆունկցիան սկսում է հնարավոր բաժանարարների ստուգումը ամենափոքր պարզ թվից (2) \n    և ստուգում է, արդյոք դրանք 'n'-ի բաժանարար են։ Եթե բաժանարար է գտնվում, \n    ֆունկցիան վերադարձնում է 'n'-ի բաժանումը այդ բաժանարարով, որը ամենամեծ պարզ \n    բաժանարարն է։ Եթե մինչև 'n'-ի քառակուսի արմատը ոչ մի բաժանարար չի գտնվում, \n    ապա 'n'-ը ինքնին պարզ թիվ է և վերադարձվում է որպես ամենամեծ պարզ բաժանարար։\n    \n    Արգումենտներ:\n    n (int): Դրական ամբողջ թիվը, որը պետք է բաժանել, որը երկու տարբեր պարզ թվերի արտադրյալն է։\n    \n    Վերադարձնում է:\n    int: 'n'-ի երկու պարզ բաժանարարներից ամենամեծը։\n    \n    Օրինակներ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "bn": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    প্রদত্ত একটি ধনাত্মক পূর্ণসংখ্যার বৃহত্তম মৌলিক গুণক খুঁজে বের করুন।\n    \n    পূর্ণসংখ্যাটি ঠিক দুটি ভিন্ন মৌলিক সংখ্যার গুণফল বলে ধারণা করা হয়।\n    ফাংশনটি সম্ভাব্য গুণকগুলির মধ্য দিয়ে ক্ষুদ্রতম মৌলিক সংখ্যা (2) থেকে শুরু করে \n    এবং পরীক্ষা করে যে তারা 'n'-এর গুণক কিনা। যদি একটি গুণক পাওয়া যায়, \n    ফাংশনটি এই গুণক দ্বারা 'n'-এর ভাগফল প্রদান করে, যা বৃহত্তম মৌলিক গুণক। \n    যদি 'n'-এর বর্গমূল পর্যন্ত কোনো গুণক পাওয়া না যায়, তাহলে 'n' নিজেই একটি মৌলিক সংখ্যা \n    এবং বৃহত্তম মৌলিক গুণক হিসেবে ফেরত দেওয়া হয়।\n    \n    Args:\n    n (int): ধনাত্মক পূর্ণসংখ্যা যা দুটি ভিন্ন মৌলিক সংখ্যার গুণফল।\n    \n    Returns:\n    int: 'n'-এর দুটি মৌলিক গুণকের মধ্যে বৃহত্তম।\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "bg": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Намерете най-големия прост делител на дадено положително цяло число.\n    \n    Предполага се, че цялото число е произведение на точно две различни прости числа. \n    Функцията обхожда потенциалните делители, започвайки от най-малкото просто число (2), \n    и проверява дали са делители на 'n'. Ако се намери делител, функцията връща \n    резултата от делението на 'n' с този делител, което е по-големият прост делител. \n    Ако не се намерят делители до квадратния корен на 'n', тогава 'n' самото е просто число \n    и се връща като най-големия прост делител.\n    \n    Аргументи:\n    n (int): Положителното цяло число за факторизиране, което е произведение на две различни прости числа.\n    \n    Връща:\n    int: По-големият от двата прости делителя на 'n'.\n    \n    Примери:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "zh": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    找到给定正整数的最大质因数。\n    \n    假设该整数是恰好由两个不同质数的乘积构成的。\n    该函数从最小的质数（2）开始遍历潜在因数，并检查它们是否是'n'的因数。\n    如果找到一个因数，函数返回'n'除以这个因数的结果，即较大的质因数。\n    如果在'n'的平方根范围内没有找到因数，那么'n'本身就是一个质数，并作为最大的质因数返回。\n    \n    参数:\n    n (int): 要分解的正整数，是两个不同质数的乘积。\n    \n    返回:\n    int: 'n'的两个质因数中较大的一个。\n    \n    示例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "fr": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Trouver le plus grand facteur premier d'un entier positif donné.\n    \n    L'entier est supposé être le produit de exactement deux nombres premiers distincts. \n    La fonction parcourt les facteurs potentiels en commençant par le plus petit nombre premier (2) \n    et vérifie s'ils sont un facteur de 'n'. Si un facteur est trouvé, la fonction retourne \n    la division de 'n' par ce facteur, qui est le plus grand facteur premier. Si aucun facteur \n    n'est trouvé jusqu'à la racine carrée de 'n', alors 'n' lui-même est un nombre premier et est \n    retourné comme le plus grand facteur premier.\n    \n    Args:\n    n (int): L'entier positif à factoriser, qui est le produit de deux nombres premiers distincts.\n    \n    Returns:\n    int: Le plus grand des deux facteurs premiers de 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "de": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Finde den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n    \n    Es wird angenommen, dass die ganze Zahl das Produkt von genau zwei verschiedenen Primzahlen ist. \n    Die Funktion iteriert durch potenzielle Faktoren, beginnend mit dem kleinsten Primfaktor (2), \n    und überprüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion \n    die Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis zur \n    Quadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl und wird \n    als größter Primfaktor zurückgegeben.\n    \n    Args:\n    n (int): Die zu faktorisierende positive ganze Zahl, die das Produkt von zwei verschiedenen Primzahlen ist.\n    \n    Returns:\n    int: Der größere der beiden Primfaktoren von 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "ha": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Nemo mafi girman abin da ya fi girma na lamba mai kyau da aka bayar.\n    \n    Ana tsammanin lambobin suna daidai da samfurin lambobi masu firam guda biyu daban-daban. \n    Aiki yana yawo ta cikin abubuwan da za su iya zama masu yawa farawa daga mafi ƙarancin firam (2) \n    kuma yana duba idan suna da alaka da 'n'. Idan an sami abin da ya dace, aikin yana dawo da \n    rabon 'n' da wannan abin, wanda shine mafi girman abin da ya fi girma. Idan ba a sami \n    abubuwan da suka dace ba har zuwa tushen murabba'in 'n', to 'n' kanta lamba ce mai firam \n    kuma ana mayar da ita a matsayin mafi girman abin da ya fi girma.\n    \n    Args:\n    n (int): Lamba mai kyau don yin factorize, wanda shine samfurin lambobi masu firam guda biyu daban-daban.\n    \n    Returns:\n    int: Mafi girman daga cikin abubuwan da suka fi girma guda biyu na 'n'.\n    \n    Misalai:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "hi": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    दिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n    \n    पूर्णांक को ठीक दो भिन्न अभाज्य संख्याओं के गुणनफल के रूप में माना जाता है। \n    यह फ़ंक्शन संभावित गुणनखंडों के माध्यम से सबसे छोटे अभाज्य (2) से शुरू होकर \n    जाँच करता है कि क्या वे 'n' के गुणनखंड हैं। यदि कोई गुणनखंड पाया जाता है, तो \n    फ़ंक्शन 'n' को इस गुणनखंड से विभाजित कर लौटाता है, जो बड़ा अभाज्य गुणनखंड होता है। \n    यदि 'n' के वर्गमूल तक कोई गुणनखंड नहीं पाया जाता है, तो 'n' स्वयं एक अभाज्य संख्या \n    है और इसे सबसे बड़े अभाज्य गुणनखंड के रूप में लौटाया जाता है।\n    \n    तर्क:\n    n (int): वह धनात्मक पूर्णांक जिसे गुणनखंडित करना है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\n    \n    लौटाता है:\n    int: 'n' के दो अभाज्य गुणनखंडों में से बड़ा।\n    \n    उदाहरण:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "hu": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Keresse meg egy adott pozitív egész szám legnagyobb prímtényezőjét.\n    \n    Az egész szám feltételezhetően pontosan két különböző prímszám szorzata. \n    A függvény a legkisebb prímtől (2) kezdve iterál a lehetséges tényezőkön, \n    és ellenőrzi, hogy ezek tényezői-e 'n'-nek. Ha talál tényezőt, a függvény \n    visszaadja 'n' osztását ezzel a tényezővel, amely a nagyobb prímtényező. \n    Ha nem talál tényezőket 'n' négyzetgyökéig, akkor 'n' maga egy prímszám, \n    és visszatér a legnagyobb prímtényezőként.\n    \n    Args:\n    n (int): A pozitív egész szám, amelyet faktorizálni kell, és amely két különböző prím szorzata.\n    \n    Returns:\n    int: 'n' két prímtényezője közül a nagyobb.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "es": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Encuentra el mayor factor primo de un número entero positivo dado.\n    \n    Se asume que el entero es el producto de exactamente dos números primos distintos. \n    La función itera a través de posibles factores comenzando desde el menor primo (2) \n    y verifica si son un factor de 'n'. Si se encuentra un factor, la función devuelve \n    la división de 'n' por este factor, que es el mayor factor primo. Si no se encuentran \n    factores hasta la raíz cuadrada de 'n', entonces 'n' en sí mismo es un número primo \n    y se devuelve como el mayor factor primo.\n    \n    Argumentos:\n    n (int): El número entero positivo a factorizar, que es el producto de dos primos distintos.\n    \n    Devuelve:\n    int: El mayor de los dos factores primos de 'n'.\n    \n    Ejemplos:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "arb": "```python\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    إيجاد أكبر عامل أولي لعدد صحيح موجب معين.\n    \n    يُفترض أن العدد الصحيح هو ناتج ضرب عددين أوليين متميزين بالضبط.\n    تقوم الدالة بتكرار العوامل المحتملة بدءًا من أصغر عدد أولي (2)\n    وتتحقق مما إذا كانت عاملاً لـ 'n'. إذا تم العثور على عامل، تُعيد الدالة\n    قسمة 'n' على هذا العامل، وهو العامل الأولي الأكبر. إذا لم يتم العثور على عوامل\n    حتى الجذر التربيعي لـ 'n'، فإن 'n' نفسه هو عدد أولي ويتم\n    إعادته كأكبر عامل أولي.\n    \n    يعيدالحجج:\n    n (int): العدد الصحيح الموجب للتفكيك، وهو ناتج ضرب عددين أوليين متميزين.\n    \n    يعيد:\n    int: الأكبر بين العاملين الأوليين لـ 'n'.\n    \n    امثله:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n```", "sw": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Pata kigezo kikubwa zaidi cha nambari ya kwanza ya nambari chanya iliyotolewa.\n    \n    Nambari inadhaniwa kuwa ni zao la nambari mbili tofauti za kwanza. \n    Kazi inazunguka kupitia vigezo vinavyowezekana kuanzia na nambari ya kwanza ndogo zaidi (2) \n    na hukagua kama ni kigezo cha 'n'. Ikiwa kigezo kinapatikana, kazi inarudisha \n    mgawanyiko wa 'n' kwa kigezo hiki, ambacho ni kigezo kikubwa zaidi cha kwanza. Ikiwa hakuna vigezo \n    vinavyopatikana hadi mzizi wa mraba wa 'n', basi 'n' yenyewe ni nambari ya kwanza na \n    inarudishwa kama kigezo kikubwa zaidi cha kwanza.\n    \n    Hoja:\n    n (int): Nambari chanya ya kufanyia ufafanuzi, ambayo ni zao la nambari mbili tofauti za kwanza.\n    \n    Inarejesha:\n    int: Kigezo kikubwa zaidi kati ya viwili vya kwanza vya 'n'.\n    \n    Mifano:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "tr": "```python\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Verilen pozitif bir tamsayının en büyük asal çarpanını bulun.\n    \n    Tamsayının, tam olarak iki farklı asal sayının çarpımı olduğu varsayılır. \n    Fonksiyon, en küçük asal sayıdan (2) başlayarak potansiyel çarpanlar üzerinden \n    iterasyon yapar ve bunların 'n'nin bir çarpanı olup olmadığını kontrol eder. \n    Bir çarpan bulunursa, fonksiyon bu çarpan ile 'n'nin bölünmesini döndürür, \n    bu da daha büyük asal çarpandır. 'n'nin kareköküne kadar hiçbir çarpan \n    bulunamazsa, o zaman 'n' kendisi bir asal sayıdır ve en büyük asal çarpan \n    olarak döndürülür.\n    \n    Argümanlar:\n    n (int): İki farklı asalın çarpımı olan pozitif tamsayı.\n    \n    Döndürür:\n    int: 'n'nin iki asal çarpanından daha büyüğü.\n    \n    Örnekler:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n```", "vi": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Tìm ước số nguyên tố lớn nhất của một số nguyên dương cho trước.\n    \n    Số nguyên được giả định là tích của chính xác hai số nguyên tố khác nhau.\n    Hàm lặp qua các ước số tiềm năng bắt đầu từ số nguyên tố nhỏ nhất (2)\n    và kiểm tra nếu chúng là một ước số của 'n'. Nếu tìm thấy một ước số, hàm sẽ trả về\n    phép chia của 'n' cho ước số này, đó là ước số nguyên tố lớn hơn. Nếu không tìm thấy\n    ước số nào cho đến căn bậc hai của 'n', thì 'n' tự nó là một số nguyên tố và được\n    trả về như là ước số nguyên tố lớn nhất.\n    \n    Tham số:\n    n (int): Số nguyên dương cần phân tích, là tích của hai số nguyên tố khác nhau.\n    \n    Trả về:\n    int: Số nguyên tố lớn hơn trong hai ước số nguyên tố của 'n'.\n    \n    Ví dụ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "id": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Temukan faktor prima terbesar dari bilangan bulat positif yang diberikan.\n    \n    Bilangan bulat diasumsikan sebagai hasil kali dari tepat dua bilangan prima yang berbeda.\n    Fungsi ini mengiterasi melalui faktor potensial mulai dari bilangan prima terkecil (2)\n    dan memeriksa apakah mereka adalah faktor dari 'n'. Jika sebuah faktor ditemukan, fungsi \n    mengembalikan hasil pembagian 'n' dengan faktor ini, yang merupakan faktor prima yang lebih besar.\n    Jika tidak ada faktor yang ditemukan hingga akar kuadrat dari 'n', maka 'n' sendiri adalah \n    bilangan prima dan dikembalikan sebagai faktor prima terbesar.\n    \n    Args:\n    n (int): Bilangan bulat positif untuk difaktorkan, yang merupakan hasil kali dari dua bilangan prima yang berbeda.\n    \n    Returns:\n    int: Yang lebih besar dari dua faktor prima dari 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "ja": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    与えられた正の整数の最大の素因数を見つけます。\n    \n    整数は正確に2つの異なる素数の積であると仮定されます。\n    関数は最小の素数（2）から始めて潜在的な因数を反復し、\n    それらが 'n' の因数であるかどうかを確認します。因数が見つかった場合、\n    関数はこの因数で 'n' を割った結果を返します。これはより大きな素因数です。\n    'n' の平方根まで因数が見つからない場合、'n' 自体が素数であり、\n    最大の素因数として返されます。\n    \n    引数:\n    n (int): 2つの異なる素数の積である正の整数。\n    \n    戻り値:\n    int: 'n' の2つの素因数のうちの大きい方。\n    \n    例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "ko": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    주어진 양의 정수의 가장 큰 소인수를 찾습니다.\n    \n    정수는 정확히 두 개의 서로 다른 소수의 곱이라고 가정합니다.\n    함수는 가장 작은 소수(2)부터 시작하여 잠재적인 인수를 반복적으로 검사하고 \n    그것들이 'n'의 인수인지 확인합니다. 인수가 발견되면 함수는 이 인수로 'n'을 나눈 값을 반환하며, \n    이는 더 큰 소인수입니다. 'n'의 제곱근까지 인수가 발견되지 않으면, 'n' 자체가 소수이며 \n    가장 큰 소인수로 반환됩니다.\n    \n    매개변수:\n    n (int): 두 개의 서로 다른 소수의 곱인 양의 정수입니다.\n    \n    반환값:\n    int: 'n'의 두 소인수 중 더 큰 값입니다.\n    \n    예시:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n", "ml": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    നൽകിയ പോസിറ്റീവ് പൂർണ്ണസംഖ്യയുടെ ഏറ്റവും വലിയ പ്രധാന ഘടകം കണ്ടെത്തുക.\n    \n    ഈ പൂർണ്ണസംഖ്യ രണ്ട് വ്യത്യസ്തമായ പ്രധാന സംഖ്യകളുടെ ഗുണഫലമാണെന്ന് ധരിക്കുന്നു. \n    ഫംഗ്ഷൻ ഏറ്റവും ചെറിയ പ്രധാന സംഖ്യ (2) മുതൽ സാധ്യതയുള്ള ഘടകങ്ങളിലൂടെ ആവർത്തിച്ച് \n    അവ 'n'ന്റെ ഘടകമാണോ എന്ന് പരിശോധിക്കുന്നു. ഒരു ഘടകം കണ്ടെത്തിയാൽ, \n    ഫംഗ്ഷൻ ഈ ഘടകത്തിലൂടെ 'n'ന്റെ വിഭജനം തിരിച്ചുകൊടുക്കുന്നു, \n    ഇത് വലിയ പ്രധാന ഘടകമാണ്. 'n'ന്റെ വർഗ്ഗമൂലത്തിൽ വരെ \n    ഘടകങ്ങൾ കണ്ടെത്താനായില്ലെങ്കിൽ, 'n' തന്നെ ഒരു പ്രധാന സംഖ്യയാണ് \n    കൂടാതെ ഏറ്റവും വലിയ പ്രധാന ഘടകമായി തിരിച്ചുകൊടുക്കുന്നു.\n    \n    Args:\n    n (int): രണ്ട് വ്യത്യസ്ത പ്രധാന സംഖ്യകളുടെ ഗുണഫലമായ ഘടകീകരിക്കേണ്ട പോസിറ്റീവ് പൂർണ്ണസംഖ്യ.\n    \n    Returns:\n    int: 'n'ന്റെ രണ്ട് പ്രധാന ഘടകങ്ങളിൽ ഏറ്റവും വലിയത്.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "fa": "python\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    بزرگترین عامل اول یک عدد صحیح مثبت داده شده را پیدا کنید.\n    \n    فرض بر این است که عدد صحیح حاصل ضرب دقیقاً دو عدد اول متمایز است.\n    تابع از کوچکترین عدد اول (2) شروع به پیمایش عوامل بالقوه می‌کند\n    و بررسی می‌کند که آیا آنها یک عامل از 'n' هستند یا خیر. اگر عاملی پیدا شود، تابع\n    تقسیم 'n' بر این عامل را برمی‌گرداند، که عامل اول بزرگتر است. اگر هیچ عاملی\n    تا جذر 'n' پیدا نشود، سپس خود 'n' یک عدد اول است و\n    به عنوان بزرگترین عامل اول برگردانده می‌شود.\n    \n    آرگومان‌ها:\n    n (int): عدد صحیح مثبتی که باید تجزیه شود، که حاصل ضرب دو عدد اول متمایز است.\n    \n    بازگشتی:\n    int: بزرگتر از دو عامل اول 'n'.\n    \n    مثال‌ها:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n"}, "canonical_solution": "    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor", "instruction": {"en": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nՏվեք Python կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nДайте кратко описание на Python кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nBa da taƙaitaccen bayanin yaren ɗan adam (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\n以下のPythonコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nപൈതൺ കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഇല്ലാതെ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_largest_prime_factor():\n    test_cases = [\n        # Test case 1: composite number\n        {\n            'n': 35,  # 5 * 7\n            'expected': 7\n        },\n        # Test case 2: prime number itself\n        {\n            'n': 29,\n            'expected': 29\n        },\n        # Test case 3: composite number with a square of a prime\n        {\n            'n': 49,  # 7 * 7\n            'expected': 7\n        },\n        # Test case 4: large composite number\n        {\n            'n': 2 * 2 * 3 * 3 * 7 * 11,  # prime factors are 2, 3, 7, 11\n            'expected': 11\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = largest_prime_factor(test['n'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_largest_prime_factor()", "entry_point": "largest_prime_factor", "signature": "def largest_prime_factor(n: int) -> int:", "docstring": {"en": "Find the largest prime factor of a given positive integer.\n\nThe integer is assumed to be the product of exactly two distinct prime numbers.\nThe function iterates through potential factors starting from the smallest prime (2)\nand checks if they are a factor of 'n'. If a factor is found, the function returns\nthe division of 'n' by this factor, which is the larger prime factor. If no factors\nare found up to the square root of 'n', then 'n' itself is a prime number and is\nreturned as the largest prime factor.\n\nArgs:\nn (int): The positive integer to factorize, which is the product of two distinct primes.\n\nReturns:\nint: The larger of the two prime factors of 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "sq": "Gjeni faktorin më të madh prim të një numri të plotë pozitiv të dhënë.\n\nNumri i plotë supozohet të jetë produkt i saktësisht dy numrave të ndryshëm prim.\nFunksioni iteron nëpër faktorët e mundshëm duke filluar nga primi më i vogël (2)\ndhe kontrollon nëse janë faktorë të 'n'. Nëse gjendet një faktor, funksioni kthen\nndarjen e 'n' me këtë faktor, i cili është faktori më i madh prim. Nëse nuk gjenden faktorë\nderi në rrënjën katrore të 'n', atëherë vetë 'n' është një numër prim dhe kthehet si\nfaktori më i madh prim.\n\nArgumentet:\nn (int): Numri i plotë pozitiv për të faktorizuar, i cili është produkt i dy primeve të ndryshëm.\n\nKthen:\nint: Më i madhi nga dy faktorët prim të 'n'.\n\nShembuj:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "hy": "Գտնել տրված դրական ամբողջ թվի ամենամեծ պարզ բաժանարարը։\n\nԸնդունվում է, որ ամբողջ թիվը երկու տարբեր պարզ թվերի արտադրյալն է։\nՖունկցիան սկսում է հնարավոր բաժանարարների ստուգումը ամենափոքր պարզ թվից (2)\nև ստուգում է՝ արդյոք դրանք 'n'-ի բաժանարար են։ Եթե բաժանարար է գտնվում, ֆունկցիան վերադարձնում է\n'n'-ի բաժանումը այդ բաժանարարով, որը ամենամեծ պարզ բաժանարարն է։ Եթե բաժանարարներ չեն գտնվում մինչև 'n'-ի քառակուսի արմատը, ապա 'n'-ն ինքնին պարզ թիվ է և վերադարձվում է որպես ամենամեծ պարզ բաժանարար։\n\nԱրգումենտներ:\nn (int): Դրական ամբողջ թիվը, որը պետք է բաժանել, և որը երկու տարբեր պարզ թվերի արտադրյալն է։\n\nՎերադարձնում է:\nint: 'n'-ի երկու պարզ բաժանարարներից մեծը։\n\nՕրինակներ:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "bn": "একটি প্রদত্ত ধনাত্মক পূর্ণসংখ্যার বৃহত্তম মৌলিক গুণক খুঁজুন।\n\nপূর্ণসংখ্যাটি দুটি পৃথক মৌলিক সংখ্যার গুণফল বলে ধরা হয়। ফাংশনটি সম্ভাব্য গুণকগুলির মধ্য দিয়ে ক্ষুদ্রতম মৌলিক সংখ্যা (2) থেকে শুরু করে পুনরাবৃত্তি করে এবং পরীক্ষা করে যে তারা 'n'-এর গুণক কিনা। যদি একটি গুণক পাওয়া যায়, ফাংশনটি 'n' কে এই গুণক দ্বারা ভাগ করে, যা বৃহত্তম মৌলিক গুণক। যদি 'n'-এর বর্গমূল পর্যন্ত কোনো গুণক পাওয়া না যায়, তাহলে 'n' নিজেই একটি মৌলিক সংখ্যা এবং বৃহত্তম মৌলিক গুণক হিসেবে ফেরত দেওয়া হয়।\n\nArgs:\nn (int): যে ধনাত্মক পূর্ণসংখ্যাটিকে গুণফল করতে হবে, যা দুটি পৃথক মৌলিক সংখ্যার গুণফল।\n\nReturns:\nint: 'n'-এর দুটি মৌলিক গুণকের মধ্যে বৃহত্তম।\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "bg": "Намерете най-големия прост делител на дадено положително цяло число.\n\nПредполага се, че цялото число е произведение на точно два различни прости числа.\nФункцията обхожда потенциалните делители, започвайки от най-малкото просто число (2),\nи проверява дали те са делител на 'n'. Ако се намери делител, функцията връща\nрезултата от делението на 'n' с този делител, което е по-големият прост делител. Ако не се намерят делители до квадратния корен на 'n', тогава самото 'n' е просто число и се връща като най-големият прост делител.\n\nАргументи:\nn (int): Положителното цяло число за факторизиране, което е произведение на два различни прости числа.\n\nВръща:\nint: По-големият от двата прости делителя на 'n'.\n\nПримери:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "zh": "找到给定正整数的最大质因数。\n\n该整数被假定为恰好是两个不同质数的乘积。函数从最小的质数（2）开始迭代潜在因数，并检查它们是否为“n”的因数。如果找到一个因数，函数返回“n”除以该因数的结果，即较大的质因数。如果在“n”的平方根范围内未找到因数，则“n”本身是一个质数，并作为最大质因数返回。\n\n参数：\nn (int): 要分解的正整数，它是两个不同质数的乘积。\n\n返回：\nint: “n”的两个质因数中较大的一个。\n\n示例：\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "fr": "Trouver le plus grand facteur premier d'un entier positif donné.\n\nL'entier est supposé être le produit de deux nombres premiers distincts exactement.\nLa fonction parcourt les facteurs potentiels en commençant par le plus petit nombre premier (2)\net vérifie s'ils sont un facteur de 'n'. Si un facteur est trouvé, la fonction retourne\nla division de 'n' par ce facteur, qui est le plus grand facteur premier. Si aucun facteur\nn'est trouvé jusqu'à la racine carrée de 'n', alors 'n' lui-même est un nombre premier et est\nretourné comme le plus grand facteur premier.\n\nArgs:\nn (int): L'entier positif à factoriser, qui est le produit de deux nombres premiers distincts.\n\nReturns:\nint: Le plus grand des deux facteurs premiers de 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "de": "Finde den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n\nDie ganze Zahl wird angenommen als das Produkt von genau zwei verschiedenen Primzahlen.\nDie Funktion iteriert durch potenzielle Faktoren, beginnend mit dem kleinsten Primfaktor (2),\nund prüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion\ndie Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis zur\nQuadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl und\nwird als der größte Primfaktor zurückgegeben.\n\nArgumente:\nn (int): Die zu faktorisierende positive ganze Zahl, die das Produkt von zwei verschiedenen Primzahlen ist.\n\nRückgabewert:\nint: Der größere der beiden Primfaktoren von 'n'.\n\nBeispiele:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "ha": "Nemo mafi girman abin da ya fi girma na lamba mai kyau da aka bayar.\n\nAn yi tsammanin cewa lambar cikakke ita ce samfurin lambobi masu lamba guda biyu daban-daban.\nAikin yana zagayawa ta hanyar abubuwan da za su iya zama masu rarrabewa farawa daga mafi ƙarancin lamba mai lamba (2)\nkuma yana duba idan suna da alaƙa da 'n'. Idan aka sami wani abu mai rarrabewa, aikin yana dawowa\nrarraba 'n' da wannan abu, wanda shine mafi girman lamba mai lamba. Idan ba a sami abubuwan da za su iya zama masu rarrabewa ba har zuwa tushen murabba'in 'n', to 'n' kanta lamba ce mai lamba kuma ana dawowa da ita a matsayin mafi girman lamba mai lamba.\n\nArgs:\nn (int): Lambar cikakke mai kyau don rarrabewa, wanda shine samfurin lambobi masu lamba guda biyu daban-daban.\n\nReturns:\nint: Mafi girman lambobi masu lamba guda biyu na 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "hi": "दिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n\nदिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n\nThe integer is assumed to be the product of exactly two distinct prime numbers.\n\nपूर्णांक को ठीक दो भिन्न अभाज्य संख्याओं के गुणनफल के रूप में माना जाता है।\n\nThe function iterates through potential factors starting from the smallest prime (2) and checks if they are a factor of 'n'. If a factor is found, the function returns the division of 'n' by this factor, which is the larger prime factor. If no factors are found up to the square root of 'n', then 'n' itself is a prime number and is returned as the largest prime factor.\n\nयह फ़ंक्शन संभावित गुणनखंडों के माध्यम से सबसे छोटे अभाज्य (2) से शुरू होकर पुनरावृत्ति करता है और जांचता है कि क्या वे 'n' का गुणनखंड हैं। यदि कोई गुणनखंड पाया जाता है, तो फ़ंक्शन 'n' को इस गुणनखंड से विभाजित करके लौटाता है, जो कि बड़ा अभाज्य गुणनखंड होता है। यदि 'n' के वर्गमूल तक कोई गुणनखंड नहीं मिलता है, तो 'n' स्वयं एक अभाज्य संख्या है और इसे सबसे बड़े अभाज्य गुणनखंड के रूप में लौटाया जाता है।\n\nArgs:\nn (int): The positive integer to factorize, which is the product of two distinct primes.\n\nn (int): वह धनात्मक पूर्णांक जिसे गुणनखंडित करना है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\n\nReturns:\nint: The larger of the two prime factors of 'n'.\n\nReturns:\nint: 'n' के दो अभाज्य गुणनखंडों में से बड़ा।\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "hu": "Keresse meg egy adott pozitív egész szám legnagyobb prímtényezőjét.\n\nFeltételezzük, hogy az egész szám pontosan két különböző prímszám szorzata.\nA függvény a legkisebb prímtől (2) kezdve iterál a lehetséges tényezőkön, és ellenőrzi, hogy tényezője-e 'n'-nek. Ha talál tényezőt, a függvény visszaadja 'n' osztását ezzel a tényezővel, amely a nagyobb prímtényező. Ha nem talál tényezőket 'n' négyzetgyökéig, akkor maga 'n' egy prímszám, és visszaadja, mint a legnagyobb prímtényezőt.\n\nArgs:\nn (int): A pozitív egész szám, amelyet faktorizálni kell, és amely két különböző prím szorzata.\n\nReturns:\nint: 'n' két prímtényezője közül a nagyobb.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "es": "Encuentra el mayor factor primo de un entero positivo dado.\n\nSe asume que el entero es el producto de exactamente dos números primos distintos. La función itera a través de posibles factores comenzando desde el primo más pequeño (2) y verifica si son un factor de 'n'. Si se encuentra un factor, la función devuelve la división de 'n' por este factor, que es el mayor factor primo. Si no se encuentran factores hasta la raíz cuadrada de 'n', entonces 'n' en sí mismo es un número primo y se devuelve como el mayor factor primo.\n\nArgumentos:\nn (int): El entero positivo a factorizar, que es el producto de dos primos distintos.\n\nDevuelve:\nint: El mayor de los dos factores primos de 'n'.\n\nEjemplos:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "arb": "البحث عن أكبر عامل أولي لعدد صحيح موجب معين.\n\nيفترض أن العدد الصحيح هو ناتج ضرب عددين أوليين مختلفين تمامًا.\nتقوم الدالة بالتكرار عبر العوامل المحتملة بدءًا من أصغر عدد أولي (2)\nوتتحقق مما إذا كانت عاملاً لـ 'n'. إذا تم العثور على عامل، تقوم الدالة بإرجاع\nقسمة 'n' على هذا العامل، وهو العامل الأولي الأكبر. إذا لم يتم العثور على عوامل\nحتى الجذر التربيعي لـ 'n'، فإن 'n' نفسه هو عدد أولي ويتم إرجاعه كأكبر عامل أولي.\n\nالمعاملات:\nn (int): العدد الصحيح الموجب لتفكيكه، وهو ناتج ضرب عددين أوليين مختلفين.\n\nالقيم المعادة:\nint: الأكبر بين العاملين الأوليين لـ 'n'.\n\nأمثلة:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "sw": "Pata kigezo kikubwa zaidi cha nambari ya kwanza ya nambari chanya iliyotolewa.\n\nNambari hiyo inadhaniwa kuwa ni zao la nambari mbili tofauti za msingi.\nKazi hii inarudia kupitia sababu zinazowezekana kuanzia na nambari ndogo zaidi ya msingi (2)\nna inakagua kama ni sababu ya 'n'. Ikiwa sababu inapatikana, kazi inarejesha\nmgawanyiko wa 'n' na sababu hii, ambayo ni sababu kubwa zaidi ya msingi. Ikiwa hakuna sababu\nzinazopatikana hadi mzizi wa mraba wa 'n', basi 'n' yenyewe ni nambari ya msingi na\ninarejeshwa kama sababu kubwa zaidi ya msingi.\n\nHoja:\nn (int): Nambari chanya ya kufanyia sababu, ambayo ni zao la nambari mbili tofauti za msingi.\n\nInarejesha:\nint: Moja ya sababu kubwa zaidi kati ya mbili za msingi za 'n'.\n\nMifano:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "tr": "Verilen pozitif bir tam sayının en büyük asal çarpanını bulun.\n\nTam sayının, tam olarak iki farklı asal sayının çarpımı olduğu varsayılmaktadır.\nFonksiyon, en küçük asal sayıdan (2) başlayarak potansiyel çarpanlar arasında iterasyon yapar\nve bunların 'n' sayısının bir çarpanı olup olmadığını kontrol eder. Bir çarpan bulunursa, fonksiyon\n'n' sayısının bu çarpana bölünmesini döndürür, bu da daha büyük asal çarpandır. Eğer 'n' sayısının\nkareköküne kadar hiçbir çarpan bulunamazsa, o zaman 'n' sayısının kendisi bir asal sayıdır ve\nen büyük asal çarpan olarak döndürülür.\n\nArgümanlar:\nn (int): İki farklı asalın çarpımı olan ve çarpanlarına ayrılacak pozitif tam sayı.\n\nDöndürür:\nint: 'n' sayısının iki asal çarpanından daha büyüğü.\n\nÖrnekler:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "vi": "Tìm ước số nguyên tố lớn nhất của một số nguyên dương cho trước.\n\nSố nguyên được giả định là tích của chính xác hai số nguyên tố khác nhau. Hàm này lặp qua các ước số tiềm năng bắt đầu từ số nguyên tố nhỏ nhất (2) và kiểm tra xem chúng có phải là ước số của 'n' hay không. Nếu tìm thấy một ước số, hàm trả về phép chia của 'n' cho ước số này, đó là ước số nguyên tố lớn hơn. Nếu không tìm thấy ước số nào cho đến căn bậc hai của 'n', thì bản thân 'n' là một số nguyên tố và được trả về như ước số nguyên tố lớn nhất.\n\nTham số:\nn (int): Số nguyên dương cần phân tích, là tích của hai số nguyên tố khác nhau.\n\nTrả về:\nint: Số lớn hơn trong hai ước số nguyên tố của 'n'.\n\nVí dụ:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "id": "Temukan faktor prima terbesar dari bilangan bulat positif yang diberikan.\n\nBilangan bulat diasumsikan sebagai hasil kali dari tepat dua bilangan prima yang berbeda. Fungsi ini mengiterasi melalui faktor potensial mulai dari bilangan prima terkecil (2) dan memeriksa apakah mereka adalah faktor dari 'n'. Jika sebuah faktor ditemukan, fungsi mengembalikan hasil pembagian 'n' dengan faktor ini, yang merupakan faktor prima yang lebih besar. Jika tidak ada faktor yang ditemukan hingga akar kuadrat dari 'n', maka 'n' sendiri adalah bilangan prima dan dikembalikan sebagai faktor prima terbesar.\n\nArgumen:\nn (int): Bilangan bulat positif untuk difaktorkan, yang merupakan hasil kali dari dua bilangan prima yang berbeda.\n\nMengembalikan:\nint: Yang lebih besar dari dua faktor prima dari 'n'.\n\nContoh:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "ja": "与えられた正の整数の最大の素因数を見つけます。\n\n整数は、正確に2つの異なる素数の積であると仮定されます。関数は、最小の素数（2）から始めて潜在的な因数を反復し、それらが 'n' の因数であるかどうかを確認します。因数が見つかった場合、関数はこの因数で 'n' を割った結果を返します。これはより大きい素因数です。もし 'n' の平方根まで因数が見つからない場合、'n' 自体が素数であり、最大の素因数として返されます。\n\n引数:\nn (int): 素因数分解する正の整数で、2つの異なる素数の積です。\n\n戻り値:\nint: 'n' の2つの素因数のうちの大きい方。\n\n例:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "ko": "주어진 양의 정수의 가장 큰 소인수를 찾습니다.\n\n정수는 정확히 두 개의 서로 다른 소수의 곱이라고 가정합니다.\n함수는 가장 작은 소수(2)부터 시작하여 잠재적인 인수를 반복적으로 검사하고,\n그들이 'n'의 인수인지 확인합니다. 인수가 발견되면, 함수는 'n'을 이 인수로 나눈 값을 반환하며,\n이는 더 큰 소인수입니다. 'n'의 제곱근까지 인수가 발견되지 않으면,\n'n' 자체가 소수이며 가장 큰 소인수로 반환됩니다.\n\n인수:\nn (int): 두 개의 서로 다른 소수의 곱인 양의 정수.\n\n반환:\nint: 'n'의 두 소인수 중 더 큰 값.\n\n예제:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "ml": "ഒരു നൽകിയ പോസിറ്റീവ് പൂർണ്ണസംഖ്യയുടെ ഏറ്റവും വലിയ പ്രധാന ഘടകം കണ്ടെത്തുക.\n\nഈ പൂർണ്ണസംഖ്യ രണ്ട് വ്യത്യസ്ത പ്രധാന സംഖ്യകളുടെ ഗുണഫലമാണെന്ന് കരുതുന്നു. ഏറ്റവും ചെറിയ പ്രധാന സംഖ്യയായ 2 മുതൽ സാധ്യതയുള്ള ഘടകങ്ങൾ പരിശോധിച്ച് അവ 'n'ന്റെ ഘടകമാണോ എന്ന് പരിശോധിക്കുന്നു. ഒരു ഘടകം കണ്ടെത്തിയാൽ, 'n'നെ ഈ ഘടകത്തോടെ വിഭജിക്കുന്നതിലൂടെ ലഭിക്കുന്ന വലിയ പ്രധാന ഘടകം ഫംഗ്ഷൻ തിരികെ നൽകുന്നു. 'n'ന്റെ വർഗ്ഗമൂലത്തിൽ വരെ ഘടകങ്ങൾ കണ്ടെത്താനാകാത്ത പക്ഷം, 'n' തന്നെ ഒരു പ്രധാന സംഖ്യയാണ്, അതിനാൽ ഏറ്റവും വലിയ പ്രധാന ഘടകമായി തിരികെ നൽകുന്നു.\n\nആർഗ്സ്:\nn (int): രണ്ട് വ്യത്യസ്ത പ്രധാന സംഖ്യകളുടെ ഗുണഫലമായ ഘടകീകരിക്കേണ്ട പോസിറ്റീവ് പൂർണ്ണസംഖ്യ.\n\nമടക്കം:\nint: 'n'ന്റെ രണ്ട് പ്രധാന ഘടകങ്ങളിൽ ഏറ്റവും വലിയത്.\n\nഉദാഹരണങ്ങൾ:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "fa": "بزرگترین عامل اول یک عدد صحیح مثبت داده شده را پیدا کنید.\n\nفرض بر این است که عدد صحیح حاصل ضرب دقیقاً دو عدد اول متمایز است. تابع از کوچکترین عدد اول (2) شروع به تکرار از طریق عوامل بالقوه می‌کند و بررسی می‌کند که آیا آن‌ها عاملی از 'n' هستند یا خیر. اگر عاملی پیدا شود، تابع تقسیم 'n' بر این عامل را برمی‌گرداند که عامل اول بزرگتر است. اگر تا ریشه دوم 'n' هیچ عاملی پیدا نشود، در این صورت خود 'n' یک عدد اول است و به عنوان بزرگترین عامل اول برگردانده می‌شود.\n\nآرگومان‌ها:\nn (int): عدد صحیح مثبت برای تجزیه، که حاصل ضرب دو عدد اول متمایز است.\n\nبازگشتی:\nint: بزرگترین عامل اول از دو عامل اول 'n'.\n\nمثال‌ها:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29"}}
{"task_id": "Python/24", "prompt": {"en": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    - count_partitions(7, 3, 1) will return 4, because there are four ways to partition \n      the number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) will return 3, because there are three ways to partition \n      the number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].\n    \"\"\"", "sq": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Numëroni numrin e mënyrave për të ndarë një numër të plotë n në k pjesë,\n    ku secila pjesë është të paktën x dhe rendi i pjesëve nuk ka rëndësi.\n\n    Parametrat:\n    n (int): Numri i plotë që do të ndahet.\n    k (int): Numri i pjesëve për të ndarë n.\n    x (int): Vlera minimale për secilën pjesë.\n\n    Kthen:\n    int: Numri i mënyrave të ndarjes së dallueshme.\n\n    Shembuj:\n    - count_partitions(7, 3, 1) do të kthejë 4, sepse ka katër mënyra për të ndarë \n      numrin 7 në 3 pjesë me secilën pjesë të paktën 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) do të kthejë 3, sepse ka tre mënyra për të ndarë \n      numrin 6 në 2 pjesë me secilën pjesë të paktën 1: [1,5], [2,4], [3,3].\n    \"\"\"", "hy": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Հաշվել, թե քանի եղանակով կարելի է n ամբողջ թիվը բաժանել k մասերի,\n    որտեղ յուրաքանչյուր մասը առնվազն x է, և մասերի կարգը նշանակություն չունի։\n\n    Պարամետրեր:\n    n (int): Բաժանվող ամբողջ թիվը։\n    k (int): Մասերի քանակը, որոնց n-ը պետք է բաժանել։\n    x (int): Յուրաքանչյուր մասի նվազագույն արժեքը։\n\n    Վերադարձնում է:\n    int: Տարբեր բաժանումների եղանակների քանակը։\n\n    Օրինակներ:\n    - count_partitions(7, 3, 1) կվերադարձնի 4, քանի որ կա չորս եղանակ 7 թիվը բաժանելու \n      3 մասերի, որտեղ յուրաքանչյուր մասը առնվազն 1 է՝ [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3]։\n    - count_partitions(6, 2, 1) կվերադարձնի 3, քանի որ կա երեք եղանակ 6 թիվը բաժանելու \n      2 մասերի, որտեղ յուրաքանչյուր մասը առնվազն 1 է՝ [1,5], [2,4], [3,3]։\n    \"\"\"", "bn": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    একটি পূর্ণসংখ্যা n কে k অংশে ভাগ করার উপায়গুলির সংখ্যা গণনা করুন,\n    যেখানে প্রতিটি অংশ কমপক্ষে x এবং অংশগুলির ক্রম গুরুত্বপূর্ণ নয়।\n\n    প্যারামিটারসমূহ:\n    n (int): পূর্ণসংখ্যাটি যা ভাগ করা হবে।\n    k (int): অংশের সংখ্যা যার মধ্যে n ভাগ করা হবে।\n    x (int): প্রতিটি অংশের জন্য ন্যূনতম মান।\n\n    রিটার্নস:\n    int: পৃথক ভাগ করার উপায়গুলির সংখ্যা।\n\n    উদাহরণ:\n    - count_partitions(7, 3, 1) 4 ফেরত দেবে, কারণ 7 সংখ্যাটিকে 3 অংশে ভাগ করার চারটি উপায় আছে \n      যেখানে প্রতিটি অংশ কমপক্ষে 1: [1,1,5], [1,2,4], [1,3,3], [2,2,3]।\n    - count_partitions(6, 2, 1) 3 ফেরত দেবে, কারণ 6 সংখ্যাটিকে 2 অংশে ভাগ করার তিনটি উপায় আছে \n      যেখানে প্রতিটি অংশ কমপক্ষে 1: [1,5], [2,4], [3,3]।\n    \"\"\"", "bg": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Брой на начините за разделяне на цяло число n на k части,\n    където всяка част е поне x и редът на частите няма значение.\n\n    Параметри:\n    n (int): Цялото число, което ще бъде разделено.\n    k (int): Броят на частите, на които да се раздели n.\n    x (int): Минималната стойност за всяка част.\n\n    Връща:\n    int: Броят на различните начини за разделяне.\n\n    Примери:\n    - count_partitions(7, 3, 1) ще върне 4, защото има четири начина да се раздели \n      числото 7 на 3 части, като всяка част е поне 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) ще върне 3, защото има три начина да се раздели \n      числото 6 на 2 части, като всяка част е поне 1: [1,5], [2,4], [3,3].\n    \"\"\"", "zh": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    计算将整数 n 分成 k 部分的方法数，\n    其中每部分至少为 x，且部分的顺序不重要。\n\n    参数:\n    n (int): 要分割的整数。\n    k (int): 将 n 分成的部分数。\n    x (int): 每部分的最小值。\n\n    返回:\n    int: 不同分割方式的数量。\n\n    示例:\n    - count_partitions(7, 3, 1) 将返回 4，因为有四种方法可以将数字 7 分成 3 部分，\n      每部分至少为 1: [1,1,5], [1,2,4], [1,3,3], [2,2,3]。\n    - count_partitions(6, 2, 1) 将返回 3，因为有三种方法可以将数字 6 分成 2 部分，\n      每部分至少为 1: [1,5], [2,4], [3,3]。\n    \"\"\"", "fr": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Compter le nombre de façons de partitionner un entier n en k parties,\n    où chaque partie est au moins x et l'ordre des parties n'a pas d'importance.\n\n    Paramètres:\n    n (int): L'entier à partitionner.\n    k (int): Le nombre de parties pour diviser n.\n    x (int): La valeur minimale pour chaque partie.\n\n    Renvoie:\n    int: Le nombre de façons distinctes de partitionnement.\n\n    Exemples:\n    - count_partitions(7, 3, 1) renverra 4, car il y a quatre façons de partitionner \n      le nombre 7 en 3 parties avec chaque partie étant au moins 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) renverra 3, car il y a trois façons de partitionner \n      le nombre 6 en 2 parties avec chaque partie étant au moins 1: [1,5], [2,4], [3,3].\n    \"\"\"", "de": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Zählt die Anzahl der Möglichkeiten, eine ganze Zahl n in k Teile zu partitionieren,\n    wobei jeder Teil mindestens x ist und die Reihenfolge der Teile keine Rolle spielt.\n\n    Parameter:\n    n (int): Die zu partitionierende ganze Zahl.\n    k (int): Die Anzahl der Teile, in die n aufgeteilt werden soll.\n    x (int): Der Mindestwert für jeden Teil.\n\n    Rückgabewert:\n    int: Die Anzahl der unterschiedlichen Partitionierungsmöglichkeiten.\n\n    Beispiele:\n    - count_partitions(7, 3, 1) wird 4 zurückgeben, da es vier Möglichkeiten gibt, \n      die Zahl 7 in 3 Teile zu partitionieren, wobei jeder Teil mindestens 1 ist: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) wird 3 zurückgeben, da es drei Möglichkeiten gibt, \n      die Zahl 6 in 2 Teile zu partitionieren, wobei jeder Teil mindestens 1 ist: [1,5], [2,4], [3,3].\n    \"\"\"", "ha": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Ƙirga adadin hanyoyin da za a iya raba lamba n zuwa k ɓangarori,\n    inda kowanne ɓangare ya kasance aƙalla x kuma tsarin ɓangarorin bai damu ba.\n\n    Sigogi:\n    n (int): Lambar da za a raba.\n    k (int): Yawan ɓangarorin da za a raba n.\n    x (int): Ƙimar mafi ƙaranci ga kowanne ɓangare.\n\n    Komawa:\n    int: Yawan hanyoyin rarrabawa daban-daban.\n\n    Misalai:\n    - count_partitions(7, 3, 1) zai dawo da 4, domin akwai hanyoyi guda huɗu da za a raba \n      lamba 7 zuwa ɓangarori 3 tare da kowanne ɓangare ya kasance aƙalla 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) zai dawo da 3, domin akwai hanyoyi guda uku da za a raba \n      lamba 6 zuwa ɓangarori 2 tare da kowanne ɓangare ya kasance aƙalla 1: [1,5], [2,4], [3,3].\n    \"\"\"", "hi": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    किसी पूर्णांक n को k भागों में विभाजित करने के तरीकों की संख्या गिनें,\n    जहाँ प्रत्येक भाग कम से कम x हो और भागों के क्रम का कोई महत्व न हो।\n\n    पैरामीटर्स:\n    n (int): विभाजित करने के लिए पूर्णांक।\n    k (int): भागों की संख्या जिसमें n को विभाजित करना है।\n    x (int): प्रत्येक भाग के लिए न्यूनतम मान।\n\n    रिटर्न्स:\n    int: विभिन्न विभाजन तरीकों की संख्या।\n\n    उदाहरण:\n    - count_partitions(7, 3, 1) 4 लौटाएगा, क्योंकि 7 को 3 भागों में विभाजित करने के \n      चार तरीके हैं जहाँ प्रत्येक भाग कम से कम 1 है: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3]।\n    - count_partitions(6, 2, 1) 3 लौटाएगा, क्योंकि 6 को 2 भागों में विभाजित करने के \n      तीन तरीके हैं जहाँ प्रत्येक भाग कम से कम 1 है: [1,5], [2,4], [3,3]।\n    \"\"\"", "hu": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Számolja meg, hányféleképpen lehet egy n egész számot k részre osztani,\n    ahol minden rész legalább x, és a részek sorrendje nem számít.\n\n    Paraméterek:\n    n (int): Az egész szám, amelyet fel kell osztani.\n    k (int): A részek száma, amelyre n-t fel kell osztani.\n    x (int): A minimális érték minden rész esetében.\n\n    Visszatér:\n    int: Az eltérő felosztási módok száma.\n\n    Példák:\n    - count_partitions(7, 3, 1) visszaadja a 4-et, mert négyféleképpen lehet \n      a 7-es számot 3 részre osztani úgy, hogy minden rész legalább 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) visszaadja a 3-at, mert háromféleképpen lehet \n      a 6-os számot 2 részre osztani úgy, hogy minden rész legalább 1: [1,5], [2,4], [3,3].\n    \"\"\"", "es": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Cuenta el número de formas de particionar un entero n en k partes,\n    donde cada parte es al menos x y el orden de las partes no importa.\n\n    Parámetros:\n    n (int): El entero a ser particionado.\n    k (int): El número de partes en las que dividir n.\n    x (int): El valor mínimo para cada parte.\n\n    Devuelve:\n    int: El número de formas distintas de particionar.\n\n    Ejemplos:\n    - count_partitions(7, 3, 1) devolverá 4, porque hay cuatro formas de particionar \n      el número 7 en 3 partes con cada parte siendo al menos 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) devolverá 3, porque hay tres formas de particionar \n      el número 6 en 2 partes con cada parte siendo al menos 1: [1,5], [2,4], [3,3].\n    \"\"\"", "arb": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    احسب عدد الطرق لتقسيم عدد صحيح n إلى k أجزاء،\n    حيث أن كل جزء لا يقل عن x وترتيب الأجزاء لا يهم.\n\n    المعلمات:\n    n (int): العدد الصحيح الذي سيتم تقسيمه.\n    k (int): عدد الأجزاء لتقسيم n إليها.\n    x (int): القيمة الدنيا لكل جزء.\n\n    العوائد:\n    int: عدد طرق التقسيم المميزة.\n\n    أمثلة:\n    - count_partitions(7, 3, 1) سيعيد 4، لأنه هناك أربع طرق لتقسيم \n      العدد 7 إلى 3 أجزاء بحيث يكون كل جزء على الأقل 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) سيعيد 3، لأنه هناك ثلاث طرق لتقسيم \n      العدد 6 إلى 2 أجزاء بحيث يكون كل جزء على الأقل 1: [1,5], [2,4], [3,3].\n    \"\"\"", "sw": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Hesabu idadi ya njia za kugawa nambari n katika sehemu k,\n    ambapo kila sehemu ni angalau x na mpangilio wa sehemu haujalishi.\n\n    Vigezo:\n    n (int): Nambari ya kugawanywa.\n    k (int): Idadi ya sehemu za kugawa n.\n    x (int): Thamani ya chini kwa kila sehemu.\n\n    Inarejesha:\n    int: Idadi ya njia tofauti za kugawa.\n\n    Mifano:\n    - count_partitions(7, 3, 1) itarejesha 4, kwa sababu kuna njia nne za kugawa \n      nambari 7 katika sehemu 3 na kila sehemu ikiwa angalau 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) itarejesha 3, kwa sababu kuna njia tatu za kugawa \n      nambari 6 katika sehemu 2 na kila sehemu ikiwa angalau 1: [1,5], [2,4], [3,3].\n    \"\"\"", "tr": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Bir tamsayı n'yi k parçaya ayırmanın yollarını sayar,\n    burada her bir parça en az x'tir ve parçaların sırası önemli değildir.\n\n    Parametreler:\n    n (int): Parçalanacak tamsayı.\n    k (int): n'yi bölmek için parça sayısı.\n    x (int): Her bir parça için minimum değer.\n\n    Döndürür:\n    int: Farklı bölme yollarının sayısı.\n\n    Örnekler:\n    - count_partitions(7, 3, 1) 4 döndürecektir, çünkü 7 sayısını 3 parçaya \n      ayırmanın dört yolu vardır ve her parça en az 1'dir: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) 3 döndürecektir, çünkü 6 sayısını 2 parçaya \n      ayırmanın üç yolu vardır ve her parça en az 1'dir: [1,5], [2,4], [3,3].\n    \"\"\"", "vi": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Đếm số cách để phân hoạch một số nguyên n thành k phần,\n    trong đó mỗi phần ít nhất là x và thứ tự của các phần không quan trọng.\n\n    Tham số:\n    n (int): Số nguyên cần được phân hoạch.\n    k (int): Số phần để chia n.\n    x (int): Giá trị tối thiểu cho mỗi phần.\n\n    Trả về:\n    int: Số cách phân hoạch khác biệt.\n\n    Ví dụ:\n    - count_partitions(7, 3, 1) sẽ trả về 4, vì có bốn cách để phân hoạch \n      số 7 thành 3 phần với mỗi phần ít nhất là 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) sẽ trả về 3, vì có ba cách để phân hoạch \n      số 6 thành 2 phần với mỗi phần ít nhất là 1: [1,5], [2,4], [3,3].\n    \"\"\"", "id": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Hitung jumlah cara untuk membagi bilangan bulat n menjadi k bagian,\n    di mana setiap bagian setidaknya x dan urutan bagian tidak penting.\n\n    Parameter:\n    n (int): Bilangan bulat yang akan dibagi.\n    k (int): Jumlah bagian untuk membagi n.\n    x (int): Nilai minimum untuk setiap bagian.\n\n    Mengembalikan:\n    int: Jumlah cara pembagian yang berbeda.\n\n    Contoh:\n    - count_partitions(7, 3, 1) akan mengembalikan 4, karena ada empat cara untuk membagi \n      angka 7 menjadi 3 bagian dengan setiap bagian setidaknya 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) akan mengembalikan 3, karena ada tiga cara untuk membagi \n      angka 6 menjadi 2 bagian dengan setiap bagian setidaknya 1: [1,5], [2,4], [3,3].\n    \"\"\"", "ja": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    整数 n を k 個の部分に分割する方法の数を数えます。\n    各部分は少なくとも x であり、部分の順序は関係ありません。\n\n    パラメータ:\n    n (int): 分割される整数。\n    k (int): n を分割する部分の数。\n    x (int): 各部分の最小値。\n\n    戻り値:\n    int: 異なる分割方法の数。\n\n    例:\n    - count_partitions(7, 3, 1) は 4 を返します。なぜなら、数 7 を 3 つの部分に分割する方法は\n      各部分が少なくとも 1 であるものが 4 通りあるからです: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3]。\n    - count_partitions(6, 2, 1) は 3 を返します。なぜなら、数 6 を 2 つの部分に分割する方法は\n      各部分が少なくとも 1 であるものが 3 通りあるからです: [1,5], [2,4], [3,3]。\n    \"\"\"", "ko": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    정수 n을 k개의 부분으로 분할하는 방법의 수를 계산합니다.\n    각 부분은 최소 x 이상이어야 하며, 부분의 순서는 중요하지 않습니다.\n\n    매개변수:\n    n (int): 분할할 정수.\n    k (int): n을 나눌 부분의 수.\n    x (int): 각 부분의 최소값.\n\n    반환값:\n    int: 서로 다른 분할 방법의 수.\n\n    예시:\n    - count_partitions(7, 3, 1)은 4를 반환합니다. 왜냐하면 숫자 7을 최소 1 이상의 3개의 부분으로 \n      분할하는 네 가지 방법이 있기 때문입니다: [1,1,5], [1,2,4], [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1)은 3을 반환합니다. 왜냐하면 숫자 6을 최소 1 이상의 2개의 부분으로 \n      분할하는 세 가지 방법이 있기 때문입니다: [1,5], [2,4], [3,3].\n    \"\"\"", "ml": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    ഒരു പൂർണ്ണസംഖ്യ n-നെ k ഭാഗങ്ങളായി വിഭജിക്കുന്നതിനുള്ള മാർഗ്ഗങ്ങളുടെ എണ്ണം എണ്ണുക,\n    ഓരോ ഭാഗവും കുറഞ്ഞത് x ആയിരിക്കണം, ഭാഗങ്ങളുടെ ക്രമം പ്രശ്നമല്ല.\n\n    പാരാമീറ്ററുകൾ:\n    n (int): വിഭജിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n    k (int): n-നെ വിഭജിക്കേണ്ട ഭാഗങ്ങളുടെ എണ്ണം.\n    x (int): ഓരോ ഭാഗത്തിനും കുറഞ്ഞത് ഈ മൂല്യം.\n\n    മടക്കുന്നു:\n    int: വ്യത്യസ്തമായ വിഭജന മാർഗ്ഗങ്ങളുടെ എണ്ണം.\n\n    ഉദാഹരണങ്ങൾ:\n    - count_partitions(7, 3, 1) 4-നെ മടക്കുന്നു, കാരണം 7-നെ 3 ഭാഗങ്ങളായി \n      ഓരോ ഭാഗവും കുറഞ്ഞത് 1 ആയുള്ള നാല് വിഭജന മാർഗ്ഗങ്ങൾ ഉണ്ട്: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) 3-നെ മടക്കുന്നു, കാരണം 6-നെ 2 ഭാഗങ്ങളായി \n      ഓരോ ഭാഗവും കുറഞ്ഞത് 1 ആയുള്ള മൂന്ന് വിഭജന മാർഗ്ഗങ്ങൾ ഉണ്ട്: [1,5], [2,4], [3,3].\n    \"\"\"", "fa": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    تعداد راه‌های تقسیم یک عدد صحیح n به k قسمت را بشمارید،\n    به طوری که هر قسمت حداقل x باشد و ترتیب قسمت‌ها مهم نباشد.\n\n    پارامترها:\n    n (int): عدد صحیحی که باید تقسیم شود.\n    k (int): تعداد قسمت‌هایی که n باید به آن تقسیم شود.\n    x (int): حداقل مقدار برای هر قسمت.\n\n    بازگشت:\n    int: تعداد راه‌های تقسیم‌بندی متمایز.\n\n    مثال‌ها:\n    - count_partitions(7, 3, 1) مقدار 4 را برمی‌گرداند، زیرا چهار راه برای تقسیم \n      عدد 7 به 3 قسمت وجود دارد که هر قسمت حداقل 1 است: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) مقدار 3 را برمی‌گرداند، زیرا سه راه برای تقسیم \n      عدد 6 به 2 قسمت وجود دارد که هر قسمت حداقل 1 است: [1,5], [2,4], [3,3].\n    \"\"\""}, "canonical_solution": "    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count", "instruction": {"en": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nՏվյալ Python կոդի համար տրամադրեք կարճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nपायथन कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\n以下のPythonコードの自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\n최대 500자를 사용하여 Python 코드에 대한 간결한 자연어 설명(docstring)을 영어로 제공하세요.", "ml": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nPython കോഡിന്റെ സവിശേഷതകൾ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ മലയാളത്തിൽ വിശദീകരിക്കുന്ന ഒരു ചുരുക്കമായ നാച്ചുറൽ ലാംഗ്വേജ് വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_count_partitions():\n    # Test case 1: Simple case\n    result = count_partitions(7, 3, 1)\n    assert result == 4, f\"Expected 4, got {result}\"\n\n    # Test case 2: Another simple case\n    result = count_partitions(6, 2, 1)\n    assert result == 3, f\"Expected 3, got {result}\"\n\n    # Test case 3: Partitioning into a larger number of parts\n    result = count_partitions(8, 4, 1)\n    assert result == 5, f\"Expected 5, got {result}\"\n\n    print(\"All test cases passed successfully!\")\n\n\n# Call the test function to run the test cases\ntest_count_partitions()", "entry_point": "count_partitions", "signature": "def count_partitions(n: int, k: int, x: int) -> int:", "docstring": {"en": "Count the number of ways to partition an integer n into k parts,\nwhere each part is at least x and order of parts does not matter.\n\nParameters:\nn (int): The integer to be partitioned.\nk (int): The number of parts to divide n into.\nx (int): The minimum value for each part.\n\nReturns:\nint: The number of distinct partitioning ways.\n\nExamples:\n- count_partitions(7, 3, 1) will return 4, because there are four ways to partition\nthe number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) will return 3, because there are three ways to partition\nthe number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].", "sq": "Numëroni numrin e mënyrave për të ndarë një numër të plotë n në k pjesë,\nku secila pjesë është të paktën x dhe rendi i pjesëve nuk ka rëndësi.\n\nParametrat:\nn (int): Numri i plotë që do të ndahet.\nk (int): Numri i pjesëve për të ndarë n.\nx (int): Vlera minimale për secilën pjesë.\n\nKthen:\nint: Numri i mënyrave të ndarjes të dallueshme.\n\nShembuj:\n- count_partitions(7, 3, 1) do të kthejë 4, sepse ka katër mënyra për të ndarë\nnumrin 7 në 3 pjesë me secilën pjesë të paktën 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) do të kthejë 3, sepse ka tre mënyra për të ndarë\nnumrin 6 në 2 pjesë me secilën pjesë të paktën 1: [1,5], [2,4], [3,3].", "hy": "Հաշվել, թե քանի եղանակով կարելի է բաժանել n ամբողջ թիվը k մասերի, որտեղ յուրաքանչյուր մասը առնվազն x է, և մասերի կարգը նշանակություն չունի։\n\nՊարամետրեր:\nn (int): Բաժանվող ամբողջ թիվը։\nk (int): Մասերի քանակը, որոնց պետք է բաժանել n-ը։\nx (int): Յուրաքանչյուր մասի նվազագույն արժեքը։\n\nՎերադարձնում է:\nint: Տարբեր բաժանումների եղանակների քանակը։\n\nՕրինակներ:\n- count_partitions(7, 3, 1) կվերադարձնի 4, որովհետև կան չորս եղանակներ 7 թիվը բաժանելու 3 մասերի, որտեղ յուրաքանչյուր մասը առնվազն 1 է՝ [1,1,5], [1,2,4], [1,3,3], [2,2,3]։\n- count_partitions(6, 2, 1) կվերադարձնի 3, որովհետև կան երեք եղանակներ 6 թիվը բաժանելու 2 մասերի, որտեղ յուրաքանչյուր մասը առնվազն 1 է՝ [1,5], [2,4], [3,3]։", "bn": "একটি পূর্ণসংখ্যা n কে k অংশে ভাগ করার উপায়ের সংখ্যা গণনা করুন,\nযেখানে প্রতিটি অংশ অন্তত x এবং অংশগুলির ক্রম বিবেচ্য নয়।\n\nপ্যারামিটার:\nn (int): যে পূর্ণসংখ্যাটি ভাগ করা হবে।\nk (int): n কে যে অংশগুলিতে ভাগ করতে হবে তার সংখ্যা।\nx (int): প্রতিটি অংশের জন্য ন্যূনতম মান।\n\nরিটার্নস:\nint: পৃথক বিভাজনের উপায়ের সংখ্যা।\n\nউদাহরণ:\n- count_partitions(7, 3, 1) 4 ফেরত দেবে, কারণ চারটি উপায় আছে\nসংখ্যা 7 কে 3 অংশে ভাগ করার, যেখানে প্রতিটি অংশ অন্তত 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3]।\n- count_partitions(6, 2, 1) 3 ফেরত দেবে, কারণ তিনটি উপায় আছে\nসংখ্যা 6 কে 2 অংশে ভাগ করার, যেখানে প্রতিটি অংশ অন্তত 1: [1,5], [2,4], [3,3]।", "bg": "Бройте броя на начините за разделяне на цяло число n на k части, където всяка част е поне x и редът на частите няма значение.\n\nПараметри:\nn (int): Цялото число, което ще бъде разделено.\nk (int): Броят на частите, на които да се раздели n.\nx (int): Минималната стойност за всяка част.\n\nВръща:\nint: Броят на различните начини за разделяне.\n\nПримери:\n- count_partitions(7, 3, 1) ще върне 4, защото има четири начина да се раздели числото 7 на 3 части, като всяка част е поне 1: [1,1,5], [1,2,4], [1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) ще върне 3, защото има три начина да се раздели числото 6 на 2 части, като всяка част е поне 1: [1,5], [2,4], [3,3].", "zh": "计算将整数 n 分成 k 个部分的方法数，其中每个部分至少为 x，并且部分的顺序无关紧要。\n\n参数：\nn (int): 要分割的整数。\nk (int): 将 n 分成的部分数。\nx (int): 每个部分的最小值。\n\n返回：\nint: 不同分割方法的数量。\n\n示例：\n- count_partitions(7, 3, 1) 将返回 4，因为有四种方法可以将数字 7 分成 3 个部分，每个部分至少为 1：[1,1,5], [1,2,4], [1,3,3], [2,2,3]。\n- count_partitions(6, 2, 1) 将返回 3，因为有三种方法可以将数字 6 分成 2 个部分，每个部分至少为 1：[1,5], [2,4], [3,3]。", "fr": "Compter le nombre de façons de partitionner un entier n en k parties,\noù chaque partie est au moins x et l'ordre des parties n'a pas d'importance.\n\nParamètres :\nn (int) : L'entier à partitionner.\nk (int) : Le nombre de parties pour diviser n.\nx (int) : La valeur minimale pour chaque partie.\n\nRenvoie :\nint : Le nombre de façons de partition distinctes.\n\nExemples :\n- count_partitions(7, 3, 1) renverra 4, car il y a quatre façons de partitionner\nle nombre 7 en 3 parties avec chaque partie étant au moins 1 : [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) renverra 3, car il y a trois façons de partitionner\nle nombre 6 en 2 parties avec chaque partie étant au moins 1 : [1,5], [2,4], [3,3].", "de": "Zähle die Anzahl der Möglichkeiten, eine ganze Zahl n in k Teile zu partitionieren,\nwobei jeder Teil mindestens x ist und die Reihenfolge der Teile keine Rolle spielt.\n\nParameter:\nn (int): Die zu partitionierende ganze Zahl.\nk (int): Die Anzahl der Teile, in die n aufgeteilt werden soll.\nx (int): Der Mindestwert für jeden Teil.\n\nRückgabewert:\nint: Die Anzahl der unterschiedlichen Partitionierungsmöglichkeiten.\n\nBeispiele:\n- count_partitions(7, 3, 1) wird 4 zurückgeben, da es vier Möglichkeiten gibt, die Zahl 7 in 3 Teile zu partitionieren, wobei jeder Teil mindestens 1 ist: [1,1,5], [1,2,4], [1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) wird 3 zurückgeben, da es drei Möglichkeiten gibt, die Zahl 6 in 2 Teile zu partitionieren, wobei jeder Teil mindestens 1 ist: [1,5], [2,4], [3,3].", "ha": "Ƙirga adadin hanyoyin da za a iya raba lamba n zuwa k ɓangarori,\ninda kowanne sashi ya kasance a kalla x kuma tsarin sassan bai da mahimmanci.\n\nSigogi:\nn (int): Lambar da za a raba.\nk (int): Yawan sassan da za a raba n.\nx (int): Mafi karancin darajar kowane sashi.\n\nDawowa:\nint: Yawan hanyoyin rarrabuwa na musamman.\n\nMisalai:\n- count_partitions(7, 3, 1) zai dawo da 4, saboda akwai hanyoyi hudu don raba\nlamba 7 zuwa sassa 3 tare da kowanne sashi ya kasance a kalla 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) zai dawo da 3, saboda akwai hanyoyi uku don raba\nlamba 6 zuwa sassa 2 tare da kowanne sashi ya kasance a kalla 1: [1,5], [2,4], [3,3].", "hi": "किसी पूर्णांक n को k भागों में विभाजित करने के तरीकों की संख्या गिनें,\nजहाँ प्रत्येक भाग कम से कम x हो और भागों के क्रम का कोई महत्व न हो।\n\nमापदंड:\nn (int): वह पूर्णांक जिसे विभाजित करना है।\nk (int): भागों की संख्या जिसमें n को विभाजित करना है।\nx (int): प्रत्येक भाग के लिए न्यूनतम मान।\n\nवापसी:\nint: विभाजन के विभिन्न तरीकों की संख्या।\n\nउदाहरण:\n- count_partitions(7, 3, 1) 4 लौटाएगा, क्योंकि 7 को 3 भागों में विभाजित करने के चार तरीके हैं, जहाँ प्रत्येक भाग कम से कम 1 है: [1,1,5], [1,2,4], [1,3,3], [2,2,3]।\n- count_partitions(6, 2, 1) 3 लौटाएगा, क्योंकि 6 को 2 भागों में विभाजित करने के तीन तरीके हैं, जहाँ प्रत्येक भाग कम से कम 1 है: [1,5], [2,4], [3,3]।", "hu": "Számolja meg, hányféleképpen lehet egy n egész számot k részre felosztani,\nahol minden rész legalább x, és a részek sorrendje nem számít.\n\nParaméterek:\nn (int): Az egész szám, amelyet fel kell osztani.\nk (int): A részek száma, amire n-t fel kell osztani.\nx (int): Minden rész minimum értéke.\n\nVisszatérési érték:\nint: A különböző felosztási módok száma.\n\nPéldák:\n- count_partitions(7, 3, 1) visszaadja a 4-et, mert négyféleképpen lehet\na 7-es számot 3 részre felosztani, ahol minden rész legalább 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) visszaadja a 3-at, mert háromféleképpen lehet\na 6-os számot 2 részre felosztani, ahol minden rész legalább 1: [1,5], [2,4], [3,3].", "es": "Contar el número de formas de particionar un entero n en k partes, donde cada parte es al menos x y el orden de las partes no importa.\n\nParámetros:\nn (int): El entero a ser particionado.\nk (int): El número de partes en las que dividir n.\nx (int): El valor mínimo para cada parte.\n\nDevuelve:\nint: El número de formas distintas de particionar.\n\nEjemplos:\n- count_partitions(7, 3, 1) devolverá 4, porque hay cuatro formas de particionar el número 7 en 3 partes con cada parte siendo al menos 1: [1,1,5], [1,2,4], [1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) devolverá 3, porque hay tres formas de particionar el número 6 en 2 partes con cada parte siendo al menos 1: [1,5], [2,4], [3,3].", "arb": "احسب عدد الطرق لتقسيم عدد صحيح n إلى k أجزاء، حيث يكون كل جزء على الأقل x ولا يهم ترتيب الأجزاء.\n\nالمعطيات:\nn (int): العدد الصحيح المراد تقسيمه.\nk (int): عدد الأجزاء لتقسيم n إليها.\nx (int): القيمة الدنيا لكل جزء.\n\nالقيم المعادة:\nint: عدد طرق التقسيم المميزة.\n\nأمثلة:\n- count_partitions(7, 3, 1) ستعيد 4، لأن هناك أربع طرق لتقسيم العدد 7 إلى 3 أجزاء بحيث يكون كل جزء على الأقل 1: [1,1,5], [1,2,4], [1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) ستعيد 3، لأن هناك ثلاث طرق لتقسيم العدد 6 إلى 2 أجزاء بحيث يكون كل جزء على الأقل 1: [1,5], [2,4], [3,3].", "sw": "Hesabu idadi ya njia za kugawanya nambari n katika sehemu k,\nambapo kila sehemu ni angalau x na mpangilio wa sehemu haujalishi.\n\nVigezo:\nn (int): Nambari ya kugawanywa.\nk (int): Idadi ya sehemu za kugawa n.\nx (int): Thamani ya chini kwa kila sehemu.\n\nRudisha:\nint: Idadi ya njia tofauti za kugawanya.\n\nMifano:\n- count_partitions(7, 3, 1) itarudisha 4, kwa sababu kuna njia nne za kugawanya\nnambari 7 katika sehemu 3 na kila sehemu ikiwa angalau 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) itarudisha 3, kwa sababu kuna njia tatu za kugawanya\nnambari 6 katika sehemu 2 na kila sehemu ikiwa angalau 1: [1,5], [2,4], [3,3].", "tr": "Bir tamsayı n'yi k parçaya ayırmanın yollarını sayın,\nher bir parça en az x olacak şekilde ve parçaların sırası önemli değildir.\n\nParametreler:\nn (int): Parçalanacak tamsayı.\nk (int): n'yi bölmek için parça sayısı.\nx (int): Her bir parça için minimum değer.\n\nDöndürür:\nint: Farklı bölme yollarının sayısı.\n\nÖrnekler:\n- count_partitions(7, 3, 1) 4 döndürecektir, çünkü\nher bir parça en az 1 olacak şekilde 7 sayısını 3 parçaya ayırmanın dört yolu vardır: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) 3 döndürecektir, çünkü\nher bir parça en az 1 olacak şekilde 6 sayısını 2 parçaya ayırmanın üç yolu vardır: [1,5], [2,4], [3,3].", "vi": "Đếm số cách để phân hoạch một số nguyên n thành k phần,\ntrong đó mỗi phần ít nhất là x và thứ tự của các phần không quan trọng.\n\nTham số:\nn (int): Số nguyên cần được phân hoạch.\nk (int): Số phần để chia n thành.\nx (int): Giá trị tối thiểu cho mỗi phần.\n\nTrả về:\nint: Số cách phân hoạch khác biệt.\n\nVí dụ:\n- count_partitions(7, 3, 1) sẽ trả về 4, vì có bốn cách để phân hoạch\nsố 7 thành 3 phần với mỗi phần ít nhất là 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) sẽ trả về 3, vì có ba cách để phân hoạch\nsố 6 thành 2 phần với mỗi phần ít nhất là 1: [1,5], [2,4], [3,3].", "id": "Hitung jumlah cara untuk membagi bilangan bulat n menjadi k bagian,\ndi mana setiap bagian setidaknya x dan urutan bagian tidak penting.\n\nParameter:\nn (int): Bilangan bulat yang akan dibagi.\nk (int): Jumlah bagian untuk membagi n.\nx (int): Nilai minimum untuk setiap bagian.\n\nMengembalikan:\nint: Jumlah cara pembagian yang berbeda.\n\nContoh:\n- count_partitions(7, 3, 1) akan mengembalikan 4, karena ada empat cara untuk membagi\nangka 7 menjadi 3 bagian dengan setiap bagian setidaknya 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) akan mengembalikan 3, karena ada tiga cara untuk membagi\nangka 6 menjadi 2 bagian dengan setiap bagian setidaknya 1: [1,5], [2,4], [3,3].", "ja": "Count the number of ways to partition an integer n into k parts, where each part is at least x and order of parts does not matter.\n\n整数 n を k 個の部分に分割する方法の数を数えます。各部分は少なくとも x であり、部分の順序は重要ではありません。\n\nParameters:  \nn (int): 分割される整数。  \nk (int): n を分割する部分の数。  \nx (int): 各部分の最小値。\n\nReturns:  \nint: 異なる分割方法の数。\n\nExamples:  \n- count_partitions(7, 3, 1) は 4 を返します。なぜなら、数 7 を 3 つの部分に分割し、各部分が少なくとも 1 である方法が 4 つあるからです: [1,1,5], [1,2,4], [1,3,3], [2,2,3]。  \n- count_partitions(6, 2, 1) は 3 を返します。なぜなら、数 6 を 2 つの部分に分割し、各部分が少なくとも 1 である方法が 3 つあるからです: [1,5], [2,4], [3,3]。", "ko": "정수 n을 k개의 부분으로 분할하는 방법의 수를 계산합니다. 여기서 각 부분은 최소 x 이상이어야 하며 부분의 순서는 중요하지 않습니다.\n\n매개변수:\nn (int): 분할할 정수입니다.\nk (int): n을 나눌 부분의 수입니다.\nx (int): 각 부분의 최소값입니다.\n\n반환값:\nint: 서로 다른 분할 방법의 수입니다.\n\n예제:\n- count_partitions(7, 3, 1)은 4를 반환합니다. 이는 숫자 7을 최소 1 이상인 3개의 부분으로 분할하는 네 가지 방법이 있기 때문입니다: [1,1,5], [1,2,4], [1,3,3], [2,2,3].\n- count_partitions(6, 2, 1)은 3을 반환합니다. 이는 숫자 6을 최소 1 이상인 2개의 부분으로 분할하는 세 가지 방법이 있기 때문입니다: [1,5], [2,4], [3,3].", "ml": "ഒരു പൂർണ്ണസംഖ്യ n-നെ k ഭാഗങ്ങളായി വിഭജിക്കുന്നതിനുള്ള മാർഗങ്ങളുടെ എണ്ണം എണ്ണുക, ഓരോ ഭാഗവും കുറഞ്ഞത് x ആയിരിക്കണം, ഭാഗങ്ങളുടെ ക്രമം പ്രശ്നമല്ല.\n\nപാരാമീറ്ററുകൾ:\nn (int): വിഭജിക്കേണ്ട പൂർണ്ണസംഖ്യ.\nk (int): n-നെ വിഭജിക്കേണ്ട ഭാഗങ്ങളുടെ എണ്ണം.\nx (int): ഓരോ ഭാഗത്തിനും കുറഞ്ഞത് ഈ മൂല്യം വേണം.\n\nമടക്കം:\nint: വ്യത്യസ്തമായ വിഭജന മാർഗങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n- count_partitions(7, 3, 1) 4-നെ മടക്കും, കാരണം 7-നെ 3 ഭാഗങ്ങളായി, ഓരോ ഭാഗവും കുറഞ്ഞത് 1 ആയിരിക്കേണ്ട, വിഭജിക്കുന്ന നാലു മാർഗങ്ങൾ ഉണ്ട്: [1,1,5], [1,2,4], [1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) 3-നെ മടക്കും, കാരണം 6-നെ 2 ഭാഗങ്ങളായി, ഓരോ ഭാഗവും കുറഞ്ഞത് 1 ആയിരിക്കേണ്ട, വിഭജിക്കുന്ന മൂന്ന് മാർഗങ്ങൾ ഉണ്ട്: [1,5], [2,4], [3,3].", "fa": "تعداد روش‌های تقسیم یک عدد صحیح n به k بخش را بشمارید،\nبه طوری که هر بخش حداقل x باشد و ترتیب بخش‌ها مهم نباشد.\n\nپارامترها:\nn (int): عدد صحیحی که باید تقسیم شود.\nk (int): تعداد بخش‌هایی که n باید به آن تقسیم شود.\nx (int): حداقل مقدار برای هر بخش.\n\nبازگشت:\nint: تعداد روش‌های تقسیم‌بندی متمایز.\n\nمثال‌ها:\n- count_partitions(7, 3, 1) مقدار 4 را برمی‌گرداند، زیرا چهار روش برای تقسیم\nعدد 7 به 3 بخش وجود دارد که هر بخش حداقل 1 است: [1,1,5]، [1,2,4]،\n[1,3,3]، [2,2,3].\n- count_partitions(6, 2, 1) مقدار 3 را برمی‌گرداند، زیرا سه روش برای تقسیم\nعدد 6 به 2 بخش وجود دارد که هر بخش حداقل 1 است: [1,5]، [2,4]، [3,3]."}}
{"task_id": "Python/25", "prompt": {"en": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        # Only one sequence can be formed starting with 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Six sequences can be formed starting with 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # More complex example with memoization dictionary passed\n        # You would typically not pass this dictionary manually,\n        # it's used internally by the function for optimization.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # This is an assumed value for the example; the actual result may differ.\n    \"\"\"\n    # Function implementation is here...", "sq": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Llogarit numrin e sekuencave të vlefshme që mund të formohen sipas rregullave specifike.\n    \n    Çdo sekuencë fillon me një numër të dhënë 'n', dhe një numër i ri mund të shtohet në sekuencë\n    nëse është një numër i plotë pozitiv dhe jo më i madh se gjysma e numrit të fundit në sekuencë. Kjo\n    funksion përdor memoizimin për të ruajtur rezultatet e llogaritura më parë për të optimizuar performancën.\n    \n    Argumentet:\n        n (int): Numri fillestar i sekuencës.\n        last (int): Numri i fundit në sekuencën aktuale.\n        memo (dict): Një fjalor i përdorur për memoizim, që ruan numrin e sekuencave të vlefshme\n                     për çdo vlerë 'last' të hasur.\n    \n    Kthen:\n        int: Numri total i sekuencave të vlefshme që mund të formohen duke filluar me 'n'.\n    \n    Shembuj:\n        # Vetëm një sekuencë mund të formohet duke filluar me 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Gjashtë sekuenca mund të formohen duke filluar me 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Shembull më kompleks me fjalorin e memoizimit të kaluar\n        # Normalisht nuk do ta kalonit këtë fjalor manualisht,\n        # ai përdoret brenda funksionit për optimizim.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Kjo është një vlerë e supozuar për shembullin; rezultati aktual mund të ndryshojë.\n    \"\"\"\n    # Zbatimi i funksionit është këtu...", "hy": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Հաշվել վավեր հաջորդականությունների քանակը, որոնք կարող են ձևավորվել ըստ որոշակի կանոնների:\n    \n    Յուրաքանչյուր հաջորդականություն սկսվում է տրված 'n' թվից, և նոր թիվ կարելի է ավելացնել հաջորդականությանը,\n    եթե այն դրական ամբողջ թիվ է և չի գերազանցում հաջորդականության վերջին թվի կեսը: Այս\n    ֆունկցիան օգտագործում է հիշողություն (memoization)՝ պահպանելու համար նախապես հաշվարկված արդյունքները՝\n    օպտիմալացնելու կատարողականությունը:\n    \n    Արգումենտներ:\n        n (int): Հաջորդականության մեկնարկային թիվը:\n        last (int): Ընթացիկ հաջորդականության վերջին թիվը:\n        memo (dict): Բառարան, որը օգտագործվում է հիշողության համար, պահելով վավեր հաջորդականությունների քանակը\n                     յուրաքանչյուր 'last' արժեքի համար:\n    \n    Վերադարձնում է:\n        int: Վավեր հաջորդականությունների ընդհանուր քանակը, որոնք կարող են ձևավորվել սկսելով 'n'-ից:\n    \n    Օրինակներ:\n        # Միայն մեկ հաջորդականություն կարող է ձևավորվել սկսելով 1-ից: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Վեց հաջորդականություն կարող է ձևավորվել սկսելով 6-ից:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Ավելի բարդ օրինակ հիշողության բառարանով\n        # Դուք սովորաբար չեք փոխանցում այս բառարանը ձեռքով,\n        # այն օգտագործվում է ֆունկցիայի ներսում օպտիմալացման համար:\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Սա օրինակ է ենթադրյալ արժեքով; իրական արդյունքը կարող է տարբերվել:\n    \"\"\"\n    # Ֆունկցիայի իրականացումը այստեղ է...", "bn": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    নির্দিষ্ট নিয়ম অনুযায়ী গঠন করা যেতে পারে এমন বৈধ সিকোয়েন্সের সংখ্যা গণনা করুন।\n    \n    প্রতিটি সিকোয়েন্স একটি নির্দিষ্ট সংখ্যা 'n' দিয়ে শুরু হয়, এবং সিকোয়েন্সে একটি নতুন সংখ্যা যোগ করা যেতে পারে\n    যদি এটি একটি ধনাত্মক পূর্ণসংখ্যা হয় এবং সিকোয়েন্সের শেষ সংখ্যার অর্ধেকের বেশি না হয়। এই\n    ফাংশনটি মেমোইজেশন ব্যবহার করে পূর্বে গণনা করা ফলাফল সংরক্ষণ করে কর্মক্ষমতা উন্নত করতে।\n    \n    Args:\n        n (int): সিকোয়েন্সের শুরুর সংখ্যা।\n        last (int): বর্তমান সিকোয়েন্সের শেষ সংখ্যা।\n        memo (dict): মেমোইজেশনের জন্য ব্যবহৃত একটি ডিকশনারি, প্রতিটি 'last' মানের জন্য বৈধ সিকোয়েন্সের সংখ্যা\n                     সংরক্ষণ করে।\n    \n    Returns:\n        int: 'n' দিয়ে শুরু করে গঠন করা যেতে পারে এমন বৈধ সিকোয়েন্সের মোট সংখ্যা।\n    \n    Examples:\n        # শুধুমাত্র একটি সিকোয়েন্স 1 দিয়ে শুরু করে গঠন করা যেতে পারে: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # ছয়টি সিকোয়েন্স 6 দিয়ে শুরু করে গঠন করা যেতে পারে:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # মেমোইজেশন ডিকশনারি সহ আরও জটিল উদাহরণ\n        # সাধারণত আপনি এই ডিকশনারি ম্যানুয়ালি পাস করবেন না,\n        # এটি ফাংশন দ্বারা অভ্যন্তরীণভাবে অপ্টিমাইজেশনের জন্য ব্যবহৃত হয়।\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # এটি উদাহরণের জন্য একটি অনুমানকৃত মান; প্রকৃত ফলাফল ভিন্ন হতে পারে।\n    \"\"\"\n    # Function implementation is here...", "bg": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Изчислява броя на валидните последователности, които могат да бъдат формирани според специфични правила.\n    \n    Всяка последователност започва с дадено число 'n', и ново число може да бъде добавено към последователността,\n    ако е положително цяло число и не е по-голямо от половината на последното число в последователността. Тази\n    функция използва мемоизация, за да съхранява предварително изчислени резултати за оптимизиране на производителността.\n    \n    Аргументи:\n        n (int): Началното число на последователността.\n        last (int): Последното число в текущата последователност.\n        memo (dict): Речник, използван за мемоизация, съхраняващ броя на валидните последователности\n                     за всяка срещната стойност на 'last'.\n    \n    Връща:\n        int: Общият брой на валидните последователности, които могат да бъдат формирани, започвайки с 'n'.\n    \n    Примери:\n        # Може да бъде формирана само една последователност, започваща с 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Шест последователности могат да бъдат формирани, започвайки с 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # По-сложен пример с предаден речник за мемоизация\n        # Обикновено не бихте предавали този речник ръчно,\n        # той се използва вътрешно от функцията за оптимизация.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Това е предположена стойност за примера; действителният резултат може да се различава.\n    \"\"\"\n    # Function implementation is here...", "zh": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    根据特定规则计算可以形成的有效序列的数量。\n    \n    每个序列以给定数字'n'开始，如果一个新数字是正整数且不大于序列中最后一个数字的一半，\n    则可以将其附加到序列中。此函数使用记忆化存储先前计算的结果以优化性能。\n    \n    参数:\n        n (int): 序列的起始数字。\n        last (int): 当前序列的最后一个数字。\n        memo (dict): 用于记忆化的字典，存储每个遇到的'last'值的有效序列数量。\n    \n    返回:\n        int: 可以从'n'开始形成的有效序列的总数。\n    \n    示例:\n        # 只有一个序列可以从1开始形成: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # 可以从6开始形成六个序列:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # 使用传递的记忆化字典的更复杂示例\n        # 通常不会手动传递此字典，\n        # 它由函数内部用于优化。\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # 这是示例的假定值；实际结果可能不同。\n    \"\"\"\n    # Function implementation is here...", "fr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculer le nombre de séquences valides qui peuvent être formées selon des règles spécifiques.\n    \n    Chaque séquence commence par un nombre donné 'n', et un nouveau nombre peut être ajouté à la séquence\n    s'il est un entier positif et pas plus grand que la moitié du dernier nombre de la séquence. Cette\n    fonction utilise la mémoïsation pour stocker les résultats précédemment calculés afin d'optimiser les performances.\n    \n    Args:\n        n (int): Le nombre de départ de la séquence.\n        last (int): Le dernier nombre dans la séquence actuelle.\n        memo (dict): Un dictionnaire utilisé pour la mémoïsation, stockant le nombre de séquences valides\n                     pour chaque valeur 'last' rencontrée.\n    \n    Returns:\n        int: Le nombre total de séquences valides qui peuvent être formées en commençant par 'n'.\n    \n    Examples:\n        # Une seule séquence peut être formée en commençant par 1 : [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Six séquences peuvent être formées en commençant par 6 :\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Exemple plus complexe avec dictionnaire de mémoïsation passé\n        # Vous ne passeriez généralement pas ce dictionnaire manuellement,\n        # il est utilisé en interne par la fonction pour l'optimisation.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Ceci est une valeur supposée pour l'exemple ; le résultat réel peut différer.\n    \"\"\"\n    # L'implémentation de la fonction est ici...", "de": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Berechne die Anzahl der gültigen Sequenzen, die gemäß spezifischer Regeln gebildet werden können.\n    \n    Jede Sequenz beginnt mit einer gegebenen Zahl 'n', und eine neue Zahl kann an die Sequenz angehängt werden,\n    wenn sie eine positive ganze Zahl ist und nicht größer als die Hälfte der letzten Zahl in der Sequenz.\n    Diese Funktion verwendet Memoisierung, um zuvor berechnete Ergebnisse zu speichern und die Leistung zu optimieren.\n    \n    Argumente:\n        n (int): Die Startzahl der Sequenz.\n        last (int): Die letzte Zahl in der aktuellen Sequenz.\n        memo (dict): Ein Wörterbuch, das für die Memoisierung verwendet wird und die Anzahl der gültigen Sequenzen\n                     für jeden 'last'-Wert speichert, der aufgetreten ist.\n    \n    Rückgabewert:\n        int: Die Gesamtanzahl der gültigen Sequenzen, die mit 'n' beginnen können.\n    \n    Beispiele:\n        # Es kann nur eine Sequenz gebildet werden, die mit 1 beginnt: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Sechs Sequenzen können gebildet werden, die mit 6 beginnen:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Komplexeres Beispiel mit übergebenem Memoisierungs-Wörterbuch\n        # Normalerweise würde man dieses Wörterbuch nicht manuell übergeben,\n        # es wird intern von der Funktion zur Optimierung verwendet.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Dies ist ein angenommener Wert für das Beispiel; das tatsächliche Ergebnis kann abweichen.\n    \"\"\"\n    # Function implementation is here...", "ha": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Lissafi adadin jerin sahihai da za a iya samarwa bisa ga wasu ƙa'idoji.\n\n    Kowace jeri tana farawa da wani adadi 'n', kuma za a iya ƙara sabon adadi zuwa jerin\n    idan yana da adadi mai kyau kuma ba ya fi rabin adadin ƙarshe a cikin jerin ba. Wannan\n    aikin yana amfani da memoization don adana sakamakon da aka lissafa a baya don inganta aiki.\n\n    Args:\n        n (int): Adadin farawa na jerin.\n        last (int): Adadin ƙarshe a cikin jerin yanzu.\n        memo (dict): Wani kamus da ake amfani da shi don memoization, yana adana adadin jerin sahihai\n                     don kowane ƙimar 'last' da aka ci karo da shi.\n\n    Returns:\n        int: Jimillar adadin jerin sahihai da za a iya samarwa farawa da 'n'.\n\n    Misalai:\n        # Jerin guda ɗaya kawai za a iya samarwa farawa da 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Jerin shida za a iya samarwa farawa da 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Misali mafi rikitarwa tare da kamus na memoization da aka wuce\n        # Da alama ba za ka wuce wannan kamus ɗin da hannu ba,\n        # ana amfani da shi a ciki ta aikin don ingantawa.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Wannan wata ƙima ce da aka ɗauka don misali; sakamakon ainihi na iya bambanta.\n    \"\"\"\n    # Function implementation is here...", "hi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    विशिष्ट नियमों के अनुसार बनाए जा सकने वाले वैध अनुक्रमों की संख्या की गणना करें।\n    \n    प्रत्येक अनुक्रम एक दिए गए संख्या 'n' से शुरू होता है, और एक नई संख्या अनुक्रम में जोड़ी जा सकती है\n    यदि यह एक सकारात्मक पूर्णांक है और अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं है। यह\n    फ़ंक्शन प्रदर्शन को अनुकूलित करने के लिए पहले से गणना किए गए परिणामों को संग्रहीत करने के लिए स्मृति-भंडारण का उपयोग करता है।\n    \n    तर्क:\n        n (int): अनुक्रम की प्रारंभिक संख्या।\n        last (int): वर्तमान अनुक्रम में अंतिम संख्या।\n        memo (dict): स्मृति-भंडारण के लिए उपयोग किया जाने वाला एक शब्दकोश, प्रत्येक 'last' मान के लिए\n                     मिले वैध अनुक्रमों की संख्या संग्रहीत करता है।\n    \n    लौटाता है:\n        int: 'n' से शुरू होने वाले बनाए जा सकने वाले वैध अनुक्रमों की कुल संख्या।\n    \n    उदाहरण:\n        # केवल एक अनुक्रम 1 से शुरू होकर बनाया जा सकता है: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # छह अनुक्रम 6 से शुरू होकर बनाए जा सकते हैं:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # स्मृति-भंडारण शब्दकोश के साथ अधिक जटिल उदाहरण\n        # आप आमतौर पर इस शब्दकोश को मैन्युअल रूप से पास नहीं करेंगे,\n        # यह अनुकूलन के लिए फ़ंक्शन द्वारा आंतरिक रूप से उपयोग किया जाता है।\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # यह उदाहरण के लिए एक अनुमानित मान है; वास्तविक परिणाम भिन्न हो सकता है।\n    \"\"\"\n    # Function implementation is here...", "hu": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Számolja ki az érvényes sorozatok számát, amelyek meghatározott szabályok szerint képezhetők.\n    \n    Minden sorozat egy adott 'n' számmal kezdődik, és egy új szám fűzhető a sorozathoz,\n    ha pozitív egész szám és nem nagyobb, mint a sorozat utolsó számának fele. Ez a\n    függvény memoizációt használ a korábban kiszámított eredmények tárolására a teljesítmény optimalizálása érdekében.\n    \n    Argok:\n        n (int): A sorozat kezdő száma.\n        last (int): Az aktuális sorozat utolsó száma.\n        memo (dict): Egy szótár a memoizációhoz, amely az érvényes sorozatok számát tárolja\n                     minden előforduló 'last' értékhez.\n    \n    Visszatér:\n        int: Az érvényes sorozatok teljes száma, amelyek 'n'-nel kezdődhetnek.\n    \n    Példák:\n        # Csak egy sorozat képezhető, amely 1-gyel kezdődik: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Hat sorozat képezhető, amely 6-tal kezdődik:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Bonyolultabb példa memoizációs szótárral\n        # Általában nem adod meg ezt a szótárt manuálisan,\n        # a függvény belsőleg használja az optimalizáláshoz.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Ez egy feltételezett érték a példában; a tényleges eredmény eltérhet.\n    \"\"\"\n    # Function implementation is here...", "es": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calcular el número de secuencias válidas que se pueden formar según reglas específicas.\n    \n    Cada secuencia comienza con un número dado 'n', y se puede agregar un nuevo número a la secuencia\n    si es un entero positivo y no es mayor que la mitad del último número en la secuencia. Esta\n    función utiliza memoización para almacenar resultados previamente calculados y optimizar el rendimiento.\n    \n    Argumentos:\n        n (int): El número inicial de la secuencia.\n        last (int): El último número en la secuencia actual.\n        memo (dict): Un diccionario utilizado para la memoización, almacenando el número de secuencias válidas\n                     para cada valor 'last' encontrado.\n    \n    Devuelve:\n        int: El número total de secuencias válidas que se pueden formar comenzando con 'n'.\n    \n    Ejemplos:\n        # Solo se puede formar una secuencia comenzando con 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Se pueden formar seis secuencias comenzando con 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Ejemplo más complejo con diccionario de memoización pasado\n        # Normalmente no pasarías este diccionario manualmente,\n        # se utiliza internamente por la función para optimización.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Este es un valor asumido para el ejemplo; el resultado real puede diferir.\n    \"\"\"\n    # Function implementation is here...", "arb": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    حساب عدد التسلسلات الصالحة التي يمكن تشكيلها وفقًا لقواعد محددة.\n    \n    يبدأ كل تسلسل برقم معين 'n'، ويمكن إضافة رقم جديد إلى التسلسل\n    إذا كان عددًا صحيحًا موجبًا ولا يزيد عن نصف الرقم الأخير في التسلسل. \n    تستخدم هذه الدالة التخزين المؤقت لحفظ النتائج المحسوبة سابقًا لتحسين الأداء.\n    \n    يعيدالحجج:\n        n (int): الرقم الابتدائي للتسلسل.\n        last (int): الرقم الأخير في التسلسل الحالي.\n        memo (dict): قاموس يستخدم للتخزين المؤقت، يخزن عدد التسلسلات الصالحة\n                     لكل قيمة 'last' تم مواجهتها.\n    \n    يعيد:\n        int: إجمالي عدد التسلسلات الصالحة التي يمكن تشكيلها بدءًا من 'n'.\n    \n    أمثلة:\n        # يمكن تشكيل تسلسل واحد فقط يبدأ بـ 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # يمكن تشكيل ستة تسلسلات تبدأ بـ 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # مثال أكثر تعقيدًا مع قاموس التخزين المؤقت الممرر\n        # عادةً لن تقوم بتمرير هذا القاموس يدويًا،\n        # يتم استخدامه داخليًا بواسطة الدالة للتحسين.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # هذه قيمة مفترضة للمثال؛ قد يختلف النتيجة الفعلية.\n    \"\"\"\n    # Function implementation is here...", "sw": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Hesabu idadi ya mlolongo halali ambao unaweza kuundwa kulingana na sheria maalum.\n    \n    Kila mlolongo huanza na nambari fulani 'n', na nambari mpya inaweza kuongezwa kwenye mlolongo\n    ikiwa ni nambari nzima chanya na haizidi nusu ya nambari ya mwisho katika mlolongo. \n    Kazi hii hutumia memoization kuhifadhi matokeo yaliyokokotolewa awali ili kuboresha utendaji.\n\n    Hoja:\n        n (int): Nambari ya kuanzia ya mlolongo.\n        last (int): Nambari ya mwisho katika mlolongo wa sasa.\n        memo (dict): Kamusi inayotumika kwa memoization, ikihifadhi idadi ya mlolongo halali\n                     kwa kila thamani ya 'last' iliyokutana nayo.\n    \n    Inarejesha:\n        int: Jumla ya idadi ya mlolongo halali ambao unaweza kuundwa kuanzia na 'n'.\n    \n    Mifano:\n        # Mlolongo mmoja tu unaweza kuundwa kuanzia na 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Mlolongo sita unaweza kuundwa kuanzia na 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Mfano mgumu zaidi na kamusi ya memoization iliyopitishwa\n        # Kwa kawaida usingepitisha kamusi hii mwenyewe,\n        # inatumika ndani ya kazi kwa ajili ya kuboresha utendaji.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Hii ni thamani iliyodhaniwa kwa mfano; matokeo halisi yanaweza kutofautiana.\n    \"\"\"\n    # Utekelezaji wa kazi uko hapa...", "tr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Belirli kurallara göre oluşturulabilecek geçerli dizilerin sayısını hesaplayın.\n    \n    Her dizi verilen bir sayı 'n' ile başlar ve dizinin son sayısının yarısından büyük olmayan\n    pozitif bir tamsayı ise diziye yeni bir sayı eklenebilir. Bu fonksiyon, performansı\n    optimize etmek için daha önce hesaplanmış sonuçları saklamak amacıyla memoization kullanır.\n    \n    Argümanlar:\n        n (int): Dizinin başlangıç sayısı.\n        last (int): Mevcut dizideki son sayı.\n        memo (dict): Her karşılaşılan 'last' değeri için geçerli dizilerin sayısını saklayan,\n                     memoization için kullanılan bir sözlük.\n    \n    Döndürür:\n        int: 'n' ile başlayan oluşturulabilecek geçerli dizilerin toplam sayısı.\n    \n    Örnekler:\n        # Sadece 1 ile başlayan bir dizi oluşturulabilir: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # 6 ile başlayan altı dizi oluşturulabilir:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Memoization sözlüğü ile daha karmaşık bir örnek\n        # Bu sözlüğü genellikle manuel olarak geçmezsiniz,\n        # fonksiyon tarafından optimizasyon için dahili olarak kullanılır.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Bu, örnek için varsayılan bir değerdir; gerçek sonuç farklı olabilir.\n    \"\"\"\n    # Function implementation is here...", "vi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Tính toán số lượng dãy hợp lệ có thể được tạo ra theo các quy tắc cụ thể.\n    \n    Mỗi dãy bắt đầu với một số cho trước 'n', và một số mới có thể được thêm vào dãy\n    nếu nó là số nguyên dương và không lớn hơn một nửa số cuối cùng trong dãy. Hàm này\n    sử dụng ghi nhớ để lưu trữ các kết quả đã tính trước đó nhằm tối ưu hóa hiệu suất.\n    \n    Tham số:\n        n (int): Số bắt đầu của dãy.\n        last (int): Số cuối cùng trong dãy hiện tại.\n        memo (dict): Một từ điển được sử dụng cho ghi nhớ, lưu trữ số lượng dãy hợp lệ\n                     cho mỗi giá trị 'last' đã gặp.\n    \n    Trả về:\n        int: Tổng số dãy hợp lệ có thể được tạo ra bắt đầu với 'n'.\n    \n    Ví dụ:\n        # Chỉ có một dãy có thể được tạo ra bắt đầu với 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Sáu dãy có thể được tạo ra bắt đầu với 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Ví dụ phức tạp hơn với từ điển ghi nhớ được truyền vào\n        # Bạn thường không truyền từ điển này thủ công,\n        # nó được sử dụng nội bộ bởi hàm để tối ưu hóa.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Đây là giá trị giả định cho ví dụ; kết quả thực tế có thể khác.\n    \"\"\"\n    # Function implementation is here...", "id": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Hitung jumlah urutan valid yang dapat dibentuk sesuai dengan aturan tertentu.\n    \n    Setiap urutan dimulai dengan angka 'n' yang diberikan, dan angka baru dapat ditambahkan ke urutan\n    jika itu adalah bilangan bulat positif dan tidak lebih besar dari setengah angka terakhir dalam urutan.\n    Fungsi ini menggunakan memoization untuk menyimpan hasil yang telah dihitung sebelumnya untuk mengoptimalkan kinerja.\n    \n    Args:\n        n (int): Angka awal dari urutan.\n        last (int): Angka terakhir dalam urutan saat ini.\n        memo (dict): Sebuah kamus yang digunakan untuk memoization, menyimpan jumlah urutan valid\n                     untuk setiap nilai 'last' yang ditemui.\n    \n    Returns:\n        int: Total jumlah urutan valid yang dapat dibentuk dimulai dengan 'n'.\n    \n    Contoh:\n        # Hanya satu urutan yang dapat dibentuk dimulai dengan 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Enam urutan dapat dibentuk dimulai dengan 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Contoh yang lebih kompleks dengan kamus memoization yang diberikan\n        # Anda biasanya tidak akan memberikan kamus ini secara manual,\n        # ini digunakan secara internal oleh fungsi untuk optimasi.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Ini adalah nilai asumsi untuk contoh; hasil sebenarnya mungkin berbeda.\n    \"\"\"\n    # Implementasi fungsi ada di sini...", "ja": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    特定のルールに従って形成できる有効なシーケンスの数を計算します。\n    \n    各シーケンスは指定された数 'n' で始まり、シーケンスに追加できる新しい数は\n    正の整数であり、シーケンス内の最後の数の半分以下でなければなりません。\n    この関数はメモ化を使用して、以前に計算された結果を保存し、パフォーマンスを最適化します。\n    \n    引数:\n        n (int): シーケンスの開始数。\n        last (int): 現在のシーケンスの最後の数。\n        memo (dict): メモ化に使用される辞書で、遭遇した各 'last' 値に対する有効なシーケンスの数を保存します。\n    \n    戻り値:\n        int: 'n' で始まる有効なシーケンスの総数。\n    \n    例:\n        # 1 で始まるシーケンスは 1 つだけ形成できます: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # 6 で始まるシーケンスは 6 つ形成できます:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # メモ化辞書を渡すより複雑な例\n        # 通常、この辞書を手動で渡すことはありません。\n        # これは関数によって内部的に最適化のために使用されます。\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # これは例のための仮定の値です。実際の結果は異なる場合があります。\n    \"\"\"\n    # Function implementation is here...", "ko": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    특정 규칙에 따라 형성될 수 있는 유효한 시퀀스의 수를 계산합니다.\n    \n    각 시퀀스는 주어진 숫자 'n'으로 시작하며, 시퀀스에 새 숫자를 추가할 수 있는 경우는\n    양의 정수이고 시퀀스의 마지막 숫자의 절반보다 크지 않은 경우입니다. 이 함수는 메모이제이션을 사용하여\n    이전에 계산된 결과를 저장하여 성능을 최적화합니다.\n    \n    Args:\n        n (int): 시퀀스의 시작 숫자.\n        last (int): 현재 시퀀스의 마지막 숫자.\n        memo (dict): 메모이제이션에 사용되는 딕셔너리로, 만난 각 'last' 값에 대한 유효한 시퀀스의 수를 저장합니다.\n    \n    Returns:\n        int: 'n'으로 시작하는 유효한 시퀀스의 총 수.\n    \n    Examples:\n        # 1로 시작하는 시퀀스는 하나만 형성될 수 있습니다: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # 6으로 시작하는 시퀀스는 여섯 개가 형성될 수 있습니다:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # 메모이제이션 딕셔너리가 전달된 더 복잡한 예\n        # 일반적으로 이 딕셔너리를 수동으로 전달하지 않으며,\n        # 함수 내부에서 최적화를 위해 사용됩니다.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # 예시를 위한 가정된 값입니다; 실제 결과는 다를 수 있습니다.\n    \"\"\"\n    # Function implementation is here...", "ml": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    പ്രത്യേക നിയമങ്ങൾ അനുസരിച്ച് രൂപീകരിക്കാവുന്ന സാധുവായ അനുക്രമങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n    \n    ഓരോ അനുക്രമവും നൽകിയിരിക്കുന്ന സംഖ്യ 'n' ഉപയോഗിച്ച് ആരംഭിക്കുന്നു, \n    ഒരു പുതിയ സംഖ്യ അനുക്രമത്തിൽ ചേർക്കാൻ കഴിയുന്നതാണ്, \n    അത് ഒരു പോസിറ്റീവ് ഇന്റിജർ ആയിരിക്കണം \n    കൂടാതെ അനുക്രമത്തിലെ അവസാന സംഖ്യയുടെ പകുതിയേക്കാൾ കൂടുതലായിരിക്കരുത്. \n    ഈ ഫംഗ്ഷൻ മെമ്മോയ്‌സേഷൻ ഉപയോഗിച്ച് \n    മുമ്പ് കണക്കാക്കിയ ഫലങ്ങൾ സംഭരിച്ച് പ്രകടനം മെച്ചപ്പെടുത്തുന്നു.\n    \n    Args:\n        n (int): അനുക്രമത്തിന്റെ ആരംഭ സംഖ്യ.\n        last (int): നിലവിലെ അനുക്രമത്തിലെ അവസാന സംഖ്യ.\n        memo (dict): മെമ്മോയ്‌സേഷനായി ഉപയോഗിക്കുന്ന ഒരു ഡിക്ഷണറി, \n                     നേരിടുന്ന ഓരോ 'last' മൂല്യത്തിനും \n                     സാധുവായ അനുക്രമങ്ങളുടെ എണ്ണം സംഭരിക്കുന്നു.\n    \n    Returns:\n        int: 'n' ഉപയോഗിച്ച് ആരംഭിക്കാവുന്ന \n             മൊത്തം സാധുവായ അനുക്രമങ്ങളുടെ എണ്ണം.\n    \n    Examples:\n        # 1 ഉപയോഗിച്ച് ആരംഭിക്കുന്ന ഒരു അനുക്രമം മാത്രമേ രൂപീകരിക്കാനാകൂ: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # 6 ഉപയോഗിച്ച് ആരംഭിക്കുന്ന ആറു അനുക്രമങ്ങൾ രൂപീകരിക്കാം:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # മെമ്മോയ്‌സേഷൻ ഡിക്ഷണറിയുമായി കൂടുതൽ സങ്കീർണ്ണമായ ഉദാഹരണം\n        # സാധാരണയായി നിങ്ങൾ ഈ ഡിക്ഷണറി കൈമാറില്ല,\n        # പ്രവർത്തനം മെച്ചപ്പെടുത്തുന്നതിനായി ഫംഗ്ഷൻ \n        # ആന്തരികമായി ഇത് ഉപയോഗിക്കുന്നു.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # ഉദാഹരണത്തിനായി ഇത് ഒരു അനുമാനിച്ച മൂല്യമാണ്; യഥാർത്ഥ ഫലം വ്യത്യസ്തമായിരിക്കാം.\n    \"\"\"\n    # Function implementation is here...", "fa": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    محاسبه تعداد دنباله‌های معتبری که می‌توان بر اساس قوانین خاص تشکیل داد.\n    \n    هر دنباله با یک عدد داده شده 'n' شروع می‌شود و می‌توان یک عدد جدید به دنباله اضافه کرد\n    اگر یک عدد صحیح مثبت باشد و بیشتر از نصف عدد آخر در دنباله نباشد. این\n    تابع از ذخیره‌سازی نتایج محاسبه شده قبلی برای بهینه‌سازی عملکرد استفاده می‌کند.\n    \n    Args:\n        n (int): عدد شروع دنباله.\n        last (int): آخرین عدد در دنباله فعلی.\n        memo (dict): یک دیکشنری که برای ذخیره‌سازی نتایج محاسبه شده\n                     برای هر مقدار 'last' که با آن مواجه می‌شود، استفاده می‌شود.\n    \n    Returns:\n        int: تعداد کل دنباله‌های معتبری که می‌توان با شروع از 'n' تشکیل داد.\n    \n    Examples:\n        # تنها یک دنباله می‌تواند با شروع از 1 تشکیل شود: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # شش دنباله می‌تواند با شروع از 6 تشکیل شود:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # مثال پیچیده‌تر با دیکشنری ذخیره‌سازی که منتقل شده است\n        # شما معمولاً این دیکشنری را به صورت دستی منتقل نمی‌کنید،\n        # این دیکشنری به صورت داخلی توسط تابع برای بهینه‌سازی استفاده می‌شود.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # این یک مقدار فرضی برای مثال است؛ نتیجه واقعی ممکن است متفاوت باشد.\n    \"\"\"\n    # Function implementation is here..."}, "canonical_solution": "    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count", "instruction": {"en": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nПредоставете кратко описание на Python кода на естествен език на български, използвайки не повече от 500 знака.", "zh": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nBada takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي المكتوب بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nVerilen Python kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) oluşturun. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\n最大 500 文字を使用して、英語で Python コードの簡潔な自然言語説明 (docstring) を提供します。", "ko": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성합니다.", "ml": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഉപയോഗിക്കാതെ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_count_sequences():\n    test_cases = [\n        (6, 6),\n        (1, 1),\n        (10, 14)\n    ]\n\n    for i, (n, expected) in enumerate(test_cases):\n        memo = {}\n        result = count_sequences(n, n, memo)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: n = {n}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_sequences()", "entry_point": "count_sequences", "signature": "def count_sequences(n: int, last: int, memo: dict) -> int:", "docstring": {"en": "Calculate the number of valid sequences that can be formed according to specific rules.\n\nEach sequence starts with a given number 'n', and a new number can be appended to the sequence\nif it is a positive integer and not greater than half the last number in the sequence. This\nfunction uses memoization to store previously calculated results to optimize performance.\n\nArgs:\nn (int): The starting number of the sequence.\nlast (int): The last number in the current sequence.\nmemo (dict): A dictionary used for memoization, storing the number of valid sequences\nfor each 'last' value encountered.\n\nReturns:\nint: The total number of valid sequences that can be formed starting with 'n'.\n\nExamples:\nOnly one sequence can be formed starting with 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSix sequences can be formed starting with 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMore complex example with memoization dictionary passed\nYou would typically not pass this dictionary manually,\nit's used internally by the function for optimization.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # This is an assumed value for the example; the actual result may differ.", "sq": "Llogarit numrin e sekuencave të vlefshme që mund të formohen sipas rregullave specifike.\n\nÇdo sekuencë fillon me një numër të dhënë 'n', dhe një numër i ri mund të shtohet në sekuencë\nnëse është një numër i plotë pozitiv dhe jo më i madh se gjysma e numrit të fundit në sekuencë. Kjo\nfunksion përdor memoizimin për të ruajtur rezultatet e llogaritura më parë për të optimizuar performancën.\n\nArgumentet:\nn (int): Numri fillestar i sekuencës.\nlast (int): Numri i fundit në sekuencën aktuale.\nmemo (dict): Një fjalor i përdorur për memoizim, që ruan numrin e sekuencave të vlefshme\npër çdo vlerë 'last' të hasur.\n\nKthen:\nint: Numri total i sekuencave të vlefshme që mund të formohen duke filluar me 'n'.\n\nShembuj:\nVetëm një sekuencë mund të formohet duke filluar me 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nGjashtë sekuenca mund të formohen duke filluar me 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nShembull më kompleks me fjalorin e memoizimit të kaluar\nZakonisht nuk do ta kalonit këtë fjalor manualisht,\nai përdoret brenda funksionit për optimizim.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Ky është një vlerë e supozuar për shembullin; rezultati aktual mund të ndryshojë.", "hy": "Հաշվել այն վավեր հաջորդականությունների քանակը, որոնք կարող են կազմվել ըստ որոշակի կանոնների։\n\nՅուրաքանչյուր հաջորդականություն սկսվում է տրված 'n' թվից, և նոր թիվը կարող է ավելացվել հաջորդականությանը, եթե այն դրական ամբողջ թիվ է և չի գերազանցում հաջորդականության վերջին թվի կեսը։ Այս ֆունկցիան օգտագործում է հիշողության օպտիմալացում՝ պահելու համար նախկինում հաշվարկված արդյունքները՝ կատարողականությունը բարելավելու համար։\n\nԱրձանագրություններ:\nn (int): Հաջորդականության մեկնարկային թիվը։\nlast (int): Ընթացիկ հաջորդականության վերջին թիվը։\nmemo (dict): Բառարան, որը օգտագործվում է հիշողության օպտիմալացման համար՝ պահելու վավեր հաջորդականությունների քանակը\nյուրաքանչյուր հանդիպած 'last' արժեքի համար։\n\nՎերադարձնում է:\nint: Վավեր հաջորդականությունների ընդհանուր քանակը, որոնք կարող են կազմվել 'n'-ով սկսած։\n\nՕրինակներ:\nՄիայն մեկ հաջորդականություն կարող է կազմվել 1-ից սկսած՝ [1]\n>>> count_sequences(1, 1, {})\n1\n\nՎեց հաջորդականություն կարող է կազմվել 6-ից սկսած՝\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nԱվելի բարդ օրինակ՝ հիշողության օպտիմալացման բառարանով\nԴուք սովորաբար չեք փոխանցում այս բառարանը ձեռքով,\nայն օգտագործվում է ֆունկցիայի կողմից ներքին օպտիմալացման համար։\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Սա օրինակային արժեք է; իրական արդյունքը կարող է տարբերվել։", "bn": "নির্দিষ্ট নিয়ম অনুযায়ী গঠন করা যেতে পারে এমন বৈধ সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্রতিটি ক্রম একটি প্রদত্ত সংখ্যা 'n' দিয়ে শুরু হয়, এবং একটি নতুন সংখ্যা ক্রমে যোগ করা যেতে পারে যদি এটি একটি ধনাত্মক পূর্ণসংখ্যা হয় এবং ক্রমের শেষ সংখ্যার অর্ধেকের বেশি না হয়। এই ফাংশনটি কর্মদক্ষতা বাড়ানোর জন্য পূর্বে গণনা করা ফলাফল সংরক্ষণ করতে মেমোইজেশন ব্যবহার করে।\n\nArgs:\nn (int): ক্রমের শুরু সংখ্যা।\nlast (int): বর্তমান ক্রমের শেষ সংখ্যা।\nmemo (dict): মেমোইজেশনের জন্য ব্যবহৃত একটি অভিধান, প্রতিটি 'last' মানের জন্য সম্মুখীন বৈধ ক্রমের সংখ্যা সংরক্ষণ করে।\n\nReturns:\nint: মোট বৈধ ক্রমের সংখ্যা যা 'n' দিয়ে শুরু হতে পারে।\n\nExamples:\nশুধুমাত্র একটি ক্রম গঠন করা যেতে পারে 1 দিয়ে শুরু করে: [1]\n>>> count_sequences(1, 1, {})\n1\n\nছয়টি ক্রম গঠন করা যেতে পারে 6 দিয়ে শুরু করে:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nমেমোইজেশন অভিধান সহ আরও জটিল উদাহরণ\nআপনি সাধারণত এই অভিধানটি ম্যানুয়ালি পাস করবেন না,\nএটি ফাংশন দ্বারা অভ্যন্তরীণভাবে অপ্টিমাইজেশনের জন্য ব্যবহৃত হয়।\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # এটি উদাহরণের জন্য একটি অনুমিত মান; প্রকৃত ফলাফল ভিন্ন হতে পারে।", "bg": "Изчислете броя на валидните последователности, които могат да бъдат формирани според специфични правила.\n\nВсяка последователност започва с дадено число 'n', и ново число може да бъде добавено към последователността, ако е положително цяло число и не е по-голямо от половината на последното число в последователността. Тази функция използва мемоизация, за да съхранява предварително изчислени резултати за оптимизиране на производителността.\n\nАргументи:\nn (int): Началното число на последователността.\nlast (int): Последното число в текущата последователност.\nmemo (dict): Речник, използван за мемоизация, съхраняващ броя на валидните последователности за всяка срещната стойност на 'last'.\n\nВръща:\nint: Общият брой на валидните последователности, които могат да бъдат формирани, започвайки с 'n'.\n\nПримери:\nСамо една последователност може да бъде формирана, започвайки с 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nШест последователности могат да бъдат формирани, започвайки с 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nПо-сложен пример с речник за мемоизация, предаден като аргумент\nОбикновено не бихте предавали този речник ръчно,\nтой се използва вътрешно от функцията за оптимизация.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Това е предполагаема стойност за примера; действителният резултат може да се различава.", "zh": "计算可以根据特定规则形成的有效序列的数量。\n\n每个序列以给定数字'n'开始，如果新数字是正整数且不大于序列中最后一个数字的一半，则可以将其附加到序列中。此函数使用记忆化技术存储先前计算的结果以优化性能。\n\n参数：\nn (int): 序列的起始数字。\nlast (int): 当前序列中的最后一个数字。\nmemo (dict): 用于记忆化的字典，存储每个遇到的'last'值的有效序列数量。\n\n返回：\nint: 可以从'n'开始形成的有效序列的总数。\n\n示例：\n只有一个序列可以从1开始形成：[1]\n>>> count_sequences(1, 1, {})\n1\n\n可以从6开始形成六个序列：\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\n更复杂的示例，传递记忆化字典\n通常不会手动传递此字典，它由函数内部用于优化。\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # 这是示例中的假定值；实际结果可能不同。", "fr": "Calculer le nombre de séquences valides qui peuvent être formées selon des règles spécifiques.\n\nChaque séquence commence par un nombre donné 'n', et un nouveau nombre peut être ajouté à la séquence\ns'il est un entier positif et ne dépasse pas la moitié du dernier nombre de la séquence. Cette\nfonction utilise la mémoïsation pour stocker les résultats précédemment calculés afin d'optimiser les performances.\n\nArgs:\nn (int): Le nombre de départ de la séquence.\nlast (int): Le dernier nombre dans la séquence actuelle.\nmemo (dict): Un dictionnaire utilisé pour la mémoïsation, stockant le nombre de séquences valides\npour chaque valeur 'last' rencontrée.\n\nReturns:\nint: Le nombre total de séquences valides qui peuvent être formées en commençant par 'n'.\n\nExamples:\nUne seule séquence peut être formée en commençant par 1 : [1]\n>>> count_sequences(1, 1, {})\n1\n\nSix séquences peuvent être formées en commençant par 6 :\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nExemple plus complexe avec dictionnaire de mémoïsation passé\nVous ne passeriez généralement pas ce dictionnaire manuellement,\nil est utilisé en interne par la fonction pour l'optimisation.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Ceci est une valeur supposée pour l'exemple ; le résultat réel peut différer.", "de": "Berechne die Anzahl der gültigen Sequenzen, die gemäß spezifischer Regeln gebildet werden können.\n\nJede Sequenz beginnt mit einer gegebenen Zahl 'n', und eine neue Zahl kann an die Sequenz angehängt werden, wenn sie eine positive ganze Zahl ist und nicht größer als die Hälfte der letzten Zahl in der Sequenz. Diese Funktion verwendet Memoisierung, um zuvor berechnete Ergebnisse zu speichern und die Leistung zu optimieren.\n\nArgs:\nn (int): Die Startzahl der Sequenz.\nlast (int): Die letzte Zahl in der aktuellen Sequenz.\nmemo (dict): Ein Wörterbuch, das für die Memoisierung verwendet wird und die Anzahl der gültigen Sequenzen für jeden aufgetretenen 'last'-Wert speichert.\n\nReturns:\nint: Die Gesamtanzahl der gültigen Sequenzen, die mit 'n' beginnen können.\n\nExamples:\nEs kann nur eine Sequenz gebildet werden, die mit 1 beginnt: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSechs Sequenzen können gebildet werden, die mit 6 beginnen:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nKomplexeres Beispiel mit übergebenem Memoisierungs-Wörterbuch\nNormalerweise würde man dieses Wörterbuch nicht manuell übergeben,\nes wird intern von der Funktion zur Optimierung verwendet.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Dies ist ein angenommener Wert für das Beispiel; das tatsächliche Ergebnis kann abweichen.", "ha": "Ƙididdige adadin jerin sahihai da za a iya samarwa bisa ga wasu ka'idoji.\n\nKowane jeri yana farawa da wani lamba 'n', kuma za a iya ƙara sabon lamba zuwa jerin idan yana da lamba mai kyau kuma ba ya fi rabin lamba ta ƙarshe a cikin jerin ba. Wannan aikin yana amfani da memoization don adana sakamakon da aka riga aka lissafa don inganta aiki.\n\nArgs:\nn (int): Lambar farawa na jerin.\nlast (int): Lambar ƙarshe a cikin jerin yanzu.\nmemo (dict): Kamus da aka yi amfani da shi don memoization, yana adana adadin jerin sahihai don kowane ƙimar 'last' da aka haɗu da shi.\n\nReturns:\nint: Jimlar adadin jerin sahihai da za a iya samarwa farawa da 'n'.\n\nMisalai:\nJerin guda ɗaya kawai za a iya samarwa farawa da 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nJerin guda shida za a iya samarwa farawa da 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMisali mai rikitarwa tare da kamus na memoization da aka wuce\nYawanci ba za ku wuce wannan kamus ɗin da hannu ba,\nana amfani da shi a cikin aikin don ingantawa.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Wannan wata ƙima ce da aka ɗauka don misali; sakamakon ainihi na iya bambanta.", "hi": "विशिष्ट नियमों के अनुसार बनने वाले मान्य अनुक्रमों की संख्या की गणना करें।\n\nप्रत्येक अनुक्रम एक दिए गए संख्या 'n' से शुरू होता है, और एक नई संख्या अनुक्रम में जोड़ी जा सकती है\nयदि यह एक धनात्मक पूर्णांक है और अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं है। यह\nकार्य प्रदर्शन को अनुकूलित करने के लिए पहले से गणना किए गए परिणामों को संग्रहीत करने के लिए स्मृति-संवर्धन का उपयोग करता है।\n\nआर्ग्स:\nn (int): अनुक्रम की प्रारंभिक संख्या।\nlast (int): वर्तमान अनुक्रम में अंतिम संख्या।\nmemo (dict): स्मृति-संवर्धन के लिए उपयोग किया जाने वाला एक शब्दकोश, प्रत्येक 'last' मान के लिए मान्य अनुक्रमों की संख्या संग्रहीत करता है।\n\nरिटर्न्स:\nint: कुल मान्य अनुक्रमों की संख्या जो 'n' से शुरू होकर बनाई जा सकती है।\n\nउदाहरण:\nकेवल एक अनुक्रम 1 से शुरू होकर बनाया जा सकता है: [1]\n>>> count_sequences(1, 1, {})\n1\n\nछह अनुक्रम 6 से शुरू होकर बनाए जा सकते हैं:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nस्मृति-संवर्धन शब्दकोश के साथ अधिक जटिल उदाहरण\nआप आमतौर पर इस शब्दकोश को मैन्युअल रूप से पास नहीं करेंगे,\nयह कार्य द्वारा आंतरिक रूप से अनुकूलन के लिए उपयोग किया जाता है।\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # यह उदाहरण के लिए एक अनुमानित मान है; वास्तविक परिणाम भिन्न हो सकता है।", "hu": "Számolja ki az érvényes sorozatok számát, amelyek meghatározott szabályok szerint képezhetők.\n\nMinden sorozat egy adott 'n' számmal kezdődik, és egy új szám fűzhető a sorozathoz, ha pozitív egész szám, és nem nagyobb, mint a sorozat utolsó számának a fele. Ez a függvény memoizációt használ a korábban kiszámított eredmények tárolására a teljesítmény optimalizálása érdekében.\n\nArgs:\nn (int): A sorozat kezdő száma.\nlast (int): Az aktuális sorozat utolsó száma.\nmemo (dict): Egy szótár, amelyet memoizációra használnak, tárolva az érvényes sorozatok számát minden előforduló 'last' értékre.\n\nReturns:\nint: Az összes érvényes sorozat száma, amely 'n'-nel kezdődik.\n\nPéldák:\nCsak egy sorozat képezhető, amely 1-gyel kezdődik: [1]\n>>> count_sequences(1, 1, {})\n1\n\nHat sorozat képezhető, amely 6-tal kezdődik:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nÖsszetettebb példa memoizációs szótárral\nÁltalában nem adja meg ezt a szótárt manuálisan, a függvény belsőleg használja az optimalizáláshoz.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Ez egy feltételezett érték a példához; a tényleges eredmény eltérhet.", "es": "Calcular el número de secuencias válidas que se pueden formar según reglas específicas.\n\nCada secuencia comienza con un número dado 'n', y se puede agregar un nuevo número a la secuencia\nsi es un entero positivo y no es mayor que la mitad del último número en la secuencia. Esta\nfunción utiliza memoización para almacenar resultados calculados previamente y optimizar el rendimiento.\n\nArgumentos:\nn (int): El número inicial de la secuencia.\nlast (int): El último número en la secuencia actual.\nmemo (dict): Un diccionario utilizado para la memoización, que almacena el número de secuencias válidas\npara cada valor 'last' encontrado.\n\nDevuelve:\nint: El número total de secuencias válidas que se pueden formar comenzando con 'n'.\n\nEjemplos:\nSolo se puede formar una secuencia comenzando con 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSe pueden formar seis secuencias comenzando con 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nEjemplo más complejo con diccionario de memoización pasado\nTípicamente no pasarías este diccionario manualmente,\nse utiliza internamente por la función para optimización.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Este es un valor asumido para el ejemplo; el resultado real puede diferir.", "arb": "احسب عدد التسلسلات الصالحة التي يمكن تشكيلها وفقًا لقواعد محددة.\n\nكل تسلسل يبدأ برقم معين 'n'، ويمكن إضافة رقم جديد إلى التسلسل\nإذا كان عددًا صحيحًا موجبًا ولا يزيد عن نصف الرقم الأخير في التسلسل. هذه\nالدالة تستخدم التخزين المؤقت لتخزين النتائج المحسوبة مسبقًا لتحسين الأداء.\n\nيعيدالحجج:\nn (int): الرقم الذي يبدأ به التسلسل.\nlast (int): الرقم الأخير في التسلسل الحالي.\nmemo (dict): قاموس يُستخدم للتخزين المؤقت، حيث يتم تخزين عدد التسلسلات الصالحة\nلكل قيمة 'last' تم مواجهتها.\n\nيعيد:\nint: العدد الإجمالي للتسلسلات الصالحة التي يمكن تشكيلها بدءًا بـ 'n'.\n\nامثله:\nيمكن تشكيل تسلسل واحد فقط يبدأ بـ 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nيمكن تشكيل ستة تسلسلات تبدأ بـ 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nمثال أكثر تعقيدًا مع قاموس التخزين المؤقت الممرر\nعادةً لن تقوم بتمرير هذا القاموس يدويًا،\nيُستخدم داخليًا بواسطة الدالة للتحسين.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # هذه قيمة مفترضة للمثال؛ قد تختلف النتيجة الفعلية.", "sw": "Hesabu idadi ya mlolongo halali ambao unaweza kuundwa kulingana na sheria maalum.\n\nKila mlolongo huanza na nambari iliyotolewa 'n', na nambari mpya inaweza kuongezwa kwenye mlolongo\nikiwa ni nambari nzima chanya na haizidi nusu ya nambari ya mwisho katika mlolongo. Hii\nkazi hutumia memoization kuhifadhi matokeo yaliyokokotolewa hapo awali ili kuboresha utendaji.\n\nHoja:\nn (int): Nambari ya kuanzia ya mlolongo.\nlast (int): Nambari ya mwisho katika mlolongo wa sasa.\nmemo (dict): Kamusi inayotumika kwa memoization, kuhifadhi idadi ya milolongo halali\nkwa kila thamani ya 'last' iliyokutana nayo.\n\nInarejesha:\nint: Jumla ya idadi ya milolongo halali inayoweza kuundwa kuanzia na 'n'.\n\nMifano:\nMlolongo mmoja tu unaweza kuundwa kuanzia na 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nMilolongo sita inaweza kuundwa kuanzia na 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMfano mgumu zaidi na kamusi ya memoization iliyopitishwa\nKwa kawaida usingepitisha kamusi hii mwenyewe,\ninatumika ndani na kazi kwa ajili ya uboreshaji.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Hii ni thamani iliyodhaniwa kwa mfano; matokeo halisi yanaweza kutofautiana.", "tr": "Geçerli dizilerin belirli kurallara göre oluşturulabileceği sayıyı hesaplayın.\n\nHer dizi verilen bir sayı 'n' ile başlar ve dizinin son sayısının yarısından büyük olmayan pozitif bir tamsayı ise diziye yeni bir sayı eklenebilir. Bu fonksiyon, performansı optimize etmek için daha önce hesaplanmış sonuçları saklamak amacıyla memoizasyon kullanır.\n\nArgümanlar:\nn (int): Dizinin başlangıç sayısı.\nlast (int): Mevcut dizideki son sayı.\nmemo (dict): Her karşılaşılan 'last' değeri için geçerli dizilerin sayısını saklayan, memoizasyon için kullanılan bir sözlük.\n\nDöndürür:\nint: 'n' ile başlayan oluşturulabilecek toplam geçerli dizi sayısı.\n\nÖrnekler:\n1 ile başlayan sadece bir dizi oluşturulabilir: [1]\n>>> count_sequences(1, 1, {})\n1\n\n6 ile başlayan altı dizi oluşturulabilir:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMemoizasyon sözlüğü ile daha karmaşık bir örnek\nBu sözlüğü manuel olarak geçmezsiniz,\nfonksiyon tarafından optimizasyon için dahili olarak kullanılır.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Bu, örnek için varsayılan bir değerdir; gerçek sonuç farklı olabilir.", "vi": "Tính toán số lượng dãy hợp lệ có thể được tạo ra theo các quy tắc cụ thể.\n\nMỗi dãy bắt đầu với một số 'n' cho trước, và một số mới có thể được thêm vào dãy\nnếu nó là một số nguyên dương và không lớn hơn một nửa số cuối cùng trong dãy. Hàm này sử dụng ghi nhớ để lưu trữ các kết quả đã tính toán trước đó nhằm tối ưu hóa hiệu suất.\n\nTham số:\nn (int): Số bắt đầu của dãy.\nlast (int): Số cuối cùng trong dãy hiện tại.\nmemo (dict): Một từ điển được sử dụng cho ghi nhớ, lưu trữ số lượng dãy hợp lệ\ncho mỗi giá trị 'last' đã gặp.\n\nTrả về:\nint: Tổng số dãy hợp lệ có thể được tạo ra bắt đầu với 'n'.\n\nVí dụ:\nChỉ có một dãy có thể được tạo ra bắt đầu với 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSáu dãy có thể được tạo ra bắt đầu với 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nVí dụ phức tạp hơn với từ điển ghi nhớ được truyền vào\nBạn thường sẽ không truyền từ điển này thủ công,\nnó được sử dụng nội bộ bởi hàm để tối ưu hóa.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Đây là một giá trị giả định cho ví dụ; kết quả thực tế có thể khác.", "id": "Hitung jumlah urutan valid yang dapat dibentuk sesuai dengan aturan tertentu.\n\nSetiap urutan dimulai dengan angka 'n' yang diberikan, dan angka baru dapat ditambahkan ke urutan\njika itu adalah bilangan bulat positif dan tidak lebih besar dari setengah angka terakhir dalam urutan. Fungsi ini menggunakan memoization untuk menyimpan hasil yang telah dihitung sebelumnya untuk mengoptimalkan kinerja.\n\nArgs:\nn (int): Angka awal dari urutan.\nlast (int): Angka terakhir dalam urutan saat ini.\nmemo (dict): Sebuah kamus yang digunakan untuk memoization, menyimpan jumlah urutan valid\nuntuk setiap nilai 'last' yang ditemui.\n\nReturns:\nint: Jumlah total urutan valid yang dapat dibentuk dimulai dengan 'n'.\n\nExamples:\nHanya satu urutan yang dapat dibentuk dimulai dengan 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nEnam urutan dapat dibentuk dimulai dengan 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nContoh yang lebih kompleks dengan kamus memoization yang diteruskan\nAnda biasanya tidak akan meneruskan kamus ini secara manual,\nitu digunakan secara internal oleh fungsi untuk optimasi.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Ini adalah nilai asumsi untuk contoh; hasil sebenarnya mungkin berbeda.", "ja": "特定のルールに従って形成できる有効なシーケンスの数を計算します。\n\n各シーケンスは与えられた数 'n' で始まり、新しい数は正の整数であり、シーケンスの最後の数の半分以下である場合にのみシーケンスに追加できます。この関数はメモ化を使用して、以前に計算された結果を保存し、パフォーマンスを最適化します。\n\n引数:\nn (int): シーケンスの開始番号。\nlast (int): 現在のシーケンスの最後の番号。\nmemo (dict): メモ化に使用される辞書で、遭遇した各 'last' 値に対する有効なシーケンスの数を保存します。\n\n戻り値:\nint: 'n' で始まる有効なシーケンスの総数。\n\n例:\n1で始まるシーケンスは1つだけ形成できます: [1]\n>>> count_sequences(1, 1, {})\n1\n\n6で始まるシーケンスは6つ形成できます:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nメモ化辞書を渡すより複雑な例\n通常、この辞書を手動で渡すことはありません。\n関数内で最適化のために使用されます。\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # これは例の仮定値です。実際の結果は異なる場合があります。", "ko": "특정 규칙에 따라 형성될 수 있는 유효한 시퀀스의 수를 계산합니다.\n\n각 시퀀스는 주어진 숫자 'n'으로 시작하며, 새로운 숫자는 양의 정수이고 시퀀스의 마지막 숫자의 절반을 넘지 않는 경우에만 시퀀스에 추가될 수 있습니다. 이 함수는 메모이제이션을 사용하여 이전에 계산된 결과를 저장함으로써 성능을 최적화합니다.\n\nArgs:\nn (int): 시퀀스의 시작 숫자.\nlast (int): 현재 시퀀스의 마지막 숫자.\nmemo (dict): 메모이제이션에 사용되는 딕셔너리로, 만난 각 'last' 값에 대한 유효한 시퀀스의 수를 저장합니다.\n\nReturns:\nint: 'n'으로 시작할 수 있는 유효한 시퀀스의 총 수.\n\nExamples:\n1로 시작하는 시퀀스는 하나만 형성될 수 있습니다: [1]\n>>> count_sequences(1, 1, {})\n1\n\n6으로 시작하는 시퀀스는 여섯 개가 형성될 수 있습니다:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\n메모이제이션 딕셔너리가 전달되는 더 복잡한 예제\n일반적으로 이 딕셔너리를 수동으로 전달하지 않으며,\n함수의 내부 최적화에 사용됩니다.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # 이 값은 예제를 위한 가정된 값이며 실제 결과는 다를 수 있습니다.", "ml": "സവിശേഷമായ നിയമങ്ങൾ അനുസരിച്ച് രൂപീകരിക്കാവുന്ന സാധുവായ ക്രമങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n\nഓരോ ക്രമവും നൽകിയിരിക്കുന്ന സംഖ്യ 'n' ഉപയോഗിച്ച് ആരംഭിക്കുന്നു, ഒരു പുതിയ സംഖ്യ ക്രമത്തിൽ ചേർക്കാൻ കഴിയുന്നത്\nഅത് ഒരു ധനാത്മക പൂർണ്ണസംഖ്യയാണെങ്കിൽ മാത്രമേയുള്ളൂ, കൂടാതെ അത് ക്രമത്തിലെ അവസാന സംഖ്യയുടെ പകുതിയേക്കാൾ കൂടുതലാകരുത്. \nപ്രകടനക്ഷമത മെച്ചപ്പെടുത്താൻ മുമ്പ് കണക്കാക്കിയ ഫലങ്ങൾ സംഭരിക്കുന്നതിന് ഈ ഫംഗ്ഷൻ മെമോവൈസേഷൻ ഉപയോഗിക്കുന്നു.\n\nആർഗുകൾ:\nn (int): ക്രമത്തിന്റെ ആരംഭ സംഖ്യ.\nlast (int): നിലവിലെ ക്രമത്തിലെ അവസാന സംഖ്യ.\nmemo (dict): മെമോവൈസേഷനായി ഉപയോഗിക്കുന്ന ഒരു നിഘണ്ടു, ഓരോ 'last' മൂല്യത്തിനും നേരിടുന്ന സാധുവായ ക്രമങ്ങളുടെ എണ്ണം സംഭരിക്കുന്നു.\n\nമടക്കം:\nint: 'n' ഉപയോഗിച്ച് ആരംഭിക്കാവുന്ന മൊത്തം സാധുവായ ക്രമങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n1 ഉപയോഗിച്ച് ആരംഭിക്കുന്ന ഒരു ക്രമം മാത്രമേ രൂപീകരിക്കാനാകൂ: [1]\n>>> count_sequences(1, 1, {})\n1\n\n6 ഉപയോഗിച്ച് ആരംഭിക്കുന്ന ആറു ക്രമങ്ങൾ രൂപീകരിക്കാനാകും:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nമെമോവൈസേഷൻ നിഘണ്ടു പാസ്സുചെയ്തുകൊണ്ടുള്ള കൂടുതൽ സങ്കീർണ്ണമായ ഉദാഹരണം\nനിങ്ങൾ സാധാരണയായി ഈ നിഘണ്ടു കൈമാറുകയില്ല,\nഇത് ഫംഗ്ഷൻ ആന്തരികമായി പ്രയോഗക്ഷമതയ്ക്കായി ഉപയോഗിക്കുന്നു.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # ഉദാഹരണത്തിനായി ഒരു അനുമാന മൂല്യം; യഥാർത്ഥ ഫലം വ്യത്യാസപ്പെട്ടേക്കാം.", "fa": "محاسبه تعداد دنباله‌های معتبری که می‌توان بر اساس قوانین خاصی تشکیل داد.\n\nهر دنباله با یک عدد داده شده 'n' شروع می‌شود و یک عدد جدید می‌تواند به دنباله اضافه شود\nاگر یک عدد صحیح مثبت باشد و بیشتر از نصف عدد آخر در دنباله نباشد. این\nتابع از حافظه‌گذاری برای ذخیره نتایج محاسبه شده قبلی استفاده می‌کند تا عملکرد را بهینه کند.\n\nآرگومان‌ها:\nn (int): عدد شروع دنباله.\nlast (int): آخرین عدد در دنباله فعلی.\nmemo (dict): یک دیکشنری که برای حافظه‌گذاری استفاده می‌شود و تعداد دنباله‌های معتبر\nبرای هر مقدار 'last' مواجه شده را ذخیره می‌کند.\n\nبازگشت:\nint: تعداد کل دنباله‌های معتبری که می‌توان با شروع از 'n' تشکیل داد.\n\nمثال‌ها:\nفقط یک دنباله می‌تواند با شروع از 1 تشکیل شود: [1]\n>>> count_sequences(1, 1, {})\n1\n\nشش دنباله می‌تواند با شروع از 6 تشکیل شود:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nمثال پیچیده‌تر با دیکشنری حافظه‌گذاری که منتقل شده است\nشما معمولاً این دیکشنری را به صورت دستی منتقل نمی‌کنید،\nاین دیکشنری به صورت داخلی توسط تابع برای بهینه‌سازی استفاده می‌شود.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # این یک مقدار فرضی برای مثال است؛ نتیجه واقعی ممکن است متفاوت باشد."}}
{"task_id": "Python/26", "prompt": {"en": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    Case 1: count_coprime_pairs(3, 60)\n    Explanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\n    Case 2: count_coprime_pairs(2, 50)\n    Explanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\n    Case 3: count_coprime_pairs(6, 180)\n    Explanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\n    Note:\n    For the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0, \n    indicating no valid pairs exist under the given constraints.\n    \"\"\"", "sq": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Numëron numrin e çifteve të numrave të plotë pozitivë (P, Q) të tillë që P dhe Q kanë x0 si përbashkuesin më të madh (GCD)\n    dhe y0 si shumëfishin më të vogël të përbashkët (LCM).\n\n    Argumentet:\n    x0 (int): GCD që çdo çift (P, Q) duhet të ketë.\n    y0 (int): LCM që çdo çift (P, Q) duhet të ketë.\n\n    Kthen:\n    int: Numri i të gjitha çifteve të mundshme (P, Q) që plotësojnë kriteret e specifikuara.\n\n    Funksioni iteron nëpër të gjithë faktorët e mundshëm 'a' të kuotientit 'y0 / x0'. Për çdo faktor 'a',\n    llogarit faktorin përkatës 'b' të tillë që 'a * b = y0 / x0'. Pastaj kontrollon nëse 'a' dhe 'b'\n    janë bashkë-kryesorë (GCD i tyre është 1) sepse P dhe Q mund të jenë vetëm shumëfishë të 'x0' nga faktorë bashkë-kryesorë për të ruajtur\n    GCD si 'x0'. Nëse 'a' dhe 'b' janë bashkë-kryesorë, numri rritet me 1 nëse 'a' është i njëjtë me 'b',\n    përndryshe me 2 për të llogaritur të dy çiftet (P, Q) dhe (Q, P).\n\n    Shembuj Rastesh:\n\n    Rasti 1: count_coprime_pairs(3, 60)\n    Shpjegim: Funksioni do të kthejë 4, pasi çiftet e vlefshme janë (3, 60), (15, 12), (12, 15), dhe (60, 3).\n\n    Rasti 2: count_coprime_pairs(2, 50)\n    Shpjegim: Funksioni do të kthejë 0, pasi 50 nuk është shumëfish i 2, kështu që nuk ka çifte të vlefshme (P, Q).\n\n    Rasti 3: count_coprime_pairs(6, 180)\n    Shpjegim: Funksioni do të kthejë 8, çiftet e vlefshme janë (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), dhe numërimet për rregullimet e tjera të këtyre numrave.\n\n    Shënim:\n    Për që funksioni të punojë saktë, hyrja y0 duhet të jetë shumëfish i x0. Nëse jo, funksioni kthen 0,\n    duke treguar se nuk ekzistojnë çifte të vlefshme nën kufizimet e dhëna.\n    \"\"\"", "hy": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Հաշվում է դրական ամբողջ թվերի (P, Q) զույգերի քանակը, այնպես որ P և Q թվերի ամենամեծ ընդհանուր բաժանարարը (GCD) լինի x0,\n    իսկ ամենափոքր ընդհանուր բազմապատիկը (LCM) լինի y0:\n\n    Արձանագրություններ:\n    x0 (int): GCD, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q):\n    y0 (int): LCM, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q):\n\n    Վերադարձնում է:\n    int: Բոլոր հնարավոր զույգերի (P, Q) քանակը, որոնք համապատասխանում են նշված չափանիշներին:\n\n    Ֆունկցիան անցնում է 'y0 / x0' բաժանարարի բոլոր հնարավոր գործոններով 'a':ի միջոցով: Յուրաքանչյուր գործոնի համար 'a',\n    հաշվարկում է համապատասխան գործոնը 'b', այնպես որ 'a * b = y0 / x0':ի: Այնուհետև ստուգում է՝ արդյոք 'a' և 'b'\n    փոխադարձաբար պարզ են (նրանց GCD-ն 1 է), քանի որ P և Q կարող են լինել միայն 'x0'-ի բազմապատիկներ՝ փոխադարձաբար պարզ գործոններով,\n    որպեսզի պահպանվի GCD-ն որպես 'x0':ի: Եթե 'a' և 'b' փոխադարձաբար պարզ են, հաշվարկը մեծանում է 1-ով, եթե 'a' նույնն է 'b'-ի հետ,\n    այլապես 2-ով՝ հաշվի առնելով (P, Q) և (Q, P) զույգերը:\n\n    Օրինակային դեպքեր:\n\n    Դեպք 1: count_coprime_pairs(3, 60)\n    Բացատրություն: Ֆունկցիան կվերադարձնի 4, քանի որ վավեր զույգերն են (3, 60), (15, 12), (12, 15) և (60, 3):\n\n    Դեպք 2: count_coprime_pairs(2, 50)\n    Բացատրություն: Ֆունկցիան կվերադարձնի 0, քանի որ 50-ը 2-ի բազմապատիկ չէ, ուստի վավեր զույգեր (P, Q) չկան:\n\n    Դեպք 3: count_coprime_pairs(6, 180)\n    Բացատրություն: Ֆունկցիան կվերադարձնի 8, վավեր զույգերն են (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), և այս թվերի այլ դասավորությունների հաշվարկները:\n\n    Նշում:\n    Որպեսզի ֆունկցիան ճիշտ աշխատի, մուտքային y0-ը պետք է լինի x0-ի բազմապատիկ: Եթե ոչ, ֆունկցիան վերադարձնում է 0,\n    ցույց տալով, որ վավեր զույգեր չկան տրված սահմանափակումների ներքո:\n    \"\"\"", "bn": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    কতগুলি যুগল ধনাত্মক পূর্ণসংখ্যা (P, Q) আছে তা গণনা করে যেখানে P এবং Q এর x0 তাদের গরিষ্ঠ সাধারণ বিভাজক (GCD)\n    এবং y0 তাদের লঘিষ্ঠ সাধারণ গুণিতক (LCM)।\n\n    Args:\n    x0 (int): GCD যা প্রতিটি যুগল (P, Q) এর থাকতে হবে।\n    y0 (int): LCM যা প্রতিটি যুগল (P, Q) এর থাকতে হবে।\n\n    Returns:\n    int: সমস্ত সম্ভাব্য যুগল (P, Q) এর সংখ্যা যা নির্দিষ্ট মানদণ্ড পূরণ করে।\n\n    ফাংশনটি 'y0 / x0' এর সমস্ত সম্ভাব্য গুণক 'a' এর মধ্য দিয়ে পুনরাবৃত্তি করে। প্রতিটি গুণক 'a' এর জন্য,\n    এটি সংশ্লিষ্ট গুণক 'b' গণনা করে যাতে 'a * b = y0 / x0' হয়। তারপর এটি পরীক্ষা করে 'a' এবং 'b'\n    সহমৌলিক কিনা (তাদের GCD হল 1) কারণ P এবং Q শুধুমাত্র 'x0' এর গুণিতক হতে পারে সহমৌলিক গুণক দ্বারা\n    GCD কে 'x0' হিসাবে বজায় রাখতে। যদি 'a' এবং 'b' সহমৌলিক হয়, তাহলে গণনা 1 দ্বারা বৃদ্ধি পায় যদি 'a' এবং 'b' একই হয়,\n    অন্যথায় 2 দ্বারা বৃদ্ধি পায় যাতে উভয় (P, Q) এবং (Q, P) যুগলগুলি অন্তর্ভুক্ত হয়।\n\n    উদাহরণ কেসসমূহ:\n\n    কেস 1: count_coprime_pairs(3, 60)\n    ব্যাখ্যা: ফাংশনটি 4 ফেরত দেবে, কারণ বৈধ যুগলগুলি হল (3, 60), (15, 12), (12, 15), এবং (60, 3)।\n\n    কেস 2: count_coprime_pairs(2, 50)\n    ব্যাখ্যা: ফাংশনটি 0 ফেরত দেবে, কারণ 50 হল 2 এর গুণিতক নয়, তাই কোন বৈধ যুগল (P, Q) নেই।\n\n    কেস 3: count_coprime_pairs(6, 180)\n    ব্যাখ্যা: ফাংশনটি 8 ফেরত দেবে, বৈধ যুগলগুলি হল (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), এবং এই সংখ্যাগুলির অন্যান্য বিন্যাসের জন্য গণনা।\n\n    নোট:\n    ফাংশনটি সঠিকভাবে কাজ করার জন্য, ইনপুট y0 অবশ্যই x0 এর গুণিতক হতে হবে। যদি না হয়, ফাংশনটি 0 ফেরত দেয়,\n    যা নির্দেশ করে যে প্রদত্ত সীমাবদ্ধতার অধীনে কোন বৈধ যুগল নেই।\n    \"\"\"", "bg": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Брои броя на двойките положителни цели числа (P, Q), такива че P и Q имат x0 като техен най-голям общ делител (НОД)\n    и y0 като тяхно най-малко общо кратно (НОК).\n\n    Args:\n    x0 (int): НОД, който всяка двойка (P, Q) трябва да има.\n    y0 (int): НОК, който всяка двойка (P, Q) трябва да има.\n\n    Returns:\n    int: Броят на всички възможни двойки (P, Q), които отговарят на зададените критерии.\n\n    Функцията преминава през всички възможни делители 'a' на частното 'y0 / x0'. За всеки делител 'a',\n    тя изчислява съответния делител 'b', такъв че 'a * b = y0 / x0'. След това проверява дали 'a' и 'b'\n    са взаимно прости (техният НОД е 1), защото P и Q могат да бъдат само кратни на 'x0' чрез взаимно прости делители,\n    за да се запази НОД като 'x0'. Ако 'a' и 'b' са взаимно прости, броят се увеличава с 1, ако 'a' е същото като 'b',\n    иначе с 2, за да се отчетат и двете двойки (P, Q) и (Q, P).\n\n    Примерни случаи:\n\n    Случай 1: count_coprime_pairs(3, 60)\n    Обяснение: Функцията ще върне 4, тъй като валидните двойки са (3, 60), (15, 12), (12, 15) и (60, 3).\n\n    Случай 2: count_coprime_pairs(2, 50)\n    Обяснение: Функцията ще върне 0, тъй като 50 не е кратно на 2, така че няма валидни двойки (P, Q).\n\n    Случай 3: count_coprime_pairs(6, 180)\n    Обяснение: Функцията ще върне 8, валидните двойки са (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6) и броят на другите подреждания на тези числа.\n\n    Забележка:\n    За да работи функцията правилно, входът y0 трябва да бъде кратен на x0. Ако не е, функцията връща 0,\n    което показва, че няма валидни двойки при дадените ограничения.\n    \"\"\"", "zh": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    计算正整数对 (P, Q) 的数量，使得 P 和 Q 的最大公约数 (GCD) 为 x0，最小公倍数 (LCM) 为 y0。\n\n    参数:\n    x0 (int): 每对 (P, Q) 必须具有的 GCD。\n    y0 (int): 每对 (P, Q) 必须具有的 LCM。\n\n    返回:\n    int: 满足指定条件的所有可能对 (P, Q) 的数量。\n\n    该函数遍历商 'y0 / x0' 的所有可能因子 'a'。对于每个因子 'a'，计算对应的因子 'b' 使得 'a * b = y0 / x0'。\n    然后检查 'a' 和 'b' 是否互质（它们的 GCD 为 1），因为 P 和 Q 只能是 'x0' 的倍数，通过互质因子来保持\n    GCD 为 'x0'。如果 'a' 和 'b' 互质，则如果 'a' 等于 'b'，计数增加 1，否则增加 2，以考虑 (P, Q) 和 (Q, P) 对。\n\n    示例案例:\n\n    案例 1: count_coprime_pairs(3, 60)\n    解释: 函数将返回 4，因为有效的对是 (3, 60), (15, 12), (12, 15), 和 (60, 3)。\n\n    案例 2: count_coprime_pairs(2, 50)\n    解释: 函数将返回 0，因为 50 不是 2 的倍数，因此没有有效的对 (P, Q)。\n\n    案例 3: count_coprime_pairs(6, 180)\n    解释: 函数将返回 8，有效的对是 (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6)，以及这些数字的其他排列的计数。\n\n    注意:\n    为了函数正确工作，输入 y0 必须是 x0 的倍数。如果不是，函数返回 0，表示在给定约束下不存在有效对。\n    \"\"\"", "fr": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Compte le nombre de paires d'entiers positifs (P, Q) tels que P et Q ont x0 comme leur plus grand commun diviseur (PGCD)\n    et y0 comme leur plus petit commun multiple (PPCM).\n\n    Args:\n    x0 (int): Le PGCD que chaque paire (P, Q) doit avoir.\n    y0 (int): Le PPCM que chaque paire (P, Q) doit avoir.\n\n    Returns:\n    int: Le nombre de toutes les paires possibles (P, Q) qui répondent aux critères spécifiés.\n\n    La fonction parcourt tous les facteurs possibles 'a' du quotient 'y0 / x0'. Pour chaque facteur 'a',\n    elle calcule le facteur correspondant 'b' tel que 'a * b = y0 / x0'. Elle vérifie ensuite si 'a' et 'b'\n    sont copremiers (leur PGCD est 1) car P et Q ne peuvent être que des multiples de 'x0' par des facteurs copremiers pour maintenir\n    le PGCD comme 'x0'. Si 'a' et 'b' sont copremiers, le compte est incrémenté de 1 si 'a' est le même que 'b',\n    sinon de 2 pour tenir compte des paires (P, Q) et (Q, P).\n\n    Cas d'exemple:\n\n    Cas 1: count_coprime_pairs(3, 60)\n    Explication: La fonction retournerait 4, puisque les paires valides sont (3, 60), (15, 12), (12, 15), et (60, 3).\n\n    Cas 2: count_coprime_pairs(2, 50)\n    Explication: La fonction retournerait 0, car 50 n'est pas un multiple de 2, donc il n'y a pas de paires valides (P, Q).\n\n    Cas 3: count_coprime_pairs(6, 180)\n    Explication: La fonction retournerait 8, les paires valides sont (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), et les comptes pour d'autres arrangements de ces nombres.\n\n    Remarque:\n    Pour que la fonction fonctionne correctement, l'entrée y0 doit être un multiple de x0. Sinon, la fonction retourne 0,\n    indiquant qu'aucune paire valide n'existe sous les contraintes données.\n    \"\"\"", "de": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Zählt die Anzahl der Paare positiver ganzer Zahlen (P, Q), sodass P und Q x0 als ihren größten gemeinsamen Teiler (GCD)\n    und y0 als ihr kleinstes gemeinsames Vielfaches (LCM) haben.\n\n    Args:\n    x0 (int): Der GCD, den jedes Paar (P, Q) haben muss.\n    y0 (int): Der LCM, den jedes Paar (P, Q) haben muss.\n\n    Returns:\n    int: Die Anzahl aller möglichen Paare (P, Q), die die angegebenen Kriterien erfüllen.\n\n    Die Funktion iteriert durch alle möglichen Faktoren 'a' des Quotienten 'y0 / x0'. Für jeden Faktor 'a'\n    berechnet sie den entsprechenden Faktor 'b', sodass 'a * b = y0 / x0'. Sie prüft dann, ob 'a' und 'b'\n    teilerfremd sind (ihr GCD ist 1), da P und Q nur Vielfache von 'x0' durch teilerfremde Faktoren sein können, um\n    den GCD als 'x0' beizubehalten. Wenn 'a' und 'b' teilerfremd sind, wird der Zähler um 1 erhöht, wenn 'a' gleich 'b' ist,\n    andernfalls um 2, um sowohl (P, Q) als auch (Q, P) Paare zu berücksichtigen.\n\n    Beispiel Fälle:\n\n    Fall 1: count_coprime_pairs(3, 60)\n    Erklärung: Die Funktion würde 4 zurückgeben, da die gültigen Paare (3, 60), (15, 12), (12, 15) und (60, 3) sind.\n\n    Fall 2: count_coprime_pairs(2, 50)\n    Erklärung: Die Funktion würde 0 zurückgeben, da 50 kein Vielfaches von 2 ist, also gibt es keine gültigen Paare (P, Q).\n\n    Fall 3: count_coprime_pairs(6, 180)\n    Erklärung: Die Funktion würde 8 zurückgeben, die gültigen Paare sind (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), und die Zählungen für andere Anordnungen dieser Zahlen.\n\n    Hinweis:\n    Damit die Funktion korrekt funktioniert, muss die Eingabe y0 ein Vielfaches von x0 sein. Wenn nicht, gibt die Funktion 0 zurück,\n    was anzeigt, dass unter den gegebenen Bedingungen keine gültigen Paare existieren.\n    \"\"\"", "ha": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Yana ƙididdige yawan ma'aurata na lambobi masu kyau (P, Q) ta yadda P da Q suna da x0 a matsayin mafi girman abin da za a iya raba su (GCD)\n    kuma y0 a matsayin mafi ƙarancin abin da za su iya raba su (LCM).\n\n    Args:\n    x0 (int): GCD wanda kowanne ma'aurata (P, Q) dole ne ya kasance da shi.\n    y0 (int): LCM wanda kowanne ma'aurata (P, Q) dole ne ya kasance da shi.\n\n    Returns:\n    int: Yawan duk ma'aurata masu yiwuwa (P, Q) waɗanda suka cika ƙa'idodin da aka fayyace.\n\n    Aikin yana zagayawa ta dukkan abubuwan da za su iya zama 'a' na rabo 'y0 / x0'. Ga kowane abu 'a',\n    yana ƙididdige abin da ya dace 'b' ta yadda 'a * b = y0 / x0'. Sannan yana duba idan 'a' da 'b'\n    suna da juna (GCD ɗin su 1 ne) domin P da Q za su iya zama sau na 'x0' ta abubuwan da ba su da juna don kiyaye\n    GCD a matsayin 'x0'. Idan 'a' da 'b' suna da juna, ana ƙara yawan da 1 idan 'a' daidai yake da 'b',\n    in ba haka ba da 2 don lissafin duka ma'aurata (P, Q) da (Q, P).\n\n    Misalan Hali:\n\n    Hali 1: count_coprime_pairs(3, 60)\n    Bayani: Aikin zai dawo da 4, tunda ma'auratan da suka dace sune (3, 60), (15, 12), (12, 15), da (60, 3).\n\n    Hali 2: count_coprime_pairs(2, 50)\n    Bayani: Aikin zai dawo da 0, domin 50 ba sau na 2 bane, don haka babu ma'aurata masu dacewa (P, Q).\n\n    Hali 3: count_coprime_pairs(6, 180)\n    Bayani: Aikin zai dawo da 8, ma'auratan da suka dace sune (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), da ƙididdigar sauran tsarukan waɗannan lambobin.\n\n    Lura:\n    Domin aikin ya yi aiki daidai, shigar y0 dole ne ya zama sau na x0. Idan ba haka ba, aikin yana dawo da 0,\n    yana nuna babu ma'aurata masu dacewa a ƙarƙashin ƙa'idodin da aka bayar.\n    \"\"\"", "hi": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    उन युग्मों (P, Q) की संख्या गिनता है जिनके लिए P और Q का x0 उनका महत्तम समापवर्तक (GCD) है\n    और y0 उनका लघुत्तम समापवर्त्य (LCM) है।\n\n    तर्क:\n    x0 (int): वह GCD जो प्रत्येक युग्म (P, Q) का होना चाहिए।\n    y0 (int): वह LCM जो प्रत्येक युग्म (P, Q) का होना चाहिए।\n\n    लौटाता है:\n    int: सभी संभावित युग्मों (P, Q) की गिनती जो निर्दिष्ट मानदंडों को पूरा करते हैं।\n\n    यह फ़ंक्शन 'y0 / x0' के भाजक 'a' के सभी संभावित कारकों के माध्यम से पुनरावृत्ति करता है। प्रत्येक कारक 'a' के लिए,\n    यह संबंधित कारक 'b' की गणना करता है ताकि 'a * b = y0 / x0' हो। फिर यह जांचता है कि 'a' और 'b'\n    सह-प्राइम हैं (उनका GCD 1 है) क्योंकि P और Q केवल 'x0' के गुणज सह-प्राइम कारकों द्वारा हो सकते हैं ताकि\n    GCD 'x0' बना रहे। यदि 'a' और 'b' सह-प्राइम हैं, तो गिनती को 1 से बढ़ाया जाता है यदि 'a' 'b' के समान है,\n    अन्यथा 2 से बढ़ाया जाता है ताकि (P, Q) और (Q, P) दोनों युग्मों को शामिल किया जा सके।\n\n    उदाहरण मामले:\n\n    मामला 1: count_coprime_pairs(3, 60)\n    व्याख्या: फ़ंक्शन 4 लौटाएगा, क्योंकि मान्य युग्म हैं (3, 60), (15, 12), (12, 15), और (60, 3)।\n\n    मामला 2: count_coprime_pairs(2, 50)\n    व्याख्या: फ़ंक्शन 0 लौटाएगा, क्योंकि 50, 2 का गुणज नहीं है, इसलिए कोई मान्य युग्म (P, Q) नहीं हैं।\n\n    मामला 3: count_coprime_pairs(6, 180)\n    व्याख्या: फ़ंक्शन 8 लौटाएगा, मान्य युग्म हैं (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), और इन संख्याओं के अन्य व्यवस्थाओं के लिए गिनती।\n\n    नोट:\n    फ़ंक्शन के सही ढंग से काम करने के लिए, इनपुट y0 को x0 का गुणज होना चाहिए। यदि नहीं, तो फ़ंक्शन 0 लौटाता है,\n    यह दर्शाता है कि दिए गए प्रतिबंधों के तहत कोई मान्य युग्म मौजूद नहीं है।\n    \"\"\"", "hu": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Megszámolja azon pozitív egész számokból álló (P, Q) párok számát, amelyekre P és Q legnagyobb közös osztója (GCD) x0,\n    és legkisebb közös többszöröse (LCM) y0.\n\n    Args:\n    x0 (int): Az a GCD, amelyet minden (P, Q) párnak tartalmaznia kell.\n    y0 (int): Az az LCM, amelyet minden (P, Q) párnak tartalmaznia kell.\n\n    Returns:\n    int: Az összes lehetséges (P, Q) pár száma, amelyek megfelelnek a megadott kritériumoknak.\n\n    A függvény végigmegy az összes lehetséges 'a' tényezőn, amely a 'y0 / x0' hányados tényezője. Minden 'a' tényezőhöz\n    kiszámítja a megfelelő 'b' tényezőt úgy, hogy 'a * b = y0 / x0'. Ezután ellenőrzi, hogy 'a' és 'b' relatív prímek-e\n    (GCD-jük 1), mert P és Q csak akkor lehetnek 'x0' többszörösei relatív prím tényezők által, hogy a GCD 'x0' maradjon.\n    Ha 'a' és 'b' relatív prímek, a számláló 1-gyel növekszik, ha 'a' megegyezik 'b'-vel, különben 2-vel, hogy figyelembe\n    vegye mind a (P, Q), mind a (Q, P) párokat.\n\n    Példa esetek:\n\n    Eset 1: count_coprime_pairs(3, 60)\n    Magyarázat: A függvény 4-et ad vissza, mivel az érvényes párok: (3, 60), (15, 12), (12, 15) és (60, 3).\n\n    Eset 2: count_coprime_pairs(2, 50)\n    Magyarázat: A függvény 0-t ad vissza, mivel 50 nem többszöröse 2-nek, így nincsenek érvényes (P, Q) párok.\n\n    Eset 3: count_coprime_pairs(6, 180)\n    Magyarázat: A függvény 8-at ad vissza, az érvényes párok: (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), és a számok más elrendezéseinek száma.\n\n    Megjegyzés:\n    Ahhoz, hogy a függvény helyesen működjön, a bemeneti y0-nak x0 többszörösének kell lennie. Ha nem, a függvény 0-t ad vissza,\n    jelezve, hogy a megadott feltételek mellett nincsenek érvényes párok.\n    \"\"\"", "es": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Cuenta el número de pares de enteros positivos (P, Q) tales que P y Q tienen x0 como su máximo común divisor (GCD)\n    y y0 como su mínimo común múltiplo (LCM).\n\n    Argumentos:\n    x0 (int): El GCD que cada par (P, Q) debe tener.\n    y0 (int): El LCM que cada par (P, Q) debe tener.\n\n    Devuelve:\n    int: La cuenta de todos los pares posibles (P, Q) que cumplen con los criterios especificados.\n\n    La función itera a través de todos los posibles factores 'a' del cociente 'y0 / x0'. Para cada factor 'a',\n    calcula el factor correspondiente 'b' tal que 'a * b = y0 / x0'. Luego verifica si 'a' y 'b'\n    son coprimos (su GCD es 1) porque P y Q solo pueden ser múltiplos de 'x0' por factores coprimos para mantener\n    el GCD como 'x0'. Si 'a' y 'b' son coprimos, la cuenta se incrementa en 1 si 'a' es igual a 'b',\n    de lo contrario en 2 para contabilizar ambos pares (P, Q) y (Q, P).\n\n    Casos de Ejemplo:\n\n    Caso 1: count_coprime_pairs(3, 60)\n    Explicación: La función devolvería 4, ya que los pares válidos son (3, 60), (15, 12), (12, 15), y (60, 3).\n\n    Caso 2: count_coprime_pairs(2, 50)\n    Explicación: La función devolvería 0, ya que 50 no es un múltiplo de 2, por lo que no hay pares válidos (P, Q).\n\n    Caso 3: count_coprime_pairs(6, 180)\n    Explicación: La función devolvería 8, los pares válidos son (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), y las cuentas para otras disposiciones de estos números.\n\n    Nota:\n    Para que la función funcione correctamente, la entrada y0 debe ser un múltiplo de x0. Si no, la función devuelve 0,\n    indicando que no existen pares válidos bajo las restricciones dadas.\n    \"\"\"", "arb": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    يحسب عدد أزواج الأعداد الصحيحة الموجبة (P, Q) بحيث يكون P و Q لهما x0 كأكبر قاسم مشترك (GCD)\n    و y0 كأصغر مضاعف مشترك (LCM).\n\n    يعيدالحجج:\n    x0 (int): القاسم المشترك الأكبر الذي يجب أن يكون لكل زوج (P, Q).\n    y0 (int): المضاعف المشترك الأصغر الذي يجب أن يكون لكل زوج (P, Q).\n\n    يعيد:\n    int: عدد جميع الأزواج الممكنة (P, Q) التي تفي بالمعايير المحددة.\n\n    تقوم الدالة بالمرور عبر جميع العوامل الممكنة 'a' للناتج 'y0 / x0'. لكل عامل 'a',\n    تحسب العامل المقابل 'b' بحيث 'a * b = y0 / x0'. ثم تتحقق مما إذا كان 'a' و 'b'\n    متوافقين (القاسم المشترك الأكبر لهما هو 1) لأن P و Q يمكن أن يكونا فقط مضاعفات لـ 'x0' بعوامل متوافقة للحفاظ\n    على القاسم المشترك الأكبر كـ 'x0'. إذا كان 'a' و 'b' متوافقين، يتم زيادة العداد بمقدار 1 إذا كان 'a' هو نفسه 'b',\n    وإلا بمقدار 2 لحساب كلا الزوجين (P, Q) و (Q, P).\n\n    أمثلة الحالات:\n\n    الحالة 1: count_coprime_pairs(3, 60)\n    التوضيح: ستعيد الدالة 4، حيث أن الأزواج الصالحة هي (3, 60)، (15, 12)، (12, 15)، و (60, 3).\n\n    الحالة 2: count_coprime_pairs(2, 50)\n    التوضيح: ستعيد الدالة 0، حيث أن 50 ليس مضاعفًا لـ 2، لذلك لا توجد أزواج صالحة (P, Q).\n\n    الحالة 3: count_coprime_pairs(6, 180)\n    التوضيح: ستعيد الدالة 8، الأزواج الصالحة هي (6, 180)، (30, 36)، (18, 60)، (42, 30)،\n    (60, 18)، (36, 30)، (180, 6)، والحسابات لترتيبات أخرى لهذه الأرقام.\n\n    ملاحظة:\n    لكي تعمل الدالة بشكل صحيح، يجب أن يكون المدخل y0 مضاعفًا لـ x0. إذا لم يكن كذلك، تعيد الدالة 0،\n    مما يشير إلى عدم وجود أزواج صالحة تحت القيود المعطاة.\n    \"\"\"", "sw": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Inahesabu idadi ya jozi za namba nzima chanya (P, Q) ambapo P na Q zina x0 kama kigezo chao kikuu cha mgawanyiko (GCD)\n    na y0 kama kigezo chao kidogo cha pamoja (LCM).\n\n    Hoja:\n    x0 (int): GCD ambayo kila jozi (P, Q) lazima iwe nayo.\n    y0 (int): LCM ambayo kila jozi (P, Q) lazima iwe nayo.\n\n    Inarejesha:\n    int: Idadi ya jozi zote zinazowezekana (P, Q) zinazokidhi vigezo vilivyobainishwa.\n\n    Kazi hii inarudia kupitia vigezo vyote vinavyowezekana 'a' vya sehemu 'y0 / x0'. Kwa kila kigezo 'a',\n    inahesabu kigezo kinacholingana 'b' ambapo 'a * b = y0 / x0'. Kisha inakagua kama 'a' na 'b'\n    ni huru (GCD yao ni 1) kwa sababu P na Q zinaweza kuwa tu na vigezo vya 'x0' kwa vigezo huru ili kudumisha\n    GCD kama 'x0'. Ikiwa 'a' na 'b' ni huru, hesabu inaongezwa kwa 1 ikiwa 'a' ni sawa na 'b',\n    vinginevyo kwa 2 ili kuhesabu jozi zote mbili (P, Q) na (Q, P).\n\n    Mifano ya Kesi:\n\n    Kesi 1: count_coprime_pairs(3, 60)\n    Maelezo: Kazi itarudisha 4, kwa kuwa jozi halali ni (3, 60), (15, 12), (12, 15), na (60, 3).\n\n    Kesi 2: count_coprime_pairs(2, 50)\n    Maelezo: Kazi itarudisha 0, kwa kuwa 50 si kigezo cha 2, hivyo hakuna jozi halali (P, Q).\n\n    Kesi 3: count_coprime_pairs(6, 180)\n    Maelezo: Kazi itarudisha 8, jozi halali ni (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), na hesabu za mipangilio mingine ya namba hizi.\n\n    Kumbuka:\n    Ili kazi ifanye kazi kwa usahihi, kipengele cha y0 lazima kiwe kigezo cha x0. Ikiwa sivyo, kazi inarudisha 0,\n    ikionyesha hakuna jozi halali zilizopo chini ya vikwazo vilivyotolewa.\n    \"\"\"", "tr": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    x0'ı en büyük ortak bölen (GCD) ve y0'ı en küçük ortak kat (LCM) olarak alan pozitif tam sayı çiftlerinin (P, Q) sayısını sayar.\n\n    Argümanlar:\n    x0 (int): Her çiftin (P, Q) sahip olması gereken GCD.\n    y0 (int): Her çiftin (P, Q) sahip olması gereken LCM.\n\n    Döndürür:\n    int: Belirtilen kriterleri karşılayan tüm olası çiftlerin (P, Q) sayısı.\n\n    Fonksiyon, 'y0 / x0' bölümünün tüm olası 'a' çarpanları üzerinden iterasyon yapar. Her 'a' çarpanı için,\n    'a * b = y0 / x0' olacak şekilde karşılık gelen 'b' çarpanını hesaplar. Daha sonra 'a' ve 'b' çarpanlarının\n    aralarında asal olup olmadığını kontrol eder (GCD'leri 1 ise) çünkü P ve Q sadece 'x0' çarpanları ile\n    aralarında asal çarpanlar olarak çarpılabilir, böylece GCD 'x0' olarak kalır. Eğer 'a' ve 'b' aralarında asal ise,\n    eğer 'a' 'b' ile aynıysa sayım 1 artırılır, aksi takdirde hem (P, Q) hem de (Q, P) çiftlerini hesaba katmak için 2 artırılır.\n\n    Örnek Durumlar:\n\n    Durum 1: count_coprime_pairs(3, 60)\n    Açıklama: Fonksiyon 4 döndürecektir, çünkü geçerli çiftler (3, 60), (15, 12), (12, 15) ve (60, 3) olacaktır.\n\n    Durum 2: count_coprime_pairs(2, 50)\n    Açıklama: Fonksiyon 0 döndürecektir, çünkü 50, 2'nin bir katı değildir, bu yüzden geçerli çiftler (P, Q) yoktur.\n\n    Durum 3: count_coprime_pairs(6, 180)\n    Açıklama: Fonksiyon 8 döndürecektir, geçerli çiftler (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6) ve bu sayıların diğer düzenlemeleri için sayımlar olacaktır.\n\n    Not:\n    Fonksiyonun doğru çalışabilmesi için, giriş y0, x0'ın bir katı olmalıdır. Aksi takdirde, fonksiyon 0 döndürür,\n    bu da verilen kısıtlar altında geçerli çiftlerin olmadığını gösterir.\n    \"\"\"", "vi": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Đếm số cặp số nguyên dương (P, Q) sao cho P và Q có x0 là ước chung lớn nhất (GCD)\n    và y0 là bội chung nhỏ nhất (LCM).\n\n    Tham số:\n    x0 (int): GCD mà mỗi cặp (P, Q) phải có.\n    y0 (int): LCM mà mỗi cặp (P, Q) phải có.\n\n    Trả về:\n    int: Số lượng tất cả các cặp (P, Q) có thể đáp ứng tiêu chí đã chỉ định.\n\n    Hàm duyệt qua tất cả các ước số có thể 'a' của thương 'y0 / x0'. Đối với mỗi ước số 'a',\n    nó tính toán ước số tương ứng 'b' sao cho 'a * b = y0 / x0'. Sau đó, nó kiểm tra xem 'a' và 'b'\n    có phải là các số nguyên tố cùng nhau (GCD của chúng là 1) vì P và Q chỉ có thể là bội số của 'x0' \n    bởi các ước số nguyên tố cùng nhau để duy trì GCD là 'x0'. Nếu 'a' và 'b' là các số nguyên tố cùng nhau, \n    số đếm được tăng thêm 1 nếu 'a' giống 'b', nếu không thì tăng thêm 2 để tính cả cặp (P, Q) và (Q, P).\n\n    Ví dụ:\n\n    Trường hợp 1: count_coprime_pairs(3, 60)\n    Giải thích: Hàm sẽ trả về 4, vì các cặp hợp lệ là (3, 60), (15, 12), (12, 15), và (60, 3).\n\n    Trường hợp 2: count_coprime_pairs(2, 50)\n    Giải thích: Hàm sẽ trả về 0, vì 50 không phải là bội số của 2, nên không có cặp hợp lệ (P, Q).\n\n    Trường hợp 3: count_coprime_pairs(6, 180)\n    Giải thích: Hàm sẽ trả về 8, các cặp hợp lệ là (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), và số đếm cho các sắp xếp khác của các số này.\n\n    Lưu ý:\n    Để hàm hoạt động chính xác, đầu vào y0 phải là bội số của x0. Nếu không, hàm trả về 0,\n    chỉ ra rằng không có cặp hợp lệ nào tồn tại dưới các điều kiện đã cho.\n    \"\"\"", "id": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Menghitung jumlah pasangan bilangan bulat positif (P, Q) sedemikian rupa sehingga P dan Q memiliki x0 sebagai pembagi\n    terbesar bersama (GCD) dan y0 sebagai kelipatan terkecil bersama (LCM).\n\n    Argumen:\n    x0 (int): GCD yang harus dimiliki setiap pasangan (P, Q).\n    y0 (int): LCM yang harus dimiliki setiap pasangan (P, Q).\n\n    Mengembalikan:\n    int: Jumlah semua pasangan (P, Q) yang memenuhi kriteria yang ditentukan.\n\n    Fungsi ini mengiterasi melalui semua faktor 'a' yang mungkin dari hasil bagi 'y0 / x0'. Untuk setiap faktor 'a',\n    ia menghitung faktor 'b' yang sesuai sehingga 'a * b = y0 / x0'. Kemudian memeriksa apakah 'a' dan 'b'\n    adalah bilangan saling prima (GCD mereka adalah 1) karena P dan Q hanya dapat menjadi kelipatan dari 'x0' dengan\n    faktor saling prima untuk mempertahankan GCD sebagai 'x0'. Jika 'a' dan 'b' adalah saling prima, jumlahnya\n    ditambah 1 jika 'a' sama dengan 'b', jika tidak ditambah 2 untuk memperhitungkan pasangan (P, Q) dan (Q, P).\n\n    Contoh Kasus:\n\n    Kasus 1: count_coprime_pairs(3, 60)\n    Penjelasan: Fungsi akan mengembalikan 4, karena pasangan yang valid adalah (3, 60), (15, 12), (12, 15), dan (60, 3).\n\n    Kasus 2: count_coprime_pairs(2, 50)\n    Penjelasan: Fungsi akan mengembalikan 0, karena 50 bukan kelipatan dari 2, sehingga tidak ada pasangan (P, Q) yang valid.\n\n    Kasus 3: count_coprime_pairs(6, 180)\n    Penjelasan: Fungsi akan mengembalikan 8, pasangan yang valid adalah (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), dan hitungan untuk pengaturan lain dari angka-angka ini.\n\n    Catatan:\n    Agar fungsi bekerja dengan benar, input y0 harus merupakan kelipatan dari x0. Jika tidak, fungsi mengembalikan 0,\n    menunjukkan tidak ada pasangan yang valid di bawah batasan yang diberikan.\n    \"\"\"", "ja": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    正の整数のペア (P, Q) の数を数えます。これらのペアは、P と Q が x0 を最大公約数 (GCD) とし、\n    y0 を最小公倍数 (LCM) とするものです。\n\n    引数:\n    x0 (int): 各ペア (P, Q) が持つべき GCD。\n    y0 (int): 各ペア (P, Q) が持つべき LCM。\n\n    戻り値:\n    int: 指定された条件を満たすすべての可能なペア (P, Q) の数。\n\n    関数は商 'y0 / x0' のすべての可能な因子 'a' を反復処理します。各因子 'a' に対して、\n    'a * b = y0 / x0' となる対応する因子 'b' を計算します。そして、'a' と 'b' が互いに素\n    （その GCD が 1）であるかどうかを確認します。P と Q は 'x0' の倍数である必要があり、\n    互いに素の因子によって GCD を 'x0' に保つ必要があります。もし 'a' と 'b' が互いに素であるならば、\n    'a' が 'b' と同じ場合はカウントを 1 増やし、そうでない場合は (P, Q) と (Q, P) の両方のペアを考慮して\n    2 増やします。\n\n    例:\n\n    ケース 1: count_coprime_pairs(3, 60)\n    説明: 関数は 4 を返します。なぜなら、有効なペアは (3, 60), (15, 12), (12, 15), (60, 3) だからです。\n\n    ケース 2: count_coprime_pairs(2, 50)\n    説明: 関数は 0 を返します。なぜなら、50 は 2 の倍数ではないため、有効なペア (P, Q) が存在しないからです。\n\n    ケース 3: count_coprime_pairs(6, 180)\n    説明: 関数は 8 を返します。有効なペアは (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6) であり、これらの数の他の配置のカウントも含まれます。\n\n    注意:\n    関数が正しく動作するためには、入力 y0 は x0 の倍数である必要があります。そうでない場合、関数は 0 を返し、\n    指定された制約の下で有効なペアが存在しないことを示します。\n    \"\"\"", "ko": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    x0을 최대 공약수(GCD)로 하고 y0을 최소 공배수(LCM)로 하는 양의 정수 쌍 (P, Q)의 개수를 셉니다.\n\n    매개변수:\n    x0 (int): 각 쌍 (P, Q)이 가져야 하는 GCD.\n    y0 (int): 각 쌍 (P, Q)이 가져야 하는 LCM.\n\n    반환값:\n    int: 지정된 기준을 충족하는 모든 가능한 쌍 (P, Q)의 개수.\n\n    함수는 'y0 / x0'의 모든 가능한 인수 'a'를 반복합니다. 각 인수 'a'에 대해 'a * b = y0 / x0'를 만족하는\n    대응 인수 'b'를 계산합니다. 그런 다음 'a'와 'b'가 서로소인지(GCD가 1인지) 확인합니다. P와 Q는\n    'x0'의 배수만이 될 수 있으며, 서로소 인수를 통해 GCD를 'x0'로 유지해야 합니다. 만약 'a'와 'b'가\n    서로소라면, 'a'가 'b'와 같으면 개수를 1 증가시키고, 그렇지 않으면 (P, Q)와 (Q, P) 쌍을 모두\n    고려하여 2를 증가시킵니다.\n\n    예제 사례:\n\n    사례 1: count_coprime_pairs(3, 60)\n    설명: 함수는 4를 반환합니다. 유효한 쌍은 (3, 60), (15, 12), (12, 15), (60, 3)입니다.\n\n    사례 2: count_coprime_pairs(2, 50)\n    설명: 함수는 0을 반환합니다. 50은 2의 배수가 아니므로 유효한 쌍 (P, Q)이 없습니다.\n\n    사례 3: count_coprime_pairs(6, 180)\n    설명: 함수는 8을 반환합니다. 유효한 쌍은 (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6)이며, 이 숫자들의 다른 배열에 대한 개수도 포함됩니다.\n\n    주의:\n    함수가 올바르게 작동하려면 입력 y0이 x0의 배수여야 합니다. 그렇지 않으면 함수는 0을 반환하여\n    주어진 제약 조건 하에 유효한 쌍이 존재하지 않음을 나타냅니다.\n    \"\"\"", "ml": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    (P, Q) എന്ന ജോടികളിൽ P, Q എന്നിവയ്ക്ക് x0 ആണ് ഏറ്റവും വലിയ പൊതുഹരവും (GCD)\n    y0 ആണ് ഏറ്റവും ചെറിയ പൊതുഗുണിതവും (LCM) ആകുന്ന സാന്നിധ്യങ്ങളുടെ എണ്ണം എണ്ണുന്നു.\n\n    Args:\n    x0 (int): ഓരോ ജോടിക്കും (P, Q) ഉണ്ടായിരിക്കേണ്ട GCD.\n    y0 (int): ഓരോ ജോടിക്കും (P, Q) ഉണ്ടായിരിക്കേണ്ട LCM.\n\n    Returns:\n    int: നിശ്ചിത മാനദണ്ഡങ്ങൾ നിറവേറ്റുന്ന എല്ലാ സാധ്യതയുള്ള ജോടികളുടെ എണ്ണം.\n\n    ഫംഗ്ഷൻ 'y0 / x0' എന്ന ഗുണനഫലത്തിന്റെ എല്ലാ സാധ്യതയുള്ള ഘടകങ്ങളായ 'a' യിലൂടെ ആവർത്തിക്കുന്നു. ഓരോ ഘടകത്തിനും 'a',\n    'a * b = y0 / x0' ആകുന്ന വിധത്തിൽ അനുയോജ്യമായ ഘടകം 'b' കണക്കാക്കുന്നു. 'a'യും 'b'യും പരസ്പരം സഹഭാജ്യങ്ങളാണോ എന്ന് പരിശോധിക്കുന്നു (അവയുടെ GCD 1 ആണ്) കാരണം P, Q എന്നിവ 'x0'ന്റെ സഹഭാജ്യ ഘടകങ്ങളായിരിക്കണം GCD 'x0' ആയി നിലനിർത്താൻ. 'a'യും 'b'യും സഹഭാജ്യങ്ങളാണെങ്കിൽ, 'a' 'b'യുമായി സമാനമാണെങ്കിൽ എണ്ണം 1 ൽ കൂട്ടിച്ചേർക്കുന്നു, അല്ലെങ്കിൽ (P, Q)യും (Q, P) ജോടികൾക്കും 2 ൽ കൂട്ടിച്ചേർക്കുന്നു.\n\n    ഉദാഹരണ കേസുകൾ:\n\n    കേസ് 1: count_coprime_pairs(3, 60)\n    വിശദീകരണം: ഫംഗ്ഷൻ 4 തിരികെ നൽകും, കാരണം സാധുവായ ജോടികൾ (3, 60), (15, 12), (12, 15), (60, 3) എന്നിവയാണ്.\n\n    കേസ് 2: count_coprime_pairs(2, 50)\n    വിശദീകരണം: ഫംഗ്ഷൻ 0 തിരികെ നൽകും, കാരണം 50 2 ന്റെ ഗുണിതകമല്ല, അതിനാൽ സാധുവായ ജോടികൾ (P, Q) ഇല്ല.\n\n    കേസ് 3: count_coprime_pairs(6, 180)\n    വിശദീകരണം: ഫംഗ്ഷൻ 8 തിരികെ നൽകും, സാധുവായ ജോടികൾ (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6) എന്നിവയാണ്, ഈ സംഖ്യകളുടെ മറ്റ് ക്രമീകരണങ്ങൾക്കും എണ്ണങ്ങൾ.\n\n    കുറിപ്പ്:\n    ഫംഗ്ഷൻ ശരിയായി പ്രവർത്തിക്കാൻ, ഇൻപുട്ട് y0 x0 ന്റെ ഗുണിതകമായിരിക്കണം. അല്ലെങ്കിൽ, ഫംഗ്ഷൻ 0 തിരികെ നൽകും,\n    നൽകിയിരിക്കുന്ന നിയന്ത്രണങ്ങൾ പ്രകാരം സാധുവായ ജോടികൾ ഇല്ലെന്ന് സൂചിപ്പിക്കുന്നു.\n    \"\"\"", "fa": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    تعداد زوج‌های اعداد صحیح مثبت (P, Q) را می‌شمارد به طوری که P و Q دارای x0 به عنوان بزرگترین مقسوم علیه مشترک (GCD) \n    و y0 به عنوان کوچکترین مضرب مشترک (LCM) باشند.\n\n    آرگومان‌ها:\n    x0 (int): GCD که هر زوج (P, Q) باید داشته باشد.\n    y0 (int): LCM که هر زوج (P, Q) باید داشته باشد.\n\n    بازگشت:\n    int: تعداد تمام زوج‌های ممکن (P, Q) که معیارهای مشخص شده را برآورده می‌کنند.\n\n    این تابع از طریق تمام عوامل ممکن 'a' از خارج قسمت 'y0 / x0' تکرار می‌کند. برای هر عامل 'a',\n    عامل مربوطه 'b' را محاسبه می‌کند به طوری که 'a * b = y0 / x0'. سپس بررسی می‌کند که آیا 'a' و 'b'\n    نسبت به هم اول هستند (GCD آن‌ها 1 است) زیرا P و Q فقط می‌توانند مضرب‌های 'x0' توسط عوامل نسبت به هم اول باشند تا\n    GCD به عنوان 'x0' باقی بماند. اگر 'a' و 'b' نسبت به هم اول باشند، تعداد به 1 افزایش می‌یابد اگر 'a' همان 'b' باشد،\n    در غیر این صورت به 2 افزایش می‌یابد تا برای هر دو زوج (P, Q) و (Q, P) حساب شود.\n\n    مثال‌ها:\n\n    مورد 1: count_coprime_pairs(3, 60)\n    توضیح: تابع 4 را برمی‌گرداند، زیرا زوج‌های معتبر (3, 60)، (15, 12)، (12, 15)، و (60, 3) هستند.\n\n    مورد 2: count_coprime_pairs(2, 50)\n    توضیح: تابع 0 را برمی‌گرداند، زیرا 50 مضربی از 2 نیست، بنابراین هیچ زوج معتبری (P, Q) وجود ندارد.\n\n    مورد 3: count_coprime_pairs(6, 180)\n    توضیح: تابع 8 را برمی‌گرداند، زوج‌های معتبر (6, 180)، (30, 36)، (18, 60)، (42, 30)،\n    (60, 18)، (36, 30)، (180, 6) و تعداد برای سایر چیدمان‌های این اعداد هستند.\n\n    توجه:\n    برای اینکه تابع به درستی کار کند، ورودی y0 باید مضربی از x0 باشد. در غیر این صورت، تابع 0 را برمی‌گرداند،\n    که نشان می‌دهد هیچ زوج معتبری تحت محدودیت‌های داده شده وجود ندارد.\n    \"\"\""}, "canonical_solution": "    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count", "instruction": {"en": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\n请用不超过500个字符的中文，为以下Python代码提供简明的自然语言描述（文档字符串）。", "fr": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nBada takaitaccen bayanin docstring na lambar Python a cikin harshen Hausa ba tare da wucewa haruffa 500 ba.", "hi": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyar nyelven, legfeljebb 500 karakterben.", "es": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nPython kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.", "vi": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\n다음 Python 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടാതെയുള്ള സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_count_coprime_pairs():\n    test_cases = [\n        (3, 60, 4),   # The example from the problem statement\n        (2, 50, 2), \n        (6, 180, 8),  # 180/6 = 30, factors are (1, 30), (2, 15), (3, 10), (5, 6), (6, 5), (10, 3), (15, 2), (30, 1)\n    ]\n\n    for i, (x0, y0, expected) in enumerate(test_cases):\n        result = count_coprime_pairs(x0, y0)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: x0 = {x0}, y0 = {y0}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_coprime_pairs()", "entry_point": "count_coprime_pairs", "signature": "def count_coprime_pairs(x0: int, y0: int) -> int:", "docstring": {"en": "Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\nand y0 as their least common multiple (LCM).\n\nArgs:\nx0 (int): The GCD that each pair (P, Q) must have.\ny0 (int): The LCM that each pair (P, Q) must have.\n\nReturns:\nint: The count of all possible pairs (P, Q) that meet the specified criteria.\n\nThe function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\nit calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\nare co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\nthe GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\nelse by 2 to account for both (P, Q) and (Q, P) pairs.\n\nExample Cases:\n\nCase 1: count_coprime_pairs(3, 60)\nExplanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\nCase 2: count_coprime_pairs(2, 50)\nExplanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\nCase 3: count_coprime_pairs(6, 180)\nExplanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\nNote:\nFor the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0,\nindicating no valid pairs exist under the given constraints.", "sq": "Numëron numrin e çifteve të numrave të plotë pozitivë (P, Q) të tillë që P dhe Q kanë x0 si përbashkësin më të madh (GCD)\ndhe y0 si shumëfishin më të vogël të përbashkët (LCM).\n\nArgs:\nx0 (int): GCD që çdo çift (P, Q) duhet të ketë.\ny0 (int): LCM që çdo çift (P, Q) duhet të ketë.\n\nReturns:\nint: Numri i të gjitha çifteve të mundshme (P, Q) që plotësojnë kriteret e specifikuara.\n\nFunksioni iteron nëpër të gjithë faktorët e mundshëm 'a' të kuotientit 'y0 / x0'. Për çdo faktor 'a',\nai llogarit faktorin përkatës 'b' të tillë që 'a * b = y0 / x0'. Më pas kontrollon nëse 'a' dhe 'b'\njanë të bashkëkryqëzuar (GCD i tyre është 1) sepse P dhe Q mund të jenë vetëm shumëfishë të 'x0' nga faktorë të bashkëkryqëzuar për të ruajtur\nGCD si 'x0'. Nëse 'a' dhe 'b' janë të bashkëkryqëzuar, numërimi rritet me 1 nëse 'a' është i njëjtë me 'b',\npërndryshe me 2 për të llogaritur të dyja çiftet (P, Q) dhe (Q, P).\n\nRaste Shembuj:\n\nRasti 1: count_coprime_pairs(3, 60)\nShpjegim: Funksioni do të kthejë 4, pasi çiftet e vlefshme janë (3, 60), (15, 12), (12, 15), dhe (60, 3).\n\nRasti 2: count_coprime_pairs(2, 50)\nShpjegim: Funksioni do të kthejë 0, pasi 50 nuk është një shumëfish i 2, kështu që nuk ka çifte të vlefshme (P, Q).\n\nRasti 3: count_coprime_pairs(6, 180)\nShpjegim: Funksioni do të kthejë 8, çiftet e vlefshme janë (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), dhe numërimet për rregullimet e tjera të këtyre numrave.\n\nShënim:\nQë funksioni të funksionojë saktë, hyrja y0 duhet të jetë një shumëfish i x0. Nëse jo, funksioni kthen 0,\nduke treguar se nuk ka çifte të vlefshme nën kufizimet e dhëna.", "hy": "Հաշվում է դրական ամբողջ թվերի զույգերի (P, Q) քանակը, այնպես որ P և Q թվերի ամենամեծ ընդհանուր բաժանարարը (GCD) լինի x0,\nիսկ ամենափոքր ընդհանուր բազմապատիկը (LCM) լինի y0։\n\nԱրգումենտներ:\nx0 (int): GCD, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q)։\ny0 (int): LCM, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q)։\n\nՎերադարձնում է:\nint: Բոլոր հնարավոր զույգերի (P, Q) քանակը, որոնք համապատասխանում են նշված չափանիշներին։\n\nՖունկցիան անցնում է 'y0 / x0' բաժանորդի բոլոր հնարավոր գործոնների 'a' միջով։ Յուրաքանչյուր գործոնի 'a' համար\nհաշվում է համապատասխան գործոնը 'b', այնպես որ 'a * b = y0 / x0'։ Այնուհետև ստուգվում է՝ արդյոք 'a' և 'b'\nփոխադարձաբար պարզ են (նրանց GCD-ն 1 է), քանի որ P և Q կարող են միայն լինել 'x0'-ի բազմապատիկներ՝ փոխադարձաբար պարզ գործոններով՝\nպահպանելու համար GCD-ն որպես 'x0'։ Եթե 'a' և 'b' փոխադարձաբար պարզ են, հաշվումը ավելանում է 1-ով, եթե 'a' նույնն է 'b'-ի հետ,\nհակառակ դեպքում՝ 2-ով՝ հաշվի առնելով ինչպես (P, Q), այնպես էլ (Q, P) զույգերը։\n\nՕրինակային դեպքեր:\n\nԴեպք 1: count_coprime_pairs(3, 60)\nԲացատրություն: Ֆունկցիան կվերադարձնի 4, քանի որ վավեր զույգերն են (3, 60), (15, 12), (12, 15) և (60, 3)։\n\nԴեպք 2: count_coprime_pairs(2, 50)\nԲացատրություն: Ֆունկցիան կվերադարձնի 0, քանի որ 50-ը 2-ի բազմապատիկ չէ, ուստի վավեր զույգեր (P, Q) չկան։\n\nԴեպք 3: count_coprime_pairs(6, 180)\nԲացատրություն: Ֆունկցիան կվերադարձնի 8, վավեր զույգերն են (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), և այս թվերի այլ դասավորությունների հաշիվները։\n\nՆշում:\nՖունկցիան ճիշտ աշխատելու համար, մուտքային y0-ն պետք է լինի x0-ի բազմապատիկ։ Եթե ոչ, ֆունկցիան վերադարձնում է 0,\nնշելով, որ վավեր զույգեր չկան տրված սահմանափակումների ներքո։", "bn": "কতগুলি যুগল ধনাত্মক পূর্ণসংখ্যা (P, Q) আছে তা গণনা করে যেখানে P এবং Q এর x0 তাদের গরিষ্ঠ সাধারণ বিভাজক (GCD)\nএবং y0 তাদের লঘিষ্ঠ সাধারণ গুণিতক (LCM)।\n\nArgs:\nx0 (int): প্রতিটি জোড়া (P, Q) এর GCD যা থাকতে হবে।\ny0 (int): প্রতিটি জোড়া (P, Q) এর LCM যা থাকতে হবে।\n\nReturns:\nint: সমস্ত সম্ভাব্য জোড়া (P, Q) এর সংখ্যা যা নির্দিষ্ট মানদণ্ড পূরণ করে।\n\nফাংশনটি 'y0 / x0' এর ভাগফল এর সমস্ত সম্ভাব্য গুণক 'a' এর মধ্য দিয়ে পুনরাবৃত্তি করে। প্রতিটি গুণকের জন্য 'a', এটি সংশ্লিষ্ট গুণক 'b' গণনা করে যাতে 'a * b = y0 / x0' হয়। তারপর এটি পরীক্ষা করে যে 'a' এবং 'b' পরস্পর সহমর্মী কিনা (তাদের GCD হল 1) কারণ P এবং Q শুধুমাত্র 'x0' এর গুণিতক হতে পারে সহমর্মী গুণক দ্বারা GCD 'x0' বজায় রাখতে। যদি 'a' এবং 'b' পরস্পর সহমর্মী হয়, তাহলে গণনা 1 দ্বারা বৃদ্ধি পায় যদি 'a' এবং 'b' একই হয়, অন্যথায় 2 দ্বারা বৃদ্ধি পায় উভয় (P, Q) এবং (Q, P) জোড়ার জন্য।\n\nExample Cases:\n\nCase 1: count_coprime_pairs(3, 60)\nExplanation: ফাংশনটি 4 ফেরত দেবে, কারণ বৈধ জোড়াগুলি হল (3, 60), (15, 12), (12, 15), এবং (60, 3)।\n\nCase 2: count_coprime_pairs(2, 50)\nExplanation: ফাংশনটি 0 ফেরত দেবে, কারণ 50 হল 2 এর গুণিতক নয়, তাই কোন বৈধ জোড়া (P, Q) নেই।\n\nCase 3: count_coprime_pairs(6, 180)\nExplanation: ফাংশনটি 8 ফেরত দেবে, বৈধ জোড়াগুলি হল (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6), এবং এই সংখ্যাগুলির অন্যান্য বিন্যাসের গণনা।\n\nNote:\nফাংশনটি সঠিকভাবে কাজ করার জন্য, ইনপুট y0 অবশ্যই x0 এর গুণিতক হতে হবে। যদি না হয়, ফাংশনটি 0 ফেরত দেয়, যা নির্দেশ করে যে প্রদত্ত সীমাবদ্ধতার অধীনে কোন বৈধ জোড়া নেই।", "bg": "Брои броя на двойките положителни цели числа (P, Q), такива че P и Q имат x0 като техен най-голям общ делител (НОД)\nи y0 като тяхно най-малко общо кратно (НОК).\n\nАргументи:\nx0 (int): НОД, който всяка двойка (P, Q) трябва да има.\ny0 (int): НОК, който всяка двойка (P, Q) трябва да има.\n\nВръща:\nint: Броят на всички възможни двойки (P, Q), които отговарят на зададените критерии.\n\nФункцията преминава през всички възможни делители 'a' на частното 'y0 / x0'. За всеки делител 'a',\nтя изчислява съответния делител 'b', така че 'a * b = y0 / x0'. След това проверява дали 'a' и 'b'\nса взаимно прости (техният НОД е 1), защото P и Q могат да бъдат само кратни на 'x0' чрез взаимно прости фактори, за да се запази\nНОД като 'x0'. Ако 'a' и 'b' са взаимно прости, броят се увеличава с 1, ако 'a' е същото като 'b',\nиначе с 2, за да се отчетат и двете двойки (P, Q) и (Q, P).\n\nПримерни случаи:\n\nСлучай 1: count_coprime_pairs(3, 60)\nОбяснение: Функцията ще върне 4, тъй като валидните двойки са (3, 60), (15, 12), (12, 15) и (60, 3).\n\nСлучай 2: count_coprime_pairs(2, 50)\nОбяснение: Функцията ще върне 0, тъй като 50 не е кратно на 2, така че няма валидни двойки (P, Q).\n\nСлучай 3: count_coprime_pairs(6, 180)\nОбяснение: Функцията ще върне 8, валидните двойки са (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), и броят за други подреждания на тези числа.\n\nЗабележка:\nЗа да работи функцията правилно, входът y0 трябва да бъде кратно на x0. Ако не е, функцията връща 0,\nкоето означава, че няма валидни двойки при дадените ограничения.", "zh": "计算正整数对 (P, Q) 的数量，使得 P 和 Q 的最大公约数 (GCD) 为 x0，最小公倍数 (LCM) 为 y0。\n\n参数：\nx0 (int): 每对 (P, Q) 必须具有的最大公约数。\ny0 (int): 每对 (P, Q) 必须具有的最小公倍数。\n\n返回：\nint: 满足指定条件的所有可能对 (P, Q) 的数量。\n\n该函数遍历商 'y0 / x0' 的所有可能因子 'a'。对于每个因子 'a'，计算相应的因子 'b'，使得 'a * b = y0 / x0'。然后检查 'a' 和 'b' 是否互质（它们的 GCD 为 1），因为 P 和 Q 只能是 'x0' 的倍数，通过互质因子来保持 GCD 为 'x0'。如果 'a' 和 'b' 互质，计数器增加 1 如果 'a' 和 'b' 相同，否则增加 2 以计入 (P, Q) 和 (Q, P) 对。\n\n示例案例：\n\n案例 1: count_coprime_pairs(3, 60)\n解释：函数将返回 4，因为有效的对是 (3, 60), (15, 12), (12, 15), 和 (60, 3)。\n\n案例 2: count_coprime_pairs(2, 50)\n解释：函数将返回 0，因为 50 不是 2 的倍数，因此没有有效的对 (P, Q)。\n\n案例 3: count_coprime_pairs(6, 180)\n解释：函数将返回 8，有效的对是 (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6)，以及这些数字的其他排列的计数。\n\n注意：\n为了函数正确工作，输入 y0 必须是 x0 的倍数。如果不是，函数返回 0，表示在给定约束条件下不存在有效对。", "fr": "Compte le nombre de paires d'entiers positifs (P, Q) tels que P et Q ont x0 comme leur plus grand commun diviseur (PGCD)\net y0 comme leur plus petit commun multiple (PPCM).\n\nArgs:\nx0 (int): Le PGCD que chaque paire (P, Q) doit avoir.\ny0 (int): Le PPCM que chaque paire (P, Q) doit avoir.\n\nReturns:\nint: Le nombre de toutes les paires possibles (P, Q) qui répondent aux critères spécifiés.\n\nLa fonction parcourt tous les facteurs possibles 'a' du quotient 'y0 / x0'. Pour chaque facteur 'a',\nelle calcule le facteur correspondant 'b' tel que 'a * b = y0 / x0'. Elle vérifie ensuite si 'a' et 'b'\nsont copremiers (leur PGCD est 1) car P et Q ne peuvent être que des multiples de 'x0' par des facteurs copremiers pour maintenir\nle PGCD comme 'x0'. Si 'a' et 'b' sont copremiers, le compteur est incrémenté de 1 si 'a' est le même que 'b',\nsinon de 2 pour tenir compte à la fois des paires (P, Q) et (Q, P).\n\nExemples de cas :\n\nCas 1: count_coprime_pairs(3, 60)\nExplication : La fonction renverrait 4, puisque les paires valides sont (3, 60), (15, 12), (12, 15) et (60, 3).\n\nCas 2: count_coprime_pairs(2, 50)\nExplication : La fonction renverrait 0, car 50 n'est pas un multiple de 2, donc il n'y a pas de paires valides (P, Q).\n\nCas 3: count_coprime_pairs(6, 180)\nExplication : La fonction renverrait 8, les paires valides sont (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), et les comptes pour d'autres arrangements de ces nombres.\n\nNote :\nPour que la fonction fonctionne correctement, l'entrée y0 doit être un multiple de x0. Sinon, la fonction renvoie 0,\nindiquant qu'aucune paire valide n'existe sous les contraintes données.", "de": "Zählt die Anzahl der Paare positiver ganzer Zahlen (P, Q), so dass P und Q x0 als ihren größten gemeinsamen Teiler (GCD) und y0 als ihr kleinstes gemeinsames Vielfaches (LCM) haben.\n\nArgs:\nx0 (int): Der GCD, den jedes Paar (P, Q) haben muss.\ny0 (int): Der LCM, den jedes Paar (P, Q) haben muss.\n\nReturns:\nint: Die Anzahl aller möglichen Paare (P, Q), die die angegebenen Kriterien erfüllen.\n\nDie Funktion iteriert über alle möglichen Faktoren 'a' des Quotienten 'y0 / x0'. Für jeden Faktor 'a' berechnet sie den entsprechenden Faktor 'b', so dass 'a * b = y0 / x0'. Sie überprüft dann, ob 'a' und 'b' teilerfremd sind (ihr GCD ist 1), da P und Q nur Vielfache von 'x0' durch teilerfremde Faktoren sein können, um den GCD als 'x0' beizubehalten. Wenn 'a' und 'b' teilerfremd sind, wird der Zähler um 1 erhöht, wenn 'a' gleich 'b' ist, andernfalls um 2, um sowohl die Paare (P, Q) als auch (Q, P) zu berücksichtigen.\n\nBeispiel Fälle:\n\nFall 1: count_coprime_pairs(3, 60)\nErklärung: Die Funktion würde 4 zurückgeben, da die gültigen Paare (3, 60), (15, 12), (12, 15) und (60, 3) sind.\n\nFall 2: count_coprime_pairs(2, 50)\nErklärung: Die Funktion würde 0 zurückgeben, da 50 kein Vielfaches von 2 ist, also gibt es keine gültigen Paare (P, Q).\n\nFall 3: count_coprime_pairs(6, 180)\nErklärung: Die Funktion würde 8 zurückgeben, die gültigen Paare sind (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6) und die Zählungen für andere Anordnungen dieser Zahlen.\n\nHinweis:\nDamit die Funktion korrekt funktioniert, muss die Eingabe y0 ein Vielfaches von x0 sein. Wenn nicht, gibt die Funktion 0 zurück, was anzeigt, dass unter den gegebenen Bedingungen keine gültigen Paare existieren.", "ha": "Yana ƙididdige yawan ma'aurata na lambobi masu kyau (P, Q) ta yadda P da Q suna da x0 a matsayin mafi girman abin da za a iya raba su (GCD)\nkuma y0 a matsayin mafi ƙarancin abin da za su iya raba su (LCM).\n\nArgs:\nx0 (int): GCD da kowanne ma'aurata (P, Q) dole su kasance da shi.\ny0 (int): LCM da kowanne ma'aurata (P, Q) dole su kasance da shi.\n\nReturns:\nint: Adadin dukkan ma'aurata masu yiwuwa (P, Q) da suka cika ka'idodin da aka bayyana.\n\nAikin yana zagayawa ta dukkan yiwuwar abubuwan da 'a' na rabo 'y0 / x0'. Ga kowane abu 'a', yana lissafin abu mai dacewa 'b' wanda 'a * b = y0 / x0'. Sannan yana duba idan 'a' da 'b' suna da alaƙa (GCD ɗinsu shine 1) saboda P da Q na iya zama sau biyu na 'x0' ta hanyar abubuwan da suke da alaƙa don kiyaye GCD a matsayin 'x0'. Idan 'a' da 'b' suna da alaƙa, ana ƙara ƙidaya da 1 idan 'a' daidai yake da 'b', in ba haka ba da 2 don lissafin duka ma'aurata (P, Q) da (Q, P).\n\nExample Cases:\n\nCase 1: count_coprime_pairs(3, 60) \nExplanation: Aikin zai dawo da 4, saboda ma'aurata masu inganci sune (3, 60), (15, 12), (12, 15), da (60, 3).\n\nCase 2: count_coprime_pairs(2, 50) \nExplanation: Aikin zai dawo da 0, saboda 50 ba sau biyu na 2 bane, don haka babu ma'aurata masu inganci (P, Q).\n\nCase 3: count_coprime_pairs(6, 180) \nExplanation: Aikin zai dawo da 8, ma'aurata masu inganci sune (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6), da ƙidaya don sauran shirye-shiryen waɗannan lambobin.\n\nNote:\nDon aikin ya yi aiki daidai, shigar y0 dole ne ya zama sau biyu na x0. Idan ba haka ba, aikin yana dawowa da 0, yana nuna babu ma'aurata masu inganci da ke akwai ƙarƙashin ƙuntatawar da aka bayar.", "hi": "सकारात्मक पूर्णांकों के युग्मों (P, Q) की संख्या गिनता है ताकि P और Q का x0 उनके महत्तम समापवर्तक (GCD) के रूप में हो\nऔर y0 उनके लघुत्तम समापवर्त्य (LCM) के रूप में हो।\n\nआर्ग्स:\nx0 (int): वह GCD जो प्रत्येक युग्म (P, Q) का होना चाहिए।\ny0 (int): वह LCM जो प्रत्येक युग्म (P, Q) का होना चाहिए।\n\nवापसी:\nint: सभी संभावित युग्मों (P, Q) की गणना जो निर्दिष्ट मानदंडों को पूरा करते हैं।\n\nयह फ़ंक्शन 'y0 / x0' के भाजक 'a' के सभी संभावित कारकों के माध्यम से पुनरावृत्ति करता है। प्रत्येक कारक 'a' के लिए,\nयह संबंधित कारक 'b' की गणना करता है ताकि 'a * b = y0 / x0' हो। फिर यह जांचता है कि 'a' और 'b'\nपरस्पर अभाज्य हैं (उनका GCD 1 है) क्योंकि P और Q केवल 'x0' के गुणज हो सकते हैं परस्पर अभाज्य कारकों द्वारा ताकि\nGCD 'x0' बना रहे। यदि 'a' और 'b' परस्पर अभाज्य हैं, तो गणना को 1 से बढ़ाया जाता है यदि 'a' 'b' के समान है,\nअन्यथा 2 से बढ़ाया जाता है ताकि (P, Q) और (Q, P) दोनों युग्मों के लिए खाता हो।\n\nउदाहरण मामले:\n\nमामला 1: count_coprime_pairs(3, 60)\nव्याख्या: फ़ंक्शन 4 लौटाएगा, क्योंकि मान्य युग्म हैं (3, 60), (15, 12), (12, 15), और (60, 3)।\n\nमामला 2: count_coprime_pairs(2, 50)\nव्याख्या: फ़ंक्शन 0 लौटाएगा, क्योंकि 50, 2 का गुणज नहीं है, इसलिए कोई मान्य युग्म (P, Q) नहीं हैं।\n\nमामला 3: count_coprime_pairs(6, 180)\nव्याख्या: फ़ंक्शन 8 लौटाएगा, मान्य युग्म हैं (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), और इन संख्याओं के अन्य व्यवस्थाओं की गणना।\n\nनोट:\nफ़ंक्शन के सही ढंग से काम करने के लिए, इनपुट y0 का x0 का गुणज होना आवश्यक है। यदि नहीं, तो फ़ंक्शन 0 लौटाता है,\nयह दर्शाता है कि दिए गए प्रतिबंधों के तहत कोई मान्य युग्म मौजूद नहीं हैं।", "hu": "Számolja meg a pozitív egész számok (P, Q) párosainak számát úgy, hogy P és Q legnagyobb közös osztója (GCD) x0, és legkisebb közös többszöröse (LCM) y0.\n\nArgs:\nx0 (int): A GCD, amelyet minden (P, Q) párnak tartalmaznia kell.\ny0 (int): Az LCM, amelyet minden (P, Q) párnak tartalmaznia kell.\n\nReturns:\nint: Az összes lehetséges (P, Q) pár száma, amely megfelel a megadott feltételeknek.\n\nA függvény végigmegy az összes lehetséges 'a' tényezőn a 'y0 / x0' hányadosban. Minden 'a' tényezőhöz kiszámítja a megfelelő 'b' tényezőt úgy, hogy 'a * b = y0 / x0'. Ezután ellenőrzi, hogy 'a' és 'b' relatív prímek-e (GCD-jük 1), mert P és Q csak akkor lehetnek 'x0' többszörösei relatív prím tényezők által, hogy a GCD 'x0' maradjon. Ha 'a' és 'b' relatív prímek, a számlálót 1-gyel növeli, ha 'a' megegyezik 'b'-vel, különben 2-vel, hogy figyelembe vegye mind a (P, Q), mind a (Q, P) párokat.\n\nPélda esetek:\n\nEset 1: count_coprime_pairs(3, 60)\nMagyarázat: A függvény 4-et adna vissza, mivel az érvényes párok: (3, 60), (15, 12), (12, 15) és (60, 3).\n\nEset 2: count_coprime_pairs(2, 50)\nMagyarázat: A függvény 0-t adna vissza, mivel 50 nem többszöröse 2-nek, így nincsenek érvényes (P, Q) párok.\n\nEset 3: count_coprime_pairs(6, 180)\nMagyarázat: A függvény 8-at adna vissza, az érvényes párok: (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6), és a számítások más elrendezései ezekkel a számokkal.\n\nMegjegyzés:\nAhhoz, hogy a függvény helyesen működjön, a bemeneti y0-nak többszöröse kell lennie x0-nak. Ha nem, a függvény 0-t ad vissza, jelezve, hogy a megadott feltételek mellett nincsenek érvényes párok.", "es": "Cuenta el número de pares de enteros positivos (P, Q) tales que P y Q tienen x0 como su máximo común divisor (MCD) y y0 como su mínimo común múltiplo (mcm).\n\nArgumentos:\nx0 (int): El MCD que cada par (P, Q) debe tener.\ny0 (int): El mcm que cada par (P, Q) debe tener.\n\nDevuelve:\nint: La cuenta de todos los pares posibles (P, Q) que cumplen con los criterios especificados.\n\nLa función itera a través de todos los posibles factores 'a' del cociente 'y0 / x0'. Para cada factor 'a', calcula el factor correspondiente 'b' tal que 'a * b = y0 / x0'. Luego verifica si 'a' y 'b' son coprimos (su MCD es 1) porque P y Q solo pueden ser múltiplos de 'x0' por factores coprimos para mantener el MCD como 'x0'. Si 'a' y 'b' son coprimos, la cuenta se incrementa en 1 si 'a' es igual a 'b', de lo contrario en 2 para contar ambos pares (P, Q) y (Q, P).\n\nCasos de Ejemplo:\n\nCaso 1: count_coprime_pairs(3, 60) Explicación: La función devolvería 4, ya que los pares válidos son (3, 60), (15, 12), (12, 15), y (60, 3).\n\nCaso 2: count_coprime_pairs(2, 50) Explicación: La función devolvería 0, ya que 50 no es múltiplo de 2, por lo que no hay pares válidos (P, Q).\n\nCaso 3: count_coprime_pairs(6, 180) Explicación: La función devolvería 8, los pares válidos son (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6), y las cuentas para otras disposiciones de estos números.\n\nNota: Para que la función funcione correctamente, la entrada y0 debe ser un múltiplo de x0. Si no, la función devuelve 0, indicando que no existen pares válidos bajo las restricciones dadas.", "arb": "يحسب عدد أزواج الأعداد الصحيحة الموجبة (P, Q) بحيث يكون P و Q لهما x0 كأكبر قاسم مشترك (GCD) و y0 كأصغر مضاعف مشترك (LCM).\n\nيعيدالحجج:\nx0 (int): القاسم المشترك الأكبر الذي يجب أن يكون لكل زوج (P, Q).\ny0 (int): المضاعف المشترك الأصغر الذي يجب أن يكون لكل زوج (P, Q).\n\nيعيد:\nint: عدد جميع الأزواج الممكنة (P, Q) التي تفي بالمعايير المحددة.\n\nتقوم الدالة بالتكرار عبر جميع العوامل الممكنة 'a' للناتج 'y0 / x0'. لكل عامل 'a'،\nتحسب العامل المقابل 'b' بحيث يكون 'a * b = y0 / x0'. ثم تتحقق مما إذا كان 'a' و 'b'\nمتباينين (القاسم المشترك الأكبر لهما هو 1) لأن P و Q يمكن أن يكونا فقط مضاعفات 'x0' بعوامل متباينة للحفاظ\nعلى القاسم المشترك الأكبر كـ 'x0'. إذا كان 'a' و 'b' متباينين، يتم زيادة العداد بمقدار 1 إذا كان 'a' هو نفسه 'b',\nوإلا بمقدار 2 لحساب كلا الزوجين (P, Q) و (Q, P).\n\nحالات المثال:\n\nالحالة 1: count_coprime_pairs(3, 60)\nالتفسير: ستعيد الدالة 4، حيث أن الأزواج الصالحة هي (3, 60)، (15, 12)، (12, 15)، و (60, 3).\n\nالحالة 2: count_coprime_pairs(2, 50)\nالتفسير: ستعيد الدالة 0، حيث أن 50 ليس مضاعفًا لـ 2، لذلك لا توجد أزواج صالحة (P, Q).\n\nالحالة 3: count_coprime_pairs(6, 180)\nالتفسير: ستعيد الدالة 8، الأزواج الصالحة هي (6, 180)، (30, 36)، (18, 60)، (42, 30)،\n(60, 18)، (36, 30)، (180, 6)، والحسابات لترتيبات أخرى لهذه الأرقام.\n\nملاحظة:\nلكي تعمل الدالة بشكل صحيح، يجب أن يكون المدخل y0 مضاعفًا لـ x0. إذا لم يكن كذلك، فإن الدالة تعيد 0،\nمما يشير إلى عدم وجود أزواج صالحة تحت القيود المعطاة.", "sw": "Hesabu idadi ya jozi za nambari nzima chanya (P, Q) ambapo P na Q wana x0 kama mgawanyiko wao mkubwa zaidi (GCD) na y0 kama kichelezo chao kidogo zaidi (LCM).\n\nHoja:\nx0 (int): GCD ambayo kila jozi (P, Q) lazima iwe nayo.\ny0 (int): LCM ambayo kila jozi (P, Q) lazima iwe nayo.\n\nInarejesha:\nint: Hesabu ya jozi zote zinazowezekana (P, Q) zinazokidhi vigezo vilivyobainishwa.\n\nKazi inarudia kupitia vipengele vyote vinavyowezekana 'a' vya sehemu 'y0 / x0'. Kwa kila kipengele 'a', inahesabu kipengele kinacholingana 'b' kama 'a * b = y0 / x0'. Kisha inakagua kama 'a' na 'b' ni co-prime (GCD yao ni 1) kwa sababu P na Q zinaweza kuwa tu vipande vya 'x0' kwa vipengele vya co-prime ili kudumisha GCD kama 'x0'. Ikiwa 'a' na 'b' ni co-prime, hesabu inaongezwa kwa 1 ikiwa 'a' ni sawa na 'b', vinginevyo kwa 2 ili kuzingatia jozi zote mbili (P, Q) na (Q, P).\n\nMfano wa Kesi:\n\nKesi 1: count_coprime_pairs(3, 60)\nMaelezo: Kazi itarudisha 4, kwa kuwa jozi halali ni (3, 60), (15, 12), (12, 15), na (60, 3).\n\nKesi 2: count_coprime_pairs(2, 50)\nMaelezo: Kazi itarudisha 0, kwa kuwa 50 si kipande cha 2, hivyo hakuna jozi halali (P, Q).\n\nKesi 3: count_coprime_pairs(6, 180)\nMaelezo: Kazi itarudisha 8, jozi halali ni (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6), na hesabu za mipangilio mingine ya nambari hizi.\n\nKumbuka:\nIli kazi ifanye kazi kwa usahihi, ingizo y0 lazima liwe kipande cha x0. Ikiwa sivyo, kazi inarudisha 0, ikionyesha hakuna jozi halali zilizopo chini ya vikwazo vilivyotolewa.", "tr": "Pozitif tam sayı çiftlerinin (P, Q) sayısını sayar, öyle ki P ve Q'nun en büyük ortak böleni (GCD) x0 ve en küçük ortak katı (LCM) y0'dır.\n\nArgümanlar:\nx0 (int): Her çiftin (P, Q) sahip olması gereken GCD.\ny0 (int): Her çiftin (P, Q) sahip olması gereken LCM.\n\nDöndürür:\nint: Belirtilen kriterleri karşılayan tüm olası çiftlerin (P, Q) sayısı.\n\nFonksiyon, 'y0 / x0' bölümünün tüm olası çarpanları 'a' üzerinden iterasyon yapar. Her çarpan 'a' için,\n'a * b = y0 / x0' olacak şekilde karşılık gelen çarpan 'b'yi hesaplar. Daha sonra 'a' ve 'b'nin\nortak asal olup olmadığını (GCD'leri 1 ise) kontrol eder çünkü P ve Q, GCD'yi 'x0' olarak korumak için\nsadece asal çarpanlarla 'x0'ün katları olabilir. Eğer 'a' ve 'b' ortak asal ise, 'a' ve 'b' aynıysa\nsayı 1 artırılır, aksi takdirde hem (P, Q) hem de (Q, P) çiftlerini hesaba katmak için 2 artırılır.\n\nÖrnek Durumlar:\n\nDurum 1: count_coprime_pairs(3, 60)\nAçıklama: Fonksiyon 4 döndürecektir, çünkü geçerli çiftler (3, 60), (15, 12), (12, 15) ve (60, 3)'tür.\n\nDurum 2: count_coprime_pairs(2, 50)\nAçıklama: Fonksiyon 0 döndürecektir, çünkü 50, 2'nin katı değildir, bu yüzden geçerli çiftler (P, Q) yoktur.\n\nDurum 3: count_coprime_pairs(6, 180)\nAçıklama: Fonksiyon 8 döndürecektir, geçerli çiftler (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6) ve bu sayıların diğer düzenlemeleri için sayılar.\n\nNot:\nFonksiyonun doğru çalışabilmesi için, giriş y0, x0'ın bir katı olmalıdır. Aksi takdirde, fonksiyon 0 döndürür,\nbu da verilen kısıtlar altında geçerli çiftlerin olmadığını belirtir.", "vi": "Đếm số cặp số nguyên dương (P, Q) sao cho P và Q có x0 là ước chung lớn nhất (GCD) của chúng\nvà y0 là bội chung nhỏ nhất (LCM) của chúng.\n\nTham số:\nx0 (int): GCD mà mỗi cặp (P, Q) phải có.\ny0 (int): LCM mà mỗi cặp (P, Q) phải có.\n\nTrả về:\nint: Số lượng tất cả các cặp (P, Q) có thể đáp ứng tiêu chí đã chỉ định.\n\nHàm lặp qua tất cả các ước số có thể 'a' của thương số 'y0 / x0'. Đối với mỗi ước số 'a',\nnó tính toán ước số tương ứng 'b' sao cho 'a * b = y0 / x0'. Sau đó, nó kiểm tra nếu 'a' và 'b'\nlà số nguyên tố cùng nhau (GCD của chúng là 1) vì P và Q chỉ có thể là bội số của 'x0' bởi các ước số nguyên tố cùng nhau để duy trì\nGCD là 'x0'. Nếu 'a' và 'b' là số nguyên tố cùng nhau, số đếm được tăng lên 1 nếu 'a' giống như 'b',\nnếu không thì tăng lên 2 để tính cho cả cặp (P, Q) và (Q, P).\n\nVí dụ các trường hợp:\n\nTrường hợp 1: count_coprime_pairs(3, 60)\nGiải thích: Hàm sẽ trả về 4, vì các cặp hợp lệ là (3, 60), (15, 12), (12, 15), và (60, 3).\n\nTrường hợp 2: count_coprime_pairs(2, 50)\nGiải thích: Hàm sẽ trả về 0, vì 50 không phải là bội số của 2, do đó không có cặp hợp lệ (P, Q).\n\nTrường hợp 3: count_coprime_pairs(6, 180)\nGiải thích: Hàm sẽ trả về 8, các cặp hợp lệ là (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), và số đếm cho các sắp xếp khác của các số này.\n\nLưu ý:\nĐể hàm hoạt động chính xác, đầu vào y0 phải là bội số của x0. Nếu không, hàm trả về 0,\ncho biết không có cặp hợp lệ nào tồn tại dưới các ràng buộc đã cho.", "id": "Menghitung jumlah pasangan bilangan bulat positif (P, Q) sedemikian sehingga P dan Q memiliki x0 sebagai pembagi terbesar (GCD) dan y0 sebagai kelipatan terkecil (LCM).\n\nArgs:\nx0 (int): GCD yang harus dimiliki setiap pasangan (P, Q).\ny0 (int): LCM yang harus dimiliki setiap pasangan (P, Q).\n\nReturns:\nint: Jumlah semua pasangan (P, Q) yang memenuhi kriteria yang ditentukan.\n\nFungsi ini mengiterasi melalui semua faktor yang mungkin 'a' dari hasil bagi 'y0 / x0'. Untuk setiap faktor 'a',\ndihitung faktor yang sesuai 'b' sedemikian sehingga 'a * b = y0 / x0'. Kemudian diperiksa apakah 'a' dan 'b'\nadalah bilangan saling prima (GCD mereka adalah 1) karena P dan Q hanya bisa menjadi kelipatan dari 'x0' dengan faktor saling prima untuk mempertahankan GCD sebagai 'x0'. Jika 'a' dan 'b' adalah bilangan saling prima, hitungan ditingkatkan sebesar 1 jika 'a' sama dengan 'b', jika tidak sebesar 2 untuk memperhitungkan pasangan (P, Q) dan (Q, P).\n\nContoh Kasus:\n\nKasus 1: count_coprime_pairs(3, 60)\nPenjelasan: Fungsi akan mengembalikan 4, karena pasangan yang valid adalah (3, 60), (15, 12), (12, 15), dan (60, 3).\n\nKasus 2: count_coprime_pairs(2, 50)\nPenjelasan: Fungsi akan mengembalikan 0, karena 50 bukan kelipatan dari 2, sehingga tidak ada pasangan (P, Q) yang valid.\n\nKasus 3: count_coprime_pairs(6, 180)\nPenjelasan: Fungsi akan mengembalikan 8, pasangan yang valid adalah (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), dan hitungan untuk susunan lain dari angka-angka ini.\n\nCatatan:\nAgar fungsi bekerja dengan benar, input y0 harus merupakan kelipatan dari x0. Jika tidak, fungsi mengembalikan 0,\nmenunjukkan tidak ada pasangan yang valid di bawah batasan yang diberikan.", "ja": "正の整数のペア (P, Q) の数を数えます。このペアは、P と Q が x0 を最大公約数 (GCD) とし、y0 を最小公倍数 (LCM) とするものです。\n\nArgs:\nx0 (int): 各ペア (P, Q) が持つべき GCD。\ny0 (int): 各ペア (P, Q) が持つべき LCM。\n\nReturns:\nint: 指定された条件を満たすすべての可能なペア (P, Q) の数。\n\n関数は、商 'y0 / x0' のすべての可能な因数 'a' を反復処理します。各因数 'a' に対して、\n対応する因数 'b' を計算し、'a * b = y0 / x0' となるようにします。その後、'a' と 'b' が互いに素（その GCD が 1）であるかどうかを確認します。\nP と Q は、GCD を 'x0' に保つために互いに素の因数による 'x0' の倍数でなければならないからです。\nもし 'a' と 'b' が互いに素であれば、'a' が 'b' と同じ場合はカウントを 1 増やし、そうでなければ (P, Q) と (Q, P) の両方のペアを考慮して 2 増やします。\n\n例:\n\nケース 1: count_coprime_pairs(3, 60)\n説明: 関数は 4 を返します。なぜなら、有効なペアは (3, 60), (15, 12), (12, 15), (60, 3) だからです。\n\nケース 2: count_coprime_pairs(2, 50)\n説明: 関数は 0 を返します。なぜなら、50 は 2 の倍数ではないので、有効なペア (P, Q) は存在しないからです。\n\nケース 3: count_coprime_pairs(6, 180)\n説明: 関数は 8 を返します。有効なペアは (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6) であり、これらの数の他の配置のカウントも含まれます。\n\n注意:\n関数が正しく動作するためには、入力 y0 は x0 の倍数でなければなりません。そうでない場合、関数は 0 を返し、与えられた制約の下で有効なペアが存在しないことを示します。", "ko": "양의 정수 쌍 (P, Q)의 개수를 계산합니다. 여기서 P와 Q는 x0을 최대 공약수(GCD)로, y0을 최소 공배수(LCM)로 가집니다.\n\nArgs:\nx0 (int): 각 쌍 (P, Q)이 가져야 하는 GCD.\ny0 (int): 각 쌍 (P, Q)이 가져야 하는 LCM.\n\nReturns:\nint: 지정된 조건을 만족하는 모든 가능한 쌍 (P, Q)의 개수.\n\n함수는 몫 'y0 / x0'의 모든 가능한 인수 'a'를 반복합니다. 각 인수 'a'에 대해,\n'y0 / x0 = a * b'를 만족하는 대응 인수 'b'를 계산합니다. 그런 다음 'a'와 'b'가 서로소인지(즉, 그들의 GCD가 1인지) 확인합니다. 왜냐하면 P와 Q는 GCD를 'x0'로 유지하기 위해 서로소 인수로 'x0'의 배수만 될 수 있기 때문입니다. 만약 'a'와 'b'가 서로소라면, 'a'와 'b'가 동일할 경우 1을, 그렇지 않으면 (P, Q)와 (Q, P) 쌍을 모두 고려하여 2를 더합니다.\n\n예제 사례:\n\n사례 1: count_coprime_pairs(3, 60)\n설명: 함수는 4를 반환합니다. 유효한 쌍은 (3, 60), (15, 12), (12, 15), (60, 3)입니다.\n\n사례 2: count_coprime_pairs(2, 50)\n설명: 함수는 0을 반환합니다. 50은 2의 배수가 아니므로 유효한 쌍 (P, Q)이 없습니다.\n\n사례 3: count_coprime_pairs(6, 180)\n설명: 함수는 8을 반환합니다. 유효한 쌍은 (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6)이며, 이 숫자들의 다른 배열에 대한 개수입니다.\n\nNote:\n함수가 올바르게 작동하려면 입력 y0이 x0의 배수여야 합니다. 그렇지 않으면 함수는 0을 반환하여 주어진 제약 조건 하에 유효한 쌍이 존재하지 않음을 나타냅니다.", "ml": "പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളായ (P, Q) എന്ന ജോഡികളുടെ എണ്ണം എണ്ണുന്നു, അവയ്ക്ക് x0 ഏറ്റവും വലിയ പൊതു ഗുണകമായി (GCD) ഉണ്ട്\nമറ്റും y0 ഏറ്റവും ചെറിയ പൊതു ഗുണിതമായി (LCM) ഉണ്ട്.\n\nArgs:\nx0 (int): ഓരോ ജോഡിക്കും (P, Q) ഉണ്ടായിരിക്കേണ്ട GCD.\ny0 (int): ഓരോ ജോഡിക്കും (P, Q) ഉണ്ടായിരിക്കേണ്ട LCM.\n\nReturns:\nint: നിർദ്ദിഷ്ട മാനദണ്ഡങ്ങൾ പാലിക്കുന്ന എല്ലാ സാധ്യതയുള്ള ജോഡികളുടെ (P, Q) എണ്ണം.\n\nഫംഗ്ഷൻ 'y0 / x0' എന്ന ഗുണിതത്തിന്റെ എല്ലാ സാധ്യതയുള്ള ഘടകങ്ങളായ 'a' യിലൂടെ ആവർത്തിക്കുന്നു. ഓരോ ഘടകത്തിനും 'a' എന്നത്\n'y0 / x0' എന്നതിനു 'a * b = y0 / x0' എന്നതായുള്ള അനുബന്ധ ഘടകം 'b' കണക്കാക്കുന്നു. 'a'യും 'b'യും\nസഹപ്രധാനമാണോ (അവയുടെ GCD 1 ആണോ) എന്ന് പരിശോധിക്കുന്നു, കാരണം P, Q എന്നിവ 'x0'യുടെ GCD നിലനിർത്താൻ സഹപ്രധാന ഘടകങ്ങളാൽ 'x0'യുടെ ഗുണിതങ്ങൾ മാത്രമേ ആയിരിക്കൂ. 'a'യും 'b'യും സഹപ്രധാനമാണെങ്കിൽ, 'a' 'b'യുമായി സമാനമാണെങ്കിൽ 1 ൽ കൂടി, അല്ലെങ്കിൽ (P, Q) കൂടാതെ (Q, P) ജോഡികൾക്കും 2 ൽ കൂടി എണ്ണുന്നു.\n\nഉദാഹരണ കേസുകൾ:\n\nകേസ് 1: count_coprime_pairs(3, 60)\nവിവരണം: ഫംഗ്ഷൻ 4 എന്നതായിരിക്കും മടക്കുക, കാരണം സാധുവായ ജോഡികൾ (3, 60), (15, 12), (12, 15), (60, 3) എന്നിവയാണ്.\n\nകേസ് 2: count_coprime_pairs(2, 50)\nവിവരണം: ഫംഗ്ഷൻ 0 മടക്കും, കാരണം 50, 2ന്റെ ഗുണിതമല്ല, അതിനാൽ സാധുവായ ജോഡികൾ (P, Q) ഇല്ല.\n\nകേസ് 3: count_coprime_pairs(6, 180)\nവിവരണം: ഫംഗ്ഷൻ 8 മടക്കും, സാധുവായ ജോഡികൾ (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), കൂടാതെ ഈ സംഖ്യകളുടെ മറ്റ് ക്രമീകരണങ്ങളുടെ എണ്ണവും.\n\nകുറിപ്പ്:\nഫംഗ്ഷൻ ശരിയായി പ്രവർത്തിക്കാൻ, ഇൻപുട്ട് y0, x0യുടെ ഗുണിതമായിരിക്കണം. അല്ലെങ്കിൽ, ഫംഗ്ഷൻ 0 മടക്കുന്നു,\nനൽകിയിരിക്കുന്ന നിയന്ത്രണങ്ങൾക്കു കീഴിൽ സാധുവായ ജോഡികൾ ഇല്ലെന്ന് സൂചിപ്പിക്കുന്നു.", "fa": "تعداد جفت‌های اعداد صحیح مثبت (P, Q) را می‌شمارد به طوری که P و Q دارای x0 به عنوان بزرگترین مقسوم‌علیه مشترک (GCD) و y0 به عنوان کوچکترین مضرب مشترک (LCM) باشند.\n\nآرگومان‌ها:\nx0 (int): بزرگترین مقسوم‌علیه مشترکی که هر جفت (P, Q) باید داشته باشد.\ny0 (int): کوچکترین مضرب مشترکی که هر جفت (P, Q) باید داشته باشد.\n\nبازگشت:\nint: تعداد تمام جفت‌های ممکن (P, Q) که معیارهای مشخص شده را برآورده می‌کنند.\n\nتابع از طریق تمام عوامل ممکن 'a' از خارج قسمت 'y0 / x0' تکرار می‌شود. برای هر عامل 'a'، عامل متناظر 'b' را محاسبه می‌کند به طوری که 'a * b = y0 / x0'. سپس بررسی می‌کند که آیا 'a' و 'b' نسبت به هم اول هستند (بزرگترین مقسوم‌علیه آن‌ها 1 است) زیرا P و Q فقط می‌توانند مضربی از 'x0' توسط عوامل نسبت به هم اول باشند تا GCD به عنوان 'x0' باقی بماند. اگر 'a' و 'b' نسبت به هم اول باشند، شمارش به اندازه 1 افزایش می‌یابد اگر 'a' با 'b' یکسان باشد، در غیر این صورت به اندازه 2 افزایش می‌یابد تا هم جفت (P, Q) و هم (Q, P) را در نظر بگیرد.\n\nموارد مثال:\n\nمورد 1: count_coprime_pairs(3, 60)\nتوضیح: تابع 4 را برمی‌گرداند، زیرا جفت‌های معتبر (3, 60)، (15, 12)، (12, 15)، و (60, 3) هستند.\n\nمورد 2: count_coprime_pairs(2, 50)\nتوضیح: تابع 0 را برمی‌گرداند، زیرا 50 مضربی از 2 نیست، بنابراین هیچ جفت معتبری (P, Q) وجود ندارد.\n\nمورد 3: count_coprime_pairs(6, 180)\nتوضیح: تابع 8 را برمی‌گرداند، جفت‌های معتبر (6, 180)، (30, 36)، (18, 60)، (42, 30)، (60, 18)، (36, 30)، (180, 6) و شمارش برای ترتیب‌های دیگر این اعداد هستند.\n\nتوجه:\nبرای اینکه تابع به درستی کار کند، ورودی y0 باید مضربی از x0 باشد. در غیر این صورت، تابع 0 را برمی‌گرداند که نشان می‌دهد هیچ جفت معتبری تحت محدودیت‌های داده شده وجود ندارد."}}
{"task_id": "Python/27", "prompt": {"en": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Cases:\n    - If both inorder and postorder traversals are empty, returns an empty string.\n    - If the tree consists of a single node, returns a string with that single node.\n    - For a larger tree, recursively finds the root from the postorder traversal,\n      splits the inorder traversal into left and right subtrees, and constructs\n      the preorder traversal by visiting the root followed by the left and right\n      subtrees.\n\n    Example:\n    - Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\n      will return the preorder traversal 'ABCD'.\n    - Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\n      will return the preorder traversal 'ABDEGCF'.\n    - Given a tree with a single node represented by the inorder and postorder traversal 'A',\n      the function will return 'A'.\n    \"\"\"", "sq": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Rikonstrukton pemën binare nga kalimet e saj inorder dhe postorder dhe\n    kthen kalimin preorder si një varg.\n\n    Args:\n    inorder (str): Kalimi inorder i pemës binare.\n    postorder (str): Kalimi postorder i pemës binare.\n\n    Returns:\n    str: Kalimi preorder i pemës binare.\n\n    Raste:\n    - Nëse të dy kalimet inorder dhe postorder janë bosh, kthen një varg bosh.\n    - Nëse pema përbëhet nga një nyje e vetme, kthen një varg me atë nyje të vetme.\n    - Për një pemë më të madhe, gjen në mënyrë rekursive rrënjën nga kalimi postorder,\n      ndan kalimin inorder në nënpema të majta dhe të djathta, dhe ndërton\n      kalimin preorder duke vizituar rrënjën ndjekur nga nënpema e majtë dhe e djathtë.\n\n    Shembull:\n    - Duke pasur kalimin inorder 'BADC' dhe kalimin postorder 'BDCA', funksioni\n      do të kthejë kalimin preorder 'ABCD'.\n    - Duke pasur kalimin inorder 'DBGEACF' dhe kalimin postorder 'DGEBFCA', funksioni\n      do të kthejë kalimin preorder 'ABDEGCF'.\n    - Duke pasur një pemë me një nyje të vetme të përfaqësuar nga kalimet inorder dhe postorder 'A',\n      funksioni do të kthejë 'A'.\n    \"\"\"", "hy": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Վերակառուցում է բինար ծառը նրա inorder և postorder անցումներից և\n    վերադարձնում է preorder անցումը որպես տող։\n\n    Արգումենտներ:\n    inorder (str): Բինար ծառի inorder անցումը։\n    postorder (str): Բինար ծառի postorder անցումը։\n\n    Վերադարձնում է:\n    str: Բինար ծառի preorder անցումը։\n\n    Դեպքեր:\n    - Եթե թե՛ inorder և թե՛ postorder անցումները դատարկ են, վերադարձնում է դատարկ տող։\n    - Եթե ծառը բաղկացած է մեկ հանգույցից, վերադարձնում է այդ մեկ հանգույցով տող։\n    - Ավելի մեծ ծառի համար, ռեկուրսիվ կերպով գտնում է արմատը postorder անցումից,\n      բաժանում է inorder անցումը ձախ և աջ ենթածառերի, և կառուցում է\n      preorder անցումը այցելելով արմատը, այնուհետև ձախ և աջ ենթածառերը։\n\n    Օրինակ:\n    - Տրված է inorder անցումը 'BADC' և postorder անցումը 'BDCA', ֆունկցիան\n      կվերադարձնի preorder անցումը 'ABCD'։\n    - Տրված է inorder անցումը 'DBGEACF' և postorder անցումը 'DGEBFCA', ֆունկցիան\n      կվերադարձնի preorder անցումը 'ABDEGCF'։\n    - Տրված է մեկ հանգույցով ծառ, որը ներկայացված է inorder և postorder անցումներով 'A',\n      ֆունկցիան կվերադարձնի 'A'։\n    \"\"\"", "bn": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে বাইনারি ট্রি পুনর্গঠন করে এবং\n    প্রিঅর্ডার ট্রাভার্সালকে একটি স্ট্রিং হিসেবে ফেরত দেয়।\n\n    Args:\n    inorder (str): বাইনারি ট্রির ইনঅর্ডার ট্রাভার্সাল।\n    postorder (str): বাইনারি ট্রির পোস্টঅর্ডার ট্রাভার্সাল।\n\n    Returns:\n    str: বাইনারি ট্রির প্রিঅর্ডার ট্রাভার্সাল।\n\n    কেসসমূহ:\n    - যদি ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল উভয়ই খালি হয়, তবে একটি খালি স্ট্রিং ফেরত দেয়।\n    - যদি ট্রি একটি একক নোড নিয়ে গঠিত হয়, তবে সেই একক নোড সহ একটি স্ট্রিং ফেরত দেয়।\n    - একটি বড় ট্রির জন্য, পোস্টঅর্ডার ট্রাভার্সাল থেকে রুট খুঁজে বের করে, ইনঅর্ডার ট্রাভার্সালকে বাম এবং ডান সাবট্রিতে ভাগ করে এবং\n      রুটের পর বাম এবং ডান সাবট্রি ভিজিট করে প্রিঅর্ডার ট্রাভার্সাল তৈরি করে।\n\n    উদাহরণ:\n    - ইনঅর্ডার ট্রাভার্সাল 'BADC' এবং পোস্টঅর্ডার ট্রাভার্সাল 'BDCA' দেওয়া হলে, ফাংশনটি\n      প্রিঅর্ডার ট্রাভার্সাল 'ABCD' ফেরত দেবে।\n    - ইনঅর্ডার ট্রাভার্সাল 'DBGEACF' এবং পোস্টঅর্ডার ট্রাভার্সাল 'DGEBFCA' দেওয়া হলে, ফাংশনটি\n      প্রিঅর্ডার ট্রাভার্সাল 'ABDEGCF' ফেরত দেবে।\n    - একটি একক নোডের ট্রি, যা ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল 'A' দ্বারা প্রতিনিধিত্ব করে,\n      ফাংশনটি 'A' ফেরত দেবে।\n    \"\"\"", "bg": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Възстановява бинарното дърво от неговите inorder и postorder обхождания и\n    връща preorder обхождането като низ.\n\n    Args:\n    inorder (str): Inorder обхождането на бинарното дърво.\n    postorder (str): Postorder обхождането на бинарното дърво.\n\n    Returns:\n    str: Preorder обхождането на бинарното дърво.\n\n    Случаи:\n    - Ако и двете inorder и postorder обхождания са празни, връща празен низ.\n    - Ако дървото се състои от един възел, връща низ с този единствен възел.\n    - За по-голямо дърво, рекурсивно намира корена от postorder обхождането,\n      разделя inorder обхождането на ляво и дясно поддърво и конструира\n      preorder обхождането, като посещава корена, последван от лявото и дясното\n      поддърво.\n\n    Пример:\n    - Дадено inorder обхождане 'BADC' и postorder обхождане 'BDCA', функцията\n      ще върне preorder обхождане 'ABCD'.\n    - Дадено inorder обхождане 'DBGEACF' и postorder обхождане 'DGEBFCA', функцията\n      ще върне preorder обхождане 'ABDEGCF'.\n    - Дадено дърво с един възел, представено от inorder и postorder обхождане 'A',\n      функцията ще върне 'A'.\n    \"\"\"", "zh": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    从中序遍历和后序遍历重建二叉树，并返回前序遍历作为字符串。\n\n    参数:\n    inorder (str): 二叉树的中序遍历。\n    postorder (str): 二叉树的后序遍历。\n\n    返回:\n    str: 二叉树的前序遍历。\n\n    情况:\n    - 如果中序和后序遍历都为空，返回一个空字符串。\n    - 如果树由单个节点组成，返回一个包含该单个节点的字符串。\n    - 对于较大的树，递归地从后序遍历中找到根节点，将中序遍历分成左子树和右子树，\n      并通过访问根节点然后访问左子树和右子树来构建前序遍历。\n\n    示例:\n    - 给定中序遍历 'BADC' 和后序遍历 'BDCA'，函数将返回前序遍历 'ABCD'。\n    - 给定中序遍历 'DBGEACF' 和后序遍历 'DGEBFCA'，函数将返回前序遍历 'ABDEGCF'。\n    - 给定一个由中序和后序遍历 'A' 表示的单节点树，函数将返回 'A'。\n    \"\"\"", "fr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstruit l'arbre binaire à partir de ses parcours inorder et postorder et\n    renvoie le parcours preorder sous forme de chaîne.\n\n    Args:\n    inorder (str): Le parcours inorder de l'arbre binaire.\n    postorder (str): Le parcours postorder de l'arbre binaire.\n\n    Returns:\n    str: Le parcours preorder de l'arbre binaire.\n\n    Cas:\n    - Si les parcours inorder et postorder sont vides, renvoie une chaîne vide.\n    - Si l'arbre consiste en un seul nœud, renvoie une chaîne avec ce seul nœud.\n    - Pour un arbre plus grand, trouve récursivement la racine à partir du parcours postorder,\n      divise le parcours inorder en sous-arbres gauche et droit, et construit\n      le parcours preorder en visitant la racine suivie des sous-arbres gauche et droit.\n\n    Exemple:\n    - Étant donné le parcours inorder 'BADC' et le parcours postorder 'BDCA', la fonction\n      renverra le parcours preorder 'ABCD'.\n    - Étant donné le parcours inorder 'DBGEACF' et le parcours postorder 'DGEBFCA', la fonction\n      renverra le parcours preorder 'ABDEGCF'.\n    - Étant donné un arbre avec un seul nœud représenté par le parcours inorder et postorder 'A',\n      la fonction renverra 'A'.\n    \"\"\"", "de": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Rekonstruiert den binären Baum aus seinen Inorder- und Postorder-Traversierungen und\n    gibt die Preorder-Traversierung als Zeichenkette zurück.\n\n    Argumente:\n    inorder (str): Die Inorder-Traversierung des binären Baums.\n    postorder (str): Die Postorder-Traversierung des binären Baums.\n\n    Rückgabewert:\n    str: Die Preorder-Traversierung des binären Baums.\n\n    Fälle:\n    - Wenn sowohl die Inorder- als auch die Postorder-Traversierungen leer sind, wird eine leere Zeichenkette zurückgegeben.\n    - Wenn der Baum aus einem einzelnen Knoten besteht, wird eine Zeichenkette mit diesem einzelnen Knoten zurückgegeben.\n    - Für einen größeren Baum wird rekursiv die Wurzel aus der Postorder-Traversierung gefunden,\n      die Inorder-Traversierung in linke und rechte Teilbäume aufgeteilt und die Preorder-Traversierung\n      durch Besuch der Wurzel gefolgt von den linken und rechten Teilbäumen konstruiert.\n\n    Beispiel:\n    - Gegeben die Inorder-Traversierung 'BADC' und die Postorder-Traversierung 'BDCA', wird die Funktion\n      die Preorder-Traversierung 'ABCD' zurückgeben.\n    - Gegeben die Inorder-Traversierung 'DBGEACF' und die Postorder-Traversierung 'DGEBFCA', wird die Funktion\n      die Preorder-Traversierung 'ABDEGCF' zurückgeben.\n    - Gegeben ein Baum mit einem einzelnen Knoten, dargestellt durch die Inorder- und Postorder-Traversierung 'A',\n      wird die Funktion 'A' zurückgeben.\n    \"\"\"", "ha": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Sake gina itacen binary daga jerin inorder da postorder kuma\n    ya dawo da jerin preorder a matsayin kirtani.\n\n    Args:\n    inorder (str): Jerin inorder na itacen binary.\n    postorder (str): Jerin postorder na itacen binary.\n\n    Returns:\n    str: Jerin preorder na itacen binary.\n\n    Lokuta:\n    - Idan duka jerin inorder da postorder babu komai, yana dawowa da kirtani mara komai.\n    - Idan itacen ya ƙunshi ƙwaya guda, yana dawowa da kirtani tare da wannan ƙwaya guda.\n    - Don babban itace, yana gano tushen daga jerin postorder,\n      ya raba jerin inorder zuwa rassan hagu da dama, kuma yana gina\n      jerin preorder ta hanyar ziyartar tushen sannan rassan hagu da dama.\n\n    Misali:\n    - An ba da jerin inorder 'BADC' da jerin postorder 'BDCA', aikin\n      zai dawo da jerin preorder 'ABCD'.\n    - An ba da jerin inorder 'DBGEACF' da jerin postorder 'DGEBFCA', aikin\n      zai dawo da jerin preorder 'ABDEGCF'.\n    - An ba da itace tare da ƙwaya guda da aka wakilta ta jerin inorder da postorder 'A',\n      aikin zai dawo da 'A'.\n    \"\"\"", "hi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    बाइनरी वृक्ष को उसके इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से पुनर्निर्मित करता है और\n    प्रीऑर्डर ट्रैवर्सल को एक स्ट्रिंग के रूप में लौटाता है।\n\n    तर्क:\n    inorder (str): बाइनरी वृक्ष का इनऑर्डर ट्रैवर्सल।\n    postorder (str): बाइनरी वृक्ष का पोस्टऑर्डर ट्रैवर्सल।\n\n    रिटर्न्स:\n    str: बाइनरी वृक्ष का प्रीऑर्डर ट्रैवर्सल।\n\n    मामले:\n    - यदि इनऑर्डर और पोस्टऑर्डर दोनों ट्रैवर्सल खाली हैं, तो एक खाली स्ट्रिंग लौटाता है।\n    - यदि वृक्ष एकल नोड से बना है, तो उस एकल नोड के साथ एक स्ट्रिंग लौटाता है।\n    - एक बड़े वृक्ष के लिए, पोस्टऑर्डर ट्रैवर्सल से जड़ को पुनरावृत्तिपूर्वक खोजता है,\n      इनऑर्डर ट्रैवर्सल को बाएं और दाएं उपवृक्षों में विभाजित करता है, और\n      जड़ के बाद बाएं और दाएं उपवृक्षों को विजिट करके प्रीऑर्डर ट्रैवर्सल का निर्माण करता है।\n\n    उदाहरण:\n    - दिए गए इनऑर्डर ट्रैवर्सल 'BADC' और पोस्टऑर्डर ट्रैवर्सल 'BDCA' के लिए, फंक्शन\n      प्रीऑर्डर ट्रैवर्सल 'ABCD' लौटाएगा।\n    - दिए गए इनऑर्डर ट्रैवर्सल 'DBGEACF' और पोस्टऑर्डर ट्रैवर्सल 'DGEBFCA' के लिए, फंक्शन\n      प्रीऑर्डर ट्रैवर्सल 'ABDEGCF' लौटाएगा।\n    - एकल नोड वाले वृक्ष के लिए, जो इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल 'A' द्वारा दर्शाया गया है,\n      फंक्शन 'A' लौटाएगा।\n    \"\"\"", "hu": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Újraépíti a bináris fát az inorder és postorder bejárásokból, és\n    visszaadja a preorder bejárást sztringként.\n\n    Args:\n    inorder (str): A bináris fa inorder bejárása.\n    postorder (str): A bináris fa postorder bejárása.\n\n    Returns:\n    str: A bináris fa preorder bejárása.\n\n    Esetek:\n    - Ha mind az inorder, mind a postorder bejárás üres, üres sztringet ad vissza.\n    - Ha a fa egyetlen csomópontból áll, visszaad egy sztringet azzal az egyetlen csomóponttal.\n    - Nagyobb fa esetén rekurzívan megtalálja a gyökeret a postorder bejárásból,\n      felosztja az inorder bejárást bal és jobb részfákra, és megalkotja\n      a preorder bejárást úgy, hogy a gyökeret követi a bal és jobb részfák.\n\n    Példa:\n    - Adott az 'BADC' inorder bejárás és a 'BDCA' postorder bejárás, a függvény\n      visszaadja az 'ABCD' preorder bejárást.\n    - Adott a 'DBGEACF' inorder bejárás és a 'DGEBFCA' postorder bejárás, a függvény\n      visszaadja az 'ABDEGCF' preorder bejárást.\n    - Adott egy fa egyetlen csomóponttal, amelyet az 'A' inorder és postorder bejárás képvisel,\n      a függvény visszaadja az 'A' értéket.\n    \"\"\"", "es": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstruye el árbol binario a partir de sus recorridos inorder y postorder y\n    devuelve el recorrido preorder como una cadena.\n\n    Argumentos:\n    inorder (str): El recorrido inorder del árbol binario.\n    postorder (str): El recorrido postorder del árbol binario.\n\n    Devuelve:\n    str: El recorrido preorder del árbol binario.\n\n    Casos:\n    - Si ambos recorridos inorder y postorder están vacíos, devuelve una cadena vacía.\n    - Si el árbol consiste en un solo nodo, devuelve una cadena con ese único nodo.\n    - Para un árbol más grande, encuentra recursivamente la raíz a partir del recorrido postorder,\n      divide el recorrido inorder en subárboles izquierdo y derecho, y construye\n      el recorrido preorder visitando la raíz seguida de los subárboles izquierdo y derecho.\n\n    Ejemplo:\n    - Dado el recorrido inorder 'BADC' y el recorrido postorder 'BDCA', la función\n      devolverá el recorrido preorder 'ABCD'.\n    - Dado el recorrido inorder 'DBGEACF' y el recorrido postorder 'DGEBFCA', la función\n      devolverá el recorrido preorder 'ABDEGCF'.\n    - Dado un árbol con un solo nodo representado por el recorrido inorder y postorder 'A',\n      la función devolverá 'A'.\n    \"\"\"", "arb": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    يعيد بناء الشجرة الثنائية من ترتيباتها الوسطى وبعد الترتيب\n    ويعيد ترتيب ما قبل الترتيب كسلسلة نصية.\n\n    يعيدالحجج:\n    inorder (str): الترتيب الوسطي للشجرة الثنائية.\n    postorder (str): الترتيب بعدي للشجرة الثنائية.\n\n    يعيد:\n    str: الترتيب القبلي للشجرة الثنائية.\n\n    حالات:\n    - إذا كانت ترتيبات الوسط وبعد الترتيب فارغة، يعيد سلسلة نصية فارغة.\n    - إذا كانت الشجرة تتكون من عقدة واحدة، يعيد سلسلة تحتوي على تلك العقدة الوحيدة.\n    - بالنسبة لشجرة أكبر، يجد الجذر بشكل متكرر من ترتيب ما بعد الترتيب،\n      يقسم ترتيب الوسط إلى أشجار فرعية يسارية ويمينية، ويبني\n      الترتيب القبلي بزيارة الجذر يليه الأشجار الفرعية اليسارية واليمينية.\n\n    مثال:\n    - بالنظر إلى الترتيب الوسطي 'BADC' والترتيب بعدي 'BDCA'، ستعيد الدالة\n      الترتيب القبلي 'ABCD'.\n    - بالنظر إلى الترتيب الوسطي 'DBGEACF' والترتيب بعدي 'DGEBFCA'، ستعيد الدالة\n      الترتيب القبلي 'ABDEGCF'.\n    - بالنظر إلى شجرة تحتوي على عقدة واحدة ممثلة بالترتيب الوسطي والترتيب بعدي 'A',\n      ستعيد الدالة 'A'.\n    \"\"\"", "sw": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Inajenga upya mti wa binary kutoka kwa mfuatano wake wa inorder na postorder na\n    inarudisha mfuatano wa preorder kama kamba.\n\n    Hoja:\n    inorder (str): Mfuatano wa inorder wa mti wa binary.\n    postorder (str): Mfuatano wa postorder wa mti wa binary.\n\n    Inarejesha:\n    str: Mfuatano wa preorder wa mti wa binary.\n\n    Matukio:\n    - Ikiwa mfuatano wa inorder na postorder ni tupu, inarudisha kamba tupu.\n    - Ikiwa mti unajumuisha nodi moja tu, inarudisha kamba yenye nodi hiyo moja.\n    - Kwa mti mkubwa, hupata mizizi kwa kurudia kutoka kwa mfuatano wa postorder,\n      hugawanya mfuatano wa inorder katika miti midogo ya kushoto na kulia, na hujenga\n      mfuatano wa preorder kwa kutembelea mizizi ikifuatiwa na miti midogo ya kushoto na kulia.\n\n    Mfano:\n    - Ukipewa mfuatano wa inorder 'BADC' na mfuatano wa postorder 'BDCA', kazi\n      itarudisha mfuatano wa preorder 'ABCD'.\n    - Ukipewa mfuatano wa inorder 'DBGEACF' na mfuatano wa postorder 'DGEBFCA', kazi\n      itarudisha mfuatano wa preorder 'ABDEGCF'.\n    - Ukipewa mti wenye nodi moja inayowakilishwa na mfuatano wa inorder na postorder 'A',\n      kazi itarudisha 'A'.\n    \"\"\"", "tr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    İkili ağacı inorder ve postorder sıralamalarından yeniden oluşturur ve\n    preorder sıralamasını bir dize olarak döndürür.\n\n    Argümanlar:\n    inorder (str): İkili ağacın inorder sıralaması.\n    postorder (str): İkili ağacın postorder sıralaması.\n\n    Döndürür:\n    str: İkili ağacın preorder sıralaması.\n\n    Durumlar:\n    - Eğer hem inorder hem de postorder sıralamaları boşsa, boş bir dize döndürür.\n    - Eğer ağaç tek bir düğümden oluşuyorsa, o tek düğümle bir dize döndürür.\n    - Daha büyük bir ağaç için, postorder sıralamasından kökü bulur,\n      inorder sıralamasını sol ve sağ alt ağaçlara böler ve\n      kökü ziyaret ederek, ardından sol ve sağ alt ağaçları ziyaret ederek\n      preorder sıralamasını oluşturur.\n\n    Örnek:\n    - 'BADC' inorder sıralaması ve 'BDCA' postorder sıralaması verildiğinde, fonksiyon\n      'ABCD' preorder sıralamasını döndürecektir.\n    - 'DBGEACF' inorder sıralaması ve 'DGEBFCA' postorder sıralaması verildiğinde, fonksiyon\n      'ABDEGCF' preorder sıralamasını döndürecektir.\n    - 'A' inorder ve postorder sıralaması ile temsil edilen tek bir düğümden oluşan bir ağaç verildiğinde,\n      fonksiyon 'A' döndürecektir.\n    \"\"\"", "vi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Tái cấu trúc cây nhị phân từ các duyệt inorder và postorder của nó và\n    trả về duyệt preorder dưới dạng một chuỗi.\n\n    Tham số:\n    inorder (str): Duyệt inorder của cây nhị phân.\n    postorder (str): Duyệt postorder của cây nhị phân.\n\n    Trả về:\n    str: Duyệt preorder của cây nhị phân.\n\n    Trường hợp:\n    - Nếu cả hai duyệt inorder và postorder đều trống, trả về một chuỗi trống.\n    - Nếu cây bao gồm một nút duy nhất, trả về một chuỗi với nút duy nhất đó.\n    - Đối với một cây lớn hơn, đệ quy tìm gốc từ duyệt postorder,\n      chia duyệt inorder thành các cây con trái và phải, và xây dựng\n      duyệt preorder bằng cách thăm gốc theo sau bởi các cây con trái và phải.\n\n    Ví dụ:\n    - Cho duyệt inorder 'BADC' và duyệt postorder 'BDCA', hàm sẽ\n      trả về duyệt preorder 'ABCD'.\n    - Cho duyệt inorder 'DBGEACF' và duyệt postorder 'DGEBFCA', hàm sẽ\n      trả về duyệt preorder 'ABDEGCF'.\n    - Cho một cây với một nút duy nhất được biểu diễn bởi duyệt inorder và postorder 'A',\n      hàm sẽ trả về 'A'.\n    \"\"\"", "id": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Merekonstruksi pohon biner dari traversal inorder dan postorder-nya dan\n    mengembalikan traversal preorder sebagai string.\n\n    Args:\n    inorder (str): Traversal inorder dari pohon biner.\n    postorder (str): Traversal postorder dari pohon biner.\n\n    Returns:\n    str: Traversal preorder dari pohon biner.\n\n    Kasus:\n    - Jika kedua traversal inorder dan postorder kosong, mengembalikan string kosong.\n    - Jika pohon terdiri dari satu simpul, mengembalikan string dengan satu simpul tersebut.\n    - Untuk pohon yang lebih besar, secara rekursif menemukan akar dari traversal postorder,\n      membagi traversal inorder menjadi subtree kiri dan kanan, dan membangun\n      traversal preorder dengan mengunjungi akar diikuti oleh subtree kiri dan kanan.\n\n    Contoh:\n    - Diberikan traversal inorder 'BADC' dan traversal postorder 'BDCA', fungsi\n      akan mengembalikan traversal preorder 'ABCD'.\n    - Diberikan traversal inorder 'DBGEACF' dan traversal postorder 'DGEBFCA', fungsi\n      akan mengembalikan traversal preorder 'ABDEGCF'.\n    - Diberikan pohon dengan satu simpul yang diwakili oleh traversal inorder dan postorder 'A',\n      fungsi akan mengembalikan 'A'.\n    \"\"\"", "ja": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    中間順と後順の走査から二分木を再構築し、\n    先行順の走査を文字列として返します。\n\n    Args:\n    inorder (str): 二分木の中間順走査。\n    postorder (str): 二分木の後順走査。\n\n    Returns:\n    str: 二分木の先行順走査。\n\n    ケース:\n    - 中間順と後順の走査が両方とも空の場合、空の文字列を返します。\n    - 木が単一のノードで構成されている場合、その単一ノードの文字列を返します。\n    - より大きな木の場合、後順走査から根を再帰的に見つけ、\n      中間順走査を左部分木と右部分木に分割し、\n      根を訪れた後に左部分木と右部分木を訪れることで先行順走査を構築します。\n\n    例:\n    - 中間順走査 'BADC' と後順走査 'BDCA' が与えられた場合、\n      関数は先行順走査 'ABCD' を返します。\n    - 中間順走査 'DBGEACF' と後順走査 'DGEBFCA' が与えられた場合、\n      関数は先行順走査 'ABDEGCF' を返します。\n    - 中間順と後順の走査で 'A' を表す単一ノードの木が与えられた場合、\n      関数は 'A' を返します。\n    \"\"\"", "ko": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    중위 순회와 후위 순회에서 이진 트리를 재구성하고\n    전위 순회를 문자열로 반환합니다.\n\n    매개변수:\n    inorder (str): 이진 트리의 중위 순회.\n    postorder (str): 이진 트리의 후위 순회.\n\n    반환값:\n    str: 이진 트리의 전위 순회.\n\n    경우:\n    - 중위 순회와 후위 순회가 모두 비어 있으면 빈 문자열을 반환합니다.\n    - 트리가 단일 노드로 구성된 경우, 해당 단일 노드가 포함된 문자열을 반환합니다.\n    - 더 큰 트리의 경우, 후위 순회에서 루트를 재귀적으로 찾고,\n      중위 순회를 왼쪽 및 오른쪽 서브트리로 나누고,\n      루트를 방문한 후 왼쪽 및 오른쪽 서브트리를 방문하여 전위 순회를 구성합니다.\n\n    예시:\n    - 중위 순회 'BADC'와 후위 순회 'BDCA'가 주어지면, 함수는 전위 순회 'ABCD'를 반환합니다.\n    - 중위 순회 'DBGEACF'와 후위 순회 'DGEBFCA'가 주어지면, 함수는 전위 순회 'ABDEGCF'를 반환합니다.\n    - 중위 순회와 후위 순회 'A'로 표현된 단일 노드 트리가 주어지면, 함수는 'A'를 반환합니다.\n    \"\"\"", "ml": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    ഇൻഓർഡർ, പോസ്റ്റ്‌ഓർഡർ ട്രാവേഴ്സലുകളിൽ നിന്ന് ബൈനറി മരം പുനർനിർമ്മിച്ച്\n    പ്രീഓർഡർ ട്രാവേഴ്സൽ ഒരു സ്ട്രിംഗായി തിരിച്ചുനൽകുന്നു.\n\n    Args:\n    inorder (str): ബൈനറി മരത്തിന്റെ ഇൻഓർഡർ ട്രാവേഴ്സൽ.\n    postorder (str): ബൈനറി മരത്തിന്റെ പോസ്റ്റ്‌ഓർഡർ ട്രാവേഴ്സൽ.\n\n    Returns:\n    str: ബൈനറി മരത്തിന്റെ പ്രീഓർഡർ ട്രാവേഴ്സൽ.\n\n    കേസുകൾ:\n    - ഇൻഓർഡർ, പോസ്റ്റ്‌ഓർഡർ ട്രാവേഴ്സലുകൾ രണ്ടും ശൂന്യമായാൽ, ശൂന്യമായ സ്ട്രിംഗ് തിരിച്ചുനൽകുന്നു.\n    - മരം ഒരു സിംഗിൾ നോഡിൽ നിന്നാണ് ഉണ്ടെങ്കിൽ, ആ സിംഗിൾ നോഡുള്ള സ്ട്രിംഗ് തിരിച്ചുനൽകുന്നു.\n    - ഒരു വലിയ മരം ഉണ്ടെങ്കിൽ, പോസ്റ്റ്‌ഓർഡർ ട്രാവേഴ്സലിൽ നിന്ന് റൂട്ട് കണ്ടെത്തി,\n      ഇൻഓർഡർ ട്രാവേഴ്സൽ ഇടതും വലതും സബ്ട്രീകളായി വിഭജിച്ച്,\n      റൂട്ട്, ഇടത്, വലത് സബ്ട്രീകൾ സന്ദർശിച്ച് പ്രീഓർഡർ ട്രാവേഴ്സൽ നിർമ്മിക്കുന്നു.\n\n    ഉദാഹരണങ്ങൾ:\n    - ഇൻഓർഡർ ട്രാവേഴ്സൽ 'BADC'യും പോസ്റ്റ്‌ഓർഡർ ട്രാവേഴ്സൽ 'BDCA'യും നൽകിയാൽ, ഫംഗ്ഷൻ\n      പ്രീഓർഡർ ട്രാവേഴ്സൽ 'ABCD' തിരിച്ചുനൽകും.\n    - ഇൻഓർഡർ ട്രാവേഴ്സൽ 'DBGEACF'യും പോസ്റ്റ്‌ഓർഡർ ട്രാവേഴ്സൽ 'DGEBFCA'യും നൽകിയാൽ, ഫംഗ്ഷൻ\n      പ്രീഓർഡർ ട്രാവേഴ്സൽ 'ABDEGCF' തിരിച്ചുനൽകും.\n    - ഇൻഓർഡർ, പോസ്റ്റ്‌ഓർഡർ ട്രാവേഴ്സലിൽ 'A' എന്നൊരു സിംഗിൾ നോഡ് ഉള്ള മരം നൽകിയാൽ,\n      ഫംഗ്ഷൻ 'A' തിരിച്ചുനൽകും.\n    \"\"\"", "fa": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    بازسازی درخت دودویی از پیمایش‌های inorder و postorder و\n    بازگرداندن پیمایش preorder به عنوان یک رشته.\n\n    آرگومان‌ها:\n    inorder (str): پیمایش inorder درخت دودویی.\n    postorder (str): پیمایش postorder درخت دودویی.\n\n    بازگرداندن:\n    str: پیمایش preorder درخت دودویی.\n\n    موارد:\n    - اگر هر دو پیمایش‌های inorder و postorder خالی باشند، یک رشته خالی بازگردانده می‌شود.\n    - اگر درخت شامل یک گره تنها باشد، یک رشته با آن گره تنها بازگردانده می‌شود.\n    - برای یک درخت بزرگتر، به صورت بازگشتی ریشه را از پیمایش postorder پیدا می‌کند،\n      پیمایش inorder را به زیر درخت‌های چپ و راست تقسیم می‌کند و\n      پیمایش preorder را با بازدید از ریشه و سپس زیر درخت‌های چپ و راست می‌سازد.\n\n    مثال:\n    - با توجه به پیمایش inorder 'BADC' و پیمایش postorder 'BDCA'، تابع\n      پیمایش preorder 'ABCD' را باز خواهد گرداند.\n    - با توجه به پیمایش inorder 'DBGEACF' و پیمایش postorder 'DGEBFCA'، تابع\n      پیمایش preorder 'ABDEGCF' را باز خواهد گرداند.\n    - با توجه به درختی با یک گره تنها که با پیمایش‌های inorder و postorder 'A' نشان داده شده است،\n      تابع 'A' را باز خواهد گرداند.\n    \"\"\""}, "canonical_solution": "    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder", "instruction": {"en": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nՏրամադրել Python կոդի հակիրճ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു നാചുറൽ ലാംഗ്വേജ് വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_preorder_traversal():\n    # Test case 1\n    inorder1 = \"BADC\"\n    postorder1 = \"BDCA\"\n    expected_preorder1 = \"ABCD\"\n    assert preorder_traversal(inorder1, postorder1) == expected_preorder1\n    print(f\"Test case 1 passed. Preorder: {preorder_traversal(inorder1, postorder1)}\")\n\n    # Test case 2\n    inorder2 = \"DBGEACF\"\n    postorder2 = \"DGEBFCA\"\n    expected_preorder2 = \"ABDEGCF\"\n    assert preorder_traversal(inorder2, postorder2) == expected_preorder2\n    print(f\"Test case 2 passed. Preorder: {preorder_traversal(inorder2, postorder2)}\")\n\n    # Test case 3\n    inorder3 = \"A\"\n    postorder3 = \"A\"\n    expected_preorder3 = \"A\"\n    assert preorder_traversal(inorder3, postorder3) == expected_preorder3\n    print(f\"Test case 3 passed. Preorder: {preorder_traversal(inorder3, postorder3)}\")\n\n# Run the test function\ntest_preorder_traversal()", "entry_point": "preorder_traversal", "signature": "def preorder_traversal(inorder: str, postorder: str) -> str:", "docstring": {"en": "Reconstructs the binary tree from its inorder and postorder traversals and\nreturns the preorder traversal as a string.\n\nArgs:\ninorder (str): The inorder traversal of the binary tree.\npostorder (str): The postorder traversal of the binary tree.\n\nReturns:\nstr: The preorder traversal of the binary tree.\n\nCases:\n- If both inorder and postorder traversals are empty, returns an empty string.\n- If the tree consists of a single node, returns a string with that single node.\n- For a larger tree, recursively finds the root from the postorder traversal,\nsplits the inorder traversal into left and right subtrees, and constructs\nthe preorder traversal by visiting the root followed by the left and right\nsubtrees.\n\nExample:\n- Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\nwill return the preorder traversal 'ABCD'.\n- Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\nwill return the preorder traversal 'ABDEGCF'.\n- Given a tree with a single node represented by the inorder and postorder traversal 'A',\nthe function will return 'A'.", "sq": "Rikonstrukton pemën binare nga kalimet e saj inorder dhe postorder dhe\nkthen kalimin preorder si një varg.\n\nArgumentet:\ninorder (str): Kalimi inorder i pemës binare.\npostorder (str): Kalimi postorder i pemës binare.\n\nKthen:\nstr: Kalimi preorder i pemës binare.\n\nRastet:\n- Nëse të dy kalimet inorder dhe postorder janë bosh, kthen një varg bosh.\n- Nëse pema përbëhet nga një nyje e vetme, kthen një varg me atë nyje të vetme.\n- Për një pemë më të madhe, gjen në mënyrë rekursive rrënjën nga kalimi postorder,\nndar kalimin inorder në nënpemë të majta dhe të djathta, dhe ndërton\nkalimin preorder duke vizituar rrënjën e ndjekur nga nënpemët e majta dhe të djathta.\n\nShembull:\n- Duke pasur kalimin inorder 'BADC' dhe kalimin postorder 'BDCA', funksioni\ndo të kthejë kalimin preorder 'ABCD'.\n- Duke pasur kalimin inorder 'DBGEACF' dhe kalimin postorder 'DGEBFCA', funksioni\ndo të kthejë kalimin preorder 'ABDEGCF'.\n- Duke pasur një pemë me një nyje të vetme të përfaqësuar nga kalimi inorder dhe postorder 'A',\nfunksioni do të kthejë 'A'.", "hy": "Վերակառուցում է բինար ծառը իր inorder և postorder անցումներից և վերադարձնում է preorder անցումը որպես տող:\n\nԱրձանագրություններ:\ninorder (str): Բինար ծառի inorder անցումը:\npostorder (str): Բինար ծառի postorder անցումը:\n\nՎերադարձնում է:\nstr: Բինար ծառի preorder անցումը:\n\nԴեպքեր:\n- Եթե թե՛ inorder և թե՛ postorder անցումները դատարկ են, վերադարձնում է դատարկ տող:\n- Եթե ծառը բաղկացած է մեկ հանգույցից, վերադարձնում է այդ մեկ հանգույցով տող:\n- Ավելի մեծ ծառի համար, ռեկուրսիվ կերպով գտնում է արմատը postorder անցումից,\nբաժանում է inorder անցումը ձախ և աջ ենթածառերի, և կառուցում է\npreorder անցումը՝ այցելելով արմատը, այնուհետև ձախ և աջ ենթածառերը:\n\nՕրինակ:\n- Տրված է inorder անցումը 'BADC' և postorder անցումը 'BDCA', ֆունկցիան\nկվերադարձնի preorder անցումը 'ABCD':\n- Տրված է inorder անցումը 'DBGEACF' և postorder անցումը 'DGEBFCA', ֆունկցիան\nկվերադարձնի preorder անցումը 'ABDEGCF':\n- Տրված է մեկ հանգույցով ծառ, որը ներկայացված է inorder և postorder անցումներով 'A',\nֆունկցիան կվերադարձնի 'A':", "bn": "বাইনারি ট্রি তার ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে পুনর্গঠন করে এবং প্রিপ্রর্ডার ট্রাভার্সাল একটি স্ট্রিং হিসেবে প্রদান করে।\n\nআর্গুমেন্টসমূহ:\ninorder (str): বাইনারি ট্রির ইনঅর্ডার ট্রাভার্সাল।\npostorder (str): বাইনারি ট্রির পোস্টঅর্ডার ট্রাভার্সাল।\n\nরিটার্নস:\nstr: বাইনারি ট্রির প্রিপ্রর্ডার ট্রাভার্সাল।\n\nক্ষেত্রসমূহ:\n- যদি ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল উভয়ই খালি হয়, তাহলে একটি খালি স্ট্রিং প্রদান করে।\n- যদি ট্রি একটি একক নোড নিয়ে গঠিত হয়, তাহলে সেই একক নোড সহ একটি স্ট্রিং প্রদান করে।\n- একটি বড় ট্রির জন্য, পোস্টঅর্ডার ট্রাভার্সাল থেকে রুট খুঁজে পেতে পুনরাবৃত্তি করে, ইনঅর্ডার ট্রাভার্সালকে বাম এবং ডান সাবট্রিতে বিভক্ত করে, এবং রুট পরিদর্শন করে প্রিপ্রর্ডার ট্রাভার্সাল তৈরি করে, তারপর বাম এবং ডান সাবট্রি।\n\nউদাহরণ:\n- প্রদত্ত ইনঅর্ডার ট্রাভার্সাল 'BADC' এবং পোস্টঅর্ডার ট্রাভার্সাল 'BDCA', ফাংশনটি প্রিপ্রর্ডার ট্রাভার্সাল 'ABCD' প্রদান করবে।\n- প্রদত্ত ইনঅর্ডার ট্রাভার্সাল 'DBGEACF' এবং পোস্টঅর্ডার ট্রাভার্সাল 'DGEBFCA', ফাংশনটি প্রিপ্রর্ডার ট্রাভার্সাল 'ABDEGCF' প্রদান করবে।\n- একটি একক নোড বিশিষ্ট ট্রি, যা ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল 'A' দ্বারা উপস্থাপিত, ফাংশনটি 'A' প্রদান করবে।", "bg": "Реконструира бинарното дърво от неговите inorder и postorder обхождания и\nвръща preorder обхождането като низ.\n\nАргументи:\ninorder (str): Inorder обхождането на бинарното дърво.\npostorder (str): Postorder обхождането на бинарното дърво.\n\nВръща:\nstr: Preorder обхождането на бинарното дърво.\n\nСлучаи:\n- Ако и двете inorder и postorder обхождания са празни, връща празен низ.\n- Ако дървото се състои от един единствен възел, връща низ с този единствен възел.\n- За по-голямо дърво, рекурсивно намира корена от postorder обхождането,\nразделя inorder обхождането на ляво и дясно поддърво и конструира\npreorder обхождането, като посещава корена, последван от лявото и дясното\nподдърво.\n\nПример:\n- Дадено inorder обхождане 'BADC' и postorder обхождане 'BDCA', функцията\nще върне preorder обхождане 'ABCD'.\n- Дадено inorder обхождане 'DBGEACF' и postorder обхождане 'DGEBFCA', функцията\nще върне preorder обхождане 'ABDEGCF'.\n- Дадено дърво с един единствен възел, представено чрез inorder и postorder обхождане 'A',\nфункцията ще върне 'A'.", "zh": "重建二叉树的中序遍历和后序遍历，并返回前序遍历作为字符串。\n\n参数：\ninorder (str): 二叉树的中序遍历。\npostorder (str): 二叉树的后序遍历。\n\n返回：\nstr: 二叉树的前序遍历。\n\n情况：\n- 如果中序遍历和后序遍历都为空，返回一个空字符串。\n- 如果树由单个节点组成，返回包含该单个节点的字符串。\n- 对于较大的树，从后序遍历中递归地找到根节点，将中序遍历分成左子树和右子树，并通过访问根节点，然后访问左子树和右子树来构建前序遍历。\n\n示例：\n- 给定中序遍历 'BADC' 和后序遍历 'BDCA'，函数将返回前序遍历 'ABCD'。\n- 给定中序遍历 'DBGEACF' 和后序遍历 'DGEBFCA'，函数将返回前序遍历 'ABDEGCF'。\n- 给定一个由中序遍历和后序遍历 'A' 表示的单节点树，函数将返回 'A'。", "fr": "Reconstruit l'arbre binaire à partir de ses parcours en ordre et en postordre et\nrenvoie le parcours en préordre sous forme de chaîne de caractères.\n\nArgs:\ninorder (str): Le parcours en ordre de l'arbre binaire.\npostorder (str): Le parcours en postordre de l'arbre binaire.\n\nReturns:\nstr: Le parcours en préordre de l'arbre binaire.\n\nCas:\n- Si les parcours en ordre et en postordre sont tous deux vides, renvoie une chaîne vide.\n- Si l'arbre est constitué d'un seul nœud, renvoie une chaîne avec ce seul nœud.\n- Pour un arbre plus grand, trouve récursivement la racine à partir du parcours en postordre,\ndivise le parcours en ordre en sous-arbres gauche et droit, et construit\nle parcours en préordre en visitant la racine suivie des sous-arbres gauche et droit.\n\nExemple:\n- Étant donné le parcours en ordre 'BADC' et le parcours en postordre 'BDCA', la fonction\nrenverra le parcours en préordre 'ABCD'.\n- Étant donné le parcours en ordre 'DBGEACF' et le parcours en postordre 'DGEBFCA', la fonction\nrenverra le parcours en préordre 'ABDEGCF'.\n- Étant donné un arbre avec un seul nœud représenté par le parcours en ordre et en postordre 'A',\nla fonction renverra 'A'.", "de": "Rekonstruiert den Binärbaum aus seinen Inorder- und Postorder-Traversierungen und gibt die Preorder-Traversierung als Zeichenkette zurück.\n\nArgs:\ninorder (str): Die Inorder-Traversierung des Binärbaums.\npostorder (str): Die Postorder-Traversierung des Binärbaums.\n\nReturns:\nstr: Die Preorder-Traversierung des Binärbaums.\n\nFälle:\n- Wenn sowohl die Inorder- als auch die Postorder-Traversierungen leer sind, wird eine leere Zeichenkette zurückgegeben.\n- Wenn der Baum aus einem einzelnen Knoten besteht, wird eine Zeichenkette mit diesem einzelnen Knoten zurückgegeben.\n- Für einen größeren Baum wird rekursiv die Wurzel aus der Postorder-Traversierung gefunden, die Inorder-Traversierung in linke und rechte Teilbäume aufgeteilt und die Preorder-Traversierung durch Besuch der Wurzel gefolgt von den linken und rechten Teilbäumen konstruiert.\n\nBeispiel:\n- Gegeben die Inorder-Traversierung 'BADC' und die Postorder-Traversierung 'BDCA', wird die Funktion die Preorder-Traversierung 'ABCD' zurückgeben.\n- Gegeben die Inorder-Traversierung 'DBGEACF' und die Postorder-Traversierung 'DGEBFCA', wird die Funktion die Preorder-Traversierung 'ABDEGCF' zurückgeben.\n- Gegeben einen Baum mit einem einzelnen Knoten, dargestellt durch die Inorder- und Postorder-Traversierung 'A', wird die Funktion 'A' zurückgeben.", "ha": "Sake gina itacen binary daga jerin inorder da postorder kuma\nya dawo da jerin preorder a matsayin kirtani.\n\nArgs:\ninorder (str): Inorder traversal na itacen binary.\npostorder (str): Postorder traversal na itacen binary.\n\nReturns:\nstr: Preorder traversal na itacen binary.\n\nCases:\n- Idan duk inorder da postorder traversals suna fanko, yana dawowa da kirtani fanko.\n- Idan itacen yana da tsawo guda ɗaya, yana dawowa da kirtani tare da wannan tsawo guda ɗaya.\n- Don itace mafi girma, yana gano tushen daga postorder traversal,\nyana raba inorder traversal zuwa subtrees na hagu da dama, kuma yana gina\npreorder traversal ta ziyartar tushen sannan ta bi subtrees na hagu da dama.\n\nExample:\n- An ba da inorder traversal 'BADC' da postorder traversal 'BDCA', aikin\nzai dawo da preorder traversal 'ABCD'.\n- An ba da inorder traversal 'DBGEACF' da postorder traversal 'DGEBFCA', aikin\nzai dawo da preorder traversal 'ABDEGCF'.\n- An ba da itace tare da tsawo guda ɗaya wanda aka wakilta ta hanyar inorder da postorder traversal 'A',\naikin zai dawo da 'A'.", "hi": "बाइनरी ट्री को उसके इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से पुनर्निर्मित करता है और\nप्रीऑर्डर ट्रैवर्सल को एक स्ट्रिंग के रूप में लौटाता है।\n\nआर्ग्स:\ninorder (str): बाइनरी ट्री का इनऑर्डर ट्रैवर्सल।\npostorder (str): बाइनरी ट्री का पोस्टऑर्डर ट्रैवर्सल।\n\nरिटर्न्स:\nstr: बाइनरी ट्री का प्रीऑर्डर ट्रैवर्सल।\n\nमामले:\n- यदि इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल दोनों खाली हैं, तो एक खाली स्ट्रिंग लौटाता है।\n- यदि ट्री एक ही नोड से बना है, तो उस एकल नोड के साथ एक स्ट्रिंग लौटाता है।\n- एक बड़े ट्री के लिए, पोस्टऑर्डर ट्रैवर्सल से रूट को पुनरावृत्तिपूर्वक खोजता है,\nइनऑर्डर ट्रैवर्सल को बाएं और दाएं सबट्री में विभाजित करता है, और\nरूट का अनुसरण करते हुए बाएं और दाएं सबट्री का दौरा करके प्रीऑर्डर ट्रैवर्सल का निर्माण करता है।\n\nउदाहरण:\n- दिए गए इनऑर्डर ट्रैवर्सल 'BADC' और पोस्टऑर्डर ट्रैवर्सल 'BDCA' के लिए, फ़ंक्शन\nप्रीऑर्डर ट्रैवर्सल 'ABCD' लौटाएगा।\n- दिए गए इनऑर्डर ट्रैवर्सल 'DBGEACF' और पोस्टऑर्डर ट्रैवर्सल 'DGEBFCA' के लिए, फ़ंक्शन\nप्रीऑर्डर ट्रैवर्सल 'ABDEGCF' लौटाएगा।\n- एकल नोड वाले ट्री के लिए, जिसे इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल 'A' द्वारा दर्शाया गया है,\nफ़ंक्शन 'A' लौटाएगा।", "hu": "Rekonstruálja a bináris fát az inorder és postorder bejárásokból, és\nvisszaadja a preorder bejárást egy karakterláncként.\n\nArgs:\ninorder (str): A bináris fa inorder bejárása.\npostorder (str): A bináris fa postorder bejárása.\n\nReturns:\nstr: A bináris fa preorder bejárása.\n\nEsetek:\n- Ha mind az inorder, mind a postorder bejárások üresek, üres karakterláncot ad vissza.\n- Ha a fa egyetlen csomópontból áll, egyetlen csomópontot tartalmazó karakterláncot ad vissza.\n- Nagyobb fa esetén rekurzívan megtalálja a gyökeret a postorder bejárásból,\nfelosztja az inorder bejárást bal és jobb részfákra, és megkonstruálja\na preorder bejárást a gyökér, majd a bal és jobb részfák bejárásával.\n\nPélda:\n- Az 'BADC' inorder és 'BDCA' postorder bejárások esetén a függvény\nvisszaadja az 'ABCD' preorder bejárást.\n- Az 'DBGEACF' inorder és 'DGEBFCA' postorder bejárások esetén a függvény\nvisszaadja az 'ABDEGCF' preorder bejárást.\n- Egyetlen csomópontot tartalmazó fa esetén, amelyet az 'A' inorder és postorder bejárás képvisel,\na függvény 'A'-t ad vissza.", "es": "Reconstruye el árbol binario a partir de sus recorridos inorder y postorder y\ndevuelve el recorrido preorder como una cadena.\n\nArgumentos:\ninorder (str): El recorrido inorder del árbol binario.\npostorder (str): El recorrido postorder del árbol binario.\n\nDevuelve:\nstr: El recorrido preorder del árbol binario.\n\nCasos:\n- Si ambos recorridos inorder y postorder están vacíos, devuelve una cadena vacía.\n- Si el árbol consta de un solo nodo, devuelve una cadena con ese único nodo.\n- Para un árbol más grande, encuentra recursivamente la raíz a partir del recorrido postorder,\ndivide el recorrido inorder en subárboles izquierdo y derecho, y construye\nel recorrido preorder visitando la raíz seguida por los subárboles izquierdo y derecho.\n\nEjemplo:\n- Dado el recorrido inorder 'BADC' y el recorrido postorder 'BDCA', la función\ndevolverá el recorrido preorder 'ABCD'.\n- Dado el recorrido inorder 'DBGEACF' y el recorrido postorder 'DGEBFCA', la función\ndevolverá el recorrido preorder 'ABDEGCF'.\n- Dado un árbol con un solo nodo representado por el recorrido inorder y postorder 'A',\nla función devolverá 'A'.", "arb": "يعيد بناء الشجرة الثنائية من ترتيبها الوسطي وترتيبها اللاحق ويعيد ترتيبها القبلي كسلسلة نصية.\n\nالمعطيات:\ninorder (str): الترتيب الوسطي للشجرة الثنائية.\npostorder (str): الترتيب اللاحق للشجرة الثنائية.\n\nالقيم المعادة:\nstr: الترتيب القبلي للشجرة الثنائية.\n\nالحالات:\n- إذا كانت كل من الترتيبات الوسطية واللاحقة فارغة، يعيد سلسلة نصية فارغة.\n- إذا كانت الشجرة تتكون من عقدة واحدة، يعيد سلسلة نصية تحتوي على تلك العقدة الوحيدة.\n- بالنسبة لشجرة أكبر، يجد الجذر بشكل متكرر من الترتيب اللاحق، ويقسم الترتيب الوسطي إلى أشجار فرعية يسرى ويمنى، ويقوم ببناء الترتيب القبلي بزيارة الجذر متبوعًا بالأشجار الفرعية اليسرى واليمنى.\n\nمثال:\n- بالنظر إلى الترتيب الوسطي 'BADC' والترتيب اللاحق 'BDCA'، ستعيد الدالة الترتيب القبلي 'ABCD'.\n- بالنظر إلى الترتيب الوسطي 'DBGEACF' والترتيب اللاحق 'DGEBFCA'، ستعيد الدالة الترتيب القبلي 'ABDEGCF'.\n- بالنظر إلى شجرة تحتوي على عقدة واحدة ممثلة بالترتيب الوسطي والترتيب اللاحق 'A'، ستعيد الدالة 'A'.", "sw": "Inajenga upya mti wa binary kutoka kwa mfuatano wake wa inorder na postorder na\ninarudisha mfuatano wa preorder kama kamba.\n\nHoja:\ninorder (str): Mfuatano wa inorder wa mti wa binary.\npostorder (str): Mfuatano wa postorder wa mti wa binary.\n\nInarejesha:\nstr: Mfuatano wa preorder wa mti wa binary.\n\nMatukio:\n- Ikiwa mfuatano wa inorder na postorder ni tupu, inarudisha kamba tupu.\n- Ikiwa mti unajumuisha nodi moja, inarudisha kamba yenye nodi hiyo moja.\n- Kwa mti mkubwa, hupata mzizi kutoka kwa mfuatano wa postorder,\nhugawanya mfuatano wa inorder katika miti midogo ya kushoto na kulia, na huunda\nmfuatano wa preorder kwa kutembelea mzizi ikifuatiwa na miti midogo ya kushoto na kulia.\n\nMfano:\n- Ukipewa mfuatano wa inorder 'BADC' na mfuatano wa postorder 'BDCA', kazi\nitarudisha mfuatano wa preorder 'ABCD'.\n- Ukipewa mfuatano wa inorder 'DBGEACF' na mfuatano wa postorder 'DGEBFCA', kazi\nitarudisha mfuatano wa preorder 'ABDEGCF'.\n- Ukipewa mti wenye nodi moja inayowakilishwa na mfuatano wa inorder na postorder 'A',\nkazi itarudisha 'A'.", "tr": "İkili ağacı inorder ve postorder geçişlerinden yeniden oluşturur ve\npreorder geçişini bir string olarak döndürür.\n\nArgümanlar:\ninorder (str): İkili ağacın inorder geçişi.\npostorder (str): İkili ağacın postorder geçişi.\n\nDöndürür:\nstr: İkili ağacın preorder geçişi.\n\nDurumlar:\n- Eğer hem inorder hem de postorder geçişleri boşsa, boş bir string döndürür.\n- Eğer ağaç tek bir düğümden oluşuyorsa, o tek düğümle bir string döndürür.\n- Daha büyük bir ağaç için, postorder geçişinden kökü özyinelemeli olarak bulur,\ninorder geçişini sol ve sağ alt ağaçlara böler ve\nkökü, ardından sol ve sağ alt ağaçları ziyaret ederek preorder geçişini oluşturur.\n\nÖrnek:\n- 'BADC' inorder geçişi ve 'BDCA' postorder geçişi verildiğinde, fonksiyon\npreorder geçişi olarak 'ABCD' döndürecektir.\n- 'DBGEACF' inorder geçişi ve 'DGEBFCA' postorder geçişi verildiğinde, fonksiyon\npreorder geçişi olarak 'ABDEGCF' döndürecektir.\n- 'A' inorder ve postorder geçişi ile temsil edilen tek bir düğümlü bir ağaç verildiğinde,\nfonksiyon 'A' döndürecektir.", "vi": "Tái tạo cây nhị phân từ các duyệt cây inorder và postorder của nó và trả về duyệt cây preorder dưới dạng chuỗi.\n\nTham số:\ninorder (str): Duyệt cây inorder của cây nhị phân.\npostorder (str): Duyệt cây postorder của cây nhị phân.\n\nTrả về:\nstr: Duyệt cây preorder của cây nhị phân.\n\nTrường hợp:\n- Nếu cả hai duyệt cây inorder và postorder đều rỗng, trả về một chuỗi rỗng.\n- Nếu cây bao gồm một nút duy nhất, trả về một chuỗi với nút duy nhất đó.\n- Đối với một cây lớn hơn, đệ quy tìm gốc từ duyệt cây postorder,\nchia duyệt cây inorder thành cây con trái và phải, và xây dựng\nduyệt cây preorder bằng cách thăm gốc tiếp theo là cây con trái và phải.\n\nVí dụ:\n- Cho duyệt cây inorder 'BADC' và duyệt cây postorder 'BDCA', hàm sẽ trả về duyệt cây preorder 'ABCD'.\n- Cho duyệt cây inorder 'DBGEACF' và duyệt cây postorder 'DGEBFCA', hàm sẽ trả về duyệt cây preorder 'ABDEGCF'.\n- Cho một cây với một nút duy nhất được biểu diễn bởi duyệt cây inorder và postorder 'A', hàm sẽ trả về 'A'.", "id": "Menyusun kembali pohon biner dari penelusuran inorder dan postorder-nya dan\nmengembalikan penelusuran preorder sebagai string.\n\nArgs:\ninorder (str): Penelusuran inorder dari pohon biner.\npostorder (str): Penelusuran postorder dari pohon biner.\n\nReturns:\nstr: Penelusuran preorder dari pohon biner.\n\nKasus:\n- Jika kedua penelusuran inorder dan postorder kosong, mengembalikan string kosong.\n- Jika pohon terdiri dari satu simpul, mengembalikan string dengan simpul tunggal tersebut.\n- Untuk pohon yang lebih besar, secara rekursif menemukan akar dari penelusuran postorder,\nmembagi penelusuran inorder menjadi subpohon kiri dan kanan, dan menyusun\npenelusuran preorder dengan mengunjungi akar diikuti oleh subpohon kiri dan kanan.\n\nContoh:\n- Diberikan penelusuran inorder 'BADC' dan penelusuran postorder 'BDCA', fungsi\nakan mengembalikan penelusuran preorder 'ABCD'.\n- Diberikan penelusuran inorder 'DBGEACF' dan penelusuran postorder 'DGEBFCA', fungsi\nakan mengembalikan penelusuran preorder 'ABDEGCF'.\n- Diberikan pohon dengan satu simpul yang diwakili oleh penelusuran inorder dan postorder 'A',\nfungsi akan mengembalikan 'A'.", "ja": "二分木をその中順および後順の巡回から再構築し、先行順の巡回を文字列として返します。\n\n引数:\ninorder (str): 二分木の中順巡回。\npostorder (str): 二分木の後順巡回。\n\n戻り値:\nstr: 二分木の先行順巡回。\n\nケース:\n- 中順および後順の巡回が両方とも空の場合、空の文字列を返します。\n- 木が単一のノードで構成されている場合、その単一のノードを含む文字列を返します。\n- より大きな木の場合、後順巡回から根を再帰的に見つけ、中順巡回を左部分木と右部分木に分割し、根を訪れた後に左部分木と右部分木を訪れることで先行順巡回を構築します。\n\n例:\n- 中順巡回 'BADC' と後順巡回 'BDCA' が与えられた場合、関数は先行順巡回 'ABCD' を返します。\n- 中順巡回 'DBGEACF' と後順巡回 'DGEBFCA' が与えられた場合、関数は先行順巡回 'ABDEGCF' を返します。\n- 中順および後順巡回が 'A' で表される単一ノードの木が与えられた場合、関数は 'A' を返します。", "ko": "이진 트리를 중위 순회 및 후위 순회로부터 재구성하고 전위 순회를 문자열로 반환합니다.\n\nArgs:\ninorder (str): 이진 트리의 중위 순회.\npostorder (str): 이진 트리의 후위 순회.\n\nReturns:\nstr: 이진 트리의 전위 순회.\n\nCases:\n- 중위 순회와 후위 순회가 모두 비어 있는 경우, 빈 문자열을 반환합니다.\n- 트리가 단일 노드로 구성된 경우, 해당 단일 노드가 포함된 문자열을 반환합니다.\n- 더 큰 트리의 경우, 후위 순회에서 루트를 재귀적으로 찾고, 중위 순회를 왼쪽 및 오른쪽 서브트리로 나누고, 루트를 방문한 후 왼쪽 및 오른쪽 서브트리를 방문하여 전위 순회를 구성합니다.\n\nExample:\n- 중위 순회 'BADC'와 후위 순회 'BDCA'가 주어지면, 함수는 전위 순회 'ABCD'를 반환합니다.\n- 중위 순회 'DBGEACF'와 후위 순회 'DGEBFCA'가 주어지면, 함수는 전위 순회 'ABDEGCF'를 반환합니다.\n- 중위 순회와 후위 순회가 'A'로 표현된 단일 노드를 가진 트리가 주어지면, 함수는 'A'를 반환합니다.", "ml": "ബൈനറി ട്രീയുടെ ഇൻഓർഡർ, പോസ്റ്റ്ഓർഡർ ട്രാവേഴ്സലുകളിൽ നിന്ന് പുനർനിർമ്മിച്ച് പ്രീഓർഡർ ട്രാവേഴ്സൽ ഒരു സ്ട്രിംഗായി തിരികെ നൽകുന്നു.\n\nആർഗുകൾ:\ninorder (str): ബൈനറി ട്രീയുടെ ഇൻഓർഡർ ട്രാവേഴ്സൽ.\npostorder (str): ബൈനറി ട്രീയുടെ പോസ്റ്റ്ഓർഡർ ട്രാവേഴ്സൽ.\n\nമടക്കം:\nstr: ബൈനറി ട്രീയുടെ പ്രീഓർഡർ ട്രാവേഴ്സൽ.\n\nകേസുകൾ:\n- ഇൻഓർഡർ, പോസ്റ്റ്ഓർഡർ ട്രാവേഴ്സലുകൾ രണ്ടും ശൂന്യമായാൽ, ശൂന്യമായ ഒരു സ്ട്രിംഗ് തിരികെ നൽകുന്നു.\n- ട്രീ ഒരു സിംഗിൾ നോഡിൽ നിന്നാണ് ഉണ്ടെങ്കിൽ, ആ സിംഗിൾ നോഡുള്ള ഒരു സ്ട്രിംഗ് തിരികെ നൽകുന്നു.\n- വലുതായ ഒരു ട്രീക്കായി, പോസ്റ്റ്ഓർഡർ ട്രാവേഴ്സലിൽ നിന്ന് റൂട്ട് പുനരാവിഷ്കരിച്ച്, ഇൻഓർഡർ ട്രാവേഴ്സലിനെ ഇടത്, വലത് ഉപട്രീകളായി വിഭജിച്ച്, റൂട്ട്, തുടർന്ന് ഇടത്, വലത് ഉപട്രീകൾ സന്ദർശിച്ച് പ്രീഓർഡർ ട്രാവേഴ്സൽ നിർമ്മിക്കുന്നു.\n\nഉദാഹരണം:\n- ഇൻഓർഡർ ട്രാവേഴ്സൽ 'BADC' എന്നും പോസ്റ്റ്ഓർഡർ ട്രാവേഴ്സൽ 'BDCA' എന്നും നൽകിയാൽ, ഫങ്ഷൻ പ്രീഓർഡർ ട്രാവേഴ്സൽ 'ABCD' തിരികെ നൽകും.\n- ഇൻഓർഡർ ട്രാവേഴ്സൽ 'DBGEACF' എന്നും പോസ്റ്റ്ഓർഡർ ട്രാവേഴ്സൽ 'DGEBFCA' എന്നും നൽകിയാൽ, ഫങ്ഷൻ പ്രീഓർഡർ ട്രാവേഴ്സൽ 'ABDEGCF' തിരികെ നൽകും.\n- ഇൻഓർഡർ, പോസ്റ്റ്ഓർഡർ ട്രാവേഴ്സൽ 'A' എന്നൊരു സിംഗിൾ നോഡുള്ള ട്രീ നൽകിയാൽ, ഫങ്ഷൻ 'A' തിരികെ നൽകും.", "fa": "بازسازی درخت دودویی از پیمایش‌های inorder و postorder و بازگرداندن پیمایش preorder به صورت یک رشته.\n\nآرگومان‌ها:\ninorder (str): پیمایش inorder درخت دودویی.\npostorder (str): پیمایش postorder درخت دودویی.\n\nبازگشت:\nstr: پیمایش preorder درخت دودویی.\n\nموارد:\n- اگر هر دو پیمایش inorder و postorder خالی باشند، یک رشته خالی بازمی‌گرداند.\n- اگر درخت شامل یک گره تنها باشد، یک رشته با آن گره تنها بازمی‌گرداند.\n- برای یک درخت بزرگتر، به صورت بازگشتی ریشه را از پیمایش postorder پیدا می‌کند،\nپیمایش inorder را به زیردرخت‌های چپ و راست تقسیم می‌کند و پیمایش preorder را با بازدید از ریشه و سپس زیردرخت‌های چپ و راست می‌سازد.\n\nمثال:\n- با توجه به پیمایش inorder 'BADC' و پیمایش postorder 'BDCA'، تابع پیمایش preorder 'ABCD' را بازمی‌گرداند.\n- با توجه به پیمایش inorder 'DBGEACF' و پیمایش postorder 'DGEBFCA'، تابع پیمایش preorder 'ABDEGCF' را بازمی‌گرداند.\n- با توجه به درختی با یک گره تنها که با پیمایش‌های inorder و postorder 'A' نمایش داده می‌شود، تابع 'A' را بازمی‌گرداند."}}
{"task_id": "Python/28", "prompt": {"en": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    Case 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) should return 3.\n\n    Case 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\n    is not possible within 10 steps.\n\n    Case 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) should return 3, as each character is replaced\n    individually.\n    \"\"\"", "sq": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Kryen transformimin e vargut nga A në B duke përdorur një grup rregullash transformimi.\n\n    Kjo funksion merr një varg fillestar A dhe një varg të synuar B, së bashku me një listë\n    të rregullave të transformimit, dhe përpiqet të transformojë A në B duke përdorur rregullat.\n    Një algoritëm Kërkimi i Gjerë (BFS) përdoret për të eksploruar transformimet e mundshme\n    deri në një maksimum prej 10 hapash. Nëse A mund të transformohet në B brenda 10 hapash, funksioni\n    kthen numrin minimal të hapave të kërkuar. Nëse nuk është e mundur, funksioni kthen\n    \"NO ANSWER!\".\n\n    Parametrat:\n    A (str): Vargu fillestar që do të transformohet.\n    B (str): Vargu i synuar që do të arrihet.\n    rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull është një dyshe\n                            që përmban nënvargun burim (që do të zëvendësohet) dhe\n                            nënvargun e synuar (me të cilin do të zëvendësohet).\n\n    Kthen:\n    Union[int, str]: Numri minimal i hapave të transformimit nëse është e mundur, përndryshe \"NO ANSWER!\".\n\n    Shembuj:\n    Rasti 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) duhet të kthejë 3.\n\n    Rasti 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) duhet të kthejë \"NO ANSWER!\" sepse transformimi\n    nuk është i mundur brenda 10 hapash.\n\n    Rasti 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) duhet të kthejë 3, pasi çdo karakter zëvendësohet\n    individualisht.\n    \"\"\"", "hy": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Իրականացնել տողերի փոխակերպում A-ից B օգտագործելով փոխակերպման կանոնների հավաքածու։\n\n    Այս ֆունկցիան վերցնում է սկզբնական տող A և նպատակային տող B, ինչպես նաև փոխակերպման\n    կանոնների ցուցակ, և փորձում է փոխակերպել A-ն B-ի օգտագործելով կանոնները։\n    Օգտագործվում է լայնության առաջին որոնման (BFS) ալգորիթմ՝ հնարավոր փոխակերպումները\n    ուսումնասիրելու համար առավելագույնը 10 քայլով։ Եթե A-ն հնարավոր է փոխակերպել B-ի\n    10 քայլի ընթացքում, ֆունկցիան վերադարձնում է պահանջվող նվազագույն քայլերի քանակը։\n    Եթե դա հնարավոր չէ, ֆունկցիան վերադարձնում է \"NO ANSWER!\"։\n\n    Պարամետրեր:\n    A (str): Սկզբնական տողը, որը պետք է փոխակերպվի։\n    B (str): Նպատակային տողը, որը պետք է ստացվի։\n    rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն\n                            զույգ է, որը պարունակում է աղբյուր ենթատողը (որը պետք է փոխարինվի)\n                            և նպատակային ենթատողը (որով պետք է փոխարինվի)։\n\n    Վերադարձնում է:\n    Union[int, str]: Փոխակերպման նվազագույն քայլերի քանակը, եթե հնարավոր է, հակառակ դեպքում՝ \"NO ANSWER!\"։\n\n    Օրինակներ:\n    Դեպք 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) պետք է վերադարձնի 3։\n\n    Դեպք 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) պետք է վերադարձնի \"NO ANSWER!\", քանի որ փոխակերպումը\n    հնարավոր չէ 10 քայլի ընթացքում։\n\n    Դեպք 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) պետք է վերադարձնի 3, քանի որ յուրաքանչյուր նիշ\n    փոխարինվում է առանձին։\n    \"\"\"", "bn": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    একটি সেট রূপান্তর নিয়ম ব্যবহার করে A থেকে B তে স্ট্রিং রূপান্তর সম্পাদন করুন।\n\n    এই ফাংশনটি একটি প্রাথমিক স্ট্রিং A এবং একটি লক্ষ্য স্ট্রিং B গ্রহণ করে, সাথে একটি রূপান্তর নিয়মের তালিকা,\n    এবং নিয়মগুলি ব্যবহার করে A কে B তে রূপান্তর করার চেষ্টা করে। একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) অ্যালগরিদম\n    ব্যবহার করা হয় সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে সর্বাধিক 10 ধাপ পর্যন্ত। যদি A কে 10 ধাপের মধ্যে B তে\n    রূপান্তর করা যায়, তাহলে ফাংশনটি প্রয়োজনীয় ন্যূনতম ধাপের সংখ্যা প্রদান করে। যদি এটি সম্ভব না হয়, তাহলে\n    ফাংশনটি \"NO ANSWER!\" প্রদান করে।\n\n    প্যারামিটারসমূহ:\n    A (str): প্রাথমিক স্ট্রিং যা রূপান্তরিত হবে।\n    B (str): লক্ষ্য স্ট্রিং যা অর্জন করতে হবে।\n    rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল\n                            হিসেবে থাকে যা উৎস সাবস্ট্রিং (যা প্রতিস্থাপন করা হবে) এবং\n                            লক্ষ্য সাবস্ট্রিং (যা দিয়ে প্রতিস্থাপন করা হবে) ধারণ করে।\n\n    রিটার্ন:\n    Union[int, str]: যদি সম্ভব হয় তাহলে ন্যূনতম রূপান্তর ধাপের সংখ্যা, অন্যথায় \"NO ANSWER!\".\n\n    উদাহরণ:\n    কেস 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) 3 প্রদান করা উচিত।\n\n    কেস 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) \"NO ANSWER!\" প্রদান করা উচিত কারণ রূপান্তর\n    10 ধাপের মধ্যে সম্ভব নয়।\n\n    কেস 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) 3 প্রদান করা উচিত, কারণ প্রতিটি অক্ষর\n    পৃথকভাবে প্রতিস্থাপিত হয়।\n    \"\"\"", "bg": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Извършване на трансформация на низ от A до B, използвайки набор от правила за трансформация.\n\n    Тази функция приема начален низ A и целеви низ B, заедно със списък от правила за трансформация,\n    и се опитва да трансформира A в B, използвайки правилата. Използва се алгоритъм за търсене в ширина (BFS),\n    за да се изследват възможните трансформации до максимум 10 стъпки. Ако A може да бъде трансформиран в B в рамките\n    на 10 стъпки, функцията връща минималния брой необходими стъпки. Ако това не е възможно, функцията връща\n    \"NO ANSWER!\".\n\n    Параметри:\n    A (str): Началният низ, който трябва да бъде трансформиран.\n    B (str): Целевият низ, който трябва да бъде постигнат.\n    rules (list of tuples): Списък от правила за трансформация, където всяко правило е кортеж,\n                            съдържащ изходния подниз (който да бъде заменен) и целевия подниз\n                            (с който да се замени).\n\n    Връща:\n    Union[int, str]: Минималният брой стъпки за трансформация, ако е възможно, в противен случай \"NO ANSWER!\".\n\n    Примери:\n    Случай 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) трябва да върне 3.\n\n    Случай 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) трябва да върне \"NO ANSWER!\" защото трансформацията\n    не е възможна в рамките на 10 стъпки.\n\n    Случай 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) трябва да върне 3, тъй като всеки символ се заменя\n    индивидуално.\n    \"\"\"", "zh": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    使用一组转换规则执行从 A 到 B 的字符串转换。\n\n    此函数接受一个初始字符串 A 和一个目标字符串 B，以及一个转换规则列表，\n    并尝试使用这些规则将 A 转换为 B。使用广度优先搜索 (BFS) 算法来探索可能的转换，\n    最多进行 10 步。如果 A 可以在 10 步内转换为 B，函数返回所需的最小步骤数。\n    如果不可能，函数返回 \"NO ANSWER!\"。\n\n    参数:\n    A (str): 要转换的初始字符串。\n    B (str): 要实现的目标字符串。\n    rules (list of tuples): 转换规则列表，其中每个规则是一个包含源子字符串（要替换）\n                            和目标子字符串（用于替换）的元组。\n\n    返回:\n    Union[int, str]: 如果可能，返回最小的转换步骤数，否则返回 \"NO ANSWER!\"。\n\n    示例:\n    案例 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) 应返回 3。\n\n    案例 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) 应返回 \"NO ANSWER!\" 因为在 10 步内无法转换。\n\n    案例 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) 应返回 3，因为每个字符都是单独替换的。\n    \"\"\"", "fr": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Effectuer une transformation de chaîne de A à B en utilisant un ensemble de règles de transformation.\n\n    Cette fonction prend une chaîne initiale A et une chaîne cible B, ainsi qu'une liste\n    de règles de transformation, et tente de transformer A en B en utilisant les règles.\n    Un algorithme de recherche en largeur (BFS) est utilisé pour explorer les transformations possibles\n    jusqu'à un maximum de 10 étapes. Si A peut être transformé en B en 10 étapes, la fonction\n    retourne le nombre minimum d'étapes requises. Si ce n'est pas possible, la fonction retourne\n    \"NO ANSWER!\".\n\n    Paramètres:\n    A (str): La chaîne initiale à transformer.\n    B (str): La chaîne cible à atteindre.\n    rules (list of tuples): Une liste de règles de transformation, où chaque règle est un tuple\n                            contenant la sous-chaîne source (à remplacer) et la\n                            sous-chaîne cible (pour remplacer).\n\n    Retours:\n    Union[int, str]: Le nombre minimum d'étapes de transformation si possible, sinon \"NO ANSWER!\".\n\n    Exemples:\n    Cas 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) devrait retourner 3.\n\n    Cas 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) devrait retourner \"NO ANSWER!\" car la transformation\n    n'est pas possible en 10 étapes.\n\n    Cas 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) devrait retourner 3, car chaque caractère est remplacé\n    individuellement.\n    \"\"\"", "de": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Führe eine Zeichenketten-Transformation von A nach B unter Verwendung eines Satzes von Transformationsregeln durch.\n\n    Diese Funktion nimmt eine Anfangszeichenkette A und eine Zielzeichenkette B sowie eine Liste\n    von Transformationsregeln und versucht, A unter Verwendung der Regeln in B zu transformieren.\n    Ein Breadth-First Search (BFS)-Algorithmus wird verwendet, um die möglichen Transformationen\n    bis zu maximal 10 Schritten zu erkunden. Wenn A innerhalb von 10 Schritten in B transformiert werden kann, gibt die Funktion\n    die minimale Anzahl der erforderlichen Schritte zurück. Wenn es nicht möglich ist, gibt die Funktion\n    \"NO ANSWER!\" zurück.\n\n    Parameter:\n    A (str): Die anfängliche Zeichenkette, die transformiert werden soll.\n    B (str): Die Zielzeichenkette, die erreicht werden soll.\n    rules (list of tuples): Eine Liste von Transformationsregeln, wobei jede Regel ein Tupel ist,\n                            das die Quellzeichenfolge (die ersetzt werden soll) und die\n                            Zielzeichenfolge (mit der ersetzt werden soll) enthält.\n\n    Rückgabewerte:\n    Union[int, str]: Die minimale Anzahl der Transformationsschritte, falls möglich, andernfalls \"NO ANSWER!\".\n\n    Beispiele:\n    Fall 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) sollte 3 zurückgeben.\n\n    Fall 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) sollte \"NO ANSWER!\" zurückgeben, da die Transformation\n    innerhalb von 10 Schritten nicht möglich ist.\n\n    Fall 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) sollte 3 zurückgeben, da jedes Zeichen\n    einzeln ersetzt wird.\n    \"\"\"", "ha": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Yi sauyin kirtani daga A zuwa B ta amfani da saitin dokokin sauyi.\n\n    Wannan aikin yana daukar kirtani na farko A da kirtani na manufa B, tare da jerin\n    dokokin sauyi, kuma yana ƙoƙarin sauya A zuwa B ta amfani da dokokin.\n    Ana amfani da algorithm na Breadth-First Search (BFS) don bincika yiwuwar sauye-sauye\n    har zuwa matakai 10 mafi yawa. Idan za a iya sauya A zuwa B cikin matakai 10, aikin\n    yana dawo da mafi ƙarancin adadin matakan da ake buƙata. Idan ba zai yiwu ba, aikin yana dawo\n    da \"NO ANSWER!\".\n\n    Sigogi:\n    A (str): Kirtani na farko da za a sauya.\n    B (str): Kirtani na manufa da za a cimma.\n    rules (list of tuples): Jerin dokokin sauyi, inda kowace doka take da tuple\n                            mai dauke da kirtani na asali (da za a maye gurbin) da\n                            kirtani na manufa (da za a maye gurbinsa da shi).\n\n    Komawa:\n    Union[int, str]: Mafi ƙarancin adadin matakan sauyi idan zai yiwu, in ba haka ba \"NO ANSWER!\".\n\n    Misalai:\n    Case 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) ya kamata ya dawo da 3.\n\n    Case 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) ya kamata ya dawo da \"NO ANSWER!\" saboda sauyi\n    ba zai yiwu ba cikin matakai 10.\n\n    Case 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) ya kamata ya dawo da 3, yayin da kowanne hali\n    aka maye gurbinsa da kansa.\n    \"\"\"", "hi": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    आरंभिक स्ट्रिंग A से B में परिवर्तन करने के लिए परिवर्तन नियमों का उपयोग करें।\n\n    यह फ़ंक्शन एक प्रारंभिक स्ट्रिंग A और एक लक्षित स्ट्रिंग B लेता है, साथ ही\n    परिवर्तन नियमों की एक सूची, और नियमों का उपयोग करके A को B में बदलने का प्रयास करता है।\n    संभावित परिवर्तनों का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) एल्गोरिदम का उपयोग किया जाता है\n    अधिकतम 10 चरणों तक। यदि A को 10 चरणों के भीतर B में बदला जा सकता है, तो फ़ंक्शन\n    आवश्यक न्यूनतम चरणों की संख्या लौटाता है। यदि यह संभव नहीं है, तो फ़ंक्शन\n    \"NO ANSWER!\" लौटाता है।\n\n    पैरामीटर्स:\n    A (str): वह प्रारंभिक स्ट्रिंग जिसे परिवर्तित किया जाना है।\n    B (str): वह लक्षित स्ट्रिंग जिसे प्राप्त किया जाना है।\n    rules (list of tuples): परिवर्तन नियमों की एक सूची, जहाँ प्रत्येक नियम एक ट्यूपल होता है\n                            जिसमें स्रोत उपस्ट्रिंग (जिसे बदला जाना है) और\n                            लक्षित उपस्ट्रिंग (जिससे बदलना है) शामिल होते हैं।\n\n    रिटर्न्स:\n    Union[int, str]: यदि संभव हो तो न्यूनतम परिवर्तन चरणों की संख्या, अन्यथा \"NO ANSWER!\".\n\n    उदाहरण:\n    केस 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) को 3 लौटाना चाहिए।\n\n    केस 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) को \"NO ANSWER!\" लौटाना चाहिए क्योंकि परिवर्तन\n    10 चरणों के भीतर संभव नहीं है।\n\n    केस 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) को 3 लौटाना चाहिए, क्योंकि प्रत्येक वर्ण को\n    व्यक्तिगत रूप से बदला जाता है।\n    \"\"\"", "hu": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    String transzformáció végrehajtása A-ból B-be egy sor transzformációs szabály segítségével.\n\n    Ez a függvény egy kezdeti A stringet és egy cél B stringet vesz, valamint egy listát\n    transzformációs szabályokkal, és megpróbálja A-t B-vé alakítani a szabályok segítségével.\n    Egy Szélességi Első Keresés (BFS) algoritmus kerül alkalmazásra a lehetséges transzformációk\n    felfedezésére legfeljebb 10 lépésig. Ha A 10 lépésen belül átalakítható B-vé, a függvény\n    visszaadja a szükséges minimális lépések számát. Ha nem lehetséges, a függvény\n    \"NO ANSWER!\"-t ad vissza.\n\n    Paraméterek:\n    A (str): A kezdeti string, amelyet át kell alakítani.\n    B (str): A cél string, amelyet el kell érni.\n    rules (list of tuples): Egy lista transzformációs szabályokkal, ahol minden szabály egy\n                            forrás részstringet (amit ki kell cserélni) és egy\n                            cél részstringet (amire ki kell cserélni) tartalmaz.\n\n    Visszatérési érték:\n    Union[int, str]: A minimális transzformációs lépések száma, ha lehetséges, ellenkező esetben \"NO ANSWER!\".\n\n    Példák:\n    1. eset:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) vissza kell adja 3.\n\n    2. eset:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) vissza kell adja \"NO ANSWER!\" mert a transzformáció\n    nem lehetséges 10 lépésen belül.\n\n    3. eset:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) vissza kell adja 3, mivel minden karakter\n    egyenként kerül kicserélésre.\n    \"\"\"", "es": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Realiza la transformación de cadena de A a B utilizando un conjunto de reglas de transformación.\n\n    Esta función toma una cadena inicial A y una cadena objetivo B, junto con una lista\n    de reglas de transformación, e intenta transformar A en B usando las reglas.\n    Se utiliza un algoritmo de Búsqueda en Anchura (BFS) para explorar las posibles transformaciones\n    hasta un máximo de 10 pasos. Si A puede transformarse en B dentro de 10 pasos, la función\n    devuelve el número mínimo de pasos requeridos. Si no es posible, la función devuelve\n    \"NO ANSWER!\".\n\n    Parámetros:\n    A (str): La cadena inicial a transformar.\n    B (str): La cadena objetivo a alcanzar.\n    rules (list of tuples): Una lista de reglas de transformación, donde cada regla es una tupla\n                            que contiene la subcadena fuente (a ser reemplazada) y la\n                            subcadena objetivo (para reemplazar con).\n\n    Retorna:\n    Union[int, str]: El número mínimo de pasos de transformación si es posible, de lo contrario \"NO ANSWER!\".\n\n    Ejemplos:\n    Caso 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) debería devolver 3.\n\n    Caso 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) debería devolver \"NO ANSWER!\" porque la transformación\n    no es posible dentro de 10 pasos.\n\n    Caso 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) debería devolver 3, ya que cada carácter se reemplaza\n    individualmente.\n    \"\"\"", "arb": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    تنفيذ تحويل سلسلة من A إلى B باستخدام مجموعة من قواعد التحويل.\n\n    تأخذ هذه الدالة سلسلة ابتدائية A وسلسلة هدف B، مع قائمة من قواعد التحويل،\n    وتحاول تحويل A إلى B باستخدام القواعد. يتم استخدام خوارزمية البحث بعرض أول\n    (BFS) لاستكشاف التحويلات الممكنة حتى حد أقصى 10 خطوات. إذا كان بالإمكان\n    تحويل A إلى B في غضون 10 خطوات، تُرجع الدالة الحد الأدنى لعدد الخطوات المطلوبة.\n    إذا لم يكن ذلك ممكنًا، تُرجع الدالة \"NO ANSWER!\".\n\n    المعلمات:\n    A (str): السلسلة الابتدائية التي سيتم تحويلها.\n    B (str): السلسلة الهدف التي يجب تحقيقها.\n    rules (list of tuples): قائمة بقواعد التحويل، حيث كل قاعدة هي زوج يحتوي\n                            على السلسلة الفرعية المصدر (التي سيتم استبدالها)\n                            والسلسلة الفرعية الهدف (التي سيتم الاستبدال بها).\n\n    العوائد:\n    Union[int, str]: الحد الأدنى لعدد خطوات التحويل إذا كان ممكنًا، وإلا \"NO ANSWER!\".\n\n    أمثلة:\n    الحالة 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) يجب أن تُرجع 3.\n\n    الحالة 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) يجب أن تُرجع \"NO ANSWER!\" لأن التحويل\n    غير ممكن في غضون 10 خطوات.\n\n    الحالة 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) يجب أن تُرجع 3، حيث يتم استبدال كل حرف\n    على حدة.\n    \"\"\"", "sw": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Fanya mabadiliko ya kamba kutoka A hadi B kwa kutumia seti ya sheria za mabadiliko.\n\n    Kazi hii inachukua kamba ya awali A na kamba lengwa B, pamoja na orodha\n    ya sheria za mabadiliko, na inajaribu kubadilisha A kuwa B kwa kutumia sheria hizo.\n    Algorithimu ya Utafutaji wa Upana Kwanza (BFS) inatumika kuchunguza mabadiliko yanayowezekana\n    hadi kiwango cha juu cha hatua 10. Ikiwa A inaweza kubadilishwa kuwa B ndani ya hatua 10,\n    kazi inarejesha idadi ndogo ya hatua zinazohitajika. Ikiwa haiwezekani, kazi inarejesha\n    \"NO ANSWER!\".\n\n    Vigezo:\n    A (str): Kamba ya awali inayopaswa kubadilishwa.\n    B (str): Kamba lengwa inayopaswa kufikiwa.\n    rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria ni jozi\n                            inayojumuisha sehemu ya kamba ya chanzo (inayopaswa kubadilishwa) na\n                            sehemu ya kamba lengwa (ya kubadilisha nayo).\n\n    Inarejesha:\n    Union[int, str]: Idadi ndogo ya hatua za mabadiliko ikiwa inawezekana, vinginevyo \"NO ANSWER!\".\n\n    Mifano:\n    Kesi 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) inapaswa kurejesha 3.\n\n    Kesi 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) inapaswa kurejesha \"NO ANSWER!\" kwa sababu mabadiliko\n    hayawezekani ndani ya hatua 10.\n\n    Kesi 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) inapaswa kurejesha 3, kwani kila herufi inabadilishwa\n    kibinafsi.\n    \"\"\"", "tr": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    A'yı B'ye bir dizi dönüşüm kuralı kullanarak dönüştürme işlemi yapar.\n\n    Bu fonksiyon, başlangıç dizgesi A ve hedef dizgesi B'yi, dönüşüm kuralları listesiyle birlikte alır\n    ve A'yı B'ye kuralları kullanarak dönüştürmeye çalışır. Olası dönüşümleri keşfetmek için\n    10 adımın maksimumuna kadar bir Genişlik Öncelikli Arama (BFS) algoritması kullanılır. \n    Eğer A, B'ye 10 adım içinde dönüştürülebilirse, fonksiyon gereken minimum adım sayısını döndürür. \n    Eğer mümkün değilse, fonksiyon \"NO ANSWER!\" döndürür.\n\n    Parametreler:\n    A (str): Dönüştürülecek başlangıç dizgesi.\n    B (str): Elde edilmesi gereken hedef dizgesi.\n    rules (list of tuples): Her kuralın kaynak alt dizgeyi (değiştirilecek) ve\n                            hedef alt dizgeyi (değiştirilecek olan) içeren bir liste.\n\n    Döndürür:\n    Union[int, str]: Mümkünse minimum dönüşüm adım sayısı, aksi takdirde \"NO ANSWER!\".\n\n    Örnekler:\n    Durum 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) 3 döndürmelidir.\n\n    Durum 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) \"NO ANSWER!\" döndürmelidir çünkü dönüşüm\n    10 adım içinde mümkün değildir.\n\n    Durum 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) 3 döndürmelidir, çünkü her karakter\n    ayrı ayrı değiştirilir.\n    \"\"\"", "vi": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Thực hiện chuyển đổi chuỗi từ A sang B bằng cách sử dụng một tập hợp các quy tắc chuyển đổi.\n\n    Hàm này nhận một chuỗi ban đầu A và một chuỗi mục tiêu B, cùng với một danh sách\n    các quy tắc chuyển đổi, và cố gắng chuyển đổi A thành B bằng cách sử dụng các quy tắc.\n    Thuật toán Tìm kiếm theo chiều rộng (BFS) được sử dụng để khám phá các chuyển đổi có thể\n    lên đến tối đa 10 bước. Nếu A có thể được chuyển đổi thành B trong vòng 10 bước, hàm sẽ\n    trả về số bước tối thiểu cần thiết. Nếu không thể, hàm sẽ trả về \"NO ANSWER!\".\n\n    Tham số:\n    A (str): Chuỗi ban đầu cần được chuyển đổi.\n    B (str): Chuỗi mục tiêu cần đạt được.\n    rules (list of tuples): Danh sách các quy tắc chuyển đổi, trong đó mỗi quy tắc là một tuple\n                            chứa chuỗi con nguồn (để được thay thế) và chuỗi con đích (để thay thế).\n\n    Trả về:\n    Union[int, str]: Số bước chuyển đổi tối thiểu nếu có thể, nếu không thì \"NO ANSWER!\".\n\n    Ví dụ:\n    Trường hợp 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) nên trả về 3.\n\n    Trường hợp 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) nên trả về \"NO ANSWER!\" vì chuyển đổi\n    không thể thực hiện trong vòng 10 bước.\n\n    Trường hợp 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) nên trả về 3, vì mỗi ký tự được thay thế\n    riêng lẻ.\n    \"\"\"", "id": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Melakukan transformasi string dari A ke B menggunakan serangkaian aturan transformasi.\n\n    Fungsi ini mengambil string awal A dan string target B, bersama dengan daftar\n    aturan transformasi, dan mencoba untuk mengubah A menjadi B menggunakan aturan-aturan tersebut.\n    Algoritma Breadth-First Search (BFS) digunakan untuk mengeksplorasi kemungkinan transformasi\n    hingga maksimum 10 langkah. Jika A dapat diubah menjadi B dalam 10 langkah, fungsi\n    mengembalikan jumlah langkah minimum yang diperlukan. Jika tidak mungkin, fungsi mengembalikan\n    \"NO ANSWER!\".\n\n    Parameter:\n    A (str): String awal yang akan diubah.\n    B (str): String target yang ingin dicapai.\n    rules (list of tuples): Daftar aturan transformasi, di mana setiap aturan adalah tuple\n                            yang berisi substring sumber (yang akan diganti) dan\n                            substring target (untuk menggantikan).\n\n    Mengembalikan:\n    Union[int, str]: Jumlah langkah transformasi minimum jika memungkinkan, jika tidak \"NO ANSWER!\".\n\n    Contoh:\n    Kasus 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) seharusnya mengembalikan 3.\n\n    Kasus 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) seharusnya mengembalikan \"NO ANSWER!\" karena transformasi\n    tidak mungkin dalam 10 langkah.\n\n    Kasus 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) seharusnya mengembalikan 3, karena setiap karakter diganti\n    secara individual.\n    \"\"\"", "ja": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    一連の変換ルールを使用して、AからBへの文字列変換を実行します。\n\n    この関数は、初期文字列Aとターゲット文字列B、および変換ルールのリストを受け取り、\n    ルールを使用してAをBに変換しようとします。\n    幅優先探索（BFS）アルゴリズムを使用して、最大10ステップまでの可能な変換を探索します。\n    Aが10ステップ以内にBに変換できる場合、関数は必要な最小ステップ数を返します。\n    変換が不可能な場合、関数は\"NO ANSWER!\"を返します。\n\n    パラメータ:\n    A (str): 変換される初期文字列。\n    B (str): 達成されるべきターゲット文字列。\n    rules (list of tuples): 変換ルールのリストで、各ルールは置換されるソース部分文字列と\n                            置換後のターゲット部分文字列を含むタプルです。\n\n    戻り値:\n    Union[int, str]: 変換が可能な場合は最小の変換ステップ数、それ以外の場合は\"NO ANSWER!\"。\n\n    例:\n    ケース 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) は3を返すべきです。\n\n    ケース 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) は\"NO ANSWER!\"を返すべきです。なぜなら、10ステップ以内に\n    変換が不可能だからです。\n\n    ケース 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) は3を返すべきです。各文字が個別に置換されるためです。\n    \"\"\"", "ko": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    주어진 변환 규칙을 사용하여 문자열 A를 B로 변환합니다.\n\n    이 함수는 초기 문자열 A와 목표 문자열 B, 그리고 변환 규칙의 리스트를 받아서,\n    A를 B로 변환하려고 시도합니다. 너비 우선 탐색(BFS) 알고리즘을 사용하여\n    최대 10단계까지 가능한 변환을 탐색합니다. A가 10단계 이내에 B로 변환될 수 있으면,\n    함수는 필요한 최소 단계 수를 반환합니다. 불가능할 경우, 함수는 \"NO ANSWER!\"를 반환합니다.\n\n    매개변수:\n    A (str): 변환할 초기 문자열.\n    B (str): 목표로 하는 문자열.\n    rules (list of tuples): 변환 규칙의 리스트로, 각 규칙은 변환할 소스 부분 문자열(대체할 부분)과\n                            대체할 목표 부분 문자열을 포함하는 튜플입니다.\n\n    반환값:\n    Union[int, str]: 변환이 가능할 경우 최소 변환 단계 수, 그렇지 않으면 \"NO ANSWER!\".\n\n    예시:\n    사례 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules)는 3을 반환해야 합니다.\n\n    사례 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules)는 \"NO ANSWER!\"를 반환해야 합니다. 왜냐하면\n    10단계 이내에 변환이 불가능하기 때문입니다.\n\n    사례 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules)는 3을 반환해야 합니다. 각 문자가 개별적으로\n    대체되기 때문입니다.\n    \"\"\"", "ml": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    ഒരു സെറ്റ് ട്രാൻസ്ഫോർമേഷൻ നിയമങ്ങൾ ഉപയോഗിച്ച് A-യിൽ നിന്ന് B-യിലേക്ക് സ്ട്രിംഗ് ട്രാൻസ്ഫോർമേഷൻ നടത്തുക.\n\n    ഈ ഫംഗ്ഷൻ ഒരു പ്രാരംഭ സ്ട്രിംഗ് A, ഒരു ലക്ഷ്യ സ്ട്രിംഗ് B, കൂടാതെ ട്രാൻസ്ഫോർമേഷൻ നിയമങ്ങളുടെ ഒരു ലിസ്റ്റ് എടുക്കുന്നു,\n    നിയമങ്ങൾ ഉപയോഗിച്ച് A-നെ B-യിലേക്ക് മാറ്റാൻ ശ്രമിക്കുന്നു. പരമാവധി 10 ഘട്ടങ്ങൾ വരെ\n    സാധ്യതയുള്ള ട്രാൻസ്ഫോർമേഷനുകൾ അന്വേഷിക്കാൻ ബ്രെഡ്ത്ത്-ഫസ്റ്റ് സെർച്ച് (BFS) ആൽഗോരിതം ഉപയോഗിക്കുന്നു.\n    10 ഘട്ടങ്ങൾക്കുള്ളിൽ A-നെ B-യിലേക്ക് മാറ്റാൻ കഴിയുമെങ്കിൽ, ആവശ്യമായ\n    കുറഞ്ഞ ഘട്ടങ്ങളുടെ എണ്ണം ഫംഗ്ഷൻ തിരികെ നൽകുന്നു. ഇത് സാധ്യമല്ലെങ്കിൽ, ഫംഗ്ഷൻ\n    \"NO ANSWER!\" തിരികെ നൽകുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    A (str): മാറ്റേണ്ട പ്രാരംഭ സ്ട്രിംഗ്.\n    B (str): കൈവരിക്കേണ്ട ലക്ഷ്യ സ്ട്രിംഗ്.\n    rules (list of tuples): ഓരോ നിയമവും ഒരു ട്യൂപ്പിള്‍ ആയിട്ടുള്ള ട്രാൻസ്ഫോർമേഷൻ നിയമങ്ങളുടെ ഒരു ലിസ്റ്റ്,\n                            ഉറവിട സബ്സ്ട്രിംഗ് (മാറ്റേണ്ടത്) കൂടാതെ\n                            ലക്ഷ്യ സബ്സ്ട്രിംഗ് (മാറ്റേണ്ടത്) അടങ്ങിയിരിക്കുന്നു.\n\n    Returns:\n    Union[int, str]: സാധ്യമായ കുറഞ്ഞ ട്രാൻസ്ഫോർമേഷൻ ഘട്ടങ്ങൾ, അല്ലെങ്കിൽ \"NO ANSWER!\".\n\n    ഉദാഹരണങ്ങൾ:\n    കേസ് 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) 3 തിരികെ നൽകണം.\n\n    കേസ് 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) \"NO ANSWER!\" തിരികെ നൽകണം കാരണം\n    10 ഘട്ടങ്ങൾക്കുള്ളിൽ ട്രാൻസ്ഫോർമേഷൻ സാധ്യമല്ല.\n\n    കേസ് 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) 3 തിരികെ നൽകണം, ഓരോ പ്രതീകവും\n    വ്യക്തിഗതമായി മാറ്റപ്പെടുന്നു.\n    \"\"\"", "fa": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    انجام تبدیل رشته از A به B با استفاده از مجموعه‌ای از قوانین تبدیل.\n\n    این تابع یک رشته اولیه A و یک رشته هدف B را به همراه لیستی از قوانین\n    تبدیل می‌گیرد و تلاش می‌کند A را با استفاده از قوانین به B تبدیل کند.\n    یک الگوریتم جستجوی اول سطح (BFS) برای بررسی تبدیل‌های ممکن تا حداکثر\n    ۱۰ مرحله استفاده می‌شود. اگر A بتواند در ۱۰ مرحله به B تبدیل شود، تابع\n    حداقل تعداد مراحل مورد نیاز را برمی‌گرداند. اگر این کار ممکن نباشد، تابع\n    \"NO ANSWER!\" را برمی‌گرداند.\n\n    پارامترها:\n    A (str): رشته اولیه‌ای که باید تبدیل شود.\n    B (str): رشته هدفی که باید به آن دست یافت.\n    rules (list of tuples): لیستی از قوانین تبدیل که هر قانون یک تاپل شامل\n                             زیررشته منبع (که باید جایگزین شود) و زیررشته هدف\n                             (که باید جایگزین کند) است.\n\n    بازگشت:\n    Union[int, str]: حداقل تعداد مراحل تبدیل در صورت امکان، در غیر این صورت \"NO ANSWER!\".\n\n    مثال‌ها:\n    مورد 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) باید 3 را برگرداند.\n\n    مورد 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) باید \"NO ANSWER!\" را برگرداند زیرا تبدیل\n    در ۱۰ مرحله ممکن نیست.\n\n    مورد 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) باید 3 را برگرداند، زیرا هر کاراکتر به\n    صورت جداگانه جایگزین می‌شود.\n    \"\"\""}, "canonical_solution": "\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"", "instruction": {"en": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nনিচের পাইথন কোডের একটি সংক্ষিপ্ত ন্যাচারাল ল্যাঙ্গুয়েজ বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, সর্বাধিক ৫০০ অক্ষর ব্যবহার করে।", "bg": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar Python a Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (docstring) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.", "sw": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) untuk kode Python dalam bahasa Indonesia dengan menggunakan maksimal 500 karakter.", "ja": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\n以下のPythonコードに対して、500文字以内で簡潔な自然言語の説明（ドックストリング）を日本語で提供してください。", "ko": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\n다음 Python 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성합니다.", "ml": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_string_transformation():\n    # Test case 1\n    A1 = \"abcd\"\n    B1 = \"xyz\"\n    rules1 = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    expected_result1 = 3\n    assert string_transformation(A1, B1, rules1) == expected_result1, \"Test case 1 failed\"\n\n    # Test case 2\n    A2 = \"aaa\"\n    B2 = \"bbbb\"\n    rules2 = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    expected_result2 = \"NO ANSWER!\"\n    assert string_transformation(A2, B2, rules2) == expected_result2, \"Test case 2 failed\"\n\n    # Test case 3\n    A3 = \"hello\"\n    B3 = \"world\"\n    rules3 = [(\"h\", \"w\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"lol\", \"ldr\")]\n    expected_result3 = \"NO ANSWER!\"\n    assert string_transformation(A3, B3, rules3) == expected_result3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_string_transformation()", "entry_point": "string_transformation", "signature": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:", "docstring": {"en": "Perform string transformation from A to B using a set of transformation rules.\n\nThis function takes an initial string A and a target string B, along with a list\nof transformation rules, and attempts to transform A into B using the rules.\nA Breadth-First Search (BFS) algorithm is used to explore the possible transformations\nup to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\nreturns the minimum number of steps required. If it's not possible, the function returns\n\"NO ANSWER!\".\n\nParameters:\nA (str): The initial string to be transformed.\nB (str): The target string to be achieved.\nrules (list of tuples): A list of transformation rules, where each rule is a tuple\ncontaining the source substring (to be replaced) and the\ntarget substring (to replace with).\n\nReturns:\nUnion[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\nExamples:\nCase 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) should return 3.\n\nCase 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\nis not possible within 10 steps.\n\nCase 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) should return 3, as each character is replaced\nindividually.", "sq": "Kryeni transformimin e vargut nga A në B duke përdorur një grup rregullash transformimi.\n\nKjo funksion merr një varg fillestar A dhe një varg synim B, së bashku me një listë\nrregullash transformimi, dhe përpiqet të transformojë A në B duke përdorur rregullat.\nNjë algoritëm Kërkimi në Gjerësi (BFS) përdoret për të eksploruar transformimet e mundshme\nderi në një maksimum prej 10 hapash. Nëse A mund të transformohet në B brenda 10 hapash, funksioni\nkthehet numrin minimal të hapave të kërkuar. Nëse nuk është e mundur, funksioni kthen\n\"NUK KA PËRGJIGJE!\".\n\nParametrat:\nA (str): Vargu fillestar që do të transformohet.\nB (str): Vargu synim që do të arrihet.\nrules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull është një tuple\nqë përmban nënvargun burim (që do të zëvendësohet) dhe\nnënvargun synim (me të cilin do të zëvendësohet).\n\nKthen:\nUnion[int, str]: Numri minimal i hapave të transformimit nëse është e mundur, përndryshe \"NUK KA PËRGJIGJE!\".\n\nShembuj:\nRasti 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) duhet të kthejë 3.\n\nRasti 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) duhet të kthejë \"NUK KA PËRGJIGJE!\" sepse transformimi\nnuk është i mundur brenda 10 hapash.\n\nRasti 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) duhet të kthejë 3, pasi çdo karakter zëvendësohet\nindividualisht.", "hy": "Տարածել տողերի փոխակերպում A-ից B օգտագործելով փոխակերպման կանոնների հավաքածու:\n\nԱյս ֆունկցիան ընդունում է սկզբնական տող A և նպատակային տող B, ինչպես նաև փոխակերպման կանոնների ցուցակ, և փորձում է փոխակերպել A-ն B-ի օգտագործելով կանոնները: Լայնության-առաջին որոնման (BFS) ալգորիթմը օգտագործվում է հնարավոր փոխակերպումները ուսումնասիրելու համար առավելագույնը 10 քայլով: Եթե A-ն կարող է փոխակերպվել B-ի 10 քայլի ընթացքում, ֆունկցիան վերադարձնում է պահանջվող նվազագույն քայլերի քանակը: Եթե դա հնարավոր չէ, ֆունկցիան վերադարձնում է \"NO ANSWER!\":\n\nՊարամետրեր:\nA (str): Սկզբնական տողը, որը պետք է փոխակերպվի:\nB (str): Նպատակային տողը, որը պետք է ստացվի:\nrules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն տողակազմ է, որը պարունակում է աղբյուր ենթատողը (որը պետք է փոխարինվի) և նպատակային ենթատողը (որով պետք է փոխարինվի):\n\nՎերադարձնում է:\nUnion[int, str]: Փոխակերպման նվազագույն քայլերի քանակը, եթե հնարավոր է, հակառակ դեպքում \"NO ANSWER!\":\n\nՕրինակներ:\nԴեպք 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) պետք է վերադարձնի 3:\n\nԴեպք 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) պետք է վերադարձնի \"NO ANSWER!\" քանի որ փոխակերպումը հնարավոր չէ 10 քայլի ընթացքում:\n\nԴեպք 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) պետք է վերադարձնի 3, քանի որ յուրաքանչյուր նիշ փոխարինվում է առանձին:", "bn": "স্ট্রিং রূপান্তর A থেকে B তে একটি সেট রূপান্তর নিয়ম ব্যবহার করে সম্পাদন করুন।\n\nএই ফাংশনটি একটি প্রাথমিক স্ট্রিং A এবং একটি লক্ষ্য স্ট্রিং B গ্রহণ করে, একটি রূপান্তর নিয়মের তালিকার সাথে, এবং নিয়মগুলি ব্যবহার করে A কে B তে রূপান্তর করার চেষ্টা করে। একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) অ্যালগরিদম ব্যবহার করা হয় সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে সর্বাধিক ১০ ধাপ পর্যন্ত। যদি A কে ১০ ধাপের মধ্যে B তে রূপান্তর করা যায়, তাহলে ফাংশনটি প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা প্রদান করে। যদি এটি সম্ভব না হয়, তাহলে ফাংশনটি \"NO ANSWER!\" প্রদান করে।\n\nপ্যারামিটারসমূহ:\nA (str): প্রাথমিক স্ট্রিং যা রূপান্তরিত হবে।\nB (str): লক্ষ্য স্ট্রিং যা অর্জন করতে হবে।\nrules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টিউপল\nযা উৎস সাবস্ট্রিং (প্রতিস্থাপন করার জন্য) এবং লক্ষ্য সাবস্ট্রিং (যা দিয়ে প্রতিস্থাপন করা হবে) ধারণ করে।\n\nরিটার্নস:\nUnion[int, str]: রূপান্তর ধাপের সর্বনিম্ন সংখ্যা যদি সম্ভব হয়, অন্যথায় \"NO ANSWER!\".\n\nউদাহরণসমূহ:\nকেস ১:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) ৩ প্রদান করা উচিত।\n\nকেস ২:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) \"NO ANSWER!\" প্রদান করা উচিত কারণ রূপান্তর\n১০ ধাপের মধ্যে সম্ভব নয়।\n\nকেস ৩:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) ৩ প্রদান করা উচিত, কারণ প্রতিটি অক্ষর পৃথকভাবে প্রতিস্থাপিত হয়।", "bg": "Извършете трансформация на низ от A до B, използвайки набор от правила за трансформация.\n\nТази функция приема начален низ A и целеви низ B, заедно със списък от правила за трансформация, и се опитва да трансформира A в B, използвайки правилата. Използва се алгоритъм за търсене в ширина (BFS), за да се изследват възможните трансформации до максимум 10 стъпки. Ако A може да бъде трансформиран в B в рамките на 10 стъпки, функцията връща минималния брой необходими стъпки. Ако не е възможно, функцията връща \"NO ANSWER!\".\n\nПараметри:\nA (str): Началният низ, който ще бъде трансформиран.\nB (str): Целевият низ, който трябва да бъде постигнат.\nrules (list of tuples): Списък от правила за трансформация, където всяко правило е кортеж, съдържащ изходния подниз (който ще бъде заменен) и целевия подниз (с който ще се замени).\n\nВръща:\nUnion[int, str]: Минималният брой стъпки за трансформация, ако е възможно, в противен случай \"NO ANSWER!\".\n\nПримери:\nСлучай 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) трябва да върне 3.\n\nСлучай 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) трябва да върне \"NO ANSWER!\", защото трансформацията\nне е възможна в рамките на 10 стъпки.\n\nСлучай 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) трябва да върне 3, тъй като всеки символ се заменя\nиндивидуално.", "zh": "执行字符串从 A 到 B 的转换，使用一组转换规则。\n\n此函数接收一个初始字符串 A 和一个目标字符串 B，以及一个转换规则列表，并尝试使用这些规则将 A 转换为 B。使用广度优先搜索（BFS）算法来探索可能的转换，最多进行 10 步。如果 A 可以在 10 步内转换为 B，函数返回所需的最小步骤数。如果不可能，函数返回 \"NO ANSWER!\"。\n\n参数：\nA (str): 要转换的初始字符串。\nB (str): 要达到的目标字符串。\nrules (list of tuples): 转换规则列表，其中每个规则是一个包含源子字符串（要替换的）和目标子字符串（用于替换）的元组。\n\n返回：\nUnion[int, str]: 如果可能，返回最小的转换步骤数，否则返回 \"NO ANSWER!\"。\n\n示例：\n案例 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) 应返回 3。\n\n案例 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) 应返回 \"NO ANSWER!\" 因为在 10 步内无法完成转换。\n\n案例 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) 应返回 3，因为每个字符被单独替换。", "fr": "Effectuer une transformation de chaîne de A à B en utilisant un ensemble de règles de transformation.\n\nCette fonction prend une chaîne initiale A et une chaîne cible B, ainsi qu'une liste\nde règles de transformation, et tente de transformer A en B en utilisant les règles.\nUn algorithme de recherche en largeur (BFS) est utilisé pour explorer les transformations possibles\njusqu'à un maximum de 10 étapes. Si A peut être transformé en B en 10 étapes, la fonction\nrenvoie le nombre minimum d'étapes nécessaires. Si ce n'est pas possible, la fonction renvoie\n\"PAS DE RÉPONSE!\".\n\nParamètres:\nA (str): La chaîne initiale à transformer.\nB (str): La chaîne cible à atteindre.\nrules (list of tuples): Une liste de règles de transformation, où chaque règle est un tuple\ncontenant la sous-chaîne source (à remplacer) et la\nsous-chaîne cible (par laquelle remplacer).\n\nRenvoie:\nUnion[int, str]: Le nombre minimum d'étapes de transformation si possible, sinon \"PAS DE RÉPONSE!\".\n\nExemples:\nCas 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) devrait renvoyer 3.\n\nCas 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) devrait renvoyer \"PAS DE RÉPONSE!\" car la transformation\nn'est pas possible en 10 étapes.\n\nCas 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) devrait renvoyer 3, car chaque caractère est remplacé\nindividuellement.", "de": "Führe eine Zeichenketten-Transformation von A nach B unter Verwendung eines Satzes von Transformationsregeln durch.\n\nDiese Funktion nimmt eine Anfangszeichenkette A und eine Zielzeichenkette B, zusammen mit einer Liste von Transformationsregeln, und versucht, A mithilfe der Regeln in B zu transformieren. Ein Breitensuche-Algorithmus (BFS) wird verwendet, um die möglichen Transformationen bis zu einem Maximum von 10 Schritten zu erkunden. Wenn A innerhalb von 10 Schritten in B transformiert werden kann, gibt die Funktion die minimale Anzahl der erforderlichen Schritte zurück. Wenn es nicht möglich ist, gibt die Funktion \"KEINE ANTWORT!\" zurück.\n\nParameter:\nA (str): Die anfängliche Zeichenkette, die transformiert werden soll.\nB (str): Die Zielzeichenkette, die erreicht werden soll.\nrules (list of tuples): Eine Liste von Transformationsregeln, wobei jede Regel ein Tupel ist, das das Quell-Substring (das ersetzt werden soll) und das Ziel-Substring (mit dem ersetzt werden soll) enthält.\n\nRückgabewerte:\nUnion[int, str]: Die minimale Anzahl der Transformationsschritte, wenn möglich, andernfalls \"KEINE ANTWORT!\".\n\nBeispiele:\nFall 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) sollte 3 zurückgeben.\n\nFall 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) sollte \"KEINE ANTWORT!\" zurückgeben, da die Transformation innerhalb von 10 Schritten nicht möglich ist.\n\nFall 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) sollte 3 zurückgeben, da jedes Zeichen einzeln ersetzt wird.", "ha": "Ai aikata sauyin kirtani daga A zuwa B ta amfani da saitin dokokin sauyi.\n\nWannan aikin yana ɗaukar kirtani na farko A da kirtani na manufa B, tare da jerin\ndokokin sauyi, kuma yana ƙoƙarin sauya A zuwa B ta amfani da dokokin.\nAna amfani da dabarar Binciken Fadada (BFS) don bincika yiwuwar sauye-sauye\nhar zuwa matakai 10 na iyaka. Idan za a iya sauya A zuwa B a cikin matakai 10, aikin\nyana mayar da mafi ƙarancin adadin matakan da ake bukata. Idan ba zai yiwu ba, aikin yana mayar da\n\"BA AMSA!\".\n\nSigogi:\nA (str): Kirtani na farko da za a sauya.\nB (str): Kirtani na manufa da za a cimma.\nrules (list of tuples): Jerin dokokin sauyi, inda kowanne doka yake da tuple\nmai ɗauke da kirtani na asali (da za a maye gurbinsa) da\nkirtani na manufa (da za a maye gurbi da shi).\n\nMayarwa:\nUnion[int, str]: Mafi ƙarancin adadin matakan sauyi idan zai yiwu, in ba haka ba \"BA AMSA!\".\n\nMisalai:\nMisali 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) ya kamata ya mayar da 3.\n\nMisali 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) ya kamata ya mayar da \"BA AMSA!\" saboda sauyi\nba zai yiwu ba a cikin matakai 10.\n\nMisali 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) ya kamata ya mayar da 3, domin kowane harafi an maye\ngurbinsa daya bayan daya.", "hi": "आरंभिक स्ट्रिंग A से B में परिवर्तन करने के लिए परिवर्तन नियमों का उपयोग करें।\n\nयह फ़ंक्शन एक प्रारंभिक स्ट्रिंग A और एक लक्ष्य स्ट्रिंग B लेता है, साथ ही एक सूची\nरूपांतरण नियमों की, और नियमों का उपयोग करके A को B में बदलने का प्रयास करता है।\nसंभावित रूपांतरणों का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) एल्गोरिदम का उपयोग किया जाता है\nअधिकतम 10 चरणों तक। यदि A को 10 चरणों के भीतर B में बदला जा सकता है, तो फ़ंक्शन\nआवश्यक न्यूनतम चरणों की संख्या लौटाता है। यदि यह संभव नहीं है, तो फ़ंक्शन\n\"NO ANSWER!\" लौटाता है।\n\nParameters:\nA (str): प्रारंभिक स्ट्रिंग जिसे रूपांतरित किया जाना है।\nB (str): लक्ष्य स्ट्रिंग जिसे प्राप्त करना है।\nrules (list of tuples): रूपांतरण नियमों की एक सूची, जहाँ प्रत्येक नियम एक टपल है\nजिसमें स्रोत सबस्ट्रिंग (जिसे बदला जाना है) और\nलक्ष्य सबस्ट्रिंग (जिससे बदलना है) शामिल है।\n\nReturns:\nUnion[int, str]: न्यूनतम रूपांतरण चरणों की संख्या यदि संभव हो, अन्यथा \"NO ANSWER!\".\n\nExamples:\nCase 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) को 3 लौटाना चाहिए।\n\nCase 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) को \"NO ANSWER!\" लौटाना चाहिए क्योंकि रूपांतरण\n10 चरणों के भीतर संभव नहीं है।\n\nCase 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) को 3 लौटाना चाहिए, क्योंकि प्रत्येक अक्षर को\nव्यक्तिगत रूप से बदला जाता है।", "hu": "Végezzen karakterlánc átalakítást A-ból B-be egy halmaz transzformációs szabály segítségével.\n\nEz a függvény egy kezdeti A karakterláncot és egy cél B karakterláncot, valamint egy lista\ntranszformációs szabályt vesz át, és megpróbálja A-t B-vé alakítani a szabályok használatával.\nEgy Szélességi Első Keresés (BFS) algoritmust használunk a lehetséges átalakítások\nfeltárására legfeljebb 10 lépésig. Ha A 10 lépésen belül átalakítható B-vé, a függvény\nvisszaadja a szükséges minimális lépések számát. Ha nem lehetséges, a függvény\n\"NO ANSWER!\"-t ad vissza.\n\nParaméterek:\nA (str): Az átalakítandó kezdeti karakterlánc.\nB (str): Az elérendő cél karakterlánc.\nrules (list of tuples): Egy lista transzformációs szabályokkal, ahol minden szabály egy\nforrás részkarakterláncot tartalmaz (amit ki kell cserélni) és a\ncél részkarakterláncot (amire ki kell cserélni).\n\nVisszatérési érték:\nUnion[int, str]: A minimális átalakítási lépések száma, ha lehetséges, különben \"NO ANSWER!\".\n\nPéldák:\n1. eset:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) vissza kell adnia 3.\n\n2. eset:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) vissza kell adnia \"NO ANSWER!\", mert az átalakítás\nnem lehetséges 10 lépésen belül.\n\n3. eset:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) vissza kell adnia 3, mivel minden karakter egyenként van kicserélve.", "es": "Realizar la transformación de cadena de A a B utilizando un conjunto de reglas de transformación.\n\nEsta función toma una cadena inicial A y una cadena objetivo B, junto con una lista\nde reglas de transformación, e intenta transformar A en B usando las reglas.\nSe utiliza un algoritmo de Búsqueda en Anchura (BFS) para explorar las posibles transformaciones\nhasta un máximo de 10 pasos. Si A puede transformarse en B dentro de 10 pasos, la función\ndevuelve el número mínimo de pasos requeridos. Si no es posible, la función devuelve\n\"¡SIN RESPUESTA!\".\n\nParámetros:\nA (str): La cadena inicial a transformar.\nB (str): La cadena objetivo a lograr.\nrules (list of tuples): Una lista de reglas de transformación, donde cada regla es una tupla\nque contiene la subcadena fuente (a ser reemplazada) y la\nsubcadena objetivo (con la que se reemplaza).\n\nDevuelve:\nUnion[int, str]: El número mínimo de pasos de transformación si es posible, de lo contrario \"¡SIN RESPUESTA!\".\n\nEjemplos:\nCaso 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) debería devolver 3.\n\nCaso 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) debería devolver \"¡SIN RESPUESTA!\" porque la transformación\nno es posible dentro de 10 pasos.\n\nCaso 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) debería devolver 3, ya que cada carácter se reemplaza\nindividualmente.", "arb": "إجراء تحويل سلسلة من A إلى B باستخدام مجموعة من قواعد التحويل.\n\nتأخذ هذه الدالة سلسلة ابتدائية A وسلسلة مستهدفة B، بالإضافة إلى قائمة\nمن قواعد التحويل، وتحاول تحويل A إلى B باستخدام القواعد.\nيتم استخدام خوارزمية البحث بعرض أول (BFS) لاستكشاف التحويلات الممكنة\nحتى حد أقصى من 10 خطوات. إذا كان بالإمكان تحويل A إلى B في غضون 10 خطوات، فإن الدالة\nتعيد الحد الأدنى لعدد الخطوات المطلوبة. إذا لم يكن ذلك ممكنًا، فإن الدالة تعيد\n\"لا يوجد جواب!\".\n\nالمعلمات:\nA (str): السلسلة الابتدائية المراد تحويلها.\nB (str): السلسلة المستهدفة المراد تحقيقها.\nrules (list of tuples): قائمة بقواعد التحويل، حيث تكون كل قاعدة عبارة عن زوج\nيحتوي على الجزء الفرعي المصدر (الذي سيتم استبداله) و\nالجزء الفرعي الهدف (الذي سيتم الاستبدال به).\n\nالقيم المعادة:\nUnion[int, str]: الحد الأدنى لعدد خطوات التحويل إذا كان ذلك ممكنًا، وإلا \"لا يوجد جواب!\".\n\nأمثلة:\nالحالة 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) يجب أن تعيد 3.\n\nالحالة 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) يجب أن تعيد \"لا يوجد جواب!\" لأن التحويل\nغير ممكن في غضون 10 خطوات.\n\nالحالة 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) يجب أن تعيد 3، حيث يتم استبدال كل حرف\nبشكل فردي.", "sw": "Fanya mabadiliko ya kamba kutoka A hadi B kwa kutumia seti ya sheria za mabadiliko.\n\nKazi hii inachukua kamba ya awali A na kamba lengwa B, pamoja na orodha\nya sheria za mabadiliko, na inajaribu kubadilisha A kuwa B kwa kutumia sheria hizo.\nAlgoriti ya Utafutaji wa Upana Kwanza (BFS) inatumika kuchunguza mabadiliko yanayowezekana\nhadi hatua 10 za juu zaidi. Ikiwa A inaweza kubadilishwa kuwa B ndani ya hatua 10, kazi\ninarudisha idadi ndogo ya hatua zinazohitajika. Ikiwa haiwezekani, kazi inarudisha\n\"HAKUNA JIBU!\".\n\nVigezo:\nA (str): Kamba ya awali inayopaswa kubadilishwa.\nB (str): Kamba lengwa inayopaswa kufikiwa.\nrules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria ni jozi\ninayojumuisha sehemu ndogo ya chanzo (inayopaswa kubadilishwa) na\nsehemu ndogo ya lengwa (ya kubadilisha nayo).\n\nInarudisha:\nMuungano[int, str]: Idadi ndogo ya hatua za mabadiliko ikiwa inawezekana, vinginevyo \"HAKUNA JIBU!\".\n\nMifano:\nKesi ya 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) inapaswa kurudisha 3.\n\nKesi ya 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) inapaswa kurudisha \"HAKUNA JIBU!\" kwa sababu mabadiliko\nhayanawezekana ndani ya hatua 10.\n\nKesi ya 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) inapaswa kurudisha 3, kwani kila herufi inabadilishwa\nindividually.", "tr": "A'yı B'ye bir dizi dönüşüm kuralı kullanarak dönüştürme işlemi yapar.\n\nBu fonksiyon, başlangıç ​​dizesi A ve hedef dize B'yi, dönüşüm kuralları listesiyle birlikte alır ve A'yı B'ye dönüştürmeye çalışır. Olası dönüşümleri keşfetmek için Genişlik Öncelikli Arama (BFS) algoritması kullanılır ve maksimum 10 adıma kadar araştırılır. Eğer A, 10 adım içinde B'ye dönüştürülebilirse, fonksiyon gereken minimum adım sayısını döndürür. Eğer mümkün değilse, fonksiyon \"NO ANSWER!\" döndürür.\n\nParametreler:\nA (str): Dönüştürülecek başlangıç ​​dizesi.\nB (str): Elde edilmesi gereken hedef dize.\nrules (list of tuples): Her kuralın, kaynak alt dize (değiştirilecek) ve hedef alt dizeyi (yerine konulacak) içeren bir demet olduğu dönüşüm kuralları listesi.\n\nDöndürür:\nUnion[int, str]: Mümkünse dönüşüm adımlarının minimum sayısı, aksi takdirde \"NO ANSWER!\".\n\nÖrnekler:\nDurum 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) 3 döndürmelidir.\n\nDurum 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) 10 adım içinde dönüşüm mümkün olmadığından \"NO ANSWER!\" döndürmelidir.\n\nDurum 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) her karakter ayrı ayrı değiştirildiği için 3 döndürmelidir.", "vi": "Thực hiện chuyển đổi chuỗi từ A sang B bằng cách sử dụng một tập hợp các quy tắc chuyển đổi.\n\nHàm này nhận một chuỗi ban đầu A và một chuỗi đích B, cùng với một danh sách\ncác quy tắc chuyển đổi, và cố gắng chuyển đổi A thành B bằng cách sử dụng các quy tắc.\nThuật toán Tìm kiếm theo chiều rộng (BFS) được sử dụng để khám phá các chuyển đổi có thể\ntối đa là 10 bước. Nếu A có thể được chuyển đổi thành B trong vòng 10 bước, hàm\ntrả về số bước tối thiểu cần thiết. Nếu không thể, hàm trả về\n\"NO ANSWER!\".\n\nTham số:\nA (str): Chuỗi ban đầu cần được chuyển đổi.\nB (str): Chuỗi đích cần đạt được.\nrules (list of tuples): Một danh sách các quy tắc chuyển đổi, trong đó mỗi quy tắc là một bộ\nchứa chuỗi con nguồn (để thay thế) và\nchuỗi con đích (để thay thế bằng).\n\nTrả về:\nUnion[int, str]: Số bước chuyển đổi tối thiểu nếu có thể, nếu không thì \"NO ANSWER!\".\n\nVí dụ:\nTrường hợp 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) sẽ trả về 3.\n\nTrường hợp 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) sẽ trả về \"NO ANSWER!\" vì chuyển đổi\nkhông thể thực hiện trong vòng 10 bước.\n\nTrường hợp 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) sẽ trả về 3, vì mỗi ký tự được thay thế\nriêng lẻ.", "id": "Melakukan transformasi string dari A ke B menggunakan serangkaian aturan transformasi.\n\nFungsi ini mengambil string awal A dan string target B, bersama dengan daftar\naturan transformasi, dan mencoba untuk mentransformasikan A menjadi B menggunakan aturan-aturan tersebut.\nAlgoritma Breadth-First Search (BFS) digunakan untuk menjelajahi kemungkinan transformasi\nhingga maksimum 10 langkah. Jika A dapat ditransformasikan menjadi B dalam 10 langkah, fungsi\nmengembalikan jumlah langkah minimum yang diperlukan. Jika tidak mungkin, fungsi mengembalikan\n\"NO ANSWER!\".\n\nParameter:\nA (str): String awal yang akan ditransformasikan.\nB (str): String target yang ingin dicapai.\nrules (list of tuples): Daftar aturan transformasi, di mana setiap aturan adalah sebuah tuple\nyang berisi substring sumber (yang akan diganti) dan\nsubstring target (untuk menggantikan).\n\nMengembalikan:\nUnion[int, str]: Jumlah langkah transformasi minimum jika memungkinkan, jika tidak \"NO ANSWER!\".\n\nContoh:\nKasus 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) seharusnya mengembalikan 3.\n\nKasus 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) seharusnya mengembalikan \"NO ANSWER!\" karena transformasi\ntidak mungkin dalam 10 langkah.\n\nKasus 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) seharusnya mengembalikan 3, karena setiap karakter diganti\nsecara individual.", "ja": "文字列変換をAからBに、変換ルールのセットを使用して行います。\n\nこの関数は初期文字列Aと目標文字列B、および変換ルールのリストを受け取り、Aをルールを使用してBに変換しようとします。幅優先探索（BFS）アルゴリズムを使用して、最大10ステップまでの可能な変換を探索します。Aが10ステップ以内にBに変換できる場合、関数は必要な最小ステップ数を返します。変換が不可能な場合、関数は\"NO ANSWER!\"を返します。\n\n引数:\nA (str): 変換される初期文字列。\nB (str): 達成される目標文字列。\nrules (list of tuples): 変換ルールのリストで、各ルールは置換されるソース部分文字列と\n置換後のターゲット部分文字列を含むタプルです。\n\n戻り値:\nUnion[int, str]: 変換が可能な場合は最小の変換ステップ数、それ以外の場合は\"NO ANSWER!\"。\n\n例:\nケース1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) は3を返すべきです。\n\nケース2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) は\"NO ANSWER!\"を返すべきです。なぜなら、変換は10ステップ以内に不可能だからです。\n\nケース3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) は3を返すべきです。各文字が個別に置換されるためです。", "ko": "문자열 변환 규칙 집합을 사용하여 A에서 B로 문자열 변환을 수행합니다.\n\n이 함수는 초기 문자열 A와 목표 문자열 B, 그리고 변환 규칙 목록을 받아서 A를 규칙을 사용하여 B로 변환하려고 시도합니다. 너비 우선 탐색(BFS) 알고리즘을 사용하여 최대 10단계까지 가능한 변환을 탐색합니다. 만약 A를 10단계 이내에 B로 변환할 수 있다면, 함수는 필요한 최소 단계 수를 반환합니다. 불가능한 경우, 함수는 \"NO ANSWER!\"를 반환합니다.\n\n매개변수:\nA (str): 변환할 초기 문자열입니다.\nB (str): 달성할 목표 문자열입니다.\nrules (list of tuples): 변환 규칙 목록으로, 각 규칙은 소스 부분 문자열(교체할 부분)과\n대상 부분 문자열(교체할 내용)을 포함하는 튜플입니다.\n\n반환값:\nUnion[int, str]: 가능하다면 최소 변환 단계 수, 그렇지 않으면 \"NO ANSWER!\".\n\n예시:\n사례 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules)는 3을 반환해야 합니다.\n\n사례 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules)는 \"NO ANSWER!\"를 반환해야 합니다. 왜냐하면 변환이 10단계 이내에 불가능하기 때문입니다.\n\n사례 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules)는 각 문자가 개별적으로 교체되므로 3을 반환해야 합니다.", "ml": "A മുതൽ B വരെ ഒരു സെറ്റ് ട്രാൻസ്ഫർമേഷൻ നിയമങ്ങൾ ഉപയോഗിച്ച് സ്ട്രിംഗ് ട്രാൻസ്ഫർമേഷൻ നടത്തുക.\n\nഈ ഫംഗ്ഷൻ ഒരു പ്രാഥമിക സ്ട്രിംഗ് A, ഒരു ലക്ഷ്യ സ്ട്രിംഗ് B, കൂടാതെ ഒരു ട്രാൻസ്ഫർമേഷൻ നിയമങ്ങളുടെ പട്ടിക എടുക്കുന്നു, നിയമങ്ങൾ ഉപയോഗിച്ച് A നെ B ആക്കാൻ ശ്രമിക്കുന്നു. ഒരു ബ്രെഡ്ത്ത്-ഫസ്റ്റ് സെർച്ച് (BFS) ആൽഗോരിതം പരമാവധി 10 ഘട്ടങ്ങൾ വരെ സാധ്യതയുള്ള ട്രാൻസ്ഫർമേഷനുകൾ അന്വേഷിക്കാൻ ഉപയോഗിക്കുന്നു. A നെ 10 ഘട്ടങ്ങൾക്കുള്ളിൽ B ആക്കാൻ കഴിയുമെങ്കിൽ, ഫംഗ്ഷൻ ആവശ്യമായ കുറഞ്ഞ ഘട്ടങ്ങളുടെ എണ്ണം തിരികെ നൽകുന്നു. അത് സാധ്യമല്ലെങ്കിൽ, ഫംഗ്ഷൻ \"NO ANSWER!\" തിരികെ നൽകുന്നു.\n\nParameters:\nA (str): മാറ്റപ്പെടേണ്ട പ്രാഥമിക സ്ട്രിംഗ്.\nB (str): കൈവരിക്കേണ്ട ലക്ഷ്യ സ്ട്രിംഗ്.\nrules (list of tuples): ഓരോ നിയമവും മാറ്റപ്പെടേണ്ട സോഴ്‌സ് സബ്സ്ട്രിംഗ് (മാറ്റേണ്ടത്) \nമറ്റും മാറ്റാനുള്ള ലക്ഷ്യ സബ്സ്ട്രിംഗ് (മാറ്റുക) എന്നിവ അടങ്ങിയ ഒരു ട്രാൻസ്ഫർമേഷൻ നിയമങ്ങളുടെ പട്ടിക.\n\nReturns:\nUnion[int, str]: സാധ്യമായെങ്കിൽ കുറഞ്ഞ ട്രാൻസ്ഫർമേഷൻ ഘട്ടങ്ങളുടെ എണ്ണം, അല്ലെങ്കിൽ \"NO ANSWER!\".\n\nExamples:\nCase 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) 3 തിരികെ നൽകണം.\n\nCase 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) \"NO ANSWER!\" തിരികെ നൽകണം കാരണം 10 ഘട്ടങ്ങൾക്കുള്ളിൽ\nട്രാൻസ്ഫർമേഷൻ സാധ്യമല്ല.\n\nCase 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) 3 തിരികെ നൽകണം, കാരണം ഓരോ അക്ഷരവും വ്യക്തിപരമായി\nമാറ്റപ്പെടുന്നു.", "fa": "انجام تبدیل رشته از A به B با استفاده از مجموعه‌ای از قوانین تبدیل.\n\nاین تابع یک رشته اولیه A و یک رشته هدف B را به همراه یک لیست از قوانین تبدیل می‌گیرد و تلاش می‌کند A را با استفاده از قوانین به B تبدیل کند. یک الگوریتم جستجوی اول سطح (BFS) برای بررسی تبدیل‌های ممکن تا حداکثر ۱۰ مرحله استفاده می‌شود. اگر A بتواند در ۱۰ مرحله به B تبدیل شود، تابع حداقل تعداد مراحل مورد نیاز را برمی‌گرداند. اگر این کار ممکن نباشد، تابع \"NO ANSWER!\" را برمی‌گرداند.\n\nپارامترها:\nA (str): رشته اولیه که باید تبدیل شود.\nB (str): رشته هدف که باید به آن دست یافت.\nrules (list of tuples): لیستی از قوانین تبدیل، که هر قانون یک زوج شامل زیررشته منبع (برای جایگزینی) و زیررشته هدف (برای جایگزینی با آن) است.\n\nبازگشتی:\nUnion[int, str]: حداقل تعداد مراحل تبدیل در صورت امکان، در غیر این صورت \"NO ANSWER!\".\n\nمثال‌ها:\nمورد 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) باید 3 را برگرداند.\n\nمورد 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) باید \"NO ANSWER!\" را برگرداند زیرا تبدیل در ۱۰ مرحله ممکن نیست.\n\nمورد 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) باید 3 را برگرداند، زیرا هر کاراکتر به صورت جداگانه جایگزین می‌شود."}}
{"task_id": "Python/29", "prompt": {"en": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    The sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    The sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.\n    \"\"\"", "sq": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Llogarit numrin më të vogël pozitiv n të tillë që shuma e serisë harmonike\n    deri në 1/n është më e madhe se një numër i dhënë pozitiv k.\n\n    Seria harmonike është e përcaktuar si S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentet:\n    - k (int): Një numër i plotë pozitiv që përfaqëson vlerën prag që shuma e serisë harmonike duhet të tejkalojë.\n\n    Kthen:\n    - int: Numri më i vogël n për të cilin shuma e serisë harmonike S_n tejkalon pragun k.\n\n    Shembuj:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Shuma S_2 = 1 + 1/2 = 1.5, e cila është më e madhe se 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Shuma S_10 = 1 + 1/2 + 1/3 + ... + 1/10 është më e vogël ose e barabartë me 3, por shuma S_11 tejkalon 3.\n    \"\"\"", "hy": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Հաշվել ամենափոքր դրական ամբողջ թիվը n, այնպես, որ հարմոնիկ շարքի \n    1/n-ով սահմանափակված գումարը մեծ լինի տրված դրական ամբողջ թիվ k-ից։\n\n    Հարմոնիկ շարքը սահմանվում է որպես S_n = 1 + 1/2 + 1/3 + ... + 1/n։\n\n    Արգումենտներ:\n    - k (int): Դրական ամբողջ թիվ, որը ներկայացնում է շեմի արժեքը, որը հարմոնիկ շարքի գումարը պետք է գերազանցի։\n\n    Վերադարձնում է:\n    - int: Ամենափոքր թիվը n, որի համար հարմոնիկ շարքի գումարը S_n գերազանցում է շեմը k։\n\n    Օրինակներ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Գումարը S_2 = 1 + 1/2 = 1.5, որը մեծ է 1-ից։\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Գումարը S_10 = 1 + 1/2 + 1/3 + ... + 1/10 փոքր կամ հավասար է 3-ին, բայց գումարը S_11 գերազանցում է 3-ը։\n    \"\"\"", "bn": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    হরমোনিক সিরিজের যোগফল 1/n পর্যন্ত একটি প্রদত্ত ধনাত্মক পূর্ণসংখ্যা k এর চেয়ে বড় এমন ক্ষুদ্রতম ধনাত্মক পূর্ণসংখ্যা n গণনা করুন।\n\n    হরমোনিক সিরিজ সংজ্ঞায়িত করা হয় S_n = 1 + 1/2 + 1/3 + ... + 1/n হিসাবে।\n\n    আর্গুমেন্টসমূহ:\n    - k (int): একটি ধনাত্মক পূর্ণসংখ্যা যা হরমোনিক সিরিজের যোগফলকে অতিক্রম করতে হবে এমন সীমা মান উপস্থাপন করে।\n\n    রিটার্নস:\n    - int: ক্ষুদ্রতম পূর্ণসংখ্যা n যার জন্য হরমোনিক সিরিজের যোগফল S_n সীমা k অতিক্রম করে।\n\n    উদাহরণ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    যোগফল S_2 = 1 + 1/2 = 1.5, যা 1 এর চেয়ে বড়।\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    যোগফল S_10 = 1 + 1/2 + 1/3 + ... + 1/10 3 এর চেয়ে কম বা সমান, কিন্তু যোগফল S_11 3 অতিক্রম করে।\n    \"\"\"", "bg": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Изчислява най-малкото положително цяло число n, такова че сумата на хармоничната редица\n    до 1/n е по-голяма от дадено положително цяло число k.\n\n    Хармоничната редица е дефинирана като S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Аргументи:\n    - k (int): Положително цяло число, представляващо праговата стойност, която сумата на хармоничната редица трябва да надвиши.\n\n    Връща:\n    - int: Най-малкото цяло число n, за което сумата на хармоничната редица S_n надвишава прага k.\n\n    Примери:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Сумата S_2 = 1 + 1/2 = 1.5, което е по-голямо от 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Сумата S_10 = 1 + 1/2 + 1/3 + ... + 1/10 е по-малка или равна на 3, но сумата S_11 надвишава 3.\n    \"\"\"", "zh": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    计算最小的正整数 n，使得调和级数的和\n    达到 1/n 时大于给定的正整数 k。\n\n    调和级数定义为 S_n = 1 + 1/2 + 1/3 + ... + 1/n。\n\n    参数:\n    - k (int): 表示调和级数和必须超过的阈值的正整数。\n\n    返回:\n    - int: 调和级数和 S_n 超过阈值 k 的最小整数 n。\n\n    示例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    和 S_2 = 1 + 1/2 = 1.5，大于 1。\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    和 S_10 = 1 + 1/2 + 1/3 + ... + 1/10 小于或等于 3，但和 S_11 超过 3。\n    \"\"\"", "fr": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculer le plus petit entier positif n tel que la somme de la série harmonique\n    jusqu'à 1/n soit supérieure à un entier positif donné k.\n\n    La série harmonique est définie comme S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Un entier positif représentant la valeur seuil que la somme de la série harmonique doit dépasser.\n\n    Returns:\n    - int: Le plus petit entier n pour lequel la somme de la série harmonique S_n dépasse le seuil k.\n\n    Exemples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    La somme S_2 = 1 + 1/2 = 1.5, qui est supérieure à 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    La somme S_10 = 1 + 1/2 + 1/3 + ... + 1/10 est inférieure ou égale à 3, mais la somme S_11 dépasse 3.\n    \"\"\"", "de": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Berechne die kleinste positive ganze Zahl n, sodass die Summe der harmonischen Reihe\n    bis 1/n größer ist als eine gegebene positive ganze Zahl k.\n\n    Die harmonische Reihe ist definiert als S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumente:\n    - k (int): Eine positive ganze Zahl, die den Schwellenwert darstellt, den die Summe der harmonischen Reihe überschreiten muss.\n\n    Rückgabewerte:\n    - int: Die kleinste ganze Zahl n, für die die Summe der harmonischen Reihe S_n den Schwellenwert k überschreitet.\n\n    Beispiele:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Die Summe S_2 = 1 + 1/2 = 1.5, die größer als 1 ist.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Die Summe S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ist kleiner oder gleich 3, aber die Summe S_11 überschreitet 3.\n    \"\"\"", "ha": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Lissafi mafi ƙarancin lamba mai kyau n wanda hakan jimillar jerin harmonic\n    har zuwa 1/n ya fi wani lamba mai kyau k.\n\n    Jerin harmonic ana bayyana shi kamar haka S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Lamba mai kyau da ke wakiltar ƙimar iyaka da jimillar jerin harmonic dole ne ta wuce.\n\n    Returns:\n    - int: Mafi ƙarancin lamba n wanda jimillar jerin harmonic S_n ta wuce iyaka k.\n\n    Misalai:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Jimillar S_2 = 1 + 1/2 = 1.5, wanda ya fi 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Jimillar S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ya yi ƙasa ko daidai da 3, amma jimillar S_11 ta wuce 3.\n    \"\"\"", "hi": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    सबसे छोटा धनात्मक पूर्णांक n गणना करें ताकि हार्मोनिक श्रेणी का योग\n    1/n तक दिए गए धनात्मक पूर्णांक k से अधिक हो।\n\n    हार्मोनिक श्रेणी को S_n = 1 + 1/2 + 1/3 + ... + 1/n के रूप में परिभाषित किया गया है।\n\n    तर्क:\n    - k (int): एक धनात्मक पूर्णांक जो उस सीमा मान का प्रतिनिधित्व करता है जिसे हार्मोनिक श्रेणी का योग पार करना चाहिए।\n\n    वापसी:\n    - int: सबसे छोटा पूर्णांक n जिसके लिए हार्मोनिक श्रेणी का योग S_n सीमा k से अधिक हो जाता है।\n\n    उदाहरण:\n    >>> find_min_n_greater_than_k(1)\n    2\n    योग S_2 = 1 + 1/2 = 1.5 है, जो 1 से अधिक है।\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    योग S_10 = 1 + 1/2 + 1/3 + ... + 1/10 3 से कम या बराबर है, लेकिन योग S_11 3 से अधिक हो जाता है।\n    \"\"\"", "hu": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Számítsa ki a legkisebb pozitív egész számot n, amelyre a harmonikus sorozat\n    1/n-ig terjedő összege nagyobb, mint egy adott pozitív egész szám k.\n\n    A harmonikus sorozat definíciója: S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentumok:\n    - k (int): Egy pozitív egész szám, amely a küszöbértéket jelöli, amelyet a harmonikus sorozat összegének meg kell haladnia.\n\n    Visszatér:\n    - int: A legkisebb egész szám n, amelyre a harmonikus sorozat összege S_n meghaladja a k küszöbértéket.\n\n    Példák:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Az összeg S_2 = 1 + 1/2 = 1.5, amely nagyobb, mint 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Az összeg S_10 = 1 + 1/2 + 1/3 + ... + 1/10 kisebb vagy egyenlő, mint 3, de az összeg S_11 meghaladja a 3-at.\n    \"\"\"", "es": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calcula el entero positivo más pequeño n tal que la suma de la serie armónica\n    hasta 1/n es mayor que un entero positivo dado k.\n\n    La serie armónica se define como S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentos:\n    - k (int): Un entero positivo que representa el valor umbral que la suma de la serie armónica debe exceder.\n\n    Devuelve:\n    - int: El entero más pequeño n para el cual la suma de la serie armónica S_n excede el umbral k.\n\n    Ejemplos:\n    >>> find_min_n_greater_than_k(1)\n    2\n    La suma S_2 = 1 + 1/2 = 1.5, que es mayor que 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    La suma S_10 = 1 + 1/2 + 1/3 + ... + 1/10 es menor o igual a 3, pero la suma S_11 excede 3.\n    \"\"\"", "arb": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    حساب أصغر عدد صحيح موجب n بحيث يكون مجموع السلسلة التوافقية\n    حتى 1/n أكبر من عدد صحيح موجب معين k.\n\n    تُعرّف السلسلة التوافقية كالتالي S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    يعيدالحجج:\n    - k (int): عدد صحيح موجب يمثل قيمة العتبة التي يجب أن يتجاوزها مجموع السلسلة التوافقية.\n\n    يعيد:\n    - int: أصغر عدد صحيح n حيث يتجاوز مجموع السلسلة التوافقية S_n العتبة k.\n\n    أمثلة:\n    >>> find_min_n_greater_than_k(1)\n    2\n    المجموع S_2 = 1 + 1/2 = 1.5، وهو أكبر من 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    المجموع S_10 = 1 + 1/2 + 1/3 + ... + 1/10 أقل من أو يساوي 3، لكن المجموع S_11 يتجاوز 3.\n    \"\"\"", "sw": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Hesabu namba ndogo kabisa chanya n kiasi kwamba jumla ya mfululizo wa harmonic\n    hadi 1/n ni kubwa kuliko namba chanya iliyotolewa k.\n\n    Mfululizo wa harmonic unafafanuliwa kama S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Hoja:\n    - k (int): Namba chanya inayowakilisha thamani ya kizingiti ambacho jumla ya mfululizo wa harmonic lazima izidi.\n\n    Inarejesha:\n    - int: Namba ndogo kabisa n ambayo jumla ya mfululizo wa harmonic S_n inazidi kizingiti k.\n\n    Mifano:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Jumla S_2 = 1 + 1/2 = 1.5, ambayo ni kubwa kuliko 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Jumla S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ni ndogo au sawa na 3, lakini jumla S_11 inazidi 3.\n    \"\"\"", "tr": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Harmonik serinin toplamının 1/n'ye kadar olan kısmının\n    verilen pozitif bir tamsayı k'dan büyük olması için en küçük pozitif tamsayı n'yi hesaplayın.\n\n    Harmonik seri S_n = 1 + 1/2 + 1/3 + ... + 1/n olarak tanımlanır.\n\n    Argümanlar:\n    - k (int): Harmonik seri toplamının aşması gereken eşik değerini temsil eden pozitif bir tamsayı.\n\n    Dönüş:\n    - int: Harmonik seri toplamı S_n'nin eşik k değerini aştığı en küçük tamsayı n.\n\n    Örnekler:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Toplam S_2 = 1 + 1/2 = 1.5, bu 1'den büyüktür.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Toplam S_10 = 1 + 1/2 + 1/3 + ... + 1/10, 3'ten küçük veya eşittir, ancak toplam S_11, 3'ü aşar.\n    \"\"\"", "vi": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Tính toán số nguyên dương nhỏ nhất n sao cho tổng của chuỗi điều hòa\n    lên đến 1/n lớn hơn một số nguyên dương cho trước k.\n\n    Chuỗi điều hòa được định nghĩa là S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Tham số:\n    - k (int): Một số nguyên dương đại diện cho giá trị ngưỡng mà tổng chuỗi điều hòa phải vượt qua.\n\n    Trả về:\n    - int: Số nguyên nhỏ nhất n sao cho tổng chuỗi điều hòa S_n vượt qua ngưỡng k.\n\n    Ví dụ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Tổng S_2 = 1 + 1/2 = 1.5, lớn hơn 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Tổng S_10 = 1 + 1/2 + 1/3 + ... + 1/10 nhỏ hơn hoặc bằng 3, nhưng tổng S_11 vượt qua 3.\n    \"\"\"", "id": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Hitung bilangan bulat positif terkecil n sehingga jumlah deret harmonik\n    hingga 1/n lebih besar dari bilangan bulat positif k yang diberikan.\n\n    Deret harmonik didefinisikan sebagai S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumen:\n    - k (int): Bilangan bulat positif yang mewakili nilai ambang yang harus dilampaui oleh jumlah deret harmonik.\n\n    Mengembalikan:\n    - int: Bilangan bulat terkecil n di mana jumlah deret harmonik S_n melebihi ambang k.\n\n    Contoh:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Jumlah S_2 = 1 + 1/2 = 1.5, yang lebih besar dari 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Jumlah S_10 = 1 + 1/2 + 1/3 + ... + 1/10 kurang dari atau sama dengan 3, tetapi jumlah S_11 melebihi 3.\n    \"\"\"", "ja": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    与えられた正の整数 k よりも大きい調和級数の和が得られるような最小の正の整数 n を計算します。\n\n    調和級数は S_n = 1 + 1/2 + 1/3 + ... + 1/n と定義されます。\n\n    引数:\n    - k (int): 調和級数の和が超えなければならない閾値を表す正の整数。\n\n    戻り値:\n    - int: 調和級数の和 S_n が閾値 k を超える最小の整数 n。\n\n    例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    和 S_2 = 1 + 1/2 = 1.5 は 1 より大きい。\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    和 S_10 = 1 + 1/2 + 1/3 + ... + 1/10 は 3 以下ですが、和 S_11 は 3 を超えます。\n    \"\"\"", "ko": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    주어진 양의 정수 k보다 큰 조화급수의 합을 갖는 가장 작은 양의 정수 n을 계산합니다.\n\n    조화급수는 S_n = 1 + 1/2 + 1/3 + ... + 1/n으로 정의됩니다.\n\n    매개변수:\n    - k (int): 조화급수의 합이 초과해야 하는 임계값을 나타내는 양의 정수입니다.\n\n    반환값:\n    - int: 조화급수의 합 S_n이 임계값 k를 초과하는 가장 작은 정수 n입니다.\n\n    예시:\n    >>> find_min_n_greater_than_k(1)\n    2\n    합 S_2 = 1 + 1/2 = 1.5, 이는 1보다 큽니다.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    합 S_10 = 1 + 1/2 + 1/3 + ... + 1/10은 3보다 작거나 같지만, 합 S_11은 3을 초과합니다.\n    \"\"\"", "ml": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    ഹാർമോണിക് ശ്രേണിയുടെ തുക 1/n വരെ നൽകിയിരിക്കുന്ന ധനാത്മക പൂർണ്ണസംഖ്യ k-നെക്കാൾ കൂടുതലായതായ ഏറ്റവും ചെറിയ\n    ധനാത്മക പൂർണ്ണസംഖ്യ n കണക്കാക്കുക.\n\n    ഹാർമോണിക് ശ്രേണി S_n = 1 + 1/2 + 1/3 + ... + 1/n എന്ന രീതിയിൽ നിർവചിച്ചിരിക്കുന്നു.\n\n    Args:\n    - k (int): ഹാർമോണിക് ശ്രേണിയുടെ തുക കവിഞ്ഞിരിക്കേണ്ടത് പ്രതിനിധീകരിക്കുന്ന ഒരു ധനാത്മക പൂർണ്ണസംഖ്യ.\n\n    Returns:\n    - int: ഹാർമോണിക് ശ്രേണിയുടെ തുക S_n പ്രതിബന്ധമായ k-നെക്കാൾ കൂടുതലാകുന്ന ഏറ്റവും ചെറിയ പൂർണ്ണസംഖ്യ n.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    തുക S_2 = 1 + 1/2 = 1.5, ഇത് 1-നെക്കാൾ കൂടുതലാണ്.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    തുക S_10 = 1 + 1/2 + 1/3 + ... + 1/10 3-നേക്കാൾ കുറവോ തുല്യമോ ആണ്, പക്ഷേ തുക S_11 3-നെക്കാൾ കൂടുതലാണ്.\n    \"\"\"", "fa": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    کوچکترین عدد صحیح مثبت n را محاسبه کنید به طوری که مجموع سری هارمونیک\n    تا 1/n بزرگتر از یک عدد صحیح مثبت داده شده k باشد.\n\n    سری هارمونیک به صورت S_n = 1 + 1/2 + 1/3 + ... + 1/n تعریف می‌شود.\n\n    آرگومان‌ها:\n    - k (int): یک عدد صحیح مثبت که نشان‌دهنده مقدار آستانه‌ای است که مجموع سری هارمونیک باید از آن بیشتر شود.\n\n    بازگشت:\n    - int: کوچکترین عدد صحیح n که مجموع سری هارمونیک S_n از آستانه k بیشتر شود.\n\n    مثال‌ها:\n    >>> find_min_n_greater_than_k(1)\n    2\n    مجموع S_2 = 1 + 1/2 = 1.5 است که بزرگتر از 1 است.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    مجموع S_10 = 1 + 1/2 + 1/3 + ... + 1/10 کمتر یا مساوی 3 است، اما مجموع S_11 از 3 بیشتر است.\n    \"\"\""}, "canonical_solution": "# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1", "instruction": {"en": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nনিচের পাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।", "bg": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\n请用中文为以下 Python 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nGeben Sie eine prägnante Beschreibung des Python-Codes in natürlicher Sprache auf Deutsch mit maximal 500 Zeichen an.", "ha": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\n最大 500 文字を使用して、英語で Python コードの簡潔な自然言語説明 (docstring) を提供します。", "ko": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\n최대 500자를 사용하여 Python 코드에 대한 간결한 자연어 설명(docstring)을 영어로 제공하세요.", "ml": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഇല്ലാത്ത ഒരു സംക്ഷിപ്ത സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_find_min_n_greater_than_k():\n    # Test case 1: k = 1, expected result is 2\n\n    assert find_min_n_greater_than_k(1) == 2, \"Test case 1 failed.\"\n\n    # Test case 2: k = 3, expected result is 11\n    assert find_min_n_greater_than_k(3) == 11, \"Test case 2 failed.\"\n    # Test case 3: k = 5, expected result is 83\n    assert find_min_n_greater_than_k(5) == 83, \"Test case 3 failed.\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_find_min_n_greater_than_k()", "entry_point": "find_min_n_greater_than_k", "signature": "def find_min_n_greater_than_k(k: int) -> int:", "docstring": {"en": "Calculate the smallest positive integer n such that the sum of the harmonic series\nup to 1/n is greater than a given positive integer k.\n\nThe harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\nReturns:\n- int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nThe sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nThe sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.", "sq": "Llogarit numrin më të vogël pozitiv n të tillë që shuma e serisë harmonike\nderi në 1/n është më e madhe se një numër i dhënë pozitiv k.\n\nSeria harmonike është e përcaktuar si S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgumentet:\n- k (int): Një numër i plotë pozitiv që përfaqëson vlerën prag që shuma e serisë harmonike duhet të tejkalojë.\n\nKthen:\n- int: Numri më i vogël n për të cilin shuma e serisë harmonike S_n tejkalon pragun k.\n\nShembuj:\n>>> find_min_n_greater_than_k(1)\n2\nShuma S_2 = 1 + 1/2 = 1.5, e cila është më e madhe se 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nShuma S_10 = 1 + 1/2 + 1/3 + ... + 1/10 është më e vogël ose e barabartë me 3, por shuma S_11 tejkalon 3.", "hy": "Հաշվել ամենափոքր դրական ամբողջ թիվը n, այնպես որ հարմոնիկ շարքի գումարը\nմինչև 1/n մեծ լինի տրված դրական ամբողջ թիվ k-ից։\n\nՀարմոնիկ շարքը սահմանվում է որպես S_n = 1 + 1/2 + 1/3 + ... + 1/n։\n\nԱրգումենտներ:\n- k (int): Դրական ամբողջ թիվ, որը ներկայացնում է շեմի արժեքը, որը հարմոնիկ շարքի գումարը պետք է գերազանցի։\n\nՎերադարձնում է:\n- int: Ամենափոքր ամբողջ թիվը n, որի համար հարմոնիկ շարքի գումարը S_n գերազանցում է շեմը k։\n\nՕրինակներ:\n>>> find_min_n_greater_than_k(1)\n2\nԳումարը S_2 = 1 + 1/2 = 1.5, որը մեծ է 1-ից։\n\n>>> find_min_n_greater_than_k(3)\n11\nԳումարը S_10 = 1 + 1/2 + 1/3 + ... + 1/10 փոքր կամ հավասար է 3, բայց գումարը S_11 գերազանցում է 3։", "bn": "হরমোনিক সিরিজের যোগফল 1/n পর্যন্ত একটি প্রদত্ত ধনাত্মক পূর্ণসংখ্যা k এর চেয়ে বড় এমন ক্ষুদ্রতম ধনাত্মক পূর্ণসংখ্যা n গণনা করুন।\n\nহারমোনিক সিরিজটি সংজ্ঞায়িত করা হয় S_n = 1 + 1/2 + 1/3 + ... + 1/n হিসাবে।\n\nআর্গস:\n- k (int): একটি ধনাত্মক পূর্ণসংখ্যা যা হারমোনিক সিরিজের যোগফলকে অতিক্রম করতে হবে এমন থ্রেশহোল্ড মানকে উপস্থাপন করে।\n\nরিটার্নস:\n- int: ক্ষুদ্রতম পূর্ণসংখ্যা n যার জন্য হারমোনিক সিরিজের যোগফল S_n থ্রেশহোল্ড k অতিক্রম করে।\n\nউদাহরণ:\n>>> find_min_n_greater_than_k(1)\n2\nযোগফল S_2 = 1 + 1/2 = 1.5, যা 1 এর চেয়ে বড়।\n\n>>> find_min_n_greater_than_k(3)\n11\nযোগফল S_10 = 1 + 1/2 + 1/3 + ... + 1/10 3 এর চেয়ে ছোট বা সমান, কিন্তু যোগফল S_11 3 অতিক্রম করে।", "bg": "Изчислете най-малкото положително цяло число n, такова че сумата на хармоничната редица\nдо 1/n да е по-голяма от дадено положително цяло число k.\n\nХармоничната редица е дефинирана като S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nАргументи:\n- k (int): Положително цяло число, представляващо праговата стойност, която сумата на хармоничната редица трябва да надвиши.\n\nВръща:\n- int: Най-малкото цяло число n, за което сумата на хармоничната редица S_n надвишава прага k.\n\nПримери:\n>>> find_min_n_greater_than_k(1)\n2\nСумата S_2 = 1 + 1/2 = 1.5, която е по-голяма от 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nСумата S_10 = 1 + 1/2 + 1/3 + ... + 1/10 е по-малка или равна на 3, но сумата S_11 надвишава 3.", "zh": "计算最小的正整数 n，使得调和级数从 1 到 1/n 的和大于给定的正整数 k。\n\n调和级数定义为 S_n = 1 + 1/2 + 1/3 + ... + 1/n。\n\n参数：\n- k (int): 一个正整数，表示调和级数和必须超过的阈值。\n\n返回：\n- int: 使调和级数和 S_n 超过阈值 k 的最小整数 n。\n\n示例：\n>>> find_min_n_greater_than_k(1)\n2\n和 S_2 = 1 + 1/2 = 1.5，大于 1。\n\n>>> find_min_n_greater_than_k(3)\n11\n和 S_10 = 1 + 1/2 + 1/3 + ... + 1/10 小于或等于 3，但和 S_11 超过 3。", "fr": "Calculer le plus petit entier positif n tel que la somme de la série harmonique\njusqu'à 1/n soit supérieure à un entier positif donné k.\n\nLa série harmonique est définie comme S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): Un entier positif représentant la valeur seuil que la somme de la série harmonique doit dépasser.\n\nReturns:\n- int: Le plus petit entier n pour lequel la somme de la série harmonique S_n dépasse le seuil k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nLa somme S_2 = 1 + 1/2 = 1.5, qui est supérieure à 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nLa somme S_10 = 1 + 1/2 + 1/3 + ... + 1/10 est inférieure ou égale à 3, mais la somme S_11 dépasse 3.", "de": "Berechne die kleinste positive ganze Zahl n, so dass die Summe der harmonischen Reihe\nbis 1/n größer als eine gegebene positive ganze Zahl k ist.\n\nDie harmonische Reihe ist definiert als S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): Eine positive ganze Zahl, die den Schwellenwert darstellt, den die Summe der harmonischen Reihe überschreiten muss.\n\nReturns:\n- int: Die kleinste ganze Zahl n, für die die Summe der harmonischen Reihe S_n den Schwellenwert k überschreitet.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nDie Summe S_2 = 1 + 1/2 = 1.5, die größer als 1 ist.\n\n>>> find_min_n_greater_than_k(3)\n11\nDie Summe S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ist kleiner oder gleich 3, aber die Summe S_11 überschreitet 3.", "ha": "Lissafi mafi ƙarancin lamba mai kyau n wanda hakan jimillar jerin harmonic\nhar zuwa 1/n ya fi wani lamba mai kyau k.\n\nHarmonic series ana ayyana shi azaman S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): Wani cikakken lamba mai kyau wanda ke wakiltar ƙimar ƙofa da jumlar jerin harmonic dole ne ta wuce.\n\nReturns:\n- int: Mafi ƙarancin lamba n wanda jumlar jerin harmonic S_n ta wuce ƙimar ƙofa k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nJumlar S_2 = 1 + 1/2 = 1.5, wanda ya fi 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nJumlar S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ya yi ƙasa ko daidai da 3, amma jumlar S_11 ta wuce 3.", "hi": "सबसे छोटा धनात्मक पूर्णांक n गणना करें ताकि हार्मोनिक श्रेणी का योग\n1/n तक दिए गए धनात्मक पूर्णांक k से अधिक हो।\n\nहरमोनिक श्रेणी को S_n = 1 + 1/2 + 1/3 + ... + 1/n के रूप में परिभाषित किया गया है।\n\nArgs:\n- k (int): एक धनात्मक पूर्णांक जो उस सीमा मान का प्रतिनिधित्व करता है जिसे हरमोनिक श्रेणी का योग पार करना चाहिए।\n\nReturns:\n- int: सबसे छोटा पूर्णांक n जिसके लिए हरमोनिक श्रेणी का योग S_n सीमा k को पार कर जाता है।\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nयोग S_2 = 1 + 1/2 = 1.5 है, जो 1 से अधिक है।\n\n>>> find_min_n_greater_than_k(3)\n11\nयोग S_10 = 1 + 1/2 + 1/3 + ... + 1/10, 3 से कम या बराबर है, लेकिन योग S_11, 3 को पार कर जाता है।", "hu": "Számítsd ki a legkisebb pozitív egész számot n, amelyre a harmonikus sorozat\n1/n-ig terjedő összege nagyobb, mint egy adott pozitív egész szám k.\n\nA harmonikus sorozatot így definiáljuk: S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): Egy pozitív egész szám, amely a küszöbértéket jelenti, amelyet a harmonikus sorozat összegének meg kell haladnia.\n\nReturns:\n- int: A legkisebb egész szám n, amelyre a harmonikus sorozat összege S_n meghaladja a k küszöbértéket.\n\nPéldák:\n>>> find_min_n_greater_than_k(1)\n2\nAz összeg S_2 = 1 + 1/2 = 1.5, amely nagyobb, mint 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nAz összeg S_10 = 1 + 1/2 + 1/3 + ... + 1/10 kisebb vagy egyenlő, mint 3, de az összeg S_11 meghaladja a 3-at.", "es": "Calcular el entero positivo más pequeño n tal que la suma de la serie armónica\nhasta 1/n sea mayor que un entero positivo dado k.\n\nLa serie armónica se define como S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgumentos:\n- k (int): Un entero positivo que representa el valor umbral que la suma de la serie armónica debe exceder.\n\nDevuelve:\n- int: El entero más pequeño n para el cual la suma de la serie armónica S_n excede el umbral k.\n\nEjemplos:\n>>> find_min_n_greater_than_k(1)\n2\nLa suma S_2 = 1 + 1/2 = 1.5, que es mayor que 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nLa suma S_10 = 1 + 1/2 + 1/3 + ... + 1/10 es menor o igual a 3, pero la suma S_11 excede 3.", "arb": "احسب أصغر عدد صحيح موجب n بحيث يكون مجموع السلسلة التوافقية حتى 1/n أكبر من عدد صحيح موجب معين k.\n\nالسلسلة التوافقية تُعرّف كالتالي S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nالمعطيات:\n- k (int): عدد صحيح موجب يمثل قيمة العتبة التي يجب أن يتجاوزها مجموع السلسلة التوافقية.\n\nالقيم المعادة:\n- int: أصغر عدد صحيح n حيث يتجاوز مجموع السلسلة التوافقية S_n العتبة k.\n\nأمثلة:\n>>> find_min_n_greater_than_k(1)\n2\nالمجموع S_2 = 1 + 1/2 = 1.5، وهو أكبر من 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nالمجموع S_10 = 1 + 1/2 + 1/3 + ... + 1/10 أقل من أو يساوي 3، لكن المجموع S_11 يتجاوز 3.", "sw": "Hesabu namba ndogo kabisa chanya n kiasi kwamba jumla ya mfululizo wa harmonic\n    hadi 1/n ni kubwa kuliko namba chanya iliyotolewa k.\n\nMfululizo wa harmonic unafafanuliwa kama S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nHoja:\n- k (int): Nambari nzima chanya inayowakilisha thamani ya kizingiti ambacho jumla ya mfululizo wa harmonic lazima izidi.\n\nInarejesha:\n- int: Nambari ndogo zaidi n ambayo jumla ya mfululizo wa harmonic S_n inazidi kizingiti k.\n\nMifano:\n>>> find_min_n_greater_than_k(1)\n2\nJumla S_2 = 1 + 1/2 = 1.5, ambayo ni kubwa kuliko 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nJumla S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ni ndogo au sawa na 3, lakini jumla S_11 inazidi 3.", "tr": "Harmonik serinin 1/n'ye kadar olan toplamının verilen pozitif bir tamsayı k'dan büyük olduğu en küçük pozitif tamsayı n'yi hesaplayın.\n\nHarmonik seri S_n = 1 + 1/2 + 1/3 + ... + 1/n olarak tanımlanır.\n\nArgümanlar:\n- k (int): Harmonik seri toplamının aşması gereken eşik değerini temsil eden pozitif bir tamsayı.\n\nDöndürür:\n- int: Harmonik seri toplamı S_n'nin eşik k değerini aştığı en küçük tamsayı n.\n\nÖrnekler:\n>>> find_min_n_greater_than_k(1)\n2\nToplam S_2 = 1 + 1/2 = 1.5, bu 1'den büyüktür.\n\n>>> find_min_n_greater_than_k(3)\n11\nToplam S_10 = 1 + 1/2 + 1/3 + ... + 1/10, 3'ten küçük veya eşittir, ancak toplam S_11, 3'ü aşar.", "vi": "Tính số nguyên dương nhỏ nhất n sao cho tổng của chuỗi điều hòa\ntới 1/n lớn hơn một số nguyên dương cho trước k.\n\nChuỗi điều hòa được định nghĩa là S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nTham số:\n- k (int): Một số nguyên dương đại diện cho giá trị ngưỡng mà tổng chuỗi điều hòa phải vượt qua.\n\nTrả về:\n- int: Số nguyên nhỏ nhất n sao cho tổng chuỗi điều hòa S_n vượt quá ngưỡng k.\n\nVí dụ:\n>>> find_min_n_greater_than_k(1)\n2\nTổng S_2 = 1 + 1/2 = 1.5, lớn hơn 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nTổng S_10 = 1 + 1/2 + 1/3 + ... + 1/10 nhỏ hơn hoặc bằng 3, nhưng tổng S_11 vượt quá 3.", "id": "Hitung bilangan bulat positif terkecil n sedemikian rupa sehingga jumlah deret harmonik\nhingga 1/n lebih besar dari bilangan bulat positif k yang diberikan.\n\nDeret harmonik didefinisikan sebagai S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): Bilangan bulat positif yang mewakili nilai ambang batas yang harus dilampaui oleh jumlah deret harmonik.\n\nReturns:\n- int: Bilangan bulat terkecil n untuk mana jumlah deret harmonik S_n melebihi ambang batas k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nJumlah S_2 = 1 + 1/2 = 1.5, yang lebih besar dari 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nJumlah S_10 = 1 + 1/2 + 1/3 + ... + 1/10 kurang dari atau sama dengan 3, tetapi jumlah S_11 melebihi 3.", "ja": "与えられた正の整数 k よりも大きい、調和級数の和が 1/n までの最小の正の整数 n を計算します。\n\n調和級数は S_n = 1 + 1/2 + 1/3 + ... + 1/n と定義されます。\n\n引数:\n- k (int): 調和級数の和が超えなければならない閾値を表す正の整数。\n\n戻り値:\n- int: 調和級数の和 S_n が閾値 k を超える最小の整数 n。\n\n例:\n>>> find_min_n_greater_than_k(1)\n2\n和 S_2 = 1 + 1/2 = 1.5 は 1 より大きいです。\n\n>>> find_min_n_greater_than_k(3)\n11\n和 S_10 = 1 + 1/2 + 1/3 + ... + 1/10 は 3 以下ですが、和 S_11 は 3 を超えます。", "ko": "주어진 양의 정수 k보다 큰 조화급수의 합을 가지는 가장 작은 양의 정수 n을 계산합니다.\n\n조화급수는 S_n = 1 + 1/2 + 1/3 + ... + 1/n으로 정의됩니다.\n\nArgs:\n- k (int): 조화급수의 합이 초과해야 하는 임계값을 나타내는 양의 정수입니다.\n\nReturns:\n- int: 조화급수의 합 S_n이 임계값 k를 초과하는 가장 작은 정수 n입니다.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\n합 S_2 = 1 + 1/2 = 1.5는 1보다 큽니다.\n\n>>> find_min_n_greater_than_k(3)\n11\n합 S_10 = 1 + 1/2 + 1/3 + ... + 1/10은 3보다 작거나 같지만, 합 S_11은 3을 초과합니다.", "ml": "ഹാർമോണിക് ശ്രേണിയുടെ തുക 1/n വരെ നൽകിയിരിക്കുന്ന ധനാത്മക പൂർണ്ണസംഖ്യ k-നെക്കാൾ കൂടുതലായതായ ഏറ്റവും ചെറിയ\n    ധനാത്മക പൂർണ്ണസംഖ്യ n കണക്കാക്കുക.\n\nഹാർമോണിക് ശ്രേണിയെ S_n = 1 + 1/2 + 1/3 + ... + 1/n എന്നിങ്ങനെ നിർവചിക്കുന്നു.\n\nArgs:\n- k (int): ഹാർമോണിക് ശ്രേണി തുക കടക്കേണ്ട പരിധി മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു ധനപരമായ പൂർണ്ണസംഖ്യ.\n\nReturns:\n- int: ഹാർമോണിക് ശ്രേണി തുക S_n പരിധി k-നെ കടക്കുന്ന ഏറ്റവും ചെറിയ പൂർണ്ണസംഖ്യ n.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nതുക S_2 = 1 + 1/2 = 1.5, ഇത് 1-നെക്കാൾ കൂടുതലാണ്.\n\n>>> find_min_n_greater_than_k(3)\n11\nതുക S_10 = 1 + 1/2 + 1/3 + ... + 1/10 3-നെക്കാൾ കുറവോ തുല്യമോ ആണ്, പക്ഷേ തുക S_11 3-നെ കടക്കുന്നു.", "fa": "محاسبه کوچکترین عدد صحیح مثبت n به طوری که مجموع سری هارمونیک تا 1/n بزرگتر از یک عدد صحیح مثبت داده شده k باشد.\n\nسری هارمونیک به صورت S_n = 1 + 1/2 + 1/3 + ... + 1/n تعریف می‌شود.\n\nآرگومان‌ها:\n- k (int): یک عدد صحیح مثبت که نشان‌دهنده مقدار آستانه‌ای است که مجموع سری هارمونیک باید از آن بیشتر شود.\n\nبازگشت:\n- int: کوچکترین عدد صحیح n که برای آن مجموع سری هارمونیک S_n از آستانه k بیشتر می‌شود.\n\nمثال‌ها:\n>>> find_min_n_greater_than_k(1)\n2\nمجموع S_2 = 1 + 1/2 = 1.5 است که بزرگتر از 1 می‌باشد.\n\n>>> find_min_n_greater_than_k(3)\n11\nمجموع S_10 = 1 + 1/2 + 1/3 + ... + 1/10 کمتر یا مساوی 3 است، اما مجموع S_11 از 3 بیشتر می‌شود."}}
{"task_id": "Python/30", "prompt": {"en": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    - For num = 2 or num = 3, the function should return True, since both are prime numbers.\n    - For num = 1 or num = 0, the function should return False, as neither is considered prime.\n    - For num = 15, which is divisible by 3 and 5, the function should return False.\n    - For num = 29, which has no divisors other than 1 and itself, the function should return True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "sq": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Përcakton nëse një numër i dhënë është numër i thjeshtë.\n\n    Një numër i thjeshtë është një numër natyror më i madh se 1 që nuk ka pjesëtues pozitivë përveç 1 dhe vetvetes. Funksioni kontrollon për thjeshtësinë duke eliminuar numrat jo të thjeshtë duke përdorur disa teste. Së pari, trajton rastet e veçanta për numrat më të vegjël ose të barabartë me 1, të cilët nuk janë të thjeshtë, dhe numrat e vegjël (2 dhe 3) të cilët janë të thjeshtë. Më pas kontrollon për pjesëtueshmëri me 2 dhe 3. Për numrat më të mëdhenj, përdor një optimizim 6k +/- 1 për të testuar për faktorë deri te rrënja katrore e numrit.\n\n    Args:\n    num (int): Numri i plotë për të kontrolluar për thjeshtësi.\n\n    Returns:\n    bool: True nëse `num` është numër i thjeshtë, False përndryshe.\n\n    Rastet:\n    - Për num = 2 ose num = 3, funksioni duhet të kthejë True, pasi të dy janë numra të thjeshtë.\n    - Për num = 1 ose num = 0, funksioni duhet të kthejë False, pasi asnjëri nuk konsiderohet i thjeshtë.\n    - Për num = 15, i cili është i pjesëtueshëm me 3 dhe 5, funksioni duhet të kthejë False.\n    - Për num = 29, i cili nuk ka pjesëtues përveç 1 dhe vetvetes, funksioni duhet të kthejë True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "hy": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Սահմանել՝ արդյոք տրված ամբողջ թիվը պարզ թիվ է:\n\n    Պարզ թիվը 1-ից մեծ բնական թիվ է, որը չունի դրական բաժանարարներ 1-ից և իրենից բացի: Ֆունկցիան ստուգում է պարզությունը՝ ոչ պարզ թվերը բացառելով մի քանի թեստերի միջոցով: Նախ, այն մշակում է եզակի դեպքերը 1-ից փոքր կամ հավասար թվերի համար, որոնք պարզ չեն, և փոքր թվերի (2 և 3) համար, որոնք պարզ են: Այնուհետև ստուգում է բաժանելիությունը 2-ով և 3-ով: Ավելի մեծ թվերի համար այն օգտագործում է 6k +/- 1 օպտիմալացում՝ գործոնները ստուգելու համար մինչև թվի քառակուսի արմատը:\n\n    Արգումենտներ:\n    num (int): Ամբողջ թիվը, որը պետք է ստուգել պարզության համար:\n\n    Վերադարձնում է:\n    bool: True, եթե `num`-ը պարզ թիվ է, False՝ հակառակ դեպքում:\n\n    Դեպքեր:\n    - num = 2 կամ num = 3 դեպքում, ֆունկցիան պետք է վերադարձնի True, քանի որ երկուսն էլ պարզ թվեր են:\n    - num = 1 կամ num = 0 դեպքում, ֆունկցիան պետք է վերադարձնի False, քանի որ ոչ մեկը պարզ չի համարվում:\n    - num = 15 դեպքում, որը բաժանվում է 3-ի և 5-ի վրա, ֆունկցիան պետք է վերադարձնի False:\n    - num = 29 դեպքում, որը չունի բաժանարարներ 1-ից և իրենից բացի, ֆունկցիան պետք է վերադարձնի True:\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "bn": "def is_prime(num: int) -> bool:\n    \"\"\"\n    প্রদত্ত পূর্ণসংখ্যাটি একটি মৌলিক সংখ্যা কিনা তা নির্ধারণ করুন।\n\n    একটি মৌলিক সংখ্যা হল ১ এর চেয়ে বড় একটি স্বাভাবিক সংখ্যা যার ১ এবং নিজে ছাড়া অন্য কোনো ধনাত্মক গুণনীয়ক নেই। ফাংশনটি বিভিন্ন পরীক্ষা ব্যবহার করে অমৌলিক সংখ্যা বাদ দিয়ে মৌলিকতা পরীক্ষা করে। প্রথমে, এটি ১ বা তার চেয়ে কম সংখ্যার জন্য প্রান্তিক কেসগুলি পরিচালনা করে, যা মৌলিক নয়, এবং ছোট সংখ্যা (২ এবং ৩) যা মৌলিক। তারপর এটি ২ এবং ৩ দ্বারা বিভাজ্যতা পরীক্ষা করে। বড় সংখ্যার জন্য, এটি সংখ্যার বর্গমূল পর্যন্ত গুণনীয়ক পরীক্ষা করার জন্য 6k +/- 1 অপ্টিমাইজেশন ব্যবহার করে।\n\n    Args:\n    num (int): মৌলিকতা পরীক্ষা করার জন্য পূর্ণসংখ্যা।\n\n    Returns:\n    bool: যদি `num` একটি মৌলিক সংখ্যা হয় তবে True, অন্যথায় False।\n\n    কেসসমূহ:\n    - num = 2 বা num = 3 এর জন্য, ফাংশনটি True ফেরত দেবে, যেহেতু উভয়ই মৌলিক সংখ্যা।\n    - num = 1 বা num = 0 এর জন্য, ফাংশনটি False ফেরত দেবে, যেহেতু এদের কোনোটিই মৌলিক নয়।\n    - num = 15 এর জন্য, যা ৩ এবং ৫ দ্বারা বিভাজ্য, ফাংশনটি False ফেরত দেবে।\n    - num = 29 এর জন্য, যার ১ এবং নিজে ছাড়া অন্য কোনো গুণনীয়ক নেই, ফাংশনটি True ফেরত দেবে।\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "bg": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Определя дали дадено цяло число е просто число.\n\n    Просто число е естествено число, по-голямо от 1, което няма положителни делители, различни от 1 и самото себе си. Функцията проверява за простота, като елиминира непростите числа чрез няколко теста. Първо, тя обработва гранични случаи за числа, по-малки или равни на 1, които не са прости, и малки числа (2 и 3), които са прости. След това проверява за делимост на 2 и 3. За по-големи числа използва оптимизация 6k +/- 1, за да тества за фактори до квадратния корен на числото.\n\n    Args:\n    num (int): Цялото число, което да се провери за простота.\n\n    Returns:\n    bool: True, ако `num` е просто число, False в противен случай.\n\n    Случаи:\n    - За num = 2 или num = 3, функцията трябва да върне True, тъй като и двете са прости числа.\n    - За num = 1 или num = 0, функцията трябва да върне False, тъй като нито едно от тях не се счита за просто.\n    - За num = 15, което е делимо на 3 и 5, функцията трябва да върне False.\n    - За num = 29, което няма делители, различни от 1 и самото себе си, функцията трябва да върне True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "zh": "def is_prime(num: int) -> bool:\n    \"\"\"\n    确定给定的整数是否为质数。\n\n    质数是大于1的自然数，除了1和它本身外没有其他正除数。该函数通过使用几个测试来消除非质数来检查质数性。首先，它处理小于或等于1的数字的边缘情况，这些数字不是质数，而小数字（2和3）是质数。然后它检查是否能被2和3整除。对于较大的数字，它使用6k +/- 1优化来测试因数，直到数字的平方根。\n\n    参数:\n    num (int): 要检查是否为质数的整数。\n\n    返回:\n    bool: 如果`num`是质数则返回True，否则返回False。\n\n    情况:\n    - 对于num = 2或num = 3，函数应返回True，因为它们都是质数。\n    - 对于num = 1或num = 0，函数应返回False，因为它们都不被认为是质数。\n    - 对于num = 15，它能被3和5整除，函数应返回False。\n    - 对于num = 29，它除了1和它本身外没有其他除数，函数应返回True。\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "fr": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Déterminer si un entier donné est un nombre premier.\n\n    Un nombre premier est un nombre naturel supérieur à 1 qui n'a pas de diviseurs positifs autres que 1 et lui-même. La fonction vérifie la primalité en éliminant les nombres non premiers à l'aide de plusieurs tests. Tout d'abord, elle gère les cas particuliers pour les nombres inférieurs ou égaux à 1, qui ne sont pas premiers, et les petits nombres (2 et 3) qui sont premiers. Elle vérifie ensuite la divisibilité par 2 et 3. Pour les nombres plus grands, elle utilise une optimisation 6k +/- 1 pour tester les facteurs jusqu'à la racine carrée du nombre.\n\n    Args:\n    num (int): L'entier à vérifier pour la primalité.\n\n    Returns:\n    bool: True si `num` est un nombre premier, False sinon.\n\n    Cas :\n    - Pour num = 2 ou num = 3, la fonction doit retourner True, car les deux sont des nombres premiers.\n    - Pour num = 1 ou num = 0, la fonction doit retourner False, car aucun n'est considéré comme premier.\n    - Pour num = 15, qui est divisible par 3 et 5, la fonction doit retourner False.\n    - Pour num = 29, qui n'a pas de diviseurs autres que 1 et lui-même, la fonction doit retourner True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "de": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Bestimmen, ob eine gegebene ganze Zahl eine Primzahl ist.\n\n    Eine Primzahl ist eine natürliche Zahl größer als 1, die keine positiven Teiler außer 1 und sich selbst hat. Die Funktion prüft die Primalität, indem sie nicht-primzahlen durch mehrere Tests eliminiert. Zuerst behandelt sie Sonderfälle für Zahlen kleiner oder gleich 1, die nicht prim sind, und kleine Zahlen (2 und 3), die prim sind. Dann prüft sie die Teilbarkeit durch 2 und 3. Für größere Zahlen verwendet sie eine 6k +/- 1 Optimierung, um nach Faktoren bis zur Quadratwurzel der Zahl zu testen.\n\n    Args:\n    num (int): Die ganze Zahl, die auf Primalität überprüft werden soll.\n\n    Returns:\n    bool: True, wenn `num` eine Primzahl ist, False andernfalls.\n\n    Fälle:\n    - Für num = 2 oder num = 3 sollte die Funktion True zurückgeben, da beide Primzahlen sind.\n    - Für num = 1 oder num = 0 sollte die Funktion False zurückgeben, da keine als prim betrachtet wird.\n    - Für num = 15, das durch 3 und 5 teilbar ist, sollte die Funktion False zurückgeben.\n    - Für num = 29, das keine Teiler außer 1 und sich selbst hat, sollte die Funktion True zurückgeben.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "ha": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Tantance ko wani lamba cikakken lamba ne.\n\n    Lamba cikakke ita ce lamba ta halitta wadda ta fi 1 girma kuma ba ta da masu rarrabewa masu kyau sai dai 1 da kanta. Aikin yana duba cikakken lamba ta hanyar kawar da lambobi marasa cikakke ta amfani da gwaje-gwaje da dama. Da farko, yana magance yanayi na musamman ga lambobi ƙasa ko daidai da 1, waɗanda ba cikakke ba ne, da ƙananan lambobi (2 da 3) waɗanda cikakke ne. Sannan yana duba rarrabuwa da 2 da 3. Ga manyan lambobi, yana amfani da ingantaccen 6k +/- 1 don gwada abubuwan har zuwa tushen murabba'in lambar.\n\n    Args:\n    num (int): Lambar da za a duba cikakken lamba.\n\n    Returns:\n    bool: Gaskiya idan `num` cikakken lamba ne, Karya idan ba haka ba.\n\n    Yanayi:\n    - Ga num = 2 ko num = 3, aikin ya kamata ya dawo da Gaskiya, tunda dukansu lambobi ne cikakke.\n    - Ga num = 1 ko num = 0, aikin ya kamata ya dawo da Karya, saboda babu ɗayansu da ake ɗauka cikakke.\n    - Ga num = 15, wanda za a iya rarrabashi da 3 da 5, aikin ya kamata ya dawo da Karya.\n    - Ga num = 29, wanda ba shi da masu rarrabewa sai dai 1 da kanta, aikin ya kamata ya dawo da Gaskiya.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "hi": "def is_prime(num: int) -> bool:\n    \"\"\"\n    यह निर्धारित करें कि दिया गया पूर्णांक एक अभाज्य संख्या है या नहीं।\n\n    एक अभाज्य संख्या एक प्राकृतिक संख्या है जो 1 से बड़ी होती है और जिसका कोई भी धनात्मक भाजक 1 और स्वयं के अलावा नहीं होता। यह फ़ंक्शन अभाज्यता की जाँच कई परीक्षणों का उपयोग करके गैर-अभाज्य संख्याओं को समाप्त करके करता है। सबसे पहले, यह 1 से कम या बराबर संख्याओं के लिए किनारे के मामलों को संभालता है, जो अभाज्य नहीं हैं, और छोटी संख्याएँ (2 और 3) जो अभाज्य हैं। फिर यह 2 और 3 से विभाज्यता की जाँच करता है। बड़ी संख्याओं के लिए, यह संख्या के वर्गमूल तक कारकों के परीक्षण के लिए 6k +/- 1 अनुकूलन का उपयोग करता है।\n\n    Args:\n    num (int): अभाज्यता की जाँच के लिए पूर्णांक।\n\n    Returns:\n    bool: यदि `num` एक अभाज्य संख्या है तो True, अन्यथा False।\n\n    मामले:\n    - num = 2 या num = 3 के लिए, फ़ंक्शन को True लौटाना चाहिए, क्योंकि दोनों अभाज्य संख्याएँ हैं।\n    - num = 1 या num = 0 के लिए, फ़ंक्शन को False लौटाना चाहिए, क्योंकि इनमें से कोई भी अभाज्य नहीं माना जाता है।\n    - num = 15 के लिए, जो 3 और 5 से विभाज्य है, फ़ंक्शन को False लौटाना चाहिए।\n    - num = 29 के लिए, जिसका कोई भी भाजक 1 और स्वयं के अलावा नहीं है, फ़ंक्शन को True लौटाना चाहिए।\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "hu": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Határozza meg, hogy egy adott egész szám prím szám-e.\n\n    A prím szám olyan 1-nél nagyobb természetes szám, amelynek nincsenek pozitív osztói 1-en és önmagán kívül. A függvény a nem prím számok kizárásával ellenőrzi a prím tulajdonságot több teszt segítségével. Először kezeli azokat a szélsőséges eseteket, amikor a szám kisebb vagy egyenlő 1-gyel, amelyek nem prímek, és a kis számokat (2 és 3), amelyek prímek. Ezután ellenőrzi az oszthatóságot 2-vel és 3-mal. Nagyobb számok esetén 6k +/- 1 optimalizálást használ, hogy tesztelje az osztókat a szám négyzetgyökéig.\n\n    Args:\n    num (int): Az egész szám, amelynek prím tulajdonságát ellenőrizzük.\n\n    Returns:\n    bool: True, ha `num` prím szám, különben False.\n\n    Esetek:\n    - Ha num = 2 vagy num = 3, a függvénynek True-t kell visszaadnia, mivel mindkettő prím szám.\n    - Ha num = 1 vagy num = 0, a függvénynek False-t kell visszaadnia, mivel egyik sem tekinthető prímnek.\n    - Ha num = 15, amely osztható 3-mal és 5-tel, a függvénynek False-t kell visszaadnia.\n    - Ha num = 29, amelynek nincsenek osztói 1-en és önmagán kívül, a függvénynek True-t kell visszaadnia.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "es": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determinar si un número entero dado es un número primo.\n\n    Un número primo es un número natural mayor que 1 que no tiene divisores positivos aparte de 1 y él mismo. La función verifica la primalidad eliminando números no primos mediante varias pruebas. Primero, maneja casos especiales para números menores o iguales a 1, que no son primos, y números pequeños (2 y 3) que son primos. Luego verifica la divisibilidad por 2 y 3. Para números más grandes, utiliza una optimización 6k +/- 1 para probar factores hasta la raíz cuadrada del número.\n\n    Argumentos:\n    num (int): El entero para verificar la primalidad.\n\n    Devuelve:\n    bool: True si `num` es un número primo, False en caso contrario.\n\n    Casos:\n    - Para num = 2 o num = 3, la función debería devolver True, ya que ambos son números primos.\n    - Para num = 1 o num = 0, la función debería devolver False, ya que ninguno se considera primo.\n    - Para num = 15, que es divisible por 3 y 5, la función debería devolver False.\n    - Para num = 29, que no tiene divisores aparte de 1 y él mismo, la función debería devolver True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "arb": "def is_prime(num: int) -> bool:\n    \"\"\"\n    تحديد ما إذا كان العدد الصحيح المعطى هو عدد أولي.\n\n    العدد الأولي هو عدد طبيعي أكبر من 1 وليس له قواسم موجبة أخرى غير 1 ونفسه. تقوم الدالة بالتحقق من الأولية عن طريق استبعاد الأعداد غير الأولية باستخدام عدة اختبارات. أولاً، تتعامل مع الحالات الخاصة للأعداد الأقل من أو تساوي 1، والتي ليست أولية، والأعداد الصغيرة (2 و3) التي هي أولية. ثم تتحقق من القابلية للقسمة على 2 و3. بالنسبة للأعداد الأكبر، تستخدم تحسين 6k +/- 1 لاختبار العوامل حتى الجذر التربيعي للعدد.\n\n    يعيدالحجج:\n    num (int): العدد الصحيح للتحقق من أوليته.\n\n    يعيد:\n    bool: True إذا كان `num` عددًا أوليًا، False خلاف ذلك.\n\n    حالات:\n    - بالنسبة لـ num = 2 أو num = 3، يجب أن تعيد الدالة True، لأن كلاهما عددان أوليان.\n    - بالنسبة لـ num = 1 أو num = 0، يجب أن تعيد الدالة False، حيث لا يعتبر أي منهما أوليًا.\n    - بالنسبة لـ num = 15، الذي يقبل القسمة على 3 و5، يجب أن تعيد الدالة False.\n    - بالنسبة لـ num = 29، الذي ليس له قواسم غير 1 ونفسه، يجب أن تعيد الدالة True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "sw": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Kuamua kama nambari kamili iliyotolewa ni nambari ya kwanza.\n\n    Nambari ya kwanza ni nambari asilia iliyo kubwa kuliko 1 ambayo haina wagawanyaji chanya isipokuwa 1 na yenyewe. Kazi hii inakagua kama ni ya kwanza kwa kuondoa nambari zisizo za kwanza kwa kutumia vipimo kadhaa. Kwanza, inashughulikia kesi maalum kwa nambari ndogo au sawa na 1, ambazo si za kwanza, na nambari ndogo (2 na 3) ambazo ni za kwanza. Kisha inakagua ugawanyiko kwa 2 na 3. Kwa nambari kubwa zaidi, inatumia uboreshaji wa 6k +/- 1 ili kupima vipengele hadi mzizi wa mraba wa nambari.\n\n    Hoja:\n    num (int): Nambari kamili ya kukagua kama ni ya kwanza.\n\n    Inarejesha:\n    bool: Kweli ikiwa `num` ni nambari ya kwanza, Si kweli vinginevyo.\n\n    Kesi:\n    - Kwa num = 2 au num = 3, kazi inapaswa kurudisha Kweli, kwani zote mbili ni nambari za kwanza.\n    - Kwa num = 1 au num = 0, kazi inapaswa kurudisha Si kweli, kwani hakuna inayozingatiwa kuwa ya kwanza.\n    - Kwa num = 15, ambayo inagawanyika kwa 3 na 5, kazi inapaswa kurudisha Si kweli.\n    - Kwa num = 29, ambayo haina wagawanyaji isipokuwa 1 na yenyewe, kazi inapaswa kurudisha Kweli.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "tr": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Verilen bir tam sayının asal sayı olup olmadığını belirleyin.\n\n    Asal sayı, 1'den büyük ve kendisi dışında pozitif böleni olmayan doğal sayıdır. Fonksiyon, asal olmayan sayıları birkaç test kullanarak elemek suretiyle asal olup olmadığını kontrol eder. İlk olarak, asal olmayan 1 veya daha küçük sayılar ve asal olan küçük sayılar (2 ve 3) için özel durumları ele alır. Daha sonra 2 ve 3 ile bölünebilirliği kontrol eder. Daha büyük sayılar için, sayının kareköküne kadar olan faktörleri test etmek için 6k +/- 1 optimizasyonunu kullanır.\n\n    Argümanlar:\n    num (int): Asallığı kontrol edilecek tam sayı.\n\n    Dönüş:\n    bool: `num` asal bir sayı ise True, aksi takdirde False.\n\n    Durumlar:\n    - num = 2 veya num = 3 için, fonksiyon True döndürmelidir, çünkü her ikisi de asal sayıdır.\n    - num = 1 veya num = 0 için, fonksiyon False döndürmelidir, çünkü hiçbiri asal kabul edilmez.\n    - num = 15 için, 3 ve 5 ile bölünebilir olduğundan, fonksiyon False döndürmelidir.\n    - num = 29 için, kendisi ve 1 dışında böleni olmadığından, fonksiyon True döndürmelidir.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "vi": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Xác định xem một số nguyên đã cho có phải là số nguyên tố hay không.\n\n    Một số nguyên tố là một số tự nhiên lớn hơn 1 không có ước số dương nào khác ngoài 1 và chính nó. Hàm kiểm tra tính nguyên tố bằng cách loại trừ các số không phải nguyên tố bằng một số phép thử. Đầu tiên, nó xử lý các trường hợp đặc biệt cho các số nhỏ hơn hoặc bằng 1, không phải là số nguyên tố, và các số nhỏ (2 và 3) là số nguyên tố. Sau đó, nó kiểm tra tính chia hết cho 2 và 3. Đối với các số lớn hơn, nó sử dụng tối ưu hóa 6k +/- 1 để kiểm tra các ước số lên đến căn bậc hai của số đó.\n\n    Tham số:\n    num (int): Số nguyên cần kiểm tra tính nguyên tố.\n\n    Trả về:\n    bool: True nếu `num` là số nguyên tố, False nếu không phải.\n\n    Trường hợp:\n    - Đối với num = 2 hoặc num = 3, hàm sẽ trả về True, vì cả hai đều là số nguyên tố.\n    - Đối với num = 1 hoặc num = 0, hàm sẽ trả về False, vì không được coi là số nguyên tố.\n    - Đối với num = 15, chia hết cho 3 và 5, hàm sẽ trả về False.\n    - Đối với num = 29, không có ước số nào ngoài 1 và chính nó, hàm sẽ trả về True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "id": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Menentukan apakah bilangan bulat yang diberikan adalah bilangan prima.\n\n    Bilangan prima adalah bilangan asli lebih besar dari 1 yang tidak memiliki pembagi positif selain 1 dan dirinya sendiri. Fungsi ini memeriksa keprimalan dengan mengeliminasi bilangan non-prima menggunakan beberapa pengujian. Pertama, fungsi ini menangani kasus tepi untuk bilangan kurang dari atau sama dengan 1, yang bukan prima, dan bilangan kecil (2 dan 3) yang merupakan prima. Kemudian memeriksa keterbagian oleh 2 dan 3. Untuk bilangan yang lebih besar, fungsi ini menggunakan optimisasi 6k +/- 1 untuk menguji faktor hingga akar kuadrat dari bilangan tersebut.\n\n    Args:\n    num (int): Bilangan bulat yang akan diperiksa keprimalannya.\n\n    Returns:\n    bool: True jika `num` adalah bilangan prima, False jika tidak.\n\n    Kasus:\n    - Untuk num = 2 atau num = 3, fungsi harus mengembalikan True, karena keduanya adalah bilangan prima.\n    - Untuk num = 1 atau num = 0, fungsi harus mengembalikan False, karena keduanya tidak dianggap prima.\n    - Untuk num = 15, yang dapat dibagi oleh 3 dan 5, fungsi harus mengembalikan False.\n    - Untuk num = 29, yang tidak memiliki pembagi selain 1 dan dirinya sendiri, fungsi harus mengembalikan True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "ja": "def is_prime(num: int) -> bool:\n    \"\"\"\n    与えられた整数が素数かどうかを判定します。\n\n    素数は、1より大きく、1とその数自身以外に正の約数を持たない自然数です。この関数は、いくつかのテストを使用して非素数を排除することで素数判定を行います。まず、1以下の数（素数ではない）や、小さな数（2と3、これらは素数）についてのエッジケースを処理します。次に、2と3での除算可能性をチェックします。より大きな数に対しては、6k +/- 1 の最適化を使用して、その数の平方根までの因数をテストします。\n\n    引数:\n    num (int): 素数判定を行う整数。\n\n    戻り値:\n    bool: `num` が素数であれば True、そうでなければ False。\n\n    ケース:\n    - num = 2 または num = 3 の場合、関数は True を返すべきです。どちらも素数です。\n    - num = 1 または num = 0 の場合、関数は False を返すべきです。どちらも素数とは見なされません。\n    - num = 15 の場合、3と5で割り切れるので、関数は False を返すべきです。\n    - num = 29 の場合、1とその数自身以外に約数がないので、関数は True を返すべきです。\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "ko": "def is_prime(num: int) -> bool:\n    \"\"\"\n    주어진 정수가 소수인지 여부를 결정합니다.\n\n    소수는 1보다 큰 자연수로, 1과 자기 자신 외에는 양의 약수가 없는 수입니다. 이 함수는 여러 가지 테스트를 통해 소수가 아닌 수를 제거하여 소수 여부를 확인합니다. 먼저, 1 이하의 숫자에 대한 예외 처리를 하며, 이는 소수가 아니며, 작은 숫자(2와 3)는 소수입니다. 그런 다음 2와 3으로 나누어 떨어지는지 확인합니다. 더 큰 숫자의 경우, 6k +/- 1 최적화를 사용하여 숫자의 제곱근까지의 인수를 테스트합니다.\n\n    Args:\n    num (int): 소수 여부를 확인할 정수입니다.\n\n    Returns:\n    bool: `num`이 소수이면 True를 반환하고, 그렇지 않으면 False를 반환합니다.\n\n    사례:\n    - num = 2 또는 num = 3의 경우, 두 숫자 모두 소수이므로 함수는 True를 반환해야 합니다.\n    - num = 1 또는 num = 0의 경우, 둘 다 소수로 간주되지 않으므로 함수는 False를 반환해야 합니다.\n    - num = 15의 경우, 3과 5로 나누어 떨어지므로 함수는 False를 반환해야 합니다.\n    - num = 29의 경우, 1과 자기 자신 외에는 약수가 없으므로 함수는 True를 반환해야 합니다.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "ml": "def is_prime(num: int) -> bool:\n    \"\"\"\n    നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യ ഒരു പ്രധാന സംഖ്യയാണോ എന്ന് നിർണ്ണയിക്കുക.\n\n    ഒരു പ്രധാന സംഖ്യ 1-ലും അതിൽ തന്നെയും ഒഴികെ മറ്റ് പോസിറ്റീവ് വിഭജകങ്ങളില്ലാത്ത ഒരു സ്വാഭാവിക സംഖ്യയാണ്. പ്രധാന സംഖ്യയാണോ എന്ന് പരിശോധിക്കുന്നതിന്, ഫംഗ്ഷൻ പല പരീക്ഷണങ്ങൾ ഉപയോഗിച്ച് പ്രധാനമല്ലാത്ത സംഖ്യകളെ ഒഴിവാക്കുന്നു. ആദ്യം, പ്രധാനമല്ലാത്ത 1-ൽ കുറവോ തുല്യമായ സംഖ്യകൾക്കായുള്ള എഡ്ജ് കേസുകൾ കൈകാര്യം ചെയ്യുന്നു, കൂടാതെ പ്രധാനമായ ചെറിയ സംഖ്യകൾ (2, 3) കൈകാര്യം ചെയ്യുന്നു. തുടർന്ന് 2, 3 എന്നിവയാൽ വിഭജിക്കാവുന്നവയോ എന്ന് പരിശോധിക്കുന്നു. വലിയ സംഖ്യകൾക്കായി, 6k +/- 1 ഓപ്റ്റിമൈസേഷൻ ഉപയോഗിച്ച് സംഖ്യയുടെ ചതുരമൂല്യത്തിലേക്കുള്ള ഘടകങ്ങൾ പരിശോധിക്കുന്നു.\n\n    Args:\n    num (int): പ്രധാനമോ എന്ന് പരിശോധിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n\n    Returns:\n    bool: `num` ഒരു പ്രധാന സംഖ്യയാണെങ്കിൽ True, അല്ലെങ്കിൽ False.\n\n    കേസുകൾ:\n    - num = 2 അല്ലെങ്കിൽ num = 3 ആയാൽ, ഫംഗ്ഷൻ True മടക്കണം, കാരണം ഇരുവരും പ്രധാന സംഖ്യകളാണ്.\n    - num = 1 അല്ലെങ്കിൽ num = 0 ആയാൽ, ഫംഗ്ഷൻ False മടക്കണം, കാരണം ഇവയെ പ്രധാനമായി പരിഗണിക്കുന്നില്ല.\n    - num = 15, 3, 5 എന്നിവയാൽ വിഭജിക്കാവുന്നതാണ്, ഫംഗ്ഷൻ False മടക്കണം.\n    - num = 29, 1-ലും അതിൽ തന്നെയും ഒഴികെ മറ്റ് വിഭജകങ്ങളില്ല, ഫംഗ്ഷൻ True മടക്കണം.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "fa": "def is_prime(num: int) -> bool:\n    \"\"\"\n    تعیین می‌کند که آیا یک عدد صحیح داده شده یک عدد اول است یا خیر.\n\n    یک عدد اول عدد طبیعی بزرگتر از 1 است که هیچ مقسوم علیه مثبت جز 1 و خودش ندارد. این تابع با حذف اعداد غیر اول با استفاده از چندین آزمون، اول بودن را بررسی می‌کند. ابتدا، موارد خاص برای اعداد کمتر یا مساوی 1 که اول نیستند و اعداد کوچک (2 و 3) که اول هستند را بررسی می‌کند. سپس برای تقسیم‌پذیری بر 2 و 3 بررسی می‌کند. برای اعداد بزرگتر، از بهینه‌سازی 6k +/- 1 برای آزمایش عوامل تا ریشه مربع عدد استفاده می‌کند.\n\n    آرگومان‌ها:\n    num (int): عدد صحیحی که باید برای اول بودن بررسی شود.\n\n    بازگشت:\n    bool: اگر `num` یک عدد اول باشد، True برمی‌گرداند، در غیر این صورت False.\n\n    موارد:\n    - برای num = 2 یا num = 3، تابع باید True برگرداند، زیرا هر دو عدد اول هستند.\n    - برای num = 1 یا num = 0، تابع باید False برگرداند، زیرا هیچ‌کدام به عنوان عدد اول در نظر گرفته نمی‌شوند.\n    - برای num = 15، که بر 3 و 5 تقسیم‌پذیر است، تابع باید False برگرداند.\n    - برای num = 29، که هیچ مقسوم علیه جز 1 و خودش ندارد، تابع باید True برگرداند.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True"}, "canonical_solution": "    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "instruction": {"en": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nBa da takaitaccen bayanin yanayi na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में वर्णन (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n以下のPythonコードの説明を日本語で簡潔に記述してください。最大500文字以内でお願いします。", "ko": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_is_prime():\n    # Test case 1: Test a prime number\n    prime_number = 29\n    assert is_prime(prime_number) == True, f\"Test case 1 failed: {prime_number} is a prime number.\"\n\n    # Test case 2: Test a non-prime number\n    non_prime_number = 21  # 21 = 3 * 7, so it's not prime\n    assert is_prime(non_prime_number) == False, f\"Test case 2 failed: {non_prime_number} is not a prime number.\"\n\n    # Test case 3: Test a number less than 2 (should not be prime)\n    less_than_two = 1\n    assert is_prime(less_than_two) == False, f\"Test case 3 failed: {less_than_two} is not a prime number.\"\n\n    # Test case 4: Test another prime number\n    another_prime_number = 97\n    assert is_prime(another_prime_number) == True, f\"Test case 4 failed: {another_prime_number} is a prime number.\"\n\n    # Test case 5: Test zero (should not be prime)\n    zero = 0\n    assert is_prime(zero) == False, f\"Test case 5 failed: {zero} is not a prime number.\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_is_prime()", "entry_point": "is_prime", "signature": "def is_prime(num: int) -> bool:", "docstring": {"en": "Determine whether a given integer is a prime number.\n\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\nArgs:\nnum (int): The integer to check for primality.\n\nReturns:\nbool: True if `num` is a prime number, False otherwise.\n\nCases:\n- For num = 2 or num = 3, the function should return True, since both are prime numbers.\n- For num = 1 or num = 0, the function should return False, as neither is considered prime.\n- For num = 15, which is divisible by 3 and 5, the function should return False.\n- For num = 29, which has no divisors other than 1 and itself, the function should return True.", "sq": "Përcaktoni nëse një numër i dhënë i plotë është një numër i thjeshtë.\n\nNjë numër i thjeshtë është një numër natyror më i madh se 1 që nuk ka ndarës pozitivë përveç 1 dhe vetes. Funksioni kontrollon për thjeshtësinë duke eliminuar numrat jo të thjeshtë duke përdorur disa teste. Së pari, trajton rastet e veçanta për numrat më të vegjël ose të barabartë me 1, të cilët nuk janë të thjeshtë, dhe numrat e vegjël (2 dhe 3) të cilët janë të thjeshtë. Më pas kontrollon për pjesëtueshmëri nga 2 dhe 3. Për numra më të mëdhenj, përdor një optimizim 6k +/- 1 për të testuar për faktorë deri në rrënjën katrore të numrit.\n\nArgumentet:\nnum (int): Numri i plotë për të kontrolluar për thjeshtësi.\n\nKthen:\nbool: True nëse `num` është një numër i thjeshtë, False përndryshe.\n\nRastet:\n- Për num = 2 ose num = 3, funksioni duhet të kthejë True, pasi të dy janë numra të thjeshtë.\n- Për num = 1 ose num = 0, funksioni duhet të kthejë False, pasi asnjëri nuk konsiderohet i thjeshtë.\n- Për num = 15, i cili është i pjesëtueshëm nga 3 dhe 5, funksioni duhet të kthejë False.\n- Për num = 29, i cili nuk ka ndarës përveç 1 dhe vetes, funksioni duhet të kthejë True.", "hy": "Սահմանել, արդյոք տրված ամբողջ թիվը պարզ թիվ է:\n\nՊարզ թիվը բնական թիվ է, որը մեծ է 1-ից և չունի դրական բաժանարարներ 1-ից և իրենից բացի: Ֆունկցիան ստուգում է պարզությունը՝ ոչ պարզ թվերը բացառելով մի քանի թեստերի միջոցով: Նախ, այն մշակում է եզակի դեպքերը 1-ից փոքր կամ հավասար թվերի համար, որոնք պարզ չեն, և փոքր թվերի (2 և 3) համար, որոնք պարզ են: Այնուհետև ստուգում է բաժանելիությունը 2-ով և 3-ով: Ավելի մեծ թվերի համար այն օգտագործում է 6k +/- 1 օպտիմալացում՝ մինչև թվի քառակուսի արմատը գործոններ ստուգելու համար:\n\nԱրձագանքներ:\nnum (int): Ամբողջ թիվը, որը պետք է ստուգել պարզության համար:\n\nՎերադարձնում է:\nbool: True, եթե `num`-ը պարզ թիվ է, False՝ հակառակ դեպքում:\n\nԴեպքեր:\n- num = 2 կամ num = 3-ի համար ֆունկցիան պետք է վերադարձնի True, քանի որ երկուսն էլ պարզ թվեր են:\n- num = 1 կամ num = 0-ի համար ֆունկցիան պետք է վերադարձնի False, քանի որ ոչ մեկը չի համարվում պարզ:\n- num = 15-ի համար, որը բաժանվում է 3-ի և 5-ի վրա, ֆունկցիան պետք է վերադարձնի False:\n- num = 29-ի համար, որը չունի բաժանարարներ 1-ից և իրենից բացի, ֆունկցիան պետք է վերադարձնի True:", "bn": "একটি প্রদত্ত পূর্ণসংখ্যা একটি মৌলিক সংখ্যা কিনা তা নির্ধারণ করুন।\n\nএকটি মৌলিক সংখ্যা হল ১ এর চেয়ে বড় একটি প্রাকৃতিক সংখ্যা যার ১ এবং তার নিজের বাইরে অন্য কোনো ধনাত্মক গুণনীয়ক নেই। ফাংশনটি বিভিন্ন পরীক্ষার মাধ্যমে অমৌলিক সংখ্যা বাদ দিয়ে মৌলিকতা যাচাই করে। প্রথমে, এটি ১ বা তার চেয়ে কম সংখ্যার জন্য প্রান্তিক কেসগুলি পরিচালনা করে, যা মৌলিক নয়, এবং ছোট সংখ্যা (২ এবং ৩) যা মৌলিক। তারপর এটি ২ এবং ৩ দ্বারা বিভাজ্যতা পরীক্ষা করে। বড় সংখ্যার জন্য, এটি সংখ্যাটির বর্গমূল পর্যন্ত গুণনীয়ক পরীক্ষা করার জন্য 6k +/- 1 অপ্টিমাইজেশন ব্যবহার করে।\n\nআর্গস:\nnum (int): যে পূর্ণসংখ্যাটি মৌলিকতা যাচাই করতে হবে।\n\nরিটার্নস:\nbool: যদি `num` একটি মৌলিক সংখ্যা হয় তবে True, অন্যথায় False।\n\nকেসসমূহ:\n- num = 2 বা num = 3 এর জন্য, ফাংশনটি True রিটার্ন করবে, যেহেতু উভয়ই মৌলিক সংখ্যা।\n- num = 1 বা num = 0 এর জন্য, ফাংশনটি False রিটার্ন করবে, যেহেতু কোনোটিই মৌলিক বলে বিবেচিত নয়।\n- num = 15 এর জন্য, যা ৩ এবং ৫ দ্বারা বিভাজ্য, ফাংশনটি False রিটার্ন করবে।\n- num = 29 এর জন্য, যার ১ এবং তার নিজের বাইরে অন্য কোনো গুণনীয়ক নেই, ফাংশনটি True রিটার্ন করবে।", "bg": "Определя дали дадено цяло число е просто число.\n\nПросто число е естествено число, по-голямо от 1, което няма положителни делители, различни от 1 и самото себе си. Функцията проверява за простота, като елиминира непростите числа чрез няколко теста. Първо, тя обработва гранични случаи за числа, по-малки или равни на 1, които не са прости, и малки числа (2 и 3), които са прости. След това проверява за делимост на 2 и 3. За по-големи числа използва оптимизация 6k +/- 1, за да тества за фактори до квадратния корен на числото.\n\nАргументи:\nnum (int): Цялото число, което да се провери за простота.\n\nВръща:\nbool: True, ако `num` е просто число, False в противен случай.\n\nСлучаи:\n- За num = 2 или num = 3, функцията трябва да върне True, тъй като и двете са прости числа.\n- За num = 1 или num = 0, функцията трябва да върне False, тъй като нито едно от тях не се счита за просто.\n- За num = 15, което е делимо на 3 и 5, функцията трябва да върне False.\n- За num = 29, което няма делители, различни от 1 и самото себе си, функцията трябва да върне True.", "zh": "确定给定的整数是否是质数。\n\n质数是大于1的自然数，除了1和它本身之外没有其他正除数。该函数通过使用多个测试来消除非质数，从而检查质数性。首先，它处理小于或等于1的数字的边界情况，这些数字不是质数，以及小数字（2和3），它们是质数。然后，它检查是否能被2和3整除。对于较大的数字，它使用6k +/- 1优化来测试因子，直到数字的平方根。\n\n参数：\nnum (int): 要检查是否为质数的整数。\n\n返回：\nbool: 如果 `num` 是质数则返回 True，否则返回 False。\n\n情况：\n- 对于 num = 2 或 num = 3，函数应返回 True，因为它们都是质数。\n- 对于 num = 1 或 num = 0，函数应返回 False，因为它们都不被认为是质数。\n- 对于 num = 15，它能被3和5整除，函数应返回 False。\n- 对于 num = 29，它除了1和它本身之外没有其他除数，函数应返回 True。", "fr": "Déterminer si un entier donné est un nombre premier.\n\nUn nombre premier est un nombre naturel supérieur à 1 qui n'a pas de diviseurs positifs autres que 1 et lui-même. La fonction vérifie la primalité en éliminant les nombres non premiers à l'aide de plusieurs tests. Tout d'abord, elle gère les cas particuliers pour les nombres inférieurs ou égaux à 1, qui ne sont pas premiers, et les petits nombres (2 et 3) qui sont premiers. Elle vérifie ensuite la divisibilité par 2 et 3. Pour les nombres plus grands, elle utilise une optimisation 6k +/- 1 pour tester les facteurs jusqu'à la racine carrée du nombre.\n\nArgs:\nnum (int): L'entier à vérifier pour la primalité.\n\nReturns:\nbool: True si `num` est un nombre premier, False sinon.\n\nCas:\n- Pour num = 2 ou num = 3, la fonction doit retourner True, car les deux sont des nombres premiers.\n- Pour num = 1 ou num = 0, la fonction doit retourner False, car aucun n'est considéré comme premier.\n- Pour num = 15, qui est divisible par 3 et 5, la fonction doit retourner False.\n- Pour num = 29, qui n'a pas de diviseurs autres que 1 et lui-même, la fonction doit retourner True.", "de": "Bestimmen, ob eine gegebene ganze Zahl eine Primzahl ist.\n\nEine Primzahl ist eine natürliche Zahl größer als 1, die keine positiven Teiler außer 1 und sich selbst hat. Die Funktion überprüft die Primalität, indem sie nicht-primzahlen durch mehrere Tests eliminiert. Zuerst behandelt sie Randfälle für Zahlen kleiner oder gleich 1, die nicht prim sind, und kleine Zahlen (2 und 3), die prim sind. Dann überprüft sie die Teilbarkeit durch 2 und 3. Für größere Zahlen verwendet sie eine 6k +/- 1 Optimierung, um Faktoren bis zur Quadratwurzel der Zahl zu testen.\n\nArgs:\nnum (int): Die ganze Zahl, die auf Primalität überprüft werden soll.\n\nReturns:\nbool: True, wenn `num` eine Primzahl ist, False andernfalls.\n\nFälle:\n- Für num = 2 oder num = 3 sollte die Funktion True zurückgeben, da beide Primzahlen sind.\n- Für num = 1 oder num = 0 sollte die Funktion False zurückgeben, da keine von beiden als prim betrachtet wird.\n- Für num = 15, das durch 3 und 5 teilbar ist, sollte die Funktion False zurückgeben.\n- Für num = 29, das keine Teiler außer 1 und sich selbst hat, sollte die Funktion True zurückgeben.", "ha": "Tantance ko wani lamba cikakken lamba ne.\n\nLambar farko lamba ce ta halitta wadda ta fi 1 girma kuma ba ta da masu raba lamba masu kyau sai dai 1 da kanta. Aikin yana duba ko lamba ce ta farko ta hanyar kawar da lambobi marasa farko ta amfani da gwaje-gwaje da dama. Da farko, yana magance lokuta na musamman ga lambobi ƙasa da ko daidai da 1, waɗanda ba su da farko, da ƙananan lambobi (2 da 3) waɗanda suke da farko. Sannan yana duba rarrabuwa da 2 da 3. Ga manyan lambobi, yana amfani da ingantaccen 6k +/- 1 don gwada abubuwan har zuwa tushen murabba'in lambar.\n\nArgs:\nnum (int): Lambar da za a duba ko tana da farko.\n\nReturns:\nbool: True idan `num` lamba ce ta farko, False in ba haka ba.\n\nCases:\n- Ga num = 2 ko num = 3, aikin ya kamata ya dawo da True, domin dukansu lambobi ne na farko.\n- Ga num = 1 ko num = 0, aikin ya kamata ya dawo da False, domin babu ɗayansu da ake ɗauka a matsayin farko.\n- Ga num = 15, wanda za a iya raba shi da 3 da 5, aikin ya kamata ya dawo da False.\n- Ga num = 29, wanda ba shi da masu raba lamba sai dai 1 da kanta, aikin ya kamata ya dawo da True.", "hi": "दिया गया पूर्णांक एक अभाज्य संख्या है या नहीं, यह निर्धारित करें।\n\nएक अभाज्य संख्या 1 से बड़ी प्राकृतिक संख्या है जिसका कोई अन्य सकारात्मक भाजक नहीं होता सिवाय 1 और स्वयं के। यह फ़ंक्शन अभाज्यता की जाँच कई परीक्षणों का उपयोग करके गैर-अभाज्य संख्याओं को समाप्त करके करता है। सबसे पहले, यह 1 से कम या बराबर संख्याओं के लिए किनारे के मामलों को संभालता है, जो अभाज्य नहीं हैं, और छोटी संख्याएँ (2 और 3) जो अभाज्य हैं। फिर यह 2 और 3 से विभाज्यता की जाँच करता है। बड़ी संख्याओं के लिए, यह संख्या के वर्गमूल तक के गुणकों की जाँच के लिए 6k +/- 1 अनुकूलन का उपयोग करता है।\n\nआर्ग्स:\nnum (int): अभाज्यता की जाँच के लिए पूर्णांक।\n\nवापसी:\nbool: यदि `num` एक अभाज्य संख्या है तो True, अन्यथा False।\n\nमामले:\n- यदि num = 2 या num = 3 है, तो फ़ंक्शन को True लौटाना चाहिए, क्योंकि दोनों अभाज्य संख्याएँ हैं।\n- यदि num = 1 या num = 0 है, तो फ़ंक्शन को False लौटाना चाहिए, क्योंकि इनमें से कोई भी अभाज्य नहीं माना जाता।\n- यदि num = 15 है, जो 3 और 5 से विभाज्य है, तो फ़ंक्शन को False लौटाना चाहिए।\n- यदि num = 29 है, जिसका कोई अन्य भाजक नहीं है सिवाय 1 और स्वयं के, तो फ़ंक्शन को True लौटाना चाहिए।", "hu": "Határozza meg, hogy egy adott egész szám prímszám-e.\n\nA prímszám olyan 1-nél nagyobb természetes szám, amelynek nincsenek pozitív osztói 1-en és önmagán kívül. A függvény több teszt segítségével szűri ki a nem prím számokat. Először kezeli azokat a szélsőséges eseteket, amikor a szám kisebb vagy egyenlő 1-gyel, amelyek nem prímek, valamint a kis számokat (2 és 3), amelyek prímek. Ezután ellenőrzi az oszthatóságot 2-vel és 3-mal. Nagyobb számok esetén egy 6k +/- 1 optimalizálást használ, hogy tesztelje az osztókat a szám négyzetgyökéig.\n\nArgs:\nnum (int): Az egész szám, amelyet ellenőrizni kell, hogy prím-e.\n\nReturns:\nbool: True, ha `num` prímszám, különben False.\n\nEsetek:\n- Ha num = 2 vagy num = 3, a függvénynek True-t kell visszaadnia, mivel mindkettő prímszám.\n- Ha num = 1 vagy num = 0, a függvénynek False-t kell visszaadnia, mivel egyik sem tekinthető prímszámnak.\n- Ha num = 15, amely osztható 3-mal és 5-tel, a függvénynek False-t kell visszaadnia.\n- Ha num = 29, amelynek nincsenek osztói 1-en és önmagán kívül, a függvénynek True-t kell visszaadnia.", "es": "Determinar si un número entero dado es un número primo.\n\nUn número primo es un número natural mayor que 1 que no tiene divisores positivos aparte de 1 y sí mismo. La función verifica la primalidad eliminando números no primos utilizando varias pruebas. Primero, maneja casos especiales para números menores o iguales a 1, que no son primos, y números pequeños (2 y 3) que son primos. Luego verifica la divisibilidad por 2 y 3. Para números más grandes, utiliza una optimización de 6k +/- 1 para probar factores hasta la raíz cuadrada del número.\n\nArgumentos:\nnum (int): El entero a verificar para primalidad.\n\nDevuelve:\nbool: True si `num` es un número primo, False en caso contrario.\n\nCases:\n- Para num = 2 o num = 3, la función debería devolver True, ya que ambos son números primos.\n- Para num = 1 o num = 0, la función debería devolver False, ya que ninguno se considera primo.\n- Para num = 15, que es divisible por 3 y 5, la función debería devolver False.\n- Para num = 29, que no tiene divisores aparte de 1 y sí mismo, la función debería devolver True.", "arb": "تحديد ما إذا كان العدد الصحيح المعطى هو عدد أولي.\n\nالعدد الأولي هو عدد طبيعي أكبر من 1 وليس له قواسم موجبة أخرى غير 1 ونفسه. تقوم الدالة بالتحقق من الأولية عن طريق استبعاد الأعداد غير الأولية باستخدام عدة اختبارات. أولاً، تتعامل مع الحالات الخاصة للأعداد الأقل من أو تساوي 1، والتي ليست أولية، والأعداد الصغيرة (2 و3) التي هي أولية. ثم تتحقق من القابلية للقسمة على 2 و3. بالنسبة للأعداد الأكبر، تستخدم تحسين 6k +/- 1 لاختبار العوامل حتى الجذر التربيعي للعدد.\n\nالمعاملات:\nnum (int): العدد الصحيح للتحقق من أوليته.\n\nالقيم المعادة:\nbool: True إذا كان `num` عددًا أوليًا، False خلاف ذلك.\n\nالحالات:\n- بالنسبة لـ num = 2 أو num = 3، يجب أن تعيد الدالة True، حيث أن كلاهما عددان أوليان.\n- بالنسبة لـ num = 1 أو num = 0، يجب أن تعيد الدالة False، حيث لا يُعتبر أي منهما أوليًا.\n- بالنسبة لـ num = 15، الذي يقبل القسمة على 3 و5، يجب أن تعيد الدالة False.\n- بالنسبة لـ num = 29، الذي ليس له قواسم غير 1 ونفسه، يجب أن تعيد الدالة True.", "sw": "Kuamua kama nambari kamili iliyotolewa ni nambari ya kwanza.\n\nNambari ya kwanza ni nambari asilia kubwa kuliko 1 ambayo haina wagawanyaji chanya isipokuwa 1 na yenyewe. Kazi hii inakagua ikiwa ni ya kwanza kwa kuondoa nambari zisizo za kwanza kwa kutumia vipimo kadhaa. Kwanza, inashughulikia kesi maalum za nambari ndogo au sawa na 1, ambazo si za kwanza, na nambari ndogo (2 na 3) ambazo ni za kwanza. Kisha inakagua ugawanyiko kwa 2 na 3. Kwa nambari kubwa, inatumia mbinu ya 6k +/- 1 kupima vipengele hadi mzizi wa mraba wa nambari.\n\nHoja:\nnum (int): Nambari ya kuangalia ikiwa ni ya kwanza.\n\nInarejesha:\nbool: True ikiwa `num` ni nambari ya kwanza, False vinginevyo.\n\nCases:\n- Kwa num = 2 au num = 3, kazi inapaswa kurudisha True, kwa kuwa zote mbili ni nambari za kwanza.\n- Kwa num = 1 au num = 0, kazi inapaswa kurudisha False, kwa kuwa hakuna inayozingatiwa kuwa ya kwanza.\n- Kwa num = 15, ambayo inagawanyika kwa 3 na 5, kazi inapaswa kurudisha False.\n- Kwa num = 29, ambayo haina wagawanyaji isipokuwa 1 na yenyewe, kazi inapaswa kurudisha True.", "tr": "Belirtilen bir tam sayının asal sayı olup olmadığını belirleyin.\n\nAsal sayı, 1'den büyük ve 1 ile kendisi dışında pozitif böleni olmayan doğal sayıdır. Fonksiyon, asal olmayan sayıları birkaç test kullanarak eleyerek asal olup olmadığını kontrol eder. İlk olarak, asal olmayan 1 veya daha küçük sayılar ve asal olan küçük sayılar (2 ve 3) için özel durumları ele alır. Daha sonra 2 ve 3'e bölünebilirliği kontrol eder. Daha büyük sayılar için, sayının kareköküne kadar olan faktörleri test etmek için 6k +/- 1 optimizasyonunu kullanır.\n\nArgümanlar:\nnum (int): Asallığı kontrol edilecek tam sayı.\n\nDöndürür:\nbool: `num` bir asal sayı ise True, aksi takdirde False.\n\nDurumlar:\n- num = 2 veya num = 3 için, fonksiyon True döndürmelidir, çünkü her ikisi de asal sayıdır.\n- num = 1 veya num = 0 için, fonksiyon False döndürmelidir, çünkü hiçbiri asal kabul edilmez.\n- num = 15 için, 3 ve 5'e bölünebildiğinden, fonksiyon False döndürmelidir.\n- num = 29 için, 1 ve kendisi dışında böleni olmadığından, fonksiyon True döndürmelidir.", "vi": "Xác định xem một số nguyên cho trước có phải là số nguyên tố hay không.\n\nMột số nguyên tố là một số tự nhiên lớn hơn 1 không có ước số dương nào khác ngoài 1 và chính nó. Hàm kiểm tra tính nguyên tố bằng cách loại bỏ các số không phải nguyên tố thông qua một số phép thử. Đầu tiên, nó xử lý các trường hợp đặc biệt cho các số nhỏ hơn hoặc bằng 1, không phải là số nguyên tố, và các số nhỏ (2 và 3) là số nguyên tố. Sau đó, nó kiểm tra tính chia hết cho 2 và 3. Đối với các số lớn hơn, nó sử dụng tối ưu hóa 6k +/- 1 để kiểm tra các ước số lên đến căn bậc hai của số đó.\n\nTham số:\nnum (int): Số nguyên để kiểm tra tính nguyên tố.\n\nTrả về:\nbool: True nếu `num` là một số nguyên tố, False nếu không.\n\nCases:\n- Đối với num = 2 hoặc num = 3, hàm sẽ trả về True, vì cả hai đều là số nguyên tố.\n- Đối với num = 1 hoặc num = 0, hàm sẽ trả về False, vì cả hai đều không được coi là số nguyên tố.\n- Đối với num = 15, chia hết cho 3 và 5, hàm sẽ trả về False.\n- Đối với num = 29, không có ước số nào ngoài 1 và chính nó, hàm sẽ trả về True.", "id": "Menentukan apakah bilangan bulat yang diberikan adalah bilangan prima.\n\nBilangan prima adalah bilangan asli yang lebih besar dari 1 yang tidak memiliki pembagi positif selain 1 dan dirinya sendiri. Fungsi ini memeriksa keprimaan dengan mengeliminasi bilangan non-prima menggunakan beberapa tes. Pertama, ia menangani kasus tepi untuk bilangan kurang dari atau sama dengan 1, yang bukan prima, dan bilangan kecil (2 dan 3) yang merupakan prima. Kemudian, ia memeriksa keterbagian dengan 2 dan 3. Untuk bilangan yang lebih besar, ia menggunakan optimasi 6k +/- 1 untuk menguji faktor hingga akar kuadrat dari bilangan tersebut.\n\nArgumen:\nnum (int): Bilangan bulat yang akan diperiksa keprimaannya.\n\nMengembalikan:\nbool: True jika `num` adalah bilangan prima, False jika tidak.\n\nKasus:\n- Untuk num = 2 atau num = 3, fungsi harus mengembalikan True, karena keduanya adalah bilangan prima.\n- Untuk num = 1 atau num = 0, fungsi harus mengembalikan False, karena keduanya tidak dianggap prima.\n- Untuk num = 15, yang dapat dibagi oleh 3 dan 5, fungsi harus mengembalikan False.\n- Untuk num = 29, yang tidak memiliki pembagi selain 1 dan dirinya sendiri, fungsi harus mengembalikan True.", "ja": "与えられた整数が素数であるかどうかを判定します。\n\n素数は、1より大きく、1とその数自身以外に正の約数を持たない自然数です。この関数は、いくつかのテストを使用して非素数を排除することで素数判定を行います。まず、素数でない1以下の数と、素数である小さな数（2と3）のエッジケースを処理します。次に、2と3での除算をチェックします。より大きな数に対しては、6k +/- 1の最適化を使用して、その数の平方根までの因数をテストします。\n\n引数:\nnum (int): 素数判定を行う整数。\n\n戻り値:\nbool: `num`が素数であればTrue、そうでなければFalse。\n\nケース:\n- num = 2 または num = 3 の場合、関数はTrueを返すべきです。どちらも素数です。\n- num = 1 または num = 0 の場合、関数はFalseを返すべきです。どちらも素数とは見なされません。\n- num = 15 の場合、3と5で割り切れるため、関数はFalseを返すべきです。\n- num = 29 の場合、1とその数自身以外に約数がないため、関数はTrueを返すべきです。", "ko": "주어진 정수가 소수인지 여부를 결정합니다.\n\n소수는 1보다 큰 자연수로, 1과 자기 자신 외에는 양의 약수가 없는 수입니다. 이 함수는 여러 테스트를 사용하여 소수가 아닌 수를 제거함으로써 소수 여부를 확인합니다. 먼저, 소수가 아닌 1 이하의 수와 소수인 작은 수(2와 3)에 대한 예외 처리를 합니다. 그런 다음, 2와 3으로 나누어지는지 확인합니다. 더 큰 수의 경우, 숫자의 제곱근까지의 인수를 테스트하기 위해 6k +/- 1 최적화를 사용합니다.\n\n인수:\nnum (int): 소수 여부를 확인할 정수입니다.\n\n반환:\nbool: `num`이 소수이면 True를 반환하고, 그렇지 않으면 False를 반환합니다.\n\n사례:\n- num = 2 또는 num = 3인 경우, 두 수 모두 소수이므로 함수는 True를 반환해야 합니다.\n- num = 1 또는 num = 0인 경우, 둘 다 소수로 간주되지 않으므로 함수는 False를 반환해야 합니다.\n- num = 15인 경우, 3과 5로 나누어지므로 함수는 False를 반환해야 합니다.\n- num = 29인 경우, 1과 자기 자신 외에는 약수가 없으므로 함수는 True를 반환해야 합니다.", "ml": "ഒരു നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യ പ്രധാന സംഖ്യയാണോ എന്ന് നിർണ്ണയിക്കുക.\n\nഒരു പ്രധാന സംഖ്യ 1-ലധികം മൂല്യമുള്ള പ്രകൃത്യാ സംഖ്യയാണ്, 1-നും അതിനും പുറമെ അനുകൂലമായ വിഭജകങ്ങൾ ഇല്ലാത്തത്. പ്രധാന സംഖ്യയാണോ എന്ന് പരിശോധിക്കുന്നതിന്, പല പരീക്ഷണങ്ങൾ ഉപയോഗിച്ച് പ്രധാനമല്ലാത്ത സംഖ്യകളെ ഒഴിവാക്കുന്നു. ആദ്യം, പ്രധാനമല്ലാത്ത 1-ൽ കുറവായ അല്ലെങ്കിൽ 1-നു തുല്യമായ സംഖ്യകൾക്കും ചെറിയ സംഖ്യകൾ (2, 3) എന്നിവയ്ക്കും, ഇവ പ്രധാന സംഖ്യകളാണ്, പ്രത്യേക പരിഗണന നൽകുന്നു. തുടർന്ന്, 2-നും 3-നും വിഭജ്യത പരിശോധിക്കുന്നു. വലിയ സംഖ്യകൾക്കായി, 6k +/- 1 ഓപ്റ്റിമൈസേഷൻ ഉപയോഗിച്ച് സംഖ്യയുടെ വേരിന്റെ ചതുരം വരെ ഘടകങ്ങൾ പരിശോധിക്കുന്നു.\n\nആർഗ്സ്:\nnum (int): പ്രധാന സംഖ്യയാണോ എന്ന് പരിശോധിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n\nമടക്കം:\nbool: `num` ഒരു പ്രധാന സംഖ്യയാണെങ്കിൽ True, അല്ലെങ്കിൽ False.\n\nകേസുകൾ:\n- num = 2 അല്ലെങ്കിൽ num = 3 ആണെങ്കിൽ, ഫംഗ്ഷൻ True മടക്കണം, കാരണം ഇവ രണ്ടും പ്രധാന സംഖ്യകളാണ്.\n- num = 1 അല്ലെങ്കിൽ num = 0 ആണെങ്കിൽ, ഫംഗ്ഷൻ False മടക്കണം, കാരണം ഇവ ഒന്നും പ്രധാനമായി കണക്കാക്കുന്നില്ല.\n- num = 15 ആണെങ്കിൽ, ഇത് 3-നും 5-നും വിഭജ്യമായതിനാൽ, ഫംഗ്ഷൻ False മടക്കണം.\n- num = 29 ആണെങ്കിൽ, 1-നും അതിനും പുറമെ വിഭജകങ്ങളില്ലാത്തതിനാൽ, ഫംഗ്ഷൻ True മടക്കണം.", "fa": "تشخیص دهید که آیا یک عدد صحیح داده شده یک عدد اول است یا خیر.\n\nیک عدد اول، عدد طبیعی بزرگتر از 1 است که هیچ مقسوم علیه مثبت دیگری جز 1 و خودش ندارد. این تابع با حذف اعداد غیر اول از طریق چندین آزمون، اول بودن را بررسی می‌کند. ابتدا، موارد خاص برای اعداد کمتر یا مساوی 1 که اول نیستند و اعداد کوچک (2 و 3) که اول هستند را بررسی می‌کند. سپس قابلیت تقسیم بر 2 و 3 را بررسی می‌کند. برای اعداد بزرگتر، از بهینه‌سازی 6k +/- 1 برای آزمایش مقسوم علیه‌ها تا جذر عدد استفاده می‌کند.\n\nآرگومان‌ها:\nnum (int): عدد صحیحی که باید برای اول بودن بررسی شود.\n\nبازگشتی:\nbool: True اگر `num` یک عدد اول باشد، در غیر این صورت False.\n\nموارد:\n- برای num = 2 یا num = 3، تابع باید True برگرداند، زیرا هر دو عدد اول هستند.\n- برای num = 1 یا num = 0، تابع باید False برگرداند، زیرا هیچ‌کدام به عنوان عدد اول در نظر گرفته نمی‌شوند.\n- برای num = 15، که بر 3 و 5 بخش‌پذیر است، تابع باید False برگرداند.\n- برای num = 29، که هیچ مقسوم علیه‌ای جز 1 و خودش ندارد، تابع باید True برگرداند."}}
{"task_id": "Python/31", "prompt": {"en": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    - Case 1: n = 234, rules = [(2, 5), (3, 6)]\n              This case should return 4 because the following unique numbers can be generated:\n              234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n    - Case 2: n = 100, rules = [(1, 9)]\n              This case should return 2 because the following unique numbers can be generated:\n              100 (original) and 900 (1 -> 9).\n\n    - Case 3: n = 8, rules = [(8, 3), (8, 5)]\n              This case should return 3 because the following unique numbers can be generated:\n              8 (original), 3 (8 -> 3), and 5 (8 -> 5).\n    \"\"\"", "sq": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Gjenero të gjitha numrat unikë nga numri i dhënë duke aplikuar rregullat e transformimit.\n\n    Çdo rregull lejon që një shifër e vetme të transformohet në një tjetër. Një kërkim në gjerësi\n    (BFS) përdoret për të eksploruar të gjitha transformimet e mundshme. Funksioni kthen numrin\n    e numrave unikë që mund të gjenerohen nga numri origjinal, duke përfshirë vetë numrin.\n\n    Argumentet:\n    - n (int): Numri origjinal i plotë për t'u transformuar.\n    - rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull përfaqësohet\n                              si një tuple (x, y) që tregon se shifra x mund të transformohet në y.\n\n    Kthen:\n    - int: Numri total i numrave unikë që mund të gjenerohen.\n\n    Rastet:\n    - Rasti 1: n = 234, rules = [(2, 5), (3, 6)]\n              Ky rast duhet të kthejë 4 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n              234 (origjinal), 534 (2 -> 5), 264 (3 -> 6), dhe 564 (2 -> 5, 3 -> 6).\n\n    - Rasti 2: n = 100, rules = [(1, 9)]\n              Ky rast duhet të kthejë 2 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n              100 (origjinal) dhe 900 (1 -> 9).\n\n    - Rasti 3: n = 8, rules = [(8, 3), (8, 5)]\n              Ky rast duhet të kthejë 3 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n              8 (origjinal), 3 (8 -> 3), dhe 5 (8 -> 5).\n    \"\"\"", "hy": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Տրված թվից գեներացնել բոլոր եզակի թվերը՝ կիրառելով փոխակերպման կանոնները:\n\n    Յուրաքանչյուր կանոն թույլ է տալիս մեկ թվանշանը փոխակերպել մեկ այլ թվանշանի: Լայնությամբ առաջին որոնում\n    (BFS) օգտագործվում է բոլոր հնարավոր փոխակերպումները ուսումնասիրելու համար: Ֆունկցիան վերադարձնում է\n    եզակի թվերի քանակը, որոնք կարող են գեներացվել սկզբնական թվից, ներառյալ ինքը՝ թիվը:\n\n    Արգումենտներ:\n    - n (int): Սկզբնական ամբողջ թիվը, որը պետք է փոխակերպել:\n    - rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն ներկայացված է\n                              որպես զույգ (x, y), որը ցույց է տալիս, որ թվանշան x-ը կարող է փոխակերպվել y-ի:\n\n    Վերադարձնում է:\n    - int: Եզակի թվերի ընդհանուր քանակը, որոնք կարող են գեներացվել:\n\n    Դեպքեր:\n    - Դեպք 1: n = 234, rules = [(2, 5), (3, 6)]\n              Այս դեպքը պետք է վերադարձնի 4, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը:\n              234 (սկզբնական), 534 (2 -> 5), 264 (3 -> 6), և 564 (2 -> 5, 3 -> 6):\n\n    - Դեպք 2: n = 100, rules = [(1, 9)]\n              Այս դեպքը պետք է վերադարձնի 2, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը:\n              100 (սկզբնական) և 900 (1 -> 9):\n\n    - Դեպք 3: n = 8, rules = [(8, 3), (8, 5)]\n              Այս դեպքը պետք է վերադարձնի 3, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը:\n              8 (սկզբնական), 3 (8 -> 3), և 5 (8 -> 5):\n    \"\"\"", "bn": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    প্রদত্ত সংখ্যাটি থেকে রূপান্তর নিয়ম প্রয়োগ করে সমস্ত অনন্য সংখ্যা তৈরি করুন।\n\n    প্রতিটি নিয়ম একটি একক অঙ্ককে অন্যটিতে রূপান্তর করার অনুমতি দেয়। সমস্ত সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে একটি ব্রেডথ-ফার্স্ট সার্চ\n    (BFS) ব্যবহার করা হয়। ফাংশনটি মূল সংখ্যাটি সহ মূল সংখ্যাটি থেকে তৈরি করা যেতে পারে এমন অনন্য সংখ্যার গণনা প্রদান করে।\n\n    আর্গুমেন্টসমূহ:\n    - n (int): রূপান্তর করার জন্য মূল পূর্ণসংখ্যা সংখ্যা।\n    - rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল (x, y) হিসাবে উপস্থাপিত\n                              হয় যা নির্দেশ করে যে অঙ্ক x কে y তে রূপান্তরিত করা যেতে পারে।\n\n    রিটার্নস:\n    - int: তৈরি করা যেতে পারে এমন অনন্য সংখ্যার মোট গণনা।\n\n    কেসসমূহ:\n    - কেস 1: n = 234, rules = [(2, 5), (3, 6)]\n              এই ক্ষেত্রে 4 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n              234 (মূল), 534 (2 -> 5), 264 (3 -> 6), এবং 564 (2 -> 5, 3 -> 6)।\n\n    - কেস 2: n = 100, rules = [(1, 9)]\n              এই ক্ষেত্রে 2 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n              100 (মূল) এবং 900 (1 -> 9)।\n\n    - কেস 3: n = 8, rules = [(8, 3), (8, 5)]\n              এই ক্ষেত্রে 3 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n              8 (মূল), 3 (8 -> 3), এবং 5 (8 -> 5)।\n    \"\"\"", "bg": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Генерира всички уникални числа от даденото число чрез прилагане на правила за трансформация.\n\n    Всяко правило позволява една цифра да бъде трансформирана в друга. Използва се търсене в ширина\n    (BFS), за да се изследват всички възможни трансформации. Функцията връща броя на уникалните числа,\n    които могат да бъдат генерирани от оригиналното число, включително самото число.\n\n    Аргументи:\n    - n (int): Оригиналното цяло число за трансформиране.\n    - rules (list of tuples): Списък с правила за трансформация, където всяко правило е представено\n                              като кортеж (x, y), указващ, че цифрата x може да бъде трансформирана в y.\n\n    Връща:\n    - int: Общият брой на уникалните числа, които могат да бъдат генерирани.\n\n    Примери:\n    - Пример 1: n = 234, rules = [(2, 5), (3, 6)]\n              Този пример трябва да върне 4, защото могат да бъдат генерирани следните уникални числа:\n              234 (оригинално), 534 (2 -> 5), 264 (3 -> 6) и 564 (2 -> 5, 3 -> 6).\n\n    - Пример 2: n = 100, rules = [(1, 9)]\n              Този пример трябва да върне 2, защото могат да бъдат генерирани следните уникални числа:\n              100 (оригинално) и 900 (1 -> 9).\n\n    - Пример 3: n = 8, rules = [(8, 3), (8, 5)]\n              Този пример трябва да върне 3, защото могат да бъдат генерирани следните уникални числа:\n              8 (оригинално), 3 (8 -> 3) и 5 (8 -> 5).\n    \"\"\"", "zh": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    通过应用转换规则从给定数字生成所有唯一数字。\n\n    每个规则允许将一个数字转换为另一个数字。使用广度优先搜索（BFS）来探索所有可能的转换。\n    该函数返回可以从原始数字生成的唯一数字的数量，包括数字本身。\n\n    参数:\n    - n (int): 要转换的原始整数。\n    - rules (list of tuples): 转换规则的列表，其中每个规则表示为一个元组 (x, y)，\n                              表示数字 x 可以转换为 y。\n\n    返回:\n    - int: 可以生成的唯一数字的总数。\n\n    情况:\n    - 情况 1: n = 234, rules = [(2, 5), (3, 6)]\n              这种情况下应该返回 4，因为可以生成以下唯一数字：\n              234 (原始), 534 (2 -> 5), 264 (3 -> 6), 和 564 (2 -> 5, 3 -> 6)。\n\n    - 情况 2: n = 100, rules = [(1, 9)]\n              这种情况下应该返回 2，因为可以生成以下唯一数字：\n              100 (原始) 和 900 (1 -> 9)。\n\n    - 情况 3: n = 8, rules = [(8, 3), (8, 5)]\n              这种情况下应该返回 3，因为可以生成以下唯一数字：\n              8 (原始), 3 (8 -> 3), 和 5 (8 -> 5)。\n    \"\"\"", "fr": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Générer tous les nombres uniques à partir du nombre donné en appliquant des règles de transformation.\n\n    Chaque règle permet de transformer un chiffre en un autre. Une recherche en largeur\n    (BFS) est utilisée pour explorer toutes les transformations possibles. La fonction retourne le nombre\n    de nombres uniques qui peuvent être générés à partir du nombre original, y compris le nombre lui-même.\n\n    Args:\n    - n (int): Le nombre entier original à transformer.\n    - rules (list of tuples): Une liste de règles de transformation, où chaque règle est représentée\n                              comme un tuple (x, y) indiquant que le chiffre x peut être transformé en y.\n\n    Returns:\n    - int: Le nombre total de nombres uniques qui peuvent être générés.\n\n    Cas:\n    - Cas 1: n = 234, rules = [(2, 5), (3, 6)]\n              Ce cas devrait retourner 4 car les nombres uniques suivants peuvent être générés :\n              234 (original), 534 (2 -> 5), 264 (3 -> 6), et 564 (2 -> 5, 3 -> 6).\n\n    - Cas 2: n = 100, rules = [(1, 9)]\n              Ce cas devrait retourner 2 car les nombres uniques suivants peuvent être générés :\n              100 (original) et 900 (1 -> 9).\n\n    - Cas 3: n = 8, rules = [(8, 3), (8, 5)]\n              Ce cas devrait retourner 3 car les nombres uniques suivants peuvent être générés :\n              8 (original), 3 (8 -> 3), et 5 (8 -> 5).\n    \"\"\"", "de": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generiere alle einzigartigen Zahlen aus der gegebenen Zahl durch Anwendung von Transformationsregeln.\n\n    Jede Regel erlaubt es, eine einzelne Ziffer in eine andere zu transformieren. Eine Breitensuche\n    (BFS) wird verwendet, um alle möglichen Transformationen zu erkunden. Die Funktion gibt die Anzahl\n    der einzigartigen Zahlen zurück, die aus der ursprünglichen Zahl generiert werden können, einschließlich der Zahl selbst.\n\n    Argumente:\n    - n (int): Die ursprüngliche ganze Zahl, die transformiert werden soll.\n    - rules (list von Tupeln): Eine Liste von Transformationsregeln, wobei jede Regel als\n                               Tupel (x, y) dargestellt wird, das angibt, dass die Ziffer x in y transformiert werden kann.\n\n    Rückgaben:\n    - int: Die Gesamtanzahl der einzigartigen Zahlen, die generiert werden können.\n\n    Fälle:\n    - Fall 1: n = 234, rules = [(2, 5), (3, 6)]\n              Dieser Fall sollte 4 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n              234 (original), 534 (2 -> 5), 264 (3 -> 6), und 564 (2 -> 5, 3 -> 6).\n\n    - Fall 2: n = 100, rules = [(1, 9)]\n              Dieser Fall sollte 2 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n              100 (original) und 900 (1 -> 9).\n\n    - Fall 3: n = 8, rules = [(8, 3), (8, 5)]\n              Dieser Fall sollte 3 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n              8 (original), 3 (8 -> 3), und 5 (8 -> 5).\n    \"\"\"", "ha": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Samar da duk lambobin musamman daga lambar da aka bayar ta hanyar amfani da dokokin sauyi.\n\n    Kowace doka tana ba da damar a sauya wata lamba guda ɗaya zuwa wata. Ana amfani da binciken farko\n    (BFS) don bincika dukkan yiwuwar sauye-sauye. Aikin yana mayar da adadin\n    lambobin musamman da za a iya samarwa daga lambar asali, ciki har da lambar kanta.\n\n    Args:\n    - n (int): Lambar asali ta integer don sauya.\n    - rules (list of tuples): Jerin dokokin sauyi, inda kowace doka aka wakilta\n                              a matsayin tuple (x, y) wanda ke nuna cewa za a iya sauya lamba x zuwa y.\n\n    Returns:\n    - int: Jimillar adadin lambobin musamman da za a iya samarwa.\n\n    Cases:\n    - Case 1: n = 234, rules = [(2, 5), (3, 6)]\n              Wannan yanayin ya kamata ya dawo da 4 saboda ana iya samar da lambobin musamman masu zuwa:\n              234 (asali), 534 (2 -> 5), 264 (3 -> 6), da 564 (2 -> 5, 3 -> 6).\n\n    - Case 2: n = 100, rules = [(1, 9)]\n              Wannan yanayin ya kamata ya dawo da 2 saboda ana iya samar da lambobin musamman masu zuwa:\n              100 (asali) da 900 (1 -> 9).\n\n    - Case 3: n = 8, rules = [(8, 3), (8, 5)]\n              Wannan yanayin ya kamata ya dawo da 3 saboda ana iya samar da lambobin musamman masu zuwa:\n              8 (asali), 3 (8 -> 3), da 5 (8 -> 5).\n    \"\"\"", "hi": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    दिए गए संख्या से सभी अद्वितीय संख्याएँ उत्पन्न करें, परिवर्तन नियमों को लागू करके।\n\n    प्रत्येक नियम एकल अंक को दूसरे में परिवर्तित करने की अनुमति देता है। सभी संभावित परिवर्तनों\n    का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) का उपयोग किया जाता है। यह फ़ंक्शन उन अद्वितीय संख्याओं की\n    गणना लौटाता है जो मूल संख्या से उत्पन्न की जा सकती हैं, जिसमें संख्या स्वयं भी शामिल है।\n\n    तर्क:\n    - n (int): मूल पूर्णांक संख्या जिसे परिवर्तित करना है।\n    - rules (list of tuples): परिवर्तन नियमों की सूची, जहाँ प्रत्येक नियम को एक टपल (x, y) के रूप में दर्शाया गया है\n                              जो दर्शाता है कि अंक x को y में परिवर्तित किया जा सकता है।\n\n    लौटाता है:\n    - int: अद्वितीय संख्याओं की कुल गणना जो उत्पन्न की जा सकती हैं।\n\n    मामले:\n    - मामला 1: n = 234, rules = [(2, 5), (3, 6)]\n              यह मामला 4 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n              234 (मूल), 534 (2 -> 5), 264 (3 -> 6), और 564 (2 -> 5, 3 -> 6)।\n\n    - मामला 2: n = 100, rules = [(1, 9)]\n              यह मामला 2 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n              100 (मूल) और 900 (1 -> 9)।\n\n    - मामला 3: n = 8, rules = [(8, 3), (8, 5)]\n              यह मामला 3 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n              8 (मूल), 3 (8 -> 3), और 5 (8 -> 5)।\n    \"\"\"", "hu": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generáljon minden egyedi számot a megadott számból átalakítási szabályok alkalmazásával.\n\n    Minden szabály lehetővé teszi, hogy egyetlen számjegy átalakuljon egy másikra. \n    Szélességi keresést (BFS) használunk az összes lehetséges átalakítás feltárására. \n    A függvény visszaadja az eredeti számból generálható egyedi számok számát, beleértve magát a számot is.\n\n    Argumentumok:\n    - n (int): Az eredeti egész szám, amelyet át kell alakítani.\n    - rules (list of tuples): Az átalakítási szabályok listája, ahol minden szabály egy\n                              (x, y) tuple-ként van megadva, jelezve, hogy az x számjegy átalakulhat y-ra.\n\n    Visszatérési érték:\n    - int: Az összes egyedi szám száma, amely generálható.\n\n    Esetek:\n    - Eset 1: n = 234, rules = [(2, 5), (3, 6)]\n              Ez az eset 4-et kell visszaadjon, mert a következő egyedi számok generálhatók:\n              234 (eredeti), 534 (2 -> 5), 264 (3 -> 6), és 564 (2 -> 5, 3 -> 6).\n\n    - Eset 2: n = 100, rules = [(1, 9)]\n              Ez az eset 2-t kell visszaadjon, mert a következő egyedi számok generálhatók:\n              100 (eredeti) és 900 (1 -> 9).\n\n    - Eset 3: n = 8, rules = [(8, 3), (8, 5)]\n              Ez az eset 3-at kell visszaadjon, mert a következő egyedi számok generálhatók:\n              8 (eredeti), 3 (8 -> 3), és 5 (8 -> 5).\n    \"\"\"", "es": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Genera todos los números únicos a partir del número dado aplicando reglas de transformación.\n\n    Cada regla permite transformar un solo dígito en otro. Se utiliza una búsqueda en anchura\n    (BFS) para explorar todas las posibles transformaciones. La función devuelve el conteo\n    de números únicos que se pueden generar a partir del número original, incluyendo el número mismo.\n\n    Argumentos:\n    - n (int): El número entero original a transformar.\n    - rules (list of tuples): Una lista de reglas de transformación, donde cada regla se representa\n                              como una tupla (x, y) indicando que el dígito x puede transformarse en y.\n\n    Devuelve:\n    - int: El conteo total de números únicos que se pueden generar.\n\n    Casos:\n    - Caso 1: n = 234, rules = [(2, 5), (3, 6)]\n              Este caso debería devolver 4 porque se pueden generar los siguientes números únicos:\n              234 (original), 534 (2 -> 5), 264 (3 -> 6), y 564 (2 -> 5, 3 -> 6).\n\n    - Caso 2: n = 100, rules = [(1, 9)]\n              Este caso debería devolver 2 porque se pueden generar los siguientes números únicos:\n              100 (original) y 900 (1 -> 9).\n\n    - Caso 3: n = 8, rules = [(8, 3), (8, 5)]\n              Este caso debería devolver 3 porque se pueden generar los siguientes números únicos:\n              8 (original), 3 (8 -> 3), y 5 (8 -> 5).\n    \"\"\"", "arb": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    توليد جميع الأرقام الفريدة من الرقم المعطى عن طريق تطبيق قواعد التحويل.\n\n    كل قاعدة تسمح بتحويل رقم واحد إلى آخر. يتم استخدام البحث بعرض أول (BFS)\n    لاستكشاف جميع التحويلات الممكنة. تُرجع الدالة عدد الأرقام الفريدة التي يمكن توليدها\n    من الرقم الأصلي، بما في ذلك الرقم نفسه.\n\n    يعيدالحجج:\n    - n (int): الرقم الصحيح الأصلي للتحويل.\n    - rules (list of tuples): قائمة بقواعد التحويل، حيث يتم تمثيل كل قاعدة\n                              كزوج (x, y) يشير إلى أن الرقم x يمكن تحويله إلى y.\n\n    يعيد:\n    - int: العدد الإجمالي للأرقام الفريدة التي يمكن توليدها.\n\n    حالات:\n    - الحالة 1: n = 234, rules = [(2, 5), (3, 6)]\n              يجب أن تُرجع هذه الحالة 4 لأن الأرقام الفريدة التالية يمكن توليدها:\n              234 (الأصلي), 534 (2 -> 5), 264 (3 -> 6), و 564 (2 -> 5, 3 -> 6).\n\n    - الحالة 2: n = 100, rules = [(1, 9)]\n              يجب أن تُرجع هذه الحالة 2 لأن الأرقام الفريدة التالية يمكن توليدها:\n              100 (الأصلي) و 900 (1 -> 9).\n\n    - الحالة 3: n = 8, rules = [(8, 3), (8, 5)]\n              يجب أن تُرجع هذه الحالة 3 لأن الأرقام الفريدة التالية يمكن توليدها:\n              8 (الأصلي), 3 (8 -> 3), و 5 (8 -> 5).\n    \"\"\"", "sw": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Tengeneza namba zote za kipekee kutoka kwa namba iliyotolewa kwa kutumia sheria za mabadiliko.\n\n    Kila sheria inaruhusu tarakimu moja kubadilishwa kuwa nyingine. Utafutaji wa upana kwanza\n    (BFS) unatumika kuchunguza mabadiliko yote yanayowezekana. Kazi inarudisha idadi\n    ya namba za kipekee ambazo zinaweza kutengenezwa kutoka kwa namba ya asili, ikiwa ni pamoja na namba yenyewe.\n\n    Hoja:\n    - n (int): Namba ya asili ya integer kubadilisha.\n    - rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria inawakilishwa\n                              kama jozi (x, y) ikionyesha kwamba tarakimu x inaweza kubadilishwa kuwa y.\n\n    Inarudi:\n    - int: Jumla ya idadi ya namba za kipekee ambazo zinaweza kutengenezwa.\n\n    Matukio:\n    - Tukio 1: n = 234, rules = [(2, 5), (3, 6)]\n              Tukio hili linapaswa kurudisha 4 kwa sababu namba zifuatazo za kipekee zinaweza kutengenezwa:\n              234 (asili), 534 (2 -> 5), 264 (3 -> 6), na 564 (2 -> 5, 3 -> 6).\n\n    - Tukio 2: n = 100, rules = [(1, 9)]\n              Tukio hili linapaswa kurudisha 2 kwa sababu namba zifuatazo za kipekee zinaweza kutengenezwa:\n              100 (asili) na 900 (1 -> 9).\n\n    - Tukio 3: n = 8, rules = [(8, 3), (8, 5)]\n              Tukio hili linapaswa kurudisha 3 kwa sababu namba zifuatazo za kipekee zinaweza kutengenezwa:\n              8 (asili), 3 (8 -> 3), na 5 (8 -> 5).\n    \"\"\"", "tr": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Verilen sayıyı dönüştürme kurallarını uygulayarak tüm benzersiz sayıları oluştur.\n\n    Her kural, tek bir rakamın başka bir rakama dönüştürülmesine izin verir. Tüm olası\n    dönüşümleri keşfetmek için genişlik öncelikli arama (BFS) kullanılır. Fonksiyon, orijinal\n    sayı da dahil olmak üzere, orijinal sayıdan üretilebilecek benzersiz sayıların sayısını döndürür.\n\n    Argümanlar:\n    - n (int): Dönüştürülecek orijinal tamsayı.\n    - rules (list of tuples): Her bir kuralın bir (x, y) ikilisi olarak temsil edildiği dönüşüm\n                              kurallarının listesi, burada x rakamının y'ye dönüştürülebileceği belirtilir.\n\n    Döndürür:\n    - int: Üretilebilecek toplam benzersiz sayıların sayısı.\n\n    Durumlar:\n    - Durum 1: n = 234, rules = [(2, 5), (3, 6)]\n              Bu durum 4 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n              234 (orijinal), 534 (2 -> 5), 264 (3 -> 6) ve 564 (2 -> 5, 3 -> 6).\n\n    - Durum 2: n = 100, rules = [(1, 9)]\n              Bu durum 2 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n              100 (orijinal) ve 900 (1 -> 9).\n\n    - Durum 3: n = 8, rules = [(8, 3), (8, 5)]\n              Bu durum 3 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n              8 (orijinal), 3 (8 -> 3) ve 5 (8 -> 5).\n    \"\"\"", "vi": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Tạo tất cả các số duy nhất từ số đã cho bằng cách áp dụng các quy tắc biến đổi.\n\n    Mỗi quy tắc cho phép một chữ số được biến đổi thành chữ số khác. Tìm kiếm theo chiều rộng\n    (BFS) được sử dụng để khám phá tất cả các biến đổi có thể. Hàm trả về số lượng\n    các số duy nhất có thể được tạo ra từ số gốc, bao gồm cả số đó.\n\n    Tham số:\n    - n (int): Số nguyên ban đầu để biến đổi.\n    - rules (list of tuples): Danh sách các quy tắc biến đổi, trong đó mỗi quy tắc được biểu diễn\n                              dưới dạng một bộ (x, y) cho biết chữ số x có thể được biến đổi thành y.\n\n    Trả về:\n    - int: Tổng số các số duy nhất có thể được tạo ra.\n\n    Trường hợp:\n    - Trường hợp 1: n = 234, rules = [(2, 5), (3, 6)]\n              Trường hợp này nên trả về 4 vì các số duy nhất sau có thể được tạo ra:\n              234 (gốc), 534 (2 -> 5), 264 (3 -> 6), và 564 (2 -> 5, 3 -> 6).\n\n    - Trường hợp 2: n = 100, rules = [(1, 9)]\n              Trường hợp này nên trả về 2 vì các số duy nhất sau có thể được tạo ra:\n              100 (gốc) và 900 (1 -> 9).\n\n    - Trường hợp 3: n = 8, rules = [(8, 3), (8, 5)]\n              Trường hợp này nên trả về 3 vì các số duy nhất sau có thể được tạo ra:\n              8 (gốc), 3 (8 -> 3), và 5 (8 -> 5).\n    \"\"\"", "id": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Menghasilkan semua angka unik dari angka yang diberikan dengan menerapkan aturan transformasi.\n\n    Setiap aturan memungkinkan satu digit untuk diubah menjadi digit lain. Pencarian pertama\n    (BFS) digunakan untuk mengeksplorasi semua kemungkinan transformasi. Fungsi ini mengembalikan jumlah\n    angka unik yang dapat dihasilkan dari angka asli, termasuk angka itu sendiri.\n\n    Argumen:\n    - n (int): Angka integer asli untuk ditransformasikan.\n    - rules (list of tuples): Daftar aturan transformasi, di mana setiap aturan diwakili\n                              sebagai tuple (x, y) yang menunjukkan bahwa digit x dapat diubah menjadi y.\n\n    Mengembalikan:\n    - int: Jumlah total angka unik yang dapat dihasilkan.\n\n    Kasus:\n    - Kasus 1: n = 234, rules = [(2, 5), (3, 6)]\n              Kasus ini harus mengembalikan 4 karena angka unik berikut dapat dihasilkan:\n              234 (asli), 534 (2 -> 5), 264 (3 -> 6), dan 564 (2 -> 5, 3 -> 6).\n\n    - Kasus 2: n = 100, rules = [(1, 9)]\n              Kasus ini harus mengembalikan 2 karena angka unik berikut dapat dihasilkan:\n              100 (asli) dan 900 (1 -> 9).\n\n    - Kasus 3: n = 8, rules = [(8, 3), (8, 5)]\n              Kasus ini harus mengembalikan 3 karena angka unik berikut dapat dihasilkan:\n              8 (asli), 3 (8 -> 3), dan 5 (8 -> 5).\n    \"\"\"", "ja": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    与えられた数から変換ルールを適用してすべてのユニークな数を生成します。\n\n    各ルールは、1つの数字を別の数字に変換することを許可します。幅優先探索（BFS）を使用して、\n    すべての可能な変換を探索します。この関数は、元の数を含む、生成可能なユニークな数の\n    カウントを返します。\n\n    引数:\n    - n (int): 変換する元の整数。\n    - rules (list of tuples): 変換ルールのリストで、各ルールはタプル (x, y) として表され、\n                              数字 x が y に変換できることを示します。\n\n    戻り値:\n    - int: 生成可能なユニークな数の総数。\n\n    ケース:\n    - ケース 1: n = 234, rules = [(2, 5), (3, 6)]\n              このケースは 4 を返すべきです。なぜなら、以下のユニークな数が生成できるからです:\n              234 (元の数), 534 (2 -> 5), 264 (3 -> 6), および 564 (2 -> 5, 3 -> 6)。\n\n    - ケース 2: n = 100, rules = [(1, 9)]\n              このケースは 2 を返すべきです。なぜなら、以下のユニークな数が生成できるからです:\n              100 (元の数) および 900 (1 -> 9)。\n\n    - ケース 3: n = 8, rules = [(8, 3), (8, 5)]\n              このケースは 3 を返すべきです。なぜなら、以下のユニークな数が生成できるからです:\n              8 (元の数), 3 (8 -> 3), および 5 (8 -> 5)。\n    \"\"\"", "ko": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    주어진 숫자에서 변환 규칙을 적용하여 모든 고유한 숫자를 생성합니다.\n\n    각 규칙은 한 자리 숫자를 다른 숫자로 변환할 수 있게 합니다. 너비 우선 탐색\n    (BFS)을 사용하여 가능한 모든 변환을 탐색합니다. 함수는 원래 숫자를 포함하여\n    원래 숫자에서 생성할 수 있는 고유한 숫자의 개수를 반환합니다.\n\n    매개변수:\n    - n (int): 변환할 원래 정수.\n    - rules (list of tuples): 변환 규칙의 목록으로, 각 규칙은 (x, y) 형태의 튜플로\n                              표시되며, 이는 숫자 x가 y로 변환될 수 있음을 나타냅니다.\n\n    반환값:\n    - int: 생성할 수 있는 고유한 숫자의 총 개수.\n\n    사례:\n    - 사례 1: n = 234, rules = [(2, 5), (3, 6)]\n              이 경우 4를 반환해야 합니다. 생성할 수 있는 고유한 숫자는 다음과 같습니다:\n              234 (원래), 534 (2 -> 5), 264 (3 -> 6), 그리고 564 (2 -> 5, 3 -> 6).\n\n    - 사례 2: n = 100, rules = [(1, 9)]\n              이 경우 2를 반환해야 합니다. 생성할 수 있는 고유한 숫자는 다음과 같습니다:\n              100 (원래) 및 900 (1 -> 9).\n\n    - 사례 3: n = 8, rules = [(8, 3), (8, 5)]\n              이 경우 3을 반환해야 합니다. 생성할 수 있는 고유한 숫자는 다음과 같습니다:\n              8 (원래), 3 (8 -> 3), 그리고 5 (8 -> 5).\n    \"\"\"", "ml": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    നൽകിയിരിക്കുന്ന സംഖ്യയിൽ നിന്ന് മാറ്റം വരുത്തുന്ന നിയമങ്ങൾ പ്രയോഗിച്ച് എല്ലാ അതുല്യമായ സംഖ്യകളും സൃഷ്ടിക്കുക.\n\n    ഓരോ നിയമവും ഒരു അക്കത്തെ മറ്റൊന്നാക്കി മാറ്റാൻ അനുവദിക്കുന്നു. എല്ലാ സാധ്യതയുള്ള മാറ്റങ്ങളും\n    അന്വേഷിക്കാൻ വീതി-ആദ്യമെന്ന (BFS) തിരച്ചിൽ ഉപയോഗിക്കുന്നു. \n    ഈ ഫംഗ്ഷൻ, സംഖ്യയുൾപ്പെടെ, മൂല സംഖ്യയിൽ നിന്ന് സൃഷ്ടിക്കാവുന്ന അതുല്യമായ സംഖ്യകളുടെ എണ്ണം തിരികെ നൽകുന്നു.\n\n    Args:\n    - n (int): മാറ്റാൻ ഉദ്ദേശിക്കുന്ന മൂലപദമായ പൂർണ്ണസംഖ്യ.\n    - rules (list of tuples): മാറ്റം വരുത്തുന്ന നിയമങ്ങളുടെ പട്ടിക, ഓരോ നിയമവും\n                              (x, y) എന്ന രൂപത്തിൽ പ്രതിനിധീകരിക്കുന്നു, \n                              ഇത് x എന്ന അക്കം y ആക്കി മാറ്റാം എന്നർത്ഥം.\n\n    Returns:\n    - int: സൃഷ്ടിക്കാവുന്ന അതുല്യമായ സംഖ്യകളുടെ ആകെ എണ്ണം.\n\n    ഉദാഹരണങ്ങൾ:\n    - ഉദാഹരണം 1: n = 234, rules = [(2, 5), (3, 6)]\n              ഈ ഉദാഹരണം 4 തിരികെ നൽകണം കാരണം താഴെ പറയുന്ന അതുല്യമായ സംഖ്യകൾ സൃഷ്ടിക്കാവുന്നതാണ്:\n              234 (മൂലപദം), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n    - ഉദാഹരണം 2: n = 100, rules = [(1, 9)]\n              ഈ ഉദാഹരണം 2 തിരികെ നൽകണം കാരണം താഴെ പറയുന്ന അതുല്യമായ സംഖ്യകൾ സൃഷ്ടിക്കാവുന്നതാണ്:\n              100 (മൂലപദം) and 900 (1 -> 9).\n\n    - ഉദാഹരണം 3: n = 8, rules = [(8, 3), (8, 5)]\n              ഈ ഉദാഹരണം 3 തിരികെ നൽകണം കാരണം താഴെ പറയുന്ന അതുല്യമായ സംഖ്യകൾ സൃഷ്ടിക്കാവുന്നതാണ്:\n              8 (മൂലപദം), 3 (8 -> 3), and 5 (8 -> 5).\n    \"\"\"", "fa": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    تولید تمام اعداد منحصر به فرد از عدد داده شده با اعمال قوانین تبدیل.\n\n    هر قانون اجازه می‌دهد یک رقم به رقم دیگری تبدیل شود. از جستجوی اول سطح \n    (BFS) برای بررسی تمام تبدیل‌های ممکن استفاده می‌شود. تابع تعداد \n    اعداد منحصر به فردی که می‌توان از عدد اصلی تولید کرد، شامل خود عدد، را برمی‌گرداند.\n\n    آرگومان‌ها:\n    - n (int): عدد صحیح اصلی که باید تبدیل شود.\n    - rules (list of tuples): لیستی از قوانین تبدیل، که هر قانون به صورت \n                              یک جفت (x, y) نشان داده می‌شود که نشان می‌دهد \n                              رقم x می‌تواند به y تبدیل شود.\n\n    بازگشت:\n    - int: تعداد کل اعداد منحصر به فردی که می‌توان تولید کرد.\n\n    موارد:\n    - مورد 1: n = 234, rules = [(2, 5), (3, 6)]\n              این مورد باید 4 را برگرداند زیرا اعداد منحصر به فرد زیر می‌توانند تولید شوند:\n              234 (اصلی), 534 (2 -> 5), 264 (3 -> 6), و 564 (2 -> 5, 3 -> 6).\n\n    - مورد 2: n = 100, rules = [(1, 9)]\n              این مورد باید 2 را برگرداند زیرا اعداد منحصر به فرد زیر می‌توانند تولید شوند:\n              100 (اصلی) و 900 (1 -> 9).\n\n    - مورد 3: n = 8, rules = [(8, 3), (8, 5)]\n              این مورد باید 3 را برگرداند زیرا اعداد منحصر به فرد زیر می‌توانند تولید شوند:\n              8 (اصلی), 3 (8 -> 3), و 5 (8 -> 5).\n    \"\"\""}, "canonical_solution": "    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)", "instruction": {"en": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nনিচের পাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nदिए गए Python कोड के लिए अधिकतम 500 वर्णों का उपयोग करते हुए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें।", "hu": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\n以下のPythonコードの説明を日本語で簡潔に記述してください。500文字以内でお願いします。", "ko": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nപൈതൺ കോഡിന്റെ സംക്ഷിപ്തമായ പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nبرای کد پایتون یک توضیح مختصر به زبان طبیعی (docstring) به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_generate_numbers():\n    # Test case 1\n    n1, k1 = 234, 2\n    rules1 = [(2, 5), (3, 6)]\n    assert generate_numbers(n1, rules1) == 4, \"Test case 1 failed\"\n\n    # Test case 2\n    n2, k2 = 123, 3\n    rules2 = [(1, 9), (2, 8), (3, 7)]\n    assert generate_numbers(n2, rules2) == 8, \"Test case 2 failed\"\n\n    # Test case 3\n    n3, k3 = 999, 1\n    rules3 = [(9, 1)]\n    assert generate_numbers(n3, rules3) == 8, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function\ntest_generate_numbers()", "entry_point": "generate_numbers", "signature": "def generate_numbers(n, rules) -> int:", "docstring": {"en": "Generate all unique numbers from the given number by applying transformation rules.\n\nEach rule allows a single digit to be transformed into another. A breadth-first search\n(BFS) is used to explore all possible transformations. The function returns the count\nof unique numbers that can be generated from the original number, including the number itself.\n\nArgs:\n- n (int): The original integer number to transform.\n- rules (list of tuples): A list of transformation rules, where each rule is represented\nas a tuple (x, y) indicating that digit x can be transformed into y.\n\nReturns:\n- int: The total count of unique numbers that can be generated.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nThis case should return 4 because the following unique numbers can be generated:\n234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nThis case should return 2 because the following unique numbers can be generated:\n100 (original) and 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nThis case should return 3 because the following unique numbers can be generated:\n8 (original), 3 (8 -> 3), and 5 (8 -> 5).", "sq": "Gjenero të gjitha numrat unikë nga numri i dhënë duke aplikuar rregullat e transformimit.\n\nÇdo rregull lejon që një shifër e vetme të transformohet në një tjetër. Një kërkim në gjerësi\n(BFS) përdoret për të eksploruar të gjitha transformimet e mundshme. Funksioni kthen numrin\ne numrave unikë që mund të gjenerohen nga numri origjinal, duke përfshirë vetë numrin.\n\nArgumentet:\n- n (int): Numri origjinal i plotë për të transformuar.\n- rules (listë e treshave): Një listë e rregullave të transformimit, ku çdo rregull përfaqësohet\nsi një treshe (x, y) që tregon se shifra x mund të transformohet në y.\n\nKthen:\n- int: Numri total i numrave unikë që mund të gjenerohen.\n\nRastet:\n- Rasti 1: n = 234, rules = [(2, 5), (3, 6)]\nKy rast duhet të kthejë 4 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n234 (origjinal), 534 (2 -> 5), 264 (3 -> 6), dhe 564 (2 -> 5, 3 -> 6).\n\n- Rasti 2: n = 100, rules = [(1, 9)]\nKy rast duhet të kthejë 2 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n100 (origjinal) dhe 900 (1 -> 9).\n\n- Rasti 3: n = 8, rules = [(8, 3), (8, 5)]\nKy rast duhet të kthejë 3 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n8 (origjinal), 3 (8 -> 3), dhe 5 (8 -> 5).", "hy": "Տրված թվից գեներացնել բոլոր եզակի թվերը՝ կիրառելով փոխակերպման կանոններ։\n\nՅուրաքանչյուր կանոն թույլ է տալիս միանիշ թվանշանը փոխակերպել մեկ այլ թվանշանի։ Լայնությամբ նախնական որոնում (BFS) օգտագործվում է բոլոր հնարավոր փոխակերպումները ուսումնասիրելու համար։ Ֆունկցիան վերադարձնում է եզակի թվերի քանակը, որոնք կարող են գեներացվել սկզբնական թվից, ներառյալ ինքը՝ թիվը։\n\nԱրձագանքներ:\n- n (int): Սկզբնական ամբողջ թիվը, որը պետք է փոխակերպել։\n- rules (ցանկ, որը բաղկացած է զույգերից): Փոխակերպման կանոնների ցանկ, որտեղ յուրաքանչյուր կանոն ներկայացված է որպես զույգ (x, y), որը ցույց է տալիս, որ թվանշան x-ը կարող է փոխակերպվել y-ի։\n\nՎերադարձնում է:\n- int: Գեներացվող եզակի թվերի ընդհանուր քանակը։\n\nԴեպքեր:\n- Դեպք 1: n = 234, rules = [(2, 5), (3, 6)]\nԱյս դեպքը պետք է վերադարձնի 4, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը՝ 234 (սկզբնական), 534 (2 -> 5), 264 (3 -> 6) և 564 (2 -> 5, 3 -> 6)։\n\n- Դեպք 2: n = 100, rules = [(1, 9)]\nԱյս դեպքը պետք է վերադարձնի 2, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը՝ 100 (սկզբնական) և 900 (1 -> 9)։\n\n- Դեպք 3: n = 8, rules = [(8, 3), (8, 5)]\nԱյս դեպքը պետք է վերադարձնի 3, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը՝ 8 (սկզբնական), 3 (8 -> 3) և 5 (8 -> 5)։", "bn": "প্রদত্ত সংখ্যাটি থেকে সমস্ত অনন্য সংখ্যা তৈরি করুন রূপান্তর নিয়ম প্রয়োগ করে।\n\nপ্রতিটি নিয়ম একটি একক অঙ্ককে অন্যটিতে রূপান্তর করার অনুমতি দেয়। সমস্ত সম্ভাব্য রূপান্তর অন্বেষণ করতে একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) ব্যবহার করা হয়। ফাংশনটি মূল সংখ্যাটি সহ যে সমস্ত অনন্য সংখ্যা তৈরি করা যেতে পারে তার গণনা প্রদান করে।\n\nআর্গস:\n- n (int): রূপান্তর করার জন্য মূল পূর্ণসংখ্যা।\n- rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল (x, y) দ্বারা উপস্থাপিত হয় যা নির্দেশ করে যে অঙ্ক x কে y তে রূপান্তর করা যেতে পারে।\n\nরিটার্নস:\n- int: যে সমস্ত অনন্য সংখ্যা তৈরি করা যেতে পারে তার মোট গণনা।\n\nকেস:\n- কেস 1: n = 234, rules = [(2, 5), (3, 6)]\nএই ক্ষেত্রে 4 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n234 (মূল), 534 (2 -> 5), 264 (3 -> 6), এবং 564 (2 -> 5, 3 -> 6)।\n\n- কেস 2: n = 100, rules = [(1, 9)]\nএই ক্ষেত্রে 2 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n100 (মূল) এবং 900 (1 -> 9)।\n\n- কেস 3: n = 8, rules = [(8, 3), (8, 5)]\nএই ক্ষেত্রে 3 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n8 (মূল), 3 (8 -> 3), এবং 5 (8 -> 5)।", "bg": "Генерирайте всички уникални числа от даденото число чрез прилагане на правила за трансформация.\n\nВсяко правило позволява една цифра да бъде трансформирана в друга. Използва се търсене в ширина (BFS), за да се изследват всички възможни трансформации. Функцията връща броя на уникалните числа, които могат да бъдат генерирани от оригиналното число, включително самото число.\n\nАргументи:\n- n (int): Оригиналното цяло число за трансформация.\n- rules (списък от кортежи): Списък с правила за трансформация, където всяко правило е представено\nкато кортеж (x, y), указващ, че цифрата x може да бъде трансформирана в y.\n\nВръща:\n- int: Общият брой на уникалните числа, които могат да бъдат генерирани.\n\nСлучаи:\n- Случай 1: n = 234, rules = [(2, 5), (3, 6)]\nТози случай трябва да върне 4, защото могат да бъдат генерирани следните уникални числа:\n234 (оригинал), 534 (2 -> 5), 264 (3 -> 6) и 564 (2 -> 5, 3 -> 6).\n\n- Случай 2: n = 100, rules = [(1, 9)]\nТози случай трябва да върне 2, защото могат да бъдат генерирани следните уникални числа:\n100 (оригинал) и 900 (1 -> 9).\n\n- Случай 3: n = 8, rules = [(8, 3), (8, 5)]\nТози случай трябва да върне 3, защото могат да бъдат генерирани следните уникални числа:\n8 (оригинал), 3 (8 -> 3) и 5 (8 -> 5).", "zh": "生成所有从给定数字通过应用转换规则得到的唯一数字。\n\n每个规则允许将一个数字转换为另一个数字。使用广度优先搜索（BFS）来探索所有可能的转换。该函数返回可以从原始数字生成的唯一数字的数量，包括数字本身。\n\n参数：\n- n (int): 要转换的原始整数。\n- rules (list of tuples): 转换规则的列表，其中每个规则表示为一个元组 (x, y)，表示数字 x 可以转换为 y。\n\n返回：\n- int: 可以生成的唯一数字的总数。\n\n案例：\n- 案例 1: n = 234, rules = [(2, 5), (3, 6)]\n这个案例应该返回 4，因为可以生成以下唯一数字：234（原始），534（2 -> 5），264（3 -> 6），和 564（2 -> 5, 3 -> 6）。\n\n- 案例 2: n = 100, rules = [(1, 9)]\n这个案例应该返回 2，因为可以生成以下唯一数字：100（原始）和 900（1 -> 9）。\n\n- 案例 3: n = 8, rules = [(8, 3), (8, 5)]\n这个案例应该返回 3，因为可以生成以下唯一数字：8（原始），3（8 -> 3），和 5（8 -> 5）。", "fr": "Générer tous les nombres uniques à partir du nombre donné en appliquant des règles de transformation.\n\nChaque règle permet de transformer un seul chiffre en un autre. Une recherche en largeur (BFS) est utilisée pour explorer toutes les transformations possibles. La fonction renvoie le nombre de nombres uniques qui peuvent être générés à partir du nombre original, y compris le nombre lui-même.\n\nArgs:\n- n (int): Le nombre entier original à transformer.\n- rules (liste de tuples): Une liste de règles de transformation, où chaque règle est représentée\ncomme un tuple (x, y) indiquant que le chiffre x peut être transformé en y.\n\nReturns:\n- int: Le nombre total de nombres uniques qui peuvent être générés.\n\nCas:\n- Cas 1: n = 234, rules = [(2, 5), (3, 6)]\nCe cas devrait retourner 4 car les nombres uniques suivants peuvent être générés :\n234 (original), 534 (2 -> 5), 264 (3 -> 6), et 564 (2 -> 5, 3 -> 6).\n\n- Cas 2: n = 100, rules = [(1, 9)]\nCe cas devrait retourner 2 car les nombres uniques suivants peuvent être générés :\n100 (original) et 900 (1 -> 9).\n\n- Cas 3: n = 8, rules = [(8, 3), (8, 5)]\nCe cas devrait retourner 3 car les nombres uniques suivants peuvent être générés :\n8 (original), 3 (8 -> 3), et 5 (8 -> 5).", "de": "Erzeuge alle einzigartigen Zahlen aus der gegebenen Zahl, indem Transformationsregeln angewendet werden.\n\nJede Regel erlaubt es, eine einzelne Ziffer in eine andere zu transformieren. Eine Breitensuche\n(BFS) wird verwendet, um alle möglichen Transformationen zu erkunden. Die Funktion gibt die Anzahl\nder einzigartigen Zahlen zurück, die aus der ursprünglichen Zahl generiert werden können, einschließlich der Zahl selbst.\n\nArgs:\n- n (int): Die ursprüngliche ganze Zahl, die transformiert werden soll.\n- rules (list von Tupeln): Eine Liste von Transformationsregeln, wobei jede Regel als\nein Tupel (x, y) dargestellt wird, das angibt, dass die Ziffer x in y transformiert werden kann.\n\nReturns:\n- int: Die Gesamtanzahl der einzigartigen Zahlen, die generiert werden können.\n\nFälle:\n- Fall 1: n = 234, rules = [(2, 5), (3, 6)]\nDieser Fall sollte 4 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n234 (original), 534 (2 -> 5), 264 (3 -> 6) und 564 (2 -> 5, 3 -> 6).\n\n- Fall 2: n = 100, rules = [(1, 9)]\nDieser Fall sollte 2 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n100 (original) und 900 (1 -> 9).\n\n- Fall 3: n = 8, rules = [(8, 3), (8, 5)]\nDieser Fall sollte 3 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n8 (original), 3 (8 -> 3) und 5 (8 -> 5).", "ha": "Samar da duk lambobin musamman daga lambar da aka bayar ta hanyar amfani da dokokin sauyi.\n\nKowane doka yana ba da damar sauya lamba guda ɗaya zuwa wata. Ana amfani da binciken nisa na farko (BFS) don bincika dukkan yiwuwar sauye-sauye. Aikin yana mayar da adadin lambobi na musamman da za a iya samarwa daga lambar asali, ciki har da lambar kanta.\n\nArgs:\n- n (int): Lambar asali ta cikakken lamba don sauyawa.\n- rules (jerin tuples): Jerin dokokin sauyi, inda kowace doka ke wakiltar\na matsayin tuple (x, y) yana nuna cewa ana iya sauya lamba x zuwa y.\n\nReturns:\n- int: Jimillar adadin lambobi na musamman da za a iya samarwa.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nWannan yanayin ya kamata ya dawo da 4 saboda ana iya samar da lambobi na musamman masu zuwa:\n234 (asali), 534 (2 -> 5), 264 (3 -> 6), da 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nWannan yanayin ya kamata ya dawo da 2 saboda ana iya samar da lambobi na musamman masu zuwa:\n100 (asali) da 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nWannan yanayin ya kamata ya dawo da 3 saboda ana iya samar da lambobi na musamman masu zuwa:\n8 (asali), 3 (8 -> 3), da 5 (8 -> 5).", "hi": "दिए गए संख्या से सभी अद्वितीय संख्याएँ उत्पन्न करें, परिवर्तन नियम लागू करके।\n\nप्रत्येक नियम एकल अंक को दूसरे में बदलने की अनुमति देता है। सभी संभावित परिवर्तनों का पता लगाने के लिए ब्रेड्थ-फर्स्ट सर्च (BFS) का उपयोग किया जाता है। यह फ़ंक्शन उन अद्वितीय संख्याओं की गिनती लौटाता है जो मूल संख्या से उत्पन्न की जा सकती हैं, जिसमें संख्या स्वयं भी शामिल है।\n\nआर्ग्स:\n- n (int): परिवर्तित करने के लिए मूल पूर्णांक संख्या।\n- rules (list of tuples): परिवर्तन नियमों की सूची, जहाँ प्रत्येक नियम को एक ट्यूपल (x, y) के रूप में दर्शाया गया है, जो दर्शाता है कि अंक x को y में परिवर्तित किया जा सकता है।\n\nरिटर्न्स:\n- int: उत्पन्न की जा सकने वाली अद्वितीय संख्याओं की कुल गिनती।\n\nमामले:\n- मामला 1: n = 234, rules = [(2, 5), (3, 6)]\nयह मामला 4 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n234 (मूल), 534 (2 -> 5), 264 (3 -> 6), और 564 (2 -> 5, 3 -> 6)।\n\n- मामला 2: n = 100, rules = [(1, 9)]\nयह मामला 2 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n100 (मूल) और 900 (1 -> 9)।\n\n- मामला 3: n = 8, rules = [(8, 3), (8, 5)]\nयह मामला 3 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n8 (मूल), 3 (8 -> 3), और 5 (8 -> 5)।", "hu": "Generálja az összes egyedi számot a megadott számból átalakítási szabályok alkalmazásával.\n\nMinden szabály lehetővé teszi egyetlen számjegy átalakítását egy másikra. Egy szélességi keresést (BFS) használnak az összes lehetséges átalakítás feltárására. A függvény visszaadja az eredeti számból generálható egyedi számok számát, beleértve magát a számot is.\n\nArgs:\n- n (int): Az eredeti egész szám, amelyet át kell alakítani.\n- rules (list of tuples): Az átalakítási szabályok listája, ahol minden szabály egy (x, y) tuple-ként van ábrázolva, jelezve, hogy az x számjegy átalakítható y-ra.\n\nReturns:\n- int: Az összes generálható egyedi szám teljes száma.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nEz az eset 4-et kell, hogy visszaadjon, mert a következő egyedi számok generálhatók: 234 (eredeti), 534 (2 -> 5), 264 (3 -> 6), és 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nEz az eset 2-t kell, hogy visszaadjon, mert a következő egyedi számok generálhatók: 100 (eredeti) és 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nEz az eset 3-at kell, hogy visszaadjon, mert a következő egyedi számok generálhatók: 8 (eredeti), 3 (8 -> 3), és 5 (8 -> 5).", "es": "Generar todos los números únicos a partir del número dado aplicando reglas de transformación.\n\nCada regla permite que un solo dígito se transforme en otro. Se utiliza una búsqueda en amplitud\n(BFS) para explorar todas las posibles transformaciones. La función devuelve el conteo\nde números únicos que se pueden generar a partir del número original, incluido el número en sí.\n\nArgumentos:\n- n (int): El número entero original a transformar.\n- rules (list of tuples): Una lista de reglas de transformación, donde cada regla se representa\ncomo una tupla (x, y) indicando que el dígito x puede transformarse en y.\n\nDevuelve:\n- int: El conteo total de números únicos que se pueden generar.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nEste caso debería devolver 4 porque se pueden generar los siguientes números únicos:\n234 (original), 534 (2 -> 5), 264 (3 -> 6), y 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nEste caso debería devolver 2 porque se pueden generar los siguientes números únicos:\n100 (original) y 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nEste caso debería devolver 3 porque se pueden generar los siguientes números únicos:\n8 (original), 3 (8 -> 3), y 5 (8 -> 5).", "arb": "توليد جميع الأرقام الفريدة من الرقم المعطى عن طريق تطبيق قواعد التحويل.\n\nتسمح كل قاعدة بتحويل رقم واحد إلى آخر. يتم استخدام البحث بعرض أول (BFS) لاستكشاف جميع التحويلات الممكنة. تقوم الدالة بإرجاع عدد الأرقام الفريدة التي يمكن توليدها من الرقم الأصلي، بما في ذلك الرقم نفسه.\n\nالمعطيات:\n- n (int): الرقم الصحيح الأصلي للتحويل.\n- rules (list of tuples): قائمة بقواعد التحويل، حيث يتم تمثيل كل قاعدة كزوج (x, y) يشير إلى أن الرقم x يمكن تحويله إلى y.\n\nالقيم المعادة:\n- int: العدد الإجمالي للأرقام الفريدة التي يمكن توليدها.\n\nالحالات:\n- الحالة 1: n = 234, rules = [(2, 5), (3, 6)]\nيجب أن تعيد هذه الحالة 4 لأن الأرقام الفريدة التالية يمكن توليدها:\n234 (الأصلي)، 534 (2 -> 5)، 264 (3 -> 6)، و 564 (2 -> 5, 3 -> 6).\n\n- الحالة 2: n = 100, rules = [(1, 9)]\nيجب أن تعيد هذه الحالة 2 لأن الأرقام الفريدة التالية يمكن توليدها:\n100 (الأصلي) و 900 (1 -> 9).\n\n- الحالة 3: n = 8, rules = [(8, 3), (8, 5)]\nيجب أن تعيد هذه الحالة 3 لأن الأرقام الفريدة التالية يمكن توليدها:\n8 (الأصلي)، 3 (8 -> 3)، و 5 (8 -> 5).", "sw": "Tengeneza namba zote za kipekee kutoka kwa namba iliyotolewa kwa kutumia sheria za mabadiliko.\n\nKila kanuni inaruhusu tarakimu moja kubadilishwa kuwa nyingine. Utafutaji wa upana-kwanza (BFS) unatumika kuchunguza mabadiliko yote yanayowezekana. Kazi inarudisha idadi ya nambari za kipekee ambazo zinaweza kuzalishwa kutoka kwa nambari ya asili, ikiwa ni pamoja na nambari yenyewe.\n\nHoja:\n- n (int): Nambari ya awali ya nambari nzima kubadilisha.\n- rules (list of tuples): Orodha ya kanuni za mabadiliko, ambapo kila kanuni inawakilishwa\nkama jozi (x, y) ikionyesha kwamba tarakimu x inaweza kubadilishwa kuwa y.\n\nInarejesha:\n- int: Jumla ya idadi ya nambari za kipekee ambazo zinaweza kuzalishwa.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nKesi hii inapaswa kurudisha 4 kwa sababu nambari zifuatazo za kipekee zinaweza kuzalishwa:\n234 (asili), 534 (2 -> 5), 264 (3 -> 6), na 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nKesi hii inapaswa kurudisha 2 kwa sababu nambari zifuatazo za kipekee zinaweza kuzalishwa:\n100 (asili) na 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nKesi hii inapaswa kurudisha 3 kwa sababu nambari zifuatazo za kipekee zinaweza kuzalishwa:\n8 (asili), 3 (8 -> 3), na 5 (8 -> 5).", "tr": "Verilen sayıdan dönüşüm kurallarını uygulayarak tüm benzersiz sayıları oluşturun.\n\nHer kural, tek bir rakamın başka bir rakama dönüştürülmesine izin verir. Tüm olası dönüşümleri keşfetmek için genişlik öncelikli arama (BFS) kullanılır. Fonksiyon, orijinal sayı da dahil olmak üzere, orijinal sayıdan üretilebilecek benzersiz sayıların sayısını döndürür.\n\nArgümanlar:\n- n (int): Dönüştürülecek orijinal tam sayı.\n- rules (list of tuples): Her kuralın, x rakamının y'ye dönüştürülebileceğini belirten bir demet (x, y) olarak temsil edildiği dönüşüm kuralları listesi.\n\nDöndürür:\n- int: Üretilebilecek benzersiz sayıların toplam sayısı.\n\nDurumlar:\n- Durum 1: n = 234, rules = [(2, 5), (3, 6)]\nBu durum 4 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n234 (orijinal), 534 (2 -> 5), 264 (3 -> 6) ve 564 (2 -> 5, 3 -> 6).\n\n- Durum 2: n = 100, rules = [(1, 9)]\nBu durum 2 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n100 (orijinal) ve 900 (1 -> 9).\n\n- Durum 3: n = 8, rules = [(8, 3), (8, 5)]\nBu durum 3 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n8 (orijinal), 3 (8 -> 3) ve 5 (8 -> 5).", "vi": "Tạo tất cả các số duy nhất từ số đã cho bằng cách áp dụng các quy tắc biến đổi.\n\nMỗi quy tắc cho phép một chữ số được biến đổi thành chữ số khác. Tìm kiếm theo chiều rộng (BFS) được sử dụng để khám phá tất cả các biến đổi có thể. Hàm trả về số lượng các số duy nhất có thể được tạo ra từ số gốc, bao gồm cả số đó.\n\nTham số:\n- n (int): Số nguyên gốc để biến đổi.\n- rules (list of tuples): Danh sách các quy tắc biến đổi, trong đó mỗi quy tắc được biểu diễn\nnhư một bộ (x, y) chỉ ra rằng chữ số x có thể được biến đổi thành y.\n\nTrả về:\n- int: Tổng số các số duy nhất có thể được tạo ra.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nTrường hợp này nên trả về 4 vì các số duy nhất sau có thể được tạo ra:\n234 (gốc), 534 (2 -> 5), 264 (3 -> 6), và 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nTrường hợp này nên trả về 2 vì các số duy nhất sau có thể được tạo ra:\n100 (gốc) và 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nTrường hợp này nên trả về 3 vì các số duy nhất sau có thể được tạo ra:\n8 (gốc), 3 (8 -> 3), và 5 (8 -> 5).", "id": "Hasilkan semua angka unik dari angka yang diberikan dengan menerapkan aturan transformasi.\n\nSetiap aturan memungkinkan satu digit untuk diubah menjadi digit lain. Pencarian pertama-breadth (BFS) digunakan untuk mengeksplorasi semua kemungkinan transformasi. Fungsi ini mengembalikan jumlah angka unik yang dapat dihasilkan dari angka asli, termasuk angka itu sendiri.\n\nArgs:\n- n (int): Angka integer asli yang akan diubah.\n- rules (list of tuples): Daftar aturan transformasi, di mana setiap aturan diwakili\nsebagai tuple (x, y) yang menunjukkan bahwa digit x dapat diubah menjadi y.\n\nReturns:\n- int: Jumlah total angka unik yang dapat dihasilkan.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nKasus ini harus mengembalikan 4 karena angka unik berikut dapat dihasilkan:\n234 (asli), 534 (2 -> 5), 264 (3 -> 6), dan 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nKasus ini harus mengembalikan 2 karena angka unik berikut dapat dihasilkan:\n100 (asli) dan 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nKasus ini harus mengembalikan 3 karena angka unik berikut dapat dihasilkan:\n8 (asli), 3 (8 -> 3), dan 5 (8 -> 5).", "ja": "与えられた数から変換ルールを適用して、すべてのユニークな数を生成します。\n\n各ルールは、1つの数字を別の数字に変換することを許可します。幅優先探索（BFS）を使用して、すべての可能な変換を探索します。この関数は、元の数を含む、生成可能なユニークな数の数を返します。\n\n引数:\n- n (int): 変換する元の整数。\n- rules (list of tuples): 変換ルールのリストで、各ルールはタプル (x, y) で表され、数字 x が y に変換できることを示します。\n\n戻り値:\n- int: 生成可能なユニークな数の総数。\n\nケース:\n- ケース 1: n = 234, rules = [(2, 5), (3, 6)]\nこのケースは4を返すべきです。なぜなら、以下のユニークな数が生成できるからです:\n234 (元の数), 534 (2 -> 5), 264 (3 -> 6), および 564 (2 -> 5, 3 -> 6)。\n\n- ケース 2: n = 100, rules = [(1, 9)]\nこのケースは2を返すべきです。なぜなら、以下のユニークな数が生成できるからです:\n100 (元の数) および 900 (1 -> 9)。\n\n- ケース 3: n = 8, rules = [(8, 3), (8, 5)]\nこのケースは3を返すべきです。なぜなら、以下のユニークな数が生成できるからです:\n8 (元の数), 3 (8 -> 3), および 5 (8 -> 5)。", "ko": "주어진 숫자에서 변환 규칙을 적용하여 모든 고유한 숫자를 생성합니다.\n\n각 규칙은 한 자리 숫자를 다른 숫자로 변환할 수 있게 합니다. 너비 우선 탐색(BFS)을 사용하여 가능한 모든 변환을 탐색합니다. 이 함수는 원래 숫자를 포함하여 원래 숫자에서 생성할 수 있는 고유한 숫자의 개수를 반환합니다.\n\nArgs:\n- n (int): 변환할 원래 정수 숫자.\n- rules (list of tuples): 변환 규칙의 목록으로, 각 규칙은 튜플 (x, y)로 표현되며, 이는 숫자 x가 y로 변환될 수 있음을 나타냅니다.\n\nReturns:\n- int: 생성할 수 있는 고유한 숫자의 총 개수.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\n이 경우는 4를 반환해야 합니다. 왜냐하면 다음과 같은 고유한 숫자가 생성될 수 있기 때문입니다:\n234 (원래), 534 (2 -> 5), 264 (3 -> 6), 그리고 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\n이 경우는 2를 반환해야 합니다. 왜냐하면 다음과 같은 고유한 숫자가 생성될 수 있기 때문입니다:\n100 (원래)와 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\n이 경우는 3을 반환해야 합니다. 왜냐하면 다음과 같은 고유한 숫자가 생성될 수 있기 때문입니다:\n8 (원래), 3 (8 -> 3), 그리고 5 (8 -> 5).", "ml": "നൽകിയിരിക്കുന്ന സംഖ്യയിൽ നിന്ന് മാറ്റം വരുത്തൽ നിയമങ്ങൾ പ്രയോഗിച്ച് എല്ലാ അതുല്യ സംഖ്യകളും സൃഷ്ടിക്കുക.\n\nഓരോ നിയമവും ഒരു അക്കത്തെ മറ്റൊന്നായി മാറ്റാൻ അനുവദിക്കുന്നു. എല്ലാ സാധ്യതയുള്ള മാറ്റങ്ങൾ അന്വേഷിക്കാൻ വീതി-ആദ്യ തിരച്ചിൽ (BFS) ഉപയോഗിക്കുന്നു. മൂല സംഖ്യയടക്കം, മൂല സംഖ്യയിൽ നിന്ന് സൃഷ്ടിക്കാവുന്ന അതുല്യ സംഖ്യകളുടെ എണ്ണം ഫലമായി നൽകുന്നു.\n\nആർഗുകൾ:\n- n (int): മാറ്റം വരുത്തേണ്ട യഥാർത്ഥ പൂജ്യം.\n- rules (list of tuples): ഓരോ നിയമവും (x, y) എന്ന രൂപത്തിൽ പ്രതിനിധീകരിക്കുന്ന, അക്ക x y ആയി മാറ്റാവുന്നതാണ് എന്ന സൂചിപ്പിക്കുന്ന മാറ്റം വരുത്തൽ നിയമങ്ങളുടെ പട്ടിക.\n\nമടക്കം:\n- int: സൃഷ്ടിക്കാവുന്ന അതുല്യ സംഖ്യകളുടെ മൊത്തം എണ്ണം.\n\nകേസുകൾ:\n- കേസ് 1: n = 234, rules = [(2, 5), (3, 6)]\nഈ കേസ് 4 എന്ന ഫലം നൽകണം കാരണം താഴെപ്പറയുന്ന അതുല്യ സംഖ്യകൾ സൃഷ്ടിക്കാവുന്നതാണ്: 234 (യഥാർത്ഥം), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n- കേസ് 2: n = 100, rules = [(1, 9)]\nഈ കേസ് 2 എന്ന ഫലം നൽകണം കാരണം താഴെപ്പറയുന്ന അതുല്യ സംഖ്യകൾ സൃഷ്ടിക്കാവുന്നതാണ്: 100 (യഥാർത്ഥം) and 900 (1 -> 9).\n\n- കേസ് 3: n = 8, rules = [(8, 3), (8, 5)]\nഈ കേസ് 3 എന്ന ഫലം നൽകണം കാരണം താഴെപ്പറയുന്ന അതുല്യ സംഖ്യകൾ സൃഷ്ടിക്കാവുന്നതാണ്: 8 (യഥാർത്ഥം), 3 (8 -> 3), and 5 (8 -> 5).", "fa": "تولید تمام اعداد منحصر به فرد از عدد داده شده با اعمال قوانین تبدیل.\n\nهر قانون اجازه می‌دهد که یک رقم به رقم دیگری تبدیل شود. جستجوی اول-به-عرض (BFS) برای بررسی تمام تبدیلات ممکن استفاده می‌شود. تابع تعداد اعداد منحصر به فردی که می‌توان از عدد اصلی تولید کرد، شامل خود عدد، را برمی‌گرداند.\n\nآرگومان‌ها:\n- n (int): عدد صحیح اصلی برای تبدیل.\n- rules (list of tuples): لیستی از قوانین تبدیل، که هر قانون به صورت یک جفت (x, y) نشان داده می‌شود که نشان می‌دهد رقم x می‌تواند به y تبدیل شود.\n\nبازگشت:\n- int: تعداد کل اعداد منحصر به فردی که می‌توان تولید کرد.\n\nموارد:\n- مورد 1: n = 234, rules = [(2, 5), (3, 6)]\nاین مورد باید 4 را برگرداند زیرا اعداد منحصر به فرد زیر می‌توانند تولید شوند:\n234 (اصلی)، 534 (2 -> 5)، 264 (3 -> 6)، و 564 (2 -> 5, 3 -> 6).\n\n- مورد 2: n = 100, rules = [(1, 9)]\nاین مورد باید 2 را برگرداند زیرا اعداد منحصر به فرد زیر می‌توانند تولید شوند:\n100 (اصلی) و 900 (1 -> 9).\n\n- مورد 3: n = 8, rules = [(8, 3), (8, 5)]\nاین مورد باید 3 را برگرداند زیرا اعداد منحصر به فرد زیر می‌توانند تولید شوند:\n8 (اصلی)، 3 (8 -> 3)، و 5 (8 -> 5)."}}
{"task_id": "Python/32", "prompt": {"en": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      True if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      False if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      True if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\n      since statements about the day of the week are ignored.\n    \"\"\"\n    # Function implementation...", "sq": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Vlerëson konsistencën e një skenari ku një pjesëmarrës është krimineli bazuar në deklaratat e dhëna.\n\n    Kjo funksion merr emrin e një krimineli potencial (skenari) dhe një grup gënjeshtarësh (liar_count) dhe kontrollon nëse\n    deklaratat e bëra nga të gjithë pjesëmarrësit janë konsistente me këtë skenar, duke injoruar çdo deklaratë\n    rreth ditës së javës.\n\n    Parametrat:\n    - scenario (str): Emri i pjesëmarrësit që po testohet si kriminel potencial.\n    - liar_count (set): Një grup emrash të pjesëmarrësve që supozohet të jenë gënjeshtarë.\n    - statements (dict): Një fjalor që lidh emrat e pjesëmarrësve me listat e deklaratave të tyre përkatëse.\n    - days_of_week (set): Një grup vargjesh që përfaqësojnë ditët e javës.\n\n    Kthen:\n    - bool: True nëse skenari është konsistent me deklaratat, False përndryshe.\n\n    Raste Testimi:\n    - Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\n      True nëse \"ALICE\" thotë \"I am guilty.\", \"BOB\" thotë \"ALICE is not guilty.\", dhe \"CHARLIE\" nuk bën deklarata relevante.\n\n    - Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\n      False nëse \"ALICE\" thotë \"I am not guilty.\", \"BOB\" thotë \"ALICE is guilty.\", që kundërshton skenarin.\n\n    - Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\n      True nëse \"ALICE\" thotë \"I am guilty.\", \"BOB\" thotë \"Today is MONDAY\", dhe \"CHARLIE\" thotë \"ALICE is guilty.\",\n      pasi deklaratat rreth ditës së javës injorohen.\n    \"\"\"\n    # Zbatimi i funksionit...", "hy": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Գնահատում է սցենարի հետևողականությունը, որտեղ մեկ մասնակիցը հանցագործ է՝ հիմնված տրված հայտարարությունների վրա:\n\n    Այս ֆունկցիան ընդունում է հնարավոր հանցագործի անունը (scenario) և ստախոսների հավաքածու (liar_count) և ստուգում է,\n    արդյոք բոլոր մասնակիցների հայտարարությունները հետևողական են այս սցենարի հետ՝ անտեսելով շաբաթվա օրվա մասին\n    հայտարարությունները:\n\n    Պարամետրեր:\n    - scenario (str): Մասնակցի անունը, որը փորձարկվում է որպես հնարավոր հանցագործ:\n    - liar_count (set): Մասնակիցների անունների հավաքածու, որոնք համարվում են ստախոսներ:\n    - statements (dict): Բառարան, որը կապում է մասնակիցների անունները նրանց համապատասխան հայտարարությունների ցուցակների հետ:\n    - days_of_week (set): Տողերի հավաքածու, որը ներկայացնում է շաբաթվա օրերը:\n\n    Վերադարձնում է:\n    - bool: True, եթե սցենարը հետևողական է հայտարարությունների հետ, False՝ հակառակ դեպքում:\n\n    Թեստային դեպքեր:\n    - Տրված սցենար, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\n      True, եթե \"ALICE\"-ը ասում է \"I am guilty.\", \"BOB\"-ը ասում է \"ALICE is not guilty.\", և \"CHARLIE\"-ն չի անում\n      համապատասխան հայտարարություններ:\n\n    - Տրված սցենար, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\n      False, եթե \"ALICE\"-ը ասում է \"I am not guilty.\", \"BOB\"-ը ասում է \"ALICE is guilty.\", ինչը հակասում է սցենարին:\n\n    - Տրված սցենար, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\n      True, եթե \"ALICE\"-ը ասում է \"I am guilty.\", \"BOB\"-ը ասում է \"Today is MONDAY\", և \"CHARLIE\"-ն ասում է \"ALICE is guilty.\",\n      քանի որ շաբաթվա օրվա մասին հայտարարությունները անտեսվում են:\n    \"\"\"\n    # Function implementation...", "bn": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    প্রদত্ত বিবৃতির উপর ভিত্তি করে এক অংশগ্রহণকারী অপরাধী এমন একটি দৃশ্যের সামঞ্জস্য মূল্যায়ন করে।\n\n    এই ফাংশনটি সম্ভাব্য অপরাধীর নাম (scenario) এবং মিথ্যাবাদীদের একটি সেট (liar_count) নেয় এবং পরীক্ষা করে\n    যে সমস্ত অংশগ্রহণকারীর দ্বারা প্রদত্ত বিবৃতিগুলি এই দৃশ্যের সাথে সামঞ্জস্যপূর্ণ কিনা, সপ্তাহের দিনের \n    সম্পর্কে কোনো বিবৃতি উপেক্ষা করে।\n\n    প্যারামিটার:\n    - scenario (str): সম্ভাব্য অপরাধী হিসাবে পরীক্ষিত অংশগ্রহণকারীর নাম।\n    - liar_count (set): অংশগ্রহণকারীদের নামের একটি সেট যারা মিথ্যাবাদী বলে মনে করা হয়।\n    - statements (dict): অংশগ্রহণকারীদের নামকে তাদের সংশ্লিষ্ট বিবৃতির তালিকার সাথে ম্যাপ করে এমন একটি অভিধান।\n    - days_of_week (set): সপ্তাহের দিনের প্রতিনিধিত্বকারী স্ট্রিংগুলির একটি সেট।\n\n    রিটার্নস:\n    - bool: যদি দৃশ্যটি বিবৃতির সাথে সামঞ্জস্যপূর্ণ হয় তবে True, অন্যথায় False।\n\n    পরীক্ষার কেস:\n    - একটি দৃশ্য দেওয়া হয়েছে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি \n      True রিটার্ন করা উচিত যদি \"ALICE\" বলে \"I am guilty.\", \"BOB\" বলে \"ALICE is not guilty.\", এবং \n      \"CHARLIE\" কোনো প্রাসঙ্গিক বিবৃতি না দেয়।\n\n    - একটি দৃশ্য দেওয়া হয়েছে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি \n      False রিটার্ন করা উচিত যদি \"ALICE\" বলে \"I am not guilty.\", \"BOB\" বলে \"ALICE is guilty.\", যা \n      দৃশ্যের সাথে বিরোধ করে।\n\n    - একটি দৃশ্য দেওয়া হয়েছে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি \n      True রিটার্ন করা উচিত যদি \"ALICE\" বলে \"I am guilty.\", \"BOB\" বলে \"Today is MONDAY\", এবং \n      \"CHARLIE\" বলে \"ALICE is guilty.\", যেহেতু সপ্তাহের দিনের সম্পর্কে বিবৃতিগুলি উপেক্ষা করা হয়।\n    \"\"\"\n    # Function implementation...", "bg": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Оценява последователността на сценарий, в който един участник е престъпникът въз основа на дадените изявления.\n\n    Тази функция приема името на потенциалния престъпник (scenario) и набор от лъжци (liar_count) и проверява дали\n    изявленията, направени от всички участници, са последователни с този сценарий, като се пренебрегват изявленията\n    за деня от седмицата.\n\n    Параметри:\n    - scenario (str): Името на участника, който се тества като потенциален престъпник.\n    - liar_count (set): Набор от имена на участници, които се приемат за лъжци.\n    - statements (dict): Речник, който свързва имената на участниците със списъци на техните съответни изявления.\n    - days_of_week (set): Набор от низове, представляващи дните от седмицата.\n\n    Връща:\n    - bool: True, ако сценарият е последователен с изявленията, False в противен случай.\n\n    Тестови случаи:\n    - При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\n      True, ако \"ALICE\" казва \"I am guilty.\", \"BOB\" казва \"ALICE is not guilty.\", и \"CHARLIE\" не прави релевантни изявления.\n\n    - При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\n      False, ако \"ALICE\" казва \"I am not guilty.\", \"BOB\" казва \"ALICE is guilty.\", което противоречи на сценария.\n\n    - При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\n      True, ако \"ALICE\" казва \"I am guilty.\", \"BOB\" казва \"Today is MONDAY\", и \"CHARLIE\" казва \"ALICE is guilty.\",\n      тъй като изявленията за деня от седмицата се игнорират.\n    \"\"\"\n    # Function implementation...", "zh": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    评估一个场景的连贯性，其中一名参与者是基于给定陈述的罪犯。\n\n    此函数接受一个潜在罪犯的名字（scenario）和一组说谎者（liar_count），并检查所有参与者的陈述是否与此场景一致，\n    忽略任何关于星期几的陈述。\n\n    参数:\n    - scenario (str): 被测试为潜在罪犯的参与者的名字。\n    - liar_count (set): 假定为说谎者的参与者名字集合。\n    - statements (dict): 一个字典，将参与者名字映射到各自陈述的列表。\n    - days_of_week (set): 表示一周中各天的字符串集合。\n\n    返回:\n    - bool: 如果场景与陈述一致，则返回 True，否则返回 False。\n\n    测试用例:\n    - 给定一个场景，其中 \"ALICE\" 是罪犯，\"BOB\" 和 \"CHARLIE\" 是说谎者，如果 \"ALICE\" 说 \"I am guilty.\",\n      \"BOB\" 说 \"ALICE is not guilty.\", 并且 \"CHARLIE\" 没有做出相关陈述，函数应返回 True。\n\n    - 给定一个场景，其中 \"ALICE\" 是罪犯，\"BOB\" 和 \"CHARLIE\" 是说谎者，如果 \"ALICE\" 说 \"I am not guilty.\",\n      \"BOB\" 说 \"ALICE is guilty.\", 这与场景矛盾，函数应返回 False。\n\n    - 给定一个场景，其中 \"ALICE\" 是罪犯，\"BOB\" 和 \"CHARLIE\" 是说谎者，如果 \"ALICE\" 说 \"I am guilty.\",\n      \"BOB\" 说 \"Today is MONDAY\", 并且 \"CHARLIE\" 说 \"ALICE is guilty.\",\n      由于关于星期几的陈述被忽略，函数应返回 True。\n    \"\"\"\n    # Function implementation...", "fr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Évalue la cohérence d'un scénario où un participant est le criminel basé sur les déclarations données.\n\n    Cette fonction prend le nom d'un criminel potentiel (scenario) et un ensemble de menteurs (liar_count) et vérifie si\n    les déclarations faites par tous les participants sont cohérentes avec ce scénario, en ignorant toute déclaration\n    concernant le jour de la semaine.\n\n    Paramètres:\n    - scenario (str): Le nom du participant testé en tant que criminel potentiel.\n    - liar_count (set): Un ensemble de noms de participants supposés être des menteurs.\n    - statements (dict): Un dictionnaire associant les noms des participants à des listes de leurs déclarations respectives.\n    - days_of_week (set): Un ensemble de chaînes représentant les jours de la semaine.\n\n    Renvoie:\n    - bool: True si le scénario est cohérent avec les déclarations, False sinon.\n\n    Cas de test:\n    - Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait retourner\n      True si \"ALICE\" dit \"I am guilty.\", \"BOB\" dit \"ALICE is not guilty.\", et \"CHARLIE\" ne fait aucune déclaration pertinente.\n\n    - Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait retourner\n      False si \"ALICE\" dit \"I am not guilty.\", \"BOB\" dit \"ALICE is guilty.\", ce qui contredit le scénario.\n\n    - Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait retourner\n      True si \"ALICE\" dit \"I am guilty.\", \"BOB\" dit \"Today is MONDAY\", et \"CHARLIE\" dit \"ALICE is guilty.\",\n      puisque les déclarations concernant le jour de la semaine sont ignorées.\n    \"\"\"\n    # Implémentation de la fonction...", "de": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Bewertet die Konsistenz eines Szenarios, in dem ein Teilnehmer der Kriminelle ist, basierend auf den gegebenen Aussagen.\n\n    Diese Funktion nimmt den Namen eines potenziellen Kriminellen (Szenario) und eine Menge von Lügnern (liar_count) und überprüft,\n    ob die Aussagen aller Teilnehmer mit diesem Szenario konsistent sind, wobei Aussagen über den Wochentag ignoriert werden.\n\n    Parameter:\n    - scenario (str): Der Name des Teilnehmers, der als potenzieller Krimineller getestet wird.\n    - liar_count (set): Eine Menge von Namen der Teilnehmer, die als Lügner angenommen werden.\n    - statements (dict): Ein Wörterbuch, das Teilnehmernamen auf Listen ihrer jeweiligen Aussagen abbildet.\n    - days_of_week (set): Eine Menge von Zeichenfolgen, die die Wochentage darstellen.\n\n    Rückgabewerte:\n    - bool: True, wenn das Szenario mit den Aussagen konsistent ist, andernfalls False.\n\n    Testfälle:\n    - Gegeben ein Szenario, in dem \"ALICE\" die Kriminelle ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion\n      True zurückgeben, wenn \"ALICE\" sagt \"I am guilty.\", \"BOB\" sagt \"ALICE is not guilty.\", und \"CHARLIE\" keine relevanten Aussagen macht.\n\n    - Gegeben ein Szenario, in dem \"ALICE\" die Kriminelle ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion\n      False zurückgeben, wenn \"ALICE\" sagt \"I am not guilty.\", \"BOB\" sagt \"ALICE is guilty.\", was dem Szenario widerspricht.\n\n    - Gegeben ein Szenario, in dem \"ALICE\" die Kriminelle ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion\n      True zurückgeben, wenn \"ALICE\" sagt \"I am guilty.\", \"BOB\" sagt \"Today is MONDAY\", und \"CHARLIE\" sagt \"ALICE is guilty.\",\n      da Aussagen über den Wochentag ignoriert werden.\n    \"\"\"\n    # Funktionsimplementierung...", "ha": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Yana tantance daidaiton wani yanayi inda ɗaya daga cikin mahalarta shine mai laifi bisa ga bayanan da aka bayar.\n\n    Wannan aikin yana ɗaukar sunan mai laifi mai yuwuwa (scenario) da kuma saitin maƙaryata (liar_count) kuma yana duba idan\n    bayanan da duk mahalarta suka bayar suna daidai da wannan yanayin, ba tare da la'akari da duk wani bayani\n    game da ranar mako ba.\n\n    Sigogi:\n    - scenario (str): Sunan mahalarta da ake gwadawa a matsayin mai laifi mai yuwuwa.\n    - liar_count (set): Saiti na sunayen mahalarta waɗanda ake ɗauka a matsayin maƙaryata.\n    - statements (dict): Kamus ɗin da ke haɗa sunayen mahalarta da jerin bayanan su na musamman.\n    - days_of_week (set): Saiti na kirtani da ke wakiltar ranakun mako.\n\n    Yana dawowa:\n    - bool: True idan yanayin ya dace da bayanan, False in ba haka ba.\n\n    Gwaje-gwaje:\n    - An bayar da wani yanayi inda \"ALICE\" ita ce mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\n      True idan \"ALICE\" ta ce \"I am guilty.\", \"BOB\" ya ce \"ALICE is not guilty.\", kuma \"CHARLIE\" bai yi wani bayani mai mahimmanci ba.\n\n    - An bayar da wani yanayi inda \"ALICE\" ita ce mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\n      False idan \"ALICE\" ta ce \"I am not guilty.\", \"BOB\" ya ce \"ALICE is guilty.\", wanda ya saba wa yanayin.\n\n    - An bayar da wani yanayi inda \"ALICE\" ita ce mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\n      True idan \"ALICE\" ta ce \"I am guilty.\", \"BOB\" ya ce \"Today is MONDAY\", kuma \"CHARLIE\" ya ce \"ALICE is guilty.\",\n      tun da bayanai game da ranar mako an yi watsi da su.\n    \"\"\"\n    # Function implementation...", "hi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    एक परिदृश्य की संगति का मूल्यांकन करता है जहाँ एक प्रतिभागी दिए गए बयानों के आधार पर अपराधी होता है।\n\n    यह फ़ंक्शन एक संभावित अपराधी का नाम (scenario) और झूठे माने जाने वाले प्रतिभागियों का सेट (liar_count) लेता है और\n    सभी प्रतिभागियों द्वारा किए गए बयानों की इस परिदृश्य के साथ संगति की जाँच करता है, सप्ताह के दिन के बारे में किसी भी बयान को\n    नजरअंदाज करते हुए।\n\n    पैरामीटर्स:\n    - scenario (str): उस प्रतिभागी का नाम जिसका संभावित अपराधी के रूप में परीक्षण किया जा रहा है।\n    - liar_count (set): प्रतिभागियों के नामों का एक सेट जो झूठे माने जाते हैं।\n    - statements (dict): प्रतिभागी के नामों को उनके संबंधित बयानों की सूचियों से मैप करने वाली एक डिक्शनरी।\n    - days_of_week (set): सप्ताह के दिनों का प्रतिनिधित्व करने वाले स्ट्रिंग्स का एक सेट।\n\n    रिटर्न्स:\n    - bool: True अगर परिदृश्य बयानों के साथ संगत है, अन्यथा False।\n\n    परीक्षण मामले:\n    - एक परिदृश्य दिया गया है जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, तो फ़ंक्शन को True लौटाना चाहिए\n      अगर \"ALICE\" कहती है \"I am guilty.\", \"BOB\" कहता है \"ALICE is not guilty.\", और \"CHARLIE\" कोई प्रासंगिक बयान नहीं देता।\n\n    - एक परिदृश्य दिया गया है जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, तो फ़ंक्शन को False लौटाना चाहिए\n      अगर \"ALICE\" कहती है \"I am not guilty.\", \"BOB\" कहता है \"ALICE is guilty.\", जो परिदृश्य का खंडन करता है।\n\n    - एक परिदृश्य दिया गया है जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, तो फ़ंक्शन को True लौटाना चाहिए\n      अगर \"ALICE\" कहती है \"I am guilty.\", \"BOB\" कहता है \"Today is MONDAY\", और \"CHARLIE\" कहता है \"ALICE is guilty.\",\n      क्योंकि सप्ताह के दिन के बारे में बयान नजरअंदाज किए जाते हैं।\n    \"\"\"\n    # Function implementation...", "hu": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Egy forgatókönyv konzisztenciájának értékelése, ahol az egyik résztvevő a bűnöző a megadott állítások alapján.\n\n    Ez a függvény egy potenciális bűnöző nevét (forgatókönyv) és egy hazugok halmazát (liar_count) veszi, és ellenőrzi,\n    hogy az összes résztvevő által tett állítások konzisztens-e ezzel a forgatókönyvvel, figyelmen kívül hagyva a hét napjára\n    vonatkozó állításokat.\n\n    Paraméterek:\n    - scenario (str): A résztvevő neve, akit potenciális bűnözőként tesztelnek.\n    - liar_count (set): A hazugnak feltételezett résztvevők neveit tartalmazó halmaz.\n    - statements (dict): Egy szótár, amely a résztvevők neveit a hozzájuk tartozó állítások listájához rendeli.\n    - days_of_week (set): A hét napjait képviselő karakterláncok halmaza.\n\n    Visszatérési érték:\n    - bool: Igaz, ha a forgatókönyv konzisztens az állításokkal, hamis egyébként.\n\n    Tesztesetek:\n    - Adott egy forgatókönyv, ahol \"ALICE\" a bűnöző, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek igazat kell visszaadnia,\n      ha \"ALICE\" azt mondja \"Bűnös vagyok.\", \"BOB\" azt mondja \"ALICE nem bűnös.\", és \"CHARLIE\" nem tesz releváns állításokat.\n\n    - Adott egy forgatókönyv, ahol \"ALICE\" a bűnöző, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek hamisat kell visszaadnia,\n      ha \"ALICE\" azt mondja \"Nem vagyok bűnös.\", \"BOB\" azt mondja \"ALICE bűnös.\", ami ellentmond a forgatókönyvnek.\n\n    - Adott egy forgatókönyv, ahol \"ALICE\" a bűnöző, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek igazat kell visszaadnia,\n      ha \"ALICE\" azt mondja \"Bűnös vagyok.\", \"BOB\" azt mondja \"Ma HÉTFŐ van\", és \"CHARLIE\" azt mondja \"ALICE bűnös.\",\n      mivel a hét napjára vonatkozó állítások figyelmen kívül vannak hagyva.\n    \"\"\"\n    # Function implementation...", "es": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evalúa la consistencia de un escenario donde un participante es el criminal basado en las declaraciones dadas.\n\n    Esta función toma el nombre de un posible criminal (scenario) y un conjunto de mentirosos (liar_count) y verifica si\n    las declaraciones hechas por todos los participantes son consistentes con este escenario, ignorando cualquier declaración\n    sobre el día de la semana.\n\n    Parámetros:\n    - scenario (str): El nombre del participante que se está probando como el posible criminal.\n    - liar_count (set): Un conjunto de nombres de participantes que se asumen como mentirosos.\n    - statements (dict): Un diccionario que mapea nombres de participantes a listas de sus respectivas declaraciones.\n    - days_of_week (set): Un conjunto de cadenas que representan los días de la semana.\n\n    Retorna:\n    - bool: True si el escenario es consistente con las declaraciones, False en caso contrario.\n\n    Casos de Prueba:\n    - Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería retornar\n      True si \"ALICE\" dice \"I am guilty.\", \"BOB\" dice \"ALICE is not guilty.\", y \"CHARLIE\" no hace declaraciones relevantes.\n\n    - Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería retornar\n      False si \"ALICE\" dice \"I am not guilty.\", \"BOB\" dice \"ALICE is guilty.\", lo cual contradice el escenario.\n\n    - Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería retornar\n      True si \"ALICE\" dice \"I am guilty.\", \"BOB\" dice \"Today is MONDAY\", y \"CHARLIE\" dice \"ALICE is guilty.\",\n      ya que las declaraciones sobre el día de la semana se ignoran.\n    \"\"\"\n    # Implementación de la función...", "arb": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    يقيم اتساق سيناريو حيث يكون أحد المشاركين هو المجرم بناءً على التصريحات المعطاة.\n\n    تأخذ هذه الدالة اسم المجرم المحتمل (scenario) ومجموعة من الكاذبين (liar_count) وتتحقق مما إذا كانت\n    التصريحات التي أدلى بها جميع المشاركين متسقة مع هذا السيناريو، متجاهلة أي تصريحات\n    حول يوم الأسبوع.\n\n    المعاملات:\n    - scenario (str): اسم المشارك الذي يتم اختباره كمجرم محتمل.\n    - liar_count (set): مجموعة من أسماء المشاركين الذين يُفترض أنهم كاذبون.\n    - statements (dict): قاموس يربط أسماء المشاركين بقوائم تصريحاتهم الخاصة.\n    - days_of_week (set): مجموعة من السلاسل النصية التي تمثل أيام الأسبوع.\n\n    يعيد:\n    - bool: True إذا كان السيناريو متسقًا مع التصريحات، False خلاف ذلك.\n\n    حالات الاختبار:\n    - بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و \"BOB\" و \"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\n      True إذا قالت \"ALICE\" \"I am guilty.\"، وقال \"BOB\" \"ALICE is not guilty.\"، ولم يقدم \"CHARLIE\" أي تصريحات ذات صلة.\n\n    - بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و \"BOB\" و \"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\n      False إذا قالت \"ALICE\" \"I am not guilty.\"، وقال \"BOB\" \"ALICE is guilty.\"، مما يتناقض مع السيناريو.\n\n    - بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و \"BOB\" و \"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\n      True إذا قالت \"ALICE\" \"I am guilty.\"، وقال \"BOB\" \"Today is MONDAY\"، وقال \"CHARLIE\" \"ALICE is guilty.\"،\n      حيث يتم تجاهل التصريحات حول يوم الأسبوع.\n    \"\"\"\n    # Function implementation...", "sw": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Inatathmini uthabiti wa hali ambapo mshiriki mmoja ni mhalifu kulingana na kauli zilizotolewa.\n\n    Kazi hii inachukua jina la mhalifu anayewezekana (scenario) na seti ya waongo (liar_count) na inakagua\n    kama kauli zilizotolewa na washiriki wote zinakubaliana na hali hii, bila kujali kauli zozote kuhusu siku ya wiki.\n\n    Vigezo:\n    - scenario (str): Jina la mshiriki anayepimwa kama mhalifu anayewezekana.\n    - liar_count (set): Seti ya majina ya washiriki wanaodhaniwa kuwa waongo.\n    - statements (dict): Kamusi inayochanganua majina ya washiriki na orodha za kauli zao husika.\n    - days_of_week (set): Seti ya misururu inayowakilisha siku za wiki.\n\n    Inarudisha:\n    - bool: Kweli ikiwa hali inakubaliana na kauli, Si kweli vinginevyo.\n\n    Visa vya Majaribio:\n    - Ikitolewa hali ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurudisha\n      Kweli ikiwa \"ALICE\" anasema \"I am guilty.\", \"BOB\" anasema \"ALICE is not guilty.\", na \"CHARLIE\" hafanyi kauli zozote husika.\n\n    - Ikitolewa hali ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurudisha\n      Si kweli ikiwa \"ALICE\" anasema \"I am not guilty.\", \"BOB\" anasema \"ALICE is guilty.\", ambayo inapingana na hali hiyo.\n\n    - Ikitolewa hali ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurudisha\n      Kweli ikiwa \"ALICE\" anasema \"I am guilty.\", \"BOB\" anasema \"Today is MONDAY\", na \"CHARLIE\" anasema \"ALICE is guilty.\",\n      kwa kuwa kauli kuhusu siku ya wiki zinapuuzwa.\n    \"\"\"\n    # Function implementation...", "tr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Verilen ifadeler temelinde bir katılımcının suçlu olduğu bir senaryonun tutarlılığını değerlendirir.\n\n    Bu fonksiyon, potansiyel suçlunun adını (senaryo) ve yalancıların bir kümesini (liar_count) alır ve\n    haftanın günü hakkındaki ifadeleri göz ardı ederek, tüm katılımcıların yaptığı ifadelerin bu senaryoyla\n    tutarlı olup olmadığını kontrol eder.\n\n    Parametreler:\n    - scenario (str): Potansiyel suçlu olarak test edilen katılımcının adı.\n    - liar_count (set): Yalancı olduğu varsayılan katılımcıların adlarının bulunduğu bir küme.\n    - statements (dict): Katılımcı adlarını, onların ilgili ifadelerinin listelerine eşleyen bir sözlük.\n    - days_of_week (set): Haftanın günlerini temsil eden stringlerin bulunduğu bir küme.\n\n    Döndürür:\n    - bool: Senaryo ifadelerle tutarlıysa True, aksi takdirde False.\n\n    Test Durumları:\n    - \"ALICE\" suçlu olduğu bir senaryo verildiğinde ve \"BOB\" ve \"CHARLIE\" yalancı olduğunda, fonksiyon\n      \"ALICE\" \"Ben suçluyum.\" derse, \"BOB\" \"ALICE suçlu değil.\" derse ve \"CHARLIE\" ilgili bir ifade yapmazsa\n      True döndürmelidir.\n\n    - \"ALICE\" suçlu olduğu bir senaryo verildiğinde ve \"BOB\" ve \"CHARLIE\" yalancı olduğunda, fonksiyon\n      \"ALICE\" \"Ben suçlu değilim.\" derse, \"BOB\" \"ALICE suçlu.\" derse, bu senaryoyla çeliştiği için\n      False döndürmelidir.\n\n    - \"ALICE\" suçlu olduğu bir senaryo verildiğinde ve \"BOB\" ve \"CHARLIE\" yalancı olduğunda, fonksiyon\n      \"ALICE\" \"Ben suçluyum.\" derse, \"BOB\" \"Bugün PAZARTESİ\" derse ve \"CHARLIE\" \"ALICE suçlu.\" derse,\n      haftanın günü hakkındaki ifadeler göz ardı edildiği için True döndürmelidir.\n    \"\"\"\n    # Function implementation...", "vi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Đánh giá tính nhất quán của một kịch bản nơi một người tham gia là tội phạm dựa trên các tuyên bố đã cho.\n\n    Hàm này nhận tên của một người có thể là tội phạm (scenario) và một tập hợp những người nói dối (liar_count) và kiểm tra xem\n    các tuyên bố được đưa ra bởi tất cả những người tham gia có nhất quán với kịch bản này không, bỏ qua bất kỳ tuyên bố nào\n    về ngày trong tuần.\n\n    Tham số:\n    - scenario (str): Tên của người tham gia đang được kiểm tra như là tội phạm tiềm năng.\n    - liar_count (set): Một tập hợp tên của những người tham gia được cho là nói dối.\n    - statements (dict): Một từ điển ánh xạ tên người tham gia tới danh sách các tuyên bố tương ứng của họ.\n    - days_of_week (set): Một tập hợp các chuỗi đại diện cho các ngày trong tuần.\n\n    Trả về:\n    - bool: True nếu kịch bản nhất quán với các tuyên bố, False nếu không.\n\n    Các trường hợp kiểm tra:\n    - Với một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\n      True nếu \"ALICE\" nói \"I am guilty.\", \"BOB\" nói \"ALICE is not guilty.\", và \"CHARLIE\" không đưa ra tuyên bố liên quan nào.\n\n    - Với một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\n      False nếu \"ALICE\" nói \"I am not guilty.\", \"BOB\" nói \"ALICE is guilty.\", điều này mâu thuẫn với kịch bản.\n\n    - Với một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\n      True nếu \"ALICE\" nói \"I am guilty.\", \"BOB\" nói \"Today is MONDAY\", và \"CHARLIE\" nói \"ALICE is guilty.\",\n      vì các tuyên bố về ngày trong tuần bị bỏ qua.\n    \"\"\"\n    # Function implementation...", "id": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Mengevaluasi konsistensi dari sebuah skenario di mana satu peserta adalah kriminal berdasarkan pernyataan yang diberikan.\n\n    Fungsi ini menerima nama kriminal potensial (skenario) dan satu set pembohong (liar_count) dan memeriksa apakah\n    pernyataan yang dibuat oleh semua peserta konsisten dengan skenario ini, mengabaikan pernyataan apa pun\n    tentang hari dalam seminggu.\n\n    Parameter:\n    - scenario (str): Nama peserta yang diuji sebagai kriminal potensial.\n    - liar_count (set): Satu set nama peserta yang diasumsikan sebagai pembohong.\n    - statements (dict): Sebuah kamus yang memetakan nama peserta ke daftar pernyataan masing-masing.\n    - days_of_week (set): Satu set string yang mewakili hari dalam seminggu.\n\n    Mengembalikan:\n    - bool: True jika skenario konsisten dengan pernyataan, False jika tidak.\n\n    Kasus Uji:\n    - Diberikan skenario di mana \"ALICE\" adalah kriminal, dan \"BOB\" dan \"CHARLIE\" adalah pembohong, fungsi harus mengembalikan\n      True jika \"ALICE\" mengatakan \"I am guilty.\", \"BOB\" mengatakan \"ALICE is not guilty.\", dan \"CHARLIE\" tidak membuat pernyataan yang relevan.\n\n    - Diberikan skenario di mana \"ALICE\" adalah kriminal, dan \"BOB\" dan \"CHARLIE\" adalah pembohong, fungsi harus mengembalikan\n      False jika \"ALICE\" mengatakan \"I am not guilty.\", \"BOB\" mengatakan \"ALICE is guilty.\", yang bertentangan dengan skenario.\n\n    - Diberikan skenario di mana \"ALICE\" adalah kriminal, dan \"BOB\" dan \"CHARLIE\" adalah pembohong, fungsi harus mengembalikan\n      True jika \"ALICE\" mengatakan \"I am guilty.\", \"BOB\" mengatakan \"Today is MONDAY\", dan \"CHARLIE\" mengatakan \"ALICE is guilty.\",\n      karena pernyataan tentang hari dalam seminggu diabaikan.\n    \"\"\"\n    # Implementasi fungsi...", "ja": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    ある参加者が犯罪者であるというシナリオの一貫性を、与えられた証言に基づいて評価します。\n\n    この関数は、潜在的な犯罪者の名前（scenario）と嘘つきとされる参加者のセット（liar_count）を受け取り、\n    すべての参加者によって行われた証言がこのシナリオと一致しているかどうかを確認します。\n    曜日に関する証言は無視されます。\n\n    パラメータ:\n    - scenario (str): 潜在的な犯罪者としてテストされている参加者の名前。\n    - liar_count (set): 嘘つきと仮定される参加者の名前のセット。\n    - statements (dict): 参加者の名前をそれぞれの証言のリストにマッピングする辞書。\n    - days_of_week (set): 曜日を表す文字列のセット。\n\n    戻り値:\n    - bool: 証言とシナリオが一致する場合はTrue、一致しない場合はFalse。\n\n    テストケース:\n    - \"ALICE\"が犯罪者であり、\"BOB\"と\"CHARLIE\"が嘘つきであるというシナリオが与えられた場合、\n      関数は\"ALICE\"が\"I am guilty.\"と言い、\"BOB\"が\"ALICE is not guilty.\"と言い、\n      \"CHARLIE\"が関連する証言をしない場合、Trueを返すべきです。\n\n    - \"ALICE\"が犯罪者であり、\"BOB\"と\"CHARLIE\"が嘘つきであるというシナリオが与えられた場合、\n      関数は\"ALICE\"が\"I am not guilty.\"と言い、\"BOB\"が\"ALICE is guilty.\"と言う場合、\n      シナリオと矛盾するためFalseを返すべきです。\n\n    - \"ALICE\"が犯罪者であり、\"BOB\"と\"CHARLIE\"が嘘つきであるというシナリオが与えられた場合、\n      関数は\"ALICE\"が\"I am guilty.\"と言い、\"BOB\"が\"Today is MONDAY\"と言い、\n      \"CHARLIE\"が\"ALICE is guilty.\"と言う場合、曜日に関する証言は無視されるためTrueを返すべきです。\n    \"\"\"\n    # Function implementation...", "ko": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    주어진 진술에 기반하여 한 참가자가 범인인 시나리오의 일관성을 평가합니다.\n\n    이 함수는 잠재적인 범인의 이름(시나리오)과 거짓말쟁이의 집합(liar_count)을 받아\n    모든 참가자들이 한 진술이 이 시나리오와 일치하는지, 요일에 대한 진술은 무시하고 확인합니다.\n\n    매개변수:\n    - scenario (str): 잠재적인 범인으로 테스트되는 참가자의 이름.\n    - liar_count (set): 거짓말쟁이로 가정되는 참가자들의 이름 집합.\n    - statements (dict): 참가자 이름을 그들의 각 진술 목록에 매핑하는 사전.\n    - days_of_week (set): 요일을 나타내는 문자열의 집합.\n\n    반환값:\n    - bool: 시나리오가 진술과 일치하면 True, 그렇지 않으면 False.\n\n    테스트 케이스:\n    - \"ALICE\"가 범인이고, \"BOB\"와 \"CHARLIE\"가 거짓말쟁이인 시나리오가 주어졌을 때, 함수는\n      \"ALICE\"가 \"I am guilty.\"라고 말하고, \"BOB\"가 \"ALICE is not guilty.\"라고 말하며, \"CHARLIE\"가 관련 없는 진술을 하지 않는 경우 True를 반환해야 합니다.\n\n    - \"ALICE\"가 범인이고, \"BOB\"와 \"CHARLIE\"가 거짓말쟁이인 시나리오가 주어졌을 때, 함수는\n      \"ALICE\"가 \"I am not guilty.\"라고 말하고, \"BOB\"가 \"ALICE is guilty.\"라고 말하는 경우, 이는 시나리오와 모순되므로 False를 반환해야 합니다.\n\n    - \"ALICE\"가 범인이고, \"BOB\"와 \"CHARLIE\"가 거짓말쟁이인 시나리오가 주어졌을 때, 함수는\n      \"ALICE\"가 \"I am guilty.\"라고 말하고, \"BOB\"가 \"Today is MONDAY\"라고 말하며, \"CHARLIE\"가 \"ALICE is guilty.\"라고 말하는 경우, 요일에 대한 진술은 무시되므로 True를 반환해야 합니다.\n    \"\"\"\n    # Function implementation...", "ml": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    ഒരു പങ്കാളി കുറ്റവാളിയാണ് എന്ന സാദ്ധ്യതയുള്ള സാഹചര്യത്തിന്റെ സുസ്ഥിരത നൽകിയ പ്രസ്താവനകളുടെ അടിസ്ഥാനത്തിൽ വിലയിരുത്തുന്നു.\n\n    ഈ ഫംഗ്ഷൻ ഒരു സാദ്ധ്യതയുള്ള കുറ്റവാളിയുടെ പേര് (scenario) കൂടാതെ ഒരു കൂട്ടം കള്ളന്മാരുടെ പേരുകൾ (liar_count) സ്വീകരിക്കുകയും\n    എല്ലാ പങ്കാളികളും നൽകിയ പ്രസ്താവനകൾ ഈ സാഹചര്യവുമായി സുസ്ഥിരമാണോ എന്ന് പരിശോധിക്കുകയും ചെയ്യുന്നു, ആഴ്ചയിലെ ദിവസത്തെക്കുറിച്ചുള്ള\n    പ്രസ്താവനകൾ അവഗണിക്കുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    - scenario (str): സാദ്ധ്യതയുള്ള കുറ്റവാളിയായി പരിശോധിക്കപ്പെടുന്ന പങ്കാളിയുടെ പേര്.\n    - liar_count (set): കള്ളന്മാരായി കരുതപ്പെടുന്ന പങ്കാളികളുടെ പേരുകളുടെ ഒരു സെറ്റ്.\n    - statements (dict): പങ്കാളികളുടെ പേരുകളെ അവരുടെ അനുബന്ധ പ്രസ്താവനകളുടെ പട്ടികയുമായി മാപ്പ് ചെയ്യുന്ന ഒരു ഡിക്ഷണറി.\n    - days_of_week (set): ആഴ്ചയിലെ ദിവസങ്ങളെ പ്രതിനിധീകരിക്കുന്ന സ്ട്രിംഗുകളുടെ ഒരു സെറ്റ്.\n\n    മടക്കുന്നു:\n    - bool: പ്രസ്താവനകളുമായി സുസ്ഥിരമാണെങ്കിൽ True, അല്ലെങ്കിൽ False.\n\n    ടെസ്റ്റ് കേസുകൾ:\n    - \"ALICE\" കുറ്റവാളിയാണ്, \"BOB\" കൂടാതെ \"CHARLIE\" കള്ളന്മാരാണ് എന്ന ഒരു സാഹചര്യത്തിൽ, \"ALICE\" \"I am guilty.\" എന്ന്\n      പറയുന്നു, \"BOB\" \"ALICE is not guilty.\" എന്ന് പറയുന്നു, \"CHARLIE\" യാതൊരു പ്രസക്തമായ പ്രസ്താവനകളും\n      ചെയ്യുന്നില്ലെങ്കിൽ ഫംഗ്ഷൻ True മടക്കണം.\n\n    - \"ALICE\" കുറ്റവാളിയാണ്, \"BOB\" കൂടാതെ \"CHARLIE\" കള്ളന്മാരാണ് എന്ന ഒരു സാഹചര്യത്തിൽ, \"ALICE\" \"I am not guilty.\" എന്ന്\n      പറയുന്നു, \"BOB\" \"ALICE is guilty.\" എന്ന് പറയുന്നു, ഇത് സാഹചര്യവുമായി വിരുദ്ധമാണെങ്കിൽ ഫംഗ്ഷൻ False മടക്കണം.\n\n    - \"ALICE\" കുറ്റവാളിയാണ്, \"BOB\" കൂടാതെ \"CHARLIE\" കള്ളന്മാരാണ് എന്ന ഒരു സാഹചര്യത്തിൽ, \"ALICE\" \"I am guilty.\" എന്ന്\n      പറയുന്നു, \"BOB\" \"Today is MONDAY\" എന്ന് പറയുന്നു, \"CHARLIE\" \"ALICE is guilty.\" എന്ന് പറയുന്നു, ആഴ്ചയിലെ\n      ദിവസത്തെക്കുറിച്ചുള്ള പ്രസ്താവനകൾ അവഗണിക്കപ്പെടുന്നതിനാൽ ഫംഗ്ഷൻ True മടക്കണം.\n    \"\"\"\n    # Function implementation...", "fa": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    ارزیابی سازگاری یک سناریو که در آن یک شرکت‌کننده مجرم است بر اساس اظهارات داده شده.\n\n    این تابع نام یک مجرم احتمالی (سناریو) و مجموعه‌ای از دروغگوها (liar_count) را می‌گیرد و بررسی می‌کند که آیا\n    اظهارات همه شرکت‌کنندگان با این سناریو سازگار است یا خیر، بدون توجه به اظهارات مربوط به روز هفته.\n\n    پارامترها:\n    - scenario (str): نام شرکت‌کننده‌ای که به عنوان مجرم احتمالی آزمایش می‌شود.\n    - liar_count (set): مجموعه‌ای از نام‌های شرکت‌کنندگانی که فرض می‌شود دروغگو هستند.\n    - statements (dict): دیکشنری که نام شرکت‌کنندگان را به لیست اظهارات مربوطه‌شان نگاشت می‌کند.\n    - days_of_week (set): مجموعه‌ای از رشته‌ها که روزهای هفته را نشان می‌دهند.\n\n    بازگشت:\n    - bool: True اگر سناریو با اظهارات سازگار باشد، در غیر این صورت False.\n\n    موارد آزمایشی:\n    - با توجه به سناریویی که در آن \"ALICE\" مجرم است و \"BOB\" و \"CHARLIE\" دروغگو هستند، تابع باید\n      True برگرداند اگر \"ALICE\" بگوید \"I am guilty.\"، \"BOB\" بگوید \"ALICE is not guilty.\"، و \"CHARLIE\" هیچ اظهارات مرتبطی نکند.\n\n    - با توجه به سناریویی که در آن \"ALICE\" مجرم است و \"BOB\" و \"CHARLIE\" دروغگو هستند، تابع باید\n      False برگرداند اگر \"ALICE\" بگوید \"I am not guilty.\"، \"BOB\" بگوید \"ALICE is guilty.\"، که با سناریو تناقض دارد.\n\n    - با توجه به سناریویی که در آن \"ALICE\" مجرم است و \"BOB\" و \"CHARLIE\" دروغگو هستند، تابع باید\n      True برگرداند اگر \"ALICE\" بگوید \"I am guilty.\"، \"BOB\" بگوید \"Today is MONDAY\"، و \"CHARLIE\" بگوید \"ALICE is guilty.\"،\n      زیرا اظهارات مربوط به روز هفته نادیده گرفته می‌شوند.\n    \"\"\"\n    # پیاده‌سازی تابع..."}, "canonical_solution": "    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True", "instruction": {"en": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, като използвате не повече от 500 знака.", "zh": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nPython kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\n以下のPythonコードの説明を日本語で500文字以内の簡潔なドキュメンテーション文字列（docstring）として提供してください。", "ko": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nPython 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 500자 이내로 제공하세요.", "ml": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടാതെയുള്ള സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ നൽകുക.", "fa": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_check_scenario():\n    # Define a set of days of the week for the test cases\n    days_of_week = set([\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\", \"SUNDAY\"])\n\n    # Test case 1: Simple case where the scenario is correct\n    statements_test1 = {\n        \"ALICE\": [\"I am not guilty.\", \"BOB is guilty.\"],\n        \"BOB\": [\"ALICE is not guilty.\", \"Today is MONDAY\"],\n        \"CHARLIE\": [\"I am guilty.\"]\n    }\n    scenario_test1 = \"CHARLIE\"\n    liar_count_test1 = {\"ALICE\", \"BOB\"}\n    assert check_scenario(scenario_test1, liar_count_test1, statements_test1, days_of_week) == False, \"Test case 1 failed\"\n\n    # Test case 2: Scenario with contradictory statements\n    statements_test2 = {\n        \"ALICE\": [\"I am guilty.\"],\n        \"BOB\": [\"I am not guilty.\", \"ALICE is guilty.\"],\n        \"CHARLIE\": [\"I am not guilty.\", \"Today is TUESDAY\"]\n    }\n    scenario_test2 = \"ALICE\"\n    liar_count_test2 = {\"BOB\", \"CHARLIE\"}\n    assert check_scenario(scenario_test2, liar_count_test2, statements_test2, days_of_week) == False, \"Test case 2 failed\"\n\n    # Test case 3: Scenario where the statements are ambiguous\n    statements_test3 = {\n        \"ALICE\": [\"I am not guilty.\", \"Today is WEDNESDAY\"],\n        \"BOB\": [\"I am not guilty.\", \"CHARLIE is guilty.\"],\n        \"CHARLIE\": [\"BOB is not guilty.\"]\n    }\n    scenario_test3 = \"BOB\"\n    liar_count_test3 = {\"ALICE\", \"CHARLIE\"}\n    assert check_scenario(scenario_test3, liar_count_test3, statements_test3, days_of_week) == False, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_check_scenario()", "entry_point": "check_scenario", "signature": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:", "docstring": {"en": "Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\nThis function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\nthe statements made by all participants are consistent with this scenario, disregarding any statements\nabout the day of the week.\n\nParameters:\n- scenario (str): The name of the participant being tested as the potential criminal.\n- liar_count (set): A set of names of participants who are assumed to be liars.\n- statements (dict): A dictionary mapping participant names to lists of their respective statements.\n- days_of_week (set): A set of strings representing the days of the week.\n\nReturns:\n- bool: True if the scenario is consistent with the statements, False otherwise.\n\nTest Cases:\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nFalse if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\nsince statements about the day of the week are ignored.", "sq": "Vlerëson konsistencën e një skenari ku një pjesëmarrës është krimineli bazuar në deklaratat e dhëna.\n\nKjo funksion merr emrin e një krimineli të mundshëm (skenari) dhe një grup gënjeshtarësh (liar_count) dhe kontrollon nëse\ndeklaratat e bëra nga të gjithë pjesëmarrësit janë konsistente me këtë skenar, duke injoruar çdo deklaratë\nrreth ditës së javës.\n\nParametrat:\n- scenario (str): Emri i pjesëmarrësit që po testohet si krimineli i mundshëm.\n- liar_count (set): Një grup emrash të pjesëmarrësve që supozohet të jenë gënjeshtarë.\n- statements (dict): Një fjalor që lidh emrat e pjesëmarrësve me listat e deklaratave të tyre përkatëse.\n- days_of_week (set): Një grup vargjesh që përfaqësojnë ditët e javës.\n\nKthen:\n- bool: True nëse skenari është konsistent me deklaratat, False përndryshe.\n\nRastet e Testimit:\n- Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\nTrue nëse \"ALICE\" thotë \"Unë jam fajtor.\", \"BOB\" thotë \"ALICE nuk është fajtore.\", dhe \"CHARLIE\" nuk bën deklarata të rëndësishme.\n\n- Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\nFalse nëse \"ALICE\" thotë \"Unë nuk jam fajtor.\", \"BOB\" thotë \"ALICE është fajtore.\", që bie ndesh me skenarin.\n\n- Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\nTrue nëse \"ALICE\" thotë \"Unë jam fajtor.\", \"BOB\" thotë \"Sot është E HËNË\", dhe \"CHARLIE\" thotë \"ALICE është fajtore.\",\npasi deklaratat rreth ditës së javës injorohen.", "hy": "Գնահատում է սցենարի հետևողականությունը, որտեղ մեկ մասնակիցը հանցագործ է՝ հիմնվելով տրված հայտարարությունների վրա։\n\nԱյս ֆունկցիան վերցնում է հնարավոր հանցագործի անունը (սցենար) և ստախոսների հավաքածու (liar_count) և ստուգում է՝ արդյոք\nբոլոր մասնակիցների հայտարարությունները համահունչ են այս սցենարի հետ՝ անտեսելով շաբաթվա օրվա մասին հայտարարությունները։\n\nՊարամետրեր:\n- scenario (str): Մասնակցի անունը, որը փորձարկվում է որպես հնարավոր հանցագործ։\n- liar_count (set): Մասնակիցների անունների հավաքածու, որոնք համարվում են ստախոսներ։\n- statements (dict): Բառարան, որը կապում է մասնակիցների անունները նրանց համապատասխան հայտարարությունների ցուցակների հետ։\n- days_of_week (set): Տողերի հավաքածու, որը ներկայացնում է շաբաթվա օրերը։\n\nՎերադարձնում է:\n- bool: True, եթե սցենարը համահունչ է հայտարարություններին, False՝ հակառակ դեպքում։\n\nԹեստային դեպքեր:\n- Տրված սցենարում, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\nTrue, եթե \"ALICE\"-ն ասում է \"Ես մեղավոր եմ։\", \"BOB\"-ն ասում է \"ALICE-ը մեղավոր չէ։\", և \"CHARLIE\"-ն չի անում համապատասխան հայտարարություններ։\n\n- Տրված սցենարում, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\nFalse, եթե \"ALICE\"-ն ասում է \"Ես մեղավոր չեմ։\", \"BOB\"-ն ասում է \"ALICE-ը մեղավոր է։\", ինչը հակասում է սցենարին։\n\n- Տրված սցենարում, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\nTrue, եթե \"ALICE\"-ն ասում է \"Ես մեղավոր եմ։\", \"BOB\"-ն ասում է \"Այսօր երկուշաբթի է\", և \"CHARLIE\"-ն ասում է \"ALICE-ը մեղավոր է։\",\nքանի որ շաբաթվա օրվա մասին հայտարարությունները անտեսվում են։", "bn": "একটি পরিস্থিতির সামঞ্জস্য মূল্যায়ন করে যেখানে একজন অংশগ্রহণকারী অপরাধী হিসাবে বিবেচিত হয় প্রদত্ত বিবৃতির ভিত্তিতে।\n\nএই ফাংশনটি সম্ভাব্য অপরাধীর নাম (scenario) এবং মিথ্যাবাদীদের একটি সেট (liar_count) গ্রহণ করে এবং পরীক্ষা করে যে\nসকল অংশগ্রহণকারীর দ্বারা প্রদত্ত বিবৃতিগুলি এই পরিস্থিতির সাথে সামঞ্জস্যপূর্ণ কিনা, সপ্তাহের দিনের বিবৃতিগুলি উপেক্ষা করে।\n\nপ্যারামিটারসমূহ:\n- scenario (str): সম্ভাব্য অপরাধী হিসাবে পরীক্ষাধীন অংশগ্রহণকারীর নাম।\n- liar_count (set): অংশগ্রহণকারীদের নামের একটি সেট যারা মিথ্যাবাদী হিসাবে বিবেচিত।\n- statements (dict): অংশগ্রহণকারীদের নামকে তাদের সংশ্লিষ্ট বিবৃতির তালিকার সাথে ম্যাপ করা একটি অভিধান।\n- days_of_week (set): সপ্তাহের দিনের প্রতিনিধিত্বকারী স্ট্রিংগুলির একটি সেট।\n\nরিটার্নস:\n- bool: যদি পরিস্থিতি বিবৃতিগুলির সাথে সামঞ্জস্যপূর্ণ হয় তবে True, অন্যথায় False।\n\nপরীক্ষার কেসসমূহ:\n- একটি পরিস্থিতিতে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি True রিটার্ন করা উচিত\nযদি \"ALICE\" বলে \"I am guilty.\", \"BOB\" বলে \"ALICE is not guilty.\", এবং \"CHARLIE\" কোনো প্রাসঙ্গিক বিবৃতি না দেয়।\n\n- একটি পরিস্থিতিতে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি False রিটার্ন করা উচিত\nযদি \"ALICE\" বলে \"I am not guilty.\", \"BOB\" বলে \"ALICE is guilty.\", যা পরিস্থিতির সাথে বিরোধপূর্ণ।\n\n- একটি পরিস্থিতিতে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি True রিটার্ন করা উচিত\nযদি \"ALICE\" বলে \"I am guilty.\", \"BOB\" বলে \"Today is MONDAY\", এবং \"CHARLIE\" বলে \"ALICE is guilty.\",\nকারণ সপ্তাহের দিনের বিবৃতিগুলি উপেক্ষা করা হয়।", "bg": "Оценява последователността на сценарий, в който един участник е престъпникът, въз основа на дадените изявления.\n\nТази функция приема име на потенциален престъпник (scenario) и набор от лъжци (liar_count) и проверява дали\nизявленията, направени от всички участници, са последователни с този сценарий, като се пренебрегват всички изявления\nотносно деня от седмицата.\n\nПараметри:\n- scenario (str): Името на участника, който се тества като потенциален престъпник.\n- liar_count (set): Набор от имена на участници, които се приемат за лъжци.\n- statements (dict): Речник, свързващ имената на участниците със списъци на техните съответни изявления.\n- days_of_week (set): Набор от низове, представляващи дните от седмицата.\n\nВръща:\n- bool: True, ако сценарият е последователен с изявленията, False в противен случай.\n\nТестови случаи:\n- При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\nTrue, ако \"ALICE\" казва \"I am guilty.\", \"BOB\" казва \"ALICE is not guilty.\", и \"CHARLIE\" не прави съответни изявления.\n\n- При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\nFalse, ако \"ALICE\" казва \"I am not guilty.\", \"BOB\" казва \"ALICE is guilty.\", което противоречи на сценария.\n\n- При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\nTrue, ако \"ALICE\" казва \"I am guilty.\", \"BOB\" казва \"Today is MONDAY\", и \"CHARLIE\" казва \"ALICE is guilty.\",\nтъй като изявленията относно деня от седмицата се игнорират.", "zh": "评估一个场景的连贯性，其中一个参与者是基于给定陈述的罪犯。\n\n此函数接受一个潜在罪犯的名字（scenario）和一组说谎者（liar_count），并检查所有参与者所做的陈述是否与此场景一致，忽略任何关于星期几的陈述。\n\n参数：\n- scenario (str): 被测试为潜在罪犯的参与者的名字。\n- liar_count (set): 假定为说谎者的参与者名字集合。\n- statements (dict): 一个字典，将参与者名字映射到他们各自陈述的列表。\n- days_of_week (set): 表示一周中各天的字符串集合。\n\n返回：\n- bool: 如果场景与陈述一致则为True，否则为False。\n\n测试用例：\n- 给定一个场景，其中“ALICE”是罪犯，“BOB”和“CHARLIE”是说谎者，如果“ALICE”说“我是有罪的。”，“BOB”说“ALICE无罪。”，并且“CHARLIE”没有做出相关陈述，函数应返回True。\n\n- 给定一个场景，其中“ALICE”是罪犯，“BOB”和“CHARLIE”是说谎者，如果“ALICE”说“我无罪。”，“BOB”说“ALICE有罪。”，这与场景矛盾，函数应返回False。\n\n- 给定一个场景，其中“ALICE”是罪犯，“BOB”和“CHARLIE”是说谎者，如果“ALICE”说“我是有罪的。”，“BOB”说“今天是星期一。”，并且“CHARLIE”说“ALICE有罪。”，由于关于星期几的陈述被忽略，函数应返回True。", "fr": "Évalue la cohérence d'un scénario où un participant est le criminel en fonction des déclarations données.\n\nCette fonction prend le nom d'un potentiel criminel (scenario) et un ensemble de menteurs (liar_count) et vérifie si\nles déclarations faites par tous les participants sont cohérentes avec ce scénario, en ignorant toute déclaration\nconcernant le jour de la semaine.\n\nParamètres :\n- scenario (str) : Le nom du participant testé en tant que criminel potentiel.\n- liar_count (set) : Un ensemble de noms de participants supposés être des menteurs.\n- statements (dict) : Un dictionnaire associant les noms des participants à des listes de leurs déclarations respectives.\n- days_of_week (set) : Un ensemble de chaînes représentant les jours de la semaine.\n\nRenvoie :\n- bool : True si le scénario est cohérent avec les déclarations, False sinon.\n\nCas de test :\n- Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait renvoyer\nTrue si \"ALICE\" dit \"I am guilty.\", \"BOB\" dit \"ALICE is not guilty.\", et \"CHARLIE\" ne fait aucune déclaration pertinente.\n\n- Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait renvoyer\nFalse si \"ALICE\" dit \"I am not guilty.\", \"BOB\" dit \"ALICE is guilty.\", ce qui contredit le scénario.\n\n- Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait renvoyer\nTrue si \"ALICE\" dit \"I am guilty.\", \"BOB\" dit \"Today is MONDAY\", et \"CHARLIE\" dit \"ALICE is guilty.\",\npuisque les déclarations concernant le jour de la semaine sont ignorées.", "de": "Überprüft die Konsistenz eines Szenarios, bei dem ein Teilnehmer der Täter ist, basierend auf den gegebenen Aussagen.\n\nDiese Funktion nimmt den Namen eines potenziellen Täters (scenario) und eine Menge von Lügnern (liar_count) und überprüft, ob die von allen Teilnehmern gemachten Aussagen mit diesem Szenario übereinstimmen, wobei Aussagen über den Wochentag ignoriert werden.\n\nParameter:\n- scenario (str): Der Name des Teilnehmers, der als potenzieller Täter getestet wird.\n- liar_count (set): Eine Menge von Namen der Teilnehmer, die als Lügner angenommen werden.\n- statements (dict): Ein Wörterbuch, das Teilnehmernamen auf Listen ihrer jeweiligen Aussagen abbildet.\n- days_of_week (set): Eine Menge von Zeichenketten, die die Wochentage darstellen.\n\nRückgabewert:\n- bool: True, wenn das Szenario mit den Aussagen konsistent ist, andernfalls False.\n\nTestfälle:\n- Gegeben ein Szenario, in dem \"ALICE\" der Täter ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion True zurückgeben, wenn \"ALICE\" sagt \"I am guilty.\", \"BOB\" sagt \"ALICE is not guilty.\", und \"CHARLIE\" keine relevanten Aussagen macht.\n\n- Gegeben ein Szenario, in dem \"ALICE\" der Täter ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion False zurückgeben, wenn \"ALICE\" sagt \"I am not guilty.\", \"BOB\" sagt \"ALICE is guilty.\", was dem Szenario widerspricht.\n\n- Gegeben ein Szenario, in dem \"ALICE\" der Täter ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion True zurückgeben, wenn \"ALICE\" sagt \"I am guilty.\", \"BOB\" sagt \"Today is MONDAY\", und \"CHARLIE\" sagt \"ALICE is guilty.\", da Aussagen über den Wochentag ignoriert werden.", "ha": "Yana tantance daidaiton wani yanayi inda ɗaya daga cikin mahalarta shine mai laifi bisa ga bayanan da aka bayar.\n\nWannan aikin yana ɗaukar sunan mai laifi mai yuwuwa (scenario) da kuma saitin maƙaryata (liar_count) kuma yana duba idan\nbayanan da duk mahalarta suka yi suna da daidaito da wannan yanayi, ba tare da la'akari da kowanne bayani\ngame da ranar mako ba.\n\nSigogi:\n- scenario (str): Sunan mahalartin da ake gwada shi a matsayin mai laifi mai yuwuwa.\n- liar_count (set): Wani saitin sunayen mahalarta da ake ɗauka a matsayin maƙaryata.\n- statements (dict): Wani kamus mai haɗa sunayen mahalarta da jerin bayanan su na musamman.\n- days_of_week (set): Wani saitin kirtani da ke wakiltar ranakun mako.\n\nMayarwa:\n- bool: True idan yanayin ya dace da bayanan, False in ba haka ba.\n\nMisalan Gwaji:\n- Idan aka ba da yanayi inda \"ALICE\" shine mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\nTrue idan \"ALICE\" ta ce \"I am guilty.\", \"BOB\" ya ce \"ALICE is not guilty.\", kuma \"CHARLIE\" bai yi wani bayani mai mahimmanci ba.\n\n- Idan aka ba da yanayi inda \"ALICE\" shine mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\nFalse idan \"ALICE\" ta ce \"I am not guilty.\", \"BOB\" ya ce \"ALICE is guilty.\", wanda ya saba da yanayin.\n\n- Idan aka ba da yanayi inda \"ALICE\" shine mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\nTrue idan \"ALICE\" ta ce \"I am guilty.\", \"BOB\" ya ce \"Today is MONDAY\", kuma \"CHARLIE\" ya ce \"ALICE is guilty.\",\nsaboda bayanan game da ranar mako an yi watsi da su.", "hi": "एक परिदृश्य की संगति का मूल्यांकन करता है जहाँ एक प्रतिभागी अपराधी है, दिए गए बयानों के आधार पर।\n\nयह फ़ंक्शन एक संभावित अपराधी का नाम (scenario) और झूठे लोगों का एक सेट (liar_count) लेता है और जाँचता है कि\nसभी प्रतिभागियों द्वारा दिए गए बयान इस परिदृश्य के साथ संगत हैं या नहीं, सप्ताह के दिन के बारे में किसी भी बयान को अनदेखा करते हुए।\n\nपैरामीटर्स:\n- scenario (str): उस प्रतिभागी का नाम जिसे संभावित अपराधी के रूप में परीक्षण किया जा रहा है।\n- liar_count (set): उन प्रतिभागियों के नामों का सेट जिन्हें झूठा माना जा रहा है।\n- statements (dict): प्रतिभागी नामों को उनके संबंधित बयानों की सूचियों के साथ मैप करने वाली एक डिक्शनरी।\n- days_of_week (set): सप्ताह के दिनों का प्रतिनिधित्व करने वाले स्ट्रिंग्स का एक सेट।\n\nरिटर्न्स:\n- bool: True यदि परिदृश्य बयानों के साथ संगत है, अन्यथा False।\n\nटेस्ट केस:\n- एक दिए गए परिदृश्य में जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, फ़ंक्शन को True लौटाना चाहिए\nयदि \"ALICE\" कहती है \"I am guilty.\", \"BOB\" कहता है \"ALICE is not guilty.\", और \"CHARLIE\" कोई प्रासंगिक बयान नहीं देता।\n\n- एक दिए गए परिदृश्य में जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, फ़ंक्शन को False लौटाना चाहिए\nयदि \"ALICE\" कहती है \"I am not guilty.\", \"BOB\" कहता है \"ALICE is guilty.\", जो परिदृश्य का खंडन करता है।\n\n- एक दिए गए परिदृश्य में जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, फ़ंक्शन को True लौटाना चाहिए\nयदि \"ALICE\" कहती है \"I am guilty.\", \"BOB\" कहता है \"Today is MONDAY\", और \"CHARLIE\" कहता है \"ALICE is guilty.\",\nक्योंकि सप्ताह के दिन के बारे में बयानों को अनदेखा किया जाता है।", "hu": "Értékeli annak a forgatókönyvnek a konzisztenciáját, ahol az egyik résztvevő a bűnös a megadott állítások alapján.\n\nEz a függvény egy potenciális bűnös nevét (forgatókönyv) és egy hazugok halmazát (hazugok_száma) veszi, és ellenőrzi, hogy az összes résztvevő által tett állítások konzisztens-e ezzel a forgatókönyvvel, figyelmen kívül hagyva a hét napjára vonatkozó állításokat.\n\nParaméterek:\n- scenario (str): Annak a résztvevőnek a neve, akit potenciális bűnösként vizsgálnak.\n- liar_count (set): A hazugnak feltételezett résztvevők neveinek halmaza.\n- statements (dict): Egy szótár, amely a résztvevők neveit a megfelelő állításaik listájához rendeli.\n- days_of_week (set): A hét napjait reprezentáló karakterláncok halmaza.\n\nVisszatérési érték:\n- bool: Igaz, ha a forgatókönyv konzisztens az állításokkal, különben Hamis.\n\nTeszt Esetek:\n- Adott egy forgatókönyv, ahol \"ALICE\" a bűnös, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek Igazat kell visszaadnia, ha \"ALICE\" azt mondja: \"Bűnös vagyok.\", \"BOB\" azt mondja: \"ALICE nem bűnös.\", és \"CHARLIE\" nem tesz releváns állításokat.\n\n- Adott egy forgatókönyv, ahol \"ALICE\" a bűnös, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek Hamisat kell visszaadnia, ha \"ALICE\" azt mondja: \"Nem vagyok bűnös.\", \"BOB\" azt mondja: \"ALICE bűnös.\", ami ellentmond a forgatókönyvnek.\n\n- Adott egy forgatókönyv, ahol \"ALICE\" a bűnös, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek Igazat kell visszaadnia, ha \"ALICE\" azt mondja: \"Bűnös vagyok.\", \"BOB\" azt mondja: \"Ma HÉTFŐ van\", és \"CHARLIE\" azt mondja: \"ALICE bűnös.\", mivel a hét napjára vonatkozó állítások figyelmen kívül vannak hagyva.", "es": "Evalúa la consistencia de un escenario donde un participante es el criminal basado en las declaraciones dadas.\n\nEsta función toma el nombre de un posible criminal (scenario) y un conjunto de mentirosos (liar_count) y verifica si\nlas declaraciones hechas por todos los participantes son consistentes con este escenario, ignorando cualquier declaración\nsobre el día de la semana.\n\nParámetros:\n- scenario (str): El nombre del participante que se está probando como el posible criminal.\n- liar_count (set): Un conjunto de nombres de participantes que se asumen como mentirosos.\n- statements (dict): Un diccionario que mapea nombres de participantes a listas de sus respectivas declaraciones.\n- days_of_week (set): Un conjunto de cadenas que representan los días de la semana.\n\nDevuelve:\n- bool: True si el escenario es consistente con las declaraciones, False en caso contrario.\n\nCasos de Prueba:\n- Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería devolver\nTrue si \"ALICE\" dice \"I am guilty.\", \"BOB\" dice \"ALICE is not guilty.\", y \"CHARLIE\" no hace declaraciones relevantes.\n\n- Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería devolver\nFalse si \"ALICE\" dice \"I am not guilty.\", \"BOB\" dice \"ALICE is guilty.\", lo cual contradice el escenario.\n\n- Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería devolver\nTrue si \"ALICE\" dice \"I am guilty.\", \"BOB\" dice \"Today is MONDAY\", y \"CHARLIE\" dice \"ALICE is guilty.\",\nya que las declaraciones sobre el día de la semana son ignoradas.", "arb": "يقيم اتساق سيناريو حيث يكون أحد المشاركين هو المجرم بناءً على البيانات المقدمة.\n\nتأخذ هذه الدالة اسم المجرم المحتمل (scenario) ومجموعة من الكاذبين (liar_count) وتتحقق مما إذا كانت\nالبيانات التي أدلى بها جميع المشاركين متسقة مع هذا السيناريو، متجاهلة أي بيانات\nحول يوم الأسبوع.\n\nالمعلمات:\n- scenario (str): اسم المشارك الذي يتم اختباره كمجرم محتمل.\n- liar_count (set): مجموعة من أسماء المشاركين الذين يُفترض أنهم كاذبون.\n- statements (dict): قاموس يربط أسماء المشاركين بقوائم بياناتهم الخاصة.\n- days_of_week (set): مجموعة من السلاسل النصية التي تمثل أيام الأسبوع.\n\nالقيم المعادة:\n- bool: True إذا كان السيناريو متسقًا مع البيانات، False خلاف ذلك.\n\nحالات الاختبار:\n- بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و\"BOB\" و\"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\nTrue إذا قالت \"ALICE\" \"I am guilty.\"، وقال \"BOB\" \"ALICE is not guilty.\"، ولم يقم \"CHARLIE\" بأي بيانات ذات صلة.\n\n- بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و\"BOB\" و\"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\nFalse إذا قالت \"ALICE\" \"I am not guilty.\"، وقال \"BOB\" \"ALICE is guilty.\"، مما يتناقض مع السيناريو.\n\n- بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و\"BOB\" و\"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\nTrue إذا قالت \"ALICE\" \"I am guilty.\"، وقال \"BOB\" \"Today is MONDAY\"، وقال \"CHARLIE\" \"ALICE is guilty.\"،\nحيث يتم تجاهل البيانات حول يوم الأسبوع.", "sw": "Inatathmini uthabiti wa tukio ambapo mshiriki mmoja ni mhalifu kulingana na taarifa zilizotolewa.\n\nKazi hii inachukua jina la mhalifu anayewezekana (scenario) na seti ya waongo (liar_count) na inakagua kama\ntaarifa zilizotolewa na washiriki wote zinakubaliana na tukio hili, bila kujali taarifa zozote\nkuhusu siku ya wiki.\n\nVigezo:\n- scenario (str): Jina la mshiriki anayepimwa kama mhalifu anayewezekana.\n- liar_count (set): Seti ya majina ya washiriki wanaodhaniwa kuwa waongo.\n- statements (dict): Kamusi inayochanganua majina ya washiriki na orodha za taarifa zao husika.\n- days_of_week (set): Seti ya mistari inayowakilisha siku za wiki.\n\nInarejesha:\n- bool: Kweli ikiwa tukio linakubaliana na taarifa, Si kweli vinginevyo.\n\nMifano ya Majaribio:\n- Ikitolewa tukio ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurejesha\nKweli ikiwa \"ALICE\" anasema \"I am guilty.\", \"BOB\" anasema \"ALICE is not guilty.\", na \"CHARLIE\" hafanyi taarifa yoyote husika.\n\n- Ikitolewa tukio ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurejesha\nSi kweli ikiwa \"ALICE\" anasema \"I am not guilty.\", \"BOB\" anasema \"ALICE is guilty.\", ambayo inapingana na tukio.\n\n- Ikitolewa tukio ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurejesha\nKweli ikiwa \"ALICE\" anasema \"I am guilty.\", \"BOB\" anasema \"Today is MONDAY\", na \"CHARLIE\" anasema \"ALICE is guilty.\",\nkwa kuwa taarifa kuhusu siku ya wiki zinapuuzwa.", "tr": "Bir senaryonun tutarlılığını, bir katılımcının suçlu olduğu varsayımına dayanarak değerlendirir.\n\nBu fonksiyon, potansiyel suçlunun adını (senaryo) ve bir grup yalancıyı (yalancı_sayısı) alır ve tüm katılımcıların yaptığı açıklamaların bu senaryo ile tutarlı olup olmadığını kontrol eder, haftanın günü hakkındaki açıklamaları dikkate almaz.\n\nParametreler:\n- scenario (str): Potansiyel suçlu olarak test edilen katılımcının adı.\n- liar_count (set): Yalancı olduğu varsayılan katılımcıların adlarını içeren bir küme.\n- statements (dict): Katılımcı adlarını, onların ilgili açıklamalarının listelerine eşleyen bir sözlük.\n- days_of_week (set): Haftanın günlerini temsil eden stringlerden oluşan bir küme.\n\nDöndürür:\n- bool: Senaryo açıklamalarla tutarlıysa True, aksi takdirde False.\n\nTest Durumları:\n- \"ALICE\" suçlu olduğu bir senaryo ve \"BOB\" ile \"CHARLIE\" yalancı olduğu durumda, fonksiyon \"ALICE\" \"Ben suçluyum.\" derse, \"BOB\" \"ALICE suçlu değil.\" derse ve \"CHARLIE\" ilgili bir açıklama yapmazsa True döndürmelidir.\n\n- \"ALICE\" suçlu olduğu bir senaryo ve \"BOB\" ile \"CHARLIE\" yalancı olduğu durumda, fonksiyon \"ALICE\" \"Ben suçlu değilim.\" derse, \"BOB\" \"ALICE suçlu.\" derse, bu senaryoyla çeliştiği için False döndürmelidir.\n\n- \"ALICE\" suçlu olduğu bir senaryo ve \"BOB\" ile \"CHARLIE\" yalancı olduğu durumda, fonksiyon \"ALICE\" \"Ben suçluyum.\" derse, \"BOB\" \"Bugün PAZARTESİ\" derse ve \"CHARLIE\" \"ALICE suçlu.\" derse, haftanın günü hakkındaki açıklamalar göz ardı edildiği için True döndürmelidir.", "vi": "Đánh giá tính nhất quán của một kịch bản nơi một người tham gia là tội phạm dựa trên các tuyên bố đã cho.\n\nHàm này nhận tên của một tội phạm tiềm năng (scenario) và một tập hợp những người nói dối (liar_count) và kiểm tra xem\ncác tuyên bố được thực hiện bởi tất cả những người tham gia có nhất quán với kịch bản này không, bỏ qua bất kỳ tuyên bố nào\nvề ngày trong tuần.\n\nTham số:\n- scenario (str): Tên của người tham gia được kiểm tra như là tội phạm tiềm năng.\n- liar_count (set): Một tập hợp tên của những người tham gia được cho là nói dối.\n- statements (dict): Một từ điển ánh xạ tên người tham gia tới danh sách các tuyên bố tương ứng của họ.\n- days_of_week (set): Một tập hợp các chuỗi đại diện cho các ngày trong tuần.\n\nTrả về:\n- bool: True nếu kịch bản nhất quán với các tuyên bố, False nếu không.\n\nCác trường hợp kiểm tra:\n- Cho một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\nTrue nếu \"ALICE\" nói \"I am guilty.\", \"BOB\" nói \"ALICE is not guilty.\", và \"CHARLIE\" không đưa ra tuyên bố nào liên quan.\n\n- Cho một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\nFalse nếu \"ALICE\" nói \"I am not guilty.\", \"BOB\" nói \"ALICE is guilty.\", điều này mâu thuẫn với kịch bản.\n\n- Cho một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\nTrue nếu \"ALICE\" nói \"I am guilty.\", \"BOB\" nói \"Today is MONDAY\", và \"CHARLIE\" nói \"ALICE is guilty.\",\nvì các tuyên bố về ngày trong tuần bị bỏ qua.", "id": "Mengevaluasi konsistensi dari sebuah skenario di mana satu peserta adalah pelaku kejahatan berdasarkan pernyataan yang diberikan.\n\nFungsi ini mengambil nama pelaku potensial (skenario) dan sekumpulan pembohong (liar_count) dan memeriksa apakah\npernyataan yang dibuat oleh semua peserta konsisten dengan skenario ini, mengabaikan pernyataan\ntentang hari dalam seminggu.\n\nParameter:\n- scenario (str): Nama peserta yang diuji sebagai pelaku potensial.\n- liar_count (set): Sekumpulan nama peserta yang diasumsikan sebagai pembohong.\n- statements (dict): Sebuah kamus yang memetakan nama peserta ke daftar pernyataan masing-masing.\n- days_of_week (set): Sekumpulan string yang mewakili hari dalam seminggu.\n\nMengembalikan:\n- bool: True jika skenario konsisten dengan pernyataan, False jika tidak.\n\nKasus Uji:\n- Diberikan skenario di mana \"ALICE\" adalah pelaku, dan \"BOB\" serta \"CHARLIE\" adalah pembohong, fungsi harus mengembalikan\nTrue jika \"ALICE\" mengatakan \"I am guilty.\", \"BOB\" mengatakan \"ALICE is not guilty.\", dan \"CHARLIE\" tidak membuat pernyataan yang relevan.\n\n- Diberikan skenario di mana \"ALICE\" adalah pelaku, dan \"BOB\" serta \"CHARLIE\" adalah pembohong, fungsi harus mengembalikan\nFalse jika \"ALICE\" mengatakan \"I am not guilty.\", \"BOB\" mengatakan \"ALICE is guilty.\", yang bertentangan dengan skenario.\n\n- Diberikan skenario di mana \"ALICE\" adalah pelaku, dan \"BOB\" serta \"CHARLIE\" adalah pembohong, fungsi harus mengembalikan\nTrue jika \"ALICE\" mengatakan \"I am guilty.\", \"BOB\" mengatakan \"Today is MONDAY\", dan \"CHARLIE\" mengatakan \"ALICE is guilty.\",\nkarena pernyataan tentang hari dalam seminggu diabaikan.", "ja": "シナリオの一貫性を評価します。ここでは、ある参加者が犯罪者であるというシナリオに基づき、与えられた陳述を評価します。\n\nこの関数は、潜在的な犯罪者の名前（シナリオ）と嘘つきのセット（liar_count）を受け取り、すべての参加者によって行われた陳述がこのシナリオと一致しているかどうかを、曜日に関する陳述を無視してチェックします。\n\nパラメータ:\n- scenario (str): 潜在的な犯罪者としてテストされている参加者の名前。\n- liar_count (set): 嘘つきであると仮定される参加者の名前のセット。\n- statements (dict): 参加者の名前をそれぞれの陳述のリストにマッピングする辞書。\n- days_of_week (set): 曜日を表す文字列のセット。\n\n戻り値:\n- bool: シナリオが陳述と一致する場合はTrue、一致しない場合はFalse。\n\nテストケース:\n- \"ALICE\"が犯罪者であり、\"BOB\"と\"CHARLIE\"が嘘つきであるというシナリオが与えられた場合、\"ALICE\"が「私は有罪です。」と言い、\"BOB\"が「ALICEは無罪です。」と言い、\"CHARLIE\"が関連する陳述をしない場合、関数はTrueを返すべきです。\n\n- \"ALICE\"が犯罪者であり、\"BOB\"と\"CHARLIE\"が嘘つきであるというシナリオが与えられた場合、\"ALICE\"が「私は無罪です。」と言い、\"BOB\"が「ALICEは有罪です。」と言う場合、これはシナリオと矛盾するため、関数はFalseを返すべきです。\n\n- \"ALICE\"が犯罪者であり、\"BOB\"と\"CHARLIE\"が嘘つきであるというシナリオが与えられた場合、\"ALICE\"が「私は有罪です。」と言い、\"BOB\"が「今日は月曜日です。」と言い、\"CHARLIE\"が「ALICEは有罪です。」と言う場合、曜日に関する陳述は無視されるため、関数はTrueを返すべきです。", "ko": "주어진 진술에 기반하여 한 참가자가 범죄자인 시나리오의 일관성을 평가합니다.\n\n이 함수는 잠재적인 범죄자의 이름(시나리오)과 거짓말쟁이의 집합(liar_count)을 받아 모든 참가자가 한 진술이 이 시나리오와 일관성이 있는지 확인하며, 요일에 대한 진술은 무시합니다.\n\n매개변수:\n- scenario (str): 잠재적인 범죄자로 테스트되는 참가자의 이름.\n- liar_count (set): 거짓말쟁이로 가정되는 참가자들의 이름 집합.\n- statements (dict): 참가자 이름을 그들의 각각의 진술 목록에 매핑하는 사전.\n- days_of_week (set): 요일을 나타내는 문자열 집합.\n\n반환값:\n- bool: 시나리오가 진술과 일관되면 True, 그렇지 않으면 False.\n\n테스트 케이스:\n- \"ALICE\"가 범죄자이고, \"BOB\"과 \"CHARLIE\"가 거짓말쟁이인 시나리오가 주어졌을 때, \"ALICE\"가 \"I am guilty.\"라고 말하고, \"BOB\"이 \"ALICE is not guilty.\"라고 말하며, \"CHARLIE\"가 관련 없는 진술을 할 경우 함수는 True를 반환해야 합니다.\n\n- \"ALICE\"가 범죄자이고, \"BOB\"과 \"CHARLIE\"가 거짓말쟁이인 시나리오가 주어졌을 때, \"ALICE\"가 \"I am not guilty.\"라고 말하고, \"BOB\"이 \"ALICE is guilty.\"라고 말할 경우, 이는 시나리오와 모순되므로 함수는 False를 반환해야 합니다.\n\n- \"ALICE\"가 범죄자이고, \"BOB\"과 \"CHARLIE\"가 거짓말쟁이인 시나리오가 주어졌을 때, \"ALICE\"가 \"I am guilty.\"라고 말하고, \"BOB\"이 \"Today is MONDAY\"라고 말하며, \"CHARLIE\"가 \"ALICE is guilty.\"라고 말할 경우, 요일에 대한 진술은 무시되므로 함수는 True를 반환해야 합니다.", "ml": "ഒരു പങ്കാളി കുറ്റവാളിയാണെന്ന സങ്കൽപത്തിന്റെ സ്ഥിരത നൽകിയ പ്രസ്താവനകളെ അടിസ്ഥാനമാക്കി വിലയിരുത്തുന്നു.\n\nഈ ഫംഗ്ഷൻ ഒരു സാധ്യതയുള്ള കുറ്റവാളിയുടെ പേര് (scenario) ഒരു കൂട്ടം കള്ളന്മാരുടെ പേരുകൾ (liar_count) എന്നിവ സ്വീകരിച്ച് എല്ലാ പങ്കാളികളും നടത്തിയ പ്രസ്താവനകൾ ഈ സങ്കൽപവുമായി സ്ഥിരതയുള്ളതാണോ എന്ന് പരിശോധിക്കുന്നു, ആഴ്ചയിലെ ദിവസത്തെക്കുറിച്ചുള്ള പ്രസ്താവനകളെ അവഗണിക്കുന്നു.\n\nപാരാമീറ്ററുകൾ:\n- scenario (str): സാധ്യതയുള്ള കുറ്റവാളിയായി പരിശോധിക്കുന്ന പങ്കാളിയുടെ പേര്.\n- liar_count (set): കള്ളന്മാരാണെന്ന് കരുതുന്ന പങ്കാളികളുടെ പേരുകളുടെ ഒരു സെറ്റ്.\n- statements (dict): പങ്കാളികളുടെ പേരുകളെ അവരുടെ പ്രസ്താവനകളുടെ പട്ടികയിലേക്ക് മാപ്പ് ചെയ്യുന്ന ഒരു നിഘണ്ടു.\n- days_of_week (set): ആഴ്ചയിലെ ദിവസങ്ങളെ പ്രതിനിധീകരിക്കുന്ന സ്ട്രിംഗുകളുടെ ഒരു സെറ്റ്.\n\nമടക്കങ്ങൾ:\n- bool: പ്രസ്താവനകളുമായി സങ്കൽപം സ്ഥിരതയുള്ളതാണെങ്കിൽ True, അല്ലെങ്കിൽ False.\n\nപരീക്ഷണ കേസുകൾ:\n- \"ALICE\" കുറ്റവാളിയാണെന്ന സങ്കൽപം നൽകിയാൽ, \"BOB\"യും \"CHARLIE\"യും കള്ളന്മാരാണെങ്കിൽ, \"ALICE\" \"I am guilty.\" എന്ന് പറയുകയും, \"BOB\" \"ALICE is not guilty.\" എന്ന് പറയുകയും, \"CHARLIE\" യാതൊരു പ്രസക്തമായ പ്രസ്താവനകളും നടത്താതിരിക്കുകയും ചെയ്താൽ ഫംഗ്ഷൻ True മടക്കണം.\n\n- \"ALICE\" കുറ്റവാളിയാണെന്ന സങ്കൽപം നൽകിയാൽ, \"BOB\"യും \"CHARLIE\"യും കള്ളന്മാരാണെങ്കിൽ, \"ALICE\" \"I am not guilty.\" എന്ന് പറയുകയും, \"BOB\" \"ALICE is guilty.\" എന്ന് പറയുകയും ചെയ്താൽ, ഇത് സങ്കൽപവുമായി വിരുദ്ധമാണെങ്കിൽ ഫംഗ്ഷൻ False മടക്കണം.\n\n- \"ALICE\" കുറ്റവാളിയാണെന്ന സങ്കൽപം നൽകിയാൽ, \"BOB\"യും \"CHARLIE\"യും കള്ളന്മാരാണെങ്കിൽ, \"ALICE\" \"I am guilty.\" എന്ന് പറയുകയും, \"BOB\" \"Today is MONDAY\" എന്ന് പറയുകയും, \"CHARLIE\" \"ALICE is guilty.\" എന്ന് പറയുകയും ചെയ്താൽ, ആഴ്ചയിലെ ദിവസത്തെക്കുറിച്ചുള്ള പ്രസ്താവനകൾ അവഗണിക്കപ്പെടുന്നതിനാൽ ഫംഗ്ഷൻ True മടക്കണം.", "fa": "ارزیابی سازگاری یک سناریو که در آن یک شرکت‌کننده مجرم است بر اساس اظهارات داده شده.\n\nاین تابع نام یک مجرم احتمالی (scenario) و مجموعه‌ای از دروغ‌گوها (liar_count) را می‌گیرد و بررسی می‌کند که آیا\nاظهاراتی که توسط تمام شرکت‌کنندگان بیان شده‌اند با این سناریو سازگار هستند یا خیر، بدون توجه به اظهارات\nمربوط به روز هفته.\n\nپارامترها:\n- scenario (str): نام شرکت‌کننده‌ای که به عنوان مجرم احتمالی مورد آزمایش قرار می‌گیرد.\n- liar_count (set): مجموعه‌ای از نام‌های شرکت‌کنندگانی که فرض می‌شود دروغ‌گو هستند.\n- statements (dict): یک دیکشنری که نام شرکت‌کنندگان را به لیستی از اظهارات مربوط به آن‌ها نگاشت می‌کند.\n- days_of_week (set): مجموعه‌ای از رشته‌ها که روزهای هفته را نشان می‌دهند.\n\nبازگشت:\n- bool: True اگر سناریو با اظهارات سازگار باشد، در غیر این صورت False.\n\nموارد آزمایشی:\n- با توجه به سناریویی که در آن \"ALICE\" مجرم است و \"BOB\" و \"CHARLIE\" دروغ‌گو هستند، تابع باید\nTrue را برگرداند اگر \"ALICE\" بگوید \"من گناهکارم.\"، \"BOB\" بگوید \"ALICE گناهکار نیست.\" و \"CHARLIE\" هیچ اظهارات مرتبطی نکند.\n\n- با توجه به سناریویی که در آن \"ALICE\" مجرم است و \"BOB\" و \"CHARLIE\" دروغ‌گو هستند، تابع باید\nFalse را برگرداند اگر \"ALICE\" بگوید \"من گناهکار نیستم.\"، \"BOB\" بگوید \"ALICE گناهکار است.\" که با سناریو تناقض دارد.\n\n- با توجه به سناریویی که در آن \"ALICE\" مجرم است و \"BOB\" و \"CHARLIE\" دروغ‌گو هستند، تابع باید\nTrue را برگرداند اگر \"ALICE\" بگوید \"من گناهکارم.\"، \"BOB\" بگوید \"امروز دوشنبه است\"، و \"CHARLIE\" بگوید \"ALICE گناهکار است.\"، زیرا اظهارات مربوط به روز هفته نادیده گرفته می‌شوند."}}
{"task_id": "Python/33", "prompt": {"en": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    - If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\n      with scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\n      The 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "sq": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Llogarit rezultatin e një serie lojërash ping-pong bazuar në sistemin e dhënë të pikëve.\n\n    Kjo funksion merr sistemin e dëshiruar të pikëve (ose 11 ose 21 pikë) dhe një varg \n    që përfaqëson sekuencën e pikëve të fituara nga lojtari ('W') dhe kundërshtari ('L'). \n    Funksioni përpunon vargun dhe kthen një listë të rezultateve të lojërave të formatuara si \"rezultati_i_lojtari:rezultati_i_kundërshtari\".\n\n    Loja konsiderohet e përfunduar kur një lojtar arrin numrin e kërkuar të pikëve të sistemit \n    (11 ose 21) me të paktën një avantazh prej 2 pikësh. Nëse sekuenca e pikëve përfundon në mes të një loje, \n    rezultati aktual i asaj loje përfshihet gjithashtu në rezultat.\n\n    Argumentet:\n    - system (int): Numri i pikëve të kërkuara për të fituar një lojë (ose 11 ose 21).\n    - points (str): Një varg me karaktere 'W' dhe 'L' që tregojnë pikët e fituara nga lojtari dhe kundërshtari.\n\n    Kthen:\n    - list: Një listë me vargje që përfaqësojnë rezultatin e secilës lojë.\n\n    Rastet:\n    - Nëse points = \"WWWWWWWWWWL\", përfaqëson një lojë të plotë me lojtarin që fiton 10-1 nën të dy sistemet.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Nëse points = \"WWLWWLWWLWWLWE\", përfaqëson dy lojëra të plota dhe një lojë në progres nën sistemin me 11 pikë,\n      me rezultatet 2-1, 2-1, dhe 1-1 respektivisht. Nën sistemin me 21 pikë, përfaqëson një lojë të vetme me rezultatin 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Nëse points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", përfaqëson disa lojëra nën të dy sistemet, me lojën e fundit të papërfunduar.\n      Sistemi me 11 pikë ka rezultatet 4-6, 5-5, dhe 1-0, ndërsa sistemi me 21 pikë ka rezultatet 13-16 dhe 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "hy": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Հաշվել պինգ-պոնգ խաղերի սերիայի հաշիվը ըստ տրամադրված միավորների համակարգի:\n\n    Այս ֆունկցիան ընդունում է ցանկալի միավորների համակարգը (կամ 11 կամ 21 միավոր) և \n    տող, որը ներկայացնում է խաղացողի ('W') և մրցակցի ('L') կողմից շահած միավորների \n    հաջորդականությունը: Ֆունկցիան մշակում է տողը և վերադարձնում խաղերի հաշիվների \n    ցուցակը, ձևաչափված որպես \"խաղացողի_հաշիվ:մրցակցի_հաշիվ\":\n\n    Խաղը համարվում է ավարտված, երբ խաղացողներից մեկը հասնում է համակարգի պահանջած \n    միավորների քանակին (11 կամ 21) առնվազն 2 միավորի առավելությամբ: Եթե միավորների \n    հաջորդականությունը ավարտվում է խաղի ընթացքում, այդ խաղի ընթացիկ հաշիվը նույնպես \n    ներառվում է արդյունքի մեջ:\n\n    Արգումենտներ:\n    - system (int): Խաղը շահելու համար պահանջվող միավորների քանակը (կամ 11 կամ 21):\n    - points (str): 'W' և 'L' նիշերի տող, որը նշում է խաղացողի և մրցակցի կողմից շահած միավորները:\n\n    Վերադարձնում է:\n    - list: Տողերի ցուցակ, որը ներկայացնում է յուրաքանչյուր խաղի հաշիվը:\n\n    Դեպքեր:\n    - Եթե points = \"WWWWWWWWWWL\", այն ներկայացնում է մեկ ամբողջական խաղ, որտեղ խաղացողը \n      հաղթում է 10-1 երկու համակարգերում էլ:\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Եթե points = \"WWLWWLWWLWWLWE\", այն ներկայացնում է երկու ամբողջական խաղ և մեկ ընթացիկ \n      խաղ 11 միավորի համակարգում, համապատասխանաբար 2-1, 2-1 և 1-1 հաշիվներով: 21 միավորի \n      համակարգում այն ներկայացնում է մեկ խաղ 6-3 հաշիվով:\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Եթե points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", այն ներկայացնում է բազմաթիվ խաղեր երկու \n      համակարգերում էլ, վերջին խաղը չավարտված: 11 միավորի համակարգում հաշիվները 4-6, 5-5 և 1-0 են, \n      իսկ 21 միավորի համակարգում՝ 13-16 և 2-1:\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "bn": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    প্রদত্ত স্কোরিং সিস্টেমের ভিত্তিতে পিং-পং গেমের একটি সিরিজের স্কোর গণনা করুন।\n\n    এই ফাংশনটি কাঙ্ক্ষিত স্কোরিং সিস্টেম (১১ বা ২১ পয়েন্ট) এবং একটি স্ট্রিং \n    নেয় যা খেলোয়াড় ('W') এবং প্রতিপক্ষ ('L') দ্বারা জেতা পয়েন্টের ক্রমকে উপস্থাপন করে। \n    ফাংশনটি স্ট্রিংটি প্রক্রিয়া করে এবং গেম স্কোরের একটি তালিকা প্রদান করে যা \"player_score:opponent_score\" হিসাবে ফরম্যাট করা হয়।\n\n    যখন একজন খেলোয়াড় সিস্টেমের প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১) কমপক্ষে ২ পয়েন্টের লিড সহ পৌঁছায়, তখন গেমটি শেষ হয়েছে বলে বিবেচিত হয়। \n    যদি পয়েন্টের ক্রমটি একটি গেমের মাঝখানে শেষ হয়, তবে সেই গেমের বর্তমান স্কোরও আউটপুটে অন্তর্ভুক্ত করা হয়।\n\n    আর্গুমেন্টসমূহ:\n    - system (int): একটি গেম জিততে প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১ এর মধ্যে একটি)।\n    - points (str): 'W' এবং 'L' অক্ষরের একটি স্ট্রিং যা খেলোয়াড় এবং প্রতিপক্ষ দ্বারা জেতা পয়েন্ট নির্দেশ করে।\n\n    রিটার্ন:\n    - list: প্রতিটি গেমের স্কোর উপস্থাপনকারী স্ট্রিংগুলির একটি তালিকা।\n\n    কেসসমূহ:\n    - যদি points = \"WWWWWWWWWWL\", এটি উভয় সিস্টেমের অধীনে খেলোয়াড়ের ১০-১ জয়ের সাথে একটি সম্পূর্ণ গেমকে উপস্থাপন করে।\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - যদি points = \"WWLWWLWWLWWLWE\", এটি ১১-পয়েন্ট সিস্টেমের অধীনে দুটি সম্পূর্ণ গেম এবং একটি চলমান গেমকে উপস্থাপন করে,\n      স্কোর ২-১, ২-১, এবং ১-১ যথাক্রমে। ২১-পয়েন্ট সিস্টেমের অধীনে, এটি একটি একক গেমকে ৬-৩ স্কোর সহ উপস্থাপন করে।\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - যদি points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", এটি উভয় সিস্টেমের অধীনে একাধিক গেমকে উপস্থাপন করে, শেষ গেমটি অসমাপ্ত।\n      ১১-পয়েন্ট সিস্টেমের স্কোর ৪-৬, ৫-৫, এবং ১-০, যখন ২১-পয়েন্ট সিস্টেমের স্কোর ১৩-১৬ এবং ২-১।\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "bg": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Изчисляване на резултата от серия пинг-понг игри на базата на предоставената система за точкуване.\n\n    Тази функция приема желаната система за точкуване (или 11 или 21 точки) и низ, \n    представляващ последователността от точки, спечелени от играча ('W') и противника ('L'). \n    Функцията обработва низа и връща списък с резултати от игрите, форматирани като \"player_score:opponent_score\".\n\n    Играта се счита за завършена, когато един играч достигне изисквания брой точки на системата \n    (11 или 21) с поне 2 точки преднина. Ако последователността от точки завърши в средата на игра, \n    текущият резултат на тази игра също е включен в изхода.\n\n    Аргументи:\n    - system (int): Броят точки, необходими за спечелване на игра (или 11 или 21).\n    - points (str): Низ от символи 'W' и 'L', обозначаващи точки, спечелени от играча и противника.\n\n    Връща:\n    - list: Списък от низове, представляващи резултата от всяка игра.\n\n    Примери:\n    - Ако points = \"WWWWWWWWWWL\", това представлява една завършена игра с победа на играча 10-1 и в двете системи.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Ако points = \"WWLWWLWWLWWLWE\", това представлява две завършени игри и една в процес на игра в системата с 11 точки,\n      с резултати 2-1, 2-1 и 1-1 съответно. В системата с 21 точки, това представлява една игра с резултат 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Ако points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", това представлява множество игри в двете системи, като последната игра е незавършена.\n      Системата с 11 точки има резултати 4-6, 5-5 и 1-0, докато системата с 21 точки има резултати 13-16 и 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "zh": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    根据提供的计分系统计算一系列乒乓球比赛的得分。\n\n    此函数接收所需的计分系统（11分或21分）和一个字符串，表示玩家（'W'）和对手（'L'）赢得的分数序列。\n    函数处理该字符串并返回一个游戏得分列表，格式为 \"player_score:opponent_score\"。\n\n    当一名玩家达到系统要求的分数（11或21）并至少领先2分时，比赛被视为结束。\n    如果分数序列在比赛中途结束，该比赛的当前得分也会包含在输出中。\n\n    参数:\n    - system (int): 赢得一局比赛所需的分数（11或21）。\n    - points (str): 一个由 'W' 和 'L' 字符组成的字符串，表示玩家和对手赢得的分数。\n\n    返回:\n    - list: 一个字符串列表，表示每局比赛的得分。\n\n    示例:\n    - 如果 points = \"WWWWWWWWWWL\"，表示在两种系统下玩家以10-1赢得一局完整比赛。\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - 如果 points = \"WWLWWLWWLWWLWE\"，表示在11分系统下有两局完整比赛和一局进行中的比赛，得分分别为2-1, 2-1和1-1。\n      在21分系统下，表示单局比赛，得分为6-3。\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - 如果 points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"，表示在两种系统下有多局比赛，最后一局未完成。\n      11分系统的得分为4-6, 5-5和1-0，而21分系统的得分为13-16和2-1。\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "fr": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculer le score d'une série de jeux de ping-pong basé sur le système de score fourni.\n\n    Cette fonction prend en entrée le système de score souhaité (soit 11 ou 21 points) et une chaîne \n    représentant la séquence de points gagnés par le joueur ('W') et l'adversaire ('L'). \n    La fonction traite la chaîne et renvoie une liste de scores de jeux formatés comme \"player_score:opponent_score\".\n\n    Le jeu est considéré comme terminé lorsqu'un joueur atteint le nombre de points requis par le système \n    (11 ou 21) avec au moins 2 points d'avance. Si la séquence de points se termine au milieu d'un jeu, \n    le score actuel de ce jeu est également inclus dans la sortie.\n\n    Args:\n    - system (int): Le nombre de points requis pour gagner un jeu (soit 11 ou 21).\n    - points (str): Une chaîne de caractères 'W' et 'L' indiquant les points gagnés par le joueur et l'adversaire.\n\n    Returns:\n    - list: Une liste de chaînes représentant le score de chaque jeu.\n\n    Cas:\n    - Si points = \"WWWWWWWWWWL\", cela représente un jeu complet avec le joueur gagnant 10-1 dans les deux systèmes.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Si points = \"WWLWWLWWLWWLWE\", cela représente deux jeux complets et un jeu en cours sous le système de 11 points,\n      avec des scores de 2-1, 2-1, et 1-1 respectivement. Sous le système de 21 points, cela représente un seul jeu avec un score de 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Si points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", cela représente plusieurs jeux sous les deux systèmes, avec le dernier jeu non terminé.\n      Le système de 11 points a des scores de 4-6, 5-5, et 1-0, tandis que le système de 21 points a des scores de 13-16 et 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "de": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Berechne die Punktzahl einer Serie von Tischtennisspielen basierend auf dem angegebenen Punktesystem.\n\n    Diese Funktion nimmt das gewünschte Punktesystem (entweder 11 oder 21 Punkte) und einen String, \n    der die Abfolge der vom Spieler ('W') und vom Gegner ('L') gewonnenen Punkte darstellt, entgegen. \n    Die Funktion verarbeitet den String und gibt eine Liste von Spielständen im Format \"player_score:opponent_score\" zurück.\n\n    Das Spiel gilt als beendet, wenn ein Spieler die erforderliche Punktzahl des Systems \n    (11 oder 21) mit mindestens 2 Punkten Vorsprung erreicht. Wenn die Punktesequenz mitten in einem Spiel endet, \n    wird der aktuelle Spielstand dieses Spiels ebenfalls in die Ausgabe aufgenommen.\n\n    Argumente:\n    - system (int): Die Anzahl der Punkte, die erforderlich sind, um ein Spiel zu gewinnen (entweder 11 oder 21).\n    - points (str): Ein String aus 'W'- und 'L'-Zeichen, die die vom Spieler und Gegner gewonnenen Punkte anzeigen.\n\n    Rückgabewert:\n    - list: Eine Liste von Strings, die den Spielstand jedes Spiels darstellen.\n\n    Fälle:\n    - Wenn points = \"WWWWWWWWWWL\", stellt es ein vollständiges Spiel dar, bei dem der Spieler mit 10-1 in beiden Systemen gewinnt.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Wenn points = \"WWLWWLWWLWWLWE\", stellt es zwei vollständige Spiele und ein laufendes Spiel im 11-Punkte-System dar,\n      mit den Spielständen 2-1, 2-1 und 1-1. Im 21-Punkte-System stellt es ein einzelnes Spiel mit einem Spielstand von 6-3 dar.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Wenn points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", stellt es mehrere Spiele in beiden Systemen dar, wobei das letzte Spiel unvollständig ist.\n      Das 11-Punkte-System hat die Spielstände 4-6, 5-5 und 1-0, während das 21-Punkte-System die Spielstände 13-16 und 2-1 hat.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "ha": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Lissafa maki na jerin wasannin ping-pong bisa tsarin maki da aka bayar.\n\n    Wannan aikin yana karɓar tsarin maki da ake so (ko dai maki 11 ko 21) da kuma wani igiyar \n    haruffa da ke wakiltar jerin maki da ɗan wasa ('W') da abokin hamayya ('L') suka ci. \n    Aikin yana sarrafa igiyar kuma yana dawo da jerin maki na wasanni da aka tsara kamar \"maki_ɗan_wasa:maki_abokin_hamayya\".\n\n    Ana ɗaukar wasan ya ƙare idan ɗaya daga cikin 'yan wasan ya kai adadin maki da ake buƙata \n    na tsarin (11 ko 21) tare da tazarar maki 2 aƙalla. Idan jerin maki ya ƙare a tsakiyar wasa, \n    ana haɗa maki na wannan wasan a cikin sakamakon.\n\n    Args:\n    - system (int): Adadin maki da ake buƙata don cin wasa (ko dai 11 ko 21).\n    - points (str): Wani igiyar haruffa na 'W' da 'L' da ke nuna maki da ɗan wasa da abokin hamayya suka ci.\n\n    Returns:\n    - list: Jerin igiyoyi da ke wakiltar maki na kowane wasa.\n\n    Cases:\n    - Idan points = \"WWWWWWWWWWL\", yana wakiltar wasa guda ɗaya da ɗan wasa ya ci 10-1 a ƙarƙashin dukkan tsarin.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Idan points = \"WWLWWLWWLWWLWE\", yana wakiltar wasanni biyu cikakku da ɗaya da ke ci gaba a ƙarƙashin tsarin maki 11,\n      tare da maki 2-1, 2-1, da 1-1 bi da bi. A ƙarƙashin tsarin maki 21, yana wakiltar wasa guda ɗaya da maki 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Idan points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", yana wakiltar wasanni da yawa a ƙarƙashin dukkan tsarin, tare da wasan ƙarshe ba a gama ba.\n      Tsarin maki 11 yana da maki 4-6, 5-5, da 1-0, yayin da tsarin maki 21 yana da maki 13-16 da 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "hi": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    प्रदान किए गए स्कोरिंग सिस्टम के आधार पर पिंग-पोंग खेलों की श्रृंखला का स्कोर गणना करें।\n\n    यह फ़ंक्शन वांछित स्कोरिंग सिस्टम (या तो 11 या 21 अंक) और एक स्ट्रिंग लेता है \n    जो खिलाड़ी ('W') और प्रतिद्वंद्वी ('L') द्वारा जीते गए अंकों के अनुक्रम का प्रतिनिधित्व करता है। \n    फ़ंक्शन स्ट्रिंग को प्रोसेस करता है और गेम स्कोर की एक सूची \"player_score:opponent_score\" के रूप में लौटाता है।\n\n    खेल को समाप्त माना जाता है जब एक खिलाड़ी सिस्टम द्वारा आवश्यक अंकों की संख्या \n    (11 या 21) कम से कम 2 अंकों की बढ़त के साथ प्राप्त कर लेता है। यदि अंकों का अनुक्रम खेल के बीच में समाप्त होता है, \n    तो उस खेल का वर्तमान स्कोर भी आउटपुट में शामिल होता है।\n\n    तर्क:\n    - system (int): गेम जीतने के लिए आवश्यक अंकों की संख्या (या तो 11 या 21)।\n    - points (str): 'W' और 'L' वर्णों की एक स्ट्रिंग जो खिलाड़ी और प्रतिद्वंद्वी द्वारा जीते गए अंकों को दर्शाती है।\n\n    रिटर्न:\n    - list: प्रत्येक खेल के स्कोर का प्रतिनिधित्व करने वाली स्ट्रिंग्स की एक सूची।\n\n    मामले:\n    - यदि points = \"WWWWWWWWWWL\", तो यह एक पूर्ण खेल का प्रतिनिधित्व करता है जिसमें खिलाड़ी 10-1 से जीतता है दोनों सिस्टमों के तहत।\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - यदि points = \"WWLWWLWWLWWLWE\", तो यह 11-अंक प्रणाली के तहत दो पूर्ण खेलों और एक प्रगति में खेल का प्रतिनिधित्व करता है,\n      स्कोर 2-1, 2-1, और 1-1 क्रमशः। 21-अंक प्रणाली के तहत, यह एकल खेल का प्रतिनिधित्व करता है जिसका स्कोर 6-3 है।\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - यदि points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", तो यह दोनों सिस्टमों के तहत कई खेलों का प्रतिनिधित्व करता है, जिसमें अंतिम खेल अधूरा है।\n      11-अंक प्रणाली में स्कोर 4-6, 5-5, और 1-0 हैं, जबकि 21-अंक प्रणाली में स्कोर 13-16 और 2-1 हैं।\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "hu": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Számolja ki egy sorozat ping-pong játék pontszámát az adott pontozási rendszer alapján.\n\n    Ez a függvény a kívánt pontozási rendszert (vagy 11 vagy 21 pont) és egy karakterláncot vesz fel, \n    amely a játékos ('W') és az ellenfél ('L') által nyert pontok sorozatát ábrázolja. \n    A függvény feldolgozza a karakterláncot, és visszaad egy listát a játék pontszámaival, \n    \"player_score:opponent_score\" formátumban.\n\n    A játék akkor tekinthető befejezettnek, amikor az egyik játékos eléri a rendszer által megkövetelt \n    pontszámot (11 vagy 21) legalább 2 pontos előnnyel. Ha a pontok sorozata egy játék közepén ér véget, \n    az adott játék aktuális pontszáma is szerepel a kimenetben.\n\n    Args:\n    - system (int): A játék megnyeréséhez szükséges pontok száma (vagy 11 vagy 21).\n    - points (str): 'W' és 'L' karakterekből álló karakterlánc, amely a játékos és az ellenfél által nyert pontokat jelöli.\n\n    Returns:\n    - list: A játékok pontszámait reprezentáló karakterláncok listája.\n\n    Esetek:\n    - Ha points = \"WWWWWWWWWWL\", ez egy teljes játékot jelent, ahol a játékos 10-1-re nyer mindkét rendszer alatt.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Ha points = \"WWLWWLWWLWWLWE\", ez két teljes játékot és egy folyamatban lévő játékot jelent a 11 pontos rendszer alatt,\n      pontszámokkal 2-1, 2-1 és 1-1. A 21 pontos rendszer alatt ez egyetlen játékot jelent 6-3-as pontszámmal.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Ha points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", ez több játékot jelent mindkét rendszer alatt, az utolsó játék befejezetlen.\n      A 11 pontos rendszer alatt a pontszámok 4-6, 5-5 és 1-0, míg a 21 pontos rendszer alatt 13-16 és 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "es": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calcular el puntaje de una serie de juegos de ping-pong basado en el sistema de puntuación proporcionado.\n\n    Esta función toma el sistema de puntuación deseado (ya sea 11 o 21 puntos) y una cadena \n    que representa la secuencia de puntos ganados por el jugador ('W') y el oponente ('L'). \n    La función procesa la cadena y devuelve una lista de puntajes de juegos formateados como \"player_score:opponent_score\".\n\n    El juego se considera terminado cuando un jugador alcanza el número de puntos requerido por el sistema \n    (11 o 21) con al menos una ventaja de 2 puntos. Si la secuencia de puntos termina en medio de un juego, \n    el puntaje actual de ese juego también se incluye en la salida.\n\n    Argumentos:\n    - system (int): El número de puntos requeridos para ganar un juego (ya sea 11 o 21).\n    - points (str): Una cadena de caracteres 'W' y 'L' que denotan puntos ganados por el jugador y el oponente.\n\n    Devuelve:\n    - list: Una lista de cadenas que representan el puntaje de cada juego.\n\n    Casos:\n    - Si points = \"WWWWWWWWWWL\", representa un juego completo con el jugador ganando 10-1 bajo ambos sistemas.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Si points = \"WWLWWLWWLWWLWE\", representa dos juegos completos y uno en progreso bajo el sistema de 11 puntos,\n      con puntajes 2-1, 2-1, y 1-1 respectivamente. Bajo el sistema de 21 puntos, representa un solo juego con un puntaje de 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Si points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", representa múltiples juegos bajo ambos sistemas, con el último juego sin terminar.\n      El sistema de 11 puntos tiene puntajes 4-6, 5-5, y 1-0, mientras que el sistema de 21 puntos tiene puntajes 13-16 y 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "arb": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    حساب النتيجة لسلسلة من مباريات كرة الطاولة بناءً على نظام التسجيل المقدم.\n\n    تأخذ هذه الدالة نظام التسجيل المطلوب (إما 11 أو 21 نقطة) وسلسلة تمثل تسلسل النقاط التي فاز بها اللاعب ('W') والخصم ('L').\n    تقوم الدالة بمعالجة السلسلة وتعيد قائمة بنتائج المباريات بصيغة \"player_score:opponent_score\".\n\n    تعتبر اللعبة منتهية عندما يصل أحد اللاعبين إلى العدد المطلوب من النقاط في النظام (11 أو 21) مع تقدم لا يقل عن نقطتين. \n    إذا انتهى تسلسل النقاط في منتصف اللعبة، يتم تضمين النتيجة الحالية لتلك اللعبة أيضًا في الناتج.\n\n    يعيدالحجج:\n    - system (int): عدد النقاط المطلوبة للفوز في اللعبة (إما 11 أو 21).\n    - points (str): سلسلة من الأحرف 'W' و 'L' تشير إلى النقاط التي فاز بها اللاعب والخصم.\n\n    يعيد:\n    - list: قائمة من السلاسل تمثل نتيجة كل لعبة.\n\n    حالات:\n    - إذا كانت النقاط = \"WWWWWWWWWWL\"، فإنها تمثل لعبة كاملة واحدة بفوز اللاعب 10-1 تحت كلا النظامين.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - إذا كانت النقاط = \"WWLWWLWWLWWLWE\"، فإنها تمثل لعبتين كاملتين وواحدة في طور التقدم تحت نظام 11 نقطة،\n      مع النتائج 2-1، 2-1، و 1-1 على التوالي. تحت نظام 21 نقطة، تمثل لعبة واحدة بنتيجة 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - إذا كانت النقاط = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"، فإنها تمثل عدة مباريات تحت كلا النظامين، مع انتهاء اللعبة الأخيرة غير مكتملة.\n      نظام 11 نقطة لديه نتائج 4-6، 5-5، و 1-0، بينما نظام 21 نقطة لديه نتائج 13-16 و 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "sw": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Hesabu alama ya mfululizo wa michezo ya ping-pong kulingana na mfumo wa alama uliotolewa.\n\n    Kazi hii inachukua mfumo wa alama unaotakiwa (ama pointi 11 au 21) na kamba \n    inayowakilisha mfululizo wa pointi zilizoshindwa na mchezaji ('W') na mpinzani ('L'). \n    Kazi hii inachakata kamba na kurudisha orodha ya alama za mchezo zilizopangwa kama \"alama_ya_mchezaji:alama_ya_mpinzani\".\n\n    Mchezo unachukuliwa kuwa umemalizika wakati mchezaji mmoja anafikia idadi ya pointi inayotakiwa na mfumo \n    (11 au 21) akiwa na uongozi wa angalau pointi 2. Ikiwa mfululizo wa pointi unamalizika katikati ya mchezo, \n    alama ya sasa ya mchezo huo pia inajumuishwa katika matokeo.\n\n    Hoja:\n    - system (int): Idadi ya pointi zinazohitajika kushinda mchezo (ama 11 au 21).\n    - points (str): Kamba ya herufi 'W' na 'L' inayoonyesha pointi zilizoshindwa na mchezaji na mpinzani.\n\n    Inarejesha:\n    - list: Orodha ya kamba zinazowakilisha alama za kila mchezo.\n\n    Matukio:\n    - Ikiwa points = \"WWWWWWWWWWL\", inawakilisha mchezo mmoja kamili na mchezaji akishinda 10-1 chini ya mifumo yote miwili.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Ikiwa points = \"WWLWWLWWLWWLWE\", inawakilisha michezo miwili kamili na mmoja unaoendelea chini ya mfumo wa pointi 11,\n      na alama 2-1, 2-1, na 1-1 mtawalia. Chini ya mfumo wa pointi 21, inawakilisha mchezo mmoja na alama ya 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Ikiwa points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", inawakilisha michezo mingi chini ya mifumo yote miwili, na mchezo wa mwisho haujakamilika.\n      Mfumo wa pointi 11 una alama 4-6, 5-5, na 1-0, wakati mfumo wa pointi 21 una alama 13-16 na 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "tr": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Sağlanan puanlama sistemine göre bir dizi masa tenisi oyununun skorunu hesaplayın.\n\n    Bu fonksiyon, istenen puanlama sistemini (ya 11 ya da 21 puan) ve oyuncu ('W') ve rakip ('L') tarafından kazanılan \n    puanların dizisini temsil eden bir dize alır. Fonksiyon diziyi işler ve \"oyuncu_skoru:rakip_skoru\" formatında \n    oyun skorlarının bir listesini döndürür.\n\n    Bir oyuncu, sistemin gerektirdiği puan sayısına (11 veya 21) en az 2 puan farkla ulaştığında oyun tamamlanmış sayılır. \n    Eğer puan dizisi bir oyunun ortasında biterse, o oyunun mevcut skoru da çıktıya dahil edilir.\n\n    Argümanlar:\n    - system (int): Bir oyunu kazanmak için gereken puan sayısı (ya 11 ya da 21).\n    - points (str): Oyuncu ve rakip tarafından kazanılan puanları belirten 'W' ve 'L' karakterlerinden oluşan bir dize.\n\n    Döndürür:\n    - list: Her oyunun skorunu temsil eden dizelerin bir listesi.\n\n    Durumlar:\n    - Eğer points = \"WWWWWWWWWWL\" ise, bu, her iki sistemde de oyuncunun 10-1 kazandığı bir tam oyunu temsil eder.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Eğer points = \"WWLWWLWWLWWLWE\" ise, bu, 11 puanlık sistemde iki tam oyun ve bir devam eden oyunu temsil eder,\n      sırasıyla 2-1, 2-1 ve 1-1 skorlarıyla. 21 puanlık sistemde ise, 6-3 skorlu tek bir oyunu temsil eder.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Eğer points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\" ise, bu, her iki sistemde de birden fazla oyunu temsil eder, son oyun tamamlanmamıştır.\n      11 puanlık sistemde skorlar 4-6, 5-5 ve 1-0 iken, 21 puanlık sistemde skorlar 13-16 ve 2-1'dir.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "vi": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Tính điểm của một loạt các trận đấu bóng bàn dựa trên hệ thống tính điểm được cung cấp.\n\n    Hàm này nhận vào hệ thống tính điểm mong muốn (hoặc 11 hoặc 21 điểm) và một chuỗi \n    đại diện cho chuỗi điểm mà người chơi ('W') và đối thủ ('L') giành được. \n    Hàm xử lý chuỗi và trả về một danh sách các điểm số của trận đấu được định dạng dưới dạng \"player_score:opponent_score\".\n\n    Trận đấu được coi là kết thúc khi một người chơi đạt đến số điểm yêu cầu của hệ thống \n    (11 hoặc 21) với ít nhất 2 điểm dẫn trước. Nếu chuỗi điểm kết thúc giữa chừng một trận đấu, \n    điểm số hiện tại của trận đấu đó cũng được bao gồm trong đầu ra.\n\n    Tham số:\n    - system (int): Số điểm cần thiết để thắng một trận đấu (hoặc 11 hoặc 21).\n    - points (str): Một chuỗi các ký tự 'W' và 'L' biểu thị điểm mà người chơi và đối thủ giành được.\n\n    Trả về:\n    - list: Một danh sách các chuỗi đại diện cho điểm số của mỗi trận đấu.\n\n    Trường hợp:\n    - Nếu points = \"WWWWWWWWWWL\", nó đại diện cho một trận đấu hoàn chỉnh với người chơi thắng 10-1 dưới cả hai hệ thống.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Nếu points = \"WWLWWLWWLWWLWE\", nó đại diện cho hai trận đấu hoàn chỉnh và một trận đấu đang diễn ra dưới hệ thống 11 điểm,\n      với điểm số lần lượt là 2-1, 2-1, và 1-1. Dưới hệ thống 21 điểm, nó đại diện cho một trận đấu với điểm số 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Nếu points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", nó đại diện cho nhiều trận đấu dưới cả hai hệ thống, với trận đấu cuối chưa hoàn thành.\n      Hệ thống 11 điểm có điểm số 4-6, 5-5, và 1-0, trong khi hệ thống 21 điểm có điểm số 13-16 và 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "id": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Hitung skor dari serangkaian permainan ping-pong berdasarkan sistem penilaian yang disediakan.\n\n    Fungsi ini menerima sistem penilaian yang diinginkan (baik 11 atau 21 poin) dan sebuah string \n    yang mewakili urutan poin yang dimenangkan oleh pemain ('W') dan lawan ('L'). \n    Fungsi ini memproses string tersebut dan mengembalikan daftar skor permainan yang diformat sebagai \"player_score:opponent_score\".\n\n    Permainan dianggap selesai ketika satu pemain mencapai jumlah poin yang diperlukan oleh sistem \n    (11 atau 21) dengan setidaknya keunggulan 2 poin. Jika urutan poin berakhir di tengah permainan, \n    skor permainan saat ini juga disertakan dalam output.\n\n    Argumen:\n    - system (int): Jumlah poin yang diperlukan untuk memenangkan permainan (baik 11 atau 21).\n    - points (str): Sebuah string dari karakter 'W' dan 'L' yang menunjukkan poin yang dimenangkan oleh pemain dan lawan.\n\n    Mengembalikan:\n    - list: Daftar string yang mewakili skor dari setiap permainan.\n\n    Kasus:\n    - Jika points = \"WWWWWWWWWWL\", ini mewakili satu permainan lengkap dengan pemain menang 10-1 di bawah kedua sistem.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Jika points = \"WWLWWLWWLWWLWE\", ini mewakili dua permainan lengkap dan satu permainan yang sedang berlangsung di bawah sistem 11 poin,\n      dengan skor masing-masing 2-1, 2-1, dan 1-1. Di bawah sistem 21 poin, ini mewakili satu permainan dengan skor 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Jika points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", ini mewakili beberapa permainan di bawah kedua sistem, dengan permainan terakhir belum selesai.\n      Sistem 11 poin memiliki skor 4-6, 5-5, dan 1-0, sedangkan sistem 21 poin memiliki skor 13-16 dan 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "ja": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    提供されたスコアリングシステムに基づいて、一連の卓球ゲームのスコアを計算します。\n\n    この関数は、希望するスコアリングシステム（11ポイントまたは21ポイント）と、プレイヤー（'W'）および対戦相手（'L'）が獲得したポイントのシーケンスを表す文字列を受け取ります。\n    関数は文字列を処理し、\"player_score:opponent_score\"の形式でゲームスコアのリストを返します。\n\n    ゲームは、あるプレイヤーがシステムで要求されるポイント数（11または21）に少なくとも2ポイントのリードで到達したときに終了したと見なされます。\n    ポイントのシーケンスがゲームの途中で終了した場合、そのゲームの現在のスコアも出力に含まれます。\n\n    引数:\n    - system (int): ゲームに勝つために必要なポイント数（11または21のいずれか）。\n    - points (str): プレイヤーと対戦相手が獲得したポイントを示す'W'と'L'の文字列。\n\n    戻り値:\n    - list: 各ゲームのスコアを表す文字列のリスト。\n\n    ケース:\n    - もしpoints = \"WWWWWWWWWWL\"の場合、これはプレイヤーが10-1で勝利する1つの完全なゲームを表し、両方のシステムで同様です。\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - もしpoints = \"WWLWWLWWLWWLWE\"の場合、これは11ポイントシステムで2つの完全なゲームと1つの進行中のゲームを表し、それぞれのスコアは2-1、2-1、1-1です。21ポイントシステムでは、6-3のスコアで1つのゲームを表します。\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - もしpoints = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"の場合、これは両方のシステムで複数のゲームを表し、最後のゲームは未完成です。\n      11ポイントシステムではスコアは4-6、5-5、1-0であり、21ポイントシステムではスコアは13-16、2-1です。\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "ko": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    제공된 점수 시스템에 따라 일련의 탁구 게임 점수를 계산합니다.\n\n    이 함수는 원하는 점수 시스템(11점 또는 21점)과 플레이어('W') 및 상대방('L')이 획득한 점수를 나타내는 문자열을 입력으로 받습니다.\n    함수는 문자열을 처리하고 각 게임의 점수를 \"player_score:opponent_score\" 형식의 문자열 리스트로 반환합니다.\n\n    한 플레이어가 시스템에서 요구하는 점수(11점 또는 21점)에 최소 2점 차이로 도달하면 게임이 종료된 것으로 간주됩니다.\n    점수의 시퀀스가 게임 중간에 끝나면 해당 게임의 현재 점수도 출력에 포함됩니다.\n\n    매개변수:\n    - system (int): 게임에서 승리하기 위해 필요한 점수(11 또는 21).\n    - points (str): 플레이어와 상대방이 획득한 점수를 나타내는 'W'와 'L' 문자로 구성된 문자열.\n\n    반환값:\n    - list: 각 게임의 점수를 나타내는 문자열 리스트.\n\n    사례:\n    - 만약 points = \"WWWWWWWWWWL\"이라면, 이는 플레이어가 10-1로 승리한 하나의 완전한 게임을 나타내며, 두 시스템 모두에서 동일합니다.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - 만약 points = \"WWLWWLWWLWWLWE\"이라면, 이는 11점 시스템에서 두 개의 완전한 게임과 하나의 진행 중인 게임을 나타내며,\n      각각의 점수는 2-1, 2-1, 1-1입니다. 21점 시스템에서는 6-3의 점수를 가진 단일 게임을 나타냅니다.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - 만약 points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"이라면, 이는 두 시스템 모두에서 여러 게임을 나타내며, 마지막 게임은 미완성입니다.\n      11점 시스템에서는 점수가 4-6, 5-5, 1-0이며, 21점 시스템에서는 점수가 13-16과 2-1입니다.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "ml": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    നൽകിയ സ്കോറിംഗ് സിസ്റ്റം അടിസ്ഥാനമാക്കി പിംഗ്-പോംഗ് ഗെയിമുകളുടെ ഒരു പരമ്പരയുടെ സ്കോർ കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ആവശ്യമായ സ്കോറിംഗ് സിസ്റ്റം (11 അല്ലെങ്കിൽ 21 പോയിന്റുകൾ) \n    ഒരു സ്ട്രിംഗ് ആകൃതിയിൽ കളിക്കാരൻ ('W') \n    എതിരാളി ('L') നേടിയ പോയിന്റുകളുടെ ക്രമം പ്രതിനിധീകരിക്കുന്നു. \n    സ്ട്രിംഗ് പ്രോസസ്സ് ചെയ്ത് \"player_score:opponent_score\" എന്ന ഫോർമാറ്റിൽ ഗെയിം സ്കോറുകളുടെ \n    ഒരു ലിസ്റ്റ് തിരികെ നൽകുന്നു.\n\n    ഒരു കളിക്കാരൻ സിസ്റ്റത്തിന്റെ ആവശ്യമായ പോയിന്റുകളുടെ എണ്ണം (11 അല്ലെങ്കിൽ 21) \n    കുറഞ്ഞത് 2-പോയിന്റ് ലീഡ് ഉള്ളപ്പോൾ ഗെയിം പൂർത്തിയായി എന്ന് കരുതുന്നു. \n    പോയിന്റുകളുടെ ക്രമം ഒരു ഗെയിമിന്റെ മധ്യത്തിൽ അവസാനിച്ചാൽ, \n    ആ ഗെയിമിന്റെ നിലവിലെ സ്കോർ ഔട്ട്പുട്ടിൽ ഉൾപ്പെടുത്തുന്നു.\n\n    Args:\n    - system (int): ഒരു ഗെയിം ജയിക്കാൻ ആവശ്യമായ പോയിന്റുകളുടെ എണ്ണം (11 അല്ലെങ്കിൽ 21).\n    - points (str): കളിക്കാരനും എതിരാളിയും നേടിയ പോയിന്റുകൾ സൂചിപ്പിക്കുന്ന 'W' \n    'L' അക്ഷരങ്ങളുടെ ഒരു സ്ട്രിംഗ്.\n\n    Returns:\n    - list: ഓരോ ഗെയിമിന്റെയും സ്കോർ പ്രതിനിധീകരിക്കുന്ന സ്ട്രിംഗുകളുടെ ഒരു ലിസ്റ്റ്.\n\n    ഉദാഹരണങ്ങൾ:\n    - If points = \"WWWWWWWWWWL\", അത് 11 പോയിന്റ് സിസ്റ്റത്തിനും 21 പോയിന്റ് സിസ്റ്റത്തിനും \n      കീഴിൽ കളിക്കാരൻ 10-1 ന് വിജയിക്കുന്ന ഒരു പൂർണ്ണ ഗെയിം പ്രതിനിധീകരിക്കുന്നു.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - If points = \"WWLWWLWWLWWLWE\", അത് 11-പോയിന്റ് സിസ്റ്റത്തിനുള്ളിൽ രണ്ട് പൂർണ്ണ ഗെയിമുകളും \n      ഒരു പുരോഗമന ഗെയിമും പ്രതിനിധീകരിക്കുന്നു, സ്കോറുകൾ യഥാക്രമം 2-1, 2-1, 1-1. \n      21-പോയിന്റ് സിസ്റ്റത്തിനുള്ളിൽ, അത് 6-3 എന്ന സ്കോറുള്ള ഒരു ഗെയിം പ്രതിനിധീകരിക്കുന്നു.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", \n      അത് ഇരുവിധ സിസ്റ്റങ്ങളിലും നിരവധി ഗെയിമുകൾ പ്രതിനിധീകരിക്കുന്നു, \n      അവസാന ഗെയിം പൂർത്തിയാകാത്തതാണ്. \n      11-പോയിന്റ് സിസ്റ്റത്തിന് സ്കോറുകൾ 4-6, 5-5, 1-0 ഉണ്ട്, \n      21-പോയിന്റ് സിസ്റ്റത്തിന് സ്കോറുകൾ 13-16, 2-1 ഉണ്ട്.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "fa": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    امتیاز یک سری بازی پینگ‌پنگ را بر اساس سیستم امتیازدهی ارائه شده محاسبه کنید.\n\n    این تابع سیستم امتیازدهی مورد نظر (یا 11 یا 21 امتیاز) و یک رشته \n    که توالی امتیازات برنده شده توسط بازیکن ('W') و حریف ('L') را نشان می‌دهد، دریافت می‌کند. \n    تابع رشته را پردازش کرده و لیستی از امتیازات بازی‌ها را به فرمت \"player_score:opponent_score\" برمی‌گرداند.\n\n    بازی زمانی تمام شده در نظر گرفته می‌شود که یکی از بازیکنان به تعداد امتیاز مورد نیاز سیستم \n    (11 یا 21) با حداقل 2 امتیاز برتری برسد. اگر توالی امتیازات در وسط یک بازی به پایان برسد، \n    امتیاز فعلی آن بازی نیز در خروجی گنجانده می‌شود.\n\n    آرگومان‌ها:\n    - system (int): تعداد امتیازات مورد نیاز برای بردن یک بازی (یا 11 یا 21).\n    - points (str): رشته‌ای از کاراکترهای 'W' و 'L' که نشان‌دهنده امتیازات برنده شده توسط بازیکن و حریف است.\n\n    بازگشت:\n    - list: لیستی از رشته‌ها که امتیاز هر بازی را نشان می‌دهد.\n\n    موارد:\n    - اگر points = \"WWWWWWWWWWL\"، یک بازی کامل را نشان می‌دهد که بازیکن 10-1 برنده می‌شود تحت هر دو سیستم.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - اگر points = \"WWLWWLWWLWWLWE\"، دو بازی کامل و یک بازی در حال پیشرفت را تحت سیستم 11 امتیازی نشان می‌دهد،\n      با امتیازات 2-1، 2-1، و 1-1 به ترتیب. تحت سیستم 21 امتیازی، یک بازی با امتیاز 6-3 را نشان می‌دهد.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - اگر points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"، چندین بازی را تحت هر دو سیستم نشان می‌دهد، با بازی آخر ناتمام.\n      سیستم 11 امتیازی امتیازات 4-6، 5-5، و 1-0 دارد، در حالی که سیستم 21 امتیازی امتیازات 13-16 و 2-1 دارد.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\""}, "canonical_solution": "    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores", "instruction": {"en": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben.", "es": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nVerilen Python kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.", "vi": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\n다음 Python 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_calculate_score():\n    # Test case 1: A single game in both systems, with a clear winner.\n    points = \"WWWWWWWWWWL\"\n    expected_11 = [\"10:1\"]\n    expected_21 = [\"10:1\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 1 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 1 (21-point) failed\"\n\n    # Test case 2: Multiple games, some completed and one in progress.\n    points = \"WWLWWLWWLWWLWE\"\n    expected_11 = [\"9:4\"]\n    expected_21 = [\"9:4\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 2 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 2 (21-point) failed\"\n\n    # Test case 3: A longer sequence with many games and a final unfinished game.\n    points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"\n    expected_11 = ['12:10', '5:4']\n    expected_21 = ['17:14']\n    assert calculate_score(11, points) == expected_11, \"Test case 3 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 3 (21-point) failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_calculate_score()", "entry_point": "calculate_score", "signature": "def calculate_score(system: int, points: str) -> list:", "docstring": {"en": "Calculate the score of a series of ping-pong games based on the provided scoring system.\n\nThis function takes in the desired scoring system (either 11 or 21 points) and a string\nrepresenting the sequence of points won by the player ('W') and the opponent ('L').\nThe function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\nThe game is considered finished when one player reaches the system's required number of points\n(11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game,\nthat game's current score is also included in the output.\n\nArgs:\n- system (int): The number of points required to win a game (either 11 or 21).\n- points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\nReturns:\n- list: A list of strings representing the score of each game.\n\nCases:\n- If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\nwith scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\nThe 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "sq": "Llogaritni rezultatin e një serie lojërash ping-pong bazuar në sistemin e dhënë të pikëve.\n\nKjo funksion merr si hyrje sistemin e dëshiruar të pikëve (ose 11 ose 21 pikë) dhe një varg\nqë përfaqëson sekuencën e pikëve të fituara nga lojtari ('W') dhe kundërshtari ('L').\nFunksioni përpunon vargun dhe kthen një listë të rezultateve të lojërave të formatuara si \"rezultati_lojtari:rezultati_kundërshtari\".\n\nLoja konsiderohet e përfunduar kur një lojtar arrin numrin e kërkuar të pikëve të sistemit\n(11 ose 21) me të paktën një avantazh prej 2 pikësh. Nëse sekuenca e pikëve përfundon në mes të një loje,\nrezultati aktual i asaj loje gjithashtu përfshihet në dalje.\n\nArgumentet:\n- system (int): Numri i pikëve të kërkuara për të fituar një lojë (ose 11 ose 21).\n- points (str): Një varg me karaktere 'W' dhe 'L' që tregojnë pikët e fituara nga lojtari dhe kundërshtari.\n\nKthen:\n- list: Një listë me vargje që përfaqësojnë rezultatin e secilës lojë.\n\nRastet:\n- Nëse points = \"WWWWWWWWWWL\", përfaqëson një lojë të plotë me lojtarin që fiton 10-1 nën të dy sistemet.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Nëse points = \"WWLWWLWWLWWLWE\", përfaqëson dy lojëra të plota dhe një lojë në progres nën sistemin me 11 pikë,\nme rezultate 2-1, 2-1, dhe 1-1 respektivisht. Nën sistemin me 21 pikë, përfaqëson një lojë të vetme me rezultat 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Nëse points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", përfaqëson lojëra të shumta nën të dy sistemet, me lojën e fundit të papërfunduar.\nSistemi me 11 pikë ka rezultate 4-6, 5-5, dhe 1-0, ndërsa sistemi me 21 pikë ka rezultate 13-16 dhe 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "hy": "Հաշվարկել պինգ-պոնգ խաղերի շարքի միավորները՝ հիմնվելով տրված միավորների համակարգի վրա։\n\nԱյս ֆունկցիան ընդունում է ցանկալի միավորների համակարգը (կամ 11 կամ 21 միավոր) և մի տող,\nորը ներկայացնում է խաղացողի ('W') և մրցակցի ('L') կողմից շահած միավորների հաջորդականությունը։\nՖունկցիան մշակում է տողը և վերադարձնում խաղերի միավորների ցուցակը՝ ձևաչափված որպես \"խաղացողի_միավորներ:մրցակցի_միավորներ\"։\n\nԽաղը համարվում է ավարտված, երբ խաղացողներից մեկը հասնում է համակարգի պահանջվող միավորների քանակին\n(11 կամ 21) առնվազն 2 միավորի առավելությամբ։ Եթե միավորների հաջորդականությունը ավարտվում է խաղի ընթացքում,\nայդ խաղի ընթացիկ միավորները նույնպես ներառվում են արդյունքում։\n\nԱրձագանքներ:\n- system (int): Խաղը շահելու համար պահանջվող միավորների քանակը (կամ 11 կամ 21)։\n- points (str): 'W' և 'L' տառերի տող, որը նշում է խաղացողի և մրցակցի կողմից շահած միավորները։\n\nՎերադարձնում է:\n- list: Տողերի ցուցակ, որը ներկայացնում է յուրաքանչյուր խաղի միավորները։\n\nԴեպքեր:\n- Եթե points = \"WWWWWWWWWWL\", այն ներկայացնում է մեկ ամբողջական խաղ, որտեղ խաղացողը հաղթում է 10-1 երկու համակարգերով։\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Եթե points = \"WWLWWLWWLWWLWE\", այն ներկայացնում է երկու ամբողջական խաղ և մեկ ընթացիկ խաղ 11 միավորների համակարգով,\nմիավորներով 2-1, 2-1 և 1-1 համապատասխանաբար։ 21 միավորների համակարգով այն ներկայացնում է մեկ խաղ՝ 6-3 միավորով։\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Եթե points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", այն ներկայացնում է բազմաթիվ խաղեր երկու համակարգերով, վերջին խաղը չավարտված։\n11 միավորների համակարգը ունի 4-6, 5-5 և 1-0 միավորներ, մինչդեռ 21 միավորների համակարգը ունի 13-16 և 2-1 միավորներ։\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "bn": "পিং-পং গেমের একটি সিরিজের স্কোর প্রদত্ত স্কোরিং সিস্টেমের ভিত্তিতে গণনা করুন।\n\nএই ফাংশনটি ইচ্ছাকৃত স্কোরিং সিস্টেম (১১ বা ২১ পয়েন্ট) এবং একটি স্ট্রিং গ্রহণ করে যা খেলোয়াড় ('W') এবং প্রতিপক্ষ ('L') দ্বারা জেতা পয়েন্টের ক্রম উপস্থাপন করে। ফাংশনটি স্ট্রিংটি প্রক্রিয়া করে এবং \"player_score:opponent_score\" হিসাবে ফরম্যাট করা গেম স্কোরের একটি তালিকা প্রদান করে।\n\nযখন একজন খেলোয়াড় সিস্টেমের প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১) কমপক্ষে ২ পয়েন্টের লিড সহ পৌঁছায়, তখন গেমটি শেষ হয়েছে বলে বিবেচিত হয়। যদি পয়েন্টের ক্রম একটি গেমের মাঝখানে শেষ হয়, তবে সেই গেমের বর্তমান স্কোরও আউটপুটে অন্তর্ভুক্ত হয়।\n\nআর্গস:\n- system (int): একটি গেম জিততে প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১ এর যেকোনো একটি)।\n- points (str): 'W' এবং 'L' অক্ষরের একটি স্ট্রিং যা খেলোয়াড় এবং প্রতিপক্ষ দ্বারা জেতা পয়েন্ট নির্দেশ করে।\n\nরিটার্নস:\n- list: প্রতিটি গেমের স্কোর উপস্থাপনকারী স্ট্রিংগুলির একটি তালিকা।\n\nকেসসমূহ:\n- যদি points = \"WWWWWWWWWWL\", এটি উভয় সিস্টেমের অধীনে খেলোয়াড়ের ১০-১ জয়ে একটি সম্পূর্ণ গেম উপস্থাপন করে।\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- যদি points = \"WWLWWLWWLWWLWE\", এটি ১১-পয়েন্ট সিস্টেমের অধীনে দুটি সম্পূর্ণ গেম এবং একটি চলমান গেম উপস্থাপন করে, যার স্কোর যথাক্রমে ২-১, ২-১, এবং ১-১। ২১-পয়েন্ট সিস্টেমের অধীনে, এটি একটি একক গেম উপস্থাপন করে যার স্কোর ৬-৩।\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- যদি points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", এটি উভয় সিস্টেমের অধীনে একাধিক গেম উপস্থাপন করে, যেখানে শেষ গেমটি অসমাপ্ত। ১১-পয়েন্ট সিস্টেমের স্কোর ৪-৬, ৫-৫, এবং ১-০, যখন ২১-পয়েন্ট সিস্টেমের স্কোর ১৩-১৬ এবং ২-১।\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "bg": "Изчисляване на резултата от серия пинг-понг игри на базата на предоставената точкова система.\n\nТази функция приема желаната точкова система (или 11, или 21 точки) и низ, представляващ последователността от точки, спечелени от играча ('W') и противника ('L'). Функцията обработва низа и връща списък с резултати от игрите, форматирани като \"резултат_на_играча:резултат_на_противника\".\n\nИграта се счита за завършена, когато един играч достигне изисквания брой точки на системата (11 или 21) с поне 2 точки преднина. Ако последователността от точки завършва в средата на игра, текущият резултат на тази игра също се включва в изхода.\n\nАргументи:\n- system (int): Броят точки, необходими за спечелване на игра (или 11, или 21).\n- points (str): Низ от символи 'W' и 'L', обозначаващи точките, спечелени от играча и противника.\n\nВръща:\n- list: Списък от низове, представляващи резултата от всяка игра.\n\nСлучаи:\n- Ако points = \"WWWWWWWWWWL\", това представлява една завършена игра с победа на играча 10-1 при двете системи.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Ако points = \"WWLWWLWWLWWLWE\", това представлява две завършени игри и една игра в процес при системата с 11 точки, с резултати 2-1, 2-1 и 1-1 съответно. При системата с 21 точки, това представлява една игра с резултат 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Ако points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", това представлява множество игри при двете системи, като последната игра е незавършена. Системата с 11 точки има резултати 4-6, 5-5 и 1-0, докато системата с 21 точки има резултати 13-16 и 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "zh": "计算一系列乒乓球比赛的得分，基于提供的计分系统。\n\n此函数接收所需的计分系统（11分或21分）和一个字符串，表示玩家（'W'）和对手（'L'）赢得的分数序列。函数处理该字符串并返回一个游戏得分列表，格式为 \"player_score:opponent_score\"。\n\n当一名玩家达到系统要求的分数（11或21分）且至少领先2分时，比赛被视为结束。如果分数序列在比赛中途结束，该场比赛的当前得分也会包含在输出中。\n\n参数:\n- system (int): 赢得一场比赛所需的分数（11或21）。\n- points (str): 一个由 'W' 和 'L' 字符组成的字符串，表示玩家和对手赢得的分数。\n\n返回:\n- list: 一个字符串列表，表示每场比赛的得分。\n\n案例:\n- 如果 points = \"WWWWWWWWWWL\"，它表示在两种系统下玩家以10-1赢得一场完整比赛。\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- 如果 points = \"WWLWWLWWLWWLWE\"，在11分制下，它表示两场完整比赛和一场进行中的比赛，得分分别为2-1、2-1和1-1。在21分制下，它表示一场比赛，得分为6-3。\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- 如果 points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"，它表示在两种系统下的多场比赛，最后一场未完成。11分制的得分为4-6、5-5和1-0，而21分制的得分为13-16和2-1。\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "fr": "Calculer le score d'une série de jeux de ping-pong basé sur le système de score fourni.\n\nCette fonction prend en entrée le système de score souhaité (soit 11 ou 21 points) et une chaîne\nreprésentant la séquence de points gagnés par le joueur ('W') et l'adversaire ('L').\nLa fonction traite la chaîne et renvoie une liste de scores de jeu formatés comme \"score_joueur:score_adversaire\".\n\nLe jeu est considéré comme terminé lorsqu'un joueur atteint le nombre de points requis par le système\n(11 ou 21) avec au moins une avance de 2 points. Si la séquence de points se termine au milieu d'un jeu,\nle score actuel de ce jeu est également inclus dans le résultat.\n\nArgs:\n- system (int): Le nombre de points requis pour gagner un jeu (soit 11 ou 21).\n- points (str): Une chaîne de caractères 'W' et 'L' indiquant les points gagnés par le joueur et l'adversaire.\n\nReturns:\n- list: Une liste de chaînes représentant le score de chaque jeu.\n\nCas:\n- Si points = \"WWWWWWWWWWL\", cela représente un jeu complet avec le joueur gagnant 10-1 sous les deux systèmes.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Si points = \"WWLWWLWWLWWLWE\", cela représente deux jeux complets et un jeu en cours sous le système de 11 points,\navec des scores de 2-1, 2-1, et 1-1 respectivement. Sous le système de 21 points, cela représente un seul jeu avec un score de 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Si points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", cela représente plusieurs jeux sous les deux systèmes, avec le dernier jeu inachevé.\nLe système de 11 points a des scores de 4-6, 5-5, et 1-0, tandis que le système de 21 points a des scores de 13-16 et 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "de": "Berechne die Punktzahl einer Serie von Ping-Pong-Spielen basierend auf dem angegebenen Punktesystem.\n\nDiese Funktion nimmt das gewünschte Punktesystem (entweder 11 oder 21 Punkte) und einen String entgegen,\nder die Sequenz der vom Spieler ('W') und vom Gegner ('L') gewonnenen Punkte darstellt.\nDie Funktion verarbeitet den String und gibt eine Liste von Spielständen im Format \"spieler_punkte:gegner_punkte\" zurück.\n\nDas Spiel gilt als beendet, wenn ein Spieler die erforderliche Punktzahl des Systems erreicht\n(11 oder 21) mit mindestens einem 2-Punkte-Vorsprung. Wenn die Punktesequenz mitten in einem Spiel endet,\nwird der aktuelle Spielstand dieses Spiels ebenfalls in der Ausgabe enthalten.\n\nArgs:\n- system (int): Die Anzahl der Punkte, die erforderlich sind, um ein Spiel zu gewinnen (entweder 11 oder 21).\n- points (str): Ein String aus 'W'- und 'L'-Zeichen, die die vom Spieler und Gegner gewonnenen Punkte anzeigen.\n\nReturns:\n- list: Eine Liste von Strings, die den Spielstand jedes Spiels darstellen.\n\nFälle:\n- Wenn points = \"WWWWWWWWWWL\", stellt es ein vollständiges Spiel dar, bei dem der Spieler mit 10-1 in beiden Systemen gewinnt.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Wenn points = \"WWLWWLWWLWWLWE\", stellt es zwei vollständige Spiele und ein laufendes Spiel im 11-Punkte-System dar,\nmit den Spielständen 2-1, 2-1 und 1-1. Im 21-Punkte-System stellt es ein einzelnes Spiel mit einem Spielstand von 6-3 dar.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Wenn points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", stellt es mehrere Spiele in beiden Systemen dar, wobei das letzte Spiel unvollständig ist.\nDas 11-Punkte-System hat die Spielstände 4-6, 5-5 und 1-0, während das 21-Punkte-System die Spielstände 13-16 und 2-1 hat.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "ha": "Ƙididdige maki na jerin wasannin ping-pong bisa tsarin maki da aka bayar.\n\nWannan aikin yana karɓar tsarin maki da ake so (ko dai maki 11 ko 21) da kuma wani kirtani\nda ke wakiltar jerin maki da ɗan wasa ('W') da abokin hamayya ('L') suka ci.\nAikin yana sarrafa kirtanin kuma yana mayar da jerin maki na wasanni da aka tsara kamar \"maki_ɗan_wasa:maki_abokin_hamayya\".\n\nAna ɗaukar wasan ya ƙare idan ɗaya daga cikin 'yan wasan ya kai adadin maki da ake buƙata\n(11 ko 21) tare da tazarar maki 2 a kalla. Idan jerin maki ya ƙare a tsakiyar wasa,\nana kuma haɗa maki na yanzu na wannan wasan a cikin sakamakon.\n\nArgs:\n- system (int): Adadin maki da ake buƙata don cin nasara a wasa (ko dai 11 ko 21).\n- points (str): Wani kirtani na haruffan 'W' da 'L' da ke nuna maki da ɗan wasa da abokin hamayya suka ci.\n\nReturns:\n- list: Jerin kirtani da ke wakiltar maki na kowane wasa.\n\nMisalai:\n- Idan points = \"WWWWWWWWWWL\", yana wakiltar wasa guda ɗaya da ɗan wasa ya ci 10-1 a ƙarƙashin duka tsarin.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Idan points = \"WWLWWLWWLWWLWE\", yana wakiltar wasanni guda biyu da wasa ɗaya da ba a gama ba a ƙarƙashin tsarin maki 11,\ntare da maki 2-1, 2-1, da 1-1 bi da bi. A ƙarƙashin tsarin maki 21, yana wakiltar wasa ɗaya da maki 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Idan points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", yana wakiltar wasanni da yawa a ƙarƙashin duka tsarin, tare da wasan ƙarshe da ba a gama ba.\nTsarin maki 11 yana da maki 4-6, 5-5, da 1-0, yayin da tsarin maki 21 yana da maki 13-16 da 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "hi": "पिंग-पोंग खेलों की एक श्रृंखला का स्कोर प्रदान की गई स्कोरिंग प्रणाली के आधार पर गणना करें।\n\nयह फ़ंक्शन वांछित स्कोरिंग प्रणाली (या तो 11 या 21 अंक) और एक स्ट्रिंग को लेता है जो खिलाड़ी ('W') और प्रतिद्वंद्वी ('L') द्वारा जीते गए अंकों के अनुक्रम का प्रतिनिधित्व करती है। फ़ंक्शन स्ट्रिंग को प्रोसेस करता है और गेम स्कोर की एक सूची को \"player_score:opponent_score\" के रूप में स्वरूपित करके लौटाता है।\n\nखेल को समाप्त माना जाता है जब एक खिलाड़ी प्रणाली द्वारा आवश्यक अंकों की संख्या (11 या 21) तक कम से कम 2 अंकों की बढ़त के साथ पहुँच जाता है। यदि अंकों का अनुक्रम खेल के मध्य में समाप्त होता है, तो उस खेल का वर्तमान स्कोर भी आउटपुट में शामिल होता है।\n\nआर्ग्स:\n- system (int): एक खेल जीतने के लिए आवश्यक अंकों की संख्या (या तो 11 या 21)।\n- points (str): 'W' और 'L' वर्णों की एक स्ट्रिंग जो खिलाड़ी और प्रतिद्वंद्वी द्वारा जीते गए अंकों को दर्शाती है।\n\nरिटर्न्स:\n- list: प्रत्येक खेल के स्कोर का प्रतिनिधित्व करने वाली स्ट्रिंग्स की एक सूची।\n\nमामले:\n- यदि points = \"WWWWWWWWWWL\", तो यह एक पूर्ण खेल का प्रतिनिधित्व करता है जिसमें खिलाड़ी दोनों प्रणालियों के तहत 10-1 से जीतता है।\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- यदि points = \"WWLWWLWWLWWLWE\", तो यह 11-अंक प्रणाली के तहत दो पूर्ण खेलों और एक प्रगति पर खेल का प्रतिनिधित्व करता है, जिसमें स्कोर क्रमशः 2-1, 2-1, और 1-1 हैं। 21-अंक प्रणाली के तहत, यह एकल खेल का प्रतिनिधित्व करता है जिसका स्कोर 6-3 है।\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- यदि points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", तो यह दोनों प्रणालियों के तहत कई खेलों का प्रतिनिधित्व करता है, जिसमें अंतिम खेल अधूरा है। 11-अंक प्रणाली के तहत स्कोर 4-6, 5-5, और 1-0 हैं, जबकि 21-अंक प्रणाली के तहत स्कोर 13-16 और 2-1 हैं।\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "hu": "Számítsa ki egy sorozat pingpong játék eredményét a megadott pontozási rendszer alapján.\n\nEz a függvény a kívánt pontozási rendszert (vagy 11 vagy 21 pont) és egy karakterláncot vesz be,\namely a játékos ('W') és az ellenfél ('L') által nyert pontok sorozatát ábrázolja.\nA függvény feldolgozza a karakterláncot, és visszaad egy listát a játék eredményeiről, \"player_score:opponent_score\" formátumban.\n\nA játék akkor tekinthető befejezettnek, amikor az egyik játékos eléri a rendszer által megkövetelt pontszámot\n(11 vagy 21) legalább 2 pontos előnnyel. Ha a pontok sorozata egy játék közepén ér véget,\nakkor annak a játéknak az aktuális eredménye is szerepel a kimenetben.\n\nArgs:\n- system (int): A játék megnyeréséhez szükséges pontok száma (vagy 11 vagy 21).\n- points (str): 'W' és 'L' karakterekből álló karakterlánc, amely a játékos és az ellenfél által nyert pontokat jelöli.\n\nReturns:\n- list: A játékok eredményeit ábrázoló karakterláncok listája.\n\nEsetek:\n- Ha points = \"WWWWWWWWWWL\", akkor ez egy teljes játékot jelent, ahol a játékos 10-1-re nyer mindkét rendszerben.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Ha points = \"WWLWWLWWLWWLWE\", akkor ez két teljes játékot és egy folyamatban lévő játékot jelent a 11 pontos rendszerben,\n2-1, 2-1 és 1-1 eredményekkel. A 21 pontos rendszerben ez egyetlen játékot jelent 6-3 eredménnyel.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Ha points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", akkor ez több játékot jelent mindkét rendszerben, az utolsó játék befejezetlen.\nA 11 pontos rendszerben az eredmények 4-6, 5-5 és 1-0, míg a 21 pontos rendszerben 13-16 és 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "es": "Calcular la puntuación de una serie de juegos de ping-pong según el sistema de puntuación proporcionado.\n\nEsta función toma el sistema de puntuación deseado (ya sea 11 o 21 puntos) y una cadena\nque representa la secuencia de puntos ganados por el jugador ('W') y el oponente ('L').\nLa función procesa la cadena y devuelve una lista de puntuaciones de juegos formateadas como \"puntuación_jugador:puntuación_oponente\".\n\nEl juego se considera terminado cuando un jugador alcanza el número de puntos requerido por el sistema\n(11 o 21) con al menos una ventaja de 2 puntos. Si la secuencia de puntos termina en medio de un juego,\nla puntuación actual de ese juego también se incluye en la salida.\n\nArgumentos:\n- system (int): El número de puntos requeridos para ganar un juego (ya sea 11 o 21).\n- points (str): Una cadena de caracteres 'W' y 'L' que denotan puntos ganados por el jugador y el oponente.\n\nDevuelve:\n- list: Una lista de cadenas que representan la puntuación de cada juego.\n\nCasos:\n- Si points = \"WWWWWWWWWWL\", representa un juego completo con el jugador ganando 10-1 bajo ambos sistemas.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Si points = \"WWLWWLWWLWWLWE\", representa dos juegos completos y uno en progreso bajo el sistema de 11 puntos,\ncon puntuaciones de 2-1, 2-1 y 1-1 respectivamente. Bajo el sistema de 21 puntos, representa un solo juego con una puntuación de 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Si points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", representa múltiples juegos bajo ambos sistemas, con el último juego sin terminar.\nEl sistema de 11 puntos tiene puntuaciones de 4-6, 5-5 y 1-0, mientras que el sistema de 21 puntos tiene puntuaciones de 13-16 y 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "arb": "احسب النتيجة لسلسلة من مباريات كرة الطاولة بناءً على نظام التسجيل المقدم.\n\nتأخذ هذه الدالة نظام التسجيل المطلوب (إما 11 أو 21 نقطة) وسلسلة تمثل تسلسل النقاط التي فاز بها اللاعب ('W') والمنافس ('L'). تقوم الدالة بمعالجة السلسلة وتعيد قائمة بنتائج المباريات بتنسيق \"player_score:opponent_score\".\n\nتعتبر اللعبة منتهية عندما يصل أحد اللاعبين إلى العدد المطلوب من النقاط في النظام (11 أو 21) مع تقدم لا يقل عن نقطتين. إذا انتهى تسلسل النقاط في منتصف اللعبة، يتم تضمين النتيجة الحالية لتلك اللعبة في النتيجة النهائية.\n\nيعيدالحجج:\n- system (int): عدد النقاط المطلوبة للفوز في اللعبة (إما 11 أو 21).\n- points (str): سلسلة من الأحرف 'W' و 'L' تشير إلى النقاط التي فاز بها اللاعب والمنافس.\n\nيعيد:\n- list: قائمة من السلاسل النصية التي تمثل نتيجة كل لعبة.\n\nCases:\n- إذا كانت النقاط = \"WWWWWWWWWWL\"، فإنها تمثل لعبة كاملة واحدة بفوز اللاعب 10-1 في كلا النظامين.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- إذا كانت النقاط = \"WWLWWLWWLWWLWE\"، فإنها تمثل لعبتين كاملتين ولعبة واحدة قيد التقدم تحت نظام 11 نقطة، مع النتائج 2-1، 2-1، و 1-1 على التوالي. تحت نظام 21 نقطة، تمثل لعبة واحدة بنتيجة 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- إذا كانت النقاط = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"، فإنها تمثل عدة مباريات تحت كلا النظامين، مع انتهاء اللعبة الأخيرة غير مكتملة. نظام 11 نقطة لديه نتائج 4-6، 5-5، و 1-0، بينما نظام 21 نقطة لديه نتائج 13-16 و 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "sw": "Hesabu alama za mfululizo wa michezo ya ping-pong kulingana na mfumo wa alama uliotolewa.\n\nKazi hii inachukua mfumo wa alama unaotakiwa (ama pointi 11 au 21) na kamba\ninayowakilisha mfululizo wa pointi zilizoshindwa na mchezaji ('W') na mpinzani ('L').\nKazi hii inachakata kamba na kurudisha orodha ya alama za mchezo zilizopangwa kama \"alama_ya_mchezaji:alama_ya_mpinzani\".\n\nMchezo unachukuliwa kuwa umemalizika wakati mchezaji mmoja anafikia idadi ya pointi inayohitajika na mfumo\n(11 au 21) akiwa na uongozi wa angalau pointi 2. Ikiwa mfululizo wa pointi unamalizika katikati ya mchezo,\nalama ya sasa ya mchezo huo pia inajumuishwa kwenye matokeo.\n\nHoja:\n- system (int): Idadi ya pointi zinazohitajika kushinda mchezo (ama 11 au 21).\n- points (str): Kamba ya herufi 'W' na 'L' zinazowakilisha pointi zilizoshindwa na mchezaji na mpinzani.\n\nInarejesha:\n- list: Orodha ya kamba zinazowakilisha alama za kila mchezo.\n\nCases:\n- Ikiwa points = \"WWWWWWWWWWL\", inawakilisha mchezo mmoja kamili na mchezaji akishinda 10-1 chini ya mifumo yote miwili.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Ikiwa points = \"WWLWWLWWLWWLWE\", inawakilisha michezo miwili kamili na mmoja unaoendelea chini ya mfumo wa pointi 11,\nna alama 2-1, 2-1, na 1-1 mtawalia. Chini ya mfumo wa pointi 21, inawakilisha mchezo mmoja na alama ya 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Ikiwa points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", inawakilisha michezo mingi chini ya mifumo yote miwili, na mchezo wa mwisho haujakamilika.\nMfumo wa pointi 11 una alama 4-6, 5-5, na 1-0, wakati mfumo wa pointi 21 una alama 13-16 na 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "tr": "Bir dizi masa tenisi oyununun puanını verilen puanlama sistemine göre hesaplayın.\n\nBu fonksiyon, istenen puanlama sistemini (ya 11 ya da 21 puan) ve oyuncunun ('W') ve rakibin ('L') kazandığı puanların dizisini temsil eden bir dizeyi alır. Fonksiyon, diziyi işler ve \"oyuncu_puanı:rakip_puanı\" formatında oyun puanlarının bir listesini döndürür.\n\nBir oyuncu, sistemin gerektirdiği puan sayısına (11 veya 21) en az 2 puan farkla ulaştığında oyun bitmiş sayılır. Eğer puan dizisi bir oyunun ortasında sona ererse, o oyunun mevcut puanı da çıktıya dahil edilir.\n\nArgümanlar:\n- system (int): Bir oyunu kazanmak için gereken puan sayısı (ya 11 ya da 21).\n- points (str): Oyuncu ve rakibin kazandığı puanları belirten 'W' ve 'L' karakterlerinden oluşan bir dize.\n\nDöndürür:\n- list: Her oyunun puanını temsil eden dizelerin bir listesi.\n\nDurumlar:\n- Eğer points = \"WWWWWWWWWWL\" ise, bu, her iki sistemde de oyuncunun 10-1 kazandığı bir tam oyunu temsil eder.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Eğer points = \"WWLWWLWWLWWLWE\" ise, bu, 11 puanlık sistemde iki tam oyun ve bir devam eden oyunu, sırasıyla 2-1, 2-1 ve 1-1 puanlarıyla temsil eder. 21 puanlık sistemde ise, 6-3 puanıyla tek bir oyunu temsil eder.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Eğer points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\" ise, bu, her iki sistemde de birden fazla oyunu ve son oyunun tamamlanmamış olduğunu temsil eder. 11 puanlık sistemde puanlar 4-6, 5-5 ve 1-0 iken, 21 puanlık sistemde puanlar 13-16 ve 2-1'dir.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "vi": "Tính điểm của một loạt các trò chơi bóng bàn dựa trên hệ thống tính điểm được cung cấp.\n\nHàm này nhận vào hệ thống tính điểm mong muốn (hoặc 11 hoặc 21 điểm) và một chuỗi\nđại diện cho chuỗi điểm mà người chơi ('W') và đối thủ ('L') giành được.\nHàm xử lý chuỗi và trả về một danh sách các điểm số trò chơi được định dạng dưới dạng \"điểm_người_chơi:điểm_đối_thủ\".\n\nTrò chơi được coi là kết thúc khi một người chơi đạt đến số điểm yêu cầu của hệ thống\n(11 hoặc 21) với ít nhất cách biệt 2 điểm. Nếu chuỗi điểm kết thúc giữa chừng một trò chơi,\nđiểm số hiện tại của trò chơi đó cũng được bao gồm trong đầu ra.\n\nTham số:\n- system (int): Số điểm cần thiết để thắng một trò chơi (hoặc 11 hoặc 21).\n- points (str): Một chuỗi các ký tự 'W' và 'L' biểu thị điểm mà người chơi và đối thủ giành được.\n\nTrả về:\n- list: Một danh sách các chuỗi đại diện cho điểm số của mỗi trò chơi.\n\nTrường hợp:\n- Nếu points = \"WWWWWWWWWWL\", nó đại diện cho một trò chơi hoàn chỉnh với người chơi thắng 10-1 dưới cả hai hệ thống.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Nếu points = \"WWLWWLWWLWWLWE\", nó đại diện cho hai trò chơi hoàn chỉnh và một trò chơi đang diễn ra dưới hệ thống 11 điểm,\nvới điểm số lần lượt là 2-1, 2-1, và 1-1. Dưới hệ thống 21 điểm, nó đại diện cho một trò chơi với điểm số 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Nếu points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", nó đại diện cho nhiều trò chơi dưới cả hai hệ thống, với trò chơi cuối cùng chưa hoàn thành.\nHệ thống 11 điểm có điểm số 4-6, 5-5, và 1-0, trong khi hệ thống 21 điểm có điểm số 13-16 và 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "id": "Hitung skor dari serangkaian permainan ping-pong berdasarkan sistem penilaian yang diberikan.\n\nFungsi ini menerima sistem penilaian yang diinginkan (baik 11 atau 21 poin) dan sebuah string\nyang mewakili urutan poin yang dimenangkan oleh pemain ('W') dan lawan ('L').\nFungsi ini memproses string dan mengembalikan daftar skor permainan yang diformat sebagai \"skor_pemain:skor_lawan\".\n\nPermainan dianggap selesai ketika salah satu pemain mencapai jumlah poin yang diperlukan oleh sistem\n(11 atau 21) dengan keunggulan setidaknya 2 poin. Jika urutan poin berakhir di tengah permainan,\nskor permainan saat itu juga disertakan dalam output.\n\nArgs:\n- system (int): Jumlah poin yang diperlukan untuk memenangkan permainan (baik 11 atau 21).\n- points (str): Sebuah string dari karakter 'W' dan 'L' yang menunjukkan poin yang dimenangkan oleh pemain dan lawan.\n\nReturns:\n- list: Daftar string yang mewakili skor setiap permainan.\n\nKasus:\n- Jika points = \"WWWWWWWWWWL\", ini mewakili satu permainan lengkap dengan pemain menang 10-1 di bawah kedua sistem.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Jika points = \"WWLWWLWWLWWLWE\", ini mewakili dua permainan lengkap dan satu permainan yang sedang berlangsung di bawah sistem 11 poin,\ndengan skor 2-1, 2-1, dan 1-1 masing-masing. Di bawah sistem 21 poin, ini mewakili satu permainan dengan skor 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Jika points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", ini mewakili beberapa permainan di bawah kedua sistem, dengan permainan terakhir belum selesai.\nSistem 11 poin memiliki skor 4-6, 5-5, dan 1-0, sedangkan sistem 21 poin memiliki skor 13-16 dan 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "ja": "一連のピンポンゲームのスコアを、提供されたスコアリングシステムに基づいて計算します。\n\nこの関数は、希望するスコアリングシステム（11点または21点）と、プレイヤー（'W'）と対戦相手（'L'）が獲得したポイントのシーケンスを表す文字列を受け取ります。\n関数は文字列を処理し、\"player_score:opponent_score\"という形式でゲームのスコアのリストを返します。\n\nゲームは、プレイヤーのいずれかがシステムで要求されるポイント数（11または21）に少なくとも2ポイントのリードで到達したときに終了と見なされます。ポイントのシーケンスがゲームの途中で終了した場合、そのゲームの現在のスコアも出力に含まれます。\n\n引数:\n- system (int): ゲームに勝つために必要なポイント数（11または21のいずれか）。\n- points (str): プレイヤーと対戦相手が獲得したポイントを示す 'W' と 'L' の文字列。\n\n戻り値:\n- list: 各ゲームのスコアを表す文字列のリスト。\n\nケース:\n- もし points = \"WWWWWWWWWWL\" の場合、これはプレイヤーが両方のシステムで10-1で勝利する1つの完全なゲームを表します。\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- もし points = \"WWLWWLWWLWWLWE\" の場合、これは11点システムで2つの完全なゲームと1つの進行中のゲームを表し、それぞれのスコアは2-1、2-1、1-1です。21点システムでは、スコア6-3の1つのゲームを表します。\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- もし points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\" の場合、これは両方のシステムで複数のゲームを表し、最後のゲームは未完成です。\n11点システムでは、スコアは4-6、5-5、1-0であり、21点システムでは、スコアは13-16、2-1です。\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "ko": "제공된 점수 시스템에 따라 일련의 탁구 게임 점수를 계산합니다.\n\n이 함수는 원하는 점수 시스템(11점 또는 21점)과 플레이어('W')와 상대방('L')이 획득한 점수의 순서를 나타내는 문자열을 입력으로 받습니다. 함수는 문자열을 처리하고 \"player_score:opponent_score\" 형식으로 게임 점수 목록을 반환합니다.\n\n게임은 한 플레이어가 시스템의 요구 점수(11 또는 21)에 최소 2점 차로 도달하면 종료된 것으로 간주됩니다. 점수의 순서가 게임 중간에 끝나면 해당 게임의 현재 점수도 출력에 포함됩니다.\n\nArgs:\n- system (int): 게임에서 승리하기 위해 필요한 점수 (11 또는 21).\n- points (str): 플레이어와 상대방이 획득한 점수를 나타내는 'W'와 'L' 문자로 구성된 문자열.\n\nReturns:\n- list: 각 게임의 점수를 나타내는 문자열 목록.\n\nCases:\n- 만약 points = \"WWWWWWWWWWL\"이라면, 이는 두 시스템 모두에서 플레이어가 10-1로 승리한 하나의 완전한 게임을 나타냅니다.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- 만약 points = \"WWLWWLWWLWWLWE\"이라면, 이는 11점 시스템에서 두 개의 완전한 게임과 하나의 진행 중인 게임을 나타내며, 각각의 점수는 2-1, 2-1, 1-1입니다. 21점 시스템에서는 6-3의 점수를 가진 단일 게임을 나타냅니다.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- 만약 points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"이라면, 이는 두 시스템 모두에서 여러 게임을 나타내며, 마지막 게임은 미완성입니다. 11점 시스템에서는 4-6, 5-5, 1-0의 점수를 가지며, 21점 시스템에서는 13-16, 2-1의 점수를 가집니다.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "ml": "പിംഗ്-പോംഗ് കളികളുടെ ഒരു പരമ്പരയുടെ സ്കോർ നൽകിയ സ്കോറിംഗ് സിസ്റ്റം അടിസ്ഥാനമാക്കി കണക്കാക്കുക.\n\nഈ ഫംഗ്ഷൻ ആവശ്യമായ സ്കോറിംഗ് സിസ്റ്റം (11 അല്ലെങ്കിൽ 21 പോയിന്റുകൾ) കൂടാതെ കളിക്കാരൻ ('W')യും എതിരാളി ('L')യും നേടിയ പോയിന്റുകളുടെ ശ്രേണിയെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് എന്നിവ സ്വീകരിക്കുന്നു. \nഫംഗ്ഷൻ സ്ട്രിംഗ് പ്രോസസ്സ് ചെയ്ത് \"player_score:opponent_score\" എന്ന ഫോർമാറ്റിൽ ഗെയിം സ്കോറുകളുടെ ഒരു പട്ടിക തിരികെ നൽകുന്നു.\n\nഒരു കളിക്കാരൻ സിസ്റ്റത്തിന്റെ ആവശ്യമായ പോയിന്റുകളുടെ എണ്ണം (11 അല്ലെങ്കിൽ 21) കുറഞ്ഞത് 2-പോയിന്റ് ലീഡോടെ എത്തുമ്പോൾ ഗെയിം പൂർത്തിയായതായി കണക്കാക്കുന്നു. \nപോയിന്റുകളുടെ ശ്രേണി ഒരു ഗെയിമിന്റെ നടുവിൽ അവസാനിക്കുന്നുവെങ്കിൽ, ആ ഗെയിമിന്റെ നിലവിലെ സ്കോർ ഔട്ട്പുട്ടിൽ ഉൾപ്പെടുന്നു.\n\nആർഗ്സ്:\n- system (int): ഒരു ഗെയിം ജയിക്കാൻ ആവശ്യമായ പോയിന്റുകളുടെ എണ്ണം (11 അല്ലെങ്കിൽ 21).\n- points (str): കളിക്കാരനും എതിരാളിയും നേടിയ പോയിന്റുകൾ സൂചിപ്പിക്കുന്ന 'W'യും 'L'യും ഉള്ള ഒരു സ്ട്രിംഗ്.\n\nറിട്ടേൺസ്:\n- list: ഓരോ ഗെയിമിന്റെയും സ്കോർ പ്രതിനിധീകരിക്കുന്ന സ്ട്രിംഗുകളുടെ ഒരു പട്ടിക.\n\nകേസുകൾ:\n- If points = \"WWWWWWWWWWL\", അത് കളിക്കാരൻ 10-1 എന്ന സ്കോറിൽ ഒരു പൂർണ്ണ ഗെയിം ജയിക്കുന്നതിനെ പ്രതിനിധീകരിക്കുന്നു, ഇരു സിസ്റ്റങ്ങളിലും.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- If points = \"WWLWWLWWLWWLWE\", അത് 11-പോയിന്റ് സിസ്റ്റത്തിൽ രണ്ട് പൂർണ്ണ ഗെയിമുകളും ഒരു പുരോഗമനത്തിലുള്ള ഗെയിമും, യഥാക്രമം 2-1, 2-1, 1-1 എന്ന സ്കോറുകളുമായി പ്രതിനിധീകരിക്കുന്നു. 21-പോയിന്റ് സിസ്റ്റത്തിൽ, അത് 6-3 എന്ന സ്കോറോടെ ഒരു ഗെയിമിനെ പ്രതിനിധീകരിക്കുന്നു.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", അത് ഇരു സിസ്റ്റങ്ങളിലും നിരവധി ഗെയിമുകളെ പ്രതിനിധീകരിക്കുന്നു, അവസാന ഗെയിം പൂർത്തിയാകാത്തതാണ്. 11-പോയിന്റ് സിസ്റ്റത്തിൽ 4-6, 5-5, 1-0 എന്ന സ്കോറുകളുണ്ട്, 21-പോയിന്റ് സിസ്റ്റത്തിൽ 13-16, 2-1 എന്ന സ്കോറുകളുണ്ട്.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "fa": "محاسبه امتیاز مجموعه‌ای از بازی‌های پینگ‌پنگ بر اساس سیستم امتیازدهی ارائه شده.\n\nاین تابع سیستم امتیازدهی مورد نظر (یا 11 یا 21 امتیاز) و یک رشته که توالی امتیازات برنده‌شده توسط بازیکن ('W') و حریف ('L') را نشان می‌دهد، دریافت می‌کند.\nتابع رشته را پردازش کرده و لیستی از امتیازات بازی‌ها را به صورت \"player_score:opponent_score\" برمی‌گرداند.\n\nبازی زمانی به پایان می‌رسد که یک بازیکن به تعداد امتیازات مورد نیاز سیستم (11 یا 21) با حداقل 2 امتیاز برتری برسد. اگر توالی امتیازات در وسط یک بازی به پایان برسد، امتیاز فعلی آن بازی نیز در خروجی گنجانده می‌شود.\n\nآرگومان‌ها:\n- system (int): تعداد امتیازات مورد نیاز برای برنده شدن در یک بازی (یا 11 یا 21).\n- points (str): رشته‌ای از کاراکترهای 'W' و 'L' که امتیازات برنده‌شده توسط بازیکن و حریف را نشان می‌دهد.\n\nبازگشت:\n- list: لیستی از رشته‌ها که امتیاز هر بازی را نشان می‌دهد.\n\nموارد:\n- اگر points = \"WWWWWWWWWWL\"، یک بازی کامل را نشان می‌دهد که بازیکن با امتیاز 10-1 در هر دو سیستم برنده می‌شود.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- اگر points = \"WWLWWLWWLWWLWE\"، دو بازی کامل و یک بازی در حال پیشرفت را تحت سیستم 11 امتیازی نشان می‌دهد،\nبا امتیازات 2-1، 2-1، و 1-1 به ترتیب. تحت سیستم 21 امتیازی، یک بازی با امتیاز 6-3 را نشان می‌دهد.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- اگر points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"، چندین بازی تحت هر دو سیستم را نشان می‌دهد، با بازی آخر ناتمام.\nسیستم 11 امتیازی دارای امتیازات 4-6، 5-5، و 1-0 است، در حالی که سیستم 21 امتیازی دارای امتیازات 13-16 و 2-1 است.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]"}}
{"task_id": "Python/34", "prompt": {"en": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n    - For n=0, the function should return 1, since C(0) = 1.\n      catalan_number(0) -> 1\n\n    - For n=3, the function should return 5, since C(3) = 5.\n      catalan_number(3) -> 5\n\n    - For n=5, the function should return 42, since C(5) = 42.\n      catalan_number(5) -> 42\n\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    \"\"\"", "sq": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Llogarit numrin e n-të të Catalan-it.\n\n    Funksioni llogarit numrin e n-të të Catalan-it duke përdorur programimin dinamik. Numrat e Catalan-it janë një sekuencë \n    numrash natyrorë që kanë shumë aplikime në matematikën kombinatorike, duke përfshirë numërimin e llojeve të caktuara të \n    shtigjeve të rrjetit, numrin e shprehjeve që përmbajnë n çifte kllapash të cilat janë të përputhura saktësisht, numrin e \n    mënyrave të ndryshme që n+1 faktorë mund të jenë plotësisht të kllapëzuar, dhe më shumë.\n\n    Argumentet:\n    - n (int): Pozicioni në sekuencën e numrave të Catalan-it për të llogaritur (duhet të jetë jo-negativ).\n\n    Kthen:\n    - int: Numri i n-të i Catalan-it.\n\n    Raste:\n    - Për n=0, funksioni duhet të kthejë 1, pasi C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Për n=3, funksioni duhet të kthejë 5, pasi C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Për n=5, funksioni duhet të kthejë 42, pasi C(5) = 42.\n      catalan_number(5) -> 42\n\n    Shënim:\n    Llogaritja bazohet në formulën rekursive:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ku C(0) është 1.\n    \"\"\"", "hy": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Հաշվել n-րդ Կատալանի թիվը։\n\n    Ֆունկցիան հաշվում է n-րդ Կատալանի թիվը դինամիկ ծրագրավորման միջոցով։ Կատալանի թվերը բնական թվերի հաջորդականություն են, \n    որոնք ունեն բազմաթիվ կիրառություններ կոմբինատորական մաթեմատիկայում, ներառյալ որոշակի տեսակի ցանցային ուղիների հաշվարկը, \n    n զույգ փակագծեր պարունակող արտահայտությունների քանակը, որոնք ճիշտ են համընկնում, n+1 գործոնների ամբողջական փակագծման \n    տարբեր եղանակների քանակը և ավելին։\n\n    Պարամետրեր:\n    - n (int): Կատալանի թվերի հաջորդականության այն դիրքը, որը պետք է հաշվել (պետք է լինի ոչ բացասական)։\n\n    Վերադարձնում է:\n    - int: n-րդ Կատալանի թիվը։\n\n    Դեպքեր:\n    - n=0-ի համար ֆունկցիան պետք է վերադարձնի 1, քանի որ C(0) = 1:\n      catalan_number(0) -> 1\n\n    - n=3-ի համար ֆունկցիան պետք է վերադարձնի 5, քանի որ C(3) = 5:\n      catalan_number(3) -> 5\n\n    - n=5-ի համար ֆունկցիան պետք է վերադարձնի 42, քանի որ C(5) = 42:\n      catalan_number(5) -> 42\n\n    Նշում:\n    Հաշվարկը հիմնված է ռեկուրսիվ բանաձևի վրա:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    որտեղ C(0) հավասար է 1:\n    \"\"\"", "bn": "def catalan_number(n: int) -> int:\n    \"\"\"\n    nth ক্যাটালান সংখ্যা গণনা করুন।\n\n    ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে nth ক্যাটালান সংখ্যা গণনা করে। ক্যাটালান সংখ্যা হল প্রাকৃতিক সংখ্যার একটি ক্রম \n    যাদের সমাবেশিক গণিতে অনেক প্রয়োগ রয়েছে, যার মধ্যে নির্দিষ্ট ধরনের ল্যাটিস পথের গণনা, n জোড়া বন্ধনী ধারণকারী \n    অভিব্যক্তিগুলি যা সঠিকভাবে মেলানো হয়েছে, n+1 ফ্যাক্টরগুলি সম্পূর্ণভাবে বন্ধনীযুক্ত করার বিভিন্ন উপায়ের সংখ্যা, এবং আরও অনেক কিছু।\n\n    আর্গুমেন্ট:\n    - n (int): ক্যাটালান সংখ্যা ক্রমের অবস্থান যা গণনা করতে হবে (অবশ্যই অ-ঋণাত্মক হতে হবে)।\n\n    রিটার্নস:\n    - int: nth ক্যাটালান সংখ্যা।\n\n    কেস:\n    - n=0 এর জন্য, ফাংশনটি 1 রিটার্ন করা উচিত, যেহেতু C(0) = 1।\n      catalan_number(0) -> 1\n\n    - n=3 এর জন্য, ফাংশনটি 5 রিটার্ন করা উচিত, যেহেতু C(3) = 5।\n      catalan_number(3) -> 5\n\n    - n=5 এর জন্য, ফাংশনটি 42 রিটার্ন করা উচিত, যেহেতু C(5) = 42।\n      catalan_number(5) -> 42\n\n    নোট:\n    গণনাটি পুনরাবৃত্ত সূত্রের উপর ভিত্তি করে:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    যেখানে C(0) হল 1।\n    \"\"\"", "bg": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Изчисляване на n-тото число на Каталан.\n\n    Функцията изчислява n-тото число на Каталан, използвайки динамично програмиране. Числата на Каталан са поредица от \n    естествени числа, които имат много приложения в комбинаторната математика, включително броене на определени видове \n    решетъчни пътища, броя на изразите, съдържащи n двойки скоби, които са правилно съчетани, броя на различните начини, \n    по които n+1 фактора могат да бъдат напълно скобирани, и други.\n\n    Аргументи:\n    - n (int): Позицията в последователността на числата на Каталан, която да се изчисли (трябва да е неотрицателно).\n\n    Връща:\n    - int: n-тото число на Каталан.\n\n    Примери:\n    - За n=0, функцията трябва да върне 1, тъй като C(0) = 1.\n      catalan_number(0) -> 1\n\n    - За n=3, функцията трябва да върне 5, тъй като C(3) = 5.\n      catalan_number(3) -> 5\n\n    - За n=5, функцията трябва да върне 42, тъй като C(5) = 42.\n      catalan_number(5) -> 42\n\n    Забележка:\n    Изчислението се основава на рекурсивната формула:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    където C(0) е 1.\n    \"\"\"", "zh": "def catalan_number(n: int) -> int:\n    \"\"\"\n    计算第 n 个 Catalan 数。\n\n    该函数使用动态规划计算第 n 个 Catalan 数。Catalan 数是一系列自然数，在组合数学中有许多应用，包括计算某些类型的格路径、\n    包含 n 对括号的正确匹配表达式的数量、n+1 个因子可以完全括起来的不同方式的数量等。\n\n    参数:\n    - n (int): 要计算的 Catalan 数序列中的位置（必须是非负数）。\n\n    返回:\n    - int: 第 n 个 Catalan 数。\n\n    情况:\n    - 对于 n=0，函数应返回 1，因为 C(0) = 1。\n      catalan_number(0) -> 1\n\n    - 对于 n=3，函数应返回 5，因为 C(3) = 5。\n      catalan_number(3) -> 5\n\n    - 对于 n=5，函数应返回 42，因为 C(5) = 42。\n      catalan_number(5) -> 42\n\n    注意:\n    计算基于递归公式:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    其中 C(0) 是 1。\n    \"\"\"", "fr": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculer le nième nombre de Catalan.\n\n    La fonction calcule le nième nombre de Catalan en utilisant la programmation dynamique. Les nombres de Catalan sont une \n    séquence de nombres naturels qui ont de nombreuses applications en mathématiques combinatoires, y compris le comptage de \n    certains types de chemins de grille, le nombre d'expressions contenant n paires de parenthèses correctement appariées, \n    le nombre de façons différentes dont n+1 facteurs peuvent être complètement parenthésés, et plus encore.\n\n    Args:\n    - n (int): La position dans la séquence des nombres de Catalan à calculer (doit être non négative).\n\n    Returns:\n    - int: Le nième nombre de Catalan.\n\n    Cas:\n    - Pour n=0, la fonction doit retourner 1, puisque C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Pour n=3, la fonction doit retourner 5, puisque C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Pour n=5, la fonction doit retourner 42, puisque C(5) = 42.\n      catalan_number(5) -> 42\n\n    Remarque:\n    Le calcul est basé sur la formule récursive :\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    où C(0) est 1.\n    \"\"\"", "de": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Berechne die n-te Catalan-Zahl.\n\n    Die Funktion berechnet die n-te Catalan-Zahl unter Verwendung der dynamischen Programmierung. Catalan-Zahlen sind eine \n    Folge natürlicher Zahlen, die viele Anwendungen in der kombinatorischen Mathematik haben, einschließlich der Zählung \n    bestimmter Arten von Gitterpfaden, der Anzahl der Ausdrücke, die n korrekt gepaarte Klammern enthalten, der Anzahl der \n    verschiedenen Möglichkeiten, n+1 Faktoren vollständig zu klammern, und mehr.\n\n    Argumente:\n    - n (int): Die Position in der Catalan-Zahlenfolge, die berechnet werden soll (muss nicht-negativ sein).\n\n    Rückgabewert:\n    - int: Die n-te Catalan-Zahl.\n\n    Fälle:\n    - Für n=0 sollte die Funktion 1 zurückgeben, da C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Für n=3 sollte die Funktion 5 zurückgeben, da C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Für n=5 sollte die Funktion 42 zurückgeben, da C(5) = 42.\n      catalan_number(5) -> 42\n\n    Hinweis:\n    Die Berechnung basiert auf der rekursiven Formel:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    wobei C(0) gleich 1 ist.\n    \"\"\"", "ha": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Lissafa lambar Catalan ta n.\n\n    Aikin yana lissafin lambar Catalan ta n ta amfani da shirye-shiryen motsi. Lambobin Catalan suna jerin lambobin halitta \n    waɗanda ke da aikace-aikace da yawa a cikin lissafin haɗaka, ciki har da ƙididdigar wasu nau'ikan hanyoyin lattice, \n    adadin maganganun da ke ɗauke da nau'i-nau'i na ma'aurata waɗanda aka dace daidai, adadin hanyoyi daban-daban n+1 \n    abubuwa za a iya rarrabe su gaba ɗaya cikin ma'aurata, da ƙari.\n\n    Args:\n    - n (int): Matsayin a cikin jerin lambobin Catalan da za a lissafa (dole ne ya zama mara kyau).\n\n    Returns:\n    - int: Lambar Catalan ta n.\n\n    Cases:\n    - Ga n=0, aikin ya kamata ya dawo da 1, tun da C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Ga n=3, aikin ya kamata ya dawo da 5, tun da C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Ga n=5, aikin ya kamata ya dawo da 42, tun da C(5) = 42.\n      catalan_number(5) -> 42\n\n    Note:\n    Lissafin yana dogara ne akan tsarin maimaitawa:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    inda C(0) shine 1.\n    \"\"\"", "hi": "def catalan_number(n: int) -> int:\n    \"\"\"\n    nth कैटलन संख्या की गणना करें।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके nth कैटलन संख्या की गणना करता है। कैटलन संख्याएँ प्राकृतिक संख्याओं की एक अनुक्रम हैं \n    जिनका संयोजकीय गणित में कई अनुप्रयोग हैं, जिनमें कुछ प्रकार के जाली पथों की गणना, n जोड़ों वाले कोष्ठकों की संख्या जो सही ढंग से मेल खाते हैं, \n    n+1 कारकों को पूरी तरह से कोष्ठक में रखने के विभिन्न तरीकों की संख्या, और अधिक शामिल हैं।\n\n    तर्क:\n    - n (int): कैटलन संख्या अनुक्रम में गणना करने के लिए स्थिति (गैर-ऋणात्मक होनी चाहिए)।\n\n    लौटाता है:\n    - int: nth कैटलन संख्या।\n\n    मामले:\n    - n=0 के लिए, फ़ंक्शन को 1 लौटाना चाहिए, क्योंकि C(0) = 1।\n      catalan_number(0) -> 1\n\n    - n=3 के लिए, फ़ंक्शन को 5 लौटाना चाहिए, क्योंकि C(3) = 5।\n      catalan_number(3) -> 5\n\n    - n=5 के लिए, फ़ंक्शन को 42 लौटाना चाहिए, क्योंकि C(5) = 42।\n      catalan_number(5) -> 42\n\n    नोट:\n    गणना पुनरावर्ती सूत्र पर आधारित है:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    जहाँ C(0) 1 है।\n    \"\"\"", "hu": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Kiszámítja az n-edik Catalan-számot.\n\n    A függvény dinamikus programozás segítségével számítja ki az n-edik Catalan-számot. A Catalan-számok olyan természetes \n    számok sorozata, amelyeknek számos alkalmazása van a kombinatorikus matematikában, beleértve bizonyos típusú rácsos utak \n    számolását, az n pár zárójelet tartalmazó kifejezések számát, amelyek helyesen vannak párosítva, az n+1 tényező különböző \n    módon történő teljes zárójelezésének számát, és még sok más.\n\n    Argumentumok:\n    - n (int): A Catalan-szám sorozatban lévő pozíció, amelyet ki kell számítani (nem lehet negatív).\n\n    Visszatérési érték:\n    - int: Az n-edik Catalan-szám.\n\n    Esetek:\n    - Ha n=0, a függvénynek 1-et kell visszaadnia, mivel C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Ha n=3, a függvénynek 5-öt kell visszaadnia, mivel C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Ha n=5, a függvénynek 42-t kell visszaadnia, mivel C(5) = 42.\n      catalan_number(5) -> 42\n\n    Megjegyzés:\n    A számítás a rekurzív képleten alapul:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ahol C(0) értéke 1.\n    \"\"\"", "es": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calcular el enésimo número de Catalan.\n\n    La función calcula el enésimo número de Catalan utilizando programación dinámica. Los números de Catalan son una secuencia de números \n    naturales que tienen muchas aplicaciones en matemáticas combinatorias, incluyendo el conteo de ciertos tipos de caminos en una cuadrícula, \n    el número de expresiones que contienen n pares de paréntesis correctamente emparejados, el número de formas diferentes en que n+1 \n    factores pueden ser completamente parentizados, y más.\n\n    Argumentos:\n    - n (int): La posición en la secuencia de números de Catalan a calcular (debe ser no negativa).\n\n    Devuelve:\n    - int: El enésimo número de Catalan.\n\n    Casos:\n    - Para n=0, la función debe devolver 1, ya que C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Para n=3, la función debe devolver 5, ya que C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Para n=5, la función debe devolver 42, ya que C(5) = 42.\n      catalan_number(5) -> 42\n\n    Nota:\n    El cálculo se basa en la fórmula recursiva:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    donde C(0) es 1.\n    \"\"\"", "arb": "def catalan_number(n: int) -> int:\n    \"\"\"\n    حساب العدد النوني من كاتالان.\n\n    تقوم الدالة بحساب العدد النوني من كاتالان باستخدام البرمجة الديناميكية. أعداد كاتالان هي سلسلة من الأعداد الطبيعية \n    التي لها العديد من التطبيقات في الرياضيات التوافقية، بما في ذلك عد أنواع معينة من مسارات الشبكة، \n    عدد التعبيرات التي تحتوي على n من الأزواج من الأقواس المتطابقة بشكل صحيح، عدد الطرق المختلفة التي يمكن بها \n    تحويط n+1 من العوامل بالكامل، وأكثر من ذلك.\n\n    يعيدالحجج:\n    - n (int): الموضع في تسلسل أعداد كاتالان للحساب (يجب أن يكون غير سالب).\n\n    يعيد:\n    - int: العدد النوني من كاتالان.\n\n    حالات:\n    - بالنسبة لـ n=0، يجب أن تعيد الدالة 1، لأن C(0) = 1.\n      catalan_number(0) -> 1\n\n    - بالنسبة لـ n=3، يجب أن تعيد الدالة 5، لأن C(3) = 5.\n      catalan_number(3) -> 5\n\n    - بالنسبة لـ n=5، يجب أن تعيد الدالة 42، لأن C(5) = 42.\n      catalan_number(5) -> 42\n\n    ملاحظة:\n    يعتمد الحساب على الصيغة التكرارية:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    حيث C(0) هو 1.\n    \"\"\"", "sw": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Kuhesabu nambari ya Catalan ya n.\n\n    Kazi hii inahesabu nambari ya Catalan ya n kwa kutumia programu ya nguvu. Nambari za Catalan ni mlolongo wa nambari \n    asilia ambazo zina matumizi mengi katika hisabati ya mchanganyiko, ikiwa ni pamoja na kuhesabu aina fulani za njia za \n    gridi, idadi ya maneno yanayojumuisha jozi n za mabano ambayo yameunganishwa kwa usahihi, idadi ya njia tofauti ambazo \n    vipengele n+1 vinaweza kuwekwa mabano kabisa, na zaidi.\n\n    Hoja:\n    - n (int): Nafasi katika mlolongo wa nambari za Catalan ya kuhesabu (lazima iwe isiyo hasi).\n\n    Inarejesha:\n    - int: Nambari ya Catalan ya n.\n\n    Matukio:\n    - Kwa n=0, kazi inapaswa kurudisha 1, kwa kuwa C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Kwa n=3, kazi inapaswa kurudisha 5, kwa kuwa C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Kwa n=5, kazi inapaswa kurudisha 42, kwa kuwa C(5) = 42.\n      catalan_number(5) -> 42\n\n    Kumbuka:\n    Hesabu inategemea fomula ya kurudiarudia:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ambapo C(0) ni 1.\n    \"\"\"", "tr": "def catalan_number(n: int) -> int:\n    \"\"\"\n    n. Catalan sayısını hesapla.\n\n    Fonksiyon, dinamik programlama kullanarak n. Catalan sayısını hesaplar. Catalan sayıları, kombinatoryal matematikte birçok \n    uygulamaya sahip doğal sayıların bir dizisidir; belirli türdeki kafes yollarının sayılması, n çift parantez içeren ve doğru \n    eşleşmiş ifadelerin sayısı, n+1 faktörün tamamen parantezlenebileceği farklı yolların sayısı ve daha fazlası dahil.\n\n    Argümanlar:\n    - n (int): Hesaplanacak Catalan sayısı dizisindeki pozisyon (negatif olmamalıdır).\n\n    Dönüş:\n    - int: n. Catalan sayısı.\n\n    Durumlar:\n    - n=0 için, fonksiyon 1 döndürmelidir, çünkü C(0) = 1.\n      catalan_number(0) -> 1\n\n    - n=3 için, fonksiyon 5 döndürmelidir, çünkü C(3) = 5.\n      catalan_number(3) -> 5\n\n    - n=5 için, fonksiyon 42 döndürmelidir, çünkü C(5) = 42.\n      catalan_number(5) -> 42\n\n    Not:\n    Hesaplama, aşağıdaki özyinelemeli formüle dayanır:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    burada C(0) 1'dir.\n    \"\"\"", "vi": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Tính số Catalan thứ n.\n\n    Hàm này tính số Catalan thứ n sử dụng lập trình động. Các số Catalan là một dãy số tự nhiên có nhiều ứng dụng \n    trong toán học tổ hợp, bao gồm việc đếm số lượng các loại đường đi trên lưới nhất định, số lượng biểu thức chứa n cặp \n    dấu ngoặc được ghép đúng, số cách khác nhau mà n+1 thừa số có thể được ngoặc hoàn toàn, và nhiều hơn nữa.\n\n    Tham số:\n    - n (int): Vị trí trong dãy số Catalan cần tính (phải là số không âm).\n\n    Trả về:\n    - int: Số Catalan thứ n.\n\n    Trường hợp:\n    - Với n=0, hàm nên trả về 1, vì C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Với n=3, hàm nên trả về 5, vì C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Với n=5, hàm nên trả về 42, vì C(5) = 42.\n      catalan_number(5) -> 42\n\n    Lưu ý:\n    Việc tính toán dựa trên công thức đệ quy:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    trong đó C(0) là 1.\n    \"\"\"", "id": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Menghitung bilangan Catalan ke-n.\n\n    Fungsi ini menghitung bilangan Catalan ke-n menggunakan pemrograman dinamis. Bilangan Catalan adalah urutan bilangan \n    alami yang memiliki banyak aplikasi dalam matematika kombinatorial, termasuk penghitungan jenis jalur kisi tertentu, \n    jumlah ekspresi yang mengandung n pasang tanda kurung yang cocok dengan benar, jumlah cara berbeda di mana n+1 \n    faktor dapat sepenuhnya diberi tanda kurung, dan lainnya.\n\n    Argumen:\n    - n (int): Posisi dalam urutan bilangan Catalan yang akan dihitung (harus non-negatif).\n\n    Mengembalikan:\n    - int: Bilangan Catalan ke-n.\n\n    Kasus:\n    - Untuk n=0, fungsi harus mengembalikan 1, karena C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Untuk n=3, fungsi harus mengembalikan 5, karena C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Untuk n=5, fungsi harus mengembalikan 42, karena C(5) = 42.\n      catalan_number(5) -> 42\n\n    Catatan:\n    Perhitungan didasarkan pada rumus rekursif:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    di mana C(0) adalah 1.\n    \"\"\"", "ja": "def catalan_number(n: int) -> int:\n    \"\"\"\n    nthカタラン数を計算します。\n\n    この関数は動的プログラミングを使用してnthカタラン数を計算します。カタラン数は組合せ数学において多くの応用があり、特定の種類の格子経路の数、n組の括弧を含む式が正しくマッチしている数、n+1個の要素を完全に括弧で囲む異なる方法の数などがあります。\n\n    引数:\n    - n (int): 計算するカタラン数列の位置（非負でなければなりません）。\n\n    戻り値:\n    - int: nthカタラン数。\n\n    ケース:\n    - n=0の場合、関数は1を返すべきです。なぜならC(0) = 1だからです。\n      catalan_number(0) -> 1\n\n    - n=3の場合、関数は5を返すべきです。なぜならC(3) = 5だからです。\n      catalan_number(3) -> 5\n\n    - n=5の場合、関数は42を返すべきです。なぜならC(5) = 42だからです。\n      catalan_number(5) -> 42\n\n    注意:\n    計算は以下の再帰式に基づいています:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ここでC(0)は1です。\n    \"\"\"", "ko": "def catalan_number(n: int) -> int:\n    \"\"\"\n    n번째 카탈란 수를 계산합니다.\n\n    이 함수는 동적 프로그래밍을 사용하여 n번째 카탈란 수를 계산합니다. 카탈란 수는 조합 수학에서 여러 응용을 가지는 자연수의 \n    수열로, 특정 유형의 격자 경로의 개수, n 쌍의 괄호가 올바르게 짝지어진 표현식의 수, n+1 개의 요소가 완전히 괄호로 묶일 수 있는 \n    서로 다른 방법의 수 등을 포함합니다.\n\n    매개변수:\n    - n (int): 계산할 카탈란 수열의 위치 (음수가 아니어야 함).\n\n    반환값:\n    - int: n번째 카탈란 수.\n\n    사례:\n    - n=0일 때, 함수는 1을 반환해야 합니다. 왜냐하면 C(0) = 1이기 때문입니다.\n      catalan_number(0) -> 1\n\n    - n=3일 때, 함수는 5를 반환해야 합니다. 왜냐하면 C(3) = 5이기 때문입니다.\n      catalan_number(3) -> 5\n\n    - n=5일 때, 함수는 42를 반환해야 합니다. 왜냐하면 C(5) = 42이기 때문입니다.\n      catalan_number(5) -> 42\n\n    참고:\n    계산은 다음의 재귀 공식에 기반합니다:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    여기서 C(0)은 1입니다.\n    \"\"\"", "ml": "def catalan_number(n: int) -> int:\n    \"\"\"\n    n-ാം കാറ്റലാൻ സംഖ്യ കണക്കാക്കുക.\n\n    ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് n-ാം കാറ്റലാൻ സംഖ്യ കണക്കാക്കുന്നു. കാറ്റലാൻ സംഖ്യകൾ സംയോജക ഗണിതശാസ്ത്രത്തിൽ \n    നിരവധി പ്രയോഗങ്ങൾ ഉള്ള പ്രകൃത്യാ സംഖ്യകളുടെ ഒരു അനുക്രമമാണ്, ഇതിൽ ചില തരം ലാറ്റിസ് പാതകളുടെ എണ്ണവും, ശരിയായി \n    പൊരുത്തപ്പെടുന്ന n ജോഡി വൃത്തചിഹ്നങ്ങൾ അടങ്ങിയ വ്യാകരണങ്ങളുടെ എണ്ണവും, n+1 ഘടകങ്ങൾ പൂർണ്ണമായും വൃത്തചിഹ്നങ്ങൾ \n    ചേർക്കാനുള്ള വ്യത്യസ്ത മാർഗ്ഗങ്ങളുടെ എണ്ണവും ഉൾപ്പെടുന്നു.\n\n    Args:\n    - n (int): കാറ്റലാൻ സംഖ്യാ അനുക്രമത്തിൽ കണക്കാക്കേണ്ട സ്ഥാനം (അനുകൂലമായിരിക്കണം).\n\n    Returns:\n    - int: n-ാം കാറ്റലാൻ സംഖ്യ.\n\n    കേസുകൾ:\n    - n=0 ആണെങ്കിൽ, ഫംഗ്ഷൻ 1 മടക്കണം, കാരണം C(0) = 1.\n      catalan_number(0) -> 1\n\n    - n=3 ആണെങ്കിൽ, ഫംഗ്ഷൻ 5 മടക്കണം, കാരണം C(3) = 5.\n      catalan_number(3) -> 5\n\n    - n=5 ആണെങ്കിൽ, ഫംഗ്ഷൻ 42 മടക്കണം, കാരണം C(5) = 42.\n      catalan_number(5) -> 42\n\n    കുറിപ്പ്:\n    കണക്കുകൂട്ടൽ പുനരാവൃത്ത സൂത്രവാക്യത്തെ അടിസ്ഥാനമാക്കിയുള്ളതാണ്:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ഇവിടെ C(0) 1 ആണ്.\n    \"\"\"", "fa": "def catalan_number(n: int) -> int:\n    \"\"\"\n    محاسبه عدد کاتالان nام.\n\n    این تابع عدد کاتالان nام را با استفاده از برنامه‌ریزی پویا محاسبه می‌کند. اعداد کاتالان دنباله‌ای از اعداد طبیعی هستند که \n    کاربردهای زیادی در ریاضیات ترکیبیاتی دارند، از جمله شمارش انواع خاصی از مسیرهای شبکه، تعداد عبارات حاوی n جفت پرانتز که به \n    درستی جفت شده‌اند، تعداد روش‌های مختلفی که n+1 عامل می‌توانند به طور کامل پرانتزگذاری شوند، و موارد دیگر.\n\n    آرگومان‌ها:\n    - n (int): موقعیت در دنباله عدد کاتالان برای محاسبه (باید غیر منفی باشد).\n\n    بازگشت:\n    - int: عدد کاتالان nام.\n\n    موارد:\n    - برای n=0، تابع باید 1 را برگرداند، زیرا C(0) = 1.\n      catalan_number(0) -> 1\n\n    - برای n=3، تابع باید 5 را برگرداند، زیرا C(3) = 5.\n      catalan_number(3) -> 5\n\n    - برای n=5، تابع باید 42 را برگرداند، زیرا C(5) = 42.\n      catalan_number(5) -> 42\n\n    توجه:\n    محاسبه بر اساس فرمول بازگشتی است:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    که در آن C(0) برابر 1 است.\n    \"\"\""}, "canonical_solution": "    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]", "instruction": {"en": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।", "bg": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nBada takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa ba tare da wucewa haruffa 500 ba.", "hi": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nइस Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nPythonコードのdocstringを日本語で記述し、500文字以内で簡潔に説明してください。", "ko": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nപൈതൺ കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെയായി നൽകുക.", "fa": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nتوضیح مختصری به زبان طبیعی (docstring) از کد پایتون به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_catalan_number():\n    # Test case 1: The first Catalan number (base case)\n    n1 = 0\n    expected_output1 = 1\n    assert catalan_number(n1) == expected_output1, f\"Test case 1 failed: expected {expected_output1}, got {catalan_number(n1)}\"\n\n    # Test case 2: The third Catalan number\n    n2 = 3\n    expected_output2 = 5\n    assert catalan_number(n2) == expected_output2, f\"Test case 2 failed: expected {expected_output2}, got {catalan_number(n2)}\"\n\n    # Test case 3: The fifth Catalan number\n    n3 = 5\n    expected_output3 = 42\n    assert catalan_number(n3) == expected_output3, f\"Test case 3 failed: expected {expected_output3}, got {catalan_number(n3)}\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_catalan_number()", "entry_point": "catalan_number", "signature": "def catalan_number(n: int) -> int:", "docstring": {"en": "Calculate the nth Catalan number.\n\nThe function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural\nnumbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths,\nthe number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1\nfactors can be completely parenthesized, and more.\n\nArgs:\n- n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\nReturns:\n- int: The nth Catalan number.\n\nCases:\n- For n=0, the function should return 1, since C(0) = 1.\ncatalan_number(0) -> 1\n\n- For n=3, the function should return 5, since C(3) = 5.\ncatalan_number(3) -> 5\n\n- For n=5, the function should return 42, since C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nThe computation is based on the recursive formula:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nwhere C(0) is 1.", "sq": "Llogarit numrin e n-të të Catalan-it.\n\nFunksioni llogarit numrin e n-të të Catalan-it duke përdorur programimin dinamik. Numrat e Catalan-it janë një sekuencë e numrave natyrorë që kanë shumë aplikime në matematikën kombinatorike, duke përfshirë numërimin e llojeve të caktuara të shtigjeve të rrjetit, numrin e shprehjeve që përmbajnë n çifte kllapash të cilat janë të përputhura saktësisht, numrin e mënyrave të ndryshme që n+1 faktorë mund të përfshihen plotësisht në kllapa, dhe më shumë.\n\nArgumentet:\n- n (int): Pozicioni në sekuencën e numrave të Catalan-it për të llogaritur (duhet të jetë jo-negativ).\n\nKthen:\n- int: Numri i n-të i Catalan-it.\n\nRastet:\n- Për n=0, funksioni duhet të kthejë 1, pasi C(0) = 1.\ncatalan_number(0) -> 1\n\n- Për n=3, funksioni duhet të kthejë 5, pasi C(3) = 5.\ncatalan_number(3) -> 5\n\n- Për n=5, funksioni duhet të kthejë 42, pasi C(5) = 42.\ncatalan_number(5) -> 42\n\nShënim:\nLlogaritja bazohet në formulën rekursive:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nku C(0) është 1.", "hy": "Հաշվել n-րդ Կատալանի թիվը։\n\nՖունկցիան հաշվում է n-րդ Կատալանի թիվը դինամիկ ծրագրավորման միջոցով։ Կատալանի թվերը բնական թվերի հաջորդականություն են, որոնք ունեն բազմաթիվ կիրառություններ կոմբինատորիկ մաթեմատիկայում, ներառյալ որոշ տեսակների ցանցային ուղիների հաշվարկը, n զույգ փակագծեր պարունակող արտահայտությունների քանակը, որոնք ճիշտ են զուգակցված, n+1 գործոնների ամբողջական փակագծման տարբեր եղանակների քանակը և ավելին։\n\nԱրձագանքներ:\n- n (int): Կատալանի թվերի հաջորդականության դիրքը, որը պետք է հաշվարկել (պետք է լինի ոչ բացասական)։\n\nՎերադարձնում է:\n- int: n-րդ Կատալանի թիվը։\n\nԴեպքեր:\n- Երբ n=0, ֆունկցիան պետք է վերադարձնի 1, քանի որ C(0) = 1։\ncatalan_number(0) -> 1\n\n- Երբ n=3, ֆունկցիան պետք է վերադարձնի 5, քանի որ C(3) = 5։\ncatalan_number(3) -> 5\n\n- Երբ n=5, ֆունկցիան պետք է վերադարձնի 42, քանի որ C(5) = 42։\ncatalan_number(5) -> 42\n\nՆշում:\nՀաշվարկը հիմնված է ռեկուրսիվ բանաձևի վրա:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nորտեղ C(0) հավասար է 1։", "bn": "nth Catalan সংখ্যা গণনা করুন।\n\nফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে nth Catalan সংখ্যা গণনা করে। Catalan সংখ্যা একটি প্রাকৃতিক সংখ্যার ক্রম যা সমাবেশিক গণিতে অনেক প্রয়োগ রয়েছে, যার মধ্যে রয়েছে নির্দিষ্ট ধরনের ল্যাটিস পথ গণনা, n জোড়া বন্ধনী ধারণকারী অভিব্যক্তির সংখ্যা যা সঠিকভাবে মিলেছে, n+1 ফ্যাক্টর সম্পূর্ণভাবে বন্ধনীযুক্ত করার বিভিন্ন উপায়ের সংখ্যা, এবং আরও অনেক কিছু।\n\nArgs:\n- n (int): Catalan সংখ্যা ক্রমে গণনা করার অবস্থান (অবশ্যই অ-ঋণাত্মক হতে হবে)।\n\nReturns:\n- int: nth Catalan সংখ্যা।\n\nCases:\n- n=0 এর জন্য, ফাংশনটি 1 ফেরত দেবে, যেহেতু C(0) = 1।\ncatalan_number(0) -> 1\n\n- n=3 এর জন্য, ফাংশনটি 5 ফেরত দেবে, যেহেতু C(3) = 5।\ncatalan_number(3) -> 5\n\n- n=5 এর জন্য, ফাংশনটি 42 ফেরত দেবে, যেহেতু C(5) = 42।\ncatalan_number(5) -> 42\n\nNote:\nগণনাটি পুনরাবৃত্ত সূত্রের উপর ভিত্তি করে:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nযেখানে C(0) হল 1।", "bg": "Изчисляване на n-тото число на Каталан.\n\nФункцията изчислява n-тото число на Каталан, използвайки динамично програмиране. Числата на Каталан са последователност от естествени числа, които имат много приложения в комбинаторната математика, включително броенето на определени видове решетъчни пътища, броя на изразите, съдържащи n двойки скоби, които са правилно съчетани, броя на различните начини n+1 фактори да бъдат напълно скобирани и други.\n\nАргументи:\n- n (int): Позицията в последователността на числата на Каталан, която да бъде изчислена (трябва да бъде неотрицателно).\n\nВръща:\n- int: n-тото число на Каталан.\n\nСлучаи:\n- За n=0, функцията трябва да върне 1, тъй като C(0) = 1.\ncatalan_number(0) -> 1\n\n- За n=3, функцията трябва да върне 5, тъй като C(3) = 5.\ncatalan_number(3) -> 5\n\n- За n=5, функцията трябва да върне 42, тъй като C(5) = 42.\ncatalan_number(5) -> 42\n\nЗабележка:\nИзчислението се основава на рекурсивната формула:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nкъдето C(0) е 1.", "zh": "计算第 n 个 Catalan 数。\n\n该函数使用动态规划计算第 n 个 Catalan 数。Catalan 数是一系列自然数，在组合数学中有许多应用，包括计数某些类型的格路径、包含 n 对正确匹配括号的表达式数量、n+1 个因子完全括号化的不同方式数量等。\n\n参数：\n- n (int): 要计算的 Catalan 数序列中的位置（必须是非负的）。\n\n返回：\n- int: 第 n 个 Catalan 数。\n\n案例：\n- 对于 n=0，函数应返回 1，因为 C(0) = 1。\ncatalan_number(0) -> 1\n\n- 对于 n=3，函数应返回 5，因为 C(3) = 5。\ncatalan_number(3) -> 5\n\n- 对于 n=5，函数应返回 42，因为 C(5) = 42。\ncatalan_number(5) -> 42\n\n注意：\n计算基于递归公式：\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n其中 C(0) 为 1。", "fr": "Calculer le nième nombre de Catalan.\n\nLa fonction calcule le nième nombre de Catalan en utilisant la programmation dynamique. Les nombres de Catalan sont une séquence de nombres naturels qui ont de nombreuses applications en mathématiques combinatoires, y compris le comptage de certains types de chemins de grille, le nombre d'expressions contenant n paires de parenthèses correctement appariées, le nombre de façons différentes dont n+1 facteurs peuvent être complètement parenthésés, et plus encore.\n\nArgs:\n- n (int): La position dans la séquence des nombres de Catalan à calculer (doit être non négative).\n\nReturns:\n- int: Le nième nombre de Catalan.\n\nCas:\n- Pour n=0, la fonction doit retourner 1, puisque C(0) = 1.\ncatalan_number(0) -> 1\n\n- Pour n=3, la fonction doit retourner 5, puisque C(3) = 5.\ncatalan_number(3) -> 5\n\n- Pour n=5, la fonction doit retourner 42, puisque C(5) = 42.\ncatalan_number(5) -> 42\n\nRemarque:\nLe calcul est basé sur la formule récursive :\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\noù C(0) est 1.", "de": "Berechne die n-te Catalan-Zahl.\n\nDie Funktion berechnet die n-te Catalan-Zahl unter Verwendung der dynamischen Programmierung. Catalan-Zahlen sind eine Folge von natürlichen Zahlen, die viele Anwendungen in der kombinatorischen Mathematik haben, einschließlich der Zählung bestimmter Arten von Gitterpfaden, der Anzahl von Ausdrücken, die n korrekt gepaarte Klammern enthalten, der Anzahl der verschiedenen Möglichkeiten, n+1 Faktoren vollständig zu klammern, und mehr.\n\nArgs:\n- n (int): Die Position in der Catalan-Zahlenfolge, die berechnet werden soll (muss nicht-negativ sein).\n\nReturns:\n- int: Die n-te Catalan-Zahl.\n\nFälle:\n- Für n=0 sollte die Funktion 1 zurückgeben, da C(0) = 1.\ncatalan_number(0) -> 1\n\n- Für n=3 sollte die Funktion 5 zurückgeben, da C(3) = 5.\ncatalan_number(3) -> 5\n\n- Für n=5 sollte die Funktion 42 zurückgeben, da C(5) = 42.\ncatalan_number(5) -> 42\n\nHinweis:\nDie Berechnung basiert auf der rekursiven Formel:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nwobei C(0) 1 ist.", "ha": "Lissafa lambar Catalan ta n.\n\nAikin yana lissafin lambar Catalan ta nth ta amfani da shirye-shiryen motsi. Lambobin Catalan suna jerin lambobin halitta\nwadanda suke da aikace-aikace da yawa a cikin lissafin haɗin gwiwa, ciki har da ƙididdigar wasu nau'ikan hanyoyin lattice,\nyawan maganganun da ke ɗauke da nau'i-nau'i n na maƙalafan da aka haɗa daidai, yawan hanyoyin daban-daban n+1\nabubuwan da za a iya rarrabewa gaba ɗaya, da ƙari.\n\nArgs:\n- n (int): Matsayi a cikin jerin lambobin Catalan da za a lissafa (dole ne ya zama maras kyau).\n\nReturns:\n- int: Lambar Catalan ta nth.\n\nCases:\n- Ga n=0, aikin ya kamata ya dawo da 1, tun da C(0) = 1.\ncatalan_number(0) -> 1\n\n- Ga n=3, aikin ya kamata ya dawo da 5, tun da C(3) = 5.\ncatalan_number(3) -> 5\n\n- Ga n=5, aikin ya kamata ya dawo da 42, tun da C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nLissafin yana dogara ne akan tsarin maimaitawa:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\ninda C(0) yake 1.", "hi": "nth कैटलन संख्या की गणना करें।\n\nयह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके nth कैटलन संख्या की गणना करता है। कैटलन संख्याएँ प्राकृतिक संख्याओं की एक श्रृंखला हैं जिनका संयोजकीय गणित में कई अनुप्रयोग हैं, जिसमें कुछ प्रकार के जाली पथों की गिनती, n जोड़े कोष्ठकों वाले अभिव्यक्तियों की संख्या जो सही ढंग से मेल खाते हैं, n+1 कारकों को पूरी तरह से कोष्ठक में रखने के विभिन्न तरीकों की संख्या, और अधिक शामिल हैं।\n\nआर्ग्स:\n- n (int): कैटलन संख्या अनुक्रम में स्थिति जिसकी गणना करनी है (गैर-ऋणात्मक होना चाहिए)।\n\nरिटर्न्स:\n- int: nth कैटलन संख्या।\n\nमामले:\n- n=0 के लिए, फ़ंक्शन को 1 लौटाना चाहिए, क्योंकि C(0) = 1।\ncatalan_number(0) -> 1\n\n- n=3 के लिए, फ़ंक्शन को 5 लौटाना चाहिए, क्योंकि C(3) = 5।\ncatalan_number(3) -> 5\n\n- n=5 के लिए, फ़ंक्शन को 42 लौटाना चाहिए, क्योंकि C(5) = 42।\ncatalan_number(5) -> 42\n\nनोट:\nगणना पुनरावर्ती सूत्र पर आधारित है:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nजहाँ C(0) 1 है।", "hu": "Számítsa ki az n-edik Catalan számot.\n\nA függvény dinamikus programozás segítségével számítja ki az n-edik Catalan számot. A Catalan számok egy sorozata a természetes számoknak, amelyek számos alkalmazással bírnak a kombinatorikus matematikában, beleértve bizonyos típusú rácsos utak számolását, az n pár zárójelet tartalmazó kifejezések számát, amelyek helyesen vannak párosítva, az n+1 tényező különböző módokon történő teljes zárójelezésének számát, és még sok mást.\n\nArgs:\n- n (int): A Catalan szám sorozatban a kiszámítandó pozíció (nem lehet negatív).\n\nReturns:\n- int: Az n-edik Catalan szám.\n\nEsetek:\n- Ha n=0, a függvénynek 1-et kell visszaadnia, mivel C(0) = 1.\ncatalan_number(0) -> 1\n\n- Ha n=3, a függvénynek 5-öt kell visszaadnia, mivel C(3) = 5.\ncatalan_number(3) -> 5\n\n- Ha n=5, a függvénynek 42-t kell visszaadnia, mivel C(5) = 42.\ncatalan_number(5) -> 42\n\nMegjegyzés:\nA számítás az alábbi rekurzív képleten alapul:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nahol C(0) értéke 1.", "es": "Calcular el enésimo número de Catalan.\n\nLa función calcula el enésimo número de Catalan utilizando programación dinámica. Los números de Catalan son una secuencia de números naturales que tienen muchas aplicaciones en matemáticas combinatorias, incluyendo el conteo de ciertos tipos de caminos en una cuadrícula, el número de expresiones que contienen n pares de paréntesis que están correctamente emparejados, el número de diferentes maneras en que n+1 factores pueden ser completamente parentetizados, y más.\n\nArgumentos:\n- n (int): La posición en la secuencia de números de Catalan a calcular (debe ser no negativa).\n\nDevuelve:\n- int: El enésimo número de Catalan.\n\nCasos:\n- Para n=0, la función debe devolver 1, ya que C(0) = 1.\ncatalan_number(0) -> 1\n\n- Para n=3, la función debe devolver 5, ya que C(3) = 5.\ncatalan_number(3) -> 5\n\n- Para n=5, la función debe devolver 42, ya que C(5) = 42.\ncatalan_number(5) -> 42\n\nNota:\nEl cálculo se basa en la fórmula recursiva:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\ndonde C(0) es 1.", "arb": "حساب العدد النوني من كاتالان.\n\nتقوم الدالة بحساب العدد النوني من كاتالان باستخدام البرمجة الديناميكية. أعداد كاتالان هي سلسلة من الأعداد الطبيعية التي لها العديد من التطبيقات في الرياضيات التوافقية، بما في ذلك عد أنواع معينة من مسارات الشبكة، عدد التعبيرات التي تحتوي على n من الأزواج من الأقواس التي تتطابق بشكل صحيح، عدد الطرق المختلفة التي يمكن بها وضع الأقواس بشكل كامل لعوامل n+1، وأكثر.\n\nالمعطيات:\n- n (int): الموضع في سلسلة أعداد كاتالان الذي سيتم حسابه (يجب أن يكون غير سالب).\n\nالقيم المعادة:\n- int: العدد النوني من كاتالان.\n\nالحالات:\n- بالنسبة لـ n=0، يجب أن تعيد الدالة 1، حيث أن C(0) = 1.\ncatalan_number(0) -> 1\n\n- بالنسبة لـ n=3، يجب أن تعيد الدالة 5، حيث أن C(3) = 5.\ncatalan_number(3) -> 5\n\n- بالنسبة لـ n=5، يجب أن تعيد الدالة 42، حيث أن C(5) = 42.\ncatalan_number(5) -> 42\n\nملاحظة:\nيعتمد الحساب على الصيغة التكرارية:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nحيث أن C(0) هو 1.", "sw": "Kuhesabu nambari ya Catalan ya n.\n\nKazi ya kifanyiko ni kuhesabu nambari ya Catalan ya nth kwa kutumia programu ya nguvu. Nambari za Catalan ni mlolongo wa nambari za asili ambazo zina matumizi mengi katika hesabu za mchanganyiko, ikijumuisha kuhesabu aina fulani za njia za lattice, idadi ya maneno yenye jozi n za mabano ambayo yamefananishwa vizuri, idadi ya njia tofauti ambazo n+1 sababu zinaweza kuwekwa mabano kikamilifu, na zaidi.\n\nHoja:\n- n (int): Nafasi katika mlolongo wa nambari za Catalan ya kuhesabu (lazima isiwe hasi).\n\nInarejesha:\n- int: Nambari ya Catalan ya nth.\n\nCases:\n- Kwa n=0, kazi inapaswa kurudisha 1, kwa kuwa C(0) = 1.\ncatalan_number(0) -> 1\n\n- Kwa n=3, kazi inapaswa kurudisha 5, kwa kuwa C(3) = 5.\ncatalan_number(3) -> 5\n\n- Kwa n=5, kazi inapaswa kurudisha 42, kwa kuwa C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nHesabu inategemea fomula ya kurudiwa:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nambapo C(0) ni 1.", "tr": "nth Catalan sayısını hesaplayın.\n\nFonksiyon, dinamik programlama kullanarak nth Catalan sayısını hesaplar. Catalan sayıları, kombinatoryal matematikte birçok uygulamaya sahip doğal sayıların bir dizisidir. Bu uygulamalar arasında belirli türdeki kafes yollarının sayılması, n çift parantez içeren ve doğru eşleşmiş ifadelerin sayısı, n+1 faktörün tamamen parantezlenebileceği farklı yolların sayısı ve daha fazlası bulunmaktadır.\n\nArgümanlar:\n- n (int): Hesaplanacak Catalan sayısı dizisindeki konum (negatif olmamalıdır).\n\nDöndürür:\n- int: nth Catalan sayısı.\n\nDurumlar:\n- n=0 için, fonksiyon 1 döndürmelidir, çünkü C(0) = 1.\ncatalan_number(0) -> 1\n\n- n=3 için, fonksiyon 5 döndürmelidir, çünkü C(3) = 5.\ncatalan_number(3) -> 5\n\n- n=5 için, fonksiyon 42 döndürmelidir, çünkü C(5) = 42.\ncatalan_number(5) -> 42\n\nNot:\nHesaplama, aşağıdaki özyinelemeli formüle dayanmaktadır:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nburada C(0) 1'dir.", "vi": "Tính số Catalan thứ n.\n\nHàm này tính số Catalan thứ n bằng cách sử dụng lập trình động. Các số Catalan là một dãy số tự nhiên có nhiều ứng dụng trong toán học tổ hợp, bao gồm việc đếm các loại đường đi trên lưới nhất định, số lượng biểu thức chứa n cặp dấu ngoặc được ghép đúng, số cách khác nhau mà n+1 yếu tố có thể được đặt dấu ngoặc hoàn toàn, và nhiều ứng dụng khác.\n\nTham số:\n- n (int): Vị trí trong dãy số Catalan cần tính (phải là số không âm).\n\nTrả về:\n- int: Số Catalan thứ n.\n\nCases:\n- Với n=0, hàm nên trả về 1, vì C(0) = 1.\ncatalan_number(0) -> 1\n\n- Với n=3, hàm nên trả về 5, vì C(3) = 5.\ncatalan_number(3) -> 5\n\n- Với n=5, hàm nên trả về 42, vì C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nViệc tính toán dựa trên công thức đệ quy:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\ntrong đó C(0) là 1.", "id": "Hitung bilangan Catalan ke-n.\n\nFungsi ini menghitung bilangan Catalan ke-n menggunakan pemrograman dinamis. Bilangan Catalan adalah urutan bilangan\nalami yang memiliki banyak aplikasi dalam matematika kombinatorial, termasuk menghitung jenis jalur kisi tertentu,\njumlah ekspresi yang mengandung n pasang tanda kurung yang cocok dengan benar, jumlah cara berbeda n+1\nfaktor dapat sepenuhnya diberi tanda kurung, dan lainnya.\n\nArgs:\n- n (int): Posisi dalam urutan bilangan Catalan yang akan dihitung (harus non-negatif).\n\nReturns:\n- int: Bilangan Catalan ke-n.\n\nKasus:\n- Untuk n=0, fungsi harus mengembalikan 1, karena C(0) = 1.\ncatalan_number(0) -> 1\n\n- Untuk n=3, fungsi harus mengembalikan 5, karena C(3) = 5.\ncatalan_number(3) -> 5\n\n- Untuk n=5, fungsi harus mengembalikan 42, karena C(5) = 42.\ncatalan_number(5) -> 42\n\nCatatan:\nPerhitungan didasarkan pada rumus rekursif:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\ndi mana C(0) adalah 1.", "ja": "nth番目のカタラン数を計算します。\n\nこの関数は動的プログラミングを使用してnth番目のカタラン数を計算します。カタラン数は、組合せ数学において多くの応用を持つ自然数の列であり、特定の種類の格子経路の数、n組の括弧を含む式が正しく対応している数、n+1個の要素を完全に括弧で囲む異なる方法の数などがあります。\n\n引数:\n- n (int): 計算するカタラン数列の位置（非負でなければなりません）。\n\n戻り値:\n- int: nth番目のカタラン数。\n\nケース:\n- n=0の場合、関数は1を返すべきです。なぜならC(0) = 1だからです。\ncatalan_number(0) -> 1\n\n- n=3の場合、関数は5を返すべきです。なぜならC(3) = 5だからです。\ncatalan_number(3) -> 5\n\n- n=5の場合、関数は42を返すべきです。なぜならC(5) = 42だからです。\ncatalan_number(5) -> 42\n\n注意:\n計算は以下の再帰式に基づいています:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nここでC(0)は1です。", "ko": "n번째 카탈란 수를 계산합니다.\n\n이 함수는 동적 프로그래밍을 사용하여 n번째 카탈란 수를 계산합니다. 카탈란 수는 조합 수학에서 여러 응용을 가지는 자연수의 수열로, 특정 유형의 격자 경로 계산, 올바르게 짝지어진 n 쌍의 괄호를 포함하는 표현식의 수, n+1개의 요소를 완전히 괄호화할 수 있는 서로 다른 방법의 수 등을 포함합니다.\n\nArgs:\n- n (int): 계산할 카탈란 수열의 위치 (0 이상의 정수여야 함).\n\nReturns:\n- int: n번째 카탈란 수.\n\nCases:\n- n=0인 경우, 함수는 1을 반환해야 합니다. 이는 C(0) = 1이기 때문입니다.\ncatalan_number(0) -> 1\n\n- n=3인 경우, 함수는 5를 반환해야 합니다. 이는 C(3) = 5이기 때문입니다.\ncatalan_number(3) -> 5\n\n- n=5인 경우, 함수는 42를 반환해야 합니다. 이는 C(5) = 42이기 때문입니다.\ncatalan_number(5) -> 42\n\nNote:\n계산은 다음의 재귀 공식에 기반합니다:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n여기서 C(0)은 1입니다.", "ml": "nth Catalan നമ്പർ കണക്കാക്കുക.\n\nഫങ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് nth Catalan നമ്പർ കണക്കാക്കുന്നു. Catalan നമ്പറുകൾ സംയോജക ഗണിതശാസ്ത്രത്തിൽ നിരവധി പ്രയോഗങ്ങൾ ഉള്ള പ്രകൃതിദത്ത സംഖ്യകളുടെ ഒരു അനുക്രമമാണ്, ഇതിൽ ചില തരം ലാറ്റിസ് പാതകളുടെ എണ്ണമാക്കൽ, ശരിയായി പൊരുത്തപ്പെടുന്ന n ജോഡി വക്രകോഷ്ടകങ്ങൾ അടങ്ങിയ വ്യാഖ്യാനങ്ങളുടെ എണ്ണം, n+1 ഘടകങ്ങൾ പൂർണ്ണമായും വക്രകോഷ്ടകമിടാനുള്ള വ്യത്യസ്ത മാർഗ്ഗങ്ങളുടെ എണ്ണം എന്നിവ ഉൾപ്പെടുന്നു.\n\nആർഗുകൾ:\n- n (int): കണക്കാക്കേണ്ട Catalan നമ്പർ അനുക്രമത്തിലെ സ്ഥാനം (നോൺ-നെഗറ്റീവ് ആയിരിക്കണം).\n\nമടക്കം:\n- int: nth Catalan നമ്പർ.\n\nകേസുകൾ:\n- n=0 ആയാൽ, ഫങ്ഷൻ 1 മടക്കണം, കാരണം C(0) = 1.\ncatalan_number(0) -> 1\n\n- n=3 ആയാൽ, ഫങ്ഷൻ 5 മടക്കണം, കാരണം C(3) = 5.\ncatalan_number(3) -> 5\n\n- n=5 ആയാൽ, ഫങ്ഷൻ 42 മടക്കണം, കാരണം C(5) = 42.\ncatalan_number(5) -> 42\n\nകുറിപ്പ്:\nകണക്കാക്കൽ പുനരാവർത്തന സൂത്രവാക്യത്തെ അടിസ്ഥാനമാക്കിയുള്ളതാണ്:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nഇവിടെ C(0) 1 ആണ്.", "fa": "محاسبه عدد کاتالان nام.\n\nاین تابع عدد کاتالان nام را با استفاده از برنامه‌نویسی پویا محاسبه می‌کند. اعداد کاتالان دنباله‌ای از اعداد طبیعی هستند که کاربردهای زیادی در ریاضیات ترکیبیاتی دارند، از جمله شمارش انواع خاصی از مسیرهای شبکه، تعداد عبارات حاوی n جفت پرانتز که به درستی جفت شده‌اند، تعداد روش‌های مختلفی که n+1 عامل می‌توانند به طور کامل پرانتزگذاری شوند، و موارد دیگر.\n\nآرگومان‌ها:\n- n (int): موقعیت در دنباله عدد کاتالان برای محاسبه (باید غیرمنفی باشد).\n\nبازگشت:\n- int: عدد کاتالان nام.\n\nموارد:\n- برای n=0، تابع باید 1 را برگرداند، زیرا C(0) = 1.\ncatalan_number(0) -> 1\n\n- برای n=3، تابع باید 5 را برگرداند، زیرا C(3) = 5.\ncatalan_number(3) -> 5\n\n- برای n=5، تابع باید 42 را برگرداند، زیرا C(5) = 42.\ncatalan_number(5) -> 42\n\nتوجه:\nمحاسبه بر اساس فرمول بازگشتی است:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nکه در آن C(0) برابر 1 است."}}
{"task_id": "Python/35", "prompt": {"en": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n    1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"", "sq": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Llogarit numrin e mollëve që Tao Tao mund të arrijë.\n\n    Args:\n    apple_heights (List[int]): Lartësitë e mollëve nga toka (në centimetra).\n    tao_reach (int): Lartësia maksimale që Tao Tao mund të arrijë me dorën e saj të shtrirë lart (në centimetra).\n\n    Returns:\n    int: Numri i mollëve që Tao Tao mund të arrijë me ose pa qëndruar në një stol 30cm.\n\n    Kjo funksion iteron mbi listën e lartësive të mollëve dhe numëron sa prej tyre janë brenda arritjes së Tao Tao,\n    duke konsideruar një shtesë prej 30cm që stoli ofron.\n\n    Shembuj rastesh:\n    1. Tao Tao mund të arrijë mollët në 120cm pa stol, dhe të gjitha mollët janë në 150cm ose më poshtë.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao mund të arrijë mollët në 100cm pa stol, dhe të gjitha mollët janë mbi 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao mund të arrijë mollët në 110cm pa stol, dhe disa mollë janë në lartësi të ndryshme.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"", "hy": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Հաշվարկել խնձորների քանակը, որոնք Տաո Տաոն կարող է հասնել։\n\n    Արգումենտներ:\n    apple_heights (List[int]): Խնձորների բարձրությունները գետնից (սանտիմետրերով)։\n    tao_reach (int): Առավելագույն բարձրությունը, որին Տաո Տաոն կարող է հասնել ձեռքը վեր պարզած (սանտիմետրերով)։\n\n    Վերադարձնում է:\n    int: Խնձորների քանակը, որոնք Տաո Տաոն կարող է հասնել 30սմ աթոռի վրա կանգնած կամ առանց դրա։\n\n    Այս ֆունկցիան անցնում է խնձորների բարձրությունների ցանկով և հաշվում, թե դրանցից քանիսն են Տաո Տաոյի հասանելիության սահմաններում,\n    հաշվի առնելով աթոռի կողմից տրվող լրացուցիչ 30սմ-ը։\n\n    Օրինակային դեպքեր:\n    1. Տաո Տաոն կարող է հասնել 120սմ բարձրության խնձորներին առանց աթոռի, և բոլոր խնձորները 150սմ կամ ավելի ցածր են։\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> վերադարձնում է 10\n\n    2. Տաո Տաոն կարող է հասնել 100սմ բարձրության խնձորներին առանց աթոռի, և բոլոր խնձորները 130սմ-ից բարձր են։\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> վերադարձնում է 0\n\n    3. Տաո Տաոն կարող է հասնել 110սմ բարձրության խնձորներին առանց աթոռի, և որոշ խնձորներ տարբեր բարձրությունների վրա են։\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> վերադարձնում է 5\n    \"\"\"", "bn": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    কতগুলি আপেল তাও তাও পৌঁছাতে পারে তা গণনা করুন।\n\n    Args:\n    apple_heights (List[int]): মাটি থেকে আপেলের উচ্চতা (সেন্টিমিটারে)।\n    tao_reach (int): তাও তাও তার হাত প্রসারিত করে সর্বাধিক যে উচ্চতায় পৌঁছাতে পারে (সেন্টিমিটারে)।\n\n    Returns:\n    int: তাও তাও একটি 30cm স্টুলের উপর দাঁড়িয়ে বা না দাঁড়িয়ে কতগুলি আপেল পৌঁছাতে পারে।\n\n    এই ফাংশনটি আপেলের উচ্চতার তালিকার উপর পুনরাবৃত্তি করে এবং কতগুলি আপেল তাও তাও এর নাগালের মধ্যে রয়েছে তা গণনা করে,\n    স্টুল যে অতিরিক্ত 30cm প্রদান করে তা বিবেচনা করে।\n\n    উদাহরণ কেস:\n    1. তাও তাও 120cm উচ্চতায় স্টুল ছাড়াই আপেল পৌঁছাতে পারে, এবং সমস্ত আপেল 150cm বা তার নিচে।\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. তাও তাও 100cm উচ্চতায় স্টুল ছাড়াই আপেল পৌঁছাতে পারে, এবং সমস্ত আপেল 130cm এর উপরে।\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. তাও তাও 110cm উচ্চতায় স্টুল ছাড়াই আপেল পৌঁছাতে পারে, এবং কিছু আপেল বিভিন্ন উচ্চতায় রয়েছে।\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"", "bg": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Изчислява броя на ябълките, които Тао Тао може да достигне.\n\n    Args:\n    apple_heights (List[int]): Височините на ябълките от земята (в сантиметри).\n    tao_reach (int): Максималната височина, която Тао Тао може да достигне с протегната ръка нагоре (в сантиметри).\n\n    Returns:\n    int: Броят на ябълките, които Тао Тао може да достигне със или без да стои на столче от 30см.\n\n    Тази функция обхожда списъка с височините на ябълките и брои колко от тях са в обсега на Тао Тао,\n    като се вземат предвид допълнителните 30см, които столчето осигурява.\n\n    Примерни случаи:\n    1. Тао Тао може да достигне ябълки на 120см без столче, и всички ябълки са на 150см или по-ниско.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> връща 10\n\n    2. Тао Тао може да достигне ябълки на 100см без столче, и всички ябълки са над 130см.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> връща 0\n\n    3. Тао Тао може да достигне ябълки на 110см без столче, и някои ябълки са на различни височини.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> връща 5\n    \"\"\"", "zh": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    计算陶陶可以够到的苹果数量。\n\n    参数：\n    apple_heights (List[int]): 苹果距离地面的高度（以厘米为单位）。\n    tao_reach (int): 陶陶伸手向上可以达到的最大高度（以厘米为单位）。\n\n    返回：\n    int: 陶陶在站上30厘米高的凳子后可以够到的苹果数量。\n\n    此函数遍历苹果高度列表，并计算其中有多少在陶陶的够到范围内，\n    考虑到凳子提供的额外30厘米。\n\n    示例案例：\n    1. 陶陶在不使用凳子的情况下可以够到120厘米的苹果，所有苹果都在150厘米或以下。\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 返回 10\n\n    2. 陶陶在不使用凳子的情况下可以够到100厘米的苹果，所有苹果都在130厘米以上。\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 返回 0\n\n    3. 陶陶在不使用凳子的情况下可以够到110厘米的苹果，部分苹果在不同高度。\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> 返回 5\n    \"\"\"", "fr": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculer le nombre de pommes que Tao Tao peut atteindre.\n\n    Args:\n    apple_heights (List[int]): Les hauteurs des pommes depuis le sol (en centimètres).\n    tao_reach (int): La hauteur maximale que Tao Tao peut atteindre avec sa main tendue vers le haut (en centimètres).\n\n    Returns:\n    int: Le nombre de pommes que Tao Tao peut atteindre avec ou sans se tenir sur un tabouret de 30 cm.\n\n    Cette fonction parcourt la liste des hauteurs des pommes et compte combien d'entre elles sont à la portée de Tao Tao,\n    en considérant un supplément de 30 cm que le tabouret fournit.\n\n    Exemples de cas :\n    1. Tao Tao peut atteindre les pommes à 120 cm sans tabouret, et toutes les pommes sont à 150 cm ou moins.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao peut atteindre les pommes à 100 cm sans tabouret, et toutes les pommes sont au-dessus de 130 cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao peut atteindre les pommes à 110 cm sans tabouret, et certaines pommes sont à différentes hauteurs.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"", "de": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Berechne die Anzahl der Äpfel, die Tao Tao erreichen kann.\n\n    Args:\n    apple_heights (List[int]): Die Höhen der Äpfel vom Boden aus (in Zentimetern).\n    tao_reach (int): Die maximale Höhe, die Tao Tao mit ausgestreckter Hand erreichen kann (in Zentimetern).\n\n    Returns:\n    int: Die Anzahl der Äpfel, die Tao Tao mit oder ohne einen 30cm hohen Hocker erreichen kann.\n\n    Diese Funktion iteriert über die Liste der Apfelhöhen und zählt, wie viele davon in Tao Taos Reichweite liegen,\n    wobei zusätzliche 30cm berücksichtigt werden, die der Hocker bietet.\n\n    Beispielhafte Fälle:\n    1. Tao Tao kann Äpfel in 120cm Höhe ohne Hocker erreichen, und alle Äpfel sind bei 150cm oder darunter.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> gibt 10 zurück\n\n    2. Tao Tao kann Äpfel in 100cm Höhe ohne Hocker erreichen, und alle Äpfel sind über 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> gibt 0 zurück\n\n    3. Tao Tao kann Äpfel in 110cm Höhe ohne Hocker erreichen, und einige Äpfel sind in verschiedenen Höhen.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> gibt 5 zurück\n    \"\"\"", "ha": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Lissafa yawan tuffa da Tao Tao za ta iya kaiwa.\n\n    Args:\n    apple_heights (List[int]): Tsayin tuffa daga ƙasa (a cikin santimita).\n    tao_reach (int): Matsakaicin tsayin da Tao Tao za ta iya kaiwa da hannunta a miƙe sama (a cikin santimita).\n\n    Returns:\n    int: Yawan tuffa da Tao Tao za ta iya kaiwa tare da ko ba tare da tsayawa a kan kujerar 30cm ba.\n\n    Wannan aikin yana zagayawa a kan jerin tsayin tuffa kuma yana lissafa nawa daga cikinsu suke cikin isar Tao Tao,\n    la'akari da ƙarin 30cm da kujerar ke bayarwa.\n\n    Misalan lokuta:\n    1. Tao Tao za ta iya kaiwa tuffa a 120cm ba tare da kujera ba, kuma duk tuffa suna a 150cm ko ƙasa da haka.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao za ta iya kaiwa tuffa a 100cm ba tare da kujera ba, kuma duk tuffa suna sama da 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao za ta iya kaiwa tuffa a 110cm ba tare da kujera ba, kuma wasu tuffa suna a tsayin daban-daban.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"", "hi": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    गणना करें कि ताओ ताओ कितने सेब तक पहुँच सकती है।\n\n    Args:\n    apple_heights (List[int]): जमीन से सेबों की ऊँचाई (सेंटीमीटर में)।\n    tao_reach (int): अधिकतम ऊँचाई तक ताओ ताओ अपने हाथ को ऊपर खींचकर पहुँच सकती है (सेंटीमीटर में)।\n\n    Returns:\n    int: उन सेबों की संख्या जिन तक ताओ ताओ 30 सेमी स्टूल पर खड़े होकर या बिना खड़े हुए पहुँच सकती है।\n\n    यह फ़ंक्शन सेबों की ऊँचाई की सूची पर इटरेट करता है और गिनता है कि उनमें से कितने ताओ ताओ की पहुँच में हैं,\n    30 सेमी अतिरिक्त ऊँचाई को ध्यान में रखते हुए जो स्टूल प्रदान करता है।\n\n    उदाहरण मामले:\n    1. ताओ ताओ 120 सेमी पर बिना स्टूल के सेब तक पहुँच सकती है, और सभी सेब 150 सेमी या उससे नीचे हैं।\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. ताओ ताओ 100 सेमी पर बिना स्टूल के सेब तक पहुँच सकती है, और सभी सेब 130 सेमी से ऊपर हैं।\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. ताओ ताओ 110 सेमी पर बिना स्टूल के सेब तक पहुँच सकती है, और कुछ सेब विभिन्न ऊँचाइयों पर हैं।\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"", "hu": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Számolja ki, hány almát ér el Tao Tao.\n\n    Args:\n    apple_heights (List[int]): Az almák magassága a talajtól (centiméterben).\n    tao_reach (int): A maximális magasság, amit Tao Tao elérhet kinyújtott kézzel (centiméterben).\n\n    Returns:\n    int: Az elérhető almák száma Tao Tao számára, akár 30 cm-es sámlin állva is.\n\n    Ez a függvény végigmegy az almák magasságának listáján, és megszámolja, hány közülük van Tao Tao elérhetőségén belül,\n    figyelembe véve a sámi által biztosított további 30 cm-t.\n\n    Példa esetek:\n    1. Tao Tao eléri az almákat 120 cm-en sámi nélkül, és minden alma 150 cm vagy az alatt van.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> visszaadja 10\n\n    2. Tao Tao eléri az almákat 100 cm-en sámi nélkül, és minden alma 130 cm felett van.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> visszaadja 0\n\n    3. Tao Tao eléri az almákat 110 cm-en sámi nélkül, és néhány alma különböző magasságokban van.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> visszaadja 5\n    \"\"\"", "es": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calcular la cantidad de manzanas que Tao Tao puede alcanzar.\n\n    Argumentos:\n    apple_heights (List[int]): Las alturas de las manzanas desde el suelo (en centímetros).\n    tao_reach (int): La altura máxima que Tao Tao puede alcanzar con su mano extendida hacia arriba (en centímetros).\n\n    Devuelve:\n    int: El número de manzanas que Tao Tao puede alcanzar con o sin pararse en un taburete de 30 cm.\n\n    Esta función itera sobre la lista de alturas de manzanas y cuenta cuántas de ellas están al alcance de Tao Tao,\n    considerando un adicional de 30 cm que proporciona el taburete.\n\n    Casos de ejemplo:\n    1. Tao Tao puede alcanzar manzanas a 120 cm sin un taburete, y todas las manzanas están a 150 cm o menos.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> Devuelve 10\n\n    2. Tao Tao puede alcanzar manzanas a 100 cm sin un taburete, y todas las manzanas están por encima de 130 cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> Devuelve 0\n\n    3. Tao Tao puede alcanzar manzanas a 110 cm sin un taburete, y algunas manzanas están a varias alturas.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> Devuelve 5\n    \"\"\"", "arb": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    حساب عدد التفاح الذي يمكن لتاو تاو الوصول إليه.\n\n    يعيدالحجج:\n    apple_heights (List[int]): ارتفاعات التفاح من الأرض (بالسنتيمترات).\n    tao_reach (int): أقصى ارتفاع يمكن لتاو تاو الوصول إليه بيدها ممدودة للأعلى (بالسنتيمترات).\n\n    يعيد:\n    int: عدد التفاح الذي يمكن لتاو تاو الوصول إليه مع أو بدون الوقوف على كرسي بارتفاع 30 سم.\n\n    تقوم هذه الدالة بتكرار قائمة ارتفاعات التفاح وتعد كم منها ضمن نطاق وصول تاو تاو،\n    مع الأخذ في الاعتبار إضافة 30 سم التي يوفرها الكرسي.\n\n    حالات المثال:\n    1. يمكن لتاو تاو الوصول إلى التفاح على ارتفاع 120 سم بدون كرسي، وجميع التفاح على ارتفاع 150 سم أو أقل.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> يعيد 10\n\n    2. يمكن لتاو تاو الوصول إلى التفاح على ارتفاع 100 سم بدون كرسي، وجميع التفاح على ارتفاع أكثر من 130 سم.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> يعيد 0\n\n    3. يمكن لتاو تاو الوصول إلى التفاح على ارتفاع 110 سم بدون كرسي، وبعض التفاح على ارتفاعات مختلفة.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> يعيد 5\n    \"\"\"", "sw": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Kuhesabu idadi ya maapulo ambayo Tao Tao anaweza kuyafikia.\n\n    Hoja:\n    apple_heights (List[int]): Urefu wa maapulo kutoka ardhini (katika sentimita).\n    tao_reach (int): Urefu wa juu zaidi ambao Tao Tao anaweza kufikia kwa mkono wake ukiwa umenyooka juu (katika sentimita).\n\n    Inarejesha:\n    int: Idadi ya maapulo ambayo Tao Tao anaweza kuyafikia akiwa amesimama au bila kusimama kwenye kigoda cha 30cm.\n\n    Kazi hii inazunguka kwenye orodha ya urefu wa maapulo na kuhesabu ni mangapi kati yao yako ndani ya urefu ambao Tao Tao anaweza kufikia,\n    ikizingatia nyongeza ya 30cm ambayo kigoda kinatoa.\n\n    Mifano ya kesi:\n    1. Tao Tao anaweza kufikia maapulo kwenye 120cm bila kigoda, na maapulo yote yako kwenye 150cm au chini.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> Inarejesha 10\n\n    2. Tao Tao anaweza kufikia maapulo kwenye 100cm bila kigoda, na maapulo yote yako juu ya 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> Inarejesha 0\n\n    3. Tao Tao anaweza kufikia maapulo kwenye 110cm bila kigoda, na baadhi ya maapulo yako kwenye urefu mbalimbali.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> Inarejesha 5\n    \"\"\"", "tr": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tao Tao'nun ulaşabileceği elma sayısını hesaplayın.\n\n    Argümanlar:\n    apple_heights (List[int]): Elmaların yerden yükseklikleri (santimetre cinsinden).\n    tao_reach (int): Tao Tao'nun elini yukarı doğru uzatarak ulaşabileceği maksimum yükseklik (santimetre cinsinden).\n\n    Döndürür:\n    int: Tao Tao'nun 30cm'lik bir tabureye çıkıp çıkmadan ulaşabileceği elma sayısı.\n\n    Bu fonksiyon, elma yükseklikleri listesini dolaşır ve bunlardan kaç tanesinin Tao Tao'nun erişebileceği mesafede olduğunu,\n    taburenin sağladığı ek 30cm'yi dikkate alarak sayar.\n\n    Örnek durumlar:\n    1. Tao Tao, taburesiz 120cm'deki elmalara ulaşabilir ve tüm elmalar 150cm veya altında.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 10 döndürür\n\n    2. Tao Tao, taburesiz 100cm'deki elmalara ulaşabilir ve tüm elmalar 130cm'nin üzerinde.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 0 döndürür\n\n    3. Tao Tao, taburesiz 110cm'deki elmalara ulaşabilir ve bazı elmalar çeşitli yüksekliklerde.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> 5 döndürür\n    \"\"\"", "vi": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tính số lượng táo mà Tao Tao có thể với tới.\n\n    Tham số:\n    apple_heights (List[int]): Chiều cao của các quả táo tính từ mặt đất (tính bằng cm).\n    tao_reach (int): Chiều cao tối đa mà Tao Tao có thể với tới khi giơ tay lên (tính bằng cm).\n\n    Trả về:\n    int: Số lượng táo mà Tao Tao có thể với tới có hoặc không đứng trên ghế đẩu cao 30cm.\n\n    Hàm này duyệt qua danh sách chiều cao của các quả táo và đếm xem có bao nhiêu quả nằm trong tầm với của Tao Tao,\n    bao gồm thêm 30cm mà ghế đẩu cung cấp.\n\n    Ví dụ:\n    1. Tao Tao có thể với tới các quả táo ở độ cao 120cm mà không cần ghế đẩu, và tất cả các quả táo đều ở độ cao 150cm hoặc thấp hơn.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> trả về 10\n\n    2. Tao Tao có thể với tới các quả táo ở độ cao 100cm mà không cần ghế đẩu, và tất cả các quả táo đều trên 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> trả về 0\n\n    3. Tao Tao có thể với tới các quả táo ở độ cao 110cm mà không cần ghế đẩu, và một số quả táo ở các độ cao khác nhau.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> trả về 5\n    \"\"\"", "id": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Menghitung jumlah apel yang dapat dijangkau oleh Tao Tao.\n\n    Argumen:\n    apple_heights (List[int]): Tinggi apel dari tanah (dalam sentimeter).\n    tao_reach (int): Tinggi maksimum yang dapat dijangkau Tao Tao dengan tangan terentang ke atas (dalam sentimeter).\n\n    Mengembalikan:\n    int: Jumlah apel yang dapat dijangkau Tao Tao dengan atau tanpa berdiri di atas bangku 30cm.\n\n    Fungsi ini mengiterasi daftar tinggi apel dan menghitung berapa banyak dari mereka yang berada dalam jangkauan Tao Tao,\n    dengan mempertimbangkan tambahan 30cm yang disediakan oleh bangku.\n\n    Contoh kasus:\n    1. Tao Tao dapat menjangkau apel pada 120cm tanpa bangku, dan semua apel berada pada 150cm atau di bawahnya.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> mengembalikan 10\n\n    2. Tao Tao dapat menjangkau apel pada 100cm tanpa bangku, dan semua apel berada di atas 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> mengembalikan 0\n\n    3. Tao Tao dapat menjangkau apel pada 110cm tanpa bangku, dan beberapa apel berada pada berbagai ketinggian.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> mengembalikan 5\n    \"\"\"", "ja": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tao Taoが届くリンゴの数を計算します。\n\n    引数:\n    apple_heights (List[int]): 地面からのリンゴの高さ（センチメートル単位）。\n    tao_reach (int): Tao Taoが手を伸ばして届く最大の高さ（センチメートル単位）。\n\n    戻り値:\n    int: Tao Taoが30cmの踏み台を使っても使わなくても届くリンゴの数。\n\n    この関数はリンゴの高さのリストを反復処理し、踏み台が提供する追加の30cmを考慮して、\n    Tao Taoの手が届く範囲内にあるリンゴの数を数えます。\n\n    例:\n    1. Tao Taoは踏み台なしで120cmのリンゴに届き、すべてのリンゴは150cm以下にあります。\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Taoは踏み台なしで100cmのリンゴに届き、すべてのリンゴは130cm以上にあります。\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Taoは踏み台なしで110cmのリンゴに届き、いくつかのリンゴはさまざまな高さにあります。\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"", "ko": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tao Tao가 닿을 수 있는 사과의 수를 계산합니다.\n\n    매개변수:\n    apple_heights (List[int]): 땅에서부터 사과까지의 높이 (센티미터 단위).\n    tao_reach (int): Tao Tao가 손을 뻗었을 때 닿을 수 있는 최대 높이 (센티미터 단위).\n\n    반환값:\n    int: Tao Tao가 30cm 의자에 서 있거나 서 있지 않을 때 닿을 수 있는 사과의 수.\n\n    이 함수는 사과 높이 목록을 순회하며 Tao Tao가 닿을 수 있는 사과의 수를 세고,\n    의자가 제공하는 추가 30cm를 고려합니다.\n\n    예제 사례:\n    1. Tao Tao는 의자 없이 120cm 높이의 사과에 닿을 수 있으며, 모든 사과는 150cm 이하에 있습니다.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao는 의자 없이 100cm 높이의 사과에 닿을 수 있으며, 모든 사과는 130cm 이상입니다.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao는 의자 없이 110cm 높이의 사과에 닿을 수 있으며, 일부 사과는 다양한 높이에 있습니다.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"", "ml": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    ടാവോ ടാവോക്ക് എത്തിച്ചേരാൻ കഴിയുന്ന ആപ്പിളുകളുടെ എണ്ണം കണക്കാക്കുക.\n\n    Args:\n    apple_heights (List[int]): നിലത്തു നിന്ന് ആപ്പിളുകളുടെ ഉയരങ്ങൾ (സെ.മീ.യിൽ).\n    tao_reach (int): ടാവോ ടാവോക്ക് കൈ ഉയർത്തി നീട്ടി എത്തിച്ചേരാൻ കഴിയുന്ന പരമാവധി ഉയരം (സെ.മീ.യിൽ).\n\n    Returns:\n    int: ടാവോ ടാവോക്ക് 30cm സ്റ്റൂൾ ഉപയോഗിച്ച് അല്ലെങ്കിൽ ഇല്ലാതെ എത്തിച്ചേരാൻ കഴിയുന്ന ആപ്പിളുകളുടെ എണ്ണം.\n\n    ഈ ഫങ്ഷൻ ആപ്പിളുകളുടെ ഉയരങ്ങളുടെ പട്ടികയിൽ ആവർത്തിച്ച്, സ്റ്റൂൾ നൽകുന്ന 30cm അധികം പരിഗണിച്ച്, ടാവോ ടാവോയുടെ കൈവശമുള്ളവ എത്രയാണെന്ന് എണ്ണുന്നു.\n\n    ഉദാഹരണ കേസുകൾ:\n    1. ടാവോ ടാവോക്ക് സ്റ്റൂൾ ഇല്ലാതെ 120cm ഉയരത്തിലുള്ള ആപ്പിളുകൾ എത്തിച്ചേരാൻ കഴിയും, എല്ലാ ആപ്പിളുകളും 150cm അല്ലെങ്കിൽ അതിൽ താഴെയാണ്.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 10 തിരികെ നൽകുന്നു\n\n    2. ടാവോ ടാവോക്ക് സ്റ്റൂൾ ഇല്ലാതെ 100cm ഉയരത്തിലുള്ള ആപ്പിളുകൾ എത്തിച്ചേരാൻ കഴിയും, എല്ലാ ആപ്പിളുകളും 130cm-ൽ കൂടുതലാണ്.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 0 തിരികെ നൽകുന്നു\n\n    3. ടാവോ ടാവോക്ക് സ്റ്റൂൾ ഇല്ലാതെ 110cm ഉയരത്തിലുള്ള ആപ്പിളുകൾ എത്തിച്ചേരാൻ കഴിയും, ചില ആപ്പിളുകൾ വിവിധ ഉയരങ്ങളിൽ ഉണ്ട്.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> 5 തിരികെ നൽകുന്നു\n    \"\"\"", "fa": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    محاسبه تعداد سیب‌هایی که تائو تائو می‌تواند به آن‌ها برسد.\n\n    آرگومان‌ها:\n    apple_heights (List[int]): ارتفاع سیب‌ها از سطح زمین (به سانتی‌متر).\n    tao_reach (int): حداکثر ارتفاعی که تائو تائو می‌تواند با دست کشیده به بالا برسد (به سانتی‌متر).\n\n    بازگشت:\n    int: تعداد سیب‌هایی که تائو تائو می‌تواند با یا بدون ایستادن روی چهارپایه ۳۰ سانتی‌متری به آن‌ها برسد.\n\n    این تابع بر روی لیست ارتفاع سیب‌ها پیمایش کرده و تعداد سیب‌هایی را که در دسترس تائو تائو هستند،\n    با در نظر گرفتن ۳۰ سانتی‌متر اضافی که چهارپایه فراهم می‌کند، شمارش می‌کند.\n\n    مثال‌ها:\n    1. تائو تائو می‌تواند بدون چهارپایه به سیب‌های ۱۲۰ سانتی‌متری برسد و همه سیب‌ها در ارتفاع ۱۵۰ سانتی‌متر یا کمتر هستند.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. تائو تائو می‌تواند بدون چهارپایه به سیب‌های ۱۰۰ سانتی‌متری برسد و همه سیب‌ها بالای ۱۳۰ سانتی‌متر هستند.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. تائو تائو می‌تواند بدون چهارپایه به سیب‌های ۱۱۰ سانتی‌متری برسد و برخی سیب‌ها در ارتفاعات مختلف هستند.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\""}, "canonical_solution": "    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples", "instruction": {"en": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nՏրամադրել Python կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, като използвате не повече от 500 знака.", "zh": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben.", "es": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nPython kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) untuk kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\n以下のPythonコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\n다음 Python 코드에 대한 간결한 자연어 설명(독스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെയായി നൽകുക.", "fa": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "import unittest\n\nclass TestTaoTaoApplePicking(unittest.TestCase):\n    def test_count_apples_reachable(self):\n        # Test case 1: Tao Tao can reach all apples\n        apples_1 = [100, 105, 110, 115, 120, 125, 130, 135, 140, 145]\n        tao_reach_1 = 120\n        self.assertEqual(count_apples_reachable(apples_1, tao_reach_1), 10)\n\n        # Test case 2: Tao Tao can't reach any apples\n        apples_2 = [200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n        tao_reach_2 = 100\n        self.assertEqual(count_apples_reachable(apples_2, tao_reach_2), 0)\n\n        # Test case 3: Tao Tao can reach some of the apples\n        apples_3 = [160, 150, 140, 170, 180, 190, 160, 150, 145, 155]\n        tao_reach_3 = 115\n        self.assertEqual(count_apples_reachable(apples_3, tao_reach_3), 2)\n\n# To run the tests\nif __name__ == '__main__':\n    unittest.main()", "entry_point": "count_apples_reachable", "signature": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:", "docstring": {"en": "Calculate the number of apples that Tao Tao can reach.\n\nArgs:\napple_heights (List[int]): The heights of apples from the ground (in centimeters).\ntao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\nReturns:\nint: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\nThis function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\nconsidering an additional 30cm that the stool provides.\n\nExample cases:\n1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5", "sq": "Llogarit numrin e mollëve që Tao Tao mund të arrijë.\n\nArgumentet:\napple_heights (List[int]): Lartësitë e mollëve nga toka (në centimetra).\ntao_reach (int): Lartësia maksimale që Tao Tao mund të arrijë me dorën e saj të shtrirë lart (në centimetra).\n\nKthen:\nint: Numri i mollëve që Tao Tao mund të arrijë me ose pa qëndruar në një stol 30cm.\n\nKjo funksion kalon nëpër listën e lartësive të mollëve dhe numëron sa prej tyre janë brenda arritjes së Tao Tao-s,\nduke marrë parasysh një shtesë prej 30cm që ofron stoli.\n\nShembuj rastesh:\n1. Tao Tao mund të arrijë mollët në 120cm pa stol, dhe të gjitha mollët janë në 150cm ose më poshtë.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> kthen 10\n\n2. Tao Tao mund të arrijë mollët në 100cm pa stol, dhe të gjitha mollët janë mbi 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> kthen 0\n\n3. Tao Tao mund të arrijë mollët në 110cm pa stol, dhe disa mollë janë në lartësi të ndryshme.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> kthen 5", "hy": "Հաշվարկել խնձորների քանակը, որոնք կարող է հասնել Տաո Տաոն:\n\nԱրգումենտներ:\napple_heights (List[int]): Խնձորների բարձրությունները հողից (սանտիմետրերով):\ntao_reach (int): Առավելագույն բարձրությունը, որին կարող է հասնել Տաո Տաոն՝ ձեռքը վեր պարզած (սանտիմետրերով):\n\nՎերադարձնում է:\nint: Խնձորների քանակը, որոնք Տաո Տաոն կարող է հասնել՝ 30սմ աթոռի վրա կանգնած կամ առանց դրա:\n\nԱյս ֆունկցիան անցնում է խնձորների բարձրությունների ցուցակը և հաշվում, թե դրանցից քանիսն են Տաո Տաոյի հասանելիության սահմաններում՝ հաշվի առնելով աթոռի ավելացրած 30սմ-ը:\n\nՕրինակներ:\n1. Տաո Տաոն կարող է հասնել 120սմ բարձրության խնձորներին առանց աթոռի, և բոլոր խնձորները 150սմ կամ ավելի ցածր են:\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> վերադարձնում է 10\n\n2. Տաո Տաոն կարող է հասնել 100սմ բարձրության խնձորներին առանց աթոռի, և բոլոր խնձորները 130սմ-ից բարձր են:\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> վերադարձնում է 0\n\n3. Տաո Տաոն կարող է հասնել 110սմ բարձրության խնձորներին առանց աթոռի, և որոշ խնձորներ տարբեր բարձրությունների վրա են:\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> վերադարձնում է 5", "bn": "Tao Tao কতগুলি আপেল পৌঁছাতে পারে তা গণনা করুন।\n\nArgs:\napple_heights (List[int]): মাটি থেকে আপেলের উচ্চতা (সেন্টিমিটারে)।\ntao_reach (int): Tao Tao তার হাত প্রসারিত করে সর্বাধিক যে উচ্চতায় পৌঁছাতে পারে (সেন্টিমিটারে)।\n\nReturns:\nint: Tao Tao একটি 30cm স্টুলের উপর দাঁড়িয়ে বা না দাঁড়িয়ে কতগুলি আপেল পৌঁছাতে পারে।\n\nএই ফাংশনটি আপেলের উচ্চতার তালিকার উপর পুনরাবৃত্তি করে এবং কতগুলি আপেল Tao Tao-এর নাগালের মধ্যে রয়েছে তা গণনা করে,\nস্টুলটি যে অতিরিক্ত 30cm প্রদান করে তা বিবেচনা করে।\n\nউদাহরণ কেস:\n1. Tao Tao একটি স্টুল ছাড়াই 120cm উচ্চতায় আপেল পৌঁছাতে পারে, এবং সমস্ত আপেল 150cm বা তার নিচে।\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao একটি স্টুল ছাড়াই 100cm উচ্চতায় আপেল পৌঁছাতে পারে, এবং সমস্ত আপেল 130cm এর উপরে।\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao একটি স্টুল ছাড়াই 110cm উচ্চতায় আপেল পৌঁছাতে পারে, এবং কিছু আপেল বিভিন্ন উচ্চতায় রয়েছে।\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5", "bg": "Изчислете броя на ябълките, до които Тао Тао може да достигне.\n\nАргументи:\napple_heights (List[int]): Височините на ябълките от земята (в сантиметри).\ntao_reach (int): Максималната височина, до която Тао Тао може да достигне с ръка, изпъната нагоре (в сантиметри).\n\nВръща:\nint: Броят на ябълките, до които Тао Тао може да достигне със или без да стои на 30см столче.\n\nТази функция обхожда списъка с височините на ябълките и брои колко от тях са в обсега на Тао Тао,\nкато се вземат предвид допълнителните 30см, които столчето осигурява.\n\nПримерни случаи:\n1. Тао Тао може да достигне ябълки на 120см без столче, и всички ябълки са на 150см или по-ниско.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> връща 10\n\n2. Тао Тао може да достигне ябълки на 100см без столче, и всички ябълки са над 130см.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> връща 0\n\n3. Тао Тао може да достигне ябълки на 110см без столче, и някои ябълки са на различни височини.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> връща 5", "zh": "计算陶陶可以够到的苹果数量。\n\n参数：\napple_heights (List[int]): 苹果距离地面的高度（以厘米为单位）。\ntao_reach (int): 陶陶伸手向上可以达到的最大高度（以厘米为单位）。\n\n返回：\nint: 陶陶在站上30厘米高的凳子时可以够到的苹果数量。\n\n此函数遍历苹果高度列表，并计算其中有多少在陶陶的可及范围内，\n考虑到凳子提供的额外30厘米高度。\n\n示例案例：\n1. 陶陶在不使用凳子的情况下可以够到120厘米高的苹果，并且所有苹果都在150厘米或以下。\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 返回 10\n\n2. 陶陶在不使用凳子的情况下可以够到100厘米高的苹果，并且所有苹果都在130厘米以上。\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 返回 0\n\n3. 陶陶在不使用凳子的情况下可以够到110厘米高的苹果，并且一些苹果处于不同的高度。\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> 返回 5", "fr": "Calculer le nombre de pommes que Tao Tao peut atteindre.\n\nArgs:\napple_heights (List[int]): Les hauteurs des pommes par rapport au sol (en centimètres).\ntao_reach (int): La hauteur maximale que Tao Tao peut atteindre avec sa main tendue vers le haut (en centimètres).\n\nReturns:\nint: Le nombre de pommes que Tao Tao peut atteindre avec ou sans se tenir sur un tabouret de 30 cm.\n\nCette fonction parcourt la liste des hauteurs des pommes et compte combien d'entre elles sont à la portée de Tao Tao,\nen considérant un supplément de 30 cm que le tabouret fournit.\n\nExemples de cas :\n1. Tao Tao peut atteindre les pommes à 120 cm sans tabouret, et toutes les pommes sont à 150 cm ou moins.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao peut atteindre les pommes à 100 cm sans tabouret, et toutes les pommes sont au-dessus de 130 cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao peut atteindre les pommes à 110 cm sans tabouret, et certaines pommes sont à différentes hauteurs.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5", "de": "Berechne die Anzahl der Äpfel, die Tao Tao erreichen kann.\n\nArgs:\napple_heights (List[int]): Die Höhen der Äpfel vom Boden (in Zentimetern).\ntao_reach (int): Die maximale Höhe, die Tao Tao mit ausgestreckter Hand erreichen kann (in Zentimetern).\n\nReturns:\nint: Die Anzahl der Äpfel, die Tao Tao mit oder ohne einen 30cm hohen Hocker erreichen kann.\n\nDiese Funktion iteriert über die Liste der Apfelhöhen und zählt, wie viele davon innerhalb von Tao Taos Reichweite liegen,\nunter Berücksichtigung zusätzlicher 30cm, die der Hocker bietet.\n\nBeispiel Fälle:\n1. Tao Tao kann Äpfel in 120cm Höhe ohne Hocker erreichen, und alle Äpfel sind bei 150cm oder darunter.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> gibt 10 zurück\n\n2. Tao Tao kann Äpfel in 100cm Höhe ohne Hocker erreichen, und alle Äpfel sind über 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> gibt 0 zurück\n\n3. Tao Tao kann Äpfel in 110cm Höhe ohne Hocker erreichen, und einige Äpfel sind in verschiedenen Höhen.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> gibt 5 zurück", "ha": "Lissafa yawan tuffa da Tao Tao za ta iya kaiwa.\n\nArgs:\napple_heights (List[int]): Tsayin apples daga ƙasa (a cikin santimita).\ntao_reach (int): Matsakaicin tsayin da Tao Tao za ta iya kaiwa da hannunta a miƙe sama (a cikin santimita).\n\nReturns:\nint: Yawan apples da Tao Tao za ta iya kaiwa tare da ko ba tare da tsayawa a kan stool mai tsayin 30cm ba.\n\nWannan aikin yana zagayawa akan jerin tsayin apples kuma yana ƙirga nawa daga cikinsu suke cikin isar Tao Tao,\nla'akari da ƙarin 30cm da stool ke bayarwa.\n\nExample cases:\n1. Tao Tao za ta iya kaiwa apples a 120cm ba tare da stool ba, kuma duk apples suna a 150cm ko ƙasa da haka.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao za ta iya kaiwa apples a 100cm ba tare da stool ba, kuma duk apples suna sama da 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao za ta iya kaiwa apples a 110cm ba tare da stool ba, kuma wasu apples suna a tsayin daban-daban.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5", "hi": "Tao Tao कितने सेब तक पहुँच सकती है, इसकी गणना करें।\n\nआर्ग्स:\napple_heights (List[int]): जमीन से सेबों की ऊंचाई (सेंटीमीटर में)।\ntao_reach (int): अधिकतम ऊंचाई तक Tao Tao अपने हाथ को ऊपर की ओर खींच सकती है (सेंटीमीटर में)।\n\nरिटर्न्स:\nint: सेबों की संख्या जिन तक Tao Tao 30 सेमी के स्टूल पर खड़े होकर या बिना खड़े हुए पहुँच सकती है।\n\nयह फ़ंक्शन सेबों की ऊंचाई की सूची पर इटरेट करता है और गिनता है कि उनमें से कितने Tao Tao की पहुँच के भीतर हैं, \n30 सेमी का अतिरिक्त लाभ जो स्टूल प्रदान करता है, उसे ध्यान में रखते हुए।\n\nउदाहरण मामले:\n1. Tao Tao 120 सेमी पर स्टूल के बिना सेब तक पहुँच सकती है, और सभी सेब 150 सेमी या नीचे हैं।\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao 100 सेमी पर स्टूल के बिना सेब तक पहुँच सकती है, और सभी सेब 130 सेमी से ऊपर हैं।\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao 110 सेमी पर स्टूल के बिना सेब तक पहुँच सकती है, और कुछ सेब विभिन्न ऊंचाइयों पर हैं।\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5", "hu": "Számítsd ki, hány almát ér el Tao Tao.\n\nArgs:\napple_heights (List[int]): Az almák magassága a talajtól (centiméterben).\ntao_reach (int): Az a maximális magasság, amit Tao Tao elér a kezével felfelé nyújtózva (centiméterben).\n\nReturns:\nint: Az almák száma, amelyeket Tao Tao elérhet akár egy 30 cm-es zsámolyon állva, akár anélkül.\n\nEz a függvény végigmegy az alma magasságok listáján, és megszámolja, hány közülük van Tao Tao elérhetőségi tartományán belül,\nfigyelembe véve a zsámoly által biztosított további 30 cm-t.\n\nPélda esetek:\n1. Tao Tao eléri az almákat 120 cm-en zsámoly nélkül, és minden alma 150 cm-en vagy az alatt van.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> visszaadja 10\n\n2. Tao Tao eléri az almákat 100 cm-en zsámoly nélkül, és minden alma 130 cm felett van.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> visszaadja 0\n\n3. Tao Tao eléri az almákat 110 cm-en zsámoly nélkül, és néhány alma különböző magasságokban van.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> visszaadja 5", "es": "Calcular el número de manzanas que Tao Tao puede alcanzar.\n\nArgumentos:\napple_heights (List[int]): Las alturas de las manzanas desde el suelo (en centímetros).\ntao_reach (int): La altura máxima que Tao Tao puede alcanzar con su mano estirada hacia arriba (en centímetros).\n\nDevuelve:\nint: El número de manzanas que Tao Tao puede alcanzar con o sin pararse en un taburete de 30 cm.\n\nEsta función itera sobre la lista de alturas de manzanas y cuenta cuántas de ellas están al alcance de Tao Tao,\nconsiderando un adicional de 30 cm que proporciona el taburete.\n\nCasos de ejemplo:\n1. Tao Tao puede alcanzar manzanas a 120 cm sin un taburete, y todas las manzanas están a 150 cm o menos.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> Devuelve 10\n\n2. Tao Tao puede alcanzar manzanas a 100 cm sin un taburete, y todas las manzanas están por encima de 130 cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> Devuelve 0\n\n3. Tao Tao puede alcanzar manzanas a 110 cm sin un taburete, y algunas manzanas están a varias alturas.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> Devuelve 5", "arb": "احسب عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه.\n\nيعيدالحجج:\napple_heights (List[int]): ارتفاعات التفاح من الأرض (بالسنتيمترات).\ntao_reach (int): أقصى ارتفاع يمكن لـ Tao Tao الوصول إليه بيدها ممدودة إلى الأعلى (بالسنتيمترات).\n\nيعيد:\nint: عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه مع أو بدون الوقوف على كرسي بارتفاع 30 سم.\n\nتقوم هذه الدالة بتكرار قائمة ارتفاعات التفاح وتحصي عدد التفاح الذي يقع ضمن نطاق وصول Tao Tao، مع الأخذ في الاعتبار 30 سم إضافية يوفرها الكرسي.\n\nأمثلة الحالات:\n1. يمكن لـ Tao Tao الوصول إلى التفاح على ارتفاع 120 سم بدون كرسي، وجميع التفاح على ارتفاع 150 سم أو أقل.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> يعيد 10\n\n2. يمكن لـ Tao Tao الوصول إلى التفاح على ارتفاع 100 سم بدون كرسي، وجميع التفاح فوق 130 سم.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> يعيد 0\n\n3. يمكن لـ Tao Tao الوصول إلى التفاح على ارتفاع 110 سم بدون كرسي، وبعض التفاح على ارتفاعات مختلفة.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> يعيد 5", "sw": "Hesabu idadi ya maapulo ambayo Tao Tao anaweza kufikia.\n\nHoja:\napple_heights (List[int]): Urefu wa maapulo kutoka ardhini (katika sentimita).\ntao_reach (int): Urefu wa juu zaidi ambao Tao Tao anaweza kufikia kwa mkono wake ulionyoshwa juu (katika sentimita).\n\nInarejesha:\nint: Idadi ya maapulo ambayo Tao Tao anaweza kufikia akiwa amesimama au bila kusimama kwenye kigoda cha 30cm.\n\nKazi hii inazunguka orodha ya urefu wa maapulo na kuhesabu ni mangapi kati yao yako ndani ya uwezo wa kufikiwa na Tao Tao,\nikizingatia ongezeko la 30cm ambalo kigoda kinatoa.\n\nMifano ya kesi:\n1. Tao Tao anaweza kufikia maapulo kwenye 120cm bila kigoda, na maapulo yote yako kwenye 150cm au chini.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> Inarejesha 10\n\n2. Tao Tao anaweza kufikia maapulo kwenye 100cm bila kigoda, na maapulo yote yako juu ya 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> Inarejesha 0\n\n3. Tao Tao anaweza kufikia maapulo kwenye 110cm bila kigoda, na baadhi ya maapulo yako kwenye urefu mbalimbali.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> Inarejesha 5", "tr": "Tao Tao'nun ulaşabileceği elma sayısını hesaplayın.\n\nArgümanlar:\napple_heights (List[int]): Elmaların yerden yüksekliği (santimetre cinsinden).\ntao_reach (int): Tao Tao'nun elini yukarı doğru uzatarak ulaşabileceği maksimum yükseklik (santimetre cinsinden).\n\nDöndürür:\nint: Tao Tao'nun 30cm tabureye çıkmadan veya çıkarak ulaşabileceği elma sayısı.\n\nBu fonksiyon, elma yükseklikleri listesini iteratif olarak dolaşır ve bunlardan kaç tanesinin Tao Tao'nun ulaşabileceği mesafede olduğunu sayar,\ntaburenin sağladığı ek 30cm'yi dikkate alarak.\n\nÖrnek vakalar:\n1. Tao Tao, taburesiz 120cm'deki elmalara ulaşabilir ve tüm elmalar 150cm veya altında.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 10 döndürür\n\n2. Tao Tao, taburesiz 100cm'deki elmalara ulaşabilir ve tüm elmalar 130cm'nin üzerinde.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 0 döndürür\n\n3. Tao Tao, taburesiz 110cm'deki elmalara ulaşabilir ve bazı elmalar çeşitli yüksekliklerde.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> 5 döndürür", "vi": "Tính số lượng táo mà Tao Tao có thể với tới.\n\nTham số:\napple_heights (List[int]): Chiều cao của những quả táo tính từ mặt đất (đơn vị: cm).\ntao_reach (int): Chiều cao tối đa mà Tao Tao có thể với tới khi duỗi tay lên (đơn vị: cm).\n\nTrả về:\nint: Số lượng táo mà Tao Tao có thể với tới có hoặc không có đứng trên ghế đẩu cao 30cm.\n\nHàm này duyệt qua danh sách chiều cao của các quả táo và đếm xem có bao nhiêu quả nằm trong tầm với của Tao Tao,\nxét thêm 30cm mà ghế đẩu cung cấp.\n\nCác trường hợp ví dụ:\n1. Tao Tao có thể với tới những quả táo ở độ cao 120cm mà không cần ghế đẩu, và tất cả các quả táo đều ở độ cao 150cm hoặc thấp hơn.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> trả về 10\n\n2. Tao Tao có thể với tới những quả táo ở độ cao 100cm mà không cần ghế đẩu, và tất cả các quả táo đều ở trên 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> trả về 0\n\n3. Tao Tao có thể với tới những quả táo ở độ cao 110cm mà không cần ghế đẩu, và một số quả táo ở các độ cao khác nhau.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> trả về 5", "id": "Hitung jumlah apel yang dapat dijangkau oleh Tao Tao.\n\nArgs:\napple_heights (List[int]): Tinggi apel dari tanah (dalam sentimeter).\ntao_reach (int): Tinggi maksimum yang dapat dijangkau Tao Tao dengan tangan terentang ke atas (dalam sentimeter).\n\nReturns:\nint: Jumlah apel yang dapat dijangkau oleh Tao Tao dengan atau tanpa berdiri di atas bangku setinggi 30cm.\n\nFungsi ini mengiterasi daftar tinggi apel dan menghitung berapa banyak dari mereka yang berada dalam jangkauan Tao Tao,\ndengan mempertimbangkan tambahan 30cm yang disediakan oleh bangku.\n\nContoh kasus:\n1. Tao Tao dapat menjangkau apel pada 120cm tanpa bangku, dan semua apel berada pada 150cm atau di bawahnya.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao dapat menjangkau apel pada 100cm tanpa bangku, dan semua apel berada di atas 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao dapat menjangkau apel pada 110cm tanpa bangku, dan beberapa apel berada pada berbagai ketinggian.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5", "ja": "Tao Taoが届くリンゴの数を計算します。\n\nArgs:\napple_heights (List[int]): 地面からのリンゴの高さ（センチメートル単位）。\ntao_reach (int): Tao Taoが手を伸ばして届く最大の高さ（センチメートル単位）。\n\nReturns:\nint: Tao Taoが30cmの踏み台を使うか使わないかで届くリンゴの数。\n\nこの関数はリンゴの高さのリストを反復処理し、踏み台が提供する追加の30cmを考慮して、Tao Taoの手の届く範囲にあるリンゴの数を数えます。\n\n例:\n1. Tao Taoは踏み台なしで120cmのリンゴに届くことができ、すべてのリンゴは150cm以下にあります。\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Taoは踏み台なしで100cmのリンゴに届くことができ、すべてのリンゴは130cm以上にあります。\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Taoは踏み台なしで110cmのリンゴに届くことができ、いくつかのリンゴはさまざまな高さにあります。\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5", "ko": "Tao Tao가 닿을 수 있는 사과의 수를 계산합니다.\n\nArgs:\napple_heights (List[int]): 땅에서부터 사과의 높이 (센티미터 단위).\ntao_reach (int): Tao Tao가 손을 뻗었을 때 닿을 수 있는 최대 높이 (센티미터 단위).\n\nReturns:\nint: Tao Tao가 30cm 의자에 서 있거나 서 있지 않을 때 닿을 수 있는 사과의 수.\n\n이 함수는 사과 높이 목록을 반복하여 Tao Tao의 손이 닿을 수 있는 사과가 몇 개인지 세며,\n의자가 제공하는 추가 30cm를 고려합니다.\n\n예제 사례:\n1. Tao Tao는 의자 없이 120cm 높이의 사과에 닿을 수 있으며, 모든 사과는 150cm 이하에 있습니다.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao는 의자 없이 100cm 높이의 사과에 닿을 수 있으며, 모든 사과는 130cm 이상입니다.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao는 의자 없이 110cm 높이의 사과에 닿을 수 있으며, 일부 사과는 다양한 높이에 있습니다.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5", "ml": "Tao Tao എത്ര ആപ്പിളുകൾക്ക് എത്തിച്ചേരാൻ കഴിയും എന്ന് കണക്കാക്കുക.\n\nArgs:\napple_heights (List[int]): നിലത്ത് നിന്ന് ആപ്പിളുകളുടെ ഉയരങ്ങൾ (സെ.മീ.യിൽ).\ntao_reach (int): Tao Tao കൈ നീട്ടി ഉയർത്തുമ്പോൾ എത്തിച്ചേരാൻ കഴിയുന്ന പരമാവധി ഉയരം (സെ.മീ.യിൽ).\n\nReturns:\nint: Tao Taoക്ക് 30cm സ്റ്റൂൾ ഉപയോഗിച്ച് അല്ലാതെയും എത്തിച്ചേരാൻ കഴിയുന്ന ആപ്പിളുകളുടെ എണ്ണം.\n\nഈ ഫംഗ്ഷൻ ആപ്പിളുകളുടെ ഉയരങ്ങളുടെ പട്ടികയിൽ ആവർത്തിച്ച് അവയിൽ എത്ര എണ്ണം Tao Taoയുടെ എത്തിപ്പിടിയിലാണെന്ന് എണ്ണുന്നു,\nസ്റ്റൂൾ നൽകുന്ന അധിക 30cm പരിഗണിച്ചുകൊണ്ട്.\n\nഉദാഹരണ കേസുകൾ:\n1. Tao Taoക്ക് 120cm-ൽ സ്റ്റൂൾ ഇല്ലാതെ ആപ്പിളുകൾക്ക് എത്തിച്ചേരാം, എല്ലാ ആപ്പിളുകളും 150cm അല്ലെങ്കിൽ അതിൽ താഴെയാണ്.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Taoക്ക് 100cm-ൽ സ്റ്റൂൾ ഇല്ലാതെ ആപ്പിളുകൾക്ക് എത്തിച്ചേരാം, എല്ലാ ആപ്പിളുകളും 130cm-ൽ കൂടുതലാണ്.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Taoക്ക് 110cm-ൽ സ്റ്റൂൾ ഇല്ലാതെ ആപ്പിളുകൾക്ക് എത്തിച്ചേരാം, ചില ആപ്പിളുകൾ വിവിധ ഉയരങ്ങളിൽ ഉണ്ട്.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5", "fa": "تعداد سیب‌هایی که تائو تائو می‌تواند به آن‌ها برسد را محاسبه کنید.\n\nپارامترها:\napple_heights (List[int]): ارتفاع سیب‌ها از زمین (به سانتی‌متر).\ntao_reach (int): حداکثر ارتفاعی که تائو تائو می‌تواند با دست کشیده به بالا برسد (به سانتی‌متر).\n\nبازگشت:\nint: تعداد سیب‌هایی که تائو تائو می‌تواند با یا بدون ایستادن روی یک چهارپایه ۳۰ سانتی‌متری به آن‌ها برسد.\n\nاین تابع بر روی لیست ارتفاع سیب‌ها تکرار می‌شود و تعداد سیب‌هایی که در دسترس تائو تائو هستند را می‌شمارد،\nبا در نظر گرفتن ۳۰ سانتی‌متر اضافی که چهارپایه فراهم می‌کند.\n\nموارد مثال:\n1. تائو تائو می‌تواند به سیب‌هایی در ارتفاع ۱۲۰ سانتی‌متر بدون چهارپایه برسد، و همه سیب‌ها در ارتفاع ۱۵۰ سانتی‌متر یا کمتر هستند.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. تائو تائو می‌تواند به سیب‌هایی در ارتفاع ۱۰۰ سانتی‌متر بدون چهارپایه برسد، و همه سیب‌ها در ارتفاع بالای ۱۳۰ سانتی‌متر هستند.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. تائو تائو می‌تواند به سیب‌هایی در ارتفاع ۱۱۰ سانتی‌متر بدون چهارپایه برسد، و برخی از سیب‌ها در ارتفاعات مختلف هستند.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5"}}
{"task_id": "Python/36", "prompt": {"en": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\n      and 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\n      and at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\n      are cleared, leaving trees at positions 0 to 9 and 91 to 100.\n    \"\"\"", "sq": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit numrin e pemëve të mbetura përgjatë një rruge pasi zonat specifike janë pastruar.\n\n    Rruga përfaqësohet si një vijë e drejtë me gjatësi 'l' dhe fillimisht është e mbushur me pemë.\n    Çdo zonë e planifikuar për pastrim specifikohet si një çift numrash të plotë (fillimi, fundi), që përfaqëson\n    intervalin përfshirës përgjatë rrugës ku pemët do të hiqen.\n\n    Argumentet:\n    - l (int): Gjatësia e rrugës.\n    - areas (List[Tuple[int, int]]): Një listë e çifteve ku çdo çift përfaqëson një zonë të pastruar në rrugë.\n    \n    Kthen:\n    - int: Numri total i pemëve të mbetura përgjatë rrugës pasi zonat e specifikuara janë pastruar.\n    \n    Shembuj:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) do të kthejë 5, pasi pemët nga pozicionet 2 deri 5\n      dhe 7 deri 9 janë pastruar, duke lënë pemët në pozicionet 0, 1, 6, dhe 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) do të kthejë 3, pasi pemët nga pozicionet 1 deri 3\n      dhe në pozicionin 4 janë pastruar, duke lënë pemët në pozicionet 0, 5, dhe 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) do të kthejë 20, pasi pemët nga pozicionet 10 deri 90\n      janë pastruar, duke lënë pemët në pozicionet 0 deri 9 dhe 91 deri 100.\n    \"\"\"", "hy": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվել ճանապարհի երկայնքով մնացած ծառերի քանակը այն բանից հետո, երբ որոշակի տարածքներ մաքրվել են:\n\n    Ճանապարհը ներկայացված է որպես ուղիղ գիծ՝ 'l' երկարությամբ և սկզբում լցված է ծառերով:\n    Յուրաքանչյուր մաքրման համար նախատեսված տարածք նշված է ամբողջ թվերի զույգով (սկիզբ, վերջ), որը\n    ներկայացնում է ճանապարհի երկայնքով ներառական միջակայքը, որտեղ ծառերը կհեռացվեն:\n\n    Պարամետրեր:\n    - l (int): Ճանապարհի երկարությունը:\n    - areas (List[Tuple[int, int]]): Զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ ներկայացնում է ճանապարհի մաքրված տարածք:\n    \n    Վերադարձնում է:\n    - int: Ճանապարհի երկայնքով մնացած ծառերի ընդհանուր քանակը այն բանից հետո, երբ նշված տարածքները մաքրվել են:\n    \n    Օրինակներ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) կվերադարձնի 5, քանի որ 2-ից 5 և 7-ից 9 դիրքերում գտնվող ծառերը\n      մաքրվում են, թողնելով ծառեր 0, 1, 6 և 10 դիրքերում:\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) կվերադարձնի 3, քանի որ 1-ից 3 և 4 դիրքերում գտնվող ծառերը\n      մաքրվում են, թողնելով ծառեր 0, 5 և 6 դիրքերում:\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) կվերադարձնի 20, քանի որ 10-ից 90 դիրքերում գտնվող ծառերը\n      մաքրվում են, թողնելով ծառեր 0-ից 9 և 91-ից 100 դիրքերում:\n    \"\"\"", "bn": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    একটি রাস্তার পাশে নির্দিষ্ট এলাকা পরিষ্কার করার পর অবশিষ্ট গাছের সংখ্যা গণনা করুন।\n\n    রাস্তা একটি সরল রেখা হিসাবে 'l' দৈর্ঘ্যের প্রতিনিধিত্ব করে এবং প্রাথমিকভাবে গাছ দ্বারা পূর্ণ।\n    প্রতিটি নির্ধারিত পরিষ্কার এলাকা দুটি পূর্ণসংখ্যার জোড়া (শুরু, শেষ) হিসাবে নির্দিষ্ট করা হয়,\n    যা রাস্তার সেই অন্তর্ভুক্ত পরিসরকে উপস্থাপন করে যেখানে গাছগুলি সরানো হবে।\n\n    আর্গুমেন্টসমূহ:\n    - l (int): রাস্তার দৈর্ঘ্য।\n    - areas (List[Tuple[int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপল রাস্তার একটি পরিষ্কার এলাকা উপস্থাপন করে।\n    \n    রিটার্ন:\n    - int: নির্দিষ্ট এলাকা পরিষ্কার করার পর রাস্তার পাশে অবশিষ্ট গাছের মোট সংখ্যা।\n    \n    উদাহরণ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 রিটার্ন করবে, কারণ অবস্থান 2 থেকে 5\n      এবং 7 থেকে 9 পর্যন্ত গাছ পরিষ্কার করা হয়, অবস্থান 0, 1, 6, এবং 10 এ গাছ অবশিষ্ট থাকে।\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 রিটার্ন করবে, কারণ অবস্থান 1 থেকে 3\n      এবং অবস্থান 4 এ গাছ পরিষ্কার করা হয়, অবস্থান 0, 5, এবং 6 এ গাছ অবশিষ্ট থাকে।\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 রিটার্ন করবে, কারণ অবস্থান 10 থেকে 90\n      পর্যন্ত গাছ পরিষ্কার করা হয়, অবস্থান 0 থেকে 9 এবং 91 থেকে 100 এ গাছ অবশিষ্ট থাকে।\n    \"\"\"", "bg": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислява броя на останалите дървета по пътя след като определени зони са били изчистени.\n\n    Пътят е представен като права линия с дължина 'l' и първоначално е запълнен с дървета.\n    Всяка зона, планирана за изчистване, е посочена като двойка от цели числа (начало, край), представляващи\n    включителния диапазон по пътя, където дърветата ще бъдат премахнати.\n\n    Аргументи:\n    - l (int): Дължината на пътя.\n    - areas (List[Tuple[int, int]]): Списък от двойки, където всяка двойка представлява изчистена зона на пътя.\n    \n    Връща:\n    - int: Общият брой на останалите дървета по пътя след като определените зони са били изчистени.\n    \n    Примери:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ще върне 5, тъй като дърветата от позиции 2 до 5\n      и 7 до 9 са изчистени, оставяйки дървета на позиции 0, 1, 6 и 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) ще върне 3, тъй като дърветата от позиции 1 до 3\n      и на позиция 4 са изчистени, оставяйки дървета на позиции 0, 5 и 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ще върне 20, тъй като дърветата от позиции 10 до 90\n      са изчистени, оставяйки дървета на позиции 0 до 9 и 91 до 100.\n    \"\"\"", "zh": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在特定区域被清除后，沿道路剩余的树木数量。\n\n    道路表示为长度为 'l' 的直线，最初被树木填满。\n    每个计划清除的区域由一对整数 (start, end) 指定，表示将要移除树木的道路上的包含范围。\n\n    参数:\n    - l (int): 道路的长度。\n    - areas (List[Tuple[int, int]]): 一个元组列表，每个元组代表道路上的一个清除区域。\n    \n    返回:\n    - int: 指定区域被清除后，沿道路剩余的树木总数。\n    \n    示例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5，因为位置 2 到 5 和 7 到 9 的树被清除，剩下位置 0, 1, 6 和 10 的树。\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 将返回 3，因为位置 1 到 3 和位置 4 的树被清除，剩下位置 0, 5 和 6 的树。\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20，因为位置 10 到 90 的树被清除，剩下位置 0 到 9 和 91 到 100 的树。\n    \"\"\"", "fr": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculer le nombre d'arbres restants le long d'une route après que des zones spécifiques ont été défrichées.\n\n    La route est représentée comme une ligne droite de longueur 'l' et est initialement remplie d'arbres.\n    Chaque zone prévue pour le défrichage est spécifiée comme une paire d'entiers (début, fin), représentant\n    la plage inclusive le long de la route où les arbres seront enlevés.\n\n    Args:\n    - l (int) : La longueur de la route.\n    - areas (List[Tuple[int, int]]) : Une liste de tuples où chaque tuple représente une zone défrichée sur la route.\n    \n    Returns:\n    - int : Le nombre total d'arbres restants le long de la route après que les zones spécifiées ont été défrichées.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) renverra 5, car les arbres des positions 2 à 5\n      et 7 à 9 sont défrichés, laissant des arbres aux positions 0, 1, 6 et 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) renverra 3, car les arbres des positions 1 à 3\n      et à la position 4 sont défrichés, laissant des arbres aux positions 0, 5 et 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) renverra 20, car les arbres des positions 10 à 90\n      sont défrichés, laissant des arbres aux positions 0 à 9 et 91 à 100.\n    \"\"\"", "de": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechne die Anzahl der verbleibenden Bäume entlang einer Straße, nachdem bestimmte Bereiche gerodet wurden.\n\n    Die Straße wird als gerade Linie der Länge 'l' dargestellt und ist zunächst mit Bäumen gefüllt.\n    Jeder zur Rodung vorgesehene Bereich wird als Paar von ganzen Zahlen (Start, Ende) angegeben, \n    das den inklusiven Bereich entlang der Straße darstellt, in dem die Bäume entfernt werden.\n\n    Argumente:\n    - l (int): Die Länge der Straße.\n    - areas (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel einen gerodeten Bereich auf der Straße darstellt.\n    \n    Rückgabewert:\n    - int: Die Gesamtanzahl der verbleibenden Bäume entlang der Straße, nachdem die angegebenen Bereiche gerodet wurden.\n    \n    Beispiele:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) gibt 5 zurück, da Bäume von den Positionen 2 bis 5\n      und 7 bis 9 gerodet werden, wodurch Bäume an den Positionen 0, 1, 6 und 10 verbleiben.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) gibt 3 zurück, da Bäume von den Positionen 1 bis 3\n      und an Position 4 gerodet werden, wodurch Bäume an den Positionen 0, 5 und 6 verbleiben.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) gibt 20 zurück, da Bäume von den Positionen 10 bis 90\n      gerodet werden, wodurch Bäume an den Positionen 0 bis 9 und 91 bis 100 verbleiben.\n    \"\"\"", "ha": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafi adadin bishiyoyin da suka rage a gefen hanya bayan an share wasu wurare.\n\n    Hanyar tana wakiltar layi madaidaici mai tsawon 'l' kuma a farko cike take da bishiyoyi.\n    Kowanne yanki da aka shirya sharewa an bayyana shi azaman ma'aurata na lambobi (farko, ƙarshe), wanda ke wakiltar\n    kewayon da aka haɗa a gefen hanya inda za a cire bishiyoyin.\n\n    Args:\n    - l (int): Tsawon hanyar.\n    - areas (List[Tuple[int, int]]): Jerin ma'aurata inda kowanne ma'aurata ke wakiltar yankin da aka share a kan hanya.\n    \n    Returns:\n    - int: Jimillar adadin bishiyoyin da suka rage a gefen hanya bayan an share wuraren da aka bayyana.\n    \n    Misalai:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) zai dawo da 5, domin an share bishiyoyi daga wurare 2 zuwa 5\n      da 7 zuwa 9, suna barin bishiyoyi a wurare 0, 1, 6, da 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) zai dawo da 3, domin an share bishiyoyi daga wurare 1 zuwa 3\n      da a wurin 4, suna barin bishiyoyi a wurare 0, 5, da 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) zai dawo da 20, domin an share bishiyoyi daga wurare 10 zuwa 90\n      suna barin bishiyoyi a wurare 0 zuwa 9 da 91 zuwa 100.\n    \"\"\"", "hi": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    एक सड़क के साथ शेष पेड़ों की संख्या की गणना करें जब विशिष्ट क्षेत्रों को साफ़ कर दिया गया हो।\n\n    सड़क को 'l' लंबाई की एक सीधी रेखा के रूप में दर्शाया गया है और यह प्रारंभ में पेड़ों से भरी होती है।\n    प्रत्येक क्षेत्र जिसे साफ़ करने के लिए निर्धारित किया गया है, को पूर्णांक (start, end) की एक जोड़ी के रूप में निर्दिष्ट किया गया है,\n    जो सड़क के साथ समावेशी सीमा का प्रतिनिधित्व करता है जहाँ पेड़ हटा दिए जाएंगे।\n\n    तर्क:\n    - l (int): सड़क की लंबाई।\n    - areas (List[Tuple[int, int]]): ट्यूपल की एक सूची जहाँ प्रत्येक ट्यूपल सड़क पर साफ़ किए गए क्षेत्र का प्रतिनिधित्व करता है।\n    \n    लौटाता है:\n    - int: कुल शेष पेड़ों की संख्या जो निर्दिष्ट क्षेत्रों को साफ़ करने के बाद सड़क के साथ बची है।\n    \n    उदाहरण:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 लौटाएगा, क्योंकि स्थिति 2 से 5 और 7 से 9 तक के पेड़ साफ़ कर दिए गए हैं,\n      जिससे स्थिति 0, 1, 6, और 10 पर पेड़ बचे हैं।\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 लौटाएगा, क्योंकि स्थिति 1 से 3 और स्थिति 4 पर पेड़ साफ़ कर दिए गए हैं,\n      जिससे स्थिति 0, 5, और 6 पर पेड़ बचे हैं।\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 लौटाएगा, क्योंकि स्थिति 10 से 90 तक के पेड़ साफ़ कर दिए गए हैं,\n      जिससे स्थिति 0 से 9 और 91 से 100 पर पेड़ बचे हैं।\n    \"\"\"", "hu": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Számítsa ki a megmaradt fák számát egy út mentén, miután meghatározott területeket kiirtottak.\n\n    Az út egy egyenes vonalként van ábrázolva, amelynek hossza 'l', és kezdetben fákkal van tele.\n    Minden irtásra tervezett területet egy (kezdő, vég) egész szám párként adnak meg, amely az út\n    mentén azt a tartományt jelöli, ahol a fákat eltávolítják.\n\n    Argumentumok:\n    - l (int): Az út hossza.\n    - areas (List[Tuple[int, int]]): Egy listája a pároknak, ahol minden pár egy irtott területet jelöl az úton.\n    \n    Visszatérési érték:\n    - int: Az út mentén megmaradt fák teljes száma a meghatározott területek kiirtása után.\n    \n    Példák:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) visszaadja az 5-öt, mivel a 2-től 5-ig\n      és 7-től 9-ig terjedő pozíciók fái ki vannak irtva, így a 0, 1, 6 és 10 pozíciókon maradnak fák.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) visszaadja a 3-at, mivel az 1-től 3-ig\n      és a 4-es pozíció fái ki vannak irtva, így a 0, 5 és 6 pozíciókon maradnak fák.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) visszaadja a 20-at, mivel a 10-től 90-ig\n      terjedő pozíciók fái ki vannak irtva, így a 0-tól 9-ig és 91-től 100-ig terjedő pozíciókon maradnak fák.\n    \"\"\"", "es": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcular el número de árboles restantes a lo largo de una carretera después de que se hayan despejado áreas específicas.\n\n    La carretera se representa como una línea recta de longitud 'l' y está inicialmente llena de árboles.\n    Cada área programada para despejarse se especifica como un par de enteros (inicio, fin), que representa\n    el rango inclusivo a lo largo de la carretera donde se eliminarán los árboles.\n\n    Argumentos:\n    - l (int): La longitud de la carretera.\n    - areas (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla representa un área despejada en la carretera.\n    \n    Devuelve:\n    - int: El número total de árboles restantes a lo largo de la carretera después de que se hayan despejado las áreas especificadas.\n    \n    Ejemplos:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) devolverá 5, ya que los árboles desde las posiciones 2 a 5\n      y de 7 a 9 se despejan, dejando árboles en las posiciones 0, 1, 6 y 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) devolverá 3, ya que los árboles desde las posiciones 1 a 3\n      y en la posición 4 se despejan, dejando árboles en las posiciones 0, 5 y 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) devolverá 20, ya que los árboles desde las posiciones 10 a 90\n      se despejan, dejando árboles en las posiciones 0 a 9 y 91 a 100.\n    \"\"\"", "arb": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    حساب عدد الأشجار المتبقية على طول الطريق بعد إزالة مناطق محددة.\n\n    يتم تمثيل الطريق كخط مستقيم بطول 'l' ومليء بالأشجار في البداية.\n    يتم تحديد كل منطقة مجدولة للإزالة كزوج من الأعداد الصحيحة (البداية، النهاية)،\n    ويمثل النطاق الشامل على طول الطريق حيث سيتم إزالة الأشجار.\n\n    يعيدالحجج:\n    - l (int): طول الطريق.\n    - areas (List[Tuple[int, int]]): قائمة من الأزواج حيث يمثل كل زوج منطقة تمت إزالتها على الطريق.\n    \n    يعيد:\n    - int: العدد الإجمالي للأشجار المتبقية على طول الطريق بعد إزالة المناطق المحددة.\n    \n    أمثلة:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) سيعيد 5، حيث يتم إزالة الأشجار من المواقع 2 إلى 5\n      و7 إلى 9، تاركًا الأشجار في المواقع 0، 1، 6، و10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) سيعيد 3، حيث يتم إزالة الأشجار من المواقع 1 إلى 3\n      وفي الموقع 4، تاركًا الأشجار في المواقع 0، 5، و6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) سيعيد 20، حيث يتم إزالة الأشجار من المواقع 10 إلى 90\n      تاركًا الأشجار في المواقع 0 إلى 9 و91 إلى 100.\n    \"\"\"", "sw": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Kuhesabu idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\n    Barabara inawakilishwa kama mstari wa moja kwa moja wa urefu 'l' na awali imejaa miti.\n    Kila eneo lililopangwa kusafishwa limeainishwa kama jozi ya nambari (mwanzo, mwisho), inayowakilisha\n    safu ya pamoja kando ya barabara ambapo miti itaondolewa.\n\n    Hoja:\n    - l (int): Urefu wa barabara.\n    - areas (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi inawakilisha eneo lililosafishwa kwenye barabara.\n    \n    Inarejesha:\n    - int: Jumla ya idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n    \n    Mifano:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) itarudisha 5, kwani miti kutoka nafasi 2 hadi 5\n      na 7 hadi 9 imesafishwa, ikiacha miti katika nafasi 0, 1, 6, na 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) itarudisha 3, kwani miti kutoka nafasi 1 hadi 3\n      na katika nafasi 4 imesafishwa, ikiacha miti katika nafasi 0, 5, na 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) itarudisha 20, kwani miti kutoka nafasi 10 hadi 90\n      imesafishwa, ikiacha miti katika nafasi 0 hadi 9 na 91 hadi 100.\n    \"\"\"", "tr": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli alanlar temizlendikten sonra yol boyunca kalan ağaçların sayısını hesaplayın.\n\n    Yol, uzunluğu 'l' olan düz bir çizgi olarak temsil edilir ve başlangıçta ağaçlarla doludur.\n    Temizlenmesi planlanan her alan, yol boyunca ağaçların kaldırılacağı kapsayıcı aralığı temsil eden\n    bir çift tam sayı (başlangıç, bitiş) olarak belirtilir.\n\n    Argümanlar:\n    - l (int): Yolun uzunluğu.\n    - areas (List[Tuple[int, int]]): Her bir çiftin yoldaki temizlenmiş bir alanı temsil ettiği bir demet listesi.\n    \n    Döndürür:\n    - int: Belirtilen alanlar temizlendikten sonra yol boyunca kalan toplam ağaç sayısı.\n    \n    Örnekler:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 döndürecektir, çünkü 2 ile 5 arasındaki\n      ve 7 ile 9 arasındaki pozisyonlardaki ağaçlar temizlenir, 0, 1, 6 ve 10 pozisyonlarında ağaçlar kalır.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 döndürecektir, çünkü 1 ile 3 arasındaki\n      ve 4 pozisyonundaki ağaçlar temizlenir, 0, 5 ve 6 pozisyonlarında ağaçlar kalır.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 döndürecektir, çünkü 10 ile 90 arasındaki\n      pozisyonlardaki ağaçlar temizlenir, 0 ile 9 ve 91 ile 100 arasındaki pozisyonlarda ağaçlar kalır.\n    \"\"\"", "vi": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính số lượng cây còn lại dọc theo một con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n\n    Con đường được biểu diễn như một đường thẳng có độ dài 'l' và ban đầu được lấp đầy bằng cây.\n    Mỗi khu vực dự kiến dọn dẹp được chỉ định như một cặp số nguyên (bắt đầu, kết thúc), đại diện cho\n    phạm vi bao gồm dọc theo con đường nơi cây sẽ bị loại bỏ.\n\n    Tham số:\n    - l (int): Độ dài của con đường.\n    - areas (List[Tuple[int, int]]): Một danh sách các cặp số nguyên, mỗi cặp đại diện cho một khu vực đã dọn dẹp trên con đường.\n    \n    Trả về:\n    - int: Tổng số cây còn lại dọc theo con đường sau khi các khu vực đã được dọn dẹp.\n    \n    Ví dụ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) sẽ trả về 5, vì cây từ vị trí 2 đến 5\n      và 7 đến 9 bị dọn dẹp, để lại cây ở vị trí 0, 1, 6, và 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) sẽ trả về 3, vì cây từ vị trí 1 đến 3\n      và tại vị trí 4 bị dọn dẹp, để lại cây ở vị trí 0, 5, và 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) sẽ trả về 20, vì cây từ vị trí 10 đến 90\n      bị dọn dẹp, để lại cây ở vị trí 0 đến 9 và 91 đến 100.\n    \"\"\"", "id": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Menghitung jumlah pohon yang tersisa di sepanjang jalan setelah area tertentu dibersihkan.\n\n    Jalan tersebut direpresentasikan sebagai garis lurus dengan panjang 'l' dan awalnya dipenuhi dengan pohon.\n    Setiap area yang dijadwalkan untuk dibersihkan ditentukan sebagai pasangan bilangan bulat (mulai, akhir), \n    yang mewakili rentang inklusif di sepanjang jalan di mana pohon akan dihilangkan.\n\n    Argumen:\n    - l (int): Panjang jalan.\n    - areas (List[Tuple[int, int]]): Daftar tuple di mana setiap tuple mewakili area yang dibersihkan di jalan.\n    \n    Mengembalikan:\n    - int: Total jumlah pohon yang tersisa di sepanjang jalan setelah area yang ditentukan dibersihkan.\n    \n    Contoh:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) akan mengembalikan 5, karena pohon dari posisi 2 hingga 5\n      dan 7 hingga 9 dibersihkan, menyisakan pohon di posisi 0, 1, 6, dan 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) akan mengembalikan 3, karena pohon dari posisi 1 hingga 3\n      dan di posisi 4 dibersihkan, menyisakan pohon di posisi 0, 5, dan 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) akan mengembalikan 20, karena pohon dari posisi 10 hingga 90\n      dibersihkan, menyisakan pohon di posisi 0 hingga 9 dan 91 hingga 100.\n    \"\"\"", "ja": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    特定のエリアが伐採された後に道路沿いに残る木の数を計算します。\n\n    道路は長さ 'l' の直線として表され、最初は木で満たされています。\n    伐採が予定されている各エリアは、道路に沿って木が除去される範囲を表す整数のペア (start, end) として指定されます。\n\n    引数:\n    - l (int): 道路の長さ。\n    - areas (List[Tuple[int, int]]): 各タプルが道路上の伐採エリアを表すタプルのリスト。\n    \n    戻り値:\n    - int: 指定されたエリアが伐採された後に道路沿いに残る木の総数。\n    \n    例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) は 5 を返します。位置 2 から 5 と 7 から 9 の木が伐採され、\n      位置 0, 1, 6, および 10 に木が残ります。\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) は 3 を返します。位置 1 から 3 と位置 4 の木が伐採され、\n      位置 0, 5, および 6 に木が残ります。\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) は 20 を返します。位置 10 から 90 の木が伐採され、\n      位置 0 から 9 および 91 から 100 に木が残ります。\n    \"\"\"", "ko": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    특정 구역이 제거된 후 도로를 따라 남아 있는 나무의 수를 계산합니다.\n\n    도로는 길이 'l'로 표현되는 직선이며 처음에는 나무로 가득 차 있습니다.\n    제거할 예정인 각 구역은 (start, end)로 지정된 정수 쌍으로, 나무가 제거될 도로를 따라 포함된 범위를 나타냅니다.\n\n    매개변수:\n    - l (int): 도로의 길이.\n    - areas (List[Tuple[int, int]]): 각 튜플이 도로의 제거된 구역을 나타내는 튜플 목록.\n    \n    반환값:\n    - int: 지정된 구역이 제거된 후 도로를 따라 남아 있는 나무의 총 수.\n    \n    예시:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)])는 5를 반환합니다. 위치 2에서 5까지와\n      7에서 9까지의 나무가 제거되어 위치 0, 1, 6, 10에 나무가 남습니다.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)])는 3을 반환합니다. 위치 1에서 3까지와\n      위치 4의 나무가 제거되어 위치 0, 5, 6에 나무가 남습니다.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)])는 20을 반환합니다. 위치 10에서 90까지의\n      나무가 제거되어 위치 0에서 9와 91에서 100에 나무가 남습니다.\n    \"\"\"", "ml": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    പ്രത്യേക പ്രദേശങ്ങൾ മുറിച്ചുമാറ്റിയതിന് ശേഷം ഒരു റോഡിനൊപ്പം ബാക്കി വരുന്ന മരങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n\n    റോഡ് 'l' നീളമുള്ള ഒരു നേരിയ രേഖയായി പ്രതിനിധീകരിക്കപ്പെടുന്നു, തുടക്കത്തിൽ മരങ്ങൾ നിറഞ്ഞിരിക്കുന്നു.\n    മുറിച്ചുമാറ്റാൻ നിശ്ചയിച്ചിരിക്കുന്ന ഓരോ പ്രദേശവും (ആരംഭം, അവസാനം) എന്ന രണ്ട് പൂർണ്ണസംഖ്യകളുടെ ജോഡിയായി വ്യക്തമാക്കപ്പെടുന്നു,\n    ഇവ റോഡിനൊപ്പം മരങ്ങൾ നീക്കംചെയ്യുന്ന ഉൾപ്പെടുന്ന പരിധി പ്രതിനിധീകരിക്കുന്നു.\n\n    Args:\n    - l (int): റോഡിന്റെ നീളം.\n    - areas (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും റോഡിലെ മുറിച്ചുമാറ്റിയ പ്രദേശത്തെ പ്രതിനിധീകരിക്കുന്ന ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    Returns:\n    - int: നിശ്ചയിച്ച പ്രദേശങ്ങൾ മുറിച്ചുമാറ്റിയതിന് ശേഷം റോഡിനൊപ്പം ബാക്കി വരുന്ന മൊത്തം മരങ്ങളുടെ എണ്ണം.\n    \n    ഉദാഹരണങ്ങൾ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5നെ മടക്കിനൽകും, കാരണം 2 മുതൽ 5 വരെയും\n      7 മുതൽ 9 വരെയും സ്ഥിതിചെയ്യുന്ന മരങ്ങൾ മുറിച്ചുമാറ്റിയതിനാൽ, 0, 1, 6, 10 സ്ഥാനങ്ങളിലെ മരങ്ങൾ ബാക്കി നിൽക്കും.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3നെ മടക്കിനൽകും, കാരണം 1 മുതൽ 3 വരെയും\n      4 സ്ഥാനത്തും സ്ഥിതിചെയ്യുന്ന മരങ്ങൾ മുറിച്ചുമാറ്റിയതിനാൽ, 0, 5, 6 സ്ഥാനങ്ങളിലെ മരങ്ങൾ ബാക്കി നിൽക്കും.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20നെ മടക്കിനൽകും, കാരണം 10 മുതൽ 90 വരെയുള്ള\n      സ്ഥിതിചെയ്യുന്ന മരങ്ങൾ മുറിച്ചുമാറ്റിയതിനാൽ, 0 മുതൽ 9 വരെയും 91 മുതൽ 100 വരെയും സ്ഥിതിചെയ്യുന്ന മരങ്ങൾ ബാക്കി നിൽക്കും.\n    \"\"\"", "fa": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    محاسبه تعداد درختان باقی‌مانده در طول یک جاده پس از پاکسازی مناطق خاص.\n\n    جاده به صورت یک خط مستقیم به طول 'l' نمایش داده می‌شود و در ابتدا با درختان پر شده است.\n    هر منطقه‌ای که برای پاکسازی برنامه‌ریزی شده است به عنوان یک جفت عدد صحیح (شروع، پایان) مشخص می‌شود،\n    که محدوده شامل در طول جاده را نشان می‌دهد که درختان در آنجا حذف خواهند شد.\n\n    آرگومان‌ها:\n    - l (int): طول جاده.\n    - areas (List[Tuple[int, int]]): لیستی از زوج‌ها که هر زوج نمایانگر یک منطقه پاکسازی شده در جاده است.\n    \n    بازگشت:\n    - int: تعداد کل درختان باقی‌مانده در طول جاده پس از پاکسازی مناطق مشخص شده.\n    \n    مثال‌ها:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) مقدار 5 را برمی‌گرداند، زیرا درختان از موقعیت‌های 2 تا 5\n      و 7 تا 9 پاکسازی می‌شوند، و درختان در موقعیت‌های 0، 1، 6، و 10 باقی می‌مانند.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) مقدار 3 را برمی‌گرداند، زیرا درختان از موقعیت‌های 1 تا 3\n      و در موقعیت 4 پاکسازی می‌شوند، و درختان در موقعیت‌های 0، 5، و 6 باقی می‌مانند.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) مقدار 20 را برمی‌گرداند، زیرا درختان از موقعیت‌های 10 تا 90\n      پاکسازی می‌شوند، و درختان در موقعیت‌های 0 تا 9 و 91 تا 100 باقی می‌مانند.\n    \"\"\""}, "canonical_solution": "    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees", "instruction": {"en": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nՏվեք Python կոդի հակիրճ բնութագրական նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, като използвате не повече от 500 знака.", "zh": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kawai.", "hi": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\n以下のPythonコードの自然言語による説明（ドックストリング）を、日本語で500文字以内で簡潔に提供してください。", "ko": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\n다음 Python 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nപൈതൺ കോഡിന്റെ സംക്ഷിപ്തമായ പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടാതെ നൽകുക.", "fa": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_remaining_trees_after_clearing():\n    test_cases = [\n        (500, [(150, 300), (100, 200), (470, 471)], 298),\n        (1000, [(0, 100), (200, 300), (400, 500), (600, 700), (800, 900)], 496),\n        (10, [(3, 4), (7, 9)], 6),\n    ]\n\n    for i, (l, areas, expected) in enumerate(test_cases, 1):\n        result = remaining_trees_after_clearing(l, areas)\n        assert result == expected, f\"Test case {i} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i} passed.\")\n\n\ntest_remaining_trees_after_clearing()", "entry_point": "remaining_trees_after_clearing", "signature": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:", "docstring": {"en": "Calculate the number of remaining trees along a road after specific areas have been cleared.\n\nThe road is represented as a straight line of length 'l' and is initially filled with trees.\nEach area scheduled for clearing is specified as a pair of integers (start, end), representing\nthe inclusive range along the road where the trees will be removed.\n\nArgs:\n- l (int): The length of the road.\n- areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n\nReturns:\n- int: The total number of trees remaining along the road after the specified areas have been cleared.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\nand 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\nand at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\nare cleared, leaving trees at positions 0 to 9 and 91 to 100.", "sq": "Llogarit numrin e pemëve të mbetura përgjatë një rruge pasi zona të caktuara janë pastruar.\n\nRruga përfaqësohet si një vijë e drejtë me gjatësi 'l' dhe fillimisht është e mbushur me pemë.\nÇdo zonë e planifikuar për pastrim specifikohet si një çift numrash të plotë (fillimi, fundi), që përfaqëson\nintervalin përfshirës përgjatë rrugës ku pemët do të hiqen.\n\nArgumentet:\n- l (int): Gjatësia e rrugës.\n- zonat (List[Tuple[int, int]]): Një listë e tupleve ku çdo tuple përfaqëson një zonë të pastruar në rrugë.\n\nKthen:\n- int: Numri total i pemëve të mbetura përgjatë rrugës pasi zonat e specifikuara janë pastruar.\n\nShembuj:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) do të kthejë 5, pasi pemët nga pozicionet 2 deri në 5\ndhe 7 deri në 9 janë pastruar, duke lënë pemët në pozicionet 0, 1, 6, dhe 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) do të kthejë 3, pasi pemët nga pozicionet 1 deri në 3\ndhe në pozicionin 4 janë pastruar, duke lënë pemët në pozicionet 0, 5, dhe 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) do të kthejë 20, pasi pemët nga pozicionet 10 deri në 90\njanë pastruar, duke lënë pemët në pozicionet 0 deri në 9 dhe 91 deri në 100.", "hy": "Հաշվարկել ճանապարհի երկայնքով մնացած ծառերի քանակը այն բանից հետո, երբ որոշակի տարածքներ մաքրվել են:\n\nՃանապարհը ներկայացված է որպես ուղիղ գիծ `l` երկարությամբ և սկզբում լցված է ծառերով:\nՅուրաքանչյուր մաքրման ենթակա տարածք նշված է որպես ամբողջ թվերի զույգ (սկիզբ, վերջ), որը ներկայացնում է\nճանապարհի երկայնքով ընդգրկուն միջակայքը, որտեղ ծառերը կհեռացվեն:\n\nԱրձանագրություններ:\n- l (int): Ճանապարհի երկարությունը:\n- areas (List[Tuple[int, int]]): Զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ ներկայացնում է ճանապարհի մաքրված տարածք:\n\nՎերադարձնում է:\n- int: Ճանապարհի երկայնքով մնացած ծառերի ընդհանուր քանակը այն բանից հետո, երբ նշված տարածքները մաքրվել են:\n\nՕրինակներ:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) կվերադարձնի 5, քանի որ 2-ից 5\nև 7-ից 9 դիրքերում ծառերը մաքրվում են, թողնելով ծառեր 0, 1, 6 և 10 դիրքերում:\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) կվերադարձնի 3, քանի որ 1-ից 3\nև 4 դիրքերում ծառերը մաքրվում են, թողնելով ծառեր 0, 5 և 6 դիրքերում:\n\n- remaining_trees_after_clearing(100, [(10, 90)]) կվերադարձնի 20, քանի որ 10-ից 90\nդիրքերում ծառերը մաքրվում են, թողնելով ծառեր 0-ից 9 և 91-ից 100 դիրքերում:", "bn": "রাস্তার পাশে নির্দিষ্ট কিছু এলাকা পরিষ্কার করার পর অবশিষ্ট গাছের সংখ্যা গণনা করুন।\n\nরাস্তা একটি সরল রেখা হিসাবে 'l' দৈর্ঘ্যের এবং প্রাথমিকভাবে গাছ দিয়ে পূর্ণ। প্রতিটি পরিষ্কার করার জন্য নির্ধারিত এলাকা একটি পূর্ণসংখ্যার জোড়া (শুরু, শেষ) হিসাবে নির্দিষ্ট করা হয়, যা রাস্তার বরাবর অন্তর্ভুক্তিকৃত পরিসরকে উপস্থাপন করে যেখানে গাছগুলি সরানো হবে।\n\nআর্গস:\n- l (int): রাস্তার দৈর্ঘ্য।\n- areas (List[Tuple[int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপল রাস্তার একটি পরিষ্কার করা এলাকা উপস্থাপন করে।\n\nরিটার্নস:\n- int: নির্দিষ্ট এলাকাগুলি পরিষ্কার করার পরে রাস্তার পাশে অবশিষ্ট মোট গাছের সংখ্যা।\n\nউদাহরণ:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 ফেরত দেবে, কারণ অবস্থান 2 থেকে 5 এবং 7 থেকে 9 পর্যন্ত গাছগুলি পরিষ্কার করা হয়েছে, অবস্থান 0, 1, 6, এবং 10 এ গাছ রেখে।\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 ফেরত দেবে, কারণ অবস্থান 1 থেকে 3 এবং অবস্থান 4 এ গাছগুলি পরিষ্কার করা হয়েছে, অবস্থান 0, 5, এবং 6 এ গাছ রেখে।\n\n- remaining_trees_after_clearing(100, [(10, 90)]) 20 ফেরত দেবে, কারণ অবস্থান 10 থেকে 90 পর্যন্ত গাছগুলি পরিষ্কার করা হয়েছে, অবস্থান 0 থেকে 9 এবং 91 থেকে 100 পর্যন্ত গাছ রেখে।", "bg": "Изчислете броя на останалите дървета по пътя след като определени зони са били изчистени.\n\nПътят е представен като права линия с дължина 'l' и първоначално е запълнен с дървета.\nВсяка зона, планирана за изчистване, е посочена като двойка от цели числа (начало, край), представляваща\nвключителния диапазон по пътя, където дърветата ще бъдат премахнати.\n\nАргументи:\n- l (int): Дължината на пътя.\n- areas (List[Tuple[int, int]]): Списък от двойки, където всяка двойка представлява изчистена зона на пътя.\n\nВръща:\n- int: Общият брой на дърветата, останали по пътя след като определените зони са били изчистени.\n\nПримери:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ще върне 5, тъй като дърветата от позиции 2 до 5\nи 7 до 9 са изчистени, оставяйки дървета на позиции 0, 1, 6 и 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) ще върне 3, тъй като дърветата от позиции 1 до 3\nи на позиция 4 са изчистени, оставяйки дървета на позиции 0, 5 и 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) ще върне 20, тъй като дърветата от позиции 10 до 90\nса изчистени, оставяйки дървета на позиции от 0 до 9 и от 91 до 100.", "zh": "计算沿道路剩余的树木数量，在特定区域被清除后。\n\n道路表示为长度为 'l' 的直线，最初布满了树木。\n每个计划清除的区域由一对整数 (start, end) 指定，表示沿道路将要移除树木的包含范围。\n\n参数：\n- l (int): 道路的长度。\n- areas (List[Tuple[int, int]]): 一个元组列表，其中每个元组表示道路上的一个清除区域。\n\n返回：\n- int: 指定区域被清除后，沿道路剩余的树木总数。\n\n示例：\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5，因为位置 2 到 5 和 7 到 9 的树木被清除，剩下位置 0, 1, 6 和 10 的树木。\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 将返回 3，因为位置 1 到 3 和位置 4 的树木被清除，剩下位置 0, 5 和 6 的树木。\n\n- remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20，因为位置 10 到 90 的树木被清除，剩下位置 0 到 9 和 91 到 100 的树木。", "fr": "Calculer le nombre d'arbres restants le long d'une route après que des zones spécifiques ont été défrichées.\n\nLa route est représentée comme une ligne droite de longueur 'l' et est initialement remplie d'arbres.\nChaque zone prévue pour le défrichage est spécifiée comme une paire d'entiers (début, fin), représentant\nla plage inclusive le long de la route où les arbres seront enlevés.\n\nArgs:\n- l (int) : La longueur de la route.\n- areas (List[Tuple[int, int]]) : Une liste de tuples où chaque tuple représente une zone défrichée sur la route.\n\nReturns:\n- int : Le nombre total d'arbres restants le long de la route après que les zones spécifiées ont été défrichées.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) retournera 5, car les arbres des positions 2 à 5\net 7 à 9 sont défrichés, laissant des arbres aux positions 0, 1, 6, et 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) retournera 3, car les arbres des positions 1 à 3\net à la position 4 sont défrichés, laissant des arbres aux positions 0, 5, et 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) retournera 20, car les arbres des positions 10 à 90\nsont défrichés, laissant des arbres aux positions 0 à 9 et 91 à 100.", "de": "Berechne die Anzahl der verbleibenden Bäume entlang einer Straße, nachdem bestimmte Bereiche gerodet wurden.\n\nDie Straße wird als gerade Linie der Länge 'l' dargestellt und ist zunächst mit Bäumen gefüllt.\nJeder zur Rodung vorgesehene Bereich wird als Paar von ganzen Zahlen (Start, Ende) angegeben, das den inklusiven Bereich entlang der Straße darstellt, in dem die Bäume entfernt werden.\n\nArgs:\n- l (int): Die Länge der Straße.\n- areas (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel einen gerodeten Bereich auf der Straße darstellt.\n\nReturns:\n- int: Die Gesamtanzahl der Bäume, die entlang der Straße verbleiben, nachdem die angegebenen Bereiche gerodet wurden.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) wird 5 zurückgeben, da die Bäume von den Positionen 2 bis 5 und 7 bis 9 gerodet werden, wodurch die Bäume an den Positionen 0, 1, 6 und 10 verbleiben.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) wird 3 zurückgeben, da die Bäume von den Positionen 1 bis 3 und an Position 4 gerodet werden, wodurch die Bäume an den Positionen 0, 5 und 6 verbleiben.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) wird 20 zurückgeben, da die Bäume von den Positionen 10 bis 90 gerodet werden, wodurch die Bäume an den Positionen 0 bis 9 und 91 bis 100 verbleiben.", "ha": "Lissafi adadin bishiyoyin da suka rage a gefen hanya bayan an share wasu wurare.\n\nAn hanyar tana wakiltar layi madaidaici mai tsawon 'l' kuma a farko cike take da itatuwa. Kowace yanki da aka tsara don sharewa an bayyana ta azaman ma'aurata na lambobi (farko, ƙarshe), wanda ke wakiltar kewayon da aka haɗa tare da hanya inda za a cire itatuwan.\n\nArgs:\n- l (int): Tsawon hanyar.\n- areas (List[Tuple[int, int]]): Jerin ma'aurata inda kowace ma'aurata ke wakiltar yanki da aka share akan hanya.\n\nReturns:\n- int: Jimillar adadin itatuwan da suka rage a kan hanya bayan an share yankunan da aka fayyace.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) zai dawo da 5, domin itatuwan daga matsayi na 2 zuwa 5\nda 7 zuwa 9 an share su, sun bar itatuwa a matsayi na 0, 1, 6, da 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) zai dawo da 3, domin itatuwan daga matsayi na 1 zuwa 3\nda a matsayi na 4 an share su, sun bar itatuwa a matsayi na 0, 5, da 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) zai dawo da 20, domin itatuwan daga matsayi na 10 zuwa 90\nan share su, sun bar itatuwa a matsayi na 0 zuwa 9 da 91 zuwa 100.", "hi": "सड़क के किनारे बचे हुए पेड़ों की संख्या की गणना करें जब कुछ विशिष्ट क्षेत्रों को साफ़ कर दिया गया हो।\n\nसड़क को 'l' लंबाई की एक सीधी रेखा के रूप में दर्शाया गया है और यह प्रारंभ में पेड़ों से भरी होती है। प्रत्येक क्षेत्र जिसे साफ़ करने के लिए निर्धारित किया गया है, को पूर्णांकों की एक जोड़ी (start, end) के रूप में निर्दिष्ट किया जाता है, जो सड़क के साथ समावेशी सीमा का प्रतिनिधित्व करता है जहाँ पेड़ों को हटाया जाएगा।\n\nआर्ग्स:\n- l (int): सड़क की लंबाई।\n- areas (List[Tuple[int, int]]): ट्यूपल की एक सूची जहाँ प्रत्येक ट्यूपल सड़क पर साफ़ किए गए क्षेत्र का प्रतिनिधित्व करता है।\n\nरिटर्न्स:\n- int: सड़क के किनारे कुल बचे हुए पेड़ों की संख्या जब निर्दिष्ट क्षेत्रों को साफ़ कर दिया गया हो।\n\nउदाहरण:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 लौटाएगा, क्योंकि स्थिति 2 से 5 और 7 से 9 तक के पेड़ साफ़ कर दिए गए हैं, जिससे स्थिति 0, 1, 6, और 10 पर पेड़ बचे हैं।\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 लौटाएगा, क्योंकि स्थिति 1 से 3 और स्थिति 4 पर पेड़ साफ़ कर दिए गए हैं, जिससे स्थिति 0, 5, और 6 पर पेड़ बचे हैं।\n\n- remaining_trees_after_clearing(100, [(10, 90)]) 20 लौटाएगा, क्योंकि स्थिति 10 से 90 तक के पेड़ साफ़ कर दिए गए हैं, जिससे स्थिति 0 से 9 और 91 से 100 पर पेड़ बचे हैं।", "hu": "Számítsa ki az út mentén megmaradt fák számát, miután bizonyos területeket megtisztítottak.\n\nAz út egy 'l' hosszúságú egyenes vonalként van ábrázolva, amely kezdetben fákkal van tele.\nMinden tisztításra ütemezett terület egy egész számokból álló párként van megadva (kezdő, vég),\namely az út mentén azt a tartományt jelöli, ahol a fákat eltávolítják.\n\nArgs:\n- l (int): Az út hossza.\n- areas (List[Tuple[int, int]]): Egy listája a pároknak, ahol minden pár egy tisztított területet jelöl az úton.\n\nReturns:\n- int: Az út mentén megmaradt fák teljes száma a megadott területek megtisztítása után.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) visszaadja az 5-öt, mivel a 2-től 5-ig\nés 7-től 9-ig terjedő pozíciók fái ki vannak tisztítva, így a 0, 1, 6 és 10 pozíciókon maradnak fák.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) visszaadja a 3-at, mivel az 1-től 3-ig\nés a 4-es pozíción lévő fák ki vannak tisztítva, így a 0, 5 és 6 pozíciókon maradnak fák.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) visszaadja a 20-at, mivel a 10-től 90-ig\nterjedő pozíciók fái ki vannak tisztítva, így a 0-tól 9-ig és 91-től 100-ig terjedő pozíciókon maradnak fák.", "es": "Calcular el número de árboles restantes a lo largo de una carretera después de que se hayan despejado áreas específicas.\n\nLa carretera se representa como una línea recta de longitud 'l' y está inicialmente llena de árboles.\nCada área programada para despejarse se especifica como un par de enteros (inicio, fin), que representa\nel rango inclusivo a lo largo de la carretera donde se eliminarán los árboles.\n\nArgumentos:\n- l (int): La longitud de la carretera.\n- areas (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla representa un área despejada en la carretera.\n\nDevuelve:\n- int: El número total de árboles restantes a lo largo de la carretera después de que las áreas especificadas hayan sido despejadas.\n\nEjemplos:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) devolverá 5, ya que los árboles de las posiciones 2 a 5\ny 7 a 9 son despejados, dejando árboles en las posiciones 0, 1, 6, y 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) devolverá 3, ya que los árboles de las posiciones 1 a 3\ny en la posición 4 son despejados, dejando árboles en las posiciones 0, 5, y 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) devolverá 20, ya que los árboles de las posiciones 10 a 90\nson despejados, dejando árboles en las posiciones 0 a 9 y 91 a 100.", "arb": "حساب عدد الأشجار المتبقية على طول الطريق بعد إزالة مناطق محددة.\n\nيتم تمثيل الطريق كخط مستقيم بطول 'l' وممتلئ بالأشجار في البداية. يتم تحديد كل منطقة مجدولة للإزالة كزوج من الأعداد الصحيحة (البداية، النهاية)، والتي تمثل النطاق الشامل على طول الطريق حيث سيتم إزالة الأشجار.\n\nالمعطيات:\n- l (int): طول الطريق.\n- areas (List[Tuple[int, int]]): قائمة من الأزواج حيث يمثل كل زوج منطقة تمت إزالتها على الطريق.\n\nالقيم المعادة:\n- int: العدد الإجمالي للأشجار المتبقية على طول الطريق بعد إزالة المناطق المحددة.\n\nأمثلة:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) سيعيد 5، حيث يتم إزالة الأشجار من المواقع 2 إلى 5 ومن 7 إلى 9، تاركًا الأشجار في المواقع 0، 1، 6، و10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) سيعيد 3، حيث يتم إزالة الأشجار من المواقع 1 إلى 3 وفي الموقع 4، تاركًا الأشجار في المواقع 0، 5، و6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) سيعيد 20، حيث يتم إزالة الأشجار من المواقع 10 إلى 90، تاركًا الأشجار في المواقع من 0 إلى 9 ومن 91 إلى 100.", "sw": "Kuhesabu idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\nBarabara inawakilishwa kama mstari wa moja kwa moja wa urefu 'l' na awali imejaa miti. Kila eneo lililopangwa kwa ajili ya kusafishwa linaelezwa kama jozi ya nambari (mwanzo, mwisho), inayowakilisha safu inayojumuisha kando ya barabara ambapo miti itaondolewa.\n\nHoja:\n- l (int): Urefu wa barabara.\n- areas (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi inawakilisha eneo lililosafishwa kwenye barabara.\n\nInarejesha:\n- int: Jumla ya idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\nMifano:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) itarudisha 5, kwani miti kutoka nafasi 2 hadi 5 na 7 hadi 9 imeondolewa, ikiacha miti katika nafasi 0, 1, 6, na 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) itarudisha 3, kwani miti kutoka nafasi 1 hadi 3 na katika nafasi 4 imeondolewa, ikiacha miti katika nafasi 0, 5, na 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) itarudisha 20, kwani miti kutoka nafasi 10 hadi 90 imeondolewa, ikiacha miti katika nafasi 0 hadi 9 na 91 hadi 100.", "tr": "Yol boyunca belirli alanlar temizlendikten sonra kalan ağaçların sayısını hesaplayın.\n\nYol, uzunluğu 'l' olan düz bir çizgi olarak temsil edilir ve başlangıçta ağaçlarla doludur.\nTemizlenmesi planlanan her alan, yol boyunca ağaçların kaldırılacağı kapsayıcı aralığı temsil eden\nbir çift tam sayı (başlangıç, bitiş) olarak belirtilir.\n\nArgümanlar:\n- l (int): Yolun uzunluğu.\n- areas (List[Tuple[int, int]]): Her bir demetin yoldaki temizlenmiş bir alanı temsil ettiği demetlerin listesi.\n\nDöndürür:\n- int: Belirtilen alanlar temizlendikten sonra yol boyunca kalan toplam ağaç sayısı.\n\nÖrnekler:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 döndürecektir, çünkü 2'den 5'e ve 7'den 9'a kadar olan\npozisyonlardaki ağaçlar temizlenir, 0, 1, 6 ve 10 pozisyonlarında ağaçlar kalır.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 döndürecektir, çünkü 1'den 3'e kadar olan pozisyonlardaki\nve 4 pozisyonundaki ağaçlar temizlenir, 0, 5 ve 6 pozisyonlarında ağaçlar kalır.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) 20 döndürecektir, çünkü 10'dan 90'a kadar olan pozisyonlardaki\nağaçlar temizlenir, 0'dan 9'a ve 91'den 100'e kadar olan pozisyonlarda ağaçlar kalır.", "vi": "Tính số lượng cây còn lại dọc theo một con đường sau khi các khu vực cụ thể đã được dọn sạch.\n\nCon đường được biểu diễn như một đường thẳng có độ dài 'l' và ban đầu được lấp đầy bởi cây.\nMỗi khu vực dự kiến dọn sạch được chỉ định như một cặp số nguyên (bắt đầu, kết thúc), đại diện cho\nphạm vi bao gồm dọc theo con đường nơi cây sẽ bị loại bỏ.\n\nTham số:\n- l (int): Độ dài của con đường.\n- areas (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ giá trị đại diện cho một khu vực đã được dọn sạch trên con đường.\n\nTrả về:\n- int: Tổng số cây còn lại dọc theo con đường sau khi các khu vực đã được dọn sạch.\n\nVí dụ:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) sẽ trả về 5, vì cây từ vị trí 2 đến 5\nvà 7 đến 9 bị dọn sạch, để lại cây ở vị trí 0, 1, 6, và 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) sẽ trả về 3, vì cây từ vị trí 1 đến 3\nvà tại vị trí 4 bị dọn sạch, để lại cây ở vị trí 0, 5, và 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) sẽ trả về 20, vì cây từ vị trí 10 đến 90\nbị dọn sạch, để lại cây ở vị trí 0 đến 9 và 91 đến 100.", "id": "Hitung jumlah pohon yang tersisa di sepanjang jalan setelah area tertentu dibersihkan.\n\nJalan diwakili sebagai garis lurus dengan panjang 'l' dan awalnya dipenuhi dengan pohon. Setiap area yang dijadwalkan untuk dibersihkan ditentukan sebagai pasangan bilangan bulat (start, end), yang mewakili rentang inklusif di sepanjang jalan di mana pohon akan dihapus.\n\nArgs:\n- l (int): Panjang jalan.\n- areas (List[Tuple[int, int]]): Daftar tuple di mana setiap tuple mewakili area yang dibersihkan di jalan.\n\nReturns:\n- int: Jumlah total pohon yang tersisa di sepanjang jalan setelah area yang ditentukan dibersihkan.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) akan mengembalikan 5, karena pohon dari posisi 2 hingga 5 dan 7 hingga 9 dibersihkan, menyisakan pohon di posisi 0, 1, 6, dan 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) akan mengembalikan 3, karena pohon dari posisi 1 hingga 3 dan di posisi 4 dibersihkan, menyisakan pohon di posisi 0, 5, dan 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) akan mengembalikan 20, karena pohon dari posisi 10 hingga 90 dibersihkan, menyisakan pohon di posisi 0 hingga 9 dan 91 hingga 100.", "ja": "道路に沿って特定のエリアが伐採された後に残る木の数を計算します。\n\n道路は長さ 'l' の直線で表され、最初は木でいっぱいです。\n伐採が予定されている各エリアは、道路に沿って木が取り除かれる範囲を表す整数のペア (start, end) として指定されます。\n\n引数:\n- l (int): 道路の長さ。\n- areas (List[Tuple[int, int]]): 各タプルが道路上の伐採エリアを表すタプルのリスト。\n\n戻り値:\n- int: 指定されたエリアが伐採された後に道路に沿って残る木の総数。\n\n例:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) は 5 を返します。位置 2 から 5 と 7 から 9 の木が伐採され、位置 0, 1, 6, および 10 に木が残ります。\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) は 3 を返します。位置 1 から 3 と位置 4 の木が伐採され、位置 0, 5, および 6 に木が残ります。\n\n- remaining_trees_after_clearing(100, [(10, 90)]) は 20 を返します。位置 10 から 90 の木が伐採され、位置 0 から 9 と 91 から 100 に木が残ります。", "ko": "도로를 따라 특정 구역이 제거된 후 남아 있는 나무의 수를 계산합니다.\n\n도로는 길이 'l'의 직선으로 표현되며, 처음에는 나무로 가득 차 있습니다. 제거할 예정인 각 구역은 (start, end)라는 정수 쌍으로 지정되며, 이는 도로를 따라 나무가 제거될 포함 범위를 나타냅니다.\n\nArgs:\n- l (int): 도로의 길이.\n- areas (List[Tuple[int, int]]): 각 튜플이 도로에서 제거된 구역을 나타내는 튜플의 리스트.\n\nReturns:\n- int: 지정된 구역이 제거된 후 도로를 따라 남아 있는 나무의 총 수.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)])는 5를 반환합니다. 위치 2에서 5까지와 7에서 9까지의 나무가 제거되어 위치 0, 1, 6, 10에 나무가 남습니다.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)])는 3을 반환합니다. 위치 1에서 3까지와 위치 4의 나무가 제거되어 위치 0, 5, 6에 나무가 남습니다.\n\n- remaining_trees_after_clearing(100, [(10, 90)])는 20을 반환합니다. 위치 10에서 90까지의 나무가 제거되어 위치 0에서 9까지와 91에서 100까지 나무가 남습니다.", "ml": "വഴിയരികിൽ പ്രത്യേക പ്രദേശങ്ങൾ മുറിച്ചുമാറ്റിയ ശേഷം അവശേഷിക്കുന്ന മരങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n\nവഴി 'l' നീളമുള്ള നേരായ വരയായി പ്രതിനിധീകരിക്കപ്പെടുന്നു, ആദ്യം മരങ്ങൾ നിറഞ്ഞിരിക്കുന്നു. മുറിച്ചുമാറ്റാൻ നിശ്ചയിച്ചിരിക്കുന്ന ഓരോ പ്രദേശവും (ആരംഭം, അവസാനം) എന്ന രണ്ട് പൂർണ്ണസംഖ്യകളുടെ ജോഡികളായി വ്യക്തമാക്കപ്പെടുന്നു, അവ വഴിയരികിൽ മരങ്ങൾ നീക്കംചെയ്യുന്ന ഉൾപ്പെടുന്ന പരിധി പ്രതിനിധീകരിക്കുന്നു.\n\nആർഗുകൾ:\n- l (int): വഴിയുടെ നീളം.\n- areas (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും വഴിയരികിലെ മുറിച്ചുമാറ്റിയ പ്രദേശത്തെ പ്രതിനിധീകരിക്കുന്ന ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\nമടക്കം:\n- int: നിശ്ചയിച്ച പ്രദേശങ്ങൾ മുറിച്ചുമാറ്റിയ ശേഷം വഴിയരികിൽ അവശേഷിക്കുന്ന മൊത്തം മരങ്ങളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 മടക്കമായി നൽകും, കാരണം 2 മുതൽ 5 വരെയും 7 മുതൽ 9 വരെയും മരങ്ങൾ മുറിച്ചുമാറ്റിയതിനാൽ 0, 1, 6, 10 സ്ഥാനങ്ങളിലെ മരങ്ങൾ അവശേഷിക്കുന്നു.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 മടക്കമായി നൽകും, കാരണം 1 മുതൽ 3 വരെയും 4 സ്ഥാനത്തുമുള്ള മരങ്ങൾ മുറിച്ചുമാറ്റിയതിനാൽ 0, 5, 6 സ്ഥാനങ്ങളിലെ മരങ്ങൾ അവശേഷിക്കുന്നു.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) 20 മടക്കമായി നൽകും, കാരണം 10 മുതൽ 90 വരെയുള്ള മരങ്ങൾ മുറിച്ചുമാറ്റിയതിനാൽ 0 മുതൽ 9 വരെയും 91 മുതൽ 100 വരെയും മരങ്ങൾ അവശേഷിക്കുന്നു.", "fa": "محاسبه تعداد درختان باقی‌مانده در طول یک جاده پس از پاکسازی مناطق خاص.\n\nجاده به صورت یک خط مستقیم به طول 'l' نمایش داده می‌شود و در ابتدا با درختان پر شده است.\nهر منطقه‌ای که برای پاکسازی برنامه‌ریزی شده است به صورت یک جفت عدد صحیح (شروع، پایان) مشخص می‌شود که نشان‌دهنده محدوده‌ای فراگیر در طول جاده است که در آن درختان برداشته خواهند شد.\n\nآرگومان‌ها:\n- l (int): طول جاده.\n- areas (List[Tuple[int, int]]): لیستی از جفت‌ها که هر جفت نشان‌دهنده یک منطقه پاکسازی شده در جاده است.\n\nبازگشت:\n- int: تعداد کل درختان باقی‌مانده در طول جاده پس از پاکسازی مناطق مشخص شده.\n\nمثال‌ها:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) مقدار 5 را برمی‌گرداند، زیرا درختان از موقعیت‌های 2 تا 5 و 7 تا 9 پاکسازی می‌شوند و درختان در موقعیت‌های 0، 1، 6 و 10 باقی می‌مانند.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) مقدار 3 را برمی‌گرداند، زیرا درختان از موقعیت‌های 1 تا 3 و در موقعیت 4 پاکسازی می‌شوند و درختان در موقعیت‌های 0، 5 و 6 باقی می‌مانند.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) مقدار 20 را برمی‌گرداند، زیرا درختان از موقعیت‌های 10 تا 90 پاکسازی می‌شوند و درختان در موقعیت‌های 0 تا 9 و 91 تا 100 باقی می‌مانند."}}
{"task_id": "Python/37", "prompt": {"en": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      In this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\n      to the time constraint, leading to a maximum value of 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Here, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      With a time limit of 5, only the first herb can be picked, providing a value of 10.\n    \"\"\"", "sq": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri kohor të caktuar.\n\n    Kjo funksion zgjidh një variant të problemit të çantës 0/1 ku qëllimi është të maksimizohet\n    vlera totale e bimëve të mbledhura pa tejkaluar kufirin kohor. Çdo bimë mund të mblidhet\n    maksimumi një herë dhe ka një kosto kohe dhe vlerë të lidhur.\n\n    Argumentet:\n    - T (int): Koha totale e disponueshme për mbledhjen e bimëve.\n    - M (int): Numri i bimëve të ndryshme në shpellë.\n    - herbs (List[Tuple[int, int]]): Një listë tuples, ku çdo tuple përmban dy numra të plotë\n      që përfaqësojnë kohën e kërkuar për të mbledhur bimën dhe vlerën e bimës, përkatësisht.\n\n    Kthen:\n    - int: Vlera maksimale totale e bimëve që mund të mblidhen brenda kufirit kohor.\n\n    Shembuj:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Në këtë skenar, vetëm bima që kërkon 1 njësi kohe për një vlerë prej 2 mund të mblidhet për shkak\n      të kufizimit kohor, duke çuar në një vlerë maksimale prej 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Këtu, strategjia më e mirë është të mblidhen bimët me kohë 1, 2, dhe 3, duke çuar në një vlerë maksimale prej 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Me një kufi kohor prej 5, vetëm bima e parë mund të mblidhet, duke ofruar një vlerë prej 10.\n    \"\"\"", "hy": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվել խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել տրված ժամանակային սահմանափակման շրջանակներում:\n\n    Այս ֆունկցիան լուծում է 0/1 պայուսակի խնդրի տարբերակը, որտեղ նպատակը խոտաբույսերի ընդհանուր արժեքի առավելագույնացումն է՝ առանց ժամանակային սահմանափակումը գերազանցելու: Յուրաքանչյուր խոտաբույս կարելի է հավաքել առավելագույնը մեկ անգամ և ունի կապված ժամանակային արժեք և արժեք:\n\n    Արգումենտներ:\n    - T (int): Ընդհանուր ժամանակը, որը հասանելի է խոտաբույսեր հավաքելու համար:\n    - M (int): Տարբեր խոտաբույսերի քանակը քարանձավում:\n    - herbs (List[Tuple[int, int]]): Ցուցակ, որտեղ յուրաքանչյուր տուփ պարունակում է երկու ամբողջ թիվ, որոնք ներկայացնում են խոտաբույսի հավաքման համար պահանջվող ժամանակը և խոտաբույսի արժեքը, համապատասխանաբար:\n\n    Վերադարձնում է:\n    - int: Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել ժամանակային սահմանափակման շրջանակներում:\n\n    Օրինակներ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Այս սցենարում, միայն այն խոտաբույսը, որը պահանջում է 1 միավոր ժամանակ արժեքով 2, կարելի է հավաքել\n      ժամանակային սահմանափակման պատճառով, ինչը հանգեցնում է առավելագույն արժեքի 3:\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Այստեղ, լավագույն ռազմավարությունն է հավաքել խոտաբույսերը, որոնց ժամանակները 1, 2 և 3 են, ինչը հանգեցնում է առավելագույն արժեքի 10 + 15 + 20 = 50:\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      5 ժամանակային սահմանափակմամբ, միայն առաջին խոտաբույսը կարելի է հավաքել՝ ապահովելով 10 արժեք:\n    \"\"\"", "bn": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    নির্দিষ্ট সময়সীমার মধ্যে যতটা সম্ভব সর্বোচ্চ মোট মূল্যবান ভেষজ সংগ্রহ করা যায় তা গণনা করুন।\n\n    এই ফাংশনটি 0/1 ন্যাপকস্যাক সমস্যার একটি পরিবর্তন সমাধান করে যেখানে লক্ষ্য হল\n    মোট ভেষজ মূল্য সর্বাধিক করা যা সময়সীমা অতিক্রম না করে সংগ্রহ করা যায়। প্রতিটি ভেষজ\n    সর্বাধিক একবার সংগ্রহ করা যেতে পারে এবং এর সাথে সম্পর্কিত সময় খরচ এবং মূল্য রয়েছে।\n\n    আর্গুমেন্টসমূহ:\n    - T (int): ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    - M (int): গুহায় বিভিন্ন ভেষজের সংখ্যা।\n    - herbs (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা\n      রয়েছে যা ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং ভেষজের মূল্য প্রতিনিধিত্ব করে।\n\n    রিটার্নস:\n    - int: সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বোচ্চ মোট মূল্য।\n\n    উদাহরণ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      এই পরিস্থিতিতে, সময় সীমাবদ্ধতার কারণে শুধুমাত্র 1 ইউনিট সময়ের জন্য 2 মূল্যের ভেষজটি সংগ্রহ করা যায়,\n      যা সর্বাধিক মূল্য 3 এ নিয়ে যায়।\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      এখানে, সর্বোত্তম কৌশল হল 1, 2 এবং 3 সময়ের ভেষজগুলি সংগ্রহ করা, যা সর্বাধিক মূল্য 10 + 15 + 20 = 50 এ নিয়ে যায়।\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      5 সময়সীমার মধ্যে, শুধুমাত্র প্রথম ভেষজটি সংগ্রহ করা যায়, যা 10 মূল্যের প্রদান করে।\n    \"\"\"", "bg": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n\n    Тази функция решава вариация на проблема с раницата 0/1, където целта е да се максимизира\n    общата стойност на събраните билки, без да се превишава времевият лимит. Всяка билка може да бъде събрана\n    най-много веднъж и има свързани времеви разходи и стойност.\n\n    Аргументи:\n    - T (int): Общото време, налично за събиране на билки.\n    - M (int): Броят на различните билки в пещерата.\n    - herbs (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа две цели числа,\n      представляващи времето, необходимо за събиране на билката и стойността на билката, съответно.\n\n    Връща:\n    - int: Максималната обща стойност на билките, които могат да бъдат събрани в рамките на времевия лимит.\n\n    Примери:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      В този сценарий, само билката, която отнема 1 единица време за стойност 2, може да бъде събрана поради\n      времевото ограничение, водещо до максимална стойност от 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Тук, най-добрата стратегия е да се съберат билките с времена 1, 2 и 3, водещи до максимална стойност от 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      С времеви лимит от 5, само първата билка може да бъде събрана, осигурявайки стойност от 10.\n    \"\"\"", "zh": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在给定时间限制内可以采摘的草药的最大总价值。\n\n    此函数解决了0/1背包问题的一个变体，其目标是在不超过时间限制的情况下最大化\n    采摘草药的总价值。每种草药最多只能采摘一次，并且有一个相关的时间成本和价值。\n\n    参数:\n    - T (int): 可用于采摘草药的总时间。\n    - M (int): 洞穴中不同草药的数量。\n    - herbs (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数，\n      分别表示采摘草药所需的时间和草药的价值。\n\n    返回:\n    - int: 在时间限制内可以采摘的草药的最大总价值。\n\n    示例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      在这种情况下，由于时间限制，只能采摘需要1单位时间且价值为2的草药，\n      从而达到最大价值3。\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      在这里，最佳策略是采摘时间为1、2和3的草药，最大价值为10 + 15 + 20 = 50。\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      在时间限制为5的情况下，只能采摘第一种草药，提供价值10。\n    \"\"\"", "fr": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculer la valeur totale maximale des herbes qui peuvent être cueillies dans un délai donné.\n\n    Cette fonction résout une variation du problème du sac à dos 0/1 où l'objectif est de maximiser\n    la valeur totale des herbes cueillies sans dépasser la limite de temps. Chaque herbe peut être cueillie\n    au plus une fois et a un coût en temps et une valeur associés.\n\n    Args:\n    - T (int): Le temps total disponible pour cueillir les herbes.\n    - M (int): Le nombre d'herbes différentes dans la grotte.\n    - herbs (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers\n      représentant le temps nécessaire pour cueillir l'herbe et la valeur de l'herbe, respectivement.\n\n    Returns:\n    - int: La valeur totale maximale des herbes qui peuvent être cueillies dans la limite de temps.\n\n    Exemples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Dans ce scénario, seule l'herbe qui prend 1 unité de temps pour une valeur de 2 peut être cueillie en raison\n      de la contrainte de temps, conduisant à une valeur maximale de 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Ici, la meilleure stratégie est de cueillir les herbes avec des temps de 1, 2 et 3, conduisant à une valeur maximale de 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Avec une limite de temps de 5, seule la première herbe peut être cueillie, fournissant une valeur de 10.\n    \"\"\"", "de": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechne den maximalen Gesamtwert der Kräuter, die innerhalb eines gegebenen Zeitlimits gesammelt werden können.\n\n    Diese Funktion löst eine Variation des 0/1-Rucksackproblems, bei dem das Ziel darin besteht,\n    den Gesamtwert der gesammelten Kräuter zu maximieren, ohne das Zeitlimit zu überschreiten.\n    Jedes Kraut kann höchstens einmal gesammelt werden und hat eine zugehörige Zeitkosten und einen Wert.\n\n    Argumente:\n    - T (int): Die insgesamt verfügbare Zeit zum Sammeln der Kräuter.\n    - M (int): Die Anzahl der verschiedenen Kräuter in der Höhle.\n    - herbs (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält,\n      die die zum Sammeln des Krauts erforderliche Zeit und den Wert des Krauts darstellen.\n\n    Rückgabewert:\n    - int: Der maximale Gesamtwert der Kräuter, die innerhalb des Zeitlimits gesammelt werden können.\n\n    Beispiele:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      In diesem Szenario kann aufgrund der Zeitbeschränkung nur das Kraut gesammelt werden,\n      das 1 Zeiteinheit für einen Wert von 2 benötigt, was zu einem maximalen Wert von 3 führt.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Hier ist die beste Strategie, Kräuter mit den Zeiten 1, 2 und 3 zu sammeln, was zu einem maximalen Wert von 10 + 15 + 20 = 50 führt.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Mit einem Zeitlimit von 5 kann nur das erste Kraut gesammelt werden, was einen Wert von 10 liefert.\n    \"\"\"", "ha": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafa darajar ganyayyaki mafi girma da za a iya ɗauka cikin iyakar lokaci da aka bayar.\n\n    Wannan aikin yana warware wani bambancin matsalar jakar 0/1 inda manufar ita ce a ƙara\n    darajar ganyayyaki da aka ɗauka ba tare da wuce iyakar lokaci ba. Ana iya ɗaukar kowanne ganye\n    sau ɗaya kawai kuma yana da alaƙa da farashin lokaci da daraja.\n\n    Args:\n    - T (int): Jimillar lokacin da ake da shi don ɗaukar ganyayyaki.\n    - M (int): Yawan nau'ikan ganyayyaki daban-daban a cikin kogon.\n    - herbs (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple ya ƙunshi lambobi biyu\n      da ke wakiltar lokacin da ake buƙata don ɗaukar ganyen da kuma darajar ganyen, bi da bi.\n\n    Returns:\n    - int: Mafi girman darajar ganyayyaki da za a iya ɗauka cikin iyakar lokacin.\n\n    Misalai:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      A wannan yanayin, kawai ganyen da ke ɗaukar 1 na lokaci don darajar 2 ne za a iya ɗauka saboda\n      ƙuntatawar lokaci, yana kaiwa ga darajar 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Anan, mafi kyawun dabaru ita ce ɗaukar ganyayyaki masu lokuta 1, 2, da 3, yana kaiwa ga darajar 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Tare da iyakar lokaci na 5, kawai ganye na farko ne za a iya ɗauka, yana bayar da darajar 10.\n    \"\"\"", "hi": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    दिए गए समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करें।\n\n    यह फ़ंक्शन 0/1 नॅपसैक समस्या के एक भिन्न रूप को हल करता है जहाँ लक्ष्य\n    समय सीमा से अधिक किए बिना चुनी गई जड़ी-बूटियों के कुल मूल्य को अधिकतम करना है। प्रत्येक जड़ी-बूटी को\n    अधिकतम एक बार चुना जा सकता है और इसका एक संबंधित समय लागत और मूल्य होता है।\n\n    तर्क:\n    - T (int): जड़ी-बूटियों को चुनने के लिए उपलब्ध कुल समय।\n    - M (int): गुफा में विभिन्न जड़ी-बूटियों की संख्या।\n    - herbs (List[Tuple[int, int]]): टुपल की एक सूची, जहाँ प्रत्येक टुपल में दो पूर्णांक होते हैं\n      जो क्रमशः जड़ी-बूटी को चुनने के लिए आवश्यक समय और जड़ी-बूटी के मूल्य का प्रतिनिधित्व करते हैं।\n\n    वापसी:\n    - int: समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    उदाहरण:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      इस परिदृश्य में, केवल वह जड़ी-बूटी जिसे 2 के मूल्य के लिए 1 इकाई समय लगता है,\n      समय सीमा के कारण चुनी जा सकती है, जिससे अधिकतम मूल्य 3 होता है।\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      यहाँ, सबसे अच्छी रणनीति 1, 2, और 3 समय वाली जड़ी-बूटियों को चुनना है, जिससे अधिकतम मूल्य 10 + 15 + 20 = 50 होता है।\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      5 की समय सीमा के साथ, केवल पहली जड़ी-बूटी को चुना जा सकता है, जो 10 का मूल्य प्रदान करती है।\n    \"\"\"", "hu": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Számítsa ki a maximális összértéket a gyógynövényeknek, amelyeket egy adott időkorláton belül lehet összegyűjteni.\n\n    Ez a függvény a 0/1 hátizsák probléma egy változatát oldja meg, ahol a cél a gyógynövények\n    összértékének maximalizálása anélkül, hogy túllépnénk az időkorlátot. Minden gyógynövényt\n    legfeljebb egyszer lehet összegyűjteni, és mindegyikhez tartozik egy időráfordítás és egy érték.\n\n    Argumentumok:\n    - T (int): Az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\n    - M (int): A különböző gyógynövények száma a barlangban.\n    - herbs (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy pár, ahol az első szám\n      a gyógynövény összegyűjtéséhez szükséges időt, a második pedig a gyógynövény értékét jelenti.\n\n    Visszatérési érték:\n    - int: A maximális összérték a gyógynövényeknek, amelyeket az időkorláton belül lehet összegyűjteni.\n\n    Példák:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Ebben az esetben csak az a gyógynövény gyűjthető össze, amely 1 egységnyi időt igényel 2 értékért,\n      az időkorlát miatt, így a maximális érték 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Itt a legjobb stratégia az 1, 2 és 3 időt igénylő gyógynövények összegyűjtése, ami 10 + 15 + 20 = 50 maximális értéket eredményez.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      5-ös időkorláttal csak az első gyógynövény gyűjthető össze, amely 10 értéket biztosít.\n    \"\"\"", "es": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcular el valor total máximo de hierbas que se pueden recoger dentro de un límite de tiempo dado.\n\n    Esta función resuelve una variación del problema de la mochila 0/1 donde el objetivo es maximizar\n    el valor total de las hierbas recogidas sin exceder el límite de tiempo. Cada hierba se puede recoger\n    como máximo una vez y tiene un costo de tiempo y un valor asociados.\n\n    Argumentos:\n    - T (int): El tiempo total disponible para recoger hierbas.\n    - M (int): El número de diferentes hierbas en la cueva.\n    - herbs (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros\n      que representan el tiempo requerido para recoger la hierba y el valor de la hierba, respectivamente.\n\n    Devuelve:\n    - int: El valor total máximo de hierbas que se pueden recoger dentro del límite de tiempo.\n\n    Ejemplos:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      En este escenario, solo se puede recoger la hierba que toma 1 unidad de tiempo por un valor de 2\n      debido a la restricción de tiempo, lo que lleva a un valor máximo de 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Aquí, la mejor estrategia es recoger las hierbas con tiempos 1, 2 y 3, lo que lleva a un valor máximo de 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Con un límite de tiempo de 5, solo se puede recoger la primera hierba, proporcionando un valor de 10.\n    \"\"\"", "arb": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    حساب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n\n    تحل هذه الدالة نوعًا من مشكلة الحقيبة 0/1 حيث يكون الهدف هو تعظيم\n    القيمة الإجمالية للأعشاب المجمعة دون تجاوز الحد الزمني. يمكن جمع كل عشب\n    مرة واحدة فقط وله تكلفة زمنية وقيمة مرتبطة به.\n\n    يعيدالحجج:\n    - T (int): إجمالي الوقت المتاح لجمع الأعشاب.\n    - M (int): عدد أنواع الأعشاب المختلفة في الكهف.\n    - herbs (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين\n      يمثلان الوقت المطلوب لجمع العشب وقيمة العشب، على التوالي.\n\n    يعيد:\n    - int: القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الحد الزمني.\n\n    أمثلة:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      في هذا السيناريو، يمكن جمع العشب الذي يستغرق 1 وحدة زمنية فقط بقيمة 2\n      بسبب قيود الوقت، مما يؤدي إلى قيمة قصوى قدرها 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      هنا، أفضل استراتيجية هي جمع الأعشاب ذات الأوقات 1، 2، و3، مما يؤدي إلى قيمة قصوى قدرها 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      مع حد زمني قدره 5، يمكن جمع العشب الأول فقط، مما يوفر قيمة قدرها 10.\n    \"\"\"", "sw": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Hesabu thamani ya juu kabisa ya mimea ya dawa inayoweza kuchukuliwa ndani ya kikomo cha muda kilichopewa.\n\n    Kazi hii inatatua tofauti ya tatizo la 0/1 knapsack ambapo lengo ni kuongeza\n    thamani ya jumla ya mimea ya dawa iliyochukuliwa bila kuzidi kikomo cha muda. Kila mmea wa dawa unaweza kuchukuliwa\n    mara moja tu na una gharama ya muda na thamani inayohusiana.\n\n    Hoja:\n    - T (int): Jumla ya muda unaopatikana kwa kuchukua mimea ya dawa.\n    - M (int): Idadi ya mimea ya dawa tofauti kwenye pango.\n    - herbs (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina nambari mbili\n      zinazowakilisha muda unaohitajika kuchukua mmea wa dawa na thamani ya mmea wa dawa, mtawalia.\n\n    Inarudisha:\n    - int: Thamani ya juu kabisa ya mimea ya dawa inayoweza kuchukuliwa ndani ya kikomo cha muda.\n\n    Mifano:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Katika hali hii, ni mmea wa dawa tu unaochukua kitengo 1 cha muda kwa thamani ya 2 unaweza kuchukuliwa kwa\n      sababu ya kikomo cha muda, na kusababisha thamani ya juu ya 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Hapa, mkakati bora ni kuchukua mimea ya dawa yenye muda 1, 2, na 3, na kusababisha thamani ya juu ya 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Kwa kikomo cha muda cha 5, ni mmea wa kwanza tu unaweza kuchukuliwa, ukitoa thamani ya 10.\n    \"\"\"", "tr": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplayın.\n\n    Bu fonksiyon, zaman sınırını aşmadan toplanan otların toplam değerini maksimize etmeyi amaçlayan\n    0/1 sırt çantası probleminin bir varyasyonunu çözer. Her ot en fazla bir kez toplanabilir ve\n    her birinin bir zaman maliyeti ve değeri vardır.\n\n    Argümanlar:\n    - T (int): Ot toplamak için mevcut toplam zaman.\n    - M (int): Mağaradaki farklı otların sayısı.\n    - herbs (List[Tuple[int, int]]): Her bir demetin, sırasıyla otu toplamak için gereken zamanı ve\n      otun değerini temsil eden iki tam sayı içeren bir demet listesi.\n\n    Döndürür:\n    - int: Zaman sınırı içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Bu senaryoda, zaman kısıtlaması nedeniyle yalnızca 1 birim zaman alan ve değeri 2 olan ot\n      toplanabilir, bu da maksimum 3 değerine yol açar.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Burada en iyi strateji, 1, 2 ve 3 zamanlı otları toplamaktır, bu da 10 + 15 + 20 = 50 maksimum\n      değerine yol açar.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      5 zaman sınırı ile yalnızca ilk ot toplanabilir ve bu da 10 değer sağlar.\n    \"\"\"", "vi": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính toán giá trị tối đa của các loại thảo mộc có thể hái được trong giới hạn thời gian cho phép.\n\n    Hàm này giải quyết một biến thể của bài toán ba lô 0/1, trong đó mục tiêu là tối đa hóa\n    tổng giá trị của các loại thảo mộc hái được mà không vượt quá giới hạn thời gian. Mỗi loại thảo mộc có thể được hái\n    nhiều nhất một lần và có chi phí thời gian và giá trị tương ứng.\n\n    Tham số:\n    - T (int): Tổng thời gian có sẵn để hái thảo mộc.\n    - M (int): Số lượng loại thảo mộc khác nhau trong hang động.\n    - herbs (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên\n      đại diện cho thời gian cần thiết để hái thảo mộc và giá trị của thảo mộc đó, tương ứng.\n\n    Trả về:\n    - int: Giá trị tối đa của các loại thảo mộc có thể hái được trong giới hạn thời gian.\n\n    Ví dụ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Trong trường hợp này, chỉ có loại thảo mộc mất 1 đơn vị thời gian với giá trị 2 có thể được hái\n      do giới hạn thời gian, dẫn đến giá trị tối đa là 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Ở đây, chiến lược tốt nhất là hái các loại thảo mộc với thời gian 1, 2 và 3, dẫn đến giá trị tối đa là 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Với giới hạn thời gian là 5, chỉ có loại thảo mộc đầu tiên có thể được hái, cung cấp giá trị là 10.\n    \"\"\"", "id": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Hitung nilai total maksimum dari herbal yang dapat dipetik dalam batas waktu yang diberikan.\n\n    Fungsi ini menyelesaikan variasi dari masalah knapsack 0/1 di mana tujuannya adalah untuk memaksimalkan\n    nilai total dari herbal yang dipetik tanpa melebihi batas waktu. Setiap herbal dapat dipetik\n    paling banyak sekali dan memiliki biaya waktu dan nilai yang terkait.\n\n    Argumen:\n    - T (int): Total waktu yang tersedia untuk memetik herbal.\n    - M (int): Jumlah berbagai jenis herbal di dalam gua.\n    - herbs (List[Tuple[int, int]]): Daftar tuple, di mana setiap tuple berisi dua bilangan bulat\n      yang mewakili waktu yang diperlukan untuk memetik herbal dan nilai herbal tersebut, masing-masing.\n\n    Mengembalikan:\n    - int: Nilai total maksimum dari herbal yang dapat dipetik dalam batas waktu.\n\n    Contoh:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Dalam skenario ini, hanya herbal yang membutuhkan waktu 1 unit dengan nilai 2 yang dapat dipetik\n      karena batasan waktu, menghasilkan nilai maksimum 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Di sini, strategi terbaik adalah memetik herbal dengan waktu 1, 2, dan 3, menghasilkan nilai maksimum 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Dengan batas waktu 5, hanya herbal pertama yang dapat dipetik, memberikan nilai 10.\n    \"\"\"", "ja": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    与えられた時間制限内で採取できるハーブの最大総価値を計算します。\n\n    この関数は、0/1ナップサック問題の変種を解決します。ここでは、時間制限を超えずに\n    採取するハーブの総価値を最大化することが目標です。各ハーブは最大で1回だけ採取でき、\n    採取にかかる時間と価値が関連付けられています。\n\n    引数:\n    - T (int): ハーブを採取するために利用可能な総時間。\n    - M (int): 洞窟内の異なるハーブの数。\n    - herbs (List[Tuple[int, int]]): 各タプルがハーブを採取するのに必要な時間と\n      ハーブの価値を表す2つの整数を含むタプルのリスト。\n\n    戻り値:\n    - int: 時間制限内で採取できるハーブの最大総価値。\n\n    例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      このシナリオでは、時間制限のため、価値2で1単位の時間がかかるハーブのみが\n      採取でき、最大価値は3になります。\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      ここでは、時間1、2、3のハーブを採取するのが最良の戦略で、最大価値は10 + 15 + 20 = 50になります。\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      時間制限が5の場合、最初のハーブのみが採取でき、価値は10になります。\n    \"\"\"", "ko": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    주어진 시간 제한 내에서 채집할 수 있는 약초의 최대 총 가치를 계산합니다.\n\n    이 함수는 0/1 배낭 문제의 변형을 해결하며, 목표는 시간 제한을 초과하지 않고\n    채집한 약초의 총 가치를 최대화하는 것입니다. 각 약초는 최대 한 번만 채집할 수 있으며,\n    관련된 시간 비용과 가치가 있습니다.\n\n    인수:\n    - T (int): 약초 채집에 사용할 수 있는 총 시간.\n    - M (int): 동굴 내의 서로 다른 약초의 수.\n    - herbs (List[Tuple[int, int]]): 각 튜플이 약초를 채집하는 데 필요한 시간과\n      약초의 가치를 각각 나타내는 두 개의 정수를 포함하는 튜플의 리스트.\n\n    반환값:\n    - int: 시간 제한 내에서 채집할 수 있는 약초의 최대 총 가치.\n\n    예시:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      이 시나리오에서는 시간 제한 때문에 1 단위의 시간으로 2의 가치를 가진 약초만 채집할 수 있으며,\n      최대 가치는 3이 됩니다.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      여기서는 시간 1, 2, 3의 약초를 채집하는 것이 최선의 전략이며, 최대 가치는 10 + 15 + 20 = 50이 됩니다.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      시간 제한이 5인 경우, 첫 번째 약초만 채집할 수 있으며, 가치는 10이 됩니다.\n    \"\"\"", "ml": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    കൊയ്യാനുള്ള സമയപരിധിക്കുള്ളിൽ കൊയ്യാൻ കഴിയുന്ന ഔഷധങ്ങളുടെ പരമാവധി മൊത്തം മൂല്യം കണക്കാക്കുക.\n\n    ഓരോ ഔഷധവും പരമാവധി ഒരിക്കൽ മാത്രമേ കൊയ്യാൻ കഴിയൂ, കൂടാതെ അതിനൊപ്പം ബന്ധപ്പെട്ട സമയ ചെലവും മൂല്യവും ഉണ്ട്. \n\n    Args:\n    - T (int): ഔഷധങ്ങൾ കൊയ്യാൻ ലഭ്യമായ മൊത്തം സമയം.\n    - M (int): ഗുഹയിൽ ഉള്ള വ്യത്യസ്തമായ ഔഷധങ്ങളുടെ എണ്ണം.\n    - herbs (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും ഔഷധം കൊയ്യാൻ ആവശ്യമായ സമയം, ഔഷധത്തിന്റെ മൂല്യം എന്നിവയെ പ്രതിനിധീകരിക്കുന്ന രണ്ട് പൂർണ്ണസംഖ്യകൾ അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\n    Returns:\n    - int: സമയപരിധിക്കുള്ളിൽ കൊയ്യാൻ കഴിയുന്ന ഔഷധങ്ങളുടെ പരമാവധി മൊത്തം മൂല്യം.\n\n    ഉദാഹരണങ്ങൾ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      ഈ സാഹചര്യത്തിൽ, സമയപരിധി കാരണം 2 മൂല്യമുള്ള 1 യൂണിറ്റ് സമയം എടുക്കുന്ന ഔഷധം മാത്രമേ കൊയ്യാൻ കഴിയൂ, ഇത് പരമാവധി മൂല്യം 3 ആക്കുന്നു.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      ഇവിടെ, മികച്ച തന്ത്രം 1, 2, 3 സമയമുള്ള ഔഷധങ്ങൾ കൊയ്യുന്നതാണ്, ഇത് പരമാവധി മൂല്യം 10 + 15 + 20 = 50 ആക്കുന്നു.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      5 സമയപരിധിയോടെ, ആദ്യത്തെ ഔഷധം മാത്രമേ കൊയ്യാൻ കഴിയൂ, ഇത് 10 മൂല്യം നൽകുന്നു.\n    \"\"\"", "fa": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    حداکثر ارزش کل گیاهانی را که می‌توان در یک محدودیت زمانی مشخص جمع‌آوری کرد، محاسبه کنید.\n\n    این تابع یک نوع از مسئله کوله‌پشتی 0/1 را حل می‌کند که در آن هدف حداکثر کردن\n    ارزش کل گیاهان جمع‌آوری شده بدون تجاوز از محدودیت زمانی است. هر گیاه را می‌توان\n    حداکثر یک بار جمع‌آوری کرد و دارای هزینه زمانی و ارزش مرتبط است.\n\n    آرگومان‌ها:\n    - T (int): زمان کل موجود برای جمع‌آوری گیاهان.\n    - M (int): تعداد گیاهان مختلف در غار.\n    - herbs (List[Tuple[int, int]]): لیستی از زوج‌ها، که هر زوج شامل دو عدد صحیح است\n      که به ترتیب زمان مورد نیاز برای جمع‌آوری گیاه و ارزش گیاه را نشان می‌دهد.\n\n    بازگشت:\n    - int: حداکثر ارزش کل گیاهانی که می‌توان در محدودیت زمانی جمع‌آوری کرد.\n\n    مثال‌ها:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      در این سناریو، تنها گیاهی که 1 واحد زمان برای ارزش 2 نیاز دارد می‌تواند به دلیل\n      محدودیت زمانی جمع‌آوری شود، که منجر به حداکثر ارزش 3 می‌شود.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      در اینجا، بهترین استراتژی این است که گیاهانی با زمان‌های 1، 2 و 3 جمع‌آوری شوند، که منجر به حداکثر ارزش 10 + 15 + 20 = 50 می‌شود.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      با محدودیت زمانی 5، تنها گیاه اول می‌تواند جمع‌آوری شود، که ارزش 10 را فراهم می‌کند.\n    \"\"\""}, "canonical_solution": "    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]", "instruction": {"en": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nՏվեք Python կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত ন্যাচারাল ল্যাঙ্গুয়েজ বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nVerilen Python kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\n以下のPythonコードの説明を日本語で500文字以内の簡潔なドキュメンテーション文字列（docstring）として提供してください。", "ko": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\n다음 Python 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nപൈതൺ കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെയായി നൽകുക.", "fa": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_max_herb_value():\n    # Test case 1: Given example in the problem statement\n    T1, M1 = 70, 3\n    herbs1 = [(71, 100), (69, 1), (1, 2)]\n    expected1 = 3\n    assert max_herb_value(T1, M1,\n                          herbs1) == expected1, f\"Test case 1 failed: expected {expected1}, got {max_herb_value(T1, M1, herbs1)}\"\n\n    # Test case 2: Multiple herbs can be picked within the time limit\n    T2, M2 = 10, 4\n    herbs2 = [(1, 10), (2, 15), (3, 20), (4, 30)]\n    expected2 = 75  # We can pick herbs with time 1, 2 and 3 to get maximum value 10 + 15 + 20\n    assert max_herb_value(T2, M2,\n                          herbs2) == expected2, f\"Test case 2 failed: expected {expected2}, got {max_herb_value(T2, M2, herbs2)}\"\n\n    # Test case 3: Only one herb can be picked due to time constraint\n    T3, M3 = 5, 3\n    herbs3 = [(5, 10), (4, 7), (6, 12)]\n    expected3 = 10  # We can only pick the first herb\n    assert max_herb_value(T3, M3,\n                          herbs3) == expected3, f\"Test case 3 failed: expected {expected3}, got {max_herb_value(T3, M3, herbs3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\ntest_max_herb_value()", "entry_point": "max_herb_value", "signature": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:", "docstring": {"en": "Calculate the maximum total value of herbs that can be picked within a given time limit.\n\nThis function solves a variation of the 0/1 knapsack problem where the goal is to maximize\nthe total value of herbs picked without exceeding the time limit. Each herb can be picked\nat most once and has an associated time cost and value.\n\nArgs:\n- T (int): The total time available for picking herbs.\n- M (int): The number of different herbs in the cave.\n- herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\nrepresenting the time required to pick the herb and the herb's value, respectively.\n\nReturns:\n- int: The maximum total value of herbs that can be picked within the time limit.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nIn this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\nto the time constraint, leading to a maximum value of 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nHere, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nWith a time limit of 5, only the first herb can be picked, providing a value of 10.", "sq": "Llogaritni vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohe.\n\nKjo funksion zgjidh një variant të problemit të çantës 0/1 ku qëllimi është të maksimizohet\nvlera totale e bimëve të mbledhura pa tejkaluar kufirin e kohës. Çdo bimë mund të mblidhet\nmaksimumi një herë dhe ka një kosto kohe dhe vlerë të lidhur.\n\nArgumentet:\n- T (int): Koha totale e disponueshme për mbledhjen e bimëve.\n- M (int): Numri i bimëve të ndryshme në shpellë.\n- herbs (List[Tuple[int, int]]): Një listë tuplesh, ku çdo tuple përmban dy numra të plotë\nqë përfaqësojnë kohën e kërkuar për të mbledhur bimën dhe vlerën e bimës, përkatësisht.\n\nKthen:\n- int: Vlera maksimale totale e bimëve që mund të mblidhen brenda kufirit të kohës.\n\nShembuj:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nNë këtë skenar, vetëm bima që kërkon 1 njësi kohe për një vlerë prej 2 mund të mblidhet për shkak\ntë kufizimit të kohës, duke çuar në një vlerë maksimale prej 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nKëtu, strategjia më e mirë është të mblidhen bimët me kohë 1, 2 dhe 3, duke çuar në një vlerë maksimale prej 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nMe një kufi kohe prej 5, vetëm bima e parë mund të mblidhet, duke ofruar një vlerë prej 10.", "hy": "Հաշվարկել խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակային սահմանափակման շրջանակներում:\n\nԱյս ֆունկցիան լուծում է 0/1 պայուսակի խնդրի տարբերակը, որտեղ նպատակն է առավելագույնացնել\nհավաքված խոտաբույսերի ընդհանուր արժեքը՝ առանց ժամանակային սահմանափակումը գերազանցելու: Յուրաքանչյուր խոտաբույս կարելի է հավաքել\nառավելագույնը մեկ անգամ և ունի կապված ժամանակային արժեք և արժեք:\n\nԱրձագանքներ:\n- T (int): Ընդհանուր ժամանակը, որը հասանելի է խոտաբույսեր հավաքելու համար:\n- M (int): Այլ խոտաբույսերի քանակը քարանձավում:\n- herbs (List[Tuple[int, int]]): Կրկնակի թվերի ցուցակ, որտեղ յուրաքանչյուր կրկնակի պարունակում է երկու ամբողջ թիվ,\nորոնք ներկայացնում են խոտաբույսը հավաքելու համար պահանջվող ժամանակը և խոտաբույսի արժեքը, համապատասխանաբար:\n\nՎերադարձնում է:\n- int: Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել ժամանակային սահմանափակման շրջանակներում:\n\nՕրինակներ:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nԱյս սցենարում, միայն այն խոտաբույսը, որը պահանջում է 1 միավոր ժամանակ 2 արժեքի համար, կարելի է հավաքել\nժամանակային սահմանափակման պատճառով, ինչը հանգեցնում է առավելագույն արժեքի՝ 3:\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nԱյստեղ, լավագույն ռազմավարությունն է հավաքել այն խոտաբույսերը, որոնք ունեն 1, 2 և 3 ժամանակներ, ինչը հանգեցնում է առավելագույն արժեքի՝ 10 + 15 + 20 = 50:\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n5 ժամանակային սահմանափակման դեպքում, միայն առաջին խոտաբույսը կարելի է հավաքել, ինչը ապահովում է 10 արժեք:", "bn": "প্রদত্ত সময়সীমার মধ্যে যতটা সম্ভব সর্বাধিক মূল্যবান ভেষজ সংগ্রহের হিসাব করুন।\n\nএই ফাংশনটি 0/1 ন্যাপকস্যাক সমস্যার একটি রূপ সমাধান করে যেখানে লক্ষ্য হল সময়সীমা অতিক্রম না করে ভেষজ সংগ্রহের মোট মূল্য সর্বাধিক করা। প্রতিটি ভেষজ সর্বাধিক একবার সংগ্রহ করা যেতে পারে এবং এর সাথে একটি নির্দিষ্ট সময় খরচ এবং মূল্য যুক্ত থাকে।\n\nArgs:\n- T (int): ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n- M (int): গুহায় বিভিন্ন ভেষজের সংখ্যা।\n- herbs (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে যা যথাক্রমে ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং ভেষজের মূল্য উপস্থাপন করে।\n\nReturns:\n- int: প্রদত্ত সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্য।\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nএই পরিস্থিতিতে, সময় সীমাবদ্ধতার কারণে শুধুমাত্র সেই ভেষজটি সংগ্রহ করা যেতে পারে যা ১ ইউনিট সময় নেয় এবং যার মূল্য ২, যা সর্বাধিক মূল্য ৩ এ পৌঁছায়।\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nএখানে, সর্বোত্তম কৌশল হল সময় ১, ২, এবং ৩ সহ ভেষজ সংগ্রহ করা, যা সর্বাধিক মূল্য ১০ + ১৫ + ২০ = ৫০ এ পৌঁছায়।\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n৫ সময়সীমার মধ্যে, শুধুমাত্র প্রথম ভেষজটি সংগ্রহ করা যেতে পারে, যা ১০ এর মূল্য প্রদান করে।", "bg": "Изчислете максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n\nТази функция решава вариация на проблема с раницата 0/1, където целта е да се максимизира\nобщата стойност на събраните билки, без да се превишава времевият лимит. Всяка билка може да бъде събрана\nнай-много веднъж и има свързани времеви разходи и стойност.\n\nАргументи:\n- T (int): Общото време, налично за събиране на билки.\n- M (int): Броят на различните билки в пещерата.\n- herbs (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа две цели числа,\nпредставляващи времето, необходимо за събиране на билката и стойността на билката, съответно.\n\nВръща:\n- int: Максималната обща стойност на билките, които могат да бъдат събрани в рамките на времевия лимит.\n\nПримери:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nВ този сценарий, поради времевото ограничение, може да бъде събрана само билката, която отнема 1 единица време за стойност 2,\nводещо до максимална стойност от 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nТук най-добрата стратегия е да се съберат билките с времена 1, 2 и 3, водещо до максимална стойност от 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nС времеви лимит от 5, може да бъде събрана само първата билка, предоставяща стойност от 10.", "zh": "计算在给定时间限制内可以采摘的草药的最大总价值。\n\n此函数解决了0/1背包问题的一个变体，其目标是在不超过时间限制的情况下最大化采摘草药的总价值。每种草药最多可以采摘一次，并且具有相关的时间成本和价值。\n\n参数：\n- T (int): 可用于采摘草药的总时间。\n- M (int): 洞穴中不同草药的数量。\n- herbs (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数，分别表示采摘草药所需的时间和草药的价值。\n\n返回：\n- int: 在时间限制内可以采摘的草药的最大总价值。\n\n示例：\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n在这种情况下，由于时间限制，只能采摘需要1单位时间且价值为2的草药，从而达到最大价值3。\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n在这里，最佳策略是采摘时间为1、2和3的草药，最大价值为10 + 15 + 20 = 50。\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n在时间限制为5的情况下，只能采摘第一种草药，提供价值10。", "fr": "Calculer la valeur totale maximale des herbes qui peuvent être cueillies dans un délai donné.\n\nCette fonction résout une variation du problème du sac à dos 0/1 où l'objectif est de maximiser\nla valeur totale des herbes cueillies sans dépasser la limite de temps. Chaque herbe peut être cueillie\nau plus une fois et a un coût en temps et une valeur associés.\n\nArgs:\n- T (int): Le temps total disponible pour cueillir des herbes.\n- M (int): Le nombre de différentes herbes dans la grotte.\n- herbs (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers\nreprésentant le temps nécessaire pour cueillir l'herbe et la valeur de l'herbe, respectivement.\n\nReturns:\n- int: La valeur totale maximale des herbes qui peuvent être cueillies dans la limite de temps.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nDans ce scénario, seule l'herbe qui prend 1 unité de temps pour une valeur de 2 peut être cueillie en raison\nde la contrainte de temps, conduisant à une valeur maximale de 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nIci, la meilleure stratégie est de cueillir les herbes avec des temps de 1, 2 et 3, conduisant à une valeur maximale de 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nAvec une limite de temps de 5, seule la première herbe peut être cueillie, fournissant une valeur de 10.", "de": "Berechne den maximalen Gesamtwert der Kräuter, die innerhalb eines gegebenen Zeitlimits gepflückt werden können.\n\nDiese Funktion löst eine Variante des 0/1-Rucksackproblems, bei der das Ziel darin besteht, den Gesamtwert der gepflückten Kräuter zu maximieren, ohne das Zeitlimit zu überschreiten. Jedes Kraut kann höchstens einmal gepflückt werden und hat eine zugehörige Zeitkosten und einen Wert.\n\nArgs:\n- T (int): Die insgesamt verfügbare Zeit zum Pflücken der Kräuter.\n- M (int): Die Anzahl der verschiedenen Kräuter in der Höhle.\n- herbs (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält, die die zum Pflücken des Krauts erforderliche Zeit und den Wert des Krauts darstellen.\n\nReturns:\n- int: Der maximale Gesamtwert der Kräuter, die innerhalb des Zeitlimits gepflückt werden können.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nIn diesem Szenario kann aufgrund der Zeitbeschränkung nur das Kraut gepflückt werden, das 1 Zeiteinheit für einen Wert von 2 benötigt, was zu einem maximalen Wert von 3 führt.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nHier ist die beste Strategie, die Kräuter mit den Zeiten 1, 2 und 3 zu pflücken, was zu einem maximalen Wert von 10 + 15 + 20 = 50 führt.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nMit einem Zeitlimit von 5 kann nur das erste Kraut gepflückt werden, was einen Wert von 10 liefert.", "ha": "Ƙididdige mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka cikin iyakar lokacin da aka bayar.\n\nWannan aikin yana warware wani bambancin matsalar 0/1 knapsack inda burin shine a haɓaka\njimillar ƙimar ganyayyaki da aka ɗauka ba tare da wuce iyakar lokaci ba. Kowanne ganye za a iya ɗauka\nsau ɗaya kawai kuma yana da alaƙa da tsadar lokaci da ƙima.\n\nArgs:\n- T (int): Jimillar lokacin da ake da shi don ɗaukar ganyayyaki.\n- M (int): Yawan nau'ikan ganyayyaki daban-daban a cikin kogon.\n- herbs (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple yana ɗauke da lambobi biyu\nyana wakiltar lokacin da ake buƙata don ɗaukar ganyen da ƙimar ganyen, bi da bi.\n\nReturns:\n- int: Mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka cikin iyakar lokacin.\n\nMisalai:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nA wannan yanayin, kawai ganyen da ke ɗaukar 1 na lokaci don ƙimar 2 za a iya ɗauka saboda\nƙuntatawar lokaci, wanda ke haifar da mafi girman ƙima na 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nA nan, mafi kyawun dabaru shine ɗaukar ganyayyaki tare da lokuta 1, 2, da 3, wanda ke haifar da mafi girman ƙima na 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nTare da iyakar lokaci na 5, kawai ganye na farko za a iya ɗauka, yana ba da ƙima na 10.", "hi": "दी गई समय सीमा के भीतर जितनी अधिकतम कुल जड़ी-बूटियों का मूल्य प्राप्त किया जा सकता है, उसकी गणना करें।\n\nयह फ़ंक्शन 0/1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ लक्ष्य है कि समय सीमा को पार किए बिना चुनी गई जड़ी-बूटियों के कुल मूल्य को अधिकतम किया जाए। प्रत्येक जड़ी-बूटी को अधिकतम एक बार चुना जा सकता है और इसका एक संबंधित समय लागत और मूल्य होता है।\n\nआर्ग्स:\n- T (int): जड़ी-बूटियों को चुनने के लिए उपलब्ध कुल समय।\n- M (int): गुफा में विभिन्न जड़ी-बूटियों की संख्या।\n- herbs (List[Tuple[int, int]]): ट्यूपल्स की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं जो क्रमशः जड़ी-बूटी को चुनने के लिए आवश्यक समय और जड़ी-बूटी के मूल्य का प्रतिनिधित्व करते हैं।\n\nरिटर्न्स:\n- int: समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\nउदाहरण:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nइस परिदृश्य में, समय सीमा के कारण केवल वह जड़ी-बूटी चुनी जा सकती है जो 1 इकाई समय में 2 का मूल्य देती है, जिससे अधिकतम मूल्य 3 होता है।\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nयहाँ, सबसे अच्छी रणनीति है कि 1, 2, और 3 समय वाली जड़ी-बूटियाँ चुनी जाएं, जिससे अधिकतम मूल्य 10 + 15 + 20 = 50 होता है।\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n5 की समय सीमा के साथ, केवल पहली जड़ी-बूटी ही चुनी जा सकती है, जो 10 का मूल्य प्रदान करती है।", "hu": "Számítsa ki a maximális összértéket a gyógynövényeknek, amelyeket egy adott időkorláton belül lehet begyűjteni.\n\nEz a függvény megold egy változatot a 0/1 hátizsák problémára, ahol a cél a gyógynövények összértékének maximalizálása anélkül, hogy túllépnénk az időkorlátot. Minden gyógynövényt legfeljebb egyszer lehet begyűjteni, és mindegyikhez társul egy időráfordítás és érték.\n\nArgs:\n- T (int): Az összes rendelkezésre álló idő a gyógynövények begyűjtésére.\n- M (int): A barlangban található különböző gyógynövények száma.\n- herbs (List[Tuple[int, int]]): Egy lista, amelyben minden egyes elem egy pár, amely két egész számot tartalmaz, az első a gyógynövény begyűjtéséhez szükséges időt, a második pedig a gyógynövény értékét jelöli.\n\nReturns:\n- int: A maximális összérték a gyógynövényeknek, amelyeket az időkorláton belül lehet begyűjteni.\n\nPéldák:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nEbben a helyzetben csak az a gyógynövény gyűjthető be, amely 1 egységnyi időt igényel és 2 értéket ad, az időkorlát miatt, ami 3 maximális értékhez vezet.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nItt a legjobb stratégia az 1, 2 és 3 időt igénylő gyógynövények begyűjtése, ami 10 + 15 + 20 = 50 maximális értékhez vezet.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n5-ös időkorláttal csak az első gyógynövény gyűjthető be, amely 10 értéket ad.", "es": "Calcular el valor total máximo de hierbas que se pueden recoger dentro de un límite de tiempo dado.\n\nEsta función resuelve una variación del problema de la mochila 0/1 donde el objetivo es maximizar\nel valor total de las hierbas recogidas sin exceder el límite de tiempo. Cada hierba se puede recoger\ncomo máximo una vez y tiene un costo de tiempo y un valor asociados.\n\nArgumentos:\n- T (int): El tiempo total disponible para recoger hierbas.\n- M (int): El número de diferentes hierbas en la cueva.\n- herbs (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros\nque representan el tiempo requerido para recoger la hierba y el valor de la hierba, respectivamente.\n\nDevuelve:\n- int: El valor total máximo de hierbas que se pueden recoger dentro del límite de tiempo.\n\nEjemplos:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nEn este escenario, solo se puede recoger la hierba que toma 1 unidad de tiempo por un valor de 2 debido\na la restricción de tiempo, lo que lleva a un valor máximo de 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nAquí, la mejor estrategia es recoger hierbas con tiempos 1, 2 y 3, lo que lleva a un valor máximo de 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nCon un límite de tiempo de 5, solo se puede recoger la primera hierba, proporcionando un valor de 10.", "arb": "حساب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n\nتحل هذه الدالة نوعًا من مشكلة حقيبة الظهر 0/1 حيث يكون الهدف هو تعظيم القيمة الإجمالية للأعشاب المجمعة دون تجاوز الحد الزمني. يمكن جمع كل عشبة مرة واحدة على الأكثر ولها تكلفة زمنية وقيمة مرتبطة بها.\n\nيعيدالحجج:\n- T (int): الوقت الإجمالي المتاح لجمع الأعشاب.\n- M (int): عدد الأعشاب المختلفة في الكهف.\n- herbs (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين يمثلان الوقت المطلوب لجمع العشبة وقيمة العشبة، على التوالي.\n\nيعيد:\n- int: القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الحد الزمني.\n\nامثله:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nفي هذا السيناريو، يمكن جمع العشبة التي تستغرق وحدة زمنية واحدة فقط بقيمة 2 بسبب القيد الزمني، مما يؤدي إلى قيمة قصوى تبلغ 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nهنا، أفضل استراتيجية هي جمع الأعشاب ذات الأوقات 1 و2 و3، مما يؤدي إلى قيمة قصوى تبلغ 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nمع حد زمني يبلغ 5، يمكن جمع العشبة الأولى فقط، مما يوفر قيمة تبلغ 10.", "sw": "Hesabu thamani ya juu kabisa ya mimea ambayo inaweza kuchumwa ndani ya kikomo cha muda kilichopewa.\n\nKazi hii inatatua tofauti ya tatizo la 0/1 knapsack ambapo lengo ni kuongeza\nthamani ya jumla ya mimea iliyochumwa bila kuzidi kikomo cha muda. Kila mmea unaweza kuchumwa\nmara moja tu na una gharama ya muda na thamani inayohusiana.\n\nHoja:\n- T (int): Jumla ya muda unaopatikana kwa kuchuma mimea.\n- M (int): Idadi ya mimea tofauti kwenye pango.\n- herbs (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili\nzinazoonyesha muda unaohitajika kuchuma mmea na thamani ya mmea, mtawalia.\n\nInarejesha:\n- int: Thamani ya juu kabisa ya mimea ambayo inaweza kuchumwa ndani ya kikomo cha muda.\n\nMifano:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nKatika hali hii, mmea pekee unaochukua muda wa kitengo 1 kwa thamani ya 2 unaweza kuchumwa kwa sababu\nya kizuizi cha muda, na kusababisha thamani ya juu kabisa ya 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nHapa, mkakati bora ni kuchuma mimea yenye muda 1, 2, na 3, na kusababisha thamani ya juu kabisa ya 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nKwa kikomo cha muda cha 5, mmea wa kwanza tu unaweza kuchumwa, ukitoa thamani ya 10.", "tr": "Belirli bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplayın.\n\nBu fonksiyon, zaman sınırını aşmadan toplanan otların toplam değerini maksimize etmeyi amaçlayan 0/1 sırt çantası probleminin bir varyasyonunu çözer. Her ot en fazla bir kez toplanabilir ve bir zaman maliyeti ve değeri ile ilişkilidir.\n\nArgümanlar:\n- T (int): Ot toplamak için mevcut toplam zaman.\n- M (int): Mağaradaki farklı otların sayısı.\n- herbs (List[Tuple[int, int]]): Her bir demetin otu toplamak için gereken zamanı ve otun değerini temsil eden iki tam sayı içeren demetlerden oluşan bir liste.\n\nDöndürür:\n- int: Zaman sınırı içinde toplanabilecek otların maksimum toplam değeri.\n\nÖrnekler:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nBu senaryoda, zaman kısıtlaması nedeniyle yalnızca 2 değerinde ve 1 birim zaman alan ot toplanabilir, bu da maksimum 3 değerine yol açar.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nBurada, en iyi strateji 1, 2 ve 3 zamanlı otları toplamaktır, bu da 10 + 15 + 20 = 50 maksimum değerine yol açar.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n5 zaman sınırı ile yalnızca ilk ot toplanabilir ve bu 10 değer sağlar.", "vi": "Tính tổng giá trị tối đa của các loại thảo mộc có thể được hái trong giới hạn thời gian cho phép.\n\nHàm này giải quyết một biến thể của bài toán cái túi 0/1, trong đó mục tiêu là tối đa hóa\ntổng giá trị của các loại thảo mộc được hái mà không vượt quá giới hạn thời gian. Mỗi loại thảo mộc có thể được hái\ntối đa một lần và có một chi phí thời gian và giá trị tương ứng.\n\nTham số:\n- T (int): Tổng thời gian có sẵn để hái thảo mộc.\n- M (int): Số lượng các loại thảo mộc khác nhau trong hang động.\n- herbs (List[Tuple[int, int]]): Một danh sách các bộ đôi, trong đó mỗi bộ đôi chứa hai số nguyên\nđại diện cho thời gian cần thiết để hái thảo mộc và giá trị của thảo mộc đó, tương ứng.\n\nTrả về:\n- int: Tổng giá trị tối đa của các loại thảo mộc có thể được hái trong giới hạn thời gian.\n\nVí dụ:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nTrong trường hợp này, chỉ có loại thảo mộc cần 1 đơn vị thời gian với giá trị 2 có thể được hái do\ngiới hạn thời gian, dẫn đến giá trị tối đa là 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nỞ đây, chiến lược tốt nhất là hái các loại thảo mộc với thời gian 1, 2 và 3, dẫn đến giá trị tối đa là 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nVới giới hạn thời gian là 5, chỉ có loại thảo mộc đầu tiên có thể được hái, cung cấp giá trị là 10.", "id": "Hitung nilai total maksimum dari ramuan yang dapat dipetik dalam batas waktu yang diberikan.\n\nFungsi ini menyelesaikan variasi dari masalah knapsack 0/1 di mana tujuannya adalah untuk memaksimalkan nilai total ramuan yang dipetik tanpa melebihi batas waktu. Setiap ramuan dapat dipetik paling banyak sekali dan memiliki biaya waktu dan nilai yang terkait.\n\nArgs:\n- T (int): Total waktu yang tersedia untuk memetik ramuan.\n- M (int): Jumlah berbagai ramuan di dalam gua.\n- herbs (List[Tuple[int, int]]): Daftar tuple, di mana setiap tuple berisi dua bilangan bulat yang mewakili waktu yang dibutuhkan untuk memetik ramuan dan nilai ramuan tersebut, masing-masing.\n\nReturns:\n- int: Nilai total maksimum dari ramuan yang dapat dipetik dalam batas waktu.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nDalam skenario ini, hanya ramuan yang membutuhkan waktu 1 unit dengan nilai 2 yang dapat dipetik karena batasan waktu, menghasilkan nilai maksimum 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nDi sini, strategi terbaik adalah memetik ramuan dengan waktu 1, 2, dan 3, menghasilkan nilai maksimum 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nDengan batas waktu 5, hanya ramuan pertama yang dapat dipetik, memberikan nilai 10.", "ja": "与えられた時間制限内で摘むことができるハーブの最大総価値を計算します。\n\nこの関数は、0/1ナップサック問題の変種を解決します。ここでは、時間制限を超えずに摘むハーブの総価値を最大化することが目標です。各ハーブは最大で1回だけ摘むことができ、関連する時間コストと価値があります。\n\n引数:\n- T (int): ハーブを摘むために利用可能な総時間。\n- M (int): 洞窟内の異なるハーブの数。\n- herbs (List[Tuple[int, int]]): 各タプルがハーブを摘むのに必要な時間とハーブの価値を表す2つの整数を含むタプルのリスト。\n\n戻り値:\n- int: 時間制限内で摘むことができるハーブの最大総価値。\n\n例:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nこのシナリオでは、時間制限のため、2の価値を持つ1単位の時間を要するハーブのみが摘むことができ、最大価値は3になります。\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nここでは、時間1, 2, 3のハーブを摘むのが最良の戦略で、最大価値は10 + 15 + 20 = 50になります。\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n時間制限が5の場合、最初のハーブのみを摘むことができ、価値は10になります。", "ko": "주어진 시간 제한 내에서 채집할 수 있는 약초의 최대 총 가치를 계산합니다.\n\n이 함수는 0/1 배낭 문제의 변형을 해결하며, 목표는 시간 제한을 초과하지 않고 채집한 약초의 총 가치를 최대화하는 것입니다. 각 약초는 최대 한 번만 채집할 수 있으며, 관련된 시간 비용과 가치가 있습니다.\n\nArgs:\n- T (int): 약초를 채집할 수 있는 총 시간.\n- M (int): 동굴 내의 서로 다른 약초의 수.\n- herbs (List[Tuple[int, int]]): 각 튜플이 약초를 채집하는 데 필요한 시간과 약초의 가치를 각각 나타내는 두 개의 정수를 포함하는 튜플의 리스트.\n\nReturns:\n- int: 시간 제한 내에서 채집할 수 있는 약초의 최대 총 가치.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n이 시나리오에서는 시간 제약으로 인해 1 단위의 시간이 걸리고 가치가 2인 약초만 채집할 수 있으며, 최대 가치는 3이 됩니다.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n여기서는 1, 2, 3의 시간을 가진 약초를 채집하는 것이 최선의 전략이며, 최대 가치는 10 + 15 + 20 = 50이 됩니다.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n시간 제한이 5인 경우, 첫 번째 약초만 채집할 수 있으며, 가치는 10이 됩니다.", "ml": "നൽകിയിരിക്കുന്ന സമയപരിധിക്കുള്ളിൽ തിരഞ്ഞെടുക്കാൻ കഴിയുന്ന ഔഷധങ്ങളുടെ പരമാവധി മൊത്തം മൂല്യം കണക്കാക്കുക.\n\nഈ ഫംഗ്ഷൻ 0/1 നാപ്സാക്ക് പ്രശ്നത്തിന്റെ ഒരു വ്യതിയാനമാണ് പരിഹരിക്കുന്നത്, ഇവിടെ ലക്ഷ്യം സമയപരിധി കവിയാതെ തിരഞ്ഞെടുക്കുന്ന ഔഷധങ്ങളുടെ മൊത്തം മൂല്യം പരമാവധി ആക്കുകയാണ്. ഓരോ ഔഷധവും പരമാവധി ഒരിക്കൽ മാത്രമേ തിരഞ്ഞെടുക്കാൻ കഴിയൂ, കൂടാതെ അതിനോട് അനുബന്ധിച്ചുള്ള സമയ ചെലവും മൂല്യവും ഉണ്ട്.\n\nആർഗ്സ്:\n- T (int): ഔഷധങ്ങൾ തിരഞ്ഞെടുക്കുന്നതിനുള്ള മൊത്തം ലഭ്യമായ സമയം.\n- M (int): ഗുഹയിലെ വ്യത്യസ്ത ഔഷധങ്ങളുടെ എണ്ണം.\n- herbs (List[Tuple[int, int]]): ഓരോ ട്യുപിളും ഔഷധം തിരഞ്ഞെടുക്കുന്നതിനാവശ്യമായ സമയം, ഔഷധത്തിന്റെ മൂല്യം എന്നിവയെ പ്രതിനിധീകരിക്കുന്ന രണ്ട് പൂർണ്ണസംഖ്യകൾ അടങ്ങിയ ട്യുപിളുകളുടെ പട്ടിക.\n\nമടക്കം:\n- int: സമയപരിധിക്കുള്ളിൽ തിരഞ്ഞെടുക്കാൻ കഴിയുന്ന ഔഷധങ്ങളുടെ പരമാവധി മൊത്തം മൂല്യം.\n\nഉദാഹരണങ്ങൾ:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nഈ സാഹചര്യത്തിൽ, സമയപരിധി കാരണം മൂല്യം 2 ആയ 1 യൂണിറ്റ് സമയം എടുക്കുന്ന ഔഷധം മാത്രമേ തിരഞ്ഞെടുക്കാൻ കഴിയൂ, 3 എന്ന പരമാവധി മൂല്യത്തിലേക്ക് നയിക്കുന്നു.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nഇവിടെ, മികച്ച തന്ത്രം 1, 2, 3 സമയമുള്ള ഔഷധങ്ങൾ തിരഞ്ഞെടുക്കുന്നതാണ്, 10 + 15 + 20 = 50 എന്ന പരമാവധി മൂല്യത്തിലേക്ക് നയിക്കുന്നു.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n5 എന്ന സമയപരിധിയോടെ, ആദ്യ ഔഷധം മാത്രമേ തിരഞ്ഞെടുക്കാൻ കഴിയൂ, 10 എന്ന മൂല്യം നൽകുന്നു.", "fa": "محاسبه حداکثر ارزش کل گیاهانی که می‌توان در یک محدودیت زمانی معین چید.\n\nاین تابع یک نوع از مسئله کوله‌پشتی 0/1 را حل می‌کند که هدف آن به حداکثر رساندن ارزش کل گیاهان چیده شده بدون تجاوز از محدودیت زمانی است. هر گیاه را می‌توان حداکثر یک بار چید و هر کدام دارای هزینه زمانی و ارزش مرتبط هستند.\n\nآرگومان‌ها:\n- T (int): کل زمان موجود برای چیدن گیاهان.\n- M (int): تعداد گیاهان مختلف در غار.\n- herbs (List[Tuple[int, int]]): لیستی از زوج‌ها، که هر زوج شامل دو عدد صحیح است که به ترتیب زمان مورد نیاز برای چیدن گیاه و ارزش گیاه را نشان می‌دهند.\n\nبازگشت:\n- int: حداکثر ارزش کل گیاهانی که می‌توان در محدودیت زمانی چید.\n\nمثال‌ها:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nدر این سناریو، تنها گیاهی که 1 واحد زمان برای ارزش 2 نیاز دارد می‌تواند به دلیل محدودیت زمانی چیده شود، که منجر به حداکثر ارزش 3 می‌شود.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nدر اینجا، بهترین استراتژی چیدن گیاهانی با زمان‌های 1، 2 و 3 است که منجر به حداکثر ارزش 10 + 15 + 20 = 50 می‌شود.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nبا محدودیت زمانی 5، تنها گیاه اول می‌تواند چیده شود که ارزش 10 را فراهم می‌کند."}}
{"task_id": "Python/38", "prompt": {"en": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      All items can be fit into the box without any remaining space.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      An optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Since all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.\n    \"\"\"", "sq": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Llogarit hapësirën minimale të mbetur në një kuti pasi të përpiqesh të vendosësh një numër artikujsh me vëllime të dhëna.\n    \n    Kjo funksion përdor një qasje të programimit dinamik për të përcaktuar vëllimin maksimal që mund të zërë\n    në kuti nga çdo nëngrup i artikujve të dhënë. Pastaj kthen diferencën midis kapacitetit total të kutisë\n    dhe këtij vëllimi maksimal të zënë, që është hapësira minimale e mbetur.\n\n    Argumentet:\n    - V (int): Kapaciteti total i kutisë.\n    - n (int): Numri i artikujve për t'u konsideruar për paketim në kuti.\n    - volumes (List[int]): Një listë e vëllimeve të n artikujve.\n\n    Kthen:\n    - int: Hapësira minimale e mbetur në kuti pas vendosjes së artikujve.\n\n    Shembuj:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Të gjithë artikujt mund të vendosen në kuti pa asnjë hapësirë të mbetur.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Një mënyrë optimale për të vendosur artikujt mund të jetë marrja e artikujve me vëllime 3, 5, dhe 3, që lë 2 njësi hapësirë.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Meqenëse të gjithë artikujt kanë një vëllim më të madh se kapaciteti i kutisë, asnjë nuk mund të vendoset dhe i gjithë kapaciteti i kutisë mbetet.\n    \"\"\"", "hy": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Հաշվարկել արկղում մնացած նվազագույն տարածությունը այն բանից հետո, երբ փորձում ենք տեղավորել տրված ծավալներով մի շարք իրեր:\n    \n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար առավելագույն ծավալը, որը կարող է զբաղեցնել\n    արկղում տրված իրերի ցանկացած ենթաբազմություն: Այնուհետև վերադարձնում է արկղի ընդհանուր տարողության և այս առավելագույն զբաղեցրած ծավալի տարբերությունը, որը նվազագույն մնացած տարածությունն է:\n\n    Արգումենտներ:\n    - V (int): Արկղի ընդհանուր տարողությունը:\n    - n (int): Իրերի քանակը, որոնք պետք է հաշվի առնել արկղում տեղավորելու համար:\n    - volumes (List[int]): n իրերի ծավալների ցուցակ:\n\n    Վերադարձնում է:\n    - int: Նվազագույն մնացած տարածությունը արկղում իրերը տեղավորելուց հետո:\n\n    Օրինակներ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Բոլոր իրերը կարող են տեղավորվել արկղում առանց որևէ մնացած տարածության:\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Իրերը տեղավորելու օպտիմալ եղանակ կարող է լինել 3, 5 և 3 ծավալներով իրերի վերցնելը, ինչը թողնում է 2 միավոր տարածություն:\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Քանի որ բոլոր իրերի ծավալը մեծ է արկղի տարողությունից, ոչ մեկը չի կարող տեղավորվել, և ամբողջ արկղի տարողությունը մնում է:\n    \"\"\"", "bn": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    একটি বাক্সে নির্দিষ্ট ভলিউমের কিছু আইটেম ফিট করার পর বাক্সে অবশিষ্ট ন্যূনতম স্থান গণনা করুন।\n    \n    এই ফাংশনটি একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে নির্ধারণ করে যে প্রদত্ত আইটেমগুলির যেকোনো উপসেট দ্বারা বাক্সে সর্বাধিক কত ভলিউম দখল করা যেতে পারে। তারপর এটি বাক্সের মোট ক্ষমতা এবং এই সর্বাধিক দখলকৃত ভলিউমের মধ্যে পার্থক্য ফিরিয়ে দেয়, যা ন্যূনতম অবশিষ্ট স্থান।\n\n    আর্গুমেন্টসমূহ:\n    - V (int): বাক্সের মোট ক্ষমতা।\n    - n (int): বাক্সে প্যাক করার জন্য বিবেচনা করা আইটেমের সংখ্যা।\n    - volumes (List[int]): n আইটেমের ভলিউমের একটি তালিকা।\n\n    রিটার্নস:\n    - int: আইটেম ফিট করার পর বাক্সে অবশিষ্ট ন্যূনতম স্থান।\n\n    উদাহরণ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      সব আইটেম বাক্সে ফিট করা যায় কোনো অবশিষ্ট স্থান ছাড়াই।\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      আইটেম ফিট করার একটি সর্বোত্তম উপায় হতে পারে 3, 5, এবং 3 ভলিউমের আইটেম নেওয়া, যা 2 ইউনিট স্থান অবশিষ্ট রাখে।\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      যেহেতু সব আইটেমের ভলিউম বাক্সের ক্ষমতার চেয়ে বেশি, কোনোটি ফিট করা যায় না এবং পুরো বাক্সের ক্ষমতা অবশিষ্ট থাকে।\n    \"\"\"", "bg": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Изчислява минималното оставащо пространство в кутия след опит да се поберат определен брой предмети с дадени обеми.\n    \n    Тази функция използва подход на динамично програмиране, за да определи максималния обем, който може да бъде зает\n    в кутията от всяко подмножество на дадените предмети. След това връща разликата между общия капацитет на кутията\n    и този максимален зает обем, което е минималното оставащо пространство.\n\n    Аргументи:\n    - V (int): Общият капацитет на кутията.\n    - n (int): Броят на предметите, които да се разгледат за опаковане в кутията.\n    - volumes (List[int]): Списък с обемите на n-те предмета.\n\n    Връща:\n    - int: Минималното оставащо пространство в кутията след побирането на предметите.\n\n    Примери:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Всички предмети могат да бъдат побрани в кутията без оставащо пространство.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Оптимален начин за побиране на предметите може да бъде вземане на предмети с обеми 3, 5 и 3, което оставя 2 единици пространство.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Тъй като всички предмети имат обем по-голям от капацитета на кутията, нито един не може да бъде побран и целият капацитет на кутията остава.\n    \"\"\"", "zh": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    计算在尝试将若干具有给定体积的物品放入箱子后，箱子中剩余的最小空间。\n\n    此函数使用动态规划方法来确定通过给定物品的任意子集可以占据箱子的最大体积。\n    然后返回箱子总容量与此最大占用体积之间的差值，即最小剩余空间。\n\n    参数:\n    - V (int): 箱子的总容量。\n    - n (int): 考虑放入箱子的物品数量。\n    - volumes (List[int]): n个物品的体积列表。\n\n    返回:\n    - int: 放入物品后箱子中剩余的最小空间。\n\n    示例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      所有物品可以放入箱子中，没有剩余空间。\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      放置物品的最佳方式可能是选择体积为3、5和3的物品，剩下2个单位的空间。\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      由于所有物品的体积都大于箱子容量，无法放入任何物品，整个箱子容量保持不变。\n    \"\"\"", "fr": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculer l'espace restant minimum dans une boîte après avoir essayé de placer un certain nombre d'articles avec des volumes donnés.\n    \n    Cette fonction utilise une approche de programmation dynamique pour déterminer le volume maximum qui peut être occupé\n    dans la boîte par n'importe quel sous-ensemble des articles donnés. Elle renvoie ensuite la différence entre la capacité totale de la boîte\n    et ce volume maximum occupé, qui est l'espace restant minimum.\n\n    Args:\n    - V (int) : La capacité totale de la boîte.\n    - n (int) : Le nombre d'articles à considérer pour le rangement dans la boîte.\n    - volumes (List[int]) : Une liste des volumes des n articles.\n\n    Returns:\n    - int : L'espace restant minimum dans la boîte après avoir rangé les articles.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Tous les articles peuvent être rangés dans la boîte sans aucun espace restant.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Une façon optimale de ranger les articles pourrait être de prendre des articles avec des volumes de 3, 5, et 3, ce qui laisse 2 unités d'espace.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Puisque tous les articles ont un volume supérieur à la capacité de la boîte, aucun ne peut être rangé et la capacité totale de la boîte reste.\n    \"\"\"", "de": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Berechne den minimal verbleibenden Platz in einer Box, nachdem versucht wurde, eine Anzahl von Gegenständen mit gegebenen Volumina unterzubringen.\n    \n    Diese Funktion verwendet einen dynamischen Programmierungsansatz, um das maximale Volumen zu bestimmen, das durch eine beliebige Teilmenge der gegebenen Gegenstände in der Box belegt werden kann. Sie gibt dann die Differenz zwischen der Gesamtkapazität der Box und diesem maximal belegten Volumen zurück, was den minimal verbleibenden Platz darstellt.\n\n    Argumente:\n    - V (int): Die Gesamtkapazität der Box.\n    - n (int): Die Anzahl der Gegenstände, die in die Box gepackt werden sollen.\n    - volumes (List[int]): Eine Liste der Volumina der n Gegenstände.\n\n    Rückgabewert:\n    - int: Der minimal verbleibende Platz in der Box nach dem Einpassen der Gegenstände.\n\n    Beispiele:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Alle Gegenstände können ohne verbleibenden Platz in die Box passen.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Eine optimale Möglichkeit, die Gegenstände einzupassen, könnte darin bestehen, Gegenstände mit den Volumina 3, 5 und 3 zu nehmen, was 2 Einheiten Platz übrig lässt.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Da alle Gegenstände ein Volumen größer als die Boxkapazität haben, kann keiner passen und die gesamte Boxkapazität bleibt erhalten.\n    \"\"\"", "ha": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Lissafi mafi ƙarancin sarari da ya rage a cikin akwati bayan ƙoƙarin sanya adadin abubuwa tare da girma da aka bayar.\n\n    Wannan aikin yana amfani da hanyar shirye-shiryen motsi don ƙayyade mafi girman girman da za a iya mamaye\n    a cikin akwatin ta kowace ƙungiya ta abubuwan da aka bayar. Sannan yana dawo da bambanci tsakanin jimlar ƙarfin akwatin\n    da wannan mafi girman girman da aka mamaye, wanda shine mafi ƙarancin sarari da ya rage.\n\n    Args:\n    - V (int): Jimlar ƙarfin akwatin.\n    - n (int): Adadin abubuwan da za a yi la'akari da su don cika cikin akwatin.\n    - volumes (List[int]): Jerin girman abubuwan n.\n\n    Returns:\n    - int: Mafi ƙarancin sarari da ya rage a cikin akwatin bayan cika abubuwan.\n\n    Misalai:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Duk abubuwan za a iya cika su cikin akwatin ba tare da wani sarari da ya rage ba.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Hanya mafi kyau don cika abubuwan na iya zama ɗaukar abubuwa tare da girma 3, 5, da 3, wanda ke barin sarari guda 2.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Tun da duk abubuwan suna da girma fiye da ƙarfin akwatin, babu wanda za a iya cika kuma duka ƙarfin akwatin ya rage.\n    \"\"\"", "hi": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    दिए गए वॉल्यूम वाले वस्तुओं की संख्या को फिट करने की कोशिश करने के बाद बॉक्स में न्यूनतम शेष स्थान की गणना करें।\n\n    यह फ़ंक्शन एक डायनामिक प्रोग्रामिंग दृष्टिकोण का उपयोग करता है ताकि यह निर्धारित किया जा सके कि दिए गए वस्तुओं के किसी भी उपसमूह द्वारा बॉक्स में अधिकतम वॉल्यूम कितना भरा जा सकता है। \n    फिर यह बॉक्स की कुल क्षमता और इस अधिकतम भरे हुए वॉल्यूम के बीच का अंतर लौटाता है, जो न्यूनतम शेष स्थान है।\n\n    तर्क:\n    - V (int): बॉक्स की कुल क्षमता।\n    - n (int): बॉक्स में पैक करने के लिए विचार करने वाली वस्तुओं की संख्या।\n    - volumes (List[int]): n वस्तुओं के वॉल्यूम की सूची।\n\n    रिटर्न्स:\n    - int: वस्तुओं को फिट करने के बाद बॉक्स में न्यूनतम शेष स्थान।\n\n    उदाहरण:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      सभी वस्तुएं बिना किसी शेष स्थान के बॉक्स में फिट हो सकती हैं।\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      वस्तुओं को फिट करने का एक आदर्श तरीका हो सकता है वॉल्यूम 3, 5, और 3 वाली वस्तुओं को लेना, जिससे 2 इकाई स्थान बचता है।\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      चूंकि सभी वस्तुओं का वॉल्यूम बॉक्स की क्षमता से अधिक है, कोई भी फिट नहीं हो सकता और पूरी बॉक्स क्षमता शेष रहती है।\n    \"\"\"", "hu": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Számítsa ki a minimális megmaradó helyet egy dobozban, miután megpróbálja elhelyezni a megadott térfogatú tárgyakat.\n    \n    Ez a függvény dinamikus programozási megközelítést alkalmaz annak meghatározására, hogy a megadott tárgyak bármely részhalmazával\n    mekkora maximális térfogat foglalható el a dobozban. Ezután visszaadja a doboz teljes kapacitása és a maximálisan elfoglalt térfogat\n    közötti különbséget, ami a minimális megmaradó hely.\n\n    Paraméterek:\n    - V (int): A doboz teljes kapacitása.\n    - n (int): A dobozba csomagolni kívánt tárgyak száma.\n    - volumes (List[int]): Az n tárgy térfogatainak listája.\n\n    Visszatérési érték:\n    - int: A minimális megmaradó hely a dobozban a tárgyak elhelyezése után.\n\n    Példák:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Minden tárgy elhelyezhető a dobozban maradék hely nélkül.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Az optimális elhelyezés lehet a 3, 5 és 3 térfogatú tárgyak kiválasztása, ami 2 egységnyi helyet hagy.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Mivel minden tárgy térfogata nagyobb, mint a doboz kapacitása, egyik sem helyezhető el, így a teljes doboz kapacitása megmarad.\n    \"\"\"", "es": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calcula el espacio mínimo restante en una caja después de intentar encajar un número de artículos con volúmenes dados.\n    \n    Esta función utiliza un enfoque de programación dinámica para determinar el volumen máximo que puede ser ocupado\n    en la caja por cualquier subconjunto de los artículos dados. Luego devuelve la diferencia entre la capacidad total de la caja\n    y este volumen máximo ocupado, que es el espacio mínimo restante.\n\n    Argumentos:\n    - V (int): La capacidad total de la caja.\n    - n (int): El número de artículos a considerar para empacar en la caja.\n    - volumes (List[int]): Una lista de los volúmenes de los n artículos.\n\n    Devuelve:\n    - int: El espacio mínimo restante en la caja después de encajar los artículos.\n\n    Ejemplos:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Todos los artículos pueden ser encajados en la caja sin ningún espacio restante.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Una forma óptima de encajar los artículos podría ser tomando artículos con volúmenes 3, 5 y 3, lo que deja 2 unidades de espacio.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Dado que todos los artículos tienen un volumen mayor que la capacidad de la caja, ninguno puede ser encajado y la capacidad total de la caja permanece.\n    \"\"\"", "arb": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    حساب الحد الأدنى من المساحة المتبقية في صندوق بعد محاولة وضع عدد من العناصر ذات الأحجام المعطاة.\n\n    تستخدم هذه الدالة نهج البرمجة الديناميكية لتحديد الحد الأقصى للحجم الذي يمكن أن يشغله\n    في الصندوق بواسطة أي مجموعة فرعية من العناصر المعطاة. ثم تعيد الفرق بين السعة الإجمالية للصندوق\n    وهذا الحجم المشغول الأقصى، وهو الحد الأدنى من المساحة المتبقية.\n\n    يعيدالحجج:\n    - V (int): السعة الإجمالية للصندوق.\n    - n (int): عدد العناصر المراد النظر فيها للتعبئة في الصندوق.\n    - volumes (List[int]): قائمة بأحجام العناصر n.\n\n    يعيد:\n    - int: الحد الأدنى من المساحة المتبقية في الصندوق بعد وضع العناصر.\n\n    أمثلة:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      يمكن وضع جميع العناصر في الصندوق دون أي مساحة متبقية.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      طريقة مثلى لوضع العناصر يمكن أن تكون بأخذ العناصر ذات الأحجام 3، 5، و3، مما يترك 2 وحدة من المساحة.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      نظرًا لأن جميع العناصر لها حجم أكبر من سعة الصندوق، لا يمكن وضع أي منها وتبقى السعة الكاملة للصندوق.\n    \"\"\"", "sw": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Kuhesabu nafasi ndogo inayobaki kwenye sanduku baada ya kujaribu kutoshea idadi ya vitu vilivyo na ujazo uliotolewa.\n    \n    Kazi hii inatumia mbinu ya programu ya nguvu ili kubaini ujazo wa juu zaidi ambao unaweza kuchukuliwa\n    kwenye sanduku na seti yoyote ndogo ya vitu vilivyotolewa. Kisha inarudisha tofauti kati ya uwezo wa jumla wa sanduku\n    na huu ujazo wa juu uliotwaliwa, ambayo ni nafasi ndogo inayobaki.\n\n    Hoja:\n    - V (int): Uwezo wa jumla wa sanduku.\n    - n (int): Idadi ya vitu vya kuzingatia kwa kufunga kwenye sanduku.\n    - volumes (List[int]): Orodha ya ujazo wa vitu n.\n\n    Inarejesha:\n    - int: Nafasi ndogo inayobaki kwenye sanduku baada ya kutoshea vitu.\n\n    Mifano:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Vitu vyote vinaweza kutoshea kwenye sanduku bila nafasi yoyote inayobaki.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Njia bora ya kutoshea vitu inaweza kuwa kuchukua vitu vyenye ujazo 3, 5, na 3, ambayo inaacha nafasi ya vitengo 2.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Kwa kuwa vitu vyote vina ujazo mkubwa kuliko uwezo wa sanduku, hakuna kinachoweza kutoshea na uwezo wote wa sanduku unabaki.\n    \"\"\"", "tr": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Belirli hacimlere sahip bir dizi öğeyi yerleştirmeye çalıştıktan sonra bir kutuda kalan minimum alanı hesaplayın.\n    \n    Bu fonksiyon, verilen öğelerin herhangi bir alt kümesi tarafından kutuda işgal edilebilecek maksimum hacmi belirlemek için dinamik programlama yaklaşımı kullanır.\n    Daha sonra kutunun toplam kapasitesi ile bu maksimum işgal edilen hacim arasındaki farkı döndürür, bu da kalan minimum alandır.\n\n    Argümanlar:\n    - V (int): Kutunun toplam kapasitesi.\n    - n (int): Kutunun içine yerleştirilmesi düşünülen öğe sayısı.\n    - volumes (List[int]): n öğesinin hacimlerinin bir listesi.\n\n    Döndürür:\n    - int: Öğeleri yerleştirdikten sonra kutuda kalan minimum alan.\n\n    Örnekler:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Tüm öğeler, hiç boş alan kalmadan kutuya sığdırılabilir.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Öğeleri yerleştirmenin optimal bir yolu, hacimleri 3, 5 ve 3 olan öğeleri almak olabilir, bu da 2 birim alan bırakır.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Tüm öğelerin hacmi kutu kapasitesinden büyük olduğundan, hiçbiri sığdırılamaz ve tüm kutu kapasitesi kalır.\n    \"\"\"", "vi": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Tính toán không gian còn lại tối thiểu trong một hộp sau khi cố gắng đặt một số lượng đồ vật với các thể tích cho trước.\n\n    Hàm này sử dụng phương pháp lập trình động để xác định thể tích tối đa có thể được chiếm trong hộp\n    bởi bất kỳ tập hợp con nào của các đồ vật đã cho. Sau đó, nó trả về sự khác biệt giữa tổng dung tích của hộp\n    và thể tích tối đa đã chiếm, đó là không gian còn lại tối thiểu.\n\n    Tham số:\n    - V (int): Tổng dung tích của hộp.\n    - n (int): Số lượng đồ vật cần xem xét để đóng gói vào hộp.\n    - volumes (List[int]): Danh sách thể tích của n đồ vật.\n\n    Trả về:\n    - int: Không gian còn lại tối thiểu trong hộp sau khi đặt các đồ vật.\n\n    Ví dụ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Tất cả các đồ vật có thể được đặt vào hộp mà không còn không gian thừa.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Một cách tối ưu để đặt các đồ vật có thể là lấy các đồ vật có thể tích 3, 5, và 3, để lại 2 đơn vị không gian.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Vì tất cả các đồ vật đều có thể tích lớn hơn dung tích hộp, không thể đặt được và toàn bộ dung tích hộp vẫn còn.\n    \"\"\"", "id": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Hitung ruang tersisa minimum dalam sebuah kotak setelah mencoba memasukkan sejumlah barang dengan volume tertentu.\n    \n    Fungsi ini menggunakan pendekatan pemrograman dinamis untuk menentukan volume maksimum yang dapat ditempati\n    dalam kotak oleh setiap subset dari barang-barang yang diberikan. Kemudian mengembalikan selisih antara kapasitas total kotak\n    dan volume maksimum yang ditempati ini, yang merupakan ruang tersisa minimum.\n\n    Argumen:\n    - V (int): Kapasitas total kotak.\n    - n (int): Jumlah barang yang dipertimbangkan untuk dimasukkan ke dalam kotak.\n    - volumes (List[int]): Daftar volume dari n barang.\n\n    Mengembalikan:\n    - int: Ruang tersisa minimum dalam kotak setelah memasukkan barang-barang.\n\n    Contoh:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Semua barang dapat dimasukkan ke dalam kotak tanpa ada ruang tersisa.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Cara optimal untuk memasukkan barang-barang bisa dengan mengambil barang dengan volume 3, 5, dan 3, yang menyisakan 2 unit ruang.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Karena semua barang memiliki volume lebih besar dari kapasitas kotak, tidak ada yang dapat dimasukkan dan seluruh kapasitas kotak tetap.\n    \"\"\"", "ja": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    与えられた体積を持つ複数のアイテムを箱に詰めようとした後の、箱の最小残りスペースを計算します。\n    \n    この関数は動的計画法を使用して、与えられたアイテムの任意の部分集合によって箱内で占有される最大体積を決定します。\n    その後、この最大占有体積と箱の総容量との差を返します。これが最小残りスペースです。\n\n    引数:\n    - V (int): 箱の総容量。\n    - n (int): 箱に詰めることを考慮するアイテムの数。\n    - volumes (List[int]): n個のアイテムの体積のリスト。\n\n    戻り値:\n    - int: アイテムを詰めた後の箱の最小残りスペース。\n\n    例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      すべてのアイテムを箱に残りスペースなしで詰めることができます。\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      アイテムを最適に詰める方法の一つとして、体積が3, 5, 3のアイテムを取ることができ、2単位のスペースが残ります。\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      すべてのアイテムが箱の容量を超える体積を持っているため、どれも詰めることができず、箱の容量全体が残ります。\n    \"\"\"", "ko": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    주어진 부피를 가진 여러 아이템을 상자에 넣으려고 할 때, 최소 남은 공간을 계산합니다.\n    \n    이 함수는 동적 프로그래밍 접근법을 사용하여 주어진 아이템의 부분 집합이 상자에서 차지할 수 있는 최대 부피를 결정합니다.\n    그런 다음 상자의 총 용량과 이 최대 차지 부피의 차이를 반환하며, 이는 최소 남은 공간입니다.\n\n    매개변수:\n    - V (int): 상자의 총 용량.\n    - n (int): 상자에 넣을 아이템의 수.\n    - volumes (List[int]): n개의 아이템의 부피 목록.\n\n    반환값:\n    - int: 아이템을 넣은 후 상자에 남은 최소 공간.\n\n    예시:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      모든 아이템을 상자에 남는 공간 없이 넣을 수 있습니다.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      아이템을 최적으로 넣는 방법은 부피가 3, 5, 3인 아이템을 선택하여 2 단위의 공간을 남기는 것입니다.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      모든 아이템의 부피가 상자 용량보다 크기 때문에 아무것도 넣을 수 없으며, 전체 상자 용량이 남습니다.\n    \"\"\"", "ml": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    നൽകിയ വോളിയങ്ങളുള്ള ഒരു സംഖ്യാ വസ്തുക്കൾക്ക് ബോക്സിൽ ഒതുങ്ങാൻ ശ്രമിച്ചതിന് ശേഷം ബോക്സിൽ ശേഷിക്കുന്ന ഏറ്റവും കുറഞ്ഞ സ്ഥലം കണക്കാക്കുക.\n    \n    ഈ ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് സമീപനം ഉപയോഗിച്ച് നൽകിയ വസ്തുക്കളുടെ ഏതെങ്കിലും ഉപസമൂഹം ബോക്സിൽ ഏറ്റെടുക്കാവുന്ന പരമാവധി വോളിയം നിർണ്ണയിക്കുന്നു. \n    തുടർന്ന് ബോക്സിന്റെ ആകെ ശേഷിയും ഈ പരമാവധി ഏറ്റെടുത്ത വോളിയത്തിനും ഇടയിലുള്ള വ്യത്യാസം തിരികെ നൽകുന്നു, \n    ഇത് ബോക്സിൽ ശേഷിക്കുന്ന ഏറ്റവും കുറഞ്ഞ സ്ഥലം ആണ്.\n\n    Args:\n    - V (int): ബോക്സിന്റെ ആകെ ശേഷി.\n    - n (int): ബോക്സിൽ പായ്ക്ക് ചെയ്യാൻ പരിഗണിക്കേണ്ട വസ്തുക്കളുടെ എണ്ണം.\n    - volumes (List[int]): n വസ്തുക്കളുടെ വോളിയങ്ങളുടെ പട്ടിക.\n\n    Returns:\n    - int: വസ്തുക്കൾ ഒതുങ്ങിയതിന് ശേഷം ബോക്സിൽ ശേഷിക്കുന്ന ഏറ്റവും കുറഞ്ഞ സ്ഥലം.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      എല്ലാ വസ്തുക്കളും ബോക്സിൽ ബാക്കിയുള്ള സ്ഥലമില്ലാതെ ഒതുങ്ങാൻ കഴിയും.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      വസ്തുക്കൾ ഒതുങ്ങാൻ ഒരു മികച്ച മാർഗ്ഗം 3, 5, 3 വോളിയങ്ങളുള്ള വസ്തുക്കൾ എടുക്കുന്നതായിരിക്കും, \n      ഇത് 2 യൂണിറ്റ് സ്ഥലം ശേഷിക്കുന്നു.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      എല്ലാ വസ്തുക്കൾക്കും ബോക്സ് ശേഷിയേക്കാൾ വോളിയം കൂടുതലായതിനാൽ, ഒന്നും ഒതുങ്ങാൻ കഴിയില്ല \n      കൂടാതെ മുഴുവൻ ബോക്സ് ശേഷിയും നിലനിൽക്കുന്നു.\n    \"\"\"", "fa": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    محاسبه حداقل فضای باقی‌مانده در یک جعبه پس از تلاش برای قرار دادن تعدادی آیتم با حجم‌های داده شده.\n\n    این تابع از یک روش برنامه‌ریزی پویا برای تعیین حداکثر حجمی که می‌تواند توسط هر زیرمجموعه‌ای از آیتم‌های داده شده\n    در جعبه اشغال شود، استفاده می‌کند. سپس تفاوت بین ظرفیت کل جعبه و این حجم اشغال‌شده حداکثری را برمی‌گرداند که همان\n    حداقل فضای باقی‌مانده است.\n\n    آرگومان‌ها:\n    - V (int): ظرفیت کل جعبه.\n    - n (int): تعداد آیتم‌هایی که باید برای بسته‌بندی در جعبه در نظر گرفته شوند.\n    - volumes (List[int]): لیستی از حجم‌های n آیتم.\n\n    بازگشت:\n    - int: حداقل فضای باقی‌مانده در جعبه پس از جا دادن آیتم‌ها.\n\n    مثال‌ها:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      همه آیتم‌ها می‌توانند بدون هیچ فضای باقی‌مانده‌ای در جعبه جا شوند.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      یک روش بهینه برای جا دادن آیتم‌ها می‌تواند گرفتن آیتم‌هایی با حجم‌های 3، 5 و 3 باشد که 2 واحد فضا باقی می‌گذارد.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      از آنجا که همه آیتم‌ها حجمی بیشتر از ظرفیت جعبه دارند، هیچ‌کدام نمی‌توانند جا شوند و کل ظرفیت جعبه باقی می‌ماند.\n    \"\"\""}, "canonical_solution": "    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]", "instruction": {"en": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nՏրամադրել համառոտ բնական լեզվով նկարագրություն (docstring) այս Python կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil tanımı (docstring) sağlayın.", "vi": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\n以下のPythonコードの自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 500자 이내로 제공하세요.", "ml": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nപൈതൺ കോഡിന്റെ സംക്ഷിപ്തമായ പ്രകൃതിദത്ത ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی و با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_min_remaining_space():\n    # Test case 1: Sample provided in the problem statement where all items can fit perfectly\n    V1, n1 = 24, 6\n    volumes1 = [8, 3, 12, 7, 9, 7]\n    expected1 = 0\n    assert min_remaining_space(V1, n1,\n                               volumes1) == expected1, f\"Test case 1 failed: expected {expected1}, got {min_remaining_space(V1, n1, volumes1)}\"\n\n    # Test case 2: Some space is expected to remain in the box\n    V2, n2 = 10, 4\n    volumes2 = [3, 5, 3, 2]\n    expected2 = 0  # Possible packing: 3, 5, and 3, leaves 2 units of space\n    assert min_remaining_space(V2, n2,\n                               volumes2) == expected2, f\"Test case 2 failed: expected {expected2}, got {min_remaining_space(V2, n2, volumes2)}\"\n\n    # Test case 3: No items can fit due to the items being larger than the box capacity\n    V3, n3 = 5, 3\n    volumes3 = [6, 7, 8]\n    expected3 = 5  # No items fit, so all 5 units of space remain\n    assert min_remaining_space(V3, n3,\n                               volumes3) == expected3, f\"Test case 3 failed: expected {expected3}, got {min_remaining_space(V3, n3, volumes3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_min_remaining_space()", "entry_point": "min_remaining_space", "signature": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:", "docstring": {"en": "Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n\nThis function uses a dynamic programming approach to determine the maximum volume that can be occupied\nin the box by any subset of the given items. It then returns the difference between the box's total capacity\nand this maximum occupied volume, which is the minimum remaining space.\n\nArgs:\n- V (int): The total capacity of the box.\n- n (int): The number of items to consider for packing into the box.\n- volumes (List[int]): A list of the volumes of the n items.\n\nReturns:\n- int: The minimum remaining space in the box after fitting the items.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nAll items can be fit into the box without any remaining space.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nAn optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nSince all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.", "sq": "Llogarit hapësirën minimale të mbetur në një kuti pas përpjekjes për të vendosur një numër artikujsh me vëllime të dhëna.\n\nKjo funksion përdor një qasje të programimit dinamik për të përcaktuar vëllimin maksimal që mund të zërë në kuti nga çdo nën-grup i artikujve të dhënë. Pastaj kthen diferencën midis kapacitetit total të kutisë dhe këtij vëllimi maksimal të zënë, që është hapësira minimale e mbetur.\n\nArgumentet:\n- V (int): Kapaciteti total i kutisë.\n- n (int): Numri i artikujve për t'u konsideruar për paketim në kuti.\n- volumes (List[int]): Një listë e vëllimeve të n artikujve.\n\nKthen:\n- int: Hapësira minimale e mbetur në kuti pas vendosjes së artikujve.\n\nShembuj:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nTë gjithë artikujt mund të vendosen në kuti pa asnjë hapësirë të mbetur.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nNjë mënyrë optimale për të vendosur artikujt mund të jetë marrja e artikujve me vëllime 3, 5, dhe 3, që lë 2 njësi hapësirë.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nMeqenëse të gjithë artikujt kanë një vëllim më të madh se kapaciteti i kutisë, asnjëri nuk mund të vendoset dhe i gjithë kapaciteti i kutisë mbetet.", "hy": "Հաշվել տուփում մնացած նվազագույն տարածքը այն բանից հետո, երբ փորձ է արվում տեղավորել որոշակի ծավալներով իրերի քանակը:\n\nԱյս ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար առավելագույն ծավալը, որը կարող է զբաղեցվել տուփում տրված իրերի ցանկացած ենթաբազմությամբ: Այնուհետև վերադարձնում է տուփի ընդհանուր տարողության և այս առավելագույն զբաղեցված ծավալի տարբերությունը, որը նվազագույն մնացած տարածքն է:\n\nԱրձագանքներ:\n- V (int): Տուփի ընդհանուր տարողությունը:\n- n (int): Տուփի մեջ տեղավորելու համար հաշվի առնվող իրերի քանակը:\n- volumes (List[int]): n իրերի ծավալների ցուցակը:\n\nՎերադարձնում է:\n- int: Տուփում մնացած նվազագույն տարածքը իրերը տեղավորելուց հետո:\n\nՕրինակներ:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nԲոլոր իրերը կարող են տեղավորվել տուփում առանց մնացած տարածքի:\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nԻրերը տեղավորելու օպտիմալ եղանակ կարող է լինել 3, 5 և 3 ծավալներով իրերը վերցնելը, որը թողնում է 2 միավոր տարածք:\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nՔանի որ բոլոր իրերի ծավալը մեծ է տուփի տարողությունից, ոչ մեկը չի կարող տեղավորվել, և ամբողջ տուփի տարողությունը մնում է:", "bn": "বাক্সে নির্দিষ্ট ভলিউমের কিছু আইটেম ফিট করার পরে বাক্সে ন্যূনতম অবশিষ্ট স্থান গণনা করুন।\n\nএই ফাংশনটি একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে নির্ধারণ করে যে প্রদত্ত আইটেমগুলির যেকোনো উপসেট দ্বারা বাক্সে সর্বাধিক কত ভলিউম দখল করা যেতে পারে। তারপর এটি বাক্সের মোট ক্ষমতা এবং এই সর্বাধিক দখলকৃত ভলিউমের মধ্যে পার্থক্য প্রদান করে, যা ন্যূনতম অবশিষ্ট স্থান।\n\nArgs:\n- V (int): বাক্সের মোট ক্ষমতা।\n- n (int): বাক্সে প্যাক করার জন্য বিবেচিত আইটেমের সংখ্যা।\n- volumes (List[int]): n আইটেমের ভলিউমের একটি তালিকা।\n\nReturns:\n- int: আইটেমগুলি ফিট করার পরে বাক্সে ন্যূনতম অবশিষ্ট স্থান।\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nসব আইটেম বাক্সে ফিট করা যায় কোনো অবশিষ্ট স্থান ছাড়াই।\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nআইটেমগুলি ফিট করার একটি সর্বোত্তম উপায় হতে পারে ভলিউম 3, 5, এবং 3 সহ আইটেমগুলি নেওয়া, যা 2 ইউনিট স্থান অবশিষ্ট রাখে।\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nযেহেতু সব আইটেমের ভলিউম বাক্সের ক্ষমতার চেয়ে বেশি, তাই কোনোটি ফিট করা যায় না এবং পুরো বাক্সের ক্ষমতা অবশিষ্ট থাকে।", "bg": "Изчислете минималното оставащо пространство в кутия след опит за поставяне на определен брой предмети с дадени обеми.\n\nТази функция използва подход на динамично програмиране, за да определи максималния обем, който може да бъде зает в кутията от всяко подмножество на дадените предмети. След това връща разликата между общия капацитет на кутията и този максимален зает обем, което е минималното оставащо пространство.\n\nАргументи:\n- V (int): Общият капацитет на кутията.\n- n (int): Броят на предметите, които да се разгледат за опаковане в кутията.\n- volumes (List[int]): Списък с обемите на n-те предмета.\n\nВръща:\n- int: Минималното оставащо пространство в кутията след поставяне на предметите.\n\nПримери:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nВсички предмети могат да бъдат поставени в кутията без оставащо пространство.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nОптимален начин за поставяне на предметите може да бъде вземането на предмети с обеми 3, 5 и 3, което оставя 2 единици пространство.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nТъй като всички предмети имат обем, по-голям от капацитета на кутията, нито един не може да бъде поставен и целият капацитет на кутията остава.", "zh": "计算在尝试将若干具有给定体积的物品放入一个箱子后，箱子内的最小剩余空间。\n\n此函数使用动态规划方法来确定给定物品的任何子集在箱子中可以占据的最大体积。然后返回箱子的总容量与此最大占用体积之间的差值，即最小剩余空间。\n\n参数：\n- V (int): 箱子的总容量。\n- n (int): 要考虑放入箱子的物品数量。\n- volumes (List[int]): n个物品的体积列表。\n\n返回：\n- int: 在放入物品后箱子内的最小剩余空间。\n\n示例：\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n所有物品可以放入箱子中，没有剩余空间。\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n一种优化的放置方式可以是选择体积为3、5和3的物品，这样会剩下2个单位的空间。\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\n由于所有物品的体积都大于箱子的容量，因此无法放入任何物品，整个箱子容量保持不变。", "fr": "Calculer l'espace restant minimum dans une boîte après avoir essayé d'y placer un certain nombre d'articles avec des volumes donnés.\n\nCette fonction utilise une approche de programmation dynamique pour déterminer le volume maximum qui peut être occupé\ndans la boîte par n'importe quel sous-ensemble des articles donnés. Elle retourne ensuite la différence entre la capacité totale de la boîte\net ce volume maximum occupé, qui est l'espace restant minimum.\n\nArgs:\n- V (int): La capacité totale de la boîte.\n- n (int): Le nombre d'articles à considérer pour le rangement dans la boîte.\n- volumes (List[int]): Une liste des volumes des n articles.\n\nReturns:\n- int: L'espace restant minimum dans la boîte après avoir rangé les articles.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nTous les articles peuvent être rangés dans la boîte sans aucun espace restant.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nUne façon optimale de ranger les articles pourrait être de prendre les articles avec des volumes de 3, 5 et 3, ce qui laisse 2 unités d'espace.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nPuisque tous les articles ont un volume supérieur à la capacité de la boîte, aucun ne peut être rangé et la capacité totale de la boîte reste.", "de": "Berechne den minimal verbleibenden Platz in einer Box, nachdem versucht wurde, eine Anzahl von Gegenständen mit gegebenen Volumen unterzubringen.\n\nDiese Funktion verwendet einen dynamischen Programmierungsansatz, um das maximale Volumen zu bestimmen, das durch eine beliebige Teilmenge der gegebenen Gegenstände in der Box belegt werden kann. Sie gibt dann die Differenz zwischen der Gesamtkapazität der Box und diesem maximal belegten Volumen zurück, was den minimal verbleibenden Platz darstellt.\n\nArgs:\n- V (int): Die Gesamtkapazität der Box.\n- n (int): Die Anzahl der Gegenstände, die in die Box gepackt werden sollen.\n- volumes (List[int]): Eine Liste der Volumen der n Gegenstände.\n\nReturns:\n- int: Der minimal verbleibende Platz in der Box, nachdem die Gegenstände untergebracht wurden.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nAlle Gegenstände können ohne verbleibenden Platz in die Box gepackt werden.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nEine optimale Möglichkeit, die Gegenstände zu packen, könnte darin bestehen, Gegenstände mit den Volumen 3, 5 und 3 zu nehmen, was 2 Einheiten Platz übrig lässt.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nDa alle Gegenstände ein Volumen größer als die Boxkapazität haben, kann keiner untergebracht werden und die gesamte Boxkapazität bleibt erhalten.", "ha": "Lissafi mafi ƙarancin sarari da ya rage a cikin akwati bayan ƙoƙarin sanya adadin abubuwa tare da girma da aka bayar.\n\nWannan aikin yana amfani da hanyar shirye-shiryen motsi don tantance mafi girman girma da za a iya cika\na cikin akwatin ta kowace rukuni na abubuwan da aka bayar. Sannan yana dawowa da bambanci tsakanin jimlar damar akwatin\nda wannan mafi girman girma da aka cika, wanda shine mafi karancin sarari da ya rage.\n\nArgs:\n- V (int): Jimlar damar akwatin.\n- n (int): Yawan abubuwan da za a yi la'akari da su don cika cikin akwatin.\n- volumes (List[int]): Jerin girman abubuwan n.\n\nReturns:\n- int: Mafi karancin sarari da ya rage a cikin akwatin bayan cika abubuwan.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nDukkan abubuwan na iya shiga cikin akwatin ba tare da wani sarari da ya rage ba.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nHanya mafi kyau don cika abubuwan na iya zama daukar abubuwa da girman 3, 5, da 3, wanda ke barin sarari na raka'a 2.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nTun da duk abubuwan suna da girma fiye da damar akwatin, babu wanda zai iya shiga kuma dukkan damar akwatin ta rage.", "hi": "बॉक्स में दिए गए वॉल्यूम वाले वस्तुओं की संख्या को फिट करने के बाद बॉक्स में बची हुई न्यूनतम जगह की गणना करें।\n\nयह फ़ंक्शन बॉक्स में दिए गए वस्तुओं के किसी भी उपसमूह द्वारा अधिकतम वॉल्यूम को निर्धारित करने के लिए एक डायनामिक प्रोग्रामिंग दृष्टिकोण का उपयोग करता है। फिर यह बॉक्स की कुल क्षमता और इस अधिकतम भरे हुए वॉल्यूम के बीच के अंतर को लौटाता है, जो कि बची हुई न्यूनतम जगह है।\n\nआर्ग्स:\n- V (int): बॉक्स की कुल क्षमता।\n- n (int): बॉक्स में पैक करने के लिए विचार की जाने वाली वस्तुओं की संख्या।\n- volumes (List[int]): n वस्तुओं के वॉल्यूम की सूची।\n\nरिटर्न्स:\n- int: वस्तुओं को फिट करने के बाद बॉक्स में बची हुई न्यूनतम जगह।\n\nउदाहरण:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nसभी वस्तुओं को बिना किसी बची हुई जगह के बॉक्स में फिट किया जा सकता है।\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nवस्तुओं को फिट करने का एक आदर्श तरीका हो सकता है 3, 5, और 3 वॉल्यूम वाली वस्तुओं को लेना, जिससे 2 यूनिट जगह बचती है।\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nचूंकि सभी वस्तुओं का वॉल्यूम बॉक्स की क्षमता से अधिक है, कोई भी फिट नहीं हो सकता और पूरी बॉक्स क्षमता बची रहती है।", "hu": "Számítsa ki a minimális megmaradó helyet egy dobozban, miután megpróbált elhelyezni egy adott számú tárgyat adott térfogatokkal.\n\nEz a függvény dinamikus programozási megközelítést alkalmaz annak meghatározására, hogy a megadott tárgyak bármely részhalmaza által a dobozban elfoglalt maximális térfogat mekkora lehet. Ezután visszaadja a doboz teljes kapacitása és az elfoglalt maximális térfogat közötti különbséget, ami a minimális megmaradó hely.\n\nArgs:\n- V (int): A doboz teljes kapacitása.\n- n (int): A figyelembe veendő tárgyak száma a dobozba való csomagoláshoz.\n- volumes (List[int]): Az n tárgy térfogatainak listája.\n\nReturns:\n- int: A minimális megmaradó hely a dobozban a tárgyak elhelyezése után.\n\nPéldák:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nMinden tárgy elfér a dobozban anélkül, hogy bármilyen megmaradó hely maradna.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nAz optimális elhelyezés lehet, ha a 3, 5 és 3 térfogatú tárgyakat választjuk, ami 2 egységnyi helyet hagy.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nMivel minden tárgy térfogata nagyobb, mint a doboz kapacitása, egyik sem fér el, és a teljes dobozkapacitás megmarad.", "es": "Calcular el espacio mínimo restante en una caja después de intentar encajar un número de artículos con volúmenes dados.\n\nEsta función utiliza un enfoque de programación dinámica para determinar el volumen máximo que puede ser ocupado\nen la caja por cualquier subconjunto de los artículos dados. Luego devuelve la diferencia entre la capacidad total de la caja\ny este volumen máximo ocupado, que es el espacio mínimo restante.\n\nArgumentos:\n- V (int): La capacidad total de la caja.\n- n (int): El número de artículos a considerar para empacar en la caja.\n- volumes (List[int]): Una lista de los volúmenes de los n artículos.\n\nDevuelve:\n- int: El espacio mínimo restante en la caja después de encajar los artículos.\n\nEjemplos:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nTodos los artículos pueden encajar en la caja sin ningún espacio restante.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nUna forma óptima de encajar los artículos podría ser tomando artículos con volúmenes 3, 5 y 3, lo que deja 2 unidades de espacio.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nDado que todos los artículos tienen un volumen mayor que la capacidad de la caja, ninguno puede encajar y toda la capacidad de la caja permanece.", "arb": "حساب الحد الأدنى للمساحة المتبقية في صندوق بعد محاولة وضع عدد من العناصر ذات الأحجام المعطاة.\n\nتستخدم هذه الدالة نهج البرمجة الديناميكية لتحديد الحد الأقصى للحجم الذي يمكن أن يشغله في الصندوق أي مجموعة فرعية من العناصر المعطاة. ثم تعيد الفرق بين السعة الإجمالية للصندوق وهذا الحجم المشغول الأقصى، وهو الحد الأدنى للمساحة المتبقية.\n\nيعيدالحجج:\n- V (int): السعة الإجمالية للصندوق.\n- n (int): عدد العناصر التي يجب النظر فيها للتعبئة في الصندوق.\n- volumes (List[int]): قائمة بأحجام العناصر n.\n\nيعيد:\n- int: الحد الأدنى للمساحة المتبقية في الصندوق بعد وضع العناصر.\n\nامثله:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nيمكن وضع جميع العناصر في الصندوق دون أي مساحة متبقية.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nطريقة مثلى لوضع العناصر يمكن أن تكون بأخذ العناصر ذات الأحجام 3، 5، و3، مما يترك 2 وحدة من المساحة.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nنظرًا لأن جميع العناصر لها حجم أكبر من سعة الصندوق، لا يمكن وضع أي منها وتبقى السعة الكاملة للصندوق.", "sw": "Kuhesabu nafasi ndogo inayobaki kwenye sanduku baada ya kujaribu kutoshea idadi ya vitu vilivyo na ujazo uliotolewa.\n\nKazi hii hutumia mbinu ya programu ya nguvu ili kubaini ujazo wa juu zaidi ambao unaweza kujazwa\nkatika sanduku na sehemu yoyote ya vitu vilivyotolewa. Kisha inarejesha tofauti kati ya uwezo wa jumla wa sanduku\nna huu ujazo wa juu zaidi uliyojazwa, ambao ndio nafasi ndogo zaidi inayobaki.\n\nHoja:\n- V (int): Uwezo wa jumla wa sanduku.\n- n (int): Idadi ya vitu vya kuzingatia kwa kufunga kwenye sanduku.\n- volumes (List[int]): Orodha ya ujazo wa vitu n.\n\nInarejesha:\n- int: Nafasi ndogo zaidi inayobaki kwenye sanduku baada ya kufunga vitu.\n\nMifano:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nVitu vyote vinaweza kujazwa kwenye sanduku bila nafasi yoyote inayobaki.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nNjia bora ya kufunga vitu inaweza kuwa kuchukua vitu vyenye ujazo 3, 5, na 3, ambayo inaacha nafasi ya vitengo 2.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nKwa kuwa vitu vyote vina ujazo mkubwa kuliko uwezo wa sanduku, hakuna kinachoweza kujazwa na uwezo wote wa sanduku unabaki.", "tr": "Kutudaki minimum kalan alanı, verilen hacimlere sahip bir dizi öğeyi sığdırmaya çalıştıktan sonra hesaplayın.\n\nBu fonksiyon, verilen öğelerin herhangi bir alt kümesi tarafından kutuda işgal edilebilecek maksimum hacmi belirlemek için dinamik programlama yaklaşımı kullanır. Daha sonra kutunun toplam kapasitesi ile bu maksimum işgal edilen hacim arasındaki farkı döndürür, bu da minimum kalan alandır.\n\nArgümanlar:\n- V (int): Kutunun toplam kapasitesi.\n- n (int): Kutunun içine yerleştirilmesi düşünülen öğe sayısı.\n- volumes (List[int]): n öğesinin hacimlerinin listesi.\n\nDöndürür:\n- int: Öğeleri yerleştirdikten sonra kutuda kalan minimum alan.\n\nÖrnekler:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nTüm öğeler kutuya herhangi bir boş alan kalmadan sığdırılabilir.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nÖğeleri sığdırmanın optimal bir yolu, hacimleri 3, 5 ve 3 olan öğeleri almak olabilir, bu da 2 birim alan bırakır.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nTüm öğelerin hacmi kutu kapasitesinden büyük olduğundan, hiçbiri sığdırılamaz ve kutunun tüm kapasitesi kalır.", "vi": "Tính toán không gian còn lại tối thiểu trong một hộp sau khi cố gắng đặt một số lượng vật phẩm với các thể tích cho trước.\n\nHàm này sử dụng phương pháp lập trình động để xác định thể tích tối đa có thể được chiếm trong hộp bởi bất kỳ tập hợp con nào của các vật phẩm đã cho. Sau đó, nó trả về sự khác biệt giữa tổng dung tích của hộp và thể tích chiếm tối đa này, đó là không gian còn lại tối thiểu.\n\nTham số:\n- V (int): Tổng dung tích của hộp.\n- n (int): Số lượng vật phẩm cần xem xét để đóng gói vào hộp.\n- volumes (List[int]): Danh sách các thể tích của n vật phẩm.\n\nTrả về:\n- int: Không gian còn lại tối thiểu trong hộp sau khi đặt các vật phẩm.\n\nVí dụ:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nTất cả các vật phẩm có thể được đặt vào hộp mà không còn không gian thừa.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nMột cách tối ưu để đặt các vật phẩm có thể là lấy các vật phẩm có thể tích 3, 5 và 3, để lại 2 đơn vị không gian.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nVì tất cả các vật phẩm có thể tích lớn hơn dung tích hộp, không vật phẩm nào có thể được đặt và toàn bộ dung tích hộp vẫn còn.", "id": "Hitung ruang sisa minimum dalam sebuah kotak setelah mencoba memasukkan sejumlah barang dengan volume tertentu.\n\nFungsi ini menggunakan pendekatan pemrograman dinamis untuk menentukan volume maksimum yang dapat ditempati\ndalam kotak oleh setiap subset dari barang-barang yang diberikan. Kemudian fungsi ini mengembalikan selisih antara kapasitas total kotak\ndan volume maksimum yang ditempati ini, yang merupakan ruang sisa minimum.\n\nArgs:\n- V (int): Kapasitas total kotak.\n- n (int): Jumlah barang yang dipertimbangkan untuk dimasukkan ke dalam kotak.\n- volumes (List[int]): Daftar volume dari n barang.\n\nReturns:\n- int: Ruang sisa minimum dalam kotak setelah memasukkan barang-barang.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nSemua barang dapat dimasukkan ke dalam kotak tanpa ruang sisa.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nCara optimal untuk memasukkan barang-barang bisa dengan mengambil barang dengan volume 3, 5, dan 3, yang menyisakan 2 unit ruang.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nKarena semua barang memiliki volume lebih besar dari kapasitas kotak, tidak ada yang dapat dimasukkan dan seluruh kapasitas kotak tetap.", "ja": "箱にアイテムをいくつかの体積で詰めようとした後の最小残りスペースを計算します。\n\nこの関数は動的計画法を使用して、与えられたアイテムの任意の部分集合によって箱の中で占有できる最大体積を決定します。次に、箱の総容量とこの最大占有体積の差を返します。これが最小残りスペースです。\n\n引数:\n- V (int): 箱の総容量。\n- n (int): 箱に詰めることを考慮するアイテムの数。\n- volumes (List[int]): n個のアイテムの体積のリスト。\n\n戻り値:\n- int: アイテムを詰めた後の箱の最小残りスペース。\n\n例:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nすべてのアイテムを箱にスペースを残さずに詰めることができます。\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nアイテムを詰める最適な方法は、体積が3, 5, 3のアイテムを取ることで、2単位のスペースが残ります。\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nすべてのアイテムが箱の容量より大きいため、どれも詰めることができず、箱の全容量が残ります。", "ko": "상자에 주어진 부피의 항목 수를 맞추려고 시도한 후 남아 있는 최소 공간을 계산합니다.\n\n이 함수는 동적 프로그래밍 접근 방식을 사용하여 주어진 항목의 하위 집합에 의해 상자에 점유될 수 있는 최대 부피를 결정합니다. 그런 다음 상자의 총 용량과 이 최대 점유 부피의 차이를 반환하며, 이는 최소 남은 공간입니다.\n\n인수:\n- V (int): 상자의 총 용량.\n- n (int): 상자에 포장할 항목의 수.\n- volumes (List[int]): n개의 항목의 부피 목록.\n\n반환:\n- int: 항목을 맞춘 후 상자에 남아 있는 최소 공간.\n\n예제:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n모든 항목을 남는 공간 없이 상자에 맞출 수 있습니다.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n항목을 맞추는 최적의 방법은 부피가 3, 5, 3인 항목을 선택하는 것이며, 이는 2 단위의 공간을 남깁니다.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\n모든 항목의 부피가 상자 용량보다 크므로 아무것도 맞출 수 없으며 전체 상자 용량이 남습니다.", "ml": "ബോക്സിൽ ഒരു നിശ്ചിത വോളിയം ഉള്ള ഒരു നിശ്ചിത എണ്ണം വസ്തുക്കൾ ഒതുക്കാൻ ശ്രമിച്ച ശേഷം ബോക്സിൽ ശേഷിക്കുന്ന കുറഞ്ഞ സ്ഥലത്തെ കണക്കാക്കുക.\n\nഈ ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് സമീപനം ഉപയോഗിച്ച് നൽകിയ വസ്തുക്കളുടെ ഏതെങ്കിലും ഉപസമൂഹം കൊണ്ട് ബോക്സിൽ ഒതുക്കാൻ കഴിയുന്ന പരമാവധി വോളിയം നിർണ്ണയിക്കുന്നു. തുടർന്ന് ബോക്സിന്റെ ആകെ ശേഷിയും ഈ പരമാവധി ഉപയോഗിച്ച വോളിയവും തമ്മിലുള്ള വ്യത്യാസം തിരിച്ചുനൽകുന്നു, അതാണ് കുറഞ്ഞ ശേഷിക്കുന്ന സ്ഥലം.\n\nആർഗ്സ്:\n- V (int): ബോക്സിന്റെ ആകെ ശേഷി.\n- n (int): ബോക്സിൽ ഒതുക്കാൻ പരിഗണിക്കേണ്ട വസ്തുക്കളുടെ എണ്ണം.\n- volumes (List[int]): n വസ്തുക്കളുടെ വോളിയങ്ങൾ ഉള്ള ഒരു ലിസ്റ്റ്.\n\nറിട്ടേൺസ്:\n- int: വസ്തുക്കൾ ഒതുക്കിയ ശേഷം ബോക്സിൽ ശേഷിക്കുന്ന കുറഞ്ഞ സ്ഥലം.\n\nഉദാഹരണങ്ങൾ:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nഎല്ലാ വസ്തുക്കളും ബോക്സിൽ ബാക്കി സ്ഥലമില്ലാതെ ഒതുക്കാൻ കഴിയും.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nവസ്തുക്കൾ ഒതുക്കാനുള്ള ഒരു മികച്ച മാർഗ്ഗം വോളിയം 3, 5, 3 ഉള്ള വസ്തുക്കൾ എടുക്കുന്നതായിരിക്കും, ഇത് 2 യൂണിറ്റ് സ്ഥലം ബാക്കി വയ്ക്കുന്നു.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nഎല്ലാ വസ്തുക്കളുടെയും വോളിയം ബോക്സിന്റെ ശേഷിയേക്കാൾ കൂടുതലായതിനാൽ, ഒന്നും ഒതുക്കാൻ കഴിയില്ല, ബോക്സിന്റെ മുഴുവൻ ശേഷിയും ശേഷിക്കുന്നു.", "fa": "محاسبه حداقل فضای باقی‌مانده در یک جعبه پس از تلاش برای جا دادن تعدادی آیتم با حجم‌های داده شده.\n\nاین تابع از یک روش برنامه‌ریزی پویا برای تعیین حداکثر حجمی که می‌تواند توسط هر زیرمجموعه‌ای از آیتم‌های داده شده در جعبه اشغال شود، استفاده می‌کند. سپس تفاوت بین ظرفیت کل جعبه و این حداکثر حجم اشغال شده را برمی‌گرداند که همان حداقل فضای باقی‌مانده است.\n\nآرگومان‌ها:\n- V (int): ظرفیت کل جعبه.\n- n (int): تعداد آیتم‌هایی که باید برای بسته‌بندی در جعبه در نظر گرفته شوند.\n- volumes (List[int]): لیستی از حجم‌های n آیتم.\n\nبازگشت:\n- int: حداقل فضای باقی‌مانده در جعبه پس از جا دادن آیتم‌ها.\n\nمثال‌ها:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nهمه آیتم‌ها می‌توانند بدون هیچ فضای باقی‌مانده‌ای در جعبه جا شوند.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nیک روش بهینه برای جا دادن آیتم‌ها می‌تواند گرفتن آیتم‌هایی با حجم‌های 3، 5 و 3 باشد که 2 واحد فضای باقی می‌گذارد.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nچون همه آیتم‌ها حجمی بیشتر از ظرفیت جعبه دارند، هیچ‌کدام نمی‌توانند جا شوند و کل ظرفیت جعبه باقی می‌ماند."}}
{"task_id": "Python/39", "prompt": {"en": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n      There are two possible arrangements for 4 pots using two types of flowers with\n      at most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n      There are six ways to arrange 3 pots using three types of flowers when the\n      maximum pots are 1, 2, and 3 for the first, second, and third types respectively.\n    \"\"\"", "sq": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Llogarit numrin e mënyrave për të rregulluar m vazo me lule duke përdorur deri në n lloje,\n    ku lloji i-të mund të ketë më së shumti a[i] vazo, dhe rregullimi duhet të jetë në\n    rend rritës të llojeve të luleve.\n\n    Argumentet:\n    - n (int): Numri i llojeve të luleve të disponueshme.\n    - m (int): Numri total i vazove me lule për t'u rregulluar.\n    - a (listë e int): Një listë ku a[i] është numri maksimal i vazove për llojin i-të të luleve.\n\n    Kthen:\n    - int: Numri i rregullimeve të dallueshme modulo (10^6 + 7).\n\n    Shembuj:\n    - calculate_arrangements(2, 4, [3, 2]) kthen 2.\n      Ka dy rregullime të mundshme për 4 vazo duke përdorur dy lloje lulesh me\n      më së shumti 3 të llojit të parë dhe 2 të llojit të dytë: [1, 1, 2, 2] dhe [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) kthen 6.\n      Ka gjashtë mënyra për të rregulluar 3 vazo duke përdorur tre lloje lulesh kur\n      maksimumi i vazove është 1, 2, dhe 3 për llojin e parë, të dytë, dhe të tretë respektivisht.\n    \"\"\"", "hy": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Հաշվել, թե քանի եղանակով կարելի է դասավորել m ծաղկամաններ՝ օգտագործելով մինչև n տեսակներ,\n    որտեղ i-րդ տեսակը կարող է ունենալ առավելագույնը a[i] ծաղկաման, և դասավորությունը պետք է լինի\n    ծաղիկների տեսակների աճման կարգով:\n\n    Արգումենտներ:\n    - n (int): Առկա ծաղիկների տեսակների քանակը:\n    - m (int): Դասավորելու ընդհանուր ծաղկամանների քանակը:\n    - a (list of int): Ցուցակ, որտեղ a[i]-ն i-րդ տեսակի ծաղիկների առավելագույն ծաղկամանների քանակն է:\n\n    Վերադարձնում է:\n    - int: Տարբեր դասավորությունների քանակը մոդուլո (10^6 + 7):\n\n    Օրինակներ:\n    - calculate_arrangements(2, 4, [3, 2]) վերադարձնում է 2:\n      Կան երկու հնարավոր դասավորություններ 4 ծաղկամանների համար՝ օգտագործելով երկու տեսակի ծաղիկներ՝\n      առավելագույնը 3 առաջին տեսակից և 2 երկրորդ տեսակից: [1, 1, 2, 2] և [1, 2, 2, 2]:\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) վերադարձնում է 6:\n      Կան վեց եղանակներ դասավորելու 3 ծաղկաման՝ օգտագործելով երեք տեսակի ծաղիկներ, երբ\n      առավելագույն ծաղկամանների քանակները 1, 2 և 3 են առաջին, երկրորդ և երրորդ տեսակների համար համապատասխանաբար.\n    \"\"\"", "bn": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    m টি ফুলের টব n প্রকারের ফুল ব্যবহার করে সাজানোর উপায়ের সংখ্যা গণনা করুন,\n    যেখানে i তম প্রকারের ফুলের সর্বাধিক a[i] টব থাকতে পারে, এবং সাজানো\n    অবশ্যই ফুলের প্রকারের ক্রমবর্ধমান ক্রমে হতে হবে।\n\n    আর্গুমেন্টসমূহ:\n    - n (int): উপলব্ধ ফুলের প্রকারের সংখ্যা।\n    - m (int): সাজানোর জন্য মোট ফুলের টবের সংখ্যা।\n    - a (list of int): একটি তালিকা যেখানে a[i] হল i তম প্রকারের ফুলের জন্য সর্বাধিক টবের সংখ্যা।\n\n    রিটার্নস:\n    - int: ভিন্ন ভিন্ন সাজানোর সংখ্যা মডুলো (10^6 + 7)।\n\n    উদাহরণ:\n    - calculate_arrangements(2, 4, [3, 2]) 2 রিটার্ন করে।\n      দুটি সম্ভবপর সাজানো রয়েছে 4 টবের জন্য দুটি প্রকারের ফুল ব্যবহার করে\n      যেখানে প্রথম প্রকারের সর্বাধিক 3 এবং দ্বিতীয় প্রকারের সর্বাধিক 2: [1, 1, 2, 2] এবং [1, 2, 2, 2]।\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 রিটার্ন করে।\n      3 টব সাজানোর ছয়টি উপায় রয়েছে তিন প্রকারের ফুল ব্যবহার করে যখন\n      সর্বাধিক টবের সংখ্যা প্রথম, দ্বিতীয় এবং তৃতীয় প্রকারের জন্য যথাক্রমে 1, 2, এবং 3।\n    \"\"\"", "bg": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Изчислете броя на начините за подреждане на m саксии с цветя, използвайки до n типа,\n    където i-тият тип може да има най-много a[i] саксии, и подреждането трябва да бъде в\n    нарастващ ред на типовете цветя.\n\n    Аргументи:\n    - n (int): Броят на наличните типове цветя.\n    - m (int): Общият брой саксии с цветя за подреждане.\n    - a (списък от int): Списък, където a[i] е максималният брой саксии за i-тия тип цветя.\n\n    Връща:\n    - int: Броят на различните подреждания по модул (10^6 + 7).\n\n    Примери:\n    - calculate_arrangements(2, 4, [3, 2]) връща 2.\n      Има два възможни подреждания за 4 саксии, използвайки два типа цветя с\n      най-много 3 от първия тип и 2 от втория тип: [1, 1, 2, 2] и [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) връща 6.\n      Има шест начина за подреждане на 3 саксии, използвайки три типа цветя, когато\n      максималният брой саксии е 1, 2 и 3 за първия, втория и третия тип съответно.\n    \"\"\"", "zh": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    计算使用最多 n 种类型来安排 m 个花盆的方法数，\n    其中第 i 种类型最多可以有 a[i] 个花盆，并且排列必须按花的类型递增顺序。\n\n    参数:\n    - n (int): 可用的花的种类数。\n    - m (int): 要安排的花盆总数。\n    - a (list of int): 一个列表，其中 a[i] 是第 i 种花的最大花盆数。\n\n    返回:\n    - int: 不同排列的数量，模 (10^6 + 7)。\n\n    示例:\n    - calculate_arrangements(2, 4, [3, 2]) 返回 2。\n      使用两种类型的花来安排 4 个花盆的两种可能排列是\n      最多 3 个第一种类型和 2 个第二种类型：[1, 1, 2, 2] 和 [1, 2, 2, 2]。\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) 返回 6。\n      使用三种类型的花来安排 3 个花盆的六种方法是\n      当最大花盆数分别为 1、2 和 3 时，第一、第二和第三种类型。\n    \"\"\"", "fr": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Calculer le nombre de façons d'arranger m pots de fleurs en utilisant jusqu'à n types,\n    où le i-ème type peut avoir au plus a[i] pots, et l'arrangement doit être dans\n    l'ordre croissant des types de fleurs.\n\n    Args:\n    - n (int): Le nombre de types de fleurs disponibles.\n    - m (int): Le nombre total de pots de fleurs à arranger.\n    - a (list of int): Une liste où a[i] est le nombre maximum de pots pour le i-ème type de fleur.\n\n    Returns:\n    - int: Le nombre d'arrangements distincts modulo (10^6 + 7).\n\n    Exemples:\n    - calculate_arrangements(2, 4, [3, 2]) retourne 2.\n      Il y a deux arrangements possibles pour 4 pots en utilisant deux types de fleurs avec\n      au plus 3 du premier type et 2 du second type : [1, 1, 2, 2] et [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) retourne 6.\n      Il y a six façons d'arranger 3 pots en utilisant trois types de fleurs lorsque les\n      pots maximums sont 1, 2 et 3 pour les premier, deuxième et troisième types respectivement.\n    \"\"\"", "de": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Berechne die Anzahl der Möglichkeiten, m Blumentöpfe unter Verwendung von bis zu n Typen anzuordnen,\n    wobei der i-te Typ höchstens a[i] Töpfe haben kann und die Anordnung in\n    aufsteigender Reihenfolge der Blumentypen erfolgen muss.\n\n    Argumente:\n    - n (int): Die Anzahl der verfügbaren Blumentypen.\n    - m (int): Die Gesamtanzahl der anzuordnenden Blumentöpfe.\n    - a (Liste von int): Eine Liste, wobei a[i] die maximale Anzahl von Töpfen für den i-ten Blumentyp ist.\n\n    Rückgabewert:\n    - int: Die Anzahl der unterschiedlichen Anordnungen modulo (10^6 + 7).\n\n    Beispiele:\n    - calculate_arrangements(2, 4, [3, 2]) gibt 2 zurück.\n      Es gibt zwei mögliche Anordnungen für 4 Töpfe unter Verwendung von zwei Blumentypen mit\n      höchstens 3 vom ersten Typ und 2 vom zweiten Typ: [1, 1, 2, 2] und [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) gibt 6 zurück.\n      Es gibt sechs Möglichkeiten, 3 Töpfe unter Verwendung von drei Blumentypen anzuordnen, wenn die\n      maximalen Töpfe 1, 2 und 3 für den ersten, zweiten und dritten Typ sind.\n    \"\"\"", "ha": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Lissafa yawan hanyoyin da za a iya tsara tukwane m na furanni ta amfani da nau'ikan n,\n    inda nau'in na i zai iya samun a[i] tukwane, kuma tsarin dole ne ya kasance a cikin\n    tsari mai ƙaruwa na nau'ikan furanni.\n\n    Args:\n    - n (int): Yawan nau'ikan furanni da ake da su.\n    - m (int): Jimillar adadin tukwane na furanni da za a tsara.\n    - a (jerin int): Jerin inda a[i] shine mafi yawan tukwane don nau'in furanni na i.\n\n    Returns:\n    - int: Yawan tsare-tsaren daban-daban modulo (10^6 + 7).\n\n    Misalai:\n    - calculate_arrangements(2, 4, [3, 2]) yana dawowa 2.\n      Akwai hanyoyi biyu masu yiwuwa don tsara tukwane 4 ta amfani da nau'ikan furanni biyu tare da\n      akalla 3 na nau'in farko da 2 na nau'in na biyu: [1, 1, 2, 2] da [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) yana dawowa 6.\n      Akwai hanyoyi shida don tsara tukwane 3 ta amfani da nau'ikan furanni uku lokacin da\n      mafi yawan tukwane su ne 1, 2, da 3 don nau'in farko, na biyu, da na uku bi da bi.\n    \"\"\"", "hi": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    m गमलों के फूलों को n प्रकारों तक का उपयोग करके सजाने के तरीकों की संख्या की गणना करें,\n    जहाँ ith प्रकार में अधिकतम a[i] गमले हो सकते हैं, और व्यवस्था फूलों के प्रकारों के\n    बढ़ते क्रम में होनी चाहिए।\n\n    तर्क:\n    - n (int): उपलब्ध फूलों के प्रकारों की संख्या।\n    - m (int): सजाने के लिए कुल गमलों की संख्या।\n    - a (list of int): एक सूची जहाँ a[i] ith प्रकार के फूल के लिए अधिकतम गमलों की संख्या है।\n\n    लौटाता है:\n    - int: विशिष्ट व्यवस्थाओं की संख्या (10^6 + 7) के मापांक के रूप में।\n\n    उदाहरण:\n    - calculate_arrangements(2, 4, [3, 2]) 2 लौटाता है।\n      दो प्रकार के फूलों का उपयोग करके 4 गमलों के लिए दो संभावित व्यवस्थाएँ हैं\n      जहाँ पहले प्रकार के अधिकतम 3 और दूसरे प्रकार के अधिकतम 2 गमले हो सकते हैं: [1, 1, 2, 2] और [1, 2, 2, 2]।\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 लौटाता है।\n      तीन प्रकार के फूलों का उपयोग करके 3 गमलों को सजाने के छह तरीके हैं जब\n      पहले, दूसरे और तीसरे प्रकार के लिए अधिकतम गमले 1, 2, और 3 हैं।\n    \"\"\"", "hu": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Számítsa ki, hányféleképpen lehet elrendezni m virágcserepet legfeljebb n típus\n    felhasználásával, ahol az i-edik típusból legfeljebb a[i] cserép lehet, és az\n    elrendezésnek növekvő sorrendben kell lennie a virágtípusok szerint.\n\n    Argumentumok:\n    - n (int): A rendelkezésre álló virágtípusok száma.\n    - m (int): Az elrendezendő virágcserepek teljes száma.\n    - a (list of int): Egy lista, ahol a[i] az i-edik virágtípushoz tartozó maximális cserépszám.\n\n    Visszatér:\n    - int: A különböző elrendezések száma modulo (10^6 + 7).\n\n    Példák:\n    - calculate_arrangements(2, 4, [3, 2]) visszaadja 2.\n      Két lehetséges elrendezés van 4 cseréphez két virágtípus felhasználásával,\n      legfeljebb 3 az első típusból és 2 a második típusból: [1, 1, 2, 2] és [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) visszaadja 6.\n      Hatféleképpen lehet elrendezni 3 cserepet három virágtípus felhasználásával, amikor a\n      maximális cserépszámok 1, 2 és 3 az első, második és harmadik típushoz.\n    \"\"\"", "es": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Calcular el número de formas de arreglar m macetas de flores usando hasta n tipos,\n    donde el i-ésimo tipo puede tener como máximo a[i] macetas, y el arreglo debe estar en\n    orden creciente de tipos de flores.\n\n    Argumentos:\n    - n (int): El número de tipos de flores disponibles.\n    - m (int): El número total de macetas de flores a arreglar.\n    - a (list of int): Una lista donde a[i] es el número máximo de macetas para el i-ésimo tipo de flor.\n\n    Devuelve:\n    - int: El número de arreglos distintos módulo (10^6 + 7).\n\n    Ejemplos:\n    - calculate_arrangements(2, 4, [3, 2]) devuelve 2.\n      Hay dos arreglos posibles para 4 macetas usando dos tipos de flores con\n      como máximo 3 del primer tipo y 2 del segundo tipo: [1, 1, 2, 2] y [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) devuelve 6.\n      Hay seis formas de arreglar 3 macetas usando tres tipos de flores cuando el\n      máximo de macetas es 1, 2 y 3 para el primer, segundo y tercer tipo respectivamente.\n    \"\"\"", "arb": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    حساب عدد الطرق لترتيب m من الأواني الزهرية باستخدام ما يصل إلى n نوعًا،\n    حيث يمكن أن يحتوي النوع i على ما لا يزيد عن a[i] من الأواني، ويجب أن يكون الترتيب\n    بترتيب تصاعدي لأنواع الأزهار.\n\n    يعيدالحجج:\n    - n (int): عدد أنواع الأزهار المتاحة.\n    - m (int): العدد الإجمالي للأواني الزهرية لترتيبها.\n    - a (list of int): قائمة حيث a[i] هو الحد الأقصى لعدد الأواني لنوع الزهرة i.\n\n    يعيد:\n    - int: عدد الترتيبات المميزة موديولو (10^6 + 7).\n\n    أمثلة:\n    - calculate_arrangements(2, 4, [3, 2]) يعيد 2.\n      هناك ترتيبين ممكنين لـ 4 أواني باستخدام نوعين من الأزهار مع\n      ما لا يزيد عن 3 من النوع الأول و2 من النوع الثاني: [1, 1, 2, 2] و[1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) يعيد 6.\n      هناك ست طرق لترتيب 3 أواني باستخدام ثلاثة أنواع من الأزهار عندما يكون\n      الحد الأقصى للأواني هو 1، 2، و3 للنوع الأول، الثاني، والثالث على التوالي.\n    \"\"\"", "sw": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Hesabu idadi ya njia za kupanga sufuria za maua m kwa kutumia aina hadi n,\n    ambapo aina ya ith inaweza kuwa na sufuria zisizozidi a[i], na mpangilio lazima uwe katika\n    mpangilio wa kuongezeka wa aina za maua.\n\n    Hoja:\n    - n (int): Idadi ya aina za maua zinazopatikana.\n    - m (int): Jumla ya idadi ya sufuria za maua za kupanga.\n    - a (list of int): Orodha ambapo a[i] ni idadi ya juu zaidi ya sufuria kwa aina ya ith ya maua.\n\n    Inarejesha:\n    - int: Idadi ya mipangilio tofauti modulo (10^6 + 7).\n\n    Mifano:\n    - calculate_arrangements(2, 4, [3, 2]) inarudisha 2.\n      Kuna mipangilio miwili inayowezekana kwa sufuria 4 kwa kutumia aina mbili za maua na\n      angalau 3 za aina ya kwanza na 2 za aina ya pili: [1, 1, 2, 2] na [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) inarudisha 6.\n      Kuna njia sita za kupanga sufuria 3 kwa kutumia aina tatu za maua wakati\n      sufuria za juu zaidi ni 1, 2, na 3 kwa aina ya kwanza, ya pili, na ya tatu mtawalia.\n    \"\"\"", "tr": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    En fazla n türü kullanarak m çiçek saksısını düzenlemenin yollarını hesaplayın,\n    burada i. tür en fazla a[i] saksıya sahip olabilir ve düzenleme\n    çiçek türlerinin artan sırasına göre olmalıdır.\n\n    Argümanlar:\n    - n (int): Mevcut çiçek türlerinin sayısı.\n    - m (int): Düzenlenecek toplam çiçek saksısı sayısı.\n    - a (list of int): a[i], i. çiçek türü için maksimum saksı sayısını belirten bir liste.\n\n    Döndürür:\n    - int: Farklı düzenlemelerin sayısı mod (10^6 + 7).\n\n    Örnekler:\n    - calculate_arrangements(2, 4, [3, 2]) 2 döndürür.\n      İki tür çiçek kullanarak 4 saksı için iki olası düzenleme vardır,\n      ilk türden en fazla 3 ve ikinci türden en fazla 2: [1, 1, 2, 2] ve [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 döndürür.\n      Maksimum saksı sayıları sırasıyla birinci, ikinci ve üçüncü türler için 1, 2 ve 3 olduğunda,\n      üç tür çiçek kullanarak 3 saksı düzenlemenin altı yolu vardır.\n    \"\"\"", "vi": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Tính số cách sắp xếp m chậu hoa sử dụng tối đa n loại,\n    trong đó loại thứ i có thể có tối đa a[i] chậu, và cách sắp xếp phải theo\n    thứ tự tăng dần của các loại hoa.\n\n    Tham số:\n    - n (int): Số loại hoa có sẵn.\n    - m (int): Tổng số chậu hoa cần sắp xếp.\n    - a (list of int): Danh sách mà a[i] là số chậu tối đa cho loại hoa thứ i.\n\n    Trả về:\n    - int: Số cách sắp xếp khác nhau theo modulo (10^6 + 7).\n\n    Ví dụ:\n    - calculate_arrangements(2, 4, [3, 2]) trả về 2.\n      Có hai cách sắp xếp 4 chậu sử dụng hai loại hoa với\n      tối đa 3 của loại thứ nhất và 2 của loại thứ hai: [1, 1, 2, 2] và [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) trả về 6.\n      Có sáu cách để sắp xếp 3 chậu sử dụng ba loại hoa khi\n      số chậu tối đa là 1, 2, và 3 cho loại thứ nhất, thứ hai, và thứ ba tương ứng.\n    \"\"\"", "id": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Hitung jumlah cara untuk mengatur m pot bunga menggunakan hingga n jenis,\n    di mana jenis ke-i dapat memiliki paling banyak a[i] pot, dan pengaturan harus dalam\n    urutan menaik dari jenis bunga.\n\n    Args:\n    - n (int): Jumlah jenis bunga yang tersedia.\n    - m (int): Jumlah total pot bunga yang akan diatur.\n    - a (list of int): Daftar di mana a[i] adalah jumlah maksimum pot untuk jenis bunga ke-i.\n\n    Returns:\n    - int: Jumlah pengaturan yang berbeda modulo (10^6 + 7).\n\n    Contoh:\n    - calculate_arrangements(2, 4, [3, 2]) mengembalikan 2.\n      Ada dua pengaturan yang mungkin untuk 4 pot menggunakan dua jenis bunga dengan\n      paling banyak 3 dari jenis pertama dan 2 dari jenis kedua: [1, 1, 2, 2] dan [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) mengembalikan 6.\n      Ada enam cara untuk mengatur 3 pot menggunakan tiga jenis bunga ketika\n      pot maksimum adalah 1, 2, dan 3 untuk jenis pertama, kedua, dan ketiga masing-masing.\n    \"\"\"", "ja": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    最大でn種類を使用してm個の花の鉢を配置する方法の数を計算します。\n    ここで、i番目の種類は最大でa[i]個の鉢を持つことができ、配置は\n    花の種類の昇順でなければなりません。\n\n    引数:\n    - n (int): 利用可能な花の種類の数。\n    - m (int): 配置する花の鉢の総数。\n    - a (list of int): a[i]がi番目の種類の花の最大鉢数であるリスト。\n\n    戻り値:\n    - int: 異なる配置の数を(10^6 + 7)で割った余り。\n\n    例:\n    - calculate_arrangements(2, 4, [3, 2]) は2を返します。\n      4つの鉢を2種類の花を使用して配置する2つの可能な方法があります。\n      最初の種類は最大3つ、2番目の種類は最大2つ: [1, 1, 2, 2] と [1, 2, 2, 2]。\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) は6を返します。\n      3つの鉢を3種類の花を使用して配置する6つの方法があります。\n      最大鉢数はそれぞれ最初、2番目、3番目の種類で1、2、3です。\n    \"\"\"", "ko": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    최대 n 종류의 꽃을 사용하여 m 개의 꽃 화분을 배열하는 방법의 수를 계산합니다.\n    여기서 i번째 종류는 최대 a[i] 개의 화분을 가질 수 있으며, 배열은 꽃 종류의\n    증가하는 순서로 이루어져야 합니다.\n\n    Args:\n    - n (int): 사용 가능한 꽃 종류의 수.\n    - m (int): 배열할 꽃 화분의 총 수.\n    - a (list of int): a[i]가 i번째 꽃 종류의 최대 화분 수인 리스트.\n\n    Returns:\n    - int: (10^6 + 7)로 나눈 나머지로 구분된 배열의 수.\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n      두 종류의 꽃을 사용하여 4개의 화분을 배열하는 두 가지 가능한 배열이 있습니다.\n      첫 번째 종류는 최대 3개, 두 번째 종류는 최대 2개: [1, 1, 2, 2] 및 [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n      첫 번째, 두 번째, 세 번째 종류의 최대 화분 수가 각각 1, 2, 3일 때\n      세 종류의 꽃을 사용하여 3개의 화분을 배열하는 여섯 가지 방법이 있습니다.\n    \"\"\"", "ml": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    m പാത്രങ്ങൾ പൂക്കൾ ഉപയോഗിച്ച് ക്രമീകരിക്കുന്നതിനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണക്കാക്കുക,\n    അതിൽ i-ാം തരം പരമാവധി a[i] പാത്രങ്ങൾ ഉണ്ടാകാം, കൂടാതെ ക്രമീകരണം പൂക്കളുടെ തരം\n    വർദ്ധിക്കുന്ന ക്രമത്തിൽ ആയിരിക്കണം.\n\n    Args:\n    - n (int): ലഭ്യമായ പൂക്കളുടെ തരം.\n    - m (int): ക്രമീകരിക്കേണ്ട മൊത്തം പൂക്കൾ പാത്രങ്ങളുടെ എണ്ണം.\n    - a (list of int): a[i] പൂക്കളുടെ i-ാം തരം പരമാവധി പാത്രങ്ങളുടെ എണ്ണം സൂചിപ്പിക്കുന്ന പട്ടിക.\n\n    Returns:\n    - int: വ്യത്യസ്ത ക്രമീകരണങ്ങളുടെ എണ്ണം (10^6 + 7) മൊഡുലോ.\n\n    ഉദാഹരണങ്ങൾ:\n    - calculate_arrangements(2, 4, [3, 2]) 2 മടക്കം ചെയ്യുന്നു.\n      രണ്ട് തരം പൂക്കൾ ഉപയോഗിച്ച് 4 പാത്രങ്ങൾ ക്രമീകരിക്കുന്നതിനുള്ള രണ്ട് സാധ്യതയുള്ള ക്രമീകരണങ്ങൾ\n      ഉണ്ട്, ആദ്യ തരം പരമാവധി 3 ഉം രണ്ടാമത്തെ തരം 2 ഉം: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 മടക്കം ചെയ്യുന്നു.\n      3 തരം പൂക്കൾ ഉപയോഗിച്ച് 3 പാത്രങ്ങൾ ക്രമീകരിക്കുന്നതിനുള്ള ആറ് മാർഗങ്ങളുണ്ട്, \n      പരമാവധി പാത്രങ്ങൾ ഒന്നാമത്തെ, രണ്ടാമത്തെ, മൂന്നാമത്തെ തരം യഥാക്രമം 1, 2, 3 ആണ്.\n    \"\"\"", "fa": "python\ndef calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    محاسبه تعداد روش‌های چیدمان m گلدان گل با استفاده از حداکثر n نوع،\n    به طوری که نوع iام می‌تواند حداکثر a[i] گلدان داشته باشد و چیدمان باید\n    به ترتیب صعودی از نوع گل‌ها باشد.\n\n    Args:\n    - n (int): تعداد انواع گل‌های موجود.\n    - m (int): تعداد کل گلدان‌های گل برای چیدمان.\n    - a (list of int): لیستی که در آن a[i] حداکثر تعداد گلدان‌ها برای نوع iام گل است.\n\n    Returns:\n    - int: تعداد چیدمان‌های متمایز به پیمانه (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n      دو چیدمان ممکن برای 4 گلدان با استفاده از دو نوع گل با\n      حداکثر 3 از نوع اول و 2 از نوع دوم وجود دارد: [1, 1, 2, 2] و [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n      شش روش برای چیدمان 3 گلدان با استفاده از سه نوع گل وجود دارد وقتی که\n      حداکثر گلدان‌ها 1، 2 و 3 برای نوع اول، دوم و سوم به ترتیب هستند.\n    \"\"\"\n"}, "canonical_solution": "    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]", "instruction": {"en": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\n请用中文为以下 Python 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nBada takaitaccen bayanin harshen dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben.", "es": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) untuk kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\n以下のPythonコードの説明を日本語で簡潔に記述してください。500文字以内でお願いします。", "ko": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자까지 사용 가능합니다.", "ml": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nപൈതൺ കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nتوضیح مختصری به زبان طبیعی (docstring) از کد پایتون به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_calculate_arrangements():\n    # Helper function to compare expected and actual results\n    def assert_equal(actual, expected, message):\n        assert actual == expected, message\n\n    # Test Case 1\n    n, m, a = 2, 4, [3, 2]\n    expected = 2\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 1 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 2\n    n, m, a = 3, 3, [1, 2, 3]\n    expected = 6\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 2 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 3\n    n, m, a = 1, 5, [5]\n    expected = 1\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 3 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_calculate_arrangements()", "entry_point": "calculate_arrangements", "signature": "def calculate_arrangements(n, m, a) -> int:", "docstring": {"en": "Compute the number of ways to arrange m pots of flowers using up to n types,\nwhere the ith type can have at most a[i] pots, and the arrangement must be in\nincreasing order of flower types.\n\nArgs:\n- n (int): The number of flower types available.\n- m (int): The total number of flower pots to arrange.\n- a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\nReturns:\n- int: The number of distinct arrangements modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) returns 2.\nThere are two possible arrangements for 4 pots using two types of flowers with\nat most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nThere are six ways to arrange 3 pots using three types of flowers when the\nmaximum pots are 1, 2, and 3 for the first, second, and third types respectively.", "sq": "Llogarit numrin e mënyrave për të rregulluar m vazo me lule duke përdorur deri në n lloje,\nku lloji i-të mund të ketë më së shumti a[i] vazo, dhe rregullimi duhet të jetë në\nrend rritës të llojeve të luleve.\n\nArgumentet:\n- n (int): Numri i llojeve të luleve në dispozicion.\n- m (int): Numri total i vazove të luleve për t'u rregulluar.\n- a (listë e int): Një listë ku a[i] është numri maksimal i vazove për llojin e i-të të luleve.\n\nKthen:\n- int: Numri i rregullimeve të dallueshme modulo (10^6 + 7).\n\nShembuj:\n- calculate_arrangements(2, 4, [3, 2]) kthen 2.\nEkzistojnë dy rregullime të mundshme për 4 vazo duke përdorur dy lloje lulesh me\nmë së shumti 3 të llojit të parë dhe 2 të llojit të dytë: [1, 1, 2, 2] dhe [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) kthen 6.\nEkzistojnë gjashtë mënyra për të rregulluar 3 vazo duke përdorur tre lloje lulesh kur\nnumri maksimal i vazove është 1, 2, dhe 3 për llojin e parë, të dytë, dhe të tretë përkatësisht.", "hy": "Հաշվել, թե քանի ձևով կարելի է դասավորել m ծաղկամաններ՝ օգտագործելով մինչև n տեսակներ, որտեղ i-րդ տեսակը կարող է ունենալ առավելագույնը a[i] ծաղկաման, և դասավորությունը պետք է լինի ծաղիկների տեսակների աճման կարգով:\n\nԱրձանագրություններ:\n- n (int): Առկա ծաղիկների տեսակների քանակը:\n- m (int): Դասավորելու ընդհանուր ծաղկամանների քանակը:\n- a (list of int): Ցուցակ, որտեղ a[i]-ն i-րդ տեսակի ծաղիկների առավելագույն ծաղկամանների քանակն է:\n\nՎերադարձնում է:\n- int: Տարբեր դասավորությունների քանակը մոդուլո (10^6 + 7):\n\nՕրինակներ:\n- calculate_arrangements(2, 4, [3, 2]) վերադարձնում է 2:\nԿան երկու հնարավոր դասավորություններ 4 ծաղկամանների համար՝ օգտագործելով երկու տեսակի ծաղիկներ, երբ առավելագույնը 3 առաջին տեսակի և 2 երկրորդ տեսակի համար՝ [1, 1, 2, 2] և [1, 2, 2, 2]:\n\n- calculate_arrangements(3, 3, [1, 2, 3]) վերադարձնում է 6:\nԿան վեց ձևեր դասավորելու 3 ծաղկամաններ՝ օգտագործելով երեք տեսակի ծաղիկներ, երբ առավելագույն ծաղկամանները 1, 2 և 3 են համապատասխանաբար առաջին, երկրորդ և երրորդ տեսակների համար:", "bn": "m টি ফুলের টব সাজানোর উপায়ের সংখ্যা গণনা করুন n প্রকারের মধ্যে, যেখানে i-তম প্রকারের সর্বাধিক a[i] টব থাকতে পারে এবং বিন্যাসটি ফুলের প্রকারের ক্রমবর্ধমান ক্রমে হতে হবে।\n\nআর্গস:\n- n (int): উপলব্ধ ফুলের প্রকারের সংখ্যা।\n- m (int): সাজানোর জন্য মোট ফুলের টবের সংখ্যা।\n- a (list of int): একটি তালিকা যেখানে a[i] হল i-তম প্রকারের ফুলের জন্য সর্বাধিক টবের সংখ্যা।\n\nরিটার্নস:\n- int: স্বতন্ত্র বিন্যাসের সংখ্যা মডুলো (10^6 + 7)।\n\nউদাহরণ:\n- calculate_arrangements(2, 4, [3, 2]) 2 প্রদান করে।\nদুটি সম্ভাব্য বিন্যাস আছে 4 টবের জন্য দুটি প্রকারের ফুল ব্যবহার করে যেখানে প্রথম প্রকারের সর্বাধিক 3 এবং দ্বিতীয় প্রকারের সর্বাধিক 2: [1, 1, 2, 2] এবং [1, 2, 2, 2]।\n\n- calculate_arrangements(3, 3, [1, 2, 3]) 6 প্রদান করে।\n6টি উপায় আছে 3 টব সাজানোর জন্য তিন প্রকারের ফুল ব্যবহার করে যখন সর্বাধিক টবের সংখ্যা যথাক্রমে প্রথম, দ্বিতীয় এবং তৃতীয় প্রকারের জন্য 1, 2, এবং 3।", "bg": "Изчислете броя на начините за подреждане на m саксии с цветя, използвайки до n типа, като i-тият тип може да има най-много a[i] саксии, и подреждането трябва да бъде във възходящ ред на типовете цветя.\n\nАргументи:\n- n (int): Броят на наличните типове цветя.\n- m (int): Общият брой саксии с цветя за подреждане.\n- a (списък от int): Списък, където a[i] е максималният брой саксии за i-тия тип цветя.\n\nВръща:\n- int: Броят на различните подреждания по модул (10^6 + 7).\n\nПримери:\n- calculate_arrangements(2, 4, [3, 2]) връща 2.\nИма два възможни подреждания за 4 саксии, използвайки два типа цветя с най-много 3 от първия тип и 2 от втория тип: [1, 1, 2, 2] и [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) връща 6.\nИма шест начина за подреждане на 3 саксии, използвайки три типа цветя, когато максималният брой саксии е 1, 2 и 3 за първия, втория и третия тип съответно.", "zh": "计算使用最多 n 种类型的 m 个花盆的排列方式，其中第 i 种类型最多可以有 a[i] 个花盆，并且排列必须按照花的类型递增顺序。\n\n参数:\n- n (int): 可用的花的类型数量。\n- m (int): 要排列的花盆总数。\n- a (list of int): 一个列表，其中 a[i] 是第 i 种花的最大花盆数量。\n\n返回:\n- int: 不同排列的数量，结果取模 (10^6 + 7)。\n\n示例:\n- calculate_arrangements(2, 4, [3, 2]) 返回 2。\n使用两种类型的花来排列 4 个花盆，第一种类型最多 3 个，第二种类型最多 2 个，有两种可能的排列：[1, 1, 2, 2] 和 [1, 2, 2, 2]。\n\n- calculate_arrangements(3, 3, [1, 2, 3]) 返回 6。\n使用三种类型的花来排列 3 个花盆，当第一、第二和第三种类型的最大花盆数分别为 1、2 和 3 时，有六种排列方式。", "fr": "Calculer le nombre de façons d'arranger m pots de fleurs en utilisant jusqu'à n types,\noù le ième type peut avoir au plus a[i] pots, et l'arrangement doit être en\nordre croissant des types de fleurs.\n\nArgs:\n- n (int): Le nombre de types de fleurs disponibles.\n- m (int): Le nombre total de pots de fleurs à arranger.\n- a (list of int): Une liste où a[i] est le nombre maximum de pots pour le ième type de fleur.\n\nReturns:\n- int: Le nombre d'arrangements distincts modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) retourne 2.\nIl y a deux arrangements possibles pour 4 pots en utilisant deux types de fleurs avec\nau plus 3 du premier type et 2 du second type : [1, 1, 2, 2] et [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) retourne 6.\nIl y a six façons d'arranger 3 pots en utilisant trois types de fleurs lorsque les\npots maximums sont 1, 2, et 3 pour les premier, deuxième, et troisième types respectivement.", "de": "Berechne die Anzahl der Möglichkeiten, m Blumentöpfe unter Verwendung von bis zu n Typen anzuordnen, wobei der i-te Typ höchstens a[i] Töpfe haben kann, und die Anordnung muss in aufsteigender Reihenfolge der Blumentypen erfolgen.\n\nArgs:\n- n (int): Die Anzahl der verfügbaren Blumentypen.\n- m (int): Die Gesamtanzahl der anzuordnenden Blumentöpfe.\n- a (list of int): Eine Liste, in der a[i] die maximale Anzahl von Töpfen für den i-ten Blumentyp ist.\n\nReturns:\n- int: Die Anzahl der unterschiedlichen Anordnungen modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) gibt 2 zurück.\nEs gibt zwei mögliche Anordnungen für 4 Töpfe unter Verwendung von zwei Blumentypen mit höchstens 3 vom ersten Typ und 2 vom zweiten Typ: [1, 1, 2, 2] und [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) gibt 6 zurück.\nEs gibt sechs Möglichkeiten, 3 Töpfe unter Verwendung von drei Blumentypen anzuordnen, wenn die maximale Anzahl der Töpfe 1, 2 und 3 für den ersten, zweiten und dritten Typ beträgt.", "ha": "Lissafa yawan hanyoyin da za a iya tsara tukwane m na furanni ta amfani da nau'ikan n,\ninda nau'in na i zai iya samun a[i] tukwane, kuma tsarin dole ne ya kasance a cikin\ntsari mai ƙaruwa na nau'ikan furanni.\n\nArgs:\n- n (int): Yawan nau'ikan furanni da ake da su.\n- m (int): Jimillar adadin tukwanen fure da za a tsara.\n- a (list of int): Jerin inda a[i] shine iyakar adadin tukwane don nau'in fure na i.\n\nReturns:\n- int: Yawan tsarukan daban-daban modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) returns 2.\nAkwai hanyoyi biyu masu yiyuwa don tsara tukwane 4 ta amfani da nau'ikan furanni biyu tare da akalla 3 na nau'in farko da 2 na nau'in na biyu: [1, 1, 2, 2] da [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nAkwai hanyoyi guda shida don tsara tukwane 3 ta amfani da nau'ikan furanni uku idan iyakar tukwane suna 1, 2, da 3 don nau'in farko, na biyu, da na uku bi da bi.", "hi": "फूलों के m गमलों को n प्रकारों का उपयोग करके व्यवस्थित करने के तरीकों की संख्या की गणना करें, जहाँ iवें प्रकार में अधिकतम a[i] गमले हो सकते हैं, और व्यवस्था फूलों के प्रकारों के बढ़ते क्रम में होनी चाहिए।\n\nआर्ग्स:\n- n (int): उपलब्ध फूलों के प्रकारों की संख्या।\n- m (int): व्यवस्थित करने के लिए कुल फूल गमलों की संख्या।\n- a (list of int): एक सूची जहाँ a[i] iवें प्रकार के फूल के लिए अधिकतम गमलों की संख्या है।\n\nवापसी:\n- int: विशिष्ट व्यवस्थाओं की संख्या (10^6 + 7) के मापांक के अनुसार।\n\nउदाहरण:\n- calculate_arrangements(2, 4, [3, 2]) 2 लौटाता है।\nदो प्रकार के फूलों का उपयोग करके 4 गमलों के लिए दो संभावित व्यवस्थाएँ हैं, पहले प्रकार के अधिकतम 3 और दूसरे प्रकार के अधिकतम 2: [1, 1, 2, 2] और [1, 2, 2, 2]।\n\n- calculate_arrangements(3, 3, [1, 2, 3]) 6 लौटाता है।\n3 गमलों को तीन प्रकार के फूलों का उपयोग करके व्यवस्थित करने के छह तरीके हैं जब पहले, दूसरे, और तीसरे प्रकार के लिए अधिकतम गमले क्रमशः 1, 2, और 3 हैं।", "hu": "Számítsuk ki, hányféleképpen lehet elrendezni m virágcserepet legfeljebb n típus használatával, ahol az i-edik típusnak legfeljebb a[i] cserép lehet, és az elrendezésnek növekvő sorrendben kell lennie a virágtípusok szerint.\n\nArgs:\n- n (int): A rendelkezésre álló virágtípusok száma.\n- m (int): Az elrendezendő virágcserepek teljes száma.\n- a (list of int): Egy lista, ahol a[i] az i-edik virágtípus maximális cserépszáma.\n\nReturns:\n- int: Az eltérő elrendezések száma modulo (10^6 + 7).\n\nPéldák:\n- calculate_arrangements(2, 4, [3, 2]) visszaadja 2.\nKét lehetséges elrendezés van 4 cserépre két virágtípus használatával, legfeljebb 3 az első típusból és 2 a második típusból: [1, 1, 2, 2] és [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) visszaadja 6.\nHatféleképpen lehet elrendezni 3 cserepet három virágtípus használatával, amikor a maximális cserépszámok 1, 2 és 3 az első, második és harmadik típusra.", "es": "Calcular el número de formas de organizar m macetas de flores usando hasta n tipos,\ndonde el tipo i puede tener como máximo a[i] macetas, y la disposición debe ser en\norden creciente de tipos de flores.\n\nArgumentos:\n- n (int): El número de tipos de flores disponibles.\n- m (int): El número total de macetas de flores a organizar.\n- a (list of int): Una lista donde a[i] es el número máximo de macetas para el tipo i de flor.\n\nDevuelve:\n- int: El número de disposiciones distintas módulo (10^6 + 7).\n\nEjemplos:\n- calculate_arrangements(2, 4, [3, 2]) devuelve 2.\nHay dos disposiciones posibles para 4 macetas usando dos tipos de flores con\ncomo máximo 3 del primer tipo y 2 del segundo tipo: [1, 1, 2, 2] y [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) devuelve 6.\nHay seis formas de organizar 3 macetas usando tres tipos de flores cuando las\nmacetas máximas son 1, 2 y 3 para el primer, segundo y tercer tipo respectivamente.", "arb": "احسب عدد الطرق لترتيب m من أواني الزهور باستخدام ما يصل إلى n نوعًا، حيث يمكن أن يحتوي النوع i على a[i] من الأواني كحد أقصى، ويجب أن يكون الترتيب بترتيب تصاعدي لأنواع الزهور.\n\nيعيدالحجج:\n- n (int): عدد أنواع الزهور المتاحة.\n- m (int): العدد الإجمالي لأواني الزهور لترتيبها.\n- a (list of int): قائمة حيث a[i] هو الحد الأقصى لعدد الأواني لنوع الزهور i.\n\nيعيد:\n- int: عدد الترتيبات المميزة مودولو (10^6 + 7).\n\nامثله:\n- calculate_arrangements(2, 4, [3, 2]) يعيد 2.\nهناك ترتيبين ممكنين لـ 4 أواني باستخدام نوعين من الزهور مع ما يصل إلى 3 من النوع الأول و2 من النوع الثاني: [1, 1, 2, 2] و [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) يعيد 6.\nهناك ست طرق لترتيب 3 أواني باستخدام ثلاثة أنواع من الزهور عندما تكون الأواني القصوى 1، 2، و3 للنوع الأول، الثاني، والثالث على التوالي.", "sw": "Hesabu idadi ya njia za kupanga sufuria za maua m kwa kutumia hadi aina n, ambapo aina ya ith inaweza kuwa na sufuria a[i] kwa zaidi, na mpangilio lazima uwe katika mpangilio wa kuongezeka wa aina za maua.\n\nHoja:\n- n (int): Idadi ya aina za maua zinazopatikana.\n- m (int): Jumla ya idadi ya sufuria za maua za kupanga.\n- a (orodha ya int): Orodha ambapo a[i] ni idadi ya juu ya sufuria kwa aina ya ith ya maua.\n\nInarejesha:\n- int: Idadi ya mipangilio tofauti modulo (10^6 + 7).\n\nMifano:\n- calculate_arrangements(2, 4, [3, 2]) inarudisha 2.\nKuna mipangilio miwili inayowezekana kwa sufuria 4 kwa kutumia aina mbili za maua na\nzaidi ya 3 za aina ya kwanza na 2 za aina ya pili: [1, 1, 2, 2] na [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) inarudisha 6.\nKuna njia sita za kupanga sufuria 3 kwa kutumia aina tatu za maua wakati\nsufuria za juu ni 1, 2, na 3 kwa aina ya kwanza, ya pili, na ya tatu mtawalia.", "tr": "m çiçek saksısını, her biri en fazla a[i] saksısına sahip olabilecek n türünü kullanarak düzenlemenin yollarını hesaplayın ve düzenleme çiçek türlerinin artan sırasına göre olmalıdır.\n\nArgümanlar:\n- n (int): Mevcut çiçek türlerinin sayısı.\n- m (int): Düzenlenecek toplam çiçek saksısı sayısı.\n- a (list of int): a[i]'nin i. çiçek türü için maksimum saksı sayısı olduğu bir liste.\n\nDöndürür:\n- int: Farklı düzenlemelerin sayısı mod (10^6 + 7).\n\nÖrnekler:\n- calculate_arrangements(2, 4, [3, 2]) 2 döndürür.\nİlk türden en fazla 3 ve ikinci türden en fazla 2 olmak üzere iki tür çiçek kullanarak 4 saksı için iki olası düzenleme vardır: [1, 1, 2, 2] ve [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) 6 döndürür.\nİlk, ikinci ve üçüncü türler için maksimum saksılar sırasıyla 1, 2 ve 3 olduğunda, üç tür çiçek kullanarak 3 saksıyı düzenlemenin altı yolu vardır.", "vi": "Tính số cách sắp xếp m chậu hoa sử dụng tối đa n loại,\ntrong đó loại thứ i có thể có tối đa a[i] chậu, và sắp xếp phải theo thứ tự tăng dần của các loại hoa.\n\nTham số:\n- n (int): Số loại hoa có sẵn.\n- m (int): Tổng số chậu hoa cần sắp xếp.\n- a (list of int): Danh sách mà a[i] là số chậu tối đa cho loại hoa thứ i.\n\nTrả về:\n- int: Số lượng sắp xếp khác nhau theo modulo (10^6 + 7).\n\nVí dụ:\n- calculate_arrangements(2, 4, [3, 2]) trả về 2.\nCó hai cách sắp xếp 4 chậu sử dụng hai loại hoa với tối đa 3 của loại thứ nhất và 2 của loại thứ hai: [1, 1, 2, 2] và [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) trả về 6.\nCó sáu cách để sắp xếp 3 chậu sử dụng ba loại hoa khi số chậu tối đa là 1, 2, và 3 cho loại thứ nhất, thứ hai, và thứ ba tương ứng.", "id": "Hitung jumlah cara untuk mengatur m pot bunga menggunakan hingga n jenis,\ndi mana jenis ke-i dapat memiliki paling banyak a[i] pot, dan pengaturan harus dalam\nurutan menaik dari jenis bunga.\n\nArgs:\n- n (int): Jumlah jenis bunga yang tersedia.\n- m (int): Jumlah total pot bunga yang akan diatur.\n- a (list of int): Daftar di mana a[i] adalah jumlah maksimum pot untuk jenis bunga ke-i.\n\nReturns:\n- int: Jumlah pengaturan yang berbeda modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) mengembalikan 2.\nAda dua kemungkinan pengaturan untuk 4 pot menggunakan dua jenis bunga dengan\npaling banyak 3 dari jenis pertama dan 2 dari jenis kedua: [1, 1, 2, 2] dan [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) mengembalikan 6.\nAda enam cara untuk mengatur 3 pot menggunakan tiga jenis bunga ketika\njumlah maksimum pot adalah 1, 2, dan 3 untuk jenis pertama, kedua, dan ketiga masing-masing.", "ja": "花の鉢をm個、n種類まで使用して配置する方法の数を計算します。ここで、i番目の種類は最大でa[i]個の鉢を持つことができ、配置は花の種類の昇順でなければなりません。\n\n引数:\n- n (int): 利用可能な花の種類の数。\n- m (int): 配置する花の鉢の総数。\n- a (list of int): a[i]がi番目の花の種類に対する鉢の最大数であるリスト。\n\n戻り値:\n- int: (10^6 + 7)での異なる配置の数。\n\n例:\n- calculate_arrangements(2, 4, [3, 2]) は2を返します。\n2種類の花を使用して4つの鉢を配置するには、最初の種類で最大3つ、2番目の種類で最大2つの鉢を使用する2つの可能な配置があります: [1, 1, 2, 2] と [1, 2, 2, 2]。\n\n- calculate_arrangements(3, 3, [1, 2, 3]) は6を返します。\n3つの鉢を3種類の花で配置する方法は6通りあります。最大鉢数は、それぞれ最初、2番目、3番目の種類で1、2、3です。", "ko": "꽃병 m개를 최대 n가지 종류를 사용하여 배열하는 방법의 수를 계산합니다. 여기서 i번째 종류는 최대 a[i]개의 꽃병을 가질 수 있으며, 배열은 꽃 종류의 증가하는 순서로 이루어져야 합니다.\n\n인수:\n- n (int): 사용 가능한 꽃 종류의 수.\n- m (int): 배열할 꽃병의 총 수.\n- a (list of int): a[i]가 i번째 꽃 종류의 최대 꽃병 수인 리스트.\n\n반환:\n- int: (10^6 + 7)로 나눈 나머지로 구분되는 배열의 수.\n\n예제:\n- calculate_arrangements(2, 4, [3, 2])는 2를 반환합니다.\n두 가지 종류의 꽃을 사용하여 최대 첫 번째 종류 3개와 두 번째 종류 2개로 4개의 꽃병을 배열하는 두 가지 가능한 배열이 있습니다: [1, 1, 2, 2] 및 [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3])는 6을 반환합니다.\n첫 번째, 두 번째, 세 번째 종류에 대해 최대 꽃병 수가 각각 1, 2, 3일 때 세 가지 종류의 꽃을 사용하여 3개의 꽃병을 배열하는 여섯 가지 방법이 있습니다.", "ml": "m പാത്രങ്ങൾ പൂക്കൾ ഉപയോഗിച്ച് ക്രമീകരിക്കുന്നതിനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണക്കാക്കുക,\n    അതിൽ i-ാം തരം പരമാവധി a[i] പാത്രങ്ങൾ ഉണ്ടാകാം, കൂടാതെ ക്രമീകരണം പൂക്കളുടെ തരം\n    വർദ്ധിക്കുന്ന ക്രമത്തിൽ ആയിരിക്കണം.\n\nArgs:\n- n (int): ലഭ്യമായ പുഷ്പ തരംങ്ങളുടെ എണ്ണം.\n- m (int): ക്രമീകരിക്കേണ്ട പുഷ്പക്കുല പാത്രങ്ങളുടെ മൊത്തം എണ്ണം.\n- a (list of int): ഒരു പട്ടിക, ഇവിടെ a[i] i-ആമത്തെ പുഷ്പ തരം ഏറ്റവും കൂടുതൽ എത്ര പാത്രങ്ങൾക്കുള്ളതാണെന്ന് കാണിക്കുന്നു.\n\nReturns:\n- int: വ്യത്യസ്തമായ ക്രമീകരണങ്ങളുടെ എണ്ണം (10^6 + 7) ന്റെ മോഡുലോ.\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) 2 നെ മടക്കുന്നു.\n2 തരം പുഷ്പങ്ങൾ ഉപയോഗിച്ച് 4 പാത്രങ്ങൾ ക്രമീകരിക്കുന്നതിനുള്ള രണ്ട് സാധ്യതയുള്ള ക്രമീകരണങ്ങൾ ഉണ്ട്, ആദ്യ തരം ഏറ്റവും കൂടുതൽ 3 ഉം രണ്ടാം തരം 2 ഉം: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) 6 നെ മടക്കുന്നു.\n3 തരം പുഷ്പങ്ങൾ ഉപയോഗിച്ച് 3 പാത്രങ്ങൾ ക്രമീകരിക്കുന്നതിനുള്ള ആറ് മാർഗ്ഗങ്ങൾ ഉണ്ട്, ആദ്യ, രണ്ടാം, മൂന്നാം തരം യഥാക്രമം 1, 2, 3 എന്നിങ്ങനെ ഏറ്റവും കൂടുതൽ പാത്രങ്ങൾ ഉള്ളപ്പോൾ.", "fa": "محاسبه تعداد روش‌های چیدمان m گلدان گل با استفاده از حداکثر n نوع،\nبه طوری که از نوع iام حداکثر a[i] گلدان می‌تواند داشته باشد و چیدمان باید به ترتیب\nافزایشی انواع گل‌ها باشد.\n\nآرگومان‌ها:\n- n (int): تعداد انواع گل‌های موجود.\n- m (int): تعداد کل گلدان‌های گل برای چیدمان.\n- a (list of int): لیستی که در آن a[i] حداکثر تعداد گلدان‌ها برای نوع iام گل است.\n\nبازگشت:\n- int: تعداد چیدمان‌های متمایز به پیمانه (10^6 + 7).\n\nمثال‌ها:\n- calculate_arrangements(2, 4, [3, 2]) مقدار 2 را برمی‌گرداند.\nدو چیدمان ممکن برای 4 گلدان با استفاده از دو نوع گل وجود دارد که\nحداکثر 3 از نوع اول و 2 از نوع دوم است: [1, 1, 2, 2] و [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) مقدار 6 را برمی‌گرداند.\nشش روش برای چیدمان 3 گلدان با استفاده از سه نوع گل وجود دارد وقتی که\nحداکثر گلدان‌ها به ترتیب 1، 2 و 3 برای نوع اول، دوم و سوم هستند."}}
{"task_id": "Python/40", "prompt": {"en": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided", "sq": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Dekripton një tekst të koduar me shifrën Vigenère duke përdorur çelësin e dhënë.\n    \n    Shifra Vigenère është një metodë për të koduar tekst alfabetik duke përdorur një seri\n    shifrash Caesar bazuar në shkronjat e një fjale kyçe. Kjo funksion kthen procesin\n    për të rikuperuar tekstin origjinal nga teksti i koduar.\n\n    Argumentet:\n        key (str): Çelësi i enkriptimit i përdorur për të koduar tekstin origjinal.\n                   Ky çelës duhet të përmbajë vetëm karaktere alfabetike.\n        ciphertext (str): Teksti i koduar që duhet të dekriptohet.\n                          Teksti i koduar duhet të përmbajë vetëm karaktere alfabetike.\n\n    Kthen:\n        str: Teksti i dekriptuar që korrespondon me tekstin e koduar të dhënë.\n\n    Shembuj:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Zbatimi i funksionit siç është dhënë", "hy": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Վիջեներ կոդով կոդավորված գաղտնագիրը ապակոդավորում է տրված բանալու միջոցով:\n    \n    Վիջեներ կոդը այբբենական տեքստի կոդավորման մեթոդ է, որը օգտագործում է\n    Կեսարի կոդերի շարք հիմնված բանալի բառի տառերի վրա: Այս ֆունկցիան հակադարձում է գործընթացը\n    վերականգնելու համար սկզբնական պարզ տեքստը գաղտնագրից:\n\n    Պարամետրեր:\n        key (str): Կոդավորման բանալին, որը օգտագործվել է սկզբնական պարզ տեքստը կոդավորելու համար:\n                   Այս բանալին պետք է կազմված լինի միայն այբբենական նիշերից:\n        ciphertext (str): Կոդավորված տեքստը, որը պետք է ապակոդավորվի:\n                          Գաղտնագիրը պետք է կազմված լինի միայն այբբենական նիշերից:\n\n    Վերադարձնում է:\n        str: Ապակոդավորված պարզ տեքստը, որը համապատասխանում է մուտքային գաղտնագրին:\n\n    Օրինակներ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Ֆունկցիայի իրականացումը ինչպես տրված է", "bn": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    প্রদত্ত কী ব্যবহার করে Vigenère সাইফার দিয়ে এনক্রিপ্ট করা একটি সাইফারটেক্সট ডিক্রিপ্ট করে।\n\n    Vigenère সাইফার হল একটি পদ্ধতি যা একটি কীওয়ার্ডের অক্ষরগুলির উপর ভিত্তি করে সিজার সাইফারের একটি সিরিজ ব্যবহার করে বর্ণানুক্রমিক টেক্সট এনক্রিপ্ট করে। এই ফাংশনটি প্রক্রিয়াটি বিপরীত করে সাইফারটেক্সট থেকে আসল প্লেইনটেক্সট পুনরুদ্ধার করে।\n\n    আর্গুমেন্টসমূহ:\n        key (str): এনক্রিপশন কী যা আসল প্লেইনটেক্সট এনক্রিপ্ট করতে ব্যবহৃত হয়েছিল।\n                   এই কী শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n        ciphertext (str): এনক্রিপ্ট করা টেক্সট যা ডিক্রিপ্ট করা প্রয়োজন।\n                          সাইফারটেক্সট শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n\n    রিটার্নস:\n        str: ইনপুট সাইফারটেক্সটের সাথে সম্পর্কিত ডিক্রিপ্ট করা প্লেইনটেক্সট।\n\n    উদাহরণ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided", "bg": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Декриптира шифротекст, шифрован с шифъра на Виженер, използвайки предоставения ключ.\n    \n    Шифърът на Виженер е метод за шифроване на азбучен текст чрез използване на серия от\n    шифри на Цезар, базирани на буквите на ключова дума. Тази функция обръща процеса,\n    за да възстанови оригиналния открит текст от шифротекста.\n\n    Args:\n        key (str): Ключът за шифроване, използван за шифроване на оригиналния открит текст.\n                   Този ключ трябва да се състои само от азбучни символи.\n        ciphertext (str): Шифротекстът, който трябва да бъде декриптиран.\n                          Шифротекстът трябва да се състои само от азбучни символи.\n\n    Returns:\n        str: Декриптираният открит текст, съответстващ на входния шифротекст.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Реализация на функцията, както е предоставена", "zh": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    使用提供的密钥解密用维吉尼亚密码加密的密文。\n    \n    维吉尼亚密码是一种通过使用基于关键字字母的凯撒密码系列来加密字母文本的方法。\n    此函数逆转该过程，从密文中恢复原始明文。\n\n    参数:\n        key (str): 用于加密原始明文的加密密钥。\n                   此密钥应仅由字母字符组成。\n        ciphertext (str): 需要解密的加密文本。\n                          密文应仅由字母字符组成。\n\n    返回:\n        str: 与输入密文对应的解密明文。\n\n    示例:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided", "fr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Décrypte un texte chiffré avec le chiffre de Vigenère en utilisant la clé fournie.\n    \n    Le chiffre de Vigenère est une méthode de chiffrement de texte alphabétique en utilisant une série de\n    chiffres de César basés sur les lettres d'un mot-clé. Cette fonction inverse le processus\n    pour récupérer le texte original à partir du texte chiffré.\n\n    Args:\n        key (str): La clé de chiffrement utilisée pour chiffrer le texte original.\n                   Cette clé doit être composée uniquement de caractères alphabétiques.\n        ciphertext (str): Le texte chiffré qui doit être déchiffré.\n                          Le texte chiffré doit être composé uniquement de caractères alphabétiques.\n\n    Returns:\n        str: Le texte déchiffré correspondant au texte chiffré d'entrée.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Implémentation de la fonction telle que fournie", "de": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Entschlüsselt einen mit dem Vigenère-Chiffre verschlüsselten Geheimtext unter Verwendung des bereitgestellten Schlüssels.\n    \n    Das Vigenère-Chiffre ist eine Methode zur Verschlüsselung von alphabetischem Text durch die Verwendung einer Reihe von\n    Caesar-Chiffren basierend auf den Buchstaben eines Schlüsselworts. Diese Funktion kehrt den Prozess um,\n    um den ursprünglichen Klartext aus dem Geheimtext wiederherzustellen.\n\n    Args:\n        key (str): Der Verschlüsselungsschlüssel, der zur Verschlüsselung des ursprünglichen Klartexts verwendet wurde.\n                   Dieser Schlüssel sollte nur aus alphabetischen Zeichen bestehen.\n        ciphertext (str): Der verschlüsselte Text, der entschlüsselt werden muss.\n                          Der Geheimtext sollte nur aus alphabetischen Zeichen bestehen.\n\n    Returns:\n        str: Der entschlüsselte Klartext, der dem Eingabe-Geheimtext entspricht.\n\n    Beispiele:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Funktionsimplementierung wie bereitgestellt", "ha": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Yana fassara rubutun da aka ɓoye tare da Vigenère cipher ta amfani da mabuɗin da aka bayar.\n    \n    Vigenère cipher wata hanya ce ta ɓoye rubutun haruffa ta hanyar amfani da jerin\n    Caesar ciphers bisa ga haruffan kalmar sirri. Wannan aikin yana juyar da tsarin\n    don dawo da ainihin rubutun daga rubutun da aka ɓoye.\n\n    Args:\n        key (str): Mabuɗin ɓoyewa da aka yi amfani da shi don ɓoye ainihin rubutun.\n                   Wannan mabuɗin ya kamata ya ƙunshi haruffa kawai.\n        ciphertext (str): Rubutun da aka ɓoye wanda ake buƙatar a fassara.\n                          Rubutun da aka ɓoye ya kamata ya ƙunshi haruffa kawai.\n\n    Returns:\n        str: Rubutun da aka fassara wanda ya dace da rubutun da aka bayar.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Aiwatar da aikin kamar yadda aka bayar", "hi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Vigenère सिफर का उपयोग करके एन्क्रिप्ट किए गए सिफरटेक्स्ट को दिए गए कुंजी का उपयोग करके डिक्रिप्ट करता है।\n    \n    Vigenère सिफर एक कीवर्ड के अक्षरों के आधार पर सीज़र सिफर की एक श्रृंखला का उपयोग करके वर्णमाला पाठ को एन्क्रिप्ट करने की एक विधि है। \n    यह फ़ंक्शन प्रक्रिया को उलटता है ताकि सिफरटेक्स्ट से मूल प्लेनटेक्स्ट को पुनः प्राप्त किया जा सके।\n\n    Args:\n        key (str): एन्क्रिप्शन कुंजी जो मूल प्लेनटेक्स्ट को एन्क्रिप्ट करने के लिए उपयोग की गई थी।\n                   यह कुंजी केवल वर्णमाला के अक्षरों से बनी होनी चाहिए।\n        ciphertext (str): एन्क्रिप्टेड पाठ जिसे डिक्रिप्ट करने की आवश्यकता है।\n                          सिफरटेक्स्ट केवल वर्णमाला के अक्षरों से बना होना चाहिए।\n\n    Returns:\n        str: इनपुट सिफरटेक्स्ट के अनुरूप डिक्रिप्टेड प्लेनटेक्स्ट।\n\n    उदाहरण:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided", "hu": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Egy Vigenère-rejtjel segítségével titkosított szöveg visszafejtése a megadott kulcs használatával.\n    \n    A Vigenère-rejtjel egy módszer az alfabetikus szöveg titkosítására, amely egy kulcsszó betűin alapuló\n    Caesar-rejtjelek sorozatát használja. Ez a függvény visszafordítja a folyamatot, hogy visszanyerje\n    az eredeti nyílt szöveget a titkosított szövegből.\n\n    Args:\n        key (str): A titkosításhoz használt kulcs az eredeti nyílt szöveg titkosításához.\n                   Ez a kulcs csak alfabetikus karaktereket tartalmazhat.\n        ciphertext (str): A titkosított szöveg, amelyet vissza kell fejteni.\n                          A titkosított szöveg csak alfabetikus karaktereket tartalmazhat.\n\n    Returns:\n        str: A visszafejtett nyílt szöveg, amely megfelel a bemeneti titkosított szövegnek.\n\n    Példák:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # A függvény megvalósítása a megadottak szerint", "es": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Descifra un texto cifrado con el cifrado de Vigenère utilizando la clave proporcionada.\n    \n    El cifrado de Vigenère es un método de cifrado de texto alfabético mediante el uso de una serie de\n    cifrados César basados en las letras de una palabra clave. Esta función invierte el proceso\n    para recuperar el texto original a partir del texto cifrado.\n\n    Argumentos:\n        key (str): La clave de cifrado utilizada para cifrar el texto original.\n                   Esta clave debe consistir únicamente en caracteres alfabéticos.\n        ciphertext (str): El texto cifrado que necesita ser descifrado.\n                          El texto cifrado debe consistir únicamente en caracteres alfabéticos.\n\n    Devuelve:\n        str: El texto descifrado correspondiente al texto cifrado de entrada.\n\n    Ejemplos:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Implementación de la función según lo proporcionado", "arb": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    يفك تشفير النص المشفر باستخدام شفرة فيجنير باستخدام المفتاح المقدم.\n    \n    شفرة فيجنير هي طريقة لتشفير النصوص الأبجدية باستخدام سلسلة من شفرات قيصر\n    بناءً على حروف كلمة مفتاحية. تقوم هذه الدالة بعكس العملية لاستعادة النص الأصلي\n    من النص المشفر.\n\n    يعيدالحجج:\n        key (str): مفتاح التشفير المستخدم لتشفير النص الأصلي.\n                   يجب أن يتكون هذا المفتاح من حروف أبجدية فقط.\n        ciphertext (str): النص المشفر الذي يحتاج إلى فك تشفير.\n                          يجب أن يتكون النص المشفر من حروف أبجدية فقط.\n\n    يعيد:\n        str: النص الأصلي المفكوك تشفيره والمطابق للنص المشفر المدخل.\n\n    امثله:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # تنفيذ الدالة كما هو مقدم", "sw": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Kufungua maandishi ya siri yaliyosimbwa na Vigenère cipher kwa kutumia ufunguo uliotolewa.\n    \n    Vigenère cipher ni mbinu ya kusimba maandishi ya alfabeti kwa kutumia mfululizo wa\n    Caesar ciphers kulingana na herufi za neno kuu. Kazi hii inarudisha mchakato\n    ili kurejesha maandishi asilia kutoka kwa maandishi ya siri.\n\n    Hoja:\n        key (str): Ufunguo wa usimbaji uliotumika kusimba maandishi asilia.\n                   Ufunguo huu unapaswa kuwa na herufi za alfabeti pekee.\n        ciphertext (str): Maandishi ya siri yanayohitaji kufunguliwa.\n                          Maandishi ya siri yanapaswa kuwa na herufi za alfabeti pekee.\n\n    Inarejesha:\n        str: Maandishi asilia yaliyofunguliwa yanayolingana na maandishi ya siri yaliyoingizwa.\n\n    Mifano:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Utekelezaji wa kazi kama ilivyotolewa", "tr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Sağlanan anahtarı kullanarak Vigenère şifreleme yöntemiyle şifrelenmiş bir şifreli metni çözer.\n    \n    Vigenère şifresi, alfabetik metni bir anahtar kelimenin harflerine dayanan bir dizi\n    Sezar şifresi kullanarak şifreleme yöntemidir. Bu fonksiyon, şifreli metinden orijinal\n    düz metni geri kazanmak için süreci tersine çevirir.\n\n    Argümanlar:\n        key (str): Orijinal düz metni şifrelemek için kullanılan şifreleme anahtarı.\n                   Bu anahtar yalnızca alfabetik karakterlerden oluşmalıdır.\n        ciphertext (str): Çözülmesi gereken şifreli metin.\n                          Şifreli metin yalnızca alfabetik karakterlerden oluşmalıdır.\n\n    Döndürür:\n        str: Girdi olarak verilen şifreli metne karşılık gelen çözülen düz metin.\n\n    Örnekler:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Sağlanan fonksiyonun uygulanması", "vi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Giải mã một văn bản mã hóa bằng mật mã Vigenère sử dụng khóa được cung cấp.\n    \n    Mật mã Vigenère là một phương pháp mã hóa văn bản chữ cái bằng cách sử dụng một loạt\n    các mật mã Caesar dựa trên các chữ cái của một từ khóa. Hàm này đảo ngược quá trình\n    để khôi phục văn bản gốc từ văn bản mã hóa.\n\n    Tham số:\n        key (str): Khóa mã hóa được sử dụng để mã hóa văn bản gốc.\n                   Khóa này chỉ nên bao gồm các ký tự chữ cái.\n        ciphertext (str): Văn bản đã được mã hóa cần được giải mã.\n                          Văn bản mã hóa chỉ nên bao gồm các ký tự chữ cái.\n\n    Trả về:\n        str: Văn bản gốc đã được giải mã tương ứng với văn bản mã hóa đầu vào.\n\n    Ví dụ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Triển khai hàm như đã cung cấp", "id": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Mendekripsi sebuah ciphertext yang dienkripsi dengan sandi Vigenère menggunakan kunci yang disediakan.\n    \n    Sandi Vigenère adalah metode enkripsi teks alfabet dengan menggunakan serangkaian\n    sandi Caesar berdasarkan huruf dari sebuah kata kunci. Fungsi ini membalikkan proses\n    untuk memulihkan teks asli dari ciphertext.\n\n    Args:\n        key (str): Kunci enkripsi yang digunakan untuk mengenkripsi teks asli.\n                   Kunci ini harus hanya terdiri dari karakter alfabet.\n        ciphertext (str): Teks terenkripsi yang perlu didekripsi.\n                          Ciphertext harus hanya terdiri dari karakter alfabet.\n\n    Returns:\n        str: Teks asli yang didekripsi yang sesuai dengan input ciphertext.\n\n    Contoh:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Implementasi fungsi seperti yang disediakan", "ja": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    提供されたキーを使用して、ヴィジュネル暗号で暗号化された暗号文を復号します。\n    \n    ヴィジュネル暗号は、キーワードの文字に基づいた一連のシーザー暗号を使用して\n    アルファベットのテキストを暗号化する方法です。この関数は、暗号文から元の平文を\n    復元するプロセスを逆にします。\n\n    Args:\n        key (str): 元の平文を暗号化するために使用された暗号キー。\n                   このキーはアルファベット文字のみで構成されている必要があります。\n        ciphertext (str): 復号する必要がある暗号化されたテキスト。\n                          暗号文はアルファベット文字のみで構成されている必要があります。\n\n    Returns:\n        str: 入力された暗号文に対応する復号された平文。\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided", "ko": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    제공된 키를 사용하여 비제네르 암호로 암호화된 암호문을 복호화합니다.\n    \n    비제네르 암호는 키워드의 문자에 기반한 일련의 시저 암호를 사용하여 알파벳 텍스트를 암호화하는 방법입니다. \n    이 함수는 암호문에서 원래의 평문을 복구하기 위해 이 과정을 역으로 수행합니다.\n\n    Args:\n        key (str): 원래 평문을 암호화하는 데 사용된 암호화 키.\n                   이 키는 알파벳 문자로만 구성되어야 합니다.\n        ciphertext (str): 복호화해야 하는 암호화된 텍스트.\n                          암호문은 알파벳 문자로만 구성되어야 합니다.\n\n    Returns:\n        str: 입력된 암호문에 해당하는 복호화된 평문.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # 제공된 함수 구현", "ml": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    നൽകിയ കീ ഉപയോഗിച്ച് Vigenère സൈഫർ ഉപയോഗിച്ച് എൻക്രിപ്റ്റ് ചെയ്ത സൈഫർടെക്സ്റ്റ് ഡീക്രിപ്റ്റ് ചെയ്യുന്നു.\n    \n    Vigenère സൈഫർ ഒരു കീവേഡിലെ അക്ഷരങ്ങളെ അടിസ്ഥാനമാക്കി സീസർ സൈഫറുകളുടെ ഒരു പരമ്പര ഉപയോഗിച്ച് അക്ഷരമാലാ\n    വാചകം എൻക്രിപ്റ്റ് ചെയ്യാനുള്ള ഒരു രീതിയാണ്. സൈഫർടെക്സ്റ്റിൽ നിന്ന് യഥാർത്ഥ പ്ലെയിൻടെക്സ്റ്റ് വീണ്ടെടുക്കാൻ\n    ഈ ഫംഗ്ഷൻ പ്രക്രിയ മറിച്ചുവയ്ക്കുന്നു.\n\n    Args:\n        key (str): യഥാർത്ഥ പ്ലെയിൻടെക്സ്റ്റ് എൻക്രിപ്റ്റ് ചെയ്യാൻ ഉപയോഗിച്ച എൻക്രിപ്ഷൻ കീ.\n                   ഈ കീ അക്ഷരമാലാ പ്രതീകങ്ങൾ മാത്രം ഉൾക്കൊള്ളണം.\n        ciphertext (str): ഡീക്രിപ്റ്റ് ചെയ്യേണ്ട എൻക്രിപ്റ്റ് ചെയ്ത വാചകം.\n                          സൈഫർടെക്സ്റ്റ് അക്ഷരമാലാ പ്രതീകങ്ങൾ മാത്രം ഉൾക്കൊള്ളണം.\n\n    Returns:\n        str: ഇൻപുട്ട് സൈഫർടെക്സ്റ്റിന് അനുയോജ്യമായ ഡീക്രിപ്റ്റ് ചെയ്ത പ്ലെയിൻടെക്സ്റ്റ്.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided", "fa": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    رمزگشایی یک متن رمزگذاری شده با رمز ویژنر با استفاده از کلید ارائه شده.\n\n    رمز ویژنر روشی برای رمزگذاری متن الفبایی است که با استفاده از مجموعه‌ای از\n    رمزهای سزار بر اساس حروف یک کلمه کلیدی انجام می‌شود. این تابع فرآیند را معکوس می‌کند\n    تا متن اصلی را از متن رمزگذاری شده بازیابی کند.\n\n    Args:\n        key (str): کلید رمزگذاری که برای رمزگذاری متن اصلی استفاده شده است.\n                   این کلید باید فقط شامل حروف الفبایی باشد.\n        ciphertext (str): متن رمزگذاری شده که نیاز به رمزگشایی دارد.\n                          متن رمزگذاری شده باید فقط شامل حروف الفبایی باشد.\n\n    Returns:\n        str: متن اصلی رمزگشایی شده که متناظر با متن رمزگذاری شده ورودی است.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # پیاده‌سازی تابع همانطور که ارائه شده است"}, "canonical_solution": "    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)", "instruction": {"en": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nՏրամադրել հակիրճ բնութագրում (docstring) այս Python կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي المكتوب بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.", "vi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nPythonコードのdocstringを日本語で記述し、500文字以内で簡潔に説明してください。", "ko": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nPython 코드에 대한 간결한 자연어 설명(독스트링)을 한국어로 500자 이내로 제공하세요.", "ml": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nപൈതൺ കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കുറയാതെ നൽകുക.", "fa": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nتوضیحی مختصر و طبیعی (docstring) از کد پایتون به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_vigenere_decrypt():\n    # Test case 1: Example provided in the problem statement\n    key1 = \"CompleteVictory\"\n    ciphertext1 = \"Yvqgpxaimmklongnzfwpvxmniytm\"\n    expected_plaintext1 = \"Wherethereisawillthereisaway\"\n    assert vigenere_decrypt(key1, ciphertext1) == expected_plaintext1, \"Test case 1 failed\"\n\n    # Test case 2: All uppercase characters\n    key2 = \"ABC\"\n    ciphertext2 = \"DEF\"\n    expected_plaintext2 = \"DDD\"\n    assert vigenere_decrypt(key2, ciphertext2) == expected_plaintext2, \"Test case 2 failed\"\n\n    # Test case 3: All lowercase characters\n    key3 = \"xyz\"\n    ciphertext3 = \"abc\"\n    expected_plaintext3 = \"ddd\"\n    assert vigenere_decrypt(key3, ciphertext3) == expected_plaintext3, \"Test case 3 failed\"\n\n    # Test case 4: Mixed case characters\n    key4 = \"MiXeD\"\n    ciphertext4 = \"JpOeR\"\n    expected_plaintext4 = \"XhRaO\"\n    assert vigenere_decrypt(key4, ciphertext4) == expected_plaintext4, \"Test case 4 failed\"\n\n    # Test case 5: Key shorter than ciphertext\n    key5 = \"short\"\n    ciphertext5 = \"PqrsPqrsPq\"\n    expected_plaintext5 = \"XjdbWykeYx\"\n    assert vigenere_decrypt(key5, ciphertext5) == expected_plaintext5, \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_vigenere_decrypt()", "entry_point": "vigenere_decrypt", "signature": "def vigenere_decrypt(key: str, ciphertext: str) -> str:", "docstring": {"en": "Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n\nThe Vigenère cipher is a method of encrypting alphabetic text by using a series of\nCaesar ciphers based on the letters of a keyword. This function reverses the process\nto recover the original plaintext from the ciphertext.\n\nArgs:\nkey (str): The encryption key used to encrypt the original plaintext.\nThis key should consist only of alphabetic characters.\nciphertext (str): The encrypted text that needs to be decrypted.\nThe ciphertext should consist only of alphabetic characters.\n\nReturns:\nstr: The decrypted plaintext corresponding to the input ciphertext.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "sq": "Dekripton një tekst të koduar me shifrën Vigenère duke përdorur çelësin e dhënë.\n\nShifra Vigenère është një metodë për të koduar tekstin alfabetik duke përdorur një seri\nshifrash Caesar bazuar në shkronjat e një fjale kyçe. Kjo funksion rikthen procesin\npër të rikuperuar tekstin origjinal nga teksti i koduar.\n\nArgumentet:\nkey (str): Çelësi i enkriptimit i përdorur për të koduar tekstin origjinal.\nKy çelës duhet të përmbajë vetëm karaktere alfabetike.\nciphertext (str): Teksti i koduar që duhet të dekriptohet.\nTeksti i koduar duhet të përmbajë vetëm karaktere alfabetike.\n\nKthen:\nstr: Teksti i dekriptuar që korrespondon me tekstin e koduar të dhënë si hyrje.\n\nShembuj:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "hy": "Վիգեներ ծածկագրով կոդավորված տեքստը ապակոդավորում է տրված բանալիով:\n\nՎիգեներ ծածկագիրը այբբենական տեքստը ծածկագրելու մեթոդ է, որը օգտագործում է Կեսարի մի շարք\nծածկագրեր՝ հիմնված բանալի բառի տառերի վրա: Այս ֆունկցիան հակառակ գործընթացն է կատարում՝\nվերականգնելու սկզբնական բաց տեքստը ծածկագրից:\n\nԱրգումենտներ:\nkey (str): Ծածկագրման բանալին, որը օգտագործվել է սկզբնական բաց տեքստը ծածկագրելու համար:\nԱյս բանալին պետք է բաղկացած լինի միայն այբբենական նիշերից:\nciphertext (str): Ծածկագրված տեքստը, որը պետք է ապակոդավորվի:\nԾածկագիրը պետք է բաղկացած լինի միայն այբբենական նիշերից:\n\nՎերադարձնում է:\nstr: Ապակոդավորված բաց տեքստը, որը համապատասխանում է մուտքային ծածկագրին:\n\nՕրինակներ:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "bn": "একটি সাইফারটেক্সটকে ডিক্রিপ্ট করে যা Vigenère সাইফার দ্বারা প্রদত্ত কী ব্যবহার করে এনক্রিপ্ট করা হয়েছিল।\n\nVigenère সাইফার হল একটি পদ্ধতি যা অক্ষরগত টেক্সট এনক্রিপ্ট করার জন্য একটি কীওয়ার্ডের অক্ষরের উপর ভিত্তি করে একাধিক Caesar সাইফার ব্যবহার করে। এই ফাংশনটি প্রক্রিয়াটি উল্টে দেয় যাতে সাইফারটেক্সট থেকে মূল প্লেইনটেক্সট পুনরুদ্ধার করা যায়।\n\nআর্গস:\nkey (str): এনক্রিপশন কী যা মূল প্লেইনটেক্সট এনক্রিপ্ট করতে ব্যবহৃত হয়েছিল।\nএই কী শুধুমাত্র অক্ষরগত অক্ষর নিয়ে গঠিত হওয়া উচিত।\nciphertext (str): এনক্রিপ্ট করা টেক্সট যা ডিক্রিপ্ট করা প্রয়োজন।\nসাইফারটেক্সট শুধুমাত্র অক্ষরগত অক্ষর নিয়ে গঠিত হওয়া উচিত।\n\nরিটার্নস:\nstr: ইনপুট সাইফারটেক্সটের সাথে সম্পর্কিত ডিক্রিপ্ট করা প্লেইনটেক্সট।\n\nউদাহরণ:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "bg": "Декриптира шифротекст, шифрован с шифъра на Виженер, използвайки предоставения ключ.\n\nШифърът на Виженер е метод за шифроване на азбучен текст чрез използване на серия от\nЦезарови шифри, базирани на буквите от ключова дума. Тази функция обръща процеса,\nза да възстанови оригиналния обикновен текст от шифротекста.\n\nАргументи:\nkey (str): Ключът за шифроване, използван за шифроване на оригиналния обикновен текст.\nТози ключ трябва да се състои само от азбучни символи.\nciphertext (str): Шифротекстът, който трябва да бъде декриптиран.\nШифротекстът трябва да се състои само от азбучни символи.\n\nВръща:\nstr: Декриптираният обикновен текст, съответстващ на входния шифротекст.\n\nПримери:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "zh": "解密使用提供的密钥通过维吉尼亚密码加密的密文。\n\n维吉尼亚密码是一种通过使用基于关键词字母的凯撒密码系列来加密字母文本的方法。此函数反转该过程以从密文中恢复原始明文。\n\n参数：\nkey (str): 用于加密原始明文的加密密钥。\n该密钥应仅由字母字符组成。\nciphertext (str): 需要解密的加密文本。\n密文应仅由字母字符组成。\n\n返回：\nstr: 与输入密文对应的解密明文。\n\n示例：\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "fr": "Déchiffre un texte chiffré avec le chiffre de Vigenère en utilisant la clé fournie.\n\nLe chiffre de Vigenère est une méthode de chiffrement de texte alphabétique en utilisant une série de\nchiffres de César basés sur les lettres d'un mot-clé. Cette fonction inverse le processus\npour récupérer le texte en clair original à partir du texte chiffré.\n\nArgs:\nkey (str): La clé de chiffrement utilisée pour chiffrer le texte en clair original.\nCette clé doit être composée uniquement de caractères alphabétiques.\nciphertext (str): Le texte chiffré qui doit être déchiffré.\nLe texte chiffré doit être composé uniquement de caractères alphabétiques.\n\nReturns:\nstr: Le texte en clair déchiffré correspondant au texte chiffré d'entrée.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "de": "Entschlüsselt einen mit dem Vigenère-Chiffre verschlüsselten Geheimtext mit dem bereitgestellten Schlüssel.\n\nDas Vigenère-Chiffre ist eine Methode zur Verschlüsselung von alphabetischem Text durch die Verwendung einer Reihe von Caesar-Chiffren, die auf den Buchstaben eines Schlüsselworts basieren. Diese Funktion kehrt den Prozess um, um den ursprünglichen Klartext aus dem Geheimtext wiederherzustellen.\n\nArgs:\nkey (str): Der Verschlüsselungsschlüssel, der verwendet wurde, um den ursprünglichen Klartext zu verschlüsseln.\nDieser Schlüssel sollte nur aus alphabetischen Zeichen bestehen.\nciphertext (str): Der verschlüsselte Text, der entschlüsselt werden muss.\nDer Geheimtext sollte nur aus alphabetischen Zeichen bestehen.\n\nReturns:\nstr: Der entschlüsselte Klartext, der dem Eingabe-Geheimtext entspricht.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "ha": "Yana fassara rubutun da aka ɓoye tare da Vigenère cipher ta amfani da mabuɗin da aka bayar.\n\nVigenère cipher wata hanya ce ta ɓoye rubutun haruffa ta hanyar amfani da jerin\nCaesar ciphers bisa ga haruffan kalmar sirri. Wannan aikin yana juyar da tsarin\ndon dawo da ainihin rubutun asali daga rubutun da aka ɓoye.\n\nArgs:\nkey (str): Maɓallin ɓoyewa da aka yi amfani da shi don ɓoye rubutun asali.\nWannan maɓalli ya kamata ya ƙunshi haruffa kawai.\nciphertext (str): Rubutun da aka ɓoye wanda ake buƙatar a warware.\nRubutun da aka ɓoye ya kamata ya ƙunshi haruffa kawai.\n\nReturns:\nstr: Rubutun da aka warware wanda ya dace da rubutun da aka shigar.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "hi": "Vigenère सिफर का उपयोग करके एन्क्रिप्ट किए गए सिफरटेक्स्ट को दिए गए कुंजी का उपयोग करके डिक्रिप्ट करता है।\n\nVigenère सिफर वर्णमाला पाठ को एन्क्रिप्ट करने की एक विधि है जो एक कुंजी शब्द के अक्षरों पर आधारित कैसर सिफर की एक श्रृंखला का उपयोग करती है। यह फ़ंक्शन प्रक्रिया को उलट देता है ताकि सिफरटेक्स्ट से मूल प्लेनटेक्स्ट पुनः प्राप्त किया जा सके।\n\nआर्ग्स:\nkey (str): एन्क्रिप्शन कुंजी जिसका उपयोग मूल प्लेनटेक्स्ट को एन्क्रिप्ट करने के लिए किया गया था।\nयह कुंजी केवल वर्णमाला के अक्षरों से बनी होनी चाहिए।\nciphertext (str): एन्क्रिप्टेड पाठ जिसे डिक्रिप्ट करने की आवश्यकता है।\nसिफरटेक्स्ट केवल वर्णमाला के अक्षरों से बना होना चाहिए।\n\nरिटर्न्स:\nstr: इनपुट सिफरटेक्स्ट के अनुरूप डिक्रिप्टेड प्लेनटेक्स्ट।\n\nउदाहरण:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "hu": "Visszafejt egy Vigenère-rejtjel által titkosított titkos szöveget a megadott kulcs használatával.\n\nA Vigenère-rejtjel egy olyan módszer, amely az ábécé szöveg titkosítására szolgál egy kulcsszó betűin alapuló Caesar-rejtjelek sorozatával. Ez a függvény visszafordítja a folyamatot, hogy visszanyerje az eredeti nyílt szöveget a titkos szövegből.\n\nArgs:\nkey (str): A titkosítási kulcs, amelyet az eredeti nyílt szöveg titkosítására használtak.\nEz a kulcs csak ábécé karakterekből állhat.\nciphertext (str): A titkosított szöveg, amelyet vissza kell fejteni.\nA titkos szöveg csak ábécé karakterekből állhat.\n\nReturns:\nstr: A visszafejtett nyílt szöveg, amely megfelel a bemeneti titkos szövegnek.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "es": "Desencripta un texto cifrado con el cifrado de Vigenère usando la clave proporcionada.\n\nEl cifrado de Vigenère es un método de cifrado de texto alfabético utilizando una serie de cifrados César basados en las letras de una palabra clave. Esta función invierte el proceso para recuperar el texto plano original del texto cifrado.\n\nArgumentos:\nkey (str): La clave de cifrado utilizada para cifrar el texto plano original.\nEsta clave debe consistir solo en caracteres alfabéticos.\nciphertext (str): El texto cifrado que necesita ser desencriptado.\nEl texto cifrado debe consistir solo en caracteres alfabéticos.\n\nDevuelve:\nstr: El texto plano desencriptado correspondiente al texto cifrado de entrada.\n\nEjemplos:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "arb": "يفك تشفير النص المشفر باستخدام شفرة فيجينير باستخدام المفتاح المقدم.\n\nشفرة فيجينير هي طريقة لتشفير النصوص الأبجدية باستخدام سلسلة من شفرات قيصر بناءً على حروف كلمة مفتاحية. تقوم هذه الدالة بعكس العملية لاستعادة النص الأصلي من النص المشفر.\n\nالمعاملات:\nkey (str): مفتاح التشفير المستخدم لتشفير النص الأصلي.\nيجب أن يتكون هذا المفتاح من حروف أبجدية فقط.\nciphertext (str): النص المشفر الذي يحتاج إلى فك التشفير.\nيجب أن يتكون النص المشفر من حروف أبجدية فقط.\n\nالقيم المعادة:\nstr: النص المفكوك الذي يتوافق مع النص المشفر المدخل.\n\nأمثلة:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "sw": "Kufungua maandishi ya siri yaliyosimbwa na Vigenère cipher kwa kutumia ufunguo uliotolewa.\n\nVigenère cipher ni mbinu ya kusimba maandishi ya alfabeti kwa kutumia mfululizo wa\nCaesar ciphers kulingana na herufi za neno kuu. Kazi hii inarudisha mchakato\nili kurejesha maandishi asilia kutoka kwenye ciphertext.\n\nHoja:\nkey (str): Ufunguo wa usimbaji uliotumika kusimba maandishi asilia.\nUfunguo huu unapaswa kuwa na herufi za alfabeti pekee.\nciphertext (str): Maandishi yaliyosimbwa ambayo yanahitaji kufumbuliwa.\nCiphertext inapaswa kuwa na herufi za alfabeti pekee.\n\nInarejesha:\nstr: Maandishi asilia yaliyofumbuliwa yanayolingana na ciphertext iliyoingizwa.\n\nMifano:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "tr": "Bir şifreleme anahtarı kullanılarak Vigenère şifresiyle şifrelenmiş bir şifreli metni çözer.\n\nVigenère şifresi, alfabetik metni bir anahtar kelimenin harflerine dayanan bir dizi Sezar şifresi kullanarak şifreleme yöntemidir. Bu fonksiyon, şifreli metinden orijinal düz metni geri kazanmak için süreci tersine çevirir.\n\nArgümanlar:\nkey (str): Orijinal düz metni şifrelemek için kullanılan şifreleme anahtarı.\nBu anahtar yalnızca alfabetik karakterlerden oluşmalıdır.\nciphertext (str): Çözülmesi gereken şifreli metin.\nŞifreli metin yalnızca alfabetik karakterlerden oluşmalıdır.\n\nDöndürür:\nstr: Girdi şifreli metnine karşılık gelen çözülmüş düz metin.\n\nÖrnekler:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "vi": "Giải mã một bản mã đã được mã hóa bằng mật mã Vigenère sử dụng khóa được cung cấp.\n\nMật mã Vigenère là một phương pháp mã hóa văn bản chữ cái bằng cách sử dụng một loạt các\nmật mã Caesar dựa trên các chữ cái của một từ khóa. Hàm này đảo ngược quá trình\nđể khôi phục văn bản gốc từ bản mã.\n\nTham số:\nkey (str): Khóa mã hóa được sử dụng để mã hóa văn bản gốc.\nKhóa này chỉ nên bao gồm các ký tự chữ cái.\nciphertext (str): Văn bản đã được mã hóa cần được giải mã.\nBản mã chỉ nên bao gồm các ký tự chữ cái.\n\nTrả về:\nstr: Văn bản gốc đã được giải mã tương ứng với bản mã đầu vào.\n\nVí dụ:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "id": "Mendekripsi teks sandi yang dienkripsi dengan sandi Vigenère menggunakan kunci yang disediakan.\n\nSandi Vigenère adalah metode enkripsi teks alfabet dengan menggunakan serangkaian sandi Caesar berdasarkan huruf-huruf dari sebuah kata kunci. Fungsi ini membalikkan proses tersebut untuk memulihkan teks asli dari teks sandi.\n\nArgs:\nkey (str): Kunci enkripsi yang digunakan untuk mengenkripsi teks asli.\nKunci ini harus hanya terdiri dari karakter alfabet.\nciphertext (str): Teks terenkripsi yang perlu didekripsi.\nTeks sandi harus hanya terdiri dari karakter alfabet.\n\nReturns:\nstr: Teks asli yang didekripsi yang sesuai dengan teks sandi masukan.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "ja": "暗号文を提供されたキーを使用して、ヴィジュネル暗号で暗号化されたものを復号します。\n\nヴィジュネル暗号は、キーワードの文字に基づいた一連のシーザー暗号を使用してアルファベットのテキストを暗号化する方法です。この関数は、そのプロセスを逆にして、暗号文から元の平文を復元します。\n\n引数:\nkey (str): 元の平文を暗号化するために使用された暗号キー。\nこのキーはアルファベット文字のみで構成されている必要があります。\nciphertext (str): 復号する必要がある暗号化されたテキスト。\n暗号文はアルファベット文字のみで構成されている必要があります。\n\n戻り値:\nstr: 入力された暗号文に対応する復号された平文。\n\n例:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "ko": "암호화된 Vigenère 암호문을 제공된 키를 사용하여 복호화합니다.\n\nVigenère 암호는 키워드의 문자에 기반한 일련의 Caesar 암호를 사용하여 알파벳 텍스트를 암호화하는 방법입니다. 이 함수는 암호문에서 원래 평문을 복구하기 위해 이 과정을 역으로 수행합니다.\n\n인수:\nkey (str): 원래 평문을 암호화하는 데 사용된 암호화 키입니다.\n이 키는 알파벳 문자로만 구성되어야 합니다.\nciphertext (str): 복호화가 필요한 암호화된 텍스트입니다.\n암호문은 알파벳 문자로만 구성되어야 합니다.\n\n반환:\nstr: 입력된 암호문에 해당하는 복호화된 평문입니다.\n\n예제:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "ml": "Vigenère സൈഫർ ഉപയോഗിച്ച് എൻക്രിപ്റ്റ് ചെയ്ത സൈഫർടെക്സ്റ്റ് നൽകിയ കീ ഉപയോഗിച്ച് ഡീക്രിപ്റ്റ് ചെയ്യുന്നു.\n\nVigenère സൈഫർ ഒരു കീവേഡിലെ അക്ഷരങ്ങളെ അടിസ്ഥാനമാക്കി സീസർ സൈഫറുകളുടെ ഒരു പരമ്പര ഉപയോഗിച്ച് അക്ഷരമാലാ ടെക്സ്റ്റ് എൻക്രിപ്റ്റ് ചെയ്യാനുള്ള ഒരു രീതിയാണ്. സൈഫർടെക്സ്റ്റിൽ നിന്ന് യഥാർത്ഥ പ്ലെയിൻടെക്സ്റ്റ് വീണ്ടെടുക്കാൻ ഈ ഫംഗ്ഷൻ പ്രക്രിയ മറിച്ചുനടത്തുന്നു.\n\nArgs:\nkey (str): യഥാർത്ഥ പ്ലെയിൻടെക്സ്റ്റ് എൻക്രിപ്റ്റ് ചെയ്യാൻ ഉപയോഗിച്ച എൻക്രിപ്ഷൻ കീ.\nഈ കീ അക്ഷരമാലാ അക്ഷരങ്ങൾ മാത്രം ഉൾക്കൊള്ളണം.\nciphertext (str): ഡീക്രിപ്റ്റ് ചെയ്യേണ്ട എൻക്രിപ്റ്റ് ചെയ്ത ടെക്സ്റ്റ്.\nസൈഫർടെക്സ്റ്റ് അക്ഷരമാലാ അക്ഷരങ്ങൾ മാത്രം ഉൾക്കൊള്ളണം.\n\nReturns:\nstr: ഇൻപുട്ട് സൈഫർടെക്സ്റ്റിനോട് അനുബന്ധിച്ച ഡീക്രിപ്റ്റ് ചെയ്ത പ്ലെയിൻടെക്സ്റ്റ്.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "fa": "رمزگشایی یک متن رمزگذاری شده با رمز ویژنر با استفاده از کلید ارائه شده.\n\nرمزنگاری ویژنر روشی برای رمزگذاری متن الفبایی است که با استفاده از مجموعه‌ای از\nرمزهای سزار بر اساس حروف یک کلمه کلیدی انجام می‌شود. این تابع فرآیند را معکوس می‌کند\nتا متن اصلی را از متن رمز شده بازیابی کند.\n\nArgs:\nkey (str): کلید رمزگذاری که برای رمزگذاری متن اصلی استفاده شده است.\nاین کلید باید فقط شامل حروف الفبایی باشد.\nciphertext (str): متنی که رمزگذاری شده و نیاز به رمزگشایی دارد.\nمتن رمز شده باید فقط شامل حروف الفبایی باشد.\n\nReturns:\nstr: متن اصلی رمزگشایی شده که متناظر با متن رمز شده ورودی است.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'"}}
{"task_id": "Python/41", "prompt": {"en": "def mod_inverse(a, b):\n    \"\"\"\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n      # Explanation: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Explanation: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Explanation: gcd(42, 2017) != 1, so no inverse exists\n    \"\"\"", "sq": "def mod_inverse(a, b):\n    \"\"\"\n    Llogarit inversin modular multiplikativ të `a` modulo `b`.\n    \n    Kjo funksion gjen një numër të plotë `x` të tillë që (a * x) % b == 1, me kusht që\n    `a` dhe `b` janë të bashkëkryqëzuar (d.m.th., gcd(a, b) == 1). Përdor Algoritmin e Zgjeruar të Euklidit\n    për të llogaritur inversin. Nëse `a` dhe `b` nuk janë të bashkëkryqëzuar, inversi modular\n    nuk ekziston, dhe funksioni kthen `None`.\n    \n    Args:\n      a (int): Numri i plotë për të cilin do të gjendet inversi modular.\n      b (int): Moduli me të cilin kërkohet inversi.\n    \n    Returns:\n      int: Inversi modular i `a` modulo `b` nëse ekziston, përndryshe `None`.\n    \n    Shembuj:\n      >>> mod_inverse(3, 10)\n      7\n      # Shpjegim: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Shpjegim: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Shpjegim: gcd(42, 2017) != 1, kështu që nuk ekziston invers\n    \"\"\"", "hy": "def mod_inverse(a, b):\n    \"\"\"\n    Հաշվել `a`-ի մոդուլային բազմապատիկ հակադարձը `b`-ի նկատմամբ։\n    \n    Այս ֆունկցիան գտնում է ամբողջ թիվ `x`, այնպես որ (a * x) % b == 1, ենթադրելով, որ\n    `a` և `b` փոխադարձ պարզ են (այսինքն՝ gcd(a, b) == 1): Այն օգտագործում է ընդլայնված Էվկլիդյան\n    ալգորիթմը հակադարձը հաշվարկելու համար։ Եթե `a` և `b` փոխադարձ պարզ չեն, ապա մոդուլային\n    հակադարձը գոյություն չունի, և ֆունկցիան վերադարձնում է `None`։\n    \n    Արգումենտներ:\n      a (int): Ամբողջ թիվ, որի մոդուլային հակադարձը պետք է գտնվի։\n      b (int): Մոդուլը, որի նկատմամբ հակադարձը փնտրվում է։\n    \n    Վերադարձնում է:\n      int: `a`-ի մոդուլային հակադարձը `b`-ի նկատմամբ, եթե այն գոյություն ունի, հակառակ դեպքում `None`։\n    \n    Օրինակներ:\n      >>> mod_inverse(3, 10)\n      7\n      # Բացատրություն: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Բացատրություն: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Բացատրություն: gcd(42, 2017) != 1, ուստի հակադարձը գոյություն չունի\n    \"\"\"", "bn": "def mod_inverse(a, b):\n    \"\"\"\n    `a` এর মডুলার গুণনীয় বিপরীত `b` মডুলোর হিসাব করুন।\n    \n    এই ফাংশন একটি পূর্ণসংখ্যা `x` খুঁজে বের করে যাতে (a * x) % b == 1 হয়, যদি\n    `a` এবং `b` পরস্পর সহমৌলিক হয় (অর্থাৎ, gcd(a, b) == 1)। এটি Extended Euclidean\n    Algorithm ব্যবহার করে বিপরীত হিসাব করে। যদি `a` এবং `b` পরস্পর সহমৌলিক না হয়, তবে মডুলার\n    বিপরীত বিদ্যমান নেই এবং ফাংশন `None` ফেরত দেয়।\n    \n    Args:\n      a (int): পূর্ণসংখ্যা যার মডুলার বিপরীত খুঁজে বের করতে হবে।\n      b (int): মডুলাস যার সাথে বিপরীত খোঁজা হচ্ছে।\n    \n    Returns:\n      int: `a` এর মডুলার বিপরীত `b` মডুলোর যদি বিদ্যমান থাকে, অন্যথায় `None`।\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n      # ব্যাখ্যা: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # ব্যাখ্যা: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # ব্যাখ্যা: gcd(42, 2017) != 1, তাই কোন বিপরীত নেই\n    \"\"\"", "bg": "def mod_inverse(a, b):\n    \"\"\"\n    Изчислява модулната мултипликативна обратна стойност на `a` по модул `b`.\n    \n    Тази функция намира цяло число `x`, такова че (a * x) % b == 1, при условие че\n    `a` и `b` са взаимно прости (т.е., gcd(a, b) == 1). Използва разширения алгоритъм на Евклид\n    за изчисляване на обратната стойност. Ако `a` и `b` не са взаимно прости, модулната\n    обратна стойност не съществува и функцията връща `None`.\n    \n    Аргументи:\n      a (int): Цялото число, чиято модулна обратна стойност трябва да бъде намерена.\n      b (int): Модулът, спрямо който се търси обратната стойност.\n    \n    Връща:\n      int: Модулната обратна стойност на `a` по модул `b`, ако съществува, в противен случай `None`.\n    \n    Примери:\n      >>> mod_inverse(3, 10)\n      7\n      # Обяснение: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Обяснение: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Обяснение: gcd(42, 2017) != 1, така че обратната стойност не съществува\n    \"\"\"", "zh": "def mod_inverse(a, b):\n    \"\"\"\n    计算 `a` 模 `b` 的模逆。\n    \n    此函数寻找一个整数 `x`，使得 (a * x) % b == 1，前提是 `a` 和 `b` 互质（即 gcd(a, b) == 1）。\n    它使用扩展欧几里得算法来计算逆。如果 `a` 和 `b` 不互质，则模逆不存在，函数返回 `None`。\n    \n    参数:\n      a (int): 要找到模逆的整数。\n      b (int): 模数。\n    \n    返回:\n      int: 如果存在，返回 `a` 模 `b` 的模逆，否则返回 `None`。\n    \n    示例:\n      >>> mod_inverse(3, 10)\n      7\n      # 解释: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # 解释: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # 解释: gcd(42, 2017) != 1，因此不存在逆\n    \"\"\"", "fr": "def mod_inverse(a, b):\n    \"\"\"\n    Calculer l'inverse multiplicatif modulaire de `a` modulo `b`.\n    \n    Cette fonction trouve un entier `x` tel que (a * x) % b == 1, à condition que\n    `a` et `b` soient copremiers (c'est-à-dire, gcd(a, b) == 1). Elle utilise l'algorithme\n    d'Euclide étendu pour calculer l'inverse. Si `a` et `b` ne sont pas copremiers, l'inverse\n    modulaire n'existe pas, et la fonction renvoie `None`.\n    \n    Args:\n      a (int): L'entier dont l'inverse modulaire doit être trouvé.\n      b (int): Le module par rapport auquel l'inverse est recherché.\n    \n    Returns:\n      int: L'inverse modulaire de `a` modulo `b` s'il existe, sinon `None`.\n    \n    Exemples:\n      >>> mod_inverse(3, 10)\n      7\n      # Explication : (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Explication : (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Explication : gcd(42, 2017) != 1, donc aucun inverse n'existe\n    \"\"\"", "de": "def mod_inverse(a, b):\n    \"\"\"\n    Berechne den modularen multiplikativen Inversen von `a` modulo `b`.\n    \n    Diese Funktion findet eine ganze Zahl `x`, so dass (a * x) % b == 1, vorausgesetzt,\n    `a` und `b` sind teilerfremd (d.h., gcd(a, b) == 1). Sie verwendet den erweiterten\n    euklidischen Algorithmus, um den Inversen zu berechnen. Wenn `a` und `b` nicht\n    teilerfremd sind, existiert der modulare Inverse nicht, und die Funktion gibt `None` zurück.\n    \n    Args:\n      a (int): Die ganze Zahl, deren modularer Inverser gefunden werden soll.\n      b (int): Der Modulus, in Bezug auf den der Inverser gesucht wird.\n    \n    Returns:\n      int: Der modulare Inverse von `a` modulo `b`, falls er existiert, sonst `None`.\n    \n    Beispiele:\n      >>> mod_inverse(3, 10)\n      7\n      # Erklärung: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Erklärung: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Erklärung: gcd(42, 2017) != 1, daher existiert kein Inverser\n    \"\"\"", "ha": "def mod_inverse(a, b):\n    \"\"\"\n    Lissafi na modular multiplicative inverse na `a` modulo `b`.\n    \n    Wannan aikin yana nemo wani cikakken lamba `x` wanda (a * x) % b == 1, idan\n    `a` da `b` suna da bambanci guda (wato, gcd(a, b) == 1). Yana amfani da\n    Tsarin Euclidean da aka faɗaɗa don lissafin inverse. Idan `a` da `b` ba su da\n    bambanci guda, to modular inverse bai wanzu ba, kuma aikin yana mayar da `None`.\n    \n    Args:\n      a (int): Lambar cikakke wanda za a nemo modular inverse ɗinsa.\n      b (int): Modulus da za a nema inverse a kansa.\n    \n    Returns:\n      int: Modular inverse na `a` modulo `b` idan yana wanzu, in ba haka ba `None`.\n    \n    Misalai:\n      >>> mod_inverse(3, 10)\n      7\n      # Bayani: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Bayani: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Bayani: gcd(42, 2017) != 1, don haka babu inverse da ya wanzu\n    \"\"\"", "hi": "def mod_inverse(a, b):\n    \"\"\"\n    `a` का `b` के मापांक के सापेक्ष गुणात्मक व्युत्क्रम की गणना करें।\n    \n    यह फ़ंक्शन एक पूर्णांक `x` ढूंढता है ताकि (a * x) % b == 1, बशर्ते कि\n    `a` और `b` सह-प्राइम हों (अर्थात, gcd(a, b) == 1)। यह व्युत्क्रम की गणना करने के लिए विस्तारित यूक्लिडियन\n    एल्गोरिथ्म का उपयोग करता है। यदि `a` और `b` सह-प्राइम नहीं हैं, तो गुणात्मक\n    व्युत्क्रम मौजूद नहीं है, और फ़ंक्शन `None` लौटाता है।\n    \n    Args:\n      a (int): वह पूर्णांक जिसका गुणात्मक व्युत्क्रम ढूंढा जाना है।\n      b (int): वह मापांक जिसके सापेक्ष व्युत्क्रम खोजा जा रहा है।\n    \n    Returns:\n      int: यदि यह मौजूद है तो `a` का `b` के मापांक के सापेक्ष गुणात्मक व्युत्क्रम, अन्यथा `None`।\n    \n    उदाहरण:\n      >>> mod_inverse(3, 10)\n      7\n      # व्याख्या: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # व्याख्या: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # व्याख्या: gcd(42, 2017) != 1, इसलिए कोई व्युत्क्रम मौजूद नहीं है\n    \"\"\"", "hu": "def mod_inverse(a, b):\n    \"\"\"\n    Számítsa ki `a` moduláris multiplikatív inverzét `b` modulussal.\n\n    Ez a függvény egy olyan egész számot talál `x`, amelyre (a * x) % b == 1, feltéve, hogy\n    `a` és `b` relatív prímek (azaz gcd(a, b) == 1). Az inverz kiszámításához az\n    Kiterjesztett Euklideszi Algoritmust használja. Ha `a` és `b` nem relatív prímek, akkor a moduláris\n    inverz nem létezik, és a függvény `None` értéket ad vissza.\n\n    Args:\n      a (int): Az egész szám, amelynek moduláris inverzét meg kell találni.\n      b (int): A modulus, amelyhez képest az inverz keresett.\n\n    Returns:\n      int: `a` moduláris inverze `b` modulussal, ha létezik, különben `None`.\n\n    Példák:\n      >>> mod_inverse(3, 10)\n      7\n      # Magyarázat: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Magyarázat: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Magyarázat: gcd(42, 2017) != 1, így nem létezik inverz\n    \"\"\"", "es": "def mod_inverse(a, b):\n    \"\"\"\n    Calcular el inverso multiplicativo modular de `a` módulo `b`.\n    \n    Esta función encuentra un entero `x` tal que (a * x) % b == 1, siempre que\n    `a` y `b` sean coprimos (es decir, gcd(a, b) == 1). Utiliza el Algoritmo\n    Euclidiano Extendido para calcular el inverso. Si `a` y `b` no son coprimos,\n    el inverso modular no existe, y la función devuelve `None`.\n    \n    Argumentos:\n      a (int): El entero cuyo inverso modular se va a encontrar.\n      b (int): El módulo con respecto al cual se busca el inverso.\n    \n    Devuelve:\n      int: El inverso modular de `a` módulo `b` si existe, de lo contrario `None`.\n    \n    Ejemplos:\n      >>> mod_inverse(3, 10)\n      7\n      # Explicación: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Explicación: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Explicación: gcd(42, 2017) != 1, por lo que no existe inverso\n    \"\"\"", "arb": "def mod_inverse(a, b):\n    \"\"\"\n    حساب المعكوس الضربي المعياري لـ `a` بالنسبة إلى `b`.\n    \n    تقوم هذه الدالة بإيجاد عدد صحيح `x` بحيث يكون (a * x) % b == 1، بشرط أن\n    يكون `a` و `b` متباينين (أي أن gcd(a, b) == 1). تستخدم خوارزمية إقليدس الموسعة\n    لحساب المعكوس. إذا لم يكن `a` و `b` متباينين، فإن المعكوس المعياري لا يوجد،\n    وتعيد الدالة `None`.\n    \n    يعيدالحجج:\n      a (int): العدد الصحيح الذي يراد إيجاد معكوسه المعياري.\n      b (int): المودولوس الذي يُبحث بالنسبة له عن المعكوس.\n    \n    يعيد:\n      int: المعكوس المعياري لـ `a` بالنسبة إلى `b` إذا كان موجودًا، وإلا `None`.\n    \n    امثله:\n      >>> mod_inverse(3, 10)\n      7\n      # الشرح: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # الشرح: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # الشرح: gcd(42, 2017) != 1، لذا لا يوجد معكوس\n    \"\"\"", "sw": "def mod_inverse(a, b):\n    \"\"\"\n    Kuhesabu kinyume cha kuzidisha cha moduli cha `a` modulo `b`.\n    \n    Kazi hii inapata nambari kamili `x` kama kwamba (a * x) % b == 1, mradi tu\n    `a` na `b` ni nambari zisizo na mgawanyiko (yaani, gcd(a, b) == 1). Inatumia\n    Algorithimu ya Euclidean Iliyopanuliwa kuhesabu kinyume. Ikiwa `a` na `b` si\n    nambari zisizo na mgawanyiko, kinyume cha moduli hakipo, na kazi inarudisha `None`.\n    \n    Hoja:\n      a (int): Nambari kamili ambayo kinyume cha moduli kinapaswa kupatikana.\n      b (int): Moduli ambayo kinyume kinatafutwa.\n    \n    Inarejesha:\n      int: Kinyume cha moduli cha `a` modulo `b` kama kipo, vinginevyo `None`.\n    \n    Mifano:\n      >>> mod_inverse(3, 10)\n      7\n      # Maelezo: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Maelezo: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Maelezo: gcd(42, 2017) != 1, kwa hivyo hakuna kinyume kinachokuwepo\n    \"\"\"", "tr": "def mod_inverse(a, b):\n    \"\"\"\n    `a` sayısının `b` modülüne göre modular çarpımsal tersini hesapla.\n    \n    Bu fonksiyon, (a * x) % b == 1 olacak şekilde bir tamsayı `x` bulur, \n    bu, `a` ve `b` aralarında asal olduğunda mümkündür (yani, gcd(a, b) == 1). \n    Tersi hesaplamak için Genişletilmiş Öklid Algoritması'nı kullanır. \n    Eğer `a` ve `b` aralarında asal değilse, modular ters mevcut değildir \n    ve fonksiyon `None` döner.\n    \n    Argümanlar:\n      a (int): Modular tersi bulunacak tamsayı.\n      b (int): Tersinin arandığı modül.\n    \n    Döndürür:\n      int: `a` sayısının `b` modülüne göre modular tersi varsa, aksi takdirde `None`.\n    \n    Örnekler:\n      >>> mod_inverse(3, 10)\n      7\n      # Açıklama: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Açıklama: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Açıklama: gcd(42, 2017) != 1, bu yüzden ters mevcut değil\n    \"\"\"", "vi": "def mod_inverse(a, b):\n    \"\"\"\n    Tính toán nghịch đảo nhân theo modulo của `a` modulo `b`.\n    \n    Hàm này tìm một số nguyên `x` sao cho (a * x) % b == 1, với điều kiện\n    `a` và `b` là hai số nguyên tố cùng nhau (tức là, gcd(a, b) == 1). Nó sử dụng\n    Thuật toán Euclid mở rộng để tính toán nghịch đảo. Nếu `a` và `b` không phải\n    là hai số nguyên tố cùng nhau, nghịch đảo theo modulo không tồn tại và hàm sẽ trả về `None`.\n    \n    Tham số:\n      a (int): Số nguyên cần tìm nghịch đảo theo modulo.\n      b (int): Modulus theo đó cần tìm nghịch đảo.\n    \n    Trả về:\n      int: Nghịch đảo theo modulo của `a` modulo `b` nếu tồn tại, ngược lại trả về `None`.\n    \n    Ví dụ:\n      >>> mod_inverse(3, 10)\n      7\n      # Giải thích: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Giải thích: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Giải thích: gcd(42, 2017) != 1, do đó không tồn tại nghịch đảo\n    \"\"\"", "id": "def mod_inverse(a, b):\n    \"\"\"\n    Hitung invers perkalian modular dari `a` modulo `b`.\n    \n    Fungsi ini menemukan bilangan bulat `x` sehingga (a * x) % b == 1, dengan syarat\n    `a` dan `b` adalah coprime (yaitu, gcd(a, b) == 1). Fungsi ini menggunakan Algoritma\n    Euclidean yang Diperluas untuk menghitung invers. Jika `a` dan `b` bukan coprime,\n    invers modular tidak ada, dan fungsi mengembalikan `None`.\n    \n    Args:\n      a (int): Bilangan bulat yang invers modularnya akan ditemukan.\n      b (int): Modulus yang menjadi acuan untuk mencari invers.\n    \n    Returns:\n      int: Invers modular dari `a` modulo `b` jika ada, jika tidak `None`.\n    \n    Contoh:\n      >>> mod_inverse(3, 10)\n      7\n      # Penjelasan: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Penjelasan: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Penjelasan: gcd(42, 2017) != 1, jadi tidak ada invers\n    \"\"\"", "ja": "def mod_inverse(a, b):\n    \"\"\"\n    `a`の`b`におけるモジュラ逆数を計算します。\n    \n    この関数は、(a * x) % b == 1 となる整数 `x` を見つけます。ただし、\n    `a` と `b` は互いに素である必要があります（つまり、gcd(a, b) == 1）。\n    拡張ユークリッドの互除法を使用して逆数を計算します。`a` と `b` が互いに素でない場合、\n    モジュラ逆数は存在せず、関数は `None` を返します。\n    \n    引数:\n      a (int): モジュラ逆数を見つける整数。\n      b (int): 逆数を求める対象の法。\n    \n    戻り値:\n      int: `a`の`b`におけるモジュラ逆数が存在する場合はその値、存在しない場合は`None`。\n    \n    例:\n      >>> mod_inverse(3, 10)\n      7\n      # 説明: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # 説明: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # 説明: gcd(42, 2017) != 1 のため、逆数は存在しません\n    \"\"\"", "ko": "def mod_inverse(a, b):\n    \"\"\"\n    `a`의 모듈러 곱셈 역원을 `b`에 대해 계산합니다.\n    \n    이 함수는 (a * x) % b == 1이 되는 정수 `x`를 찾습니다. 여기서 `a`와 `b`는 서로소\n    (즉, gcd(a, b) == 1)이어야 합니다. 확장 유클리드 알고리즘을 사용하여 역원을 계산합니다.\n    `a`와 `b`가 서로소가 아니면 모듈러 역원이 존재하지 않으며, 함수는 `None`을 반환합니다.\n    \n    인수:\n      a (int): 모듈러 역원을 찾고자 하는 정수.\n      b (int): 역원을 구하고자 하는 모듈러스.\n    \n    반환값:\n      int: `a`의 모듈러 역원이 존재하면 그 값을 반환하고, 그렇지 않으면 `None`을 반환합니다.\n    \n    예제:\n      >>> mod_inverse(3, 10)\n      7\n      # 설명: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # 설명: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # 설명: gcd(42, 2017) != 1, 따라서 역원이 존재하지 않음\n    \"\"\"", "ml": "def mod_inverse(a, b):\n    \"\"\"\n    `a` ന്റെ മോഡുലാർ മൾട്ടിപ്ലിക്കേറ്റീവ് ഇൻവേഴ്സ് `b` മോഡുലോ കണക്കാക്കുക.\n    \n    ഈ ഫംഗ്ഷൻ (a * x) % b == 1 ആകുന്ന ഒരു പൂർണ്ണസംഖ്യ `x` കണ്ടെത്തുന്നു, بشرط `a` \n    மற்றும் `b` തമ്മിൽ കോപ്രൈം (അഥവാ, gcd(a, b) == 1) ആകണം. ഇൻവേഴ്സ് കണക്കാക്കാൻ \n    ഇത് എക്സ്റ്റൻഡഡ് യൂക്ലിഡിയൻ ആൽഗോരിതം ഉപയോഗിക്കുന്നു. `a` மற்றும் `b` കോപ്രൈം \n    അല്ലെങ്കിൽ, മോഡുലാർ ഇൻവേഴ്സ് നിലവിലില്ല, ഫംഗ്ഷൻ `None` തിരികെ നൽകും.\n    \n    Args:\n      a (int): മോഡുലാർ ഇൻവേഴ്സ് കണ്ടെത്തേണ്ട പൂർണ്ണസംഖ്യ.\n      b (int): ഇൻവേഴ്സ് അന്വേഷിക്കുന്ന മോഡുലസ്.\n    \n    Returns:\n      int: `a` ന്റെ മോഡുലാർ ഇൻവേഴ്സ് `b` മോഡുലോ നിലവിലുണ്ടെങ്കിൽ, അല്ലെങ്കിൽ `None`.\n    \n    ഉദാഹരണങ്ങൾ:\n      >>> mod_inverse(3, 10)\n      7\n      # വിശദീകരണം: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # വിശദീകരണം: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # വിശദീകരണം: gcd(42, 2017) != 1, അതിനാൽ ഇൻവേഴ്സ് നിലവിലില്ല\n    \"\"\"", "fa": "def mod_inverse(a, b):\n    \"\"\"\n    محاسبه معکوس ضربی مدولار `a` مد `b`.\n    \n    این تابع یک عدد صحیح `x` را پیدا می‌کند به طوری که (a * x) % b == 1، به شرطی که\n    `a` و `b` نسبت به هم اول باشند (یعنی، gcd(a, b) == 1). این از الگوریتم\n    بسط یافته اقلیدسی برای محاسبه معکوس استفاده می‌کند. اگر `a` و `b` نسبت به هم اول نباشند،\n    معکوس مدولار وجود ندارد و تابع `None` را برمی‌گرداند.\n    \n    آرگومان‌ها:\n      a (int): عدد صحیحی که معکوس مدولار آن باید پیدا شود.\n      b (int): مدی که نسبت به آن معکوس جستجو می‌شود.\n    \n    بازگشت:\n      int: معکوس مدولار `a` مد `b` اگر وجود داشته باشد، در غیر این صورت `None`.\n    \n    مثال‌ها:\n      >>> mod_inverse(3, 10)\n      7\n      # توضیح: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # توضیح: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # توضیح: gcd(42, 2017) != 1، بنابراین معکوسی وجود ندارد\n    \"\"\""}, "canonical_solution": "    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b", "instruction": {"en": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nՏվյալ Python կոդի համար տրամադրեք կարճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），不超过500个字符。", "fr": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nBa da taƙaitaccen bayani a cikin yaren mutum (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を、日本語で500文字以内で提供してください。", "ko": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\n다음 Python 코드의 동작을 설명하는 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടുതൽ അല്ലാത്ത വിധത്തിൽ നൽകുക.", "fa": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_mod_inverse():\n    test_cases = [\n        (3, 10),  # Test case 1: gcd(3, 10) = 1, inverse should be 7\n        (17, 3120),  # Test case 2: gcd(17, 3120) = 1, inverse should be 2753\n        (42, 2017),  # Test case 3: gcd(42, 2017) = 1, inverse should be 1969\n    ]\n    expected_results = [\n        7,  # Expected result for test case 1\n        2753,  # Expected result for test case 2\n        1969,  # Expected result for test case 3\n    ]\n\n    for i, (a, b) in enumerate(test_cases):\n        actual_result = mod_inverse(a, b)\n        expected_result = expected_results[i]\n        assert actual_result == expected_result, f\"Test case {i+1} failed: expected {expected_result}, got {actual_result}\"\n        print(f\"Test case {i+1} passed: a={a}, b={b}, x0={actual_result}\")\n\n# Run the test function\ntest_mod_inverse()", "entry_point": "mod_inverse", "signature": "def mod_inverse(a, b):", "docstring": {"en": "Calculate the modular multiplicative inverse of `a` modulo `b`.\n\nThis function finds an integer `x` such that (a * x) % b == 1, provided that\n`a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\nAlgorithm to compute the inverse. If `a` and `b` are not coprime, the modular\ninverse does not exist, and the function returns `None`.\n\nArgs:\na (int): The integer whose modular inverse is to be found.\nb (int): The modulus with respect to which the inverse is sought.\n\nReturns:\nint: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nExplanation: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplanation: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplanation: gcd(42, 2017) != 1, so no inverse exists", "sq": "Llogaritni inversin modular multiplikativ të `a` modulo `b`.\n\nKjo funksion gjen një numër të plotë `x` i tillë që (a * x) % b == 1, me kusht që\n`a` dhe `b` të jenë të papërbashkët (d.m.th., gcd(a, b) == 1). Përdor Algoritmin e Zgjeruar të Euklidit për të llogaritur inversin. Nëse `a` dhe `b` nuk janë të papërbashkët, inversi modular nuk ekziston, dhe funksioni kthen `None`.\n\nArgs:\na (int): Numri i plotë për të cilin do të gjendet inversi modular.\nb (int): Moduli në lidhje me të cilin kërkohet inversi.\n\nReturns:\nint: Inversi modular i `a` modulo `b` nëse ekziston, përndryshe `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nShpjegim: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nShpjegim: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nShpjegim: gcd(42, 2017) != 1, kështu që nuk ekziston asnjë invers", "hy": "Հաշվարկել `a`-ի մոդուլային բազմապատիկ հակադարձը `b` մոդուլով։\n\nԱյս ֆունկցիան գտնում է ամբողջ թիվ `x`, այնպես որ (a * x) % b == 1, եթե\n`a` և `b` փոխադարձաբար պարզ են (այսինքն՝ gcd(a, b) == 1)։ Այն օգտագործում է ընդլայնված Էվկլիդյան\nալգորիթմը հակադարձը հաշվարկելու համար։ Եթե `a` և `b` փոխադարձաբար պարզ չեն, մոդուլային\nհակադարձը գոյություն չունի, և ֆունկցիան վերադարձնում է `None`։\n\nԱրգումենտներ:\na (int): Ամբողջ թիվը, որի մոդուլային հակադարձը պետք է գտնվի։\nb (int): Մոդուլը, որի նկատմամբ հակադարձը փնտրվում է։\n\nՎերադարձներ:\nint: `a`-ի մոդուլային հակադարձը `b` մոդուլով, եթե այն գոյություն ունի, հակառակ դեպքում `None`։\n\nՕրինակներ:\n>>> mod_inverse(3, 10)\n7\nԲացատրություն: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nԲացատրություն: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nԲացատրություն: gcd(42, 2017) != 1, ուստի հակադարձը գոյություն չունի", "bn": "`a` এর মডুলার গুণগত বিপরীত `b` মডুলোর সাথে গণনা করুন।\n\nএই ফাংশনটি এমন একটি পূর্ণসংখ্যা `x` খুঁজে বের করে যাতে (a * x) % b == 1, যদি `a` এবং `b` পরস্পর সহমর্মী হয় (অর্থাৎ, gcd(a, b) == 1)। এটি বিপরীত গণনা করতে Extended Euclidean Algorithm ব্যবহার করে। যদি `a` এবং `b` পরস্পর সহমর্মী না হয়, তাহলে মডুলার বিপরীত বিদ্যমান নয় এবং ফাংশনটি `None` ফেরত দেয়।\n\nআর্গস:\na (int): পূর্ণসংখ্যা যার মডুলার বিপরীত খুঁজে বের করতে হবে।\nb (int): মডুলাস যার সাথে বিপরীত খোঁজা হচ্ছে।\n\nরিটার্নস:\nint: `a` এর মডুলার বিপরীত `b` মডুলোর সাথে যদি বিদ্যমান থাকে, অন্যথায় `None`।\n\nউদাহরণ:\n>>> mod_inverse(3, 10)\n7\nব্যাখ্যা: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nব্যাখ্যা: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nব্যাখ্যা: gcd(42, 2017) != 1, তাই কোনো বিপরীত বিদ্যমান নেই", "bg": "Изчислява модулната мултипликативна обратна стойност на `a` модул `b`.\n\nТази функция намира цяло число `x`, такова че (a * x) % b == 1, при условие че\n`a` и `b` са взаимно прости (т.е., gcd(a, b) == 1). Използва разширения алгоритъм на Евклид\nза да изчисли обратната стойност. Ако `a` и `b` не са взаимно прости, модулната\nобратна стойност не съществува и функцията връща `None`.\n\nАргументи:\na (int): Цялото число, чиято модулна обратна стойност трябва да се намери.\nb (int): Модулът, спрямо който се търси обратната стойност.\n\nВръща:\nint: Модулната обратна стойност на `a` модул `b`, ако съществува, в противен случай `None`.\n\nПримери:\n>>> mod_inverse(3, 10)\n7\nОбяснение: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nОбяснение: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nОбяснение: gcd(42, 2017) != 1, така че обратна стойност не съществува", "zh": "计算 `a` 模 `b` 的模逆。\n\n此函数寻找一个整数 `x`，使得 (a * x) % b == 1，前提是 `a` 和 `b` 互质（即，gcd(a, b) == 1）。它使用扩展欧几里得算法来计算逆。如果 `a` 和 `b` 不互质，则模逆不存在，函数返回 `None`。\n\n参数：\na (int): 要找到模逆的整数。\nb (int): 所求逆的模数。\n\n返回：\nint: 如果存在，则返回 `a` 模 `b` 的模逆，否则返回 `None`。\n\n示例：\n>>> mod_inverse(3, 10)\n7\n解释: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\n解释: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\n解释: gcd(42, 2017) != 1，因此不存在逆。", "fr": "Calculer l'inverse multiplicatif modulaire de `a` modulo `b`.\n\nCette fonction trouve un entier `x` tel que (a * x) % b == 1, à condition que\n`a` et `b` soient copremiers (c'est-à-dire, gcd(a, b) == 1). Elle utilise l'algorithme\nd'Euclide étendu pour calculer l'inverse. Si `a` et `b` ne sont pas copremiers, l'inverse\nmodulaire n'existe pas, et la fonction retourne `None`.\n\nArgs:\na (int): L'entier dont l'inverse modulaire doit être trouvé.\nb (int): Le module par rapport auquel l'inverse est recherché.\n\nReturns:\nint: L'inverse modulaire de `a` modulo `b` s'il existe, sinon `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nExplication : (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplication : (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplication : gcd(42, 2017) != 1, donc aucun inverse n'existe", "de": "Berechne das modulare multiplikative Inverse von `a` modulo `b`.\n\nDiese Funktion findet eine ganze Zahl `x`, so dass (a * x) % b == 1, vorausgesetzt, dass `a` und `b` teilerfremd sind (d.h., gcd(a, b) == 1). Sie verwendet den erweiterten euklidischen Algorithmus, um das Inverse zu berechnen. Wenn `a` und `b` nicht teilerfremd sind, existiert das modulare Inverse nicht, und die Funktion gibt `None` zurück.\n\nArgs:\na (int): Die ganze Zahl, deren modulares Inverses gefunden werden soll.\nb (int): Der Modul, bezüglich dessen das Inverse gesucht wird.\n\nReturns:\nint: Das modulare Inverse von `a` modulo `b`, falls es existiert, andernfalls `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nErläuterung: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nErläuterung: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nErläuterung: gcd(42, 2017) != 1, daher existiert kein Inverses", "ha": "Lissafi na modular multiplicative inverse na `a` modulo `b`.\n\nWannan aikin yana nemo wani lamba `x` wanda (a * x) % b == 1, idan har `a` da `b` suna da bambancin daya (wato, gcd(a, b) == 1). Yana amfani da Tsarin Euclidean Mai Fadada don lissafa abin da ya dace. Idan `a` da `b` ba su da bambancin daya, to babu modular inverse, kuma aikin zai dawo da `None`.\n\nArgs:\na (int): Lambar da za a nemo modular inverse dinta.\nb (int): Modulus wanda ake nema inverse dinta dangane da shi.\n\nReturns:\nint: Modular inverse na `a` modulo `b` idan yana wanzu, in ba haka ba `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nBayani: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nBayani: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nBayani: gcd(42, 2017) != 1, don haka babu inverse da ke wanzu", "hi": "`a` का `b` के मापांक में गुणात्मक प्रतिलोम गणना करें।\n\nयह फ़ंक्शन एक पूर्णांक `x` खोजता है ताकि (a * x) % b == 1 हो, बशर्ते कि `a` और `b` परस्पर अभाज्य हों (अर्थात, gcd(a, b) == 1)। यह प्रतिलोम की गणना के लिए विस्तारित यूक्लिडियन एल्गोरिदम का उपयोग करता है। यदि `a` और `b` परस्पर अभाज्य नहीं हैं, तो गुणात्मक प्रतिलोम मौजूद नहीं होता है, और फ़ंक्शन `None` लौटाता है।\n\nआर्ग्स:\na (int): वह पूर्णांक जिसका गुणात्मक प्रतिलोम खोजना है।\nb (int): वह मापांक जिसके सापेक्ष प्रतिलोम खोजा जा रहा है।\n\nरिटर्न्स:\nint: `a` का `b` के मापांक में गुणात्मक प्रतिलोम यदि यह मौजूद है, अन्यथा `None`।\n\nउदाहरण:\n>>> mod_inverse(3, 10)\n7\nव्याख्या: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nव्याख्या: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nव्याख्या: gcd(42, 2017) != 1, इसलिए कोई प्रतिलोम मौजूद नहीं है।", "hu": "Számítsa ki `a` moduláris multiplikatív inverzét `b` modulóval.\n\nEz a függvény olyan egész számot talál `x`, amelyre (a * x) % b == 1, feltéve, hogy\n`a` és `b` relatív prímek (azaz gcd(a, b) == 1). Az inverz kiszámításához a kiterjesztett euklideszi algoritmust használja. Ha `a` és `b` nem relatív prímek, a moduláris inverz nem létezik, és a függvény `None`-t ad vissza.\n\nArgok:\na (int): Az egész szám, amelynek moduláris inverzét meg kell találni.\nb (int): A modulus, amelyhez képest az inverz keresendő.\n\nVisszatér:\nint: `a` moduláris inverze `b` modulóval, ha létezik, egyébként `None`.\n\nPéldák:\n>>> mod_inverse(3, 10)\n7\nMagyarázat: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nMagyarázat: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nMagyarázat: gcd(42, 2017) != 1, így nem létezik inverz", "es": "Calcular el inverso multiplicativo modular de `a` módulo `b`.\n\nEsta función encuentra un entero `x` tal que (a * x) % b == 1, siempre que\n`a` y `b` sean coprimos (es decir, gcd(a, b) == 1). Utiliza el Algoritmo\nEuclidiano Extendido para calcular el inverso. Si `a` y `b` no son coprimos, el\ninverso modular no existe, y la función devuelve `None`.\n\nArgumentos:\na (int): El entero cuyo inverso modular se va a encontrar.\nb (int): El módulo con respecto al cual se busca el inverso.\n\nDevuelve:\nint: El inverso modular de `a` módulo `b` si existe, de lo contrario `None`.\n\nEjemplos:\n>>> mod_inverse(3, 10)\n7\nExplicación: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplicación: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplicación: gcd(42, 2017) != 1, por lo que no existe un inverso", "arb": "احسب المعكوس الضربي المعياري لـ `a` بالنسبة لـ `b`.\n\nتجد هذه الدالة عددًا صحيحًا `x` بحيث أن (a * x) % b == 1، بشرط أن\n`a` و `b` أوليان (أي، gcd(a, b) == 1). تستخدم خوارزمية إقليدس الموسعة\nلحساب المعكوس. إذا لم يكن `a` و `b` أوليان، فإن المعكوس المعياري لا يوجد، وتعيد الدالة `None`.\n\nالأوساط:\na (int): العدد الصحيح الذي يجب إيجاد معكوسه المعياري.\nb (int): المعيار الذي يُبحث عن المعكوس بالنسبة له.\n\nالقيم المعادة:\nint: المعكوس المعياري لـ `a` بالنسبة لـ `b` إذا كان موجودًا، وإلا `None`.\n\nأمثلة:\n>>> mod_inverse(3, 10)\n7\nالتوضيح: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nالتوضيح: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nالتوضيح: gcd(42, 2017) != 1، لذا لا يوجد معكوس", "sw": "Kuhesabu kinyume cha kuzidisha cha moduli cha `a` modulo `b`.\n\nKazi hii inapata nambari kamili `x` kama kwamba (a * x) % b == 1, mradi tu\n`a` na `b` ni coprime (yaani, gcd(a, b) == 1). Inatumia Algorithm ya Euclidean\nIliyopanuliwa ili kuhesabu kinyume. Ikiwa `a` na `b` si coprime, kinyume cha modular hakipo, na kazi inarudisha `None`.\n\nHoja:\na (int): Nambari kamili ambayo kinyume chake cha modular kinapaswa kupatikana.\nb (int): Modulus ambayo kinyume kinatafutwa.\n\nInarejesha:\nint: Kinyume cha modular cha `a` modulo `b` ikiwa kipo, vinginevyo `None`.\n\nMifano:\n>>> mod_inverse(3, 10)\n7\nMaelezo: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nMaelezo: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nMaelezo: gcd(42, 2017) != 1, kwa hivyo hakuna kinyume kinachokuwepo", "tr": "`a` sayısının `b` modülüne göre modüler çarpımsal tersini hesaplayın.\n\nBu fonksiyon, (a * x) % b == 1 olacak şekilde bir tamsayı `x` bulur, bu durumda\n`a` ve `b` aralarında asal olmalıdır (yani, gcd(a, b) == 1). Tersi hesaplamak için\nGenişletilmiş Öklid Algoritması'nı kullanır. Eğer `a` ve `b` aralarında asal değilse,\nmodüler ters mevcut değildir ve fonksiyon `None` döndürür.\n\nArgümanlar:\na (int): Modüler tersi bulunacak tamsayı.\nb (int): Tersinin arandığı modül.\n\nDöndürür:\nint: Eğer mevcutsa `a`'nın `b` modülüne göre modüler tersi, aksi takdirde `None`.\n\nÖrnekler:\n>>> mod_inverse(3, 10)\n7\nAçıklama: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nAçıklama: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nAçıklama: gcd(42, 2017) != 1, bu yüzden ters mevcut değil", "vi": "Tính nghịch đảo nhân theo modulo của `a` modulo `b`.\n\nHàm này tìm một số nguyên `x` sao cho (a * x) % b == 1, với điều kiện\n`a` và `b` là nguyên tố cùng nhau (tức là, gcd(a, b) == 1). Nó sử dụng\nThuật toán Euclid mở rộng để tính nghịch đảo. Nếu `a` và `b` không phải là nguyên tố cùng nhau, nghịch đảo theo modulo không tồn tại, và hàm trả về `None`.\n\nTham số:\na (int): Số nguyên cần tìm nghịch đảo theo modulo.\nb (int): Modulo mà nghịch đảo được tìm kiếm.\n\nTrả về:\nint: Nghịch đảo theo modulo của `a` modulo `b` nếu tồn tại, ngược lại `None`.\n\nVí dụ:\n>>> mod_inverse(3, 10)\n7\nGiải thích: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nGiải thích: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nGiải thích: gcd(42, 2017) != 1, vì vậy không có nghịch đảo nào tồn tại", "id": "Hitung invers perkalian modular dari `a` modulo `b`.\n\nFungsi ini menemukan bilangan bulat `x` sehingga (a * x) % b == 1, dengan syarat bahwa `a` dan `b` adalah coprime (yaitu, gcd(a, b) == 1). Fungsi ini menggunakan Algoritma Euclidean yang Diperluas untuk menghitung invers. Jika `a` dan `b` tidak coprime, invers modular tidak ada, dan fungsi mengembalikan `None`.\n\nArgumen:\na (int): Bilangan bulat yang invers modularnya akan dicari.\nb (int): Modulus terhadap mana invers dicari.\n\nMengembalikan:\nint: Invers modular dari `a` modulo `b` jika ada, jika tidak `None`.\n\nContoh:\n>>> mod_inverse(3, 10)\n7\nPenjelasan: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nPenjelasan: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nPenjelasan: gcd(42, 2017) != 1, jadi tidak ada invers", "ja": "`a`を法`b`でのモジュラ逆数を計算します。\n\nこの関数は、(a * x) % b == 1 となる整数 `x` を見つけます。ただし、`a` と `b` が互いに素であることが条件です（つまり、gcd(a, b) == 1）。拡張ユークリッドの互除法を使用して逆数を計算します。`a` と `b` が互いに素でない場合、モジュラ逆数は存在せず、関数は `None` を返します。\n\n引数:\na (int): モジュラ逆数を見つけたい整数。\nb (int): 逆数を求める際の法。\n\n戻り値:\nint: `a` の法`b`でのモジュラ逆数が存在する場合はその値、存在しない場合は `None`。\n\n例:\n>>> mod_inverse(3, 10)\n7\n説明: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\n説明: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\n説明: gcd(42, 2017) != 1 のため、逆数は存在しません", "ko": "`a`의 모듈러 곱셈 역원을 `b`에 대해 계산합니다.\n\n이 함수는 (a * x) % b == 1이 되는 정수 `x`를 찾습니다. 여기서 `a`와 `b`는 서로소여야 합니다 (즉, gcd(a, b) == 1). 이 함수는 확장 유클리드 알고리즘을 사용하여 역수를 계산합니다. 만약 `a`와 `b`가 서로소가 아니라면, 모듈러 역수는 존재하지 않으며 함수는 `None`을 반환합니다.\n\nArgs:\na (int): 모듈러 역수를 찾고자 하는 정수입니다.\nb (int): 역수를 구하고자 하는 모듈러스입니다.\n\nReturns:\nint: `a`의 모듈러 역수가 존재하면 그 값을 반환하고, 그렇지 않으면 `None`을 반환합니다.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nExplanation: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplanation: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplanation: gcd(42, 2017) != 1, so no inverse exists", "ml": "`a` നെ `b` ന്റെ മോഡുലോ ആയി ഗണിതീയ ഗുണകത്തിന്റെ വിപരീതം കണക്കാക്കുക.\n\nഈ ഫംഗ്ഷൻ (a * x) % b == 1 എന്നതിനെ തൃപ്തിപ്പെടുത്തുന്ന ഒരു പൂർണ്ണസംഖ്യ `x` നെ കണ്ടെത്തുന്നു, بشرط `a` ۽ `b` പരസ്പരം പ്രധാനമാണെങ്കിൽ (അഥവാ, gcd(a, b) == 1). വിപരീതം കണക്കാക്കാൻ ഇത് വിപുലമായ യൂക്ലിഡിയൻ ആൽഗോരിതം ഉപയോഗിക്കുന്നു. `a` ۽ `b` പരസ്പരം പ്രധാനമല്ലെങ്കിൽ, മോഡുലാർ വിപരീതം നിലവിലില്ല, ഫംഗ്ഷൻ `None` മടക്കുന്നു.\n\nആർഗ്സ്:\na (int): മോഡുലാർ വിപരീതം കണ്ടെത്തേണ്ട പൂർണ്ണസംഖ്യ.\nb (int): വിപരീതം തേടുന്ന മോഡുലസ്.\n\nമടക്കുന്നു:\nint: `a` ന്റെ മോഡുലാർ വിപരീതം `b` ന്റെ മോഡുലോ നിലവിലുണ്ടെങ്കിൽ, അല്ലെങ്കിൽ `None`.\n\nഉദാഹരണങ്ങൾ:\n>>> mod_inverse(3, 10)\n7\nവിവരണം: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nവിവരണം: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nവിവരണം: gcd(42, 2017) != 1, അതിനാൽ വിപരീതം നിലവിലില്ല", "fa": "محاسبه معکوس ضربی مدولار `a` مد `b`.\n\nاین تابع یک عدد صحیح `x` را پیدا می‌کند به طوری که (a * x) % b == 1، به شرطی که\n`a` و `b` نسبت به هم اول باشند (یعنی، gcd(a, b) == 1). این تابع از\nالگوریتم توسعه‌یافته اقلیدسی برای محاسبه معکوس استفاده می‌کند. اگر `a` و `b` نسبت به هم اول نباشند، معکوس مدولار وجود ندارد و تابع `None` را برمی‌گرداند.\n\nآرگومان‌ها:\na (int): عدد صحیحی که معکوس مدولار آن باید پیدا شود.\nb (int): مدی که نسبت به آن معکوس جستجو می‌شود.\n\nبازگشت:\nint: معکوس مدولار `a` مد `b` اگر وجود داشته باشد، در غیر این صورت `None`.\n\nمثال‌ها:\n>>> mod_inverse(3, 10)\n7\nتوضیح: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nتوضیح: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nتوضیح: gcd(42, 2017) != 1، بنابراین معکوسی وجود ندارد"}}
{"task_id": "Python/42", "prompt": {"en": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n        - If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          she is most unhappy on Wednesday (day 3), so the function will return 3.\n        - If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\n          unhappy, and the function will return 0.\n        - For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally \n          unhappy on Monday and Thursday, but since Monday comes first, the function returns 1.\n    \"\"\"", "sq": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Llogarit ditën e javës kur Jinjin është më e pakënaqur bazuar në orarin e saj.\n    \n    Jinjin është e pakënaqur nëse orët totale të kaluara në shkollë dhe klasa shtesë tejkalojnë 8 orë në një ditë.\n    Funksioni gjen ditën kur pakënaqësia e saj është më e madhe, që është dita kur orët totale janë më të larta mbi pragun.\n    Nëse ka disa ditë me të njëjtin nivel të pakënaqësisë maksimale, kthehet dita më e hershme. Nëse Jinjin nuk është e pakënaqur në asnjë ditë,\n    funksioni kthen 0.\n    \n    Argumentet:\n        schedule (list[tuple[int, int]]): Një listë me 7 tufa, ku çdo tufë përfaqëson \n                                           numrin e orëve të kaluara në shkollë dhe në klasa shtesë\n                                           për çdo ditë të javës, respektivisht.\n                                           \n    Kthen:\n        int: Dita e javës kur Jinjin është më e pakënaqur (1-7 për të hënën deri të dielën) ose 0 \n             nëse ajo nuk është kurrë e pakënaqur.\n    \n    Rastet:\n        - Nëse Jinjin ka orarin e mëposhtëm [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          ajo është më e pakënaqur të mërkurën (dita 3), kështu që funksioni do të kthejë 3.\n        - Nëse orari i saj është [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin nuk është kurrë\n          e pakënaqur, dhe funksioni do të kthejë 0.\n        - Për një orar [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin është njësoj \n          e pakënaqur të hënën dhe të enjten, por meqë e hëna vjen e para, funksioni kthen 1.\n    \"\"\"", "hy": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Հաշվարկել այն շաբաթվա օրը, երբ Ջինջինը ամենաանհաջողն է իր ժամանակացույցի հիման վրա։\n    \n    Ջինջինը դժգոհ է, եթե դպրոցում և լրացուցիչ դասերի ժամանակ անցկացրած ընդհանուր ժամերը գերազանցում են 8 ժամը մեկ օրում։ \n    Ֆունկցիան գտնում է այն օրը, երբ նրա դժգոհությունը ամենամեծն է, այսինքն՝ այն օրը, երբ ընդհանուր\n    ժամերը առավելագույնս գերազանցում են շեմը։ Եթե կան մի քանի օրեր նույն մակարդակի \n    առավելագույն դժգոհությամբ, վերադարձվում է ամենավաղ օրը։ Եթե Ջինջինը ոչ մի օր դժգոհ չէ, \n    ֆունկցիան վերադարձնում է 0։\n    \n    Արգումենտներ:\n        schedule (list[tuple[int, int]]): 7 տուփերի ցուցակ, որտեղ յուրաքանչյուր տուփ ներկայացնում է \n                                           դպրոցում և լրացուցիչ դասերի ժամանակ անցկացրած \n                                           ժամերի քանակը շաբաթվա յուրաքանչյուր օրվա համար։\n                                           \n    Վերադարձնում է:\n        int: Շաբաթվա այն օրը, երբ Ջինջինը ամենաանհաջողն է (1-7 երկուշաբթիից կիրակի) կամ 0 \n             եթե նա երբեք դժգոհ չէ։\n    \n    Դեպքեր:\n        - Եթե Ջինջինը ունի հետևյալ ժամանակացույցը [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          նա ամենաանհաջողն է չորեքշաբթի (օր 3), ուստի ֆունկցիան կվերադարձնի 3։\n        - Եթե նրա ժամանակացույցը [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] է, Ջինջինը երբեք\n          դժգոհ չէ, և ֆունկցիան կվերադարձնի 0։\n        - Ժամանակացույցի համար [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Ջինջինը հավասարապես \n          դժգոհ է երկուշաբթի և հինգշաբթի, բայց քանի որ երկուշաբթին առաջինն է, ֆունկցիան կվերադարձնի 1։\n    \"\"\"", "bn": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    জিনজিনের সময়সূচির ভিত্তিতে সপ্তাহের কোন দিনটি সে সবচেয়ে অসুখী তা নির্ণয় করুন।\n    \n    জিনজিন অসুখী হয় যদি স্কুল এবং অতিরিক্ত ক্লাসে ব্যয় করা মোট সময় এক দিনে ৮ ঘণ্টার বেশি হয়।\n    ফাংশনটি সেই দিনটি খুঁজে বের করে যখন তার অসুখীতা সবচেয়ে বেশি, অর্থাৎ যেদিন মোট \n    সময় সীমার উপরে সবচেয়ে বেশি। যদি একাধিক দিন একই স্তরের সর্বাধিক অসুখীতা থাকে, \n    তাহলে সবচেয়ে প্রথম দিনটি ফেরত দেওয়া হয়। যদি জিনজিন কোনো দিনই অসুখী না হয়, তাহলে \n    ফাংশনটি 0 ফেরত দেয়।\n    \n    Args:\n        schedule (list[tuple[int, int]]): ৭টি টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল \n                                           সপ্তাহের প্রতিটি দিনের জন্য স্কুল এবং অতিরিক্ত \n                                           ক্লাসে ব্যয় করা ঘণ্টার সংখ্যা উপস্থাপন করে।\n                                           \n    Returns:\n        int: সপ্তাহের যে দিনটিতে জিনজিন সবচেয়ে অসুখী (সোমবার থেকে রবিবারের জন্য ১-৭) \n             অথবা যদি সে কখনোই অসুখী না হয় তাহলে 0।\n    \n    উদাহরণ:\n        - যদি জিনজিনের সময়সূচি হয় [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          তাহলে সে বুধবার (দিন ৩) সবচেয়ে অসুখী, তাই ফাংশনটি ৩ ফেরত দেবে।\n        - যদি তার সময়সূচি হয় [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], \n          জিনজিন কখনোই অসুখী নয়, এবং ফাংশনটি 0 ফেরত দেবে।\n        - একটি সময়সূচির জন্য [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], \n          জিনজিন সোমবার এবং বৃহস্পতিবার সমানভাবে অসুখী, কিন্তু যেহেতু সোমবার প্রথমে আসে, \n          ফাংশনটি ১ ফেরত দেবে।\n    \"\"\"", "bg": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Изчислява деня от седмицата, когато Джинджин е най-нещастна въз основа на нейния график.\n    \n    Джинджин е нещастна, ако общият брой часове, прекарани в училище и допълнителни класове, надвишава 8 часа на ден.\n    Функцията намира деня, когато нещастието ѝ е най-голямо, което е денят, когато общият брой часове е най-далеч над прага.\n    Ако има няколко дни със същото ниво на максимално нещастие, се връща най-ранният ден. Ако Джинджин не е нещастна в нито един ден,\n    функцията връща 0.\n    \n    Аргументи:\n        schedule (list[tuple[int, int]]): Списък от 7 кортежа, където всеки кортеж представлява\n                                           броя часове, прекарани в училище и в допълнителни класове\n                                           за всеки ден от седмицата, съответно.\n                                           \n    Връща:\n        int: Денят от седмицата, когато Джинджин е най-нещастна (1-7 за понеделник до неделя) или 0\n             ако никога не е нещастна.\n    \n    Примери:\n        - Ако Джинджин има следния график [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          тя е най-нещастна в сряда (ден 3), така че функцията ще върне 3.\n        - Ако графикът ѝ е [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Джинджин никога не е\n          нещастна и функцията ще върне 0.\n        - За график [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Джинджин е еднакво\n          нещастна в понеделник и четвъртък, но тъй като понеделник е първи, функцията връща 1.\n    \"\"\"", "zh": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    计算根据日程安排，金金在哪一天最不开心。\n    \n    如果金金在学校和额外课程上花费的总时间超过8小时，她就会不开心。\n    该函数找出她不开心程度最大的那一天，即总小时数超过阈值最多的那一天。\n    如果有多天达到相同的最大不开心程度，则返回最早的一天。\n    如果金金在任何一天都不不开心，函数返回0。\n    \n    参数:\n        schedule (list[tuple[int, int]]): 一个包含7个元组的列表，每个元组分别表示\n                                           每周每天在学校和额外课程上花费的小时数。\n                                           \n    返回:\n        int: 金金最不开心的那一天（1-7表示星期一到星期天），如果她从不不开心则返回0。\n    \n    示例:\n        - 如果金金的日程是 [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          她在星期三（第3天）最不开心，所以函数将返回3。\n        - 如果她的日程是 [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)]，金金从不\n          不开心，函数将返回0。\n        - 对于日程 [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]，金金在星期一和\n          星期四同样不开心，但由于星期一在前，函数返回1。\n    \"\"\"", "fr": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculer le jour de la semaine où Jinjin est la plus malheureuse en fonction de son emploi du temps.\n    \n    Jinjin est malheureuse si le total des heures passées à l'école et aux cours supplémentaires dépasse 8 heures par jour.\n    La fonction trouve le jour où son malheur est le plus grand, c'est-à-dire le jour où le total\n    des heures est le plus au-dessus du seuil. S'il y a plusieurs jours avec le même niveau de\n    malheur maximal, le premier jour est retourné. Si Jinjin n'est malheureuse aucun jour, la\n    fonction retourne 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Une liste de 7 tuples, où chaque tuple représente le\n                                           nombre d'heures passées à l'école et aux cours supplémentaires\n                                           pour chaque jour de la semaine, respectivement.\n                                           \n    Returns:\n        int: Le jour de la semaine où Jinjin est la plus malheureuse (1-7 pour lundi à dimanche) ou 0\n             si elle n'est jamais malheureuse.\n    \n    Cas:\n        - Si Jinjin a l'emploi du temps suivant [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          elle est la plus malheureuse le mercredi (jour 3), donc la fonction retournera 3.\n        - Si son emploi du temps est [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin n'est jamais\n          malheureuse, et la fonction retournera 0.\n        - Pour un emploi du temps [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin est également\n          malheureuse le lundi et le jeudi, mais comme le lundi vient en premier, la fonction retourne 1.\n    \"\"\"", "de": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Berechne den Wochentag, an dem Jinjin am unglücklichsten ist, basierend auf ihrem Stundenplan.\n    \n    Jinjin ist unglücklich, wenn die Gesamtstunden, die sie in der Schule und in zusätzlichen Kursen verbringt, 8 Stunden an einem Tag überschreiten. \n    Die Funktion findet den Tag, an dem ihr Unglück am größten ist, was der Tag ist, an dem die Gesamtstunden am weitesten über dem Schwellenwert liegen. \n    Wenn es mehrere Tage mit dem gleichen Maß an maximalem Unglück gibt, wird der früheste Tag zurückgegeben. \n    Wenn Jinjin an keinem Tag unglücklich ist, gibt die Funktion 0 zurück.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Eine Liste von 7 Tupeln, wobei jedes Tupel die Anzahl der Stunden darstellt, \n                                           die an der Schule und in zusätzlichen Kursen für jeden Wochentag verbracht werden.\n                                           \n    Returns:\n        int: Der Wochentag, an dem Jinjin am unglücklichsten ist (1-7 für Montag bis Sonntag) oder 0, \n             wenn sie nie unglücklich ist.\n    \n    Fälle:\n        - Wenn Jinjin den folgenden Stundenplan hat [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          ist sie am Mittwoch (Tag 3) am unglücklichsten, daher wird die Funktion 3 zurückgeben.\n        - Wenn ihr Stundenplan [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] ist, ist Jinjin nie\n          unglücklich, und die Funktion wird 0 zurückgeben.\n        - Für einen Stundenplan [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] ist Jinjin gleichermaßen \n          unglücklich am Montag und Donnerstag, aber da Montag zuerst kommt, gibt die Funktion 1 zurück.\n    \"\"\"", "ha": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Lissafa ranar mako da Jinjin take mafi rashin jin daɗi bisa ga jadawalin ta.\n    \n    Jinjin tana rashin jin daɗi idan jimillar awanni da aka kwashe a makaranta da ƙarin aji sun wuce awanni 8 a rana.\n    Aikin yana nemo ranar da rashin jin daɗin ta ya fi yawa, wato ranar da jimillar awanni suka fi nesa daga ƙayyadadden\n    matakin. Idan akwai ranaku da yawa da suke da irin wannan matakin mafi girman rashin jin daɗi, za a dawo da ranar da\n    ta fara. Idan Jinjin ba ta rashin jin daɗi a kowace rana, aikin zai dawo da 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Jerin tuples guda 7, inda kowanne tuple ke wakiltar\n                                           adadin awanni da aka kwashe a makaranta da ƙarin aji\n                                           don kowace rana ta mako, bi da bi.\n                                           \n    Returns:\n        int: Ranar mako da Jinjin take mafi rashin jin daɗi (1-7 don Litinin zuwa Lahadi) ko 0\n             idan ba ta taɓa rashin jin daɗi ba.\n    \n    Cases:\n        - Idan Jinjin tana da jadawalin mai zuwa [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          tana mafi rashin jin daɗi a ranar Laraba (rana ta 3), don haka aikin zai dawo da 3.\n        - Idan jadawalin ta shine [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin ba ta taɓa\n          rashin jin daɗi ba, kuma aikin zai dawo da 0.\n        - Don jadawalin [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin tana daidai\n          rashin jin daɗi a ranar Litinin da Alhamis, amma tunda Litinin ta fara, aikin zai dawo da 1.\n    \"\"\"", "hi": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Jinjin के कार्यक्रम के आधार पर सप्ताह के उस दिन की गणना करें जब वह सबसे अधिक दुखी होती है।\n    \n    Jinjin दुखी होती है यदि स्कूल और अतिरिक्त कक्षाओं में बिताए गए कुल घंटे एक दिन में 8 घंटे से अधिक होते हैं।\n    फ़ंक्शन उस दिन को खोजता है जब उसकी दुखी होने की स्थिति सबसे अधिक होती है, जो वह दिन होता है जब कुल\n    घंटे सीमा से सबसे अधिक ऊपर होते हैं। यदि कई दिनों में अधिकतम दुखी होने का स्तर समान होता है, तो सबसे पहले\n    आने वाला दिन लौटाया जाता है। यदि Jinjin किसी भी दिन दुखी नहीं होती है, तो फ़ंक्शन 0 लौटाता है।\n    \n    Args:\n        schedule (list[tuple[int, int]]): 7 ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल स्कूल और अतिरिक्त कक्षाओं में\n                                           बिताए गए घंटों की संख्या को क्रमशः सप्ताह के प्रत्येक दिन के लिए दर्शाता है।\n                                           \n    Returns:\n        int: सप्ताह का वह दिन जब Jinjin सबसे अधिक दुखी होती है (सोमवार से रविवार के लिए 1-7) या 0 \n             यदि वह कभी दुखी नहीं होती है।\n    \n    उदाहरण:\n        - यदि Jinjin का कार्यक्रम इस प्रकार है [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          वह बुधवार (दिन 3) को सबसे अधिक दुखी होती है, इसलिए फ़ंक्शन 3 लौटाएगा।\n        - यदि उसका कार्यक्रम [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] है, तो Jinjin कभी\n          दुखी नहीं होती है, और फ़ंक्शन 0 लौटाएगा।\n        - एक कार्यक्रम [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] के लिए, Jinjin सोमवार और\n          गुरुवार को समान रूप से दुखी होती है, लेकिन चूंकि सोमवार पहले आता है, इसलिए फ़ंक्शन 1 लौटाएगा।\n    \"\"\"", "hu": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Számítsd ki, hogy a hét melyik napján a legboldogtalanabb Jinjin az időbeosztása alapján.\n    \n    Jinjin boldogtalan, ha az iskolában és az extra órákon eltöltött összes idő meghaladja a napi 8 órát.\n    A függvény megkeresi azt a napot, amikor a boldogtalansága a legnagyobb, vagyis azt a napot, amikor\n    az összes óraszám a legjobban meghaladja a küszöböt. Ha több nap is azonos szintű maximális\n    boldogtalansággal bír, akkor a legkorábbi napot adja vissza. Ha Jinjin egyetlen napon sem boldogtalan,\n    a függvény 0-t ad vissza.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Egy lista 7 darab párral, ahol minden pár az iskolában és az\n                                           extra órákon eltöltött órák számát jelenti a hét minden napjára\n                                           vonatkozóan.\n                                           \n    Returns:\n        int: A hét azon napja, amikor Jinjin a legboldogtalanabb (1-7 hétfőtől vasárnapig) vagy 0, ha\n             soha nem boldogtalan.\n    \n    Esetek:\n        - Ha Jinjin időbeosztása a következő: [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          akkor a legboldogtalanabb szerdán (3. nap), így a függvény 3-at ad vissza.\n        - Ha az időbeosztása [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin soha nem\n          boldogtalan, és a függvény 0-t ad vissza.\n        - Egy olyan időbeosztásnál, mint [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin\n          egyformán boldogtalan hétfőn és csütörtökön, de mivel hétfő az első, a függvény 1-et ad vissza.\n    \"\"\"", "es": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calcula el día de la semana en que Jinjin está más infeliz según su horario.\n    \n    Jinjin está infeliz si el total de horas pasadas en la escuela y clases extra excede 8 horas en un día.\n    La función encuentra el día cuando su infelicidad es mayor, que es el día cuando el total\n    de horas está más por encima del umbral. Si hay múltiples días con el mismo nivel de\n    máxima infelicidad, se devuelve el primer día. Si Jinjin no está infeliz en ningún día, la\n    función devuelve 0.\n    \n    Argumentos:\n        schedule (list[tuple[int, int]]): Una lista de 7 tuplas, donde cada tupla representa el\n                                           número de horas pasadas en la escuela y en clases extra\n                                           para cada día de la semana, respectivamente.\n                                           \n    Devuelve:\n        int: El día de la semana en que Jinjin está más infeliz (1-7 para lunes a domingo) o 0\n             si nunca está infeliz.\n    \n    Casos:\n        - Si Jinjin tiene el siguiente horario [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          está más infeliz el miércoles (día 3), por lo que la función devolverá 3.\n        - Si su horario es [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin nunca está\n          infeliz, y la función devolverá 0.\n        - Para un horario [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin está igualmente\n          infeliz el lunes y el jueves, pero como el lunes viene primero, la función devuelve 1.\n    \"\"\"", "arb": "```python\ndef find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    حساب اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة بناءً على جدولها.\n\n    تكون جينجين غير سعيدة إذا تجاوز إجمالي الساعات التي تقضيها في المدرسة والدروس الإضافية 8 ساعات في اليوم.\n    تقوم الدالة بالعثور على اليوم الذي تكون فيه تعاستها أكبر، وهو اليوم الذي تكون فيه الساعات الإجمالية\n    أبعد ما يكون عن الحد الأدنى. إذا كان هناك عدة أيام بنفس مستوى التعاسة القصوى، يتم إرجاع اليوم الأول.\n    إذا لم تكن جينجين غير سعيدة في أي يوم، فإن الدالة ترجع 0.\n\n    يعيدالحجج:\n        schedule (list[tuple[int, int]]): قائمة تحتوي على 7 مجموعات، حيث تمثل كل مجموعة\n                                           عدد الساعات التي تقضيها في المدرسة والدروس الإضافية\n                                           لكل يوم من أيام الأسبوع، على التوالي.\n                                           \n    يعيد:\n        int: اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة (1-7 من الاثنين إلى الأحد) أو 0\n             إذا لم تكن غير سعيدة أبدًا.\n\n    حالات:\n        - إذا كان لجينجين الجدول التالي [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          فإنها تكون الأكثر تعاسة يوم الأربعاء (اليوم 3)، لذا ستعيد الدالة 3.\n        - إذا كان جدولها هو [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)]، فإن جينجين ليست\n          غير سعيدة أبدًا، وستعيد الدالة 0.\n        - لجدول [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]، فإن جينجين تكون غير\n          سعيدة بالتساوي يوم الاثنين والخميس، ولكن بما أن الاثنين يأتي أولاً، فإن الدالة تعيد 1.\n    \"\"\"\n```", "sw": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Kuhesabu siku ya wiki ambapo Jinjin hana furaha zaidi kulingana na ratiba yake.\n    \n    Jinjin hana furaha ikiwa jumla ya masaa yaliyotumika shuleni na madarasa ya ziada yanazidi masaa 8 kwa siku. \n    Kazi hii inapata siku ambapo kutoridhika kwake ni kubwa zaidi, ambayo ni siku ambapo jumla ya masaa \n    yanazidi kiwango. Ikiwa kuna siku nyingi zenye kiwango sawa cha kutoridhika, siku ya mapema zaidi \n    inarudishwa. Ikiwa Jinjin hana huzuni siku yoyote, kazi inarudisha 0.\n    \n    Hoja:\n        schedule (list[tuple[int, int]]): Orodha ya jozi 7, ambapo kila jozi inawakilisha \n                                           idadi ya masaa yaliyotumika shuleni na kwenye madarasa ya ziada\n                                           kwa kila siku ya wiki, mtawalia.\n                                           \n    Inarejesha:\n        int: Siku ya wiki ambapo Jinjin hana furaha zaidi (1-7 kwa Jumatatu hadi Jumapili) au 0 \n             ikiwa hana huzuni kamwe.\n    \n    Mifano:\n        - Ikiwa Jinjin ana ratiba ifuatayo [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          hana furaha zaidi siku ya Jumatano (siku ya 3), hivyo kazi itarudisha 3.\n        - Ikiwa ratiba yake ni [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin hana huzuni kamwe,\n          na kazi itarudisha 0.\n        - Kwa ratiba [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin hana furaha sawa \n          siku ya Jumatatu na Alhamisi, lakini kwa kuwa Jumatatu inakuja kwanza, kazi inarudisha 1.\n    \"\"\"", "tr": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Jinjin'in programına göre en mutsuz olduğu haftanın gününü hesapla.\n    \n    Jinjin, bir günde okulda ve ekstra derslerde geçirilen toplam saatler 8 saati aşarsa mutsuz olur.\n    Fonksiyon, mutsuzluğunun en fazla olduğu günü bulur, bu da toplam saatlerin eşik değerin en çok\n    üzerinde olduğu gündür. Eğer birden fazla gün aynı seviyede maksimum mutsuzluk içeriyorsa, \n    en erken gün döndürülür. Eğer Jinjin herhangi bir gün mutsuz değilse, fonksiyon 0 döndürür.\n    \n    Argümanlar:\n        schedule (list[tuple[int, int]]): Her bir gün için okulda ve ekstra derslerde geçirilen \n                                           saat sayısını temsil eden 7 demetlik bir liste.\n                                           \n    Inarejesha:\n        int: Jinjin'in en mutsuz olduğu haftanın günü (Pazartesi'den Pazar'a 1-7) veya hiç mutsuz \n             değilse 0.\n    \n    Durumlar:\n        - Eğer Jinjin'in programı [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)] ise,\n          Çarşamba günü (gün 3) en mutsuz olduğu gündür, bu yüzden fonksiyon 3 döndürecektir.\n        - Eğer programı [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] ise, Jinjin hiç\n          mutsuz değildir ve fonksiyon 0 döndürecektir.\n        - [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] programı için, Jinjin Pazartesi \n          ve Perşembe günleri eşit derecede mutsuzdur, ancak Pazartesi önce geldiği için fonksiyon 1 \n          döndürecektir.\n    \"\"\"", "vi": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Tính toán ngày trong tuần khi Jinjin cảm thấy không vui nhất dựa trên lịch trình của cô ấy.\n    \n    Jinjin cảm thấy không vui nếu tổng số giờ ở trường và lớp học thêm vượt quá 8 giờ trong một ngày.\n    Hàm này tìm ngày mà sự không vui của cô ấy là lớn nhất, tức là ngày mà tổng số giờ vượt quá ngưỡng\n    nhiều nhất. Nếu có nhiều ngày có mức độ không vui tối đa giống nhau, ngày sớm nhất sẽ được trả về.\n    Nếu Jinjin không cảm thấy không vui vào bất kỳ ngày nào, hàm sẽ trả về 0.\n    \n    Tham số:\n        schedule (list[tuple[int, int]]): Một danh sách gồm 7 bộ giá trị, mỗi bộ giá trị đại diện cho\n                                           số giờ ở trường và lớp học thêm cho mỗi ngày trong tuần.\n                                           \n    Trả về:\n        int: Ngày trong tuần khi Jinjin cảm thấy không vui nhất (1-7 cho Thứ Hai đến Chủ Nhật) hoặc 0\n             nếu cô ấy không bao giờ cảm thấy không vui.\n    \n    Trường hợp:\n        - Nếu Jinjin có lịch trình sau [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          cô ấy cảm thấy không vui nhất vào Thứ Tư (ngày 3), vì vậy hàm sẽ trả về 3.\n        - Nếu lịch trình của cô ấy là [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin\n          không bao giờ cảm thấy không vui, và hàm sẽ trả về 0.\n        - Với lịch trình [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin cảm thấy không\n          vui như nhau vào Thứ Hai và Thứ Năm, nhưng vì Thứ Hai đến trước, hàm sẽ trả về 1.\n    \"\"\"", "id": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Hitung hari dalam seminggu ketika Jinjin paling tidak bahagia berdasarkan jadwalnya.\n    \n    Jinjin tidak bahagia jika total jam yang dihabiskan di sekolah dan kelas tambahan melebihi 8 jam dalam sehari.\n    Fungsi ini menemukan hari ketika ketidakbahagiaannya paling besar, yaitu hari ketika total\n    jam paling jauh di atas ambang batas. Jika ada beberapa hari dengan tingkat ketidakbahagiaan maksimum yang sama,\n    hari paling awal yang dikembalikan. Jika Jinjin tidak tidak bahagia pada hari apa pun,\n    fungsi mengembalikan 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Daftar 7 tuple, di mana setiap tuple mewakili\n                                           jumlah jam yang dihabiskan di sekolah dan di kelas tambahan\n                                           untuk setiap hari dalam seminggu, masing-masing.\n                                           \n    Returns:\n        int: Hari dalam seminggu ketika Jinjin paling tidak bahagia (1-7 untuk Senin hingga Minggu) atau 0\n             jika dia tidak pernah tidak bahagia.\n    \n    Kasus:\n        - Jika Jinjin memiliki jadwal berikut [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          dia paling tidak bahagia pada hari Rabu (hari ke-3), jadi fungsi akan mengembalikan 3.\n        - Jika jadwalnya adalah [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin tidak pernah\n          tidak bahagia, dan fungsi akan mengembalikan 0.\n        - Untuk jadwal [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin sama\n          tidak bahagia pada hari Senin dan Kamis, tetapi karena Senin datang lebih dulu, fungsi mengembalikan 1.\n    \"\"\"", "ja": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    スケジュールに基づいて、ジンジンが最も不幸な曜日を計算します。\n    \n    ジンジンは、学校と追加のクラスで過ごす合計時間が1日で8時間を超えると不幸になります。\n    この関数は、彼女の不幸が最も大きい日、つまり合計時間がしきい値を最も超えている日を見つけます。\n    最大の不幸のレベルが同じ日が複数ある場合は、最も早い日が返されます。ジンジンがどの日も不幸でない場合、\n    関数は0を返します。\n    \n    引数:\n        schedule (list[tuple[int, int]]): 7つのタプルのリストで、各タプルはそれぞれの曜日における\n                                           学校と追加のクラスで過ごす時間を表します。\n                                           \n    戻り値:\n        int: ジンジンが最も不幸な曜日（1-7で月曜日から日曜日）または彼女が決して不幸でない場合は0。\n    \n    ケース:\n        - ジンジンが次のスケジュール [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)] を持っている場合、\n          彼女は水曜日（3日目）に最も不幸なので、関数は3を返します。\n        - 彼女のスケジュールが [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] の場合、ジンジンは決して\n          不幸ではなく、関数は0を返します。\n        - スケジュールが [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] の場合、ジンジンは月曜日と木曜日に\n          同じように不幸ですが、月曜日が先に来るので、関数は1を返します。\n    \"\"\"", "ko": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Jinjin의 일정에 따라 그녀가 가장 불행한 요일을 계산합니다.\n    \n    Jinjin은 하루에 학교와 추가 수업에서 보낸 총 시간이 8시간을 초과하면 불행합니다.\n    이 함수는 그녀의 불행이 가장 큰 날, 즉 총 시간이 임계값을 가장 많이 초과하는 날을 찾습니다.\n    최대 불행 수준이 동일한 여러 날이 있는 경우, 가장 이른 날이 반환됩니다. Jinjin이 어느 날에도 불행하지 않다면,\n    함수는 0을 반환합니다.\n    \n    Args:\n        schedule (list[tuple[int, int]]): 각 튜플이 각각 주의 각 요일에 학교와 추가 수업에서 보낸 \n                                           시간을 나타내는 7개의 튜플 리스트입니다.\n                                           \n    Returns:\n        int: Jinjin이 가장 불행한 요일 (월요일부터 일요일까지 1-7) 또는 그녀가 전혀 불행하지 않으면 0을 반환합니다.\n    \n    Cases:\n        - Jinjin이 다음과 같은 일정을 가지고 있다면 [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          그녀는 수요일(3일)에 가장 불행하므로 함수는 3을 반환합니다.\n        - 그녀의 일정이 [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)]이라면, Jinjin은 전혀 불행하지 않으며,\n          함수는 0을 반환합니다.\n        - 일정이 [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]인 경우, Jinjin은 월요일과 목요일에 \n          동일하게 불행하지만, 월요일이 먼저 오기 때문에 함수는 1을 반환합니다.\n    \"\"\"", "ml": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    ജിൻജിൻ തന്റെ ഷെഡ്യൂളിനെ അടിസ്ഥാനമാക്കി ഏറ്റവും അസന്തുഷ്ടമായ ആഴ്ചയിലെ ദിവസം കണക്കാക്കുക.\n    \n    ഒരു ദിവസം സ്കൂളിലും അധിക ക്ലാസ്സുകളിലും ചെലവഴിച്ച മൊത്തം മണിക്കൂറുകൾ 8 മണിക്കൂറിൽ കൂടുതൽ ആയാൽ ജിൻജിൻ അസന്തുഷ്ടയാണ്.\n    അവളുടെ അസന്തോഷം ഏറ്റവും കൂടുതലായിരിക്കുന്ന ദിവസം ഫങ്ഷൻ കണ്ടെത്തുന്നു, ഇത് മൊത്തം മണിക്കൂറുകൾ\n    പരിധിയേക്കാൾ ഏറ്റവും കൂടുതൽ ആയിരിക്കുന്ന ദിവസമാണ്. ഒരേ തോതിലുള്ള പരമാവധി അസന്തോഷം ഉള്ള നിരവധി ദിവസങ്ങൾ ഉണ്ടെങ്കിൽ,\n    ആദ്യത്തെ ദിവസം തിരികെ നൽകുന്നു. ജിൻജിൻ ഏതെങ്കിലും ദിവസവും അസന്തുഷ്ടയല്ലെങ്കിൽ, ഫങ്ഷൻ 0 തിരികെ നൽകും.\n    \n    Args:\n        schedule (list[tuple[int, int]]): 7 ട്യൂപ്പിളുകളുടെ ഒരു ലിസ്റ്റ്, ഓരോ ട്യൂപ്പിളും\n                                           ആഴ്ചയിലെ ഓരോ ദിവസവും സ്കൂളിലും അധിക ക്ലാസ്സുകളിലും ചെലവഴിച്ച\n                                           മണിക്കൂറുകളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്നു.\n                                           \n    Returns:\n        int: ജിൻജിൻ ഏറ്റവും അസന്തുഷ്ടയായ ആഴ്ചയിലെ ദിവസം (തിങ്കളാഴ്ച മുതൽ ഞായറാഴ്ച വരെ 1-7) അല്ലെങ്കിൽ\n             അവൾ ഒരിക്കലും അസന്തുഷ്ടയല്ലെങ്കിൽ 0.\n    \n    ഉദാഹരണങ്ങൾ:\n        - ജിൻജിൻക്ക് [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)] എന്ന ഷെഡ്യൂൾ ഉണ്ടെങ്കിൽ,\n          അവൾ ബുധനാഴ്ച (ദിവസം 3) ഏറ്റവും അസന്തുഷ്ടയാണ്, അതിനാൽ ഫങ്ഷൻ 3 തിരികെ നൽകും.\n        - അവളുടെ ഷെഡ്യൂൾ [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] ആണെങ്കിൽ, ജിൻജിൻ ഒരിക്കലും\n          അസന്തുഷ്ടയല്ല, ഫങ്ഷൻ 0 തിരികെ നൽകും.\n        - [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] എന്ന ഷെഡ്യൂളിനായി, ജിൻജിൻ തിങ്കളാഴ്ചയും വ്യാഴാഴ്ചയും\n          ഒരുപോലെ അസന്തുഷ്ടയാണ്, എന്നാൽ തിങ്കളാഴ്ച ആദ്യം വരുന്നതിനാൽ, ഫങ്ഷൻ 1 തിരികെ നൽകും.\n    \"\"\"", "fa": "python\ndef find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    محاسبه روزی از هفته که جینجین بر اساس برنامه‌اش بیشترین ناراحتی را دارد.\n    \n    جینجین ناراحت است اگر مجموع ساعات صرف شده در مدرسه و کلاس‌های اضافی در یک روز بیش از 8 ساعت باشد.\n    تابع روزی را پیدا می‌کند که ناراحتی او بیشترین است، یعنی روزی که مجموع ساعات بیشترین فاصله را از\n    حد آستانه دارد. اگر چندین روز با سطح یکسانی از حداکثر ناراحتی وجود داشته باشد، اولین روز برگردانده می‌شود.\n    اگر جینجین در هیچ روزی ناراحت نباشد، تابع 0 را برمی‌گرداند.\n    \n    آرگومان‌ها:\n        schedule (list[tuple[int, int]]): لیستی از 7 تاپل، که هر تاپل نشان‌دهنده تعداد ساعات صرف شده\n                                           در مدرسه و کلاس‌های اضافی برای هر روز هفته به ترتیب است.\n                                           \n    بازگشت:\n        int: روزی از هفته که جینجین بیشترین ناراحتی را دارد (1-7 برای دوشنبه تا یکشنبه) یا 0 \n             اگر او هرگز ناراحت نباشد.\n    \n    موارد:\n        - اگر جینجین برنامه زیر را داشته باشد [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          او در روز چهارشنبه (روز 3) بیشترین ناراحتی را دارد، بنابراین تابع 3 را برمی‌گرداند.\n        - اگر برنامه او [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] باشد، جینجین هرگز\n          ناراحت نیست و تابع 0 را برمی‌گرداند.\n        - برای برنامه [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]، جینجین به طور مساوی\n          در روز دوشنبه و پنج‌شنبه ناراحت است، اما چون دوشنبه اول می‌آید، تابع 1 را برمی‌گرداند.\n    \"\"\"\n"}, "canonical_solution": "    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day", "instruction": {"en": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nՏվեք Python կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।", "bg": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nПредоставете кратко описание на Python кода на естествен език на български, използвайки най-много 500 символа.", "zh": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\n请用中文为以下 Python 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nVerilen Python kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olmalıdır.", "vi": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\n以下のPythonコードに対して、500文字以内で簡潔な自然言語の説明（ドックストリング）を日本語で提供してください。", "ko": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\n다음 Python 코드의 동작을 설명하는 간결한 자연어 설명(도크스트링)을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കൂടാതെ നൽകുക.", "fa": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nتوضیحی مختصر و به زبان طبیعی (docstring) از کد پایتون به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_find_most_unhappy_day():\n    # Test case 1: Provided example where Jinjin is most unhappy on Wednesday\n    schedule1 = [\n        (5, 3),\n        (6, 2),\n        (7, 2),\n        (5, 3),\n        (5, 4),\n        (0, 4),\n        (0, 6)\n    ]\n    assert find_most_unhappy_day(schedule1) == 3, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin is never unhappy\n    schedule2 = [\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule2) == 0, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin is most unhappy on Monday and Thursday, but Monday should be returned\n    schedule3 = [\n        (6, 3),\n        (6, 2),\n        (6, 2),\n        (6, 3),\n        (6, 2),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule3) == 1, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_find_most_unhappy_day()", "entry_point": "find_most_unhappy_day", "signature": "def find_most_unhappy_day(schedule) -> int:", "docstring": {"en": "Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n\nJinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day.\nThe function finds the day when her unhappiness is the greatest, which is the day when the total\nhours are the farthest above the threshold. If there are multiple days with the same level of\nmaximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the\nfunction returns 0.\n\nArgs:\nschedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the\nnumber of hours spent at school and in extra classes\nfor each day of the week, respectively.\n\nReturns:\nint: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0\nif she is never unhappy.\n\nCases:\n- If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nshe is most unhappy on Wednesday (day 3), so the function will return 3.\n- If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\nunhappy, and the function will return 0.\n- For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally\nunhappy on Monday and Thursday, but since Monday comes first, the function returns 1.", "sq": "Llogarit ditën e javës kur Jinjin është më e pakënaqur bazuar në orarin e saj.\n\nJinjin është e pakënaqur nëse orët totale të kaluara në shkollë dhe në klasa shtesë tejkalojnë 8 orë në një ditë. Funksioni gjen ditën kur pakënaqësia e saj është më e madhe, që është dita kur orët totale janë më të larta mbi pragun. Nëse ka disa ditë me të njëjtin nivel të pakënaqësisë maksimale, kthehet dita më e hershme. Nëse Jinjin nuk është e pakënaqur në asnjë ditë, funksioni kthen 0.\n\nArgumentet:\nschedule (list[tuple[int, int]]): Një listë me 7 tufa, ku çdo tufë përfaqëson\nnumrin e orëve të kaluara në shkollë dhe në klasa shtesë\npër çdo ditë të javës, respektivisht.\n\nKthen:\nint: Dita e javës kur Jinjin është më e pakënaqur (1-7 për të hënën deri të dielën) ose 0\nnëse ajo nuk është kurrë e pakënaqur.\n\nRastet:\n- Nëse Jinjin ka orarin e mëposhtëm [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\najo është më e pakënaqur të mërkurën (dita 3), kështu që funksioni do të kthejë 3.\n- Nëse orari i saj është [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin nuk është kurrë\ne pakënaqur, dhe funksioni do të kthejë 0.\n- Për një orar [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin është njësoj\ne pakënaqur të hënën dhe të enjten, por meqë e hëna vjen e para, funksioni kthen 1.", "hy": "Հաշվարկել այն շաբաթվա օրը, երբ Ջինջինը ամենից դժգոհ է իր ժամանակացույցի հիման վրա։\n\nՋինջինը դժգոհ է, եթե դպրոցում և լրացուցիչ դասերի վրա ծախսված ընդհանուր ժամերը գերազանցում են 8 ժամը մեկ օրվա ընթացքում։ Ֆունկցիան գտնում է այն օրը, երբ նրա դժգոհությունը առավելագույնն է, այսինքն՝ այն օրը, երբ ընդհանուր ժամերը ամենից շատ են գերազանցում շեմը։ Եթե կան մի քանի օրեր նույն մակարդակի առավելագույն դժգոհությամբ, վերադարձվում է ամենավաղ օրը։ Եթե Ջինջինը ոչ մի օր դժգոհ չէ, ֆունկցիան վերադարձնում է 0։\n\nԱրձագանքներ:\nschedule (list[tuple[int, int]]): 7 տուփերի ցուցակ, որտեղ յուրաքանչյուր տուփ ներկայացնում է\nդպրոցում և լրացուցիչ դասերի վրա ծախսված ժամերի քանակը\nշաբաթվա յուրաքանչյուր օրվա համար, համապատասխանաբար։\n\nՎերադարձնում է:\nint: Շաբաթվա օրը, երբ Ջինջինը ամենից դժգոհ է (1-7 երկուշաբթիից կիրակի) կամ 0,\nեթե նա երբեք դժգոհ չէ։\n\nՕրինակներ:\n- Եթե Ջինջինի ժամանակացույցը [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)] է,\nնա ամենից դժգոհ է չորեքշաբթի (օր 3), ուստի ֆունկցիան կվերադարձնի 3։\n- Եթե նրա ժամանակացույցը [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] է, Ջինջինը երբեք\nդժգոհ չէ, և ֆունկցիան կվերադարձնի 0։\n- Ժամանակացույցի համար [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Ջինջինը հավասարապես\nդժգոհ է երկուշաբթի և հինգշաբթի, բայց քանի որ երկուշաբթին առաջինն է, ֆունկցիան կվերադարձնի 1։", "bn": "জিনজিনের সময়সূচির ভিত্তিতে সপ্তাহের কোন দিনটি সে সবচেয়ে অসুখী তা নির্ণয় করুন।\n\nজিনজিন সবচেয়ে অসুখী হয় যেদিন তার স্কুল এবং অতিরিক্ত ক্লাসে ব্যয় করা মোট সময় ৮ ঘণ্টার বেশি হয়। ফাংশনটি সেই দিনটি খুঁজে বের করে যেদিন তার অসুখী হওয়ার মাত্রা সবচেয়ে বেশি, অর্থাৎ যেদিন মোট সময় সীমার উপরে সবচেয়ে বেশি। যদি একই স্তরের সর্বাধিক অসুখী হওয়ার একাধিক দিন থাকে, তাহলে সবচেয়ে প্রথম দিনটি ফেরত দেওয়া হয়। যদি কোনও দিন জিনজিন অসুখী না হয়, তাহলে ফাংশনটি 0 ফেরত দেয়।\n\nArgs:\nschedule (list[tuple[int, int]]): ৭টি টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল\nপ্রতিনিধিত্ব করে প্রতিটি সপ্তাহের দিনের জন্য স্কুল এবং অতিরিক্ত ক্লাসে\nকত ঘণ্টা ব্যয় করা হয়েছে।\n\nReturns:\nint: সপ্তাহের দিন যেদিন জিনজিন সবচেয়ে অসুখী (১-৭ সোমবার থেকে রবিবার) অথবা ০\nযদি সে কখনও অসুখী না হয়।\n\nCases:\n- যদি জিনজিনের সময়সূচি হয় [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nতাহলে সে সবচেয়ে অসুখী বুধবার (দিন ৩) এ, তাই ফাংশনটি ৩ ফেরত দেবে।\n- যদি তার সময়সূচি হয় [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], জিনজিন কখনও\nঅসুখী নয়, এবং ফাংশনটি ০ ফেরত দেবে।\n- একটি সময়সূচির জন্য [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], জিনজিন সমানভাবে\nঅসুখী সোমবার এবং বৃহস্পতিবার, কিন্তু যেহেতু সোমবার প্রথম আসে, ফাংশনটি ১ ফেরত দেবে।", "bg": "Изчислете деня от седмицата, когато Джинджин е най-нещастна въз основа на нейния график.\n\nДжинджин е нещастна, ако общият брой часове, прекарани в училище и допълнителни часове, надвишава 8 часа на ден. Функцията намира деня, когато нейното нещастие е най-голямо, което е денят, когато общият брой часове е най-далеч над прага. Ако има няколко дни с едно и също ниво на максимално нещастие, се връща най-ранният ден. Ако Джинджин не е нещастна в нито един ден, функцията връща 0.\n\nАргументи:\nschedule (list[tuple[int, int]]): Списък от 7 кортежа, където всеки кортеж представлява\nброя часове, прекарани в училище и в допълнителни часове\nза всеки ден от седмицата, съответно.\n\nВръща:\nint: Денят от седмицата, когато Джинджин е най-нещастна (1-7 за понеделник до неделя) или 0\nако тя никога не е нещастна.\n\nПримери:\n- Ако Джинджин има следния график [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nтя е най-нещастна в сряда (ден 3), така че функцията ще върне 3.\n- Ако нейният график е [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Джинджин никога не е\nнещастна и функцията ще върне 0.\n- За график [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Джинджин е еднакво\nнещастна в понеделник и четвъртък, но тъй като понеделник идва първи, функцията връща 1.", "zh": "计算Jinjin在她的日程安排中最不开心的那一天。\n\n如果Jinjin在学校和额外课程中花费的总时间超过8小时，她会感到不开心。该函数找到她最不开心的那一天，即总时间超过阈值最多的那一天。如果有多天达到相同的最大不开心程度，则返回最早的一天。如果Jinjin在任何一天都不感到不开心，函数返回0。\n\n参数：\nschedule (list[tuple[int, int]]): 一个包含7个元组的列表，每个元组分别表示\n每周每天在学校和额外课程中花费的小时数。\n\n返回：\nint: Jinjin最不开心的那一天（1-7表示周一到周日）或0如果她从未感到不开心。\n\n案例：\n- 如果Jinjin的日程安排是[(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n她在星期三（第3天）最不开心，所以函数将返回3。\n- 如果她的日程安排是[(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)]，Jinjin从未\n感到不开心，函数将返回0。\n- 对于日程安排[(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]，Jinjin在周一和周四同样\n不开心，但由于周一在前，函数返回1。", "fr": "Calculer le jour de la semaine où Jinjin est la plus malheureuse en fonction de son emploi du temps.\n\nJinjin est malheureuse si le total des heures passées à l'école et en cours supplémentaires dépasse 8 heures en une journée. La fonction trouve le jour où son malheur est le plus grand, c'est-à-dire le jour où le total des heures dépasse le plus le seuil. S'il y a plusieurs jours avec le même niveau de malheur maximal, le premier jour est retourné. Si Jinjin n'est malheureuse aucun jour, la fonction retourne 0.\n\nArgs:\nschedule (list[tuple[int, int]]): Une liste de 7 tuples, où chaque tuple représente le\nnombre d'heures passées à l'école et en cours supplémentaires\npour chaque jour de la semaine, respectivement.\n\nReturns:\nint: Le jour de la semaine où Jinjin est la plus malheureuse (1-7 pour lundi à dimanche) ou 0\nsi elle n'est jamais malheureuse.\n\nCases:\n- Si Jinjin a l'emploi du temps suivant [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nelle est la plus malheureuse le mercredi (jour 3), donc la fonction retournera 3.\n- Si son emploi du temps est [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin n'est jamais\nmalheureuse, et la fonction retournera 0.\n- Pour un emploi du temps [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin est également\nmalheureuse le lundi et le jeudi, mais comme le lundi vient en premier, la fonction retourne 1.", "de": "Berechne den Wochentag, an dem Jinjin am unglücklichsten ist, basierend auf ihrem Stundenplan.\n\nJinjin ist unglücklich, wenn die Gesamtstunden, die sie in der Schule und in zusätzlichen Kursen verbringt, an einem Tag 8 Stunden überschreiten. Die Funktion findet den Tag, an dem ihr Unglück am größten ist, was der Tag ist, an dem die Gesamtstunden am weitesten über dem Schwellenwert liegen. Wenn es mehrere Tage mit dem gleichen Maß an maximalem Unglück gibt, wird der früheste Tag zurückgegeben. Wenn Jinjin an keinem Tag unglücklich ist, gibt die Funktion 0 zurück.\n\nArgs:\nschedule (list[tuple[int, int]]): Eine Liste von 7 Tupeln, wobei jedes Tupel die Anzahl der Stunden darstellt, die in der Schule und in zusätzlichen Kursen verbracht werden, jeweils für jeden Tag der Woche.\n\nReturns:\nint: Der Wochentag, an dem Jinjin am unglücklichsten ist (1-7 für Montag bis Sonntag) oder 0, wenn sie nie unglücklich ist.\n\nFälle:\n- Wenn Jinjin den folgenden Stundenplan hat [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)], ist sie am unglücklichsten am Mittwoch (Tag 3), daher wird die Funktion 3 zurückgeben.\n- Wenn ihr Stundenplan [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] ist, ist Jinjin nie unglücklich, und die Funktion wird 0 zurückgeben.\n- Für einen Stundenplan [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] ist Jinjin gleichermaßen unglücklich am Montag und Donnerstag, aber da Montag zuerst kommt, gibt die Funktion 1 zurück.", "ha": "Lissafa ranar mako da Jinjin take mafi rashin jin daɗi bisa ga jadawalin ta.\n\nJinjin tana cikin rashin jin daɗi idan jimillar awanni da aka kashe a makaranta da ƙarin aji sun wuce awanni 8 a rana. Aikin yana gano ranar da rashin jin daɗinta ya fi tsanani, wato ranar da jimillar awanni suka fi nisa daga matakin. Idan akwai ranaku da yawa da suke da irin wannan matakin na rashin jin daɗi, ranar farko za a dawo da ita. Idan Jinjin ba ta cikin rashin jin daɗi a kowace rana, aikin yana dawo da 0.\n\nArgs:\nschedule (list[tuple[int, int]]): Jerin tuples guda 7, inda kowanne tuple ke wakiltar\nyawan awanni da aka kashe a makaranta da kuma a ƙarin aji\ndon kowace rana ta mako, bi da bi.\n\nReturns:\nint: Ranar mako inda Jinjin ta fi rashin jin daɗi (1-7 don Litinin zuwa Lahadi) ko 0\nidan ba ta taɓa rashin jin daɗi ba.\n\nCases:\n- Idan Jinjin tana da jadawalin mai zuwa [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nta fi rashin jin daɗi a ranar Laraba (rana ta 3), don haka aikin zai dawo da 3.\n- Idan jadawalinta shi ne [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin ba ta taɓa\nrashin jin daɗi ba, kuma aikin zai dawo da 0.\n- Don jadawalin [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin tana da\nrashin jin daɗi iri ɗaya a ranar Litinin da Alhamis, amma tun da Litinin ta fara zuwa, aikin zai dawo da 1.", "hi": "सप्ताह के उस दिन की गणना करें जब जिनजिन अपने कार्यक्रम के आधार पर सबसे अधिक दुखी होती है।\n\nजिनजिन तब दुखी होती है जब स्कूल और अतिरिक्त कक्षाओं में बिताए गए कुल घंटे एक दिन में 8 घंटे से अधिक होते हैं। यह फ़ंक्शन उस दिन को खोजता है जब उसकी उदासी सबसे अधिक होती है, जो वह दिन होता है जब कुल घंटे सीमा से सबसे अधिक ऊपर होते हैं। यदि अधिकतम उदासी के समान स्तर वाले कई दिन हैं, तो सबसे पहला दिन लौटाया जाता है। यदि जिनजिन किसी भी दिन दुखी नहीं है, तो फ़ंक्शन 0 लौटाता है।\n\nआर्ग्स:\nschedule (list[tuple[int, int]]): 7 ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल क्रमशः सप्ताह के प्रत्येक दिन के लिए स्कूल और अतिरिक्त कक्षाओं में बिताए गए घंटों की संख्या का प्रतिनिधित्व करता है।\n\nरिटर्न्स:\nint: सप्ताह का वह दिन जब जिनजिन सबसे अधिक दुखी होती है (सोमवार से रविवार के लिए 1-7) या 0 यदि वह कभी दुखी नहीं होती।\n\nमामले:\n- यदि जिनजिन का कार्यक्रम निम्नलिखित है [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)], तो वह बुधवार (दिन 3) को सबसे अधिक दुखी होती है, इसलिए फ़ंक्शन 3 लौटाएगा।\n- यदि उसका कार्यक्रम [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] है, तो जिनजिन कभी दुखी नहीं होती, और फ़ंक्शन 0 लौटाएगा।\n- एक कार्यक्रम [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] के लिए, जिनजिन सोमवार और गुरुवार को समान रूप से दुखी होती है, लेकिन चूंकि सोमवार पहले आता है, इसलिए फ़ंक्शन 1 लौटाएगा।", "hu": "Számítsuk ki, hogy Jinjin melyik napon a legboldogtalanabb a beosztása alapján.\n\nJinjin boldogtalan, ha az iskolában és a különórákon töltött összes órák száma meghaladja a napi 8 órát. A függvény megkeresi azt a napot, amikor a boldogtalansága a legnagyobb, vagyis azt a napot, amikor az összóraszám a legjobban meghaladja a küszöböt. Ha több nap is azonos szintű maximális boldogtalansággal bír, akkor a legkorábbi napot adja vissza. Ha Jinjin egyetlen napon sem boldogtalan, a függvény 0-t ad vissza.\n\nArgs:\nschedule (list[tuple[int, int]]): Egy 7 elemből álló lista, ahol minden egyes elem egy\npár, amely az iskolában és a különórákon töltött órák számát\nképviseli a hét minden napjára vonatkozóan.\n\nReturns:\nint: A hét azon napja, amikor Jinjin a legboldogtalanabb (1-7 hétfőtől vasárnapig) vagy 0,\nha soha nem boldogtalan.\n\nEsetek:\n- Ha Jinjin beosztása a következő: [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nakkor szerdán (3. nap) a legboldogtalanabb, így a függvény 3-at ad vissza.\n- Ha a beosztása [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin soha nem\nboldogtalan, és a függvény 0-t ad vissza.\n- Egy beosztás esetén [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin egyformán\nboldogtalan hétfőn és csütörtökön, de mivel hétfő az első, a függvény 1-et ad vissza.", "es": "Calcular el día de la semana cuando Jinjin está más infeliz según su horario.\n\nJinjin está infeliz si el total de horas pasadas en la escuela y clases extra excede 8 horas en un día. La función encuentra el día cuando su infelicidad es mayor, que es el día cuando el total de horas está más por encima del umbral. Si hay múltiples días con el mismo nivel de máxima infelicidad, se devuelve el primer día. Si Jinjin no está infeliz en ningún día, la función devuelve 0.\n\nArgumentos:\nschedule (list[tuple[int, int]]): Una lista de 7 tuplas, donde cada tupla representa el\nnúmero de horas pasadas en la escuela y en clases extra\npara cada día de la semana, respectivamente.\n\nDevuelve:\nint: El día de la semana cuando Jinjin está más infeliz (1-7 para lunes a domingo) o 0\nsi nunca está infeliz.\n\nCases:\n- Si Jinjin tiene el siguiente horario [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nestá más infeliz el miércoles (día 3), por lo que la función devolverá 3.\n- Si su horario es [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin nunca está\ninfeliz, y la función devolverá 0.\n- Para un horario [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin está igualmente\ninfeliz el lunes y el jueves, pero como el lunes viene primero, la función devuelve 1.", "arb": "احسب اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة بناءً على جدولها.\n\nجينجين تكون غير سعيدة إذا تجاوز إجمالي الساعات التي تقضيها في المدرسة والدروس الإضافية 8 ساعات في اليوم. تقوم الدالة بالعثور على اليوم الذي تكون فيه تعاستها هي الأكبر، وهو اليوم الذي يكون فيه إجمالي الساعات هو الأبعد عن الحد الأدنى. إذا كان هناك عدة أيام بنفس مستوى التعاسة القصوى، يتم إرجاع اليوم الأسبق. إذا لم تكن جينجين غير سعيدة في أي يوم، تُرجع الدالة 0.\n\nيعيدالحجج:\nschedule (list[tuple[int, int]]): قائمة من 7 مجموعات، حيث تمثل كل مجموعة عدد الساعات التي تقضيها في المدرسة وفي الدروس الإضافية لكل يوم من أيام الأسبوع، على التوالي.\n\nيعيد:\nint: اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة (1-7 من الاثنين إلى الأحد) أو 0 إذا لم تكن غير سعيدة أبدًا.\n\nCases:\n- إذا كان لدى جينجين الجدول الزمني التالي [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)]، فهي تكون الأكثر تعاسة في يوم الأربعاء (اليوم 3)، لذا ستعيد الدالة 3.\n- إذا كان جدولها [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)]، فإن جينجين ليست غير سعيدة أبدًا، وستعيد الدالة 0.\n- بالنسبة لجدول [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]، فإن جينجين تكون غير سعيدة بالتساوي في يوم الاثنين والخميس، ولكن بما أن يوم الاثنين يأتي أولاً، فإن الدالة تعيد 1.", "sw": "Hesabu siku ya wiki ambayo Jinjin ana huzuni zaidi kulingana na ratiba yake.\n\nJinjin ana huzuni ikiwa jumla ya masaa yaliyotumika shuleni na madarasa ya ziada yanazidi masaa 8 kwa siku. Kazi hii inapata siku ambayo huzuni yake ni kubwa zaidi, ambayo ni siku ambapo jumla ya masaa ni mengi zaidi juu ya kizingiti. Ikiwa kuna siku nyingi zenye kiwango sawa cha huzuni kubwa, siku ya mapema zaidi inarejeshwa. Ikiwa Jinjin hana huzuni siku yoyote, kazi inarejesha 0.\n\nHoja:\nschedule (list[tuple[int, int]]): Orodha ya jozi 7, ambapo kila jozi inawakilisha\nidadi ya masaa yaliyotumika shuleni na katika madarasa ya ziada\nkwa kila siku ya wiki, mtawalia.\n\nInarejesha:\nint: Siku ya wiki ambayo Jinjin ana huzuni zaidi (1-7 kwa Jumatatu hadi Jumapili) au 0\nikiwa hana huzuni kamwe.\n\nCases:\n- Ikiwa Jinjin ana ratiba ifuatayo [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nana huzuni zaidi siku ya Jumatano (siku ya 3), hivyo kazi itarejesha 3.\n- Ikiwa ratiba yake ni [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin hana\nhuzuni kamwe, na kazi itarejesha 0.\n- Kwa ratiba [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin ana huzuni sawa\nsiku ya Jumatatu na Alhamisi, lakini kwa kuwa Jumatatu inakuja kwanza, kazi inarejesha 1.", "tr": "Jinjin'in programına göre en mutsuz olduğu haftanın gününü hesaplayın.\n\nJinjin, bir gün içinde okulda ve ek derslerde geçirilen toplam saatler 8 saati aşarsa mutsuz olur. Fonksiyon, mutsuzluğunun en fazla olduğu günü bulur; bu, toplam saatlerin eşik değerin en çok üzerinde olduğu gündür. Eğer aynı seviyede maksimum mutsuzluk olan birden fazla gün varsa, en erken gün döndürülür. Jinjin hiçbir gün mutsuz değilse, fonksiyon 0 döndürür.\n\nArgümanlar:\nschedule (list[tuple[int, int]]): Her bir demetin haftanın her günü için okulda ve ek derslerde geçirilen saatleri temsil ettiği 7 demetlik bir liste.\n\nDöndürür:\nint: Jinjin'in en mutsuz olduğu haftanın günü (Pazartesi için 1, Pazar için 7) veya hiç mutsuz değilse 0.\n\nCases:\n- Eğer Jinjin'in programı [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)] şeklindeyse, Çarşamba günü (gün 3) en mutsuz olduğu gündür, bu yüzden fonksiyon 3 döndürecektir.\n- Eğer programı [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] şeklindeyse, Jinjin hiçbir zaman mutsuz değildir ve fonksiyon 0 döndürecektir.\n- [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] programı için, Jinjin Pazartesi ve Perşembe günleri eşit derecede mutsuzdur, ancak Pazartesi ilk geldiği için fonksiyon 1 döndürecektir.", "vi": "Tính toán ngày trong tuần khi Jinjin cảm thấy không vui nhất dựa trên lịch trình của cô ấy.\n\nJinjin cảm thấy không vui nếu tổng số giờ dành cho trường học và các lớp học thêm vượt quá 8 giờ trong một ngày. Hàm này tìm ngày mà sự không vui của cô ấy là lớn nhất, đó là ngày mà tổng số giờ vượt ngưỡng nhiều nhất. Nếu có nhiều ngày có mức độ không vui tối đa giống nhau, ngày sớm nhất sẽ được trả về. Nếu Jinjin không cảm thấy không vui vào bất kỳ ngày nào, hàm sẽ trả về 0.\n\nTham số:\nschedule (list[tuple[int, int]]): Một danh sách gồm 7 bộ giá trị, trong đó mỗi bộ giá trị đại diện cho\nsố giờ dành cho trường học và các lớp học thêm\ncho mỗi ngày trong tuần, tương ứng.\n\nTrả về:\nint: Ngày trong tuần khi Jinjin cảm thấy không vui nhất (1-7 cho Thứ Hai đến Chủ Nhật) hoặc 0\nnếu cô ấy không bao giờ cảm thấy không vui.\n\nCases:\n- Nếu Jinjin có lịch trình sau [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\ncô ấy cảm thấy không vui nhất vào Thứ Tư (ngày 3), vì vậy hàm sẽ trả về 3.\n- Nếu lịch trình của cô ấy là [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin không bao giờ\ncảm thấy không vui, và hàm sẽ trả về 0.\n- Đối với lịch trình [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin cảm thấy không vui\nnhư nhau vào Thứ Hai và Thứ Năm, nhưng vì Thứ Hai đến trước, hàm sẽ trả về 1.", "id": "Hitung hari dalam seminggu ketika Jinjin paling tidak bahagia berdasarkan jadwalnya.\n\nJinjin tidak bahagia jika total jam yang dihabiskan di sekolah dan kelas tambahan melebihi 8 jam dalam sehari. Fungsi ini menemukan hari ketika ketidakbahagiaannya adalah yang terbesar, yaitu hari ketika total jam paling jauh di atas ambang batas. Jika ada beberapa hari dengan tingkat ketidakbahagiaan maksimum yang sama, hari paling awal yang dikembalikan. Jika Jinjin tidak bahagia pada hari apa pun, fungsi mengembalikan 0.\n\nArgs:\nschedule (list[tuple[int, int]]): Daftar 7 tuple, di mana setiap tuple mewakili\njumlah jam yang dihabiskan di sekolah dan di kelas tambahan\nuntuk setiap hari dalam seminggu, masing-masing.\n\nReturns:\nint: Hari dalam seminggu ketika Jinjin paling tidak bahagia (1-7 untuk Senin hingga Minggu) atau 0\njika dia tidak pernah tidak bahagia.\n\nCases:\n- Jika Jinjin memiliki jadwal berikut [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\ndia paling tidak bahagia pada hari Rabu (hari ke-3), jadi fungsi akan mengembalikan 3.\n- Jika jadwalnya adalah [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin tidak pernah\ntidak bahagia, dan fungsi akan mengembalikan 0.\n- Untuk jadwal [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin sama-sama\ntidak bahagia pada hari Senin dan Kamis, tetapi karena hari Senin datang lebih dulu, fungsi mengembalikan 1.", "ja": "ジンジンがスケジュールに基づいて最も不幸な曜日を計算します。\n\nジンジンは、学校と追加授業に費やす合計時間が1日で8時間を超えると不幸になります。この関数は、彼女の不幸が最も大きい日、つまり合計時間が閾値を最も超える日を見つけます。最大の不幸のレベルが同じ複数の日がある場合は、最も早い日が返されます。ジンジンがどの日にも不幸でない場合、関数は0を返します。\n\n引数:\nschedule (list[tuple[int, int]]): 7つのタプルのリストで、それぞれのタプルは\n週の各曜日における学校と追加授業に費やした時間を表します。\n\n戻り値:\nint: ジンジンが最も不幸な曜日 (月曜日から日曜日を1-7で表す) または彼女が決して不幸でない場合は0。\n\nケース:\n- ジンジンが次のスケジュール [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)] を持っている場合、彼女は水曜日 (3日目) に最も不幸なので、関数は3を返します。\n- 彼女のスケジュールが [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] の場合、ジンジンは決して不幸ではなく、関数は0を返します。\n- スケジュールが [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] の場合、ジンジンは月曜日と木曜日に同じように不幸ですが、月曜日が先に来るので、関数は1を返します。", "ko": "Jinjin의 일정에 따라 가장 불행한 요일을 계산합니다.\n\nJinjin은 학교와 추가 수업에 보낸 총 시간이 하루에 8시간을 초과하면 불행합니다. 이 함수는 그녀의 불행이 가장 큰 날, 즉 총 시간이 임계값을 가장 많이 초과하는 날을 찾습니다. 최대 불행 수준이 같은 여러 날이 있는 경우 가장 빠른 날이 반환됩니다. Jinjin이 어느 날에도 불행하지 않으면 함수는 0을 반환합니다.\n\nArgs:\nschedule (list[tuple[int, int]]): 각 튜플이 각각 주중 하루 동안 학교와 추가 수업에 보낸 시간을 나타내는 7개의 튜플 목록입니다.\n\nReturns:\nint: Jinjin이 가장 불행한 요일 (월요일부터 일요일까지 1-7) 또는 그녀가 전혀 불행하지 않으면 0을 반환합니다.\n\nCases:\n- Jinjin이 다음과 같은 일정 [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)]을 가지고 있다면, 그녀는 수요일(3일째)에 가장 불행하므로 함수는 3을 반환합니다.\n- 그녀의 일정이 [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)]인 경우, Jinjin은 전혀 불행하지 않으며 함수는 0을 반환합니다.\n- 일정이 [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]인 경우, Jinjin은 월요일과 목요일에 똑같이 불행하지만 월요일이 먼저 오므로 함수는 1을 반환합니다.", "ml": "ജിൻജിൻ ഏറ്റവും അസന്തുഷ്ടയാകുന്ന ആഴ്ചയിലെ ദിവസം അവളുടെ ഷെഡ്യൂളിനെ അടിസ്ഥാനമാക്കി കണക്കാക്കുക.\n\nഒരു ദിവസത്തിൽ സ്കൂളിലും അധിക ക്ലാസ്സുകളിലും ചെലവഴിക്കുന്ന ആകെ മണിക്കൂറുകൾ 8 മണിക്കൂറുകൾക്കു മുകളിൽ ആണെങ്കിൽ ജിൻജിൻ അസന്തുഷ്ടയാണ്. ആകെ മണിക്കൂറുകൾ പരിധിയേക്കാൾ ഏറ്റവും കൂടുതലായിരിക്കുന്ന ദിവസം, അതായത് അവളുടെ അസന്തോഷം ഏറ്റവും കൂടുതലായിരിക്കുന്ന ദിവസം ഈ ഫംഗ്ഷൻ കണ്ടെത്തുന്നു. ഒരേ തോതിലുള്ള പരമാവധി അസന്തോഷമുള്ള നിരവധി ദിവസങ്ങൾ ഉണ്ടെങ്കിൽ, ആദ്യത്തെ ദിവസം തിരികെ നൽകുന്നു. ജിൻജിൻ ഏതെങ്കിലും ദിവസവും അസന്തുഷ്ടയല്ലെങ്കിൽ, ഫംഗ്ഷൻ 0 തിരികെ നൽകുന്നു.\n\nആർഗ്സ്:\nschedule (list[tuple[int, int]]): 7 ട്യൂപ്പിളുകളുടെ ഒരു ലിസ്റ്റ്, ഓരോ ട്യൂപ്പിളും ഓരോ ദിവസവും സ്കൂളിലും അധിക ക്ലാസ്സുകളിലും ചെലവഴിക്കുന്ന\nമണിക്കൂറുകളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്നു.\n\nറിട്ടേൺസ്:\nint: ജിൻജിൻ ഏറ്റവും അസന്തുഷ്ടയായ ആഴ്ചയിലെ ദിവസം (തിങ്കളാഴ്ച മുതൽ ഞായറാഴ്ച വരെ 1-7) അല്ലെങ്കിൽ അവൾ ഒരിക്കലും അസന്തുഷ്ടയല്ലെങ്കിൽ 0.\n\nകേസുകൾ:\n- ജിൻജിൻക്ക് [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)] എന്ന ഷെഡ്യൂൾ ഉണ്ടെങ്കിൽ, അവൾ ബുധനാഴ്ച (ദിവസം 3) ഏറ്റവും അസന്തുഷ്ടയാണ്, അതിനാൽ ഫംഗ്ഷൻ 3 തിരികെ നൽകും.\n- അവളുടെ ഷെഡ്യൂൾ [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] ആണെങ്കിൽ, ജിൻജിൻ ഒരിക്കലും അസന്തുഷ്ടയല്ല, ഫംഗ്ഷൻ 0 തിരികെ നൽകും.\n- [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] എന്ന ഷെഡ്യൂളിനായി, ജിൻജിൻ തിങ്കളാഴ്ചയും വ്യാഴാഴ്ചയും ഒരുപോലെ അസന്തുഷ്ടയാണ്, പക്ഷേ തിങ്കളാഴ്ച ആദ്യം വരുന്നതുകൊണ്ട്, ഫംഗ്ഷൻ 1 തിരികെ നൽകുന്നു.", "fa": "محاسبه کنید که جینجین در کدام روز هفته بر اساس برنامه‌اش بیشترین ناراحتی را دارد.\n\nجینجین ناراحت است اگر مجموع ساعات صرف شده در مدرسه و کلاس‌های اضافی در یک روز بیش از 8 ساعت باشد.\nتابع روزی را پیدا می‌کند که ناراحتی او بیشترین است، یعنی روزی که مجموع\nساعات بیشترین فاصله را از حد آستانه دارد. اگر چندین روز با همان سطح\nحداکثر ناراحتی وجود داشته باشد، اولین روز برگردانده می‌شود. اگر جینجین در هیچ روزی ناراحت نباشد،\nتابع 0 را برمی‌گرداند.\n\nآرگومان‌ها:\nschedule (list[tuple[int, int]]): لیستی از 7 تاپل، که هر تاپل نشان‌دهنده\nتعداد ساعات صرف شده در مدرسه و کلاس‌های اضافی\nبرای هر روز هفته به ترتیب است.\n\nبازگشت:\nint: روز هفته که جینجین بیشترین ناراحتی را دارد (1-7 برای دوشنبه تا یکشنبه) یا 0\nاگر او هرگز ناراحت نباشد.\n\nموارد:\n- اگر جینجین برنامه زیر را داشته باشد [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nاو در روز چهارشنبه (روز 3) بیشترین ناراحتی را دارد، بنابراین تابع 3 را برمی‌گرداند.\n- اگر برنامه او [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] باشد، جینجین هرگز\nناراحت نیست و تابع 0 را برمی‌گرداند.\n- برای برنامه [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]، جینجین به طور مساوی\nدر روز دوشنبه و پنج‌شنبه ناراحت است، اما از آنجا که دوشنبه اول می‌آید، تابع 1 را برمی‌گرداند."}}
{"task_id": "Python/43", "prompt": {"en": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "sq": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transformon permutacionin hyrës në permutacionin e radhës në rend leksikografik.\n    \n    Funksioni gjen numrin e parë nga fundi që është më i vogël se numri që e ndjek \n    dhe e shkëmben atë me numrin më të vogël që është më i madh dhe vjen pas tij. Pastaj kthen \n    rendin e numrave pas numrit të parë origjinal më të vogël. Nëse hyrja është permutacioni i fundit \n    (në rend zbritës), funksioni kthen False, duke treguar se asnjë permutacion i radhës nuk është i mundur.\n    \n    Args:\n    perm (list): Një listë e numrave të plotë që përfaqëson permutacionin aktual.\n    \n    Returns:\n    bool: True nëse permutacioni u transformua me sukses, False nëse ishte permutacioni i fundit.\n    \n    Shembuj:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "hy": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Փոխակերպում է մուտքային փոխադրությունը հաջորդ փոխադրության դեպի բառարանային կարգով:\n    \n    Ֆունկցիան գտնում է առաջին թիվը վերջից, որը փոքր է իրեն հաջորդող թվից և փոխանակում է այն \n    ամենափոքր թվի հետ, որը մեծ է և գտնվում է դրանից հետո: Այնուհետև այն շրջում է թվերի \n    կարգը սկզբնական առաջին փոքր թվից հետո: Եթե մուտքը վերջին փոխադրությունն է (նվազող կարգով), \n    ֆունկցիան վերադարձնում է False, ցույց տալով, որ հաջորդ փոխադրությունը հնարավոր չէ:\n    \n    Պարամետրեր:\n    perm (list): Ցուցակ ամբողջ թվերի, որը ներկայացնում է ընթացիկ փոխադրությունը:\n    \n    Վերադարձնում է:\n    bool: True, եթե փոխադրությունը հաջողությամբ փոխակերպվել է, False, եթե դա վերջին փոխադրությունն էր:\n    \n    Օրինակներ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "bn": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    ইনপুট পারমুটেশনকে লেক্সিকোগ্রাফিক ক্রমে পরবর্তী পারমুটেশনে রূপান্তর করে।\n\n    ফাংশনটি শেষ থেকে প্রথম সংখ্যাটি খুঁজে পায় যা তার পরবর্তী সংখ্যার থেকে ছোট \n    এবং এটি এমন একটি ছোট সংখ্যার সাথে অদলবদল করে যা বড় এবং এর পরে আসে। তারপর এটি \n    মূল প্রথম ছোট সংখ্যার পরে সংখ্যাগুলির ক্রম উল্টে দেয়। যদি ইনপুটটি শেষ পারমুটেশন হয় \n    (অবতরণ ক্রমে), ফাংশনটি False ফেরত দেয়, যা নির্দেশ করে যে কোনও পরবর্তী পারমুটেশন সম্ভব নয়।\n\n    Args:\n    perm (list): বর্তমান পারমুটেশন উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    Returns:\n    bool: যদি পারমুটেশন সফলভাবে রূপান্তরিত হয় তবে True, যদি এটি শেষ পারমুটেশন হয় তবে False।\n\n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "bg": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Преобразува входната пермутация в следващата пермутация в лексикографски ред.\n    \n    Функцията намира първото число от края, което е по-малко от следващото число \n    и го разменя с най-малкото число, което е по-голямо и идва след него. След това обръща \n    реда на числата след оригиналното първо по-малко число. Ако входът е последната пермутация \n    (в низходящ ред), функцията връща False, което показва, че няма възможна следваща пермутация.\n    \n    Аргументи:\n    perm (list): Списък от цели числа, представляващи текущата пермутация.\n    \n    Връща:\n    bool: True ако пермутацията беше успешно преобразувана, False ако беше последната пермутация.\n    \n    Примери:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "zh": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    将输入的排列转换为字典序中的下一个排列。\n    \n    该函数从末尾开始找到第一个小于其后面数字的数字，并将其与后面比它大的最小数字交换。\n    然后反转原始第一个较小数字之后的数字顺序。如果输入是最后一个排列（降序排列），\n    函数返回False，表示没有下一个排列。\n    \n    参数:\n    perm (list): 一个整数列表，表示当前排列。\n    \n    返回:\n    bool: 如果排列成功转换，返回True；如果是最后一个排列，返回False。\n    \n    示例:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "fr": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforme la permutation d'entrée en la permutation suivante dans l'ordre lexicographique.\n    \n    La fonction trouve le premier nombre depuis la fin qui est plus petit que le nombre qui le suit \n    et l'échange avec le plus petit nombre qui est plus grand et vient après lui. Ensuite, elle inverse \n    l'ordre des nombres après le premier nombre plus petit d'origine. Si l'entrée est la dernière permutation \n    (dans l'ordre décroissant), la fonction retourne False, indiquant qu'aucune permutation suivante n'est possible.\n    \n    Args:\n    perm (list): Une liste d'entiers représentant la permutation actuelle.\n    \n    Returns:\n    bool: True si la permutation a été transformée avec succès, False si c'était la dernière permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "de": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transformiert die Eingabepermutation in die nächste Permutation in lexikographischer Reihenfolge.\n    \n    Die Funktion findet die erste Zahl von hinten, die kleiner ist als die folgende Zahl, \n    und tauscht sie mit der kleinsten Zahl, die größer ist und danach kommt. Dann kehrt sie die \n    Reihenfolge der Zahlen nach der ursprünglichen ersten kleineren Zahl um. Wenn die Eingabe die \n    letzte Permutation ist (in absteigender Reihenfolge), gibt die Funktion False zurück, was \n    anzeigt, dass keine nächste Permutation möglich ist.\n    \n    Argumente:\n    perm (list): Eine Liste von ganzen Zahlen, die die aktuelle Permutation darstellt.\n    \n    Rückgabewerte:\n    bool: True, wenn die Permutation erfolgreich transformiert wurde, False, wenn es die letzte Permutation war.\n    \n    Beispiele:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "ha": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Canza shigarwar permutation zuwa permutation na gaba a cikin tsari na lexicographic.\n    \n    Aikin yana nemo lambar farko daga ƙarshe wadda ta fi ƙarami fiye da lambar da ke biyo baya \n    kuma yana musanya ta da mafi ƙarancin lamba wadda ta fi girma kuma ta zo bayan ta. Sannan yana jujjuya \n    tsarin lambobin bayan asalin lambar farko mafi ƙarami. Idan shigarwar ita ce permutation na ƙarshe \n    (a cikin tsari mai saukarwa), aikin yana dawowa da False, yana nuna babu wani permutation na gaba da zai yiwu.\n    \n    Args:\n    perm (list): Jerin lambobi masu wakiltar permutation na yanzu.\n    \n    Returns:\n    bool: True idan an yi nasarar canza permutation, False idan ita ce permutation na ƙarshe.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "hi": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    इनपुट क्रमचय को लेक्सिकोग्राफिक क्रम में अगले क्रमचय में बदलता है।\n    \n    यह फ़ंक्शन अंत से पहला ऐसा नंबर ढूंढता है जो उसके बाद आने वाले नंबर से छोटा होता है \n    और उसे सबसे छोटे नंबर से बदलता है जो बड़ा होता है और उसके बाद आता है। फिर यह \n    मूल पहले छोटे नंबर के बाद के नंबरों के क्रम को उलट देता है। यदि इनपुट अंतिम क्रमचय \n    (अवरोही क्रम में) है, तो फ़ंक्शन False लौटाता है, जो इंगित करता है कि कोई अगला क्रमचय संभव नहीं है।\n    \n    Args:\n    perm (list): पूर्णांकों की एक सूची जो वर्तमान क्रमचय का प्रतिनिधित्व करती है।\n    \n    Returns:\n    bool: True यदि क्रमचय को सफलतापूर्वक बदला गया, False यदि यह अंतिम क्रमचय था।\n    \n    उदाहरण:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "hu": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Az input permutációt átalakítja a következő permutációvá lexikografikus sorrendben.\n    \n    A függvény megkeresi az első számot a végéről, amely kisebb, mint az utána következő szám, \n    és kicseréli a legkisebb, nála nagyobb számmal, amely utána következik. Ezután megfordítja \n    az eredeti első kisebb szám utáni számok sorrendjét. Ha az input a legutolsó permutáció \n    (csökkenő sorrendben), a függvény False értéket ad vissza, jelezve, hogy nincs következő permutáció.\n    \n    Args:\n    perm (list): Egész számokat tartalmazó lista, amely a jelenlegi permutációt képviseli.\n    \n    Returns:\n    bool: True, ha a permutációt sikeresen átalakították, False, ha ez volt az utolsó permutáció.\n    \n    Példák:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "es": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforma la permutación de entrada en la siguiente permutación en orden lexicográfico.\n    \n    La función encuentra el primer número desde el final que es más pequeño que el número que le sigue \n    y lo intercambia con el número más pequeño que es mayor y viene después de él. Luego invierte el \n    orden de los números después del primer número más pequeño original. Si la entrada es la última permutación \n    (en orden descendente), la función devuelve False, indicando que no es posible una siguiente permutación.\n    \n    Argumentos:\n    perm (list): Una lista de enteros que representa la permutación actual.\n    \n    Devuelve:\n    bool: True si la permutación fue transformada con éxito, False si era la última permutación.\n    \n    Ejemplos:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "arb": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    يحول ترتيب الإدخال إلى الترتيب التالي في الترتيب المعجمي.\n    \n    تجد الدالة أول رقم من النهاية يكون أصغر من الرقم الذي يليه \n    وتقوم بتبديله مع أصغر رقم يكون أكبر ويأتي بعده. ثم تعكس \n    ترتيب الأرقام بعد الرقم الأصغر الأصلي. إذا كان الإدخال هو الترتيب الأخير \n    (في ترتيب تنازلي)، فإن الدالة تعيد False، مما يشير إلى عدم إمكانية وجود ترتيب تالي.\n    \n    يعيدالحجج:\n    perm (list): قائمة من الأعداد الصحيحة تمثل الترتيب الحالي.\n    \n    يعيد:\n    bool: True إذا تم تحويل الترتيب بنجاح، False إذا كان الترتيب الأخير.\n    \n    أمثلة:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "sw": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Hubadilisha mpangilio wa pembejeo kuwa mpangilio unaofuata katika mpangilio wa lexicographic.\n    \n    Kazi hii inapata namba ya kwanza kutoka mwisho ambayo ni ndogo kuliko namba inayofuata \n    na kubadilisha na namba ndogo zaidi ambayo ni kubwa na inakuja baada yake. Kisha inageuza \n    mpangilio wa namba baada ya namba ya kwanza ndogo ya awali. Ikiwa pembejeo ni mpangilio wa mwisho \n    (katika mpangilio wa kushuka), kazi inarudisha False, ikionyesha hakuna mpangilio unaofuata unaowezekana.\n    \n    Hoja:\n    perm (list): Orodha ya namba nzima inayowakilisha mpangilio wa sasa.\n    \n    Inarejesha:\n    bool: True ikiwa mpangilio umebadilishwa kwa mafanikio, False ikiwa ulikuwa mpangilio wa mwisho.\n    \n    Mifano:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "tr": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Girdi olarak verilen permütasyonu sözlük sırasındaki bir sonraki permütasyona dönüştürür.\n    \n    Fonksiyon, sondan başlayarak kendisinden sonra gelen sayıdan daha küçük olan ilk sayıyı bulur \n    ve bunu, kendisinden sonra gelen ve daha büyük olan en küçük sayıyla değiştirir. Ardından, \n    orijinal olarak ilk daha küçük sayıdan sonraki sayıların sırasını tersine çevirir. Eğer girdi \n    son permütasyon ise (azalan sırada), fonksiyon False döndürür, bu da bir sonraki permütasyonun \n    mümkün olmadığını belirtir.\n    \n    Argümanlar:\n    perm (list): Mevcut permütasyonu temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    bool: Permütasyon başarıyla dönüştürüldüyse True, son permütasyon ise False döner.\n    \n    Örnekler:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "vi": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Chuyển đổi hoán vị đầu vào thành hoán vị tiếp theo theo thứ tự từ điển.\n    \n    Hàm tìm số đầu tiên từ cuối mà nhỏ hơn số theo sau nó và hoán đổi nó với số nhỏ nhất \n    mà lớn hơn và xuất hiện sau nó. Sau đó, nó đảo ngược thứ tự của các số sau số nhỏ hơn \n    ban đầu. Nếu đầu vào là hoán vị cuối cùng (theo thứ tự giảm dần), hàm trả về False, \n    chỉ ra rằng không có hoán vị tiếp theo nào khả thi.\n    \n    Tham số:\n    perm (list): Một danh sách các số nguyên đại diện cho hoán vị hiện tại.\n    \n    Trả về:\n    bool: True nếu hoán vị đã được chuyển đổi thành công, False nếu đó là hoán vị cuối cùng.\n    \n    Ví dụ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "id": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Mengubah permutasi input ke permutasi berikutnya dalam urutan leksikografis.\n    \n    Fungsi ini menemukan angka pertama dari akhir yang lebih kecil dari angka yang mengikutinya \n    dan menukarnya dengan angka terkecil yang lebih besar dan datang setelahnya. Kemudian membalikkan \n    urutan angka setelah angka pertama yang lebih kecil yang asli. Jika input adalah permutasi terakhir \n    (dalam urutan menurun), fungsi mengembalikan False, menunjukkan tidak ada permutasi berikutnya yang mungkin.\n    \n    Args:\n    perm (list): Daftar bilangan bulat yang mewakili permutasi saat ini.\n    \n    Returns:\n    bool: True jika permutasi berhasil diubah, False jika itu adalah permutasi terakhir.\n    \n    Contoh:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "ja": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    入力された順列を辞書式順序で次の順列に変換します。\n    \n    関数は、末尾から始めて、次の数より小さい最初の数を見つけ、それをその後に来るより大きい最小の数と交換します。\n    その後、元の最初の小さい数の後の数の順序を逆にします。入力が最後の順列（降順）の場合、関数はFalseを返し、\n    次の順列が不可能であることを示します。\n    \n    引数:\n    perm (list): 現在の順列を表す整数のリスト。\n    \n    戻り値:\n    bool: 順列が正常に変換された場合はTrue、最後の順列だった場合はFalse。\n    \n    例:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "ko": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    입력된 순열을 사전식 순서의 다음 순열로 변환합니다.\n    \n    함수는 끝에서부터 시작하여 자신보다 다음 숫자가 더 큰 첫 번째 숫자를 찾고, \n    그 숫자와 그 뒤에 있는 숫자 중 가장 작은 숫자와 교환합니다. 그런 다음 원래의 \n    첫 번째 작은 숫자 이후의 숫자들의 순서를 반대로 바꿉니다. 입력이 마지막 순열 \n    (내림차순)인 경우, 함수는 다음 순열이 불가능함을 나타내는 False를 반환합니다.\n    \n    매개변수:\n    perm (list): 현재 순열을 나타내는 정수 리스트.\n    \n    반환값:\n    bool: 순열이 성공적으로 변환되면 True, 마지막 순열이면 False.\n    \n    예시:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "ml": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    ഇൻപുട്ട് പെർമ്യൂട്ടേഷൻ ലെക്സികോഗ്രാഫിക് ക്രമത്തിൽ അടുത്ത പെർമ്യൂട്ടേഷനിലേക്ക് മാറ്റുന്നു.\n    \n    ഫംഗ്ഷൻ അവസാനത്തിൽ നിന്ന് ആദ്യ നമ്പർ കണ്ടെത്തി, അത് പിന്തുടരുന്ന നമ്പറിനേക്കാൾ ചെറുതാണ് \n    എന്നതും, അതിനേക്കാൾ വലുതും അതിന് ശേഷം വരുന്ന ഏറ്റവും ചെറിയ നമ്പറുമായി അത് മാറ്റിസ്ഥാപിക്കുന്നു. \n    തുടർന്ന്, യഥാർത്ഥ ആദ്യത്തെ ചെറിയ നമ്പറിന് ശേഷം നമ്പറുകളുടെ ക്രമം മറിച്ചുവയ്ക്കുന്നു. \n    ഇൻപുട്ട് അവസാനത്തെ പെർമ്യൂട്ടേഷൻ (ഇറക്കം ക്രമത്തിൽ) ആണെങ്കിൽ, ഫംഗ്ഷൻ False മടക്കുന്നു, \n    അടുത്ത പെർമ്യൂട്ടേഷൻ സാധ്യമല്ലെന്ന് സൂചിപ്പിക്കുന്നു.\n    \n    Args:\n    perm (list): നിലവിലെ പെർമ്യൂട്ടേഷൻ പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n    \n    Returns:\n    bool: പെർമ്യൂട്ടേഷൻ വിജയകരമായി മാറ്റിയെങ്കിൽ True, അത് അവസാനത്തെ പെർമ്യൂട്ടേഷൻ ആയിരുന്നെങ്കിൽ False.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "fa": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    ورودی جایگشت را به جایگشت بعدی در ترتیب لغت‌نامه‌ای تبدیل می‌کند.\n    \n    این تابع اولین عدد از انتها که کوچکتر از عدد بعدی است را پیدا کرده و با کوچکترین عددی \n    که بزرگتر است و بعد از آن می‌آید، جابجا می‌کند. سپس ترتیب اعداد بعد از اولین عدد کوچکتر \n    اصلی را معکوس می‌کند. اگر ورودی آخرین جایگشت (به ترتیب نزولی) باشد، تابع مقدار False \n    را برمی‌گرداند که نشان می‌دهد جایگشت بعدی ممکن نیست.\n    \n    آرگومان‌ها:\n    perm (list): لیستی از اعداد صحیح که جایگشت فعلی را نشان می‌دهد.\n    \n    بازگشت:\n    bool: اگر جایگشت با موفقیت تغییر یافت True، اگر آخرین جایگشت بود False.\n    \n    مثال‌ها:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\""}, "canonical_solution": "    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True", "instruction": {"en": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Python կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nনিচের পাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyar nyelven, legfeljebb 500 karakterben.", "es": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Python باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nPython kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.", "vi": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\n다음 Python 코드의 동작을 설명하는 간결한 자연어 설명(독스트링)을 한국어로 작성하세요. 최대 500자 이내로 작성합니다.", "ml": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_next_permutation():\n    # Test case 1: ordinary case\n    perm1 = [1, 2, 3]\n    assert next_permutation(perm1) == True, \"Test case 1 failed: next_permutation([1, 2, 3]) should return True\"\n    assert perm1 == [1, 3, 2], \"Test case 1 failed: perm1 should be [1, 3, 2]\"\n    \n    # Test case 2: last permutation, should return False\n    perm2 = [3, 2, 1]\n    assert next_permutation(perm2) == False, \"Test case 2 failed: next_permutation([3, 2, 1]) should return False\"\n    assert perm2 == [3, 2, 1], \"Test case 2 failed: perm2 should be [3, 2, 1] (unchanged)\"\n    \n    # Test case 3: permutation with repeated elements\n    perm3 = [1, 5, 1]\n    assert next_permutation(perm3) == True, \"Test case 3 failed: next_permutation([1, 5, 1]) should return True\"\n    assert perm3 == [5, 1, 1], \"Test case 3 failed: perm3 should be [5, 1, 1]\"\n\n    # Test case 4: permutation with all elements equal\n    perm4 = [1, 1, 1]\n    assert next_permutation(perm4) == False, \"Test case 4 failed: next_permutation([1, 1, 1]) should return False\"\n    assert perm4 == [1, 1, 1], \"Test case 4 failed: perm4 should be [1, 1, 1] (unchanged)\"\n    \n    # Test case 5: permutation with only one element\n    perm5 = [42]\n    assert next_permutation(perm5) == False, \"Test case 5 failed: next_permutation([42]) should return False\"\n    assert perm5 == [42], \"Test case 5 failed: perm5 should be [42] (unchanged)\"\n    \n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_next_permutation()", "entry_point": "next_permutation", "signature": "def next_permutation(perm: list) -> bool:", "docstring": {"en": "Transforms the input permutation to the next permutation in lexicographic order.\n\nThe function finds the first number from the end that is smaller than the number following it\nand swaps it with the smallest number that is larger and comes after it. Then it reverses the\norder of numbers after the original first smaller number. If the input is the last permutation\n(in descending order), the function returns False, indicating no next permutation is possible.\n\nArgs:\nperm (list): A list of integers representing the current permutation.\n\nReturns:\nbool: True if the permutation was successfully transformed, False if it was the last permutation.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "sq": "Transformon permutimin hyrës në permutimin e radhës në rend leksikografik.\n\nFunksioni gjen numrin e parë nga fundi që është më i vogël se numri që e ndjek atë dhe e ndërron atë me numrin më të vogël që është më i madh dhe vjen pas tij. Pastaj e kthen rendin e numrave pas numrit të parë origjinal më të vogël. Nëse hyrja është permutimi i fundit (në rend zbritës), funksioni kthen False, duke treguar se nuk është e mundur një permutim tjetër.\n\nArgumentet:\nperm (listë): Një listë e numrave të plotë që përfaqëson permutimin aktual.\n\nKthen:\nbool: True nëse permutimi u transformua me sukses, False nëse ishte permutimi i fundit.\n\nShembuj:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "hy": "Վերափոխում է մուտքային փոխատեղումը հաջորդ փոխատեղման դեպի բառարանային կարգով:\n\nՖունկցիան գտնում է առաջին թիվը վերջից, որը փոքր է իրեն հաջորդող թվից և փոխանակում այն ամենափոքր թվի հետ, որը մեծ է և գալիս է դրանից հետո: Այնուհետև այն շրջում է թվերի կարգը սկզբնական առաջին փոքր թվից հետո: Եթե մուտքը վերջին փոխատեղումն է (նվազող կարգով), ֆունկցիան վերադարձնում է False, նշելով, որ հաջորդ փոխատեղումը հնարավոր չէ:\n\nԱրձագանքներ:\nperm (list): Թվերի ցուցակ, որը ներկայացնում է ընթացիկ փոխատեղումը:\n\nՎերադարձնում է:\nbool: True, եթե փոխատեղումը հաջողությամբ վերափոխվել է, False, եթե դա վերջին փոխատեղումն էր:\n\nՕրինակներ:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "bn": "ইনপুট পারমুটেশনকে লেক্সিকোগ্রাফিক ক্রমে পরবর্তী পারমুটেশনে রূপান্তর করে।\n\nফাংশনটি শেষ থেকে প্রথম যে সংখ্যাটি তার পরবর্তী সংখ্যার চেয়ে ছোট সেটি খুঁজে বের করে এবং এটি তার পরবর্তী সবচেয়ে ছোট বড় সংখ্যার সাথে অদলবদল করে। তারপর এটি মূল প্রথম ছোট সংখ্যার পরের সংখ্যাগুলোর ক্রম উল্টে দেয়। যদি ইনপুটটি শেষ পারমুটেশন হয় (অবনমিত ক্রমে), তাহলে ফাংশনটি False রিটার্ন করে, যা নির্দেশ করে যে কোনো পরবর্তী পারমুটেশন সম্ভব নয়।\n\nআর্গস:\nperm (list): পূর্ণসংখ্যার একটি তালিকা যা বর্তমান পারমুটেশনকে উপস্থাপন করে।\n\nরিটার্নস:\nbool: যদি পারমুটেশন সফলভাবে রূপান্তরিত হয় তাহলে True, যদি এটি শেষ পারমুটেশন হয় তাহলে False।\n\nউদাহরণ:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "bg": "Трансформира входната пермутация към следващата пермутация в лексикографски ред.\n\nФункцията намира първото число от края, което е по-малко от следващото число и го разменя с най-малкото число, което е по-голямо и идва след него. След това обръща реда на числата след оригиналното първо по-малко число. Ако входът е последната пермутация (в низходящ ред), функцията връща False, което означава, че не е възможна следваща пермутация.\n\nАргументи:\nperm (list): Списък от цели числа, представляващ текущата пермутация.\n\nВръща:\nbool: True, ако пермутацията беше успешно трансформирана, False, ако беше последната пермутация.\n\nПримери:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "zh": "将输入排列转换为字典序中的下一个排列。\n\n该函数从末尾开始找到第一个小于其后面的数字的数字，并将其与后面最小的且大于它的数字交换。然后反转原始第一个较小数字之后的数字顺序。如果输入是最后一个排列（降序排列），函数返回 False，表示没有下一个排列可能。\n\n参数：\nperm (list): 一个整数列表，表示当前排列。\n\n返回：\nbool: 如果排列成功转换，返回 True；如果是最后一个排列，返回 False。\n\n示例：\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "fr": "Transforme la permutation d'entrée en la permutation suivante dans l'ordre lexicographique.\n\nLa fonction trouve le premier nombre depuis la fin qui est plus petit que le nombre qui le suit\net l'échange avec le plus petit nombre qui est plus grand et vient après lui. Ensuite, elle inverse l'ordre des nombres après le premier nombre plus petit d'origine. Si l'entrée est la dernière permutation (en ordre décroissant), la fonction renvoie False, indiquant qu'aucune permutation suivante n'est possible.\n\nArgs:\nperm (list): Une liste d'entiers représentant la permutation actuelle.\n\nReturns:\nbool: True si la permutation a été transformée avec succès, False si c'était la dernière permutation.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "de": "Transformiert die Eingabepermutation in die nächste Permutation in lexikographischer Reihenfolge.\n\nDie Funktion findet die erste Zahl vom Ende her, die kleiner ist als die ihr folgende Zahl, und tauscht sie mit der kleinsten Zahl, die größer ist und danach kommt. Dann kehrt sie die Reihenfolge der Zahlen nach der ursprünglichen ersten kleineren Zahl um. Wenn die Eingabe die letzte Permutation (in absteigender Reihenfolge) ist, gibt die Funktion False zurück, was anzeigt, dass keine nächste Permutation möglich ist.\n\nArgs:\nperm (list): Eine Liste von ganzen Zahlen, die die aktuelle Permutation darstellt.\n\nReturns:\nbool: True, wenn die Permutation erfolgreich transformiert wurde, False, wenn es die letzte Permutation war.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "ha": "Canza shigarwar permutation zuwa permutation na gaba a cikin tsari na lexicographic.\n\nAikin yana nemo lambar farko daga ƙarshe wadda ta fi ƙarami fiye da lambar da ke binta\nkuma yana musanya ta da lambar mafi ƙaranci wadda ta fi girma kuma tana zuwa bayan ta. Sannan yana juyar da\ntsarin lambobin bayan lambar farko mafi ƙaranci ta asali. Idan shigarwar ita ce permutation na ƙarshe\n(a cikin tsari mai sauka), aikin yana dawowa da False, yana nuna babu wani permutation na gaba da zai yiwu.\n\nArgs:\nperm (list): Jerin lambobi masu nuna permutation na yanzu.\n\nReturns:\nbool: True idan an yi nasarar sauya permutation, False idan ita ce permutation na ƙarshe.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "hi": "इनपुट क्रमचय को शब्दकोशीय क्रम में अगले क्रमचय में बदलता है।\n\nयह फ़ंक्शन अंत से पहला ऐसा संख्या ढूंढता है जो उसके बाद आने वाले संख्या से छोटा हो और उसे उसके बाद आने वाले सबसे छोटे और बड़े संख्या के साथ अदला-बदली करता है। फिर यह मूल पहले छोटे संख्या के बाद के संख्याओं के क्रम को उलट देता है। यदि इनपुट अंतिम क्रमचय है (अवरोही क्रम में), तो फ़ंक्शन False लौटाता है, यह दर्शाते हुए कि कोई अगला क्रमचय संभव नहीं है।\n\nआर्ग्स:\nperm (list): पूर्णांकों की एक सूची जो वर्तमान क्रमचय का प्रतिनिधित्व करती है।\n\nरिटर्न्स:\nbool: True यदि क्रमचय को सफलतापूर्वक बदला गया, False यदि यह अंतिम क्रमचय था।\n\nउदाहरण:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "hu": "Átalakítja a bemeneti permutációt a következő permutációvá lexikografikus sorrendben.\n\nA függvény megkeresi a végétől az első számot, amely kisebb, mint az utána következő szám, és kicseréli azt a legkisebb számmal, amely nagyobb és utána következik. Ezután megfordítja az eredeti első kisebb szám utáni számok sorrendjét. Ha a bemenet az utolsó permutáció (csökkenő sorrendben), a függvény False értéket ad vissza, jelezve, hogy nincs lehetséges következő permutáció.\n\nArgs:\nperm (list): Egész számok listája, amely a jelenlegi permutációt képviseli.\n\nReturns:\nbool: True, ha a permutációt sikeresen átalakították, False, ha az utolsó permutáció volt.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "es": "Transforma la permutación de entrada a la siguiente permutación en orden lexicográfico.\n\nLa función encuentra el primer número desde el final que es más pequeño que el número que lo sigue y lo intercambia con el número más pequeño que es mayor y viene después de él. Luego invierte el orden de los números después del primer número más pequeño original. Si la entrada es la última permutación (en orden descendente), la función devuelve False, indicando que no es posible una siguiente permutación.\n\nArgumentos:\nperm (list): Una lista de enteros que representa la permutación actual.\n\nDevuelve:\nbool: True si la permutación fue transformada exitosamente, False si era la última permutación.\n\nEjemplos:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "arb": "يحوّل ترتيب الإدخال إلى الترتيب التالي في الترتيب المعجمي.\n\nتجد الدالة أول رقم من النهاية يكون أصغر من الرقم الذي يليه وتستبدله بأصغر رقم يكون أكبر ويأتي بعده. ثم تعكس ترتيب الأرقام بعد الرقم الأصغر الأصلي. إذا كان الإدخال هو الترتيب الأخير (بترتيب تنازلي)، فإن الدالة تعيد False، مما يشير إلى عدم إمكانية وجود ترتيب تالي.\n\nالمعطيات:\nperm (list): قائمة من الأعداد الصحيحة تمثل الترتيب الحالي.\n\nالقيم المعادة:\nbool: True إذا تم تحويل الترتيب بنجاح، False إذا كان الترتيب هو الأخير.\n\nأمثلة:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "sw": "Hubadilisha mpangilio wa pembejeo kuwa mpangilio unaofuata katika mpangilio wa lexicographic.\n\nKazi hii inapata nambari ya kwanza kutoka mwisho ambayo ni ndogo kuliko nambari inayofuata\nna inabadilisha na nambari ndogo zaidi ambayo ni kubwa na inakuja baada yake. Kisha inageuza\nmpangilio wa nambari baada ya nambari ya kwanza ndogo ya awali. Ikiwa pembejeo ni mpangilio wa mwisho\n(katika mpangilio wa kushuka), kazi inarudisha False, ikiashiria hakuna mpangilio unaofuata unaowezekana.\n\nHoja:\nperm (list): Orodha ya nambari za mzima zinazowakilisha mpangilio wa sasa.\n\nInarejesha:\nbool: True ikiwa mpangilio umebadilishwa kwa mafanikio, False ikiwa ulikuwa mpangilio wa mwisho.\n\nMifano:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "tr": "Girdi permütasyonunu sözlükbilimsel sırada bir sonraki permütasyona dönüştürür.\n\nFonksiyon, sondan başlayarak kendisinden sonra gelen sayıdan daha küçük olan ilk sayıyı bulur ve bunu, kendisinden sonra gelen en küçük ve daha büyük sayı ile değiştirir. Daha sonra, orijinal ilk küçük sayıdan sonraki sayıların sırasını tersine çevirir. Eğer girdi, son permütasyon ise (azalan sırada), fonksiyon bir sonraki permütasyonun mümkün olmadığını belirten False değerini döndürür.\n\nArgümanlar:\nperm (list): Mevcut permütasyonu temsil eden bir tamsayı listesi.\n\nDöndürür:\nbool: Permütasyon başarıyla dönüştürüldüyse True, son permütasyon ise False.\n\nÖrnekler:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "vi": "Chuyển đổi hoán vị đầu vào thành hoán vị tiếp theo theo thứ tự từ điển.\n\nHàm tìm số đầu tiên từ cuối mà nhỏ hơn số theo sau nó và hoán đổi nó với số nhỏ nhất mà lớn hơn và xuất hiện sau nó. Sau đó, nó đảo ngược thứ tự các số sau số nhỏ hơn đầu tiên ban đầu. Nếu đầu vào là hoán vị cuối cùng (theo thứ tự giảm dần), hàm trả về False, cho biết không có hoán vị tiếp theo nào khả thi.\n\nTham số:\nperm (list): Một danh sách các số nguyên đại diện cho hoán vị hiện tại.\n\nTrả về:\nbool: True nếu hoán vị đã được chuyển đổi thành công, False nếu đó là hoán vị cuối cùng.\n\nVí dụ:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "id": "Mengubah permutasi input ke permutasi berikutnya dalam urutan leksikografis.\n\nFungsi ini menemukan angka pertama dari akhir yang lebih kecil dari angka yang mengikutinya dan menukarnya dengan angka terkecil yang lebih besar dan datang setelahnya. Kemudian membalikkan urutan angka setelah angka pertama yang lebih kecil dari aslinya. Jika input adalah permutasi terakhir (dalam urutan menurun), fungsi mengembalikan False, menunjukkan tidak ada permutasi berikutnya yang mungkin.\n\nArgs:\nperm (list): Daftar bilangan bulat yang mewakili permutasi saat ini.\n\nReturns:\nbool: True jika permutasi berhasil diubah, False jika itu adalah permutasi terakhir.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "ja": "入力された順列を辞書式順序で次の順列に変換します。\n\nこの関数は、後ろから見て最初に次の数字より小さい数字を見つけ、それをその後に来る数字の中で最小の大きい数字と交換します。その後、元の最初の小さい数字の後の数字の順序を逆にします。入力が最後の順列（降順）である場合、関数は False を返し、次の順列が不可能であることを示します。\n\n引数:\nperm (list): 現在の順列を表す整数のリスト。\n\n戻り値:\nbool: 順列が正常に変換された場合は True、最後の順列だった場合は False。\n\n例:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "ko": "입력 순열을 사전식 순서의 다음 순열로 변환합니다.\n\n이 함수는 끝에서부터 시작하여 다음 숫자보다 작은 첫 번째 숫자를 찾아서, 그 숫자보다 크고 뒤에 오는 가장 작은 숫자와 교환합니다. 그런 다음, 원래의 첫 번째 작은 숫자 이후의 숫자들의 순서를 뒤집습니다. 만약 입력이 마지막 순열(내림차순)이라면, 함수는 False를 반환하여 다음 순열이 불가능함을 나타냅니다.\n\n인수:\nperm (list): 현재 순열을 나타내는 정수 리스트.\n\n반환값:\nbool: 순열이 성공적으로 변환되었으면 True, 마지막 순열이었다면 False.\n\n예제:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "ml": "ഇൻപുട്ട് പെർമ്യൂട്ടേഷൻ ലെക്സികോഗ്രാഫിക് ക്രമത്തിൽ അടുത്ത പെർമ്യൂട്ടേഷനിലേക്ക് മാറ്റുന്നു.\n\nഫംഗ്ഷൻ അവസാനത്തുനിന്നും ആദ്യ സംഖ്യയെ കണ്ടെത്തുന്നു, അത് അതിനെ പിന്തുടരുന്ന സംഖ്യയേക്കാൾ ചെറുതാണ്, കൂടാതെ അതിനേക്കാൾ വലിയതും അതിന് ശേഷം വരുന്നതുമായ ഏറ്റവും ചെറിയ സംഖ്യയുമായി അത് മാറുന്നു. തുടർന്ന്, യഥാർത്ഥ ആദ്യത്തെ ചെറിയ സംഖ്യയ്ക്ക് ശേഷം സംഖ്യകളുടെ ക്രമം മറിക്കുന്നു. ഇൻപുട്ട് അവസാനത്തെ പെർമ്യൂട്ടേഷൻ (ഇറക്കമുള്ള ക്രമത്തിൽ) ആണെങ്കിൽ, അടുത്ത പെർമ്യൂട്ടേഷൻ സാധ്യമല്ലെന്ന് സൂചിപ്പിക്കുന്ന False ഫംഗ്ഷൻ തിരികെ നൽകുന്നു.\n\nആർഗ്സ്:\nperm (list): നിലവിലെ പെർമ്യൂട്ടേഷൻ പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n\nറിട്ടേൺസ്:\nbool: പെർമ്യൂട്ടേഷൻ വിജയകരമായി മാറ്റിയെങ്കിൽ True, അത് അവസാനത്തെ പെർമ്യൂട്ടേഷൻ ആയിരുന്നെങ്കിൽ False.\n\nഉദാഹരണങ്ങൾ:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "fa": "ورودی جایگشت را به جایگشت بعدی در ترتیب لغت‌نامه‌ای تبدیل می‌کند.\n\nاین تابع اولین عدد از انتها که کوچکتر از عدد بعدی است را پیدا کرده و آن را با کوچکترین عددی که بزرگتر است و بعد از آن می‌آید، جابجا می‌کند. سپس ترتیب اعداد بعد از اولین عدد کوچکتر اصلی را معکوس می‌کند. اگر ورودی آخرین جایگشت (به ترتیب نزولی) باشد، تابع مقدار False را برمی‌گرداند که نشان می‌دهد جایگشت بعدی ممکن نیست.\n\nآرگومان‌ها:\nperm (list): لیستی از اعداد صحیح که جایگشت فعلی را نشان می‌دهد.\n\nبازگشتی:\nbool: اگر جایگشت با موفقیت تبدیل شد، True و اگر آخرین جایگشت بود، False برمی‌گرداند.\n\nمثال‌ها:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]"}}
{"task_id": "Python/44", "prompt": {"en": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin runs out of money in July (the 7th month)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin has 1580 units of currency by the end of the year\n    \"\"\"", "sq": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Llogarit shumën totale të parave që Jinjin do të ketë deri në fund të vitit\n    pas ndjekjes së planit të saj të kursimeve me nënën e saj. Çdo muaj, ajo mund të kursejë\n    shumëfish të 100 nga paratë e saj të xhepit (300 në muaj) nëse parashikon të ketë\n    të paktën 100 njësi të mbetura pas shpenzimeve. Paratë e kursyera do të fitojnë 20%\n    interes në fund të vitit.\n\n    Parametrat:\n    budgets (List[int]): Një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n\n    Kthen:\n    int: Shuma totale e parave që Jinjin do të ketë në fund të vitit pas interesit.\n         Nëse Jinjin mbetet pa para në ndonjë muaj të caktuar, kthen vlerën negative të\n         atij muaji (-X, ku X është numri i muajit).\n\n    Shembuj:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin mbetet pa para në korrik (muaji i 7-të)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin ka 1580 njësi të monedhës deri në fund të vitit\n    \"\"\"", "hy": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Հաշվարկում է այն գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում\n    իր մոր հետ խնայողությունների պլանը հետևելուց հետո: Ամեն ամիս, նա կարող է խնայել\n    100-ի բազմապատիկները իր գրպանի գումարից (300 ամեն ամիս), եթե կանխատեսում է, որ\n    ծախսերից հետո կունենա առնվազն 100 միավոր: Խնայված գումարը կստանա 20%\n    տոկոսադրույք տարվա վերջում:\n\n    Պարամետրեր:\n    budgets (List[int]): Ցուցակ 12 ամբողջ թվերից, որոնք ներկայացնում են Ջինջինի ամսական բյուջեն:\n\n    Վերադարձնում է:\n    int: Գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում տոկոսադրույքից հետո:\n         Եթե Ջինջինը որևէ ամսում գումարից դուրս է գալիս, վերադարձնում է\n         այդ ամսվա բացասական արժեքը (-X, որտեղ X-ը ամսվա համարն է):\n\n    Օրինակներ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Ջինջինը գումարից դուրս է գալիս հուլիսին (7-րդ ամիս)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Ջինջինը տարվա վերջում ունի 1580 միավոր արժույթ\n    \"\"\"", "bn": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    বছরের শেষে জিনজিনের মোট কত টাকা থাকবে তা গণনা করে\n    তার মায়ের সাথে তার সঞ্চয় পরিকল্পনা অনুসরণ করার পরে। প্রতি মাসে, সে তার\n    পকেট মানি (প্রতি মাসে 300) থেকে 100 এর গুণিতক সঞ্চয় করতে পারে যদি সে\n    খরচের পরে কমপক্ষে 100 ইউনিট অবশিষ্ট থাকার পূর্বাভাস দেয়। সঞ্চিত টাকা বছরের শেষে 20%\n    সুদ অর্জন করবে।\n\n    প্যারামিটার:\n    budgets (List[int]): ১২টি পূর্ণসংখ্যার একটি তালিকা যা জিনজিনের মাসিক বাজেট উপস্থাপন করে।\n\n    রিটার্নস:\n    int: বছরের শেষে সুদের পরে জিনজিনের মোট কত টাকা থাকবে।\n         যদি জিনজিন কোনো মাসে টাকা শেষ করে ফেলে, তবে সেই মাসের ঋণাত্মক মান (-X, যেখানে X মাসের সংখ্যা) ফেরত দেয়।\n\n    উদাহরণ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # জিনজিন জুলাই মাসে (৭ম মাস) টাকা শেষ করে ফেলে\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # বছরের শেষে জিনজিনের 1580 ইউনিট মুদ্রা থাকে\n    \"\"\"", "bg": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Изчислява общата сума пари, която Джинджин ще има в края на годината\n    след като следва своя план за спестявания с майка си. Всеки месец тя може да спести\n    кратни на 100 от джобните си пари (300 на месец), ако предвижда да има\n    поне 100 единици, останали след разходите. Спестените пари ще получат 20%\n    лихва в края на годината.\n\n    Параметри:\n    budgets (List[int]): Списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n\n    Връща:\n    int: Общата сума пари, която Джинджин ще има в края на годината след лихвата.\n         Ако Джинджин остане без пари в който и да е месец, връща отрицателната стойност на\n         този месец (-X, където X е номерът на месеца).\n\n    Примери:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Джинджин остава без пари през юли (7-ми месец)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Джинджин има 1580 единици валута в края на годината\n    \"\"\"", "zh": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    计算金金在年底按照她和她母亲的储蓄计划后将拥有的总金额。每个月，如果她预测在支出后至少剩余100单位，她可以从她的零花钱（每月300）中存入100的倍数。存入的钱将在年底获得20%的利息。\n\n    参数：\n    budgets (List[int]): 一个包含12个整数的列表，表示金金每个月的预算。\n\n    返回：\n    int: 年底金金在利息后将拥有的总金额。\n         如果金金在任何一个月用完了钱，返回该月份的负值（-X，其中X是月份编号）。\n\n    示例：\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # 金金在七月（第7个月）用完了钱\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # 年底金金有1580单位的货币\n    \"\"\"", "fr": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calcule le montant total d'argent que Jinjin aura à la fin de l'année\n    après avoir suivi son plan d'épargne avec sa mère. Chaque mois, elle peut économiser\n    des multiples de 100 de son argent de poche (300 par mois) si elle prévoit d'avoir\n    au moins 100 unités restantes après les dépenses. L'argent économisé gagnera 20%\n    d'intérêt à la fin de l'année.\n\n    Paramètres:\n    budgets (List[int]): Une liste de 12 entiers représentant le budget mensuel de Jinjin.\n\n    Renvoie:\n    int: Le montant total d'argent que Jinjin aura à la fin de l'année après les intérêts.\n         Si Jinjin manque d'argent à un moment donné du mois, renvoie la valeur négative\n         de ce mois (-X, où X est le numéro du mois).\n\n    Exemples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin manque d'argent en juillet (le 7ème mois)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin a 1580 unités de monnaie à la fin de l'année\n    \"\"\"", "de": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Berechnet den Gesamtbetrag an Geld, den Jinjin am Ende des Jahres haben wird,\n    nachdem sie ihren Sparplan mit ihrer Mutter befolgt hat. Jeden Monat kann sie\n    Vielfache von 100 von ihrem Taschengeld (300 pro Monat) sparen, wenn sie\n    voraussieht, dass nach den Ausgaben mindestens 100 Einheiten übrig bleiben.\n    Das gesparte Geld wird am Ende des Jahres 20% Zinsen erhalten.\n\n    Parameter:\n    budgets (List[int]): Eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n\n    Rückgabe:\n    int: Der Gesamtbetrag an Geld, den Jinjin am Ende des Jahres nach Zinsen haben wird.\n         Wenn Jinjin in einem bestimmten Monat kein Geld mehr hat, wird der negative Wert\n         dieses Monats zurückgegeben (-X, wobei X die Monatsnummer ist).\n\n    Beispiele:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin hat im Juli (dem 7. Monat) kein Geld mehr\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin hat am Ende des Jahres 1580 Währungseinheiten\n    \"\"\"", "ha": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Lissafa jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara\n    bayan bin shirin ajiyar kuɗi tare da mahaifiyarta. Kowace wata, za ta iya ajiye\n    sau na 100 daga cikin kuɗin aljihunta (300 a kowane wata) idan ta hango samun\n    aƙalla 100 saura bayan kashe kuɗi. Kuɗin da aka ajiye zai samu riba 20%\n    a ƙarshen shekara.\n\n    Sigogi:\n    budgets (List[int]): Jerin lambobi 12 da ke wakiltar kasafin kuɗin wata-wata na Jinjin.\n\n    Abin da ake dawowa da shi:\n    int: Jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara bayan riba.\n         Idan Jinjin ta ƙare da kuɗi a kowanne wata, za a dawo da ƙimar da ta yi\n         rashin kuɗi a watan (-X, inda X shine lambar watan).\n\n    Misalai:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin ta ƙare da kuɗi a watan Yuli (wata na 7)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin tana da 1580 na kuɗi a ƙarshen shekara\n    \"\"\"", "hi": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    वर्ष के अंत तक Jinjin के पास कुल कितनी राशि होगी, इसकी गणना करता है\n    अपनी माँ के साथ उसकी बचत योजना का पालन करने के बाद। प्रत्येक महीने, वह\n    अपनी पॉकेट मनी (प्रति माह 300) से 100 के गुणकों की बचत कर सकती है यदि वह\n    खर्चों के बाद कम से कम 100 इकाइयाँ बचने की भविष्यवाणी करती है। बचाई गई राशि\n    को वर्ष के अंत में 20% ब्याज प्राप्त होगा।\n\n    पैरामीटर्स:\n    budgets (List[int]): Jinjin के मासिक बजट का प्रतिनिधित्व करने वाले 12 पूर्णांकों की सूची।\n\n    रिटर्न्स:\n    int: वर्ष के अंत में ब्याज के बाद Jinjin के पास कुल कितनी राशि होगी।\n         यदि Jinjin किसी भी महीने में पैसे से बाहर हो जाती है, तो उस महीने का\n         नकारात्मक मान लौटाता है (-X, जहाँ X महीने का नंबर है)।\n\n    उदाहरण:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin जुलाई (7वां महीना) में पैसे से बाहर हो जाती है\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # वर्ष के अंत तक Jinjin के पास 1580 मुद्रा इकाइयाँ हैं\n    \"\"\"", "hu": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Kiszámítja, hogy mennyi pénze lesz Jinjinnek az év végére,\n    miután követi a megtakarítási tervét az anyukájával. Minden hónapban\n    100 többszöröseit tudja megtakarítani a zsebpénzéből (havonta 300),\n    ha előre látja, hogy legalább 100 egység marad a kiadások után. A megtakarított\n    pénz 20%-os kamatot kap az év végén.\n\n    Paraméterek:\n    budgets (List[int]): Egy 12 egész számot tartalmazó lista, amely Jinjin havi költségvetését jelöli.\n\n    Visszatérési érték:\n    int: Az év végére Jinjin által birtokolt teljes pénzösszeg a kamatokkal együtt.\n         Ha Jinjin bármelyik hónapban kifogy a pénzből, akkor az adott hónap negatív\n         értékével tér vissza (-X, ahol X a hónap száma).\n\n    Példák:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin kifogy a pénzből júliusban (a 7. hónapban)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjinnek 1580 pénzegysége van az év végére\n    \"\"\"", "es": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calcula la cantidad total de dinero que Jinjin tendrá al final del año\n    después de seguir su plan de ahorros con su madre. Cada mes, puede ahorrar\n    múltiplos de 100 de su dinero de bolsillo (300 por mes) si predice tener\n    al menos 100 unidades restantes después de los gastos. El dinero ahorrado ganará un 20%\n    de interés al final del año.\n\n    Parámetros:\n    budgets (List[int]): Una lista de 12 enteros que representan el presupuesto mensual de Jinjin.\n\n    Devuelve:\n    int: La cantidad total de dinero que Jinjin tendrá al final del año después de los intereses.\n         Si Jinjin se queda sin dinero en cualquier mes, devuelve el valor negativo de\n         ese mes (-X, donde X es el número del mes).\n\n    Ejemplos:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin se queda sin dinero en julio (el 7º mes)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin tiene 1580 unidades de moneda al final del año\n    \"\"\"", "arb": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    يحسب إجمالي المبلغ الذي ستحصل عليه جينجين بحلول نهاية العام\n    بعد اتباع خطة التوفير مع والدتها. كل شهر، يمكنها توفير\n    مضاعفات 100 من مصروفها الشهري (300 شهريًا) إذا توقعت أن يكون لديها\n    على الأقل 100 وحدة متبقية بعد النفقات. سيتم كسب المال المدخر فائدة بنسبة 20%\n    في نهاية العام.\n\n    المعلمات:\n    budgets (List[int]): قائمة تحتوي على 12 عددًا صحيحًا تمثل ميزانية جينجين الشهرية.\n\n    العوائد:\n    int: إجمالي المبلغ الذي ستحصل عليه جينجين في نهاية العام بعد الفائدة.\n         إذا نفدت أموال جينجين في أي شهر معين، يتم إرجاع القيمة السالبة\n         لذلك الشهر (-X، حيث X هو رقم الشهر).\n\n    أمثلة:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # نفدت أموال جينجين في يوليو (الشهر السابع)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # جينجين لديها 1580 وحدة من العملة بحلول نهاية العام\n    \"\"\"", "sw": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Inahesabu jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka\n    baada ya kufuata mpango wake wa akiba na mama yake. Kila mwezi, anaweza kuweka\n    akiba ya mara 100 kutoka kwenye pesa zake za mfukoni (300 kwa mwezi) ikiwa anatarajia kubaki\n    na angalau vitengo 100 baada ya matumizi. Pesa zilizowekwa akiba zitapata riba ya 20%\n    mwishoni mwa mwaka.\n\n    Vigezo:\n    budgets (List[int]): Orodha ya namba 12 zinazowakilisha bajeti ya kila mwezi ya Jinjin.\n\n    Inarudisha:\n    int: Jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya riba.\n         Ikiwa Jinjin anaishiwa na pesa katika mwezi wowote, inarudisha thamani hasi ya\n         mwezi huo (-X, ambapo X ni namba ya mwezi).\n\n    Mifano:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin anaishiwa na pesa mwezi wa Julai (mwezi wa 7)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin ana vitengo 1580 vya sarafu mwishoni mwa mwaka\n    \"\"\"", "tr": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Jinjin'in annesiyle birlikte tasarruf planını takip ettikten sonra yıl sonunda\n    sahip olacağı toplam para miktarını hesaplar. Her ay, harcamalardan sonra en az\n    100 birim kalacağını tahmin ederse, cep harçlığından (ayda 300) 100'ün katları\n    kadar tasarruf edebilir. Biriktirilen para yıl sonunda %20 faiz kazanacaktır.\n\n    Parametreler:\n    budgets (List[int]): Jinjin'in aylık bütçesini temsil eden 12 tam sayıdan oluşan bir liste.\n\n    Dönüş:\n    int: Jinjin'in yıl sonunda faizle birlikte sahip olacağı toplam para miktarı.\n         Eğer Jinjin herhangi bir ayda parası biterse, o ayın negatif değeri döner (-X, burada X ay numarasıdır).\n\n    Örnekler:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin Temmuz ayında (7. ay) parası bitiyor\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin yıl sonunda 1580 birim para birimine sahip oluyor\n    \"\"\"", "vi": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Tính tổng số tiền mà Jinjin sẽ có vào cuối năm\n    sau khi thực hiện kế hoạch tiết kiệm với mẹ của cô ấy. Mỗi tháng, cô ấy có thể tiết kiệm\n    bội số của 100 từ tiền tiêu vặt của mình (300 mỗi tháng) nếu cô ấy dự đoán còn lại\n    ít nhất 100 đơn vị sau khi chi tiêu. Số tiền tiết kiệm sẽ được hưởng lãi suất 20%\n    vào cuối năm.\n\n    Tham số:\n    budgets (List[int]): Danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n\n    Trả về:\n    int: Tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi tính lãi.\n         Nếu Jinjin hết tiền trong bất kỳ tháng nào, trả về giá trị âm của\n         tháng đó (-X, trong đó X là số tháng).\n\n    Ví dụ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin hết tiền vào tháng 7 (tháng thứ 7)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin có 1580 đơn vị tiền tệ vào cuối năm\n    \"\"\"", "id": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Menghitung jumlah total uang yang akan dimiliki Jinjin pada akhir tahun\n    setelah mengikuti rencana tabungannya dengan ibunya. Setiap bulan, dia dapat menabung\n    kelipatan 100 dari uang sakunya (300 per bulan) jika dia memprediksi memiliki\n    setidaknya 100 unit tersisa setelah pengeluaran. Uang yang ditabung akan mendapatkan bunga 20%\n    pada akhir tahun.\n\n    Parameter:\n    budgets (List[int]): Daftar 12 bilangan bulat yang mewakili anggaran bulanan Jinjin.\n\n    Mengembalikan:\n    int: Jumlah total uang yang akan dimiliki Jinjin pada akhir tahun setelah bunga.\n         Jika Jinjin kehabisan uang di bulan mana pun, mengembalikan nilai negatif dari\n         bulan tersebut (-X, di mana X adalah nomor bulan).\n\n    Contoh:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin kehabisan uang pada bulan Juli (bulan ke-7)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin memiliki 1580 unit mata uang pada akhir tahun\n    \"\"\"", "ja": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    年末までにJinjinが貯蓄計画に従って母親と一緒に貯めることができる\n    お金の総額を計算します。毎月、彼女は少なくとも100単位が\n    出費後に残ると予測できる場合、ポケットマネー（毎月300）から\n    100の倍数を貯金することができます。貯金したお金は年末に20%\n    の利子を得ることになります。\n\n    パラメータ:\n    budgets (List[int]): Jinjinの毎月の予算を表す12個の整数のリスト。\n\n    戻り値:\n    int: 年末に利子を含めてJinjinが持つお金の総額。\n         もしJinjinが任意の月にお金が足りなくなった場合、その月の\n         負の値を返します（-X、ここでXは月の番号です）。\n\n    例:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjinは7月（7番目の月）にお金が足りなくなります\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjinは年末までに1580単位の通貨を持っています\n    \"\"\"", "ko": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    진진이의 저축 계획을 따라 연말까지 진진이가 갖게 될 총 금액을 계산합니다.\n    매달, 그녀는 지출 후 최소 100 단위가 남을 것으로 예상되면 용돈(매달 300)에서\n    100의 배수를 저축할 수 있습니다. 저축한 돈은 연말에 20%의 이자를 얻게 됩니다.\n\n    매개변수:\n    budgets (List[int]): 진진이의 월별 예산을 나타내는 12개의 정수 리스트.\n\n    반환값:\n    int: 연말에 이자를 포함하여 진진이가 갖게 될 총 금액.\n         만약 진진이가 어떤 달에 돈이 부족해지면, 그 달의 음수 값(-X, 여기서 X는 달 번호)을 반환합니다.\n\n    예시:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # 진진이는 7월(7번째 달)에 돈이 부족합니다.\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # 진진이는 연말까지 1580 단위의 화폐를 갖게 됩니다.\n    \"\"\"", "ml": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    ജിൻജിൻ അവളുടെ അമ്മയോടൊപ്പം അവളുടെ സംരക്ഷണ പദ്ധതിയെ പിന്തുടർന്ന് വർഷാവസാനത്തോടെ എത്ര പണം ഉണ്ടാകും\n    എന്നത് കണക്കാക്കുന്നു. ഓരോ മാസവും, ചെലവുകൾക്കുശേഷം കുറഞ്ഞത് 100 യൂണിറ്റ് ശേഷിക്കുമെന്ന് അവൾ പ്രവചിച്ചാൽ\n    അവളുടെ പോക്കറ്റ് മണിയിൽ നിന്ന് (മാസത്തിൽ 300) 100ന്റെ ഗുണിതകങ്ങൾ അവൾ സംരക്ഷിക്കാം. സംരക്ഷിച്ച പണം \n    വർഷാവസാനത്തിൽ 20% പലിശ നേടും.\n\n    പാരാമീറ്ററുകൾ:\n    budgets (List[int]): ജിൻജിന്റെ മാസാന്ത ബജറ്റ് പ്രതിനിധീകരിക്കുന്ന 12 പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n\n    മടക്കങ്ങൾ:\n    int: പലിശയ്ക്കുശേഷം വർഷാവസാനത്തിൽ ജിൻജിന് എത്ര പണം ഉണ്ടാകും എന്നത്. \n         ജിൻജിന് ഏതെങ്കിലും മാസത്തിൽ പണം തീർന്നാൽ, ആ മാസത്തിന്റെ നെഗറ്റീവ് മൂല്യം (-X, എവിടെ X മാസ സംഖ്യയാണ്) മടക്കുന്നു.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # ജൂലൈയിൽ (7-ാം മാസം) ജിൻജിന് പണം തീരുന്നു\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # വർഷാവസാനത്തിൽ ജിൻജിന് 1580 യൂണിറ്റ് കറൻസി ഉണ്ട്\n    \"\"\"", "fa": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    محاسبه مقدار کل پولی که جینجین تا پایان سال پس از پیروی از برنامه پس‌انداز خود با مادرش خواهد داشت.\n    هر ماه، او می‌تواند مضرب‌های 100 از پول توجیبی خود (300 در ماه) را پس‌انداز کند اگر پیش‌بینی کند که\n    حداقل 100 واحد پس از هزینه‌ها باقی خواهد ماند. پول پس‌انداز شده در پایان سال 20% سود دریافت خواهد کرد.\n\n    پارامترها:\n    budgets (List[int]): لیستی از 12 عدد صحیح که بودجه ماهانه جینجین را نشان می‌دهد.\n\n    بازگشت:\n    int: مقدار کل پولی که جینجین در پایان سال پس از دریافت سود خواهد داشت.\n         اگر جینجین در هر ماهی پولش تمام شود، مقدار منفی آن ماه را برمی‌گرداند (-X، جایی که X شماره ماه است).\n\n    مثال‌ها:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # جینجین در ماه جولای (ماه هفتم) پولش تمام می‌شود\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # جینجین تا پایان سال 1580 واحد پول دارد\n    \"\"\""}, "canonical_solution": "    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money", "instruction": {"en": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nՏվեք Python կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\n以下のPythonコードに対して、500文字以内で簡潔な自然言語の説明（ドックストリング）を日本語で提供してください。", "ko": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nPython 코드에 대한 간결한 자연어 설명을 한국어로 작성하세요. 최대 500자까지 가능합니다.", "ml": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nPython കോഡിന് 500 അക്ഷരങ്ങളിൽ കൂടുതൽ ഉപയോഗിക്കാതെ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_jinjin_savings_plan():\n    # Test case 1: Jinjin runs out of money in July (the 7th month)\n    budgets1 = [290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets1) == -7, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin has 1580 units of currency by the end of the year\n    budgets2 = [290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets2) == 1580, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin manages her budget perfectly and has a specific amount by the end\n    budgets3 = [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300]\n    assert jinjin_savings_plan(budgets3) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Jinjin does not need to save any money and spends exactly the amount she receives\n    budgets4 = [300, 290, 280, 270, 260, 250, 240, 230, 220, 210, 200, 190]\n    assert jinjin_savings_plan(budgets4) == 780, \"Test case 4 failed\"\n\n    # Test case 5: Jinjin runs out of money in the first month\n    budgets5 = [350, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n    assert jinjin_savings_plan(budgets5) == -1, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_jinjin_savings_plan()", "entry_point": "jinjin_savings_plan", "signature": "def jinjin_savings_plan(budgets: List[int]) -> int:", "docstring": {"en": "Calculates the total amount of money Jinjin will have by the end of the year\nafter following her savings plan with her mother. Each month, she can save\nmultiples of 100 from her pocket money (300 per month) if she predicts having\nat least 100 units remaining after expenses. The saved money will gain 20%\ninterest at the end of the year.\n\nParameters:\nbudgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\nReturns:\nint: The total amount of money Jinjin will have at the end of the year after interest.\nIf Jinjin runs out of money in any given month, returns the negative value of\nthat month (-X, where X is the month number).\n\nExamples:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin runs out of money in July (the 7th month)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin has 1580 units of currency by the end of the year", "sq": "Llogarit shumën totale të parave që Jinjin do të ketë deri në fund të vitit\npas ndjekjes së planit të saj të kursimeve me nënën e saj. Çdo muaj, ajo mund të kursejë\nshumëfish të 100 nga paratë e saj të xhepit (300 në muaj) nëse parashikon të ketë\ntë paktën 100 njësi të mbetura pas shpenzimeve. Paratë e kursyera do të fitojnë 20%\ninteres në fund të vitit.\n\nParametrat:\nbudgets (List[int]): Një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n\nKthen:\nint: Shuma totale e parave që Jinjin do të ketë në fund të vitit pas interesit.\nNëse Jinjin mbetet pa para në ndonjë muaj të caktuar, kthen vlerën negative të\natij muaji (-X, ku X është numri i muajit).\n\nShembuj:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin mbetet pa para në korrik (muaji i 7-të)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin ka 1580 njësi monedhe deri në fund të vitit", "hy": "Հաշվում է, թե որքան գումար կունենա Ջինջինը տարվա վերջում՝ իր խնայողությունների պլանը իր մոր հետ հետևելուց հետո: Ամեն ամիս նա կարող է խնայել 100-ի բազմապատիկներ իր գրպանի գումարից (300 ամսական), եթե կանխատեսում է, որ ծախսերից հետո առնվազն 100 միավոր կմնա: Խնայված գումարը տարվա վերջում կստանա 20% տոկոսադրույք:\n\nՊարամետրեր:\nbudgets (List[int]): Ցուցակ 12 ամբողջ թվերից, որոնք ներկայացնում են Ջինջինի ամսական բյուջեն:\n\nՎերադարձնում է:\nint: Գումարի ընդհանուր քանակը, որը Ջինջինը կունենա տարվա վերջում՝ տոկոսադրույքից հետո:\nԵթե Ջինջինը որևէ ամսում գումարը սպառվի, վերադարձնում է այդ ամսվա բացասական արժեքը (-X, որտեղ X-ը ամսվա համարն է):\n\nՕրինակներ:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Ջինջինը գումարը սպառվում է հուլիսին (7-րդ ամիս)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Ջինջինը տարվա վերջում ունի 1580 միավոր արժույթ", "bn": "বছরের শেষে জিনজিনের মোট কত টাকা থাকবে তা গণনা করে তার সঞ্চয় পরিকল্পনা অনুসরণ করার পর তার মায়ের সাথে। প্রতিটি মাসে, সে তার পকেট মানি (প্রতি মাসে ৩০০) থেকে ১০০-এর গুণিতক সঞ্চয় করতে পারে যদি সে খরচের পর অন্তত ১০০ ইউনিট অবশিষ্ট থাকবে বলে পূর্বাভাস দেয়। সঞ্চিত অর্থ বছরের শেষে ২০% সুদ অর্জন করবে।\n\nপ্যারামিটার:\nbudgets (List[int]): জিনজিনের মাসিক বাজেটের প্রতিনিধিত্বকারী ১২টি পূর্ণসংখ্যার একটি তালিকা।\n\nরিটার্নস:\nint: বছরের শেষে সুদের পর জিনজিনের মোট কত টাকা থাকবে। যদি কোনো মাসে জিনজিনের টাকা শেষ হয়ে যায়, তাহলে সেই মাসের ঋণাত্মক মান (-X, যেখানে X হল মাসের সংখ্যা) রিটার্ন করে।\n\nউদাহরণ:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # জিনজিন জুলাই মাসে (৭ম মাসে) টাকা শেষ হয়ে যায়\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # বছরের শেষে জিনজিনের ১৫৮০ ইউনিট মুদ্রা থাকে", "bg": "Изчислява общата сума пари, която Джинджин ще има до края на годината след като следва плана си за спестявания с майка си. Всеки месец тя може да спести кратни на 100 от джобните си пари (300 на месец), ако предвижда, че ще има поне 100 единици, останали след разходите. Спестените пари ще получат 20% лихва в края на годината.\n\nПараметри:\nbudgets (List[int]): Списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n\nВръща:\nint: Общата сума пари, която Джинджин ще има в края на годината след лихвата. Ако Джинджин остане без пари през който и да е месец, връща отрицателната стойност на този месец (-X, където X е номерът на месеца).\n\nПримери:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Джинджин остава без пари през юли (седмия месец)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Джинджин има 1580 единици валута до края на годината", "zh": "计算金金在遵循她与母亲的储蓄计划后，到年底将拥有的总金额。每个月，如果她预测在支出后至少剩余100单位，她可以从她的零花钱（每月300）中存下100的倍数。储蓄的钱将在年底获得20%的利息。\n\n参数：\nbudgets (List[int]): 一个包含12个整数的列表，表示金金每月的预算。\n\n返回：\nint: 金金在年底加上利息后将拥有的总金额。如果金金在任何一个月用完了钱，返回该月份的负值（-X，其中X是月份编号）。\n\n示例：\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # 金金在七月（第7个月）用完了钱\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # 金金在年底有1580单位的货币", "fr": "Calcule le montant total d'argent que Jinjin aura à la fin de l'année après avoir suivi son plan d'épargne avec sa mère. Chaque mois, elle peut économiser des multiples de 100 de son argent de poche (300 par mois) si elle prévoit d'avoir au moins 100 unités restantes après les dépenses. L'argent économisé gagnera 20% d'intérêt à la fin de l'année.\n\nParamètres :\nbudgets (List[int]): Une liste de 12 entiers représentant le budget mensuel de Jinjin.\n\nRenvoie :\nint : Le montant total d'argent que Jinjin aura à la fin de l'année après intérêts. Si Jinjin manque d'argent à un moment donné du mois, renvoie la valeur négative de ce mois (-X, où X est le numéro du mois).\n\nExemples :\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin manque d'argent en juillet (le 7ème mois)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin a 1580 unités de monnaie à la fin de l'année", "de": "Berechnet den Gesamtbetrag an Geld, den Jinjin bis zum Ende des Jahres haben wird, nachdem sie ihren Sparplan mit ihrer Mutter befolgt hat. Jeden Monat kann sie Vielfache von 100 von ihrem Taschengeld (300 pro Monat) sparen, wenn sie voraussagt, dass nach den Ausgaben mindestens 100 Einheiten übrig bleiben. Das gesparte Geld wird am Ende des Jahres 20% Zinsen erhalten.\n\nParameter:\nbudgets (List[int]): Eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n\nRückgabewerte:\nint: Der Gesamtbetrag an Geld, den Jinjin am Ende des Jahres nach Zinsen haben wird. Wenn Jinjin in einem beliebigen Monat kein Geld mehr hat, wird der negative Wert dieses Monats zurückgegeben (-X, wobei X die Monatsnummer ist).\n\nBeispiele:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin hat im Juli (dem 7. Monat) kein Geld mehr\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin hat bis zum Ende des Jahres 1580 Währungseinheiten", "ha": "Lissafa jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara\nbayan bin shirin ajiyar kuɗi tare da mahaifiyarta. Kowace wata, za ta iya ajiye\nsau na 100 daga cikin kuɗin aljihunta (300 a kowane wata) idan ta hango samun\naƙalla 100 saura bayan kashe kuɗi. Kuɗin da aka ajiye zai samu riba 20%\na ƙarshen shekara.\n\nSigogi:\nbudgets (List[int]): Jerin lambobi 12 da ke wakiltar kasafin kudin wata-wata na Jinjin.\n\nReturns:\nint: Jimillar adadin kuɗin da Jinjin za ta samu a ƙarshen shekara bayan riba. Idan Jinjin ta ƙare da kuɗi a kowane wata, yana dawo da ƙimar mara kyau na wannan watan (-X, inda X shine lambar wata).\n\nExamples:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin ta ƙare da kuɗi a watan Yuli (wata na 7)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin tana da 1580 na kuɗi a ƙarshen shekara", "hi": "वर्ष के अंत तक Jinjin के पास कुल कितनी राशि होगी, इसकी गणना करता है\nअपनी माँ के साथ उसकी बचत योजना का पालन करने के बाद। प्रत्येक महीने, वह\nअपनी पॉकेट मनी (प्रति माह 300) से 100 के गुणकों की बचत कर सकती है यदि वह\nखर्चों के बाद कम से कम 100 इकाइयाँ बचने की भविष्यवाणी करती है। बचाई गई राशि\nको वर्ष के अंत में 20% ब्याज प्राप्त होगा।\n\nमापदंड:\nbudgets (List[int]): 12 पूर्णांकों की एक सूची जो जिनजिन के मासिक बजट का प्रतिनिधित्व करती है।\n\nवापसी:\nint: वर्ष के अंत में ब्याज के बाद जिनजिन के पास कुल धनराशि होगी।\nयदि जिनजिन किसी भी महीने में पैसे से बाहर हो जाती है, तो उस महीने का नकारात्मक मान लौटाता है (-X, जहाँ X महीने का क्रमांक है)।\n\nउदाहरण:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # जिनजिन जुलाई (7वां महीना) में पैसे से बाहर हो जाती है\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # जिनजिन के पास वर्ष के अंत तक 1580 मुद्रा इकाइयाँ हैं", "hu": "Kiszámítja, hogy mennyi pénze lesz Jinjinnek az év végére, miután követi a megtakarítási tervét az anyukájával. Minden hónapban 100-as többszöröseit tudja megtakarítani a zsebpénzéből (havonta 300), ha előre látja, hogy legalább 100 egység marad a kiadások után. A megtakarított pénz 20%-os kamatot kap az év végén.\n\nParaméterek:\nbudgets (List[int]): Egy 12 egész számot tartalmazó lista, amely Jinjin havi költségvetését jelöli.\n\nVisszatérési érték:\nint: Az összeg, amennyi pénze lesz Jinjinnek az év végén a kamatokkal együtt. Ha Jinjin bármelyik hónapban kifogy a pénzből, akkor az adott hónap negatív értékét adja vissza (-X, ahol X a hónap száma).\n\nPéldák:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin kifogy a pénzből júliusban (a 7. hónap)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjinnek 1580 pénzegysége van az év végére", "es": "Calcula la cantidad total de dinero que Jinjin tendrá al final del año después de seguir su plan de ahorro con su madre. Cada mes, puede ahorrar múltiplos de 100 de su dinero de bolsillo (300 por mes) si predice tener al menos 100 unidades restantes después de los gastos. El dinero ahorrado ganará un 20% de interés al final del año.\n\nParámetros:\nbudgets (List[int]): Una lista de 12 enteros que representa el presupuesto mensual de Jinjin.\n\nDevuelve:\nint: La cantidad total de dinero que Jinjin tendrá al final del año después de los intereses. Si Jinjin se queda sin dinero en cualquier mes, devuelve el valor negativo de ese mes (-X, donde X es el número del mes).\n\nEjemplos:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin se queda sin dinero en julio (el 7º mes)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin tiene 1580 unidades de moneda al final del año", "arb": "يحسب إجمالي المبلغ الذي ستحصل عليه جينجين بنهاية العام بعد اتباع خطة التوفير مع والدتها. في كل شهر، يمكنها توفير مضاعفات 100 من مصروفها الشخصي (300 شهريًا) إذا توقعت بقاء ما لا يقل عن 100 وحدة بعد النفقات. ستكسب الأموال المدخرة فائدة بنسبة 20% في نهاية العام.\n\nالمعطيات:\nbudgets (List[int]): قائمة مكونة من 12 عددًا صحيحًا تمثل الميزانية الشهرية لجينجين.\n\nالقيم المعادة:\nint: إجمالي المبلغ الذي ستحصل عليه جينجين في نهاية العام بعد الفائدة. إذا نفدت أموال جينجين في أي شهر، يتم إرجاع القيمة السالبة لذلك الشهر (-X، حيث X هو رقم الشهر).\n\nأمثلة:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # نفدت أموال جينجين في يوليو (الشهر السابع)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # تمتلك جينجين 1580 وحدة نقدية بنهاية العام", "sw": "Hesabu jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya kufuata mpango wake wa akiba na mama yake. Kila mwezi, anaweza kuweka akiba ya mara 100 kutoka kwa pesa zake za mfukoni (300 kwa mwezi) ikiwa anatarajia kubaki na angalau vitengo 100 baada ya matumizi. Pesa zilizowekwa akiba zitapata riba ya 20% mwishoni mwa mwaka.\n\nVigezo:\nbudgets (List[int]): Orodha ya namba 12 zinazowakilisha bajeti ya kila mwezi ya Jinjin.\n\nInarejesha:\nint: Jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya riba. Ikiwa Jinjin atamaliza pesa katika mwezi wowote, inarejesha thamani hasi ya mwezi huo (-X, ambapo X ni namba ya mwezi).\n\nMifano:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin anakosa pesa mwezi wa Julai (mwezi wa 7)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin ana vitengo 1580 vya fedha mwishoni mwa mwaka", "tr": "Yıl sonunda Jinjin'in annesiyle yaptığı tasarruf planını takip ettikten sonra sahip olacağı toplam para miktarını hesaplar. Her ay, masraflardan sonra en az 100 birim kalacağını tahmin ederse, cep harçlığından (ayda 300) 100'ün katları kadar tasarruf edebilir. Biriktirilen para yıl sonunda %20 faiz kazanacaktır.\n\nParametreler:\nbudgets (List[int]): Jinjin'in aylık bütçesini temsil eden 12 tam sayıdan oluşan bir liste.\n\nDöndürülen:\nint: Jinjin'in yıl sonunda faiziyle birlikte sahip olacağı toplam para miktarı.\nEğer Jinjin herhangi bir ayda parasız kalırsa, o ayın negatif değerini döndürür (-X, burada X ay numarasıdır).\n\nÖrnekler:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin Temmuz ayında (7. ay) parasız kalıyor\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin yıl sonunda 1580 birim para birimine sahip", "vi": "Tính tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi thực hiện kế hoạch tiết kiệm với mẹ của cô ấy. Mỗi tháng, cô ấy có thể tiết kiệm bội số của 100 từ tiền tiêu vặt của mình (300 mỗi tháng) nếu cô ấy dự đoán còn ít nhất 100 đơn vị sau khi chi tiêu. Số tiền tiết kiệm sẽ nhận được lãi suất 20% vào cuối năm.\n\nTham số:\nbudgets (List[int]): Một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n\nTrả về:\nint: Tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi tính lãi. Nếu Jinjin hết tiền trong bất kỳ tháng nào, trả về giá trị âm của tháng đó (-X, trong đó X là số tháng).\n\nVí dụ:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin hết tiền vào tháng 7 (tháng thứ 7)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin có 1580 đơn vị tiền tệ vào cuối năm", "id": "Menghitung jumlah total uang yang akan dimiliki Jinjin pada akhir tahun setelah mengikuti rencana tabungannya dengan ibunya. Setiap bulan, dia dapat menabung kelipatan 100 dari uang sakunya (300 per bulan) jika dia memperkirakan memiliki setidaknya 100 unit tersisa setelah pengeluaran. Uang yang ditabung akan mendapatkan bunga 20% pada akhir tahun.\n\nParameter:\nbudgets (List[int]): Daftar 12 bilangan bulat yang mewakili anggaran bulanan Jinjin.\n\nMengembalikan:\nint: Jumlah total uang yang akan dimiliki Jinjin pada akhir tahun setelah bunga. Jika Jinjin kehabisan uang di bulan tertentu, mengembalikan nilai negatif dari bulan tersebut (-X, di mana X adalah nomor bulan).\n\nContoh:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin kehabisan uang di bulan Juli (bulan ke-7)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin memiliki 1580 unit mata uang pada akhir tahun", "ja": "年末までにJinjinが母親との貯蓄計画に従って持つことになる総額を計算します。毎月、彼女は少なくとも100単位が支出後に残ると予測できれば、お小遣い（毎月300）から100の倍数を貯金することができます。貯めたお金は年末に20%の利息がつきます。\n\n引数:\nbudgets (List[int]): Jinjinの月ごとの予算を表す12個の整数のリスト。\n\n戻り値:\nint: 年末に利息を含めてJinjinが持つことになる総額。Jinjinが任意の月でお金が不足した場合、その月の負の値（-X、ここでXは月の番号）を返します。\n\n例:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjinは7月（7番目の月）にお金が不足します\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjinは年末に1580単位の通貨を持っています", "ko": "연말까지 Jinjin이 저축 계획을 따라 어머니와 함께 모을 총 금액을 계산합니다. 매달 그녀는 용돈(월 300)에서 100 단위 이상이 남을 것으로 예상되면 100의 배수를 저축할 수 있습니다. 저축한 돈은 연말에 20%의 이자를 얻습니다.\n\n매개변수:\nbudgets (List[int]): Jinjin의 월별 예산을 나타내는 12개의 정수 리스트.\n\n반환:\nint: 연말에 Jinjin이 이자를 포함하여 갖게 될 총 금액.\nJinjin이 어떤 달에 돈이 부족해지면, 그 달의 음수 값을 반환합니다 (-X, 여기서 X는 달 번호입니다).\n\n예제:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin은 7월(7번째 달)에 돈이 부족합니다.\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin은 연말까지 1580 단위의 통화를 갖습니다.", "ml": "ജിൻജിൻ അവളുടെ അമ്മയോടൊപ്പം അവളുടെ സംരക്ഷണ പദ്ധതിയെ പിന്തുടർന്ന് വർഷാവസാനത്തോടെ എത്ര പണം ഉണ്ടാകും\n    എന്നത് കണക്കാക്കുന്നു. ഓരോ മാസവും, ചെലവുകൾക്കുശേഷം കുറഞ്ഞത് 100 യൂണിറ്റ് ശേഷിക്കുമെന്ന് അവൾ പ്രവചിച്ചാൽ\n    അവളുടെ പോക്കറ്റ് മണിയിൽ നിന്ന് (മാസത്തിൽ 300) 100ന്റെ ഗുണിതകങ്ങൾ അവൾ സംരക്ഷിക്കാം. സംരക്ഷിച്ച പണം \n    വർഷാവസാനത്തിൽ 20% പലിശ നേടും.\n\nParameters:\nbudgets (List[int]): ജിൻജിന്റെ മാസാന്ത ബജറ്റ് പ്രതിനിധീകരിക്കുന്ന 12 പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n\nReturns:\nint: വർഷാവസാനത്തിൽ പലിശയ്ക്കുശേഷം ജിൻജിനുണ്ടാകുന്ന മൊത്തം പണം. ജിൻജിന് ഏതെങ്കിലും മാസത്തിൽ പണം തീർന്നാൽ, ആ മാസത്തിന്റെ നെഗറ്റീവ് മൂല്യം (-X, എവിടെ X മാസ സംഖ്യയാണ്) തിരിച്ചുനൽകുന്നു.\n\nExamples:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # ജിൻജിന് ജൂലൈയിൽ (7-ആം മാസം) പണം തീർന്നിരിക്കുന്നു\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # വർഷാവസാനത്തിൽ ജിൻജിന് 1580 കറൻസി യൂണിറ്റുകൾ ഉണ്ട്", "fa": "محاسبه می‌کند که جینجین تا پایان سال پس از دنبال کردن برنامه پس‌انداز خود با مادرش چه مقدار پول خواهد داشت. هر ماه، او می‌تواند مضرب‌های 100 از پول توجیبی خود (300 در ماه) را پس‌انداز کند اگر پیش‌بینی کند که پس از هزینه‌ها حداقل 100 واحد باقی بماند. پول پس‌انداز شده در پایان سال 20٪ سود خواهد داشت.\n\nپارامترها:\nbudgets (List[int]): لیستی از 12 عدد صحیح که بودجه ماهانه جینجین را نشان می‌دهد.\n\nبازگشت:\nint: مجموع پولی که جینجین در پایان سال پس از سود خواهد داشت. اگر جینجین در هر ماهی پولش تمام شود، مقدار منفی آن ماه را برمی‌گرداند (-X، که X شماره ماه است).\n\nمثال‌ها:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # جینجین در ماه ژوئیه (ماه هفتم) پولش تمام می‌شود\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # جینجین تا پایان سال 1580 واحد پول دارد"}}
{"task_id": "Python/45", "prompt": {"en": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Merging (5+5) with a total cost of 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\n        # followed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\n        # Total cost is 30+60+90+150 = 300.\n    \"\"\"", "sq": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Llogarit koston minimale totale për të bashkuar disa grumbuj frutash në një grumbull të vetëm.\n    Kostoja e bashkimit të dy grumbujve është e barabartë me shumën e peshave të tyre. Funksioni përdor\n    një algoritëm lakmitar me një grumbull minimal (radhë prioriteti) për të siguruar që grumbujt më të vegjël të bashkohen të parët,\n    duke minimizuar koston totale.\n\n    Parametrat:\n    fruit_counts (List[int]): Një listë e numrave të plotë që përfaqësojnë numrat e secilit lloj fruti.\n\n    Kthen:\n    int: Kostoja minimale totale e kërkuar për të bashkuar të gjithë grumbujt e frutave.\n\n    Shembuj:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Bashkimi (1+2) me një kosto prej 3, dhe pastaj (3+9) me një kosto prej 12, jep një kosto totale prej 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Bashkimi (5+5) me një kosto totale prej 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Një mënyrë optimale është bashkimi 10+20 (kosto 30), pastaj bashkimi 30+30 (kosto 60),\n        # pasuar nga 40+50 (kosto 90), dhe në fund bashkimi i dy grumbujve të mbetur 60+90 (kosto 150).\n        # Kostoja totale është 30+60+90+150 = 300.\n    \"\"\"", "hy": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Հաշվում է մրգերի մի քանի կույտերը մեկ կույտի մեջ միացնելու նվազագույն ընդհանուր արժեքը:\n    Երկու կույտերի միացման արժեքը հավասար է նրանց կշիռների գումարին: Ֆունկցիան օգտագործում է\n    ագահ ալգորիթմ մին-կույտով (առաջնահերթության հերթ)՝ ապահովելու համար, որ ամենափոքր կույտերը\n    առաջինը միացվեն՝ նվազեցնելով ընդհանուր արժեքը:\n\n    Պարամետրեր:\n    fruit_counts (List[int]): Թվերի ցուցակ, որը ներկայացնում է յուրաքանչյուր տեսակի մրգի քանակը:\n\n    Վերադարձնում է:\n    int: Նվազագույն ընդհանուր արժեքը, որը պահանջվում է մրգերի բոլոր կույտերը միացնելու համար:\n\n    Օրինակներ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Միացնելով (1+2) արժեքով 3, և ապա (3+9) արժեքով 12, ստացվում է ընդհանուր արժեք 15:\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Միացնելով (5+5) ընդհանուր արժեքով 10:\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Մեկ օպտիմալ եղանակ է միացնել 10+20 (արժեք 30), ապա միացնել 30+30 (արժեք 60),\n        # այնուհետև 40+50 (արժեք 90), և վերջապես միացնել երկու մնացած կույտերը 60+90 (արժեք 150):\n        # Ընդհանուր արժեքը 30+60+90+150 = 300:\n    \"\"\"", "bn": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    একাধিক ফলের স্তূপকে একক স্তূপে একত্রিত করার জন্য সর্বনিম্ন মোট খরচ হিসাব করে।\n    দুটি স্তূপ একত্রিত করার খরচ তাদের ওজনের সমান। ফাংশনটি একটি লোভী অ্যালগরিদম ব্যবহার করে\n    একটি মিন-হিপ (অগ্রাধিকার সারি) সহ নিশ্চিত করে যে ছোট স্তূপগুলি প্রথমে একত্রিত হয়,\n    মোট খরচ কমিয়ে দেয়।\n\n    প্যারামিটার:\n    fruit_counts (List[int]): প্রতিটি ধরণের ফলের গণনা উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: সমস্ত ফলের স্তূপ একত্রিত করার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ।\n\n    উদাহরণ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # (1+2) একত্রিত করার খরচ 3, এবং তারপর (3+9) একত্রিত করার খরচ 12, মোট খরচ 15 দেয়।\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # (5+5) একত্রিত করার মোট খরচ 10।\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # একটি সর্বোত্তম উপায় হল 10+20 (খরচ 30) একত্রিত করা, তারপর 30+30 (খরচ 60) একত্রিত করা,\n        # তারপরে 40+50 (খরচ 90), এবং অবশেষে দুটি অবশিষ্ট স্তূপ 60+90 (খরচ 150) একত্রিত করা।\n        # মোট খরচ 30+60+90+150 = 300।\n    \"\"\"", "bg": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Изчислява минималната обща цена за сливане на множество купчини плодове в една купчина.\n    Цената за сливане на две купчини е равна на сумата от техните тегла. Функцията използва\n    алчен алгоритъм с мин-купа (приоритетна опашка), за да гарантира, че най-малките купчини се сливат първи,\n    минимизирайки общата цена.\n\n    Параметри:\n    fruit_counts (List[int]): Списък от цели числа, представляващи броя на всеки вид плод.\n\n    Връща:\n    int: Минималната обща цена, необходима за сливане на всички купчини плодове.\n\n    Примери:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Сливане (1+2) с цена 3, и след това (3+9) с цена 12, дава обща цена от 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Сливане (5+5) с обща цена 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Един оптимален начин е сливане на 10+20 (цена 30), след това сливане на 30+30 (цена 60),\n        # следвано от 40+50 (цена 90), и накрая сливане на двете останали купчини 60+90 (цена 150).\n        # Общата цена е 30+60+90+150 = 300.\n    \"\"\"", "zh": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    计算将多个水果堆合并成一个堆的最小总成本。\n    合并两个堆的成本等于它们重量的总和。该函数利用贪心算法和最小堆（优先队列）\n    来确保首先合并最小的堆，从而最小化总成本。\n\n    参数:\n    fruit_counts (List[int]): 一个整数列表，表示每种水果的数量。\n\n    返回:\n    int: 合并所有水果堆所需的最小总成本。\n\n    示例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # 合并 (1+2) 的成本为 3，然后合并 (3+9) 的成本为 12，总成本为 15。\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # 合并 (5+5) 的总成本为 10。\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # 一种最优方式是合并 10+20（成本 30），然后合并 30+30（成本 60），\n        # 接着合并 40+50（成本 90），最后合并剩下的两个堆 60+90（成本 150）。\n        # 总成本是 30+60+90+150 = 300。\n    \"\"\"", "fr": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calcule le coût total minimum pour fusionner plusieurs tas de fruits en un seul tas.\n    Le coût de fusion de deux tas est égal à la somme de leurs poids. La fonction utilise\n    un algorithme glouton avec un tas minimum (file de priorité) pour s'assurer que les plus petits tas sont fusionnés en premier,\n    minimisant ainsi le coût total.\n\n    Paramètres:\n    fruit_counts (List[int]): Une liste d'entiers représentant les quantités de chaque type de fruit.\n\n    Retourne:\n    int: Le coût total minimum requis pour fusionner tous les tas de fruits.\n\n    Exemples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Fusionner (1+2) avec un coût de 3, puis (3+9) avec un coût de 12, donne un coût total de 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Fusionner (5+5) avec un coût total de 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Une façon optimale est de fusionner 10+20 (coût 30), puis fusionner 30+30 (coût 60),\n        # suivi par 40+50 (coût 90), et enfin fusionner les deux tas restants 60+90 (coût 150).\n        # Le coût total est 30+60+90+150 = 300.\n    \"\"\"", "de": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Berechnet die minimalen Gesamtkosten, um mehrere Haufen von Früchten zu einem einzigen Haufen zu verschmelzen.\n    Die Kosten für das Verschmelzen von zwei Haufen entsprechen der Summe ihrer Gewichte. Die Funktion verwendet\n    einen gierigen Algorithmus mit einem Min-Heap (Prioritätswarteschlange), um sicherzustellen, dass die kleinsten Haufen zuerst verschmolzen werden,\n    wodurch die Gesamtkosten minimiert werden.\n\n    Parameter:\n    fruit_counts (List[int]): Eine Liste von ganzen Zahlen, die die Anzahl der Früchte jeder Art darstellen.\n\n    Rückgabewert:\n    int: Die minimalen Gesamtkosten, die erforderlich sind, um alle Haufen von Früchten zu verschmelzen.\n\n    Beispiele:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Verschmelzen von (1+2) mit Kosten von 3 und dann (3+9) mit Kosten von 12 ergibt Gesamtkosten von 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Verschmelzen von (5+5) mit Gesamtkosten von 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Eine optimale Methode ist das Verschmelzen von 10+20 (Kosten 30), dann das Verschmelzen von 30+30 (Kosten 60),\n        # gefolgt von 40+50 (Kosten 90) und schließlich das Verschmelzen der beiden verbleibenden Haufen 60+90 (Kosten 150).\n        # Gesamtkosten sind 30+60+90+150 = 300.\n    \"\"\"", "ha": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Lissafa mafi ƙarancin jimillar kuɗi don haɗa tarin 'ya'yan itatuwa da yawa zuwa tarin guda.\n    Farashin haɗa tarin biyu yana daidai da jimillar nauyin su. Aikin yana amfani da\n    dabarun kwaikwayo tare da ƙaramin tarin (layin fifiko) don tabbatar da cewa an fara haɗa ƙananan tarin,\n    yana rage jimillar kuɗi.\n\n    Sigogi:\n    fruit_counts (List[int]): Jerin lambobi da ke wakiltar ƙididdigar kowane nau'in 'ya'yan itace.\n\n    Komawa:\n    int: Mafi ƙarancin jimillar kuɗi da ake buƙata don haɗa dukkan tarin 'ya'yan itatuwa.\n\n    Misalai:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Haɗa (1+2) tare da kuɗin 3, sannan (3+9) tare da kuɗin 12, yana ba da jimillar kuɗi 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Haɗa (5+5) tare da jimillar kuɗi 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Ɗaya daga cikin hanyoyin da za a iya bi shi ne haɗa 10+20 (kuɗi 30), sannan haɗa 30+30 (kuɗi 60),\n        # biye da 40+50 (kuɗi 90), kuma a ƙarshe haɗa ragowar tarin guda biyu 60+90 (kuɗi 150).\n        # Jimillar kuɗi ita ce 30+60+90+150 = 300.\n    \"\"\"", "hi": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    कई ढेरों फलों को एक ही ढेर में मिलाने की न्यूनतम कुल लागत की गणना करता है।\n    दो ढेरों को मिलाने की लागत उनके भार के योग के बराबर होती है। यह फ़ंक्शन सुनिश्चित करने के लिए\n    एक लालची एल्गोरिदम के साथ एक मिन-हीप (प्राथमिकता कतार) का उपयोग करता है कि सबसे छोटे ढेर पहले\n    मिलाए जाएं, जिससे कुल लागत न्यूनतम हो।\n\n    पैरामीटर्स:\n    fruit_counts (List[int]): प्रत्येक प्रकार के फल की गिनती का प्रतिनिधित्व करने वाली पूर्णांकों की एक सूची।\n\n    रिटर्न्स:\n    int: सभी फलों के ढेरों को मिलाने के लिए आवश्यक न्यूनतम कुल लागत।\n\n    उदाहरण:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # (1+2) को 3 की लागत से मिलाना, और फिर (3+9) को 12 की लागत से मिलाना, कुल लागत 15 देता है।\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # (5+5) को 10 की कुल लागत से मिलाना।\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # एक इष्टतम तरीका है 10+20 को मिलाना (लागत 30), फिर 30+30 को मिलाना (लागत 60),\n        # उसके बाद 40+50 को मिलाना (लागत 90), और अंत में बचे हुए दो ढेरों 60+90 को मिलाना (लागत 150)।\n        # कुल लागत 30+60+90+150 = 300 है।\n    \"\"\"", "hu": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Kiszámítja a minimális összköltséget, hogy több gyümölcshalmazt egyetlen halmazzá egyesítsen.\n    Két halmaz egyesítésének költsége megegyezik a súlyuk összegével. A függvény egy mohó algoritmust\n    használ egy min-kupaccal (prioritási sor), hogy biztosítsa, a legkisebb halmazok kerülnek először egyesítésre,\n    minimalizálva az összköltséget.\n\n    Paraméterek:\n    fruit_counts (List[int]): Egész számokat tartalmazó lista, amely az egyes gyümölcstípusok számát jelöli.\n\n    Visszatérési érték:\n    int: A minimális összköltség, amely szükséges az összes gyümölcshalmaz egyesítéséhez.\n\n    Példák:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Az (1+2) egyesítése 3 költséggel, majd a (3+9) egyesítése 12 költséggel, összesen 15 költséget ad.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Az (5+5) egyesítése összesen 10 költséggel.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Egy optimális mód az, ha először 10+20-at egyesítünk (30 költség), majd 30+30-at (60 költség),\n        # ezt követően 40+50-et (90 költség), és végül a két megmaradt halmazt 60+90 (150 költség).\n        # Az összköltség 30+60+90+150 = 300.\n    \"\"\"", "es": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calcula el costo total mínimo para fusionar múltiples montones de frutas en un solo montón.\n    El costo de fusionar dos montones es igual a la suma de sus pesos. La función utiliza\n    un algoritmo codicioso con un montón mínimo (cola de prioridad) para asegurar que los montones más pequeños se fusionen primero,\n    minimizando el costo total.\n\n    Parámetros:\n    fruit_counts (List[int]): Una lista de enteros que representa las cantidades de cada tipo de fruta.\n\n    Devuelve:\n    int: El costo total mínimo requerido para fusionar todos los montones de frutas.\n\n    Ejemplos:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Fusionar (1+2) con un costo de 3, y luego (3+9) con un costo de 12, da un costo total de 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Fusionar (5+5) con un costo total de 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Una forma óptima es fusionar 10+20 (costo 30), luego fusionar 30+30 (costo 60),\n        # seguido de 40+50 (costo 90), y finalmente fusionar los dos montones restantes 60+90 (costo 150).\n        # El costo total es 30+60+90+150 = 300.\n    \"\"\"", "arb": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    يحسب الحد الأدنى للتكلفة الإجمالية لدمج أكوام متعددة من الفواكه في كومة واحدة.\n    تكلفة دمج كومتين تساوي مجموع أوزانهما. تستخدم الدالة خوارزمية جشعة مع كومة ذات أولوية (طابور ذو أولوية)\n    لضمان دمج أصغر الأكوام أولاً، مما يقلل من التكلفة الإجمالية.\n\n    المعاملات:\n    fruit_counts (List[int]): قائمة من الأعداد الصحيحة تمثل عدد كل نوع من الفاكهة.\n\n    العوائد:\n    int: الحد الأدنى للتكلفة الإجمالية المطلوبة لدمج جميع أكوام الفواكه.\n\n    أمثلة:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # دمج (1+2) بتكلفة 3، ثم (3+9) بتكلفة 12، يعطي تكلفة إجمالية قدرها 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # دمج (5+5) بتكلفة إجمالية قدرها 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # إحدى الطرق المثلى هي دمج 10+20 (بتكلفة 30)، ثم دمج 30+30 (بتكلفة 60)،\n        # يليها دمج 40+50 (بتكلفة 90)، وأخيراً دمج الكومتين المتبقيتين 60+90 (بتكلفة 150).\n        # التكلفة الإجمالية هي 30+60+90+150 = 300.\n    \"\"\"", "sw": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Inakokotoa gharama ndogo kabisa ya jumla ya kuunganisha marundo mengi ya matunda kuwa rundo moja.\n    Gharama ya kuunganisha marundo mawili ni sawa na jumla ya uzito wao. Kazi hii inatumia\n    algorithimu ya pupa na min-heap (foleni ya kipaumbele) kuhakikisha marundo madogo yanaunganishwa kwanza,\n    kupunguza gharama ya jumla.\n\n    Vigezo:\n    fruit_counts (List[int]): Orodha ya namba zinazowakilisha idadi ya kila aina ya matunda.\n\n    Inarudisha:\n    int: Gharama ndogo kabisa ya jumla inayohitajika kuunganisha marundo yote ya matunda.\n\n    Mifano:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Kuunganisha (1+2) kwa gharama ya 3, na kisha (3+9) kwa gharama ya 12, inatoa gharama ya jumla ya 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Kuunganisha (5+5) kwa gharama ya jumla ya 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Njia moja bora ni kuunganisha 10+20 (gharama 30), kisha kuunganisha 30+30 (gharama 60),\n        # ikifuatiwa na 40+50 (gharama 90), na hatimaye kuunganisha marundo mawili yaliyobaki 60+90 (gharama 150).\n        # Gharama ya jumla ni 30+60+90+150 = 300.\n    \"\"\"", "tr": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Birden fazla meyve yığınını tek bir yığın halinde birleştirmek için minimum toplam maliyeti hesaplar.\n    İki yığını birleştirmenin maliyeti, ağırlıklarının toplamına eşittir. Fonksiyon, en küçük yığınların\n    önce birleştirilmesini sağlamak için bir min-heap (öncelik kuyruğu) ile açgözlü bir algoritma kullanır,\n    böylece toplam maliyet en aza indirilir.\n\n    Parametreler:\n    fruit_counts (List[int]): Her bir meyve türünün sayısını temsil eden bir tamsayı listesi.\n\n    Döndürür:\n    int: Tüm meyve yığınlarını birleştirmek için gereken minimum toplam maliyet.\n\n    Örnekler:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # (1+2) yığınını 3 maliyetle birleştirip, ardından (3+9) yığınını 12 maliyetle birleştirerek toplamda 15 maliyet elde edilir.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # (5+5) yığınını toplam 10 maliyetle birleştirir.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Bir optimal yol, 10+20'yi (maliyet 30) birleştirmek, ardından 30+30'u (maliyet 60) birleştirmek,\n        # sonra 40+50'yi (maliyet 90) ve son olarak kalan iki yığını 60+90'ı (maliyet 150) birleştirmektir.\n        # Toplam maliyet 30+60+90+150 = 300'dür.\n    \"\"\"", "vi": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Tính toán tổng chi phí tối thiểu để gộp nhiều đống trái cây thành một đống duy nhất.\n    Chi phí gộp hai đống bằng tổng trọng lượng của chúng. Hàm sử dụng\n    thuật toán tham lam với một heap nhỏ nhất (hàng đợi ưu tiên) để đảm bảo các đống nhỏ nhất được gộp trước,\n    giảm thiểu tổng chi phí.\n\n    Tham số:\n    fruit_counts (List[int]): Một danh sách các số nguyên đại diện cho số lượng của mỗi loại trái cây.\n\n    Trả về:\n    int: Tổng chi phí tối thiểu cần thiết để gộp tất cả các đống trái cây.\n\n    Ví dụ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Gộp (1+2) với chi phí 3, sau đó (3+9) với chi phí 12, tổng chi phí là 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Gộp (5+5) với tổng chi phí 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Một cách tối ưu là gộp 10+20 (chi phí 30), sau đó gộp 30+30 (chi phí 60),\n        # tiếp theo là gộp 40+50 (chi phí 90), và cuối cùng gộp hai đống còn lại 60+90 (chi phí 150).\n        # Tổng chi phí là 30+60+90+150 = 300.\n    \"\"\"", "id": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Menghitung total biaya minimum untuk menggabungkan beberapa tumpukan buah menjadi satu tumpukan.\n    Biaya penggabungan dua tumpukan sama dengan jumlah berat mereka. Fungsi ini menggunakan\n    algoritma greedy dengan min-heap (antrian prioritas) untuk memastikan tumpukan terkecil digabungkan terlebih dahulu,\n    meminimalkan total biaya.\n\n    Parameter:\n    fruit_counts (List[int]): Daftar bilangan bulat yang mewakili jumlah setiap jenis buah.\n\n    Mengembalikan:\n    int: Total biaya minimum yang diperlukan untuk menggabungkan semua tumpukan buah.\n\n    Contoh:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Menggabungkan (1+2) dengan biaya 3, dan kemudian (3+9) dengan biaya 12, memberikan total biaya 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Menggabungkan (5+5) dengan total biaya 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Salah satu cara optimal adalah menggabungkan 10+20 (biaya 30), kemudian menggabungkan 30+30 (biaya 60),\n        # diikuti dengan 40+50 (biaya 90), dan akhirnya menggabungkan dua tumpukan yang tersisa 60+90 (biaya 150).\n        # Total biaya adalah 30+60+90+150 = 300.\n    \"\"\"", "ja": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    複数の果物の山を1つの山に統合するための最小の総コストを計算します。\n    2つの山を統合するコストは、それらの重さの合計に等しいです。この関数は、\n    最小ヒープ（優先度キュー）を使用した貪欲アルゴリズムを利用して、\n    最小の山を最初に統合し、総コストを最小化します。\n\n    パラメータ:\n    fruit_counts (List[int]): 各種類の果物の数を表す整数のリスト。\n\n    戻り値:\n    int: すべての果物の山を統合するために必要な最小の総コスト。\n\n    例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # (1+2)をコスト3で統合し、その後(3+9)をコスト12で統合すると、総コストは15になります。\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # (5+5)を総コスト10で統合します。\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # 最適な方法の1つは、10+20を統合（コスト30）、次に30+30を統合（コスト60）、\n        # 続いて40+50を統合（コスト90）、最後に残りの2つの山60+90を統合（コスト150）。\n        # 総コストは30+60+90+150 = 300。\n    \"\"\"", "ko": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    여러 개의 과일 더미를 하나의 더미로 합치는 데 필요한 최소 총 비용을 계산합니다.\n    두 더미를 합치는 비용은 그들의 무게 합과 같습니다. 이 함수는 가장 작은 더미가 먼저 합쳐지도록\n    하기 위해 최소 힙(우선순위 큐)을 사용하는 탐욕 알고리즘을 활용하여 총 비용을 최소화합니다.\n\n    매개변수:\n    fruit_counts (List[int]): 각 종류의 과일 개수를 나타내는 정수 리스트입니다.\n\n    반환값:\n    int: 모든 과일 더미를 합치는 데 필요한 최소 총 비용입니다.\n\n    예시:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # (1+2)를 비용 3으로 합치고, 그 다음 (3+9)를 비용 12로 합치면 총 비용은 15입니다.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # (5+5)를 총 비용 10으로 합칩니다.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # 하나의 최적 방법은 10+20 (비용 30)을 합치고, 그 다음 30+30 (비용 60)을 합치고,\n        # 40+50 (비용 90)을 합친 후, 마지막으로 남은 두 더미 60+90 (비용 150)을 합치는 것입니다.\n        # 총 비용은 30+60+90+150 = 300입니다.\n    \"\"\"", "ml": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    നിരവധി കൂമ്പാരങ്ങളായ ഫലങ്ങളെ ഒറ്റ കൂമ്പാരമാക്കി ലയിപ്പിക്കുന്നതിനുള്ള കുറഞ്ഞ മൊത്തം ചെലവ് കണക്കാക്കുന്നു.\n    രണ്ട് കൂമ്പാരങ്ങളെ ലയിപ്പിക്കുന്നതിനുള്ള ചെലവ് അവയുടെ ഭാരങ്ങളുടെ തുല്യമാണ്. ഏറ്റവും ചെറിയ കൂമ്പാരങ്ങൾ ആദ്യം ലയിപ്പിക്കപ്പെടുന്നുവെന്ന് ഉറപ്പാക്കാൻ\n    ഒരു മിൻ-കൂമ്പാരം (പ്രാഥമിക ക്യൂ) ഉപയോഗിച്ച് ഒരു ലോഭാലോചന ആൽഗോരിതം ഉപയോഗിക്കുന്നു, മൊത്തം ചെലവ് കുറയ്ക്കുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    fruit_counts (List[int]): ഓരോ തരം ഫലത്തിന്റെ എണ്ണങ്ങളെ പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n\n    മടക്കങ്ങൾ:\n    int: എല്ലാ ഫലങ്ങളുടെ കൂമ്പാരങ്ങളും ലയിപ്പിക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ്.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # (1+2) 3 എന്ന ചെലവിൽ ലയിപ്പിക്കുന്നു, തുടർന്ന് (3+9) 12 എന്ന ചെലവിൽ, മൊത്തം ചെലവ് 15 നൽകുന്നു.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # (5+5) 10 എന്ന മൊത്തം ചെലവിൽ ലയിപ്പിക്കുന്നു.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # ഒരു ഓപ്റ്റിമൽ മാർഗ്ഗം 10+20 (ചെലവ് 30) ലയിപ്പിക്കുന്നതാണ്, തുടർന്ന് 30+30 (ചെലവ് 60) ലയിപ്പിക്കുന്നു,\n        # തുടർന്ന് 40+50 (ചെലവ് 90), ഒടുവിൽ ബാക്കി രണ്ട് കൂമ്പാരങ്ങൾ 60+90 (ചെലവ് 150) ലയിപ്പിക്കുന്നു.\n        # മൊത്തം ചെലവ് 30+60+90+150 = 300 ആണ്.\n    \"\"\"", "fa": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    حداقل هزینه کل برای ادغام چندین توده میوه به یک توده واحد را محاسبه می‌کند.\n    هزینه ادغام دو توده برابر با مجموع وزن‌های آن‌ها است. این تابع از یک الگوریتم حریصانه\n    با یک توده کمینه (صف اولویت) استفاده می‌کند تا اطمینان حاصل شود که کوچک‌ترین توده‌ها ابتدا ادغام می‌شوند،\n    و هزینه کل را به حداقل می‌رساند.\n\n    پارامترها:\n    fruit_counts (List[int]): لیستی از اعداد صحیح که تعداد هر نوع میوه را نشان می‌دهد.\n\n    خروجی:\n    int: حداقل هزینه کل مورد نیاز برای ادغام تمام توده‌های میوه.\n\n    مثال‌ها:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # ادغام (1+2) با هزینه 3، و سپس (3+9) با هزینه 12، هزینه کل 15 را می‌دهد.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # ادغام (5+5) با هزینه کل 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # یک روش بهینه ادغام 10+20 (هزینه 30)، سپس ادغام 30+30 (هزینه 60)،\n        # به دنبال آن 40+50 (هزینه 90)، و در نهایت ادغام دو توده باقی‌مانده 60+90 (هزینه 150).\n        # هزینه کل 30+60+90+150 = 300 است.\n    \"\"\""}, "canonical_solution": "    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost", "instruction": {"en": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nՏվյալ Python կոդի համար տրամադրեք համառոտ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\n请用中文为以下 Python 代码提供简洁的自然语言描述（文档字符串），不超过 500 个字符。", "fr": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.", "hi": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.", "sw": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\n以下のPythonコードの自然言語による簡潔な説明（ドックストリング）を、日本語で500文字以内で提供してください。", "ko": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\n다음 Python 코드에 대한 간결한 자연어 설명(독스트링)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nتوضیح مختصری به زبان طبیعی (docstring) از کد پایتون به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "def test_minimum_cost_to_merge_fruits():\n    # Test case 1: As provided in the problem statement example\n    fruits1 = [1, 2, 9]\n    assert minimum_cost_to_merge_fruits(fruits1) == 15, \"Test case 1 failed\"\n\n    # Test case 2: Simple case with only two types of fruits\n    fruits2 = [5, 5]\n    assert minimum_cost_to_merge_fruits(fruits2) == 10, \"Test case 2 failed\"\n\n    # Test case 3: More complex case with multiple types of fruits\n    fruits3 = [10, 20, 30, 40, 50]\n    assert minimum_cost_to_merge_fruits(fruits3) == 330, \"Test case 3 failed\"\n\n    # Test case 4: Case with fruits having the same count\n    fruits4 = [3, 3, 3, 3]\n    assert minimum_cost_to_merge_fruits(fruits4) == 24, \"Test case 4 failed\"\n\n    # Test case 5: Case with a single type of fruit\n    fruits5 = [7]\n    assert minimum_cost_to_merge_fruits(fruits5) == 0, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_minimum_cost_to_merge_fruits()", "entry_point": "minimum_cost_to_merge_fruits", "signature": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:", "docstring": {"en": "Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\nThe cost of merging two heaps is equal to the sum of their weights. The function utilizes\na greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\nminimizing the total cost.\n\nParameters:\nfruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\nReturns:\nint: The minimum total cost required to merge all heaps of fruits.\n\nExamples:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Merging (5+5) with a total cost of 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\nfollowed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\nTotal cost is 30+60+90+150 = 300.", "sq": "Llogarit koston minimale totale për të bashkuar disa grumbuj frutash në një grumbull të vetëm. Kostoja e bashkimit të dy grumbujve është e barabartë me shumën e peshave të tyre. Funksioni përdor një algoritëm lakmitar me një grumbull minimal (radhë prioriteti) për të siguruar që grumbujt më të vegjël të bashkohen të parët, duke minimizuar koston totale.\n\nParametrat:\nfruit_counts (List[int]): Një listë e numrave të plotë që përfaqësojnë numrin e secilit lloj fruti.\n\nKthen:\nint: Kostoja minimale totale e kërkuar për të bashkuar të gjithë grumbujt e frutave.\n\nShembuj:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Bashkimi (1+2) me një kosto prej 3, dhe pastaj (3+9) me një kosto prej 12, jep një kosto totale prej 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Bashkimi (5+5) me një kosto totale prej 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Një mënyrë optimale është bashkimi 10+20 (kosto 30), pastaj bashkimi 30+30 (kosto 60),\nndjekur nga 40+50 (kosto 90), dhe në fund bashkimi i dy grumbujve të mbetur 60+90 (kosto 150).\nKostoja totale është 30+60+90+150 = 300.", "hy": "Հաշվում է մրգերի մի քանի կույտերը մեկ կույտի մեջ միացնելու նվազագույն ընդհանուր արժեքը: Երկու կույտերի միացման արժեքը հավասար է նրանց քաշերի գումարին: Ֆունկցիան օգտագործում է ագահ ալգորիթմ մին-կույտով (առաջնահերթության հերթ)՝ ապահովելու համար, որ ամենափոքր կույտերը առաջինը միացվեն, նվազեցնելով ընդհանուր արժեքը:\n\nՊարամետրեր:\nfruit_counts (List[int]): Թվերի ցուցակ, որը ներկայացնում է յուրաքանչյուր տեսակի մրգերի քանակը:\n\nՎերադարձնում է:\nint: Նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր մրգերի կույտերը միացնելու համար:\n\nՕրինակներ:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Միացնելով (1+2) արժեքով 3, և հետո (3+9) արժեքով 12, ստացվում է ընդհանուր արժեք 15:\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Միացնելով (5+5) ընդհանուր արժեքով 10:\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Մեկ օպտիմալ եղանակ է միացնել 10+20 (արժեք 30), հետո միացնել 30+30 (արժեք 60),\nհետո 40+50 (արժեք 90), և վերջապես միացնել մնացած երկու կույտերը 60+90 (արժեք 150):\nԸնդհանուր արժեքը 30+60+90+150 = 300:", "bn": "একাধিক ফলের স্তূপকে একটি একক স্তূপে একত্রিত করার জন্য সর্বনিম্ন মোট খরচ গণনা করে।\nদুইটি স্তূপ একত্রিত করার খরচ তাদের ওজনের সমান। ফাংশনটি একটি লোভী অ্যালগরিদম ব্যবহার করে\nএকটি মিন-হীপ (অগ্রাধিকার সারি) সহ নিশ্চিত করে যে ছোট স্তূপগুলি প্রথমে একত্রিত হয়,\nমোট খরচ কমিয়ে দেয়।\n\nপ্যারামিটারসমূহ:\nfruit_counts (List[int]): প্রতিটি প্রকারের ফলের সংখ্যা নির্দেশকারী পূর্ণসংখ্যার একটি তালিকা।\n\nরিটার্নস:\nint: সমস্ত ফলের স্তূপ একত্রিত করার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ।\n\nউদাহরণ:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # (1+2) একত্রিত করার খরচ 3, এবং তারপর (3+9) একত্রিত করার খরচ 12, মোট খরচ 15 দেয়।\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # (5+5) একত্রিত করার মোট খরচ 10।\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # একটি অনুকূল উপায় হলো 10+20 একত্রিত করা (খরচ 30), তারপর 30+30 একত্রিত করা (খরচ 60),\nএরপর 40+50 একত্রিত করা (খরচ 90), এবং শেষ পর্যন্ত অবশিষ্ট দুটি স্তূপ 60+90 একত্রিত করা (খরচ 150)।\nমোট খরচ হলো 30+60+90+150 = 300।", "bg": "Изчислява минималната обща стойност за сливане на множество купчини плодове в една купчина. Стойността на сливане на две купчини е равна на сумата от техните тегла. Функцията използва алчен алгоритъм с мин-купа (приоритетна опашка), за да гарантира, че най-малките купчини се сливат първи, минимизирайки общата стойност.\n\nПараметри:\nfruit_counts (List[int]): Списък от цели числа, представляващи броя на всеки вид плодове.\n\nВръща:\nint: Минималната обща стойност, необходима за сливане на всички купчини плодове.\n\nПримери:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Сливане (1+2) със стойност 3, и след това (3+9) със стойност 12, дава обща стойност 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Сливане (5+5) с обща стойност 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Един оптимален начин е сливане на 10+20 (стойност 30), след това сливане на 30+30 (стойност 60),\nпоследвано от 40+50 (стойност 90), и накрая сливане на двете останали купчини 60+90 (стойност 150).\nОбщата стойност е 30+60+90+150 = 300.", "zh": "计算将多个水果堆合并为一个堆的最小总成本。\n合并两个堆的成本等于它们重量的总和。该函数利用贪心算法与最小堆（优先队列）来确保最小的堆先合并，从而最小化总成本。\n\n参数：\nfruit_counts (List[int]): 一个整数列表，表示每种水果的数量。\n\n返回：\nint: 合并所有水果堆所需的最小总成本。\n\n示例：\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # 合并 (1+2) 的成本为 3，然后合并 (3+9) 的成本为 12，总成本为 15。\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # 合并 (5+5) 的总成本为 10。\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # 一种最优方式是合并 10+20（成本 30），然后合并 30+30（成本 60），\n接着合并 40+50（成本 90），最后合并剩下的两个堆 60+90（成本 150）。\n总成本是 30+60+90+150 = 300。", "fr": "Calcule le coût total minimum pour fusionner plusieurs tas de fruits en un seul tas. Le coût de fusion de deux tas est égal à la somme de leurs poids. La fonction utilise un algorithme glouton avec un tas min (file de priorité) pour s'assurer que les plus petits tas sont fusionnés en premier, minimisant ainsi le coût total.\n\nParamètres :\nfruit_counts (List[int]): Une liste d'entiers représentant les quantités de chaque type de fruit.\n\nRenvoie :\nint: Le coût total minimum requis pour fusionner tous les tas de fruits.\n\nExemples :\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Fusionner (1+2) avec un coût de 3, puis (3+9) avec un coût de 12, donne un coût total de 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Fusionner (5+5) avec un coût total de 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Une manière optimale est de fusionner 10+20 (coût 30), puis fusionner 30+30 (coût 60),\nsuivi de 40+50 (coût 90), et enfin fusionner les deux tas restants 60+90 (coût 150).\nLe coût total est 30+60+90+150 = 300.", "de": "Berechnet die minimalen Gesamtkosten, um mehrere Haufen von Früchten zu einem einzigen Haufen zusammenzuführen.\nDie Kosten für das Zusammenführen von zwei Haufen entsprechen der Summe ihrer Gewichte. Die Funktion verwendet\neinen gierigen Algorithmus mit einem Min-Heap (Prioritätswarteschlange), um sicherzustellen, dass die kleinsten Haufen zuerst zusammengeführt werden,\nwodurch die Gesamtkosten minimiert werden.\n\nParameter:\nfruit_counts (List[int]): Eine Liste von ganzen Zahlen, die die Anzahl jeder Fruchtsorte darstellen.\n\nRückgabewert:\nint: Die minimalen Gesamtkosten, die erforderlich sind, um alle Fruchthaufen zusammenzuführen.\n\nBeispiele:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Zusammenführen von (1+2) mit Kosten von 3 und dann (3+9) mit Kosten von 12 ergibt Gesamtkosten von 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Zusammenführen von (5+5) mit Gesamtkosten von 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Eine optimale Möglichkeit ist das Zusammenführen von 10+20 (Kosten 30), dann 30+30 (Kosten 60),\ngefolgt von 40+50 (Kosten 90) und schließlich das Zusammenführen der beiden verbleibenden Haufen 60+90 (Kosten 150).\nGesamtkosten sind 30+60+90+150 = 300.", "ha": "Yana ƙididdige mafi ƙarancin jimlar kuɗi don haɗa tarin 'ya'yan itatuwa da yawa zuwa tarin guda ɗaya. \nKuɗin haɗa tarin biyu ya yi daidai da jimlar nauyinsu. Aikin yana amfani da \nalgoritm mai kwaɗayi tare da ƙaramin tarin (layin fifiko) don tabbatar da cewa ana haɗa ƙananan tarin farko, \nyana rage jimlar kuɗi.\n\nSigogi:\nfruit_counts (List[int]): Jerin lambobi da ke wakiltar adadin kowanne nau'in 'ya'yan itace.\n\nAbubuwan da ake dawowa:\nint: Mafi ƙarancin jimlar kuɗi da ake buƙata don haɗa dukkan tarin 'ya'yan itatuwa.\n\nMisalai:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Haɗa (1+2) tare da kuɗin 3, sannan (3+9) tare da kuɗin 12, yana ba da jimlar kuɗi 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Haɗa (5+5) tare da jimlar kuɗi 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Ɗaya daga cikin hanyoyi masu kyau shine haɗa 10+20 (kuɗin 30), sannan haɗa 30+30 (kuɗin 60),\nsannan 40+50 (kuɗin 90), kuma a ƙarshe haɗa sauran tarin guda biyu 60+90 (kuɗin 150).\nJimlar kuɗi shine 30+60+90+150 = 300.", "hi": "फल के ढेरों को एक ही ढेर में मिलाने की न्यूनतम कुल लागत की गणना करता है।\nदो ढेरों को मिलाने की लागत उनके वजन के योग के बराबर होती है। यह फ़ंक्शन\nएक लालची एल्गोरिदम का उपयोग करता है जिसमें सबसे छोटे ढेर पहले मिलाए जाते हैं,\nजिससे कुल लागत न्यूनतम होती है।\n\nपैरामीटर्स:\nfruit_counts (List[int]): प्रत्येक प्रकार के फल की गिनती को दर्शाने वाली पूर्णांकों की एक सूची।\n\nवापसी:\nint: सभी फलों के ढेरों को मिलाने के लिए आवश्यक न्यूनतम कुल लागत।\n\nउदाहरण:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # (1+2) को 3 की लागत पर मिलाना, और फिर (3+9) को 12 की लागत पर मिलाना, कुल लागत 15 देता है।\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # (5+5) को मिलाना, कुल लागत 10।\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # एक आदर्श तरीका है 10+20 (लागत 30) को मिलाना, फिर 30+30 (लागत 60) को मिलाना,\nइसके बाद 40+50 (लागत 90), और अंत में दो शेष ढेरों 60+90 (लागत 150) को मिलाना।\nकुल लागत 30+60+90+150 = 300 है।", "hu": "Kiszámítja a minimális összköltséget, hogy több gyümölcshalom egyetlen halommá egyesüljön.\nKét halom egyesítésének költsége egyenlő a súlyuk összegével. A függvény egy mohó algoritmust használ egy min-halommal (prioritási sor), hogy biztosítsa, hogy a legkisebb halmokat egyesítik először, minimalizálva az összköltséget.\n\nParaméterek:\nfruit_counts (List[int]): Egész számokat tartalmazó lista, amely az egyes gyümölcstípusok számát jelöli.\n\nVisszatérési érték:\nint: Az összes gyümölcshalom egyesítéséhez szükséges minimális összköltség.\n\nPéldák:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Az (1+2) egyesítése 3 költséggel, majd a (3+9) egyesítése 12 költséggel, összesen 15 költséget ad.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Az (5+5) egyesítése összesen 10 költséggel.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Egy optimális mód az 10+20 egyesítése (30 költség), majd a 30+30 egyesítése (60 költség),\nezt követi a 40+50 egyesítése (90 költség), végül az utolsó két halom 60+90 egyesítése (150 költség).\nAz összköltség 30+60+90+150 = 300.", "es": "Calcula el costo total mínimo para fusionar múltiples montones de frutas en un solo montón. El costo de fusionar dos montones es igual a la suma de sus pesos. La función utiliza un algoritmo codicioso con un montón mínimo (cola de prioridad) para asegurar que los montones más pequeños se fusionen primero, minimizando el costo total.\n\nParámetros:\nfruit_counts (List[int]): Una lista de enteros que representa las cantidades de cada tipo de fruta.\n\nDevuelve:\nint: El costo total mínimo requerido para fusionar todos los montones de frutas.\n\nEjemplos:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Fusionar (1+2) con un costo de 3, y luego (3+9) con un costo de 12, da un costo total de 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Fusionar (5+5) con un costo total de 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Una forma óptima es fusionar 10+20 (costo 30), luego fusionar 30+30 (costo 60),\nseguido de 40+50 (costo 90), y finalmente fusionar los dos montones restantes 60+90 (costo 150).\nEl costo total es 30+60+90+150 = 300.", "arb": "يحسب الحد الأدنى للتكلفة الإجمالية لدمج أكوام متعددة من الفواكه في كومة واحدة.\nتكلفة دمج كومتين تساوي مجموع أوزانهما. تستخدم الدالة خوارزمية جشعة مع كومة ذات أولوية (طابور الأولوية) لضمان دمج أصغر الأكوام أولاً، مما يقلل التكلفة الإجمالية.\n\nالمعلمات:\nfruit_counts (List[int]): قائمة من الأعداد الصحيحة تمثل عدد كل نوع من الفاكهة.\n\nالقيم المعادة:\nint: الحد الأدنى للتكلفة الإجمالية المطلوبة لدمج جميع أكوام الفواكه.\n\nأمثلة:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # دمج (1+2) بتكلفة 3، ثم (3+9) بتكلفة 12، يعطي تكلفة إجمالية 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # دمج (5+5) بتكلفة إجمالية 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # إحدى الطرق المثلى هي دمج 10+20 (بتكلفة 30)، ثم دمج 30+30 (بتكلفة 60)،\nثم دمج 40+50 (بتكلفة 90)، وأخيراً دمج الكومتين المتبقيتين 60+90 (بتكلفة 150).\nالتكلفة الإجمالية هي 30+60+90+150 = 300.", "sw": "Hesabu gharama ndogo kabisa ya kuunganisha marundo mengi ya matunda kuwa rundo moja. Gharama ya kuunganisha marundo mawili ni sawa na jumla ya uzito wao. Kazi hii inatumia algoriti ya pupa na min-rundo (foleni ya kipaumbele) kuhakikisha marundo madogo zaidi yanaunganishwa kwanza, kupunguza gharama ya jumla.\n\nVigezo:\nfruit_counts (List[int]): Orodha ya namba inayoonyesha idadi ya kila aina ya tunda.\n\nRudisha:\nint: Gharama ndogo kabisa inayohitajika kuunganisha marundo yote ya matunda.\n\nMifano:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Kuunganisha (1+2) kwa gharama ya 3, na kisha (3+9) kwa gharama ya 12, inatoa gharama ya jumla ya 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Kuunganisha (5+5) kwa gharama ya jumla ya 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Njia moja bora ni kuunganisha 10+20 (gharama 30), kisha kuunganisha 30+30 (gharama 60),\nikifuatiwa na 40+50 (gharama 90), na hatimaye kuunganisha marundo mawili yaliyobaki 60+90 (gharama 150).\nGharama ya jumla ni 30+60+90+150 = 300.", "tr": "Birden fazla meyve yığınını tek bir yığın halinde birleştirmek için minimum toplam maliyeti hesaplar.\nİki yığını birleştirmenin maliyeti, ağırlıklarının toplamına eşittir. Fonksiyon, toplam maliyeti en aza indirmek için\nen küçük yığınların önce birleştirilmesini sağlamak amacıyla min-yığın (öncelik kuyruğu) ile açgözlü bir algoritma kullanır.\n\nParametreler:\nfruit_counts (List[int]): Her tür meyvenin sayısını temsil eden bir tamsayı listesi.\n\nDöndürülen:\nint: Tüm meyve yığınlarını birleştirmek için gereken minimum toplam maliyet.\n\nÖrnekler:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # (1+2) yığınını 3 maliyetle birleştirmek ve ardından (3+9) yığınını 12 maliyetle birleştirmek, toplamda 15 maliyet verir.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # (5+5) yığınını toplam 10 maliyetle birleştirmek.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Bir optimal yol, 10+20'yi (maliyet 30) birleştirmek, ardından 30+30'u (maliyet 60) birleştirmek,\n40+50'yi (maliyet 90) birleştirmek ve son olarak kalan iki yığını 60+90 (maliyet 150) birleştirmektir.\nToplam maliyet 30+60+90+150 = 300.", "vi": "Tính toán tổng chi phí tối thiểu để gộp nhiều đống trái cây thành một đống duy nhất. Chi phí gộp hai đống bằng tổng trọng lượng của chúng. Hàm sử dụng một thuật toán tham lam với một đống tối thiểu (hàng đợi ưu tiên) để đảm bảo các đống nhỏ nhất được gộp trước, giảm thiểu tổng chi phí.\n\nTham số:\nfruit_counts (List[int]): Một danh sách các số nguyên đại diện cho số lượng của mỗi loại trái cây.\n\nTrả về:\nint: Tổng chi phí tối thiểu cần thiết để gộp tất cả các đống trái cây.\n\nVí dụ:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Gộp (1+2) với chi phí 3, và sau đó (3+9) với chi phí 12, cho tổng chi phí là 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Gộp (5+5) với tổng chi phí là 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Một cách tối ưu là gộp 10+20 (chi phí 30), sau đó gộp 30+30 (chi phí 60),\ntiếp theo là 40+50 (chi phí 90), và cuối cùng gộp hai đống còn lại 60+90 (chi phí 150).\nTổng chi phí là 30+60+90+150 = 300.", "id": "Menghitung total biaya minimum untuk menggabungkan beberapa tumpukan buah menjadi satu tumpukan.\nBiaya penggabungan dua tumpukan sama dengan jumlah beratnya. Fungsi ini menggunakan\nalgoritma greedy dengan min-heap (antrian prioritas) untuk memastikan tumpukan terkecil digabungkan terlebih dahulu,\nmeminimalkan total biaya.\n\nParameter:\nfruit_counts (List[int]): Daftar bilangan bulat yang mewakili jumlah masing-masing jenis buah.\n\nMengembalikan:\nint: Biaya total minimum yang diperlukan untuk menggabungkan semua tumpukan buah.\n\nContoh:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Menggabungkan (1+2) dengan biaya 3, dan kemudian (3+9) dengan biaya 12, memberikan total biaya 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Menggabungkan (5+5) dengan total biaya 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Salah satu cara optimal adalah menggabungkan 10+20 (biaya 30), kemudian menggabungkan 30+30 (biaya 60),\ndiikuti oleh 40+50 (biaya 90), dan akhirnya menggabungkan dua tumpukan yang tersisa 60+90 (biaya 150).\nTotal biaya adalah 30+60+90+150 = 300.", "ja": "複数の果物の山を1つの山にまとめるための最小の総コストを計算します。\n2つの山を合併するコストは、それらの重さの合計に等しいです。この関数は、\n最小ヒープ（優先度キュー）を使用した貪欲アルゴリズムを利用して、最小の山が\n最初に合併されるようにし、総コストを最小化します。\n\n引数:\nfruit_counts (List[int]): 各種類の果物の数を表す整数のリスト。\n\n戻り値:\nint: すべての果物の山を合併するために必要な最小の総コスト。\n\n例:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # (1+2)をコスト3で合併し、その後(3+9)をコスト12で合併すると、合計コストは15になります。\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # (5+5)を合併して、合計コストは10になります。\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # 最適な方法の1つは、10+20を合併（コスト30）、次に30+30を合併（コスト60）し、\n続いて40+50を合併（コスト90）、最後に残りの2つの山60+90を合併（コスト150）します。\n合計コストは30+60+90+150 = 300です。", "ko": "여러 개의 과일 더미를 하나의 더미로 합치는데 필요한 최소 총 비용을 계산합니다.\n두 더미를 합치는 비용은 그들의 무게 합과 같습니다. 이 함수는 가장 작은 더미가 먼저 합쳐지도록\n보장하기 위해 최소 힙(우선순위 큐)을 사용하는 탐욕 알고리즘을 활용하여 총 비용을 최소화합니다.\n\n매개변수:\nfruit_counts (List[int]): 각 종류의 과일 수를 나타내는 정수 목록.\n\n반환값:\nint: 모든 과일 더미를 합치는데 필요한 최소 총 비용.\n\n예제:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # (1+2)를 합쳐 비용 3, 그리고 (3+9)를 합쳐 비용 12가 되어 총 비용은 15입니다.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # (5+5)를 합쳐 총 비용이 10입니다.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # 하나의 최적 방법은 10+20을 합쳐 비용 30, 그 다음 30+30을 합쳐 비용 60,\n40+50을 합쳐 비용 90, 마지막으로 남은 두 더미 60+90을 합쳐 비용 150입니다.\n총 비용은 30+60+90+150 = 300입니다.", "ml": "ഫലങ്ങളുടെ അനവധി കൂമ്പാരങ്ങളെ ഒരു കൂമ്പാരമായി ലയിപ്പിക്കുന്നതിനുള്ള കുറഞ്ഞ മൊത്തം ചെലവ് കണക്കാക്കുന്നു. രണ്ട് കൂമ്പാരങ്ങളെ ലയിപ്പിക്കുന്നതിനുള്ള ചെലവ് അവയുടെ ഭാരങ്ങളുടെ മൊത്തം തുകയ്ക്ക് തുല്യമാണ്.   ഏറ്റവും ചെറിയ കൂമ്പാരങ്ങൾ ആദ്യം ലയിപ്പിക്കപ്പെടുന്നുവെന്ന് ഉറപ്പാക്കാൻ ഈ ഫംഗ്ഷൻ ഒരു മിൻ-ഹീപ് (പ്രാഥമിക ക്യൂ) ഉപയോഗിക്കുന്ന ഒരു ഗ്രീഡി ആൽഗോരിതം ഉപയോഗിക്കുന്നു, മൊത്തം ചെലവ് കുറയ്ക്കുന്നു.\n\nParameters:\nfruit_counts (List[int]): ഓരോ ഫലത്തിന്റെ എണ്ണവും പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n\nReturns:\nint: എല്ലാ ഫലങ്ങളുടെ കൂമ്പാരങ്ങളും ലയിപ്പിക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ്.\n\nExamples:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # (1+2) നെ 3 എന്ന ചെലവിൽ ലയിപ്പിക്കുകയും, തുടർന്ന് (3+9) നെ 12 എന്ന ചെലവിൽ ലയിപ്പിക്കുകയും ചെയ്യുന്നു, മൊത്തം ചെലവ് 15 നൽകുന്നു.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # (5+5) നെ 10 എന്ന മൊത്തം ചെലവിൽ ലയിപ്പിക്കുന്നു.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # ഒരു മികച്ച മാർഗ്ഗം 10+20 (ചെലവ് 30) ലയിപ്പിക്കുകയും, തുടർന്ന് 30+30 (ചെലവ് 60) ലയിപ്പിക്കുകയും, തുടർന്ന് 40+50 (ചെലവ് 90) ലയിപ്പിക്കുകയും, അന്തിമമായി ബാക്കി രണ്ട് കൂമ്പാരങ്ങൾ 60+90 (ചെലവ് 150) ലയിപ്പിക്കുകയും ചെയ്യുന്നു. മൊത്തം ചെലവ് 30+60+90+150 = 300.", "fa": "محاسبه حداقل هزینه کل برای ادغام چندین توده میوه به یک توده واحد.\nهزینه ادغام دو توده برابر با مجموع وزن‌های آن‌ها است. این تابع از یک الگوریتم حریصانه با یک توده کوچک (صف اولویت) استفاده می‌کند تا اطمینان حاصل شود که کوچک‌ترین توده‌ها ابتدا ادغام می‌شوند و هزینه کل به حداقل می‌رسد.\n\nپارامترها:\nfruit_counts (List[int]): لیستی از اعداد صحیح که تعداد هر نوع میوه را نشان می‌دهد.\n\nبازگشت:\nint: حداقل هزینه کل مورد نیاز برای ادغام تمام توده‌های میوه.\n\nمثال‌ها:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # ادغام (1+2) با هزینه 3، و سپس (3+9) با هزینه 12، مجموع هزینه 15 را می‌دهد.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # ادغام (5+5) با هزینه کل 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # یک راه بهینه این است که 10+20 (هزینه 30) را ادغام کنیم، سپس 30+30 (هزینه 60) را ادغام کنیم،\nسپس 40+50 (هزینه 90) را ادغام کنیم، و در نهایت دو توده باقی‌مانده 60+90 (هزینه 150) را ادغام کنیم.\nهزینه کل 30+60+90+150 = 300 است."}}
{"task_id": "Python/46", "prompt": {"en": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    \"\"\"", "sq": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Llogarit numrin minimal të studentëve që duhet të largohen për të formuar një formacion kori.\n    Një formacion kori përcaktohet në mënyrë të tillë që për disa pozicione 'i', lartësitë e studentëve\n    rriten nga fillimi deri te 'i' dhe ulen nga 'i' deri në fund të formacionit.\n\n    Argumentet:\n    heights (List[int]): Një listë e lartësive të studentëve.\n\n    Kthen:\n    int: Numri minimal i studentëve që duhet të largohen.\n    \"\"\"", "hy": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Հաշվել նվազագույն թվով ուսանողներ, որոնք պետք է հեռանան երգչախմբի կազմ ձևավորելու համար:\n    Երգչախմբի կազմը սահմանվում է այնպես, որ որոշ դիրքի 'i' համար ուսանողների բարձրությունները\n    աճում են սկզբից մինչև 'i' և նվազում են 'i'-ից մինչև կազմի վերջը:\n\n    Արձանագրություններ:\n    heights (List[int]): Ուսանողների բարձրությունների ցուցակ:\n\n    Վերադարձնում է:\n    int: Նվազագույն թվով ուսանողներ, որոնք պետք է հեռանան:\n    \"\"\"", "bn": "def minimum_students_to_leave(heights):\n    \"\"\"\n    একটি গায়কদল গঠনের জন্য কতজন ছাত্রকে ছেড়ে যেতে হবে তার সর্বনিম্ন সংখ্যা গণনা করুন।\n    একটি গায়কদল গঠন এমনভাবে সংজ্ঞায়িত করা হয় যে কোনো একটি অবস্থান 'i' এর জন্য, ছাত্রদের উচ্চতা\n    শুরু থেকে 'i' পর্যন্ত বৃদ্ধি পায় এবং 'i' থেকে গঠনের শেষ পর্যন্ত হ্রাস পায়।\n\n    আর্গুমেন্টসমূহ:\n    heights (List[int]): ছাত্রদের উচ্চতার একটি তালিকা।\n\n    রিটার্নস:\n    int: সর্বনিম্ন সংখ্যক ছাত্র যারা ছেড়ে যেতে হবে।\n    \"\"\"", "bg": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Изчислете минималния брой ученици, които трябва да напуснат, за да се формира хорова формация.\n    Хоровата формация е дефинирана така, че за някаква позиция 'i', височините на учениците\n    се увеличават от началото до 'i' и намаляват от 'i' до края на формацията.\n\n    Аргументи:\n    heights (List[int]): Списък с височините на учениците.\n\n    Връща:\n    int: Минималният брой ученици, които трябва да напуснат.\n    \"\"\"", "zh": "def minimum_students_to_leave(heights):\n    \"\"\"\n    计算需要离开的最小学生人数以形成合唱队形。\n    合唱队形的定义是，对于某个位置 'i'，学生的身高从开始到 'i' 递增，并从 'i' 到队形的结束递减。\n\n    参数:\n    heights (List[int]): 学生身高的列表。\n\n    返回:\n    int: 需要离开的最小学生人数。\n    \"\"\"", "fr": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculer le nombre minimum d'élèves qui doivent partir pour former une formation de chorale.\n    Une formation de chorale est définie de telle sorte que pour une position 'i', les hauteurs des élèves\n    augmentent du début à 'i' et diminuent de 'i' à la fin de la formation.\n\n    Args:\n    heights (List[int]): Une liste des hauteurs des élèves.\n\n    Returns:\n    int: Le nombre minimum d'élèves qui doivent partir.\n    \"\"\"", "de": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Berechne die minimale Anzahl von Schülern, die gehen müssen, um eine Chorformation zu bilden.\n    Eine Chorformation ist so definiert, dass für eine Position 'i' die Höhen der Schüler\n    vom Anfang bis 'i' zunehmen und von 'i' bis zum Ende der Formation abnehmen.\n\n    Argumente:\n    heights (List[int]): Eine Liste von Schülerhöhen.\n\n    Rückgabewert:\n    int: Die minimale Anzahl von Schülern, die gehen müssen.\n    \"\"\"", "ha": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Lissafi adadin ɗaliban da ya kamata su bar wurin don a samar da tsarin rera waka.\n    An bayyana tsarin rera waka ta yadda a wani matsayi 'i', tsayin ɗalibai\n    yana ƙaruwa daga farkon zuwa 'i' kuma yana raguwa daga 'i' zuwa ƙarshen tsarin.\n\n    Args:\n    heights (List[int]): Jerin tsayin ɗalibai.\n\n    Returns:\n    int: Mafi ƙarancin adadin ɗaliban da ya kamata su bar wurin.\n    \"\"\"", "hi": "def minimum_students_to_leave(heights):\n    \"\"\"\n    गणना करें कि गाना गाने वाले समूह की संरचना बनाने के लिए न्यूनतम कितने छात्रों को छोड़ना पड़ेगा।\n    गाना गाने वाले समूह की संरचना इस प्रकार परिभाषित की जाती है कि किसी स्थिति 'i' के लिए,\n    छात्रों की ऊँचाई शुरू से 'i' तक बढ़ती है और 'i' से संरचना के अंत तक घटती है।\n\n    तर्क:\n    heights (List[int]): छात्रों की ऊँचाई की सूची।\n\n    वापसी:\n    int: न्यूनतम छात्रों की संख्या जिन्हें छोड़ना पड़ेगा।\n    \"\"\"", "hu": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Számítsa ki a minimális számú diákot, akinek el kell hagynia a kórus felállás kialakításához.\n    Egy kórus felállás úgy van meghatározva, hogy egy 'i' pozíció esetén a diákok magassága\n    növekszik a kezdetektől 'i'-ig, majd csökken 'i'-től a felállás végéig.\n\n    Args:\n    heights (List[int]): A diákok magasságainak listája.\n\n    Returns:\n    int: A minimális számú diák, akinek el kell hagynia a sort.\n    \"\"\"", "es": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calcular el número mínimo de estudiantes que deben salir para formar una formación de coro.\n    Se define una formación de coro tal que para alguna posición 'i', las alturas de los estudiantes\n    aumentan desde el inicio hasta 'i' y disminuyen desde 'i' hasta el final de la formación.\n\n    Argumentos:\n    heights (List[int]): Una lista de alturas de estudiantes.\n\n    Devuelve:\n    int: El número mínimo de estudiantes que deben salir.\n    \"\"\"", "arb": "def minimum_students_to_leave(heights):\n    \"\"\"\n    حساب الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة لتشكيل جوقة.\n    يتم تعريف تشكيل الجوقة بحيث أنه بالنسبة لموقع معين 'i'، تزداد أطوال الطلاب\n    من البداية إلى 'i' وتتناقص من 'i' إلى نهاية التشكيل.\n\n    يعيدالحجج:\n    heights (List[int]): قائمة بأطوال الطلاب.\n\n    يعيد:\n    int: الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة.\n    \"\"\"", "sw": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Hesabu idadi ndogo ya wanafunzi wanaohitajika kuondoka ili kuunda safu ya kwaya.\n    Safu ya kwaya inafafanuliwa kwamba kwa nafasi fulani 'i', urefu wa wanafunzi\n    unaongezeka kutoka mwanzo hadi 'i' na kupungua kutoka 'i' hadi mwisho wa safu.\n\n    Hoja:\n    heights (List[int]): Orodha ya urefu wa wanafunzi.\n\n    Inarejesha:\n    int: Idadi ndogo ya wanafunzi wanaohitajika kuondoka.\n    \"\"\"", "tr": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Bir koro formasyonu oluşturmak için ayrılması gereken minimum öğrenci sayısını hesaplayın.\n    Bir koro formasyonu, 'i' pozisyonu için, öğrencilerin boylarının başlangıçtan 'i'ye kadar arttığı\n    ve 'i'den formasyonun sonuna kadar azaldığı şekilde tanımlanır.\n\n    Argümanlar:\n    heights (List[int]): Öğrenci boylarının listesi.\n\n    Döndürür:\n    int: Ayrılması gereken minimum öğrenci sayısı.\n    \"\"\"", "vi": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Tính toán số lượng học sinh tối thiểu cần rời đi để tạo thành đội hình hợp xướng.\n    Một đội hình hợp xướng được định nghĩa sao cho tại một vị trí 'i', chiều cao của học sinh\n    tăng dần từ đầu đến 'i' và giảm dần từ 'i' đến cuối đội hình.\n\n    Tham số:\n    heights (List[int]): Một danh sách chiều cao của học sinh.\n\n    Trả về:\n    int: Số lượng học sinh tối thiểu cần rời đi.\n    \"\"\"", "id": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Hitung jumlah minimum siswa yang perlu keluar untuk membentuk formasi paduan suara.\n    Sebuah formasi paduan suara didefinisikan sedemikian rupa sehingga untuk beberapa posisi 'i', tinggi siswa\n    meningkat dari awal hingga 'i' dan menurun dari 'i' hingga akhir formasi.\n\n    Args:\n    heights (List[int]): Daftar tinggi siswa.\n\n    Returns:\n    int: Jumlah minimum siswa yang perlu keluar.\n    \"\"\"", "ja": "def minimum_students_to_leave(heights):\n    \"\"\"\n    合唱隊の隊形を形成するために退場する必要がある最小の学生数を計算します。\n    合唱隊の隊形は、ある位置 'i' に対して、学生の身長が開始から 'i' まで増加し、\n    'i' から隊形の終わりまで減少するように定義されます。\n\n    引数:\n    heights (List[int]): 学生の身長のリスト。\n\n    戻り値:\n    int: 退場する必要がある最小の学生数。\n    \"\"\"", "ko": "def minimum_students_to_leave(heights):\n    \"\"\"\n    합창단 구성을 형성하기 위해 떠나야 하는 최소 학생 수를 계산합니다.\n    합창단 구성은 어떤 위치 'i'에 대해 학생들의 키가 시작부터 'i'까지 증가하고\n    'i'부터 구성의 끝까지 감소하는 것으로 정의됩니다.\n\n    Args:\n    heights (List[int]): 학생들의 키 목록.\n\n    Returns:\n    int: 떠나야 하는 최소 학생 수.\n    \"\"\"", "ml": "def minimum_students_to_leave(heights):\n    \"\"\"\n    ഒരു ഗായകസംഘം രൂപീകരണം ഉണ്ടാക്കാൻ എത്ര കുറഞ്ഞ വിദ്യാർത്ഥികൾ പുറത്തുപോകേണ്ടിവരും എന്ന് കണക്കാക്കുക.\n    ഒരു ഗായകസംഘം രൂപീകരണം ഇങ്ങനെ നിർവചിക്കുന്നു: ചില സ്ഥാനത്ത് 'i', വിദ്യാർത്ഥികളുടെ ഉയരങ്ങൾ\n    ആരംഭം മുതൽ 'i' വരെ വർദ്ധിക്കുകയും 'i' മുതൽ രൂപീകരണത്തിന്റെ അവസാനം വരെ കുറയുകയും ചെയ്യുന്നു.\n\n    Args:\n    heights (List[int]): വിദ്യാർത്ഥികളുടെ ഉയരങ്ങളുടെ ഒരു പട്ടിക.\n\n    Returns:\n    int: പുറത്തുപോകേണ്ട ഏറ്റവും കുറഞ്ഞ വിദ്യാർത്ഥികളുടെ എണ്ണം.\n    \"\"\"", "fa": "def minimum_students_to_leave(heights):\n    \"\"\"\n    حداقل تعداد دانش‌آموزانی را که باید ترک کنند تا یک آرایش گروه کر تشکیل شود، محاسبه کنید.\n    یک آرایش گروه کر به گونه‌ای تعریف می‌شود که برای موقعیت 'i'، قد دانش‌آموزان از ابتدا تا 'i' افزایش یافته و از 'i' تا انتهای آرایش کاهش می‌یابد.\n\n    Args:\n    heights (List[int]): لیستی از قد دانش‌آموزان.\n\n    Returns:\n    int: حداقل تعداد دانش‌آموزانی که باید ترک کنند.\n    \"\"\""}, "canonical_solution": "    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length", "instruction": {"en": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.", "hy": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nՏվեք Python կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nBada takaitaccen bayani a cikin yaren halitta (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.", "hi": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español usando un máximo de 500 caracteres.", "arb": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.", "vi": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\n最大 500 文字を使用して、英語で Python コードの簡潔な自然言語説明 (docstring) を提供します。", "ko": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 최대 500자 이내로 제공하세요.", "ml": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരത്തിൽ കവിയാതെ നൽകുക.", "fa": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_minimum_students_to_leave():\n    # Test case 1: Provided example\n    assert minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220]) == 4, \"Test case 1 failed\"\n\n    # Test case 2: All students have the same height\n    assert minimum_students_to_leave([150, 150, 150, 150, 150]) == 4, \"Test case 2 failed\"\n\n    # Test case 3: Students are already in a choir formation\n    assert minimum_students_to_leave([130, 150, 170, 190, 170, 150, 130]) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Students are in strictly increasing order\n    assert minimum_students_to_leave([130, 135, 140, 145, 150, 155]) == 0, \"Test case 4 failed\"\n\n    # Test case 5: Students are in strictly decreasing order\n    assert minimum_students_to_leave([155, 150, 145, 140, 135, 130]) == 0, \"Test case 5 failed\"\n\n    # Test case 6: Optimal choir formation is not including the first or last student\n    assert minimum_students_to_leave([200, 180, 190, 170, 210, 160, 220]) == 3, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_minimum_students_to_leave()", "entry_point": "minimum_students_to_leave", "signature": "def minimum_students_to_leave(heights):", "docstring": {"en": "Calculate the minimum number of students that need to leave to form a choir formation.\nA choir formation is defined such that for some position 'i', the heights of students\nincrease from the start to 'i' and decrease from 'i' to the end of the formation.\n\nArgs:\nheights (List[int]): A list of student heights.\n\nReturns:\nint: The minimum number of students that need to leave.", "sq": "Llogarit numrin minimal të nxënësve që duhet të largohen për të formuar një formacion kori. Një formacion kori përcaktohet në mënyrë të tillë që për një pozicion 'i', lartësitë e nxënësve rriten nga fillimi deri te 'i' dhe ulen nga 'i' deri në fund të formacionit.\n\nArgumentet:\nheights (List[int]): Një listë e lartësive të nxënësve.\n\nKthen:\nint: Numri minimal i nxënësve që duhet të largohen.", "hy": "Հաշվարկել նվազագույն թվով ուսանողներ, որոնք պետք է հեռանան, որպեսզի կազմվի երգչախմբի կազմավորում:\nԵրգչախմբի կազմավորումը սահմանվում է այնպես, որ որոշ դիրքի 'i' համար ուսանողների բարձրությունները\nաճում են սկզբից մինչև 'i' և նվազում 'i'-ից մինչև կազմավորման վերջը:\n\nԱրգումենտներ:\nheights (List[int]): Ուսանողների բարձրությունների ցանկ:\n\nՎերադարձնում է:\nint: Նվազագույն թվով ուսանողներ, որոնք պետք է հեռանան:", "bn": "একটি গায়কদল গঠনের জন্য কতজন ছাত্রকে ছেড়ে যেতে হবে তার সর্বনিম্ন সংখ্যা গণনা করুন।\nএকটি গায়কদলের গঠন এমনভাবে সংজ্ঞায়িত করা হয় যে কিছু অবস্থান 'i' এর জন্য, শিক্ষার্থীদের উচ্চতা শুরু থেকে 'i' পর্যন্ত বৃদ্ধি পায় এবং 'i' থেকে গঠনের শেষ পর্যন্ত হ্রাস পায়।\n\nআর্গস:\nheights (List[int]): শিক্ষার্থীদের উচ্চতার একটি তালিকা।\n\nরিটার্নস:\nint: ন্যূনতম সংখ্যক শিক্ষার্থী যারা চলে যেতে হবে।", "bg": "Изчислете минималния брой ученици, които трябва да напуснат, за да се формира хорова формация. Хоровата формация е дефинирана така, че за някаква позиция 'i', височините на учениците се увеличават от началото до 'i' и намаляват от 'i' до края на формацията.\n\nАргументи:\nheights (List[int]): Списък с височините на учениците.\n\nВръща:\nint: Минималният брой ученици, които трябва да напуснат.", "zh": "计算需要离开的最小学生人数以形成合唱队形。  \n合唱队形的定义是，对于某个位置 'i'，学生的身高从开始到 'i' 递增，并从 'i' 到队形的结束递减。\n\n参数：\nheights (List[int]): 学生身高的列表。\n\n返回：\nint: 需要离开的最小学生人数。", "fr": "Calculer le nombre minimum d'élèves qui doivent partir pour former une chorale.\nUne formation de chorale est définie de telle sorte que pour une certaine position 'i', les hauteurs des élèves augmentent du début jusqu'à 'i' et diminuent de 'i' jusqu'à la fin de la formation.\n\nArgs:\nheights (List[int]): Une liste des hauteurs des élèves.\n\nReturns:\nint: Le nombre minimum d'élèves qui doivent partir.", "de": "Berechne die minimale Anzahl von Schülern, die gehen müssen, um eine Chorformation zu bilden.\nEine Chorformation ist so definiert, dass für eine Position 'i' die Höhen der Schüler\nvom Anfang bis 'i' zunehmen und von 'i' bis zum Ende der Formation abnehmen.\n\nArgs:\nheights (List[int]): Eine Liste von Schülerhöhen.\n\nReturns:\nint: Die minimale Anzahl von Schülern, die gehen müssen.", "ha": "Ƙididdige mafi ƙarancin adadin ɗaliban da ya kamata su bar wurin don samar da tsarin rera waka. \nAna ayyana tsarin rera waka ta yadda don wani matsayi 'i', tsayin ɗalibai yana ƙaruwa daga farkon zuwa 'i' kuma yana raguwa daga 'i' zuwa ƙarshen tsarin.\n\nArgs:\nheights (List[int]): Jerin tsayin ɗalibai.\n\nReturns:\nint: Mafi ƙarancin adadin ɗaliban da ya kamata su bar wurin.", "hi": "गणना करें कि गाना गाने वाले समूह की संरचना बनाने के लिए न्यूनतम कितने छात्रों को छोड़ना पड़ेगा।\nएक गाना समूह गठन को इस प्रकार परिभाषित किया जाता है कि किसी स्थिति 'i' के लिए, छात्रों की ऊंचाई  \nशुरुआत से 'i' तक बढ़ती है और 'i' से गठन के अंत तक घटती है।\n\nArgs:  \nheights (List[int]): छात्रों की ऊंचाइयों की एक सूची।\n\nReturns:  \nint: न्यूनतम संख्या में छात्र जिन्हें छोड़ना आवश्यक है।", "hu": "Számítsa ki a minimum hány diáknak kell elhagynia a kórus felállás kialakításához.\nEgy kórus felállás úgy van meghatározva, hogy egy 'i' pozíció esetén a diákok magassága\nnövekszik a kezdetektől 'i'-ig, majd csökken 'i'-től a felállás végéig.\n\nArgs:\nheights (List[int]): A diákok magasságának listája.\n\nReturns:\nint: A minimum hány diáknak kell elhagynia.", "es": "Calcular el número mínimo de estudiantes que necesitan salir para formar una formación de coro. \nUna formación de coro se define de tal manera que para alguna posición 'i', las alturas de los estudiantes \naumentan desde el inicio hasta 'i' y disminuyen desde 'i' hasta el final de la formación.\n\nArgumentos:\nheights (List[int]): Una lista de alturas de estudiantes.\n\nDevuelve:\nint: El número mínimo de estudiantes que necesitan salir.", "arb": "احسب الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة لتشكيل تكوين جوقة. يتم تعريف تكوين الجوقة بحيث أنه بالنسبة لموضع ما 'i'، تزداد أطوال الطلاب من البداية إلى 'i' وتتناقص من 'i' إلى نهاية التكوين.\n\nالمعطيات:\nheights (List[int]): قائمة بأطوال الطلاب.\n\nالإرجاع:\nint: الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة.", "sw": "Hesabu idadi ndogo ya wanafunzi wanaohitajika kuondoka ili kuunda muundo wa kwaya. \nMuundo wa kwaya unafafanuliwa kwamba kwa nafasi fulani 'i', urefu wa wanafunzi \nunaongezeka kutoka mwanzo hadi 'i' na kupungua kutoka 'i' hadi mwisho wa muundo.\n\nHoja:\nheights (List[int]): Orodha ya urefu wa wanafunzi.\n\nInarejesha:\nint: Idadi ndogo ya wanafunzi wanaohitajika kuondoka.", "tr": "Öğrencilerin koroya katılımı için ayrılması gereken minimum öğrenci sayısını hesaplayın. Bir koro formasyonu, bazı 'i' pozisyonları için, öğrencilerin boylarının başlangıçtan 'i'ye kadar arttığı ve 'i'den formasyonun sonuna kadar azaldığı şekilde tanımlanır.\n\nArgümanlar:\nheights (List[int]): Öğrenci boylarının listesi.\n\nDöndürür:\nint: Ayrılması gereken minimum öğrenci sayısı.", "vi": "Tính toán số lượng học sinh tối thiểu cần rời đi để tạo thành một đội hợp xướng. \nMột đội hợp xướng được định nghĩa sao cho với một vị trí 'i' nào đó, chiều cao của học sinh \ntăng dần từ đầu đến 'i' và giảm dần từ 'i' đến cuối của đội hình.\n\nTham số:\nheights (List[int]): Một danh sách chiều cao của học sinh.\n\nTrả về:\nint: Số lượng học sinh tối thiểu cần rời đi.", "id": "Hitung jumlah minimum siswa yang perlu keluar untuk membentuk formasi paduan suara.  \nFormasi paduan suara didefinisikan sedemikian rupa sehingga untuk beberapa posisi 'i', tinggi siswa meningkat dari awal hingga 'i' dan menurun dari 'i' hingga akhir formasi.\n\nArgs:  \nheights (List[int]): Daftar tinggi siswa.\n\nReturns:  \nint: Jumlah minimum siswa yang perlu keluar.", "ja": "合唱隊の編成を形成するために退場する必要がある最小の学生数を計算します。合唱隊の編成は、ある位置 'i' に対して、学生の身長が開始から 'i' まで増加し、'i' から編成の終わりまで減少するように定義されます。\n\n引数:\nheights (List[int]): 学生の身長のリスト。\n\n戻り値:\nint: 退場する必要がある最小の学生数。", "ko": "합창단 구성을 만들기 위해 떠나야 하는 최소한의 학생 수를 계산합니다. 합창단 구성은 어떤 위치 'i'에 대해 학생들의 키가 시작부터 'i'까지 증가하고, 'i'부터 구성의 끝까지 감소하는 것으로 정의됩니다.\n\n인수:\nheights (List[int]): 학생들의 키 목록.\n\n반환:\nint: 떠나야 하는 최소한의 학생 수.", "ml": "ക്വയർ രൂപീകരണം ഉണ്ടാക്കാൻ എത്ര വിദ്യാർത്ഥികൾ പുറത്തുപോകേണ്ടിവരും എന്നത് കണക്കാക്കുക. \nഒരു ക്വയർ രൂപീകരണം ഇങ്ങനെ നിർവചിക്കപ്പെടുന്നു, ഏതെങ്കിലും 'i' സ്ഥാനത്തേക്ക്, വിദ്യാർത്ഥികളുടെ ഉയരങ്ങൾ ആരംഭത്തിൽ നിന്ന് 'i' വരെ വർദ്ധിക്കുകയും 'i' മുതൽ രൂപീകരണത്തിന്റെ അവസാനം വരെ കുറയുകയും ചെയ്യുന്നു.\n\nആർഗുകൾ:\nheights (List[int]): വിദ്യാർത്ഥികളുടെ ഉയരങ്ങളുടെ പട്ടിക.\n\nമടക്കം:\nint: എത്ര വിദ്യാർത്ഥികൾ പുറത്തുപോകേണ്ടിവരും എന്നതിന്റെ കുറഞ്ഞ സംഖ്യ.", "fa": "محاسبه حداقل تعداد دانش‌آموزانی که باید برای تشکیل یک گروه کر خارج شوند.\nیک گروه کر به گونه‌ای تعریف می‌شود که برای موقعیت 'i'، قد دانش‌آموزان از ابتدا تا 'i' افزایش یافته و از 'i' تا انتهای تشکیل کاهش می‌یابد.\n\nآرگومان‌ها:\nheights (List[int]): لیستی از قدهای دانش‌آموزان.\n\nبازگشت:\nint: حداقل تعداد دانش‌آموزانی که باید خارج شوند."}}
{"task_id": "Python/47", "prompt": {"en": "def sort_students(student_scores):\n    \"\"\"\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    In the first example, the student with the highest total score is number 6. Students number 4 and 3 follow,\n    with descending total scores. Student number 1 has a lower total score than student number 2, but a higher Chinese score,\n    so student number 1 is placed after student number 2 in the sorted list.\n    \n    In the second example, students number 1 and 2 have the same total score, but student number 1 has a higher Chinese score,\n    so they are placed first. The rest are sorted by their descending total scores.\n    \"\"\"", "sq": "def sort_students(student_scores):\n    \"\"\"\n    Rendit një listë studentësh bazuar në pikët e tyre. Studentët renditen kryesisht sipas pikëve të tyre totale (në zbritje),\n    pastaj sipas pikëve të tyre në gjuhën kineze (në zbritje), dhe së fundi sipas numrit të studentit (në rritje) në rast barazimi.\n    \n    Args:\n    student_scores (list): Një listë tuplesh, ku secili tuple përbëhet nga (numri_studentit, pikët_totale, pikët_kineze).\n    \n    Returns:\n    list: Një listë tuplesh e renditur sipas rregullave të mësipërme.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Në shembullin e parë, studenti me pikët më të larta totale është numri 6. Studentët numër 4 dhe 3 ndjekin,\n    me pikë totale në zbritje. Studenti numër 1 ka pikë totale më të ulëta se studenti numër 2, por pikë më të larta në gjuhën kineze,\n    kështu që studenti numër 1 vendoset pas studentit numër 2 në listën e renditur.\n    \n    Në shembullin e dytë, studentët numër 1 dhe 2 kanë të njëjtat pikë totale, por studenti numër 1 ka pikë më të larta në gjuhën kineze,\n    kështu që ata vendosen të parët. Të tjerët renditen sipas pikëve të tyre totale në zbritje.\n    \"\"\"", "hy": "def sort_students(student_scores):\n    \"\"\"\n    Դասավորում է ուսանողների ցուցակը՝ հիմնվելով նրանց միավորների վրա։ Ուսանողները դասավորվում են նախ իրենց ընդհանուր միավորներով (նվազման կարգով),\n    հետո՝ չինարենի միավորներով (նվազման կարգով), և վերջապես՝ ուսանողի համարով (աճման կարգով)՝ եթե միավորները հավասար են։\n    \n    Արգումենտներ:\n    student_scores (ցուցակ): Ցուցակ, որը բաղկացած է տուփերից, որտեղ յուրաքանչյուր տուփ ներառում է (ուսանողի համար, ընդհանուր միավոր, չինարենի միավոր)։\n    \n    Վերադարձնում է:\n    ցուցակ: Տուփերի ցուցակ, դասավորված ըստ վերը նշված կանոնների։\n    \n    Օրինակներ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Առաջին օրինակով, ուսանողը, ով ունի ամենաբարձր ընդհանուր միավորը, համար 6-ն է։ Հետևում են համար 4 և 3 ուսանողները՝ նվազման կարգով ընդհանուր միավորներով։ \n    Ուսանող համար 1-ը ունի ավելի ցածր ընդհանուր միավոր, քան ուսանող համար 2-ը, բայց ավելի բարձր չինարենի միավոր, \n    ուստի ուսանող համար 1-ը տեղադրվում է ուսանող համար 2-ից հետո դասավորված ցուցակում։\n    \n    Երկրորդ օրինակով, ուսանողներ համար 1-ը և 2-ը ունեն նույն ընդհանուր միավորը, բայց ուսանող համար 1-ը ունի ավելի բարձր չինարենի միավոր,\n    ուստի նրանք տեղադրվում են առաջինը։ Մնացածները դասավորվում են իրենց ընդհանուր միավորների նվազման կարգով։\n    \"\"\"", "bn": "def sort_students(student_scores):\n    \"\"\"\n    শিক্ষার্থীদের স্কোরের ভিত্তিতে একটি তালিকা সাজায়। শিক্ষার্থীরা প্রধানত তাদের মোট স্কোর (অবতরণী ক্রমে) দ্বারা সাজানো হয়,\n    তারপর তাদের চীনা স্কোর (অবতরণী ক্রমে) দ্বারা, এবং অবশেষে শিক্ষার্থী নম্বর (আরোহণী ক্রমে) দ্বারা যদি স্কোর সমান হয়।\n    \n    Args:\n    student_scores (list): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে (student_number, total_score, Chinese_score) থাকে।\n    \n    Returns:\n    list: উপরের নিয়ম অনুযায়ী সাজানো টুপলের একটি তালিকা।\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    প্রথম উদাহরণে, সর্বোচ্চ মোট স্কোর সহ শিক্ষার্থী হলেন নম্বর 6। শিক্ষার্থী নম্বর 4 এবং 3 তাদের অবতরণী মোট স্কোর সহ অনুসরণ করে।\n    শিক্ষার্থী নম্বর 1 এর মোট স্কোর শিক্ষার্থী নম্বর 2 এর চেয়ে কম, কিন্তু চীনা স্কোর বেশি, তাই শিক্ষার্থী নম্বর 1 শিক্ষার্থী নম্বর 2 এর পরে স্থাপন করা হয়।\n    \n    দ্বিতীয় উদাহরণে, শিক্ষার্থী নম্বর 1 এবং 2 এর একই মোট স্কোর রয়েছে, কিন্তু শিক্ষার্থী নম্বর 1 এর চীনা স্কোর বেশি,\n    তাই তারা প্রথম স্থানে রাখা হয়। বাকিরা তাদের অবতরণী মোট স্কোর দ্বারা সাজানো হয়।\n    \"\"\"", "bg": "def sort_students(student_scores):\n    \"\"\"\n    Сортира списък от студенти въз основа на техните резултати. Студентите се сортират първоначално по общия им резултат (в низходящ ред),\n    след това по резултата им по китайски език (в низходящ ред), и накрая по техния студентски номер (във възходящ ред) в случай на равенство.\n    \n    Args:\n    student_scores (list): Списък от кортежи, където всеки кортеж се състои от (студентски номер, общ резултат, резултат по китайски език).\n    \n    Returns:\n    list: Списък от кортежи, сортирани според горепосочените правила.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    В първия пример, студентът с най-висок общ резултат е номер 6. Следват студенти номер 4 и 3,\n    с намаляващи общи резултати. Студент номер 1 има по-нисък общ резултат от студент номер 2, но по-висок резултат по китайски език,\n    затова студент номер 1 е поставен след студент номер 2 в сортирания списък.\n    \n    Във втория пример, студенти номер 1 и 2 имат еднакъв общ резултат, но студент номер 1 има по-висок резултат по китайски език,\n    затова те са поставени първи. Останалите са сортирани по техните намаляващи общи резултати.\n    \"\"\"", "zh": "def sort_students(student_scores):\n    \"\"\"\n    根据学生的分数对学生列表进行排序。学生首先按总分（降序）排序，\n    然后按语文分数（降序）排序，最后在总分和语文分数相同的情况下按学号（升序）排序。\n    \n    参数:\n    student_scores (list): 一个元组列表，每个元组包含 (student_number, total_score, Chinese_score)。\n    \n    返回:\n    list: 一个根据上述规则排序的元组列表。\n    \n    示例:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    在第一个示例中，总分最高的学生是6号。接下来是4号和3号学生，总分依次递减。1号学生的总分低于2号学生，\n    但语文分数更高，因此在排序列表中1号学生排在2号学生之后。\n    \n    在第二个示例中，1号和2号学生的总分相同，但1号学生的语文分数更高，因此他们排在最前面。其余的按总分降序排列。\n    \"\"\"", "fr": "def sort_students(student_scores):\n    \"\"\"\n    Trie une liste d'étudiants en fonction de leurs scores. Les étudiants sont triés principalement par leur score total (décroissant),\n    puis par leur score en chinois (décroissant), et enfin par leur numéro d'étudiant (croissant) en cas d'égalité.\n    \n    Args:\n    student_scores (list): Une liste de tuples, où chaque tuple se compose de (numéro_étudiant, score_total, score_chinois).\n    \n    Returns:\n    list: Une liste de tuples triés selon les règles ci-dessus.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Dans le premier exemple, l'étudiant avec le score total le plus élevé est le numéro 6. Les étudiants numéros 4 et 3 suivent,\n    avec des scores totaux décroissants. L'étudiant numéro 1 a un score total inférieur à l'étudiant numéro 2, mais un score en chinois plus élevé,\n    donc l'étudiant numéro 1 est placé après l'étudiant numéro 2 dans la liste triée.\n    \n    Dans le deuxième exemple, les étudiants numéros 1 et 2 ont le même score total, mais l'étudiant numéro 1 a un score en chinois plus élevé,\n    donc ils sont placés en premier. Les autres sont triés par leurs scores totaux décroissants.\n    \"\"\"", "de": "def sort_students(student_scores):\n    \"\"\"\n    Sortiert eine Liste von Studenten basierend auf ihren Punktzahlen. Die Studenten werden primär nach ihrer Gesamtpunktzahl (absteigend),\n    dann nach ihrer Chinesisch-Punktzahl (absteigend) und schließlich nach ihrer Studentennummer (aufsteigend) im Falle eines Gleichstands sortiert.\n    \n    Args:\n    student_scores (list): Eine Liste von Tupeln, wobei jedes Tupel aus (Studentennummer, Gesamtpunktzahl, Chinesisch-Punktzahl) besteht.\n    \n    Returns:\n    list: Eine Liste von Tupeln, die gemäß den obigen Regeln sortiert ist.\n    \n    Beispiele:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Im ersten Beispiel hat der Student mit der höchsten Gesamtpunktzahl die Nummer 6. Die Studenten mit den Nummern 4 und 3 folgen,\n    mit absteigenden Gesamtpunktzahlen. Student Nummer 1 hat eine niedrigere Gesamtpunktzahl als Student Nummer 2, aber eine höhere Chinesisch-Punktzahl,\n    daher wird Student Nummer 1 nach Student Nummer 2 in der sortierten Liste platziert.\n    \n    Im zweiten Beispiel haben die Studenten mit den Nummern 1 und 2 die gleiche Gesamtpunktzahl, aber Student Nummer 1 hat eine höhere Chinesisch-Punktzahl,\n    daher werden sie zuerst platziert. Der Rest wird nach ihren absteigenden Gesamtpunktzahlen sortiert.\n    \"\"\"", "ha": "def sort_students(student_scores):\n    \"\"\"\n    Yana tsara jerin ɗalibai bisa ga maki nasu. Ana tsara ɗaliban ne da farko bisa ga jimillar maki nasu (daga mafi girma zuwa ƙasa),\n    sannan bisa ga maki na Sinanci (daga mafi girma zuwa ƙasa), kuma a ƙarshe bisa ga lambar ɗalibi (daga mafi ƙanƙanta zuwa mafi girma) idan akwai daidaito.\n    \n    Args:\n    student_scores (list): Jerin tuples, inda kowanne tuple ya ƙunshi (lambar_ɗalibi, jimillar_maki, maki_Sinanci).\n    \n    Returns:\n    list: Jerin tuples da aka tsara bisa ga ƙa'idodin da ke sama.\n    \n    Misalai:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    A cikin misali na farko, ɗalibin da ke da jimillar maki mafi girma shi ne lamba 6. Ɗalibai lambobi 4 da 3 suna biye,\n    tare da jimillar maki masu raguwa. Ɗalibi lamba 1 yana da jimillar maki ƙasa da ɗalibi lamba 2, amma yana da maki na Sinanci mafi girma,\n    don haka ɗalibi lamba 1 yana bayan ɗalibi lamba 2 a cikin jerin da aka tsara.\n    \n    A cikin misali na biyu, ɗalibai lambobi 1 da 2 suna da jimillar maki ɗaya, amma ɗalibi lamba 1 yana da maki na Sinanci mafi girma,\n    don haka suna farko. Sauran suna tsara bisa ga jimillar maki nasu daga mafi girma zuwa ƙasa.\n    \"\"\"", "hi": "def sort_students(student_scores):\n    \"\"\"\n    छात्रों की एक सूची को उनके अंकों के आधार पर क्रमबद्ध करता है। छात्रों को मुख्य रूप से उनके कुल अंक (अवरोही क्रम में),\n    फिर उनके चीनी अंकों (अवरोही क्रम में), और अंत में टाई होने पर उनके छात्र संख्या (आरोही क्रम में) के आधार पर क्रमबद्ध किया जाता है।\n    \n    Args:\n    student_scores (list): टुपल की एक सूची, जहाँ प्रत्येक टुपल में (student_number, total_score, Chinese_score) होते हैं।\n    \n    Returns:\n    list: उपरोक्त नियमों के अनुसार क्रमबद्ध टुपल की एक सूची।\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    पहले उदाहरण में, सबसे अधिक कुल अंक वाला छात्र संख्या 6 है। छात्र संख्या 4 और 3 इसके बाद आते हैं,\n    उनके कुल अंकों के अवरोही क्रम में। छात्र संख्या 1 के पास छात्र संख्या 2 की तुलना में कम कुल अंक हैं, लेकिन चीनी अंक अधिक हैं,\n    इसलिए छात्र संख्या 1 को क्रमबद्ध सूची में छात्र संख्या 2 के बाद रखा गया है।\n    \n    दूसरे उदाहरण में, छात्र संख्या 1 और 2 के समान कुल अंक हैं, लेकिन छात्र संख्या 1 के चीनी अंक अधिक हैं,\n    इसलिए उन्हें पहले रखा गया है। बाकी छात्रों को उनके कुल अंकों के अवरोही क्रम में क्रमबद्ध किया गया है।\n    \"\"\"", "hu": "def sort_students(student_scores):\n    \"\"\"\n    Egy lista diákot rendez a pontszámaik alapján. A diákok elsősorban az összpontszámuk szerint vannak rendezve (csökkenő sorrendben),\n    majd a kínai pontszámuk szerint (csökkenő sorrendben), és végül a diák azonosítójuk szerint (növekvő sorrendben) döntetlen esetén.\n    \n    Args:\n    student_scores (list): Egy lista, amelyben minden elem egy tuple, ami a következőket tartalmazza: (diák_azonosító, összpontszám, kínai_pontszám).\n    \n    Returns:\n    list: Egy lista tuple-ökkel, a fenti szabályok szerint rendezve.\n    \n    Példák:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Az első példában a legmagasabb összpontszámú diák a 6-os számú. A 4-es és 3-as számú diákok következnek,\n    csökkenő összpontszám szerint. Az 1-es számú diáknak alacsonyabb az összpontszáma, mint a 2-es számú diáknak, de magasabb a kínai pontszáma,\n    így az 1-es számú diák a 2-es számú diák után kerül a rendezett listába.\n    \n    A második példában az 1-es és 2-es számú diákoknak azonos az összpontszámuk, de az 1-es számú diáknak magasabb a kínai pontszáma,\n    így ők kerülnek az első helyre. A többiek csökkenő összpontszám szerint vannak rendezve.\n    \"\"\"", "es": "def sort_students(student_scores):\n    \"\"\"\n    Ordena una lista de estudiantes según sus puntajes. Los estudiantes se ordenan principalmente por su puntaje total (descendente),\n    luego por su puntaje en Chino (descendente), y finalmente por su número de estudiante (ascendente) en caso de empate.\n    \n    Argumentos:\n    student_scores (list): Una lista de tuplas, donde cada tupla consiste en (número_estudiante, puntaje_total, puntaje_Chino).\n    \n    Devuelve:\n    list: Una lista de tuplas ordenadas según las reglas anteriores.\n    \n    Ejemplos:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    En el primer ejemplo, el estudiante con el puntaje total más alto es el número 6. Los estudiantes número 4 y 3 siguen,\n    con puntajes totales descendentes. El estudiante número 1 tiene un puntaje total más bajo que el estudiante número 2, pero un puntaje en Chino más alto,\n    por lo que el estudiante número 1 se coloca después del estudiante número 2 en la lista ordenada.\n    \n    En el segundo ejemplo, los estudiantes número 1 y 2 tienen el mismo puntaje total, pero el estudiante número 1 tiene un puntaje en Chino más alto,\n    por lo que se colocan primero. El resto se ordena por sus puntajes totales descendentes.\n    \"\"\"", "arb": "def sort_students(student_scores):\n    \"\"\"\n    يقوم بفرز قائمة الطلاب بناءً على درجاتهم. يتم فرز الطلاب بشكل أساسي حسب مجموع درجاتهم (تنازليًا)،\n    ثم حسب درجة اللغة الصينية (تنازليًا)، وأخيرًا حسب رقم الطالب (تصاعديًا) في حالة التعادل.\n    \n    يعيدالحجج:\n    student_scores (list): قائمة من المجموعات، حيث تتكون كل مجموعة من (رقم الطالب، مجموع الدرجات، درجة اللغة الصينية).\n    \n    يعيد:\n    list: قائمة من المجموعات مرتبة وفقًا للقواعد المذكورة أعلاه.\n    \n    امثله:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    في المثال الأول، الطالب الذي لديه أعلى مجموع درجات هو رقم 6. يتبعه الطلاب رقم 4 و3،\n    مع مجموع درجات تنازلي. الطالب رقم 1 لديه مجموع درجات أقل من الطالب رقم 2، لكن درجة اللغة الصينية أعلى،\n    لذا يتم وضع الطالب رقم 1 بعد الطالب رقم 2 في القائمة المرتبة.\n    \n    في المثال الثاني، الطلاب رقم 1 و2 لديهم نفس مجموع الدرجات، لكن الطالب رقم 1 لديه درجة لغة صينية أعلى،\n    لذا يتم وضعهم أولاً. الباقي يتم ترتيبه حسب مجموع درجاتهم التنازلي.\n    \"\"\"", "sw": "def sort_students(student_scores):\n    \"\"\"\n    Hupanga orodha ya wanafunzi kulingana na alama zao. Wanafunzi wanapangwa kimsingi kwa alama zao za jumla (kutoka juu kwenda chini),\n    kisha kwa alama zao za Kichina (kutoka juu kwenda chini), na hatimaye kwa nambari yao ya mwanafunzi (kutoka chini kwenda juu) ikiwa kuna sare.\n    \n    Hoja:\n    student_scores (list): Orodha ya jozi, ambapo kila jozi inajumuisha (nambari_ya_mwanafunzi, alama_ya_jumla, alama_ya_Kichina).\n    \n    Inarejesha:\n    list: Orodha ya jozi zilizopangwa kulingana na sheria zilizo hapo juu.\n    \n    Mifano:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Katika mfano wa kwanza, mwanafunzi mwenye alama ya juu zaidi ya jumla ni nambari 6. Wanafunzi nambari 4 na 3 wanafuata,\n    na alama za jumla zinazoshuka. Mwanafunzi nambari 1 ana alama ya jumla ya chini kuliko mwanafunzi nambari 2, lakini ana alama ya juu ya Kichina,\n    hivyo mwanafunzi nambari 1 amewekwa baada ya mwanafunzi nambari 2 katika orodha iliyopangwa.\n    \n    Katika mfano wa pili, wanafunzi nambari 1 na 2 wana alama sawa ya jumla, lakini mwanafunzi nambari 1 ana alama ya juu ya Kichina,\n    hivyo wamewekwa kwanza. Wengine wanapangwa kwa alama zao za jumla zinazoshuka.\n    \"\"\"", "tr": "def sort_students(student_scores):\n    \"\"\"\n    Öğrencileri puanlarına göre sıralar. Öğrenciler öncelikle toplam puanlarına göre (azalan),\n    ardından Çince puanlarına göre (azalan) ve son olarak eşitlik durumunda öğrenci numarasına göre (artan) sıralanır.\n    \n    Argümanlar:\n    student_scores (list): Her bir demetin (öğrenci_numarası, toplam_puan, Çince_puanı) içerdiği demetlerden oluşan bir liste.\n    \n    Döndürür:\n    list: Yukarıdaki kurallara göre sıralanmış demetlerden oluşan bir liste.\n    \n    Örnekler:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    İlk örnekte, en yüksek toplam puana sahip öğrenci numarası 6'dır. Öğrenci numarası 4 ve 3,\n    azalan toplam puanlarla takip eder. Öğrenci numarası 1, öğrenci numarası 2'den daha düşük toplam puana sahiptir,\n    ancak daha yüksek bir Çince puanına sahiptir, bu yüzden sıralı listede öğrenci numarası 2'den sonra yer alır.\n    \n    İkinci örnekte, öğrenci numarası 1 ve 2 aynı toplam puana sahiptir, ancak öğrenci numarası 1 daha yüksek bir Çince puanına sahiptir,\n    bu yüzden ilk sırada yer alırlar. Geri kalanlar azalan toplam puanlarına göre sıralanmıştır.\n    \"\"\"", "vi": "def sort_students(student_scores):\n    \"\"\"\n    Sắp xếp danh sách học sinh dựa trên điểm số của họ. Các học sinh được sắp xếp chủ yếu theo tổng điểm (giảm dần),\n    sau đó theo điểm tiếng Trung (giảm dần), và cuối cùng theo số thứ tự học sinh (tăng dần) trong trường hợp điểm bằng nhau.\n    \n    Tham số:\n    student_scores (list): Một danh sách các bộ giá trị, trong đó mỗi bộ gồm (số thứ tự học sinh, tổng điểm, điểm tiếng Trung).\n    \n    Trả về:\n    list: Một danh sách các bộ giá trị được sắp xếp theo các quy tắc trên.\n    \n    Ví dụ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Trong ví dụ đầu tiên, học sinh có tổng điểm cao nhất là số 6. Học sinh số 4 và 3 theo sau,\n    với tổng điểm giảm dần. Học sinh số 1 có tổng điểm thấp hơn học sinh số 2, nhưng có điểm tiếng Trung cao hơn,\n    vì vậy học sinh số 1 được xếp sau học sinh số 2 trong danh sách đã sắp xếp.\n    \n    Trong ví dụ thứ hai, học sinh số 1 và 2 có cùng tổng điểm, nhưng học sinh số 1 có điểm tiếng Trung cao hơn,\n    vì vậy họ được xếp trước. Các học sinh còn lại được sắp xếp theo tổng điểm giảm dần.\n    \"\"\"", "id": "def sort_students(student_scores):\n    \"\"\"\n    Mengurutkan daftar siswa berdasarkan skor mereka. Siswa diurutkan pertama berdasarkan skor total mereka (menurun),\n    kemudian berdasarkan skor Bahasa Mandarin mereka (menurun), dan akhirnya berdasarkan nomor siswa mereka (menaik) jika ada kesamaan.\n    \n    Args:\n    student_scores (list): Daftar tuple, di mana setiap tuple terdiri dari (nomor_siswa, skor_total, skor_Bahasa_Mandarin).\n    \n    Returns:\n    list: Daftar tuple yang diurutkan sesuai dengan aturan di atas.\n    \n    Contoh:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Dalam contoh pertama, siswa dengan skor total tertinggi adalah nomor 6. Siswa nomor 4 dan 3 mengikuti,\n    dengan skor total menurun. Siswa nomor 1 memiliki skor total lebih rendah daripada siswa nomor 2, tetapi skor Bahasa Mandarin lebih tinggi,\n    sehingga siswa nomor 1 ditempatkan setelah siswa nomor 2 dalam daftar yang diurutkan.\n    \n    Dalam contoh kedua, siswa nomor 1 dan 2 memiliki skor total yang sama, tetapi siswa nomor 1 memiliki skor Bahasa Mandarin lebih tinggi,\n    sehingga mereka ditempatkan pertama. Sisanya diurutkan berdasarkan skor total mereka yang menurun.\n    \"\"\"", "ja": "def sort_students(student_scores):\n    \"\"\"\n    学生のリストをスコアに基づいてソートします。学生は主に総合スコア（降順）でソートされ、\n    次に中国語のスコア（降順）、最後に同点の場合は学生番号（昇順）でソートされます。\n    \n    引数:\n    student_scores (list): 各タプルが (student_number, total_score, Chinese_score) から成るタプルのリスト。\n    \n    戻り値:\n    list: 上記のルールに従ってソートされたタプルのリスト。\n    \n    例:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    最初の例では、最も高い総合スコアを持つのは学生番号6です。学生番号4と3が続き、総合スコアは降順です。\n    学生番号1は学生番号2よりも総合スコアが低いですが、中国語のスコアが高いため、ソートされたリストでは学生番号2の後に配置されます。\n    \n    2番目の例では、学生番号1と2は同じ総合スコアを持っていますが、学生番号1の方が中国語のスコアが高いため、最初に配置されます。\n    残りは総合スコアの降順でソートされます。\n    \"\"\"", "ko": "def sort_students(student_scores):\n    \"\"\"\n    학생들의 점수를 기준으로 목록을 정렬합니다. 학생들은 주로 총점(내림차순)으로 정렬되며,\n    그 다음으로 중국어 점수(내림차순), 동점일 경우 학번(오름차순)으로 정렬됩니다.\n    \n    Args:\n    student_scores (list): 각 튜플이 (학번, 총점, 중국어 점수)로 구성된 튜플의 목록입니다.\n    \n    Returns:\n    list: 위의 규칙에 따라 정렬된 튜플 목록입니다.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    첫 번째 예제에서는, 총점이 가장 높은 학생은 6번입니다. 4번과 3번 학생이 그 뒤를 따르며,\n    총점이 내림차순으로 정렬됩니다. 1번 학생은 2번 학생보다 총점이 낮지만 중국어 점수가 높기 때문에,\n    정렬된 목록에서 2번 학생 다음에 배치됩니다.\n    \n    두 번째 예제에서는, 1번과 2번 학생이 동일한 총점을 가지고 있지만, 1번 학생이 중국어 점수가 더 높아\n    먼저 배치됩니다. 나머지는 총점 내림차순으로 정렬됩니다.\n    \"\"\"", "ml": "def sort_students(student_scores):\n    \"\"\"\n    വിദ്യാർത്ഥികളുടെ സ്കോറുകളുടെ അടിസ്ഥാനത്തിൽ അവരെ ക്രമീകരിക്കുന്നു. വിദ്യാർത്ഥികളെ പ്രധാനമായും അവരുടെ മൊത്തം സ്കോർ (ഇറക്കം കുറയുന്ന ക്രമത്തിൽ) അനുസരിച്ച് ക്രമീകരിക്കുന്നു,\n    തുടർന്ന് അവരുടെ ചൈനീസ് സ്കോർ (ഇറക്കം കുറയുന്ന ക്രമത്തിൽ) അനുസരിച്ച്, ഒടുവിൽ സമനിലയുണ്ടെങ്കിൽ അവരുടെ വിദ്യാർത്ഥി നമ്പർ (കൂടുന്ന ക്രമത്തിൽ) അനുസരിച്ച്.\n\n    Args:\n    student_scores (list): ഓരോ ട്യൂപ്പിളും (student_number, total_score, Chinese_score) അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\n    Returns:\n    list: മുകളിൽ പറയുന്ന നിയമങ്ങൾ അനുസരിച്ച് ക്രമീകരിച്ച ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    ആദ്യ ഉദാഹരണത്തിൽ, ഏറ്റവും ഉയർന്ന മൊത്തം സ്കോർ ഉള്ള വിദ്യാർത്ഥി 6 ആണ്. വിദ്യാർത്ഥി നമ്പർ 4, 3 എന്നിവരാണ് തുടർന്നുള്ളവർ,\n    ഇറക്കം കുറയുന്ന മൊത്തം സ്കോറുകൾ. വിദ്യാർത്ഥി നമ്പർ 1-ന് വിദ്യാർത്ഥി നമ്പർ 2-നെക്കാൾ കുറഞ്ഞ മൊത്തം സ്കോർ ഉണ്ട്, പക്ഷേ ഉയർന്ന ചൈനീസ് സ്കോർ ഉണ്ട്,\n    അതിനാൽ വിദ്യാർത്ഥി നമ്പർ 1-നെ വിദ്യാർത്ഥി നമ്പർ 2-ന്റെ ശേഷം ക്രമീകരിച്ച പട്ടികയിൽ ഇടം നൽകുന്നു.\n    \n    രണ്ടാം ഉദാഹരണത്തിൽ, വിദ്യാർത്ഥി നമ്പർ 1, 2 എന്നിവർക്കും സമാനമായ മൊത്തം സ്കോർ ഉണ്ട്, പക്ഷേ വിദ്യാർത്ഥി നമ്പർ 1-ന് ഉയർന്ന ചൈനീസ് സ്കോർ ഉണ്ട്,\n    അതിനാൽ അവർ ആദ്യം ഇടം നേടുന്നു. ബാക്കിയുള്ളവരെ അവരുടെ ഇറക്കം കുറയുന്ന മൊത്തം സ്കോറുകൾ അനുസരിച്ച് ക്രമീകരിക്കുന്നു.\n    \"\"\"", "fa": "def sort_students(student_scores):\n    \"\"\"\n    لیستی از دانش‌آموزان را بر اساس نمراتشان مرتب می‌کند. دانش‌آموزان ابتدا بر اساس نمره کل (نزولی) مرتب می‌شوند،\n    سپس بر اساس نمره چینی (نزولی)، و در نهایت در صورت تساوی بر اساس شماره دانش‌آموز (صعودی) مرتب می‌شوند.\n    \n    Args:\n    student_scores (list): لیستی از تاپل‌ها، که هر تاپل شامل (شماره دانش‌آموز، نمره کل، نمره چینی) است.\n    \n    Returns:\n    list: لیستی از تاپل‌ها که بر اساس قوانین فوق مرتب شده‌اند.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    در مثال اول، دانش‌آموز با بالاترین نمره کل شماره 6 است. دانش‌آموزان شماره 4 و 3 به ترتیب با نمرات کل نزولی دنبال می‌شوند.\n    دانش‌آموز شماره 1 نمره کل کمتری نسبت به دانش‌آموز شماره 2 دارد، اما نمره چینی بالاتری دارد،\n    بنابراین دانش‌آموز شماره 1 بعد از دانش‌آموز شماره 2 در لیست مرتب شده قرار می‌گیرد.\n    \n    در مثال دوم، دانش‌آموزان شماره 1 و 2 نمره کل یکسانی دارند، اما دانش‌آموز شماره 1 نمره چینی بالاتری دارد،\n    بنابراین آن‌ها در ابتدا قرار می‌گیرند. بقیه بر اساس نمرات کل نزولی مرتب می‌شوند.\n    \"\"\""}, "canonical_solution": "    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students", "instruction": {"en": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nՏվյալ Python կոդի համար տրամադրեք կարճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\n请为以下Python代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。", "fr": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar Python a cikin Hausa wanda bai wuce haruffa 500 ba.", "hi": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي المكتوب بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.", "vi": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự.", "id": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\n以下のPythonコードの説明を日本語で簡潔に記述してください。500文字以内でお願いします。", "ko": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\n다음 Python 코드에 대한 간결한 자연어 설명(도크스트링)을 한국어로 작성하세요. 최대 500자 이내로 작성하십시오.", "ml": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nPython കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) പരമാവധി 500 അക്ഷരങ്ങൾ ഉപയോഗിച്ച് മലയാളത്തിൽ നൽകുക.", "fa": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_sort_students():\n    # Test case 1\n    input_scores = [(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)]\n    expected_output = [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 1 failed\"\n\n    # Test case 2\n    input_scores = [(1, 258, 80), (2, 264, 88), (3, 258, 90), (4, 244, 87), (5, 258, 78), (6, 264, 88), (7, 220, 67), (8, 265, 78)]\n    expected_output = [(8, 265, 78), (2, 264, 88), (6, 264, 88), (3, 258, 90), (1, 258, 80), (5, 258, 78), (4, 244, 87), (7, 220, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 2 failed\"\n\n    # Test case 3\n    input_scores = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    expected_output = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    assert sort_students(input_scores) == expected_output, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_sort_students()", "entry_point": "sort_students", "signature": "def sort_students(student_scores):", "docstring": {"en": "Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\nthen by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n\nArgs:\nstudent_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n\nReturns:\nlist: A list of tuples sorted according to the above rules.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nIn the first example, the student with the highest total score is number 6. Students number 4 and 3 follow,\nwith descending total scores. Student number 1 has a lower total score than student number 2, but a higher Chinese score,\nso student number 1 is placed after student number 2 in the sorted list.\n\nIn the second example, students number 1 and 2 have the same total score, but student number 1 has a higher Chinese score,\nso they are placed first. The rest are sorted by their descending total scores.", "sq": "Rendit një listë studentësh bazuar në notat e tyre. Studentët renditen kryesisht sipas notës së tyre totale (në zbritje), pastaj sipas notës së tyre në gjuhën kineze (në zbritje), dhe së fundi sipas numrit të tyre të studentit (në rritje) në rast të një barazimi.\n\nArgs:\nstudent_scores (list): Një listë tuples, ku çdo tuple përbëhet nga (numri_i_studentit, nota_totale, nota_kineze).\n\nReturns:\nlist: Një listë tuples e renditur sipas rregullave të mësipërme.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nNë shembullin e parë, studenti me notën më të lartë totale është numri 6. Studentët numër 4 dhe 3 ndjekin, me nota totale në zbritje. Studenti numër 1 ka një notë totale më të ulët se studenti numër 2, por një notë më të lartë në gjuhën kineze, kështu që studenti numër 1 vendoset pas studentit numër 2 në listën e renditur.\n\nNë shembullin e dytë, studentët numër 1 dhe 2 kanë të njëjtën notë totale, por studenti numër 1 ka një notë më të lartë në gjuhën kineze, kështu që ata vendosen të parët. Pjesa tjetër renditet sipas notave të tyre totale në zbritje.", "hy": "Դասավորում է ուսանողների ցուցակը՝ հիմնվելով նրանց գնահատականների վրա։ Ուսանողները դասավորվում են հիմնականում ըստ իրենց ընդհանուր գնահատականի (նվազման կարգով), ապա՝ ըստ իրենց չինարենի գնահատականի (նվազման կարգով), և վերջապես՝ ըստ իրենց ուսանողի համարի (աճման կարգով)՝ հավասարության դեպքում։\n\nԱրձանագրումներ:\nstudent_scores (list): Ցուցակ, որտեղ յուրաքանչյուր տուփ բաղկացած է (ուսանողի համար, ընդհանուր գնահատական, չինարեն գնահատական)։\n\nՎերադարձնում է:\nlist: Տուփերի ցուցակ՝ դասավորված ըստ վերը նշված կանոնների։\n\nՕրինակներ:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nԱռաջին օրինակով, ուսանողը, ով ունի ամենաբարձր ընդհանուր գնահատականը, համար 6-ն է։ Ուսանողներ համար 4-ը և 3-ը հաջորդում են՝ նվազման կարգով ընդհանուր գնահատականներով։ Ուսանող համար 1-ը ունի ավելի ցածր ընդհանուր գնահատական, քան ուսանող համար 2-ը, բայց ավելի բարձր չինարեն գնահատական, ուստի ուսանող համար 1-ը տեղադրվում է ուսանող համար 2-ից հետո դասավորված ցուցակում։\n\nԵրկրորդ օրինակով, ուսանողներ համար 1-ը և 2-ը ունեն նույն ընդհանուր գնահատականը, բայց ուսանող համար 1-ը ունի ավելի բարձր չինարեն գնահատական, ուստի նրանք տեղադրվում են առաջինը։ Մնացածը դասավորվում են իրենց ընդհանուր գնահատականների նվազման կարգով։", "bn": "ছাত্রদের একটি তালিকা তাদের স্কোরের ভিত্তিতে সাজায়। ছাত্রদের প্রধানত তাদের মোট স্কোর (অবতরণক্রমে) দ্বারা সাজানো হয়, তারপর তাদের চীনা স্কোর (অবতরণক্রমে) দ্বারা, এবং অবশেষে সমতার ক্ষেত্রে তাদের ছাত্র নম্বর (আরোহণক্রমে) দ্বারা।\n\nআর্গস:\nstudent_scores (list): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপল (student_number, total_score, Chinese_score) নিয়ে গঠিত।\n\nরিটার্নস:\nlist: উপরের নিয়ম অনুযায়ী সাজানো টুপলের একটি তালিকা।\n\nউদাহরণ:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nপ্রথম উদাহরণে, সর্বোচ্চ মোট স্কোর সহ ছাত্র হলেন নম্বর 6। ছাত্র নম্বর 4 এবং 3 অনুসরণ করে, অবতরণক্রমে মোট স্কোর সহ। ছাত্র নম্বর 1 এর মোট স্কোর ছাত্র নম্বর 2 এর চেয়ে কম, কিন্তু চীনা স্কোর বেশি, তাই ছাত্র নম্বর 1 কে ছাত্র নম্বর 2 এর পরে সাজানো তালিকায় রাখা হয়েছে।\n\nদ্বিতীয় উদাহরণে, ছাত্র নম্বর 1 এবং 2 এর একই মোট স্কোর আছে, কিন্তু ছাত্র নম্বর 1 এর চীনা স্কোর বেশি, তাই তারা প্রথমে রাখা হয়েছে। বাকি ছাত্ররা তাদের অবতরণক্রমে মোট স্কোর দ্বারা সাজানো হয়েছে।", "bg": "Сортира списък от студенти въз основа на техните оценки. Студентите са сортирани основно по общата им оценка (в низходящ ред), след това по оценката им по китайски (в низходящ ред), и накрая по номера на студента (възходящ ред) в случай на равенство.\n\nАргументи:\nstudent_scores (list): Списък от кортежи, където всеки кортеж се състои от (номер_на_студент, обща_оценка, оценка_по_китайски).\n\nВръща:\nlist: Списък от кортежи, сортирани според горните правила.\n\nПримери:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nВ първия пример, студентът с най-висока обща оценка е номер 6. Следват студенти номер 4 и 3 с намаляващи общи оценки. Студент номер 1 има по-ниска обща оценка от студент номер 2, но по-висока оценка по китайски, затова студент номер 1 е поставен след студент номер 2 в сортирания списък.\n\nВъв втория пример, студентите номер 1 и 2 имат еднаква обща оценка, но студент номер 1 има по-висока оценка по китайски, затова те са поставени първи. Останалите са сортирани по намаляващите им общи оценки.", "zh": "对学生列表进行排序，主要依据他们的总分（降序），然后是他们的语文分数（降序），最后在分数相同的情况下根据学号（升序）排序。\n\n参数：\nstudent_scores (list): 一个元组列表，每个元组包含 (student_number, total_score, Chinese_score)。\n\n返回：\nlist: 一个根据上述规则排序的元组列表。\n\n示例：\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\n在第一个示例中，总分最高的学生是学号6。接下来是学号4和3，总分依次递减。学号1的总分低于学号2，但语文分数更高，因此学号1在排序列表中排在学号2之后。\n\n在第二个示例中，学号1和2的总分相同，但学号1的语文分数更高，因此他们排在最前面。其余的按照总分降序排序。", "fr": "Trie une liste d'étudiants en fonction de leurs scores. Les étudiants sont triés principalement par leur score total (décroissant), puis par leur score en chinois (décroissant), et enfin par leur numéro d'étudiant (croissant) en cas d'égalité.\n\nArgs:\nstudent_scores (list): Une liste de tuples, où chaque tuple se compose de (numéro_étudiant, score_total, score_chinois).\n\nReturns:\nlist: Une liste de tuples triés selon les règles ci-dessus.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nDans le premier exemple, l'étudiant avec le score total le plus élevé est le numéro 6. Les étudiants numéro 4 et 3 suivent, avec des scores totaux décroissants. L'étudiant numéro 1 a un score total inférieur à l'étudiant numéro 2, mais un score en chinois plus élevé, donc l'étudiant numéro 1 est placé après l'étudiant numéro 2 dans la liste triée.\n\nDans le deuxième exemple, les étudiants numéro 1 et 2 ont le même score total, mais l'étudiant numéro 1 a un score en chinois plus élevé, donc ils sont placés en premier. Les autres sont triés par leurs scores totaux décroissants.", "de": "Sortiert eine Liste von Studenten basierend auf ihren Punktzahlen. Die Studenten werden hauptsächlich nach ihrer Gesamtpunktzahl (absteigend) sortiert, dann nach ihrer Chinesisch-Punktzahl (absteigend) und schließlich nach ihrer Studentennummer (aufsteigend) im Falle eines Gleichstands.\n\nArgs:\nstudent_scores (list): Eine Liste von Tupeln, wobei jedes Tupel aus (student_number, total_score, Chinese_score) besteht.\n\nReturns:\nlist: Eine Liste von Tupeln, die gemäß den obigen Regeln sortiert ist.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nIm ersten Beispiel hat der Student mit der höchsten Gesamtpunktzahl die Nummer 6. Die Studenten mit den Nummern 4 und 3 folgen, mit absteigenden Gesamtpunktzahlen. Student Nummer 1 hat eine niedrigere Gesamtpunktzahl als Student Nummer 2, aber eine höhere Chinesisch-Punktzahl, daher wird Student Nummer 1 nach Student Nummer 2 in der sortierten Liste platziert.\n\nIm zweiten Beispiel haben die Studenten mit den Nummern 1 und 2 die gleiche Gesamtpunktzahl, aber Student Nummer 1 hat eine höhere Chinesisch-Punktzahl, daher werden sie zuerst platziert. Der Rest wird nach ihren absteigenden Gesamtpunktzahlen sortiert.", "ha": "Yana tsara jerin ɗalibai bisa ga maki nasu. Ana tsara ɗaliban ne da farko bisa ga jimillar maki nasu (daga mafi girma zuwa ƙasa),\nsannan bisa ga maki na Sinanci (daga mafi girma zuwa ƙasa), kuma a ƙarshe bisa ga lambar ɗalibi (daga mafi ƙanƙanta zuwa mafi girma) idan akwai daidaito.\n\nArgs:\nstudent_scores (list): Jerin tuples, inda kowanne tuple ya ƙunshi (student_number, total_score, Chinese_score).\n\nReturns:\nlist: Jerin tuples da aka jera bisa ga dokokin da ke sama.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nA cikin misali na farko, ɗalibin da ke da mafi girman jimillar maki shi ne lamba 6. Dalibai lamba 4 da 3 suna biye, tare da jimillar maki mai sauka. Dalibi lamba 1 yana da ƙananan jimillar maki fiye da dalibi lamba 2, amma yana da mafi girman maki na Sinanci, don haka dalibi lamba 1 yana bayan dalibi lamba 2 a cikin jerin da aka jera.\n\nA cikin misali na biyu, dalibai lamba 1 da 2 suna da jimillar maki iri ɗaya, amma dalibi lamba 1 yana da mafi girman maki na Sinanci, don haka suna farko. Sauran suna jerawa bisa ga jimillar maki mai sauka.", "hi": "छात्रों की एक सूची को उनके अंकों के आधार पर क्रमबद्ध करता है। छात्रों को मुख्य रूप से उनके कुल अंकों (अवरोही क्रम में) के आधार पर क्रमबद्ध किया जाता है, फिर उनके चीनी अंकों (अवरोही क्रम में), और अंत में टाई की स्थिति में उनके छात्र संख्या (आरोही क्रम में) के आधार पर।\n\nआर्ग्स:\nstudent_scores (list): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में (student_number, total_score, Chinese_score) होते हैं।\n\nवापसी:\nlist: उपरोक्त नियमों के अनुसार क्रमबद्ध ट्यूपल की एक सूची।\n\nउदाहरण:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nपहले उदाहरण में, सबसे अधिक कुल अंक वाला छात्र संख्या 6 है। छात्र संख्या 4 और 3 उसके बाद आते हैं, अवरोही कुल अंकों के साथ। छात्र संख्या 1 के पास छात्र संख्या 2 की तुलना में कम कुल अंक हैं, लेकिन अधिक चीनी अंक हैं, इसलिए छात्र संख्या 1 को क्रमबद्ध सूची में छात्र संख्या 2 के बाद रखा गया है।\n\nदूसरे उदाहरण में, छात्र संख्या 1 और 2 के पास समान कुल अंक हैं, लेकिन छात्र संख्या 1 के पास अधिक चीनी अंक हैं, इसलिए उन्हें पहले रखा गया है। बाकी को उनके अवरोही कुल अंकों के अनुसार क्रमबद्ध किया गया है।", "hu": "Rendezi a diákok listáját a pontszámaik alapján. A diákok elsősorban az összpontszámuk szerint (csökkenő sorrendben) vannak rendezve, majd a kínai pontszámuk szerint (csökkenő sorrendben), és végül a diák számuk szerint (növekvő sorrendben) döntetlen esetén.\n\nArgs:\nstudent_scores (list): Egy listája a tuple-öknek, ahol minden tuple a következőkből áll: (diák_szám, összpontszám, kínai_pontszám).\n\nReturns:\nlist: Egy listája a tuple-öknek, a fenti szabályok szerint rendezve.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nAz első példában a legmagasabb összpontszámmal rendelkező diák a 6-os számú. A 4-es és 3-as számú diákok követik, csökkenő összpontszámokkal. Az 1-es számú diáknak alacsonyabb az összpontszáma, mint a 2-es számú diáknak, de magasabb a kínai pontszáma, így az 1-es számú diák a 2-es számú diák után van elhelyezve a rendezett listában.\n\nA második példában az 1-es és 2-es számú diákoknak azonos az összpontszámuk, de az 1-es számú diáknak magasabb a kínai pontszáma, így ők kerülnek előre. A többiek csökkenő összpontszám szerint vannak rendezve.", "es": "Ordena una lista de estudiantes según sus puntajes. Los estudiantes se ordenan principalmente por su puntaje total (descendente), luego por su puntaje en Chino (descendente), y finalmente por su número de estudiante (ascendente) en caso de empate.\n\nArgumentos:\nstudent_scores (list): Una lista de tuplas, donde cada tupla consiste en (número_de_estudiante, puntaje_total, puntaje_Chino).\n\nDevuelve:\nlist: Una lista de tuplas ordenadas de acuerdo con las reglas anteriores.\n\nEjemplos:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nEn el primer ejemplo, el estudiante con el puntaje total más alto es el número 6. Los estudiantes número 4 y 3 siguen, con puntajes totales descendentes. El estudiante número 1 tiene un puntaje total más bajo que el estudiante número 2, pero un puntaje en Chino más alto, por lo que el estudiante número 1 se coloca después del estudiante número 2 en la lista ordenada.\n\nEn el segundo ejemplo, los estudiantes número 1 y 2 tienen el mismo puntaje total, pero el estudiante número 1 tiene un puntaje en Chino más alto, por lo que se colocan primero. El resto se ordena por sus puntajes totales descendentes.", "arb": "يقوم بترتيب قائمة الطلاب بناءً على درجاتهم. يتم ترتيب الطلاب بشكل أساسي حسب مجموع درجاتهم (تنازليًا)، ثم حسب درجاتهم في اللغة الصينية (تنازليًا)، وأخيرًا حسب رقم الطالب (تصاعديًا) في حالة التعادل.\n\nالمعاملات:\nstudent_scores (list): قائمة من الأزواج، حيث يتكون كل زوج من (رقم الطالب، مجموع الدرجات، درجة اللغة الصينية).\n\nالقيم المعادة:\nlist: قائمة من الأزواج مرتبة وفقًا للقواعد المذكورة أعلاه.\n\nأمثلة:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nفي المثال الأول، الطالب الذي لديه أعلى مجموع درجات هو رقم 6. يتبعه الطلاب رقم 4 و3، مع مجموع درجات تنازلي. الطالب رقم 1 لديه مجموع درجات أقل من الطالب رقم 2، ولكن درجة أعلى في اللغة الصينية، لذلك يتم وضع الطالب رقم 1 بعد الطالب رقم 2 في القائمة المرتبة.\n\nفي المثال الثاني، الطلاب رقم 1 و2 لديهم نفس مجموع الدرجات، ولكن الطالب رقم 1 لديه درجة أعلى في اللغة الصينية، لذلك يتم وضعهم أولاً. الباقي يتم ترتيبهم حسب مجموع درجاتهم التنازلي.", "sw": "Hupanga orodha ya wanafunzi kulingana na alama zao. Wanafunzi wanapangwa kimsingi kwa alama zao za jumla (kutoka juu kwenda chini), kisha kwa alama zao za Kichina (kutoka juu kwenda chini), na hatimaye kwa nambari zao za mwanafunzi (kutoka chini kwenda juu) ikiwa kuna sare.\n\nHoja:\nstudent_scores (list): Orodha ya jozi, ambapo kila jozi inajumuisha (nambari ya mwanafunzi, alama ya jumla, alama ya Kichina).\n\nInarejesha:\nlist: Orodha ya jozi zilizopangwa kulingana na sheria zilizo hapo juu.\n\nMifano:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nKatika mfano wa kwanza, mwanafunzi mwenye alama ya juu kabisa ya jumla ni nambari 6. Wanafunzi nambari 4 na 3 wanafuata, na alama za jumla zinazopungua. Mwanafunzi nambari 1 ana alama ya jumla ya chini kuliko mwanafunzi nambari 2, lakini ana alama ya juu ya Kichina, hivyo mwanafunzi nambari 1 amewekwa baada ya mwanafunzi nambari 2 katika orodha iliyopangwa.\n\nKatika mfano wa pili, wanafunzi nambari 1 na 2 wana alama sawa ya jumla, lakini mwanafunzi nambari 1 ana alama ya juu ya Kichina, hivyo wamewekwa kwanza. Wengine wanapangwa kwa alama zao za jumla zinazopungua.", "tr": "Öğrencilerin puanlarına göre bir listeyi sıralar. Öğrenciler öncelikle toplam puanlarına göre (azalan), ardından Çince puanlarına göre (azalan) ve son olarak eşitlik durumunda öğrenci numaralarına göre (artan) sıralanır.\n\nArgümanlar:\nstudent_scores (list): Her bir demetin (öğrenci_numarası, toplam_puan, Çince_puan) içerdiği demetlerin bir listesi.\n\nDöndürür:\nlist: Yukarıdaki kurallara göre sıralanmış demetlerin bir listesi.\n\nÖrnekler:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nİlk örnekte, en yüksek toplam puana sahip öğrenci numarası 6'dır. Öğrenci numaraları 4 ve 3, azalan toplam puanlarla takip eder. Öğrenci numarası 1, öğrenci numarası 2'den daha düşük bir toplam puana sahiptir, ancak daha yüksek bir Çince puana sahiptir, bu nedenle sıralı listede öğrenci numarası 2'nin ardından yer alır.\n\nİkinci örnekte, öğrenci numaraları 1 ve 2 aynı toplam puana sahiptir, ancak öğrenci numarası 1 daha yüksek bir Çince puana sahiptir, bu nedenle ilk sırada yer alırlar. Geri kalanlar, azalan toplam puanlarına göre sıralanır.", "vi": "Sắp xếp danh sách sinh viên dựa trên điểm số của họ. Sinh viên được sắp xếp chủ yếu theo tổng điểm (giảm dần), sau đó theo điểm tiếng Trung (giảm dần), và cuối cùng theo số hiệu sinh viên (tăng dần) trong trường hợp hòa.\n\nTham số:\nstudent_scores (list): Một danh sách các bộ giá trị, trong đó mỗi bộ giá trị bao gồm (số hiệu sinh viên, tổng điểm, điểm tiếng Trung).\n\nTrả về:\nlist: Một danh sách các bộ giá trị được sắp xếp theo các quy tắc trên.\n\nVí dụ:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nTrong ví dụ đầu tiên, sinh viên có tổng điểm cao nhất là số 6. Sinh viên số 4 và 3 theo sau, với tổng điểm giảm dần. Sinh viên số 1 có tổng điểm thấp hơn sinh viên số 2, nhưng điểm tiếng Trung cao hơn, vì vậy sinh viên số 1 được xếp sau sinh viên số 2 trong danh sách đã sắp xếp.\n\nTrong ví dụ thứ hai, sinh viên số 1 và 2 có cùng tổng điểm, nhưng sinh viên số 1 có điểm tiếng Trung cao hơn, vì vậy họ được xếp đầu tiên. Những người còn lại được sắp xếp theo tổng điểm giảm dần của họ.", "id": "Mengurutkan daftar siswa berdasarkan nilai mereka. Siswa diurutkan terutama berdasarkan total nilai mereka (menurun), kemudian berdasarkan nilai Bahasa Mandarin mereka (menurun), dan akhirnya berdasarkan nomor siswa mereka (menaik) jika ada kesamaan.\n\nArgs:\nstudent_scores (list): Daftar tuple, di mana setiap tuple terdiri dari (nomor_siswa, total_nilai, nilai_Bahasa_Mandarin).\n\nReturns:\nlist: Daftar tuple yang diurutkan sesuai dengan aturan di atas.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nDalam contoh pertama, siswa dengan total nilai tertinggi adalah nomor 6. Siswa nomor 4 dan 3 mengikuti, dengan total nilai menurun. Siswa nomor 1 memiliki total nilai yang lebih rendah dari siswa nomor 2, tetapi nilai Bahasa Mandarin yang lebih tinggi, jadi siswa nomor 1 ditempatkan setelah siswa nomor 2 dalam daftar yang diurutkan.\n\nDalam contoh kedua, siswa nomor 1 dan 2 memiliki total nilai yang sama, tetapi siswa nomor 1 memiliki nilai Bahasa Mandarin yang lebih tinggi, jadi mereka ditempatkan pertama. Sisanya diurutkan berdasarkan total nilai mereka yang menurun.", "ja": "学生のスコアに基づいて学生のリストをソートします。学生は主に総合スコア（降順）でソートされ、次に中国語のスコア（降順）、同点の場合は学生番号（昇順）でソートされます。\n\n引数:\nstudent_scores (list): 各タプルが (student_number, total_score, Chinese_score) で構成されるタプルのリスト。\n\n戻り値:\nlist: 上記のルールに従ってソートされたタプルのリスト。\n\n例:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\n最初の例では、最も高い総合スコアを持つ学生は番号6です。番号4と3の学生が続き、総合スコアは降順です。番号1の学生は番号2の学生よりも総合スコアが低いですが、中国語のスコアが高いため、ソートされたリストでは番号2の後に配置されます。\n\n2番目の例では、番号1と2の学生は同じ総合スコアを持っていますが、番号1の学生は中国語のスコアが高いため、最初に配置されます。残りは総合スコアの降順でソートされます。", "ko": "학생들의 점수를 기준으로 목록을 정렬합니다. 학생들은 주로 총점(내림차순)으로 정렬되며, 그 다음으로는 중국어 점수(내림차순), 마지막으로 동점일 경우 학번(오름차순)으로 정렬됩니다.\n\nArgs:\nstudent_scores (list): 각 튜플이 (학번, 총점, 중국어 점수)로 구성된 튜플의 목록입니다.\n\nReturns:\nlist: 위의 규칙에 따라 정렬된 튜플 목록입니다.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\n첫 번째 예제에서, 총점이 가장 높은 학생은 6번입니다. 4번과 3번 학생이 그 뒤를 따르며, 총점이 내림차순으로 정렬됩니다. 1번 학생은 2번 학생보다 총점이 낮지만 중국어 점수가 높기 때문에, 정렬된 목록에서 2번 학생 다음에 배치됩니다.\n\n두 번째 예제에서, 1번과 2번 학생은 총점이 같지만 1번 학생이 중국어 점수가 더 높아 먼저 배치됩니다. 나머지는 총점이 내림차순으로 정렬됩니다.", "ml": "വിദ്യാർത്ഥികളുടെ പട്ടിക അവരുടെ സ്കോറുകളുടെ അടിസ്ഥാനത്തിൽ ക്രമീകരിക്കുന്നു. വിദ്യാർത്ഥികളെ പ്രധാനമായും അവരുടെ മൊത്തം സ്കോറിന്റെ (ഇറക്കം ക്രമത്തിൽ) അടിസ്ഥാനത്തിൽ, തുടർന്ന് അവരുടെ ചൈനീസ് സ്കോറിന്റെ (ഇറക്കം ക്രമത്തിൽ) അടിസ്ഥാനത്തിൽ, ഒടുവിൽ സമതുല്യമായ സാഹചര്യത്തിൽ അവരുടെ വിദ്യാർത്ഥി നമ്പറിന്റെ (ആരോഹണ ക്രമത്തിൽ) അടിസ്ഥാനത്തിൽ ക്രമീകരിക്കുന്നു.\n\nആർഗ്സ്:\nstudent_scores (list): ഓരോ ട്യൂപ്പിളും (student_number, total_score, Chinese_score) അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\nമടക്കം:\nlist: മുകളിൽ പറഞ്ഞിരിക്കുന്ന നിയമങ്ങൾ അനുസരിച്ച് ക്രമീകരിച്ച ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\nഉദാഹരണങ്ങൾ:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nആദ്യ ഉദാഹരണത്തിൽ, ഏറ്റവും ഉയർന്ന മൊത്തം സ്കോർ ഉള്ള വിദ്യാർത്ഥി നമ്പർ 6 ആണ്. വിദ്യാർത്ഥി നമ്പർ 4, 3 എന്നിവരാണ് തുടർന്നുള്ളവർ, ഇറക്കം ക്രമത്തിലുള്ള മൊത്തം സ്കോറുകളോടെ. വിദ്യാർത്ഥി നമ്പർ 1 ന് വിദ്യാർത്ഥി നമ്പർ 2 നെക്കാൾ കുറഞ്ഞ മൊത്തം സ്കോർ ഉണ്ട്, പക്ഷേ ഉയർന്ന ചൈനീസ് സ്കോർ ഉണ്ട്, അതിനാൽ വിദ്യാർത്ഥി നമ്പർ 1 നെ വിദ്യാർത്ഥി നമ്പർ 2 ന്റെ ശേഷം ക്രമീകരിച്ച പട്ടികയിൽ ഇടം നൽകുന്നു.\n\nരണ്ടാമത്തെ ഉദാഹരണത്തിൽ, വിദ്യാർത്ഥി നമ്പർ 1, 2 എന്നിവർക്കും സമാനമായ മൊത്തം സ്കോർ ഉണ്ട്, പക്ഷേ വിദ്യാർത്ഥി നമ്പർ 1 ന് ഉയർന്ന ചൈനീസ് സ്കോർ ഉണ്ട്, അതിനാൽ അവർ ആദ്യം ഇടം നേടുന്നു. ബാക്കി വിദ്യാർത്ഥികളെ അവരുടെ ഇറക്കം ക്രമത്തിലുള്ള മൊത്തം സ്കോറുകൾ പ്രകാരം ക്രമീകരിക്കുന്നു.", "fa": "مرتب‌سازی لیستی از دانش‌آموزان بر اساس نمرات آن‌ها. دانش‌آموزان ابتدا بر اساس نمره کل (نزولی)، سپس بر اساس نمره زبان چینی (نزولی) و در نهایت در صورت تساوی بر اساس شماره دانش‌آموز (صعودی) مرتب می‌شوند.\n\nArgs:\nstudent_scores (list): لیستی از تاپل‌ها که هر تاپل شامل (شماره دانش‌آموز، نمره کل، نمره زبان چینی) است.\n\nReturns:\nlist: لیستی از تاپل‌ها که بر اساس قوانین فوق مرتب شده‌اند.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nدر مثال اول، دانش‌آموز با بالاترین نمره کل شماره 6 است. دانش‌آموزان شماره 4 و 3 با نمرات کل نزولی دنبال می‌شوند. دانش‌آموز شماره 1 نمره کل کمتری نسبت به دانش‌آموز شماره 2 دارد، اما نمره زبان چینی بالاتری دارد، بنابراین دانش‌آموز شماره 1 بعد از دانش‌آموز شماره 2 در لیست مرتب شده قرار می‌گیرد.\n\nدر مثال دوم، دانش‌آموزان شماره 1 و 2 نمره کل یکسانی دارند، اما دانش‌آموز شماره 1 نمره زبان چینی بالاتری دارد، بنابراین آن‌ها در ابتدا قرار می‌گیرند. بقیه بر اساس نمرات کل نزولی مرتب می‌شوند."}}
{"task_id": "Python/48", "prompt": {"en": "def min_groups(w, n, prices):\n    \"\"\"\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    \n    Case 1:\n    A limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    The minimum number of groups is 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Case 2:\n    A limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\n    The minimum number of groups is 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Case 3:\n    A limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\n    Since each pair's total price does not exceed the limit, the minimum number of groups is 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "sq": "def min_groups(w, n, prices):\n    \"\"\"\n    Përcakton numrin minimal të grupeve të nevojshme për të shpërndarë suveniret me një kufizim në çmimin total të grupit.\n    \n    Suveniret grupohen në çifte të tilla që çmimi total i secilit grup nuk e tejkalon kufirin `w`. \n    Funksioni synon të minimizojë numrin e grupeve të krijuara nën këtë kufizim.\n    \n    Args:\n    w (int): Shuma maksimale e lejuar e çmimeve për çdo grup suveniresh.\n    n (int): Numri total i suvenireve.\n    prices (list): Një listë e numrave të plotë që përfaqësojnë çmimin e secilit suvenir.\n    \n    Returns:\n    int: Numri minimal i grupeve të nevojshme për të shpërndarë të gjitha suveniret.\n\n    Shembuj:\n    \n    Rasti 1:\n    Një kufi prej 100 dhe 9 suvenire me çmime [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Numri minimal i grupeve është 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Rasti 2:\n    Një kufi prej 200 dhe 5 suvenire me çmime [80, 120, 60, 40, 100].\n    Numri minimal i grupeve është 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Rasti 3:\n    Një kufi prej 80 dhe 4 suvenire me çmime [30, 30, 20, 10].\n    Meqenëse çmimi total i secilit çift nuk e tejkalon kufirin, numri minimal i grupeve është 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "hy": "def min_groups(w, n, prices):\n    \"\"\"\n    Որոշում է անհրաժեշտ խմբերի նվազագույն քանակը հուշանվերները բաշխելու համար՝ խմբի ընդհանուր գնի սահմանափակմամբ։\n    \n    Հուշանվերները խմբավորվում են զույգերով այնպես, որ յուրաքանչյուր խմբի ընդհանուր գինը չգերազանցի `w` սահմանը։\n    Ֆունկցիան նպատակ ունի նվազեցնել ստեղծված խմբերի քանակը այս սահմանափակման ներքո։\n    \n    Արգումենտներ:\n    w (int): Հուշանվերների ցանկացած խմբի գների թույլատրելի առավելագույն գումարը։\n    n (int): Հուշանվերների ընդհանուր քանակը։\n    prices (list): Ցանկ, որը ներկայացնում է յուրաքանչյուր հուշանվերի գինը ամբողջ թվերով։\n    \n    Վերադարձնում է:\n    int: Անհրաժեշտ խմբերի նվազագույն քանակը՝ բոլոր հուշանվերները բաշխելու համար։\n\n    Օրինակներ:\n    \n    Դեպք 1:\n    100 սահման և 9 հուշանվերներ գներով [90, 20, 20, 30, 50, 60, 70, 80, 90]։\n    Նվազագույն խմբերի քանակը 6 է։\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Դեպք 2:\n    200 սահման և 5 հուշանվերներ գներով [80, 120, 60, 40, 100]։\n    Նվազագույն խմբերի քանակը 3 է։\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Դեպք 3:\n    80 սահման և 4 հուշանվերներ գներով [30, 30, 20, 10]։\n    Քանի որ յուրաքանչյուր զույգի ընդհանուր գինը չի գերազանցում սահմանը, նվազագույն խմբերի քանակը 2 է։\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "bn": "def min_groups(w, n, prices):\n    \"\"\"\n    স্মৃতিচিহ্ন বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ নির্ধারণ করে একটি গ্রুপের মোট মূল্যের সীমাবদ্ধতা সহ।\n    \n    স্মৃতিচিহ্নগুলি এমনভাবে জোড়ায় জোড়ায় গ্রুপ করা হয় যাতে প্রতিটি গ্রুপের মোট মূল্য সীমা `w` অতিক্রম না করে। \n    এই সীমাবদ্ধতার অধীনে তৈরি গ্রুপের সংখ্যা কমিয়ে আনার লক্ষ্য রাখে ফাংশনটি।\n    \n    Args:\n    w (int): যে কোনো স্মৃতিচিহ্নের গ্রুপের জন্য অনুমোদিত সর্বাধিক মূল্যের যোগফল।\n    n (int): স্মৃতিচিহ্নের মোট সংখ্যা।\n    prices (list): প্রতিটি স্মৃতিচিহ্নের মূল্য উপস্থাপনকারী পূর্ণসংখ্যার তালিকা।\n    \n    Returns:\n    int: সমস্ত স্মৃতিচিহ্ন বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ।\n\n    উদাহরণসমূহ:\n    \n    কেস 1:\n    100 এর সীমা এবং 9 টি স্মৃতিচিহ্ন যার মূল্য [90, 20, 20, 30, 50, 60, 70, 80, 90]।\n    সর্বনিম্ন গ্রুপের সংখ্যা 6।\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    কেস 2:\n    200 এর সীমা এবং 5 টি স্মৃতিচিহ্ন যার মূল্য [80, 120, 60, 40, 100]।\n    সর্বনিম্ন গ্রুপের সংখ্যা 3।\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    কেস 3:\n    80 এর সীমা এবং 4 টি স্মৃতিচিহ্ন যার মূল্য [30, 30, 20, 10]।\n    যেহেতু প্রতিটি জোড়ার মোট মূল্য সীমা অতিক্রম করে না, সর্বনিম্ন গ্রুপের সংখ্যা 2।\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "bg": "def min_groups(w, n, prices):\n    \"\"\"\n    Определя минималния брой групи, необходими за разпределение на сувенири с ограничение на общата цена на групата.\n    \n    Сувенирите се групират по двойки така, че общата цена на всяка група да не надвишава лимита `w`. \n    Функцията има за цел да минимизира броя на създадените групи при това ограничение.\n    \n    Аргументи:\n    w (int): Максимално допустимата сума на цените за която и да е група сувенири.\n    n (int): Общият брой на сувенирите.\n    prices (list): Списък от цели числа, представляващи цената на всеки сувенир.\n    \n    Връща:\n    int: Минималният брой групи, необходими за разпределение на всички сувенири.\n\n    Примери:\n    \n    Случай 1:\n    Лимит от 100 и 9 сувенира с цени [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Минималният брой групи е 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Случай 2:\n    Лимит от 200 и 5 сувенира с цени [80, 120, 60, 40, 100].\n    Минималният брой групи е 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Случай 3:\n    Лимит от 80 и 4 сувенира с цени [30, 30, 20, 10].\n    Тъй като общата цена на всяка двойка не надвишава лимита, минималният брой групи е 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "zh": "def min_groups(w, n, prices):\n    \"\"\"\n    确定在对组的总价格有限制的情况下分配纪念品所需的最小组数。\n    \n    纪念品成对分组，使每组的总价格不超过限制 `w`。\n    该函数旨在在此限制下最小化创建的组数。\n    \n    参数:\n    w (int): 任何纪念品组允许的最大价格总和。\n    n (int): 纪念品的总数量。\n    prices (list): 一个整数列表，表示每个纪念品的价格。\n    \n    返回:\n    int: 分配所有纪念品所需的最小组数。\n\n    示例:\n    \n    案例 1:\n    限制为 100 和 9 个纪念品，价格为 [90, 20, 20, 30, 50, 60, 70, 80, 90]。\n    最小组数为 6。\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    案例 2:\n    限制为 200 和 5 个纪念品，价格为 [80, 120, 60, 40, 100]。\n    最小组数为 3。\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    案例 3:\n    限制为 80 和 4 个纪念品，价格为 [30, 30, 20, 10]。\n    由于每对的总价格不超过限制，最小组数为 2。\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "fr": "def min_groups(w, n, prices):\n    \"\"\"\n    Détermine le nombre minimum de groupes nécessaires pour distribuer des souvenirs avec une contrainte sur le prix total du groupe.\n    \n    Les souvenirs sont regroupés par paires de sorte que le prix total de chaque groupe ne dépasse pas la limite `w`. \n    La fonction vise à minimiser le nombre de groupes créés sous cette contrainte.\n    \n    Args:\n    w (int): La somme maximale autorisée des prix pour tout groupe de souvenirs.\n    n (int): Le nombre total de souvenirs.\n    prices (list): Une liste d'entiers représentant le prix de chaque souvenir.\n    \n    Returns:\n    int: Le nombre minimum de groupes requis pour distribuer tous les souvenirs.\n\n    Exemples:\n    \n    Cas 1:\n    Une limite de 100 et 9 souvenirs avec des prix [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Le nombre minimum de groupes est 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Cas 2:\n    Une limite de 200 et 5 souvenirs avec des prix [80, 120, 60, 40, 100].\n    Le nombre minimum de groupes est 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Cas 3:\n    Une limite de 80 et 4 souvenirs avec des prix [30, 30, 20, 10].\n    Comme le prix total de chaque paire ne dépasse pas la limite, le nombre minimum de groupes est 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "de": "def min_groups(w, n, prices):\n    \"\"\"\n    Bestimmt die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs mit einer Einschränkung auf den Gesamtpreis der Gruppe zu verteilen.\n    \n    Die Souvenirs werden paarweise gruppiert, sodass der Gesamtpreis jeder Gruppe das Limit `w` nicht überschreitet. \n    Die Funktion zielt darauf ab, die Anzahl der unter dieser Einschränkung erstellten Gruppen zu minimieren.\n    \n    Argumente:\n    w (int): Die maximal erlaubte Summe der Preise für jede Gruppe von Souvenirs.\n    n (int): Die Gesamtanzahl der Souvenirs.\n    prices (list): Eine Liste von ganzen Zahlen, die den Preis jedes Souvenirs darstellen.\n    \n    Rückgabewert:\n    int: Die minimale Anzahl von Gruppen, die erforderlich sind, um alle Souvenirs zu verteilen.\n\n    Beispiele:\n    \n    Fall 1:\n    Ein Limit von 100 und 9 Souvenirs mit Preisen [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Die minimale Anzahl von Gruppen ist 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Fall 2:\n    Ein Limit von 200 und 5 Souvenirs mit Preisen [80, 120, 60, 40, 100].\n    Die minimale Anzahl von Gruppen ist 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Fall 3:\n    Ein Limit von 80 und 4 Souvenirs mit Preisen [30, 30, 20, 10].\n    Da der Gesamtpreis jedes Paares das Limit nicht überschreitet, ist die minimale Anzahl von Gruppen 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "ha": "def min_groups(w, n, prices):\n    \"\"\"\n    Yana tantance mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kayan kyauta tare da ƙuntatawa kan jimillar farashin ƙungiyar.\n\n    Ana haɗa kayan kyaututtuka a cikin ma'aurata ta yadda jimillar farashin kowace ƙungiya ba ta wuce iyaka `w`. \n    Aikin yana nufin rage yawan ƙungiyoyin da aka ƙirƙira ƙarƙashin wannan ƙuntatawa.\n\n    Args:\n    w (int): Mafi girman adadin jimillar farashin kowace ƙungiyar kayan kyauta.\n    n (int): Jimillar adadin kayan kyauta.\n    prices (list): Jerin lambobi masu wakiltar farashin kowane kayan kyauta.\n\n    Returns:\n    int: Mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba duk kayan kyauta.\n\n    Misalai:\n    \n    Case 1:\n    Iyaka na 100 da kayan kyauta 9 tare da farashi [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Mafi ƙarancin adadin ƙungiyoyi shine 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Case 2:\n    Iyaka na 200 da kayan kyauta 5 tare da farashi [80, 120, 60, 40, 100].\n    Mafi ƙarancin adadin ƙungiyoyi shine 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Case 3:\n    Iyaka na 80 da kayan kyauta 4 tare da farashi [30, 30, 20, 10].\n    Tun da jimillar farashin kowace ma'aurata ba ta wuce iyaka ba, mafi ƙarancin adadin ƙungiyoyi shine 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "hi": "def min_groups(w, n, prices):\n    \"\"\"\n    स्मृति चिह्नों को एक सीमा के साथ समूह की कुल कीमत पर वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करता है।\n    \n    स्मृति चिह्नों को जोड़ों में इस तरह से समूहबद्ध किया जाता है कि प्रत्येक समूह की कुल कीमत सीमा `w` से अधिक न हो। \n    यह फ़ंक्शन इस सीमा के तहत बनाए गए समूहों की संख्या को न्यूनतम करने का प्रयास करता है।\n    \n    Args:\n    w (int): किसी भी स्मृति चिह्न समूह के लिए अनुमत कीमतों का अधिकतम योग।\n    n (int): स्मृति चिह्नों की कुल संख्या।\n    prices (list): प्रत्येक स्मृति चिह्न की कीमत का प्रतिनिधित्व करने वाले पूर्णांकों की सूची।\n    \n    Returns:\n    int: सभी स्मृति चिह्नों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या।\n\n    उदाहरण:\n    \n    मामला 1:\n    100 की सीमा और 9 स्मृति चिह्न जिनकी कीमतें [90, 20, 20, 30, 50, 60, 70, 80, 90] हैं।\n    न्यूनतम समूहों की संख्या 6 है।\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    मामला 2:\n    200 की सीमा और 5 स्मृति चिह्न जिनकी कीमतें [80, 120, 60, 40, 100] हैं।\n    न्यूनतम समूहों की संख्या 3 है।\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    मामला 3:\n    80 की सीमा और 4 स्मृति चिह्न जिनकी कीमतें [30, 30, 20, 10] हैं।\n    चूंकि प्रत्येक जोड़े की कुल कीमत सीमा से अधिक नहीं है, न्यूनतम समूहों की संख्या 2 है।\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "hu": "def min_groups(w, n, prices):\n    \"\"\"\n    Meghatározza a szükséges minimális csoportok számát az ajándéktárgyak elosztásához, a csoport teljes árának korlátozásával.\n    \n    Az ajándéktárgyakat párokba csoportosítják úgy, hogy minden csoport teljes ára ne haladja meg a `w` korlátot. \n    A függvény célja a létrehozott csoportok számának minimalizálása ezen korlátozás alatt.\n    \n    Args:\n    w (int): Az ajándéktárgyak bármely csoportjának megengedett maximális árösszege.\n    n (int): Az ajándéktárgyak teljes száma.\n    prices (list): Egész számokat tartalmazó lista, amely az egyes ajándéktárgyak árát reprezentálja.\n    \n    Returns:\n    int: A szükséges minimális csoportok száma az összes ajándéktárgy elosztásához.\n\n    Példák:\n    \n    1. eset:\n    100-as korlát és 9 ajándéktárgy áraival [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    A minimális csoportok száma 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    2. eset:\n    200-as korlát és 5 ajándéktárgy áraival [80, 120, 60, 40, 100].\n    A minimális csoportok száma 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    3. eset:\n    80-as korlát és 4 ajándéktárgy áraival [30, 30, 20, 10].\n    Mivel minden pár teljes ára nem haladja meg a korlátot, a minimális csoportok száma 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "es": "def min_groups(w, n, prices):\n    \"\"\"\n    Determina el número mínimo de grupos necesarios para distribuir los souvenirs con una restricción en el precio total del grupo.\n    \n    Los souvenirs se agrupan en pares de manera que el precio total de cada grupo no exceda el límite `w`. \n    La función busca minimizar el número de grupos creados bajo esta restricción.\n    \n    Argumentos:\n    w (int): La suma máxima permitida de precios para cualquier grupo de souvenirs.\n    n (int): El número total de souvenirs.\n    prices (list): Una lista de enteros que representa el precio de cada souvenir.\n    \n    Devuelve:\n    int: El número mínimo de grupos necesarios para distribuir todos los souvenirs.\n\n    Ejemplos:\n    \n    Caso 1:\n    Un límite de 100 y 9 souvenirs con precios [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    El número mínimo de grupos es 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Caso 2:\n    Un límite de 200 y 5 souvenirs con precios [80, 120, 60, 40, 100].\n    El número mínimo de grupos es 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Caso 3:\n    Un límite de 80 y 4 souvenirs con precios [30, 30, 20, 10].\n    Dado que el precio total de cada par no excede el límite, el número mínimo de grupos es 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "arb": "def min_groups(w, n, prices):\n    \"\"\"\n    يحدد الحد الأدنى لعدد المجموعات اللازمة لتوزيع التذكارات مع وجود قيد على السعر الإجمالي للمجموعة.\n\n    يتم تجميع التذكارات في أزواج بحيث لا يتجاوز السعر الإجمالي لكل مجموعة الحد `w`.\n    تهدف الدالة إلى تقليل عدد المجموعات التي تم إنشاؤها تحت هذا القيد.\n\n    يعيدالحجج:\n    w (int): الحد الأقصى المسموح به لمجموع أسعار أي مجموعة من التذكارات.\n    n (int): العدد الإجمالي للتذكارات.\n    prices (list): قائمة من الأعداد الصحيحة تمثل سعر كل تذكار.\n\n    يعيد:\n    int: الحد الأدنى لعدد المجموعات المطلوبة لتوزيع جميع التذكارات.\n\n    أمثلة:\n\n    الحالة 1:\n    حد 100 و 9 تذكارات بأسعار [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    الحد الأدنى لعدد المجموعات هو 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n\n    الحالة 2:\n    حد 200 و 5 تذكارات بأسعار [80, 120, 60, 40, 100].\n    الحد الأدنى لعدد المجموعات هو 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n\n    الحالة 3:\n    حد 80 و 4 تذكارات بأسعار [30, 30, 20, 10].\n    بما أن السعر الإجمالي لكل زوج لا يتجاوز الحد، فإن الحد الأدنى لعدد المجموعات هو 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "sw": "def min_groups(w, n, prices):\n    \"\"\"\n    Huamua idadi ndogo ya vikundi vinavyohitajika kugawa zawadi kwa kizuizi cha jumla ya bei ya kikundi.\n    \n    Zawadi zimepangwa katika jozi ili jumla ya bei ya kila kikundi isizidi kikomo `w`. \n    Kazi hii inalenga kupunguza idadi ya vikundi vilivyoundwa chini ya kizuizi hiki.\n    \n    Hoja:\n    w (int): Jumla ya juu inayoruhusiwa ya bei kwa kikundi chochote cha zawadi.\n    n (int): Jumla ya zawadi.\n    prices (list): Orodha ya namba za mzima zinazoonyesha bei ya kila zawadi.\n    \n    Inarejesha:\n    int: Idadi ndogo ya vikundi vinavyohitajika kugawa zawadi zote.\n\n    Mifano:\n    \n    Kesi 1:\n    Kikomo cha 100 na zawadi 9 zenye bei [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Idadi ndogo ya vikundi ni 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Kesi 2:\n    Kikomo cha 200 na zawadi 5 zenye bei [80, 120, 60, 40, 100].\n    Idadi ndogo ya vikundi ni 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Kesi 3:\n    Kikomo cha 80 na zawadi 4 zenye bei [30, 30, 20, 10].\n    Kwa kuwa jumla ya bei ya kila jozi haizidi kikomo, idadi ndogo ya vikundi ni 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "tr": "def min_groups(w, n, prices):\n    \"\"\"\n    Bir grubun toplam fiyatı üzerinde bir kısıtlama ile hediyelik eşyaları dağıtmak için gereken minimum grup sayısını belirler.\n    \n    Hediyelik eşyalar, her grubun toplam fiyatı `w` limitini aşmayacak şekilde çiftler halinde gruplanır.\n    Fonksiyon, bu kısıtlama altında oluşturulan grup sayısını en aza indirmeyi amaçlar.\n    \n    Argümanlar:\n    w (int): Herhangi bir hediyelik eşya grubunun izin verilen maksimum fiyat toplamı.\n    n (int): Toplam hediyelik eşya sayısı.\n    prices (list): Her hediyelik eşyanın fiyatını temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    int: Tüm hediyelik eşyaları dağıtmak için gereken minimum grup sayısı.\n\n    Örnekler:\n    \n    Durum 1:\n    100 limiti ve fiyatları [90, 20, 20, 30, 50, 60, 70, 80, 90] olan 9 hediyelik eşya.\n    Minimum grup sayısı 6'dır.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Durum 2:\n    200 limiti ve fiyatları [80, 120, 60, 40, 100] olan 5 hediyelik eşya.\n    Minimum grup sayısı 3'tür.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Durum 3:\n    80 limiti ve fiyatları [30, 30, 20, 10] olan 4 hediyelik eşya.\n    Her çiftin toplam fiyatı limiti aşmadığından, minimum grup sayısı 2'dir.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "vi": "def min_groups(w, n, prices):\n    \"\"\"\n    Xác định số nhóm tối thiểu cần thiết để phân phối quà lưu niệm với một giới hạn về tổng giá của nhóm.\n    \n    Các quà lưu niệm được nhóm thành cặp sao cho tổng giá của mỗi nhóm không vượt quá giới hạn `w`. \n    Hàm này nhằm mục đích giảm thiểu số lượng nhóm được tạo ra dưới giới hạn này.\n    \n    Tham số:\n    w (int): Tổng giá tối đa được phép cho bất kỳ nhóm quà lưu niệm nào.\n    n (int): Tổng số quà lưu niệm.\n    prices (list): Một danh sách các số nguyên đại diện cho giá của mỗi quà lưu niệm.\n    \n    Trả về:\n    int: Số lượng nhóm tối thiểu cần thiết để phân phối tất cả quà lưu niệm.\n\n    Ví dụ:\n    \n    Trường hợp 1:\n    Giới hạn là 100 và 9 quà lưu niệm với giá [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Số lượng nhóm tối thiểu là 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Trường hợp 2:\n    Giới hạn là 200 và 5 quà lưu niệm với giá [80, 120, 60, 40, 100].\n    Số lượng nhóm tối thiểu là 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Trường hợp 3:\n    Giới hạn là 80 và 4 quà lưu niệm với giá [30, 30, 20, 10].\n    Vì tổng giá của mỗi cặp không vượt quá giới hạn, số lượng nhóm tối thiểu là 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "id": "def min_groups(w, n, prices):\n    \"\"\"\n    Menentukan jumlah minimum kelompok yang dibutuhkan untuk mendistribusikan suvenir dengan batasan pada total harga kelompok.\n    \n    Suvenir dikelompokkan dalam pasangan sedemikian rupa sehingga total harga setiap kelompok tidak melebihi batas `w`. \n    Fungsi ini bertujuan untuk meminimalkan jumlah kelompok yang dibuat di bawah batasan ini.\n    \n    Argumen:\n    w (int): Jumlah maksimum yang diizinkan dari harga untuk setiap kelompok suvenir.\n    n (int): Jumlah total suvenir.\n    prices (list): Daftar bilangan bulat yang mewakili harga masing-masing suvenir.\n    \n    Mengembalikan:\n    int: Jumlah minimum kelompok yang diperlukan untuk mendistribusikan semua suvenir.\n\n    Contoh:\n    \n    Kasus 1:\n    Batas 100 dan 9 suvenir dengan harga [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Jumlah minimum kelompok adalah 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Kasus 2:\n    Batas 200 dan 5 suvenir dengan harga [80, 120, 60, 40, 100].\n    Jumlah minimum kelompok adalah 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Kasus 3:\n    Batas 80 dan 4 suvenir dengan harga [30, 30, 20, 10].\n    Karena total harga setiap pasangan tidak melebihi batas, jumlah minimum kelompok adalah 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "ja": "def min_groups(w, n, prices):\n    \"\"\"\n    グループの合計価格に制約がある状態で、お土産を配布するために必要な最小のグループ数を決定します。\n    \n    お土産はペアでグループ化され、各グループの合計価格が制限 `w` を超えないようにします。\n    この制約の下で作成されるグループの数を最小化することを目的としています。\n    \n    Args:\n    w (int): お土産のグループに許可される価格の合計の最大値。\n    n (int): お土産の総数。\n    prices (list): 各お土産の価格を表す整数のリスト。\n    \n    Returns:\n    int: すべてのお土産を配布するために必要な最小のグループ数。\n\n    Examples:\n    \n    ケース 1:\n    制限が100で、価格が [90, 20, 20, 30, 50, 60, 70, 80, 90] の9つのお土産。\n    最小のグループ数は6です。\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    ケース 2:\n    制限が200で、価格が [80, 120, 60, 40, 100] の5つのお土産。\n    最小のグループ数は3です。\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    ケース 3:\n    制限が80で、価格が [30, 30, 20, 10] の4つのお土産。\n    各ペアの合計価格が制限を超えないため、最小のグループ数は2です。\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "ko": "def min_groups(w, n, prices):\n    \"\"\"\n    그룹의 총 가격에 대한 제약 조건을 가지고 기념품을 배포하는 데 필요한 최소 그룹 수를 결정합니다.\n    \n    기념품은 각 그룹의 총 가격이 `w`를 초과하지 않도록 쌍으로 그룹화됩니다.\n    이 함수는 이러한 제약 조건 하에서 생성되는 그룹의 수를 최소화하는 것을 목표로 합니다.\n    \n    Args:\n    w (int): 기념품 그룹의 허용되는 최대 가격 합계.\n    n (int): 기념품의 총 수.\n    prices (list): 각 기념품의 가격을 나타내는 정수 리스트.\n    \n    Returns:\n    int: 모든 기념품을 배포하는 데 필요한 최소 그룹 수.\n\n    Examples:\n    \n    사례 1:\n    100의 제한과 가격이 [90, 20, 20, 30, 50, 60, 70, 80, 90]인 9개의 기념품.\n    최소 그룹 수는 6입니다.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    사례 2:\n    200의 제한과 가격이 [80, 120, 60, 40, 100]인 5개의 기념품.\n    최소 그룹 수는 3입니다.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    사례 3:\n    80의 제한과 가격이 [30, 30, 20, 10]인 4개의 기념품.\n    각 쌍의 총 가격이 제한을 초과하지 않으므로 최소 그룹 수는 2입니다.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "ml": "def min_groups(w, n, prices):\n    \"\"\"\n    ഒരു ഗ്രൂപ്പിന്റെ മൊത്തം വിലയ്ക്കുള്ള നിയന്ത്രണത്തോടെ സവീനിയറുകൾ വിതരണം ചെയ്യാൻ ആവശ്യമായ കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം നിർണയിക്കുന്നു.\n    \n    സവീനിയറുകൾ ഓരോ ഗ്രൂപ്പിന്റെയും മൊത്തം വില `w` എന്ന പരിധി കവിയാത്ത വിധത്തിൽ ജോഡികളായി ഗ്രൂപ്പുചെയ്യുന്നു. \n    ഈ നിയന്ത്രണത്തിന് കീഴിൽ സൃഷ്ടിക്കുന്ന ഗ്രൂപ്പുകളുടെ എണ്ണം കുറയ്ക്കുക എന്നതാണ് ഫങ്ഷന്റെ ലക്ഷ്യം.\n    \n    Args:\n    w (int): ഏതെങ്കിലും സവീനിയർ ഗ്രൂപ്പിന്റെ വിലയുടെ പരമാവധി അനുവദനീയമായ മൊത്തം.\n    n (int): മൊത്തം സവീനിയറുകളുടെ എണ്ണം.\n    prices (list): ഓരോ സവീനിയറിന്റെയും വില പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n    \n    Returns:\n    int: എല്ലാ സവീനിയറുകളും വിതരണം ചെയ്യാൻ ആവശ്യമായ കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം.\n\n    ഉദാഹരണങ്ങൾ:\n    \n    കേസ് 1:\n    100 എന്ന പരിധിയും 9 സവീനിയറുകളും വിലകൾ [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം 6 ആണ്.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    കേസ് 2:\n    200 എന്ന പരിധിയും 5 സവീനിയറുകളും വിലകൾ [80, 120, 60, 40, 100].\n    കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം 3 ആണ്.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    കേസ് 3:\n    80 എന്ന പരിധിയും 4 സവീനിയറുകളും വിലകൾ [30, 30, 20, 10].\n    ഓരോ ജോഡിയുടെ മൊത്തം വിലയും പരിധി കവിയാത്തതിനാൽ, കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം 2 ആണ്.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "fa": "def min_groups(w, n, prices):\n    \"\"\"\n    تعیین حداقل تعداد گروه‌های مورد نیاز برای توزیع سوغاتی‌ها با محدودیت در قیمت کل گروه.\n    \n    سوغاتی‌ها به صورت جفت گروه‌بندی می‌شوند به طوری که قیمت کل هر گروه از حد `w` تجاوز نکند.\n    این تابع هدف دارد که تعداد گروه‌های ایجاد شده تحت این محدودیت را به حداقل برساند.\n    \n    آرگومان‌ها:\n    w (int): حداکثر مجموع قیمت‌های مجاز برای هر گروه از سوغاتی‌ها.\n    n (int): تعداد کل سوغاتی‌ها.\n    prices (list): لیستی از اعداد صحیح که قیمت هر سوغاتی را نشان می‌دهد.\n    \n    بازمی‌گرداند:\n    int: حداقل تعداد گروه‌های مورد نیاز برای توزیع تمام سوغاتی‌ها.\n\n    مثال‌ها:\n    \n    مورد 1:\n    محدودیت 100 و 9 سوغاتی با قیمت‌های [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    حداقل تعداد گروه‌ها 6 است.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    مورد 2:\n    محدودیت 200 و 5 سوغاتی با قیمت‌های [80, 120, 60, 40, 100].\n    حداقل تعداد گروه‌ها 3 است.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    مورد 3:\n    محدودیت 80 و 4 سوغاتی با قیمت‌های [30, 30, 20, 10].\n    از آنجا که قیمت کل هر جفت از حد تجاوز نمی‌کند، حداقل تعداد گروه‌ها 2 است.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\""}, "canonical_solution": "    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups", "instruction": {"en": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ։", "bn": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।", "bg": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.", "hi": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.", "arb": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nقم بتقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\n以下のPythonコードの簡潔な自然言語による説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 최대 500자 이내로 한국어로 제공하세요.", "ml": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nപൈതൺ കോഡിന്റെ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങളിൽ കവിയാതെ നൽകുക.", "fa": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_min_groups():\n    # Test case 1\n    w1 = 100\n    n1 = 9\n    prices1 = [90, 20, 20, 30, 50, 60, 70, 80, 90]\n    expected_output1 = 6\n    assert min_groups(w1, n1, prices1) == expected_output1, \"Test case 1 failed\"\n\n    # Test case 2\n    w2 = 200\n    n2 = 5\n    prices2 = [80, 120, 60, 40, 100]\n    expected_output2 = 3\n    assert min_groups(w2, n2, prices2) == expected_output2, \"Test case 2 failed\"\n\n    # Test case 3\n    w3 = 80\n    n3 = 4\n    prices3 = [30, 30, 20, 10]\n    expected_output3 = 2\n    assert min_groups(w3, n3, prices3) == expected_output3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_min_groups()", "entry_point": "min_groups", "signature": "def min_groups(w, n, prices):", "docstring": {"en": "Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n\nThe souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`.\nThe function aims to minimize the number of groups created under this constraint.\n\nArgs:\nw (int): The maximum allowed sum of prices for any group of souvenirs.\nn (int): The total number of souvenirs.\nprices (list): A list of integers representing the price of each souvenir.\n\nReturns:\nint: The minimum number of groups required to distribute all souvenirs.\n\nExamples:\n\nCase 1:\nA limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\nThe minimum number of groups is 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nCase 2:\nA limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\nThe minimum number of groups is 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nCase 3:\nA limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\nSince each pair's total price does not exceed the limit, the minimum number of groups is 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "sq": "Përcakton numrin minimal të grupeve të nevojshme për të shpërndarë suveniret me një kufizim mbi çmimin total të grupit.\n\nSuveniret janë grupuar në çifte në mënyrë që çmimi total i secilit grup të mos e kalojë kufirin `w`. Funksioni synon të minimizojë numrin e grupeve të krijuara nën këtë kufizim.\n\nArgumentet:\nw (int): Shuma maksimale e lejuar e çmimeve për çdo grup suveniresh.\nn (int): Numri total i suvenireve.\nprices (list): Një listë e numrave të plotë që përfaqësojnë çmimin e secilit suvenir.\n\nKthen:\nint: Numri minimal i grupeve të nevojshme për të shpërndarë të gjitha suveniret.\n\nShembuj:\n\nRasti 1:\nNjë kufi prej 100 dhe 9 suvenire me çmime [90, 20, 20, 30, 50, 60, 70, 80, 90].\nNumri minimal i grupeve është 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nRasti 2:\nNjë kufi prej 200 dhe 5 suvenire me çmime [80, 120, 60, 40, 100].\nNumri minimal i grupeve është 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nRasti 3:\nNjë kufi prej 80 dhe 4 suvenire me çmime [30, 30, 20, 10].\nMeqenëse çmimi total i çdo çifti nuk e kalon kufirin, numri minimal i grupeve është 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "hy": "Սահմանում է անհրաժեշտ խմբերի նվազագույն քանակը, որպեսզի բաշխվեն հուշանվերները՝ խմբի ընդհանուր գնի սահմանափակմամբ։\n\nՀուշանվերները խմբավորվում են զույգերով այնպես, որ յուրաքանչյուր խմբի ընդհանուր գինը չգերազանցի սահմանը `w`:\nՖունկցիան նպատակ ունի նվազագույնացնել ստեղծված խմբերի քանակը այս սահմանափակման ներքո։\n\nԱրգումենտներ:\nw (int): Հուշանվերների ցանկացած խմբի համար թույլատրելի գների գումարի առավելագույն սահմանը։\nn (int): Հուշանվերների ընդհանուր քանակը։\nprices (list): Ցուցակ, որը ներկայացնում է յուրաքանչյուր հուշանվերի գինը։\n\nՎերադարձնում է:\nint: Անհրաժեշտ խմբերի նվազագույն քանակը՝ բոլոր հուշանվերները բաշխելու համար։\n\nՕրինակներ:\n\nԴեպք 1:\n100 սահման և 9 հուշանվերներ՝ գներով [90, 20, 20, 30, 50, 60, 70, 80, 90]:\nՆվազագույն խմբերի քանակը 6 է։\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nԴեպք 2:\n200 սահման և 5 հուշանվերներ՝ գներով [80, 120, 60, 40, 100]:\nՆվազագույն խմբերի քանակը 3 է։\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nԴեպք 3:\n80 սահման և 4 հուշանվերներ՝ գներով [30, 30, 20, 10]:\nՔանի որ յուրաքանչյուր զույգի ընդհանուր գինը չի գերազանցում սահմանը, նվազագույն խմբերի քանակը 2 է։\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "bn": "স্মারক বিতরণের জন্য প্রয়োজনীয় ন্যূনতম সংখ্যক গ্রুপ নির্ধারণ করে যেখানে গ্রুপের মোট মূল্যের উপর একটি সীমাবদ্ধতা রয়েছে।\n\nস্মারকগুলোকে জোড়ায় জোড়ায় গ্রুপ করা হয় যাতে প্রতিটি গ্রুপের মোট মূল্য সীমা `w` অতিক্রম না করে। এই ফাংশনটি এই সীমাবদ্ধতার অধীনে তৈরি করা গ্রুপের সংখ্যা কমানোর লক্ষ্য রাখে।\n\nআর্গস:\nw (int): যে কোনো স্মারক গ্রুপের জন্য অনুমোদিত মূল্যের সর্বাধিক যোগফল।\nn (int): স্মারকের মোট সংখ্যা।\nprices (list): প্রতিটি স্মারকের মূল্য উপস্থাপনকারী পূর্ণসংখ্যার তালিকা।\n\nরিটার্নস:\nint: সমস্ত স্মারক বিতরণের জন্য প্রয়োজনীয় ন্যূনতম গ্রুপের সংখ্যা।\n\nউদাহরণসমূহ:\n\nকেস ১:\n১০০ এর সীমা এবং ৯টি স্মারক যার মূল্য [90, 20, 20, 30, 50, 60, 70, 80, 90]।\nন্যূনতম গ্রুপের সংখ্যা ৬।\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nকেস ২:\n২০০ এর সীমা এবং ৫টি স্মারক যার মূল্য [80, 120, 60, 40, 100]।\nন্যূনতম গ্রুপের সংখ্যা ৩।\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nকেস ৩:\n৮০ এর সীমা এবং ৪টি স্মারক যার মূল্য [30, 30, 20, 10]।\nযেহেতু প্রতিটি জোড়ার মোট মূল্য সীমা অতিক্রম করে না, ন্যূনতম গ্রুপের সংখ্যা ২।\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "bg": "Определя минималния брой групи, необходими за разпределение на сувенири с ограничение върху общата цена на групата.\n\nСувенирите са групирани по двойки така, че общата цена на всяка група да не надвишава лимита `w`. Функцията цели да минимизира броя на създадените групи при това ограничение.\n\nArgs:\nw (int): Максимално допустимата сума на цените за всяка група сувенири.\nn (int): Общият брой на сувенирите.\nprices (list): Списък от цели числа, представляващи цената на всеки сувенир.\n\nReturns:\nint: Минималният брой групи, необходими за разпределение на всички сувенири.\n\nExamples:\n\nСлучай 1:\nЛимит от 100 и 9 сувенира с цени [90, 20, 20, 30, 50, 60, 70, 80, 90].\nМинималният брой групи е 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nСлучай 2:\nЛимит от 200 и 5 сувенира с цени [80, 120, 60, 40, 100].\nМинималният брой групи е 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nСлучай 3:\nЛимит от 80 и 4 сувенира с цени [30, 30, 20, 10].\nТъй като общата цена на всяка двойка не надвишава лимита, минималният брой групи е 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "zh": "确定分配纪念品所需的最小组数，并对组的总价格进行限制。\n\n纪念品按对分组，使得每组的总价格不超过限制 `w`。\n该函数旨在在此约束下最小化创建的组数。\n\n参数：\nw (int): 任何纪念品组允许的最大价格总和。\nn (int): 纪念品的总数量。\nprices (list): 一个整数列表，表示每个纪念品的价格。\n\n返回：\nint: 分配所有纪念品所需的最小组数。\n\n示例：\n\n案例 1：\n限制为 100 和 9 个纪念品，价格为 [90, 20, 20, 30, 50, 60, 70, 80, 90]。\n最小组数为 6。\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\n案例 2：\n限制为 200 和 5 个纪念品，价格为 [80, 120, 60, 40, 100]。\n最小组数为 3。\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\n案例 3：\n限制为 80 和 4 个纪念品，价格为 [30, 30, 20, 10]。\n由于每对的总价格不超过限制，最小组数为 2。\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "fr": "Détermine le nombre minimum de groupes nécessaires pour distribuer des souvenirs avec une contrainte sur le prix total du groupe.\n\nLes souvenirs sont regroupés par paires de telle sorte que le prix total de chaque groupe ne dépasse pas la limite `w`. La fonction vise à minimiser le nombre de groupes créés sous cette contrainte.\n\nArgs:\nw (int): La somme maximale autorisée des prix pour tout groupe de souvenirs.\nn (int): Le nombre total de souvenirs.\nprices (list): Une liste d'entiers représentant le prix de chaque souvenir.\n\nReturns:\nint: Le nombre minimum de groupes requis pour distribuer tous les souvenirs.\n\nExamples:\n\nCas 1:\nUne limite de 100 et 9 souvenirs avec des prix [90, 20, 20, 30, 50, 60, 70, 80, 90].\nLe nombre minimum de groupes est 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nCas 2:\nUne limite de 200 et 5 souvenirs avec des prix [80, 120, 60, 40, 100].\nLe nombre minimum de groupes est 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nCas 3:\nUne limite de 80 et 4 souvenirs avec des prix [30, 30, 20, 10].\nPuisque le prix total de chaque paire ne dépasse pas la limite, le nombre minimum de groupes est 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "de": "Bestimmt die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs mit einer Einschränkung des Gesamtpreises der Gruppe zu verteilen.\n\nDie Souvenirs werden paarweise gruppiert, so dass der Gesamtpreis jeder Gruppe das Limit `w` nicht überschreitet. Die Funktion zielt darauf ab, die Anzahl der unter dieser Einschränkung erstellten Gruppen zu minimieren.\n\nArgs:\nw (int): Die maximal zulässige Summe der Preise für jede Gruppe von Souvenirs.\nn (int): Die Gesamtanzahl der Souvenirs.\nprices (list): Eine Liste von ganzen Zahlen, die den Preis jedes Souvenirs darstellen.\n\nReturns:\nint: Die minimale Anzahl von Gruppen, die erforderlich sind, um alle Souvenirs zu verteilen.\n\nExamples:\n\nFall 1:\nEin Limit von 100 und 9 Souvenirs mit Preisen [90, 20, 20, 30, 50, 60, 70, 80, 90].\nDie minimale Anzahl von Gruppen ist 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nFall 2:\nEin Limit von 200 und 5 Souvenirs mit Preisen [80, 120, 60, 40, 100].\nDie minimale Anzahl von Gruppen ist 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nFall 3:\nEin Limit von 80 und 4 Souvenirs mit Preisen [30, 30, 20, 10].\nDa der Gesamtpreis jedes Paares das Limit nicht überschreitet, ist die minimale Anzahl von Gruppen 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "ha": "Yana tantance mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kayan kyauta tare da ƙuntatawa akan jimillar farashin ƙungiyar.\n\nAna haɗa kayan kyaututtuka a cikin ma'aurata ta yadda jimillar farashin kowace ƙungiya ba ta wuce iyaka `w`.\nAikin aikin shine rage adadin ƙungiyoyin da aka ƙirƙira ƙarƙashin wannan ƙuntatawa.\n\nArgs:\nw (int): Mafi girman adadin farashin da aka yarda don kowace ƙungiyar kayan kyauta.\nn (int): Jimillar adadin kayan kyauta.\nprices (list): Jerin lambobin da ke wakiltar farashin kowanne kayan kyauta.\n\nReturns:\nint: Mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba duk kayan kyauta.\n\nMisalai:\n\nHali na 1:\nIyaka na 100 da kayan kyauta 9 tare da farashi [90, 20, 20, 30, 50, 60, 70, 80, 90].\nMafi ƙarancin adadin ƙungiyoyi shine 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nHali na 2:\nIyaka na 200 da kayan kyauta 5 tare da farashi [80, 120, 60, 40, 100].\nMafi ƙarancin adadin ƙungiyoyi shine 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nHali na 3:\nIyaka na 80 da kayan kyauta 4 tare da farashi [30, 30, 20, 10].\nTunda jimillar farashin kowanne ma'aurata ba ta wuce iyaka ba, mafi ƙarancin adadin ƙungiyoyi shine 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "hi": "स्मृति चिह्नों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करता है, जिसमें समूह की कुल कीमत पर एक बाधा होती है।\n\nस्मृति चिह्नों को जोड़ों में इस प्रकार समूहित किया जाता है कि प्रत्येक समूह की कुल कीमत सीमा `w` से अधिक न हो।\nयह फ़ंक्शन इस बाधा के तहत बनाए गए समूहों की संख्या को न्यूनतम करने का प्रयास करता है।\n\nआर्ग्स:\nw (int): किसी भी स्मृति चिन्ह समूह के लिए अनुमत कीमतों का अधिकतम योग।\nn (int): स्मृति चिह्नों की कुल संख्या।\nprices (list): प्रत्येक स्मृति चिन्ह की कीमत का प्रतिनिधित्व करने वाले पूर्णांकों की सूची।\n\nरिटर्न्स:\nint: सभी स्मृति चिह्नों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या।\n\nउदाहरण:\n\nमामला 1:\n100 की सीमा और 9 स्मृति चिह्न जिनकी कीमतें [90, 20, 20, 30, 50, 60, 70, 80, 90] हैं।\nन्यूनतम समूहों की संख्या 6 है।\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nमामला 2:\n200 की सीमा और 5 स्मृति चिह्न जिनकी कीमतें [80, 120, 60, 40, 100] हैं।\nन्यूनतम समूहों की संख्या 3 है।\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nमामला 3:\n80 की सीमा और 4 स्मृति चिह्न जिनकी कीमतें [30, 30, 20, 10] हैं।\nचूंकि प्रत्येक जोड़े की कुल कीमत सीमा से अधिक नहीं है, न्यूनतम समूहों की संख्या 2 है।\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "hu": "Meghatározza a szükséges csoportok minimális számát az ajándéktárgyak elosztásához, figyelembe véve a csoportok összárának korlátozását.\n\nAz ajándéktárgyakat párokba csoportosítják úgy, hogy minden csoport összára ne haladja meg a `w` korlátot. A függvény célja a létrehozott csoportok számának minimalizálása ezen korlátozás mellett.\n\nArgs:\nw (int): Az ajándéktárgyak bármely csoportjának megengedett maximális árösszege.\nn (int): Az ajándéktárgyak teljes száma.\nprices (list): Egész számokat tartalmazó lista, amely az egyes ajándéktárgyak árát jelöli.\n\nReturns:\nint: A szükséges minimális csoportok száma az összes ajándéktárgy elosztásához.\n\nPéldák:\n\n1. eset:\n100-as korlát és 9 ajándéktárgy, amelyek árai [90, 20, 20, 30, 50, 60, 70, 80, 90].\nA minimális csoportok száma 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\n2. eset:\n200-as korlát és 5 ajándéktárgy, amelyek árai [80, 120, 60, 40, 100].\nA minimális csoportok száma 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\n3. eset:\n80-as korlát és 4 ajándéktárgy, amelyek árai [30, 30, 20, 10].\nMivel minden pár összára nem haladja meg a korlátot, a minimális csoportok száma 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "es": "Determina el número mínimo de grupos necesarios para distribuir souvenirs con una restricción en el precio total del grupo.\n\nLos souvenirs se agrupan en pares de manera que el precio total de cada grupo no exceda el límite `w`. La función tiene como objetivo minimizar el número de grupos creados bajo esta restricción.\n\nArgumentos:\nw (int): La suma máxima permitida de precios para cualquier grupo de souvenirs.\nn (int): El número total de souvenirs.\nprices (list): Una lista de enteros que representa el precio de cada souvenir.\n\nDevuelve:\nint: El número mínimo de grupos necesarios para distribuir todos los souvenirs.\n\nEjemplos:\n\nCaso 1:\nUn límite de 100 y 9 souvenirs con precios [90, 20, 20, 30, 50, 60, 70, 80, 90]. El número mínimo de grupos es 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nCaso 2:\nUn límite de 200 y 5 souvenirs con precios [80, 120, 60, 40, 100]. El número mínimo de grupos es 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nCaso 3:\nUn límite de 80 y 4 souvenirs con precios [30, 30, 20, 10]. Dado que el precio total de cada par no excede el límite, el número mínimo de grupos es 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "arb": "يحدد الحد الأدنى لعدد المجموعات اللازمة لتوزيع التذكارات مع وجود قيد على السعر الإجمالي للمجموعة.\n\nيتم تجميع التذكارات في أزواج بحيث لا يتجاوز السعر الإجمالي لكل مجموعة الحد `w`.\nتهدف الدالة إلى تقليل عدد المجموعات التي تم إنشاؤها تحت هذا القيد.\n\nيعيدالحجج:\nw (int): الحد الأقصى المسموح به لمجموع أسعار أي مجموعة من التذكارات.\nn (int): العدد الإجمالي للتذكارات.\nprices (list): قائمة من الأعداد الصحيحة تمثل سعر كل تذكار.\n\nيعيد:\nint: الحد الأدنى لعدد المجموعات المطلوبة لتوزيع جميع التذكارات.\n\nامثله:\n\nالحالة 1:\nحد 100 و 9 تذكارات بأسعار [90, 20, 20, 30, 50, 60, 70, 80, 90].\nالحد الأدنى لعدد المجموعات هو 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nالحالة 2:\nحد 200 و 5 تذكارات بأسعار [80, 120, 60, 40, 100].\nالحد الأدنى لعدد المجموعات هو 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nالحالة 3:\nحد 80 و 4 تذكارات بأسعار [30, 30, 20, 10].\nبما أن السعر الإجمالي لكل زوج لا يتجاوز الحد، فإن الحد الأدنى لعدد المجموعات هو 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "sw": "Inabainisha idadi ndogo ya vikundi vinavyohitajika kusambaza zawadi zikiwa na kizuizi kwenye jumla ya bei ya kikundi.\n\nZawadi zimepangwa katika jozi ili jumla ya bei ya kila kikundi isizidi kikomo `w`. \nKazi inalenga kupunguza idadi ya vikundi vilivyoundwa chini ya kizuizi hiki.\n\nHoja:\nw (int): Jumla ya juu inayoruhusiwa ya bei kwa kikundi chochote cha zawadi.\nn (int): Jumla ya idadi ya zawadi.\nprices (list): Orodha ya namba nzima inayoonyesha bei ya kila zawadi.\n\nInarejesha:\nint: Idadi ndogo ya vikundi vinavyohitajika kusambaza zawadi zote.\n\nMifano:\n\nKesi 1:\nKikomo cha 100 na zawadi 9 zenye bei [90, 20, 20, 30, 50, 60, 70, 80, 90].\nIdadi ndogo ya vikundi ni 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nKesi 2:\nKikomo cha 200 na zawadi 5 zenye bei [80, 120, 60, 40, 100].\nIdadi ndogo ya vikundi ni 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nKesi 3:\nKikomo cha 80 na zawadi 4 zenye bei [30, 30, 20, 10].\nKwa kuwa jumla ya bei ya kila jozi haizidi kikomo, idadi ndogo ya vikundi ni 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "tr": "Hatıra eşyalarını, grubun toplam fiyatı üzerinde bir kısıtlama ile dağıtmak için gereken minimum grup sayısını belirler.\n\nHatıra eşyaları, her grubun toplam fiyatı `w` limitini aşmayacak şekilde çiftler halinde gruplanır. Fonksiyon, bu kısıtlama altında oluşturulan grup sayısını en aza indirmeyi amaçlar.\n\nArgümanlar:\nw (int): Herhangi bir hatıra grubu için izin verilen maksimum fiyat toplamı.\nn (int): Toplam hatıra sayısı.\nprices (list): Her bir hatıranın fiyatını temsil eden tamsayıların listesi.\n\nDöndürür:\nint: Tüm hatıraları dağıtmak için gereken minimum grup sayısı.\n\nÖrnekler:\n\nDurum 1:\n100 limiti ve fiyatları [90, 20, 20, 30, 50, 60, 70, 80, 90] olan 9 hatıra.\nMinimum grup sayısı 6'dır.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nDurum 2:\n200 limiti ve fiyatları [80, 120, 60, 40, 100] olan 5 hatıra.\nMinimum grup sayısı 3'tür.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nDurum 3:\n80 limiti ve fiyatları [30, 30, 20, 10] olan 4 hatıra.\nHer çiftin toplam fiyatı limiti aşmadığından, minimum grup sayısı 2'dir.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "vi": "Xác định số lượng nhóm tối thiểu cần thiết để phân phối quà lưu niệm với một giới hạn về tổng giá của nhóm.\n\nCác quà lưu niệm được nhóm thành cặp sao cho tổng giá của mỗi nhóm không vượt quá giới hạn `w`. Hàm này nhằm mục đích giảm thiểu số lượng nhóm được tạo ra dưới giới hạn này.\n\nTham số:\nw (int): Tổng giá tối đa được phép cho bất kỳ nhóm quà lưu niệm nào.\nn (int): Tổng số quà lưu niệm.\nprices (list): Một danh sách các số nguyên đại diện cho giá của mỗi quà lưu niệm.\n\nTrả về:\nint: Số lượng nhóm tối thiểu cần thiết để phân phối tất cả quà lưu niệm.\n\nVí dụ:\n\nTrường hợp 1:\nGiới hạn là 100 và 9 quà lưu niệm với giá [90, 20, 20, 30, 50, 60, 70, 80, 90].\nSố lượng nhóm tối thiểu là 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nTrường hợp 2:\nGiới hạn là 200 và 5 quà lưu niệm với giá [80, 120, 60, 40, 100].\nSố lượng nhóm tối thiểu là 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nTrường hợp 3:\nGiới hạn là 80 và 4 quà lưu niệm với giá [30, 30, 20, 10].\nVì tổng giá của mỗi cặp không vượt quá giới hạn, số lượng nhóm tối thiểu là 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "id": "Menentukan jumlah minimum kelompok yang dibutuhkan untuk mendistribusikan suvenir dengan batasan pada total harga kelompok.\n\nSuvenir dikelompokkan dalam pasangan sedemikian rupa sehingga total harga setiap kelompok tidak melebihi batas `w`. Fungsi ini bertujuan untuk meminimalkan jumlah kelompok yang dibuat di bawah batasan ini.\n\nArgs:\nw (int): Jumlah maksimum yang diizinkan dari harga untuk setiap kelompok suvenir.\nn (int): Jumlah total suvenir.\nprices (list): Daftar bilangan bulat yang mewakili harga masing-masing suvenir.\n\nReturns:\nint: Jumlah minimum kelompok yang diperlukan untuk mendistribusikan semua suvenir.\n\nExamples:\n\nKasus 1:\nBatas 100 dan 9 suvenir dengan harga [90, 20, 20, 30, 50, 60, 70, 80, 90].\nJumlah minimum kelompok adalah 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nKasus 2:\nBatas 200 dan 5 suvenir dengan harga [80, 120, 60, 40, 100].\nJumlah minimum kelompok adalah 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nKasus 3:\nBatas 80 dan 4 suvenir dengan harga [30, 30, 20, 10].\nKarena total harga setiap pasangan tidak melebihi batas, jumlah minimum kelompok adalah 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "ja": "お土産を配布するために必要な最小のグループ数を、グループの合計価格に制約を設けて決定します。\n\nお土産はペアでグループ化され、各グループの合計価格が制限 `w` を超えないようにします。\nこの制約の下で作成されるグループの数を最小化することを目的としています。\n\n引数:\nw (int): お土産のグループに許可される価格の合計の最大値。\nn (int): お土産の総数。\nprices (list): 各お土産の価格を表す整数のリスト。\n\n戻り値:\nint: すべてのお土産を配布するために必要な最小のグループ数。\n\n例:\n\nケース 1:\n制限が100で、価格が [90, 20, 20, 30, 50, 60, 70, 80, 90] の9つのお土産。\n最小のグループ数は6です。\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nケース 2:\n制限が200で、価格が [80, 120, 60, 40, 100] の5つのお土産。\n最小のグループ数は3です。\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nケース 3:\n制限が80で、価格が [30, 30, 20, 10] の4つのお土産。\n各ペアの合計価格が制限を超えないため、最小のグループ数は2です。\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "ko": "기념품을 배포하는 데 필요한 최소 그룹 수를 결정합니다. 그룹의 총 가격에는 제한이 있습니다.\n\n기념품은 각 그룹의 총 가격이 `w`를 초과하지 않도록 쌍으로 그룹화됩니다. 이 함수는 이 제약 조건 하에서 생성되는 그룹 수를 최소화하는 것을 목표로 합니다.\n\nArgs:\nw (int): 기념품 그룹의 가격 합계에 허용되는 최대값.\nn (int): 기념품의 총 개수.\nprices (list): 각 기념품의 가격을 나타내는 정수 리스트.\n\nReturns:\nint: 모든 기념품을 배포하는 데 필요한 최소 그룹 수.\n\nExamples:\n\n사례 1:\n제한이 100이고 가격이 [90, 20, 20, 30, 50, 60, 70, 80, 90]인 9개의 기념품.\n최소 그룹 수는 6입니다.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\n사례 2:\n제한이 200이고 가격이 [80, 120, 60, 40, 100]인 5개의 기념품.\n최소 그룹 수는 3입니다.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\n사례 3:\n제한이 80이고 가격이 [30, 30, 20, 10]인 4개의 기념품.\n각 쌍의 총 가격이 제한을 초과하지 않으므로 최소 그룹 수는 2입니다.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "ml": "സ്മരണികകൾ ഒരു ഗ്രൂപ്പിന്റെ മൊത്തം വിലയ്ക്കുള്ള നിയന്ത്രണത്തോടെ വിതരണം ചെയ്യാൻ ആവശ്യമായ കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം നിർണ്ണയിക്കുന്നു.\n\nസ്മരണികകൾ ഓരോ ഗ്രൂപ്പിന്റെയും മൊത്തം വില `w` എന്ന പരിധി കവിയാത്ത വിധത്തിൽ ജോഡികളായി ഗ്രൂപ്പുചെയ്യുന്നു. ഈ നിയന്ത്രണത്തിന്റെ കീഴിൽ സൃഷ്ടിക്കുന്ന ഗ്രൂപ്പുകളുടെ എണ്ണം കുറഞ്ഞതാക്കുക എന്നതാണ് ഫങ്ഷന്റെ ലക്ഷ്യം.\n\nആർഗുകൾ:\nw (int): ഏതെങ്കിലും സ്മരണികാ ഗ്രൂപ്പിന്റെ വിലയുടെ പരമാവധി അനുവദനീയമായ മൊത്തം.\nn (int): സ്മരണികകളുടെ മൊത്തം എണ്ണം.\nprices (list): ഓരോ സ്മരണികയുടെ വില പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n\nമടക്കം:\nint: എല്ലാ സ്മരണികകളും വിതരണം ചെയ്യാൻ ആവശ്യമായ കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം.\n\nഉദാഹരണങ്ങൾ:\n\nകേസ് 1:\n100 എന്ന പരിധിയും 9 സ്മരണികകളും, വിലകൾ [90, 20, 20, 30, 50, 60, 70, 80, 90].\nകുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം 6 ആണ്.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nകേസ് 2:\n200 എന്ന പരിധിയും 5 സ്മരണികകളും, വിലകൾ [80, 120, 60, 40, 100].\nകുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം 3 ആണ്.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nകേസ് 3:\n80 എന്ന പരിധിയും 4 സ്മരണികകളും, വിലകൾ [30, 30, 20, 10].\nഓരോ ജോഡിയുടെ മൊത്തം വിലയും പരിധി കവിയാത്തതിനാൽ, കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം 2 ആണ്.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "fa": "تعیین حداقل تعداد گروه‌های مورد نیاز برای توزیع سوغاتی‌ها با محدودیتی بر روی قیمت کل گروه.\n\nسوغاتی‌ها به صورت جفت‌هایی گروه‌بندی می‌شوند به طوری که قیمت کل هر گروه از حد `w` تجاوز نکند.\nهدف تابع، به حداقل رساندن تعداد گروه‌های ایجاد شده تحت این محدودیت است.\n\nآرگومان‌ها:\nw (int): حداکثر مجموع قیمت‌های مجاز برای هر گروه از سوغاتی‌ها.\nn (int): تعداد کل سوغاتی‌ها.\nprices (list): لیستی از اعداد صحیح که قیمت هر سوغاتی را نشان می‌دهد.\n\nبازگشت:\nint: حداقل تعداد گروه‌های مورد نیاز برای توزیع همه سوغاتی‌ها.\n\nمثال‌ها:\n\nمورد 1:\nحد 100 و 9 سوغاتی با قیمت‌های [90, 20, 20, 30, 50, 60, 70, 80, 90].\nحداقل تعداد گروه‌ها 6 است.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nمورد 2:\nحد 200 و 5 سوغاتی با قیمت‌های [80, 120, 60, 40, 100].\nحداقل تعداد گروه‌ها 3 است.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nمورد 3:\nحد 80 و 4 سوغاتی با قیمت‌های [30, 30, 20, 10].\nاز آنجا که قیمت کل هر جفت از حد تجاوز نمی‌کند، حداقل تعداد گروه‌ها 2 است.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2"}}
{"task_id": "Python/49", "prompt": {"en": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n    - For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n    - For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair, \n      4 more for the second, and then 8 additional moves for the third pair.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "sq": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Llogarit numrin minimal të lëvizjeve të nevojshme për të zgjidhur problemin e Kullave të Hanoi me dy disqe për n palë disqesh.\n    \n    Kjo funksion implementon një algoritëm iterativ për të përcaktuar numrin minimal të lëvizjeve të nevojshme për të transferuar\n    2n disqe nga shtylla A në shtyllën C në një konfigurim të Kullave të Hanoi me dy disqe, duke ndjekur rregullat që vetëm një disk \n    mund të zhvendoset në një kohë dhe asnjë disk nuk mund të vendoset mbi një disk më të vogël. Funksioni përdor një lidhje të njohur rekursive \n    dhe llogarit në mënyrë iterative numrin total të lëvizjeve për n palë disqesh.\n    \n    Argumentet:\n    n (int): Numri i palëve të disqeve (secila prej dy disqeve identike) në shtyllën A.\n\n    Kthen:\n    int: Numri minimal i lëvizjeve të nevojshme për të transferuar të gjithë disqet nga shtylla A në shtyllën C.\n\n    Rastet:\n    - Për n=1, funksioni duhet të kthejë 2, pasi ka dy disqe identike që mund të zhvendosen në dy lëvizje.\n    - Për n=2, funksioni duhet të kthejë 6, pasi duhen 2 lëvizje për palën e parë dhe pastaj 4 lëvizje të tjera për palën e dytë.\n    - Për n=3, funksioni duhet të kthejë 14, që është rezultati i procesit iterativ: 2 lëvizje për palën e parë, \n      4 të tjera për të dytën, dhe pastaj 8 lëvizje shtesë për palën e tretë.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "hy": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Հաշվարկել նվազագույն քայլերի քանակը, որը պահանջվում է կրկնակի սկավառակների Հանոյյան աշտարակների խնդիրը լուծելու համար n զույգ սկավառակների համար:\n    \n    Այս ֆունկցիան իրականացնում է իտերատիվ ալգորիթմ՝ որոշելու համար նվազագույն քայլերի քանակը, որը անհրաժեշտ է 2n սկավառակները\n    A ձողից C ձող տեղափոխելու համար կրկնակի սկավառակների Հանոյյան աշտարակների պարագայում՝ հետևելով այն կանոններին, որ միայն մեկ սկավառակ\n    կարող է տեղափոխվել միաժամանակ և ոչ մի սկավառակ չի կարող տեղադրվել ավելի փոքր սկավառակի վրա: Ֆունկցիան օգտագործում է հայտնի ռեկուրսիվ հարաբերություն\n    և իտերատիվ կերպով հաշվարկում է քայլերի ընդհանուր քանակը n զույգ սկավառակների համար:\n    \n    Արգումենտներ:\n    n (int): A ձողի վրա գտնվող սկավառակների զույգերի քանակը (յուրաքանչյուր զույգ բաղկացած է երկու նույնական սկավառակներից):\n\n    Վերադարձնում է:\n    int: Նվազագույն քայլերի քանակը, որը պահանջվում է բոլոր սկավառակները A ձողից C ձող տեղափոխելու համար:\n\n    Դեպքեր:\n    - n=1-ի դեպքում ֆունկցիան պետք է վերադարձնի 2, քանի որ կան երկու նույնական սկավառակներ, որոնք կարող են տեղափոխվել երկու քայլով:\n    - n=2-ի դեպքում ֆունկցիան պետք է վերադարձնի 6, քանի որ 2 քայլ է պահանջվում առաջին զույգի համար, և ապա 4 քայլ՝ երկրորդ զույգի համար:\n    - n=3-ի դեպքում ֆունկցիան պետք է վերադարձնի 14, որը իտերատիվ գործընթացի արդյունքն է՝ 2 քայլ առաջին զույգի համար,\n      4 քայլ երկրորդ զույգի համար, և ապա 8 լրացուցիչ քայլեր՝ երրորդ զույգի համար:\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "bn": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    n জোড়া ডিস্কের জন্য ডাবল-ডিস্ক হ্যানয় টাওয়ার সমস্যার সমাধান করতে প্রয়োজনীয় ন্যূনতম চলাচলের সংখ্যা গণনা করুন।\n    \n    এই ফাংশনটি একটি পুনরাবৃত্ত অ্যালগরিদম প্রয়োগ করে যা ডাবল-ডিস্ক হ্যানয় টাওয়ার সেটআপে 2n ডিস্ককে A পোল থেকে C পোল পর্যন্ত স্থানান্তর করার জন্য প্রয়োজনীয় ন্যূনতম চলাচলের সংখ্যা নির্ধারণ করে, এই নিয়মগুলি অনুসরণ করে যে একবারে শুধুমাত্র একটি ডিস্ক সরানো যেতে পারে এবং কোন ডিস্ক ছোট ডিস্কের উপরে স্থাপন করা যাবে না। ফাংশনটি একটি পরিচিত পুনরাবৃত্ত সম্পর্ক ব্যবহার করে এবং n জোড়া ডিস্কের জন্য মোট চলাচলের সংখ্যা পুনরাবৃত্তভাবে গণনা করে।\n    \n    Args:\n    n (int): A পোলের উপর ডিস্ক জোড়ার সংখ্যা (প্রতিটি দুটি অভিন্ন ডিস্কের)।\n\n    Returns:\n    int: সমস্ত ডিস্ক A পোল থেকে C পোল পর্যন্ত স্থানান্তর করতে প্রয়োজনীয় ন্যূনতম চলাচলের সংখ্যা।\n\n    উদাহরণ:\n    - n=1 এর জন্য, ফাংশনটি 2 ফেরত দেবে, যেহেতু দুটি অভিন্ন ডিস্ক রয়েছে যা দুটি চলাচলে সরানো যেতে পারে।\n    - n=2 এর জন্য, ফাংশনটি 6 ফেরত দেবে, কারণ প্রথম জোড়ার জন্য 2 চলাচল এবং তারপর দ্বিতীয় জোড়ার জন্য আরও 4 চলাচল লাগে।\n    - n=3 এর জন্য, ফাংশনটি 14 ফেরত দেবে, যা পুনরাবৃত্ত প্রক্রিয়ার ফলাফল: প্রথম জোড়ার জন্য 2 চলাচল, দ্বিতীয়টির জন্য আরও 4, এবং তারপর তৃতীয় জোড়ার জন্য অতিরিক্ত 8 চলাচল।\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "bg": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Изчислява минималния брой ходове, необходими за решаване на проблема с двойните дискове на Ханойските кули за n двойки дискове.\n    \n    Тази функция реализира итеративен алгоритъм за определяне на минималния брой ходове, необходими за преместване\n    на 2n диска от полюса A към полюса C в настройка на Ханойските кули с двойни дискове, следвайки правилата, че само един диск \n    може да се премества наведнъж и не може да се поставя диск върху по-малък диск. Функцията използва известна рекурсивна връзка \n    и итеративно изчислява общия брой ходове за n двойки дискове.\n    \n    Args:\n    n (int): Броят на двойките дискове (всяка от два идентични диска) на полюса A.\n\n    Returns:\n    int: Минималният брой ходове, необходими за преместване на всички дискове от полюса A към полюса C.\n\n    Примери:\n    - За n=1, функцията трябва да върне 2, тъй като има два идентични диска, които могат да бъдат преместени в два хода.\n    - За n=2, функцията трябва да върне 6, тъй като са необходими 2 хода за първата двойка и след това още 4 хода за втората двойка.\n    - За n=3, функцията трябва да върне 14, което е резултат от итеративния процес: 2 хода за първата двойка, \n      още 4 за втората и след това още 8 хода за третата двойка.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "zh": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    计算解决双盘汉诺塔问题所需的最小移动次数，对于n对圆盘。\n    \n    此函数实现了一个迭代算法，以确定在双盘汉诺塔设置中，将2n个圆盘从A杆转移到C杆所需的最小移动次数，\n    遵循的规则是每次只能移动一个圆盘，且不能将圆盘放在比它小的圆盘上。该函数使用已知的递归关系，并迭代计算n对圆盘的总移动次数。\n    \n    参数：\n    n (int): A杆上的圆盘对数（每对由两个相同的圆盘组成）。\n\n    返回：\n    int: 将所有圆盘从A杆转移到C杆所需的最小移动次数。\n\n    情况：\n    - 对于n=1，函数应返回2，因为有两个相同的圆盘，可以在两次移动中完成。\n    - 对于n=2，函数应返回6，因为第一对需要2次移动，然后第二对需要再移动4次。\n    - 对于n=3，函数应返回14，这是迭代过程的结果：第一对需要2次移动，第二对再需要4次，然后第三对再需要8次移动。\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "fr": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculer le nombre minimum de mouvements nécessaires pour résoudre le problème des Tours de Hanoï à double disque pour n paires de disques.\n    \n    Cette fonction implémente un algorithme itératif pour déterminer le nombre minimum de mouvements nécessaires pour transférer\n    2n disques du poteau A au poteau C dans une configuration de Tours de Hanoï à double disque, en suivant les règles selon lesquelles un seul disque \n    peut être déplacé à la fois et aucun disque ne peut être placé sur un disque plus petit. La fonction utilise une relation récursive connue \n    et calcule de manière itérative le nombre total de mouvements pour n paires de disques.\n    \n    Args:\n    n (int): Le nombre de paires de disques (chacune de deux disques identiques) sur le poteau A.\n\n    Returns:\n    int: Le nombre minimum de mouvements nécessaires pour transférer tous les disques du poteau A au poteau C.\n\n    Cas:\n    - Pour n=1, la fonction doit retourner 2, car il y a deux disques identiques qui peuvent être déplacés en deux mouvements.\n    - Pour n=2, la fonction doit retourner 6, car il faut 2 mouvements pour la première paire puis 4 mouvements supplémentaires pour la deuxième paire.\n    - Pour n=3, la fonction doit retourner 14, ce qui est le résultat du processus itératif : 2 mouvements pour la première paire, \n      4 de plus pour la deuxième, puis 8 mouvements supplémentaires pour la troisième paire.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "de": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Berechne die minimale Anzahl von Zügen, die erforderlich sind, um das Doppelscheiben-Hanoi-Türme-Problem für n Scheibenpaare zu lösen.\n    \n    Diese Funktion implementiert einen iterativen Algorithmus, um die minimale Anzahl von Zügen zu bestimmen, die notwendig sind, \n    um 2n Scheiben vom A-Pfosten zum C-Pfosten in einem Doppelscheiben-Hanoi-Türme-Setup zu übertragen, wobei die Regeln befolgt werden, \n    dass nur eine Scheibe gleichzeitig bewegt werden kann und keine Scheibe auf eine kleinere Scheibe gelegt werden darf. \n    Die Funktion verwendet eine bekannte rekursive Beziehung und berechnet iterativ die Gesamtanzahl der Züge für n Scheibenpaare.\n    \n    Argumente:\n    n (int): Die Anzahl der Scheibenpaare (jeweils zwei identische Scheiben) auf dem A-Pfosten.\n\n    Rückgabewert:\n    int: Die minimale Anzahl von Zügen, die erforderlich sind, um alle Scheiben vom A-Pfosten zum C-Pfosten zu übertragen.\n\n    Fälle:\n    - Für n=1 sollte die Funktion 2 zurückgeben, da es zwei identische Scheiben gibt, die in zwei Zügen bewegt werden können.\n    - Für n=2 sollte die Funktion 6 zurückgeben, da es 2 Züge für das erste Paar und dann 4 weitere Züge für das zweite Paar benötigt.\n    - Für n=3 sollte die Funktion 14 zurückgeben, was das Ergebnis des iterativen Prozesses ist: 2 Züge für das erste Paar, \n      4 weitere für das zweite und dann 8 zusätzliche Züge für das dritte Paar.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "ha": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Lissafa mafi ƙarancin yawan motsi da ake buƙata don warware matsalar hasumiyar Hanoi mai faifan diski biyu don n nau'i biyu na faifai.\n    \n    Wannan aikin yana aiwatar da wani tsari mai maimaitawa don ƙayyade mafi ƙarancin yawan motsi da ake buƙata don canja wurin\n    2n faifai daga sandar A zuwa sandar C a cikin saitin hasumiyar Hanoi mai faifan diski biyu, bisa ga dokokin cewa ana iya motsa faifan guda ɗaya \n    a lokaci guda kuma babu wani faifan da za a iya sanya shi a saman faifan da ya fi shi girma. Aikin yana amfani da wata sananniyar dangantaka mai maimaitawa \n    kuma yana lissafa jimillar yawan motsi don n nau'i biyu na faifai.\n    \n    Args:\n    n (int): Yawan nau'i biyu na faifai (kowanne na faifai biyu masu kama) a kan sandar A.\n\n    Returns:\n    int: Mafi ƙarancin yawan motsi da ake buƙata don canja duk faifan daga sandar A zuwa sandar C.\n\n    Lokuta:\n    - Ga n=1, aikin ya kamata ya dawo da 2, tun da akwai faifai biyu masu kama da za a iya motsa su cikin motsi biyu.\n    - Ga n=2, aikin ya kamata ya dawo da 6, domin yana ɗaukar motsi 2 don nau'i na farko sannan kuma motsi 4 don nau'i na biyu.\n    - Ga n=3, aikin ya kamata ya dawo da 14, wanda shine sakamakon tsarin maimaitawa: motsi 2 don nau'i na farko, \n      4 ƙarin don na biyu, sannan kuma 8 ƙarin motsi don nau'i na uku.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "hi": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    दोहरे-डिस्क हनोई टावर्स समस्या के लिए n जोड़ों के डिस्क के लिए आवश्यक न्यूनतम चालों की गणना करें।\n    \n    यह फ़ंक्शन एक पुनरावृत्त एल्गोरिदम को लागू करता है ताकि यह निर्धारित किया जा सके कि दोहरे-डिस्क हनोई टावर्स सेटअप में \n    2n डिस्क को A पोल से C पोल तक स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या कितनी है, इस नियम का पालन करते हुए \n    कि केवल एक डिस्क को एक बार में स्थानांतरित किया जा सकता है और किसी भी डिस्क को एक छोटी डिस्क के ऊपर नहीं रखा जा सकता। \n    फ़ंक्शन एक ज्ञात पुनरावृत्त संबंध का उपयोग करता है और n जोड़ों के डिस्क के लिए कुल चालों की संख्या को पुनरावृत्त रूप से गणना करता है।\n    \n    Args:\n    n (int): A पोल पर डिस्क जोड़ों की संख्या (प्रत्येक दो समान डिस्क के).\n\n    Returns:\n    int: A पोल से C पोल तक सभी डिस्क को स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या।\n\n    मामले:\n    - n=1 के लिए, फ़ंक्शन को 2 लौटाना चाहिए, क्योंकि दो समान डिस्क हैं जिन्हें दो चालों में स्थानांतरित किया जा सकता है।\n    - n=2 के लिए, फ़ंक्शन को 6 लौटाना चाहिए, क्योंकि पहले जोड़े के लिए 2 चालें लगती हैं और फिर दूसरे जोड़े के लिए 4 और चालें लगती हैं।\n    - n=3 के लिए, फ़ंक्शन को 14 लौटाना चाहिए, जो पुनरावृत्त प्रक्रिया का परिणाम है: पहले जोड़े के लिए 2 चालें, \n      दूसरे के लिए 4 और फिर तीसरे जोड़े के लिए 8 अतिरिक्त चालें।\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "hu": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Számítsa ki a minimális lépések számát, amely szükséges a dupla korongos Hanoi-tornyok problémájának megoldásához n korongpár esetén.\n    \n    Ez a függvény egy iteratív algoritmust valósít meg annak meghatározására, hogy hány lépés szükséges 2n korong áthelyezéséhez\n    az A oszlopról a C oszlopra egy dupla korongos Hanoi-tornyok elrendezésben, követve azokat a szabályokat, hogy egyszerre csak egy korong\n    mozgatható, és egy korong sem helyezhető kisebb korong tetejére. A függvény egy ismert rekurzív összefüggést használ, és iteratívan \n    kiszámítja a teljes lépésszámot n korongpár esetén.\n    \n    Args:\n    n (int): A korongpárok száma (mindegyik két azonos korongból áll) az A oszlopon.\n\n    Returns:\n    int: A minimális lépések száma, amely szükséges az összes korong áthelyezéséhez az A oszlopról a C oszlopra.\n\n    Esetek:\n    - Ha n=1, a függvénynek 2-t kell visszaadnia, mivel két azonos korong van, amelyeket két lépésben lehet áthelyezni.\n    - Ha n=2, a függvénynek 6-ot kell visszaadnia, mivel 2 lépés szükséges az első párhoz, majd további 4 lépés a második párhoz.\n    - Ha n=3, a függvénynek 14-et kell visszaadnia, amely az iteratív folyamat eredménye: 2 lépés az első párhoz, \n      további 4 a másodikhoz, majd 8 további lépés a harmadik párhoz.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "es": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calcula el número mínimo de movimientos necesarios para resolver el problema de las Torres de Hanoi de doble disco para n pares de discos.\n    \n    Esta función implementa un algoritmo iterativo para determinar el número mínimo de movimientos necesarios para transferir\n    2n discos del poste A al poste C en una configuración de Torres de Hanoi de doble disco, siguiendo las reglas de que solo un disco \n    puede moverse a la vez y ningún disco puede colocarse sobre un disco más pequeño. La función utiliza una relación recursiva conocida \n    y calcula iterativamente el número total de movimientos para n pares de discos.\n    \n    Argumentos:\n    n (int): El número de pares de discos (cada uno de dos discos idénticos) en el poste A.\n\n    Devuelve:\n    int: El número mínimo de movimientos necesarios para transferir todos los discos del poste A al poste C.\n\n    Casos:\n    - Para n=1, la función debe devolver 2, ya que hay dos discos idénticos que pueden moverse en dos movimientos.\n    - Para n=2, la función debe devolver 6, ya que se necesitan 2 movimientos para el primer par y luego 4 movimientos más para el segundo par.\n    - Para n=3, la función debe devolver 14, que es el resultado del proceso iterativo: 2 movimientos para el primer par, \n      4 más para el segundo, y luego 8 movimientos adicionales para el tercer par.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "arb": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    حساب الحد الأدنى لعدد الحركات المطلوبة لحل مشكلة أبراج هانوي ذات الأقراص المزدوجة لعدد n من أزواج الأقراص.\n    \n    تقوم هذه الدالة بتطبيق خوارزمية تكرارية لتحديد الحد الأدنى لعدد الحركات اللازمة لنقل 2n قرصًا من العمود A إلى العمود C\n    في إعداد أبراج هانوي ذات الأقراص المزدوجة، مع اتباع القواعد التي تنص على أنه لا يمكن نقل سوى قرص واحد في كل مرة\n    ولا يجوز وضع قرص فوق قرص أصغر منه. تستخدم الدالة علاقة تكرارية معروفة وتحسب بشكل تكراري العدد الإجمالي للحركات\n    لعدد n من أزواج الأقراص.\n    \n    يعيدالحجج:\n    n (int): عدد أزواج الأقراص (كل زوج يتكون من قرصين متطابقين) على العمود A.\n\n    يعيد:\n    int: الحد الأدنى لعدد الحركات المطلوبة لنقل جميع الأقراص من العمود A إلى العمود C.\n\n    حالات:\n    - بالنسبة لـ n=1، يجب أن تعيد الدالة 2، حيث يوجد قرصان متطابقان يمكن نقلهما في حركتين.\n    - بالنسبة لـ n=2، يجب أن تعيد الدالة 6، حيث يتطلب الأمر حركتين للزوج الأول ثم 4 حركات إضافية للزوج الثاني.\n    - بالنسبة لـ n=3، يجب أن تعيد الدالة 14، وهو نتيجة العملية التكرارية: حركتان للزوج الأول، \n      4 حركات إضافية للزوج الثاني، ثم 8 حركات إضافية للزوج الثالث.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "sw": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Kuhesabu idadi ndogo ya hatua zinazohitajika kutatua tatizo la Hanoi Towers lenye diski mbili kwa jozi n za diski.\n    \n    Kazi hii inatekeleza algoriti ya kurudia ili kuamua idadi ndogo ya hatua zinazohitajika kuhamisha\n    diski 2n kutoka nguzo A hadi nguzo C katika mpangilio wa Hanoi Towers wenye diski mbili, kufuata sheria kwamba diski moja tu \n    inaweza kuhamishwa kwa wakati mmoja na hakuna diski inayoweza kuwekwa juu ya diski ndogo. Kazi hii inatumia uhusiano wa kurudia unaojulikana \n    na inahesabu kwa kurudia jumla ya idadi ya hatua kwa jozi n za diski.\n    \n    Hoja:\n    n (int): Idadi ya jozi za diski (kila moja ikiwa na diski mbili sawa) kwenye nguzo A.\n\n    Inarejesha:\n    int: Idadi ndogo ya hatua zinazohitajika kuhamisha diski zote kutoka nguzo A hadi nguzo C.\n\n    Matukio:\n    - Kwa n=1, kazi inapaswa kurudisha 2, kwa kuwa kuna diski mbili sawa zinazoweza kuhamishwa kwa hatua mbili.\n    - Kwa n=2, kazi inapaswa kurudisha 6, kwani inachukua hatua 2 kwa jozi ya kwanza na kisha hatua 4 zaidi kwa jozi ya pili.\n    - Kwa n=3, kazi inapaswa kurudisha 14, ambayo ni matokeo ya mchakato wa kurudia: hatua 2 kwa jozi ya kwanza, \n      4 zaidi kwa ya pili, na kisha hatua 8 za ziada kwa jozi ya tatu.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "tr": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Çift diskli Hanoi Kuleleri problemini n çift disk için çözmek için gereken minimum hamle sayısını hesaplayın.\n    \n    Bu fonksiyon, çift diskli bir Hanoi Kuleleri düzeninde, 2n diski A çubuğundan C çubuğuna transfer etmek için\n    gereken minimum hamle sayısını belirlemek amacıyla iteratif bir algoritma uygular. Kurallara göre, aynı anda sadece bir disk \n    hareket ettirilebilir ve hiçbir disk daha küçük bir diskin üzerine yerleştirilemez. Fonksiyon, bilinen bir özyinelemeli ilişkiyi \n    kullanır ve n çift disk için toplam hamle sayısını iteratif olarak hesaplar.\n    \n    Argümanlar:\n    n (int): A çubuğundaki disk çiftlerinin sayısı (her biri iki özdeş diskten oluşur).\n\n    Döndürür:\n    int: Tüm diskleri A çubuğundan C çubuğuna transfer etmek için gereken minimum hamle sayısı.\n\n    Durumlar:\n    - n=1 için, fonksiyon 2 döndürmelidir, çünkü iki özdeş disk iki hamlede taşınabilir.\n    - n=2 için, fonksiyon 6 döndürmelidir, çünkü ilk çift için 2 hamle ve ardından ikinci çift için 4 hamle daha gereklidir.\n    - n=3 için, fonksiyon 14 döndürmelidir, bu iteratif sürecin sonucudur: ilk çift için 2 hamle, \n      ikinci çift için 4 hamle daha ve ardından üçüncü çift için 8 ek hamle.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "vi": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Tính toán số lần di chuyển tối thiểu cần thiết để giải quyết vấn đề Tháp Hà Nội đĩa đôi cho n cặp đĩa.\n    \n    Hàm này triển khai một thuật toán lặp để xác định số lần di chuyển tối thiểu cần thiết để chuyển\n    2n đĩa từ cột A sang cột C trong thiết lập Tháp Hà Nội đĩa đôi, tuân theo các quy tắc chỉ có thể di chuyển một đĩa \n    tại một thời điểm và không đĩa nào được đặt lên trên một đĩa nhỏ hơn. Hàm sử dụng một quan hệ đệ quy đã biết \n    và tính toán lặp số lần di chuyển tổng cộng cho n cặp đĩa.\n    \n    Tham số:\n    n (int): Số cặp đĩa (mỗi cặp gồm hai đĩa giống nhau) trên cột A.\n\n    Trả về:\n    int: Số lần di chuyển tối thiểu cần thiết để chuyển tất cả các đĩa từ cột A sang cột C.\n\n    Trường hợp:\n    - Với n=1, hàm sẽ trả về 2, vì có hai đĩa giống nhau có thể được di chuyển trong hai lần di chuyển.\n    - Với n=2, hàm sẽ trả về 6, vì cần 2 lần di chuyển cho cặp đầu tiên và sau đó 4 lần di chuyển nữa cho cặp thứ hai.\n    - Với n=3, hàm sẽ trả về 14, đó là kết quả của quá trình lặp: 2 lần di chuyển cho cặp đầu tiên, \n      4 lần nữa cho cặp thứ hai, và sau đó 8 lần di chuyển bổ sung cho cặp thứ ba.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "id": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Menghitung jumlah minimum gerakan yang diperlukan untuk menyelesaikan masalah Menara Hanoi cakram ganda untuk n pasang cakram.\n    \n    Fungsi ini mengimplementasikan algoritma iteratif untuk menentukan jumlah minimum gerakan yang diperlukan untuk memindahkan\n    2n cakram dari tiang A ke tiang C dalam pengaturan Menara Hanoi cakram ganda, mengikuti aturan bahwa hanya satu cakram \n    yang dapat dipindahkan pada satu waktu dan tidak ada cakram yang boleh ditempatkan di atas cakram yang lebih kecil. Fungsi ini menggunakan hubungan rekursif yang dikenal \n    dan secara iteratif menghitung total jumlah gerakan untuk n pasang cakram.\n    \n    Args:\n    n (int): Jumlah pasangan cakram (masing-masing terdiri dari dua cakram identik) pada tiang A.\n\n    Returns:\n    int: Jumlah minimum gerakan yang diperlukan untuk memindahkan semua cakram dari tiang A ke tiang C.\n\n    Kasus:\n    - Untuk n=1, fungsi harus mengembalikan 2, karena ada dua cakram identik yang dapat dipindahkan dalam dua gerakan.\n    - Untuk n=2, fungsi harus mengembalikan 6, karena dibutuhkan 2 gerakan untuk pasangan pertama dan kemudian 4 gerakan lagi untuk pasangan kedua.\n    - Untuk n=3, fungsi harus mengembalikan 14, yang merupakan hasil dari proses iteratif: 2 gerakan untuk pasangan pertama, \n      4 lagi untuk pasangan kedua, dan kemudian 8 gerakan tambahan untuk pasangan ketiga.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "ja": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    ダブルディスクハノイの塔問題をn組のディスクに対して解くために必要な最小移動回数を計算します。\n    \n    この関数は、ダブルディスクハノイの塔の設定で、2n枚のディスクをAポールからCポールに移動するために必要な\n    最小移動回数を決定するための反復アルゴリズムを実装しています。ルールとしては、一度に1枚のディスクしか\n    移動できず、小さいディスクの上に大きいディスクを置くことはできません。この関数は既知の再帰的関係を使用し、\n    n組のディスクに対する総移動回数を反復的に計算します。\n    \n    引数:\n    n (int): Aポール上のディスクのペア数（各ペアは同一の2枚のディスク）。\n\n    戻り値:\n    int: すべてのディスクをAポールからCポールに移動するのに必要な最小移動回数。\n\n    ケース:\n    - n=1の場合、関数は2を返すべきです。これは、2枚の同一のディスクが2回の移動で移動できるためです。\n    - n=2の場合、関数は6を返すべきです。最初のペアに2回の移動が必要で、その後2番目のペアにさらに4回の移動が必要です。\n    - n=3の場合、関数は14を返すべきです。これは反復プロセスの結果で、最初のペアに2回の移動、次に2番目のペアに4回、\n      そして3番目のペアにさらに8回の移動が必要です。\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "ko": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    n 쌍의 디스크에 대해 이중 디스크 하노이 탑 문제를 해결하는 데 필요한 최소 이동 횟수를 계산합니다.\n    \n    이 함수는 이중 디스크 하노이 탑 설정에서 2n개의 디스크를 A 기둥에서 C 기둥으로 옮기는 데 필요한 \n    최소 이동 횟수를 결정하기 위해 반복 알고리즘을 구현합니다. 한 번에 하나의 디스크만 이동할 수 있으며 \n    작은 디스크 위에 더 큰 디스크를 놓을 수 없다는 규칙을 따릅니다. 이 함수는 알려진 재귀 관계를 사용하여 \n    n 쌍의 디스크에 대한 총 이동 횟수를 반복적으로 계산합니다.\n    \n    Args:\n    n (int): A 기둥에 있는 디스크 쌍의 수 (각각 두 개의 동일한 디스크로 구성).\n\n    Returns:\n    int: 모든 디스크를 A 기둥에서 C 기둥으로 옮기는 데 필요한 최소 이동 횟수.\n\n    Cases:\n    - n=1인 경우, 함수는 2를 반환해야 합니다. 이는 두 개의 동일한 디스크가 두 번의 이동으로 이동할 수 있기 때문입니다.\n    - n=2인 경우, 함수는 6을 반환해야 합니다. 첫 번째 쌍에 2번의 이동이 필요하고 두 번째 쌍에 4번의 추가 이동이 필요하기 때문입니다.\n    - n=3인 경우, 함수는 14를 반환해야 합니다. 이는 반복 과정의 결과로, 첫 번째 쌍에 2번의 이동, \n      두 번째 쌍에 4번의 추가 이동, 세 번째 쌍에 8번의 추가 이동이 필요하기 때문입니다.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "ml": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    n ജോഡികളായ ഡിസ്കുകൾക്കായി ഡബിൾ-ഡിസ്ക് ഹാനോയ് ടവേഴ്സ് പ്രശ്നം പരിഹരിക്കാൻ ആവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n    \n    ഈ ഫംഗ്ഷൻ ആവർത്തന ആൽഗോരിതം നടപ്പിലാക്കുന്നു, 2n ഡിസ്കുകൾ A പോളിൽ നിന്ന് C പോളിലേക്ക് ഡബിൾ-ഡിസ്ക് ഹാനോയ് ടവേഴ്സ് ക്രമത്തിൽ \n    മാറ്റുന്നതിനുള്ള കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം നിർണ്ണയിക്കാൻ, ഓരോ സമയത്തും ഒരു ഡിസ്ക് മാത്രമേ മാറ്റാൻ കഴിയൂ, ഒരു ചെറിയ \n    ഡിസ്കിന് മുകളിൽ മറ്റൊരു ഡിസ്ക് വയ്ക്കാൻ പാടില്ല. ഈ ഫംഗ്ഷൻ അറിയപ്പെടുന്ന പുനരാവർത്തന ബന്ധം ഉപയോഗിക്കുന്നു \n    കൂടാതെ n ജോഡികളായ ഡിസ്കുകൾക്കായി ആകെ നീക്കങ്ങളുടെ എണ്ണം ആവർത്തിച്ച് കണക്കാക്കുന്നു.\n    \n    Args:\n    n (int): A പോളിലെ ഓരോന്നും രണ്ട് ഒരേപോലുള്ള ഡിസ്കുകളുള്ള ഡിസ്ക് ജോഡികളുടെ എണ്ണം.\n\n    Returns:\n    int: A പോളിൽ നിന്ന് C പോളിലേക്ക് എല്ലാ ഡിസ്കുകളും മാറ്റുന്നതിനുള്ള കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം.\n\n    കേസുകൾ:\n    - n=1 ആണെങ്കിൽ, ഫംഗ്ഷൻ 2 മടക്കണം, കാരണം രണ്ട് ഒരേപോലുള്ള ഡിസ്കുകൾ രണ്ട് നീക്കങ്ങളിൽ മാറ്റാൻ കഴിയും.\n    - n=2 ആണെങ്കിൽ, ഫംഗ്ഷൻ 6 മടക്കണം, കാരണം ആദ്യ ജോഡിക്ക് 2 നീക്കങ്ങൾ വേണ്ടിവരും, പിന്നെ രണ്ടാം ജോഡിക്ക് 4 കൂടുതൽ നീക്കങ്ങൾ.\n    - n=3 ആണെങ്കിൽ, ഫംഗ്ഷൻ 14 മടക്കണം, ഇത് ആവർത്തന പ്രക്രിയയുടെ ഫലമാണ്: ആദ്യ ജോഡിക്ക് 2 നീക്കങ്ങൾ, \n      രണ്ടാം ജോഡിക്ക് 4 കൂടുതൽ, പിന്നെ മൂന്നാം ജോഡിക്ക് 8 അധിക നീക്കങ്ങൾ.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "fa": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    حداقل تعداد حرکات مورد نیاز برای حل مسئله برج‌های هانوی با دیسک‌های دوتایی برای n جفت دیسک را محاسبه کنید.\n    \n    این تابع یک الگوریتم تکراری را برای تعیین حداقل تعداد حرکات لازم برای انتقال\n    2n دیسک از میله A به میله C در یک تنظیم برج‌های هانوی با دیسک‌های دوتایی پیاده‌سازی می‌کند، با رعایت قوانینی که فقط یک دیسک \n    می‌تواند در یک زمان منتقل شود و هیچ دیسکی نباید روی دیسک کوچکتر قرار گیرد. تابع از یک رابطه بازگشتی شناخته شده استفاده می‌کند \n    و به صورت تکراری تعداد کل حرکات را برای n جفت دیسک محاسبه می‌کند.\n    \n    آرگومان‌ها:\n    n (int): تعداد جفت دیسک‌ها (هر کدام شامل دو دیسک یکسان) روی میله A.\n\n    بازگشت:\n    int: حداقل تعداد حرکات مورد نیاز برای انتقال تمام دیسک‌ها از میله A به میله C.\n\n    موارد:\n    - برای n=1، تابع باید 2 را برگرداند، زیرا دو دیسک یکسان وجود دارد که می‌توانند در دو حرکت منتقل شوند.\n    - برای n=2، تابع باید 6 را برگرداند، زیرا 2 حرکت برای جفت اول و سپس 4 حرکت دیگر برای جفت دوم لازم است.\n    - برای n=3، تابع باید 14 را برگرداند، که نتیجه فرآیند تکراری است: 2 حرکت برای جفت اول، \n      4 حرکت دیگر برای جفت دوم، و سپس 8 حرکت اضافی برای جفت سوم.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves"}, "canonical_solution": "    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "instruction": {"en": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.", "zh": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。", "fr": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.", "ha": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nBada taƙaitaccen bayani a cikin yaren ɗan adam (docstring) na lambar Python a Hausa ba tare da wucewa haruffa 500 ba.", "hi": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।", "hu": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Python باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.", "sw": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.", "vi": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\n以下のPythonコードの自然言語による簡潔な説明（ドックストリング）を日本語で500文字以内で提供してください。", "ko": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성합니다.", "ml": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nപൈതൺ കോഡിന് 500 അക്ഷരങ്ങൾക്കുള്ളിൽ മലയാളത്തിൽ സംക്ഷിപ്തമായ ഒരു സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) നൽകുക.", "fa": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون را به زبان فارسی با حداکثر ۵۰۰ کاراکتر ارائه دهید."}, "level": "", "test": "def test_hanoi_double_iterative():\n    # Test case 1: n = 1\n    assert hanoi_double_iterative(1) == 2, \"Test case 1 failed\"\n\n    # Test case 2: n = 2\n    assert hanoi_double_iterative(2) == 6, \"Test case 2 failed\"\n\n    # Test case 3: n = 3\n    assert hanoi_double_iterative(3) == 14, \"Test case 3 failed\"\n\n    # Additional test cases can be added based on computed or known results\n    # Test case 4: n = 4 (computed using the formula)\n    assert hanoi_double_iterative(4) == 30, \"Test case 4 failed\"\n\n    # Test case 5: n = 5 (computed using the formula)\n    assert hanoi_double_iterative(5) == 62, \"Test case 5 failed\"\n\n    # Test case 6: Large n, n = 10 (computed using the formula or a trusted source)\n    assert hanoi_double_iterative(10) == 2046, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_hanoi_double_iterative()", "entry_point": "hanoi_double_iterative", "signature": "def hanoi_double_iterative(n: int) -> int:", "docstring": {"en": "Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n\nThis function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc\ncan be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation\nand iteratively computes the total number of moves for n pairs of discs.\n\nArgs:\nn (int): The number of disc pairs (each of two identical discs) on the A pole.\n\nReturns:\nint: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\nCases:\n- For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n- For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n- For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair,\n4 more for the second, and then 8 additional moves for the third pair.", "sq": "Llogarit numrin minimal të lëvizjeve të nevojshme për të zgjidhur problemin e Kullave të Hanoi me dy disqe për n çifte disqesh.\n\nKjo funksion implementon një algoritëm iterativ për të përcaktuar numrin minimal të lëvizjeve të nevojshme për të transferuar\n2n disqe nga shtylla A në shtyllën C në një konfigurim të Kullave të Hanoi me dy disqe, duke ndjekur rregullat që vetëm një disk\nmund të zhvendoset në një kohë dhe asnjë disk nuk mund të vendoset mbi një disk më të vogël. Funksioni përdor një marrëdhënie të njohur rekursive\ndhe llogarit në mënyrë iterative numrin total të lëvizjeve për n çifte disqesh.\n\nArgumentet:\nn (int): Numri i çifteve të disqeve (secili me dy disqe identike) në shtyllën A.\n\nKthen:\nint: Numri minimal i lëvizjeve të nevojshme për të transferuar të gjithë disqet nga shtylla A në shtyllën C.\n\nRastet:\n- Për n=1, funksioni duhet të kthejë 2, pasi ka dy disqe identike që mund të zhvendosen në dy lëvizje.\n- Për n=2, funksioni duhet të kthejë 6, pasi duhen 2 lëvizje për çiftin e parë dhe pastaj 4 lëvizje të tjera për çiftin e dytë.\n- Për n=3, funksioni duhet të kthejë 14, që është rezultati i procesit iterativ: 2 lëvizje për çiftin e parë,\n4 të tjera për të dytin, dhe pastaj 8 lëvizje shtesë për çiftin e tretë.", "hy": "Հաշվել նվազագույն քայլերի քանակը, որը պահանջվում է կրկնակի սկավառակներով Հանոյի աշտարակների խնդիրը լուծելու համար n զույգ սկավառակների համար։\n\nԱյս ֆունկցիան իրականացնում է իտերատիվ ալգորիթմ՝ որոշելու նվազագույն քայլերի քանակը, որը անհրաժեշտ է 2n սկավառակները A ձողից C ձող տեղափոխելու համար կրկնակի սկավառակներով Հանոյի աշտարակների պարագայում՝ հետևելով այն կանոններին, որ միայն մեկ սկավառակ կարելի է տեղափոխել միաժամանակ և ոչ մի սկավառակ չի կարող տեղադրվել ավելի փոքր սկավառակի վրա։ Ֆունկցիան օգտագործում է հայտնի ռեկուրսիվ հարաբերություն և իտերատիվ կերպով հաշվարկում է ընդհանուր քայլերի քանակը n զույգ սկավառակների համար։\n\nԱրգումենտներ:\nn (int): Սկավառակների զույգերի քանակը (յուրաքանչյուր զույգ բաղկացած է երկու նույնական սկավառակներից) A ձողի վրա։\n\nՎերադարձնում է:\nint: Նվազագույն քայլերի քանակը, որը պահանջվում է բոլոր սկավառակները A ձողից C ձող տեղափոխելու համար։\n\nԴեպքեր:\n- n=1-ի համար ֆունկցիան պետք է վերադարձնի 2, քանի որ կան երկու նույնական սկավառակներ, որոնք կարելի է տեղափոխել երկու քայլով։\n- n=2-ի համար ֆունկցիան պետք է վերադարձնի 6, քանի որ առաջին զույգի համար պահանջվում է 2 քայլ, իսկ երկրորդ զույգի համար՝ ևս 4 քայլ։\n- n=3-ի համար ֆունկցիան պետք է վերադարձնի 14, որը իտերատիվ գործընթացի արդյունքն է՝ 2 քայլ առաջին զույգի համար, 4 քայլ երկրորդ զույգի համար, և ապա 8 լրացուցիչ քայլեր երրորդ զույգի համար։", "bn": "ডাবল-ডিস্ক হ্যানয় টাওয়ার সমস্যা সমাধানের জন্য প্রয়োজনীয় ন্যূনতম পদক্ষেপের সংখ্যা গণনা করুন n জোড়া ডিস্কের জন্য।\n\nএই ফাংশনটি একটি পুনরাবৃত্তিমূলক অ্যালগরিদম বাস্তবায়ন করে যা ডাবল-ডিস্ক হ্যানয় টাওয়ার সেটআপে 2n ডিস্ককে A খুঁটি থেকে C খুঁটিতে স্থানান্তর করার জন্য প্রয়োজনীয় ন্যূনতম পদক্ষেপের সংখ্যা নির্ধারণ করে, এই নিয়মগুলি অনুসরণ করে যে একবারে শুধুমাত্র একটি ডিস্ক সরানো যেতে পারে এবং কোনো ডিস্ক ছোট ডিস্কের উপরে রাখা যাবে না। ফাংশনটি একটি পরিচিত পুনরাবৃত্ত সম্পর্ক ব্যবহার করে এবং n জোড়া ডিস্কের জন্য মোট পদক্ষেপের সংখ্যা পুনরাবৃত্তিমূলকভাবে গণনা করে।\n\nআর্গুমেন্টসমূহ:\nn (int): A খুঁটিতে থাকা ডিস্কের জোড়ার সংখ্যা (প্রত্যেকটি দুটি অভিন্ন ডিস্কের)।\n\nরিটার্নস:\nint: সমস্ত ডিস্ক A খুঁটি থেকে C খুঁটিতে স্থানান্তর করার জন্য প্রয়োজনীয় ন্যূনতম পদক্ষেপের সংখ্যা।\n\nঘটনাগুলি:\n- n=1 এর জন্য, ফাংশনটি 2 ফেরত দেবে, যেহেতু দুটি অভিন্ন ডিস্ক রয়েছে যা দুটি পদক্ষেপে সরানো যেতে পারে।\n- n=2 এর জন্য, ফাংশনটি 6 ফেরত দেবে, কারণ প্রথম জোড়ার জন্য 2 পদক্ষেপ এবং তারপর দ্বিতীয় জোড়ার জন্য আরও 4 পদক্ষেপ লাগে।\n- n=3 এর জন্য, ফাংশনটি 14 ফেরত দেবে, যা পুনরাবৃত্তিমূলক প্রক্রিয়ার ফলাফল: প্রথম জোড়ার জন্য 2 পদক্ষেপ, দ্বিতীয়টির জন্য আরও 4, এবং তারপর তৃতীয় জোড়ার জন্য অতিরিক্ত 8 পদক্ষেপ।", "bg": "Изчисляване на минималния брой ходове, необходими за решаване на проблема с двойните дискове на Ханойските кули за n двойки дискове.\n\nТази функция реализира итеративен алгоритъм за определяне на минималния брой ходове, необходими за преместване на 2n диска от стълба A към стълба C в конфигурация на Ханойските кули с двойни дискове, следвайки правилата, че само един диск може да бъде преместен наведнъж и никой диск не може да бъде поставен върху по-малък диск. Функцията използва известна рекурсивна връзка и итеративно изчислява общия брой ходове за n двойки дискове.\n\nАргументи:\nn (int): Броят на двойките дискове (всяка от два идентични диска) на стълба A.\n\nВръща:\nint: Минималният брой ходове, необходими за преместване на всички дискове от стълба A към стълба C.\n\nСлучаи:\n- За n=1, функцията трябва да върне 2, тъй като има два идентични диска, които могат да бъдат преместени в два хода.\n- За n=2, функцията трябва да върне 6, тъй като са необходими 2 хода за първата двойка и след това още 4 хода за втората двойка.\n- За n=3, функцията трябва да върне 14, което е резултат от итеративния процес: 2 хода за първата двойка, още 4 за втората и след това още 8 хода за третата двойка.", "zh": "计算解决双盘汉诺塔问题所需的最小移动次数，对于 n 对圆盘。\n\n此函数实现了一种迭代算法，以确定在双盘汉诺塔设置中，将 2n 个圆盘从 A 柱移动到 C 柱所需的最小移动次数，遵循的规则是一次只能移动一个圆盘，并且不能将圆盘放在比它小的圆盘上。该函数使用已知的递归关系，并迭代计算 n 对圆盘的总移动次数。\n\n参数：\nn (int): A 柱上的圆盘对数（每对由两个相同的圆盘组成）。\n\n返回：\nint: 将所有圆盘从 A 柱转移到 C 柱所需的最小移动次数。\n\n情况：\n- 对于 n=1，函数应返回 2，因为有两个相同的圆盘，可以通过两次移动完成。\n- 对于 n=2，函数应返回 6，因为第一对需要 2 次移动，然后第二对需要再 4 次移动。\n- 对于 n=3，函数应返回 14，这是迭代过程的结果：第一对需要 2 次移动，第二对再需要 4 次，第三对再需要 8 次移动。", "fr": "Calculer le nombre minimum de mouvements nécessaires pour résoudre le problème des Tours de Hanoï à double disque pour n paires de disques.\n\nCette fonction implémente un algorithme itératif pour déterminer le nombre minimum de mouvements nécessaires pour transférer\n2n disques du poteau A au poteau C dans une configuration de Tours de Hanoï à double disque, en suivant les règles selon lesquelles un seul disque\npeut être déplacé à la fois et aucun disque ne peut être placé sur un disque plus petit. La fonction utilise une relation récursive connue\net calcule de manière itérative le nombre total de mouvements pour n paires de disques.\n\nArgs:\nn (int): Le nombre de paires de disques (chacune de deux disques identiques) sur le poteau A.\n\nReturns:\nint: Le nombre minimum de mouvements nécessaires pour transférer tous les disques du poteau A au poteau C.\n\nCas:\n- Pour n=1, la fonction doit retourner 2, car il y a deux disques identiques qui peuvent être déplacés en deux mouvements.\n- Pour n=2, la fonction doit retourner 6, car il faut 2 mouvements pour la première paire et ensuite 4 mouvements supplémentaires pour la deuxième paire.\n- Pour n=3, la fonction doit retourner 14, ce qui est le résultat du processus itératif : 2 mouvements pour la première paire,\n4 de plus pour la deuxième, puis 8 mouvements supplémentaires pour la troisième paire.", "de": "Berechne die minimale Anzahl von Zügen, die erforderlich sind, um das Doppelscheiben-Hanoi-Türme-Problem für n Scheibenpaare zu lösen.\n\nDiese Funktion implementiert einen iterativen Algorithmus, um die minimale Anzahl von Zügen zu bestimmen, die notwendig sind, um 2n Scheiben vom A-Pfosten zum C-Pfosten in einem Doppelscheiben-Hanoi-Türme-Aufbau zu übertragen, wobei die Regeln befolgt werden, dass jeweils nur eine Scheibe bewegt werden kann und keine Scheibe auf eine kleinere Scheibe gelegt werden darf. Die Funktion verwendet eine bekannte rekursive Beziehung und berechnet iterativ die Gesamtanzahl der Züge für n Scheibenpaare.\n\nArgumente:\nn (int): Die Anzahl der Scheibenpaare (jeweils zwei identische Scheiben) auf dem A-Pfosten.\n\nRückgabewert:\nint: Die minimale Anzahl von Zügen, die erforderlich ist, um alle Scheiben vom A-Pfosten zum C-Pfosten zu übertragen.\n\nFälle:\n- Für n=1 sollte die Funktion 2 zurückgeben, da es zwei identische Scheiben gibt, die in zwei Zügen bewegt werden können.\n- Für n=2 sollte die Funktion 6 zurückgeben, da es 2 Züge für das erste Paar und dann 4 weitere Züge für das zweite Paar benötigt.\n- Für n=3 sollte die Funktion 14 zurückgeben, was das Ergebnis des iterativen Prozesses ist: 2 Züge für das erste Paar, 4 weitere für das zweite und dann 8 zusätzliche Züge für das dritte Paar.", "ha": "Lissafa mafi ƙarancin yawan motsi da ake buƙata don warware matsalar hasumiyar Hanoi mai faifan diski biyu don n nau'i biyu na faifai.\n\nWannan aikin yana aiwatar da wata dabara mai maimaitawa don tantance adadin motsi mafi karanci da ake bukata don canja wurin\nfaifan 2n daga sandar A zuwa sandar C a cikin saitin double-disc Hanoi Towers, bisa ga dokokin da ke cewa faifan daya kawai\nza a iya motsawa a lokaci daya kuma babu wani faifan da za a iya sanya shi a saman faifan da ya fi shi girma. Aikin yana amfani da wata dangantaka mai maimaitawa da aka sani\nkuma yana lissafa jimlar adadin motsi don nau'i-nau'i na faifan diski.\n\nArgs:\nn (int): Adadin nau'i-nau'i na faifan diski (kowanne na faifan diski guda biyu masu kama) a kan sandar A.\n\nReturns:\nint: Adadin motsi mafi karanci da ake bukata don canja dukkan faifan daga sandar A zuwa sandar C.\n\nCases:\n- Don n=1, aikin ya kamata ya dawo da 2, tun da akwai faifan diski guda biyu masu kama da za a iya motsawa a cikin motsi biyu.\n- Don n=2, aikin ya kamata ya dawo da 6, saboda yana daukar motsi 2 don nau'i na farko sannan kuma karin motsi 4 don nau'i na biyu.\n- Don n=3, aikin ya kamata ya dawo da 14, wanda shine sakamakon tsarin maimaitawa: motsi 2 don nau'i na farko,\nkarin motsi 4 don na biyu, sannan kuma karin motsi 8 don nau'i na uku.", "hi": "दोहरे-डिस्क हनोई टावर्स समस्या के लिए n जोड़ों के डिस्क के लिए आवश्यक न्यूनतम चालों की गणना करें।\n\nयह फ़ंक्शन एक पुनरावृत्त एल्गोरिदम को लागू करता है ताकि यह निर्धारित किया जा सके कि दोहरे-डिस्क हनोई टावर्स सेटअप में 2n डिस्क को A पोल से C पोल तक स्थानांतरित करने के लिए न्यूनतम चालों की संख्या क्या है, इस नियम का पालन करते हुए कि एक समय में केवल एक डिस्क को स्थानांतरित किया जा सकता है और कोई भी डिस्क छोटी डिस्क के ऊपर नहीं रखी जा सकती। यह फ़ंक्शन ज्ञात पुनरावर्ती संबंध का उपयोग करता है और n जोड़े डिस्क के लिए कुल चालों की संख्या को पुनरावृत्त रूप से गणना करता है।\n\nArgs:\nn (int): A पोल पर डिस्क के जोड़ों की संख्या (प्रत्येक दो समान डिस्क का)।\n\nReturns:\nint: A पोल से C पोल तक सभी डिस्क को स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या।\n\nCases:\n- n=1 के लिए, फ़ंक्शन को 2 लौटाना चाहिए, क्योंकि दो समान डिस्क हैं जिन्हें दो चालों में स्थानांतरित किया जा सकता है।\n- n=2 के लिए, फ़ंक्शन को 6 लौटाना चाहिए, क्योंकि पहले जोड़े के लिए 2 चालें लगती हैं और फिर दूसरे जोड़े के लिए 4 और चालें लगती हैं।\n- n=3 के लिए, फ़ंक्शन को 14 लौटाना चाहिए, जो पुनरावृत्त प्रक्रिया का परिणाम है: पहले जोड़े के लिए 2 चालें, दूसरे के लिए 4 और फिर तीसरे जोड़े के लिए 8 अतिरिक्त चालें।", "hu": "Számítsa ki a minimális lépések számát, amely szükséges a dupla korongos Hanoi tornyok problémájának megoldásához n korongpár esetén.\n\nEz a függvény egy iteratív algoritmust valósít meg annak meghatározására, hogy mi a minimális lépésszám, amely szükséges 2n korong áthelyezéséhez az A oszlopról a C oszlopra egy dupla korongos Hanoi tornyok felállásban, követve azokat a szabályokat, hogy egyszerre csak egy korong mozgatható, és egyetlen korong sem helyezhető kisebb korong tetejére. A függvény egy ismert rekurzív összefüggést használ, és iteratívan kiszámítja a teljes lépésszámot n korongpár esetén.\n\nArgs:\nn (int): A korongpárok száma (mindegyik két azonos korongból áll) az A oszlopon.\n\nReturns:\nint: A minimális lépésszám, amely szükséges az összes korong áthelyezéséhez az A oszlopról a C oszlopra.\n\nEsetek:\n- Ha n=1, a függvénynek 2-t kell visszaadnia, mivel két azonos korong van, amelyeket két lépésben lehet áthelyezni.\n- Ha n=2, a függvénynek 6-ot kell visszaadnia, mivel 2 lépés szükséges az első párhoz, majd további 4 lépés a második párhoz.\n- Ha n=3, a függvénynek 14-et kell visszaadnia, ami az iteratív folyamat eredménye: 2 lépés az első párhoz, további 4 a másodikhoz, majd 8 további lépés a harmadik párhoz.", "es": "Calcular el número mínimo de movimientos necesarios para resolver el problema de las Torres de Hanoi de doble disco para n pares de discos.\n\nEsta función implementa un algoritmo iterativo para determinar el número mínimo de movimientos necesarios para transferir\n2n discos desde el poste A al poste C en una configuración de Torres de Hanoi de doble disco, siguiendo las reglas de que solo un disco\npuede moverse a la vez y ningún disco puede colocarse sobre otro más pequeño. La función utiliza una relación recursiva conocida\ny calcula iterativamente el número total de movimientos para n pares de discos.\n\nArgumentos:\nn (int): El número de pares de discos (cada uno de dos discos idénticos) en el poste A.\n\nDevuelve:\nint: El número mínimo de movimientos necesarios para transferir todos los discos del poste A al poste C.\n\nCasos:\n- Para n=1, la función debería devolver 2, ya que hay dos discos idénticos que pueden moverse en dos movimientos.\n- Para n=2, la función debería devolver 6, ya que se requieren 2 movimientos para el primer par y luego 4 movimientos más para el segundo par.\n- Para n=3, la función debería devolver 14, que es el resultado del proceso iterativo: 2 movimientos para el primer par,\n4 más para el segundo, y luego 8 movimientos adicionales para el tercer par.", "arb": "احسب الحد الأدنى لعدد الحركات المطلوبة لحل مشكلة أبراج هانوي ذات القرصين المزدوجين لعدد n من أزواج الأقراص.\n\nتقوم هذه الدالة بتنفيذ خوارزمية تكرارية لتحديد الحد الأدنى لعدد الحركات اللازمة لنقل 2n قرصًا من العمود A إلى العمود C في إعداد أبراج هانوي ذات القرصين المزدوجين، مع اتباع القواعد التي تنص على أنه يمكن نقل قرص واحد فقط في كل مرة ولا يمكن وضع أي قرص فوق قرص أصغر. تستخدم الدالة علاقة تكرارية معروفة وتحسب بشكل تكراري العدد الإجمالي للحركات لعدد n من أزواج الأقراص.\n\nيعيدالحجج:\nn (int): عدد أزواج الأقراص (كل زوج من قرصين متطابقين) على العمود A.\n\nيعيد:\nint: الحد الأدنى لعدد الحركات المطلوبة لنقل جميع الأقراص من العمود A إلى العمود C.\n\nCases:\n- بالنسبة لـ n=1، يجب أن تعيد الدالة 2، حيث يوجد قرصان متطابقان يمكن نقلهما في حركتين.\n- بالنسبة لـ n=2، يجب أن تعيد الدالة 6، حيث يتطلب الأمر حركتين للزوج الأول ثم 4 حركات إضافية للزوج الثاني.\n- بالنسبة لـ n=3، يجب أن تعيد الدالة 14، وهو نتيجة العملية التكرارية: حركتان للزوج الأول، 4 أخرى للزوج الثاني، ثم 8 حركات إضافية للزوج الثالث.", "sw": "Kuhesabu idadi ndogo ya hatua zinazohitajika kutatua tatizo la Hanoi Towers lenye diski mbili kwa jozi n za diski.\n\nKazi hii inatekeleza algoriti ya kurudia ili kubaini idadi ndogo ya hatua zinazohitajika kuhamisha\ndiski 2n kutoka nguzo A hadi nguzo C katika mpangilio wa Hanoi Towers wa diski mbili, kufuata sheria kwamba diski moja tu\ninaweza kuhamishwa kwa wakati mmoja na hakuna diski inayoweza kuwekwa juu ya diski ndogo. Kazi hii inatumia uhusiano wa kurudia unaojulikana\nna inahesabu kwa kurudia jumla ya idadi ya hatua kwa jozi n za diski.\n\nHoja:\nn (int): Idadi ya jozi za diski (kila moja ina diski mbili sawa) kwenye nguzo A.\n\nInarejesha:\nint: Idadi ndogo ya hatua zinazohitajika kuhamisha diski zote kutoka nguzo A hadi nguzo C.\n\nCases:\n- Kwa n=1, kazi inapaswa kurudisha 2, kwa kuwa kuna diski mbili sawa ambazo zinaweza kuhamishwa katika hatua mbili.\n- Kwa n=2, kazi inapaswa kurudisha 6, kwani inachukua hatua 2 kwa jozi ya kwanza na kisha hatua 4 zaidi kwa jozi ya pili.\n- Kwa n=3, kazi inapaswa kurudisha 14, ambayo ni matokeo ya mchakato wa kurudia: hatua 2 kwa jozi ya kwanza,\nhatua 4 zaidi kwa ya pili, na kisha hatua 8 za ziada kwa jozi ya tatu.", "tr": "Çift diskli Hanoi Kuleleri problemini çözmek için gereken minimum hamle sayısını n disk çifti için hesaplayın.\n\nBu fonksiyon, çift diskli Hanoi Kuleleri düzeninde 2n diski A direğinden C direğine transfer etmek için gereken minimum hamle sayısını belirlemek amacıyla iteratif bir algoritma uygular. Kurallara göre, her seferinde yalnızca bir disk taşınabilir ve hiçbir disk daha küçük bir diskin üzerine yerleştirilemez. Fonksiyon, bilinen bir özyinelemeli ilişki kullanır ve n disk çifti için toplam hamle sayısını iteratif olarak hesaplar.\n\nArgümanlar:\nn (int): A direğinde bulunan disk çiftlerinin sayısı (her biri iki özdeş diskten oluşur).\n\nDöndürür:\nint: Tüm disklerin A direğinden C direğine transferi için gereken minimum hamle sayısı.\n\nDurumlar:\n- n=1 için, fonksiyon 2 döndürmelidir, çünkü iki özdeş disk iki hamlede taşınabilir.\n- n=2 için, fonksiyon 6 döndürmelidir, çünkü ilk çift için 2 hamle ve ikinci çift için 4 ek hamle gereklidir.\n- n=3 için, fonksiyon 14 döndürmelidir, bu iteratif sürecin sonucudur: ilk çift için 2 hamle, ikinci için 4 daha ve üçüncü çift için 8 ek hamle.", "vi": "Tính toán số lần di chuyển tối thiểu cần thiết để giải quyết vấn đề Tháp Hà Nội hai đĩa cho n cặp đĩa.\n\nHàm này triển khai một thuật toán lặp để xác định số lần di chuyển tối thiểu cần thiết để chuyển 2n đĩa từ cột A sang cột C trong thiết lập Tháp Hà Nội hai đĩa, tuân theo các quy tắc chỉ có thể di chuyển một đĩa tại một thời điểm và không đĩa nào được đặt lên trên một đĩa nhỏ hơn. Hàm sử dụng một quan hệ đệ quy đã biết và tính toán lặp số lần di chuyển tổng cộng cho n cặp đĩa.\n\nTham số:\nn (int): Số cặp đĩa (mỗi cặp gồm hai đĩa giống nhau) trên cột A.\n\nTrả về:\nint: Số lần di chuyển tối thiểu cần thiết để chuyển tất cả các đĩa từ cột A sang cột C.\n\nTrường hợp:\n- Với n=1, hàm nên trả về 2, vì có hai đĩa giống nhau có thể được di chuyển trong hai lần di chuyển.\n- Với n=2, hàm nên trả về 6, vì cần 2 lần di chuyển cho cặp đầu tiên và sau đó thêm 4 lần di chuyển cho cặp thứ hai.\n- Với n=3, hàm nên trả về 14, đây là kết quả của quá trình lặp: 2 lần di chuyển cho cặp đầu tiên, thêm 4 lần cho cặp thứ hai, và sau đó thêm 8 lần di chuyển cho cặp thứ ba.", "id": "Hitung jumlah minimum gerakan yang diperlukan untuk menyelesaikan masalah Menara Hanoi dua-cakram untuk n pasang cakram.\n\nFungsi ini mengimplementasikan algoritma iteratif untuk menentukan jumlah minimum gerakan yang diperlukan untuk memindahkan 2n cakram dari tiang A ke tiang C dalam pengaturan Menara Hanoi dua-cakram, mengikuti aturan bahwa hanya satu cakram yang dapat dipindahkan pada satu waktu dan tidak ada cakram yang boleh ditempatkan di atas cakram yang lebih kecil. Fungsi ini menggunakan hubungan rekursif yang dikenal dan secara iteratif menghitung jumlah total gerakan untuk n pasang cakram.\n\nArgs:\nn (int): Jumlah pasangan cakram (masing-masing terdiri dari dua cakram identik) pada tiang A.\n\nReturns:\nint: Jumlah minimum gerakan yang diperlukan untuk memindahkan semua cakram dari tiang A ke tiang C.\n\nKasus:\n- Untuk n=1, fungsi harus mengembalikan 2, karena ada dua cakram identik yang dapat dipindahkan dalam dua gerakan.\n- Untuk n=2, fungsi harus mengembalikan 6, karena dibutuhkan 2 gerakan untuk pasangan pertama dan kemudian 4 gerakan lagi untuk pasangan kedua.\n- Untuk n=3, fungsi harus mengembalikan 14, yang merupakan hasil dari proses iteratif: 2 gerakan untuk pasangan pertama, 4 lagi untuk yang kedua, dan kemudian 8 gerakan tambahan untuk pasangan ketiga.", "ja": "ディスクのペア数 n に対して、二重ディスクのハノイの塔問題を解くために必要な最小移動回数を計算します。\n\nこの関数は、二重ディスクのハノイの塔の設定で、A ポールから C ポールに 2n 枚のディスクを移動するために必要な最小移動回数を決定する反復アルゴリズムを実装しています。ルールとして、一度に移動できるディスクは1枚だけであり、小さいディスクの上に大きいディスクを置くことはできません。この関数は既知の再帰関係を使用し、n ペアのディスクに対する総移動回数を反復的に計算します。\n\n引数:\nn (int): A ポール上のディスクペア（それぞれ2枚の同一ディスク）の数。\n\n戻り値:\nint: すべてのディスクを A ポールから C ポールに移動するために必要な最小移動回数。\n\nケース:\n- n=1 の場合、関数は 2 を返すべきです。なぜなら、2 枚の同一ディスクが2回の移動で移動できるからです。\n- n=2 の場合、関数は 6 を返すべきです。最初のペアに2回の移動が必要で、次のペアにさらに4回の移動が必要だからです。\n- n=3 の場合、関数は 14 を返すべきです。これは反復プロセスの結果であり、最初のペアに2回、次に4回、そして3番目のペアにさらに8回の移動が必要です。", "ko": "2개의 디스크로 구성된 하노이 탑 문제를 해결하는 데 필요한 최소 이동 횟수를 계산합니다.\n\n이 함수는 이중 디스크 하노이 탑 설정에서 2n개의 디스크를 A 기둥에서 C 기둥으로 옮기는 데 필요한 최소 이동 횟수를 결정하기 위해 반복 알고리즘을 구현합니다. 이때 한 번에 하나의 디스크만 이동할 수 있으며, 작은 디스크 위에 큰 디스크를 놓을 수 없습니다. 함수는 알려진 재귀 관계를 사용하여 n 쌍의 디스크에 대한 총 이동 횟수를 반복적으로 계산합니다.\n\nArgs:\nn (int): A 기둥에 있는 디스크 쌍(각각 두 개의 동일한 디스크)의 수.\n\nReturns:\nint: 모든 디스크를 A 기둥에서 C 기둥으로 옮기는 데 필요한 최소 이동 횟수.\n\nCases:\n- n=1일 때, 함수는 2를 반환해야 합니다. 이는 두 개의 동일한 디스크가 두 번의 이동으로 옮겨질 수 있기 때문입니다.\n- n=2일 때, 함수는 6을 반환해야 합니다. 첫 번째 쌍에 2번의 이동이 필요하고, 두 번째 쌍에 4번의 추가 이동이 필요하기 때문입니다.\n- n=3일 때, 함수는 14를 반환해야 합니다. 이는 반복 과정의 결과로, 첫 번째 쌍에 2번의 이동, 두 번째 쌍에 4번의 추가 이동, 세 번째 쌍에 8번의 추가 이동이 필요하기 때문입니다.", "ml": "n ജോഡികളായ ഡിസ്കുകൾക്കായി ഡബിൾ-ഡിസ്ക് ഹാനോയ് ടവേഴ്സ് പ്രശ്നം പരിഹരിക്കാൻ ആവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n\nഈ ഫംഗ്ഷൻ, ഡബിൾ-ഡിസ്‌ക് ഹനോയ് ടവേഴ്സ് ക്രമീകരണത്തിൽ, 2n ഡിസ്‌കുകൾ A പോളിൽ നിന്ന് C പോളിലേക്ക് മാറ്റുന്നതിനാവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം നിർണ്ണയിക്കുന്നതിനുള്ള ഒരു ആവർത്തന ആൽഗോരിതം നടപ്പിലാക്കുന്നു. ഓരോ തവണയും ഒരു ഡിസ്‌ക് മാത്രമേ നീക്കാൻ പാടുള്ളൂ, കൂടാതെ ഒരു ചെറിയ ഡിസ്‌കിന്റെ മുകളിൽ മറ്റൊരു ഡിസ്‌ക് വെക്കാൻ പാടില്ല എന്ന നിയമങ്ങൾ പാലിച്ചുകൊണ്ട്, ഫംഗ്ഷൻ ഒരു അറിയപ്പെടുന്ന പുനരാവർത്തന ബന്ധം ഉപയോഗിച്ച് n ജോഡികളുടെ ഡിസ്‌കുകൾക്കുള്ള മൊത്തം നീക്കങ്ങളുടെ എണ്ണം ആവർത്തിച്ച് കണക്കാക്കുന്നു.\n\nArgs:\nn (int): A പോളിലെ ഡിസ്‌ക് ജോഡികളുടെ എണ്ണം (ഓരോന്നും രണ്ട് സമാനമായ ഡിസ്‌കുകൾ).\n\nReturns:\nint: എല്ലാ ഡിസ്‌കുകളും A പോളിൽ നിന്ന് C പോളിലേക്ക് മാറ്റുന്നതിനാവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം.\n\nCases:\n- n=1 ആണെങ്കിൽ, ഫംഗ്ഷൻ 2 തിരികെ നൽകണം, കാരണം രണ്ട് സമാനമായ ഡിസ്‌കുകൾ രണ്ട് നീക്കങ്ങളിൽ നീക്കാൻ കഴിയും.\n- n=2 ആണെങ്കിൽ, ഫംഗ്ഷൻ 6 തിരികെ നൽകണം, കാരണം ആദ്യ ജോഡിക്ക് 2 നീക്കങ്ങളും, പിന്നെ രണ്ടാമത്തെ ജോഡിക്ക് 4 കൂടുതൽ നീക്കങ്ങളും വേണം.\n- n=3 ആണെങ്കിൽ, ഫംഗ്ഷൻ 14 തിരികെ നൽകണം, ഇത് ആവർത്തന പ്രക്രിയയുടെ ഫലമാണ്: ആദ്യ ജോഡിക്ക് 2 നീക്കങ്ങൾ, രണ്ടാമത്തേക്ക് 4 കൂടുതൽ, പിന്നെ മൂന്നാമത്തെ ജോഡിക്ക് 8 അധിക നീക്കങ്ങൾ.", "fa": "محاسبه حداقل تعداد حرکت‌های لازم برای حل مسئله برج‌های هانوی دو دیسکی برای n جفت دیسک.\n\nاین تابع یک الگوریتم تکراری را پیاده‌سازی می‌کند تا حداقل تعداد حرکت‌های لازم برای انتقال 2n دیسک از میله A به میله C در یک تنظیم برج‌های هانوی دو دیسکی را تعیین کند، با رعایت قوانینی که تنها یک دیسک می‌تواند در هر زمان حرکت کند و هیچ دیسکی نباید بر روی دیسک کوچکتر قرار گیرد. این تابع از یک رابطه بازگشتی شناخته شده استفاده می‌کند و به صورت تکراری تعداد کل حرکت‌ها را برای n جفت دیسک محاسبه می‌کند.\n\nآرگومان‌ها:\nn (int): تعداد جفت دیسک‌ها (هر جفت شامل دو دیسک یکسان) بر روی میله A.\n\nبازگشت:\nint: حداقل تعداد حرکت‌های لازم برای انتقال تمام دیسک‌ها از میله A به میله C.\n\nموارد:\n- برای n=1، تابع باید 2 را برگرداند، زیرا دو دیسک یکسان وجود دارند که می‌توانند در دو حرکت جابجا شوند.\n- برای n=2، تابع باید 6 را برگرداند، زیرا 2 حرکت برای جفت اول و سپس 4 حرکت بیشتر برای جفت دوم لازم است.\n- برای n=3، تابع باید 14 را برگرداند، که نتیجه فرآیند تکراری است: 2 حرکت برای جفت اول، 4 حرکت بیشتر برای جفت دوم، و سپس 8 حرکت اضافی برای جفت سوم."}}
{"task_id": "Python/50", "prompt": {"en": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "sq": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Llogarit numrin total të cigareve që Peter mund të pijë.\n    Peter fillon me n cigare dhe mund të shkëmbejë k bishta për një cigare të re.\n    Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve,\n    dhe k është numri i bishtave të cigareve të nevojshëm për të shkëmbyer për një cigare të re.\n    Funksioni kthen numrin total të cigareve që Peter mund të pijë.\n    Shembull:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "hy": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Հաշվում է ընդհանուր ծխախոտների քանակը, որ Պետերը կարող է ծխել։\n    Պետերը սկսում է n ծխախոտներով և կարող է փոխանակել k մնացորդները մեկ նոր ծխախոտի համար։\n    Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ն սկզբնական ծխախոտների քանակն է,\n    և k-ն այն մնացորդների քանակն է, որոնք անհրաժեշտ են մեկ նոր ծխախոտի փոխանակման համար։\n    Ֆունկցիան վերադարձնում է ընդհանուր ծխախոտների քանակը, որ Պետերը կարող է ծխել։\n    Օրինակ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "bn": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    পিটার মোট কতগুলি সিগারেট খেতে পারে তা গণনা করে।\n    পিটার n সিগারেট দিয়ে শুরু করে এবং k টুকরো বাট দিয়ে একটি নতুন সিগারেট বিনিময় করতে পারে।\n    ফাংশনটি দুটি আর্গুমেন্ট নেয়, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা,\n    এবং k হল একটি নতুন সিগারেট বিনিময়ের জন্য প্রয়োজনীয় সিগারেট বাটের সংখ্যা।\n    ফাংশনটি পিটার মোট কতগুলি সিগারেট খেতে পারে তা ফেরত দেয়।\n    উদাহরণ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "bg": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Изчислява общия брой цигари, които Петър може да изпуши.\n    Петър започва с n цигари и може да размени k фасове за една нова цигара.\n    Функцията приема два аргумента, n и k, където n е началният брой цигари,\n    а k е броят на фасовете, необходими за размяна за една нова цигара.\n    Функцията връща общия брой цигари, които Петър може да изпуши.\n    Пример:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "zh": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    计算Peter可以抽的香烟总数。\n    Peter开始时有n支香烟，可以用k个烟头换一支新香烟。\n    该函数接受两个参数，n和k，其中n是初始香烟数量，\n    k是换取一支新香烟所需的烟头数量。\n    该函数返回Peter可以抽的香烟总数。\n    示例：\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "fr": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calcule le nombre total de cigarettes que Peter peut fumer.\n    Peter commence avec n cigarettes et peut échanger k mégots contre une nouvelle cigarette.\n    La fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes,\n    et k est le nombre de mégots de cigarettes nécessaires pour échanger contre une nouvelle cigarette.\n    La fonction renvoie le nombre total de cigarettes que Peter peut fumer.\n    Exemple:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "de": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n    Peter beginnt mit n Zigaretten und kann k Kippen gegen eine neue Zigarette eintauschen.\n    Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist,\n    und k die Anzahl der Kippen ist, die für eine neue Zigarette eingetauscht werden müssen.\n    Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n    Beispiel:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "ha": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Lissafa jimillar adadin sigari da Peter zai iya sha.\n    Peter yana farawa da sigari n kuma yana iya musanya k butts don sabon sigari daya.\n    Aikin yana daukar hujjoji guda biyu, n da k, inda n shine adadin sigari na farko,\n    kuma k shine adadin bututun sigari da ake bukata don musanya sabon sigari daya.\n    Aikin yana mayar da jimillar adadin sigari da Peter zai iya sha.\n    Misali:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "hi": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    कुल सिगरेटों की संख्या की गणना करता है जो पीटर पी सकता है।\n    पीटर n सिगरेटों से शुरू करता है और k बट्स के लिए एक नई सिगरेट का आदान-प्रदान कर सकता है।\n    फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेटों की संख्या है,\n    और k वह संख्या है जो एक नई सिगरेट के लिए आदान-प्रदान करने के लिए आवश्यक है।\n    फ़ंक्शन कुल सिगरेटों की संख्या लौटाता है जो पीटर पी सकता है।\n    उदाहरण:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "hu": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Kiszámítja a teljes cigarettaszámot, amit Péter elszívhat.\n    Péter n cigarettával kezd, és k csikket tud beváltani egy új cigarettára.\n    A függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigarettaszám,\n    és k az a csikkszám, ami szükséges egy új cigaretta beváltásához.\n    A függvény visszaadja a teljes cigarettaszámot, amit Péter elszívhat.\n    Példa:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "es": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calcula el número total de cigarrillos que Peter puede fumar.\n    Peter comienza con n cigarrillos y puede intercambiar k colillas por un cigarrillo nuevo.\n    La función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos,\n    y k es el número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\n    La función devuelve el número total de cigarrillos que Peter puede fumar.\n    Ejemplo:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "arb": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    يبدأ بيتر بـ n سجائر ويمكنه تبادل k أعقاب للحصول على سيجارة جديدة واحدة.\n    تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر،\n    و k هو عدد أعقاب السجائر اللازمة للتبادل للحصول على سيجارة جديدة واحدة.\n    تعيد الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "sw": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n    Peter anaanza na sigara n na anaweza kubadilisha vipande vya sigara k kwa sigara mpya moja.\n    Kazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara,\n    na k ni idadi ya vipande vya sigara vinavyohitajika kubadilisha kwa sigara mpya moja.\n    Kazi inarudisha jumla ya sigara ambazo Peter anaweza kuvuta.\n    Mfano:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "tr": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Peter'ın içebileceği toplam sigara sayısını hesaplar.\n    Peter, n sigara ile başlar ve k izmariti bir yeni sigara ile değiştirebilir.\n    Fonksiyon, iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır,\n    ve k bir yeni sigara ile değiştirmek için gereken izmarit sayısıdır.\n    Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n    Örnek:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "vi": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Tính tổng số điếu thuốc mà Peter có thể hút.\n    Peter bắt đầu với n điếu thuốc và có thể đổi k tàn thuốc để lấy một điếu thuốc mới.\n    Hàm nhận hai tham số, n và k, trong đó n là số điếu thuốc ban đầu,\n    và k là số tàn thuốc cần để đổi lấy một điếu thuốc mới.\n    Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n    Ví dụ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "id": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Menghitung total jumlah rokok yang bisa dihisap Peter.\n    Peter mulai dengan n rokok dan dapat menukar k puntung rokok untuk satu rokok baru.\n    Fungsi ini menerima dua argumen, n dan k, di mana n adalah jumlah awal rokok,\n    dan k adalah jumlah puntung rokok yang dibutuhkan untuk ditukar dengan satu rokok baru.\n    Fungsi ini mengembalikan total jumlah rokok yang bisa dihisap Peter.\n    Contoh:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "ja": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Peterが吸うことができるタバコの総数を計算します。\n    Peterはn本のタバコを持って始め、k個の吸い殻を新しいタバコ1本と交換できます。\n    関数は2つの引数、nとkを取り、nは初期のタバコの本数、\n    kは新しいタバコ1本と交換するために必要な吸い殻の数です。\n    関数はPeterが吸うことができるタバコの総数を返します。\n    例:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "ko": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Peter가 피울 수 있는 총 담배 수를 계산합니다.\n    Peter는 n개의 담배로 시작하며, k개의 꽁초를 새 담배 한 개로 교환할 수 있습니다.\n    이 함수는 두 개의 인수 n과 k를 받으며, n은 초기 담배 수이고,\n    k는 새 담배 한 개로 교환하기 위해 필요한 꽁초의 수입니다.\n    이 함수는 Peter가 피울 수 있는 총 담배 수를 반환합니다.\n    예시:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "ml": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    പീറ്റർ എത്ര സിഗരറ്റുകൾ പുകയ്ക്കുമെന്ന് കണക്കാക്കുന്നു.\n    പീറ്റർ n സിഗരറ്റുകളുമായി ആരംഭിക്കുന്നു, k ബട്ടുകൾ ഒരു പുതിയ സിഗരറ്റ് ലഭിക്കാൻ മാറ്റിക്കൊടുക്കാം.\n    ഈ ഫംഗ്ഷൻ രണ്ട് ആർഗ്യുമെന്റുകൾ സ്വീകരിക്കുന്നു, n, k, n ആരംഭത്തിൽ ഉള്ള സിഗരറ്റുകളുടെ എണ്ണം,\n    k ഒരു പുതിയ സിഗരറ്റ് ലഭിക്കാൻ ആവശ്യമായ സിഗരറ്റ് ബട്ടുകളുടെ എണ്ണം.\n    പീറ്റർ എത്ര സിഗരറ്റുകൾ പുകയ്ക്കാമെന്ന് ഈ ഫംഗ്ഷൻ തിരിച്ചുതരുന്നു.\n    ഉദാഹരണം:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "fa": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    محاسبه می‌کند که پیتر می‌تواند چند سیگار بکشد.\n    پیتر با n سیگار شروع می‌کند و می‌تواند k ته‌سیگار را با یک سیگار جدید عوض کند.\n    این تابع دو آرگومان می‌گیرد، n و k، که n تعداد اولیه سیگارها است\n    و k تعداد ته‌سیگارهایی است که برای تعویض با یک سیگار جدید نیاز است.\n    این تابع تعداد کل سیگارهایی که پیتر می‌تواند بکشد را برمی‌گرداند.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\""}, "canonical_solution": "    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total", "instruction": {"en": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.", "sq": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.", "hy": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nՏվեք Python կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:", "bn": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।", "bg": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.", "zh": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\n请用中文为以下 Python 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。", "fr": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.", "de": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.", "ha": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.", "hi": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।", "hu": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben.", "es": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.", "arb": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.", "sw": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.", "tr": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nPython kodunun işlevselliğini açıklayan en fazla 500 karakterlik öz bir açıklama (docstring) sağlayın.", "vi": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự.", "id": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nBerikan deskripsi singkat dalam bahasa alami (docstring) dari kode Python dalam bahasa Indonesia dengan maksimal 500 karakter.", "ja": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\n以下のPythonコードに対して、500文字以内で簡潔な自然言語の説明（ドックストリング）を日本語で提供してください。", "ko": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\n다음 Python 코드에 대한 간결한 자연어 설명(docstring)을 한국어로 작성하세요. 최대 500자 이내로 작성합니다.", "ml": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nപൈതൺ കോഡിന്റെ സംക്ഷിപ്തമായ സ്വാഭാവിക ഭാഷാ വിവരണം (ഡോക്സ്ട്രിംഗ്) മലയാളത്തിൽ 500 അക്ഷരങ്ങൾക്കുള്ളിൽ നൽകുക.", "fa": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nتوضیح مختصر و طبیعی (docstring) از کد پایتون زیر را به زبان فارسی ارائه دهید که حداکثر ۵۰۰ کاراکتر باشد."}, "level": "", "test": "assert total_smoked_cigarettes(4, 3) == 5\nassert total_smoked_cigarettes(10, 3) == 14\nassert total_smoked_cigarettes(1, 2) == 1  # Peter cannot exchange butts as he starts with less than k\nassert total_smoked_cigarettes(20, 4) == 26\nassert total_smoked_cigarettes(0, 5) == 0  # Peter starts with no cigarettes", "entry_point": "total_smoked_cigarettes", "signature": "def total_smoked_cigarettes(n, k):", "docstring": {"en": "Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "sq": "Llogarit numrin total të cigareve që Peter mund të pijë.\n    Peter fillon me n cigare dhe mund të shkëmbejë k bishta për një cigare të re.\n    Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve,\n    dhe k është numri i bishtave të cigareve të nevojshëm për të shkëmbyer për një cigare të re.\n    Funksioni kthen numrin total të cigareve që Peter mund të pijë.\n    Shembull:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "hy": "Հաշվում է, թե քանի ծխախոտ կարող է ծխել Պետերը:\n    Պետերը սկսում է n ծխախոտով և կարող է փոխանակել k մնացորդները մեկ նոր ծխախոտի համար:\n    Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ը ծխախոտների սկզբնական քանակն է,\n    և k-ը այն ծխախոտի մնացորդների քանակն է, որոնք անհրաժեշտ են մեկ նոր ծխախոտի համար փոխանակելու համար:\n    Ֆունկցիան վերադարձնում է այն ծխախոտների ընդհանուր քանակը, որոնք Պետերը կարող է ծխել:\n    Օրինակ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "bn": "সিগারেটের মোট সংখ্যা গণনা করে যা পিটার ধূমপান করতে পারে।\n    পিটার n সিগারেট দিয়ে শুরু করে এবং k বাট দিয়ে একটি নতুন সিগারেট বিনিময় করতে পারে।\n    ফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা,\n    এবং k হল একটি নতুন সিগারেট বিনিময়ের জন্য প্রয়োজনীয় সিগারেটের বাটের সংখ্যা।\n    ফাংশনটি পিটার কতগুলি সিগারেট ধূমপান করতে পারে তার মোট সংখ্যা প্রদান করে।\n    উদাহরণ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "bg": "Изчислява общия брой цигари, които Петър може да изпуши.  \nПетър започва с n цигари и може да размени k фасове за една нова цигара.  \nФункцията приема два аргумента, n и k, където n е началният брой цигари,  \nа k е броят на фасовете, необходими за размяна за една нова цигара.  \nФункцията връща общия брой цигари, които Петър може да изпуши.  \nПример:  \n>>> total_smoked_cigarettes(4, 3)  \n    5  \n>>> total_smoked_cigarettes(10, 3)  \n    14  ", "zh": "计算 Peter 可以抽的香烟总数。\n    Peter 从 n 支香烟开始，可以用 k 个烟头换一支新香烟。\n    该函数接受两个参数，n 和 k，其中 n 是初始香烟数量，\n    k 是换取一支新香烟所需的烟头数量。\n    该函数返回 Peter 可以抽的香烟总数。\n    示例：\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "fr": "Calcule le nombre total de cigarettes que Peter peut fumer.\n    Peter commence avec n cigarettes et peut échanger k mégots contre une nouvelle cigarette.\n    La fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes,\n    et k est le nombre de mégots de cigarette nécessaires pour échanger contre une nouvelle cigarette.\n    La fonction renvoie le nombre total de cigarettes que Peter peut fumer.\n    Exemple :\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "de": "Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n    Peter beginnt mit n Zigaretten und kann k Kippen gegen eine neue Zigarette eintauschen.\n    Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist,\n    und k die Anzahl der Kippen ist, die für eine neue Zigarette eingetauscht werden müssen.\n    Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n    Beispiel:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "ha": "Yana ƙididdige jimlar adadin sigari da Peter zai iya sha.\n    Peter yana farawa da n sigari kuma zai iya musanya k butts don sabon sigari ɗaya.\n    Aikin yana ɗaukar hujjoji biyu, n da k, inda n shine adadin sigari na farko,\n    kuma k shine adadin bututun sigari da ake buƙata don musanya don sabon sigari ɗaya.\n    Aikin yana mayar da jimlar adadin sigari da Peter zai iya sha.\n    Misali:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "hi": "कुल सिगरेट की संख्या की गणना करता है जो पीटर पी सकता है।  \n    पीटर n सिगरेट के साथ शुरू करता है और एक नई सिगरेट के लिए k बट्स का आदान-प्रदान कर सकता है।  \n    फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेट की संख्या है,  \n    और k वह संख्या है जितने सिगरेट बट्स एक नई सिगरेट के लिए आदान-प्रदान करने की आवश्यकता होती है।  \n    फ़ंक्शन वह कुल सिगरेट की संख्या लौटाता है जो पीटर पी सकता है।  \n    उदाहरण:  \n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "hu": "Kiszámítja, hogy összesen hány cigarettát tud elszívni Péter.\n    Péter n cigarettával kezd, és k csikket tud beváltani egy új cigarettára.\n    A függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigaretták száma,\n    és k a csikkek száma, amelyeket be kell váltani egy új cigarettára.\n    A függvény visszaadja az összes cigaretta számát, amit Péter el tud szívni.\n    Példa:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "es": "Calcula el número total de cigarrillos que Peter puede fumar.\n    Peter comienza con n cigarrillos y puede intercambiar k colillas por un cigarrillo nuevo.\n    La función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos,\n    y k es el número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\n    La función devuelve el número total de cigarrillos que Peter puede fumar.\n    Ejemplo:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "arb": "يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.  \n    يبدأ بيتر بـ n سجائر ويمكنه تبادل k أعقاب للحصول على سيجارة جديدة.  \n    تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر،  \n    و k هو عدد أعقاب السجائر اللازمة للتبادل للحصول على سيجارة جديدة.  \n    تعيد الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.  \n    مثال:  \n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta.  \n    Peter anaanza na sigara n na anaweza kubadilisha vipande k vya sigara kwa sigara mpya moja.  \n    Kazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara,  \n    na k ni idadi ya vipande vya sigara vinavyohitajika kubadilisha kwa sigara mpya moja.  \n    Kazi inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.  \n    Mfano:  \n    >>> total_smoked_cigarettes(4, 3)  \n        5  \n    >>> total_smoked_cigarettes(10, 3)  \n        14  ", "tr": "Peter'ın içebileceği toplam sigara sayısını hesaplar.\n    Peter n sigara ile başlar ve k izmariti bir yeni sigara ile değiştirebilir.\n    Fonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır,\n    ve k bir yeni sigara ile değiştirmek için gereken izmarit sayısıdır.\n    Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n    Örnek:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "vi": "Tính tổng số điếu thuốc mà Peter có thể hút.\n    Peter bắt đầu với n điếu thuốc và có thể đổi k tàn thuốc lấy một điếu thuốc mới.\n    Hàm nhận hai đối số, n và k, trong đó n là số điếu thuốc ban đầu,\n    và k là số tàn thuốc cần để đổi lấy một điếu thuốc mới.\n    Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n    Ví dụ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "id": "Menghitung jumlah total rokok yang bisa dihisap Peter.\n    Peter mulai dengan n rokok dan dapat menukar k puntung untuk satu rokok baru.\n    Fungsi ini menerima dua argumen, n dan k, di mana n adalah jumlah awal rokok,\n    dan k adalah jumlah puntung rokok yang dibutuhkan untuk ditukar dengan satu rokok baru.\n    Fungsi ini mengembalikan jumlah total rokok yang bisa dihisap Peter.\n    Contoh:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "ja": "ピーターが吸えるタバコの総数を計算します。  \nピーターは n 本のタバコを持っており、k 個の吸い殻を新しいタバコ1本と交換できます。  \nこの関数は2つの引数、n と k を取り、n は初期のタバコの本数、k は新しいタバコ1本と交換するために必要な吸い殻の数です。  \nこの関数はピーターが吸えるタバコの総数を返します。  \n例:  \n>>> total_smoked_cigarettes(4, 3)  \n    5  \n>>> total_smoked_cigarettes(10, 3)  \n    14  ", "ko": "Peter가 피울 수 있는 총 담배 수를 계산합니다.  \n    Peter는 n개의 담배로 시작하며, k개의 꽁초를 새 담배 하나로 교환할 수 있습니다.  \n    이 함수는 두 개의 인수 n과 k를 받으며, n은 초기 담배 수이고,  \n    k는 새 담배 하나로 교환하기 위해 필요한 꽁초의 수입니다.  \n    이 함수는 Peter가 피울 수 있는 총 담배 수를 반환합니다.  \n    예시:  \n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "ml": "പീറ്റർ പുകവലിക്കാൻ കഴിയുന്ന മൊത്തം സിഗരറ്റുകളുടെ എണ്ണം കണക്കാക്കുന്നു.\n    പീറ്റർ n സിഗരറ്റുകളുമായി ആരംഭിക്കുന്നു, ഒരു പുതിയ സിഗരറ്റ് നേടാൻ k ബട്ടുകൾ കൈമാറാൻ കഴിയും.\n    ഈ ഫംഗ്ഷൻ രണ്ട് ആർഗ്യൂമെന്റുകൾ സ്വീകരിക്കുന്നു, n, k, n ആരംഭത്തിലെ സിഗരറ്റുകളുടെ എണ്ണം,\n    k ഒരു പുതിയ സിഗരറ്റിന് കൈമാറേണ്ട സിഗരറ്റ് ബട്ടുകളുടെ എണ്ണം.\n    പീറ്റർ പുകവലിക്കാൻ കഴിയുന്ന മൊത്തം സിഗരറ്റുകളുടെ എണ്ണം ഫംഗ്ഷൻ തിരിച്ചുനൽകുന്നു.\n    ഉദാഹരണം:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "fa": "تعداد کل سیگارهایی که پیتر می‌تواند بکشد را محاسبه می‌کند.\n    پیتر با n سیگار شروع می‌کند و می‌تواند k ته‌سیگار را با یک سیگار جدید تعویض کند.\n    این تابع دو آرگومان n و k را می‌پذیرد، که در آن n تعداد اولیه سیگارها است،\n    و k تعداد ته‌سیگارهایی است که برای تعویض با یک سیگار جدید نیاز است.\n    این تابع تعداد کل سیگارهایی که پیتر می‌تواند بکشد را برمی‌گرداند.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14"}}
