{"task_id": "Python/1", "prompt": {"en": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "sq": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit se\n    pragu i dhënë.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "hy": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Ստուգել, արդյոք տրված թվերի ցուցակում կան որևէ երկու թվեր, որոնք միմյանցից ավելի մոտ են,\n    քան տրված շեմը:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "bn": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা একে অপরের থেকে প্রদত্ত সীমার চেয়ে\n    কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "bg": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Проверете дали в дадения списък от числа има някакви две числа, които са по-близо едно до друго\n    от дадения праг.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "zh": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "fr": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Vérifie si, dans la liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que\n    le seuil donné.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "de": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n    der gegebene Schwellenwert.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "ha": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Duba idan a cikin jerin lambobin da aka bayar, akwai wasu lambobi biyu da ke kusa da juna fiye da\n    ƙayyadadden tazara.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "hi": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ एक-दूसरे के अधिक निकट हैं\n    दिए गए सीमा से।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "hu": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Ellenőrizze, hogy a megadott számok listájában van-e bármelyik két szám, amely közelebb van egymáshoz, mint a megadott küszöbérték.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "es": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Verifica si en la lista dada de números, hay dos números más cercanos entre sí que\n    el umbral dado.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "arb": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" تحقق مما إذا كان في قائمة الأرقام المعطاة، يوجد أي رقمين أقرب إلى بعضهما من العتبة المعطاة.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "sw": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Angalia kama katika orodha iliyotolewa ya nambari, kuna nambari mbili zozote zilizo karibu zaidi kuliko\n    kizingiti kilichotolewa.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "tr": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Verilen sayı listesinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol edin.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "vi": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn\n    ngưỡng đã cho hay không.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "id": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Periksa apakah dalam daftar angka yang diberikan, ada dua angka yang lebih dekat satu sama lain daripada\n    ambang batas yang diberikan.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "ja": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 与えられた数値のリストの中で、任意の2つの数値が指定されたしきい値よりも\n    近いかどうかを確認します。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "ko": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 주어진 숫자 목록에서, 두 숫자가 주어진 임계값보다 더 가까운지 확인합니다.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "ml": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" നൽകിയ നമ്പറുകളുടെ പട്ടികയിൽ, ഏതെങ്കിലും രണ്ട് നമ്പറുകൾ തമ്മിൽ നൽകിയ ത്രെഷോൾഡിനേക്കാൾ അടുത്തതാണോ എന്ന് പരിശോധിക്കുക.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "fa": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" بررسی کنید که آیا در لیست داده شده از اعداد، آیا دو عدد وجود دارند که به یکدیگر نزدیکتر از\n    آستانه داده شده باشند.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\""}, "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False", "instruction": {"en": "Write a python function 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' to solve the following problem:\n Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "sq": "Shkruani një funksion python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' për të zgjidhur problemin e mëposhtëm:\n Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa\n    pragu i dhënë.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "hy": "Պայթոն ֆունկցիա 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' գրեք հետևյալ խնդիրը լուծելու համար:\n Ստուգեք, արդյոք տրված թվերի ցուցակում որևէ երկու թիվ ավելի մոտ են միմյանց, քան\n    տրված շեմը։\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "bn": "একটি পাইথন ফাংশন 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n প্রদত্ত সংখ্যার তালিকায় পরীক্ষা করুন, কোনো দুটি সংখ্যা কি একে অপরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "bg": "Напишете Python функция 'def has_close_elements(numbers: List[float], threshold: float) -> bool:', за да решите следния проблем:\n Проверете дали в дадения списък от числа има две числа, които са по-близо едно до друго от\n    дадения праг.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "zh": "编写一个Python函数 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' 来解决以下问题：\n 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "fr": "Écrivez une fonction python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' pour résoudre le problème suivant :\n Vérifiez si, dans la liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que le seuil donné.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "de": "Schreiben Sie eine Python-Funktion 'def has_close_elements(numbers: List[float], threshold: float) -> bool:', um das folgende Problem zu lösen:\n Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "ha": "Rubuta wani aikin python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' don warware matsalar mai zuwa:\n Duba idan a cikin jerin lambobi da aka bayar, akwai wasu lambobi biyu da suke kusa da juna fiye da\n    iyakar da aka bayar.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "hi": "एक पायथन फ़ंक्शन 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n जांचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएं एक-दूसरे के जितनी करीब हैं उतनी जितनी दी गई सीमा है।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "hu": "Írj egy python függvényt 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' a következő probléma megoldására:\n Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám, amely közelebb van egymáshoz, mint a megadott küszöbérték.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "es": "Escribe una función en Python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' para resolver el siguiente problema:\n Verifica si en la lista dada de números, hay dos números más cercanos entre sí que el\n    umbral dado.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "arb": "اكتب دالة بايثون 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' لحل المشكلة التالية:\n تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "sw": "Andika kazi ya python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' kutatua tatizo lifuatalo:\n Angalia kama katika orodha iliyotolewa ya namba, kuna namba zozote mbili zilizo karibu zaidi ya\n    kizingiti kilichopewa.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "tr": "Bir Python fonksiyonu 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' yazarak aşağıdaki problemi çözün:\n Verilen sayı listesindeki herhangi iki sayının\n    verilen eşikten daha yakın olup olmadığını kontrol edin.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "vi": "Viết một hàm python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' để giải quyết vấn đề sau:  \n Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho không.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "id": "Tulis sebuah fungsi python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' untuk menyelesaikan masalah berikut:\n Periksa apakah dalam daftar angka yang diberikan, ada dua angka yang lebih dekat satu sama lain daripada ambang batas yang diberikan.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "ja": "以下の問題を解決するためのPython関数 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' を作成してください:\n 与えられた数値のリストの中で、任意の2つの数値が指定された閾値よりも互いに近いかどうかを確認します。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "ko": "파이썬 함수를 작성하십시오 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' 다음 문제를 해결하기 위해:\n 주어진 숫자 목록에서 주어진 임계값보다 서로 가까운 두 숫자가 있는지 확인하십시오.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "ml": "'def has_close_elements(numbers: List[float], threshold: float) -> bool:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n കൊടുത്തിരിക്കുന്ന നമ്പറുകളുടെ പട്ടികയിൽ, ഏതെങ്കിലും രണ്ട് നമ്പറുകൾ പരസ്പരം\n    നൽകിയിരിക്കുന്ന ത്രെഷോൾഡിനേക്കാൾ അടുത്തതാണോ എന്ന് പരിശോധിക്കുക.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "fa": "یک تابع پایتون بنویسید 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' برای حل مسئله زیر:\n بررسی کنید که آیا در لیست داده شده از اعداد، هیچ دو عددی به یکدیگر نزدیک‌تر از آستانه داده شده هستند یا خیر.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True"}, "level": "easy", "test": "def check(has_close_elements):\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n \ncheck(has_close_elements)", "entry_point": "has_close_elements", "signature": "def has_close_elements(numbers: List[float], threshold: float) -> bool:", "docstring": {"en": " Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "sq": " Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "hy": " Ստուգեք, արդյոք տրված թվերի ցուցակում կան որևէ երկու թվեր, որոնք միմյանց ավելի մոտ են, քան տրված շեմը։\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "bn": " প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা কি দেওয়া থ্রেশহোল্ডের চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "bg": " Проверете дали в дадения списък от числа има две числа, които са по-близо едно до друго от дадения праг.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "zh": " 检查给定数字列表中是否有任意两个数字之间的距离小于给定的阈值。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "fr": " Vérifiez si, dans une liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que le seuil donné.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "de": " Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "ha": " Duba idan a cikin jerin lambobi da aka bayar, akwai wasu lambobi biyu da ke kusa da juna fiye da\n    ƙayyadadden ƙima.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "hi": " दिए गए संख्याओं की सूची में जांचें, क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "hu": " Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám közelebb egymáshoz, mint a megadott küszöbérték.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "es": "Verifica si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "arb": " تحقق مما إذا كان في قائمة الأرقام المعطاة، هل يوجد أي رقمين أقرب إلى بعضهما البعض من العتبة المحددة.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "sw": " Angalia kama katika orodha ya nambari zilizotolewa, kuna nambari mbili zozote ambazo ziko karibu zaidi kuliko kizingiti kilichotolewa.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "tr": " Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "vi": "Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không.", "id": " Periksa apakah dalam daftar angka yang diberikan, ada dua angka yang lebih dekat satu sama lain daripada ambang batas yang diberikan.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "ja": " 指定された数値のリスト内で、任意の2つの数値が指定されたしきい値よりも近いかどうかを確認します。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "ko": "주어진 숫자 목록에서 두 숫자가 주어진 임계값보다 더 가까운지 확인합니다.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "ml": "പങ്കാളിയായ ലിസ്റ്റിൽ ഏതെങ്കിലും രണ്ട് സംഖ്യകൾ നൽകിയ ത്രെഷോൾഡിനേക്കാൾ അടുത്തതായി ഉണ്ടോ എന്ന് പരിശോധിക്കുക.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "fa": " بررسی کنید که آیا در لیست داده شده از اعداد، هیچ دو عددی به یکدیگر نزدیکتر از آستانه داده شده هستند یا خیر.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True"}}
{"task_id": "Python/2", "prompt": {"en": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "sq": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Hyrja në këtë funksion është një varg që përmban grupe të shumta të kllapave të brendshme. Qëllimi juaj është të\n    ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre.\n    Grupet e ndara janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të brendshme brenda njëra-tjetrës.\n    Injoroni çdo hapësirë në vargun e hyrjes.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "hy": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Այս ֆունկցիայի մուտքը տող է, որը պարունակում է մի քանի խմբեր ներդրված փակագծերով: Ձեր նպատակը\n    այդ խմբերը առանձին տողերի բաժանելն է և վերադարձնել դրանց ցուցակը:\n    Առանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակված է) և միմյանց մեջ ներդրված չեն:\n    Անտեսեք մուտքագրված տողի ցանկացած բացատ:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "bn": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" এই ফাংশনের ইনপুট হল একটি স্ট্রিং যা একাধিক গ্রুপের নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল \n    সেই গ্রুপগুলোকে আলাদা স্ট্রিংয়ে বিভক্ত করা এবং সেগুলোর তালিকা ফেরত দেওয়া।\n    আলাদা গ্রুপগুলো সুষম (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়।\n    ইনপুট স্ট্রিংয়ের যেকোনো স্পেস উপেক্ষা করুন।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "bg": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Входът за тази функция е низ, съдържащ няколко групи вложени скоби. Вашата цел е да\n    разделите тези групи на отделни низове и да върнете списък с тях.\n    Отделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\n    Игнорирайте всички интервали в входния низ.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "zh": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" 此函数的输入是一个包含多个嵌套括号组的字符串。你的目标是将这些组分离成独立的字符串，并返回这些字符串的列表。\n    分离的组是平衡的（每个开括号都有正确的闭合）并且不相互嵌套。\n    忽略输入字符串中的任何空格。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "fr": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de\n    séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci.\n    Les groupes séparés sont équilibrés (chaque parenthèse ouverte est correctement fermée) et ne sont pas imbriqués les uns dans les autres.\n    Ignorez tous les espaces dans la chaîne d'entrée.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "de": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Die Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es,\n    diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben.\n    Separate Gruppen sind ausgeglichen (jede öffnende Klammer wird ordnungsgemäß geschlossen) und nicht ineinander verschachtelt.\n    Ignorieren Sie alle Leerzeichen im Eingabestring.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "ha": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Shigar wannan aikin shine wani igiya wanda ke dauke da kungiyoyi da yawa na kowane nau'in kowane nau'in baka. Manufarka ita ce\n    raba waɗannan kungiyoyin zuwa igiyoyi daban-daban kuma dawo da jerin waɗannan.\n    Kungiyoyi daban-daban suna daidaitawa (kowace buɗaɗɗen baka an rufe ta daidai) kuma ba a haɗa su cikin juna ba\n    Yi watsi da duk wani sarari a cikin igiyar shigar.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "hi": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों की नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य है \n    उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करना और उनकी सूची लौटाना।\n    अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।\n    इनपुट स्ट्रिंग में किसी भी स्पेस को नजरअंदाज करें।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "hu": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Ennek a függvénynek a bemenete egy olyan karakterlánc, amely több csoportba rendezett, egymásba ágyazott zárójelet tartalmaz. A cél az,\n    hogy ezeket a csoportokat külön karakterláncokra bontsuk, és visszaadjuk ezek listáját.\n    A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva.\n    Figyelmen kívül hagyja a bemeneti karakterláncban lévő szóközöket.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "es": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es\n    separar esos grupos en cadenas separadas y devolver la lista de estas.\n    Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí.\n    Ignora cualquier espacio en la cadena de entrada.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "arb": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" المدخل لهذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو\n    فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بتلك السلاسل.\n    المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض\n    تجاهل أي مسافات في سلسلة الإدخال.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "sw": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Ingizo kwa kazi hii ni kamba inayo na vikundi vingi vya mabano yaliyopachikwa. Lengo lako ni\n    kutenganisha vikundi hivyo katika kamba tofauti na kurudisha orodha ya hizo.\n    Vikundi vilivyotenganishwa vina uwiano (kila kufungua brace imefungwa ipasavyo) na havijapachikwa ndani ya kila mmoja\n    Puuzia nafasi zozote kwenye kamba ya ingizo.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "tr": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Bu fonksiyona girdi, birden fazla iç içe geçmiş parantez grubunu içeren bir stringdir. Amacınız,\n    bu grupları ayrı stringlere ayırmak ve bunların listesini döndürmektir.\n    Ayrı gruplar dengelidir (her açık parantez düzgün bir şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir.\n    Girdi stringindeki boşlukları göz ardı edin.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "vi": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Đầu vào cho hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là\n    tách các nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó.\n    Các nhóm riêng biệt là cân bằng (mỗi dấu mở đều được đóng đúng cách) và không lồng vào nhau\n    Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "id": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input untuk fungsi ini adalah sebuah string yang mengandung beberapa grup tanda kurung bersarang. Tujuan Anda adalah\n    memisahkan grup-grup tersebut menjadi string terpisah dan mengembalikan daftar dari string-string tersebut.\n    Grup yang terpisah adalah seimbang (setiap kurung buka ditutup dengan benar) dan tidak bersarang satu sama lain.\n    Abaikan spasi apapun dalam string input.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "ja": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" この関数への入力は、複数のネストされた括弧のグループを含む文字列です。あなたの目標は、それらのグループを個別の文字列に分け、それらのリストを返すことです。\n    個別のグループはバランスが取れており（各開き括弧が適切に閉じられている）、互いにネストされていません。\n    入力文字列のスペースは無視してください。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "ko": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" 이 함수의 입력은 여러 그룹의 중첩된 괄호를 포함하는 문자열입니다. 목표는 이러한 그룹을 개별 문자열로 분리하고 그 목록을 반환하는 것입니다.\n    개별 그룹은 균형이 잡혀 있으며(각 열린 괄호는 적절히 닫혀 있음) 서로 중첩되지 않습니다.\n    입력 문자열의 공백은 무시합니다.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "ml": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" ഈ ഫംഗ്ഷനിലേക്ക് ഉള്ള ഇൻപുട്ട് ഒന്നിലധികം ഗ്രൂപ്പുകൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് ആണ്, അവയെ വേർതിരിച്ച് ഓരോ ഗ്രൂപ്പും വേർതിരിച്ച് സ്ട്രിംഗുകളായി മാറ്റി ആ ലിസ്റ്റ് തിരികെ നൽകുക.\n    വേർതിരിച്ച ഗ്രൂപ്പുകൾ സമതുലിതമാണ് (ഓരോ തുറന്ന ബ്രേസും ശരിയായി അടച്ചിരിക്കുന്നു) കൂടാതെ പരസ്പരം നെസ്റ്റഡ് ചെയ്തിട്ടില്ല.\n    ഇൻപുട്ട് സ്ട്രിംഗിലെ സ്പേസുകൾ അവഗണിക്കുക.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "fa": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" ورودی این تابع یک رشته حاوی چندین گروه از پرانتزهای تو در تو است. هدف شما این است که\n    این گروه‌ها را به رشته‌های جداگانه تفکیک کرده و لیستی از آنها را برگردانید.\n    گروه‌های جداگانه متوازن هستند (هر پرانتز باز به درستی بسته می‌شود) و درون یکدیگر تو در تو نیستند.\n    هرگونه فاصله در رشته ورودی را نادیده بگیرید.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\""}, "canonical_solution": "    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result", "instruction": {"en": "Write a python function 'def separate_paren_groups(paren_string: str) -> List[str]:' to solve the following problem:\n Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "sq": "Shkruani një funksion python 'def separate_paren_groups(paren_string: str) -> List[str]:' për të zgjidhur problemin e mëposhtëm:\n Hyrja në këtë funksion është një varg që përmban grupe të shumta të kllapave të folezuara. Qëllimi juaj është të\n    ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre.\n    Grupet e ndara janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të folezuara brenda njëra-tjetrës.\n    Injoroni çdo hapësirë në vargun e hyrjes.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "hy": "Պայթոն ֆունկցիա 'def separate_paren_groups(paren_string: str) -> List[str]:' գրեք հետևյալ խնդիրը լուծելու համար:\n Այս ֆունկցիայի մուտքը տող է, որը պարունակում է փակագծերի մի քանի խմբեր: Ձեր նպատակն է\n    այդ խմբերը առանձնացնել առանձին տողերի մեջ և վերադարձնել դրանց ցուցակը:\n    Առանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակվում է) և միմյանց մեջ ներդրված չեն:\n    Անտեսեք մուտքագրված տողի ցանկացած բացատ:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "bn": "একটি পাইথন ফাংশন 'def separate_paren_groups(paren_string: str) -> List[str]:' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n\nএই ফাংশনের ইনপুট হল একটি স্ট্রিং যা একাধিক গ্রুপের নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল \n    সেই গ্রুপগুলোকে আলাদা স্ট্রিংয়ে বিভক্ত করা এবং তাদের তালিকা ফেরত দেওয়া।\n    আলাদা গ্রুপগুলো সুষম (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়।\n    ইনপুট স্ট্রিংয়ে কোনো স্পেস উপেক্ষা করুন।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "bg": "Напишете Python функция 'def separate_paren_groups(paren_string: str) -> List[str]:' за решаване на следния проблем:\n Входът за тази функция е низ, съдържащ множество групи от вложени скоби. Вашата цел е да\n    разделите тези групи на отделни низове и да върнете списъка с тях.\n    Отделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\n    Игнорирайте всички интервали във входния низ.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "zh": "编写一个Python函数 'def separate_paren_groups(paren_string: str) -> List[str]:' 来解决以下问题：\n\n    此函数的输入是一个包含多个嵌套括号组的字符串。你的目标是将这些组分离成单独的字符串并返回这些字符串的列表。\n    分离的组是平衡的（每个开放括号都正确关闭）并且不相互嵌套。\n    忽略输入字符串中的任何空格。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "fr": "Écrivez une fonction python 'def separate_paren_groups(paren_string: str) -> List[str]:' pour résoudre le problème suivant :\n L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de\n    séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci.\n    Les groupes séparés sont équilibrés (chaque parenthèse ouvrante est correctement fermée) et ne sont pas imbriqués les uns dans les autres.\n    Ignorez tous les espaces dans la chaîne d'entrée.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "de": "Schreiben Sie eine Python-Funktion 'def separate_paren_groups(paren_string: str) -> List[str]:' um das folgende Problem zu lösen:\n Die Eingabe dieser Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es,\n    diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben.\n    Separate Gruppen sind ausgeglichen (jede öffnende Klammer ist korrekt geschlossen) und nicht ineinander verschachtelt.\n    Ignorieren Sie alle Leerzeichen im Eingabestring.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "ha": "Rubuta wani aikin python 'def separate_paren_groups(paren_string: str) -> List[str]:' don warware matsalar mai zuwa:\n Shigar da wannan aikin shi ne wani igiyar rubutu mai dauke da rukuni da dama na kowane irin baka. Burinka shi ne\n    raba wadannan rukuni zuwa igiyoyi daban-daban kuma dawo da jerin su.\n    Rukunan da aka raba suna daidaita (kowace buɗewa tana da rufewa daidai) kuma ba a nannade su cikin juna ba\n    Yi watsi da duk wani sarari a cikin igiyar shigarwa.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "hi": "एक पायथन फ़ंक्शन 'def separate_paren_groups(paren_string: str) -> List[str]:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों की नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य है कि\n    उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करें और उनकी सूची लौटाएं।\n    अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।\n    इनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "hu": "Írj egy Python függvényt 'def separate_paren_groups(paren_string: str) -> List[str]:', hogy megoldja a következő problémát:\n Ennek a függvénynek a bemenete egy olyan karakterlánc, amely több csoportot tartalmaz egymásba ágyazott zárójelekből. A célod az,\n    hogy ezeket a csoportokat külön karakterláncokra bontsd, és visszaadd ezek listáját.\n    A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva.\n    Hagyd figyelmen kívül a bemeneti karakterláncban lévő szóközöket.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "es": "Escribe una función en Python 'def separate_paren_groups(paren_string: str) -> List[str]:' para resolver el siguiente problema:\n La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es\n    separar esos grupos en cadenas separadas y devolver la lista de estas.\n    Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí.\n    Ignora cualquier espacio en la cadena de entrada.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "arb": "اكتب دالة بايثون 'def separate_paren_groups(paren_string: str) -> List[str]:' لحل المشكلة التالية:\n المدخلات لهذه الدالة هي سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو\n    فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بتلك السلاسل.\n    المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض.\n    تجاهل أي مسافات في سلسلة المدخلات.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "sw": "Andika kazi ya python 'def separate_paren_groups(paren_string: str) -> List[str]:' kutatua tatizo lifuatalo:\n Ingizo kwa kazi hii ni kamba inayojumuisha vikundi vingi vya mabano yaliyojificha. Lengo lako ni\n    kutenganisha vikundi hivyo kuwa kamba tofauti na kurudisha orodha ya hizo.\n    Vikundi vilivyotenganishwa vina usawa (kila mabano ya kufungua yanafungwa ipasavyo) na havijajificha ndani ya kila kimoja\n    Puuza nafasi zozote kwenye kamba ya ingizo.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "tr": "Bir python fonksiyonu 'def separate_paren_groups(paren_string: str) -> List[str]:' yazın ve aşağıdaki problemi çözün:\n Bu fonksiyona giriş, birden fazla iç içe geçmiş parantez grubu içeren bir stringdir. Amacınız bu grupları ayrı stringlere ayırmak ve bunların listesini döndürmektir.\n    Ayrı gruplar dengelidir (her açık parantez düzgün bir şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir.\n    Giriş stringindeki boşlukları yok sayın.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "vi": "Viết một hàm python 'def separate_paren_groups(paren_string: str) -> List[str]:' để giải quyết vấn đề sau:\n Đầu vào của hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là\n    tách các nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó.\n    Các nhóm riêng biệt là cân bằng (mỗi dấu mở được đóng đúng cách) và không lồng vào nhau\n    Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "id": "Tulis fungsi python 'def separate_paren_groups(paren_string: str) -> List[str]:' untuk menyelesaikan masalah berikut:\n Input untuk fungsi ini adalah sebuah string yang mengandung beberapa kelompok tanda kurung bersarang. Tujuan Anda adalah untuk\n    memisahkan kelompok-kelompok tersebut menjadi string terpisah dan mengembalikan daftar dari string-string tersebut.\n    Kelompok terpisah adalah seimbang (setiap tanda kurung buka ditutup dengan benar) dan tidak bersarang satu sama lain.\n    Abaikan spasi apa pun dalam string input.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "ja": "Python関数 'def separate_paren_groups(paren_string: str) -> List[str]:' を作成して、次の問題を解決してください:\n この関数への入力は、複数のネストされた括弧のグループを含む文字列です。あなたの目標は、\n    それらのグループを個別の文字列に分け、それらのリストを返すことです。\n    個別のグループはバランスが取れており（各開き括弧は適切に閉じられている）、互いにネストされていません。\n    入力文字列のスペースは無視してください。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "ko": "다음 문제를 해결하기 위해 'def separate_paren_groups(paren_string: str) -> List[str]:'라는 파이썬 함수를 작성하세요:\n 이 함수의 입력은 여러 그룹의 중첩된 괄호를 포함하는 문자열입니다. 목표는 이러한 그룹을 개별 문자열로 분리하고 그 목록을 반환하는 것입니다.\n    개별 그룹은 균형 잡혀 있으며(각 열린 괄호는 제대로 닫혀 있음) 서로 중첩되지 않습니다.\n    입력 문자열의 공백은 무시합니다.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "ml": "Python ഫംഗ്ഷൻ 'def separate_paren_groups(paren_string: str) -> List[str]:' എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n ഈ ഫംഗ്ഷനിൽ ഇൻപുട്ട് ഒരു സ്ട്രിംഗ് ആണ്, ഇത് പല ഗ്രൂപ്പുകളിലായി നൊസ്റ്റഡ് പാരന്റീസിസുകൾ അടങ്ങിയിരിക്കുന്നു. നിങ്ങളുടെ ലക്ഷ്യം\n    ആ ഗ്രൂപ്പുകൾ വേർതിരിച്ച് വ്യത്യസ്ത സ്ട്രിംഗുകളായി മാറ്റി അവയുടെ ലിസ്റ്റ് മടക്കിനൽകുക എന്നതാണ്.\n    വേർതിരിച്ച ഗ്രൂപ്പുകൾ ബാലൻസ്ഡ് ആണ് (ഓരോ ഓപ്പൺ ബ്രേസ്-നും ശരിയായി ക്ലോസ് ചെയ്തിരിക്കുന്നു) കൂടാതെ പരസ്പരം നൊസ്റ്റഡ് ആയിട്ടില്ല.\n    ഇൻപുട്ട് സ്ട്രിംഗിലെ ഏതെങ്കിലും സ്പേസുകൾ അവഗണിക്കുക.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "fa": "یک تابع پایتون 'def separate_paren_groups(paren_string: str) -> List[str]:' بنویسید تا مسئله زیر را حل کند:\nورودی این تابع یک رشته است که شامل چندین گروه از پرانتزهای تو در تو می‌باشد. هدف شما این است که\n    این گروه‌ها را به رشته‌های جداگانه تقسیم کرده و لیستی از آن‌ها را برگردانید.\n    گروه‌های جداگانه متوازن هستند (هر پرانتز باز به درستی بسته می‌شود) و درون یکدیگر تو در تو نیستند.\n    هرگونه فضای خالی در رشته ورودی را نادیده بگیرید.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']"}, "level": "hard", "test": "def check(separate_paren_groups):\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n    '(()())', '((()))', '()', '((())()())'\n    ]\n    assert separate_paren_groups('() (()) ((())) (((())))') == [\n    '()', '(())', '((()))', '(((())))'\n    ]\n    assert separate_paren_groups('(()(())((())))') == [\n    '(()(())((())))'\n    ]\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n \ncheck(separate_paren_groups)", "entry_point": "separate_paren_groups", "signature": "def separate_paren_groups(paren_string: str) -> List[str]:", "docstring": {"en": " Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "sq": " Hyrja për këtë funksion është një varg që përmban grupe të shumta të kllapave të folezuara. Qëllimi juaj është të ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre.\n    Grupet e veçanta janë të balancuara (çdo kllapë e hapur është mbyllur si duhet) dhe nuk janë të folezuara brenda njëra-tjetrës.\n    Injoroni çdo hapësirë në vargun e hyrjes.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "hy": " Այս ֆունկցիայի մուտքը տող է, որը պարունակում է փակագծերի մի քանի խումբ։ Ձեր նպատակն է այդ խմբերը բաժանել առանձին տողերի և վերադարձնել դրանց ցուցակը։  \n    Առանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակվում է) և միմյանց մեջ չեն ներդրված։  \n    Անտեսեք մուտքային տողի ցանկացած բացատ։  \n    >>> separate_paren_groups('( ) (( )) (( )( ))')  \n    ['()', '(())', '(()())']\n    ", "bn": " এই ফাংশনের ইনপুট হল একটি স্ট্রিং যা একাধিক গোষ্ঠীর নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল সেই গোষ্ঠীগুলিকে আলাদা স্ট্রিংয়ে বিভক্ত করা এবং তাদের তালিকা ফেরত দেওয়া।\n    পৃথক গোষ্ঠীগুলি সুষম (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়\n    ইনপুট স্ট্রিংয়ে কোনো স্পেস উপেক্ষা করুন।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "bg": " Входът за тази функция е низ, съдържащ множество групи вложени скоби. Вашата цел е да\n    разделите тези групи на отделни низове и да върнете списък с тях.\n    Отделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\n    Игнорирайте всички интервали в входния низ.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "zh": " 函数的输入是一个包含多个嵌套括号组的字符串。你的目标是将这些组分离成单独的字符串，并返回这些字符串的列表。\n    分离的组是平衡的（每个打开的括号都有正确的闭合）且不相互嵌套。\n    忽略输入字符串中的任何空格。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "fr": " L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci. Les groupes séparés sont équilibrés (chaque parenthèse ouvrante est correctement fermée) et ne sont pas imbriqués les uns dans les autres. Ignorez tous les espaces dans la chaîne d'entrée.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "de": " Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es, diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben. \n    Separate Gruppen sind ausgeglichen (jede öffnende Klammer wird korrekt geschlossen) und nicht ineinander verschachtelt. \n    Ignorieren Sie alle Leerzeichen im Eingabestring.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "ha": " Shigar da wannan aikin shine wani kirtani wanda ya ƙunshi rukuni da yawa na zoben baka da aka nannade. Manufarka ita ce\n    raba waɗannan rukunin zuwa kirtani daban-daban kuma dawo da jerin waɗannan.\n    Rukuni daban-daban suna daidaitawa (kowace buɗaɗɗen baka an rufe ta daidai) kuma ba a nannade su cikin juna ba\n    Yi watsi da duk wani sarari a cikin kirtanin shigarwa.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "hi": " इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों के नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करना और उन स्ट्रिंग्स की सूची लौटाना है। \n    अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं। \n    इनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ", "hu": " A függvény bemenete egy olyan karakterlánc, amely több, egymásba ágyazott zárójelet tartalmaz. A cél az, hogy ezeket a csoportokat külön karakterláncokra bontsuk, és visszaadjuk ezek listáját. A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva. Figyelmen kívül hagyjuk a bemeneti karakterláncban lévő szóközöket. >>> separate_paren_groups('( ) (( )) (( )( ))') ['()', '(())', '(()())']\n    ", "es": "La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es separar esos grupos en cadenas separadas y devolver la lista de estas. Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí. Ignora cualquier espacio en la cadena de entrada.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "arb": "مدخل هذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بها. \nالمجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض. \nتجاهل أي مسافات في سلسلة المدخلات.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "sw": "Ingizo kwa kazi hii ni kamba inayojumuisha makundi mengi ya mabano yaliyopachikwa. Lengo lako ni\n    kutenganisha makundi hayo katika kamba tofauti na kurudisha orodha ya hizo.\n    Makundi tofauti yamebalansiwa (kila kufungua brace imefungwa ipasavyo) na hayajapachikwa ndani ya kila moja\n    Puuza nafasi zozote katika kamba ya ingizo.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "tr": "Bu fonksiyonun girdisi, birden fazla iç içe geçmiş parantez grubunu içeren bir dizedir. Amacınız, bu grupları ayrı dizelere ayırmak ve bunların listesini döndürmektir.\n    Ayrı gruplar dengelidir (her açma parantezi düzgün bir şekilde kapatılır) ve birbirlerinin içinde iç içe değildir.\n    Girdi dizesindeki boşlukları yok sayın.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "vi": "Đầu vào cho hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là tách các nhóm đó thành các chuỗi riêng biệt và trả về danh sách của chúng. Các nhóm riêng biệt là cân bằng (mỗi dấu mở ngoặc được đóng đúng cách) và không lồng vào nhau. Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "id": "Input untuk fungsi ini adalah string yang berisi beberapa kelompok tanda kurung bersarang. Tujuan Anda adalah untuk memisahkan kelompok-kelompok tersebut menjadi string terpisah dan mengembalikan daftar dari kelompok-kelompok tersebut. Kelompok yang terpisah seimbang (setiap kurung buka ditutup dengan benar) dan tidak bersarang satu sama lain. Abaikan spasi apa pun dalam string input.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "ja": "この関数への入力は、複数のグループのネストされた括弧を含む文字列です。あなたの目標は、それらのグループを個別の文字列に分け、それらのリストを返すことです。\n    個別のグループはバランスが取れており（各開き括弧は適切に閉じられている）、互いにネストされていません。\n    入力文字列のスペースは無視してください。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "ko": "이 함수의 입력은 여러 그룹의 중첩된 괄호를 포함하는 문자열입니다. 목표는 이러한 그룹을 개별 문자열로 분리하고 그 목록을 반환하는 것입니다.\n    개별 그룹은 균형이 잡혀 있으며(각 열린 괄호는 적절히 닫혀 있음) 서로 중첩되지 않습니다.\n    입력 문자열의 공백은 무시합니다.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "ml": "ഈ ഫംഗ്ഷന്‍റെ ഇൻപുട്ട് പല ഗ്രൂപ്പുകളിലായി നിക്ഷിപ്തമായ വക്രകോഷ്ടകങ്ങൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് ആണ്. നിങ്ങളുടെ ലക്ഷ്യം ആ ഗ്രൂപ്പുകൾ വേർതിരിച്ച് വ്യത്യസ്ത സ്ട്രിംഗുകളായി മാറ്റി അവയുടെ പട്ടിക തിരിച്ചുനൽകുക എന്നതാണ്. വേർതിരിച്ച ഗ്രൂപ്പുകൾ സുതാര്യമാണ് (ഓരോ തുറന്ന കോഷ്ടകവും ശരിയായി അടയ്ക്കപ്പെട്ടിരിക്കുന്നു) കൂടാതെ പരസ്പരം നിക്ഷിപ്തമായിട്ടില്ല. ഇൻപുട്ട് സ്ട്രിംഗിലെ ഏതെങ്കിലും സ്പേസുകൾ അവഗണിക്കുക.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']", "fa": "ورودی این تابع یک رشته شامل چندین گروه از پرانتزهای تو در تو است. هدف شما این است که\n    آن گروه‌ها را به رشته‌های جداگانه تقسیم کرده و لیستی از آن‌ها را برگردانید.\n    گروه‌های جداگانه متوازن هستند (هر پرانتز باز به درستی بسته شده است) و درون یکدیگر تو در تو نیستند.\n    هرگونه فضای خالی در رشته ورودی را نادیده بگیرید.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']"}}
{"task_id": "Python/3", "prompt": {"en": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "sq": "def truncate_number(number: float) -> float:\n    \"\"\" Duke dhënë një numër pozitiv me presje dhjetore, ai mund të dekompozohet në\n    pjesën e plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetoret\n    (pjesa e mbetur gjithmonë më e vogël se 1).\n    \n    Kthen pjesën dhjetore të numrit.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "hy": "def truncate_number(number: float) -> float:\n    \"\"\" Տրված դրական տասնորդական թիվը կարելի է բաժանել ամբողջ մասի \n    (ամենամեծ ամբողջ թիվը, որը փոքր է տրված թվից) և տասնորդականների \n    (մնացորդային մասը, որը միշտ փոքր է 1-ից):\n    \n    Վերադարձնել թվի տասնորդական մասը:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "bn": "def truncate_number(number: float) -> float:\n    \"\"\" একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা দেওয়া হলে, এটি একটি পূর্ণসংখ্যা অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্টাংশ যা সর্বদা 1-এর চেয়ে ছোট) বিভক্ত করা যায়।\n    \n    সংখ্যার দশমিক অংশটি ফেরত দিন।\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "bg": "def truncate_number(number: float) -> float:\n    \"\"\" Дадено е положително число с плаваща запетая, което може да бъде \n    разложено на цяла част (най-голямото цяло число, по-малко от даденото число) и \n    десетична част (остатък, който винаги е по-малък от 1).\n    \n    Връща десетичната част на числото.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "zh": "def truncate_number(number: float) -> float:\n    \"\"\" 给定一个正浮点数，它可以被分解为整数部分（小于给定数的最大整数）和小数部分（总是小于1的剩余部分）。\n    \n    返回该数的小数部分。\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "fr": "def truncate_number(number: float) -> float:\n    \"\"\" Étant donné un nombre flottant positif, il peut être décomposé en\n    une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales\n    (partie restante toujours inférieure à 1).\n    \n    Retourne la partie décimale du nombre.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "de": "def truncate_number(number: float) -> float:\n    \"\"\" Gegeben eine positive Fließkommazahl, kann sie in einen ganzzahligen \n    Teil (größte ganze Zahl, die kleiner als die gegebene Zahl ist) und Dezimalstellen \n    (Restteil, der immer kleiner als 1 ist) zerlegt werden.\n    \n    Gibt den Dezimalteil der Zahl zurück.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "ha": "def truncate_number(number: float) -> float:\n    \"\"\" An ba da lamba mai yawo mai kyau, za a iya raba shi zuwa\n    wani ɓangare na cikakken lamba (mafi girman cikakken lamba ƙasa da lambar da aka bayar) da kuma ragowar\n    (ɓangaren da ya rage koyaushe ƙasa da 1).\n    \n    Mayar da ɓangaren ragowar lambar.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "hi": "def truncate_number(number: float) -> float:\n    \"\"\" दिए गए एक धनात्मक फ्लोटिंग पॉइंट संख्या को एक पूर्णांक भाग (दिए गए संख्या से छोटा सबसे बड़ा पूर्णांक) \n    और दशमलव में विभाजित किया जा सकता है (हमेशा 1 से छोटा बचा हुआ भाग)।\n    \n    संख्या के दशमलव भाग को लौटाएं।\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "hu": "def truncate_number(number: float) -> float:\n    \"\"\" Adott egy pozitív lebegőpontos szám, amely felbontható egy\n    egész részre (a megadott számnál kisebb legnagyobb egész szám) és tizedesjegyekre\n    (a maradék rész mindig kisebb, mint 1).\n    \n    Visszaadja a szám tizedes részét.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "es": "def truncate_number(number: float) -> float:\n    \"\"\" Dado un número de punto flotante positivo, se puede descomponer en\n    una parte entera (el mayor entero menor que el número dado) y decimales\n    (parte restante siempre menor que 1).\n    \n    Devuelve la parte decimal del número.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "arb": "def truncate_number(number: float) -> float:\n    \"\"\" بالنظر إلى عدد عشري موجب، يمكن تحليله إلى\n    جزء صحيح (أكبر عدد صحيح أصغر من العدد المعطى) وأجزاء عشرية\n    (الجزء المتبقي دائماً أصغر من 1).\n    \n    إرجاع الجزء العشري من العدد.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "sw": "def truncate_number(number: float) -> float:\n    \"\"\" Ukipewa namba chanya ya nukta, inaweza kugawanywa katika\n    sehemu ya namba kamili (namba kamili kubwa zaidi iliyo ndogo kuliko namba iliyotolewa) na desimali\n    (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n    \n    Rudisha sehemu ya desimali ya namba.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "tr": "def truncate_number(number: float) -> float:\n    \"\"\" Pozitif bir ondalık sayının, bir tamsayı kısmına (verilen sayıdan küçük en büyük tamsayı)\n    ve ondalıklara (her zaman 1'den küçük kalan kısım) ayrılabileceği verilmiştir.\n    \n    Sayının ondalık kısmını döndür.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "vi": "def truncate_number(number: float) -> float:\n    \"\"\" Cho một số thực dương, nó có thể được phân tách thành\n    phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n    (phần còn lại luôn nhỏ hơn 1).\n    \n    Trả về phần thập phân của số.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "id": "def truncate_number(number: float) -> float:\n    \"\"\" Diberikan sebuah bilangan titik mengambang positif, bilangan tersebut dapat diuraikan menjadi\n    bagian bilangan bulat (bilangan bulat terbesar yang lebih kecil dari bilangan yang diberikan) dan desimal\n    (bagian sisa yang selalu lebih kecil dari 1).\n    \n    Mengembalikan bagian desimal dari bilangan tersebut.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "ja": "def truncate_number(number: float) -> float:\n    \"\"\" 正の浮動小数点数が与えられた場合、それは整数部分（与えられた数より小さい最大の整数）と\n    小数部分（常に1より小さい残りの部分）に分解できます。\n    \n    数の小数部分を返します。\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "ko": "def truncate_number(number: float) -> float:\n    \"\"\" 양의 부동 소수점 수가 주어지면, 이는 정수 부분(주어진 수보다 작은 가장 큰 정수)과\n    소수 부분(항상 1보다 작은 나머지 부분)으로 분해될 수 있습니다.\n    \n    숫자의 소수 부분을 반환합니다.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "ml": "def truncate_number(number: float) -> float:\n    \"\"\" ഒരു പോസിറ്റീവ് ഫ്ലോട്ടിംഗ് പോയിന്റ് സംഖ്യ നൽകിയാൽ, \n    അത് ഒരു പൂർണ്ണസംഖ്യാ ഭാഗത്തിലും (നൽകിയ സംഖ്യയേക്കാൾ ചെറിയ ഏറ്റവും വലിയ പൂർണ്ണസംഖ്യ) \n    ഡെസിമൽ ഭാഗത്തിലും (എപ്പോഴും 1-ലേക്കാൾ ചെറിയ ശേഷിക്കുന്ന ഭാഗം) വിഭജിക്കാം.\n    \n    സംഖ്യയുടെ ഡെസിമൽ ഭാഗം മടക്കിനൽകുക.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "fa": "def truncate_number(number: float) -> float:\n    \"\"\" با توجه به یک عدد اعشاری مثبت، می‌توان آن را به یک بخش صحیح \n    (بزرگترین عدد صحیح کوچکتر از عدد داده شده) و اعشار \n    (بخش باقی‌مانده که همیشه کوچکتر از 1 است) تجزیه کرد.\n    \n    بخش اعشاری عدد را برگردانید.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\""}, "canonical_solution": "    return number % 1.0", "instruction": {"en": "Write a python function 'def truncate_number(number: float) -> float:' to solve the following problem:\n Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    ", "sq": "Shkruani një funksion python 'def truncate_number(number: float) -> float:' për të zgjidhur problemin e mëposhtëm:\n Duke pasur një numër pozitiv me pikë lundruese, ai mund të dekompozohet në\n    një pjesë të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetore\n    (pjesa e mbetur gjithmonë më e vogël se 1).\n    \n    Kthe pjesën dhjetore të numrit.\n    >>> truncate_number(3.5)\n    0.5\n    ", "hy": "Պայթոն ֆունկցիա 'def truncate_number(number: float) -> float:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Տրված դրական լողացող կետով թիվը կարելի է բաժանել\n    ամբողջ մասի (տրված թվից փոքր ամենամեծ ամբողջ թիվը) և տասնորդական մասի\n    (մնացորդային մասը միշտ փոքր է 1-ից):\n\n    Վերադարձնել թվի տասնորդական մասը:\n    >>> truncate_number(3.5)\n    0.5\n    ", "bn": "একটি পাইথন ফাংশন 'def truncate_number(number: float) -> float:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা দেওয়া হলে, এটি একটি পূর্ণসংখ্যা অংশে (দেওয়া সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্ট অংশ সর্বদা 1 এর চেয়ে ছোট) বিভক্ত করা যেতে পারে।\n    \n    সংখ্যার দশমিক অংশটি ফেরত দিন।\n    >>> truncate_number(3.5)\n    0.5\n    ", "bg": "Напишете Python функция 'def truncate_number(number: float) -> float:', за да решите следния проблем:\n Дадено е положително число с плаваща запетая, което може да бъде разложено на\n    цяла част (най-голямото цяло число, по-малко от даденото число) и десетични\n    (оставаща част, винаги по-малка от 1).\n    \n    Върнете десетичната част на числото.\n    >>> truncate_number(3.5)\n    0.5\n    ", "zh": "编写一个Python函数 'def truncate_number(number: float) -> float:' 来解决以下问题：\n\n 给定一个正浮点数，它可以分解为整数部分（小于给定数的最大整数）和小数部分（剩余部分总是小于1）。\n    \n 返回该数的小数部分。\n    >>> truncate_number(3.5)\n    0.5\n    ", "fr": "Écrivez une fonction python 'def truncate_number(number: float) -> float:' pour résoudre le problème suivant :\n Étant donné un nombre à virgule flottante positif, il peut être décomposé en\n    une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales\n    (partie restante toujours inférieure à 1).\n    \n    Retournez la partie décimale du nombre.\n    >>> truncate_number(3.5)\n    0.5\n    ", "de": "Schreiben Sie eine Python-Funktion 'def truncate_number(number: float) -> float:', um das folgende Problem zu lösen:\n Gegeben eine positive Gleitkommazahl, kann sie in einen ganzzahligen Teil (größte ganze Zahl, die kleiner als die gegebene Zahl ist) und Dezimalstellen (übrig bleibender Teil, der immer kleiner als 1 ist) zerlegt werden.\n    \n    Geben Sie den Dezimalteil der Zahl zurück.\n    >>> truncate_number(3.5)\n    0.5\n    ", "ha": "Rubuta wani aikin python 'def truncate_number(number: float) -> float:' don warware matsalar mai zuwa:\n An ba da lamba mai kyau mai iyo, za a iya raba ta zuwa\n    kuma ɓangaren cikakken lamba (mafi girman cikakken lamba fiye da lambar da aka bayar) da ƙananan lambobi\n    (ɓangaren da ya rage koyaushe ya fi 1 ƙanƙanta).\n    \n    Mayar da ɓangaren ƙananan lambobi na lambar.\n    >>> truncate_number(3.5)\n    0.5\n    ", "hi": "एक पायथन फ़ंक्शन 'def truncate_number(number: float) -> float:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n दिए गए धनात्मक फ्लोटिंग पॉइंट संख्या को तोड़ा जा सकता है\n    और पूर्णांक भाग (दिए गए संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलव\n    (बचा हुआ भाग हमेशा 1 से छोटा होता है) में।\n    \n    संख्या के दशमलव भाग को लौटाएं।\n    >>> truncate_number(3.5)\n    0.5\n    ", "hu": "Írj egy python függvényt 'def truncate_number(number: float) -> float:' a következő probléma megoldására:\n\n    Adott egy pozitív lebegőpontos szám, amely felbontható egy\n    egész részre (a megadott számnál kisebb legnagyobb egész szám) és tizedesjegyekre\n    (a maradék rész mindig kisebb, mint 1).\n    \n    Add vissza a szám tizedes részét.\n    >>> truncate_number(3.5)\n    0.5\n    ", "es": "Escribe una función de Python 'def truncate_number(number: float) -> float:' para resolver el siguiente problema:\n Dado un número de punto flotante positivo, se puede descomponer en\n    una parte entera (el entero más grande menor que el número dado) y decimales\n    (parte sobrante siempre menor que 1).\n    \n    Devuelve la parte decimal del número.\n    >>> truncate_number(3.5)\n    0.5", "arb": "اكتب دالة بايثون 'def truncate_number(number: float) -> float:' لحل المشكلة التالية:\n  بالنظر إلى رقم عشري موجب، يمكن تقسيمه إلى\n    جزء صحيح (أكبر عدد صحيح أصغر من الرقم المعطى) وعشري\n    (الجزء المتبقي دائماً أصغر من 1).\n    \n    أعد الجزء العشري من الرقم.\n    >>> truncate_number(3.5)\n    0.5", "sw": "Andika kazi ya python 'def truncate_number(number: float) -> float:' kutatua tatizo lifuatalo:\n Kwa kuzingatia nambari chanya ya nukta inayoyeyuka, inaweza kugawanywa katika\n    sehemu ya nambari kamili (nambari kubwa zaidi ndogo kuliko nambari iliyotolewa) na desimali\n    (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n    \n    Rudisha sehemu ya desimali ya nambari.\n    >>> truncate_number(3.5)\n    0.5", "tr": "Bir python fonksiyonu 'def truncate_number(number: float) -> float:' yazın ve aşağıdaki problemi çözün:\n Verilen pozitif bir ondalık sayı, bir tam sayı kısmına (verilen sayıdan küçük en büyük tam sayı) ve ondalıklara (her zaman 1'den küçük kalan kısım) ayrılabilir.\n    \n    Sayının ondalık kısmını döndürün.\n    >>> truncate_number(3.5)\n    0.5", "vi": "Viết một hàm python 'def truncate_number(number: float) -> float:' để giải quyết vấn đề sau:  \n Cho một số thực dương, nó có thể được phân tách thành  \n    phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân  \n    (phần còn lại luôn nhỏ hơn 1).\n    \n    Trả về phần thập phân của số đó.\n    >>> truncate_number(3.5)\n    0.5", "id": "Tulis fungsi python 'def truncate_number(number: float) -> float:' untuk menyelesaikan masalah berikut:\n Diberikan sebuah bilangan floating point positif, bilangan tersebut dapat diuraikan menjadi\n    bagian bilangan bulat (bilangan bulat terbesar yang lebih kecil dari bilangan yang diberikan) dan desimal\n    (bagian sisa yang selalu lebih kecil dari 1).\n    \n    Kembalikan bagian desimal dari bilangan tersebut.\n    >>> truncate_number(3.5)\n    0.5", "ja": "Python関数 'def truncate_number(number: float) -> float:' を作成して、次の問題を解決してください:\n 正の浮動小数点数が与えられた場合、それは整数部分（与えられた数より小さい最大の整数）と小数部分（常に1未満の残りの部分）に分解できます。\n\n    数の小数部分を返します。\n    >>> truncate_number(3.5)\n    0.5", "ko": "파이썬 함수를 작성하시오 'def truncate_number(number: float) -> float:' 다음 문제를 해결하기 위해:\n 주어진 양의 부동 소수점 숫자는 정수 부분(주어진 숫자보다 작은 가장 큰 정수)과 소수 부분(항상 1보다 작은 나머지 부분)으로 분해될 수 있습니다.\n    \n    숫자의 소수 부분을 반환합니다.\n    >>> truncate_number(3.5)\n    0.5", "ml": "'def truncate_number(number: float) -> float:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\nഒരു പോസിറ്റീവ് ഫ്ലോട്ടിംഗ് പോയിന്റ് സംഖ്യ നൽകിയാൽ, അത് ഒരു പൂർണ്ണസംഖ്യാ ഭാഗത്തിലും (നൽകിയിരിക്കുന്ന സംഖ്യയേക്കാൾ ചെറിയ ഏറ്റവും വലിയ പൂർണ്ണസംഖ്യ) ഡെസിമൽ ഭാഗത്തിലും (എപ്പോഴും 1-ലേക്കാൾ ചെറിയ ശേഷിക്കുന്ന ഭാഗം) വിഭജിക്കാം.\n\nസംഖ്യയുടെ ഡെസിമൽ ഭാഗം മടക്കുക.\n>>> truncate_number(3.5)\n0.5", "fa": "یک تابع پایتون بنویسید 'def truncate_number(number: float) -> float:' برای حل مسئله زیر:\n با توجه به یک عدد اعشاری مثبت، می‌توان آن را به یک قسمت صحیح (بزرگترین عدد صحیح کوچکتر از عدد داده شده) و اعشار (قسمت باقی‌مانده که همیشه کوچکتر از 1 است) تجزیه کرد.\n    \n    قسمت اعشاری عدد را برگردانید.\n    >>> truncate_number(3.5)\n    0.5"}, "level": "easy", "test": "def check(truncate_number):\n    assert truncate_number(3.5) == 0.5\n    assert abs(truncate_number(1.33) - 0.33) < 1e-6\n    assert abs(truncate_number(123.456) - 0.456) < 1e-6\n \ncheck(truncate_number)", "entry_point": "truncate_number", "signature": "def truncate_number(number: float) -> float:", "docstring": {"en": " Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    ", "sq": " Duke pasur një numër pozitiv me presje dhjetore, ai mund të dekompozohet në\n    një pjesë të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetore\n    (pjesa e mbetur gjithmonë më e vogël se 1).\n    \n    Kthe pjesën dhjetore të numrit.\n    >>> truncate_number(3.5)\n    0.5\n    ", "hy": " Տրված դրական տասնորդական կետով թիվը կարելի է բաժանել ամբողջ մասի (տրված թվից փոքրագույն ամբողջ թիվ) և տասնորդական մասի (մնացորդային մաս, որը միշտ փոքր է 1-ից)։\n\n    Վերադարձնել թվի տասնորդական մասը։\n    >>> truncate_number(3.5)\n    0.5\n    ", "bn": " প্রদত্ত একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা, এটি ভাঙা যেতে পারে একটি পূর্ণসংখ্যার অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্ট অংশ সবসময় ১ এর চেয়ে ছোট)।\n\n    সংখ্যার দশমিক অংশ ফেরত দিন।\n    >>> truncate_number(3.5)\n    0.5\n    ", "bg": " Дадено е положително число с плаваща запетая, то може да бъде разложено на\n    цяла част (най-голямото цяло число, по-малко от даденото число) и десетични\n    (оставаща част, винаги по-малка от 1).\n    \n    Върнете десетичната част на числото.\n    >>> truncate_number(3.5)\n    0.5\n    ", "zh": " 给定一个正浮点数，可以将其分解为整数部分（小于给定数的最大整数）和小数部分（剩余部分总是小于1）。\n    \n    返回该数的小数部分。\n    >>> truncate_number(3.5)\n    0.5\n    ", "fr": " Étant donné un nombre flottant positif, il peut être décomposé en\n    une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales\n    (partie restante toujours inférieure à 1).\n    \n    Retourne la partie décimale du nombre.\n    >>> truncate_number(3.5)\n    0.5\n    ", "de": " Gegeben eine positive Gleitkommazahl, kann sie in einen ganzzahligen Teil (größte ganze Zahl, die kleiner als die gegebene Zahl ist) und Dezimalstellen (Restteil, der immer kleiner als 1 ist) zerlegt werden.\n    \n    Gib den Dezimalteil der Zahl zurück.\n    >>> truncate_number(3.5)\n    0.5\n    ", "ha": " An ba da lamba mai lamba mai kyau, za a iya raba ta zuwa\n    wani ɓangare na integer (babban integer mafi ƙanƙanta fiye da adadin da aka bayar) da decimals\n    (ɓangaren da ya rage koyaushe ƙasa da 1).\n    \n    Mayar da ɓangaren decimal na lambar.\n    >>> truncate_number(3.5)\n    0.5\n    ", "hi": " दिए गए एक धनात्मक फ्लोटिंग पॉइंट संख्या को दो भागों में विभाजित किया जा सकता है:\n    एक पूर्णांक भाग (दी गई संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलव\n    (बचा हुआ भाग जो हमेशा 1 से छोटा होता है)।\n    \n    संख्या के दशमलव भाग को लौटाएं।\n    >>> truncate_number(3.5)\n    0.5\n    ", "hu": " Adott egy pozitív lebegőpontos szám, amely felbontható egy\n    egész részre (a megadott számnál kisebb legnagyobb egész szám) és tizedesjegyekre\n    (a maradék rész mindig kisebb, mint 1).\n    \n    Adja vissza a szám tizedes részét.\n    >>> truncate_number(3.5)\n    0.5\n    ", "es": "Dado un número de punto flotante positivo, se puede descomponer en\n    una parte entera (el entero más grande menor que el número dado) y decimales\n    (parte sobrante siempre menor que 1).\n    \n    Devuelve la parte decimal del número.\n    >>> truncate_number(3.5)\n    0.5", "arb": "بالنظر إلى عدد عشري موجب، يمكن تقسيمه إلى جزء صحيح (أكبر عدد صحيح أصغر من العدد المعطى) وأجزاء عشرية (الجزء المتبقي الذي يكون دائماً أصغر من 1).\n\nإرجاع الجزء العشري من العدد.\n>>> truncate_number(3.5)\n0.5", "sw": " Ikitolewa namba chanya ya nukta, inaweza kugawanywa katika\n    sehemu ya nambari kamili (nambari kamili kubwa zaidi ndogo kuliko namba iliyotolewa) na desimali\n    (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n    \n    Rudisha sehemu ya desimali ya namba.\n    >>> truncate_number(3.5)\n    0.5\n    ", "tr": " Verilen pozitif bir kayan noktalı sayı, bir tamsayı kısmına (verilen sayıdan küçük en büyük tamsayı) ve ondalıklara (her zaman 1'den küçük kalan kısım) ayrılabilir.\n    \n    Sayının ondalık kısmını döndürün.\n    >>> truncate_number(3.5)\n    0.5\n    ", "vi": "Đưa ra một số thực dương, nó có thể được phân tách thành\n    phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n    (phần còn lại luôn nhỏ hơn 1).\n    \n    Trả về phần thập phân của số.\n    >>> truncate_number(3.5)\n    0.5", "id": " Diberikan sebuah bilangan titik mengambang positif, bilangan tersebut dapat diuraikan menjadi\n    bagian bilangan bulat (bilangan bulat terbesar yang lebih kecil dari bilangan yang diberikan) dan desimal\n    (bagian sisa yang selalu lebih kecil dari 1).\n    \n    Mengembalikan bagian desimal dari bilangan tersebut.\n    >>> truncate_number(3.5)\n    0.5", "ja": " 指定された正の浮動小数点数は、整数部分（指定された数より小さい最大の整数）と小数部分（常に1より小さい残りの部分）に分解できます。\n\n    数の小数部分を返します。\n    >>> truncate_number(3.5)\n    0.5", "ko": "주어진 양의 부동 소수점 숫자는 정수 부분(주어진 숫자보다 작은 가장 큰 정수)과 소수 부분(항상 1보다 작은 나머지 부분)으로 분해될 수 있습니다.\n\n숫자의 소수 부분을 반환합니다.\n>>> truncate_number(3.5)\n0.5", "ml": "ഒരു പോസിറ്റീവ് ഫ്ലോട്ടിംഗ് പോയിന്റ് സംഖ്യ നൽകിയാൽ, അതിനെ ഒരു പൂർണ്ണഭാഗത്തിലും (നൽകിയ സംഖ്യയെക്കാൾ ചെറിയ ഏറ്റവും വലിയ പൂർണ്ണസംഖ്യ) ദശാംശങ്ങളിലും (എപ്പോഴും 1-ൽ കുറവായ ശേഷിക്കുന്ന ഭാഗം) വിഭജിക്കാം.\n\nസംഖ്യയുടെ ദശാംശഭാഗം തിരികെ നൽകുക.\n>>> truncate_number(3.5)\n0.5", "fa": "با توجه به یک عدد اعشاری مثبت، می‌توان آن را به دو بخش تقسیم کرد: \n    بخش صحیح (بزرگ‌ترین عدد صحیح کوچکتر از عدد داده شده) و بخش اعشاری\n    (بخش باقی‌مانده که همیشه کوچکتر از 1 است).\n    \n    بخش اعشاری عدد را برمی‌گرداند.\n    >>> truncate_number(3.5)\n    0.5"}}
{"task_id": "Python/4", "prompt": {"en": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "sq": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Ju është dhënë një listë e operacioneve të depozitave dhe tërheqjeve në një llogari bankare që fillon me\n    bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe\n    në atë pikë funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "hy": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Ձեզ տրված է բանկային հաշվի վրա կատարվող ավանդների և հանումների գործողությունների ցուցակ, որը սկսվում է\n    զրոյական մնացորդով: Ձեր խնդիրն է հայտնաբերել, թե արդյոք որևէ պահի հաշվի մնացորդը իջնում է զրոյից ցածր, և\n    այդ պահին ֆունկցիան պետք է վերադարձնի True: Հակառակ դեպքում այն պետք է վերադարձնի False:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "bn": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" আপনার কাছে একটি ব্যাংক অ্যাকাউন্টের জমা এবং উত্তোলন কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। \n    আপনার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই মুহূর্তে ফাংশনটি True রিটার্ন করা উচিত। \n    অন্যথায় এটি False রিটার্ন করা উচিত।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "bg": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Даден ви е списък с операции за депозити и тегления от банкова сметка, която започва с\n    нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нулата и\n    в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "zh": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" 给定一个银行账户的存款和取款操作列表，该账户初始余额为零。\n    你的任务是检测账户余额是否在任何时候低于零，如果是，函数应返回 True。\n    否则应返回 False。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "fr": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Vous avez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec\n    un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et\n    à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "de": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sie erhalten eine Liste von Einzahlungs- und Abhebungsoperationen auf einem Bankkonto, das mit\n    einem Kontostand von null beginnt. Ihre Aufgabe ist es zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und\n    in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "ha": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" An ba ka jerin ayyukan ajiya da cire kudi daga asusun banki wanda ya fara da\n    sifili a matsayin ma'auni. Aikin ka shi ne gano ko a wani lokaci ma'aunin asusun ya fadi kasa da sifili, kuma\n    a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "hi": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" आपको एक बैंक खाते पर जमा और निकासी संचालन की एक सूची दी गई है जो शून्य शेष के साथ शुरू होता है।\n    आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते का शेष शून्य से नीचे गिरता है, और उस बिंदु पर\n    फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "hu": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Egy bankszámlán végzett befizetési és kifizetési műveletek listáját kapod, amely kezdetben nulla egyenleggel rendelkezik. A feladatod az, hogy észleld, ha bármikor az egyenleg nulla alá csökken, és ebben az esetben a függvénynek True-t kell visszaadnia. Ellenkező esetben False-t kell visszaadnia.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "es": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con\n    saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y\n    en ese momento la función debe devolver True. De lo contrario, debe devolver False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "arb": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" لديك قائمة بعمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفر. مهمتك هي اكتشاف ما إذا كان في أي نقطة\n    يصبح رصيد الحساب أقل من الصفر، وفي هذه الحالة يجب أن تعيد الدالة True. وإلا يجب أن تعيد False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "sw": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na\n    salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti linashuka chini ya sifuri, na\n    wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "tr": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sıfır bakiye ile başlayan bir banka hesabında yapılan para yatırma ve çekme işlemlerinin bir listesini alıyorsunuz.\n    Göreviniz, hesabın bakiyesinin herhangi bir noktada sıfırın altına düşüp düşmediğini tespit etmektir ve\n    bu noktada fonksiyon True döndürmelidir. Aksi takdirde False döndürmelidir.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "vi": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Bạn được cung cấp một danh sách các giao dịch gửi tiền và rút tiền trên một tài khoản ngân hàng bắt đầu với\n    số dư bằng không. Nhiệm vụ của bạn là phát hiện nếu tại bất kỳ thời điểm nào số dư của tài khoản giảm xuống dưới không, và\n    tại thời điểm đó hàm nên trả về True. Ngược lại, nó nên trả về False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "id": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Anda diberikan daftar operasi setoran dan penarikan pada rekening bank yang dimulai dengan\n    saldo nol. Tugas Anda adalah mendeteksi apakah pada suatu titik saldo rekening jatuh di bawah nol, dan\n    pada titik itu fungsi harus mengembalikan True. Jika tidak, fungsi harus mengembalikan False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "ja": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" 銀行口座の入金および引き出し操作のリストが与えられます。この口座はゼロ残高から始まります。\n    あなたのタスクは、口座の残高がゼロを下回るかどうかを検出し、その時点で関数はTrueを返すべきです。\n    それ以外の場合はFalseを返すべきです。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "ko": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" 은행 계좌에 대한 입금 및 출금 작업 목록이 주어집니다. 계좌는 0의 잔액으로 시작합니다.\n    작업은 계좌의 잔액이 0 아래로 떨어지는지 감지하는 것이며, 그 시점에서 함수는 True를 반환해야 합니다.\n    그렇지 않으면 False를 반환해야 합니다.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "ml": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" നിങ്ങൾക്ക് ഒരു ബാങ്ക് അക്കൗണ്ടിലെ നിക്ഷേപ, പിന്‍വലിക്കല്‍ പ്രവര്‍ത്തനങ്ങളുടെ ഒരു പട്ടിക നല്‍കപ്പെടുന്നു, \n    ഇത് ശൂന്യ ബാലന്‍സില്‍ ആരംഭിക്കുന്നു. അക്കൗണ്ടിന്റെ ബാലന്‍സ് ഏതെങ്കിലും സമയത്ത് \n    ശൂന്യത്തിന് താഴെയായി വീഴുന്നുണ്ടോ എന്ന് കണ്ടെത്തുക, അപ്പോള്‍ ഫങ്ഷന്‍ True മടക്കണം. \n    അല്ലാത്ത പക്ഷം അത് False മടക്കണം.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "fa": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" شما یک لیست از عملیات واریز و برداشت در یک حساب بانکی دارید که با موجودی صفر شروع می‌شود. \n    وظیفه شما این است که تشخیص دهید آیا در هر نقطه‌ای موجودی حساب به زیر صفر می‌رسد یا خیر، \n    و در آن نقطه تابع باید True را برگرداند. در غیر این صورت باید False برگرداند.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\""}, "canonical_solution": "    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False", "instruction": {"en": "Write a python function 'def below_zero(operations: List[int]) -> bool:' to solve the following problem:\n You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    ", "sq": "Shkruani një funksion python 'def below_zero(operations: List[int]) -> bool:' për të zgjidhur problemin e mëposhtëm:\n Ju jepet një listë e operacioneve të depozitimit dhe tërheqjes në një llogari bankare që fillon me\n    bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe\n    në atë moment funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "hy": "Պայթոն ֆունկցիա 'def below_zero(operations: List[int]) -> bool:' գրեք հետևյալ խնդիրը լուծելու համար:\n Ձեզ տրված է բանկային հաշվի վրա ավանդների և դուրսբերումների գործողությունների ցուցակ, որը սկսվում է\n    զրոյական հաշվեկշռով։ Ձեր խնդիրն է հայտնաբերել, թե արդյոք որևէ պահի հաշվի մնացորդը զրոյից ցածր է ընկնում, և\n    այդ պահին ֆունկցիան պետք է վերադարձնի True։ Հակառակ դեպքում այն պետք է վերադարձնի False։\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "bn": "একটি পাইথন ফাংশন 'def below_zero(operations: List[int]) -> bool:' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n আপনাকে একটি ব্যাংক অ্যাকাউন্টের জমা এবং উত্তোলন অপারেশনের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। আপনার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই মুহূর্তে ফাংশনটি True রিটার্ন করা উচিত। অন্যথায় এটি False রিটার্ন করা উচিত।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "bg": "Напишете Python функция 'def below_zero(operations: List[int]) -> bool:', за да решите следния проблем:\n Дават ви се списък с операции за депозити и тегления по банкова сметка, която започва с\n    нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нула, и\n    в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "zh": "编写一个 Python 函数 'def below_zero(operations: List[int]) -> bool:' 来解决以下问题：\n 你得到一个银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候低于零，并且在这种情况下函数应该返回 True。否则，它应该返回 False。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "fr": "Écrivez une fonction python 'def below_zero(operations: List[int]) -> bool:' pour résoudre le problème suivant :\n Vous avez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec\n    un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et\n    à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "de": "Schreiben Sie eine Python-Funktion 'def below_zero(operations: List[int]) -> bool:', um das folgende Problem zu lösen:\n Sie erhalten eine Liste von Einzahlungs- und Abhebungsvorgängen auf einem Bankkonto, das mit einem\n    Kontostand von null beginnt. Ihre Aufgabe ist es zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und\n    in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "ha": "Rubuta wani aikin python 'def below_zero(operations: List[int]) -> bool:' don warware matsalar mai zuwa:\n An baka jerin ajiya da cire kudi a asusun banki wanda ya fara da\n    sifili. Aikinka shi ne gano ko a kowane lokaci asusun ya fadi kasa da sifili, kuma\n    a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "hi": "एक पायथन फ़ंक्शन 'def below_zero(operations: List[int]) -> bool:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको एक बैंक खाते पर जमा और निकासी संचालन की एक सूची दी गई है जो शून्य शेष राशि से शुरू होती है। आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते की शेष राशि शून्य से नीचे गिरती है, और उस बिंदु पर फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "hu": "Írj egy python függvényt 'def below_zero(operations: List[int]) -> bool:' a következő probléma megoldására:\n Adott egy lista, amely egy bankszámlán végrehajtott befizetési és kifizetési műveleteket tartalmaz, és amely nulla egyenleggel indul. A feladatod az, hogy észleld, ha bármely ponton a számla egyenlege nulla alá csökken, és ebben az esetben a függvénynek True értéket kell visszaadnia. Ellenkező esetben False-t kell visszaadnia.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "es": "Escribe una función en Python 'def below_zero(operations: List[int]) -> bool:' para resolver el siguiente problema:\n Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con\n    saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y\n    en ese momento la función debe devolver True. De lo contrario, debe devolver False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "arb": "اكتب دالة بايثون 'def below_zero(operations: List[int]) -> bool:' لحل المشكلة التالية:\n لديك قائمة من عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفر. مهمتك هي اكتشاف ما إذا كان في أي نقطة ينخفض رصيد الحساب إلى أقل من الصفر، وفي تلك الحالة يجب أن تعيد الدالة True. وإلا يجب أن تعيد False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "sw": "Andika kazi ya python 'def below_zero(operations: List[int]) -> bool:' kutatua tatizo lifuatalo:\n Unapewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na\n    salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti litashuka chini ya sifuri, na\n    wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "tr": "Bir python fonksiyonu 'def below_zero(operations: List[int]) -> bool:' yazın ve aşağıdaki problemi çözün:\n    Sıfır bakiyeyle başlayan bir banka hesabında yapılan para yatırma ve çekme işlemlerinin bir listesini veriliyor. Göreviniz, herhangi bir noktada hesabın bakiyesinin sıfırın altına düşüp düşmediğini tespit etmektir ve bu noktada fonksiyon True döndürmelidir. Aksi takdirde False döndürmelidir.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "vi": "Viết một hàm python 'def below_zero(operations: List[int]) -> bool:' để giải quyết vấn đề sau:  \nBạn được cung cấp một danh sách các giao dịch gửi và rút tiền trên một tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ thời điểm nào số dư của tài khoản có giảm xuống dưới không hay không, và tại thời điểm đó hàm nên trả về True. Ngược lại, nó nên trả về False.  \n>>> below_zero([1, 2, 3])  \nFalse  \n>>> below_zero([1, 2, -4, 5])  \nTrue  ", "id": "Tulis sebuah fungsi python 'def below_zero(operations: List[int]) -> bool:' untuk menyelesaikan masalah berikut:\n Anda diberikan daftar operasi setoran dan penarikan pada rekening bank yang dimulai dengan\n    saldo nol. Tugas Anda adalah mendeteksi apakah pada titik mana pun saldo rekening jatuh di bawah nol, dan\n    pada titik itu fungsi harus mengembalikan True. Jika tidak, harus mengembalikan False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "ja": "以下の問題を解決するためのPython関数 'def below_zero(operations: List[int]) -> bool:' を作成してください:\n あなたは、ゼロ残高で始まる銀行口座の預金と引き出しの操作のリストを与えられます。あなたのタスクは、口座の残高がゼロを下回るかどうかを検出し、その時点で関数がTrueを返すようにすることです。そうでない場合はFalseを返すべきです。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "ko": "다음 문제를 해결하기 위해 'def below_zero(operations: List[int]) -> bool:'라는 파이썬 함수를 작성하십시오:\n당신은 0의 잔액으로 시작하는 은행 계좌에 대한 입금 및 출금 작업 목록을 받았습니다. 당신의 작업은 계좌의 잔액이 어느 시점에서든 0 아래로 떨어지는지를 감지하는 것입니다. 그 시점에서 함수는 True를 반환해야 합니다. 그렇지 않으면 False를 반환해야 합니다.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "ml": "'def below_zero(operations: List[int]) -> bool:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\nനിങ്ങൾക്ക് ശൂന്യ ബാലൻസിൽ ആരംഭിക്കുന്ന ഒരു ബാങ്ക് അക്കൗണ്ടിലെ നിക്ഷേപ, പിന്‍വലിക്കൽ പ്രവർത്തനങ്ങളുടെ ഒരു പട്ടിക ലഭിച്ചു. അക്കൗണ്ടിന്റെ ബാലൻസ് ഏതെങ്കിലും സമയത്ത് ശൂന്യത്തിന് താഴെയാണെങ്കിൽ കണ്ടെത്തുക, അപ്പോൾ ഫംഗ്ഷൻ True മടക്കണം. അല്ലാത്തപക്ഷം, അത് False മടക്കണം.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "fa": "یک تابع پایتون 'def below_zero(operations: List[int]) -> bool:' بنویسید تا مسئله زیر را حل کند:\n به شما یک لیست از عملیات واریز و برداشت در یک حساب بانکی داده شده است که با\n    موجودی صفر شروع می‌شود. وظیفه شما این است که تشخیص دهید آیا در هر نقطه‌ای موجودی حساب به زیر صفر می‌رسد یا خیر، و\n    در آن نقطه تابع باید True را برگرداند. در غیر این صورت، باید False را برگرداند.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True"}, "level": "easy", "test": "def check(below_zero):\n    assert below_zero([]) == False\n    assert below_zero([1, 2, -3, 1, 2, -3]) == False\n    assert below_zero([1, 2, -4, 5, 6]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True\n \ncheck(below_zero)", "entry_point": "below_zero", "signature": "def below_zero(operations: List[int]) -> bool:", "docstring": {"en": " You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    ", "sq": " Ju jepet një listë operacionesh depozitimi dhe tërheqjeje në një llogari bankare që fillon me një bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe në atë pikë funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "hy": " Ձեզ տրված է բանկային հաշվի ավանդների և դուրսբերումների գործողությունների ցուցակ, որը սկսվում է զրոյական մնացորդով։ Ձեր խնդիրն է հայտնաբերել, թե արդյոք որևէ պահի հաշվի մնացորդը ընկնում է զրոյից ցածր, և այդ պահին ֆունկցիան պետք է վերադարձնի True։ Հակառակ դեպքում այն պետք է վերադարձնի False։\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "bn": " আপনাকে একটি ব্যাংক অ্যাকাউন্টের জমা এবং উত্তোলন কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। আপনার কাজ হল সনাক্ত করা যে কোনো সময়ে অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই সময়ে ফাংশনটি True ফেরত দেওয়া উচিত। অন্যথায় এটি False ফেরত দেওয়া উচিত।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "bg": " Даден ви е списък с операции за депозити и тегления от банкова сметка, която започва с нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нулата, и в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "zh": " 你有一个银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候低于零，并在此时函数应返回 True。否则应返回 False。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "fr": " Vous avez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "de": " Du hast eine Liste von Einzahlungs- und Abhebungsoperationen auf einem Bankkonto, das mit einem Kontostand von null beginnt. Deine Aufgabe ist es zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "ha": " An ba ku jerin ajiya da cire kudi a kan asusun banki wanda ya fara da sifili. Aikin ku shi ne gano ko a kowane lokaci asusun ya yi kasa da sifili, kuma a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "hi": " आपको एक बैंक खाते पर जमा और निकासी संचालन की सूची दी गई है, जो शून्य शेष के साथ शुरू होता है। आपका कार्य यह पता लगाना है कि क्या किसी बिंदु पर खाते का शेष शून्य से नीचे गिरता है, और उस बिंदु पर फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "hu": " Egy bankszámlán végzett befizetési és kifizetési műveletek listáját kapod, amely kezdetben nulla egyenleggel rendelkezik. A feladatod az, hogy észleld, ha bármely ponton a számla egyenlege nulla alá csökken, és ebben az esetben a függvénynek True értéket kell visszaadnia. Ellenkező esetben False értéket kell visszaadnia.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "es": "Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con un saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y en ese punto la función debería devolver True. De lo contrario, debería devolver False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "arb": "أنت مُعطى قائمة من عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفري. مهمتك هي اكتشاف ما إذا كان في أي نقطة ينخفض رصيد الحساب إلى ما دون الصفر، وعند هذه النقطة يجب أن تُعيد الدالة True. خلاف ذلك، يجب أن تُعيد False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "sw": "Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti linashuka chini ya sifuri, na wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "tr": " Verilen bir banka hesabı üzerinde sıfır bakiyeyle başlayan para yatırma ve çekme işlemlerinin bir listesidir. Göreviniz, herhangi bir noktada hesap bakiyesinin sıfırın altına düşüp düşmediğini tespit etmektir ve bu noktada fonksiyon True döndürmelidir. Aksi takdirde False döndürmelidir.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    ", "vi": "Bạn được cung cấp một danh sách các hoạt động gửi và rút tiền trên một tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ thời điểm nào số dư của tài khoản có giảm xuống dưới không hay không, và tại thời điểm đó hàm nên trả về True. Nếu không, nó nên trả về False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "id": "Anda diberikan daftar operasi setoran dan penarikan pada rekening bank yang dimulai dengan saldo nol. Tugas Anda adalah mendeteksi apakah pada titik mana pun saldo rekening jatuh di bawah nol, dan pada titik itu fungsi harus mengembalikan True. Jika tidak, fungsi harus mengembalikan False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "ja": "銀行口座の入金および引き出し操作のリストが与えられています。この口座はゼロ残高から始まります。あなたのタスクは、口座の残高がゼロを下回るかどうかを検出し、その時点で関数がTrueを返すようにすることです。そうでなければ、Falseを返すべきです。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "ko": "당신은 0의 잔액으로 시작하는 은행 계좌에 대한 입금 및 출금 작업 목록을 받았습니다. 당신의 작업은 계좌의 잔액이 어느 시점에서든 0보다 떨어지는지 감지하는 것입니다. 그 시점에서 함수는 True를 반환해야 합니다. 그렇지 않으면 False를 반환해야 합니다.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "ml": "നിങ്ങൾക്ക് ഒരു ബാങ്ക് അക്കൗണ്ടിലെ നിക്ഷേപവും പിന്‍വലിക്കലും സംബന്ധിച്ച പ്രവർത്തനങ്ങളുടെ പട്ടിക ലഭിച്ചിട്ടുണ്ട്, ഇത് ശൂന്യ ബാലൻസിൽ ആരംഭിക്കുന്നു. അക്കൗണ്ടിന്റെ ബാലൻസ് ഏതെങ്കിലും സമയത്ത് പൂജ്യത്തിനേക്കാൾ താഴെയാണോ എന്ന് കണ്ടെത്തുക, അപ്പോഴേക്കും ഫംഗ്ഷൻ True മടക്കണം. അല്ലാത്തപക്ഷം അത് False മടക്കണം.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True", "fa": "شما یک لیست از عملیات واریز و برداشت در یک حساب بانکی دارید که با موجودی صفر شروع می‌شود. وظیفه شما این است که تشخیص دهید آیا در هر نقطه‌ای موجودی حساب به زیر صفر می‌رسد یا خیر، و در آن نقطه تابع باید True را برگرداند. در غیر این صورت باید False را برگرداند.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True"}}
{"task_id": "Python/5", "prompt": {"en": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "sq": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Për një listë të dhënë të numrave hyrës, llogaritni Devijimin Absolut Mesatar\n    rreth mesatares së këtij grupi të dhënash.\n    Devijimi Absolut Mesatar është mesatarja e diferencës absolute midis secilit\n    element dhe një pikë qendrore (mesatarja në këtë rast):\n    MAD = mesatarja | x - x_mesatarja |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "hy": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Տրված թվերի ցուցակի համար հաշվարկել միջին բացարձակ շեղումը\n    այս տվյալների հավաքածուի միջինի շուրջ:\n    Միջին բացարձակ շեղումը յուրաքանչյուր տարրի և կենտրոնական կետի (այս դեպքում՝ միջինի) միջև միջին բացարձակ տարբերությունն է:\n    MAD = միջին | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "bn": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি গণনা করুন।\n    গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য:\n    MAD = গড় | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "bg": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" За даден списък от входни числа, изчислете Средно Абсолютно Отклонение\n    около средната стойност на този набор от данни.\n    Средното Абсолютно Отклонение е средната абсолютна разлика между всеки\n    елемент и централната точка (в този случай средната стойност):\n    MAD = средно | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "zh": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" 对于给定的输入数字列表，计算该数据集的平均绝对偏差。\n    平均绝对偏差是每个元素与中心点（在此情况下为均值）之间的平均绝对差：\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "fr": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Pour une liste donnée de nombres en entrée, calculer la Déviation Absolue Moyenne\n    autour de la moyenne de cet ensemble de données.\n    La Déviation Absolue Moyenne est la différence absolue moyenne entre chaque\n    élément et un point central (la moyenne dans ce cas) :\n    MAD = moyenne | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "de": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Für eine gegebene Liste von Eingabezahlen, berechne die mittlere absolute Abweichung\n    um den Mittelwert dieses Datensatzes.\n    Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n    Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n    MAD = Durchschnitt | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "ha": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Don jerin lambobi da aka bayar, ƙididdige Matsakaicin Bambanci na Gaskiya\n    a kusa da matsakaicin wannan bayanan.\n    Matsakaicin Bambanci na Gaskiya shine matsakaicin bambancin kowane\n    abu da wata cibiyar (matsakaici a wannan yanayin):\n    MAD = matsakaici | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "hi": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटा सेट के औसत के चारों ओर औसत निरपेक्ष विचलन की गणना करें।\n    औसत निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्र बिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "hu": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Egy adott számok listájára számítsa ki az átlagos abszolút eltérést\n    az adathalmaz átlagához képest.\n    Az átlagos abszolút eltérés az egyes elemek és egy középpont (ebben az esetben az átlag) közötti átlagos abszolút különbség:\n    MAD = átlag | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "es": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Para una lista dada de números de entrada, calcular la Desviación Absoluta Media\n    alrededor de la media de este conjunto de datos.\n    La Desviación Absoluta Media es la diferencia absoluta promedio entre cada\n    elemento y un punto central (media en este caso):\n    MAD = promedio | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "arb": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" لحساب الانحراف المطلق المتوسط لقائمة معينة من الأرقام المدخلة\n    حول متوسط هذه المجموعة من البيانات.\n    الانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل عنصر ونقطة مركزية \n    (المتوسط في هذه الحالة):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "sw": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Kwa orodha iliyotolewa ya namba za ingizo, hesabu Mkengeuko wa Kawaida wa \n    Wastani kuzunguka wastani wa seti hii ya data.\n    Mkengeuko wa Kawaida wa Wastani ni wastani wa tofauti kamili kati ya kila \n    kipengele na kituo (wastani katika kesi hii):\n    MAD = wastani | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "tr": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Verilen bir sayı listesi için, bu veri kümesinin ortalaması etrafında Ortalama Mutlak Sapmayı hesaplayın.\n    Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "vi": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Đối với một danh sách các số đầu vào cho trước, tính Độ lệch tuyệt đối trung bình\n    quanh giá trị trung bình của tập dữ liệu này.\n    Độ lệch tuyệt đối trung bình là sự khác biệt tuyệt đối trung bình giữa mỗi\n    phần tử và một điểm trung tâm (trung bình trong trường hợp này):\n    MAD = trung bình | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "id": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Untuk daftar angka masukan yang diberikan, hitung Deviasi Absolut Rata-rata\n    di sekitar rata-rata dari dataset ini.\n    Deviasi Absolut Rata-rata adalah rata-rata perbedaan absolut antara setiap\n    elemen dan titik pusat (rata-rata dalam kasus ini):\n    MAD = rata-rata | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "ja": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" 与えられた入力数値のリストに対して、データセットの平均を中心とした平均絶対偏差を計算します。\n    平均絶対偏差は、各要素と中心点（この場合は平均）との間の平均絶対差です:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "ko": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" 주어진 입력 숫자 목록에 대해, 이 데이터셋의 평균을 중심으로 한 평균 절대 편차를 계산합니다.\n    평균 절대 편차는 각 요소와 중심점(이 경우 평균) 사이의 평균 절대 차이입니다:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "ml": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" നൽകിയ ഒരു ലിസ്റ്റ് ഇൻപുട്ട് സംഖ്യകൾക്കായി, ഈ ഡാറ്റാസെറ്റിന്റെ ശരാശരിക്ക് ചുറ്റുമുള്ള ശരാശരി പരമാവധി വ്യതിയാനം\n    കണക്കാക്കുക.\n    ശരാശരി പരമാവധി വ്യതിയാനം ഓരോ ഘടകവും ഒരു കേന്ദ്രബിന്ദുവുമായുള്ള ശരാശരി പരമാവധി വ്യത്യാസമാണ് (ഈ സാഹചര്യത്തിൽ ശരാശരി):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "fa": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" برای یک لیست داده شده از اعداد ورودی، انحراف مطلق میانگین را\n    حول میانگین این مجموعه داده محاسبه کنید.\n    انحراف مطلق میانگین، میانگین تفاوت مطلق بین هر عنصر و یک نقطه مرکزی\n    (در این مورد میانگین) است:\n    MAD = میانگین | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\""}, "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "instruction": {"en": "Write a python function 'def mean_absolute_deviation(numbers: List[float]) -> float:' to solve the following problem:\n For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ", "sq": "Shkruani një funksion python 'def mean_absolute_deviation(numbers: List[float]) -> float:' për të zgjidhur problemin e mëposhtëm:\n Për një listë të dhënë të numrave hyrës, llogaritni Devijimin Absolut Mesatar\n    rreth mesatares së këtij grupi të dhënash.\n    Devijimi Absolut Mesatar është mesatarja e diferencës absolute midis secilit\n    element dhe një pikë qendrore (mesatarja në këtë rast):\n    MAD = mesatarja | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "hy": "Պայթոն ֆունկցիա 'def mean_absolute_deviation(numbers: List[float]) -> float:' գրեք հետևյալ խնդիրը լուծելու համար:\n Տրված մուտքային թվերի ցուցակի համար հաշվարկել Միջին բացարձակ շեղումը\n    այս տվյալների հավաքածուի միջինի շուրջ:\n    Միջին բացարձակ շեղումը յուրաքանչյուր\n    տարրի և կենտրոնական կետի (այս դեպքում միջինի) միջև միջին բացարձակ տարբերությունն է:\n    MAD = միջին | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "bn": "একটি পাইথন ফাংশন 'def mean_absolute_deviation(numbers: List[float]) -> float:' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n\n    প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি (Mean Absolute Deviation) গণনা করুন।\n    গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য:\n    MAD = গড় | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "bg": "Напишете функция на Python 'def mean_absolute_deviation(numbers: List[float]) -> float:', за да решите следния проблем:\n За даден списък от входни числа, изчислете Средното Абсолютно Отклонение\n    около средната стойност на този набор от данни.\n    Средното Абсолютно Отклонение е средната абсолютна разлика между всеки\n    елемент и централната точка (в този случай средната стойност):\n    MAD = средно | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "zh": "编写一个 Python 函数 'def mean_absolute_deviation(numbers: List[float]) -> float:' 来解决以下问题：\n\n对于给定的输入数字列表，计算该数据集均值周围的平均绝对偏差。\n\n平均绝对偏差是每个元素与中心点（在此情况下为均值）之间的平均绝对差：\n\nMAD = average | x - x_mean |\n\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0", "fr": "Écrivez une fonction python 'def mean_absolute_deviation(numbers: List[float]) -> float:' pour résoudre le problème suivant :\n Pour une liste donnée de nombres d'entrée, calculez la Déviation Absolue Moyenne\n    autour de la moyenne de cet ensemble de données.\n    La Déviation Absolue Moyenne est la différence absolue moyenne entre chaque\n    élément et un point central (la moyenne dans ce cas) :\n    MAD = moyenne | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "de": "Schreiben Sie eine Python-Funktion 'def mean_absolute_deviation(numbers: List[float]) -> float:', um das folgende Problem zu lösen:\n Für eine gegebene Liste von Eingabezahlen berechnen Sie die mittlere absolute Abweichung\n    um den Mittelwert dieses Datensatzes.\n    Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n    Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n    MAD = Durchschnitt | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "ha": "Rubuta wani aikin python 'def mean_absolute_deviation(numbers: List[float]) -> float:' don warware matsalar mai zuwa:\n Don jerin lambobi da aka bayar, ƙididdige Matsakaicin Bambancin Dangi\n    a kusa da matsakaicin wannan bayanan.\n    Matsakaicin Bambancin Dangi shine matsakaicin bambancin dangi tsakanin kowane\n    abu da wani tsakiya (matsakaici a wannan yanayin):\n    MAD = matsakaici | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "hi": "एक पायथन फ़ंक्शन 'def mean_absolute_deviation(numbers: List[float]) -> float:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटासेट के औसत के चारों ओर माध्य निरपेक्ष विचलन की गणना करें।\n    माध्य निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्रबिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "hu": "Írj egy Python függvényt 'def mean_absolute_deviation(numbers: List[float]) -> float:' a következő probléma megoldására:\n Egy adott bemeneti számok listájához számítsd ki az átlagos abszolút eltérést\n    ennek az adathalmaznak az átlaga körül.\n    Az átlagos abszolút eltérés az egyes elemek és egy középpont (ebben az esetben az átlag) közötti átlagos abszolút különbség:\n    MAD = átlag | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "es": "Escribe una función de Python 'def mean_absolute_deviation(numbers: List[float]) -> float:' para resolver el siguiente problema:\n Para una lista dada de números de entrada, calcula la Desviación Absoluta Media\n    alrededor de la media de este conjunto de datos.\n    La Desviación Absoluta Media es la diferencia absoluta promedio entre cada\n    elemento y un punto central (media en este caso):\n    MAD = promedio | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "arb": "اكتب دالة بايثون 'def mean_absolute_deviation(numbers: List[float]) -> float:' لحل المشكلة التالية:\nبالنسبة لقائمة معينة من الأرقام المدخلة، احسب الانحراف المطلق المتوسط حول متوسط هذه المجموعة.\nالانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل عنصر ونقطة مركزية (المتوسط في هذه الحالة):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0", "sw": "Andika kazi ya python 'def mean_absolute_deviation(numbers: List[float]) -> float:' kutatua tatizo lifuatalo:\n Kwa orodha fulani ya namba za pembejeo, hesabu Mkengeuko wa Wastani wa Kawaida\n    kuzunguka wastani wa seti hii ya data.\n    Mkengeuko wa Wastani wa Kawaida ni wastani wa tofauti ya kawaida kati ya kila\n    kipengele na sehemu ya kati (wastani katika kesi hii):\n    MAD = wastani | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "tr": "Bir python fonksiyonu 'def mean_absolute_deviation(numbers: List[float]) -> float:' yazın ve aşağıdaki problemi çözün:\n Verilen bir sayı listesi için, bu veri kümesinin ortalaması etrafında Ortalama Mutlak Sapmayı hesaplayın.\n    Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:\n    MAD = ortalama | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "vi": "Viết một hàm python 'def mean_absolute_deviation(numbers: List[float]) -> float:' để giải quyết vấn đề sau:\n Đối với một danh sách các số đầu vào đã cho, tính Độ lệch tuyệt đối trung bình\n    xung quanh giá trị trung bình của tập dữ liệu này.\n    Độ lệch tuyệt đối trung bình là trung bình của sự khác biệt tuyệt đối giữa mỗi\n    phần tử và một điểm trung tâm (trung bình trong trường hợp này):\n    MAD = trung bình | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "id": "Tulis sebuah fungsi python 'def mean_absolute_deviation(numbers: List[float]) -> float:' untuk menyelesaikan masalah berikut:\n Untuk daftar angka masukan yang diberikan, hitung Deviasi Absolut Rata-rata\n    di sekitar rata-rata dari dataset ini.\n    Deviasi Absolut Rata-rata adalah rata-rata perbedaan absolut antara setiap\n    elemen dan titik pusat (rata-rata dalam kasus ini):\n    MAD = rata-rata | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "ja": "以下の問題を解決するためのPython関数 'def mean_absolute_deviation(numbers: List[float]) -> float:' を作成してください:\n 与えられた入力数値のリストに対して、データセットの平均を中心とした平均絶対偏差を計算します。\n    平均絶対偏差は、各要素と中心点（この場合は平均）との絶対差の平均です:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "ko": "다음 문제를 해결하기 위해 파이썬 함수를 작성하세요: 'def mean_absolute_deviation(numbers: List[float]) -> float:'\n 주어진 입력 숫자 리스트에 대해 평균 절대 편차를 계산합니다.\n    평균 절대 편차는 데이터셋의 평균을 중심으로 각 요소와의 평균 절대 차이입니다.\n    평균 절대 편차(MAD)는 각 요소와 중심점(이 경우 평균) 간의 평균 절대 차이입니다:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "ml": "ഒരു പൈത്തൺ ഫംഗ്ഷൻ 'def mean_absolute_deviation(numbers: List[float]) -> float:' എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n  നൽകിയ ഒരു ഇൻപുട്ട് നമ്പറുകളുടെ ലിസ്റ്റിനായി, ഈ ഡാറ്റാസെറ്റിന്റെ ശരാശരിയെ ചുറ്റിപ്പറ്റി മീൻ ആബ്സല്യൂട്ട് ഡിവിയേഷൻ കണക്കാക്കുക.\n    മീൻ ആബ്സല്യൂട്ട് ഡിവിയേഷൻ ഓരോ ഘടകവും ഒരു കേന്ദ്രബിന്ദുവുമായുള്ള ശരാശരി ആബ്സല്യൂട്ട് വ്യത്യാസമാണ് (ഈ കേസിൽ ശരാശരി):\n    MAD = ശരാശരി | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "fa": "یک تابع پایتون بنویسید 'def mean_absolute_deviation(numbers: List[float]) -> float:' تا مسئله زیر را حل کند:\n برای یک لیست از اعداد ورودی، انحراف مطلق میانگین را محاسبه کنید\n    حول میانگین این مجموعه داده.\n    انحراف مطلق میانگین، میانگین تفاوت مطلق بین هر\n    عنصر و یک نقطه مرکزی (در این مورد میانگین) است:\n    MAD = میانگین | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0"}, "level": "easy", "test": "def check(mean_absolute_deviation):\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n    \ncheck(mean_absolute_deviation)", "entry_point": "mean_absolute_deviation", "signature": "def mean_absolute_deviation(numbers: List[float]) -> float:", "docstring": {"en": " For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ", "sq": " Për një listë të dhënë të numrave të hyrjes, llogaritni Devijimin Absolut Mesatar rreth mesatares së këtij grupi të dhënash.\n    Devijimi Absolut Mesatar është diferenca mesatare absolute midis secilit element dhe një pikë qendrore (mesatarja në këtë rast):\n    MAD = mesatarja | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ", "hy": " Տրված թվերի ցուցակի համար հաշվարկել միջին բացարձակ շեղումը\n    այս տվյալների հավաքածուի միջինի շուրջ:\n    Միջին բացարձակ շեղումը յուրաքանչյուր տարրի և կենտրոնական կետի (այս դեպքում միջինի) միջև միջին բացարձակ տարբերությունն է.\n    MAD = միջին | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ", "bn": " প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি গণনা করুন।\n    গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য:\n    MAD = গড় | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "bg": " За даден списък от входни числа, изчислете Средното Абсолютно Отклонение\n    около средната стойност на този набор от данни.\n    Средното Абсолютно Отклонение е средната абсолютна разлика между всеки\n    елемент и централната точка (в този случай средната стойност):\n    MAD = средно | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ", "zh": " 对于给定的输入数字列表，计算该数据集平均值周围的平均绝对偏差。  \n平均绝对偏差是每个元素与中心点（在此情况下为平均值）之间的平均绝对差：  \nMAD = average | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ", "fr": " Pour une liste donnée de nombres d'entrée, calculer la déviation absolue moyenne autour de la moyenne de cet ensemble de données.\n    La déviation absolue moyenne est la différence absolue moyenne entre chaque élément et un point central (la moyenne dans ce cas) :\n    MAD = moyenne | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ", "de": " Für eine gegebene Liste von Eingabezahlen berechnen Sie die mittlere absolute Abweichung\n    um den Mittelwert dieses Datensatzes.\n    Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n    Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n    MAD = Durchschnitt | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ", "ha": " Don Allah, a jerin lambobi masu shigarwa da aka bayar, a lissafta Matsakaicin Maimaitawa na Dama \n    a kusa da matsakaicin wannan bayanan.\n    Matsakaicin Maimaitawa na Dama shine matsakaicin bambancin dama tsakanin kowanne \n    abu da wani tsakiya (matsakaici a wannan yanayin):\n    MAD = matsakaici | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ", "hi": " दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटासेट के औसत के चारों ओर माध्य निरपेक्ष विचलन की गणना करें।  \nमाध्य निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्रबिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:  \nMAD = average | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ", "hu": " Adott bemeneti számok listája esetén számítsa ki az átlagos abszolút eltérést\n    az adathalmaz átlagához képest.\n    Az átlagos abszolút eltérés az egyes elemek és egy középpont (jelen esetben az átlag) közötti abszolút különbségek átlaga:\n    MAD = átlag | x - x_átlag |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ", "es": " Para una lista dada de números de entrada, calcular la Desviación Absoluta Media\n    alrededor de la media de este conjunto de datos.\n    La Desviación Absoluta Media es la diferencia absoluta promedio entre cada\n    elemento y un punto central (la media en este caso):\n    MAD = promedio | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "arb": "للحصول على قائمة معينة من الأرقام المدخلة، احسب الانحراف المطلق المتوسط حول متوسط هذه المجموعة من البيانات. الانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل عنصر ونقطة مركزية (المتوسط في هذه الحالة): MAD = متوسط | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0", "sw": "Kwa orodha iliyotolewa ya namba za ingizo, hesabu Mkengeuko Wastani wa Absolute\n    kuzunguka wastani wa seti hii ya data.\n    Mkengeuko Wastani wa Absolute ni tofauti ya wastani ya absolute kati ya kila\n    kipengele na sehemu ya kati (wastani katika kesi hii):\n    MAD = wastani | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "tr": "Verilen bir giriş numaraları listesi için, bu veri kümesinin etrafındaki Ortalama Mutlak Sapmayı hesaplayın.\n    Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:\n    MAD = ortalama | x - x_ortalama |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "vi": " Đối với một danh sách các số đầu vào đã cho, tính Độ lệch tuyệt đối trung bình xung quanh trung bình của tập dữ liệu này. Độ lệch tuyệt đối trung bình là sự khác biệt tuyệt đối trung bình giữa mỗi phần tử và một điểm trung tâm (trung bình trong trường hợp này): MAD = trung bình | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0", "id": "Untuk daftar angka masukan yang diberikan, hitung Deviasi Absolut Rata-rata\n    di sekitar rata-rata dari dataset ini.\n    Deviasi Absolut Rata-rata adalah rata-rata perbedaan absolut antara setiap\n    elemen dan titik pusat (rata-rata dalam kasus ini):\n    MAD = rata-rata | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "ja": "指定された入力数のリストに対して、このデータセットの平均を中心とした平均絶対偏差を計算します。  \n平均絶対偏差は、各要素と中心点（この場合は平均）との間の絶対差の平均です：  \nMAD = 平均 | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0  ", "ko": "주어진 입력 숫자 목록에 대해, 이 데이터셋의 평균을 중심으로 한 평균 절대 편차를 계산합니다.  \n평균 절대 편차는 각 요소와 중심점(이 경우 평균) 사이의 평균 절대 차이입니다:  \nMAD = average | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0  ", "ml": "ഒരു നൽകിയ ലിസ്റ്റ് ഇൻപുട്ട് നമ്പറുകൾക്കായി, ഈ ഡാറ്റാസെറ്റിന്റെ ശരാശരിയെ ചുറ്റിപ്പറ്റി ശരാശരി ആബ്സല്യൂട്ട് വ്യതിഭ്രംശം (Mean Absolute Deviation) കണക്കാക്കുക.\n    \nശരാശരി ആബ്സല്യൂട്ട് വ്യതിഭ്രംശം എന്നത് ഓരോ ഘടകത്തിനും ഒരു കേന്ദ്രബിന്ദുവിനും (ഈ സാഹചര്യത്തിൽ ശരാശരി) ഇടയിലെ ശരാശരി ആബ്സല്യൂട്ട് വ്യത്യാസമാണ്:\n    \n    MAD = average | x - x_mean |\n    MAD = ശരാശരി | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0", "fa": "برای یک لیست داده شده از اعداد ورودی، انحراف مطلق میانگین را در اطراف میانگین این مجموعه داده محاسبه کنید.  \nانحراف مطلق میانگین میانگین تفاوت مطلق بین هر عنصر و یک نقطه مرکزی (در این مورد میانگین) است:  \nMAD = میانگین | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0  "}}
{"task_id": "Python/6", "prompt": {"en": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    \"\"\"", "sq": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Shton dy numra të plotë së bashku.\n\n    Parametrat:\n    a (int): Numri i parë që do të shtohet.\n    b (int): Numri i dytë që do të shtohet.\n\n    Kthen:\n    int: Shuma e dy numrave.\n    \"\"\"", "hy": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Գումարում է երկու ամբողջ թիվ:\n\n    Պարամետրեր:\n    a (int): Առաջին թիվը, որը պետք է գումարվի:\n    b (int): Երկրորդ թիվը, որը պետք է գումարվի:\n\n    Վերադարձնում է:\n    int: Երկու թվերի գումարը:\n    \"\"\"", "bn": "def add(a: int, b: int) -> int:\n    \"\"\"\n    দুটি পূর্ণসংখ্যা একসাথে যোগ করে।\n\n    প্যারামিটারসমূহ:\n    a (int): যোগ করার জন্য প্রথম সংখ্যা।\n    b (int): যোগ করার জন্য দ্বিতীয় সংখ্যা।\n\n    রিটার্ন:\n    int: দুটি সংখ্যার যোগফল।\n    \"\"\"", "bg": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Събира две цели числа.\n\n    Parameters:\n    a (int): Първото число, което ще бъде събрано.\n    b (int): Второто число, което ще бъде събрано.\n\n    Returns:\n    int: Сумата на двете числа.\n    \"\"\"", "zh": "def add(a: int, b: int) -> int:\n    \"\"\"\n    将两个整数相加。\n\n    参数:\n    a (int): 要相加的第一个数字。\n    b (int): 要相加的第二个数字。\n\n    返回:\n    int: 两个数字的和。\n    \"\"\"", "fr": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Additionne deux nombres entiers ensemble.\n\n    Paramètres:\n    a (int): Le premier nombre à ajouter.\n    b (int): Le deuxième nombre à ajouter.\n\n    Retourne:\n    int: La somme des deux nombres.\n    \"\"\"", "de": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Addiert zwei ganze Zahlen miteinander.\n\n    Parameter:\n    a (int): Die erste Zahl, die addiert werden soll.\n    b (int): Die zweite Zahl, die addiert werden soll.\n\n    Rückgabewert:\n    int: Die Summe der beiden Zahlen.\n    \"\"\"", "ha": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Ƙara lambobi guda biyu tare.\n\n    Ma'auni:\n    a (int): Lambar farko da za a ƙara.\n    b (int): Lambar biyu da za a ƙara.\n\n    Komawa:\n    int: Jimillar lambobin guda biyu.\n    \"\"\"", "hi": "def add(a: int, b: int) -> int:\n    \"\"\"\n    दो पूर्णांक संख्याओं को जोड़ता है।\n\n    पैरामीटर्स:\n    a (int): पहली संख्या जिसे जोड़ा जाना है।\n    b (int): दूसरी संख्या जिसे जोड़ा जाना है।\n\n    रिटर्न:\n    int: दोनों संख्याओं का योग।\n    \"\"\"", "hu": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Két egész számot ad össze.\n\n    Paraméterek:\n    a (int): Az első szám, amelyet hozzáadunk.\n    b (int): A második szám, amelyet hozzáadunk.\n\n    Visszatér:\n    int: A két szám összege.\n    \"\"\"", "es": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Suma dos números enteros.\n\n    Parámetros:\n    a (int): El primer número a sumar.\n    b (int): El segundo número a sumar.\n\n    Devuelve:\n    int: La suma de los dos números.\n    \"\"\"", "arb": "def add(a: int, b: int) -> int:\n    \"\"\"\n    يجمع عددين صحيحين معًا.\n\n    Parameters:\n    a (int): الرقم الأول الذي سيتم جمعه.\n    b (int): الرقم الثاني الذي سيتم جمعه.\n\n    يعيد:\n    int: مجموع العددين.\n    \"\"\"", "sw": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Huongeza namba mbili za integer pamoja.\n\n    Parameters:\n    a (int): Namba ya kwanza ya kuongezwa.\n    b (int): Namba ya pili ya kuongezwa.\n\n    Inarejesha:\n    int: Jumla ya namba hizo mbili.\n    \"\"\"", "tr": "def add(a: int, b: int) -> int:\n    \"\"\"\n    İki tam sayıyı toplar.\n\n    Parametreler:\n    a (int): Toplanacak ilk sayı.\n    b (int): Toplanacak ikinci sayı.\n\n    Döndürülen:\n    int: İki sayının toplamı.\n    \"\"\"", "vi": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Cộng hai số nguyên lại với nhau.\n\n    Tham số:\n    a (int): Số thứ nhất để cộng.\n    b (int): Số thứ hai để cộng.\n\n    Trả về:\n    int: Tổng của hai số.\n    \"\"\"", "id": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Menambahkan dua angka integer bersama-sama.\n\n    Parameter:\n    a (int): Angka pertama yang akan ditambahkan.\n    b (int): Angka kedua yang akan ditambahkan.\n\n    Mengembalikan:\n    int: Jumlah dari dua angka.\n    \"\"\"", "ja": "def add(a: int, b: int) -> int:\n    \"\"\"\n    2つの整数を加算します。\n\n    Parameters:\n    a (int): 加算される最初の数。\n    b (int): 加算される2番目の数。\n\n    Returns:\n    int: 2つの数の合計。\n    \"\"\"", "ko": "def add(a: int, b: int) -> int:\n    \"\"\"\n    두 정수를 더합니다.\n\n    매개변수:\n    a (int): 더할 첫 번째 숫자.\n    b (int): 더할 두 번째 숫자.\n\n    반환값:\n    int: 두 숫자의 합.\n    \"\"\"", "ml": "def add(a: int, b: int) -> int:\n    \"\"\"\n    രണ്ട് പൂർണ്ണസംഖ്യകളെ ചേർക്കുന്നു.\n\n    Parameters:\n    a (int): ചേർക്കേണ്ട ആദ്യ സംഖ്യ.\n    b (int): ചേർക്കേണ്ട രണ്ടാം സംഖ്യ.\n\n    Returns:\n    int: രണ്ട് സംഖ്യകളുടെ മൊത്തം.\n    \"\"\"", "fa": "def add(a: int, b: int) -> int:\n    \"\"\"\n    دو عدد صحیح را با هم جمع می‌کند.\n\n    پارامترها:\n    a (int): عدد اولی که باید جمع شود.\n    b (int): عدد دومی که باید جمع شود.\n\n    بازگشت:\n    int: مجموع دو عدد.\n    \"\"\""}, "canonical_solution": "    return a + b", "instruction": {"en": "Write a python function 'def add(a: int, b: int) -> int:' to solve the following problem:\n\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    ", "sq": "Shkruani një funksion python 'def add(a: int, b: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Shton dy numra të plotë së bashku.\n\n    Parametrat:\n    a (int): Numri i parë që do të shtohet.\n    b (int): Numri i dytë që do të shtohet.\n\n    Kthen:\n    int: Shuma e dy numrave.", "hy": "Պայթոն ֆունկցիա 'def add(a: int, b: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Գումարում է երկու ամբողջ թվեր միասին։\n\n    Պարամետրեր:\n    a (int): Առաջին թիվը, որը պետք է գումարվի։\n    b (int): Երկրորդ թիվը, որը պետք է գումարվի։\n\n    Վերադարձնում է:\n    int: Երկու թվերի գումարը։", "bn": "একটি পাইথন ফাংশন 'def add(a: int, b: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    দুটি পূর্ণসংখ্যা একসাথে যোগ করে।\n\n    প্যারামিটার:\n    a (int): প্রথম সংখ্যা যা যোগ করা হবে।\n    b (int): দ্বিতীয় সংখ্যা যা যোগ করা হবে।\n\n    রিটার্নস:\n    int: দুটি সংখ্যার যোগফল।", "bg": "Напишете Python функция 'def add(a: int, b: int) -> int:' за решаване на следния проблем:\n\n    Събира две цели числа заедно.\n\n    Параметри:\n    a (int): Първото число, което ще бъде добавено.\n    b (int): Второто число, което ще бъде добавено.\n\n    Връща:\n    int: Сумата от двете числа.", "zh": "编写一个python函数 'def add(a: int, b: int) -> int:' 来解决以下问题：\n\n    将两个整数相加。\n\n    参数:\n    a (int): 第一个要相加的数字。\n    b (int): 第二个要相加的数字。\n\n    返回:\n    int: 两个数字的和。", "fr": "Écrivez une fonction python 'def add(a: int, b: int) -> int:' pour résoudre le problème suivant :\n\n    Ajoute deux nombres entiers ensemble.\n\n    Paramètres:\n    a (int): Le premier nombre à ajouter.\n    b (int): Le deuxième nombre à ajouter.\n\n    Renvoie:\n    int: La somme des deux nombres.", "de": "Schreiben Sie eine Python-Funktion 'def add(a: int, b: int) -> int:', um das folgende Problem zu lösen:\n\n    Addiert zwei ganze Zahlen zusammen.\n\n    Parameter:\n    a (int): Die erste Zahl, die addiert werden soll.\n    b (int): Die zweite Zahl, die addiert werden soll.\n\n    Gibt zurück:\n    int: Die Summe der beiden Zahlen.", "ha": "Rubuta wani aikin python 'def add(a: int, b: int) -> int:' don warware matsalar mai zuwa:\n\n    Ƙara lambobi guda biyu na cikakken lamba tare.\n\n    Sigogi:\n    a (int): Lambar farko da za a ƙara.\n    b (int): Lambar ta biyu da za a ƙara.\n\n    Yana dawowa:\n    int: Jimillar lambobin biyu.", "hi": "एक पायथन फ़ंक्शन 'def add(a: int, b: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दो पूर्णांक संख्याओं को एक साथ जोड़ता है।\n\n    पैरामीटर्स:\n    a (int): जोड़ने के लिए पहली संख्या।\n    b (int): जोड़ने के लिए दूसरी संख्या।\n\n    लौटाता है:\n    int: दोनों संख्याओं का योग।", "hu": "Írj egy python függvényt 'def add(a: int, b: int) -> int:' a következő probléma megoldására:\n\n    Két egész számot összead.\n\n    Paraméterek:\n    a (int): Az első szám, amit hozzá kell adni.\n    b (int): A második szám, amit hozzá kell adni.\n\n    Visszatér:\n    int: A két szám összege.", "es": "Escribe una función de Python 'def add(a: int, b: int) -> int:' para resolver el siguiente problema:\n\n    Suma dos números enteros.\n\n    Parámetros:\n    a (int): El primer número a sumar.\n    b (int): El segundo número a sumar.\n\n    Devuelve:\n    int: La suma de los dos números.", "arb": "اكتب دالة بايثون 'def add(a: int, b: int) -> int:' لحل المشكلة التالية:\n\n    يجمع عددين صحيحين معًا.\n\n    المعاملات:\n    a (int): الرقم الأول الذي سيتم جمعه.\n    b (int): الرقم الثاني الذي سيتم جمعه.\n\n    يعيد:\n    int: مجموع الرقمين.", "sw": "Andika kazi ya python 'def add(a: int, b: int) -> int:' kutatua tatizo lifuatalo:\n\n    Huongeza namba mbili za mzima pamoja.\n\n    Vigezo:\n    a (int): Namba ya kwanza ya kuongezwa.\n    b (int): Namba ya pili ya kuongezwa.\n\n    Inarejesha:\n    int: Jumla ya namba hizo mbili.", "tr": "Aşağıdaki problemi çözmek için bir python fonksiyonu 'def add(a: int, b: int) -> int:' yazın:\n\n    İki tam sayıyı toplar.\n\n    Parametreler:\n    a (int): Toplanacak ilk sayı.\n    b (int): Toplanacak ikinci sayı.\n\n    Döndürür:\n    int: İki sayının toplamı.", "vi": "Viết một hàm python 'def add(a: int, b: int) -> int:' để giải quyết vấn đề sau:\n\n    Cộng hai số nguyên lại với nhau.\n\n    Tham số:\n    a (int): Số thứ nhất cần cộng.\n    b (int): Số thứ hai cần cộng.\n\n    Trả về:\n    int: Tổng của hai số.", "id": "Tulis fungsi python 'def add(a: int, b: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Menambahkan dua bilangan bulat bersama-sama.\n\n    Parameter:\n    a (int): Angka pertama yang akan ditambahkan.\n    b (int): Angka kedua yang akan ditambahkan.\n\n    Mengembalikan:\n    int: Jumlah dari dua angka.", "ja": "次の問題を解決するためにPython関数を作成してください 'def add(a: int, b: int) -> int:':\n\n    2つの整数を加算します。\n\n    パラメータ:\n    a (int): 加算する最初の数。\n    b (int): 加算する2番目の数。\n\n    戻り値:\n    int: 2つの数の合計。", "ko": "다음 문제를 해결하기 위해 파이썬 함수를 작성하세요:\n\n    두 정수 숫자를 더합니다.\n\n    매개변수:\n    a (int): 더할 첫 번째 숫자.\n    b (int): 더할 두 번째 숫자.\n\n    반환값:\n    int: 두 숫자의 합.", "ml": "'def add(a: int, b: int) -> int:' എന്ന python ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    രണ്ട് പൂർണ്ണസംഖ്യകളെ തമ്മിൽ ചേർക്കുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    a (int): ചേർക്കേണ്ട ആദ്യ സംഖ്യ.\n    b (int): ചേർക്കേണ്ട രണ്ടാം സംഖ്യ.\n\n    മടക്കുന്നു:\n    int: ഈ രണ്ട് സംഖ്യകളുടെ ആകെ ഫലം.", "fa": "یک تابع پایتون بنویسید 'def add(a: int, b: int) -> int:' برای حل مسئله زیر:\n\n    دو عدد صحیح را با هم جمع می‌کند.\n\n    پارامترها:\n    a (int): عدد اولی که باید جمع شود.\n    b (int): عدد دومی که باید جمع شود.\n\n    بازگشت:\n    int: مجموع دو عدد."}, "level": "easy", "test": "# Test cases:\n# The following lines are not part of the function's implementation but are provided\n# for testing purposes.\n\n# Test case 1: Positive integers\nassert add(2, 3) == 5\n\n# Test case 2: A positive and a negative integer\nassert add(-1, 1) == 0\n\n# Test case 3: Two negative integers\nassert add(-4, -5) == -9\n\n# Test case 4: Zeroes\nassert add(0, 0) == 0\n\n# Test case 5: Large integers\nassert add(123456, 654321) == 777777\n\nprint(\"All test cases passed.\")", "entry_point": "add", "signature": "def add(a: int, b: int) -> int:", "docstring": {"en": "\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    ", "sq": "\n    Shton dy numra të plotë së bashku.\n\n    Parametrat:\n    a (int): Numri i parë që do të shtohet.\n    b (int): Numri i dytë që do të shtohet.\n\n    Kthen:\n    int: Shuma e dy numrave.\n    ", "hy": "\n    Գումարում է երկու ամբողջ թվեր:\n\n    Պարամետրեր:\n    a (int): Առաջին թիվը, որը պետք է գումարվի:\n    b (int): Երկրորդ թիվը, որը պետք է գումարվի:\n\n    Վերադարձնում է:\n    int: Երկու թվերի գումարը.\n    ", "bn": "\n    দুটি পূর্ণসংখ্যা যোগ করে।\n\n    প্যারামিটারসমূহ:\n    a (int): যোগ করার জন্য প্রথম সংখ্যা।\n    b (int): যোগ করার জন্য দ্বিতীয় সংখ্যা।\n\n    রিটার্নস:\n    int: দুটি সংখ্যার যোগফল।\n    ", "bg": "\n    Събира две цели числа.\n\n    Параметри:\n    a (int): Първото число за събиране.\n    b (int): Второто число за събиране.\n\n    Връща:\n    int: Сумата на двете числа.\n    ", "zh": "\n    将两个整数相加。\n\n    参数:\n    a (int): 要相加的第一个数字。\n    b (int): 要相加的第二个数字。\n\n    返回:\n    int: 两个数字的和。\n    ", "fr": "\n    Ajoute deux nombres entiers ensemble.\n\n    Paramètres:\n    a (int): Le premier nombre à ajouter.\n    b (int): Le deuxième nombre à ajouter.\n\n    Retourne:\n    int: La somme des deux nombres.\n    ", "de": "\n    Addiert zwei ganze Zahlen miteinander.\n\n    Parameter:\n    a (int): Die erste Zahl, die addiert werden soll.\n    b (int): Die zweite Zahl, die addiert werden soll.\n\n    Rückgabewert:\n    int: Die Summe der beiden Zahlen.\n    ", "ha": "\n    Ƙara lambobi guda biyu masu cikakken lamba tare.\n\n    Sigogi:\n    a (int): Lamba ta farko da za a ƙara.\n    b (int): Lamba ta biyu da za a ƙara.\n\n    Dawowa:\n    int: Jimillar lambobi biyun.\n    ", "hi": "\n    दो पूर्णांक संख्याओं को एक साथ जोड़ता है।\n\n    पैरामीटर:\n    a (int): जोड़ने के लिए पहली संख्या।\n    b (int): जोड़ने के लिए दूसरी संख्या।\n\n    रिटर्न:\n    int: दोनों संख्याओं का योग।", "hu": "\n    Két egész számot ad össze.\n\n    Paraméterek:\n    a (int): Az első szám, amelyet hozzá kell adni.\n    b (int): A második szám, amelyet hozzá kell adni.\n\n    Visszatér:\n    int: A két szám összege.\n    ", "es": "\n    Suma dos números enteros.\n\n    Parámetros:\n    a (int): El primer número a sumar.\n    b (int): El segundo número a sumar.\n\n    Devuelve:\n    int: La suma de los dos números.", "arb": "\n    يجمع عددين صحيحين معًا.\n\n    Parameters:\n    a (int): الرقم الأول الذي سيتم جمعه.\n    b (int): الرقم الثاني الذي سيتم جمعه.\n\n    يعيد:\n    int: مجموع الرقمين.", "sw": "\n    Huongeza namba mbili za integer pamoja.\n\n    Vigezo:\n    a (int): Namba ya kwanza ya kuongezwa.\n    b (int): Namba ya pili ya kuongezwa.\n\n    Inarudisha:\n    int: Jumla ya namba hizo mbili.", "tr": "\n    İki tam sayıyı toplar.\n\n    Parametreler:\n    a (int): Toplanacak ilk sayı.\n    b (int): Toplanacak ikinci sayı.\n\n    Döndürülenler:\n    int: İki sayının toplamı.", "vi": "\n    Cộng hai số nguyên với nhau.\n\n    Tham số:\n    a (int): Số thứ nhất cần được cộng.\n    b (int): Số thứ hai cần được cộng.\n\n    Trả về:\n    int: Tổng của hai số.", "id": "    Menambahkan dua bilangan bulat bersama-sama.\n\n    Parameters:\n    a (int): Angka pertama yang akan ditambahkan.\n    b (int): Angka kedua yang akan ditambahkan.\n\n    Returns:\n    int: Jumlah dari dua angka tersebut.", "ja": "    2つの整数を加算します。\n\n    Parameters:\n    a (int): 加算される最初の数。\n    b (int): 加算される2番目の数。\n\n    Returns:\n    int: 2つの数の合計。", "ko": "    두 정수 숫자를 더합니다.\n\n    매개변수:\n    a (int): 더할 첫 번째 숫자입니다.\n    b (int): 더할 두 번째 숫자입니다.\n\n    반환값:\n    int: 두 숫자의 합입니다.", "ml": "    രണ്ട് പൂർണ്ണസംഖ്യകളെ കൂട്ടിച്ചേർക്കുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    a (int): ചേർക്കേണ്ട ആദ്യ സംഖ്യ.\n    b (int): ചേർക്കേണ്ട രണ്ടാം സംഖ്യ.\n\n    മടക്കുന്നു:\n    int: രണ്ട് സംഖ്യകളുടെ മൊത്തം.", "fa": "    دو عدد صحیح را با هم جمع می‌کند.\n\n    پارامترها:\n    a (int): عدد اول برای جمع شدن.\n    b (int): عدد دوم برای جمع شدن.\n\n    بازگشت:\n    int: مجموع دو عدد."}}
{"task_id": "Python/7", "prompt": {"en": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "sq": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Gjen qilimin më të sipërm që mbulon një pikë të dhënë në planin koordinativ.\n\n    Args:\n    n (int): Numri total i qilimave.\n    carpets (list of tuples): Një listë që përmban n tufa, secila që përfaqëson informacionin e një qilimi.\n                              Çdo tufë përmban katër numra të plotë (a, b, g, k) ku (a, b) janë\n                              koordinatat e këndit të poshtëm të majtë të qilimit dhe (g, k) janë\n                              gjatësitë e qilimit përgjatë boshtit x dhe y përkatësisht.\n    point (tuple): Një tufë që përmban dy numra të plotë (x, y), koordinatat e pikës për të kontrolluar.\n\n    Returns:\n    int: Numri i qilimit më të sipërm që mbulon pikën (x, y), ose -1 nëse asnjë qilim nuk e mbulon atë.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "hy": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Գտնում է տրված կետը ծածկող ամենավերին գորգը կոորդինատային հարթության վրա:\n\n    Պարամետրեր:\n    n (int): Գորգերի ընդհանուր քանակը:\n    carpets (list of tuples): Ցուցակ, որը պարունակում է n տուփեր, յուրաքանչյուրն ներկայացնում է գորգի մասին տեղեկատվությունը:\n                              Յուրաքանչյուր տուփ պարունակում է չորս ամբողջ թիվ (a, b, g, k), որտեղ (a, b) \n                              գորգի ներքևի ձախ անկյունի կոորդինատներն են, իսկ (g, k) գորգի երկարությունները \n                              համապատասխանաբար x և y առանցքների երկայնքով:\n    point (tuple): Տուփ, որը պարունակում է երկու ամբողջ թիվ (x, y), կետը ստուգելու կոորդինատները:\n\n    Վերադարձնում է:\n    int: Ամենավերին գորգի համարը, որը ծածկում է կետը (x, y), կամ -1, եթե ոչ մի գորգ չի ծածկում այն:\n\n    Օրինակներ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "bn": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    সমন্বয় সমতলে একটি নির্দিষ্ট বিন্দু আচ্ছাদনকারী সর্বোচ্চ কার্পেট খুঁজে বের করে।\n\n    আর্গস:\n    n (int): মোট কার্পেটের সংখ্যা।\n    carpets (list of tuples): একটি তালিকা যা n টুপল ধারণ করে, প্রতিটি টুপল একটি কার্পেটের তথ্য উপস্থাপন করে।\n                              প্রতিটি টুপলে চারটি পূর্ণসংখ্যা (a, b, g, k) থাকে যেখানে (a, b) হল\n                              কার্পেটের নিচের-বাম কোণের সমন্বয় এবং (g, k) হল x এবং y অক্ষ বরাবর কার্পেটের দৈর্ঘ্য।\n    point (tuple): একটি টুপল যা দুটি পূর্ণসংখ্যা (x, y) ধারণ করে, চেক করার জন্য বিন্দুর সমন্বয়।\n\n    রিটার্নস:\n    int: সর্বোচ্চ কার্পেটের সংখ্যা যা বিন্দু (x, y) আচ্ছাদন করে, অথবা -1 যদি কোনো কার্পেট এটি আচ্ছাদন না করে।\n\n    উদাহরণ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "bg": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Намира най-горния килим, покриващ дадена точка в координатната равнина.\n\n    Args:\n    n (int): Общият брой килими.\n    carpets (list of tuples): Списък, съдържащ n кортежа, всеки от които представлява информация за килим.\n                              Всеки кортеж съдържа четири цели числа (a, b, g, k), където (a, b) са\n                              координатите на долния ляв ъгъл на килима, а (g, k) са дължините на килима\n                              по оста x и y съответно.\n    point (tuple): Кортеж, съдържащ две цели числа (x, y), координатите на точката за проверка.\n\n    Returns:\n    int: Номерът на най-горния килим, покриващ точката (x, y), или -1 ако няма килим, който да я покрива.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "zh": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    找到覆盖坐标平面上给定点的最上层地毯。\n\n    参数:\n    n (int): 地毯的总数量。\n    carpets (list of tuples): 包含 n 个元组的列表，每个元组代表一个地毯的信息。\n                              每个元组包含四个整数 (a, b, g, k)，其中 (a, b) 是地毯左下角的坐标，\n                              (g, k) 是地毯在 x 和 y 轴上的长度。\n    point (tuple): 包含两个整数 (x, y) 的元组，要检查的点的坐标。\n\n    返回:\n    int: 覆盖点 (x, y) 的最上层地毯的编号，如果没有地毯覆盖该点，则返回 -1。\n\n    示例:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "fr": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Trouve le tapis le plus haut couvrant un point donné sur le plan de coordonnées.\n\n    Arguments:\n    n (int): Le nombre total de tapis.\n    carpets (list of tuples): Une liste contenant n tuples, chacun représentant les informations d'un tapis.\n                              Chaque tuple contient quatre entiers (a, b, g, k) où (a, b) sont les\n                              coordonnées du coin inférieur gauche du tapis et (g, k) sont\n                              les longueurs du tapis le long de l'axe x et y respectivement.\n    point (tuple): Un tuple contenant deux entiers (x, y), les coordonnées du point à vérifier.\n\n    Retourne:\n    int: Le numéro du tapis le plus haut couvrant le point (x, y), ou -1 si aucun tapis ne le couvre.\n\n    Exemples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "de": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Findet den obersten Teppich, der einen gegebenen Punkt auf der Koordinatenebene bedeckt.\n\n    Args:\n    n (int): Die Gesamtanzahl der Teppiche.\n    carpets (list of tuples): Eine Liste, die n Tupel enthält, von denen jedes die Informationen eines Teppichs darstellt.\n                              Jedes Tupel enthält vier ganze Zahlen (a, b, g, k), wobei (a, b) die\n                              Koordinaten der unteren linken Ecke des Teppichs sind und (g, k) die\n                              Längen des Teppichs entlang der x- und y-Achse sind.\n    point (tuple): Ein Tupel, das zwei ganze Zahlen (x, y) enthält, die Koordinaten des zu überprüfenden Punktes.\n\n    Returns:\n    int: Die Nummer des obersten Teppichs, der den Punkt (x, y) bedeckt, oder -1, wenn kein Teppich ihn bedeckt.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "ha": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Nemo tabarmar da take saman sauran tabarma waɗanda ke rufe wani wuri a kan tsarin daidaitawa.\n\n    Args:\n    n (int): Jimillar adadin tabarmai.\n    carpets (list of tuples): Jerin da ke ɗauke da n tuplai, kowanne yana wakiltar bayanin tabarma.\n                              Kowanne tupla yana ƙunshe da lambobi huɗu (a, b, g, k) inda (a, b) \n                              suke matsayin daidaitawar kusurwar ƙasa-hagu na tabarma kuma (g, k) \n                              su ne tsawon tabarma a kan x da y axis bi da bi.\n    point (tuple): Tupla da ke ƙunshe da lambobi biyu (x, y), daidaitawar wurin da za a duba.\n\n    Returns:\n    int: Lambar tabarmar da take saman sauran tabarmai da ke rufe wuri (x, y), ko -1 idan babu tabarma da ta rufe shi.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "hi": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    दिए गए बिंदु पर समन्वय तल पर सबसे ऊपर का कालीन खोजें।\n\n    Args:\n    n (int): कुल कालीनों की संख्या।\n    carpets (list of tuples): एक सूची जिसमें n ट्यूपल होते हैं, प्रत्येक एक कालीन की जानकारी का प्रतिनिधित्व करता है।\n                              प्रत्येक ट्यूपल में चार पूर्णांक (a, b, g, k) होते हैं जहाँ (a, b)\n                              कालीन के नीचे-बाएँ कोने के समन्वय होते हैं और (g, k) क्रमशः x और y अक्ष पर कालीन की लंबाई होती है।\n    point (tuple): एक ट्यूपल जिसमें दो पूर्णांक (x, y) होते हैं, जाँचने के लिए बिंदु के समन्वय।\n\n    Returns:\n    int: बिंदु (x, y) को ढकने वाला सबसे ऊपर का कालीन संख्या, या -1 यदि कोई कालीन इसे नहीं ढकता।\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "hu": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Megtalálja a koordináta síkon egy adott pontot lefedő legfelső szőnyeget.\n\n    Args:\n    n (int): A szőnyegek teljes száma.\n    carpets (list of tuples): Egy lista, amely n darab tuple-t tartalmaz, mindegyik egy szőnyeg információját képviseli.\n                              Minden tuple négy egész számot tartalmaz (a, b, g, k), ahol (a, b) a szőnyeg bal alsó sarkának\n                              koordinátái, és (g, k) a szőnyeg hosszai az x és y tengely mentén.\n    point (tuple): Egy tuple, amely két egész számot tartalmaz (x, y), a vizsgálandó pont koordinátái.\n\n    Returns:\n    int: A pontot (x, y) lefedő legfelső szőnyeg száma, vagy -1, ha egyetlen szőnyeg sem fedi le.\n\n    Példák:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "es": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Encuentra la alfombra más superior que cubre un punto dado en el plano de coordenadas.\n\n    Argumentos:\n    n (int): El número total de alfombras.\n    carpets (list of tuples): Una lista que contiene n tuplas, cada una representando la información de una alfombra.\n                              Cada tupla contiene cuatro enteros (a, b, g, k) donde (a, b) son las\n                              coordenadas de la esquina inferior izquierda de la alfombra y (g, k) son\n                              las longitudes de la alfombra a lo largo del eje x e y respectivamente.\n    point (tuple): Una tupla que contiene dos enteros (x, y), las coordenadas del punto a verificar.\n\n    Devuelve:\n    int: El número de la alfombra más superior que cubre el punto (x, y), o -1 si ninguna alfombra lo cubre.\n\n    Ejemplos:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "arb": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    يجد السجادة العليا التي تغطي نقطة معينة على مستوى الإحداثيات.\n\n    يعيدالحجج:\n    n (int): العدد الإجمالي للسجاد.\n    carpets (list of tuples): قائمة تحتوي على n من الأزواج المرتبة، كل منها يمثل معلومات السجادة.\n                              يحتوي كل زوج على أربعة أعداد صحيحة (a, b, g, k) حيث (a, b) هي\n                              إحداثيات الزاوية السفلية اليسرى للسجادة و(g, k) هي\n                              أطوال السجادة على طول المحورين x و y على التوالي.\n    point (tuple): زوج مرتب يحتوي على عددين صحيحين (x, y)، إحداثيات النقطة المراد التحقق منها.\n\n    يعيد:\n    int: رقم السجادة العليا التي تغطي النقطة (x, y)، أو -1 إذا لم تغطيها أي سجادة.\n\n    امثله:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "sw": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Inapata zulia la juu zaidi linalofunika nukta fulani kwenye ndege ya kuratibu.\n\n    Hoja:\n    n (int): Jumla ya idadi ya mazulia.\n    carpets (list of tuples): Orodha inayo na n tuples, kila moja ikiwakilisha taarifa ya zulia.\n                              Kila tuple ina integer nne (a, b, g, k) ambapo (a, b) ni\n                              kuratibu za kona ya chini-kushoto ya zulia na (g, k) ni\n                              urefu wa zulia kando ya mhimili wa x na y mtawalia.\n    point (tuple): Tuple inayo na integer mbili (x, y), kuratibu za nukta ya kuangalia.\n\n    Inarejesha:\n    int: Namba ya zulia la juu zaidi linalofunika nukta (x, y), au -1 kama hakuna zulia linaloifunika.\n\n    Mifano:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "tr": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Koordinat düzleminde verilen bir noktayı kaplayan en üstteki halıyı bulur.\n\n    Argümanlar:\n    n (int): Toplam halı sayısı.\n    carpets (list of tuples): Her biri bir halının bilgisini temsil eden n adet demet içeren bir liste.\n                              Her demet dört tam sayı (a, b, g, k) içerir, burada (a, b) halının\n                              sol alt köşesinin koordinatlarıdır ve (g, k) sırasıyla x ve y ekseni\n                              boyunca halının uzunluklarıdır.\n    point (tuple): Kontrol edilecek noktanın koordinatlarını içeren iki tam sayılık bir demet (x, y).\n\n    Döndürür:\n    int: Noktayı (x, y) kaplayan en üstteki halının numarası veya hiçbir halı kaplamıyorsa -1.\n\n    Örnekler:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "vi": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Tìm tấm thảm trên cùng bao phủ một điểm nhất định trên mặt phẳng tọa độ.\n\n    Tham số:\n    n (int): Tổng số tấm thảm.\n    carpets (list of tuples): Một danh sách chứa n bộ, mỗi bộ đại diện cho thông tin của một tấm thảm.\n                              Mỗi bộ chứa bốn số nguyên (a, b, g, k) trong đó (a, b) là\n                              tọa độ của góc dưới bên trái của tấm thảm và (g, k) là\n                              chiều dài của tấm thảm theo trục x và y tương ứng.\n    point (tuple): Một bộ chứa hai số nguyên (x, y), tọa độ của điểm cần kiểm tra.\n\n    Trả về:\n    int: Số của tấm thảm trên cùng bao phủ điểm (x, y), hoặc -1 nếu không có tấm thảm nào bao phủ nó.\n\n    Ví dụ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "id": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Menemukan karpet paling atas yang menutupi titik tertentu pada bidang koordinat.\n\n    Argumen:\n    n (int): Jumlah total karpet.\n    carpets (list of tuples): Daftar yang berisi n tuple, masing-masing mewakili informasi karpet.\n                              Setiap tuple berisi empat bilangan bulat (a, b, g, k) di mana (a, b) adalah\n                              koordinat sudut kiri bawah karpet dan (g, k) adalah\n                              panjang karpet sepanjang sumbu x dan y masing-masing.\n    point (tuple): Sebuah tuple yang berisi dua bilangan bulat (x, y), koordinat titik yang akan diperiksa.\n\n    Mengembalikan:\n    int: Nomor karpet paling atas yang menutupi titik (x, y), atau -1 jika tidak ada karpet yang menutupinya.\n\n    Contoh:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "ja": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    指定された座標平面上のポイントを覆う最上のカーペットを見つけます。\n\n    引数:\n    n (int): カーペットの総数。\n    carpets (list of tuples): 各タプルがカーペットの情報を表すn個のタプルを含むリスト。\n                              各タプルは4つの整数 (a, b, g, k) を含み、(a, b) は\n                              カーペットの左下隅の座標で、(g, k) はそれぞれx軸とy軸に沿った\n                              カーペットの長さです。\n    point (tuple): 2つの整数 (x, y) を含むタプルで、チェックするポイントの座標です。\n\n    戻り値:\n    int: ポイント (x, y) を覆う最上のカーペットの番号、またはカーペットがそれを覆わない場合は-1。\n\n    例:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "ko": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    주어진 좌표 평면의 점을 덮고 있는 가장 위에 있는 카펫을 찾습니다.\n\n    Args:\n    n (int): 카펫의 총 개수.\n    carpets (list of tuples): 각 카펫의 정보를 나타내는 n개의 튜플을 포함하는 리스트.\n                              각 튜플은 네 개의 정수 (a, b, g, k)를 포함하며, (a, b)는\n                              카펫의 왼쪽 아래 모서리의 좌표이고 (g, k)는 각각 x축과 y축을 따라\n                              카펫의 길이입니다.\n    point (tuple): 두 개의 정수 (x, y)를 포함하는 튜플로, 확인할 점의 좌표입니다.\n\n    Returns:\n    int: 점 (x, y)를 덮고 있는 가장 위에 있는 카펫의 번호, 또는 어떤 카펫도 덮고 있지 않으면 -1을 반환합니다.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "ml": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    കൊഓർഡിനേറ്റ് പ്ലെയിനിലെ ഒരു നിർദ്ദിഷ്ട ബിന്ദുവിൽ മുകളിൽ കിടക്കുന്ന പായയെ കണ്ടെത്തുന്നു.\n\n    Args:\n    n (int): പായകളുടെ ആകെ എണ്ണം.\n    carpets (list of tuples): ഓരോ പായയുടെ വിവരങ്ങൾ പ്രതിനിധീകരിക്കുന്ന n ട്യൂപ്പിളുകൾ അടങ്ങിയ ഒരു ലിസ്റ്റ്.\n                              ഓരോ ട്യൂപ്പിളിലും നാല് പൂർണ്ണസംഖ്യകൾ (a, b, g, k) അടങ്ങിയിരിക്കും, \n                              ഇവിടെ (a, b) പായയുടെ വലതുകീഴ്ന്നിലത്തെ മൂലയുടെ \n                              കൊഓർഡിനേറ്റുകളാണ്, (g, k) യഥാക്രമം x, y അക്ഷങ്ങളിലേക്കുള്ള പായയുടെ നീളങ്ങളാണ്.\n    point (tuple): പരിശോധിക്കേണ്ട ബിന്ദുവിന്റെ കൊഓർഡിനേറ്റുകൾ അടങ്ങിയ രണ്ട് പൂർണ്ണസംഖ്യകൾ (x, y) ഉള്ള ഒരു ട്യൂപ്പിൾ.\n\n    Returns:\n    int: ബിന്ദു (x, y) മൂടുന്ന മുകളിൽ കിടക്കുന്ന പായയുടെ നമ്പർ, അല്ലെങ്കിൽ ഒരു പായയും മൂടുന്നില്ലെങ്കിൽ -1.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "fa": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    بالاترین فرش پوشاننده یک نقطه خاص در صفحه مختصات را پیدا می‌کند.\n\n    Args:\n    n (int): تعداد کل فرش‌ها.\n    carpets (list of tuples): لیستی شامل n تاپل، که هر کدام نشان‌دهنده اطلاعات یک فرش است.\n                              هر تاپل شامل چهار عدد صحیح (a, b, g, k) است که (a, b) مختصات\n                              گوشه پایین-چپ فرش و (g, k) طول‌های فرش در امتداد محور x و y به ترتیب هستند.\n    point (tuple): یک تاپل شامل دو عدد صحیح (x, y)، مختصات نقطه‌ای که باید بررسی شود.\n\n    Returns:\n    int: شماره بالاترین فرش پوشاننده نقطه (x, y)، یا -1 اگر هیچ فرشی آن را نپوشاند.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\""}, "canonical_solution": "    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point", "instruction": {"en": "Write a python function 'def find_topmost_carpet(n, carpets, point) -> int:' to solve the following problem:\n\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ", "sq": "Shkruani një funksion python 'def find_topmost_carpet(n, carpets, point) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Gjen tapetin më të sipërm që mbulon një pikë të dhënë në planin koordinativ.\n\n    Argumentet:\n    n (int): Numri total i tapetëve.\n    carpets (list of tuples): Një listë që përmban n tufa, secila që përfaqëson informacionin e një tapeti.\n                              Çdo tufë përmban katër numra të plotë (a, b, g, k) ku (a, b) janë\n                              koordinatat e këndit të poshtëm të majtë të tapetit dhe (g, k) janë\n                              gjatësitë e tapetit përgjatë boshtit x dhe y përkatësisht.\n    point (tuple): Një tufë që përmban dy numra të plotë (x, y), koordinatat e pikës për të kontrolluar.\n\n    Kthen:\n    int: Numri i tapetit më të sipërm që mbulon pikën (x, y), ose -1 nëse asnjë tapet nuk e mbulon atë.\n\n    Shembuj:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "hy": "Պայթոն ֆունկցիա 'def find_topmost_carpet(n, carpets, point) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Տրված կոորդինատային հարթության վրա կետը ծածկող ամենավերին գորգը գտնել:\n\n    Args:\n    n (int): Գորգերի ընդհանուր քանակը:\n    carpets (list of tuples): Ցանկ, որը պարունակում է n տուփեր, որոնցից յուրաքանչյուրը ներկայացնում է գորգի մասին տեղեկատվությունը:\n                              Յուրաքանչյուր տուփ պարունակում է չորս ամբողջ թիվ (a, b, g, k), որտեղ (a, b) \n                              գորգի ներքևի ձախ անկյունի կոորդինատներն են, իսկ (g, k) գորգի երկարությունները \n                              համապատասխանաբար x և y առանցքների երկայնքով:\n    point (tuple): Տուփ, որը պարունակում է երկու ամբողջ թիվ (x, y), այն կետի կոորդինատները, որը պետք է ստուգել:\n\n    Returns:\n    int: Կետի (x, y) վրա գտնվող ամենավերին գորգի համարը, կամ -1, եթե ոչ մի գորգ չի ծածկում այն:\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "bn": "একটি পাইথন ফাংশন 'def find_topmost_carpet(n, carpets, point) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    প্রদত্ত বিন্দুতে স্থানাঙ্ক সমতলে যে কার্পেটটি সবচেয়ে উপরে রয়েছে তা খুঁজে বের করুন।\n\n    আর্গুমেন্টস:\n    n (int): মোট কার্পেটের সংখ্যা।\n    carpets (list of tuples): একটি তালিকা যা n টুপল ধারণ করে, প্রতিটি টুপল একটি কার্পেটের তথ্য উপস্থাপন করে।\n                              প্রতিটি টুপলে চারটি পূর্ণসংখ্যা (a, b, g, k) থাকে যেখানে (a, b) হল\n                              কার্পেটের নিচের-বাম কোণের স্থানাঙ্ক এবং (g, k) হল\n                              যথাক্রমে x এবং y অক্ষ বরাবর কার্পেটের দৈর্ঘ্য।\n    point (tuple): একটি টুপল যা দুটি পূর্ণসংখ্যা (x, y) ধারণ করে, যাচাই করার জন্য বিন্দুর স্থানাঙ্ক।\n\n    রিটার্নস:\n    int: বিন্দু (x, y) কে আবৃতকারী সবচেয়ে উপরের কার্পেটের সংখ্যা, অথবা -1 যদি কোনো কার্পেট এটি আবৃত না করে।\n\n    উদাহরণ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "bg": "Напишете Python функция 'def find_topmost_carpet(n, carpets, point) -> int:', за да решите следния проблем:\n\n    Намира най-горния килим, покриващ дадена точка на координатната равнина.\n\n    Аргументи:\n    n (int): Общият брой на килимите.\n    carpets (list of tuples): Списък, съдържащ n кортежа, всеки от които представлява информация за килим.\n                              Всеки кортеж съдържа четири цели числа (a, b, g, k), където (a, b) са\n                              координатите на долния ляв ъгъл на килима, а (g, k) са\n                              дължините на килима по x и y осите съответно.\n    point (tuple): Кортеж, съдържащ две цели числа (x, y), координатите на точката за проверка.\n\n    Връща:\n    int: Номерът на най-горния килим, покриващ точката (x, y), или -1, ако няма килим, който да я покрива.\n\n    Примери:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "zh": "编写一个python函数 'def find_topmost_carpet(n, carpets, point) -> int:' 来解决以下问题：\n\n    找到在坐标平面上覆盖给定点的最上层地毯。\n\n    参数：\n    n (int): 地毯的总数量。\n    carpets (list of tuples): 包含n个元组的列表，每个元组代表一个地毯的信息。\n                              每个元组包含四个整数 (a, b, g, k)，其中 (a, b) 是地毯左下角的坐标，\n                              (g, k) 分别是地毯在x轴和y轴上的长度。\n    point (tuple): 包含两个整数 (x, y) 的元组，要检查的点的坐标。\n\n    返回：\n    int: 覆盖点 (x, y) 的最上层地毯的编号，如果没有地毯覆盖该点，则返回 -1。\n\n    示例：\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "fr": "Écrivez une fonction python 'def find_topmost_carpet(n, carpets, point) -> int:' pour résoudre le problème suivant :\n\n    Trouve le tapis le plus haut couvrant un point donné sur le plan de coordonnées.\n\n    Args:\n    n (int): Le nombre total de tapis.\n    carpets (list of tuples): Une liste contenant n tuples, chacun représentant les informations d'un tapis.\n                              Chaque tuple contient quatre entiers (a, b, g, k) où (a, b) sont\n                              les coordonnées du coin inférieur gauche du tapis et (g, k) sont\n                              les longueurs du tapis le long de l'axe x et y respectivement.\n    point (tuple): Un tuple contenant deux entiers (x, y), les coordonnées du point à vérifier.\n\n    Returns:\n    int: Le numéro du tapis le plus haut couvrant le point (x, y), ou -1 si aucun tapis ne le couvre.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "de": "Schreiben Sie eine Python-Funktion 'def find_topmost_carpet(n, carpets, point) -> int:', um das folgende Problem zu lösen:\n\n    Findet den obersten Teppich, der einen gegebenen Punkt auf der Koordinatenebene bedeckt.\n\n    Argumente:\n    n (int): Die Gesamtanzahl der Teppiche.\n    carpets (Liste von Tupeln): Eine Liste, die n Tupel enthält, von denen jedes die Informationen eines Teppichs darstellt.\n                              Jedes Tupel enthält vier ganze Zahlen (a, b, g, k), wobei (a, b) die\n                              Koordinaten der unteren linken Ecke des Teppichs sind und (g, k) die\n                              Längen des Teppichs entlang der x- bzw. y-Achse sind.\n    point (Tupel): Ein Tupel, das zwei ganze Zahlen (x, y) enthält, die Koordinaten des zu überprüfenden Punktes.\n\n    Rückgabewert:\n    int: Die Nummer des obersten Teppichs, der den Punkt (x, y) bedeckt, oder -1, wenn kein Teppich ihn bedeckt.\n\n    Beispiele:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "ha": "Rubuta aikin python 'def find_topmost_carpet(n, carpets, point) -> int:' don warware matsalar mai zuwa:\n\n    Nemi tabarma mafi sama da ke rufe wani wuri a kan tsararren tsari.\n\n    Args:\n    n (int): Jimillar adadin tabarma.\n    carpets (list of tuples): Jerin da ke dauke da n tuples, kowanne yana wakiltar bayanin tabarma.\n                              Kowanne tuple yana dauke da lambobi hudu (a, b, g, k) inda (a, b) \n                              suke matsayin ko'odinet na kusurwar kasa-hagu na tabarma kuma (g, k) \n                              sune tsawon tabarma a kan x da y axis bi da bi.\n    point (tuple): Tuple da ke dauke da lambobi biyu (x, y), ko'odinet na wurin da za a duba.\n\n    Returns:\n    int: Lambar tabarma mafi sama da ke rufe wurin (x, y), ko -1 idan babu tabarma da ke rufe shi.\n\n    Misalai:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "hi": "एक पायथन फ़ंक्शन 'def find_topmost_carpet(n, carpets, point) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए बिंदु पर निर्देशांक तल पर सबसे ऊपर का कालीन खोजें।\n\n    तर्क:\n    n (int): कुल कालीनों की संख्या।\n    carpets (list of tuples): n ट्यूपल्स की एक सूची, जिसमें प्रत्येक ट्यूपल एक कालीन की जानकारी का प्रतिनिधित्व करता है।\n                              प्रत्येक ट्यूपल में चार पूर्णांक (a, b, g, k) होते हैं जहाँ (a, b) कालीन के \n                              निचले-बाएँ कोने के निर्देशांक होते हैं और (g, k) क्रमशः x और y अक्ष के \n                              साथ कालीन की लंबाई होती है।\n    point (tuple): एक ट्यूपल जिसमें दो पूर्णांक (x, y) होते हैं, जो जांचने के लिए बिंदु के निर्देशांक होते हैं।\n\n    लौटाता है:\n    int: सबसे ऊपर के कालीन की संख्या जो बिंदु (x, y) को ढकता है, या -1 यदि कोई कालीन इसे नहीं ढकता।\n\n    उदाहरण:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "hu": "Írj egy python függvényt 'def find_topmost_carpet(n, carpets, point) -> int:' a következő probléma megoldására:\n\n    Megkeresi a koordinátasíkon egy adott pontot lefedő legfelső szőnyeget.\n\n    Argumentumok:\n    n (int): A szőnyegek teljes száma.\n    carpets (list of tuples): Egy lista, amely n darab tuple-t tartalmaz, mindegyik egy szőnyeg információját képviseli.\n                              Minden tuple négy egész számot tartalmaz (a, b, g, k), ahol (a, b) a szőnyeg bal alsó sarkának\n                              koordinátái, és (g, k) a szőnyeg hossza az x és y tengely mentén.\n    point (tuple): Egy tuple, amely két egész számot tartalmaz (x, y), a vizsgálandó pont koordinátái.\n\n    Visszatérési érték:\n    int: A pontot (x, y) lefedő legfelső szőnyeg száma, vagy -1, ha egyetlen szőnyeg sem fedi le.\n\n    Példák:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "es": "Escribe una función de Python 'def find_topmost_carpet(n, carpets, point) -> int:' para resolver el siguiente problema:\n\n    Encuentra la alfombra más alta que cubre un punto dado en el plano de coordenadas.\n\n    Argumentos:\n    n (int): El número total de alfombras.\n    carpets (list of tuples): Una lista que contiene n tuplas, cada una representando la información de una alfombra.\n                              Cada tupla contiene cuatro enteros (a, b, g, k) donde (a, b) son las\n                              coordenadas de la esquina inferior izquierda de la alfombra y (g, k) son\n                              las longitudes de la alfombra a lo largo del eje x e y respectivamente.\n    point (tuple): Una tupla que contiene dos enteros (x, y), las coordenadas del punto a verificar.\n\n    Devuelve:\n    int: El número de la alfombra más alta que cubre el punto (x, y), o -1 si ninguna alfombra lo cubre.\n\n    Ejemplos:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "arb": "اكتب دالة بايثون 'def find_topmost_carpet(n, carpets, point) -> int:' لحل المشكلة التالية:\n\n    إيجاد السجادة العليا التي تغطي نقطة معينة على مستوى الإحداثيات.\n\n    يعيدالحجج:\n    n (int): العدد الإجمالي للسجاد.\n    carpets (list of tuples): قائمة تحتوي على n من الأزواج، كل منها يمثل معلومات السجادة.\n                              يحتوي كل زوج على أربعة أعداد صحيحة (a, b, g, k) حيث أن (a, b) هي\n                              إحداثيات الزاوية السفلية اليسرى للسجادة و (g, k) هي\n                              أطوال السجادة على طول محوري x و y على التوالي.\n    point (tuple): زوج يحتوي على عددين صحيحين (x, y)، إحداثيات النقطة المراد التحقق منها.\n\n    يعيد:\n    int: رقم السجادة العليا التي تغطي النقطة (x, y)، أو -1 إذا لم تغطيها أي سجادة.\n\n    أمثلة:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "sw": "Andika kazi ya python 'def find_topmost_carpet(n, carpets, point) -> int:' kutatua tatizo lifuatalo:\n\n    Inapata zulia la juu kabisa linalofunika sehemu fulani kwenye ndege ya kuratibu.\n\n    Hoja:\n    n (int): Jumla ya idadi ya mazulia.\n    carpets (list of tuples): Orodha inayojumuisha n tuples, kila moja ikiwakilisha taarifa ya zulia.\n                              Kila tuple ina namba nne za mzima (a, b, g, k) ambapo (a, b) ni\n                              kuratibu za kona ya chini-kushoto ya zulia na (g, k) ni\n                              urefu wa zulia kando ya mhimili wa x na y mtawalia.\n    point (tuple): Tuple inayojumuisha namba mbili za mzima (x, y), kuratibu za sehemu ya kuangalia.\n\n    Inarejesha:\n    int: Namba ya zulia la juu kabisa linalofunika sehemu (x, y), au -1 ikiwa hakuna zulia linalofunika.\n\n    Mifano:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "tr": "Bir python fonksiyonu 'def find_topmost_carpet(n, carpets, point) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Koordinat düzleminde verilen bir noktayı kaplayan en üstteki halıyı bulur.\n\n    Argümanlar:\n    n (int): Toplam halı sayısı.\n    carpets (list of tuples): Her biri bir halının bilgilerini temsil eden n adet demet içeren bir liste.\n                              Her demet dört tamsayı (a, b, g, k) içerir, burada (a, b)\n                              halının sol alt köşesinin koordinatlarıdır ve (g, k) halının\n                              x ve y eksenleri boyunca uzunluklarıdır.\n    point (tuple): İki tamsayı (x, y) içeren bir demet, kontrol edilecek noktanın koordinatları.\n\n    Döndürür:\n    int: Nokta (x, y) üzerindeki en üstteki halının numarası veya hiçbir halı kaplamıyorsa -1.\n\n    Örnekler:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "vi": "Viết một hàm python 'def find_topmost_carpet(n, carpets, point) -> int:' để giải quyết vấn đề sau:\n\n    Tìm tấm thảm trên cùng phủ lên một điểm cho trước trên mặt phẳng tọa độ.\n\n    Tham số:\n    n (int): Tổng số tấm thảm.\n    carpets (list of tuples): Một danh sách chứa n bộ giá trị, mỗi bộ đại diện cho thông tin của một tấm thảm.\n                              Mỗi bộ chứa bốn số nguyên (a, b, g, k) trong đó (a, b) là tọa độ của góc dưới bên trái của tấm thảm và (g, k) là chiều dài của tấm thảm theo trục x và y tương ứng.\n    point (tuple): Một bộ chứa hai số nguyên (x, y), tọa độ của điểm cần kiểm tra.\n\n    Trả về:\n    int: Số của tấm thảm trên cùng phủ lên điểm (x, y), hoặc -1 nếu không có tấm thảm nào phủ lên nó.\n\n    Ví dụ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "id": "Tulis sebuah fungsi python 'def find_topmost_carpet(n, carpets, point) -> int:' untuk menyelesaikan masalah berikut:\n\n    Menemukan karpet paling atas yang menutupi titik tertentu pada bidang koordinat.\n\n    Argumen:\n    n (int): Jumlah total karpet.\n    carpets (list of tuples): Sebuah daftar yang berisi n tuple, masing-masing mewakili informasi sebuah karpet.\n                              Setiap tuple berisi empat bilangan bulat (a, b, g, k) di mana (a, b) adalah\n                              koordinat sudut kiri bawah karpet dan (g, k) adalah\n                              panjang karpet sepanjang sumbu x dan y masing-masing.\n    point (tuple): Sebuah tuple yang berisi dua bilangan bulat (x, y), koordinat titik yang akan diperiksa.\n\n    Mengembalikan:\n    int: Nomor karpet paling atas yang menutupi titik (x, y), atau -1 jika tidak ada karpet yang menutupinya.\n\n    Contoh:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "ja": "Python関数 'def find_topmost_carpet(n, carpets, point) -> int:' を作成して、次の問題を解決してください:\n\n    指定された座標平面上の点を覆う最上層のカーペットを見つけます。\n\n    引数:\n    n (int): カーペットの総数。\n    carpets (list of tuples): 各カーペットの情報を表すn個のタプルを含むリスト。\n                              各タプルは4つの整数 (a, b, g, k) を含み、(a, b) はカーペットの左下隅の座標、\n                              (g, k) はそれぞれx軸とy軸に沿ったカーペットの長さです。\n    point (tuple): 2つの整数 (x, y) を含むタプルで、チェックする点の座標。\n\n    戻り値:\n    int: 点 (x, y) を覆う最上層のカーペットの番号、またはカーペットがそれを覆わない場合は -1。\n\n    例:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "ko": "파이썬 함수를 작성하세요 'def find_topmost_carpet(n, carpets, point) -> int:' 다음 문제를 해결하기 위해:\n\n    주어진 좌표 평면의 점을 덮고 있는 가장 위에 있는 카펫을 찾습니다.\n\n    인수:\n    n (int): 카펫의 총 개수.\n    carpets (list of tuples): 각 카펫의 정보를 나타내는 n개의 튜플을 포함하는 리스트.\n                              각 튜플은 네 개의 정수 (a, b, g, k)를 포함하며, 여기서 (a, b)는\n                              카펫의 왼쪽 아래 모서리의 좌표이고, (g, k)는 각각 x축과 y축을 따라\n                              카펫의 길이입니다.\n    point (tuple): 두 개의 정수 (x, y)를 포함하는 튜플로, 확인할 점의 좌표입니다.\n\n    반환값:\n    int: 점 (x, y)를 덮고 있는 가장 위에 있는 카펫의 번호, 또는 어떤 카펫도 덮고 있지 않으면 -1을 반환합니다.\n\n    예시:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "ml": "Python ഫങ്ഷൻ 'def find_topmost_carpet(n, carpets, point) -> int:' എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    നൽകിയിരിക്കുന്ന കോർഡിനേറ്റ് പ്ലെയിനിൽ ഒരു നിർദ്ദിഷ്ട ബിന്ദുവിനെ മൂടുന്ന ഏറ്റവും മുകളിലുള്ള കാർപ്പറ്റ് കണ്ടെത്തുന്നു.\n\n    Args:\n    n (int): കാർപ്പറ്റുകളുടെ ആകെ എണ്ണം.\n    carpets (list of tuples): n ട്യൂപ്പിളുകൾ അടങ്ങിയ ഒരു ലിസ്റ്റ്, ഓരോന്നും ഒരു കാർപ്പറ്റിന്റെ വിവരങ്ങൾ പ്രതിനിധീകരിക്കുന്നു.\n                              ഓരോ ട്യൂപ്പിളിലും നാല് പൂർണ്ണസംഖ്യകൾ (a, b, g, k) അടങ്ങിയിരിക്കും, ഇവിടെ (a, b) ആണ്\n                              കാർപ്പറ്റിന്റെ താഴത്തെ-ഇടത് കോർണറിന്റെ കോർഡിനേറ്റുകൾ, (g, k) യഥാക്രമം x, y അക്ഷങ്ങളിലേക്കുള്ള\n                              കാർപ്പറ്റിന്റെ നീളങ്ങളാണ്.\n    point (tuple): രണ്ട് പൂർണ്ണസംഖ്യകൾ (x, y) അടങ്ങിയ ഒരു ട്യൂപ്പിൾ, പരിശോധിക്കേണ്ട ബിന്ദുവിന്റെ കോർഡിനേറ്റുകൾ.\n\n    Returns:\n    int: ബിന്ദു (x, y) മൂടുന്ന ഏറ്റവും മുകളിലുള്ള കാർപ്പറ്റിന്റെ നമ്പർ, അല്ലെങ്കിൽ ഒരു കാർപ്പറ്റും മൂടുന്നില്ലെങ്കിൽ -1.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "fa": "یک تابع پایتون بنویسید 'def find_topmost_carpet(n, carpets, point) -> int:' برای حل مسئله زیر:\n\n    بالاترین فرش پوشاننده یک نقطه مشخص در صفحه مختصات را پیدا می‌کند.\n\n    آرگومان‌ها:\n    n (int): تعداد کل فرش‌ها.\n    carpets (list of tuples): لیستی شامل n تاپل، که هر کدام اطلاعات یک فرش را نشان می‌دهد.\n                              هر تاپل شامل چهار عدد صحیح (a, b, g, k) است که (a, b) مختصات\n                              گوشه پایین-چپ فرش و (g, k) طول‌های فرش در امتداد محور x و y به ترتیب هستند.\n    point (tuple): یک تاپل شامل دو عدد صحیح (x, y)، مختصات نقطه‌ای که باید بررسی شود.\n\n    بازگشت:\n    int: شماره بالاترین فرش پوشاننده نقطه (x, y)، یا -1 اگر هیچ فرشی آن را نپوشاند.\n\n    مثال‌ها:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1"}, "level": "easy", "test": "def check_find_topmost_carpet():\n    # Test case 1: Point is on topmost carpet (carpet 3)\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2)) == 3\n\n    # Test case 2: Point is not covered by any carpet\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5)) == -1\n\n    # Test case 3: Point is on the edge of the carpet (carpet 1)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (4, 1)) == 1\n\n    # Test case 4: Point is at the corner of the carpet (carpet 2)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (6, 4)) == 2\n\n    # Test case 5: Multiple carpets cover the point, but the last one is on top (carpet 4)\n    assert find_topmost_carpet(4, [(0, 0, 5, 5), (1, 1, 5, 5), (2, 2, 5, 5), (3, 3, 5, 5)], (4, 4)) == 4\n\n    # Test case 6: No carpets at all, should return -1\n    assert find_topmost_carpet(0, [], (0, 0)) == -1\n\n    # Test case 8: Point is covered by the first carpet and no others (carpet 1)\n    assert find_topmost_carpet(3, [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)], (1, 1)) == 1\n\n    print(\"All test cases passed!\")\n\n\n# Run the test cases to ensure the function works as expected\ncheck_find_topmost_carpet()", "entry_point": "find_topmost_carpet", "signature": "def find_topmost_carpet(n, carpets, point) -> int:", "docstring": {"en": "\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ", "sq": "\n    Gjen qilimin më sipërfaqësor që mbulon një pikë të dhënë në planin koordinativ.\n\n    Argumentet:\n    n (int): Numri total i qilimave.\n    carpets (list of tuples): Një listë që përmban n tufa, secila që përfaqëson informacionin e një qilimi.\n                              Çdo tufë përmban katër numra të plotë (a, b, g, k) ku (a, b) janë\n                              koordinatat e këndit të poshtëm të majtë të qilimit dhe (g, k) janë\n                              gjatësitë e qilimit përgjatë boshtit x dhe y përkatësisht.\n    point (tuple): Një tufë që përmban dy numra të plotë (x, y), koordinatat e pikës për të kontrolluar.\n\n    Kthen:\n    int: Numri i qilimit më sipërfaqësor që mbulon pikën (x, y), ose -1 nëse asnjë qilim nuk e mbulon atë.\n\n    Shembuj:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ", "hy": "\n    Գտնում է տրված կոորդինատային հարթության վրա գտնվող կետի վրա գտնվող ամենավերևի գորգը։\n\n    Պարամետրեր:\n    n (int): Գորգերի ընդհանուր քանակը։\n    carpets (list of tuples): Ցանկ, որը պարունակում է n թյուպլ, յուրաքանչյուրը ներկայացնում է գորգի մասին տեղեկություն։\n                              Յուրաքանչյուր թյուպլ պարունակում է չորս ամբողջ թիվ (a, b, g, k), որտեղ (a, b) \n                              գորգի ներքևի ձախ անկյունի կոորդինատներն են, իսկ (g, k) գորգի երկարություններն են \n                              համապատասխանաբար x և y առանցքների երկայնքով։\n    point (tuple): Թյուպլ, որը պարունակում է երկու ամբողջ թիվ (x, y), կոորդինատները այն կետի, որը պետք է ստուգել։\n\n    Վերադարձնում է:\n    int: Ամենավերևի գորգի համարը, որը ծածկում է կետը (x, y), կամ -1, եթե ոչ մի գորգ չի ծածկում այն։\n\n    Օրինակներ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ", "bn": "\n    প্রদত্ত বিন্দুতে স্থানাঙ্ক সমতলে আবৃত শীর্ষস্থানীয় কার্পেট খুঁজে বের করে।\n\n    আর্গুমেন্টসমূহ:\n    n (int): কার্পেটের মোট সংখ্যা।\n    carpets (list of tuples): একটি তালিকা যা n টুপল ধারণ করে, প্রতিটি টুপল একটি কার্পেটের তথ্য উপস্থাপন করে।\n                              প্রতিটি টুপলে চারটি পূর্ণসংখ্যা (a, b, g, k) থাকে যেখানে (a, b) হল কার্পেটের\n                              নিচের-বাম কোণের স্থানাঙ্ক এবং (g, k) হল x এবং y অক্ষ বরাবর কার্পেটের দৈর্ঘ্য।\n    point (tuple): একটি টুপল যা দুটি পূর্ণসংখ্যা (x, y) ধারণ করে, চেক করার জন্য বিন্দুটির স্থানাঙ্ক।\n\n    রিটার্নস:\n    int: শীর্ষস্থানীয় কার্পেটের সংখ্যা যা বিন্দু (x, y) আবৃত করে, অথবা -1 যদি কোনো কার্পেট এটি আবৃত না করে।\n\n    উদাহরণ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ", "bg": "\n    Намира най-горния килим, покриващ дадена точка в координатната равнина.\n\n    Аргументи:\n    n (int): Общият брой на килимите.\n    carpets (list of tuples): Списък, съдържащ n кортежа, всеки от които представлява информация за килим.\n                              Всеки кортеж съдържа четири цели числа (a, b, g, k), където (a, b) са\n                              координатите на долния ляв ъгъл на килима и (g, k) са дължините на килима\n                              по оста x и y съответно.\n    point (tuple): Кортеж, съдържащ две цели числа (x, y), координатите на точката за проверка.\n\n    Връща:\n    int: Номера на най-горния килим, покриващ точката (x, y), или -1, ако няма килим, който да я покрива.\n\n    Примери:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ", "zh": "\n    找到在坐标平面上覆盖给定点的最上层地毯。\n\n    参数:\n    n (int): 地毯的总数量。\n    carpets (list of tuples): 一个包含 n 个元组的列表，每个元组代表一个地毯的信息。\n                              每个元组包含四个整数 (a, b, g, k)，其中 (a, b) 是地毯左下角的坐标，\n                              (g, k) 分别是地毯在 x 和 y 轴上的长度。\n    point (tuple): 一个包含两个整数 (x, y) 的元组，要检查的点的坐标。\n\n    返回:\n    int: 覆盖点 (x, y) 的最上层地毯的编号，如果没有地毯覆盖该点，则返回 -1。\n\n    示例:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "fr": "\n    Trouve le tapis le plus haut couvrant un point donné sur le plan de coordonnées.\n\n    Args:\n    n (int): Le nombre total de tapis.\n    carpets (list of tuples): Une liste contenant n tuples, chacun représentant les informations d'un tapis.\n                              Chaque tuple contient quatre entiers (a, b, g, k) où (a, b) sont les\n                              coordonnées du coin inférieur gauche du tapis et (g, k) sont\n                              les longueurs du tapis le long de l'axe x et y respectivement.\n    point (tuple): Un tuple contenant deux entiers (x, y), les coordonnées du point à vérifier.\n\n    Returns:\n    int: Le numéro du tapis le plus haut couvrant le point (x, y), ou -1 si aucun tapis ne le couvre.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ", "de": "\n    Findet den obersten Teppich, der einen gegebenen Punkt auf der Koordinatenebene bedeckt.\n\n    Argumente:\n    n (int): Die Gesamtanzahl der Teppiche.\n    carpets (list von Tupeln): Eine Liste, die n Tupel enthält, von denen jedes die Informationen eines Teppichs darstellt.\n                              Jedes Tupel enthält vier ganze Zahlen (a, b, g, k), wobei (a, b) die\n                              Koordinaten der linken unteren Ecke des Teppichs sind und (g, k) die\n                              Längen des Teppichs entlang der x- und y-Achse sind.\n    point (tuple): Ein Tupel, das zwei ganze Zahlen (x, y) enthält, die Koordinaten des zu überprüfenden Punktes.\n\n    Rückgabewert:\n    int: Die Nummer des obersten Teppichs, der den Punkt (x, y) bedeckt, oder -1, wenn kein Teppich ihn bedeckt.\n\n    Beispiele:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ", "ha": "\n    Nemo tabarmar da ke saman wani wuri a kan filin da aka bayar.\n\n    Ma'auni:\n    n (int): Jimillar adadin tabarmai.\n    carpets (list of tuples): Jerin da ke dauke da n tuples, kowanne yana wakiltar bayanin tabarma.\n                              Kowanne tuple yana dauke da lambobi hudu (a, b, g, k) inda (a, b) \n                              suke matsayin da ke kasa-hagu na tabarma kuma (g, k) suna \n                              tsawon tabarma a kan x da y axis bi da bi.\n    point (tuple): Tuple da ke dauke da lambobi biyu (x, y), wuraren da za a duba.\n\n    Komawa:\n    int: Lambar tabarmar da ke saman wurin (x, y), ko -1 idan babu tabarma da ta rufe shi.\n\n    Misalai:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ", "hi": "\n    दिए गए बिंदु पर समन्वय तल पर सबसे ऊपर की कालीन को खोजें।\n\n    तर्क:\n    n (int): कुल कालीनों की संख्या।\n    carpets (list of tuples): एक सूची जिसमें n ट्यूपल होते हैं, प्रत्येक एक कालीन की जानकारी का प्रतिनिधित्व करता है।\n                              प्रत्येक ट्यूपल में चार पूर्णांक (a, b, g, k) होते हैं जहाँ (a, b) कालीन के निचले-बाएँ कोने के\n                              समन्वय होते हैं और (g, k) कालीन की लंबाई x और y अक्ष के साथ होती है।\n    point (tuple): एक ट्यूपल जिसमें दो पूर्णांक (x, y) होते हैं, जाँचने के लिए बिंदु के समन्वय।\n\n    लौटाता है:\n    int: सबसे ऊपर की कालीन की संख्या जो बिंदु (x, y) को कवर करती है, या -1 यदि कोई कालीन इसे कवर नहीं करती है।\n\n    उदाहरण:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ", "hu": "\n    Megkeresi a koordináta síkon adott pontot lefedő legfelső szőnyeget.\n\n    Args:\n    n (int): A szőnyegek teljes száma.\n    carpets (list of tuples): Egy lista, amely n darab tuple-t tartalmaz, mindegyik egy szőnyeg információit képviseli.\n                              Minden tuple négy egész számot tartalmaz (a, b, g, k), ahol (a, b) a szőnyeg bal alsó sarkának\n                              koordinátái, és (g, k) a szőnyeg x és y tengely menti hossza.\n    point (tuple): Egy tuple, amely két egész számot tartalmaz (x, y), a vizsgálandó pont koordinátái.\n\n    Returns:\n    int: A (x, y) pontot lefedő legfelső szőnyeg száma, vagy -1, ha egyetlen szőnyeg sem fedi le.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ", "es": "\n    Encuentra la alfombra más alta que cubre un punto dado en el plano de coordenadas.\n\nArgumentos:\nn (int): El número total de alfombras.\ncarpets (list of tuples): Una lista que contiene n tuplas, cada una representando la información de una alfombra.\n                          Cada tupla contiene cuatro enteros (a, b, g, k) donde (a, b) son las\n                          coordenadas de la esquina inferior izquierda de la alfombra y (g, k) son\n                          las longitudes de la alfombra a lo largo del eje x e y respectivamente.\npoint (tuple): Una tupla que contiene dos enteros (x, y), las coordenadas del punto a verificar.\n\nDevuelve:\nint: El número de la alfombra más alta que cubre el punto (x, y), o -1 si ninguna alfombra lo cubre.\n\nEjemplos:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "arb": "\n    يجد السجادة العلوية التي تغطي نقطة معينة على مستوى الإحداثيات.\n\n    يعيدالحجج:\n    n (int): العدد الإجمالي للسجاد.\n    carpets (list of tuples): قائمة تحتوي على n من الأزواج، كل منها يمثل معلومات السجادة.\n                              يحتوي كل زوج على أربعة أعداد صحيحة (a, b, g, k) حيث (a, b) هي\n                              إحداثيات الزاوية السفلية اليسرى للسجادة و (g, k) هي\n                              أطوال السجادة على طول المحورين x و y على التوالي.\n    point (tuple): زوج يحتوي على عددين صحيحين (x, y)، إحداثيات النقطة المراد التحقق منها.\n\n    يعيد:\n    int: رقم السجادة العلوية التي تغطي النقطة (x, y)، أو -1 إذا لم تغطيها أي سجادة.\n\n    امثله:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "sw": "\n    Inapata zulia la juu zaidi linalofunika nukta fulani kwenye ndege ya kuratibu.\n\nHoja:\nn (int): Jumla ya idadi ya mazulia.\ncarpets (list of tuples): Orodha inayo na n tuples, kila moja ikiwakilisha taarifa ya zulia.\n                          Kila tuple ina namba nne za mzima (a, b, g, k) ambapo (a, b) ni\n                          kuratibu za kona ya chini-kushoto ya zulia na (g, k) ni\n                          urefu wa zulia kando ya mhimili wa x na y mtawalia.\npoint (tuple): Tuple inayo na namba mbili za mzima (x, y), kuratibu za nukta ya kukagua.\n\nInarejesha:\nint: Namba ya zulia la juu zaidi linalofunika nukta (x, y), au -1 ikiwa hakuna zulia linaloifunika.\n\nMifano:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "tr": "\n    Belirtilen bir noktayı koordinat düzleminde örten en üstteki halıyı bulur.\n\n    Argümanlar:\n    n (int): Toplam halı sayısı.\n    carpets (list of tuples): Her biri bir halının bilgilerini temsil eden n demetini içeren bir liste.\n                              Her demet, halının sol alt köşesinin koordinatları olan (a, b) ve\n                              sırasıyla x ve y ekseni boyunca halının uzunlukları olan (g, k) dört tam sayı içerir.\n    point (tuple): Kontrol edilecek noktanın koordinatlarını içeren iki tam sayı (x, y) içeren bir demet.\n\n    Döndürür:\n    int: Noktayı (x, y) örten en üstteki halının numarası veya hiçbir halı örtmüyorsa -1.\n\n    Örnekler:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "vi": "\n    Tìm tấm thảm trên cùng phủ lên một điểm cho trước trên mặt phẳng tọa độ.\n\n    Tham số:\n    n (int): Tổng số lượng thảm.\n    carpets (list of tuples): Một danh sách chứa n bộ giá trị, mỗi bộ đại diện cho thông tin của một tấm thảm.\n                              Mỗi bộ chứa bốn số nguyên (a, b, g, k) trong đó (a, b) là tọa độ của góc dưới bên trái của tấm thảm và (g, k) là\n                              chiều dài của tấm thảm theo trục x và y tương ứng.\n    point (tuple): Một bộ chứa hai số nguyên (x, y), tọa độ của điểm cần kiểm tra.\n\n    Trả về:\n    int: Số của tấm thảm trên cùng phủ lên điểm (x, y), hoặc -1 nếu không có tấm thảm nào phủ lên.\n\n    Ví dụ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "id": "Menemukan karpet paling atas yang menutupi titik tertentu pada bidang koordinat.\n\nArgs:\nn (int): Jumlah total karpet.\ncarpets (list of tuples): Daftar yang berisi n tuple, masing-masing mewakili informasi karpet.\n                          Setiap tuple berisi empat bilangan bulat (a, b, g, k) di mana (a, b) adalah\n                          koordinat sudut kiri bawah karpet dan (g, k) adalah panjang karpet\n                          sepanjang sumbu x dan y masing-masing.\npoint (tuple): Sebuah tuple yang berisi dua bilangan bulat (x, y), koordinat titik yang akan diperiksa.\n\nReturns:\nint: Nomor karpet paling atas yang menutupi titik (x, y), atau -1 jika tidak ada karpet yang menutupinya.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "ja": "    座標平面上の指定された点を覆う最上位のカーペットを見つけます。\n\n    引数:\n    n (int): カーペットの総数。\n    carpets (list of tuples): 各カーペットの情報を表すn個のタプルを含むリスト。\n                              各タプルは4つの整数 (a, b, g, k) を含み、(a, b) はカーペットの左下隅の座標で、\n                              (g, k) はそれぞれx軸とy軸に沿ったカーペットの長さです。\n    point (tuple): 2つの整数 (x, y) を含むタプルで、チェックする点の座標です。\n\n    戻り値:\n    int: 点 (x, y) を覆う最上位のカーペットの番号、またはカーペットがそれを覆わない場合は -1。\n\n    例:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "ko": "    주어진 좌표 평면의 점을 덮는 가장 위에 있는 카펫을 찾습니다.\n\n    Args:\n    n (int): 카펫의 총 개수.\n    carpets (list of tuples): 각 카펫의 정보를 나타내는 n개의 튜플을 포함하는 리스트.\n                              각 튜플은 네 개의 정수 (a, b, g, k)를 포함하며, 여기서 (a, b)는\n                              카펫의 왼쪽 아래 모서리의 좌표이고 (g, k)는 각각 x축과 y축을 따라\n                              카펫의 길이입니다.\n    point (tuple): 두 개의 정수 (x, y)를 포함하는 튜플로, 확인할 점의 좌표입니다.\n\n    Returns:\n    int: 점 (x, y)를 덮는 가장 위에 있는 카펫의 번호, 또는 아무 카펫도 덮지 않을 경우 -1.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "ml": "    കൊഓർഡിനേറ്റ് പ്ലെയിനിൽ നൽകിയ പോയിന്റ് മൂടുന്ന ഏറ്റവും മുകളിലുള്ള കർപ്പറ്റ് കണ്ടെത്തുന്നു.\n\n    Args:\n    n (int): കർപ്പറ്റുകളുടെ മൊത്തം എണ്ണം.\n    carpets (list of tuples): ഓരോ കർപ്പറ്റിന്റെയും വിവരങ്ങൾ പ്രതിനിധീകരിക്കുന്ന n ട്യൂപ്പിളുകൾ അടങ്ങിയ ഒരു പട്ടിക.\n                              ഓരോ ട്യൂപ്പിളിലും നാല് ഇന്റിജറുകൾ (a, b, g, k) അടങ്ങിയിരിക്കും, \n                              ഇവിടെ (a, b) കർപ്പറ്റിന്റെ താഴത്തെ ഇടത് കോണിന്റെ \n                              കൊഓർഡിനേറ്റുകളാണ്, (g, k) യഥാക്രമം x, y അക്ഷങ്ങളിലായി \n                              കർപ്പറ്റിന്റെ നീളങ്ങളാണ്.\n    point (tuple): പരിശോധിക്കേണ്ട പോയിന്റിന്റെ കൊഓർഡിനേറ്റുകൾ, രണ്ട് ഇന്റിജറുകൾ (x, y) അടങ്ങിയ ഒരു ട്യൂപ്പിൾ.\n\n    Returns:\n    int: പോയിന്റ് (x, y) മൂടുന്ന ഏറ്റവും മുകളിലുള്ള കർപ്പറ്റിന്റെ നമ്പർ, അല്ലെങ്കിൽ \n         ഒരു കർപ്പറ്റും മൂടുന്നില്ലെങ്കിൽ -1.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1", "fa": "    بالاترین فرش پوشاننده یک نقطه مشخص در صفحه مختصات را پیدا می‌کند.\n\n    آرگومان‌ها:\n    n (int): تعداد کل فرش‌ها.\n    carpets (list of tuples): لیستی شامل n تاپل، که هر کدام اطلاعات یک فرش را نشان می‌دهد.\n                              هر تاپل شامل چهار عدد صحیح (a, b, g, k) است که در آن (a, b)\n                              مختصات گوشه پایین-چپ فرش و (g, k) طول‌های فرش به ترتیب در\n                              محور x و y هستند.\n    point (tuple): یک تاپل شامل دو عدد صحیح (x, y)، مختصات نقطه‌ای که باید بررسی شود.\n\n    بازگشت:\n    int: شماره بالاترین فرش پوشاننده نقطه (x, y)، یا -1 اگر هیچ فرشی آن را نپوشاند.\n\n    مثال‌ها:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1"}}
{"task_id": "Python/8", "prompt": {"en": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "sq": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Llogarit shumën maksimale të vlerave të mbledhura në dy shtigje në një rrjetë N x N.\n\n    Kjo funksion përdor programimin dinamik për të gjetur dy shtigje nga këndi i sipërm i majtë\n    deri në këndin e poshtëm të djathtë të rrjetës që maksimizojnë shumën e vlerave të mbledhura. \n    Çdo vlerë mund të mblidhet maksimumi një herë, edhe nëse të dy shtigjet kalojnë përmes saj.\n\n    Argumentet:\n    - N (int): Madhësia e rrjetës (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Një listë tuples ku çdo tuple përmban\n      koordinatën x, koordinatën y, dhe vlerën që do të vendoset në rrjetë në atë pozicion.\n      Lista përfundon me një tuple me të gjitha zero.\n\n    Kthen:\n    - int: Shuma maksimale e vlerave të mbledhura në dy shtigjet.\n\n    Shembuj:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "hy": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Հաշվարկել արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիների վրա N x N ցանցում:\n\n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ գտնելու համար երկու ուղիներ ցանցի վերին ձախ անկյունից\n    մինչև ցանցի ներքևի աջ անկյունը, որոնք առավելագույնացնում են հավաքված արժեքների գումարը: Յուրաքանչյուր\n    արժեք կարող է հավաքվել առավելագույնը մեկ անգամ, նույնիսկ եթե երկու ուղիներն անցնում են դրա միջով:\n\n    Պարամետրեր:\n    - N (int): Ցանցի չափը (N x N):\n    - grid_values (List[Tuple[int, int, int]]): Թվերի ցուցակ, որտեղ յուրաքանչյուր տուփ պարունակում է\n      x-կոորդինատը, y-կոորդինատը և արժեքը, որը պետք է տեղադրվի ցանցում այդ դիրքում:\n      Ցուցակը ավարտվում է զրոներով տուփով:\n\n    Վերադարձնում է:\n    - int: Երկու ուղիների վրա հավաքված արժեքների առավելագույն գումարը:\n\n    Օրինակներ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "bn": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    একটি N x N গ্রিডে দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল গণনা করুন।\n\n    এই ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে গ্রিডের উপরের-বাম কোণ থেকে\n    নীচের-ডান কোণে দুটি পথ খুঁজে বের করে যা সংগৃহীত মানগুলির যোগফল সর্বাধিক করে। প্রতিটি\n    মান সর্বাধিক একবার সংগৃহীত হতে পারে, এমনকি উভয় পথ এর মধ্য দিয়ে গেলেও।\n\n    আর্গস:\n    - N (int): গ্রিডের আকার (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপলে\n      গ্রিডের নির্দিষ্ট অবস্থানে স্থাপন করার জন্য x-অক্ষাংশ, y-অক্ষাংশ এবং মান থাকে।\n      তালিকাটি সমস্ত শূন্য সহ একটি টুপল দ্বারা শেষ হয়।\n\n    রিটার্নস:\n    - int: দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল।\n\n    উদাহরণ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "bg": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Изчислява максималната сума от стойности, събрани по два пътя в мрежа N x N.\n\n    Тази функция използва динамично програмиране, за да намери два пътя от горния ляв ъгъл\n    до долния десен ъгъл на мрежата, които максимизират сумата от събраните стойности. Всяка\n    стойност може да бъде събрана най-много веднъж, дори ако и двата пътя минават през нея.\n\n    Аргументи:\n    - N (int): Размерът на мрежата (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Списък от кортежи, където всеки кортеж съдържа\n      x-координата, y-координата и стойност, която да бъде поставена на мрежата на тази позиция.\n      Списъкът завършва с кортеж с всички нули.\n\n    Връща:\n    - int: Максималната сума от стойности, събрани по двата пътя.\n\n    Примери:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "zh": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    计算在 N x N 网格中收集的两条路径上的最大值总和。\n\n    此函数利用动态规划找到从网格的左上角到右下角的两条路径，\n    以最大化收集的值的总和。即使两条路径都经过某个值，该值最多也只能被收集一次。\n\n    参数:\n    - N (int): 网格的大小 (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 一个元组列表，其中每个元组包含\n      x 坐标、y 坐标和要放置在该位置的网格上的值。\n      列表以一个全为零的元组结束。\n\n    返回:\n    - int: 在两条路径上收集的最大值总和。\n\n    示例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "fr": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculer la somme maximale des valeurs collectées sur deux chemins dans une grille N x N.\n\n    Cette fonction utilise la programmation dynamique pour trouver deux chemins allant du coin\n    supérieur gauche au coin inférieur droit de la grille qui maximisent la somme des valeurs\n    collectées. Chaque valeur peut être collectée au maximum une fois, même si les deux chemins\n    passent par elle.\n\n    Arguments:\n    - N (int): La taille de la grille (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Une liste de tuples où chaque tuple contient\n      la coordonnée x, la coordonnée y, et la valeur à placer sur la grille à cette position.\n      La liste est terminée par un tuple avec tous les zéros.\n\n    Retourne:\n    - int: La somme maximale des valeurs collectées sur les deux chemins.\n\n    Exemples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "de": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Berechne die maximale Summe der gesammelten Werte auf zwei Pfaden in einem N x N Gitter.\n\n    Diese Funktion verwendet dynamische Programmierung, um zwei Pfade vom oberen linken Eckpunkt\n    zum unteren rechten Eckpunkt des Gitters zu finden, die die Summe der gesammelten Werte maximieren.\n    Jeder Wert kann höchstens einmal gesammelt werden, selbst wenn beide Pfade ihn durchqueren.\n\n    Argumente:\n    - N (int): Die Größe des Gitters (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die\n      x-Koordinate, y-Koordinate und den Wert enthält, der an dieser Position auf das Gitter\n      gesetzt werden soll. Die Liste wird durch ein Tupel mit lauter Nullen beendet.\n\n    Rückgabewert:\n    - int: Die maximale Summe der auf den beiden Pfaden gesammelten Werte.\n\n    Beispiele:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "ha": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Lissafi mafi girman jimillar ƙimomi da aka tattara akan hanyoyi biyu a cikin grid na N x N.\n\n    Wannan aikin yana amfani da shirye-shiryen motsi don nemo hanyoyi biyu daga saman hagu zuwa\n    ƙasan dama na grid wanda ke haɓaka jimillar ƙimomin da aka tattara. Ana iya tattara kowace ƙima sau ɗaya kawai, ko da kuwa duk hanyoyin sun wuce ta cikinsa.\n\n    Args:\n    - N (int): Girman grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi\n      x-ma'auni, y-ma'auni, da ƙima da za a sanya a kan grid a wannan matsayi.\n      Jerin yana ƙarewa da tuple tare da duk sifili.\n\n    Returns:\n    - int: Mafi girman jimillar ƙimomi da aka tattara akan hanyoyi biyu.\n\n    Misalai:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "hi": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    एक N x N ग्रिड में दो पथों पर एकत्रित मानों के अधिकतम योग की गणना करें।\n\n    यह फ़ंक्शन डायनामिक प्रोग्रामिंग का उपयोग करता है ताकि ग्रिड के शीर्ष-बाएँ कोने से\n    निचले-दाएँ कोने तक दो पथों को खोजा जा सके जो एकत्रित मानों के योग को अधिकतम करते हैं। प्रत्येक\n    मान को अधिकतम एक बार ही एकत्रित किया जा सकता है, भले ही दोनों पथ उसके माध्यम से गुजरें।\n\n    तर्क:\n    - N (int): ग्रिड का आकार (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल में\n      x-निर्देशांक, y-निर्देशांक, और उस स्थिति पर ग्रिड पर रखे जाने वाले मान होते हैं।\n      सूची एक ट्यूपल के साथ समाप्त होती है जिसमें सभी शून्य होते हैं।\n\n    वापसी:\n    - int: दो पथों पर एकत्रित मानों का अधिकतम योग।\n\n    उदाहरण:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "hu": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Számítsa ki az értékek maximális összegét, amelyet két útvonalon gyűjtenek össze egy N x N-es rácson.\n\n    Ez a függvény dinamikus programozást használ annak érdekében, hogy megtalálja a rács bal felső sarkából\n    a jobb alsó sarkába vezető két útvonalat, amelyek maximalizálják az összegyűjtött értékek összegét. Minden\n    értéket legfeljebb egyszer lehet összegyűjteni, még akkor is, ha mindkét útvonal áthalad rajta.\n\n    Paraméterek:\n    - N (int): A rács mérete (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Egy olyan tuple-ök listája, ahol minden tuple tartalmazza\n      az x-koordinátát, y-koordinátát és az értéket, amelyet a rács adott pozíciójára kell helyezni.\n      A lista egy minden nullát tartalmazó tuple-lel zárul.\n\n    Visszatér:\n    - int: Az összegyűjtött értékek maximális összege a két útvonalon.\n\n    Példák:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "es": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calcular la suma máxima de valores recolectados en dos caminos en una cuadrícula de N x N.\n\n    Esta función utiliza programación dinámica para encontrar dos caminos desde la esquina\n    superior izquierda hasta la esquina inferior derecha de la cuadrícula que maximizan la\n    suma de los valores recolectados. Cada valor puede ser recolectado como máximo una vez,\n    incluso si ambos caminos pasan por él.\n\n    Argumentos:\n    - N (int): El tamaño de la cuadrícula (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Una lista de tuplas donde cada tupla contiene\n      la coordenada x, la coordenada y, y el valor que se colocará en la cuadrícula en esa\n      posición. La lista termina con una tupla con todos ceros.\n\n    Devuelve:\n    - int: La suma máxima de valores recolectados en los dos caminos.\n\n    Ejemplos:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "arb": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    حساب مجموع القيم الأقصى التي تم جمعها على مسارين في شبكة بحجم N x N.\n\n    تستخدم هذه الدالة البرمجة الديناميكية لإيجاد مسارين من الزاوية العلوية اليسرى\n    إلى الزاوية السفلية اليمنى من الشبكة والتي تزيد من مجموع القيم التي تم جمعها. يمكن جمع\n    كل قيمة مرة واحدة فقط، حتى إذا مر كلا المسارين من خلالها.\n\n    يعيدالحجج:\n    - N (int): حجم الشبكة (N x N).\n    - grid_values (List[Tuple[int, int, int]]): قائمة من الأزواج حيث يحتوي كل زوج\n      على الإحداثي السيني، الإحداثي الصادي، والقيمة التي سيتم وضعها على الشبكة في ذلك الموقع.\n      تنتهي القائمة بزوج يحتوي على جميع الأصفار.\n\n    يعيد:\n    - int: مجموع القيم الأقصى التي تم جمعها على المسارين.\n\n    أمثلة:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "sw": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Kuhesabu jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili katika gridi ya N x N.\n\n    Kazi hii inatumia programu ya nguvu ili kupata njia mbili kutoka kona ya juu-kushoto hadi\n    kona ya chini-kulia ya gridi ambayo inakuza jumla ya thamani zilizokusanywa. Kila\n    thamani inaweza kukusanywa mara moja tu, hata kama njia zote mbili zinapita kupitia hiyo.\n\n    Hoja:\n    - N (int): Ukubwa wa gridi (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Orodha ya jozi ambapo kila jozi inajumuisha\n      x-kiwiania, y-kiwiania, na thamani ya kuwekwa kwenye gridi katika nafasi hiyo.\n      Orodha inakamilishwa na jozi yenye sifuri zote.\n\n    Inarejesha:\n    - int: Jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili.\n\n    Mifano:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "tr": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    N x N boyutundaki bir ızgarada iki yol üzerinde toplanan değerlerin maksimum toplamını hesaplayın.\n\n    Bu fonksiyon, dinamik programlama kullanarak ızgaranın sol üst köşesinden sağ alt köşesine\n    kadar iki yol bulur ve toplanan değerlerin toplamını maksimize eder. Her bir değer, her iki yol\n    da üzerinden geçse bile en fazla bir kez toplanabilir.\n\n    Argümanlar:\n    - N (int): Izgaranın boyutu (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Her bir demetin x-koordinatı, y-koordinatı ve\n      o konumda ızgaraya yerleştirilecek değeri içerdiği bir demet listesi. Liste, tüm elemanları\n      sıfır olan bir demet ile sonlandırılır.\n\n    Döndürür:\n    - int: İki yol üzerinde toplanan değerlerin maksimum toplamı.\n\n    Örnekler:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "vi": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Tính tổng giá trị lớn nhất thu thập được trên hai đường đi trong lưới N x N.\n\n    Hàm này sử dụng lập trình động để tìm hai đường đi từ góc trên bên trái đến\n    góc dưới bên phải của lưới mà tối đa hóa tổng giá trị thu thập được. Mỗi\n    giá trị có thể được thu thập tối đa một lần, ngay cả khi cả hai đường đi qua nó.\n\n    Tham số:\n    - N (int): Kích thước của lưới (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Một danh sách các bộ ba mà mỗi bộ chứa\n      tọa độ x, tọa độ y, và giá trị được đặt trên lưới tại vị trí đó.\n      Danh sách kết thúc bằng một bộ ba với tất cả các giá trị bằng không.\n\n    Trả về:\n    - int: Tổng giá trị lớn nhất thu thập được trên hai đường đi.\n\n    Ví dụ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "id": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Hitung jumlah maksimum nilai yang dikumpulkan pada dua jalur dalam grid N x N.\n\n    Fungsi ini menggunakan pemrograman dinamis untuk menemukan dua jalur dari sudut kiri atas ke\n    sudut kanan bawah grid yang memaksimalkan jumlah nilai yang dikumpulkan. Setiap\n    nilai dapat dikumpulkan paling banyak sekali, bahkan jika kedua jalur melewatinya.\n\n    Argumen:\n    - N (int): Ukuran grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Daftar tuple di mana setiap tuple berisi\n      koordinat x, koordinat y, dan nilai yang akan ditempatkan pada grid di posisi tersebut.\n      Daftar diakhiri dengan tuple yang semua elemennya nol.\n\n    Mengembalikan:\n    - int: Jumlah maksimum nilai yang dikumpulkan pada dua jalur.\n\n    Contoh:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "ja": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    N x N グリッドで2つのパスで収集される値の最大合計を計算します。\n\n    この関数は動的計画法を利用して、グリッドの左上隅から右下隅までの2つのパスを見つけ、\n    収集される値の合計を最大化します。各値は、両方のパスがそれを通過しても、最大で1回しか\n    収集できません。\n\n    引数:\n    - N (int): グリッドのサイズ (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 各タプルがグリッド上の位置に配置される\n      x座標、y座標、および値を含むタプルのリスト。このリストはすべてゼロのタプルで終了します。\n\n    戻り値:\n    - int: 2つのパスで収集される値の最大合計。\n\n    例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "ko": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    N x N 그리드에서 두 경로에서 수집된 값의 최대 합을 계산합니다.\n\n    이 함수는 동적 프로그래밍을 활용하여 그리드의 왼쪽 상단 모서리에서\n    오른쪽 하단 모서리까지의 두 경로를 찾아 수집된 값의 합을 최대화합니다. 각\n    값은 두 경로가 그 값을 지나가더라도 최대 한 번만 수집될 수 있습니다.\n\n    매개변수:\n    - N (int): 그리드의 크기 (N x N).\n    - grid_values (List[Tuple[int, int, int]]): 각 튜플이 그리드의 해당 위치에\n      놓일 x좌표, y좌표, 값을 포함하는 튜플의 리스트입니다.\n      리스트는 모든 값이 0인 튜플로 종료됩니다.\n\n    반환값:\n    - int: 두 경로에서 수집된 값의 최대 합.\n\n    예제:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "ml": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    N x N ഗ്രിഡിലെ രണ്ട് പാതകളിൽ ശേഖരിച്ച മൂല്യങ്ങളുടെ പരമാവധി തുക കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് ഗ്രിഡിന്റെ മുകളിൽ-ഇടതുവശത്ത് നിന്ന്\n    താഴെ-വലതുവശത്തേക്ക് രണ്ട് പാതകൾ കണ്ടെത്തുന്നു, ഇത് ശേഖരിച്ച മൂല്യങ്ങളുടെ തുക പരമാവധി\n    ആക്കുന്നു. ഓരോ മൂല്യവും പരമാവധി ഒരിക്കൽ മാത്രമേ ശേഖരിക്കാൻ കഴിയൂ, ആ പാതകൾ\n    അതിലൂടെ കടന്നുപോയാലും.\n\n    Args:\n    - N (int): ഗ്രിഡിന്റെ വലിപ്പം (N x N).\n    - grid_values (List[Tuple[int, int, int]]): ഓരോ ട്യൂപ്പിളും x-കോഓർഡിനേറ്റ്, y-കോഓർഡിനേറ്റ്,\n      ആ സ്ഥാനത്ത് ഗ്രിഡിൽ വയ്ക്കേണ്ട മൂല്യം എന്നിവ അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക.\n      പട്ടിക മുഴുവൻ ശൂന്യങ്ങളുള്ള ഒരു ട്യൂപ്പിള്‍ ഉപയോഗിച്ച് അവസാനിപ്പിക്കുന്നു.\n\n    Returns:\n    - int: രണ്ട് പാതകളിൽ ശേഖരിച്ച മൂല്യങ്ങളുടെ പരമാവധി തുക.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "fa": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    حداکثر مجموع مقادیر جمع‌آوری شده در دو مسیر در یک شبکه N x N را محاسبه کنید.\n\n    این تابع از برنامه‌ریزی پویا برای یافتن دو مسیر از گوشه بالا-چپ به گوشه پایین-راست\n    شبکه استفاده می‌کند که مجموع مقادیر جمع‌آوری شده را به حداکثر می‌رساند. هر مقدار\n    می‌تواند حداکثر یک بار جمع‌آوری شود، حتی اگر هر دو مسیر از آن عبور کنند.\n\n    آرگومان‌ها:\n    - N (int): اندازه شبکه (N x N).\n    - grid_values (List[Tuple[int, int, int]]): لیستی از تاپل‌ها که هر تاپل شامل\n      مختصات x، مختصات y و مقداری است که باید در آن موقعیت روی شبکه قرار گیرد.\n      لیست با یک تاپل که همه عناصر آن صفر هستند خاتمه می‌یابد.\n\n    بازگشت:\n    - int: حداکثر مجموع مقادیر جمع‌آوری شده در دو مسیر.\n\n    مثال‌ها:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\""}, "canonical_solution": "# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]", "instruction": {"en": "Write a python function 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' to solve the following problem:\n\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    ", "sq": "Shkruani një funksion python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni shumën maksimale të vlerave të mbledhura në dy rrugë në një rrjet N x N.\n\n    Ky funksion përdor programimin dinamik për të gjetur dy rrugë nga këndi i sipërm i majtë\n    deri në këndin e poshtëm të djathtë të rrjetit që maksimizojnë shumën e vlerave të mbledhura. \n    Çdo vlerë mund të mblidhet maksimumi një herë, edhe nëse të dyja rrugët kalojnë nëpër të.\n\n    Args:\n    - N (int): Madhësia e rrjetit (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Një listë tuples ku çdo tuple përmban\n      koordinatën x, koordinatën y, dhe vlerën që do të vendoset në rrjet në atë pozicion.\n      Lista përfundon me një tuple me të gjitha zerot.\n\n    Kthen:\n    - int: Shuma maksimale e vlerave të mbledhura në dy rrugët.\n\n    Shembuj:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "hy": "Պայթոն ֆունկցիա 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիների վրա N x N ցանցում:\n\n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ գտնելու համար երկու ուղի ցանցի վերին ձախ անկյունից\n    ցանցի ներքևի աջ անկյունը, որոնք առավելագույնացնում են հավաքված արժեքների գումարը: Յուրաքանչյուր\n    արժեք կարող է հավաքվել առավելագույնը մեկ անգամ, նույնիսկ եթե երկու ուղիներն էլ անցնում են դրա միջով:\n\n    Արգումենտներ:\n    - N (int): Ցանցի չափը (N x N):\n    - grid_values (List[Tuple[int, int, int]]): Թվերի ցուցակ, որտեղ յուրաքանչյուր տապլի մեջ պարունակվում է\n      x-կոորդինատը, y-կոորդինատը և արժեքը, որը պետք է տեղադրվի ցանցում այդ դիրքում:\n      Ցուցակը ավարտվում է զրոներով տապլով:\n\n    Վերադարձնում է:\n    - int: Արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիների վրա:\n\n    Օրինակներ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "bn": "একটি পাইথন ফাংশন 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি N x N গ্রিডে দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল গণনা করুন।\n\n    এই ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে গ্রিডের উপরের-বাম কোণ থেকে\n    নিচের-ডান কোণে দুটি পথ খুঁজে বের করে যা সংগৃহীত মানগুলির যোগফলকে সর্বাধিক করে। প্রতিটি\n    মান সর্বাধিক একবার সংগৃহীত হতে পারে, এমনকি যদি উভয় পথ এর মধ্য দিয়ে যায়।\n\n    আর্গুমেন্টস:\n    - N (int): গ্রিডের আকার (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপলে\n      x-অক্ষাংশ, y-অক্ষাংশ, এবং মান থাকে যা সেই অবস্থানে গ্রিডে স্থাপন করা হবে।\n      তালিকাটি সমস্ত শূন্য সহ একটি টুপল দ্বারা শেষ হয়।\n\n    রিটার্নস:\n    - int: দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল।\n\n    উদাহরণ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "bg": "Напишете Python функция 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:', за да решите следния проблем:\n\n    Изчислете максималната сума от стойности, събрани по два пътя в решетка N x N.\n\n    Тази функция използва динамично програмиране, за да намери два пътя от горния ляв ъгъл до\n    долния десен ъгъл на решетката, които максимизират сумата от събраните стойности. Всяка\n    стойност може да бъде събрана най-много веднъж, дори ако и двата пътя преминават през нея.\n\n    Аргументи:\n    - N (int): Размерът на решетката (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Списък от кортежи, където всеки кортеж съдържа\n      x-координатата, y-координатата и стойността, която да бъде поставена на решетката на тази позиция.\n      Списъкът завършва с кортеж с всички нули.\n\n    Връща:\n    - int: Максималната сума от стойности, събрани по двата пътя.\n\n    Примери:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "zh": "编写一个python函数'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:'来解决以下问题：\n\n    计算在N x N网格中收集的两个路径上的值的最大和。\n\n    此函数利用动态编程从网格的左上角找到两条路径到右下角，这两条路径最大化收集的值的和。即使两条路径都经过，每个值最多只能收集一次。\n\n    参数:\n    - N (int): 网格的大小 (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 一个元组列表，其中每个元组包含x坐标、y坐标和要放置在该位置的网格上的值。列表以一个全为零的元组结束。\n\n    返回:\n    - int: 在两条路径上收集的值的最大和。\n\n    示例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "fr": "Écrivez une fonction python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' pour résoudre le problème suivant :\n\n    Calculer la somme maximale des valeurs collectées sur deux chemins dans une grille N x N.\n\n    Cette fonction utilise la programmation dynamique pour trouver deux chemins du coin supérieur gauche\n    au coin inférieur droit de la grille qui maximisent la somme des valeurs collectées. Chaque\n    valeur peut être collectée au maximum une fois, même si les deux chemins passent par elle.\n\n    Args:\n    - N (int): La taille de la grille (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Une liste de tuples où chaque tuple contient\n      la coordonnée x, la coordonnée y, et la valeur à placer sur la grille à cette position.\n      La liste est terminée par un tuple avec tous les zéros.\n\n    Returns:\n    - int: La somme maximale des valeurs collectées sur les deux chemins.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "de": "Schreiben Sie eine Python-Funktion 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die maximale Summe der Werte, die auf zwei Pfaden in einem N x N Gitter gesammelt werden.\n\n    Diese Funktion verwendet dynamische Programmierung, um zwei Pfade vom oberen linken Eckpunkt\n    zum unteren rechten Eckpunkt des Gitters zu finden, die die Summe der gesammelten Werte maximieren.\n    Jeder Wert kann höchstens einmal gesammelt werden, selbst wenn beide Pfade ihn durchqueren.\n\n    Argumente:\n    - N (int): Die Größe des Gitters (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die\n      x-Koordinate, y-Koordinate und den Wert enthält, der an dieser Position auf das Gitter gelegt werden soll.\n      Die Liste wird durch ein Tupel mit lauter Nullen beendet.\n\n    Rückgabewert:\n    - int: Die maximale Summe der auf den beiden Pfaden gesammelten Werte.\n\n    Beispiele:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "ha": "Rubuta wani aikin python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa jimillar mafi girma na ƙimomin da aka tattara akan hanyoyi biyu a cikin grid N x N.\n\n    Wannan aikin yana amfani da shirye-shiryen motsi don nemo hanyoyi biyu daga saman hagu zuwa\n    ƙasan dama na grid wanda ke haɓaka jimillar ƙimomin da aka tattara. Kowace\n    ƙima za a iya tattara ta sau ɗaya kawai, ko da kuwa duk hanyoyin biyu sun wuce ta.\n\n    Args:\n    - N (int): Girman grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi\n      x-coordinate, y-coordinate, da ƙima da za a sanya a grid a wannan matsayi.\n      Jerin yana ƙarewa da tuple tare da duk sifili.\n\n    Returns:\n    - int: Jimillar mafi girma na ƙimomin da aka tattara akan hanyoyi biyu.\n\n    Misalai:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "hi": "एक पायथन फ़ंक्शन 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    एक N x N ग्रिड में दो पथों पर एकत्रित मूल्यों का अधिकतम योग गणना करें।\n\n    यह फ़ंक्शन डायनामिक प्रोग्रामिंग का उपयोग करता है ताकि ग्रिड के शीर्ष-बाएँ कोने से\n    निचले-दाएँ कोने तक दो पथ खोजे जा सकें जो एकत्रित मूल्यों के योग को अधिकतम करते हैं। प्रत्येक\n    मूल्य को अधिकतम एक बार एकत्र किया जा सकता है, भले ही दोनों पथ इसके माध्यम से गुजरें।\n\n    तर्क:\n    - N (int): ग्रिड का आकार (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): ट्यूपल्स की एक सूची जहां प्रत्येक ट्यूपल में\n      x-निर्देशांक, y-निर्देशांक, और उस स्थिति पर ग्रिड पर रखे जाने वाले मूल्य होते हैं।\n      सूची सभी शून्य वाले एक ट्यूपल के साथ समाप्त होती है।\n\n    लौटाता है:\n    - int: दो पथों पर एकत्रित मूल्यों का अधिकतम योग।\n\n    उदाहरण:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "hu": "Írj egy python függvényt 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' a következő probléma megoldására:\n\n    Számítsd ki az értékek maximális összegét, amelyet két útvonalon gyűjtenek össze egy N x N-es rácsban.\n\n    Ez a függvény dinamikus programozást használ, hogy megtalálja a rács bal felső sarkából a jobb alsó sarkába vezető két útvonalat, amelyek maximalizálják az összegyűjtött értékek összegét. Minden értéket legfeljebb egyszer lehet összegyűjteni, még akkor is, ha mindkét útvonal áthalad rajta.\n\n    Argok:\n    - N (int): A rács mérete (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Egy listája a tuple-öknek, ahol minden tuple tartalmazza az x-koordinátát, y-koordinátát és az értéket, amelyet a rács adott pozíciójára kell helyezni. A lista egy teljesen nullákból álló tuple-lel zárul.\n\n    Visszatér:\n    - int: Az értékek maximális összege, amelyet a két útvonalon gyűjtenek össze.\n\n    Példák:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "es": "Escribe una función de Python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' para resolver el siguiente problema:\n\n    Calcular la suma máxima de valores recogidos en dos caminos en una cuadrícula de N x N.\n\n    Esta función utiliza programación dinámica para encontrar dos caminos desde la esquina superior izquierda hasta\n    la esquina inferior derecha de la cuadrícula que maximicen la suma de los valores recogidos. Cada\n    valor puede ser recogido como máximo una vez, incluso si ambos caminos pasan por él.\n\n    Argumentos:\n    - N (int): El tamaño de la cuadrícula (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Una lista de tuplas donde cada tupla contiene\n      la coordenada x, la coordenada y, y el valor a colocar en la cuadrícula en esa posición.\n      La lista termina con una tupla con todos ceros.\n\n    Devuelve:\n    - int: La suma máxima de valores recogidos en los dos caminos.\n\n    Ejemplos:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "arb": "اكتب دالة بايثون 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' لحل المشكلة التالية:\n\n    احسب مجموع القيم الأقصى التي تم جمعها على مسارين في شبكة بحجم N x N.\n\n    تستخدم هذه الدالة البرمجة الديناميكية لإيجاد مسارين من الزاوية العلوية اليسرى إلى\n    الزاوية السفلية اليمنى من الشبكة والتي تزيد من مجموع القيم التي تم جمعها. يمكن جمع كل\n    قيمة مرة واحدة فقط، حتى إذا مر كلا المسارين عبرها.\n\n    يعيدالحجج:\n    - N (int): حجم الشبكة (N x N).\n    - grid_values (List[Tuple[int, int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على\n      الإحداثي السيني، الإحداثي الصادي، والقيمة التي سيتم وضعها على الشبكة في ذلك الموقع.\n      تنتهي القائمة بزوج يحتوي على جميع الأصفار.\n\n    يعيد:\n    - int: مجموع القيم الأقصى التي تم جمعها على المسارين.\n\n    أمثلة:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "sw": "Andika kazi ya python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili katika gridi ya N x N.\n\n    Kazi hii inatumia programu ya nguvu kupata njia mbili kutoka kona ya juu-kushoto hadi\n    kona ya chini-kulia ya gridi ambayo huongeza jumla ya thamani zilizokusanywa. Kila\n    thamani inaweza kukusanywa mara moja tu, hata kama njia zote mbili zinapita kupitia hiyo.\n\n    Hoja:\n    - N (int): Ukubwa wa gridi (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Orodha ya jozi ambapo kila jozi ina\n      x-coordinate, y-coordinate, na thamani ya kuwekwa kwenye gridi katika nafasi hiyo.\n      Orodha inakamilishwa na jozi yenye sifuri zote.\n\n    Inarejesha:\n    - int: Jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili.\n\n    Mifano:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "tr": "Bir python fonksiyonu 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' yazarak aşağıdaki problemi çözün:\n\n    N x N boyutundaki bir ızgarada iki yolda toplanan değerlerin maksimum toplamını hesaplayın.\n\n    Bu fonksiyon, dinamik programlama kullanarak ızgaranın sol üst köşesinden sağ alt köşesine\n    kadar olan iki yolu bulur ve toplanan değerlerin toplamını maksimize eder. Her bir değer\n    en fazla bir kez toplanabilir, her iki yol da üzerinden geçse bile.\n\n    Argümanlar:\n    - N (int): Izgaranın boyutu (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Her bir demetin x-koordinatı, y-koordinatı ve\n      o pozisyonda ızgaraya yerleştirilecek değeri içerdiği demetlerin bir listesi.\n      Liste, tüm elemanları sıfır olan bir demet ile sonlanır.\n\n    Döndürür:\n    - int: İki yolda toplanan değerlerin maksimum toplamı.\n\n    Örnekler:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "vi": "Viết một hàm python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' để giải quyết vấn đề sau:\n\n    Tính tổng giá trị lớn nhất thu được trên hai đường đi trong một lưới N x N.\n\n    Hàm này sử dụng lập trình động để tìm hai đường đi từ góc trên bên trái đến\n    góc dưới bên phải của lưới mà tối đa hóa tổng giá trị thu được. Mỗi\n    giá trị có thể được thu thập nhiều nhất một lần, ngay cả khi cả hai đường đi đều đi qua nó.\n\n    Tham số:\n    - N (int): Kích thước của lưới (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Một danh sách các bộ ba, trong đó mỗi bộ ba chứa\n      tọa độ x, tọa độ y, và giá trị được đặt trên lưới tại vị trí đó.\n      Danh sách kết thúc bằng một bộ ba với tất cả các số không.\n\n    Trả về:\n    - int: Tổng giá trị lớn nhất thu được trên hai đường đi.\n\n    Ví dụ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "id": "Tulis sebuah fungsi python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung jumlah maksimum nilai yang dikumpulkan pada dua jalur dalam grid N x N.\n\n    Fungsi ini menggunakan pemrograman dinamis untuk menemukan dua jalur dari sudut kiri atas\n    ke sudut kanan bawah dari grid yang memaksimalkan jumlah nilai yang dikumpulkan. Setiap\n    nilai dapat dikumpulkan paling banyak sekali, bahkan jika kedua jalur melewatinya.\n\n    Argumen:\n    - N (int): Ukuran grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Daftar tuple di mana setiap tuple berisi\n      koordinat x, koordinat y, dan nilai yang akan ditempatkan pada grid di posisi tersebut.\n      Daftar diakhiri dengan tuple yang semuanya nol.\n\n    Mengembalikan:\n    - int: Jumlah maksimum nilai yang dikumpulkan pada dua jalur.\n\n    Contoh:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "ja": "Python関数を書いてください。 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' を解決するために以下の問題を:\n\n    N x N グリッドで2つの経路で収集された値の最大合計を計算します。\n\n    この関数は、動的プログラミングを利用して、グリッドの左上隅から右下隅までの2つの経路を見つけ、\n    収集された値の合計を最大化します。各値は、たとえ両方の経路がそれを通過しても、最大で1回しか収集できません。\n\n    引数:\n    - N (int): グリッドのサイズ (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 各タプルがグリッド上のその位置に配置される\n      x座標、y座標、および値を含むタプルのリスト。リストはすべてゼロのタプルで終了します。\n\n    戻り値:\n    - int: 2つの経路で収集された値の最大合計。\n\n    例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "ko": "파이썬 함수를 작성하세요 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' 다음 문제를 해결하기 위해:\n\n    N x N 그리드에서 두 경로에서 수집된 값의 최대 합을 계산합니다.\n\n    이 함수는 동적 프로그래밍을 사용하여 그리드의 왼쪽 상단 모서리에서 오른쪽 하단 모서리까지의 두 경로를 찾아\n    수집된 값의 합을 최대화합니다. 각 값은 두 경로가 통과하더라도 최대 한 번만 수집할 수 있습니다.\n\n    인수:\n    - N (int): 그리드의 크기 (N x N).\n    - grid_values (List[Tuple[int, int, int]]): 각 튜플이 그리드의 해당 위치에 배치될\n      x좌표, y좌표, 값을 포함하는 튜플의 목록입니다.\n      목록은 모든 값이 0인 튜플로 종료됩니다.\n\n    반환:\n    - int: 두 경로에서 수집된 값의 최대 합.\n\n    예제:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "ml": "'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    N x N ഗ്രിഡിൽ രണ്ട് പാതകളിൽ ശേഖരിച്ച മൂല്യങ്ങളുടെ പരമാവധി തുക കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് ഗ്രിഡിന്റെ മുകളിൽ-ഇടത് കോണിൽ നിന്ന്\n    താഴെ-വലത് കോണിലേക്ക് രണ്ട് പാതകൾ കണ്ടെത്തുന്നു, അവ ശേഖരിച്ച മൂല്യങ്ങളുടെ തുക പരമാവധി\n    ആക്കുന്നു. ഓരോ മൂല്യവും പരമാവധി ഒരിക്കൽ മാത്രമേ ശേഖരിക്കാൻ കഴിയൂ, രണ്ട് പാതകളും\n    അതിലൂടെ കടന്നുപോയാലും.\n\n    Args:\n    - N (int): ഗ്രിഡിന്റെ വലിപ്പം (N x N).\n    - grid_values (List[Tuple[int, int, int]]): ഓരോ ട്യൂപ്പിളും x-കോഓർഡിനേറ്റ്, y-കോഓർഡിനേറ്റ്, \n      ആ സ്ഥാനത്ത് ഗ്രിഡിൽ വയ്ക്കേണ്ട മൂല്യം എന്നിവ അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക. \n      പട്ടിക മുഴുവൻ ശൂന്യങ്ങളുള്ള ഒരു ട്യൂപ്പിള് കൊണ്ട് അവസാനിക്കുന്നു.\n\n    Returns:\n    - int: രണ്ട് പാതകളിൽ ശേഖരിച്ച മൂല്യങ്ങളുടെ പരമാവധി തുക.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "fa": "یک تابع پایتون 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' بنویسید تا مسئله زیر را حل کند:\n\n    حداکثر مجموع مقادیر جمع‌آوری شده در دو مسیر در یک شبکه N x N را محاسبه کنید.\n\n    این تابع از برنامه‌ریزی پویا برای یافتن دو مسیر از گوشه بالا-چپ به\n    گوشه پایین-راست شبکه استفاده می‌کند که مجموع مقادیر جمع‌آوری شده را به حداکثر می‌رساند. هر\n    مقدار می‌تواند حداکثر یک بار جمع‌آوری شود، حتی اگر هر دو مسیر از آن عبور کنند.\n\n    آرگومان‌ها:\n    - N (int): اندازه شبکه (N x N).\n    - grid_values (List[Tuple[int, int, int]]): لیستی از تاپل‌ها که هر تاپل شامل\n      مختصات x، مختصات y و مقدار قرار داده شده در شبکه در آن موقعیت است.\n      لیست با یک تاپل که همه عناصر آن صفر است خاتمه می‌یابد.\n\n    بازگشت:\n    - int: حداکثر مجموع مقادیر جمع‌آوری شده در دو مسیر.\n\n    مثال‌ها:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67"}, "level": "hard", "test": "def test_max_value_on_paths():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_max_value_on_paths()", "entry_point": "max_value_on_paths", "signature": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:", "docstring": {"en": "\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    ", "sq": "\n    Llogarit shumën maksimale të vlerave të mbledhura në dy shtigje në një rrjet N x N.\n\n    Kjo funksion përdor programimin dinamik për të gjetur dy shtigje nga këndi i sipërm i majtë\n    deri në këndin e poshtëm të djathtë të rrjetit që maksimizojnë shumën e vlerave të mbledhura. \n    Çdo vlerë mund të mblidhet maksimumi një herë, edhe nëse të dy shtigjet kalojnë përmes saj.\n\n    Argumentet:\n    - N (int): Madhësia e rrjetit (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Një listë tuples ku çdo tuple përmban\n      koordinatën x, koordinatën y, dhe vlerën që do të vendoset në rrjet në atë pozicion.\n      Lista përfundon me një tuple me të gjitha zerot.\n\n    Kthen:\n    - int: Shuma maksimale e vlerave të mbledhura në dy shtigjet.\n\n    Shembuj:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "hy": "\n    Հաշվեք արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիներով N x N ցանցում։\n\n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ գտնելու համար երկու ուղի ցանցի վերին ձախ անկյունից\n    դեպի ցանցի ներքևի աջ անկյունը, որոնք առավելագույնի են հասցնում հավաքված արժեքների գումարը։ Յուրաքանչյուր\n    արժեք կարող է հավաքվել առավելագույնը մեկ անգամ, նույնիսկ եթե երկու ուղիներն անցնում են դրա միջով։\n\n    Արգումենտներ:\n    - N (int): Ցանցի չափը (N x N)։\n    - grid_values (List[Tuple[int, int, int]]): Կտորների ցուցակ, որտեղ յուրաքանչյուր կտոր պարունակում է\n      x-համակարգը, y-համակարգը և արժեքը, որը պետք է տեղադրվի ցանցում այդ դիրքում։\n      Ցուցակը ավարտվում է բոլոր զրոներով կտորով։\n\n    Վերադարձնում է:\n    - int: Երկու ուղիներով հավաքված արժեքների առավելագույն գումարը։\n\n    Օրինակներ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "bn": "\n    একটি N x N গ্রিডে দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল গণনা করুন।\n\n    এই ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে গ্রিডের উপরের-বাম কোণ থেকে নিচের-ডান কোণে দুটি পথ খুঁজে বের করে যা সংগৃহীত মানগুলির যোগফল সর্বাধিক করে। প্রতিটি মান সর্বাধিক একবার সংগ্রহ করা যেতে পারে, এমনকি যদি উভয় পথ এর মধ্য দিয়ে যায়।\n\n    আর্গুমেন্টস:\n    - N (int): গ্রিডের আকার (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপলে গ্রিডের নির্দিষ্ট স্থানে স্থাপন করার জন্য x-সমন্বয়, y-সমন্বয় এবং মান থাকে। তালিকাটি সমস্ত শূন্য সহ একটি টুপল দ্বারা সমাপ্ত হয়।\n\n    রিটার্নস:\n    - int: দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল।\n\n    উদাহরণ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "bg": "\n    Изчислете максималната сума от стойности, събрани по два пътя в N x N мрежа.\n\n    Тази функция използва динамично програмиране, за да намери два пътя от горния ляв ъгъл до\n    долния десен ъгъл на мрежата, които максимизират сумата на събраните стойности. Всяка\n    стойност може да бъде събрана най-много веднъж, дори ако и двата пътя минават през нея.\n\n    Аргументи:\n    - N (int): Размерът на мрежата (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Списък от кортежи, където всеки кортеж съдържа\n      x-координата, y-координата и стойност, която да бъде поставена на мрежата на тази позиция.\n      Списъкът завършва с кортеж с всички нули.\n\n    Връща:\n    - int: Максималната сума от стойности, събрани по двата пътя.\n\n    Примери:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "zh": "\n    计算在 N x N 网格中两条路径上收集的最大值和。\n\n    此函数利用动态规划找到从网格左上角到右下角的两条路径，以最大化收集的值的总和。\n    每个值最多只能收集一次，即使两条路径都经过该值。\n\n    参数:\n    - N (int): 网格的大小 (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 一个元组列表，其中每个元组包含\n      x 坐标、y 坐标以及要放置在该位置的值。列表以全为零的元组结束。\n\n    返回:\n    - int: 两条路径上收集的最大值和。\n\n    示例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "fr": "\n    Calculer la somme maximale des valeurs collectées sur deux chemins dans une grille N x N.\n\n    Cette fonction utilise la programmation dynamique pour trouver deux chemins allant du coin\n    supérieur gauche au coin inférieur droit de la grille qui maximisent la somme des valeurs\n    collectées. Chaque valeur peut être collectée au maximum une fois, même si les deux chemins\n    passent par elle.\n\n    Args:\n    - N (int): La taille de la grille (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Une liste de tuples où chaque tuple contient\n      la coordonnée x, la coordonnée y, et la valeur à placer sur la grille à cette position.\n      La liste est terminée par un tuple avec tous les zéros.\n\n    Returns:\n    - int: La somme maximale des valeurs collectées sur les deux chemins.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    ", "de": "\n    Berechne die maximale Summe der auf zwei Pfaden gesammelten Werte in einem N x N Raster.\n\n    Diese Funktion verwendet dynamische Programmierung, um zwei Pfade vom oberen linken Eckpunkt\n    zum unteren rechten Eckpunkt des Rasters zu finden, die die Summe der gesammelten Werte maximieren.\n    Jeder Wert kann höchstens einmal gesammelt werden, auch wenn beide Pfade ihn durchqueren.\n\n    Argumente:\n    - N (int): Die Größe des Rasters (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die\n      x-Koordinate, y-Koordinate und den Wert enthält, der an dieser Position im Raster platziert wird.\n      Die Liste wird durch ein Tupel mit lauter Nullen beendet.\n\n    Rückgabewert:\n    - int: Die maximale Summe der auf den beiden Pfaden gesammelten Werte.\n\n    Beispiele:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "ha": "\n    Lissafa mafi girman jimillar ƙimomin da aka tattara a kan hanyoyi biyu a cikin grid ɗin N x N.\n\n    Wannan aikin yana amfani da shirye-shiryen motsi don nemo hanyoyi biyu daga saman hagu zuwa\n    ƙasan dama na grid wanda ke ƙara yawan jimillar ƙimomin da aka tattara. Kowace ƙima za a iya tattarawa sau ɗaya kawai, ko da kuwa dukkan hanyoyin sun wuce ta cikinta.\n\n    Args:\n    - N (int): Girman grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi\n      x-coordinate, y-coordinate, da ƙima da za a sanya a kan grid a wannan matsayi.\n      Jerin yana ƙarewa da tuple mai dukkan sifili.\n\n    Returns:\n    - int: Mafi girman jimillar ƙimomin da aka tattara a kan hanyoyi biyu.\n\n    Misalai:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "hi": "\n    एक N x N ग्रिड में दो पथों पर एकत्रित मूल्यों का अधिकतम योग गणना करें।\n\n    यह फ़ंक्शन डायनेमिक प्रोग्रामिंग का उपयोग करता है ताकि ग्रिड के शीर्ष-बाएँ कोने से\n    निचले-दाएँ कोने तक दो पथ खोजे जा सकें जो एकत्रित मूल्यों के योग को अधिकतम करें। प्रत्येक\n    मूल्य को अधिकतम एक बार एकत्र किया जा सकता है, भले ही दोनों पथ उसके माध्यम से गुजरें।\n\n    तर्क:\n    - N (int): ग्रिड का आकार (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): एक सूची जिसमें प्रत्येक ट्यूपल में\n      x-निर्देशांक, y-निर्देशांक, और उस स्थिति पर ग्रिड पर रखा जाने वाला मूल्य होता है।\n      सूची एक ट्यूपल के साथ समाप्त होती है जिसमें सभी शून्य होते हैं।\n\n    लौटाता है:\n    - int: दो पथों पर एकत्रित मूल्यों का अधिकतम योग।\n\n    उदाहरण:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "hu": "\n    Számítsa ki az értékek maximális összegét, amelyet két úton gyűjtenek össze egy N x N-es rácsban.\n\n    Ez a függvény dinamikus programozást alkalmaz annak érdekében, hogy megtalálja a rács bal felső sarkából\n    a jobb alsó sarokba vezető két utat, amelyek maximalizálják az összegyűjtött értékek összegét. Minden\n    értéket legfeljebb egyszer lehet összegyűjteni, még akkor is, ha mindkét út áthalad rajta.\n\n    Paraméterek:\n    - N (int): A rács mérete (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Egy listája a hármasoknak, ahol minden hármas tartalmazza\n      az x-koordinátát, y-koordinátát és az értéket, amelyet a rács adott pozíciójára kell helyezni.\n      A lista egy teljesen nullás hármassal zárul.\n\n    Visszatér:\n    - int: Az értékek maximális összege, amelyet a két úton gyűjtöttek össze.\n\n    Példák:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "es": "    Calcular la suma máxima de valores recogidos en dos caminos en una cuadrícula de N x N.\n\n    Esta función utiliza programación dinámica para encontrar dos caminos desde la esquina\n    superior izquierda hasta la esquina inferior derecha de la cuadrícula que maximicen la\n    suma de los valores recogidos. Cada valor puede ser recogido como máximo una vez, incluso\n    si ambos caminos pasan por él.\n\n    Argumentos:\n    - N (int): El tamaño de la cuadrícula (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Una lista de tuplas donde cada tupla contiene\n      la coordenada x, la coordenada y, y el valor que se colocará en la cuadrícula en esa\n      posición. La lista está terminada por una tupla con todos ceros.\n\n    Devuelve:\n    - int: La suma máxima de valores recogidos en los dos caminos.\n\n    Ejemplos:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "arb": "    حساب الحد الأقصى لمجموع القيم المجمعة على مسارين في شبكة بحجم N x N.\n\n    تستخدم هذه الدالة البرمجة الديناميكية للعثور على مسارين من الزاوية العلوية اليسرى إلى\n    الزاوية السفلية اليمنى من الشبكة والتي تزيد من مجموع القيم المجمعة. يمكن جمع كل\n    قيمة مرة واحدة فقط، حتى إذا مر كلا المسارين بها.\n\n    Args:\n    - N (int): حجم الشبكة (N x N).\n    - grid_values (List[Tuple[int, int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على\n      الإحداثي السيني، الإحداثي الصادي، والقيمة التي توضع على الشبكة في ذلك الموضع.\n      تنتهي القائمة بزوج يحتوي على جميع الأصفار.\n\n    يعيد:\n    - int: الحد الأقصى لمجموع القيم المجمعة على المسارين.\n\n    امثله:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "sw": "    Kuhesabu jumla ya juu ya thamani zilizokusanywa kwenye njia mbili katika gridi ya N x N.\n\n    Kazi hii inatumia programu ya nguvu ili kupata njia mbili kutoka kona ya juu-kushoto hadi\n    kona ya chini-kulia ya gridi ambayo huongeza jumla ya thamani zilizokusanywa. Kila\n    thamani inaweza kukusanywa mara moja tu, hata kama njia zote mbili zinapita kupitia hiyo.\n\n    Hoja:\n    - N (int): Ukubwa wa gridi (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Orodha ya jozi ambapo kila jozi ina\n      x-kiwianishi, y-kiwianishi, na thamani ya kuwekwa kwenye gridi katika nafasi hiyo.\n      Orodha inakamilishwa na jozi yenye sifuri zote.\n\n    Inarejesha:\n    - int: Jumla ya juu ya thamani zilizokusanywa kwenye njia mbili.\n\n    Mifano:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "tr": "    N x N boyutundaki bir ızgarada iki yolda toplanan değerlerin maksimum toplamını hesaplayın.\n\n    Bu fonksiyon, dinamik programlamayı kullanarak ızgaranın sol üst köşesinden sağ alt köşesine\n    kadar olan iki yolu bulur ve toplanan değerlerin toplamını maksimize eder. Her bir değer en fazla\n    bir kez toplanabilir, her iki yol da aynı değerden geçse bile.\n\n    Argümanlar:\n    - N (int): Izgaranın boyutu (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Her bir demetin x-koordinatını, y-koordinatını ve\n      o konumda ızgaraya yerleştirilecek değeri içeren demetlerin listesi. Liste, tüm elemanları\n      sıfır olan bir demet ile sonlandırılır.\n\n    Döndürür:\n    - int: İki yolda toplanan değerlerin maksimum toplamı.\n\n    Örnekler:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "vi": "    Tính tổng lớn nhất của các giá trị thu thập được trên hai đường đi trong lưới N x N.\n\n    Hàm này sử dụng lập trình động để tìm hai đường đi từ góc trên bên trái đến\n    góc dưới bên phải của lưới nhằm tối đa hóa tổng các giá trị thu thập được. Mỗi\n    giá trị chỉ có thể được thu thập tối đa một lần, ngay cả khi cả hai đường đi đều đi qua nó.\n\n    Tham số:\n    - N (int): Kích thước của lưới (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Một danh sách các bộ ba, trong đó mỗi bộ ba chứa\n      tọa độ x, tọa độ y, và giá trị được đặt trên lưới tại vị trí đó.\n      Danh sách kết thúc bằng một bộ ba với tất cả các giá trị bằng không.\n\n    Trả về:\n    - int: Tổng lớn nhất của các giá trị thu thập được trên hai đường đi.\n\n    Ví dụ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "id": "Menghitung jumlah maksimum nilai yang dikumpulkan pada dua jalur dalam grid N x N.\n\nFungsi ini memanfaatkan pemrograman dinamis untuk menemukan dua jalur dari sudut kiri atas ke sudut kanan bawah grid yang memaksimalkan jumlah nilai yang dikumpulkan. Setiap nilai dapat dikumpulkan paling banyak sekali, bahkan jika kedua jalur melewatinya.\n\nArgs:\n- N (int): Ukuran grid (N x N).\n- grid_values (List[Tuple[int, int, int]]): Daftar tuple di mana setiap tuple berisi\n  koordinat x, koordinat y, dan nilai yang akan ditempatkan pada grid di posisi tersebut.\n  Daftar diakhiri dengan tuple yang berisi semua nol.\n\nReturns:\n- int: Jumlah maksimum nilai yang dikumpulkan pada dua jalur.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "ja": "    N x N グリッドにおける2つの経路で収集される値の最大合計を計算します。\n\n    この関数は動的プログラミングを利用して、グリッドの左上隅から右下隅までの2つの経路を見つけ、\n    収集される値の合計を最大化します。各値は、両方の経路がそれを通過したとしても、最大で1回しか収集できません。\n\n    引数:\n    - N (int): グリッドのサイズ (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 各タプルがグリッド上のその位置に配置される\n      x座標、y座標、および値を含むタプルのリスト。このリストは、すべてがゼロのタプルで終了します。\n\n    戻り値:\n    - int: 2つの経路で収集される値の最大合計。\n\n    例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "ko": "    N x N 그리드에서 두 경로로 수집한 값의 최대 합을 계산합니다.\n\n    이 함수는 동적 프로그래밍을 활용하여 그리드의 왼쪽 상단 모서리에서 오른쪽 하단 모서리까지\n    두 경로를 찾아 수집한 값의 합을 최대화합니다. 각 값은 두 경로가 통과하더라도 최대 한 번만\n    수집될 수 있습니다.\n\n    Args:\n    - N (int): 그리드의 크기 (N x N).\n    - grid_values (List[Tuple[int, int, int]]): 각 튜플이 그리드의 해당 위치에 배치될\n      x좌표, y좌표, 값을 포함하는 튜플의 리스트입니다. 리스트는 모든 값이 0인 튜플로 종료됩니다.\n\n    Returns:\n    - int: 두 경로로 수집한 값의 최대 합.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "ml": "    N x N ഗ്രിഡിലെ രണ്ട് പാതകളിൽ ശേഖരിച്ച മൂല്യങ്ങളുടെ പരമാവധി തുക കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് ഗ്രിഡിന്റെ മുകളിൽ-ഇടത് കോണിൽ നിന്ന് \n    താഴെ-വലത് കോണിലേക്ക് രണ്ട് പാതകൾ കണ്ടെത്തുന്നു, ശേഖരിച്ച മൂല്യങ്ങളുടെ തുക പരമാവധി \n    ആക്കുന്നു. ഓരോ മൂല്യവും പരമാവധി ഒരിക്കൽ മാത്രമേ ശേഖരിക്കാൻ കഴിയൂ, രണ്ട് പാതകളും \n    അതിലൂടെ കടന്നുപോയാലും.\n\n    Args:\n    - N (int): ഗ്രിഡിന്റെ വലിപ്പം (N x N).\n    - grid_values (List[Tuple[int, int, int]]): ഓരോ ട്യൂപ്പിളും x-കോഓർഡിനേറ്റ്, y-കോഓർഡിനേറ്റ്, \n      ആ സ്ഥാനത്ത് ഗ്രിഡിൽ വയ്ക്കേണ്ട മൂല്യം എന്നിവ അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക. \n      പട്ടിക മുഴുവൻ ശൂന്യങ്ങളുള്ള ഒരു ട്യൂപ്പിള് കൊണ്ട് അവസാനിക്കുന്നു.\n\n    Returns:\n    - int: രണ്ട് പാതകളിൽ ശേഖരിച്ച മൂല്യങ്ങളുടെ പരമാവധി തുക.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67", "fa": "محاسبه حداکثر مجموع مقادیر جمع‌آوری شده در دو مسیر در یک شبکه N x N.\n\nاین تابع از برنامه‌ریزی پویا برای یافتن دو مسیر از گوشه بالا-چپ به گوشه پایین-راست شبکه استفاده می‌کند که مجموع مقادیر جمع‌آوری شده را به حداکثر می‌رساند. هر مقدار می‌تواند حداکثر یک بار جمع‌آوری شود، حتی اگر هر دو مسیر از آن عبور کنند.\n\nArgs:\n- N (int): اندازه شبکه (N x N).\n- grid_values (List[Tuple[int, int, int]]): لیستی از تاپل‌ها که هر تاپل شامل مختصات x، مختصات y و مقداری است که باید در آن موقعیت روی شبکه قرار گیرد. لیست با یک تاپل که همه عناصر آن صفر هستند خاتمه می‌یابد.\n\nReturns:\n- int: حداکثر مجموع مقادیر جمع‌آوری شده در دو مسیر.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67"}}
{"task_id": "Python/9", "prompt": {"en": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "sq": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Gjeneroni të gjitha kombinimet unike të tre numrave, secili i formuar nga shifrat 1 deri në 9 pa përsëritje,\n    të tilla që numri i dytë është dy herë i pari dhe i treti është tre herë i pari.\n\n    Kthen:\n        listë e treshave: Një listë e renditur e treshave, ku secila treshe përmban tre numra të plotë që përfaqësojnë\n                          kombinimet e vlefshme të numrave në rend rritës bazuar në numrin e parë.\n\n    Shembull:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "hy": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Գեներացնել երեք թվերի բոլոր եզակի կոմբինացիաները, որոնք կազմված են 1-ից 9 թվանշաններից առանց կրկնության,\n    այնպես, որ երկրորդ թիվը լինի առաջինի կրկնակի, իսկ երրորդը՝ առաջինի եռակի։\n\n    Վերադարձնում է:\n        list of tuples: Դասավորված tuple-ների ցուցակ, որտեղ յուրաքանչյուր tuple պարունակում է երեք ամբողջ թվեր,\n                        որոնք ներկայացնում են վավեր թվային կոմբինացիաները աճման կարգով՝ հիմնված առաջին թվի վրա։\n\n    Օրինակ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "bn": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    ১ থেকে ৯ পর্যন্ত অঙ্কগুলি থেকে পুনরাবৃত্তি ছাড়াই গঠিত তিনটি সংখ্যার সমস্ত অনন্য সমন্বয় তৈরি করুন,\n    যাতে দ্বিতীয় সংখ্যা প্রথম সংখ্যার দ্বিগুণ এবং তৃতীয়টি প্রথম সংখ্যার তিনগুণ হয়।\n\n    Returns:\n        list of tuples: একটি সাজানো টুপলের তালিকা, যেখানে প্রতিটি টুপলে তিনটি পূর্ণসংখ্যা থাকে যা\n                        প্রথম সংখ্যার উপর ভিত্তি করে ক্রমবর্ধমান ক্রমে বৈধ সংখ্যার সমন্বয় উপস্থাপন করে।\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "bg": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Генерира всички уникални комбинации от три числа, всяко от които е образувано от цифрите от 1 до 9 без повторение,\n    така че второто число да е два пъти първото, а третото да е три пъти първото.\n\n    Връща:\n        списък от кортежи: Сортиран списък от кортежи, където всеки кортеж съдържа три цели числа, представляващи\n                           валидните числови комбинации във възходящ ред на базата на първото число.\n\n    Пример:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "zh": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    生成由数字1到9组成的三个数字的所有唯一组合，且每个数字不重复，\n    使得第二个数字是第一个数字的两倍，第三个数字是第一个数字的三倍。\n\n    返回:\n        list of tuples: 一个排序后的元组列表，其中每个元组包含三个整数，表示根据第一个数字升序排列的有效数字组合。\n\n    示例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "fr": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Générer toutes les combinaisons uniques de trois nombres, chacun formé à partir des chiffres de 1 à 9 sans répétition,\n    de telle sorte que le deuxième nombre soit le double du premier et le troisième soit le triple du premier.\n\n    Retourne:\n        list of tuples: Une liste triée de tuples, où chaque tuple contient trois entiers représentant les\n                        combinaisons de nombres valides dans l'ordre croissant basé sur le premier nombre.\n\n    Exemple:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "de": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generiere alle einzigartigen Kombinationen von drei Zahlen, die jeweils aus den Ziffern 1 bis 9 ohne Wiederholung gebildet werden,\n    sodass die zweite Zahl das Doppelte der ersten und die dritte das Dreifache der ersten ist.\n\n    Rückgabe:\n        list of tuples: Eine sortierte Liste von Tupeln, wobei jedes Tupel drei ganze Zahlen enthält, die die\n                        gültigen Zahlenkombinationen in aufsteigender Reihenfolge basierend auf der ersten Zahl darstellen.\n\n    Beispiel:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "ha": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Ƙirƙiri duk haɗe-haɗe na musamman na lambobi uku, kowanne an ƙirƙira shi daga lambobin 1 zuwa 9 ba tare da maimaitawa ba,\n    ta yadda lamba ta biyu ta ninka ta farko sau biyu kuma ta uku ta ninka ta farko sau uku.\n\n    Abin da ake mayarwa:\n        jerin tuples: Jerin tuples da aka tsara, inda kowane tuple ya ƙunshi lambobi uku masu wakiltar\n                      haɗe-haɗen lambobi masu inganci a cikin tsari mai tashi dangane da lamba ta farko.\n\n    Misali:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "hi": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    1 से 9 तक के अंकों से बिना पुनरावृत्ति के बने तीन संख्याओं के सभी अद्वितीय संयोजनों को उत्पन्न करें,\n    ताकि दूसरी संख्या पहली का दोगुना हो और तीसरी संख्या पहली का तीन गुना हो।\n\n    Returns:\n        list of tuples: एक क्रमबद्ध सूची जिसमें प्रत्येक ट्यूपल तीन पूर्णांकों को दर्शाता है जो पहले नंबर के आधार पर \n                        आरोही क्रम में मान्य संख्या संयोजन हैं।\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "hu": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generálja az összes egyedi háromszám-kombinációt, amelyeket az 1-től 9-ig terjedő számjegyekből képeznek ismétlés nélkül,\n    úgy, hogy a második szám kétszerese az elsőnek, a harmadik pedig háromszorosa az elsőnek.\n\n    Visszatér:\n        list of tuples: Egy rendezett lista a tuple-ökről, ahol minden tuple három egész számot tartalmaz,\n                        amelyek a megfelelő számkombinációkat ábrázolják növekvő sorrendben az első szám alapján.\n\n    Példa:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "es": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generar todas las combinaciones únicas de tres números, cada uno formado por los dígitos del 1 al 9 sin repetición,\n    de tal manera que el segundo número sea el doble del primero y el tercero sea el triple del primero.\n\n    Retorna:\n        lista de tuplas: Una lista ordenada de tuplas, donde cada tupla contiene tres enteros que representan las\n                         combinaciones de números válidas en orden ascendente basado en el primer número.\n\n    Ejemplo:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "arb": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    توليد جميع التوليفات الفريدة من ثلاثة أرقام، كل منها مكون من الأرقام من 1 إلى 9 بدون تكرار،\n    بحيث يكون الرقم الثاني ضعف الأول والثالث ثلاثة أضعاف الأول.\n\n    يعيد:\n        list of tuples: قائمة مرتبة من المجموعات، حيث يحتوي كل مجموعة على ثلاثة أعداد صحيحة تمثل\n                        توليفات الأرقام الصالحة بترتيب تصاعدي بناءً على الرقم الأول.\n\n    امثله:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "sw": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Tengeneza michanganyiko yote ya kipekee ya nambari tatu, kila moja ikiwa imetengenezwa kutoka kwa tarakimu 1 hadi 9 bila kurudia,\n    kiasi kwamba nambari ya pili ni mara mbili ya ya kwanza na ya tatu ni mara tatu ya ya kwanza.\n\n    Inarejesha:\n        orodha ya tuples: Orodha iliyopangwa ya tuples, ambapo kila tuple ina nambari tatu za integer zinazowakilisha\n                          michanganyiko halali ya nambari kwa mpangilio wa kupanda kulingana na nambari ya kwanza.\n\n    Mfano:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "tr": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    1'den 9'a kadar olan rakamlardan tekrar etmeden oluşturulan üç sayının tüm benzersiz kombinasyonlarını üret,\n    öyle ki ikinci sayı birincinin iki katı ve üçüncü sayı birincinin üç katı olsun.\n\n    Döndürür:\n        list of tuples: Her bir tuple'ın, ilk sayıya göre artan sırada geçerli sayı kombinasyonlarını temsil eden\n                        üç tam sayı içerdiği sıralı bir tuple listesi.\n\n    Örnek:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "vi": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Tạo tất cả các tổ hợp duy nhất của ba số, mỗi số được tạo từ các chữ số từ 1 đến 9 mà không lặp lại,\n    sao cho số thứ hai gấp đôi số thứ nhất và số thứ ba gấp ba lần số thứ nhất.\n\n    Trả về:\n        danh sách các bộ giá trị: Một danh sách đã sắp xếp của các bộ giá trị, trong đó mỗi bộ chứa ba số nguyên\n                                  đại diện cho các tổ hợp số hợp lệ theo thứ tự tăng dần dựa trên số thứ nhất.\n\n    Ví dụ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "id": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Menghasilkan semua kombinasi unik dari tiga angka, masing-masing dibentuk dari digit 1 hingga 9 tanpa pengulangan,\n    sedemikian rupa sehingga angka kedua adalah dua kali lipat dari yang pertama dan yang ketiga adalah tiga kali lipat dari yang pertama.\n\n    Mengembalikan:\n        list of tuples: Daftar tuple yang diurutkan, di mana setiap tuple berisi tiga bilangan bulat yang mewakili\n                        kombinasi angka yang valid dalam urutan menaik berdasarkan angka pertama.\n\n    Contoh:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "ja": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    数字1から9の数字を使って、繰り返しなしで形成される3つの数字のすべてのユニークな組み合わせを生成します。\n    その際、2番目の数字は1番目の数字の2倍、3番目の数字は1番目の数字の3倍である必要があります。\n\n    戻り値:\n        list of tuples: 各タプルが3つの整数を含むタプルのソートされたリストで、\n                        それぞれのタプルは1番目の数字に基づいて昇順で並んだ有効な数字の組み合わせを表します。\n\n    例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "ko": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    숫자 1부터 9까지의 숫자를 반복 없이 사용하여 세 숫자의 모든 고유 조합을 생성합니다.\n    두 번째 숫자는 첫 번째 숫자의 두 배이고, 세 번째 숫자는 첫 번째 숫자의 세 배입니다.\n\n    반환:\n        list of tuples: 각 튜플이 첫 번째 숫자를 기준으로 오름차순으로 정렬된 유효한 숫자 조합을 나타내는\n                        세 개의 정수를 포함하는 튜플의 정렬된 리스트입니다.\n\n    예시:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "ml": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    1 മുതൽ 9 വരെയുള്ള അക്കങ്ങൾ ആവർത്തനമില്ലാതെ ഉപയോഗിച്ച് രൂപീകരിച്ച മൂന്ന് അക്കങ്ങളുടെ എല്ലാ അനന്യ സംയോജനങ്ങളും സൃഷ്ടിക്കുക,\n    രണ്ടാമത്തെ സംഖ്യ ആദ്യത്തേതിന്റെ ഇരട്ടിയാണ്, മൂന്നാമത്തെ സംഖ്യ ആദ്യത്തേതിന്റെ മൂന്നിരട്ടിയാണ്.\n\n    മടക്കം:\n        list of tuples: ഓരോ ട്യൂപ്പിളും ആദ്യ സംഖ്യയെ അടിസ്ഥാനമാക്കി ഉയർന്ന ക്രമത്തിൽ സാധുവായ സംഖ്യാ സംയോജനങ്ങൾ അടങ്ങിയ\n                        മൂന്ന് പൂർണ്ണസംഖ്യകളെ പ്രതിനിധീകരിക്കുന്ന ട്യൂപ്പിളുകളുടെ ഒരു ക്രമീകരിച്ച പട്ടിക.\n\n    ഉദാഹരണം:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "fa": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    تولید تمام ترکیب‌های منحصر به فرد از سه عدد، که هر یک از ارقام 1 تا 9 بدون تکرار تشکیل شده‌اند،\n    به طوری که عدد دوم دو برابر اولی و عدد سوم سه برابر اولی باشد.\n\n    بازگشت:\n        list of tuples: یک لیست مرتب از تاپل‌ها، که هر تاپل شامل سه عدد صحیح است که\n                        ترکیب‌های معتبر اعداد را به ترتیب صعودی بر اساس عدد اول نشان می‌دهد.\n\n    مثال:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\""}, "canonical_solution": "# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])", "instruction": {"en": "Write a python function 'def find_number_combinations():' to solve the following problem:\n\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    ", "sq": "Shkruani një funksion python 'def find_number_combinations():' për të zgjidhur problemin e mëposhtëm:\n\n    Gjeneroni të gjitha kombinimet unike të tre numrave, secili i formuar nga shifrat 1 deri në 9 pa përsëritje,\n    në mënyrë që numri i dytë të jetë dy herë më i madh se i pari dhe i treti të jetë tri herë më i madh se i pari.\n\n    Kthen:\n        listë tuplesh: Një listë e renditur tuplesh, ku secili tuple përmban tre numra të plotë që përfaqësojnë\n                        kombinimet e vlefshme të numrave në rend rritës bazuar në numrin e parë.\n\n    Shembull:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "hy": "Պայթոն ֆունկցիա 'def find_number_combinations():' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Գեներացնել երեք թվերի բոլոր եզակի կոմբինացիաները, որոնցից յուրաքանչյուրը կազմված է 1-ից 9 թվանշաններից առանց կրկնության,\n    այնպես, որ երկրորդ թիվը լինի առաջինի կրկնակի և երրորդը՝ առաջինի եռակի:\n\n    Վերադարձնում է:\n        list of tuples: Դասավորված tuple-ների ցուցակ, որտեղ յուրաքանչյուր tuple պարունակում է երեք ամբողջ թիվ, \n                        որոնք ներկայացնում են վավեր թվային կոմբինացիաները աճման կարգով՝ հիմնված առաջին թվի վրա:\n\n    Օրինակ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "bn": "একটি পাইথন ফাংশন 'def find_number_combinations():' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    তিনটি সংখ্যার সমস্ত অনন্য সমন্বয় তৈরি করুন, প্রতিটি সংখ্যা 1 থেকে 9 পর্যন্ত অঙ্ক থেকে পুনরাবৃত্তি ছাড়াই গঠিত,\n    যাতে দ্বিতীয় সংখ্যা প্রথম সংখ্যার দ্বিগুণ এবং তৃতীয়টি প্রথম সংখ্যার তিনগুণ হয়।\n\n    Returns:\n        list of tuples: একটি সাজানো টিউপলের তালিকা, যেখানে প্রতিটি টিউপল তিনটি পূর্ণসংখ্যা ধারণ করে\n                        যা প্রথম সংখ্যার উপর ভিত্তি করে ক্রমবর্ধমান ক্রমে বৈধ সংখ্যার সমন্বয় উপস্থাপন করে।\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "bg": "Напишете Python функция 'def find_number_combinations():' за решаване на следния проблем:\n\n    Генерирайте всички уникални комбинации от три числа, всяко образувано от цифрите от 1 до 9 без повторение,\n    така че второто число да е два пъти първото, а третото да е три пъти първото.\n\n    Връща:\n        списък от кортежи: Подреден списък от кортежи, където всеки кортеж съдържа три цели числа, представляващи\n                           валидните числови комбинации във възходящ ред на базата на първото число.\n\n    Пример:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "zh": "编写一个Python函数 'def find_number_combinations():' 以解决以下问题：\n\n    生成三个数字的所有唯一组合，每个数字由1到9的数字组成且不重复，\n    使得第二个数字是第一个数字的两倍，第三个数字是第一个数字的三倍。\n\n    返回:\n        list of tuples: 一个排序的元组列表，其中每个元组包含三个整数，\n                        表示基于第一个数字按升序排列的有效数字组合。\n\n    示例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "fr": "Écrivez une fonction python 'def find_number_combinations():' pour résoudre le problème suivant :\n\n    Générer toutes les combinaisons uniques de trois nombres, chacun formé à partir des chiffres de 1 à 9 sans répétition,\n    de telle sorte que le deuxième nombre soit le double du premier et le troisième soit le triple du premier.\n\n    Renvoie :\n        liste de tuples : Une liste triée de tuples, où chaque tuple contient trois entiers représentant les\n                          combinaisons de nombres valides dans l'ordre croissant basé sur le premier nombre.\n\n    Exemple :\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "de": "Schreiben Sie eine Python-Funktion 'def find_number_combinations():' um das folgende Problem zu lösen:\n\n    Generieren Sie alle einzigartigen Kombinationen von drei Zahlen, die jeweils aus den Ziffern 1 bis 9 ohne Wiederholung gebildet werden,\n    so dass die zweite Zahl das Doppelte der ersten und die dritte das Dreifache der ersten ist.\n\n    Rückgabe:\n        Liste von Tupeln: Eine sortierte Liste von Tupeln, wobei jedes Tupel drei ganze Zahlen enthält, die die\n                          gültigen Zahlenkombinationen in aufsteigender Reihenfolge basierend auf der ersten Zahl darstellen.\n\n    Beispiel:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "ha": "Rubuta wani aikin python 'def find_number_combinations():' don warware matsalar mai zuwa:\n\n    Samar da dukkan haɗin gwiwar na musamman na lambobi uku, kowanne an kafa shi daga lambobin 1 zuwa 9 ba tare da maimaitawa ba,\n    ta yadda lamba ta biyu tana ninki biyu na na farko kuma ta uku tana ninki uku na na farko.\n\n    Returns:\n        list of tuples: Jerin jerin jeri wanda aka tsara, inda kowanne tuple ya ƙunshi lambobi uku da ke wakiltar\n                        sahihan haɗin lambobi a tsari mai tashi bisa lamba ta farko.\n\n    Misali:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "hi": "एक पायथन फ़ंक्शन 'def find_number_combinations():' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    तीन संख्याओं के सभी अद्वितीय संयोजनों को उत्पन्न करें, जिनमें से प्रत्येक को 1 से 9 तक के अंकों से बिना पुनरावृत्ति के बनाया गया है,\n    ताकि दूसरी संख्या पहली का दो गुना हो और तीसरी संख्या पहली का तीन गुना हो।\n\n    लौटाता है:\n        सूची का ट्यूपल: ट्यूपलों की एक क्रमबद्ध सूची, जहाँ प्रत्येक ट्यूपल में तीन पूर्णांक होते हैं जो पहले नंबर के आधार पर \n                        आरोही क्रम में मान्य संख्या संयोजनों का प्रतिनिधित्व करते हैं।\n\n    उदाहरण:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "hu": "Írj egy python függvényt 'def find_number_combinations():' a következő probléma megoldására:\n\n    Generálj minden egyedi kombinációt három számból, amelyek mindegyike az 1-től 9-ig terjedő számjegyekből van kialakítva ismétlés nélkül,\n    úgy, hogy a második szám kétszerese az elsőnek, és a harmadik háromszorosa az elsőnek.\n\n    Visszatérési érték:\n        list of tuples: Egy rendezett lista tuple-ökkel, ahol minden tuple három egész számot tartalmaz, amelyek a\n                        érvényes számkombinációkat képviselik növekvő sorrendben az első szám alapján.\n\n    Példa:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "es": "Escribe una función de Python 'def find_number_combinations():' para resolver el siguiente problema:\n\n    Generar todas las combinaciones únicas de tres números, cada uno formado por los dígitos del 1 al 9 sin repetición,\n    de tal manera que el segundo número sea el doble del primero y el tercero sea el triple del primero.\n\n    Retorna:\n        list of tuples: Una lista ordenada de tuplas, donde cada tupla contiene tres enteros que representan las\n                        combinaciones de números válidas en orden ascendente basado en el primer número.\n\n    Ejemplo:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "arb": "اكتب دالة بايثون 'def find_number_combinations():' لحل المشكلة التالية:\n\n    توليد جميع التوليفات الفريدة من ثلاثة أرقام، كل منها مكون من الأرقام من 1 إلى 9 دون تكرار،\n    بحيث يكون الرقم الثاني ضعف الرقم الأول والرقم الثالث ثلاثة أضعاف الرقم الأول.\n\n    يعيد:\n        list of tuples: قائمة مرتبة من التوليفات، حيث يحتوي كل توليفة على ثلاثة أعداد صحيحة تمثل\n                        التوليفات العددية الصحيحة بترتيب تصاعدي بناءً على الرقم الأول.\n\n    امثله:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "sw": "Andika kazi ya python 'def find_number_combinations():' kutatua tatizo lifuatalo:\n\n    Tengeneza michanganyiko yote ya kipekee ya namba tatu, kila moja ikiwa imetengenezwa kutoka kwa tarakimu 1 hadi 9 bila kurudia,\n    kiasi kwamba namba ya pili ni mara mbili ya ya kwanza na ya tatu ni mara tatu ya ya kwanza.\n\n    Inarudisha:\n        orodha ya tuples: Orodha iliyopangwa ya tuples, ambapo kila tuple ina namba tatu za mzima zinazowakilisha\n                          michanganyiko halali ya namba kwa mpangilio wa kupanda kulingana na namba ya kwanza.\n\n    Mfano:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "tr": "Bir python fonksiyonu 'def find_number_combinations():' yazın ve aşağıdaki problemi çözün:\n\n    1'den 9'a kadar olan rakamlardan, tekrar etmeden, her biri üç rakamdan oluşan tüm benzersiz kombinasyonları oluşturun,\n    öyle ki ikinci sayı birincinin iki katı ve üçüncü sayı birincinin üç katı olsun.\n\n    Döndürür:\n        list of tuples: Her bir tuple'ın geçerli sayı kombinasyonlarını birinci sayıya göre artan sırada içerdiği\n                        sıralı tuple listesi.\n\n    Örnek:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "vi": "Viết một hàm python 'def find_number_combinations():' để giải quyết vấn đề sau:\n\n    Tạo tất cả các tổ hợp duy nhất của ba số, mỗi số được tạo thành từ các chữ số từ 1 đến 9 mà không lặp lại,\n    sao cho số thứ hai gấp đôi số thứ nhất và số thứ ba gấp ba lần số thứ nhất.\n\n    Trả về:\n        list of tuples: Một danh sách đã sắp xếp của các bộ ba, trong đó mỗi bộ ba chứa ba số nguyên đại diện cho\n                        các tổ hợp số hợp lệ theo thứ tự tăng dần dựa trên số thứ nhất.\n\n    Ví dụ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "id": "Tulis fungsi python 'def find_number_combinations():' untuk menyelesaikan masalah berikut:\n\n    Hasilkan semua kombinasi unik dari tiga angka, masing-masing dibentuk dari digit 1 hingga 9 tanpa pengulangan,\n    sehingga angka kedua adalah dua kali angka pertama dan angka ketiga adalah tiga kali angka pertama.\n\n    Mengembalikan:\n        daftar tuple: Daftar tuple yang diurutkan, di mana setiap tuple berisi tiga bilangan bulat yang\n                      mewakili kombinasi angka yang valid dalam urutan menaik berdasarkan angka pertama.\n\n    Contoh:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "ja": "以下の問題を解決するためのPython関数 'def find_number_combinations():' を作成してください。\n\n    1から9までの数字を使って、重複なしで各々が形成される3つの数字のすべてのユニークな組み合わせを生成します。\n    ただし、2番目の数字は1番目の数字の2倍、3番目の数字は1番目の数字の3倍である必要があります。\n\n    戻り値:\n        list of tuples: 各タプルが昇順で有効な数字の組み合わせを表す3つの整数を含む、タプルのソートされたリスト。\n\n    例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "ko": "다음 문제를 해결하기 위해 'def find_number_combinations():'라는 파이썬 함수를 작성하세요:\n\n    1부터 9까지의 숫자로 구성된 세 숫자의 모든 고유한 조합을 생성합니다. 각 숫자는 반복 없이 형성되며,\n    두 번째 숫자는 첫 번째 숫자의 두 배이고 세 번째 숫자는 첫 번째 숫자의 세 배입니다.\n\n    반환값:\n        list of tuples: 각 튜플이 첫 번째 숫자를 기준으로 오름차순으로 유효한 숫자 조합을 나타내는\n                        세 개의 정수를 포함하는 정렬된 튜플 목록입니다.\n\n    예시:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "ml": "'def find_number_combinations():' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    1 മുതൽ 9 വരെയുള്ള അക്കങ്ങളിൽ നിന്ന് ആവർത്തനമില്ലാതെ രൂപീകരിക്കുന്ന മൂന്ന് സംഖ്യകളുടെ എല്ലാ അതുല്യമായ സംയോജനങ്ങളും സൃഷ്ടിക്കുക,\n    രണ്ടാമത്തെ സംഖ്യ ഒന്നാമത്തേതിന്റെ ഇരട്ടിയാകുകയും മൂന്നാമത്തെ സംഖ്യ ഒന്നാമത്തേതിന്റെ മൂന്നിരട്ടിയാകുകയും ചെയ്യുന്നു.\n\n    Returns:\n        list of tuples: ഓരോ ട്യൂപ്പിളും ആദ്യ സംഖ്യയെ അടിസ്ഥാനമാക്കി ഉയരുന്ന ക്രമത്തിൽ സാധുവായ സംഖ്യാ സംയോജനങ്ങൾ പ്രതിനിധീകരിക്കുന്ന\n                        മൂന്ന് പൂർണ്ണസംഖ്യകൾ അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ ക്രമീകരിച്ച പട്ടിക.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "fa": "یک تابع پایتون 'def find_number_combinations():' بنویسید تا مسئله زیر را حل کند:\n\n    تمام ترکیب‌های یکتای سه عدد را تولید کنید، هر کدام از ارقام 1 تا 9 بدون تکرار تشکیل شده‌اند،\n    به طوری که عدد دوم دو برابر اولی و عدد سوم سه برابر اولی باشد.\n\n    بازگرداندن:\n        list of tuples: یک لیست مرتب از تاپل‌ها، که هر تاپل شامل سه عدد صحیح است که\n                        ترکیب‌های عددی معتبر را به ترتیب صعودی بر اساس عدد اول نشان می‌دهد.\n\n    مثال:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]"}, "level": "middle", "test": "def test_find_number_combinations():\n    # Call the function to get the combinations\n    combinations = find_number_combinations()\n\n    # Check that we have at least one valid combination\n    assert len(combinations) > 0, \"There should be at least one valid combination.\"\n\n    # Iterate over each combination to perform further checks\n    for combo in combinations:\n        # Each combination should have exactly three numbers\n        assert len(combo) == 3, \"Each combination should have three numbers.\"\n\n        # Check if numbers are 3-digit numbers\n        for num in combo:\n            assert 100 <= num <= 999, f\"Each number should be a 3-digit number, got {num}.\"\n\n        # Check the 1:2:3 ratio\n        assert combo[1] == 2 * combo[0] and combo[2] == 3 * combo[0], \"The numbers should be in a 1:2:3 ratio.\"\n\n    print(\"All test cases passed!\")", "entry_point": "find_number_combinations", "signature": "def find_number_combinations():", "docstring": {"en": "\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    ", "sq": "\n    Gjeneroni të gjitha kombinimet unike të tre numrave, secili i formuar nga shifrat 1 deri në 9 pa përsëritje,\n    në mënyrë që numri i dytë të jetë dy herë i pari dhe i treti të jetë tre herë i pari.\n\n    Kthen:\n        list of tuples: Një listë e renditur tuples, ku secili tuple përmban tre numra të plotë që përfaqësojnë\n                        kombinimet e vlefshme të numrave në rend rritës bazuar në numrin e parë.\n\n    Shembull:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "hy": "\n    Գեներացնել երեք թվերի բոլոր եզակի համակցությունները, որոնցից յուրաքանչյուրը կազմված է 1-ից 9 թվանշաններից առանց կրկնության,\n    այնպես, որ երկրորդ թիվը երկու անգամ մեծ լինի առաջինից, իսկ երրորդը՝ երեք անգամ մեծ լինի առաջինից:\n\n    Վերադարձնում է:\n        list of tuples: Կարգավորված tuple-ների ցուցակ, որտեղ յուրաքանչյուր tuple պարունակում է երեք ամբողջ թիվ, \n                        որոնք ներկայացնում են վավեր թվային համակցությունները աճման կարգով՝ հիմնված առաջին թվի վրա:\n\n    Օրինակ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "bn": "\n    ১ থেকে ৯ পর্যন্ত অঙ্কগুলি থেকে পুনরাবৃত্তি ছাড়াই গঠিত তিনটি সংখ্যার সমস্ত অনন্য সংমিশ্রণ তৈরি করুন, \n    যাতে দ্বিতীয় সংখ্যা প্রথম সংখ্যার দ্বিগুণ এবং তৃতীয়টি প্রথম সংখ্যার তিনগুণ হয়।\n\n    Returns:\n        list of tuples: একটি সাজানো টুপলের তালিকা, যেখানে প্রতিটি টুপলে তিনটি পূর্ণসংখ্যা থাকে যা \n                        প্রথম সংখ্যার উপর ভিত্তি করে ক্রমবর্ধমান ক্রমে বৈধ সংখ্যার সংমিশ্রণ উপস্থাপন করে।\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "bg": "\n    Генерирайте всички уникални комбинации от три числа, всяко от които е образувано от цифрите от 1 до 9 без повторение,\n    така че второто число да е два пъти по-голямо от първото, а третото да е три пъти по-голямо от първото.\n\n    Връща:\n        списък от кортежи: Сортиран списък от кортежи, където всеки кортеж съдържа три цели числа, представляващи\n                           валидните числови комбинации във възходящ ред въз основа на първото число.\n\n    Пример:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "zh": "\n    生成所有由数字1到9组成的三个数字的唯一组合，每个数字不重复，\n    使得第二个数字是第一个数字的两倍，第三个数字是第一个数字的三倍。\n\n    返回:\n        list of tuples: 一个排序后的元组列表，其中每个元组包含三个整数，表示基于第一个数字按升序排列的有效数字组合。\n\n    示例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "fr": "\n    Générer toutes les combinaisons uniques de trois nombres, chacun formé à partir des chiffres de 1 à 9 sans répétition,\n    de sorte que le deuxième nombre soit le double du premier et le troisième soit le triple du premier.\n\n    Retourne:\n        list of tuples: Une liste triée de tuples, où chaque tuple contient trois entiers représentant les\n                        combinaisons de nombres valides en ordre croissant basé sur le premier nombre.\n\n    Exemple:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "de": "\n    Erzeuge alle einzigartigen Kombinationen von drei Zahlen, die jeweils aus den Ziffern 1 bis 9 ohne Wiederholung gebildet werden,\n    so dass die zweite Zahl das Doppelte der ersten und die dritte das Dreifache der ersten ist.\n\n    Rückgabe:\n        list of tuples: Eine sortierte Liste von Tupeln, wobei jedes Tupel drei ganze Zahlen enthält, die die\n                        gültigen Zahlenkombinationen in aufsteigender Reihenfolge basierend auf der ersten Zahl darstellen.\n\n    Beispiel:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "ha": "\n    Samar da duk haɗakarwa na musamman na lambobi uku, kowanne an ƙirƙira shi daga lambobin 1 zuwa 9 ba tare da maimaitawa ba,\n    ta yadda lamba ta biyu sau biyu ce ta farko kuma ta uku sau uku ce ta farko.\n\n    Yana dawowa:\n        jerin tubalan: Jerin tubalan da aka tsara, inda kowane tubali ya ƙunshi lambobi uku da ke wakiltar\n                        haɗakar lambobi masu inganci a cikin tsari mai tashi dangane da lamba ta farko.\n\n    Misali:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "hi": "\n    1 से 9 तक के अंकों से बिना पुनरावृत्ति के बने तीन संख्याओं के सभी अद्वितीय संयोजन उत्पन्न करें,\n    ताकि दूसरी संख्या पहली संख्या का दोगुना हो और तीसरी संख्या पहली संख्या का तीन गुना हो।\n\n    Returns:\n        list of tuples: एक क्रमबद्ध सूची जो tuples का समावेश करती है, जहाँ प्रत्येक tuple तीन पूर्णांकों को \n                        दर्शाता है जो पहले संख्या के आधार पर आरोही क्रम में वैध संख्या संयोजन हैं।\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "hu": "\n    Generálja az összes egyedi kombinációját három számnak, mindegyik az 1-től 9-ig terjedő számjegyekből ismétlés nélkül, úgy, hogy a második szám kétszerese az elsőnek, a harmadik pedig háromszorosa az elsőnek.\n\n    Visszatér:\n        list of tuples: Egy rendezett lista a tuple-ökkel, ahol minden tuple három egész számot tartalmaz, amelyek a megfelelő számkombinációkat képviselik növekvő sorrendben az első szám alapján.\n\n    Példa:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "es": "\n    Genera todas las combinaciones únicas de tres números, cada uno formado por los dígitos del 1 al 9 sin repetición, de tal manera que el segundo número sea el doble del primero y el tercero sea el triple del primero.\n\nDevuelve:\n    list of tuples: Una lista ordenada de tuplas, donde cada tupla contiene tres enteros que representan las combinaciones de números válidas en orden ascendente basado en el primer número.\n\nEjemplo:\n    >>> find_number_combinations()\n    [(123, 246, 369), (124, 248, 372), ...]", "arb": "\n    توليد جميع التوليفات الفريدة من ثلاثة أرقام، كل منها مكون من الأرقام من 1 إلى 9 بدون تكرار،\n    بحيث يكون الرقم الثاني ضعف الأول والثالث ثلاثة أضعاف الأول.\n\n    يعيد:\n        list of tuples: قائمة مرتبة من المجموعات، حيث يحتوي كل مجموعة على ثلاثة أعداد صحيحة تمثل\n                        توليفات الأرقام الصحيحة بترتيب تصاعدي بناءً على الرقم الأول.\n\n    امثله:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "sw": "\n    Tengeneza mchanganyiko wa kipekee wa nambari tatu, kila moja ikitengenezwa kutoka kwa tarakimu 1 hadi 9 bila kurudia,\n    ambapo nambari ya pili ni mara mbili ya ya kwanza na ya tatu ni mara tatu ya ya kwanza.\n\n    Inarejesha:\n        orodha ya tuples: Orodha iliyopangwa ya tuples, ambapo kila tuple ina nambari tatu za mzima zinazowakilisha\n                          mchanganyiko halali wa nambari katika mpangilio wa kupanda kulingana na nambari ya kwanza.\n\n    Mfano:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "tr": "\n    1'den 9'a kadar olan rakamlardan tekrar etmeden oluşturulan üç sayının tüm benzersiz kombinasyonlarını üretin,\n    öyle ki ikinci sayı birincinin iki katı ve üçüncü sayı birincinin üç katı olsun.\n\n    Dönüş:\n        list of tuples: Her bir demetin, ilk sayıya göre artan sırayla geçerli sayı kombinasyonlarını temsil eden\n                        üç tam sayı içerdiği sıralı bir demet listesi.\n\n    Örnek:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "vi": "\n    Tạo tất cả các tổ hợp duy nhất của ba số, mỗi số được tạo từ các chữ số từ 1 đến 9 mà không lặp lại,\n    sao cho số thứ hai gấp đôi số thứ nhất và số thứ ba gấp ba lần số thứ nhất.\n\n    Trả về:\n        list of tuples: Một danh sách đã sắp xếp của các bộ ba, trong đó mỗi bộ ba chứa ba số nguyên đại diện cho\n                        các tổ hợp số hợp lệ theo thứ tự tăng dần dựa trên số thứ nhất.\n\n    Ví dụ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "id": "    Hasilkan semua kombinasi unik dari tiga angka, masing-masing dibentuk dari digit 1 hingga 9 tanpa pengulangan,\n    sedemikian rupa sehingga angka kedua adalah dua kali lipat dari yang pertama dan yang ketiga adalah tiga kali lipat dari yang pertama.\n\n    Mengembalikan:\n        list of tuples: Daftar tuple yang diurutkan, di mana setiap tuple berisi tiga bilangan bulat yang mewakili\n                        kombinasi angka yang valid dalam urutan menaik berdasarkan angka pertama.\n\n    Contoh:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "ja": "    1から9までの数字を使用して、各桁を重複させずに形成された3つの数のすべてのユニークな組み合わせを生成します。\n    ただし、2番目の数は1番目の数の2倍であり、3番目の数は1番目の数の3倍である必要があります。\n\n    戻り値:\n        list of tuples: 各タプルが昇順で有効な数の組み合わせを表す3つの整数を含む、タプルのソートされたリスト。\n\n    例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "ko": "    1부터 9까지의 숫자로 구성된 세 숫자의 모든 고유 조합을 생성합니다. 각 숫자는 반복 없이 사용되며,\n    두 번째 숫자는 첫 번째 숫자의 두 배이고 세 번째 숫자는 첫 번째 숫자의 세 배입니다.\n\n    반환:\n        list of tuples: 각 튜플이 첫 번째 숫자를 기준으로 오름차순으로 정렬된 유효한 숫자 조합을 나타내는\n                        세 개의 정수를 포함하는 튜플의 정렬된 목록입니다.\n\n    예:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "ml": "    1 മുതൽ 9 വരെ ഉള്ള അക്കങ്ങൾ ആവർത്തനമില്ലാതെ ഉപയോഗിച്ച് രൂപീകരിക്കുന്ന മൂന്നു സംഖ്യകളുടെ എല്ലാ അനന്യ സംയോജനങ്ങളും സൃഷ്ടിക്കുക,\n    രണ്ടാമത്തെ സംഖ്യ ഒന്നാമത്തെ സംഖ്യയുടെ ഇരട്ടിയാകുകയും മൂന്നാമത്തെ സംഖ്യ ഒന്നാമത്തെ സംഖ്യയുടെ മൂന്നു മടങ്ങ് ആയിരിക്കുകയും വേണം.\n\n    Returns:\n        list of tuples: ഓരോ ട്യൂപ്പിളും മൂന്നു പൂർണ്ണസംഖ്യകൾ അടങ്ങിയ, ആദ്യ സംഖ്യയുടെ ക്രമത്തിൽ ക്രമീകരിച്ച\n                        സാധുവായ സംഖ്യാ സംയോജനങ്ങളുടെ ഒരു ക്രമീകരിച്ച പട്ടിക.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]", "fa": "تولید تمام ترکیب‌های منحصر به فرد از سه عدد، که هر کدام از ارقام 1 تا 9 بدون تکرار تشکیل شده‌اند، به گونه‌ای که عدد دوم دو برابر عدد اول و عدد سوم سه برابر عدد اول باشد.\n\nReturns:\n    list of tuples: یک لیست مرتب از تاپل‌ها، که هر تاپل شامل سه عدد صحیح است که ترکیب‌های معتبر اعداد را به ترتیب صعودی بر اساس عدد اول نشان می‌دهند.\n\nExample:\n    >>> find_number_combinations()\n    [(123, 246, 369), (124, 248, 372), ...]"}}
{"task_id": "Python/10", "prompt": {"en": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "sq": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Llogarit shumën kumulative të vlerave faktoriel nga 1 deri te një numër i specifikuar n.\n\n    Kjo funksion përdor një metodë më efikase për të llogaritur faktoriel duke shumëzuar\n    në mënyrë iterative numrin aktual me rezultatin e mëparshëm të faktorielit, duke shmangur\n    llogaritjet e panevojshme. Pastaj akumulon faktorielin e çdo numri nga 1 deri te n përfshirë.\n\n    Argumentet:\n    n (int): Kufiri i sipërm i intervalit për të cilin do të llogaritet shuma e faktorielit.\n             Vlera e n duhet të jetë në intervalin nga 1 deri në 50, përfshirë.\n\n    Kthen:\n    int: Shuma e të gjitha vlerave faktoriel nga 1! deri te n!.\n\n    Shembuj:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "hy": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Հաշվարկել ֆակտորիալ արժեքների կուտակային գումարը 1-ից մինչև նշված ամբողջ թիվ n:\n\n    Այս ֆունկցիան օգտագործում է ավելի արդյունավետ մեթոդ ֆակտորիալներ հաշվարկելու համար՝\n    հերթական թվի բազմապատկմամբ նախորդ ֆակտորիալ արդյունքի վրա, այդպիսով խուսափելով ավելորդ\n    հաշվարկներից: Այնուհետև այն կուտակում է 1-ից մինչև n ներառյալ յուրաքանչյուր թվի ֆակտորիալը:\n\n    Պարամետրեր:\n    n (int): Շարքի վերին սահմանը, որի համար պետք է հաշվարկել ֆակտորիալների գումարը:\n             n-ի արժեքը պետք է լինի 1-ից 50 միջակայքում, ներառյալ:\n\n    Վերադարձնում է:\n    int: Բոլոր ֆակտորիալ արժեքների գումարը 1! -ից մինչև n!:\n\n    Օրինակներ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "bn": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    ১ থেকে নির্দিষ্ট পূর্ণসংখ্যা n পর্যন্ত ফ্যাক্টোরিয়াল মানের সমষ্টি গণনা করুন।\n\n    এই ফাংশনটি ফ্যাক্টোরিয়াল গণনা করার জন্য আরও দক্ষ পদ্ধতি ব্যবহার করে, \n    যা পূর্ববর্তী ফ্যাক্টোরিয়াল ফলাফলের সাথে বর্তমান সংখ্যাকে গুণ করে \n    পুনরাবৃত্তি করে, ফলে অপ্রয়োজনীয় গণনা এড়ানো যায়। \n    এরপর এটি ১ থেকে n পর্যন্ত প্রতিটি সংখ্যার ফ্যাক্টোরিয়াল যোগ করে।\n\n    আর্গুমেন্টসমূহ:\n    n (int): সেই পরিসরের উপরের সীমা যার জন্য ফ্যাক্টোরিয়াল সমষ্টি গণনা করা হবে।\n             n এর মান ১ থেকে ৫০ এর মধ্যে হওয়া উচিত, অন্তর্ভুক্ত।\n\n    রিটার্নস:\n    int: ১! থেকে n! পর্যন্ত সমস্ত ফ্যাক্টোরিয়াল মানের সমষ্টি।\n\n    উদাহরণ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "bg": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Изчислява кумулативната сума на факториелните стойности от 1 до зададено цяло число n.\n\n    Тази функция използва по-ефективен метод за изчисляване на факториелите, като итеративно\n    умножава текущото число с предишния резултат от факториела, като по този начин избягва\n    излишни изчисления. След това натрупва факториела на всяко число от 1 до n включително.\n\n    Аргументи:\n    n (int): Горната граница на диапазона, за който трябва да се изчисли сумата на факториелите.\n             Стойността на n трябва да бъде в диапазона от 1 до 50, включително.\n\n    Връща:\n    int: Сумата на всички факториелни стойности от 1! до n!.\n\n    Примери:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "zh": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    计算从1到指定整数n的阶乘值的累积和。\n\n    此函数采用更高效的方法来计算阶乘，通过迭代地将当前数字乘以前一个阶乘结果，从而避免冗余计算。\n    然后累加从1到n（包括n）的每个数字的阶乘。\n\n    参数:\n    n (int): 要计算阶乘和的范围上限。\n             n的值应在1到50之间（包括1和50）。\n\n    返回:\n    int: 从1!到n!的所有阶乘值的和。\n\n    示例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "fr": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Calculer la somme cumulative des valeurs factorielles de 1 jusqu'à un entier spécifié n.\n\n    Cette fonction utilise une méthode plus efficace pour calculer les factorielles en multipliant\n    itérativement le nombre actuel par le résultat factoriel précédent, évitant ainsi des calculs\n    redondants. Elle accumule ensuite la factorielle de chaque nombre de 1 à n inclusivement.\n\n    Args:\n    n (int): La limite supérieure de la plage pour laquelle la somme factorielle doit être calculée.\n             La valeur de n doit être comprise entre 1 et 50, inclusivement.\n\n    Returns:\n    int: La somme de toutes les valeurs factorielles de 1! à n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "de": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Berechne die kumulative Summe der Fakultätswerte von 1 bis zu einer angegebenen ganzen Zahl n.\n\n    Diese Funktion verwendet eine effizientere Methode zur Berechnung von Fakultäten, indem sie\n    die aktuelle Zahl iterativ mit dem vorherigen Fakultätsergebnis multipliziert, um so\n    redundante Berechnungen zu vermeiden. Anschließend akkumuliert sie die Fakultät jeder Zahl\n    von 1 bis einschließlich n.\n\n    Argumente:\n    n (int): Die obere Grenze des Bereichs, für den die Fakultätssumme berechnet werden soll.\n             Der Wert von n sollte im Bereich von 1 bis 50 liegen, einschließlich.\n\n    Rückgabewert:\n    int: Die Summe aller Fakultätswerte von 1! bis n!.\n\n    Beispiele:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "ha": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Lissafa jimillar darajar factorial daga 1 har zuwa wani adadi n da aka fayyace.\n\n    Wannan aikin yana amfani da wata hanya mai inganci don lissafin factorial ta hanyar\n    ninka adadin yanzu da sakamakon factorial na baya, don haka yana guje wa lissafi\n    mai maimaitawa. Daga nan yana tara factorial na kowane adadi daga 1 zuwa n har da shi.\n\n    Args:\n    n (int): Iyakar kewayon da za a lissafa jimillar factorial.\n             Darajar n ya kamata ta kasance a cikin kewayon 1 zuwa 50, har da shi.\n\n    Returns:\n    int: Jimillar duk darajar factorial daga 1! zuwa n!.\n\n    Misalai:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "hi": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1 से लेकर एक निर्दिष्ट पूर्णांक n तक के फैक्टोरियल मानों का संचयी योग गणना करें।\n\n    यह फ़ंक्शन फैक्टोरियल्स की गणना के लिए एक अधिक कुशल विधि का उपयोग करता है, \n    जो वर्तमान संख्या को पिछले फैक्टोरियल परिणाम से गुणा करके अनावश्यक गणनाओं से बचता है। \n    इसके बाद यह 1 से n तक प्रत्येक संख्या के फैक्टोरियल को जोड़ता है।\n\n    Args:\n    n (int): वह सीमा जिसके लिए फैक्टोरियल योग की गणना की जानी है।\n             n का मान 1 से 50 के बीच होना चाहिए, समावेशी।\n\n    Returns:\n    int: 1! से n! तक के सभी फैक्टोरियल मानों का योग।\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "hu": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Számítsa ki a faktoriális értékek kumulatív összegét 1-től egy megadott n egész számig.\n\n    Ez a függvény egy hatékonyabb módszert alkalmaz a faktoriálisok kiszámítására azáltal, hogy\n    iteratívan szorozza meg az aktuális számot az előző faktoriális eredménnyel, így elkerülve\n    a felesleges számításokat. Ezután összegzi az 1-től n-ig terjedő számok faktoriálisát, beleértve n-t is.\n\n    Paraméterek:\n    n (int): Az a felső határ, amelynek tartományához a faktoriális összegét ki kell számítani.\n             Az n értékének 1 és 50 között kell lennie, beleértve.\n\n    Visszatérési érték:\n    int: Az 1! és n! közötti összes faktoriális érték összege.\n\n    Példák:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "es": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Calcular la suma acumulativa de valores factoriales desde 1 hasta un entero especificado n.\n\n    Esta función emplea un método más eficiente para calcular factoriales multiplicando\n    iterativamente el número actual por el resultado factorial anterior, evitando así cálculos\n    redundantes. Luego acumula el factorial de cada número desde 1 hasta n inclusive.\n\n    Argumentos:\n    n (int): El límite superior del rango para el cual se va a calcular la suma de factoriales.\n             El valor de n debe estar en el rango de 1 a 50, inclusive.\n\n    Devuelve:\n    int: La suma de todos los valores factoriales desde 1! hasta n!.\n\n    Ejemplos:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "arb": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    حساب المجموع التراكمي لقيم المضروب من 1 حتى عدد صحيح محدد n.\n\n    تستخدم هذه الدالة طريقة أكثر كفاءة لحساب المضروبات عن طريق ضرب الرقم الحالي في نتيجة المضروب السابقة،\n    وبالتالي تجنب الحسابات المتكررة. ثم تجمع مضروب كل رقم من 1 إلى n بشكل شامل.\n\n    يعيدالحجج:\n    n (int): الحد الأعلى للنطاق الذي سيتم حساب مجموع المضروب له.\n             يجب أن تكون قيمة n في النطاق من 1 إلى 50، شاملًا.\n\n    يعيد:\n    int: مجموع جميع قيم المضروب من 1! إلى n!.\n\n    أمثلة:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "sw": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Kuhesabu jumla ya thamani za faktoria kutoka 1 hadi n iliyobainishwa.\n\n    Kazi hii inatumia mbinu bora zaidi ya kuhesabu faktoria kwa kuzidisha\n    namba ya sasa na matokeo ya faktoria ya awali, hivyo kuepuka mahesabu\n    yanayojirudia. Kisha inakusanya faktoria ya kila namba kutoka 1 hadi n\n    ikijumuishwa.\n\n    Hoja:\n    n (int): Kikomo cha juu cha safu ambayo jumla ya faktoria itahesabiwa.\n             Thamani ya n inapaswa kuwa katika safu ya 1 hadi 50, ikijumuishwa.\n\n    Inarejesha:\n    int: Jumla ya thamani zote za faktoria kutoka 1! hadi n!.\n\n    Mifano:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "tr": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1'den belirtilen bir tamsayı n'e kadar olan faktöriyel değerlerinin kümülatif toplamını hesaplayın.\n\n    Bu fonksiyon, faktöriyel hesaplamalarını daha verimli bir şekilde gerçekleştirmek için\n    mevcut sayıyı önceki faktöriyel sonucuyla çarparak yinelemeli bir yöntem kullanır, böylece\n    gereksiz hesaplamalardan kaçınılır. Daha sonra 1'den n'e kadar her sayının faktöriyelini toplar.\n\n    Argümanlar:\n    n (int): Faktöriyel toplamının hesaplanacağı aralığın üst sınırı.\n             n değeri 1 ile 50 arasında olmalıdır, dahil.\n\n    Döndürür:\n    int: 1!'den n!'e kadar olan tüm faktöriyel değerlerinin toplamı.\n\n    Örnekler:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "vi": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Tính tổng tích lũy của các giá trị giai thừa từ 1 đến một số nguyên n được chỉ định.\n\n    Hàm này sử dụng một phương pháp hiệu quả hơn để tính giai thừa bằng cách nhân lặp\n    số hiện tại với kết quả giai thừa trước đó, do đó tránh được các tính toán dư thừa.\n    Sau đó, nó tích lũy giai thừa của mỗi số từ 1 đến n bao gồm cả n.\n\n    Tham số:\n    n (int): Giới hạn trên của phạm vi mà tổng giai thừa sẽ được tính.\n             Giá trị của n nên nằm trong khoảng từ 1 đến 50, bao gồm cả 1 và 50.\n\n    Trả về:\n    int: Tổng của tất cả các giá trị giai thừa từ 1! đến n!.\n\n    Ví dụ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "id": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Hitung jumlah kumulatif dari nilai faktorial dari 1 hingga bilangan bulat tertentu n.\n\n    Fungsi ini menggunakan metode yang lebih efisien untuk menghitung faktorial dengan\n    mengalikan bilangan saat ini dengan hasil faktorial sebelumnya secara iteratif, sehingga\n    menghindari perhitungan yang berlebihan. Kemudian mengakumulasi faktorial dari setiap\n    bilangan dari 1 hingga n secara inklusif.\n\n    Args:\n    n (int): Batas atas dari rentang untuk mana jumlah faktorial akan dihitung.\n             Nilai n harus berada dalam rentang 1 hingga 50, inklusif.\n\n    Returns:\n    int: Jumlah dari semua nilai faktorial dari 1! hingga n!.\n\n    Contoh:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "ja": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1から指定された整数nまでの階乗値の累積和を計算します。\n\n    この関数は、現在の数を前の階乗の結果に反復的に掛けることで、階乗を計算する\n    より効率的な方法を採用し、冗長な計算を避けます。その後、1からnまでの各数の\n    階乗を累積します。\n\n    引数:\n    n (int): 階乗の和を計算する範囲の上限。\n             nの値は1から50の範囲内であるべきです。\n\n    戻り値:\n    int: 1!からn!までのすべての階乗値の合計。\n\n    例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "ko": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1부터 지정된 정수 n까지의 팩토리얼 값의 누적 합을 계산합니다.\n\n    이 함수는 이전 팩토리얼 결과에 현재 숫자를 반복적으로 곱하여 팩토리얼을 계산하는\n    보다 효율적인 방법을 사용하여 불필요한 계산을 피합니다. 그런 다음 1부터 n까지의\n    각 숫자의 팩토리얼을 포함하여 누적합니다.\n\n    Args:\n    n (int): 팩토리얼 합을 계산할 범위의 상한 값.\n             n의 값은 1에서 50 사이여야 합니다.\n\n    Returns:\n    int: 1!부터 n!까지의 모든 팩토리얼 값의 합.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "ml": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1 മുതൽ ഒരു നിർദ്ദിഷ്ടമായ പൂർണ്ണസംഖ്യ n വരെ ഫാക്ടോറിയൽ മൂല്യങ്ങളുടെ സംയോജിത തുക കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ഫാക്ടോറിയലുകൾ കണക്കാക്കാൻ കൂടുതൽ കാര്യക്ഷമമായ ഒരു രീതി ഉപയോഗിക്കുന്നു,\n    അതായത്, നിലവിലെ സംഖ്യയെ മുൻ ഫാക്ടോറിയൽ ഫലത്തിൽ ഗുണിച്ചുകൊണ്ട് ആവർത്തിച്ച്\n    ഗണിതങ്ങൾ ഒഴിവാക്കുന്നു. തുടർന്ന് 1 മുതൽ n വരെയുള്ള ഓരോ സംഖ്യയുടെ ഫാക്ടോറിയൽ\n    സമാഹരിക്കുന്നു.\n\n    Args:\n    n (int): ഫാക്ടോറിയൽ തുക കണക്കാക്കേണ്ട ശ്രേണിയുടെ മുകളിൽ പരിധി.\n             n-ന്റെ മൂല്യം 1 മുതൽ 50 വരെയുള്ള പരിധിയിൽ ആയിരിക്കണം.\n\n    Returns:\n    int: 1! മുതൽ n! വരെയുള്ള എല്ലാ ഫാക്ടോറിയൽ മൂല്യങ്ങളുടെ തുക.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"", "fa": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    محاسبه مجموع تجمعی مقادیر فاکتوریل از 1 تا یک عدد صحیح مشخص n.\n\n    این تابع از یک روش کارآمدتر برای محاسبه فاکتوریل‌ها استفاده می‌کند که با ضرب\n    عدد جاری در نتیجه فاکتوریل قبلی، از محاسبات تکراری جلوگیری می‌کند. سپس فاکتوریل\n    هر عدد از 1 تا n را به صورت تجمعی جمع می‌کند.\n\n    آرگومان‌ها:\n    n (int): حد بالای دامنه‌ای که مجموع فاکتوریل برای آن محاسبه می‌شود.\n             مقدار n باید در محدوده 1 تا 50 باشد، شامل هر دو.\n\n    بازگشت:\n    int: مجموع تمام مقادیر فاکتوریل از 1! تا n!.\n\n    مثال‌ها:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\""}, "canonical_solution": "    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials", "instruction": {"en": "Write a python function 'def sum_of_factorials_optimized(n: int) -> int:' to solve the following problem:\n\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "sq": "Shkruani një funksion python 'def sum_of_factorials_optimized(n: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni shumën kumulative të vlerave faktoriale nga 1 deri te një numër i caktuar n.\n\n    Ky funksion përdor një metodë më efikase për të llogaritur faktorialet duke shumëzuar në mënyrë iterative\n    numrin aktual me rezultatin e mëparshëm faktorial, duke shmangur kështu llogaritjet e panevojshme.\n    Më pas akumulon faktorialin e secilit numër nga 1 deri në n përfshirë.\n\n    Args:\n    n (int): Kufiri i sipërm i intervalit për të cilin do të llogaritet shuma faktoriale.\n             Vlera e n duhet të jetë në intervalin nga 1 deri në 50, përfshirë.\n\n    Kthen:\n    int: Shuma e të gjitha vlerave faktoriale nga 1! deri në n!.\n\n    Shembuj:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "hy": "Պայթոն ֆունկցիա 'def sum_of_factorials_optimized(n: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք ֆակտորիալ արժեքների կումուլյատիվ գումարը 1-ից մինչև նշված ամբողջ թիվ n:\n\n    Այս ֆունկցիան օգտագործում է ավելի արդյունավետ մեթոդ ֆակտորիալները հաշվարկելու համար՝\n    ընթացիկ թիվը բազմապատկելով նախորդ ֆակտորիալ արդյունքի հետ, այդպիսով խուսափելով ավելորդ\n    հաշվարկներից: Այնուհետև այն կուտակում է 1-ից մինչև n ներառյալ յուրաքանչյուր թվի ֆակտորիալը:\n\n    Արգումենտներ:\n    n (int): Շարքի վերին սահմանը, որի համար պետք է հաշվարկվի ֆակտորիալ գումարը:\n             n-ի արժեքը պետք է լինի 1-ից 50 միջակայքում, ներառյալ:\n\n    Վերադարձնում է:\n    int: Բոլոր ֆակտորիալ արժեքների գումարը 1! -ից մինչև n!:\n\n    Օրինակներ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "bn": "একটি পাইথন ফাংশন 'def sum_of_factorials_optimized(n: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    1 থেকে একটি নির্দিষ্ট পূর্ণসংখ্যা n পর্যন্ত ফ্যাক্টোরিয়াল মানগুলির সামষ্টিক যোগফল গণনা করুন।\n\n    এই ফাংশনটি ফ্যাক্টোরিয়াল গণনা করার জন্য একটি আরও দক্ষ পদ্ধতি ব্যবহার করে যা পূর্ববর্তী ফ্যাক্টোরিয়াল ফলাফলের সাথে বর্তমান সংখ্যাকে গুণ করে, ফলে অপ্রয়োজনীয় গণনা এড়ানো যায়। এটি তারপর 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার ফ্যাক্টোরিয়ালকে অন্তর্ভুক্ত করে যোগফল করে।\n\n    Args:\n    n (int): ফ্যাক্টোরিয়াল যোগফল গণনা করার জন্য যার পরিসরের উপরের সীমা।\n             n এর মান 1 থেকে 50 এর মধ্যে হওয়া উচিত, অন্তর্ভুক্ত।\n\n    Returns:\n    int: 1! থেকে n! পর্যন্ত সমস্ত ফ্যাক্টোরিয়াল মানের যোগফল।\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "bg": "Напишете Python функция 'def sum_of_factorials_optimized(n: int) -> int:', за да решите следния проблем:\n\n    Изчислете кумулативната сума на факториелните стойности от 1 до дадено цяло число n.\n\n    Тази функция използва по-ефективен метод за изчисляване на факториели, като итеративно\n    умножава текущото число с предишния резултат от факториела, като по този начин избягва\n    излишни изчисления. След това натрупва факториела на всяко число от 1 до n включително.\n\n    Аргументи:\n    n (int): Горната граница на диапазона, за който трябва да се изчисли сумата на факториелите.\n             Стойността на n трябва да бъде в диапазона от 1 до 50, включително.\n\n    Връща:\n    int: Сумата на всички факториелни стойности от 1! до n!.\n\n    Примери:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "zh": "编写一个 python 函数 'def sum_of_factorials_optimized(n: int) -> int:' 来解决以下问题：\n\n    计算从 1 到指定整数 n 的阶乘值的累积和。\n\n    该函数采用一种更高效的方法来计算阶乘，通过迭代地将当前数字乘以前一个阶乘结果，从而避免冗余计算。然后，它累积从 1 到 n（包括 n）的每个数字的阶乘。\n\n    参数:\n    n (int): 要计算阶乘和的范围的上限。\n             n 的值应在 1 到 50 之间（包括 1 和 50）。\n\n    返回:\n    int: 从 1! 到 n! 的所有阶乘值的和。\n\n    示例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "fr": "Écrivez une fonction python 'def sum_of_factorials_optimized(n: int) -> int:' pour résoudre le problème suivant :\n\n    Calculer la somme cumulative des valeurs factorielles de 1 jusqu'à un entier spécifié n.\n\n    Cette fonction utilise une méthode plus efficace pour calculer les factorielles en multipliant\n    itérativement le nombre actuel par le résultat factoriel précédent, évitant ainsi les calculs redondants.\n    Elle accumule ensuite la factorielle de chaque nombre de 1 à n inclusivement.\n\n    Args:\n    n (int): La limite supérieure de la plage pour laquelle la somme factorielle doit être calculée.\n             La valeur de n doit être comprise entre 1 et 50, inclusivement.\n\n    Returns:\n    int: La somme de toutes les valeurs factorielles de 1! à n!.\n\n    Exemples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "de": "Schreiben Sie eine Python-Funktion 'def sum_of_factorials_optimized(n: int) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die kumulative Summe der Fakultätswerte von 1 bis zu einer angegebenen ganzen Zahl n.\n\n    Diese Funktion verwendet eine effizientere Methode zur Berechnung von Fakultäten, indem sie\n    die aktuelle Zahl iterativ mit dem vorherigen Fakultätsergebnis multipliziert und so\n    redundante Berechnungen vermeidet. Anschließend summiert sie die Fakultät jeder Zahl von 1 bis einschließlich n.\n\n    Argumente:\n    n (int): Die obere Grenze des Bereichs, für den die Fakultätssumme berechnet werden soll.\n             Der Wert von n sollte im Bereich von 1 bis 50 liegen, einschließlich.\n\n    Rückgabewert:\n    int: Die Summe aller Fakultätswerte von 1! bis n!.\n\n    Beispiele:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "ha": "Rubuta wani aikin python 'def sum_of_factorials_optimized(n: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa jimlar jimlar ƙimar factorial daga 1 har zuwa wani cikakken lamba n.\n\n    Wannan aikin yana amfani da wata hanya mai inganci don lissafin factorials ta hanyar \n    ninka lambar yanzu zuwa sakamakon factorial na baya, ta haka yana guje wa lissafin \n    da ba dole ba. Sannan yana tara factorial na kowace lamba daga 1 zuwa n har da shi.\n\n    Args:\n    n (int): Iyakar kewayon wanda za a lissafa jimlar factorial.\n             Darajar n ya kamata ta kasance a cikin kewayon 1 zuwa 50, har da shi.\n\n    Returns:\n    int: Jimlar duk ƙimar factorial daga 1! zuwa n!.\n\n    Misalai:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "hi": "एक पायथन फ़ंक्शन 'def sum_of_factorials_optimized(n: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    1 से लेकर निर्दिष्ट पूर्णांक n तक के फैक्टोरियल मानों का संचयी योग गणना करें।\n\n    यह फ़ंक्शन फैक्टोरियल्स की गणना के लिए एक अधिक कुशल विधि का उपयोग करता है, \n    जो वर्तमान संख्या को पिछले फैक्टोरियल परिणाम से गुणा करके पुनरावृत्त रूप से करता है, \n    इस प्रकार अनावश्यक गणनाओं से बचता है। फिर यह 1 से n तक प्रत्येक संख्या का फैक्टोरियल \n    समावेशी रूप से संचित करता है।\n\n    तर्क:\n    n (int): वह सीमा जिसके लिए फैक्टोरियल योग की गणना की जानी है।\n             n का मान 1 से 50 के बीच होना चाहिए, समावेशी।\n\n    लौटाता है:\n    int: 1! से n! तक के सभी फैक्टोरियल मानों का योग।\n\n    उदाहरण:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "hu": "Írj egy Python függvényt 'def sum_of_factorials_optimized(n: int) -> int:' a következő probléma megoldására:\n\n    Számítsd ki a faktoriális értékek összegét 1-től egy megadott n egész számig.\n\n    Ez a függvény egy hatékonyabb módszert alkalmaz a faktoriálisok kiszámítására azáltal, hogy iteratívan\n    szorozza a jelenlegi számot az előző faktoriális eredménnyel, így elkerülve a felesleges\n    számításokat. Ezután összegzi az 1-től n-ig terjedő számok faktoriálisát, beleértve.\n\n    Argumentumok:\n    n (int): Az a tartomány felső határa, amelyre a faktoriális összeg kiszámítandó.\n             Az n értékének 1 és 50 között kell lennie, beleértve.\n\n    Visszatér:\n    int: Az összes faktoriális érték összege 1!-től n!-ig.\n\n    Példák:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "es": "Escribe una función de Python 'def sum_of_factorials_optimized(n: int) -> int:' para resolver el siguiente problema:\n\n    Calcular la suma acumulativa de los valores factoriales desde 1 hasta un número entero especificado n.\n\n    Esta función emplea un método más eficiente para calcular factoriales multiplicando iterativamente\n    el número actual por el resultado factorial anterior, evitando así cálculos redundantes. Luego acumula el factorial de cada número desde 1 hasta n inclusive.\n\n    Argumentos:\n    n (int): El límite superior del rango para el cual se debe calcular la suma de factoriales.\n             El valor de n debe estar en el rango de 1 a 50, inclusive.\n\n    Devuelve:\n    int: La suma de todos los valores factoriales desde 1! hasta n!.\n\n    Ejemplos:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "arb": "اكتب دالة بايثون 'def sum_of_factorials_optimized(n: int) -> int:' لحل المشكلة التالية:\n\n    احسب المجموع التراكمي لقيم المضاعفات من 1 حتى عدد صحيح محدد n.\n\n    تستخدم هذه الدالة طريقة أكثر كفاءة لحساب المضاعفات عن طريق ضرب الرقم الحالي في نتيجة المضاعف السابقة بشكل تكراري، وبالتالي تجنب الحسابات الزائدة. ثم تجمع مضاعف كل رقم من 1 إلى n بشكل شامل.\n\n    يعيدالحجج:\n    n (int): الحد الأعلى للنطاق الذي سيتم حساب مجموع المضاعفات له.\n             يجب أن تكون قيمة n في النطاق من 1 إلى 50، شاملًا.\n\n    يعيد:\n    int: مجموع جميع قيم المضاعفات من 1! إلى n!.\n\n    أمثلة:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "sw": "Andika kazi ya python 'def sum_of_factorials_optimized(n: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu jumla ya thamani za factorial kutoka 1 hadi n iliyobainishwa.\n\n    Kazi hii inatumia njia bora zaidi ya kuhesabu factorial kwa kuzidisha\n    nambari ya sasa na matokeo ya factorial ya awali, hivyo kuepuka mahesabu ya kurudia.\n    Kisha inakusanya factorial ya kila nambari kutoka 1 hadi n ikijumuisha.\n\n    Hoja:\n    n (int): Kikomo cha juu cha safu ambayo jumla ya factorial inapaswa kuhesabiwa.\n             Thamani ya n inapaswa kuwa katika safu ya 1 hadi 50, ikijumuisha.\n\n    Inarejesha:\n    int: Jumla ya thamani zote za factorial kutoka 1! hadi n!.\n\n    Mifano:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "tr": "Bir python fonksiyonu 'def sum_of_factorials_optimized(n: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    1'den belirtilen bir tamsayı n'ye kadar olan faktöriyel değerlerinin kümülatif toplamını hesaplayın.\n\n    Bu fonksiyon, faktöriyelleri hesaplamak için daha verimli bir yöntem kullanır; önceki faktöriyel sonucuna\n    mevcut sayıyı çarparak tekrarlayan hesaplamalardan kaçınır. Daha sonra 1'den n'ye kadar her sayının\n    faktöriyelini toplar.\n\n    Argümanlar:\n    n (int): Faktöriyel toplamının hesaplanacağı aralığın üst sınırı.\n             n'nin değeri 1 ile 50 arasında olmalıdır, dahil.\n\n    Döndürür:\n    int: 1!'den n!'ye kadar olan tüm faktöriyel değerlerinin toplamı.\n\n    Örnekler:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "vi": "Viết một hàm python 'def sum_of_factorials_optimized(n: int) -> int:' để giải quyết vấn đề sau:\n\n    Tính tổng tích lũy của các giá trị giai thừa từ 1 đến một số nguyên n được chỉ định.\n\n    Hàm này sử dụng một phương pháp hiệu quả hơn để tính giai thừa bằng cách nhân lặp\n    số hiện tại với kết quả giai thừa trước đó, do đó tránh được các tính toán dư thừa.\n    Sau đó, nó tích lũy giai thừa của mỗi số từ 1 đến n bao gồm cả n.\n\n    Tham số:\n    n (int): Giới hạn trên của phạm vi mà tổng giai thừa cần được tính toán.\n             Giá trị của n nên nằm trong khoảng từ 1 đến 50, bao gồm cả 50.\n\n    Trả về:\n    int: Tổng của tất cả các giá trị giai thừa từ 1! đến n!.\n\n    Ví dụ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "id": "Tulis sebuah fungsi python 'def sum_of_factorials_optimized(n: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung jumlah kumulatif dari nilai faktorial dari 1 hingga bilangan bulat tertentu n.\n\n    Fungsi ini menggunakan metode yang lebih efisien untuk menghitung faktorial dengan cara mengalikan\n    angka saat ini dengan hasil faktorial sebelumnya secara iteratif, sehingga menghindari perhitungan\n    yang berlebihan. Kemudian mengakumulasi faktorial dari setiap angka dari 1 hingga n secara inklusif.\n\n    Argumen:\n    n (int): Batas atas dari rentang untuk mana jumlah faktorial akan dihitung.\n             Nilai n harus dalam rentang 1 hingga 50, inklusif.\n\n    Mengembalikan:\n    int: Jumlah dari semua nilai faktorial dari 1! hingga n!.\n\n    Contoh:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "ja": "Python関数 'def sum_of_factorials_optimized(n: int) -> int:' を作成して、次の問題を解決してください:\n\n    1から指定された整数nまでの階乗値の累積和を計算します。\n\n    この関数は、より効率的な方法で階乗を計算するために、現在の数を前の階乗結果に反復的に掛けることで、冗長な計算を避けます。次に、1からnまでの各数の階乗を累積します。\n\n    引数:\n    n (int): 階乗の合計を計算する範囲の上限。\n             nの値は1から50の範囲内である必要があります。\n\n    戻り値:\n    int: 1!からn!までのすべての階乗値の合計。\n\n    例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "ko": "다음 문제를 해결하기 위해 'def sum_of_factorials_optimized(n: int) -> int:'라는 파이썬 함수를 작성하십시오:\n\n    1부터 지정된 정수 n까지의 팩토리얼 값의 누적 합을 계산합니다.\n\n    이 함수는 현재 숫자를 이전 팩토리얼 결과에 반복적으로 곱하여 불필요한 계산을 피함으로써\n    팩토리얼을 계산하는 보다 효율적인 방법을 사용합니다. 그런 다음 1부터 n까지 각 숫자의\n    팩토리얼을 포함하여 누적합니다.\n\n    매개변수:\n    n (int): 팩토리얼 합계를 계산할 범위의 상한선.\n             n의 값은 1에서 50 사이여야 합니다.\n\n    반환값:\n    int: 1!부터 n!까지 모든 팩토리얼 값의 합.\n\n    예시:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "ml": "'def sum_of_factorials_optimized(n: int) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ കാണിച്ചിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    1 മുതൽ ഒരു നിർദ്ദിഷ്ട പൂർണ്ണസംഖ്യ n വരെ ഫാക്ടോറിയൽ മൂല്യങ്ങളുടെ ആകെ തുക കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ഫാക്ടോറിയലുകൾ കണക്കാക്കാൻ കൂടുതൽ കാര്യക്ഷമമായ ഒരു രീതി ഉപയോഗിക്കുന്നു, \n    അതായത്, നിലവിലെ സംഖ്യയെ മുൻ ഫാക്ടോറിയൽ ഫലത്തിൽ ഗുണിച്ച് ആവർത്തിച്ച്, \n    ആവർത്തന കണക്കുകൾ ഒഴിവാക്കുന്നു. \n    തുടർന്ന് 1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ ഫാക്ടോറിയലും കൂട്ടിച്ചേർക്കുന്നു.\n\n    Args:\n    n (int): ഫാക്ടോറിയൽ തുക കണക്കാക്കേണ്ട ശ്രേണിയുടെ മുകളിലെ പരിധി. \n             n-ന്റെ മൂല്യം 1 മുതൽ 50 വരെയുള്ള ശ്രേണിയിലായിരിക്കണം.\n\n    Returns:\n    int: 1! മുതൽ n! വരെ എല്ലാ ഫാക്ടോറിയൽ മൂല്യങ്ങളുടെയും തുക.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "fa": "یک تابع پایتون 'def sum_of_factorials_optimized(n: int) -> int:' بنویسید تا مسئله زیر را حل کند:\n\n    مجموع تجمعی مقادیر فاکتوریل را از 1 تا یک عدد صحیح مشخص n محاسبه کنید.\n\n    این تابع از یک روش کارآمدتر برای محاسبه فاکتوریل‌ها استفاده می‌کند که با ضرب عدد فعلی در نتیجه فاکتوریل قبلی به صورت تکراری،\n    از محاسبات زائد جلوگیری می‌کند. سپس فاکتوریل هر عدد از 1 تا n را به صورت فراگیر جمع می‌کند.\n\n    آرگومان‌ها:\n    n (int): حد بالای بازه‌ای که برای آن مجموع فاکتوریل باید محاسبه شود.\n             مقدار n باید در بازه 1 تا 50 باشد، شامل.\n\n    بازگشت:\n    int: مجموع تمام مقادیر فاکتوریل از 1! تا n!.\n\n    مثال‌ها:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153"}, "level": "easy", "test": "def test_sum_of_factorials_optimized():\n    assert sum_of_factorials_optimized(1) == 1, \"Test case 1 failed: sum_of_factorials_optimized(1) should be 1.\"\n    assert sum_of_factorials_optimized(3) == 9, \"Test case 2 failed: sum_of_factorials_optimized(3) should be 9.\"\n    assert sum_of_factorials_optimized(4) == 33, \"Test case 3 failed: sum_of_factorials_optimized(4) should be 33.\"\n    assert sum_of_factorials_optimized(5) == 153, \"Test case 4 failed: sum_of_factorials_optimized(5) should be 153.\"\n    assert sum_of_factorials_optimized(6) == 873, \"Test case 5 failed: sum_of_factorials_optimized(6) should be 873.\"\n    assert sum_of_factorials_optimized(10) == 4037913, \"Test case 6 failed: sum_of_factorials_optimized(10) should be 4037913.\"\n    print(\"All test cases passed.\")\n\n# Call the test function to run the test cases\ntest_sum_of_factorials_optimized()", "entry_point": "sum_of_factorials_optimized", "signature": "def sum_of_factorials_optimized(n: int) -> int:", "docstring": {"en": "\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "sq": "\n    Llogarit shumën kumulative të vlerave faktoriel nga 1 deri te një numër i specifikuar n.\n\n    Kjo funksion përdor një metodë më efikase për të llogaritur faktorielët duke shumëzuar në mënyrë iteruese\n    numrin aktual me rezultatin e mëparshëm të faktorielit, duke shmangur kështu llogaritjet e panevojshme.\n    Më pas, akumulon faktorielin e secilit numër nga 1 deri te n përfshirë.\n\n    Argumentet:\n    n (int): Kufiri i sipërm i intervalit për të cilin do të llogaritet shuma e faktorielit.\n             Vlera e n duhet të jetë në intervalin nga 1 deri në 50, përfshirë.\n\n    Kthen:\n    int: Shuma e të gjitha vlerave faktoriel nga 1! deri te n!.\n\n    Shembuj:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "hy": "\n    Հաշվել ֆակտորիալ արժեքների կուտակային գումարը 1-ից մինչև նշված n ամբողջ թիվը:\n\n    Այս ֆունկցիան օգտագործում է ավելի արդյունավետ մեթոդ ֆակտորիալները հաշվելու համար՝\n    հերթական թվին բազմապատկելով նախորդ ֆակտորիալի արդյունքը, այդպիսով խուսափելով ավելորդ\n    հաշվարկներից: Այնուհետև այն կուտակում է 1-ից մինչև n ներառյալ յուրաքանչյուր թվի ֆակտորիալը:\n\n    Պարամետրեր:\n    n (int): Շարքի վերին սահմանը, որի համար պետք է հաշվարկել ֆակտորիալների գումարը:\n             n-ի արժեքը պետք է լինի 1-ից 50 միջակայքում, ներառյալ:\n\n    Վերադարձնում է:\n    int: Բոլոր ֆակտորիալ արժեքների գումարը 1!-ից մինչև n!:\n\n    Օրինակներ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "bn": "\n    ১ থেকে একটি নির্দিষ্ট পূর্ণসংখ্যা n পর্যন্ত ফ্যাক্টোরিয়াল মানগুলির ক্রমবর্ধমান যোগফল গণনা করুন।\n\n    এই ফাংশনটি ফ্যাক্টোরিয়াল গণনা করার জন্য একটি আরও দক্ষ পদ্ধতি ব্যবহার করে, যা পূর্ববর্তী ফ্যাক্টোরিয়াল ফলাফলের সাথে বর্তমান সংখ্যাকে গুণ করে, ফলে অপ্রয়োজনীয় গণনা এড়ানো যায়। এটি ১ থেকে n পর্যন্ত প্রতিটি সংখ্যার ফ্যাক্টোরিয়ালকে অন্তর্ভুক্ত করে জমা করে।\n\n    আর্গস:\n    n (int): ফ্যাক্টোরিয়াল যোগফল গণনা করার জন্য সীমার উপরের সীমা।\n             n এর মান ১ থেকে ৫০ এর মধ্যে হওয়া উচিত, অন্তর্ভুক্ত।\n\n    রিটার্নস:\n    int: ১! থেকে n! পর্যন্ত সমস্ত ফ্যাক্টোরিয়াল মানের যোগফল।\n\n    উদাহরণ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "bg": "\n    Изчислете кумулативната сума на факториелните стойности от 1 до дадено цяло число n.\n\nТази функция използва по-ефективен метод за изчисляване на факториели, като итеративно умножава текущото число с предишния резултат на факториела, като по този начин избягва излишни изчисления. След това натрупва факториела на всяко число от 1 до n включително.\n\nАргументи:\nn (int): Горната граница на диапазона, за който трябва да се изчисли сумата на факториелите.\n         Стойността на n трябва да бъде в диапазона от 1 до 50, включително.\n\nВръща:\nint: Сумата на всички факториелни стойности от 1! до n!.\n\nПримери:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n    153\n    ", "zh": "\n    计算从 1 到指定整数 n 的阶乘值的累积和。\n\n    该函数采用一种更高效的方法来计算阶乘，通过迭代地将当前数字乘以前一个阶乘结果，从而避免冗余计算。\n    然后累积从 1 到 n（包括 n）每个数字的阶乘。\n\n    参数:\n    n (int): 要计算阶乘和的范围上限。\n             n 的值应在 1 到 50 之间（包括 1 和 50）。\n\n    返回:\n    int: 从 1! 到 n! 的所有阶乘值的和。\n\n    示例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "fr": "\n    Calculer la somme cumulative des valeurs factorielles de 1 jusqu'à un entier spécifié n.\n\n    Cette fonction utilise une méthode plus efficace pour calculer les factorielles en multipliant\n    de manière itérative le nombre actuel par le résultat factoriel précédent, évitant ainsi les\n    calculs redondants. Elle accumule ensuite la factorielle de chaque nombre de 1 à n inclusivement.\n\n    Args:\n    n (int): La limite supérieure de la plage pour laquelle la somme des factorielles doit être calculée.\n             La valeur de n doit être comprise entre 1 et 50, inclusivement.\n\n    Returns:\n    int: La somme de toutes les valeurs factorielles de 1! à n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "de": "\n    Berechne die kumulative Summe der Fakultätswerte von 1 bis zu einer angegebenen ganzen Zahl n.\n\n    Diese Funktion verwendet eine effizientere Methode zur Berechnung von Fakultäten, indem sie\n    die aktuelle Zahl mit dem vorherigen Fakultätsergebnis multipliziert, um so redundante\n    Berechnungen zu vermeiden. Anschließend summiert sie die Fakultät jeder Zahl von 1 bis einschließlich n.\n\n    Argumente:\n    n (int): Die obere Grenze des Bereichs, für den die Fakultätssumme berechnet werden soll.\n             Der Wert von n sollte im Bereich von 1 bis 50 liegen, einschließlich.\n\n    Rückgabewert:\n    int: Die Summe aller Fakultätswerte von 1! bis n!.\n\n    Beispiele:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "ha": "\n    Lissafa jimillar darajar factorial daga 1 har zuwa wani adadi n da aka kayyade.\n\n    Wannan aikin yana amfani da wata hanya mai inganci don lissafin factorial ta hanyar\n    ninka adadi na yanzu da sakamakon factorial na baya, don haka yana guje wa lissafi\n    maras amfani. Sannan yana tara factorial na kowanne adadi daga 1 zuwa n ciki har da shi.\n\n    Args:\n    n (int): Iyakacin adadin da za a lissafa jimillar factorial.\n             Darajar n ya kamata ta kasance a tsakanin 1 zuwa 50, ciki har da su.\n\n    Returns:\n    int: Jimillar dukkan darajar factorial daga 1! zuwa n!.\n\n    Misalai:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "hi": "\n    1 से लेकर एक निर्दिष्ट पूर्णांक n तक के फैक्टोरियल मानों का संचयी योग गणना करें।\n\n    यह फ़ंक्शन फैक्टोरियल की गणना के लिए एक अधिक कुशल विधि का उपयोग करता है, \n    जो वर्तमान संख्या को पिछले फैक्टोरियल परिणाम से गुणा करके अनावश्यक गणनाओं से बचता है। \n    फिर यह 1 से n तक प्रत्येक संख्या के फैक्टोरियल को जोड़ता है।\n\n    तर्क:\n    n (int): उस सीमा का ऊपरी सीमा जिसके लिए फैक्टोरियल योग की गणना की जानी है। \n             n का मान 1 से 50 की सीमा में होना चाहिए, समावेशी।\n\n    वापसी:\n    int: 1! से n! तक के सभी फैक्टोरियल मानों का योग।\n\n    उदाहरण:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "hu": "\n    Számítsa ki az 1-től egy megadott n egész számig terjedő faktoriális értékek kumulatív összegét.\n\n    Ez a függvény hatékonyabb módszert alkalmaz a faktoriálisok kiszámítására azáltal, hogy iteratívan\n    megszorozza a jelenlegi számot az előző faktoriális eredménnyel, így elkerülve a felesleges\n    számításokat. Ezután összegzi az 1-től n-ig terjedő számok faktoriálisát, beleértve n-t is.\n\n    Paraméterek:\n    n (int): Az a tartomány felső határa, amelyre a faktoriális összeget ki kell számítani.\n             Az n értékének 1 és 50 között kell lennie, beleértve mindkettőt.\n\n    Visszatér:\n    int: Az 1! és n! közötti összes faktoriális érték összege.\n\n    Példák:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "es": "Calcular la suma acumulativa de los valores factoriales desde 1 hasta un entero especificado n.\n\nEsta función emplea un método más eficiente para calcular factoriales multiplicando iterativamente el número actual por el resultado factorial anterior, evitando así cálculos redundantes. Luego acumula el factorial de cada número desde 1 hasta n inclusive.\n\nArgumentos:\nn (int): El límite superior del rango para el cual se va a calcular la suma de factoriales.\n         El valor de n debe estar en el rango de 1 a 50, inclusive.\n\nDevuelve:\nint: La suma de todos los valores factoriales desde 1! hasta n!.\n\nEjemplos:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153", "arb": "\n    حساب مجموع القيم التراكمية للعاملي من 1 حتى عدد صحيح محدد n.\n\n    تستخدم هذه الدالة طريقة أكثر كفاءة لحساب القيم العاملي عن طريق ضرب العدد الحالي\n    في نتيجة العاملي السابقة بشكل تكراري، مما يتجنب الحسابات المكررة. ثم تجمع العاملي\n    لكل عدد من 1 إلى n بشكل شامل.\n\n    يعيدالحجج:\n    n (int): الحد الأعلى للنطاق الذي سيتم حساب مجموع القيم العاملي له.\n             يجب أن تكون قيمة n في النطاق من 1 إلى 50، شامل.\n\n    يعيد:\n    int: مجموع كل القيم العاملي من 1! إلى n!.\n\n    امثله:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ", "sw": "\n    Hesabu jumla ya thamani za faktoria kutoka 1 hadi n iliyobainishwa.\n\n    Kazi hii hutumia njia bora zaidi ya kuhesabu faktoria kwa kuzidisha\n    nambari ya sasa na matokeo ya faktoria ya awali, hivyo kuepuka mahesabu\n    yasiyo ya lazima. Kisha inakusanya faktoria ya kila nambari kutoka 1 hadi n ikijumuishwa.\n\n    Vipengele:\n    n (int): Kikomo cha juu cha safu ambayo jumla ya faktoria itahesabiwa.\n             Thamani ya n inapaswa kuwa katika safu ya 1 hadi 50, ikijumuishwa.\n\n    Inarejesha:\n    int: Jumla ya thamani zote za faktoria kutoka 1! hadi n!.\n\n    Mifano:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "tr": "\n    1'den belirtilen bir tamsayı n'e kadar olan faktöriyel değerlerinin kümülatif toplamını hesaplayın.\n\n    Bu fonksiyon, faktöriyelleri hesaplamak için daha verimli bir yöntem kullanır; önceki faktöriyel sonucuna\n    mevcut sayıyı iteratif olarak çarparak gereksiz hesaplamalardan kaçınır. Daha sonra 1'den n'e kadar\n    her sayının faktöriyelini toplar.\n\n    Argümanlar:\n    n (int): Faktöriyel toplamının hesaplanacağı aralığın üst sınırı.\n             n değeri 1 ile 50 arasında olmalıdır, her iki değer de dahil.\n\n    Döndürür:\n    int: 1!'den n!'e kadar olan tüm faktöriyel değerlerinin toplamı.\n\n    Örnekler:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "vi": "\n    Tính tổng tích lũy của các giá trị giai thừa từ 1 đến một số nguyên n được chỉ định.\n\n    Hàm này sử dụng một phương pháp hiệu quả hơn để tính giai thừa bằng cách nhân lặp\n    số hiện tại với kết quả giai thừa trước đó, do đó tránh được các tính toán dư thừa.\n    Sau đó, nó tích lũy giai thừa của mỗi số từ 1 đến n bao gồm cả n.\n\n    Tham số:\n    n (int): Giới hạn trên của phạm vi mà tổng giai thừa sẽ được tính toán.\n             Giá trị của n nên nằm trong khoảng từ 1 đến 50, bao gồm cả 1 và 50.\n\n    Trả về:\n    int: Tổng của tất cả các giá trị giai thừa từ 1! đến n!.\n\n    Ví dụ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "id": "Menghitung jumlah kumulatif dari nilai faktorial dari 1 hingga bilangan bulat n yang ditentukan.\n\nFungsi ini menggunakan metode yang lebih efisien untuk menghitung faktorial dengan cara mengalikan bilangan saat ini dengan hasil faktorial sebelumnya secara iteratif, sehingga menghindari perhitungan yang berlebihan. Kemudian, fungsi ini mengakumulasi faktorial dari setiap bilangan dari 1 hingga n secara inklusif.\n\nArgs:\nn (int): Batas atas dari rentang untuk mana jumlah faktorial akan dihitung.\n         Nilai n harus berada dalam rentang 1 hingga 50, inklusif.\n\nReturns:\nint: Jumlah dari semua nilai faktorial dari 1! hingga n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153", "ja": "    1から指定された整数nまでの階乗値の累積和を計算します。\n\n    この関数は、より効率的な方法で階乗を計算するために、現在の数を前の階乗結果に\n    反復的に掛けることで冗長な計算を避けます。そして、1からnまでの各数の階乗を累積します。\n\n    引数:\n    n (int): 階乗の和を計算する範囲の上限。\n             nの値は1から50の範囲である必要があります（両端を含む）。\n\n    戻り値:\n    int: 1!からn!までのすべての階乗値の合計。\n\n    例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "ko": "    1부터 지정된 정수 n까지의 팩토리얼 값의 누적 합을 계산합니다.\n\n    이 함수는 이전 팩토리얼 결과에 현재 숫자를 반복적으로 곱하여 팩토리얼을 계산하는\n    보다 효율적인 방법을 사용하여 불필요한 계산을 피합니다. 그런 다음 1부터 n까지\n    각 숫자의 팩토리얼을 누적합니다.\n\n    Args:\n    n (int): 팩토리얼 합을 계산할 범위의 상한선.\n             n의 값은 1에서 50 사이여야 합니다.\n\n    Returns:\n    int: 1!부터 n!까지 모든 팩토리얼 값의 합.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "ml": "    1 മുതൽ ഒരു നിർദ്ദിഷ്ടമായ പൂർണ്ണസംഖ്യ n വരെ ഫാക്ടോറിയൽ മൂല്യങ്ങളുടെ സമാകലനം കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ഫാക്ടോറിയലുകൾ കണക്കാക്കാൻ കൂടുതൽ കാര്യക്ഷമമായ രീതിയാണ് ഉപയോഗിക്കുന്നത്, \n    അതായത്, നിലവിലെ സംഖ്യയെ മുൻ ഫാക്ടോറിയൽ ഫലത്തിൽ ഗുണിച്ചുകൊണ്ട് ആവർത്തനാത്മകമായി കണക്കാക്കുന്നു, \n    അതുവഴി ആവർത്തന കണക്കുകൾ ഒഴിവാക്കുന്നു. \n    ഇത് 1 മുതൽ n വരെ ഓരോ സംഖ്യയുടെ ഫാക്ടോറിയലും സമാഹരിക്കുന്നു.\n\n    Args:\n    n (int): ഫാക്ടോറിയൽ സമാഹാരം കണക്കാക്കേണ്ട ശ്രേണിയുടെ പരമാവധി പരിധി.\n             n-ന്റെ മൂല്യം 1 മുതൽ 50 വരെയുള്ള പരിധിയിലായിരിക്കണം, ഉൾപ്പെടെ.\n\n    Returns:\n    int: 1! മുതൽ n! വരെ എല്ലാ ഫാക്ടോറിയൽ മൂല്യങ്ങളുടെയും സമാഹാരം.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153", "fa": "محاسبه مجموع تجمعی مقادیر فاکتوریل از 1 تا یک عدد صحیح مشخص n.\n\nاین تابع از یک روش کارآمدتر برای محاسبه فاکتوریل‌ها استفاده می‌کند که با ضرب عدد فعلی در نتیجه فاکتوریل قبلی، از محاسبات تکراری جلوگیری می‌کند. سپس فاکتوریل هر عدد از 1 تا n را به صورت فراگیر جمع می‌کند.\n\nآرگومان‌ها:\nn (int): حد بالای بازه‌ای که مجموع فاکتوریل برای آن محاسبه می‌شود.\n         مقدار n باید در بازه 1 تا 50 باشد، شامل.\n\nبرمی‌گرداند:\nint: مجموع تمام مقادیر فاکتوریل از 1! تا n!.\n\nمثال‌ها:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153"}}
{"task_id": "Python/11", "prompt": {"en": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    \"\"\"", "sq": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Përcakton numëruesin dhe emëruesin e termit të N-të në tabelën e Cantor-it.\n\n    Argumentet:\n    - N (int): Pozicioni në tabelën e Cantor-it për të cilin do të gjendet fraksioni përkatës.\n\n    Kthen:\n    - str: Një përfaqësim me varg i fraksionit në pozicionin e N-të në tabelën e Cantor-it.\n    \"\"\"", "hy": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Որոշում է Cantor աղյուսակի N-րդ անդամի համարիչը և հայտարարիչը։\n\n    Պարամետրեր:\n    - N (int): Դիրքը Cantor աղյուսակում, որի համար պետք է գտնել համապատասխան կոտորակը։\n\n    Վերադարձնում է:\n    - str: Տողային ներկայացում Cantor աղյուսակի N-րդ դիրքի կոտորակի։\n    \"\"\"", "bn": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    ক্যান্টর টেবিলের N-তম পদের লব ও হর নির্ধারণ করে।\n\n    আর্গুমেন্ট:\n    - N (int): ক্যান্টর টেবিলে যে অবস্থানের জন্য সংশ্লিষ্ট ভগ্নাংশ খুঁজতে হবে।\n\n    রিটার্নস:\n    - str: ক্যান্টর টেবিলের N-তম অবস্থানে থাকা ভগ্নাংশের একটি স্ট্রিং উপস্থাপনা।\n    \"\"\"", "bg": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Определя числителя и знаменателя на N-тия член в таблицата на Кантор.\n\n    Аргументи:\n    - N (int): Позицията в таблицата на Кантор, за която да се намери съответната дроб.\n\n    Връща:\n    - str: Стринг представяне на дробта на N-тата позиция в таблицата на Кантор.\n    \"\"\"", "zh": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    确定康托表中第 N 项的分子和分母。\n\n    参数:\n    - N (int): 康托表中要查找对应分数的位置。\n\n    返回:\n    - str: 康托表中第 N 个位置的分数的字符串表示。\n    \"\"\"", "fr": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Détermine le numérateur et le dénominateur du N-ième terme dans la table de Cantor.\n\n    Arguments:\n    - N (int): La position dans la table de Cantor pour laquelle trouver la fraction correspondante.\n\n    Retourne:\n    - str: Une représentation sous forme de chaîne de la fraction à la position N dans la table de Cantor.\n    \"\"\"", "de": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Bestimmt den Zähler und Nenner des N-ten Terms in der Cantor-Tabelle.\n\n    Argumente:\n    - N (int): Die Position in der Cantor-Tabelle, für die der entsprechende Bruch gefunden werden soll.\n\n    Rückgabe:\n    - str: Eine Zeichenfolgenrepräsentation des Bruchs an der N-ten Position in der Cantor-Tabelle.\n    \"\"\"", "ha": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Tabbatar da mai ƙididdigewa da kuma mai rarrabawa na juzu'i na N-na a cikin teburin Cantor.\n\n    Args:\n    - N (int): Matsayi a cikin teburin Cantor don nemo juzu'i daidai da shi.\n\n    Returns:\n    - str: Wakilcin juzu'i a matsayin kirtani a matsayi na N a cikin teburin Cantor.\n    \"\"\"", "hi": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Cantor तालिका में N-वें पद का अंश और हर का निर्धारण करता है।\n\n    तर्क:\n    - N (int): Cantor तालिका में वह स्थिति जिसके लिए संबंधित भिन्न को खोजा जाना है।\n\n    वापसी:\n    - str: Cantor तालिका में N-वें स्थान पर भिन्न का स्ट्रिंग प्रतिनिधित्व।\n    \"\"\"", "hu": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Meghatározza az N-edik elem számlálóját és nevezőjét a Cantor-táblázatban.\n\n    Args:\n    - N (int): A Cantor-táblázatban lévő pozíció, amelyhez a megfelelő törtet meg kell találni.\n\n    Returns:\n    - str: A Cantor-táblázat N-edik pozícióján lévő tört szöveges ábrázolása.\n    \"\"\"", "es": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determina el numerador y el denominador del término N-ésimo en la tabla de Cantor.\n\n    Argumentos:\n    - N (int): La posición en la tabla de Cantor para encontrar la fracción correspondiente.\n\n    Devuelve:\n    - str: Una representación en cadena de la fracción en la posición N-ésima en la tabla de Cantor.\n    \"\"\"", "arb": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    يحدد البسط والمقام للعنصر N في جدول كانتور.\n\n    يعيدالحجج:\n    - N (int): الموضع في جدول كانتور للعثور على الكسر المقابل له.\n\n    يعيد:\n    - str: تمثيل نصي للكسر في الموضع N في جدول كانتور.\n    \"\"\"", "sw": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Huamua kianzilishi na kipeuo cha neno la N katika jedwali la Cantor.\n\n    Hoja:\n    - N (int): Nafasi katika jedwali la Cantor kupata sehemu inayolingana nayo.\n\n    Inarejesha:\n    - str: Uwakilishi wa herufi wa sehemu katika nafasi ya N katika jedwali la Cantor.\n    \"\"\"", "tr": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Cantor tablosundaki N-inci terimin pay ve paydasını belirler.\n\n    Argümanlar:\n    - N (int): Cantor tablosundaki karşılık gelen kesiri bulmak için pozisyon.\n\n    Döndürür:\n    - str: Cantor tablosundaki N-inci pozisyondaki kesirin string gösterimi.\n    \"\"\"", "vi": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Xác định tử số và mẫu số của số hạng thứ N trong bảng Cantor.\n\n    Tham số:\n    - N (int): Vị trí trong bảng Cantor để tìm phân số tương ứng.\n\n    Trả về:\n    - str: Một chuỗi biểu diễn phân số tại vị trí thứ N trong bảng Cantor.\n    \"\"\"", "id": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Menentukan pembilang dan penyebut dari suku ke-N dalam tabel Cantor.\n\n    Argumen:\n    - N (int): Posisi dalam tabel Cantor untuk menemukan pecahan yang sesuai.\n\n    Mengembalikan:\n    - str: Representasi string dari pecahan pada posisi ke-N dalam tabel Cantor.\n    \"\"\"", "ja": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    カントール表のN番目の項の分子と分母を決定します。\n\n    引数:\n    - N (int): 対応する分数を見つけるためのカントール表の位置。\n\n    戻り値:\n    - str: カントール表のN番目の位置にある分数の文字列表現。\n    \"\"\"", "ko": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Cantor 테이블의 N번째 항의 분자와 분모를 결정합니다.\n\n    인수:\n    - N (int): 해당 분수를 찾기 위한 Cantor 테이블의 위치.\n\n    반환:\n    - str: Cantor 테이블의 N번째 위치에 있는 분수의 문자열 표현.\n    \"\"\"", "ml": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    കാന്റർ പട്ടികയിലെ N-ാം പദത്തിന്റെ ന്യുമറേറ്ററും ഡിനോമിനേറ്ററും നിർണയിക്കുന്നു.\n\n    Args:\n    - N (int): കാന്റർ പട്ടികയിലെ സ്ഥാനത്തെ കണ്ടെത്താൻ അനുബന്ധ ഭിന്നം.\n\n    Returns:\n    - str: കാന്റർ പട്ടികയിലെ N-ാം സ്ഥാനത്തെ ഭിന്നത്തിന്റെ ഒരു സ്ട്രിംഗ് പ്രതിനിധാനം.\n    \"\"\"", "fa": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    صورت و مخرج جمله N-ام در جدول کانتور را تعیین می‌کند.\n\n    آرگومان‌ها:\n    - N (int): موقعیت در جدول کانتور که باید کسر متناظر با آن پیدا شود.\n\n    بازگشت:\n    - str: یک نمایش رشته‌ای از کسر در موقعیت N-ام در جدول کانتور.\n    \"\"\""}, "canonical_solution": "    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"", "instruction": {"en": "Write a python function 'def cantor_numbering(N: int) -> str:' to solve the following problem:\n\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    ", "sq": "Shkruani një funksion python 'def cantor_numbering(N: int) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Përcakton numëruesin dhe emëruesin e termit të N-të në tabelën e Cantor-it.\n\n    Argumentet:\n    - N (int): Pozicioni në tabelën e Cantor-it për të gjetur thyesën përkatëse.\n\n    Kthen:\n    - str: Një përfaqësim me varg i thyesës në pozicionin e N-të në tabelën e Cantor-it.", "hy": "Պայթոն ֆունկցիա 'def cantor_numbering(N: int) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Սահմանում է Cantor աղյուսակի N-րդ անդամի համարիչը և հայտարարը։\n\n    Արձագանքներ:\n    - N (int): Cantor աղյուսակում դիրքը, որի համար պետք է գտնել համապատասխան կոտորակը։\n\n    Վերադարձնում է:\n    - str: Տողային ներկայացում Cantor աղյուսակի N-րդ դիրքի կոտորակի համար։", "bn": "একটি পাইথন ফাংশন 'def cantor_numbering(N: int) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    ক্যান্টর টেবিলের N-তম পদটির লব এবং হর নির্ধারণ করে।\n\n    আর্গুমেন্ট:\n    - N (int): ক্যান্টর টেবিলে অবস্থান, যার জন্য সংশ্লিষ্ট ভগ্নাংশ খুঁজে বের করতে হবে।\n\n    রিটার্নস:\n    - str: ক্যান্টর টেবিলের N-তম অবস্থানে ভগ্নাংশের একটি স্ট্রিং উপস্থাপনা।", "bg": "Напишете функция на Python 'def cantor_numbering(N: int) -> str:' за да решите следния проблем:\n\n    Определя числителя и знаменателя на N-тия член в таблицата на Кантор.\n\n    Аргументи:\n    - N (int): Позицията в таблицата на Кантор, за която да се намери съответната дроб.\n\n    Връща:\n    - str: Стрингова репрезентация на дробта на N-тата позиция в таблицата на Кантор.", "zh": "编写一个 python 函数 'def cantor_numbering(N: int) -> str:' 来解决以下问题：\n\n    确定 Cantor 表中第 N 项的分子和分母。\n\n    参数:\n    - N (int): Cantor 表中要查找对应分数的位置。\n\n    返回:\n    - str: Cantor 表中第 N 位置的分数的字符串表示。", "fr": "Écrivez une fonction python 'def cantor_numbering(N: int) -> str:' pour résoudre le problème suivant :\n\n    Détermine le numérateur et le dénominateur du N-ième terme dans la table de Cantor.\n\n    Args:\n    - N (int): La position dans la table de Cantor pour laquelle trouver la fraction correspondante.\n\n    Retourne:\n    - str: Une représentation sous forme de chaîne de la fraction à la position N dans la table de Cantor.", "de": "Schreiben Sie eine Python-Funktion 'def cantor_numbering(N: int) -> str:', um das folgende Problem zu lösen:\n\n    Bestimmt den Zähler und Nenner des N-ten Terms in der Cantor-Tabelle.\n\n    Argumente:\n    - N (int): Die Position in der Cantor-Tabelle, um den entsprechenden Bruch zu finden.\n\n    Rückgaben:\n    - str: Eine Zeichenketten-Darstellung des Bruchs an der N-ten Position in der Cantor-Tabelle.", "ha": "Rubuta wani aikin python 'def cantor_numbering(N: int) -> str:' don warware matsalar mai zuwa:\n\n    Yana tantance mai lamba da mai kasa na sharadi na N a cikin teburin Cantor.\n\n    Args:\n    - N (int): Matsayin a cikin teburin Cantor don nemo rabon da ya dace.\n\n    Returns:\n    - str: Wakilcin kirtani na rabon a matsayi na N a cikin teburin Cantor.", "hi": "एक पायथन फ़ंक्शन 'def cantor_numbering(N: int) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    कैंटर तालिका में N-वें पद के अंश और हर का निर्धारण करता है।\n\n    तर्क:\n    - N (int): कैंटर तालिका में वह स्थिति जिसके लिए संबंधित भिन्न खोजनी है।\n\n    लौटाता है:\n    - str: कैंटर तालिका में N-वें स्थिति पर भिन्न का स्ट्रिंग प्रतिनिधित्व।", "hu": "Írj egy Python függvényt 'def cantor_numbering(N: int) -> str:' a következő probléma megoldására:\n\n    Meghatározza az N-edik tétel számlálóját és nevezőjét a Cantor táblázatban.\n\n    Argumentumok:\n    - N (int): A pozíció a Cantor táblázatban, amelyhez meg kell találni a megfelelő törtet.\n\n    Visszatér:\n    - str: A tört szöveges ábrázolása az N-edik pozíción a Cantor táblázatban.", "es": "Escribe una función en Python 'def cantor_numbering(N: int) -> str:' para resolver el siguiente problema:\n\n    Determina el numerador y el denominador del término N-ésimo en la tabla de Cantor.\n\n    Argumentos:\n    - N (int): La posición en la tabla de Cantor para encontrar la fracción correspondiente.\n\n    Devuelve:\n    - str: Una representación en cadena de la fracción en la posición N-ésima en la tabla de Cantor.", "arb": "اكتب دالة بايثون 'def cantor_numbering(N: int) -> str:' لحل المشكلة التالية:\n\n    تحديد البسط والمقام للعنصر N في جدول كانتور.\n\n    يعيدالحجج:\n    - N (int): الموضع في جدول كانتور للعثور على الكسر المقابل له.\n\n    يعيد:\n    - str: تمثيل نصي للكسر في الموضع N في جدول كانتور.", "sw": "Andika kazi ya python 'def cantor_numbering(N: int) -> str:' kutatua tatizo lifuatalo:\n\n    Huamua numerator na denominator ya neno la N katika jedwali la Cantor.\n\n    Hoja:\n    - N (int): Nafasi katika jedwali la Cantor kupata sehemu inayolingana nayo.\n\n    Inarejesha:\n    - str: Uwakilishi wa kamba wa sehemu katika nafasi ya N katika jedwali la Cantor.", "tr": "Bir python fonksiyonu 'def cantor_numbering(N: int) -> str:' yazın:\n\n    Cantor tablosundaki N. terimin pay ve paydasını belirler.\n\n    Argümanlar:\n    - N (int): Cantor tablosundaki ilgili kesiri bulmak için pozisyon.\n\n    Döndürür:\n    - str: Cantor tablosundaki N. pozisyondaki kesirin string gösterimi.", "vi": "Viết một hàm python 'def cantor_numbering(N: int) -> str:' để giải quyết vấn đề sau:\n\n    Xác định tử số và mẫu số của số hạng thứ N trong bảng Cantor.\n\n    Tham số:\n    - N (int): Vị trí trong bảng Cantor để tìm phân số tương ứng.\n\n    Trả về:\n    - str: Một chuỗi biểu diễn phân số tại vị trí thứ N trong bảng Cantor.", "id": "Tulis fungsi python 'def cantor_numbering(N: int) -> str:' untuk menyelesaikan masalah berikut:\n\n    Menentukan pembilang dan penyebut dari suku ke-N dalam tabel Cantor.\n\n    Argumen:\n    - N (int): Posisi dalam tabel Cantor untuk menemukan pecahan yang sesuai.\n\n    Mengembalikan:\n    - str: Representasi string dari pecahan pada posisi ke-N dalam tabel Cantor.", "ja": "次の問題を解くためのPython関数 'def cantor_numbering(N: int) -> str:' を作成してください。\n\n    カントール表のN番目の項の分子と分母を決定します。\n\n    引数:\n    - N (int): カントール表で対応する分数を見つける位置。\n\n    戻り値:\n    - str: カントール表のN番目の位置にある分数の文字列表現。", "ko": "다음 문제를 해결하기 위해 파이썬 함수를 작성하세요 'def cantor_numbering(N: int) -> str:':\n\n    N번째 칸토어 테이블 항의 분자와 분모를 결정합니다.\n\n    인수:\n    - N (int): 해당 분수를 찾기 위한 칸토어 테이블의 위치.\n\n    반환:\n    - str: 칸토어 테이블의 N번째 위치에 있는 분수의 문자열 표현.", "ml": "ഒരു പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക 'def cantor_numbering(N: int) -> str:' താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    Cantor പട്ടികയിലെ N-ാം പദത്തിന്റെ ലഘുവും ഹരവും നിശ്ചയിക്കുന്നു.\n\n    Args:\n    - N (int): Cantor പട്ടികയിലെ സ്ഥാനം, അതിന് അനുയോജ്യമായ ഭിന്നം കണ്ടെത്താൻ.\n\n    Returns:\n    - str: Cantor പട്ടികയിലെ N-ാം സ്ഥാനത്തെ ഭിന്നത്തിന്റെ ഒരു സ്ട്രിംഗ് പ്രതിനിധാനം.", "fa": "یک تابع پایتون 'def cantor_numbering(N: int) -> str:' بنویسید تا مسئله زیر را حل کند:\n\n    صورت و مخرج جمله Nام در جدول کانتور را تعیین می‌کند.\n\n    آرگومان‌ها:\n    - N (int): موقعیت در جدول کانتور برای یافتن کسر مربوطه.\n\n    بازگشت:\n    - str: یک نمایش رشته‌ای از کسر در موقعیت Nام در جدول کانتور."}, "level": "easy", "test": "def test_cantor_numbering():\n    # Test case 1: N = 1, the first element, should be \"1/1\"\n    assert cantor_numbering(1)==\"1/1\"\n\n    # Test case 2: N = 2, the second element, should be \"1/2\"\n    assert cantor_numbering(2)==\"1/2\"\n\n    # Test case 3: N = 6, the sixth element, should be \"1/3\"\n    assert cantor_numbering(6)==\"1/3\"\n\n    # Corrected test case: N = 7, the seventh element, should be \"1/4\"\n    assert cantor_numbering(7) == \"1/4\"\n\n    # Additional test case: N = 8, the eighth element, should be \"2/3\"\n    assert cantor_numbering(8) == \"2/3\"\n\n\ntest_cantor_numbering()", "entry_point": "cantor_numbering", "signature": "def cantor_numbering(N: int) -> str:", "docstring": {"en": "\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    ", "sq": "\n    Përcakton numëruesin dhe emëruesin e termit të N-të në tabelën e Cantor-it.\n\n    Argumentet:\n    - N (int): Pozicioni në tabelën e Cantor-it për të gjetur fraksionin përkatës.\n\n    Kthen:\n    - str: Një përfaqësim në formë vargu i fraksionit në pozicionin e N-të në tabelën e Cantor-it.", "hy": "\n    Որոշում է Կանտորի աղյուսակի N-րդ անդամի համարիչը և հայտարարիչը։\n\n    Արգումենտներ:\n    - N (int): Դիրքը Կանտորի աղյուսակում, որի համար պետք է գտնել համապատասխան կոտորակը։\n\n    Վերադարձնում է:\n    - str: Կանտորի աղյուսակի N-րդ դիրքում գտնվող կոտորակի տողային ներկայացումը։", "bn": "\n    ক্যান্টর টেবিলের N-তম পদের লব এবং হর নির্ধারণ করে।\n\n    আর্গুমেন্টসমূহ:\n    - N (int): ক্যান্টর টেবিলে যে অবস্থানের জন্য সংশ্লিষ্ট ভগ্নাংশ খুঁজে বের করতে হবে।\n\n    রিটার্ন:\n    - str: ক্যান্টর টেবিলের N-তম অবস্থানে থাকা ভগ্নাংশের একটি স্ট্রিং উপস্থাপনা।", "bg": "\n    Определя числителя и знаменателя на N-тия член в таблицата на Кантор.\n\n    Аргументи:\n    - N (int): Позицията в таблицата на Кантор, за която да се намери съответната дроб.\n\n    Връща:\n    - str: Стринг представяне на дробта на N-тата позиция в таблицата на Кантор.", "zh": "\n    确定康托表中第 N 项的分子和分母。\n\n    参数:\n    - N (int): 康托表中要查找对应分数的位置。\n\n    返回:\n    - str: 康托表中第 N 个位置的分数的字符串表示。", "fr": "\n    Détermine le numérateur et le dénominateur du N-ième terme dans la table de Cantor.\n\n    Args:\n    - N (int): La position dans la table de Cantor pour laquelle trouver la fraction correspondante.\n\n    Returns:\n    - str: Une représentation sous forme de chaîne de la fraction à la position N dans la table de Cantor.", "de": "\n    Bestimmt den Zähler und Nenner des N-ten Terms in der Cantor-Tabelle.\n\n    Argumente:\n    - N (int): Die Position in der Cantor-Tabelle, für die der entsprechende Bruch gefunden werden soll.\n\n    Rückgabe:\n    - str: Eine Zeichenketten-Darstellung des Bruchs an der N-ten Position in der Cantor-Tabelle.", "ha": "\n    Yana tantance mai lamba da mai kasa na sharadi na N a cikin teburin Cantor.\n\n    Args:\n    - N (int): Matsayin a cikin teburin Cantor don nemo rabon da ya dace.\n\n    Returns:\n    - str: Wakilcin kirtani na rabon a matsayi na N a cikin teburin Cantor.", "hi": "\n    कैन्टर तालिका में N-वें पद का अंश और हर का निर्धारण करता है।\n\n    तर्क:\n    - N (int): कैन्टर तालिका में स्थिति जिसके लिए संबंधित भिन्न को खोजना है।\n\n    लौटाता है:\n    - str: कैन्टर तालिका में N-वें स्थान पर भिन्न का स्ट्रिंग प्रतिनिधित्व।", "hu": "\n    Meghatározza a Cantor-táblázat N-edik elemének számlálóját és nevezőjét.\n\n    Paraméterek:\n    - N (int): A Cantor-táblázatban lévő pozíció, amelyhez a megfelelő törtet meg kell találni.\n\n    Visszatér:\n    - str: A Cantor-táblázat N-edik pozícióján lévő tört szöveges ábrázolása.", "es": "\n    Determina el numerador y el denominador del término N-ésimo en la tabla de Cantor.\n\nArgumentos:\n- N (int): La posición en la tabla de Cantor para encontrar la fracción correspondiente.\n\nDevuelve:\n- str: Una representación en cadena de la fracción en la posición N-ésima en la tabla de Cantor.", "arb": "\n    يحدد البسط والمقام للحد N في جدول كانتور.\n\n    يعيدالحجج:\n    - N (int): الموضع في جدول كانتور للعثور على الكسر المقابل له.\n\n    يعيد:\n    - str: تمثيل نصي للكسر في الموضع N في جدول كانتور.", "sw": "\n    Huamua kigezo na kipatanishi cha neno la N katika jedwali la Cantor.\n\n    Hoja:\n    - N (int): Nafasi katika jedwali la Cantor kupata sehemu inayolingana.\n\n    Inarejesha:\n    - str: Uwakilishi wa kamba ya sehemu katika nafasi ya N katika jedwali la Cantor.", "tr": "\n    Cantor tablosundaki N. terimin pay ve paydasını belirler.\n\n    Argümanlar:\n    - N (int): Cantor tablosundaki karşılık gelen kesiri bulmak için pozisyon.\n\n    Döndürür:\n    - str: Cantor tablosundaki N. pozisyondaki kesirin string gösterimi.", "vi": "\n    Xác định tử số và mẫu số của số hạng thứ N trong bảng Cantor.\n\n    Tham số:\n    - N (int): Vị trí trong bảng Cantor để tìm phân số tương ứng.\n\n    Trả về:\n    - str: Một chuỗi đại diện cho phân số tại vị trí thứ N trong bảng Cantor.", "id": "Menentukan pembilang dan penyebut dari suku ke-N dalam tabel Cantor.\n\nArgs:\n- N (int): Posisi dalam tabel Cantor untuk menemukan pecahan yang sesuai.\n\nReturns:\n- str: Representasi string dari pecahan pada posisi ke-N dalam tabel Cantor.", "ja": "    カントール表のN番目の項の分子と分母を決定します。\n\n    引数:\n    - N (int): カントール表で対応する分数を見つけるための位置。\n\n    戻り値:\n    - str: カントール表のN番目の位置にある分数の文字列表現。", "ko": "N번째 칸토어 테이블 항의 분자와 분모를 결정합니다.\n\nArgs:\n- N (int): 칸토어 테이블에서 해당 분수를 찾을 위치입니다.\n\nReturns:\n- str: 칸토어 테이블의 N번째 위치에 있는 분수의 문자열 표현입니다.", "ml": "    കാന്റർ പട്ടികയിലെ N-ാം പദത്തിലെ ലബ്ധവും ഹരവും നിർണ്ണയിക്കുന്നു.\n\n    Arguments:\n    - N (int): കാന്റർ പട്ടികയിലെ സ്ഥാനത്തെ കണ്ടെത്താൻ ആവശ്യമായ പദം.\n\n    Returns:\n    - str: കാന്റർ പട്ടികയിലെ N-ാം സ്ഥാനത്തെ ലബ്ധത്തിന്റെ ഒരു സ്ട്രിംഗ് പ്രതിനിധാനം.", "fa": "    صورت و مخرج جمله Nام در جدول کانتور را تعیین می‌کند.\n\n    آرگومان‌ها:\n    - N (int): موقعیت در جدول کانتور برای یافتن کسر مربوطه.\n\n    بازگشت:\n    - str: یک نمایش رشته‌ای از کسر در موقعیت Nام در جدول کانتور."}}
{"task_id": "Python/12", "prompt": {"en": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    \"\"\"", "sq": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Emri i funksionit: max_product\n    Argumentet:\n    num_str (str): Një varg që përfaqëson vargun e numrave.\n    N (int): Një numër i plotë që përfaqëson gjatësinë e vargut të numrave.\n    K (int): Një numër i plotë që përfaqëson numrin e shenjave të shumëzimit për t'u futur.\n    Lloji i kthimit: int (Funksioni kthen produktin maksimal që mund të merret duke futur K shenja të shumëzimit në vargun e numrave.)\n    \"\"\"", "hy": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Ֆունկցիայի անունը: max_product\n    Արգումենտներ:\n    num_str (str): Տող, որը ներկայացնում է թվային տողը։\n    N (int): Թվային տողի երկարությունը ներկայացնող ամբողջ թիվ։\n    K (int): Ամբողջ թիվ, որը ներկայացնում է տեղադրելու բազմապատկման նշանների քանակը։\n    Վերադարձի տիպը: int (Ֆունկցիան վերադարձնում է առավելագույն արտադրյալը, որը կարելի է ստանալ թվային տողի մեջ K բազմապատկման նշաններ տեղադրելով։)\n    \"\"\"", "bn": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    ফাংশনের নাম: max_product\n    আর্গুমেন্টসমূহ:\n    num_str (str): একটি স্ট্রিং যা সংখ্যা স্ট্রিংকে উপস্থাপন করে।\n    N (int): একটি পূর্ণসংখ্যা যা সংখ্যা স্ট্রিংয়ের দৈর্ঘ্যকে উপস্থাপন করে।\n    K (int): একটি পূর্ণসংখ্যা যা প্রবেশ করানোর জন্য গুণচিহ্নের সংখ্যা উপস্থাপন করে।\n    রিটার্ন টাইপ: int (ফাংশনটি সংখ্যার স্ট্রিংয়ে Kটি গুণচিহ্ন প্রবেশ করিয়ে প্রাপ্ত সর্বাধিক গুণফল রিটার্ন করে।)\n    \"\"\"", "bg": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Име на функция: max_product\n    Аргументи:\n    num_str (str): Низ, представляващ числовия низ.\n    N (int): Цяло число, представляващо дължината на числовия низ.\n    K (int): Цяло число, представляващо броя на знаците за умножение, които да се вмъкнат.\n    Тип на връщане: int (Функцията връща максималния произведение, което може да се получи чрез вмъкване на K знаци за умножение в числовия низ.)\n    \"\"\"", "zh": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    函数名称: max_product\n    参数:\n    num_str (str): 表示数字字符串的字符串。\n    N (int): 表示数字字符串长度的整数。\n    K (int): 表示要插入的乘号数量的整数。\n    返回类型: int (该函数返回通过在数字字符串中插入K个乘号可以获得的最大乘积。)\n    \"\"\"", "fr": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Nom de la fonction : max_product\n    Arguments :\n    num_str (str) : Une chaîne représentant le nombre sous forme de chaîne.\n    N (int) : Un entier représentant la longueur de la chaîne de nombres.\n    K (int) : Un entier représentant le nombre de signes de multiplication à insérer.\n    Type de retour : int (La fonction renvoie le produit maximum pouvant être obtenu en insérant K signes de multiplication dans la chaîne de nombres.)\n    \"\"\"", "de": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Funktionsname: max_product\n    Argumente:\n    num_str (str): Ein String, der die Zahlenfolge darstellt.\n    N (int): Ein Integer, der die Länge der Zahlenfolge darstellt.\n    K (int): Ein Integer, der die Anzahl der einzufügenden Multiplikationszeichen darstellt.\n    Rückgabetyp: int (Die Funktion gibt das maximale Produkt zurück, das durch das Einfügen von K Multiplikationszeichen in die Zahlenfolge erzielt werden kann.)\n    \"\"\"", "ha": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Sunan aiki: max_product\n    Huɗɗa:\n    num_str (str): Wani kirtani da ke wakiltar lambar kirtani.\n    N (int): Wani cikakken lamba da ke wakiltar tsawon lambar kirtani.\n    K (int): Wani cikakken lamba da ke wakiltar yawan alamar ninkawa da za a saka.\n    Nau'in dawowa: int (Aikin yana dawowa da mafi girman samfurin da za a iya samu ta hanyar saka K alamomin ninkawa cikin lambar kirtani.)\n    \"\"\"", "hi": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    फ़ंक्शन का नाम: max_product\n    तर्क:\n    num_str (str): संख्या स्ट्रिंग का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    N (int): संख्या स्ट्रिंग की लंबाई का प्रतिनिधित्व करने वाला एक पूर्णांक।\n    K (int): गुणा चिह्नों की संख्या डालने का प्रतिनिधित्व करने वाला एक पूर्णांक।\n    वापसी प्रकार: int (यह फ़ंक्शन अधिकतम उत्पाद लौटाता है जो संख्या स्ट्रिंग में K गुणा चिह्न डालकर प्राप्त किया जा सकता है।)\n    \"\"\"", "hu": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Függvény neve: max_product\n    Argumentumok:\n    num_str (str): Egy karakterlánc, amely a számkarakterláncot képviseli.\n    N (int): Egy egész szám, amely a számkarakterlánc hosszát jelenti.\n    K (int): Egy egész szám, amely a beszúrandó szorzásjelek számát jelenti.\n    Visszatérési típus: int (A függvény visszaadja a maximális szorzatot, amelyet a K szorzásjel beszúrásával lehet elérni a számkarakterláncba.)\n    \"\"\"", "es": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Nombre de la función: max_product\n    Argumentos:\n    num_str (str): Una cadena que representa la cadena de números.\n    N (int): Un entero que representa la longitud de la cadena de números.\n    K (int): Un entero que representa el número de signos de multiplicación a insertar.\n    Tipo de retorno: int (La función devuelve el producto máximo que se puede obtener insertando K signos de multiplicación en la cadena de números.)\n    \"\"\"", "arb": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    اسم الدالة: max_product\n    الوسائط:\n    num_str (str): سلسلة تمثل سلسلة الأرقام.\n    N (int): عدد صحيح يمثل طول سلسلة الأرقام.\n    K (int): عدد صحيح يمثل عدد علامات الضرب المراد إدراجها.\n    نوع الإرجاع: int (تُرجع الدالة أكبر حاصل يمكن الحصول عليه عن طريق إدراج K علامات ضرب في سلسلة الأرقام.)\n    \"\"\"", "sw": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Jina la kazi: max_product\n    Hoja:\n    num_str (str): Mstari wa herufi unaowakilisha mstari wa nambari.\n    N (int): Nambari kamili inayowakilisha urefu wa mstari wa nambari.\n    K (int): Nambari kamili inayowakilisha idadi ya alama za kuzidisha za kuingiza.\n    Aina ya kurudi: int (Kazi inarudisha bidhaa ya juu zaidi inayoweza kupatikana kwa kuingiza alama za kuzidisha K kwenye mstari wa nambari.)\n    \"\"\"", "tr": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Fonksiyon adı: max_product\n    Argümanlar:\n    num_str (str): Sayı dizisini temsil eden bir string.\n    N (int): Sayı dizisinin uzunluğunu temsil eden bir tamsayı.\n    K (int): Eklenecek çarpma işareti sayısını temsil eden bir tamsayı.\n    Dönüş tipi: int (Fonksiyon, sayı dizisine K çarpma işareti ekleyerek elde edilebilecek maksimum çarpımı döndürür.)\n    \"\"\"", "vi": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Tên hàm: max_product\n    Tham số:\n    num_str (str): Một chuỗi đại diện cho chuỗi số.\n    N (int): Một số nguyên đại diện cho độ dài của chuỗi số.\n    K (int): Một số nguyên đại diện cho số dấu nhân cần chèn vào.\n    Kiểu trả về: int (Hàm trả về tích lớn nhất có thể đạt được bằng cách chèn K dấu nhân vào chuỗi số.)\n    \"\"\"", "id": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Nama fungsi: max_product\n    Argumen:\n    num_str (str): Sebuah string yang mewakili string angka.\n    N (int): Sebuah bilangan bulat yang mewakili panjang dari string angka.\n    K (int): Sebuah bilangan bulat yang mewakili jumlah tanda perkalian yang akan dimasukkan.\n    Jenis pengembalian: int (Fungsi mengembalikan hasil perkalian maksimum yang dapat diperoleh dengan memasukkan K tanda perkalian ke dalam string angka.)\n    \"\"\"", "ja": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    関数名: max_product\n    引数:\n    num_str (str): 数字列を表す文字列。\n    N (int): 数字列の長さを表す整数。\n    K (int): 挿入する掛け算記号の数を表す整数。\n    戻り値の型: int (関数は、数字列にK個の掛け算記号を挿入することで得られる最大の積を返します。)\n    \"\"\"", "ko": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    함수 이름: max_product\n    인수:\n    num_str (str): 숫자 문자열을 나타내는 문자열.\n    N (int): 숫자 문자열의 길이를 나타내는 정수.\n    K (int): 삽입할 곱셈 기호의 수를 나타내는 정수.\n    반환 유형: int (이 함수는 숫자 문자열에 K개의 곱셈 기호를 삽입하여 얻을 수 있는 최대 곱을 반환합니다.)\n    \"\"\"", "ml": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    ഫങ്ഷൻ നാമം: max_product\n    ആഗ്യുമെന്റുകൾ:\n    num_str (str): നമ്പർ സ്ട്രിംഗ് പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    N (int): നമ്പർ സ്ട്രിംഗിന്റെ നീളം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n    K (int): ഗുണന ചിഹ്നങ്ങൾ ചേർക്കാനുള്ള പൂർണ്ണസംഖ്യ.\n    റിട്ടേൺ തരം: int (നമ്പർ സ്ട്രിംഗിൽ K ഗുണന ചിഹ്നങ്ങൾ ചേർത്തു കൊണ്ട് ലഭിക്കാവുന്ന പരമാവധി ഗുണഫലം ഫങ്ഷൻ തിരികെ നൽകുന്നു.)\n    \"\"\"", "fa": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    نام تابع: max_product\n    آرگومان‌ها:\n    num_str (str): یک رشته که رشته عددی را نشان می‌دهد.\n    N (int): یک عدد صحیح که طول رشته عددی را نشان می‌دهد.\n    K (int): یک عدد صحیح که تعداد علائم ضربی که باید درج شود را نشان می‌دهد.\n    نوع بازگشتی: int (تابع حداکثر حاصل‌ضربی که می‌توان با درج K علامت ضرب در رشته عددی به دست آورد را برمی‌گرداند.)\n    \"\"\""}, "canonical_solution": "    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]", "instruction": {"en": "Write a python function 'def max_product(num_str: str, N: int, K: int) -> int:' to solve the following problem:\n\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    ", "sq": "Shkruani një funksion python 'def max_product(num_str: str, N: int, K: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Emri i funksionit: max_product\n    Argumentet:\n    num_str (str): Një varg që përfaqëson vargun e numrave.\n    N (int): Një numër i plotë që përfaqëson gjatësinë e vargut të numrave.\n    K (int): Një numër i plotë që përfaqëson numrin e shenjave të shumëzimit për të futur.\n    Lloji i kthimit: int (Funksioni kthen produktin maksimal që mund të merret duke futur K shenja shumëzimi në vargun e numrave.)", "hy": "Պայթոն ֆունկցիա 'def max_product(num_str: str, N: int, K: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Ֆունկցիայի անունը: max_product\n    Արգումենտներ:\n    num_str (str): Թվային տողը ներկայացնող տող:\n    N (int): Թվային տողի երկարությունը ներկայացնող ամբողջ թիվ:\n    K (int): Մուտքագրելու բազմապատկման նշանների քանակը ներկայացնող ամբողջ թիվ:\n    Վերադարձի տիպը: int (Ֆունկցիան վերադարձնում է առավելագույն արդյունքը, որը կարող է ստացվել թվային տողի մեջ K բազմապատկման նշաններ մուտքագրելով:)", "bn": "একটি পাইথন ফাংশন 'def max_product(num_str: str, N: int, K: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    ফাংশনের নাম: max_product\n    আর্গুমেন্টস:\n    num_str (str): একটি স্ট্রিং যা সংখ্যার স্ট্রিংকে উপস্থাপন করে।\n    N (int): একটি পূর্ণসংখ্যা যা সংখ্যার স্ট্রিংয়ের দৈর্ঘ্য উপস্থাপন করে।\n    K (int): একটি পূর্ণসংখ্যা যা প্রবেশ করানোর জন্য গুণের চিহ্নের সংখ্যা উপস্থাপন করে।\n    রিটার্ন টাইপ: int (ফাংশনটি সংখ্যার স্ট্রিংয়ে K গুণের চিহ্ন প্রবেশ করিয়ে প্রাপ্ত সর্বাধিক গুণফল রিটার্ন করে।)", "bg": "Напишете Python функция 'def max_product(num_str: str, N: int, K: int) -> int:' за да решите следния проблем:\n\n    Име на функцията: max_product\n    Аргументи:\n    num_str (str): Низ, представляващ числовия низ.\n    N (int): Цяло число, представляващо дължината на числовия низ.\n    K (int): Цяло число, представляващо броя на знаците за умножение, които да се вмъкнат.\n    Тип на връщане: int (Функцията връща максималния продукт, който може да бъде получен чрез вмъкване на K знака за умножение в числовия низ.)", "zh": "编写一个Python函数 'def max_product(num_str: str, N: int, K: int) -> int:' 来解决以下问题:\n\n    函数名称: max_product\n    参数:\n    num_str (str): 表示数字字符串的字符串。\n    N (int): 表示数字字符串长度的整数。\n    K (int): 表示要插入的乘号数量的整数。\n    返回类型: int (函数返回通过在数字字符串中插入K个乘号可以获得的最大乘积。)", "fr": "Écrivez une fonction python 'def max_product(num_str: str, N: int, K: int) -> int:' pour résoudre le problème suivant :\n\n    Nom de la fonction : max_product\n    Arguments :\n    num_str (str) : Une chaîne représentant la chaîne de chiffres.\n    N (int) : Un entier représentant la longueur de la chaîne de chiffres.\n    K (int) : Un entier représentant le nombre de signes de multiplication à insérer.\n    Type de retour : int (La fonction retourne le produit maximum qui peut être obtenu en insérant K signes de multiplication dans la chaîne de chiffres.)", "de": "Schreiben Sie eine Python-Funktion 'def max_product(num_str: str, N: int, K: int) -> int:' um das folgende Problem zu lösen:\n\n    Funktionsname: max_product\n    Argumente:\n    num_str (str): Ein String, der die Zahlenfolge darstellt.\n    N (int): Eine ganze Zahl, die die Länge der Zahlenfolge darstellt.\n    K (int): Eine ganze Zahl, die die Anzahl der einzufügenden Multiplikationszeichen darstellt.\n    Rückgabetyp: int (Die Funktion gibt das maximale Produkt zurück, das durch Einfügen von K Multiplikationszeichen in die Zahlenfolge erzielt werden kann.)", "ha": "Rubuta wani aikin python 'def max_product(num_str: str, N: int, K: int) -> int:' don warware matsalar mai zuwa:\n\n    Sunan aiki: max_product\n    Hujojji:\n    num_str (str): Wani zare mai wakiltar zaren lamba.\n    N (int): Wani cikakken lamba mai wakiltar tsawon zaren lamba.\n    K (int): Wani cikakken lamba mai wakiltar adadin alamar ninkawa da za a saka.\n    Nau'in dawowa: int (Aikin yana dawowa da mafi girman samfurin da za a iya samu ta hanyar saka alamomin ninkawa K cikin zaren lamba.)", "hi": "एक पायथन फ़ंक्शन 'def max_product(num_str: str, N: int, K: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    फ़ंक्शन का नाम: max_product\n    तर्क:\n    num_str (str): एक स्ट्रिंग जो संख्या स्ट्रिंग का प्रतिनिधित्व करती है।\n    N (int): एक पूर्णांक जो संख्या स्ट्रिंग की लंबाई का प्रतिनिधित्व करता है।\n    K (int): एक पूर्णांक जो डालने के लिए गुणा चिह्नों की संख्या का प्रतिनिधित्व करता है।\n    लौटाने का प्रकार: int (फ़ंक्शन अधिकतम उत्पाद लौटाता है जो संख्या स्ट्रिंग में K गुणा चिह्न डालकर प्राप्त किया जा सकता है।)", "hu": "Írj egy python függvényt 'def max_product(num_str: str, N: int, K: int) -> int:' a következő probléma megoldására:\n\n    Függvény neve: max_product\n    Argumentumok:\n    num_str (str): Egy karakterlánc, amely a számkarakterláncot ábrázolja.\n    N (int): Egy egész szám, amely a számkarakterlánc hosszát jelöli.\n    K (int): Egy egész szám, amely a beszúrandó szorzásjelek számát jelöli.\n    Visszatérési típus: int (A függvény visszaadja a maximális szorzatot, amely elérhető a K szorzásjel beszúrásával a számkarakterláncba.)", "es": "Escribe una función de Python 'def max_product(num_str: str, N: int, K: int) -> int:' para resolver el siguiente problema:\n\n    Nombre de la función: max_product\n    Argumentos:\n    num_str (str): Una cadena que representa la cadena de números.\n    N (int): Un entero que representa la longitud de la cadena de números.\n    K (int): Un entero que representa el número de signos de multiplicación a insertar.\n    Tipo de retorno: int (La función devuelve el producto máximo que se puede obtener insertando K signos de multiplicación en la cadena de números.)", "arb": "اكتب دالة بايثون 'def max_product(num_str: str, N: int, K: int):' لحل المشكلة التالية:\n\n    اسم الدالة: max_product\n    الوسائط:\n    num_str (str): سلسلة تمثل سلسلة الأرقام.\n    N (int): عدد صحيح يمثل طول سلسلة الأرقام.\n    K (int): عدد صحيح يمثل عدد علامات الضرب التي سيتم إدراجها.\n    نوع القيمة المعادة: int (تعيد الدالة أكبر حاصل ضرب يمكن الحصول عليه بإدراج K علامات ضرب في سلسلة الأرقام.)", "sw": "Andika kazi ya python 'def max_product(num_str: str, N: int, K: int) -> int:' kutatua tatizo lifuatalo:\n\n    Jina la kazi: max_product\n    Hoja:\n    num_str (str): Mfuatano wa herufi unaowakilisha mfuatano wa nambari.\n    N (int): Nambari kamili inayowakilisha urefu wa mfuatano wa nambari.\n    K (int): Nambari kamili inayowakilisha idadi ya alama za kuzidisha za kuingiza.\n    Aina ya kurudi: int (Kazi inarudisha bidhaa ya juu zaidi inayoweza kupatikana kwa kuingiza alama za kuzidisha K kwenye mfuatano wa nambari.)", "tr": "Bir Python fonksiyonu 'def max_product(num_str: str, N: int, K: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Fonksiyon adı: max_product\n    Argümanlar:\n    num_str (str): Sayı dizgisini temsil eden bir dize.\n    N (int): Sayı dizgisinin uzunluğunu temsil eden bir tamsayı.\n    K (int): Eklenecek çarpma işaretlerinin sayısını temsil eden bir tamsayı.\n    Dönüş tipi: int (Fonksiyon, sayı dizisine K çarpma işareti ekleyerek elde edilebilecek maksimum çarpımı döndürür.)", "vi": "Viết một hàm python 'def max_product(num_str: str, N: int, K: int) -> int:' để giải quyết vấn đề sau:\n\n    Tên hàm: max_product\n    Tham số:\n    num_str (str): Một chuỗi đại diện cho chuỗi số.\n    N (int): Một số nguyên đại diện cho độ dài của chuỗi số.\n    K (int): Một số nguyên đại diện cho số dấu nhân cần chèn vào.\n    Kiểu trả về: int (Hàm trả về tích lớn nhất có thể đạt được bằng cách chèn K dấu nhân vào chuỗi số.)", "id": "Tulis fungsi python 'def max_product(num_str: str, N: int, K: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Nama fungsi: max_product\n    Argumen:\n    num_str (str): Sebuah string yang mewakili string angka.\n    N (int): Sebuah bilangan bulat yang mewakili panjang dari string angka.\n    K (int): Sebuah bilangan bulat yang mewakili jumlah tanda perkalian yang akan disisipkan.\n    Jenis pengembalian: int (Fungsi mengembalikan hasil perkalian maksimum yang dapat diperoleh dengan menyisipkan K tanda perkalian ke dalam string angka.)", "ja": "次の問題を解くためのPython関数 'def max_product(num_str: str, N: int, K: int) -> int:' を書いてください:\n\n    関数名: max_product\n    引数:\n    num_str (str): 数字列を表す文字列。\n    N (int): 数字列の長さを表す整数。\n    K (int): 挿入する掛け算記号の数を表す整数。\n    戻り値の型: int (関数は、数字列にK個の掛け算記号を挿入することで得られる最大の積を返します。)", "ko": "파이썬 함수를 작성하세요 'def max_product(num_str: str, N: int, K: int) -> int:' 다음 문제를 해결하기 위해:\n\n    함수 이름: max_product\n    인수:\n    num_str (str): 숫자 문자열을 나타내는 문자열.\n    N (int): 숫자 문자열의 길이를 나타내는 정수.\n    K (int): 곱셈 기호를 삽입할 횟수를 나타내는 정수.\n    반환 유형: int (함수는 숫자 문자열에 K개의 곱셈 기호를 삽입하여 얻을 수 있는 최대 곱을 반환합니다.)", "ml": "ഒരു പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക 'def max_product(num_str: str, N: int, K: int) -> int:' താഴെക്കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    ഫംഗ്ഷൻ നാമം: max_product\n    ആർഗ്യുമെന്റുകൾ:\n    num_str (str): സംഖ്യാ സ്ട്രിംഗ് പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    N (int): സംഖ്യാ സ്ട്രിംഗിന്റെ നീളം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n    K (int): ചേർക്കാനുള്ള ഗുണന ചിഹ്നങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n    റിട്ടേൺ തരം: int (സംഖ്യാ സ്ട്രിംഗിലേക്ക് K ഗുണന ചിഹ്നങ്ങൾ ചേർത്ത് നേടാവുന്ന പരമാവധി ഗുണഫലം ഫംഗ്ഷൻ തിരികെ നൽകുന്നു.)", "fa": "یک تابع پایتون بنویسید 'def max_product(num_str: str, N: int, K: int) -> int:' برای حل مسئله زیر:\n\n    نام تابع: max_product\n    آرگومان‌ها:\n    num_str (str): یک رشته که رشته عددی را نشان می‌دهد.\n    N (int): یک عدد صحیح که طول رشته عددی را نشان می‌دهد.\n    K (int): یک عدد صحیح که تعداد علامت‌های ضربی که باید وارد شوند را نشان می‌دهد.\n    نوع بازگشتی: int (تابع بیشترین حاصل‌ضرب که می‌توان با وارد کردن K علامت ضرب در رشته عددی به دست آورد را برمی‌گرداند.)"}, "level": "middle", "test": "def test_max_product():\n    # Test case 1\n    num_str1 = \"123\"\n    N1 = 3\n    K1 = 1\n    expected_result1 = 36  # Corrected expected result: 1*23 = 23 or 12*3 = 36, max is 36\n    assert max_product(num_str1, N1,\n                       K1) == expected_result1, f\"Test case 1 failed. Expected {expected_result1}, got {max_product(num_str1, N1, K1)}\"\n\n    # Test case 2\n    num_str2 = \"1234\"\n    N2 = 4\n    K2 = 2\n    expected_result2 = 144  # Corrected expected result: 1*2*34 = 68 or 12*3*4 = 144, max is 144\n    assert max_product(num_str2, N2,\n                       K2) == expected_result2, f\"Test case 2 failed. Expected {expected_result2}, got {max_product(num_str2, N2, K2)}\"\n\n    # Test case 3\n    num_str3 = \"051\"\n    N3 = 3\n    K3 = 1\n    expected_result3 = 5  # 0*51 = 0 or 05*1 = 5, max is 5\n    assert max_product(num_str3, N3,\n                       K3) == expected_result3, f\"Test case 3 failed. Expected {expected_result3}, got {max_product(num_str3, N3, K3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\ntest_max_product()", "entry_point": "max_product", "signature": "def max_product(num_str: str, N: int, K: int) -> int:", "docstring": {"en": "\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    ", "sq": "\n    Emri i funksionit: max_product\n    Argumentet:\n    num_str (str): Një varg që përfaqëson vargun e numrave.\n    N (int): Një numër i plotë që përfaqëson gjatësinë e vargut të numrave.\n    K (int): Një numër i plotë që përfaqëson numrin e shenjave të shumëzimit për t'u futur.\n    Lloji i kthimit: int (Funksioni kthen produktin maksimal që mund të merret duke futur K shenja shumëzimi në vargun e numrave.)", "hy": "\n    Գործառույթի անունը: max_product\n    Փոփոխականներ:\n    num_str (str): Թվային տողը ներկայացնող տող։\n    N (int): Թվային տողի երկարությունը ներկայացնող ամբողջ թիվ։\n    K (int): Մուլտիպլիկացիայի նշանների քանակը տեղադրելու համար ներկայացնող ամբողջ թիվ։\n    Վերադարձի տեսակը: int (Գործառույթը վերադարձնում է առավելագույն արդյունքը, որը կարելի է ստանալ թվային տողի մեջ K մուլտիպլիկացիայի նշաններ տեղադրելով։)", "bn": "\n    ফাংশনের নাম: max_product\n    আর্গুমেন্টসমূহ:\n    num_str (str): একটি স্ট্রিং যা সংখ্যার স্ট্রিংকে উপস্থাপন করে।\n    N (int): একটি পূর্ণসংখ্যা যা সংখ্যার স্ট্রিংয়ের দৈর্ঘ্যকে উপস্থাপন করে।\n    K (int): একটি পূর্ণসংখ্যা যা যোগ করার জন্য গুণ চিহ্নের সংখ্যা উপস্থাপন করে।\n    রিটার্ন টাইপ: int (ফাংশনটি সংখ্যার স্ট্রিংয়ে Kটি গুণ চিহ্ন যোগ করে প্রাপ্ত সর্বাধিক গুণফল প্রদান করে।)", "bg": "\n    Име на функция: max_product\n    Аргументи:\n    num_str (str): Низ, представляващ числовия низ.\n    N (int): Цяло число, представляващо дължината на числовия низ.\n    K (int): Цяло число, представляващо броя на знаците за умножение, които да се вмъкнат.\n    Тип на връщане: int (Функцията връща максималния произведение, което може да се получи чрез вмъкване на K знаци за умножение в числовия низ.)", "zh": "\n    函数名称: max_product\n    参数:\n    num_str (str): 表示数字字符串的字符串。\n    N (int): 表示数字字符串长度的整数。\n    K (int): 表示要插入的乘号数量的整数。\n    返回类型: int (该函数返回通过在数字字符串中插入 K 个乘号可以获得的最大乘积。)", "fr": "\n    Nom de la fonction: max_product\n    Arguments:\n    num_str (str): Une chaîne représentant la chaîne de chiffres.\n    N (int): Un entier représentant la longueur de la chaîne de chiffres.\n    K (int): Un entier représentant le nombre de signes de multiplication à insérer.\n    Type de retour: int (La fonction renvoie le produit maximum qui peut être obtenu en insérant K signes de multiplication dans la chaîne de chiffres.)", "de": "\n    Funktionsname: max_product\n    Argumente:\n    num_str (str): Ein String, der die Zahlenfolge darstellt.\n    N (int): Eine ganze Zahl, die die Länge der Zahlenfolge darstellt.\n    K (int): Eine ganze Zahl, die die Anzahl der einzufügenden Multiplikationszeichen darstellt.\n    Rückgabetyp: int (Die Funktion gibt das maximale Produkt zurück, das durch Einfügen von K Multiplikationszeichen in die Zahlenfolge erzielt werden kann.)", "ha": "\n    Sunan aiki: max_product\n    Huɗa:\n    num_str (str): Wani kirtani da ke wakiltar lambar kirtani.\n    N (int): Wani cikakken lamba da ke wakiltar tsawon lambar kirtani.\n    K (int): Wani cikakken lamba da ke wakiltar adadin alamar ninkawa da za a saka.\n    Nau'in dawowa: int (Aikin yana dawowa da mafi girman samfurin da za a iya samu ta hanyar saka alamomin ninkawa K cikin lambar kirtani.)", "hi": "\n    फ़ंक्शन का नाम: max_product\n    तर्क:\n    num_str (str): एक स्ट्रिंग जो संख्या स्ट्रिंग का प्रतिनिधित्व करती है।\n    N (int): एक पूर्णांक जो संख्या स्ट्रिंग की लंबाई का प्रतिनिधित्व करता है।\n    K (int): एक पूर्णांक जो डालने के लिए गुणा चिह्नों की संख्या का प्रतिनिधित्व करता है।\n    लौटाने का प्रकार: int (यह फ़ंक्शन अधिकतम उत्पाद लौटाता है जो संख्या स्ट्रिंग में K गुणा चिह्न डालकर प्राप्त किया जा सकता है।)", "hu": "\n    A függvény neve: max_product\n    Argumentumok:\n    num_str (str): Egy karakterlánc, amely a számot reprezentálja.\n    N (int): Egy egész szám, amely a szám karakterlánc hosszát jelöli.\n    K (int): Egy egész szám, amely a beszúrandó szorzásjelek számát jelöli.\n    Visszatérési típus: int (A függvény visszaadja a maximális szorzatot, amelyet a szám karakterláncba K szorzásjel beszúrásával lehet elérni.)", "es": "\n    Nombre de la función: max_product\n    Argumentos:\n    num_str (str): Una cadena que representa la cadena de números.\n    N (int): Un entero que representa la longitud de la cadena de números.\n    K (int): Un entero que representa el número de signos de multiplicación a insertar.\n    Tipo de retorno: int (La función devuelve el producto máximo que se puede obtener insertando K signos de multiplicación en la cadena de números.)", "arb": "اسم الدالة: max_product  \nالمعطيات:  \nnum_str (str): سلسلة تمثل رقمًا كسلسلة نصية.  \nN (int): عدد صحيح يمثل طول سلسلة الرقم.  \nK (int): عدد صحيح يمثل عدد علامات الضرب التي سيتم إدراجها.  \nنوع القيمة المعادة: int (تعيد الدالة أكبر حاصل ضرب يمكن الحصول عليه بإدراج K من علامات الضرب في سلسلة الرقم.)  ", "sw": "\n    Jina la kazi: max_product\n    Hoja:\n    num_str (str): Kamba inayowakilisha mfuatano wa nambari.\n    N (int): Nambari ya mzima inayowakilisha urefu wa mfuatano wa nambari.\n    K (int): Nambari ya mzima inayowakilisha idadi ya alama za kuzidisha za kuingiza.\n    Aina ya kurudi: int (Kazi inarudisha bidhaa ya juu zaidi inayoweza kupatikana kwa kuingiza alama za kuzidisha K katika mfuatano wa nambari.)", "tr": "Fonksiyon adı: max_product\nArgümanlar:\nnum_str (str): Sayı dizgisini temsil eden bir dize.\nN (int): Sayı dizgisinin uzunluğunu temsil eden bir tamsayı.\nK (int): Eklenecek çarpma işaretlerinin sayısını temsil eden bir tamsayı.\nDönüş tipi: int (Fonksiyon, sayı dizgisine K çarpma işareti ekleyerek elde edilebilecek maksimum çarpımı döndürür.)", "vi": "\n    Tên hàm: max_product\n    Đối số:\n    num_str (str): Một chuỗi đại diện cho chuỗi số.\n    N (int): Một số nguyên đại diện cho độ dài của chuỗi số.\n    K (int): Một số nguyên đại diện cho số dấu nhân cần chèn.\n    Kiểu trả về: int (Hàm trả về tích lớn nhất có thể đạt được bằng cách chèn K dấu nhân vào chuỗi số.)", "id": "    Nama fungsi: max_product\n    Argumen:\n    num_str (str): Sebuah string yang mewakili string angka.\n    N (int): Sebuah bilangan bulat yang mewakili panjang string angka.\n    K (int): Sebuah bilangan bulat yang mewakili jumlah tanda perkalian yang akan dimasukkan.\n    Tipe pengembalian: int (Fungsi mengembalikan hasil perkalian maksimum yang dapat diperoleh dengan memasukkan K tanda perkalian ke dalam string angka.)", "ja": "    関数名: max_product\n    引数:\n    num_str (str): 数字列を表す文字列。\n    N (int): 数字列の長さを表す整数。\n    K (int): 挿入する掛け算記号の数を表す整数。\n    戻り値の型: int (この関数は、数字列にK個の掛け算記号を挿入することで得られる最大の積を返します。)", "ko": "    함수 이름: max_product\n    인수:\n    num_str (str): 숫자 문자열을 나타내는 문자열입니다.\n    N (int): 숫자 문자열의 길이를 나타내는 정수입니다.\n    K (int): 삽입할 곱셈 기호의 수를 나타내는 정수입니다.\n    반환 유형: int (함수는 숫자 문자열에 K개의 곱셈 기호를 삽입하여 얻을 수 있는 최대 곱을 반환합니다.)", "ml": "    ഫംഗ്ഷൻ പേര്: max_product\n    ആർഗ്യുമെന്റുകൾ:\n    num_str (str): നമ്പർ സ്ട്രിംഗ് പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    N (int): നമ്പർ സ്ട്രിംഗിന്റെ നീളം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n    K (int): ചേർക്കാനുള്ള ഗുണന ചിഹ്നങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n    മടക്കമുള്ള തരം: int (നമ്പർ സ്ട്രിംഗിൽ K ഗുണന ചിഹ്നങ്ങൾ ചേർത്ത് ലഭിക്കാവുന്ന പരമാവധി ഗുണഫലം ഫംഗ്ഷൻ മടക്കുന്നു.)", "fa": "Function name: max_product\nArguments:\nnum_str (str): رشته‌ای که نمایانگر رشته عددی است.\nN (int): عدد صحیحی که نمایانگر طول رشته عددی است.\nK (int): عدد صحیحی که نمایانگر تعداد علائم ضربی است که باید درج شود.\nReturn type: int (تابع حداکثر حاصل‌ضربی را که می‌توان با درج K علامت ضرب در رشته عددی به دست آورد، برمی‌گرداند.)"}}
{"task_id": "Python/13", "prompt": {"en": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    If the final average score is greater than 80 and one or more papers are published, a scholarship of 8000 will be added\n    If the final average score is greater than 85 points and the class evaluation is greater than 80 points, the scholarship will be increased by 4000 points\n    If the final average score is greater than 90 points, the scholarship will be increased by 2000\n    If the final average score is greater than 85 and the student is from the western region, the scholarship will be increased by 1000\n    If the final assessment of the class is greater than 80 points and the class leader is the class leader, the scholarship will be increased by 850 points\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"\n\n", "sq": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Nëse nota mesatare përfundimtare është më e madhe se 80 dhe një ose më shumë punime janë publikuar, do të shtohet një bursë prej 8000\n    Nëse nota mesatare përfundimtare është më e madhe se 85 pikë dhe vlerësimi i klasës është më i madh se 80 pikë, bursa do të rritet me 4000 pikë\n    Nëse nota mesatare përfundimtare është më e madhe se 90 pikë, bursa do të rritet me 2000\n    Nëse nota mesatare përfundimtare është më e madhe se 85 dhe studenti është nga rajoni perëndimor, bursa do të rritet me 1000\n    Nëse vlerësimi përfundimtar i klasës është më i madh se 80 pikë dhe lideri i klasës është lideri i klasës, bursa do të rritet me 850 pikë\n\n    Parametra:\n    grades (list of int): Një listë me dy elemente që përmban notat akademike të studentit [mesatarja e fundvitit, vlerësimi i klasës].\n    leader (str): Një varg ('Y' ose 'N') që tregon nëse studenti është lider i klasës.\n    west (str): Një varg ('Y' ose 'N') që tregon nëse studenti është nga një provincë perëndimore.\n    papers (int): Një numër i plotë që përfaqëson numrin e punimeve kërkimore të publikuara nga studenti.\n\n    Kthen:\n    int: Shuma totale e bursës për të cilën studenti është i kualifikuar.\n\n    Shembuj:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "hy": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Եթե վերջնական միջին գնահատականը մեծ է 80-ից և մեկ կամ ավելի հոդվածներ են տպագրվել, ապա 8000 դրամի կրթաթոշակ կավելացվի\n    Եթե վերջնական միջին գնահատականը մեծ է 85 միավորից և դասի գնահատականը մեծ է 80 միավորից, ապա կրթաթոշակը կավելանա 4000 միավորով\n    Եթե վերջնական միջին գնահատականը մեծ է 90 միավորից, ապա կրթաթոշակը կավելանա 2000-ով\n    Եթե վերջնական միջին գնահատականը մեծ է 85-ից և ուսանողը արևմտյան տարածաշրջանից է, ապա կրթաթոշակը կավելանա 1000-ով\n    Եթե դասի վերջնական գնահատականը մեծ է 80 միավորից և դասի ղեկավարը դասի ղեկավարն է, ապա կրթաթոշակը կավելանա 850-ով\n\n    Պարամետրեր:\n    grades (list of int): Երկու տարր պարունակող ցուցակ, որը պարունակում է ուսանողի ակադեմիական գնահատականները [տարեվերջի միջին, դասի գնահատական]:\n    leader (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, թե արդյոք ուսանողը դասի ղեկավար է:\n    west (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, թե արդյոք ուսանողը արևմտյան մարզից է:\n    papers (int): Ամբողջ թիվ, որը ներկայացնում է ուսանողի կողմից տպագրված գիտական հոդվածների քանակը:\n\n    Վերադարձնում է:\n    int: Կրթաթոշակի ընդհանուր գումարը, որին ուսանողը իրավունք ունի:\n\n    Օրինակներ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "bn": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    যদি চূড়ান্ত গড় স্কোর 80 এর বেশি হয় এবং এক বা একাধিক পেপার প্রকাশিত হয়, তাহলে 8000 টাকার বৃত্তি যোগ করা হবে\n    যদি চূড়ান্ত গড় স্কোর 85 পয়েন্টের বেশি হয় এবং শ্রেণীর মূল্যায়ন 80 পয়েন্টের বেশি হয়, তাহলে বৃত্তি 4000 পয়েন্ট বাড়ানো হবে\n    যদি চূড়ান্ত গড় স্কোর 90 পয়েন্টের বেশি হয়, তাহলে বৃত্তি 2000 বাড়ানো হবে\n    যদি চূড়ান্ত গড় স্কোর 85 এর বেশি হয় এবং ছাত্রটি পশ্চিমাঞ্চল থেকে আসে, তাহলে বৃত্তি 1000 বাড়ানো হবে\n    যদি শ্রেণীর চূড়ান্ত মূল্যায়ন 80 পয়েন্টের বেশি হয় এবং শ্রেণী নেতা শ্রেণী নেতা হয়, তাহলে বৃত্তি 850 বাড়ানো হবে\n\n    Parameters:\n    grades (list of int): একটি দুই-উপাদান তালিকা যা ছাত্রের একাডেমিক গ্রেড [টার্মের শেষ গড়, শ্রেণীর মূল্যায়ন] ধারণ করে।\n    leader (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে ছাত্রটি শ্রেণী নেতা কিনা।\n    west (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে ছাত্রটি পশ্চিম প্রদেশ থেকে কিনা।\n    papers (int): একটি পূর্ণসংখ্যা যা ছাত্রের দ্বারা প্রকাশিত গবেষণাপত্রের সংখ্যা নির্দেশ করে।\n\n    Returns:\n    int: ছাত্রটি যে মোট বৃত্তির পরিমাণের জন্য যোগ্য তা।\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "bg": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Ако крайната средна оценка е по-голяма от 80 и е публикувана една или повече статии, ще се добави стипендия от 8000\n    Ако крайната средна оценка е по-голяма от 85 точки и оценката на класа е по-голяма от 80 точки, стипендията ще се увеличи с 4000 точки\n    Ако крайната средна оценка е по-голяма от 90 точки, стипендията ще се увеличи с 2000\n    Ако крайната средна оценка е по-голяма от 85 и студентът е от западния регион, стипендията ще се увеличи с 1000\n    Ако крайната оценка на класа е по-голяма от 80 точки и класният ръководител е класен ръководител, стипендията ще се увеличи с 850 точки\n\n    Параметри:\n    grades (list of int): Двуелементен списък, съдържащ академичните оценки на студента [среден успех в края на срока, оценка на класа].\n    leader (str): Низ ('Y' или 'N'), указващ дали студентът е класен ръководител.\n    west (str): Низ ('Y' или 'N'), указващ дали студентът е от западна провинция.\n    papers (int): Цяло число, представляващо броя на публикуваните научни статии от студента.\n\n    Връща:\n    int: Общата сума на стипендията, за която студентът има право.\n\n    Примери:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "zh": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    如果期末平均分大于80且发表了一篇或多篇论文，则奖学金增加8000\n    如果期末平均分大于85分且班级评估大于80分，则奖学金增加4000分\n    如果期末平均分大于90分，则奖学金增加2000\n    如果期末平均分大于85且学生来自西部地区，则奖学金增加1000\n    如果班级的最终评估大于80分且班长是班长，则奖学金增加850分\n\n    参数:\n    grades (list of int): 一个包含学生学术成绩的两元素列表 [期末平均, 班级评估]。\n    leader (str): 一个字符串 ('Y' 或 'N')，表示学生是否是班长。\n    west (str): 一个字符串 ('Y' 或 'N')，表示学生是否来自西部省份。\n    papers (int): 一个整数，表示学生发表的研究论文数量。\n\n    返回:\n    int: 学生有资格获得的总奖学金金额。\n\n    示例:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "fr": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Si la note moyenne finale est supérieure à 80 et qu'un ou plusieurs articles sont publiés, une bourse de 8000 sera ajoutée\n    Si la note moyenne finale est supérieure à 85 points et que l'évaluation de la classe est supérieure à 80 points, la bourse sera augmentée de 4000 points\n    Si la note moyenne finale est supérieure à 90 points, la bourse sera augmentée de 2000\n    Si la note moyenne finale est supérieure à 85 et que l'étudiant est de la région ouest, la bourse sera augmentée de 1000\n    Si l'évaluation finale de la classe est supérieure à 80 points et que le chef de classe est le chef de classe, la bourse sera augmentée de 850 points\n\n    Paramètres:\n    grades (list of int): Une liste de deux éléments contenant les notes académiques de l'étudiant [moyenne de fin de trimestre, évaluation de la classe].\n    leader (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est un chef de classe.\n    west (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est d'une province de l'ouest.\n    papers (int): Un entier représentant le nombre d'articles de recherche publiés par l'étudiant.\n\n    Retourne:\n    int: Le montant total de la bourse auquel l'étudiant est éligible.\n\n    Exemples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "de": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Wenn die endgültige Durchschnittsnote größer als 80 ist und ein oder mehrere Arbeiten veröffentlicht werden, wird ein Stipendium von 8000 hinzugefügt.\n    Wenn die endgültige Durchschnittsnote größer als 85 Punkte ist und die Klassenbewertung größer als 80 Punkte ist, wird das Stipendium um 4000 Punkte erhöht.\n    Wenn die endgültige Durchschnittsnote größer als 90 Punkte ist, wird das Stipendium um 2000 erhöht.\n    Wenn die endgültige Durchschnittsnote größer als 85 ist und der Student aus der westlichen Region stammt, wird das Stipendium um 1000 erhöht.\n    Wenn die endgültige Bewertung der Klasse größer als 80 Punkte ist und der Klassensprecher der Klassensprecher ist, wird das Stipendium um 850 erhöht.\n\n    Parameter:\n    grades (list of int): Eine Liste mit zwei Elementen, die die akademischen Noten des Studenten enthält [Durchschnitt am Ende des Semesters, Klassenbewertung].\n    leader (str): Ein String ('Y' oder 'N'), der angibt, ob der Student ein Klassensprecher ist.\n    west (str): Ein String ('Y' oder 'N'), der angibt, ob der Student aus einer westlichen Provinz stammt.\n    papers (int): Eine ganze Zahl, die die Anzahl der vom Studenten veröffentlichten Forschungsarbeiten darstellt.\n\n    Rückgabe:\n    int: Der Gesamtbetrag des Stipendiums, für den der Student berechtigt ist.\n\n    Beispiele:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "ha": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Idan matsakaicin maki na ƙarshe ya fi 80 kuma an buga ɗaya ko fiye da haka, za a ƙara tallafin karatu na 8000\n    Idan matsakaicin maki na ƙarshe ya fi maki 85 kuma kimantawa na aji ya fi maki 80, za a ƙara tallafin karatu da maki 4000\n    Idan matsakaicin maki na ƙarshe ya fi maki 90, za a ƙara tallafin karatu da 2000\n    Idan matsakaicin maki na ƙarshe ya fi 85 kuma ɗalibin yana daga yankin yamma, za a ƙara tallafin karatu da 1000\n    Idan kimantawa na ƙarshe na aji ya fi maki 80 kuma shugaban aji shine shugaban aji, za a ƙara tallafin karatu da 850\n\n    Parameters:\n    grades (list of int): Jerin abubuwa guda biyu da ke dauke da maki na ɗalibi [matsakaicin ƙarshen lokaci, kimantawa na aji].\n    leader (str): Wani kirtani ('Y' ko 'N') da ke nuna idan ɗalibin shine shugaban aji.\n    west (str): Wani kirtani ('Y' ko 'N') da ke nuna idan ɗalibin yana daga lardin yamma.\n    papers (int): Wani lamba da ke wakiltar adadin takardun bincike da ɗalibin ya buga.\n\n    Returns:\n    int: Jimlar adadin tallafin karatu da ɗalibin ya cancanci samu.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "hi": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    यदि अंतिम औसत स्कोर 80 से अधिक है और एक या अधिक पेपर प्रकाशित हैं, तो 8000 की छात्रवृत्ति जोड़ी जाएगी\n    यदि अंतिम औसत स्कोर 85 अंक से अधिक है और कक्षा मूल्यांकन 80 अंक से अधिक है, तो छात्रवृत्ति 4000 अंक से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 90 अंक से अधिक है, तो छात्रवृत्ति 2000 से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 85 से अधिक है और छात्र पश्चिमी क्षेत्र से है, तो छात्रवृत्ति 1000 से बढ़ाई जाएगी\n    यदि कक्षा का अंतिम मूल्यांकन 80 अंक से अधिक है और कक्षा लीडर कक्षा लीडर है, तो छात्रवृत्ति 850 से बढ़ाई जाएगी\n\n    पैरामीटर्स:\n    grades (list of int): दो तत्वों की सूची जिसमें छात्र के शैक्षणिक ग्रेड [अवधि के अंत का औसत, कक्षा मूल्यांकन] शामिल हैं।\n    leader (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र कक्षा लीडर है या नहीं।\n    west (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र पश्चिमी प्रांत से है या नहीं।\n    papers (int): एक पूर्णांक जो छात्र द्वारा प्रकाशित शोध पत्रों की संख्या को दर्शाता है।\n\n    रिटर्न्स:\n    int: कुल छात्रवृत्ति राशि जिसके लिए छात्र पात्र है।\n\n    उदाहरण:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "hu": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Ha a végső átlagpontszám nagyobb, mint 80, és egy vagy több publikáció van, akkor 8000 ösztöndíjat adnak hozzá\n    Ha a végső átlagpontszám nagyobb, mint 85 pont, és az osztályértékelés nagyobb, mint 80 pont, akkor az ösztöndíjat 4000 ponttal növelik\n    Ha a végső átlagpontszám nagyobb, mint 90 pont, akkor az ösztöndíjat 2000-rel növelik\n    Ha a végső átlagpontszám nagyobb, mint 85, és a diák nyugati régióból származik, akkor az ösztöndíjat 1000-rel növelik\n    Ha az osztály végső értékelése nagyobb, mint 80 pont, és az osztályvezető az osztályvezető, akkor az ösztöndíjat 850-rel növelik\n\n    Paraméterek:\n    grades (list of int): Egy két elemből álló lista, amely a diák tanulmányi eredményeit tartalmazza [félévi átlag, osztályértékelés].\n    leader (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák osztályvezető-e.\n    west (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák nyugati tartományból származik-e.\n    papers (int): Egy egész szám, amely a diák által publikált kutatási dolgozatok számát jelzi.\n\n    Visszatér:\n    int: Az összes ösztöndíj összege, amelyre a diák jogosult.\n\n    Példák:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "es": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Si la puntuación promedio final es mayor que 80 y se publican uno o más artículos, se añadirá una beca de 8000\n    Si la puntuación promedio final es mayor que 85 puntos y la evaluación de la clase es mayor que 80 puntos, la beca se incrementará en 4000 puntos\n    Si la puntuación promedio final es mayor que 90 puntos, la beca se incrementará en 2000\n    Si la puntuación promedio final es mayor que 85 y el estudiante es de la región occidental, la beca se incrementará en 1000\n    Si la evaluación final de la clase es mayor que 80 puntos y el líder de la clase es el líder de la clase, la beca se incrementará en 850 puntos\n\n    Parámetros:\n    grades (list of int): Una lista de dos elementos que contiene las calificaciones académicas del estudiante [promedio de fin de curso, evaluación de la clase].\n    leader (str): Una cadena ('Y' o 'N') que indica si el estudiante es líder de clase.\n    west (str): Una cadena ('Y' o 'N') que indica si el estudiante es de una provincia occidental.\n    papers (int): Un entero que representa el número de artículos de investigación publicados por el estudiante.\n\n    Retorna:\n    int: La cantidad total de beca a la que el estudiante es elegible.\n\n    Ejemplos:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "arb": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    إذا كان متوسط الدرجة النهائية أكبر من 80 وتم نشر ورقة بحثية واحدة أو أكثر، سيتم إضافة منحة دراسية بقيمة 8000\n    إذا كان متوسط الدرجة النهائية أكبر من 85 نقطة وكان تقييم الفصل أكبر من 80 نقطة، سيتم زيادة المنحة الدراسية بمقدار 4000 نقطة\n    إذا كان متوسط الدرجة النهائية أكبر من 90 نقطة، سيتم زيادة المنحة الدراسية بمقدار 2000\n    إذا كان متوسط الدرجة النهائية أكبر من 85 وكان الطالب من المنطقة الغربية، سيتم زيادة المنحة الدراسية بمقدار 1000\n    إذا كان التقييم النهائي للفصل أكبر من 80 نقطة وكان قائد الفصل هو قائد الفصل، سيتم زيادة المنحة الدراسية بمقدار 850 نقطة\n\n    Parameters:\n    grades (list of int): قائمة تحتوي على درجتين أكاديميتين للطالب [متوسط نهاية الفصل، تقييم الفصل].\n    leader (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب قائد الفصل.\n    west (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب من مقاطعة غربية.\n    papers (int): عدد يمثل عدد الأوراق البحثية المنشورة من قبل الطالب.\n\n    يعيد:\n    int: إجمالي مبلغ المنحة الدراسية الذي يكون الطالب مؤهلاً للحصول عليه.\n\n    امثله:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "sw": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Ikiwa alama ya wastani ya mwisho ni kubwa kuliko 80 na karatasi moja au zaidi zimechapishwa, udhamini wa 8000 utaongezwa\n    Ikiwa alama ya wastani ya mwisho ni kubwa kuliko pointi 85 na tathmini ya darasa ni kubwa kuliko pointi 80, udhamini utaongezwa kwa pointi 4000\n    Ikiwa alama ya wastani ya mwisho ni kubwa kuliko pointi 90, udhamini utaongezwa kwa 2000\n    Ikiwa alama ya wastani ya mwisho ni kubwa kuliko 85 na mwanafunzi anatoka mkoa wa magharibi, udhamini utaongezwa kwa 1000\n    Ikiwa tathmini ya mwisho ya darasa ni kubwa kuliko pointi 80 na kiongozi wa darasa ni kiongozi wa darasa, udhamini utaongezwa kwa 850\n\n    Parameters:\n    grades (list of int): Orodha ya vipengele viwili inayoonyesha alama za kitaaluma za mwanafunzi [wastani wa mwisho wa muhula, tathmini ya darasa].\n    leader (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi ni kiongozi wa darasa.\n    west (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi anatoka mkoa wa magharibi.\n    papers (int): Nambari inayowakilisha idadi ya karatasi za utafiti zilizochapishwa na mwanafunzi.\n\n    Inarejesha:\n    int: Jumla ya kiasi cha udhamini ambacho mwanafunzi anastahili.\n\n    Mifano:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "tr": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Eğer final ortalama puanı 80'den büyükse ve bir veya daha fazla makale yayınlanmışsa, burs miktarına 8000 eklenir\n    Eğer final ortalama puanı 85 puandan büyükse ve sınıf değerlendirmesi 80 puandan büyükse, burs miktarı 4000 puan artırılır\n    Eğer final ortalama puanı 90 puandan büyükse, burs miktarı 2000 artırılır\n    Eğer final ortalama puanı 85'ten büyükse ve öğrenci batı bölgesindense, burs miktarı 1000 artırılır\n    Eğer sınıfın son değerlendirmesi 80 puandan büyükse ve sınıf lideri sınıf lideriyse, burs miktarı 850 artırılır\n\n    Parametreler:\n    grades (list of int): Öğrencinin akademik notlarını içeren iki elemanlı bir liste [dönem sonu ortalaması, sınıf değerlendirmesi].\n    leader (str): Öğrencinin sınıf lideri olup olmadığını belirten bir dize ('Y' veya 'N').\n    west (str): Öğrencinin batı bölgesinden olup olmadığını belirten bir dize ('Y' veya 'N').\n    papers (int): Öğrencinin yayınladığı araştırma makalelerinin sayısını temsil eden bir tamsayı.\n\n    Dönüş:\n    int: Öğrencinin hak kazandığı toplam burs miktarı.\n\n    Örnekler:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "vi": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Nếu điểm trung bình cuối kỳ lớn hơn 80 và có một hoặc nhiều bài báo được xuất bản, học bổng sẽ được cộng thêm 8000\n    Nếu điểm trung bình cuối kỳ lớn hơn 85 điểm và đánh giá lớp lớn hơn 80 điểm, học bổng sẽ được tăng thêm 4000 điểm\n    Nếu điểm trung bình cuối kỳ lớn hơn 90 điểm, học bổng sẽ được tăng thêm 2000\n    Nếu điểm trung bình cuối kỳ lớn hơn 85 và sinh viên đến từ khu vực phía tây, học bổng sẽ được tăng thêm 1000\n    Nếu đánh giá cuối kỳ của lớp lớn hơn 80 điểm và lớp trưởng là lớp trưởng, học bổng sẽ được tăng thêm 850 điểm\n\n    Tham số:\n    grades (list of int): Một danh sách hai phần tử chứa điểm học tập của sinh viên [điểm trung bình cuối kỳ, đánh giá lớp].\n    leader (str): Một chuỗi ('Y' hoặc 'N') chỉ ra liệu sinh viên có phải là lớp trưởng hay không.\n    west (str): Một chuỗi ('Y' hoặc 'N') chỉ ra liệu sinh viên có đến từ tỉnh phía tây hay không.\n    papers (int): Một số nguyên đại diện cho số lượng bài báo nghiên cứu được sinh viên xuất bản.\n\n    Trả về:\n    int: Tổng số tiền học bổng mà sinh viên đủ điều kiện nhận.\n\n    Ví dụ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "id": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Jika nilai rata-rata akhir lebih dari 80 dan satu atau lebih makalah diterbitkan, beasiswa sebesar 8000 akan ditambahkan\n    Jika nilai rata-rata akhir lebih dari 85 poin dan evaluasi kelas lebih dari 80 poin, beasiswa akan ditingkatkan sebesar 4000 poin\n    Jika nilai rata-rata akhir lebih dari 90 poin, beasiswa akan ditingkatkan sebesar 2000\n    Jika nilai rata-rata akhir lebih dari 85 dan siswa berasal dari wilayah barat, beasiswa akan ditingkatkan sebesar 1000\n    Jika penilaian akhir kelas lebih dari 80 poin dan ketua kelas adalah ketua kelas, beasiswa akan ditingkatkan sebesar 850 poin\n\n    Parameter:\n    grades (list of int): Daftar dua elemen yang berisi nilai akademik siswa [rata-rata akhir semester, evaluasi kelas].\n    leader (str): Sebuah string ('Y' atau 'N') yang menunjukkan apakah siswa adalah ketua kelas.\n    west (str): Sebuah string ('Y' atau 'N') yang menunjukkan apakah siswa berasal dari provinsi barat.\n    papers (int): Sebuah bilangan bulat yang mewakili jumlah makalah penelitian yang diterbitkan oleh siswa.\n\n    Mengembalikan:\n    int: Jumlah total beasiswa yang berhak diterima oleh siswa.\n\n    Contoh:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "ja": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    もし最終平均スコアが80を超え、1つ以上の論文が発表されている場合、奨学金に8000が加算されます\n    もし最終平均スコアが85点を超え、クラス評価が80点を超えている場合、奨学金は4000点増加します\n    もし最終平均スコアが90点を超えている場合、奨学金は2000増加します\n    もし最終平均スコアが85を超え、学生が西部地域出身である場合、奨学金は1000増加します\n    もしクラスの最終評価が80点を超え、クラスリーダーがクラスリーダーである場合、奨学金は850増加します\n\n    Parameters:\n    grades (list of int): 学生の学業成績を含む2要素のリスト [学期末平均、クラス評価]。\n    leader (str): 学生がクラスリーダーであるかを示す文字列 ('Y' または 'N')。\n    west (str): 学生が西部地域出身であるかを示す文字列 ('Y' または 'N')。\n    papers (int): 学生が発表した研究論文の数を表す整数。\n\n    Returns:\n    int: 学生が受け取る資格のある奨学金の総額。\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "ko": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    최종 평균 점수가 80점 이상이고 하나 이상의 논문이 발표된 경우 장학금 8000이 추가됩니다.\n    최종 평균 점수가 85점 이상이고 수업 평가가 80점 이상인 경우 장학금이 4000점 증가합니다.\n    최종 평균 점수가 90점 이상인 경우 장학금이 2000 증가합니다.\n    최종 평균 점수가 85점 이상이고 학생이 서부 지역 출신인 경우 장학금이 1000 증가합니다.\n    수업의 최종 평가가 80점 이상이고 반장이 반장인 경우 장학금이 850 증가합니다.\n\n    매개변수:\n    grades (list of int): 학생의 학업 성적을 포함하는 두 요소의 리스트 [학기말 평균, 수업 평가].\n    leader (str): 학생이 반장인지 여부를 나타내는 문자열 ('Y' 또는 'N').\n    west (str): 학생이 서부 지방 출신인지 여부를 나타내는 문자열 ('Y' 또는 'N').\n    papers (int): 학생이 발표한 연구 논문의 수를 나타내는 정수.\n\n    반환:\n    int: 학생이 받을 수 있는 총 장학금 금액.\n\n    예제:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "ml": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    അവസാന ശരാശരി സ്കോർ 80-ൽ കൂടുതലാണെങ്കിൽ, ഒരു അല്ലെങ്കിൽ അതിലധികം പേപ്പറുകൾ പ്രസിദ്ധീകരിച്ചാൽ, 8000 രൂപയുടെ സ്കോളർഷിപ്പ് ചേർക്കും\n    അവസാന ശരാശരി സ്കോർ 85 പോയിന്റിൽ കൂടുതലാണെങ്കിൽ, ക്ലാസ് മൂല്യനിർണ്ണയം 80 പോയിന്റിൽ കൂടുതലാണെങ്കിൽ, സ്കോളർഷിപ്പ് 4000 പോയിന്റ് വർദ്ധിപ്പിക്കും\n    അവസാന ശരാശരി സ്കോർ 90 പോയിന്റിൽ കൂടുതലാണെങ്കിൽ, സ്കോളർഷിപ്പ് 2000 വർദ്ധിപ്പിക്കും\n    അവസാന ശരാശരി സ്കോർ 85-ൽ കൂടുതലാണെങ്കിൽ, വിദ്യാർത്ഥി പടിഞ്ഞാറൻ മേഖലയിൽ നിന്നുള്ളവനാണെങ്കിൽ, സ്കോളർഷിപ്പ് 1000 വർദ്ധിപ്പിക്കും\n    ക്ലാസിന്റെ അവസാന മൂല്യനിർണ്ണയം 80 പോയിന്റിൽ കൂടുതലാണെങ്കിൽ, ക്ലാസ് ലീഡർ ക്ലാസ് ലീഡറാണെങ്കിൽ, സ്കോളർഷിപ്പ് 850 വർദ്ധിപ്പിക്കും\n\n    പാരാമീറ്ററുകൾ:\n    grades (list of int): വിദ്യാർത്ഥിയുടെ അക്കാദമിക് ഗ്രേഡുകൾ [അവസാന സെമസ്റ്റർ ശരാശരി, ക്ലാസ് മൂല്യനിർണ്ണയം] അടങ്ങിയ രണ്ട് ഘടകങ്ങളുടെ പട്ടിക.\n    leader (str): വിദ്യാർത്ഥി ക്ലാസ് ലീഡറാണോ അല്ലയോ എന്ന് സൂചിപ്പിക്കുന്ന ഒരു സ്ട്രിംഗ് ('Y' അല്ലെങ്കിൽ 'N').\n    west (str): വിദ്യാർത്ഥി പടിഞ്ഞാറൻ പ്രവിശ്യയിൽ നിന്നുള്ളവനാണോ എന്ന് സൂചിപ്പിക്കുന്ന ഒരു സ്ട്രിംഗ് ('Y' അല്ലെങ്കിൽ 'N').\n    papers (int): വിദ്യാർത്ഥി പ്രസിദ്ധീകരിച്ച ഗവേഷണ പേപ്പറുകളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\n    മടക്കുന്നു:\n    int: വിദ്യാർത്ഥിക്ക് അർഹതയുള്ള മൊത്തം സ്കോളർഷിപ്പ് തുക.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"", "fa": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    اگر میانگین نهایی نمرات بیشتر از 80 باشد و یک یا چند مقاله منتشر شده باشد، مبلغ 8000 به بورسیه اضافه می‌شود\n    اگر میانگین نهایی نمرات بیشتر از 85 امتیاز باشد و ارزیابی کلاس بیشتر از 80 امتیاز باشد، بورسیه 4000 امتیاز افزایش می‌یابد\n    اگر میانگین نهایی نمرات بیشتر از 90 امتیاز باشد، بورسیه 2000 افزایش می‌یابد\n    اگر میانگین نهایی نمرات بیشتر از 85 باشد و دانشجو از منطقه غربی باشد، بورسیه 1000 افزایش می‌یابد\n    اگر ارزیابی نهایی کلاس بیشتر از 80 امتیاز باشد و رهبر کلاس رهبر کلاس باشد، بورسیه 850 افزایش می‌یابد\n\n    پارامترها:\n    grades (list of int): یک لیست دو عنصری که نمرات تحصیلی دانشجو را شامل می‌شود [میانگین پایان ترم، ارزیابی کلاس].\n    leader (str): یک رشته ('Y' یا 'N') که نشان می‌دهد آیا دانشجو رهبر کلاس است یا خیر.\n    west (str): یک رشته ('Y' یا 'N') که نشان می‌دهد آیا دانشجو از استان‌های غربی است یا خیر.\n    papers (int): یک عدد صحیح که تعداد مقالات پژوهشی منتشر شده توسط دانشجو را نشان می‌دهد.\n\n    بازگشت:\n    int: مبلغ کل بورسیه‌ای که دانشجو واجد شرایط آن است.\n\n    مثال‌ها:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\""}, "canonical_solution": "    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship", "instruction": {"en": "Write a python function 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' to solve the following problem:\n\n    If the final average score is greater than 80 and one or more papers are published, a scholarship of 8000 will be added\n    If the final average score is greater than 85 points and the class evaluation is greater than 80 points, the scholarship will be increased by 4000 points\n    If the final average score is greater than 90 points, the scholarship will be increased by 2000\n    If the final average score is greater than 85 and the student is from the western region, the scholarship will be increased by 1000\n    If the final assessment of the class is greater than 80 points and the class leader is the class leader, the scholarship will be increased by 850 points\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    ", "sq": "Shkruani një funksion python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Nëse nota mesatare përfundimtare është më e madhe se 80 dhe një ose më shumë punime janë publikuar, një bursë prej 8000 do të shtohet\n    Nëse nota mesatare përfundimtare është më e madhe se 85 pikë dhe vlerësimi i klasës është më i madh se 80 pikë, bursa do të rritet me 4000 pikë\n    Nëse nota mesatare përfundimtare është më e madhe se 90 pikë, bursa do të rritet me 2000\n    Nëse nota mesatare përfundimtare është më e madhe se 85 dhe studenti është nga rajoni perëndimor, bursa do të rritet me 1000\n    Nëse vlerësimi përfundimtar i klasës është më i madh se 80 pikë dhe drejtuesi i klasës është drejtuesi i klasës, bursa do të rritet me 850 pikë\n\n    Parametrat:\n    grades (list of int): Një listë me dy elemente që përmban notat akademike të studentit [mesatarja e fundvitit, vlerësimi i klasës].\n    leader (str): Një varg ('Y' ose 'N') që tregon nëse studenti është drejtues i klasës.\n    west (str): Një varg ('Y' ose 'N') që tregon nëse studenti është nga një provincë perëndimore.\n    papers (int): Një numër i plotë që përfaqëson numrin e punimeve kërkimore të publikuara nga studenti.\n\n    Kthen:\n    int: Shuma totale e bursës për të cilën studenti është i kualifikuar.\n\n    Shembuj:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "hy": "Պայթոն ֆունկցիա 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Եթե վերջնական միջին գնահատականը գերազանցում է 80-ը և մեկ կամ ավելի հոդվածներ հրապարակված են, կավելացվի 8000 դրամի կրթաթոշակ\n    Եթե վերջնական միջին գնահատականը գերազանցում է 85 միավորը և դասի գնահատականը գերազանցում է 80 միավորը, կրթաթոշակը կավելանա 4000 միավորով\n    Եթե վերջնական միջին գնահատականը գերազանցում է 90 միավորը, կրթաթոշակը կավելանա 2000-ով\n    Եթե վերջնական միջին գնահատականը գերազանցում է 85-ը և ուսանողը արևմտյան տարածաշրջանից է, կրթաթոշակը կավելանա 1000-ով\n    Եթե դասի վերջնական գնահատականը գերազանցում է 80 միավորը և դասի ղեկավարը դասի ղեկավարն է, կրթաթոշակը կավելանա 850 միավորով\n\n    Պարամետրեր:\n    grades (list of int): Երկու տարրից բաղկացած ցուցակ, որը պարունակում է ուսանողի ակադեմիական գնահատականները [կիսամյակի վերջի միջին, դասի գնահատական]:\n    leader (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, արդյոք ուսանողը դասի ղեկավար է:\n    west (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, արդյոք ուսանողը արևմտյան մարզից է:\n    papers (int): Թիվ, որը ներկայացնում է ուսանողի կողմից հրապարակված գիտական հոդվածների քանակը:\n\n    Վերադարձնում է:\n    int: Կրթաթոշակի ընդհանուր գումարը, որին ուսանողը իրավունք ունի:\n\n    Օրինակներ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "bn": "একটি পাইথন ফাংশন 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    যদি চূড়ান্ত গড় স্কোর 80 এর বেশি হয় এবং একটি বা একাধিক পেপার প্রকাশিত হয়, তাহলে 8000 টাকার বৃত্তি যোগ করা হবে\n    যদি চূড়ান্ত গড় স্কোর 85 পয়েন্টের বেশি হয় এবং শ্রেণীর মূল্যায়ন 80 পয়েন্টের বেশি হয়, তাহলে বৃত্তি 4000 পয়েন্ট দ্বারা বৃদ্ধি পাবে\n    যদি চূড়ান্ত গড় স্কোর 90 পয়েন্টের বেশি হয়, তাহলে বৃত্তি 2000 দ্বারা বৃদ্ধি পাবে\n    যদি চূড়ান্ত গড় স্কোর 85 এর বেশি হয় এবং ছাত্রটি পশ্চিমাঞ্চল থেকে আসে, তাহলে বৃত্তি 1000 দ্বারা বৃদ্ধি পাবে\n    যদি শ্রেণীর চূড়ান্ত মূল্যায়ন 80 পয়েন্টের বেশি হয় এবং শ্রেণীর নেতা শ্রেণীর নেতা হয়, তাহলে বৃত্তি 850 পয়েন্ট দ্বারা বৃদ্ধি পাবে\n\n    Parameters:\n    grades (list of int): একটি দুই-উপাদান তালিকা যা শিক্ষার্থীর একাডেমিক গ্রেড [টার্মের শেষ গড়, শ্রেণীর মূল্যায়ন] ধারণ করে।\n    leader (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে যে শিক্ষার্থী শ্রেণীর নেতা কিনা।\n    west (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে যে শিক্ষার্থী পশ্চিম প্রদেশ থেকে কিনা।\n    papers (int): একটি পূর্ণসংখ্যা যা শিক্ষার্থীর দ্বারা প্রকাশিত গবেষণা পেপারের সংখ্যা উপস্থাপন করে।\n\n    Returns:\n    int: শিক্ষার্থী যে মোট বৃত্তির জন্য যোগ্য তার পরিমাণ।\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "bg": "Напишете Python функция 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' за решаване на следния проблем:\n\n    Ако крайната средна оценка е по-голяма от 80 и е публикувана една или повече статии, ще бъде добавена стипендия от 8000\n    Ако крайната средна оценка е по-голяма от 85 точки и оценката на класа е по-голяма от 80 точки, стипендията ще бъде увеличена с 4000 точки\n    Ако крайната средна оценка е по-голяма от 90 точки, стипендията ще бъде увеличена с 2000\n    Ако крайната средна оценка е по-голяма от 85 и студентът е от западния регион, стипендията ще бъде увеличена с 1000\n    Ако крайната оценка на класа е по-голяма от 80 точки и класният ръководител е класният ръководител, стипендията ще бъде увеличена с 850 точки\n\n    Параметри:\n    grades (list of int): Списък с два елемента, съдържащ академичните оценки на студента [средна оценка в края на срока, оценка на класа].\n    leader (str): Низ ('Y' или 'N'), указващ дали студентът е класен ръководител.\n    west (str): Низ ('Y' или 'N'), указващ дали студентът е от западна провинция.\n    papers (int): Цяло число, представляващо броя на научните статии, публикувани от студента.\n\n    Връща:\n    int: Общата сума на стипендията, за която студентът има право.\n\n    Примери:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "zh": "编写一个 Python 函数 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' 来解决以下问题：\n\n    如果期末平均分大于80且发表了一篇或多篇论文，则增加8000的奖学金\n    如果期末平均分大于85分且班级评价大于80分，则奖学金增加4000分\n    如果期末平均分大于90分，则奖学金增加2000\n    如果期末平均分大于85且学生来自西部地区，则奖学金增加1000\n    如果班级的最终评估大于80分且班长是班长，则奖学金增加850分\n\n    参数：\n    grades (list of int): 一个包含学生学术成绩的两元素列表 [期末平均分, 班级评价]。\n    leader (str): 一个字符串 ('Y' 或 'N')，指示学生是否是班长。\n    west (str): 一个字符串 ('Y' 或 'N')，指示学生是否来自西部省份。\n    papers (int): 一个整数，表示学生发表的研究论文数量。\n\n    返回：\n    int: 学生有资格获得的总奖学金金额。\n\n    示例：\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "fr": "Écrivez une fonction python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' pour résoudre le problème suivant :\n\n    Si la note moyenne finale est supérieure à 80 et qu'un ou plusieurs articles sont publiés, une bourse de 8000 sera ajoutée.\n    Si la note moyenne finale est supérieure à 85 points et que l'évaluation de la classe est supérieure à 80 points, la bourse sera augmentée de 4000 points.\n    Si la note moyenne finale est supérieure à 90 points, la bourse sera augmentée de 2000.\n    Si la note moyenne finale est supérieure à 85 et que l'étudiant est de la région ouest, la bourse sera augmentée de 1000.\n    Si l'évaluation finale de la classe est supérieure à 80 points et que le chef de classe est le chef de classe, la bourse sera augmentée de 850 points.\n\n    Paramètres:\n    grades (list of int): Une liste à deux éléments contenant les notes académiques de l'étudiant [moyenne de fin de trimestre, évaluation de la classe].\n    leader (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est un chef de classe.\n    west (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est d'une province de l'ouest.\n    papers (int): Un entier représentant le nombre d'articles de recherche publiés par l'étudiant.\n\n    Renvoie:\n    int: Le montant total de la bourse auquel l'étudiant est éligible.\n\n    Exemples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "de": "Schreiben Sie eine Python-Funktion 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:', um das folgende Problem zu lösen:\n\n    Wenn die endgültige Durchschnittsnote größer als 80 ist und ein oder mehrere Arbeiten veröffentlicht wurden, wird ein Stipendium von 8000 hinzugefügt.\n    Wenn die endgültige Durchschnittsnote größer als 85 Punkte ist und die Klassenbewertung größer als 80 Punkte ist, wird das Stipendium um 4000 Punkte erhöht.\n    Wenn die endgültige Durchschnittsnote größer als 90 Punkte ist, wird das Stipendium um 2000 erhöht.\n    Wenn die endgültige Durchschnittsnote größer als 85 ist und der Schüler aus der westlichen Region kommt, wird das Stipendium um 1000 erhöht.\n    Wenn die endgültige Bewertung der Klasse größer als 80 Punkte ist und der Klassensprecher der Klassensprecher ist, wird das Stipendium um 850 Punkte erhöht.\n\n    Parameter:\n    grades (list von int): Eine Liste mit zwei Elementen, die die akademischen Noten des Schülers enthält [Durchschnitt am Ende des Semesters, Klassenbewertung].\n    leader (str): Ein String ('Y' oder 'N'), der angibt, ob der Schüler Klassensprecher ist.\n    west (str): Ein String ('Y' oder 'N'), der angibt, ob der Schüler aus einer westlichen Provinz stammt.\n    papers (int): Eine Ganzzahl, die die Anzahl der vom Schüler veröffentlichten Forschungsarbeiten darstellt.\n\n    Rückgabe:\n    int: Der Gesamtbetrag des Stipendiums, für das der Schüler berechtigt ist.\n\n    Beispiele:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "ha": "Rubuta wani aikin python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' don warware matsalar mai zuwa:\n\n    Idan matsakaicin maki na ƙarshe ya fi 80 kuma an buga takardu ɗaya ko fiye, za a ƙara tallafin karatu na 8000\n    Idan matsakaicin maki na ƙarshe ya fi maki 85 kuma kimantawa na aji ya fi maki 80, za a ƙara tallafin karatu da maki 4000\n    Idan matsakaicin maki na ƙarshe ya fi maki 90, za a ƙara tallafin karatu da 2000\n    Idan matsakaicin maki na ƙarshe ya fi 85 kuma ɗalibin yana daga yankin yamma, za a ƙara tallafin karatu da 1000\n    Idan kimantawa na ƙarshe na aji ya fi maki 80 kuma shugaban aji shine shugaban aji, za a ƙara tallafin karatu da maki 850\n\n    Sigogi:\n    grades (list na int): Jerin abubuwa guda biyu da ke ƙunshe da maki na ɗalibin [matsakaicin ƙarshen lokaci, kimantawa na aji].\n    leader (str): Wata kirtani ('Y' ko 'N') da ke nuna idan ɗalibin shine shugaban aji.\n    west (str): Wata kirtani ('Y' ko 'N') da ke nuna idan ɗalibin yana daga lardin yamma.\n    papers (int): Wani lamba da ke wakiltar yawan takardun bincike da ɗalibin ya wallafa.\n\n    Returns:\n    int: Jimlar adadin tallafin karatu da ɗalibin ya cancanta.\n\n    Misalai:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "hi": "एक पायथन फ़ंक्शन 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    यदि अंतिम औसत स्कोर 80 से अधिक है और एक या अधिक शोध पत्र प्रकाशित होते हैं, तो 8000 की छात्रवृत्ति जोड़ी जाएगी\n    यदि अंतिम औसत स्कोर 85 अंकों से अधिक है और कक्षा मूल्यांकन 80 अंकों से अधिक है, तो छात्रवृत्ति 4000 अंकों से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 90 अंकों से अधिक है, तो छात्रवृत्ति 2000 से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 85 से अधिक है और छात्र पश्चिमी क्षेत्र से है, तो छात्रवृत्ति 1000 से बढ़ाई जाएगी\n    यदि कक्षा का अंतिम मूल्यांकन 80 अंकों से अधिक है और कक्षा नेता कक्षा का नेता है, तो छात्रवृत्ति 850 से बढ़ाई जाएगी\n\n    पैरामीटर:\n    grades (list of int): एक दो-तत्वों वाली सूची जिसमें छात्र के शैक्षणिक ग्रेड [सत्रांत औसत, कक्षा मूल्यांकन] शामिल हैं।\n    leader (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र कक्षा का नेता है या नहीं।\n    west (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र पश्चिमी प्रांत से है या नहीं।\n    papers (int): एक पूर्णांक जो छात्र द्वारा प्रकाशित शोध पत्रों की संख्या का प्रतिनिधित्व करता है।\n\n    लौटाता है:\n    int: कुल छात्रवृत्ति राशि जिसके लिए छात्र पात्र है।\n\n    उदाहरण:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "hu": "Írj egy python függvényt 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' a következő probléma megoldására:\n\n    Ha a végső átlagpontszám nagyobb, mint 80, és egy vagy több dolgozat megjelenik, akkor 8000 ösztöndíjat adnak hozzá\n    Ha a végső átlagpontszám nagyobb, mint 85 pont, és az osztályértékelés nagyobb, mint 80 pont, akkor az ösztöndíj 4000 ponttal növekszik\n    Ha a végső átlagpontszám nagyobb, mint 90 pont, akkor az ösztöndíj 2000-rel növekszik\n    Ha a végső átlagpontszám nagyobb, mint 85, és a diák a nyugati régióból származik, akkor az ösztöndíj 1000-rel növekszik\n    Ha az osztály végső értékelése nagyobb, mint 80 pont, és az osztályvezető az osztályvezető, akkor az ösztöndíj 850 ponttal növekszik\n\n    Paraméterek:\n    grades (list of int): Egy két elemből álló lista, amely tartalmazza a diák tanulmányi eredményeit [félév végi átlag, osztályértékelés].\n    leader (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák osztályvezető-e.\n    west (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák egy nyugati tartományból származik-e.\n    papers (int): Egy egész szám, amely a diák által publikált kutatási dolgozatok számát jelöli.\n\n    Visszatér:\n    int: Az összes ösztöndíj összege, amelyre a diák jogosult.\n\n    Példák:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "es": "Escribe una función de Python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' para resolver el siguiente problema:\n\n    Si la puntuación media final es superior a 80 y se publican uno o más artículos, se añadirá una beca de 8000\n    Si la puntuación media final es superior a 85 puntos y la evaluación de la clase es superior a 80 puntos, la beca se incrementará en 4000 puntos\n    Si la puntuación media final es superior a 90 puntos, la beca se incrementará en 2000\n    Si la puntuación media final es superior a 85 y el estudiante es de la región occidental, la beca se incrementará en 1000\n    Si la evaluación final de la clase es superior a 80 puntos y el líder de la clase es el líder de la clase, la beca se incrementará en 850 puntos\n\n    Parámetros:\n    grades (lista de int): Una lista de dos elementos que contiene las calificaciones académicas del estudiante [promedio de fin de curso, evaluación de clase].\n    leader (str): Una cadena ('Y' o 'N') que indica si el estudiante es líder de clase.\n    west (str): Una cadena ('Y' o 'N') que indica si el estudiante es de una provincia occidental.\n    papers (int): Un entero que representa el número de artículos de investigación publicados por el estudiante.\n\n    Retorna:\n    int: La cantidad total de beca para la que el estudiante es elegible.\n\n    Ejemplos:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "arb": "اكتب دالة بايثون 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' لحل المشكلة التالية:\n\n    إذا كان متوسط الدرجة النهائية أكبر من 80 وتم نشر ورقة أو أكثر، سيتم إضافة منحة دراسية بقيمة 8000\n    إذا كان متوسط الدرجة النهائية أكبر من 85 نقطة وكان تقييم الصف أكبر من 80 نقطة، سيتم زيادة المنحة الدراسية بمقدار 4000 نقطة\n    إذا كان متوسط الدرجة النهائية أكبر من 90 نقطة، سيتم زيادة المنحة الدراسية بمقدار 2000\n    إذا كان متوسط الدرجة النهائية أكبر من 85 وكان الطالب من المنطقة الغربية، سيتم زيادة المنحة الدراسية بمقدار 1000\n    إذا كان التقييم النهائي للصف أكبر من 80 نقطة وكان قائد الصف هو قائد الصف، سيتم زيادة المنحة الدراسية بمقدار 850 نقطة\n\n    المعاملات:\n    grades (قائمة من الأعداد الصحيحة): قائمة تحتوي على عنصرين تمثل درجات الطالب الأكاديمية [متوسط نهاية الفصل، تقييم الصف].\n    leader (سلسلة نصية): سلسلة نصية ('Y' أو 'N') تشير إلى ما إذا كان الطالب قائد الصف.\n    west (سلسلة نصية): سلسلة نصية ('Y' أو 'N') تشير إلى ما إذا كان الطالب من مقاطعة غربية.\n    papers (عدد صحيح): عدد صحيح يمثل عدد الأوراق البحثية المنشورة من قبل الطالب.\n\n    يعيد:\n    int: إجمالي مبلغ المنحة الدراسية الذي يستحقه الطالب.\n\n    أمثلة:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "sw": "Andika kazi ya python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' kutatua tatizo lifuatalo:\n\n    Ikiwa alama ya wastani ya mwisho ni zaidi ya 80 na moja au zaidi ya karatasi zimechapishwa, udhamini wa 8000 utaongezwa\n    Ikiwa alama ya wastani ya mwisho ni zaidi ya pointi 85 na tathmini ya darasa ni zaidi ya pointi 80, udhamini utaongezwa kwa pointi 4000\n    Ikiwa alama ya wastani ya mwisho ni zaidi ya pointi 90, udhamini utaongezwa kwa 2000\n    Ikiwa alama ya wastani ya mwisho ni zaidi ya 85 na mwanafunzi anatoka katika eneo la magharibi, udhamini utaongezwa kwa 1000\n    Ikiwa tathmini ya mwisho ya darasa ni zaidi ya pointi 80 na kiongozi wa darasa ni kiongozi wa darasa, udhamini utaongezwa kwa 850\n\n    Vigezo:\n    grades (orodha ya int): Orodha ya vipengele viwili inayoonyesha alama za kitaaluma za mwanafunzi [mwisho wa wastani wa muhula, tathmini ya darasa].\n    leader (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi ni kiongozi wa darasa.\n    west (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi anatoka katika jimbo la magharibi.\n    papers (int): Nambari inayoonyesha idadi ya karatasi za utafiti zilizochapishwa na mwanafunzi.\n\n    Inarudi:\n    int: Jumla ya kiasi cha udhamini ambacho mwanafunzi anastahili.\n\n    Mifano:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "tr": "Bir python fonksiyonu 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Eğer nihai ortalama puan 80'den büyükse ve bir veya daha fazla makale yayınlanmışsa, 8000 burs eklenecektir\n    Eğer nihai ortalama puan 85 puandan büyükse ve sınıf değerlendirmesi 80 puandan büyükse, burs 4000 puan artırılacaktır\n    Eğer nihai ortalama puan 90 puandan büyükse, burs 2000 artırılacaktır\n    Eğer nihai ortalama puan 85'ten büyükse ve öğrenci batı bölgesindense, burs 1000 artırılacaktır\n    Eğer sınıfın nihai değerlendirmesi 80 puandan büyükse ve sınıf lideri sınıf lideriyse, burs 850 artırılacaktır\n\n    Parametreler:\n    grades (list of int): Öğrencinin akademik notlarını içeren iki elemanlı bir liste [dönem sonu ortalaması, sınıf değerlendirmesi].\n    leader (str): Öğrencinin sınıf lideri olup olmadığını belirten bir string ('Y' veya 'N').\n    west (str): Öğrencinin batı bölgesinden olup olmadığını belirten bir string ('Y' veya 'N').\n    papers (int): Öğrenci tarafından yayınlanan araştırma makalelerinin sayısını temsil eden bir tamsayı.\n\n    Dönüş:\n    int: Öğrencinin hak kazandığı toplam burs miktarı.\n\n    Örnekler:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "vi": "Viết một hàm python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' để giải quyết vấn đề sau:\n\n    Nếu điểm trung bình cuối kỳ lớn hơn 80 và có một hoặc nhiều bài báo được xuất bản, học bổng sẽ được cộng thêm 8000\n    Nếu điểm trung bình cuối kỳ lớn hơn 85 điểm và đánh giá lớp lớn hơn 80 điểm, học bổng sẽ được tăng thêm 4000 điểm\n    Nếu điểm trung bình cuối kỳ lớn hơn 90 điểm, học bổng sẽ được tăng thêm 2000\n    Nếu điểm trung bình cuối kỳ lớn hơn 85 và sinh viên đến từ khu vực phía tây, học bổng sẽ được tăng thêm 1000\n    Nếu đánh giá cuối kỳ của lớp lớn hơn 80 điểm và lớp trưởng là lớp trưởng, học bổng sẽ được tăng thêm 850 điểm\n\n    Tham số:\n    grades (list of int): Một danh sách hai phần tử chứa điểm học tập của sinh viên [điểm trung bình cuối kỳ, đánh giá lớp].\n    leader (str): Một chuỗi ('Y' hoặc 'N') cho biết liệu sinh viên có phải là lớp trưởng hay không.\n    west (str): Một chuỗi ('Y' hoặc 'N') cho biết liệu sinh viên có đến từ một tỉnh phía tây hay không.\n    papers (int): Một số nguyên đại diện cho số lượng bài báo nghiên cứu được xuất bản bởi sinh viên.\n\n    Trả về:\n    int: Tổng số tiền học bổng mà sinh viên đủ điều kiện nhận.\n\n    Ví dụ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "id": "Tulis fungsi python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Jika nilai rata-rata akhir lebih dari 80 dan satu atau lebih makalah diterbitkan, beasiswa sebesar 8000 akan ditambahkan\n    Jika nilai rata-rata akhir lebih dari 85 poin dan evaluasi kelas lebih dari 80 poin, beasiswa akan ditingkatkan sebesar 4000 poin\n    Jika nilai rata-rata akhir lebih dari 90 poin, beasiswa akan ditingkatkan sebesar 2000\n    Jika nilai rata-rata akhir lebih dari 85 dan siswa berasal dari wilayah barat, beasiswa akan ditingkatkan sebesar 1000\n    Jika penilaian akhir kelas lebih dari 80 poin dan ketua kelas adalah ketua kelas, beasiswa akan ditingkatkan sebesar 850 poin\n\n    Parameter:\n    grades (list of int): Daftar dua elemen yang berisi nilai akademik siswa [rata-rata akhir semester, evaluasi kelas].\n    leader (str): Sebuah string ('Y' atau 'N') yang menunjukkan apakah siswa adalah ketua kelas.\n    west (str): Sebuah string ('Y' atau 'N') yang menunjukkan apakah siswa berasal dari provinsi barat.\n    papers (int): Sebuah bilangan bulat yang mewakili jumlah makalah penelitian yang diterbitkan oleh siswa.\n\n    Mengembalikan:\n    int: Jumlah total beasiswa yang berhak diterima oleh siswa.\n\n    Contoh:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "ja": "Python関数 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' を作成して、次の問題を解決してください:\n\n    もし最終平均スコアが80を超え、1つ以上の論文が発表されている場合、奨学金に8000が追加されます\n    もし最終平均スコアが85点を超え、クラス評価が80点を超える場合、奨学金は4000ポイント増加します\n    もし最終平均スコアが90点を超える場合、奨学金は2000増加します\n    もし最終平均スコアが85を超え、学生が西部地域出身である場合、奨学金は1000増加します\n    もしクラスの最終評価が80点を超え、クラスリーダーがクラスリーダーである場合、奨学金は850増加します\n\n    パラメータ:\n    grades (list of int): 学生の学業成績を含む2要素のリスト [学期末平均, クラス評価]。\n    leader (str): 学生がクラスリーダーであるかを示す文字列 ('Y' または 'N')。\n    west (str): 学生が西部地域出身であるかを示す文字列 ('Y' または 'N')。\n    papers (int): 学生が発表した研究論文の数を表す整数。\n\n    戻り値:\n    int: 学生が受け取る資格のある奨学金の総額。\n\n    例:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "ko": "파이썬 함수를 작성하세요 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' 다음 문제를 해결하기 위해:\n\n    만약 최종 평균 점수가 80점 이상이고 하나 이상의 논문이 출판된 경우, 8000의 장학금이 추가됩니다.\n    만약 최종 평균 점수가 85점 이상이고 반 평가가 80점 이상인 경우, 장학금이 4000점 증가합니다.\n    만약 최종 평균 점수가 90점 이상인 경우, 장학금이 2000 증가합니다.\n    만약 최종 평균 점수가 85점 이상이고 학생이 서부 지역 출신인 경우, 장학금이 1000 증가합니다.\n    만약 반의 최종 평가가 80점 이상이고 반장이 반장인 경우, 장학금이 850 증가합니다.\n\n    매개변수:\n    grades (list of int): 학생의 학업 성적 [학기말 평균, 반 평가]을 포함하는 두 요소의 리스트.\n    leader (str): 학생이 반장인지 여부를 나타내는 문자열 ('Y' 또는 'N').\n    west (str): 학생이 서부 지방 출신인지 여부를 나타내는 문자열 ('Y' 또는 'N').\n    papers (int): 학생이 출판한 연구 논문의 수를 나타내는 정수.\n\n    반환값:\n    int: 학생이 받을 수 있는 총 장학금 금액.\n\n    예시:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "ml": "'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' എന്ന python ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    അവസാന ശരാശരി സ്കോർ 80-ൽ കൂടുതലാണെങ്കിൽ, ഒരു അല്ലെങ്കിൽ അതിലധികം പേപ്പറുകൾ പ്രസിദ്ധീകരിച്ചാൽ, 8000 സ്കോളർഷിപ്പ് ചേർക്കും\n    അവസാന ശരാശരി സ്കോർ 85 പോയിന്റിൽ കൂടുതലാണെങ്കിൽ, ക്ലാസ് മൂല്യനിർണയം 80 പോയിന്റിൽ കൂടുതലാണെങ്കിൽ, സ്കോളർഷിപ്പ് 4000 പോയിന്റ് വർദ്ധിപ്പിക്കും\n    അവസാന ശരാശരി സ്കോർ 90 പോയിന്റിൽ കൂടുതലാണെങ്കിൽ, സ്കോളർഷിപ്പ് 2000 വർദ്ധിപ്പിക്കും\n    അവസാന ശരാശരി സ്കോർ 85-ൽ കൂടുതലാണെങ്കിൽ, വിദ്യാർത്ഥി പാശ്ചാത്യ മേഖലയിൽ നിന്നുള്ളവനാണെങ്കിൽ, സ്കോളർഷിപ്പ് 1000 വർദ്ധിപ്പിക്കും\n    ക്ലാസിന്റെ അവസാന മൂല്യനിർണയം 80 പോയിന്റിൽ കൂടുതലാണെങ്കിൽ, ക്ലാസ് ലീഡർ ക്ലാസ് ലീഡറാണെങ്കിൽ, സ്കോളർഷിപ്പ് 850 വർദ്ധിപ്പിക്കും\n\n    പാരാമീറ്ററുകൾ:\n    grades (list of int): വിദ്യാർത്ഥിയുടെ അക്കാദമിക് ഗ്രേഡുകൾ [അവസാനകാല ശരാശരി, ക്ലാസ് മൂല്യനിർണയം] അടങ്ങിയ രണ്ട് ഘടകങ്ങളുടെ പട്ടിക.\n    leader (str): വിദ്യാർത്ഥി ക്ലാസ് ലീഡറാണോ അല്ലയോ എന്ന് സൂചിപ്പിക്കുന്ന ഒരു സ്ട്രിംഗ് ('Y' അല്ലെങ്കിൽ 'N').\n    west (str): വിദ്യാർത്ഥി പാശ്ചാത്യ പ്രവിശ്യയിൽ നിന്നുള്ളവനാണോ എന്ന് സൂചിപ്പിക്കുന്ന ഒരു സ്ട്രിംഗ് ('Y' അല്ലെങ്കിൽ 'N').\n    papers (int): വിദ്യാർത്ഥി പ്രസിദ്ധീകരിച്ച ഗവേഷണ പേപ്പറുകളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\n    മടക്കങ്ങൾ:\n    int: വിദ്യാർത്ഥിക്ക് അർഹമായ മൊത്തം സ്കോളർഷിപ്പ് തുക.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "fa": "یک تابع پایتون بنویسید 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' برای حل مسئله زیر:\n\n    اگر میانگین نهایی بیشتر از 80 باشد و یک یا چند مقاله منتشر شده باشد، مبلغ 8000 به بورسیه اضافه می‌شود\n    اگر میانگین نهایی بیشتر از 85 امتیاز باشد و ارزیابی کلاس بیشتر از 80 امتیاز باشد، بورسیه به میزان 4000 امتیاز افزایش می‌یابد\n    اگر میانگین نهایی بیشتر از 90 امتیاز باشد، بورسیه به میزان 2000 افزایش می‌یابد\n    اگر میانگین نهایی بیشتر از 85 باشد و دانشجو از منطقه غربی باشد، بورسیه به میزان 1000 افزایش می‌یابد\n    اگر ارزیابی نهایی کلاس بیشتر از 80 امتیاز باشد و رهبر کلاس، رهبر کلاس باشد، بورسیه به میزان 850 افزایش می‌یابد\n\n    پارامترها:\n    grades (list of int): یک لیست دو عنصری شامل نمرات تحصیلی دانشجو [میانگین پایان ترم، ارزیابی کلاس].\n    leader (str): یک رشته ('Y' یا 'N') که نشان می‌دهد آیا دانشجو رهبر کلاس است.\n    west (str): یک رشته ('Y' یا 'N') که نشان می‌دهد آیا دانشجو از یک استان غربی است.\n    papers (int): یک عدد صحیح که تعداد مقالات تحقیقاتی منتشر شده توسط دانشجو را نشان می‌دهد.\n\n    بازگشت:\n    int: مجموع مبلغ بورسیه‌ای که دانشجو واجد شرایط آن است.\n\n    مثال‌ها:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000"}, "level": "easy", "test": "def test_calculate_scholarship():\n    # Test case 1: Student meets multiple scholarship criteria\n    grades1 = [90, 85]  # Both grades are high\n    leader1 = 'Y'  # Is a leader\n    west1 = 'Y'  # Is from the West\n    papers1 = 2  # Has published papers\n    expected_scholarship1 = 13850  # Should receive multiple scholarships\n    assert calculate_scholarship(grades1, leader1, west1,\n                                 papers1) == expected_scholarship1, f\"Test case 1 failed. Expected {expected_scholarship1}, got {calculate_scholarship(grades1, leader1, west1, papers1)}\"\n\n    # Test case 2: Student meets one scholarship criteria\n    grades2 = [82, 70]  # Only the first grade is high enough\n    leader2 = 'N'  # Is not a leader\n    west2 = 'N'  # Is not from the West\n    papers2 = 1  # Has published papers\n    expected_scholarship2 = 8000  # Should receive scholarship for first grade and papers\n    assert calculate_scholarship(grades2, leader2, west2,\n                                 papers2) == expected_scholarship2, f\"Test case 2 failed. Expected {expected_scholarship2}, got {calculate_scholarship(grades2, leader2, west2, papers2)}\"\n\n    # Test case 3: Student does not meet any scholarship criteria\n    grades3 = [75, 75]  # Both grades are below the threshold\n    leader3 = 'N'  # Is not a leader\n    west3 = 'N'  # Is not from the West\n    papers3 = 0  # Has no published papers\n    expected_scholarship3 = 0  # Should not receive any scholarships\n    assert calculate_scholarship(grades3, leader3, west3,\n                                 papers3) == expected_scholarship3, f\"Test case 3 failed. Expected {expected_scholarship3}, got {calculate_scholarship(grades3, leader3, west3, papers3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\n\n\ntest_calculate_scholarship()", "entry_point": "calculate_scholarship", "signature": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:", "docstring": {"en": "\n    If the final average score is greater than 80 and one or more papers are published, a scholarship of 8000 will be added\n    If the final average score is greater than 85 points and the class evaluation is greater than 80 points, the scholarship will be increased by 4000 points\n    If the final average score is greater than 90 points, the scholarship will be increased by 2000\n    If the final average score is greater than 85 and the student is from the western region, the scholarship will be increased by 1000\n    If the final assessment of the class is greater than 80 points and the class leader is the class leader, the scholarship will be increased by 850 points\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    ", "sq": "\n    Nëse nota mesatare përfundimtare është më e madhe se 80 dhe një ose më shumë punime janë publikuar, një bursë prej 8000 do të shtohet\n    Nëse nota mesatare përfundimtare është më e madhe se 85 pikë dhe vlerësimi i klasës është më i madh se 80 pikë, bursa do të rritet me 4000 pikë\n    Nëse nota mesatare përfundimtare është më e madhe se 90 pikë, bursa do të rritet me 2000\n    Nëse nota mesatare përfundimtare është më e madhe se 85 dhe studenti është nga rajoni perëndimor, bursa do të rritet me 1000\n    Nëse vlerësimi përfundimtar i klasës është më i madh se 80 pikë dhe udhëheqësi i klasës është udhëheqësi i klasës, bursa do të rritet me 850 pikë\n\n    Parametra:\n    grades (list of int): Një listë me dy elemente që përmban notat akademike të studentit [mesatarja e fundvitit, vlerësimi i klasës].\n    leader (str): Një varg ('Y' ose 'N') që tregon nëse studenti është udhëheqës i klasës.\n    west (str): Një varg ('Y' ose 'N') që tregon nëse studenti është nga një provincë perëndimore.\n    papers (int): Një numër që përfaqëson numrin e punimeve kërkimore të publikuara nga studenti.\n\n    Kthen:\n    int: Shuma totale e bursës për të cilën studenti është i kualifikuar.\n\n    Shembuj:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "hy": "\n    Եթե վերջնական միջին գնահատականը գերազանցում է 80-ը և հրապարակված է մեկ կամ ավելի հոդվածներ, ապա 8000 դրամի կրթաթոշակ կավելացվի\n    Եթե վերջնական միջին գնահատականը գերազանցում է 85 միավորը և դասի գնահատականը գերազանցում է 80 միավորը, ապա կրթաթոշակը կավելանա 4000 միավորով\n    Եթե վերջնական միջին գնահատականը գերազանցում է 90 միավորը, ապա կրթաթոշակը կավելանա 2000-ով\n    Եթե վերջնական միջին գնահատականը գերազանցում է 85-ը և ուսանողը արևմտյան տարածաշրջանից է, ապա կրթաթոշակը կավելանա 1000-ով\n    Եթե դասի վերջնական գնահատականը գերազանցում է 80 միավորը և դասի ղեկավարը դասի ղեկավարն է, ապա կրթաթոշակը կավելանա 850-ով\n\n    Պարամետրեր:\n    grades (list of int): Երկու տարրերից բաղկացած ցուցակ, որը պարունակում է ուսանողի ակադեմիական գնահատականները [կիսամյակի վերջնական միջին, դասի գնահատում]:\n    leader (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, թե արդյոք ուսանողը դասի ղեկավար է:\n    west (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, թե արդյոք ուսանողը արևմտյան մարզից է:\n    papers (int): Ամբողջ թիվ, որը ներկայացնում է ուսանողի կողմից հրապարակված գիտական հոդվածների քանակը:\n\n    Վերադարձնում է:\n    int: Կրթաթոշակի ընդհանուր գումարը, որին ուսանողը իրավասու է:\n\n    Օրինակներ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "bn": "\n    যদি চূড়ান্ত গড় স্কোর ৮০ এর বেশি হয় এবং একটি বা একাধিক পেপার প্রকাশিত হয়, তাহলে ৮০০০ টাকার বৃত্তি যোগ করা হবে\n    যদি চূড়ান্ত গড় স্কোর ৮৫ পয়েন্টের বেশি হয় এবং শ্রেণীর মূল্যায়ন ৮০ পয়েন্টের বেশি হয়, তাহলে বৃত্তি ৪০০০ পয়েন্ট বাড়ানো হবে\n    যদি চূড়ান্ত গড় স্কোর ৯০ পয়েন্টের বেশি হয়, তাহলে বৃত্তি ২০০০ বাড়ানো হবে\n    যদি চূড়ান্ত গড় স্কোর ৮৫ এর বেশি হয় এবং শিক্ষার্থী পশ্চিমাঞ্চল থেকে হয়, তাহলে বৃত্তি ১০০০ বাড়ানো হবে\n    যদি শ্রেণীর চূড়ান্ত মূল্যায়ন ৮০ পয়েন্টের বেশি হয় এবং শ্রেণী নেতা শ্রেণী নেতা হয়, তাহলে বৃত্তি ৮৫০ পয়েন্ট বাড়ানো হবে\n\n    প্যারামিটারসমূহ:\n    grades (list of int): একটি দুই-উপাদান তালিকা যা শিক্ষার্থীর একাডেমিক গ্রেড [টার্মের শেষ গড়, শ্রেণীর মূল্যায়ন] ধারণ করে।\n    leader (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী শ্রেণী নেতা কিনা।\n    west (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী পশ্চিম প্রদেশ থেকে কিনা।\n    papers (int): একটি পূর্ণসংখ্যা যা শিক্ষার্থীর প্রকাশিত গবেষণাপত্রের সংখ্যা নির্দেশ করে।\n\n    রিটার্নস:\n    int: শিক্ষার্থী যে মোট বৃত্তির পরিমাণের জন্য যোগ্য তা।\n\n    উদাহরণ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "bg": "\n    Ако крайната средна оценка е по-голяма от 80 и е публикувана една или повече статии, ще бъде добавена стипендия от 8000\n    Ако крайната средна оценка е по-голяма от 85 точки и оценката на класа е по-голяма от 80 точки, стипендията ще бъде увеличена с 4000 точки\n    Ако крайната средна оценка е по-голяма от 90 точки, стипендията ще бъде увеличена с 2000\n    Ако крайната средна оценка е по-голяма от 85 и студентът е от западния регион, стипендията ще бъде увеличена с 1000\n    Ако крайната оценка на класа е по-голяма от 80 точки и класният ръководител е класен ръководител, стипендията ще бъде увеличена с 850 точки\n\n    Параметри:\n    grades (list of int): Двуелементен списък, съдържащ академичните оценки на студента [средна оценка в края на срока, оценка на класа].\n    leader (str): Низ ('Y' или 'N'), указващ дали студентът е класен ръководител.\n    west (str): Низ ('Y' или 'N'), указващ дали студентът е от западна провинция.\n    papers (int): Цяло число, представляващо броя на научните статии, публикувани от студента.\n\n    Връща:\n    int: Общата сума на стипендията, за която студентът има право.\n\n    Примери:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "zh": "\n    如果期末平均分大于80且发表了一篇或多篇论文，则增加8000奖学金\n    如果期末平均分大于85分且班级评价大于80分，则奖学金增加4000分\n    如果期末平均分大于90分，则奖学金增加2000\n    如果期末平均分大于85且学生来自西部地区，则奖学金增加1000\n    如果班级的最终评估大于80分且班长是班长，则奖学金增加850分\n\n    参数:\n    grades (list of int): 一个包含学生学术成绩的两元素列表 [期末平均分, 班级评价]。\n    leader (str): 一个字符串 ('Y' 或 'N')，表示学生是否是班长。\n    west (str): 一个字符串 ('Y' 或 'N')，表示学生是否来自西部省份。\n    papers (int): 一个整数，表示学生发表的研究论文数量。\n\n    返回:\n    int: 学生有资格获得的总奖学金金额。\n\n    示例:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "fr": "\n    Si la moyenne finale est supérieure à 80 et qu'un ou plusieurs articles sont publiés, une bourse de 8000 sera ajoutée.\n    Si la moyenne finale est supérieure à 85 points et que l'évaluation de la classe est supérieure à 80 points, la bourse sera augmentée de 4000 points.\n    Si la moyenne finale est supérieure à 90 points, la bourse sera augmentée de 2000.\n    Si la moyenne finale est supérieure à 85 et que l'étudiant est de la région occidentale, la bourse sera augmentée de 1000.\n    Si l'évaluation finale de la classe est supérieure à 80 points et que le chef de classe est le chef de classe, la bourse sera augmentée de 850 points.\n\n    Paramètres:\n    grades (list of int): Une liste de deux éléments contenant les notes académiques de l'étudiant [moyenne de fin de trimestre, évaluation de la classe].\n    leader (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est un chef de classe.\n    west (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est d'une province occidentale.\n    papers (int): Un entier représentant le nombre d'articles de recherche publiés par l'étudiant.\n\n    Retourne:\n    int: Le montant total de la bourse auquel l'étudiant est éligible.\n\n    Exemples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    ", "de": "\n    Wenn die endgültige Durchschnittsnote größer als 80 ist und ein oder mehrere Arbeiten veröffentlicht wurden, wird ein Stipendium von 8000 hinzugefügt\n    Wenn die endgültige Durchschnittsnote größer als 85 Punkte ist und die Klassenbewertung größer als 80 Punkte ist, wird das Stipendium um 4000 Punkte erhöht\n    Wenn die endgültige Durchschnittsnote größer als 90 Punkte ist, wird das Stipendium um 2000 erhöht\n    Wenn die endgültige Durchschnittsnote größer als 85 ist und der Student aus der westlichen Region stammt, wird das Stipendium um 1000 erhöht\n    Wenn die endgültige Bewertung der Klasse größer als 80 Punkte ist und der Klassensprecher der Klassensprecher ist, wird das Stipendium um 850 erhöht\n\n    Parameter:\n    grades (list of int): Eine Liste mit zwei Elementen, die die akademischen Noten des Studenten enthält [Ende der Semester-Durchschnitt, Klassenbewertung].\n    leader (str): Ein String ('Y' oder 'N'), der angibt, ob der Student Klassensprecher ist.\n    west (str): Ein String ('Y' oder 'N'), der angibt, ob der Student aus einer westlichen Provinz stammt.\n    papers (int): Eine ganze Zahl, die die Anzahl der vom Studenten veröffentlichten Forschungsarbeiten darstellt.\n\n    Rückgabe:\n    int: Der Gesamtbetrag des Stipendiums, für den der Student berechtigt ist.\n\n    Beispiele:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "ha": "\n    Idan matsakaicin maki na ƙarshe ya fi 80 kuma an buga takardu ɗaya ko fiye, za a ƙara tallafin karatu na 8000\n    Idan matsakaicin maki na ƙarshe ya fi maki 85 kuma kimantawa na aji ya fi maki 80, za a ƙara tallafin karatu da maki 4000\n    Idan matsakaicin maki na ƙarshe ya fi maki 90, za a ƙara tallafin karatu da 2000\n    Idan matsakaicin maki na ƙarshe ya fi 85 kuma ɗalibin daga yankin yamma ne, za a ƙara tallafin karatu da 1000\n    Idan kimantawa na ƙarshe na aji ya fi maki 80 kuma shugaban aji ne, za a ƙara tallafin karatu da 850\n\n    Parameters:\n    grades (list of int): Jerin abubuwa guda biyu da ke ɗauke da maki na ɗalibi [matsakaicin ƙarshen zangon, kimantawa na aji].\n    leader (str): Wani kirtani ('Y' ko 'N') da ke nuna idan ɗalibin shugaban aji ne.\n    west (str): Wani kirtani ('Y' ko 'N') da ke nuna idan ɗalibin daga lardin yamma ne.\n    papers (int): Wani lamba da ke wakiltar adadin takardun bincike da ɗalibin ya buga.\n\n    Returns:\n    int: Jimillar adadin tallafin karatu da ɗalibin ya cancanci samu.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "hi": "\n    यदि अंतिम औसत स्कोर 80 से अधिक है और एक या अधिक पेपर प्रकाशित होते हैं, तो 8000 की छात्रवृत्ति जोड़ी जाएगी\n    यदि अंतिम औसत स्कोर 85 अंकों से अधिक है और कक्षा का मूल्यांकन 80 अंकों से अधिक है, तो छात्रवृत्ति 4000 अंकों से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 90 अंकों से अधिक है, तो छात्रवृत्ति 2000 से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 85 से अधिक है और छात्र पश्चिमी क्षेत्र से है, तो छात्रवृत्ति 1000 से बढ़ाई जाएगी\n    यदि कक्षा का अंतिम मूल्यांकन 80 अंकों से अधिक है और कक्षा का नेता कक्षा का नेता है, तो छात्रवृत्ति 850 से बढ़ाई जाएगी\n\n    Parameters:\n    grades (list of int): एक दो-तत्वों की सूची जिसमें छात्र के शैक्षणिक ग्रेड [अवधि के अंत का औसत, कक्षा का मूल्यांकन] शामिल हैं।\n    leader (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र कक्षा का नेता है या नहीं।\n    west (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र पश्चिमी प्रांत से है या नहीं।\n    papers (int): एक पूर्णांक जो छात्र द्वारा प्रकाशित शोध पत्रों की संख्या को दर्शाता है।\n\n    Returns:\n    int: कुल छात्रवृत्ति राशि जिसके लिए छात्र पात्र है।\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "hu": "\n    Ha a végső átlagpontszám nagyobb, mint 80, és egy vagy több dolgozat megjelent, 8000 ösztöndíj kerül hozzáadásra\n    Ha a végső átlagpontszám nagyobb, mint 85 pont, és az osztályértékelés nagyobb, mint 80 pont, az ösztöndíj 4000 ponttal növekszik\n    Ha a végső átlagpontszám nagyobb, mint 90 pont, az ösztöndíj 2000-rel növekszik\n    Ha a végső átlagpontszám nagyobb, mint 85, és a diák a nyugati régióból származik, az ösztöndíj 1000-rel növekszik\n    Ha az osztály végső értékelése nagyobb, mint 80 pont, és az osztályvezető az osztályvezető, az ösztöndíj 850 ponttal növekszik\n\n    Paraméterek:\n    grades (list of int): Egy két elemből álló lista, amely tartalmazza a diák tanulmányi eredményeit [félév végi átlag, osztályértékelés].\n    leader (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák osztályvezető-e.\n    west (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák nyugati tartományból származik-e.\n    papers (int): Egy egész szám, amely a diák által publikált kutatási dolgozatok számát jelzi.\n\n    Visszatér:\n    int: Az összes ösztöndíj összege, amelyre a diák jogosult.\n\n    Példák:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "es": "\n    Si la puntuación promedio final es mayor que 80 y se publican uno o más artículos, se añadirá una beca de 8000\n    Si la puntuación promedio final es mayor que 85 puntos y la evaluación de la clase es mayor que 80 puntos, la beca se incrementará en 4000 puntos\n    Si la puntuación promedio final es mayor que 90 puntos, la beca se incrementará en 2000\n    Si la puntuación promedio final es mayor que 85 y el estudiante es de la región occidental, la beca se incrementará en 1000\n    Si la evaluación final de la clase es mayor que 80 puntos y el líder de la clase es el líder de la clase, la beca se incrementará en 850 puntos\n\n    Parámetros:\n    grades (list of int): Una lista de dos elementos que contiene las calificaciones académicas del estudiante [promedio de fin de curso, evaluación de la clase].\n    leader (str): Una cadena ('Y' o 'N') que indica si el estudiante es líder de clase.\n    west (str): Una cadena ('Y' o 'N') que indica si el estudiante es de una provincia occidental.\n    papers (int): Un entero que representa el número de artículos de investigación publicados por el estudiante.\n\n    Devuelve:\n    int: La cantidad total de beca para la que el estudiante es elegible.\n\n    Ejemplos:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "arb": "\n    إذا كانت الدرجة النهائية المتوسطة أكبر من 80 وتم نشر ورقة بحثية واحدة أو أكثر، سيتم إضافة منحة دراسية بقيمة 8000\n    إذا كانت الدرجة النهائية المتوسطة أكبر من 85 نقطة وكان تقييم الفصل أكبر من 80 نقطة، سيتم زيادة المنحة الدراسية بمقدار 4000 نقطة\n    إذا كانت الدرجة النهائية المتوسطة أكبر من 90 نقطة، سيتم زيادة المنحة الدراسية بمقدار 2000\n    إذا كانت الدرجة النهائية المتوسطة أكبر من 85 وكان الطالب من المنطقة الغربية، سيتم زيادة المنحة الدراسية بمقدار 1000\n    إذا كان التقييم النهائي للفصل أكبر من 80 نقطة وكان قائد الفصل هو قائد الفصل، سيتم زيادة المنحة الدراسية بمقدار 850 نقطة\n\n    Parameters:\n    grades (list of int): قائمة تحتوي على درجتين أكاديميتين للطالب [متوسط نهاية الفصل، تقييم الفصل].\n    leader (str): سلسلة نصية ('Y' أو 'N') تشير إلى ما إذا كان الطالب قائد الفصل.\n    west (str): سلسلة نصية ('Y' أو 'N') تشير إلى ما إذا كان الطالب من مقاطعة غربية.\n    papers (int): عدد صحيح يمثل عدد الأبحاث المنشورة من قبل الطالب.\n\n   يعيد:\n    int: إجمالي مبلغ المنحة الدراسية الذي يكون الطالب مؤهلاً للحصول عليه.\n\n    امثله:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "sw": "Ikiwa alama ya wastani ya mwisho ni zaidi ya 80 na moja au zaidi ya karatasi zimechapishwa, udhamini wa 8000 utaongezwa  \nIkiwa alama ya wastani ya mwisho ni zaidi ya 80 na karatasi moja au zaidi zimechapishwa, udhamini wa 8000 utaongezwa \nIkiwa alama ya wastani ya mwisho ni zaidi ya pointi 85 na tathmini ya darasa ni zaidi ya pointi 80, udhamini utaongezwa kwa pointi 4000 \nIkiwa alama ya wastani ya mwisho ni zaidi ya pointi 90, udhamini utaongezwa kwa 2000  \nIkiwa alama ya wastani ya mwisho ni zaidi ya 85 na mwanafunzi anatoka eneo la magharibi, udhamini utaongezwa kwa 1000  \nIkiwa tathmini ya mwisho ya darasa ni zaidi ya pointi 80 na kiongozi wa darasa ni kiongozi wa darasa, udhamini utaongezwa kwa pointi 850\n\nParameters:  \ngrades (list of int): Orodha ya vipengele viwili inayoonyesha alama za kitaaluma za mwanafunzi [mwisho wa wastani wa muhula, tathmini ya darasa].  \nleader (str): Kamba ('Y' au 'N') inayoonyesha ikiwa mwanafunzi ni kiongozi wa darasa.  \nwest (str): Kamba ('Y' au 'N') inayoonyesha ikiwa mwanafunzi anatoka mkoa wa magharibi.  \npapers (int): Nambari inayoonyesha idadi ya karatasi za utafiti zilizochapishwa na mwanafunzi.\n\nInarejesha:  \nint: Kiasi cha jumla cha udhamini ambacho mwanafunzi anastahili.\n\nMifano:  \n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)  \n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)  \n9000", "tr": "Eğer nihai ortalama puan 80'den büyükse ve bir veya daha fazla makale yayımlanmışsa, 8000 burs eklenecektir\nEğer nihai ortalama puan 85 puandan büyükse ve sınıf değerlendirmesi 80 puandan büyükse, burs 4000 puan artırılacaktır\nEğer nihai ortalama puan 90 puandan büyükse, burs 2000 artırılacaktır\nEğer nihai ortalama puan 85'ten büyükse ve öğrenci batı bölgesindense, burs 1000 artırılacaktır\nEğer sınıfın nihai değerlendirmesi 80 puandan büyükse ve sınıf lideri sınıf lideriyse, burs 850 artırılacaktır\n\nParametreler:\ngrades (list of int): Öğrencinin akademik notlarını içeren iki elemanlı bir liste [dönem sonu ortalaması, sınıf değerlendirmesi].\nleader (str): Öğrencinin sınıf lideri olup olmadığını belirten bir dize ('Y' veya 'N').\nwest (str): Öğrencinin batı bölgesinden olup olmadığını belirten bir dize ('Y' veya 'N').\npapers (int): Öğrencinin yayımladığı araştırma makalelerinin sayısını temsil eden bir tam sayı.\n\nDöndürülenler:\nint: Öğrencinin hak kazandığı toplam burs miktarı.\n\nÖrnekler:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000", "vi": "Nếu điểm trung bình cuối kỳ lớn hơn 80 và có một hoặc nhiều bài báo được xuất bản, học bổng sẽ được cộng thêm 8000  \nNếu điểm trung bình cuối cùng lớn hơn 80 và có một hoặc nhiều bài báo được xuất bản, học bổng 8000 sẽ được thêm vào   \nNếu điểm trung bình cuối cùng lớn hơn 85 điểm và đánh giá lớp lớn hơn 80 điểm, học bổng sẽ được tăng thêm 4000 điểm  \nNếu điểm trung bình cuối cùng lớn hơn 90 điểm, học bổng sẽ được tăng thêm 2000  \nNếu điểm trung bình cuối cùng lớn hơn 85 và học sinh đến từ khu vực miền Tây, học bổng sẽ được tăng thêm 1000   \nNếu đánh giá cuối cùng của lớp lớn hơn 80 điểm và lớp trưởng là lớp trưởng, học bổng sẽ được tăng thêm 850 điểm  \n\nParameters:  \ngrades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].  \ngrades (list of int): Danh sách hai phần tử chứa điểm học tập của học sinh [điểm trung bình cuối kỳ, đánh giá lớp]. \nleader (str): Một chuỗi ('Y' hoặc 'N') chỉ ra nếu học sinh là lớp trưởng.   \nwest (str): Một chuỗi ('Y' hoặc 'N') chỉ ra nếu học sinh đến từ tỉnh miền Tây.  \npapers (int): Một số nguyên đại diện cho số lượng bài báo nghiên cứu được học sinh xuất bản.  \n\nTrả về: \nint: Tổng số tiền học bổng mà học sinh đủ điều kiện nhận.  \n\nVí dụ:  \n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)  \n4850  \n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)  \n9000  ", "id": "Jika nilai rata-rata akhir lebih dari 80 dan satu atau lebih makalah diterbitkan, beasiswa sebesar 8000 akan ditambahkan  \nJika nilai rata-rata akhir lebih dari 85 poin dan evaluasi kelas lebih dari 80 poin, beasiswa akan ditingkatkan sebesar 4000 poin  \nJika nilai rata-rata akhir lebih dari 90 poin, beasiswa akan ditingkatkan sebesar 2000  \nJika nilai rata-rata akhir lebih dari 85 dan siswa berasal dari wilayah barat, beasiswa akan ditingkatkan sebesar 1000  \nJika penilaian akhir kelas lebih dari 80 poin dan pemimpin kelas adalah pemimpin kelas, beasiswa akan ditingkatkan sebesar 850 poin  \n\nParameter:  \ngrades (list of int): Daftar dua elemen yang berisi nilai akademik siswa [rata-rata akhir semester, evaluasi kelas].  \nleader (str): Sebuah string ('Y' atau 'N') yang menunjukkan apakah siswa adalah pemimpin kelas.  \nwest (str): Sebuah string ('Y' atau 'N') yang menunjukkan apakah siswa berasal dari provinsi barat.  \npapers (int): Sebuah bilangan bulat yang mewakili jumlah makalah penelitian yang diterbitkan oleh siswa.  \n\nMengembalikan:  \nint: Jumlah total beasiswa yang berhak diterima siswa.  \n\nContoh:  \n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)  \n4850  \n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)  \n9000  ", "ja": "    最終平均スコアが80を超え、1つ以上の論文が発表されている場合、奨学金として8000が追加されます\n    最終平均スコアが85点を超え、クラス評価が80点を超える場合、奨学金は4000ポイント増加します\n    最終平均スコアが90点を超える場合、奨学金は2000増加します\n    最終平均スコアが85を超え、学生が西部地域出身の場合、奨学金は1000増加します\n    クラスの最終評価が80点を超え、クラスリーダーがクラスリーダーである場合、奨学金は850ポイント増加します\n\n    パラメータ:\n    grades (list of int): 学生の学業成績を含む2要素のリスト [学期末平均, クラス評価]。\n    leader (str): 学生がクラスリーダーであるかを示す文字列 ('Y' または 'N')。\n    west (str): 学生が西部地域出身であるかを示す文字列 ('Y' または 'N')。\n    papers (int): 学生が発表した研究論文の数を表す整数。\n\n    戻り値:\n    int: 学生が受け取る資格のある奨学金の総額。\n\n    例:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "ko": "최종 평균 점수가 80점 이상이고 하나 이상의 논문이 발표된 경우 장학금 8000이 추가됩니다.최종 평균 점수가 80보다 크고 하나 이상의 논문이 출판된 경우, 8000의 장학금이 추가됩니다  \n\\n최종 평균 점수가 85점 이상이고 수업 평가가 80점 이상인 경우, 장학금이 4000점 증가합니다  \n\n최종 평균 점수가 90점 이상인 경우, 장학금이 2000 증가합니다  \n\n최종 평균 점수가 85보다 크고 학생이 서부 지역 출신인 경우, 장학금이 1000 증가합니다  \n\n수업의 최종 평가가 80점 이상이고 반장이 반장인 경우, 장학금이 850점 증가합니다  \n\nParameters:   \ngrades (list of int): 학생의 학업 성적을 포함하는 두 요소 리스트 [학기말 평균, 수업 평가].  \n\nleader (str): 학생이 반장인지 여부를 나타내는 문자열 ('Y' 또는 'N').  \n\nwest (str): 학생이 서부 지방 출신인지 여부를 나타내는 문자열 ('Y' 또는 'N').  \n\npapers (int): 학생이 출판한 연구 논문의 수를 나타내는 정수.  \n\nReturns:  \n\nint: 학생이 받을 수 있는 총 장학금 금액.  \n\nExamples:  \n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)  \n4850  \n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)  \n9000  ", "ml": "    അന്തിമ ശരാശരി മാർക്ക് 80-ൽ കൂടുതലാണെങ്കിൽ, ഒരു പേപ്പർ പ്രസിദ്ധീകരിച്ചാലും 8000 രൂപയുടെ സ്കോളർഷിപ്പ് ചേർക്കും\n    അന്തിമ ശരാശരി മാർക്ക് 85 പോയിന്റ്-ൽ കൂടുതലാണെങ്കിൽ, ക്ലാസ് മൂല്യനിർണ്ണയം 80 പോയിന്റ്-ൽ കൂടുതലാണെങ്കിൽ, സ്കോളർഷിപ്പ് 4000 പോയിന്റ് വർദ്ധിപ്പിക്കും\n    അന്തിമ ശരാശരി മാർക്ക് 90 പോയിന്റ്-ൽ കൂടുതലാണെങ്കിൽ, സ്കോളർഷിപ്പ് 2000 വർദ്ധിപ്പിക്കും\n    അന്തിമ ശരാശരി മാർക്ക് 85-ൽ കൂടുതലാണെങ്കിൽ, വിദ്യാർത്ഥി പടിഞ്ഞാറൻ പ്രദേശത്തുനിന്നുള്ളവനാണെങ്കിൽ, സ്കോളർഷിപ്പ് 1000 വർദ്ധിപ്പിക്കും\n    ക്ലാസിന്റെ അന്തിമ മൂല്യനിർണ്ണയം 80 പോയിന്റ്-ൽ കൂടുതലാണെങ്കിൽ, ക്ലാസ് ലീഡർ ക്ലാസ് ലീഡറാണെങ്കിൽ, സ്കോളർഷിപ്പ് 850 വർദ്ധിപ്പിക്കും\n\n    Parameters:\n    grades (list of int): വിദ്യാർത്ഥിയുടെ അക്കാദമിക് ഗ്രേഡുകൾ [ടേം അവസാന ശരാശരി, ക്ലാസ് മൂല്യനിർണ്ണയം] അടങ്ങിയ രണ്ട് ഘടകങ്ങളുടെ പട്ടിക.\n    leader (str): വിദ്യാർത്ഥി ക്ലാസ് ലീഡറാണോ അല്ലയോ എന്ന് സൂചിപ്പിക്കുന്ന ഒരു സ്ട്രിംഗ് ('Y' അല്ലെങ്കിൽ 'N').\n    west (str): വിദ്യാർത്ഥി പടിഞ്ഞാറൻ പ്രവിശ്യയിൽ നിന്നുള്ളവനാണോ അല്ലയോ എന്ന് സൂചിപ്പിക്കുന്ന ഒരു സ്ട്രിംഗ് ('Y' അല്ലെങ്കിൽ 'N').\n    papers (int): വിദ്യാർത്ഥി പ്രസിദ്ധീകരിച്ച ഗവേഷണ പ്രബന്ധങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\n    Returns:\n    int: വിദ്യാർത്ഥിക്ക് അർഹമായ മൊത്തം സ്കോളർഷിപ്പ് തുക.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000", "fa": "    اگر میانگین نهایی بیشتر از 80 باشد و یک یا چند مقاله منتشر شده باشد، یک بورسیه 8000 اضافه خواهد شد\n    اگر میانگین نهایی بیشتر از 85 امتیاز باشد و ارزیابی کلاس بیشتر از 80 امتیاز باشد، بورسیه به میزان 4000 امتیاز افزایش می‌یابد\n    اگر میانگین نهایی بیشتر از 90 امتیاز باشد، بورسیه به میزان 2000 افزایش می‌یابد\n    اگر میانگین نهایی بیشتر از 85 باشد و دانشجو از منطقه غربی باشد، بورسیه به میزان 1000 افزایش می‌یابد\n    اگر ارزیابی نهایی کلاس بیشتر از 80 امتیاز باشد و رهبر کلاس رهبر کلاس باشد، بورسیه به میزان 850 افزایش می‌یابد\n\n    پارامترها:\n    grades (list of int): یک لیست دو عنصری که شامل نمرات تحصیلی دانشجو [میانگین پایان ترم، ارزیابی کلاس] است.\n    leader (str): یک رشته ('Y' یا 'N') که نشان می‌دهد آیا دانشجو رهبر کلاس است یا خیر.\n    west (str): یک رشته ('Y' یا 'N') که نشان می‌دهد آیا دانشجو از استان غربی است یا خیر.\n    papers (int): یک عدد صحیح که نمایانگر تعداد مقالات پژوهشی منتشر شده توسط دانشجو است.\n\n    بازگشت:\n    int: مجموع مبلغ بورسیه‌ای که دانشجو واجد شرایط آن است.\n\n    مثال‌ها:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000"}}
{"task_id": "Python/14", "prompt": {"en": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "sq": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verifikoni saktësinë e një numri të dhënë ISBN dhe korrigjojeni atë nëse është e nevojshme.\n\n    Funksioni kontrollon numrin e dhënë ISBN sipas llogaritjes standarde të kontrollit të ISBN.\n    Nëse kontrolli është i saktë, funksioni kthen \"Right\". Nëse kontrolli është i pasaktë,\n    funksioni kthen numrin e korrigjuar ISBN.\n\n    Argumentet:\n    isbn: Një varg që përfaqëson numrin ISBN që do të verifikohet. Formati duhet të jetë 'x-xxx-xxxxx-x',\n          ku 'x' është një shifër, dhe 'x' i fundit mund të jetë gjithashtu 'X' që përfaqëson shifrën e kontrollit.\n\n    Kthen:\n    Një varg që është ose \"Right\" nëse kontrolli i ISBN është i saktë, ose numri i korrigjuar ISBN\n    në të njëjtin format si hyrja nëse kontrolli është i pasaktë.\n\n    Shembuj:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "hy": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Ստուգել տրված ISBN համարի ճշգրտությունը և անհրաժեշտության դեպքում ուղղել այն։\n\n    Ֆունկցիան ստուգում է տրամադրված ISBN համարը՝ համաձայն ISBN ստանդարտի ստուգման գումարի հաշվարկի։\n    Եթե ստուգման գումարը ճիշտ է, ֆունկցիան վերադարձնում է \"Right\": Եթե ստուգման գումարը սխալ է,\n    ֆունկցիան վերադարձնում է ուղղված ISBN համարը։\n\n    Արգումենտներ:\n    isbn: Տող, որը ներկայացնում է ստուգվող ISBN համարը։ Ֆորմատը պետք է լինի 'x-xxx-xxxxx-x',\n          որտեղ 'x'-ը թիվ է, իսկ վերջին 'x'-ը կարող է լինել նաև 'X', որը ներկայացնում է ստուգման գումարի թիվը։\n\n    Վերադարձնում է:\n    Տող, որը կամ \"Right\" է, եթե ISBN ստուգման գումարը ճիշտ է, կամ ուղղված ISBN համարը\n    նույն ֆորմատով, ինչ մուտքագրվածը, եթե ստուգման գումարը սխալ է։\n\n    Օրինակներ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "bn": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করুন এবং প্রয়োজন হলে এটি সংশোধন করুন।\n\n    ফাংশনটি প্রদত্ত ISBN নম্বরকে ISBN মানদণ্ডের চেকসাম গণনার সাথে মিলিয়ে দেখে।\n    যদি চেকসাম সঠিক হয়, ফাংশনটি \"Right\" ফেরত দেয়। যদি চেকসাম ভুল হয়,\n    ফাংশনটি সংশোধিত ISBN নম্বর ফেরত দেয়।\n\n    Args:\n    isbn: যাচাই করার জন্য একটি স্ট্রিং যা ISBN নম্বরকে উপস্থাপন করে। ফরম্যাটটি হওয়া উচিত 'x-xxx-xxxxx-x',\n          যেখানে 'x' একটি সংখ্যা, এবং শেষের 'x' ও 'X' হতে পারে যা চেকসাম সংখ্যা উপস্থাপন করে।\n\n    Returns:\n    একটি স্ট্রিং যা হয় \"Right\" যদি ISBN চেকসাম সঠিক হয়, অথবা সংশোধিত ISBN নম্বর\n    ইনপুটের একই ফরম্যাটে যদি চেকসাম ভুল হয়।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "bg": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Проверете коректността на даден ISBN номер и го коригирайте, ако е необходимо.\n\n    Функцията проверява предоставения ISBN номер спрямо стандартното изчисление на контролна сума за ISBN.\n    Ако контролната сума е правилна, функцията връща \"Right\". Ако контролната сума е неправилна,\n    функцията връща коригирания ISBN номер.\n\n    Аргументи:\n    isbn: Низ, представляващ ISBN номера, който трябва да бъде проверен. Форматът трябва да бъде 'x-xxx-xxxxx-x',\n          където 'x' е цифра, а последният 'x' може също да бъде 'X', представляващ контролния знак.\n\n    Връща:\n    Низ, който е или \"Right\", ако контролната сума на ISBN е правилна, или коригирания ISBN номер\n    в същия формат като входа, ако контролната сума е неправилна.\n\n    Примери:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "zh": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    验证给定的ISBN号码的正确性，并在必要时进行更正。\n\n    该函数根据ISBN标准校验和计算检查提供的ISBN号码。\n    如果校验和正确，函数返回 \"Right\"。如果校验和不正确，\n    函数返回更正后的ISBN号码。\n\n    参数:\n    isbn: 表示要验证的ISBN号码的字符串。格式应为 'x-xxx-xxxxx-x'，\n          其中 'x' 是一个数字，最后一个 'x' 也可以是代表校验和数字的 'X'。\n\n    返回:\n    一个字符串，如果ISBN校验和正确，则为 \"Right\"；如果校验和不正确，则为\n    与输入格式相同的更正后的ISBN号码。\n\n    示例:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "fr": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Vérifie la validité d'un numéro ISBN donné et le corrige si nécessaire.\n\n    La fonction vérifie le numéro ISBN fourni en utilisant le calcul de la somme de contrôle standard de l'ISBN.\n    Si la somme de contrôle est correcte, la fonction retourne \"Right\". Si la somme de contrôle est incorrecte,\n    la fonction retourne le numéro ISBN corrigé.\n\n    Args:\n    isbn: Une chaîne de caractères représentant le numéro ISBN à vérifier. Le format doit être 'x-xxx-xxxxx-x',\n          où 'x' est un chiffre, et le dernier 'x' peut également être 'X' représentant le chiffre de contrôle.\n\n    Returns:\n    Une chaîne de caractères qui est soit \"Right\" si la somme de contrôle de l'ISBN est correcte, soit le numéro ISBN corrigé\n    dans le même format que l'entrée si la somme de contrôle est incorrecte.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "de": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Überprüfen Sie die Korrektheit einer gegebenen ISBN-Nummer und korrigieren Sie sie bei Bedarf.\n\n    Die Funktion überprüft die angegebene ISBN-Nummer anhand der ISBN-Standard-Prüfziffernberechnung.\n    Wenn die Prüfziffer korrekt ist, gibt die Funktion \"Right\" zurück. Wenn die Prüfziffer falsch ist,\n    gibt die Funktion die korrigierte ISBN-Nummer zurück.\n\n    Argumente:\n    isbn: Ein String, der die zu überprüfende ISBN-Nummer darstellt. Das Format sollte 'x-xxx-xxxxx-x' sein,\n          wobei 'x' eine Ziffer ist und das letzte 'x' auch 'X' sein könnte, was die Prüfziffer darstellt.\n\n    Rückgaben:\n    Ein String, der entweder \"Right\" ist, wenn die ISBN-Prüfziffer korrekt ist, oder die korrigierte ISBN-Nummer\n    im gleichen Format wie die Eingabe, wenn die Prüfziffer falsch ist.\n\n    Beispiele:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "ha": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Tabbatar da daidaiton lambar ISBN da aka bayar kuma gyara ta idan ya zama dole.\n\n    Aikin yana duba lambar ISBN da aka bayar daidai da lissafin duba daidaiton ISBN.\n    Idan lissafin duba ya yi daidai, aikin yana dawo da \"Right\". Idan lissafin duba bai yi daidai ba,\n    aikin yana dawo da lambar ISBN da aka gyara.\n\n    Args:\n    isbn: Wani kirtani da ke wakiltar lambar ISBN da za a tabbatar. Tsarin ya kamata ya zama 'x-xxx-xxxxx-x',\n          inda 'x' yake nuni da lamba, kuma 'x' na ƙarshe na iya zama 'X' wanda ke wakiltar lambar duba.\n\n    Returns:\n    Wani kirtani wanda ko dai \"Right\" idan lissafin duba ISBN ya yi daidai, ko kuma lambar ISBN da aka gyara\n    a cikin tsarin iri ɗaya da shigarwar idan lissafin duba bai yi daidai ba.\n\n    Misalai:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "hi": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    दिए गए ISBN नंबर की शुद्धता की जाँच करें और यदि आवश्यक हो तो इसे सही करें।\n\n    यह फ़ंक्शन प्रदान किए गए ISBN नंबर को ISBN मानक चेकसम गणना के विरुद्ध जाँचता है।\n    यदि चेकसम सही है, तो फ़ंक्शन \"Right\" लौटाता है। यदि चेकसम गलत है,\n    तो फ़ंक्शन सही किया गया ISBN नंबर लौटाता है।\n\n    Args:\n    isbn: एक स्ट्रिंग जो सत्यापित किए जाने वाले ISBN नंबर का प्रतिनिधित्व करती है। प्रारूप 'x-xxx-xxxxx-x' होना चाहिए,\n          जहाँ 'x' एक अंक है, और अंतिम 'x' चेकसम अंक का प्रतिनिधित्व करने वाला 'X' भी हो सकता है।\n\n    Returns:\n    एक स्ट्रिंग जो या तो \"Right\" है यदि ISBN चेकसम सही है, या यदि चेकसम गलत है तो इनपुट के समान प्रारूप में सही किया गया ISBN नंबर है।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "hu": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Ellenőrzi egy adott ISBN szám helyességét, és szükség esetén kijavítja.\n\n    A függvény ellenőrzi a megadott ISBN számot az ISBN szabványos ellenőrző összeg számítása alapján.\n    Ha az ellenőrző összeg helyes, a függvény \"Right\" értéket ad vissza. Ha az ellenőrző összeg hibás,\n    a függvény a javított ISBN számot adja vissza.\n\n    Paraméterek:\n    isbn: Egy string, amely az ellenőrizendő ISBN számot képviseli. A formátumnak 'x-xxx-xxxxx-x' kell lennie,\n          ahol 'x' egy számjegy, és az utolsó 'x' lehet 'X' is, amely az ellenőrző számjegyet képviseli.\n\n    Visszatérési érték:\n    Egy string, amely \"Right\", ha az ISBN ellenőrző összege helyes, vagy a javított ISBN szám\n    ugyanabban a formátumban, mint a bemenet, ha az ellenőrző összeg hibás.\n\n    Példák:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "es": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verifica la corrección de un número ISBN dado y corrígelo si es necesario.\n\n    La función verifica el número ISBN proporcionado contra el cálculo estándar de suma de verificación de ISBN.\n    Si la suma de verificación es correcta, la función devuelve \"Right\". Si la suma de verificación es incorrecta,\n    la función devuelve el número ISBN corregido.\n\n    Argumentos:\n    isbn: Una cadena que representa el número ISBN a verificar. El formato debe ser 'x-xxx-xxxxx-x',\n          donde 'x' es un dígito, y el último 'x' también podría ser 'X' representando el dígito de suma de verificación.\n\n    Devuelve:\n    Una cadena que es \"Right\" si la suma de verificación del ISBN es correcta, o el número ISBN corregido\n    en el mismo formato que la entrada si la suma de verificación es incorrecta.\n\n    Ejemplos:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "arb": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    التحقق من صحة رقم ISBN المعطى وتصحيحه إذا لزم الأمر.\n\n    تقوم الدالة بالتحقق من رقم ISBN المقدم وفقًا لحساب التحقق القياسي لـ ISBN.\n    إذا كان حساب التحقق صحيحًا، تعيد الدالة \"Right\". إذا كان حساب التحقق غير صحيح،\n    تعيد الدالة رقم ISBN المصحح.\n\n    يعيدالحجج:\n    isbn: سلسلة تمثل رقم ISBN المراد التحقق منه. يجب أن يكون التنسيق 'x-xxx-xxxxx-x',\n          حيث 'x' هو رقم، ويمكن أن يكون 'x' الأخير أيضًا 'X' لتمثيل رقم التحقق.\n\n    يعيد:\n    سلسلة تكون إما \"Right\" إذا كان حساب التحقق لـ ISBN صحيحًا، أو رقم ISBN المصحح\n    بنفس تنسيق الإدخال إذا كان حساب التحقق غير صحيح.\n\n    امثله:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "sw": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Thibitisha usahihi wa nambari ya ISBN iliyotolewa na uirekebishe ikiwa ni lazima.\n\n    Kazi hii inakagua nambari ya ISBN iliyotolewa dhidi ya hesabu ya kawaida ya checksum ya ISBN.\n    Ikiwa checksum ni sahihi, kazi inarudisha \"Right\". Ikiwa checksum si sahihi,\n    kazi inarudisha nambari ya ISBN iliyorekebishwa.\n\n    Hoja:\n    isbn: Kamba inayowakilisha nambari ya ISBN inayopaswa kuthibitishwa. Muundo unapaswa kuwa 'x-xxx-xxxxx-x',\n          ambapo 'x' ni tarakimu, na 'x' ya mwisho inaweza pia kuwa 'X' inayowakilisha tarakimu ya checksum.\n\n    Inarejesha:\n    Kamba ambayo ni \"Right\" ikiwa checksum ya ISBN ni sahihi, au nambari ya ISBN iliyorekebishwa\n    katika muundo sawa na pembejeo ikiwa checksum si sahihi.\n\n    Mifano:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "tr": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verilen ISBN numarasının doğruluğunu kontrol edin ve gerekirse düzeltin.\n\n    Fonksiyon, sağlanan ISBN numarasını ISBN standart kontrol toplamı hesaplamasına göre kontrol eder.\n    Eğer kontrol toplamı doğruysa, fonksiyon \"Right\" döndürür. Eğer kontrol toplamı yanlışsa,\n    fonksiyon düzeltilmiş ISBN numarasını döndürür.\n\n    Argümanlar:\n    isbn: Doğrulanacak ISBN numarasını temsil eden bir string. Format 'x-xxx-xxxxx-x' olmalıdır,\n          burada 'x' bir rakamdır ve son 'x' kontrol toplamı rakamını temsil eden 'X' de olabilir.\n\n    Döndürür:\n    Kontrol toplamı doğruysa \"Right\" veya kontrol toplamı yanlışsa girişle aynı formatta düzeltilmiş\n    ISBN numarasını döndüren bir string.\n\n    Örnekler:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "vi": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Xác minh tính đúng đắn của một số ISBN đã cho và sửa nó nếu cần thiết.\n\n    Hàm kiểm tra số ISBN được cung cấp dựa trên tính toán tổng kiểm tra tiêu chuẩn ISBN.\n    Nếu tổng kiểm tra đúng, hàm trả về \"Right\". Nếu tổng kiểm tra sai,\n    hàm trả về số ISBN đã được sửa.\n\n    Tham số:\n    isbn: Một chuỗi đại diện cho số ISBN cần được xác minh. Định dạng nên là 'x-xxx-xxxxx-x',\n          trong đó 'x' là một chữ số, và 'x' cuối cùng cũng có thể là 'X' đại diện cho chữ số tổng kiểm tra.\n\n    Trả về:\n    Một chuỗi là \"Right\" nếu tổng kiểm tra ISBN đúng, hoặc số ISBN đã được sửa\n    trong cùng định dạng như đầu vào nếu tổng kiểm tra sai.\n\n    Ví dụ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "id": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verifikasi kebenaran nomor ISBN yang diberikan dan koreksi jika perlu.\n\n    Fungsi ini memeriksa nomor ISBN yang diberikan berdasarkan perhitungan checksum standar ISBN.\n    Jika checksum benar, fungsi mengembalikan \"Right\". Jika checksum salah,\n    fungsi mengembalikan nomor ISBN yang telah dikoreksi.\n\n    Argumen:\n    isbn: Sebuah string yang mewakili nomor ISBN yang akan diverifikasi. Formatnya harus 'x-xxx-xxxxx-x',\n          di mana 'x' adalah digit, dan 'x' terakhir juga bisa 'X' yang mewakili digit checksum.\n\n    Mengembalikan:\n    Sebuah string yang berupa \"Right\" jika checksum ISBN benar, atau nomor ISBN yang telah dikoreksi\n    dalam format yang sama seperti input jika checksum salah.\n\n    Contoh:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "ja": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    指定されたISBN番号の正確性を確認し、必要に応じて修正します。\n\n    関数は、提供されたISBN番号をISBN標準のチェックサム計算に基づいて確認します。\n    チェックサムが正しい場合、関数は \"Right\" を返します。チェックサムが間違っている場合、\n    関数は修正されたISBN番号を返します。\n\n    引数:\n    isbn: 確認するISBN番号を表す文字列。形式は 'x-xxx-xxxxx-x' で、\n          'x' は数字を表し、最後の 'x' はチェックサムの数字を表す 'X' である可能性もあります。\n\n    戻り値:\n    ISBNチェックサムが正しい場合は \"Right\"、チェックサムが間違っている場合は\n    入力と同じ形式の修正されたISBN番号を返します。\n\n    例:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "ko": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    주어진 ISBN 번호의 정확성을 확인하고 필요시 수정합니다.\n\n    이 함수는 제공된 ISBN 번호를 ISBN 표준 체크섬 계산에 따라 확인합니다.\n    체크섬이 올바르면 함수는 \"Right\"를 반환합니다. 체크섬이 올바르지 않으면,\n    함수는 수정된 ISBN 번호를 반환합니다.\n\n    Args:\n    isbn: 확인할 ISBN 번호를 나타내는 문자열입니다. 형식은 'x-xxx-xxxxx-x'이어야 하며,\n          여기서 'x'는 숫자이고, 마지막 'x'는 체크섬 숫자를 나타내는 'X'일 수도 있습니다.\n\n    Returns:\n    ISBN 체크섬이 올바르면 \"Right\" 문자열을 반환하고, 체크섬이 올바르지 않으면\n    입력과 동일한 형식의 수정된 ISBN 번호를 반환합니다.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "ml": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    നൽകിയ ISBN നമ്പറിന്റെ ശരിതമ്മാനങ്ങൾ പരിശോധിക്കുകയും ആവശ്യമായാൽ ശരിയാക്കുകയും ചെയ്യുക.\n\n    ISBN സ്റ്റാൻഡേർഡ് ചെക്സം കാൽക്കുലേഷൻ പ്രകാരം നൽകിയ ISBN നമ്പർ പരിശോധിക്കുന്നു.\n    ചെക്സം ശരിയാണെങ്കിൽ, ഫംഗ്ഷൻ \"Right\" എന്നതിനെ തിരികെ നൽകുന്നു. ചെക്സം തെറ്റാണെങ്കിൽ,\n    ഫംഗ്ഷൻ ശരിയായ ISBN നമ്പർ തിരികെ നൽകുന്നു.\n\n    Args:\n    isbn: പരിശോധിക്കേണ്ട ISBN നമ്പർ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. ഫോർമാറ്റ് 'x-xxx-xxxxx-x' ആയിരിക്കണം,\n          ഇവിടെ 'x' ഒരു അക്കമാണ്, അവസാനത്തെ 'x' ചെക്സം അക്കം പ്രതിനിധീകരിക്കുന്ന 'X' ആയിരിക്കാം.\n\n    Returns:\n    ISBN ചെക്സം ശരിയാണെങ്കിൽ \"Right\" എന്ന സ്ട്രിംഗ്, അല്ലെങ്കിൽ ചെക്സം തെറ്റാണെങ്കിൽ\n    ഇൻപുട്ട് പോലെ തന്നെയുള്ള ഫോർമാറ്റിൽ ശരിയായ ISBN നമ്പർ.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"", "fa": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    صحت یک شماره ISBN داده شده را بررسی کرده و در صورت لزوم آن را تصحیح می‌کند.\n\n    این تابع شماره ISBN ارائه شده را با محاسبه استاندارد چک‌سام ISBN بررسی می‌کند.\n    اگر چک‌سام صحیح باشد، تابع \"Right\" را برمی‌گرداند. اگر چک‌سام نادرست باشد،\n    تابع شماره ISBN تصحیح شده را برمی‌گرداند.\n\n    آرگومان‌ها:\n    isbn: یک رشته که شماره ISBN برای بررسی را نشان می‌دهد. قالب باید به صورت 'x-xxx-xxxxx-x' باشد،\n          که در آن 'x' یک رقم است و آخرین 'x' می‌تواند 'X' باشد که نشان‌دهنده رقم چک‌سام است.\n\n    بازگشت:\n    رشته‌ای که یا \"Right\" است اگر چک‌سام ISBN صحیح باشد، یا شماره ISBN تصحیح شده\n    در همان قالب ورودی اگر چک‌سام نادرست باشد.\n\n    مثال‌ها:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\""}, "canonical_solution": "    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit", "instruction": {"en": "Write a python function 'def verify_isbn(isbn: str) -> str:' to solve the following problem:\n\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    ", "sq": "Shkruani një funksion python 'def verify_isbn(isbn: str) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Verifikoni saktësinë e një numri të dhënë ISBN dhe korrigjojeni atë nëse është e nevojshme.\n\n    Funksioni kontrollon numrin e dhënë ISBN kundrejt llogaritjes së kontrollit standard të ISBN.\n    Nëse kontrolli është i saktë, funksioni kthen \"Right\". Nëse kontrolli është i pasaktë,\n    funksioni kthen numrin e korrigjuar ISBN.\n\n    Args:\n    isbn: Një varg që përfaqëson numrin ISBN që do të verifikohet. Formati duhet të jetë 'x-xxx-xxxxx-x',\n          ku 'x' është një shifër, dhe 'x' i fundit mund të jetë gjithashtu 'X' që përfaqëson shifrën e kontrollit.\n\n    Kthen:\n    Një varg që është ose \"Right\" nëse kontrolli i ISBN është i saktë, ose numri i korrigjuar ISBN\n    në të njëjtin format si hyrja nëse kontrolli është i pasaktë.\n\n    Shembuj:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "hy": "Պայթոն ֆունկցիա 'def verify_isbn(isbn: str) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Ստուգել տրված ISBN համարի ճշգրտությունը և անհրաժեշտության դեպքում ուղղել այն։\n\n    Ֆունկցիան ստուգում է տրված ISBN համարը՝ համեմատելով այն ISBN ստանդարտ ստուգիչ գումարի հաշվարկի հետ։\n    Եթե ստուգիչ գումարը ճիշտ է, ֆունկցիան վերադարձնում է \"Right\"։ Եթե ստուգիչ գումարը սխալ է,\n    ֆունկցիան վերադարձնում է ուղղված ISBN համարը։\n\n    Արգումենտներ:\n    isbn: Տող, որը ներկայացնում է ստուգվող ISBN համարը։ Ֆորմատը պետք է լինի 'x-xxx-xxxxx-x',\n          որտեղ 'x'-ը թիվ է, իսկ վերջին 'x'-ը կարող է լինել նաև 'X', որը ներկայացնում է ստուգիչ թիվը։\n\n    Վերադարձնում է:\n    Տող, որը կամ \"Right\" է, եթե ISBN ստուգիչ գումարը ճիշտ է, կամ ուղղված ISBN համարը\n    նույն ֆորմատով, ինչ մուտքագրվածը, եթե ստուգիչ գումարը սխալ է։\n\n    Օրինակներ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "bn": "একটি পাইথন ফাংশন 'def verify_isbn(isbn: str) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করুন এবং প্রয়োজনে এটি সংশোধন করুন।\n\n    ফাংশনটি প্রদত্ত ISBN নম্বরটি ISBN স্ট্যান্ডার্ড চেকসম গণনার সাথে যাচাই করে।\n    যদি চেকসম সঠিক হয়, ফাংশনটি \"Right\" ফেরত দেয়। যদি চেকসম ভুল হয়,\n    ফাংশনটি সংশোধিত ISBN নম্বর ফেরত দেয়।\n\n    Args:\n    isbn: একটি স্ট্রিং যা যাচাই করার জন্য ISBN নম্বর উপস্থাপন করে। ফরম্যাটটি 'x-xxx-xxxxx-x' হওয়া উচিত,\n          যেখানে 'x' একটি সংখ্যা, এবং শেষের 'x' ও 'X' হতে পারে যা চেকসম সংখ্যা উপস্থাপন করে।\n\n    Returns:\n    একটি স্ট্রিং যা হয় \"Right\" যদি ISBN চেকসম সঠিক হয়, অথবা সংশোধিত ISBN নম্বর\n    ইনপুটের একই ফরম্যাটে যদি চেকসম ভুল হয়।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "bg": "Напишете функция на Python 'def verify_isbn(isbn: str) -> str:', за да решите следния проблем:\n\n    Проверете коректността на даден ISBN номер и го коригирайте, ако е необходимо.\n\n    Функцията проверява предоставения ISBN номер спрямо стандартното изчисление на контролна сума на ISBN.\n    Ако контролната сума е правилна, функцията връща \"Right\". Ако контролната сума е неправилна,\n    функцията връща коригирания ISBN номер.\n\n    Аргументи:\n    isbn: Низ, представляващ ISBN номера, който трябва да бъде проверен. Форматът трябва да бъде 'x-xxx-xxxxx-x',\n          където 'x' е цифра, а последният 'x' може да бъде и 'X', представляващ контролна цифра.\n\n    Връща:\n    Низ, който е или \"Right\", ако контролната сума на ISBN е правилна, или коригирания ISBN номер\n    в същия формат като входа, ако контролната сума е неправилна.\n\n    Примери:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "zh": "编写一个Python函数 'def verify_isbn(isbn: str) -> str:' 来解决以下问题：\n\n    验证给定的ISBN号码的正确性，并在必要时进行更正。\n\n    该函数根据ISBN标准校验和计算检查提供的ISBN号码。\n    如果校验和正确，函数返回 \"Right\"。如果校验和不正确，\n    函数返回更正后的ISBN号码。\n\n    参数:\n    isbn: 一个表示要验证的ISBN号码的字符串。格式应为 'x-xxx-xxxxx-x'，\n          其中 'x' 是一个数字，最后一个 'x' 也可以是代表校验位的 'X'。\n\n    返回:\n    一个字符串，如果ISBN校验和正确则为 \"Right\"，如果校验和不正确则为\n    与输入格式相同的更正后的ISBN号码。\n\n    示例:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "fr": "Écrivez une fonction python 'def verify_isbn(isbn: str) -> str:' pour résoudre le problème suivant :\n\n    Vérifiez la validité d'un numéro ISBN donné et corrigez-le si nécessaire.\n\n    La fonction vérifie le numéro ISBN fourni par rapport au calcul standard de la somme de contrôle ISBN.\n    Si la somme de contrôle est correcte, la fonction renvoie \"Right\". Si la somme de contrôle est incorrecte,\n    la fonction renvoie le numéro ISBN corrigé.\n\n    Args:\n    isbn: Une chaîne représentant le numéro ISBN à vérifier. Le format doit être 'x-xxx-xxxxx-x',\n          où 'x' est un chiffre, et le dernier 'x' pourrait aussi être 'X' représentant le chiffre de contrôle.\n\n    Returns:\n    Une chaîne qui est soit \"Right\" si la somme de contrôle ISBN est correcte, soit le numéro ISBN corrigé\n    dans le même format que l'entrée si la somme de contrôle est incorrecte.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "de": "Schreiben Sie eine Python-Funktion 'def verify_isbn(isbn: str) -> str:', um das folgende Problem zu lösen:\n\n    Überprüfen Sie die Korrektheit einer gegebenen ISBN-Nummer und korrigieren Sie sie bei Bedarf.\n\n    Die Funktion überprüft die angegebene ISBN-Nummer anhand der ISBN-Standard-Prüfziffernberechnung.\n    Wenn die Prüfziffer korrekt ist, gibt die Funktion \"Right\" zurück. Wenn die Prüfziffer nicht korrekt ist,\n    gibt die Funktion die korrigierte ISBN-Nummer zurück.\n\n    Argumente:\n    isbn: Ein String, der die zu überprüfende ISBN-Nummer darstellt. Das Format sollte 'x-xxx-xxxxx-x' sein,\n          wobei 'x' eine Ziffer ist und das letzte 'x' auch 'X' sein könnte, das die Prüfziffer darstellt.\n\n    Rückgabewert:\n    Ein String, der entweder \"Right\" ist, wenn die ISBN-Prüfziffer korrekt ist, oder die korrigierte ISBN-Nummer\n    im gleichen Format wie die Eingabe, wenn die Prüfziffer nicht korrekt ist.\n\n    Beispiele:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "ha": "Rubuta wani aikin python 'def verify_isbn(isbn: str) -> str:' don warware matsalar mai zuwa:\n\n    Tabbatar da daidaiton lambar ISBN da aka bayar kuma gyara idan ya cancanta.\n\n    Aikin yana duba lambar ISBN da aka bayar daidai da lissafin checksum na ma'aunin ISBN.\n    Idan checksum din ya dace, aikin yana dawowa \"Right\". Idan checksum din ba daidai ba ne,\n    aikin yana dawowa da lambar ISBN da aka gyara.\n\n    Args:\n    isbn: Wani kirtani da ke wakiltar lambar ISBN da za a tabbatar. Tsarin ya zama 'x-xxx-xxxxx-x',\n          inda 'x' ke nuni da lamba, kuma na ƙarshe 'x' na iya zama 'X' wanda ke wakiltar lambar checksum.\n\n    Returns:\n    Wani kirtani wanda ko dai \"Right\" idan checksum na ISBN ya dace, ko kuma lambar ISBN da aka gyara\n    a cikin irin wannan tsarin kamar yadda aka shigar idan checksum din ba daidai ba ne.\n\n    Misalai:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "hi": "एक पायथन फ़ंक्शन 'def verify_isbn(isbn: str) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए ISBN नंबर की शुद्धता की जांच करें और यदि आवश्यक हो तो उसे सही करें।\n\n    फ़ंक्शन प्रदान किए गए ISBN नंबर की ISBN मानक चेकसम गणना के खिलाफ जांच करता है।\n    यदि चेकसम सही है, तो फ़ंक्शन \"Right\" लौटाता है। यदि चेकसम गलत है,\n    तो फ़ंक्शन सही किया गया ISBN नंबर लौटाता है।\n\n    तर्क:\n    isbn: एक स्ट्रिंग जो सत्यापित करने के लिए ISBN नंबर का प्रतिनिधित्व करती है। प्रारूप 'x-xxx-xxxxx-x' होना चाहिए,\n          जहाँ 'x' एक अंक है, और अंतिम 'x' चेकसम अंक का प्रतिनिधित्व करने वाला 'X' भी हो सकता है।\n\n    लौटाता है:\n    एक स्ट्रिंग जो या तो \"Right\" है यदि ISBN चेकसम सही है, या सही किया गया ISBN नंबर\n    उसी प्रारूप में जैसा इनपुट है यदि चेकसम गलत है।\n\n    उदाहरण:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "hu": "Írj egy Python függvényt 'def verify_isbn(isbn: str) -> str:' a következő probléma megoldására:\n\n    Ellenőrizze egy adott ISBN szám helyességét, és szükség esetén javítsa ki.\n\n    A függvény ellenőrzi a megadott ISBN számot az ISBN szabvány ellenőrző összeg számításával.\n    Ha az ellenőrző összeg helyes, a függvény \"Right\"-ot ad vissza. Ha az ellenőrző összeg helytelen,\n    a függvény a javított ISBN számot adja vissza.\n\n    Args:\n    isbn: Egy string, amely az ellenőrizendő ISBN számot képviseli. A formátumnak 'x-xxx-xxxxx-x'-nek kell lennie,\n          ahol 'x' egy számjegy, és az utolsó 'x' lehet 'X' is, amely az ellenőrző számjegyet képviseli.\n\n    Returns:\n    Egy string, amely vagy \"Right\", ha az ISBN ellenőrző összege helyes, vagy a javított ISBN szám\n    ugyanabban a formátumban, mint a bemenet, ha az ellenőrző összeg helytelen.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "es": "Escribe una función de Python 'def verify_isbn(isbn: str) -> str:' para resolver el siguiente problema:\n\n    Verificar la corrección de un número ISBN dado y corregirlo si es necesario.\n\n    La función verifica el número ISBN proporcionado contra el cálculo de la suma de verificación estándar de ISBN.\n    Si la suma de verificación es correcta, la función devuelve \"Right\". Si la suma de verificación es incorrecta,\n    la función devuelve el número ISBN corregido.\n\n    Argumentos:\n    isbn: Una cadena que representa el número ISBN a verificar. El formato debe ser 'x-xxx-xxxxx-x',\n          donde 'x' es un dígito, y el último 'x' también podría ser 'X' representando el dígito de suma de verificación.\n\n    Devuelve:\n    Una cadena que es \"Right\" si la suma de verificación del ISBN es correcta, o el número ISBN corregido\n    en el mismo formato que la entrada si la suma de verificación es incorrecta.\n\n    Ejemplos:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "arb": "اكتب دالة بايثون 'def verify_isbn(isbn: str) -> str:' لحل المشكلة التالية:\n\n    تحقق من صحة رقم ISBN المعطى وصححه إذا لزم الأمر.\n\n    تقوم الدالة بفحص رقم ISBN المقدم مقابل حساب المجموع الاختباري القياسي لـ ISBN.\n    إذا كان المجموع الاختباري صحيحًا، تعيد الدالة \"Right\". إذا كان المجموع الاختباري غير صحيح،\n    تعيد الدالة رقم ISBN المصحح.\n\n    يعيدالحجج:\n    isbn: سلسلة تمثل رقم ISBN المراد التحقق منه. يجب أن يكون التنسيق 'x-xxx-xxxxx-x',\n          حيث 'x' هو رقم، و'X' الأخير يمكن أن يكون أيضًا 'X' لتمثيل رقم المجموع الاختباري.\n\n    يعيد:\n    سلسلة تكون إما \"Right\" إذا كان المجموع الاختباري لـ ISBN صحيحًا، أو رقم ISBN المصحح\n    بنفس تنسيق المدخل إذا كان المجموع الاختباري غير صحيح.\n\n    أمثلة:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "sw": "Andika kazi ya python 'def verify_isbn(isbn: str) -> str:' kutatua tatizo lifuatalo:\n\n    Hakikisha usahihi wa nambari ya ISBN iliyotolewa na uirekebishe ikiwa ni lazima.\n\n    Kazi hukagua nambari ya ISBN iliyotolewa dhidi ya hesabu ya kiwango cha checksum cha ISBN.\n    Ikiwa checksum ni sahihi, kazi inarudisha \"Right\". Ikiwa checksum si sahihi,\n    kazi inarudisha nambari ya ISBN iliyorekebishwa.\n\n    Hoja:\n    isbn: Kamba inayowakilisha nambari ya ISBN itakayohakikiwa. Muundo unapaswa kuwa 'x-xxx-xxxxx-x',\n          ambapo 'x' ni tarakimu, na 'x' ya mwisho inaweza pia kuwa 'X' inayowakilisha tarakimu ya checksum.\n\n    Inarejesha:\n    Kamba ambayo ni \"Right\" ikiwa checksum ya ISBN ni sahihi, au nambari ya ISBN iliyorekebishwa\n    katika muundo sawa na ingizo ikiwa checksum si sahihi.\n\n    Mifano:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "tr": "Bir python fonksiyonu 'def verify_isbn(isbn: str) -> str:' yazarak aşağıdaki problemi çözün:\n\n    Verilen bir ISBN numarasının doğruluğunu kontrol edin ve gerekirse düzeltin.\n\n    Fonksiyon, sağlanan ISBN numarasını ISBN standart kontrol toplamı hesaplamasına göre kontrol eder.\n    Eğer kontrol toplamı doğruysa, fonksiyon \"Right\" döndürür. Eğer kontrol toplamı yanlışsa,\n    fonksiyon düzeltilmiş ISBN numarasını döndürür.\n\n    Argümanlar:\n    isbn: Doğrulanacak ISBN numarasını temsil eden bir string. Format 'x-xxx-xxxxx-x' şeklinde olmalıdır,\n          burada 'x' bir rakamdır ve son 'x' kontrol toplamı rakamını temsil eden 'X' de olabilir.\n\n    Dönüş:\n    Eğer ISBN kontrol toplamı doğruysa \"Right\" veya kontrol toplamı yanlışsa girişle aynı formatta\n    düzeltilmiş ISBN numarası olan bir string.\n\n    Örnekler:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "vi": "Viết một hàm python 'def verify_isbn(isbn: str) -> str:' để giải quyết vấn đề sau:\n\n    Xác minh tính chính xác của một số ISBN đã cho và sửa nó nếu cần thiết.\n\n    Hàm kiểm tra số ISBN được cung cấp dựa trên tính toán kiểm tra tiêu chuẩn ISBN.\n    Nếu kiểm tra đúng, hàm trả về \"Right\". Nếu kiểm tra sai,\n    hàm trả về số ISBN đã được sửa.\n\n    Tham số:\n    isbn: Một chuỗi đại diện cho số ISBN cần được xác minh. Định dạng nên là 'x-xxx-xxxxx-x',\n          trong đó 'x' là một chữ số, và 'x' cuối cùng cũng có thể là 'X' đại diện cho chữ số kiểm tra.\n\n    Trả về:\n    Một chuỗi là \"Right\" nếu kiểm tra ISBN đúng, hoặc số ISBN đã được sửa\n    trong cùng định dạng như đầu vào nếu kiểm tra sai.\n\n    Ví dụ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "id": "Tulis fungsi python 'def verify_isbn(isbn: str) -> str:' untuk menyelesaikan masalah berikut:\n\n    Verifikasi kebenaran dari nomor ISBN yang diberikan dan perbaiki jika perlu.\n\n    Fungsi memeriksa nomor ISBN yang diberikan terhadap perhitungan checksum standar ISBN.\n    Jika checksum benar, fungsi mengembalikan \"Right\". Jika checksum salah,\n    fungsi mengembalikan nomor ISBN yang telah diperbaiki.\n\n    Argumen:\n    isbn: Sebuah string yang mewakili nomor ISBN yang akan diverifikasi. Formatnya harus 'x-xxx-xxxxx-x',\n          di mana 'x' adalah digit, dan 'x' terakhir juga bisa 'X' yang mewakili digit checksum.\n\n    Mengembalikan:\n    Sebuah string yang berupa \"Right\" jika checksum ISBN benar, atau nomor ISBN yang telah diperbaiki\n    dalam format yang sama dengan input jika checksum salah.\n\n    Contoh:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "ja": "Python関数を書いてください。 'def verify_isbn(isbn: str) -> str:' を使用して次の問題を解決します:\n\n    指定されたISBN番号の正確性を確認し、必要に応じて修正します。\n\n    関数は、提供されたISBN番号をISBN標準のチェックサム計算に基づいて確認します。\n    チェックサムが正しい場合、関数は \"Right\" を返します。チェックサムが間違っている場合、\n    関数は修正されたISBN番号を返します。\n\n    引数:\n    isbn: 確認するISBN番号を表す文字列。形式は 'x-xxx-xxxxx-x' で、\n          ここで 'x' は数字であり、最後の 'x' はチェックサムの数字を表す 'X' になることもあります。\n\n    戻り値:\n    ISBNチェックサムが正しい場合は \"Right\"、チェックサムが間違っている場合は\n    入力と同じ形式で修正されたISBN番号を表す文字列。\n\n    例:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "ko": "파이썬 함수를 작성하십시오 'def verify_isbn(isbn: str) -> str:' 다음 문제를 해결하기 위해:\n\n    주어진 ISBN 번호의 정확성을 확인하고 필요하면 수정하십시오.\n\n    이 함수는 제공된 ISBN 번호를 ISBN 표준 체크섬 계산과 비교합니다.\n    체크섬이 올바르면 함수는 \"Right\"를 반환합니다. 체크섬이 틀리면,\n    함수는 수정된 ISBN 번호를 반환합니다.\n\n    인수:\n    isbn: 확인할 ISBN 번호를 나타내는 문자열입니다. 형식은 'x-xxx-xxxxx-x'이어야 하며,\n          여기서 'x'는 숫자이고 마지막 'x'는 체크섬 숫자를 나타내는 'X'일 수도 있습니다.\n\n    반환:\n    ISBN 체크섬이 올바르면 \"Right\" 문자열을 반환하고, 체크섬이 틀리면 입력과 동일한 형식으로\n    수정된 ISBN 번호를 반환합니다.\n\n    예시:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "ml": "'def verify_isbn(isbn: str) -> str:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    നൽകിയിരിക്കുന്ന ISBN നമ്പറിന്റെ ശരിതനിയെ പരിശോധിക്കുകയും ആവശ്യമെങ്കിൽ അത് ശരിയാക്കുകയും ചെയ്യുക.\n\n    ഫംഗ്ഷൻ നൽകിയിരിക്കുന്ന ISBN നമ്പർ ISBN സ്റ്റാൻഡേർഡ് ചെക്സം കണക്കുകൂട്ടലിനെതിരെ പരിശോധിക്കുന്നു.\n    ചെക്സം ശരിയാണെങ്കിൽ, ഫംഗ്ഷൻ \"Right\" എന്നത് തിരികെ നൽകുന്നു. ചെക്സം തെറ്റാണെങ്കിൽ,\n    ഫംഗ്ഷൻ ശരിയായ ISBN നമ്പർ തിരികെ നൽകുന്നു.\n\n    Args:\n    isbn: പരിശോധിക്കേണ്ട ISBN നമ്പർ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. ഫോർമാറ്റ് 'x-xxx-xxxxx-x' ആയിരിക്കണം,\n          ഇവിടെ 'x' ഒരു അക്കമാണ്, അവസാനത്തെ 'x' ചെക്സം അക്കം പ്രതിനിധീകരിക്കുന്ന 'X' ആയിരിക്കാം.\n\n    Returns:\n    ഒരു സ്ട്രിംഗ്, ISBN ചെക്സം ശരിയാണെങ്കിൽ \"Right\" അല്ലെങ്കിൽ ചെക്സം തെറ്റാണെങ്കിൽ\n    ഇൻപുട്ടിനോടു സമാനമായ ഫോർമാറ്റിൽ ശരിയായ ISBN നമ്പർ.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "fa": "یک تابع پایتون بنویسید 'def verify_isbn(isbn: str) -> str:' تا مسئله زیر را حل کند:\n\n    صحت یک شماره ISBN داده شده را بررسی کرده و در صورت لزوم آن را تصحیح کنید.\n\n    تابع شماره ISBN ارائه شده را با محاسبه چک‌سام استاندارد ISBN بررسی می‌کند.\n    اگر چک‌سام صحیح باشد، تابع \"Right\" را برمی‌گرداند. اگر چک‌سام نادرست باشد،\n    تابع شماره ISBN تصحیح شده را برمی‌گرداند.\n\n    آرگومان‌ها:\n    isbn: یک رشته که شماره ISBN برای بررسی را نشان می‌دهد. فرمت باید به صورت 'x-xxx-xxxxx-x' باشد،\n          که در آن 'x' یک رقم است و آخرین 'x' می‌تواند 'X' نیز باشد که نشان‌دهنده رقم چک‌سام است.\n\n    بازگشت:\n    یک رشته که یا \"Right\" است اگر چک‌سام ISBN صحیح باشد، یا شماره ISBN تصحیح شده\n    در همان فرمت ورودی اگر چک‌سام نادرست باشد.\n\n    مثال‌ها:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'"}, "level": "middle", "test": "def test_verify_isbn():\n    # Test case 1: Correct ISBN number\n    assert verify_isbn(\"0-670-82162-4\") == \"Right\", \"Test case 1 failed\"\n\n    # Test case 2: Incorrect ISBN number with wrong checksum digit\n    assert verify_isbn(\"0-670-82162-0\") == \"0-670-82162-4\", \"Test case 2 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_verify_isbn()", "entry_point": "verify_isbn", "signature": "def verify_isbn(isbn: str) -> str:", "docstring": {"en": "\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    ", "sq": "\n    Verifikoni saktësinë e një numri ISBN të dhënë dhe korrigjojeni atë nëse është e nevojshme.\n\n    Funksioni kontrollon numrin e dhënë ISBN kundrejt llogaritjes standarde të kontrollit të ISBN.\n    Nëse kontrolli është i saktë, funksioni kthen \"Right\". Nëse kontrolli është i pasaktë,\n    funksioni kthen numrin e korrigjuar ISBN.\n\n    Argumentet:\n    isbn: Një varg që përfaqëson numrin ISBN që do të verifikohet. Formati duhet të jetë 'x-xxx-xxxxx-x',\n          ku 'x' është një shifër, dhe 'x' i fundit mund të jetë gjithashtu 'X' që përfaqëson shifrën e kontrollit.\n\n    Kthen:\n    Një varg që është ose \"Right\" nëse kontrolli i ISBN është i saktë, ose numri i korrigjuar ISBN\n    në të njëjtin format si hyrja nëse kontrolli është i pasaktë.\n\n    Shembuj:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "hy": "\n    Ստուգել տրված ISBN համարի ճշտությունը և անհրաժեշտության դեպքում ուղղել այն։\n\n    Ֆունկցիան ստուգում է տրամադրված ISBN համարը ըստ ISBN ստանդարտի ստուգիչ գումարի հաշվարկի։\n    Եթե ստուգիչ գումարը ճիշտ է, ֆունկցիան վերադարձնում է \"Right\"։ Եթե ստուգիչ գումարը սխալ է,\n    ֆունկցիան վերադարձնում է ուղղված ISBN համարը։\n\n    Պարամետրեր:\n    isbn: Տող, որը ներկայացնում է ստուգվող ISBN համարը։ Ձևաչափը պետք է լինի 'x-xxx-xxxxx-x',\n          որտեղ 'x'-ը թիվ է, իսկ վերջին 'x'-ը կարող է լինել նաև 'X', որը ներկայացնում է ստուգիչ թիվը։\n\n    Վերադարձնում է:\n    Տող, որը կամ \"Right\" է, եթե ISBN ստուգիչ գումարը ճիշտ է, կամ ուղղված ISBN համարը\n    նույն ձևաչափով, ինչ մուտքագրվածը, եթե ստուգիչ գումարը սխալ է։\n\n    Օրինակներ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "bn": "\n    প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করুন এবং প্রয়োজন হলে এটি সংশোধন করুন।\n\n    ফাংশনটি প্রদত্ত ISBN নম্বরটি ISBN মানদণ্ডের চেকসাম গণনার বিরুদ্ধে পরীক্ষা করে।\n    যদি চেকসাম সঠিক হয়, ফাংশনটি \"Right\" ফেরত দেয়। যদি চেকসাম ভুল হয়,\n    ফাংশনটি সংশোধিত ISBN নম্বর ফেরত দেয়।\n\n    আর্গুমেন্টসমূহ:\n    isbn: একটি স্ট্রিং যা যাচাই করার জন্য ISBN নম্বর উপস্থাপন করে। ফরম্যাটটি হওয়া উচিত 'x-xxx-xxxxx-x',\n          যেখানে 'x' একটি সংখ্যা, এবং শেষের 'x' ও 'X' হতে পারে যা চেকসাম ডিজিট উপস্থাপন করে।\n\n    রিটার্নস:\n    একটি স্ট্রিং যা হয় \"Right\" যদি ISBN চেকসাম সঠিক হয়, অথবা সংশোধিত ISBN নম্বর\n    ইনপুটের মতো একই ফরম্যাটে যদি চেকসাম ভুল হয়।\n\n    উদাহরণ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "bg": "\n    Проверете коректността на даден ISBN номер и го коригирайте, ако е необходимо.\n\n    Функцията проверява предоставения ISBN номер спрямо стандартното изчисление на контролната сума на ISBN.\n    Ако контролната сума е правилна, функцията връща \"Right\". Ако контролната сума е неправилна,\n    функцията връща коригирания ISBN номер.\n\n    Аргументи:\n    isbn: Низ, представляващ ISBN номера, който трябва да бъде проверен. Форматът трябва да бъде 'x-xxx-xxxxx-x',\n          където 'x' е цифра, а последното 'x' може да бъде и 'X', представляващо контролния знак.\n\n    Връща:\n    Низ, който е или \"Right\", ако контролната сума на ISBN е правилна, или коригирания ISBN номер\n    в същия формат като входа, ако контролната сума е неправилна.\n\n    Примери:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "zh": "\n    验证给定的ISBN号码的正确性，并在必要时进行更正。\n\n    该函数根据ISBN标准校验和计算检查提供的ISBN号码。\n    如果校验和正确，函数返回 \"Right\"。如果校验和不正确，\n    函数返回更正后的ISBN号码。\n\n    参数:\n    isbn: 一个表示要验证的ISBN号码的字符串。格式应为 'x-xxx-xxxxx-x'，\n          其中 'x' 是一个数字，最后一个 'x' 也可以是代表校验和数字的 'X'。\n\n    返回:\n    一个字符串，如果ISBN校验和正确，则为 \"Right\"；如果校验和不正确，\n    则为与输入格式相同的更正后的ISBN号码。\n\n    示例:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "fr": "\n    Vérifiez la validité d'un numéro ISBN donné et corrigez-le si nécessaire.\n\n    La fonction vérifie le numéro ISBN fourni en utilisant le calcul de somme de contrôle standard de l'ISBN.\n    Si la somme de contrôle est correcte, la fonction renvoie \"Right\". Si la somme de contrôle est incorrecte,\n    la fonction renvoie le numéro ISBN corrigé.\n\n    Args:\n    isbn: Une chaîne de caractères représentant le numéro ISBN à vérifier. Le format doit être 'x-xxx-xxxxx-x',\n          où 'x' est un chiffre, et le dernier 'x' peut également être 'X' représentant le chiffre de contrôle.\n\n    Returns:\n    Une chaîne de caractères qui est soit \"Right\" si la somme de contrôle de l'ISBN est correcte, soit le numéro ISBN corrigé\n    dans le même format que l'entrée si la somme de contrôle est incorrecte.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "de": "\n    Überprüfen Sie die Korrektheit einer gegebenen ISBN-Nummer und korrigieren Sie sie bei Bedarf.\n\n    Die Funktion überprüft die angegebene ISBN-Nummer anhand der ISBN-Standard-Prüfziffernberechnung.\n    Wenn die Prüfziffer korrekt ist, gibt die Funktion \"Right\" zurück. Wenn die Prüfziffer falsch ist,\n    gibt die Funktion die korrigierte ISBN-Nummer zurück.\n\n    Argumente:\n    isbn: Ein String, der die zu überprüfende ISBN-Nummer darstellt. Das Format sollte 'x-xxx-xxxxx-x' sein,\n          wobei 'x' eine Ziffer ist und das letzte 'x' auch 'X' sein könnte, was die Prüfziffer darstellt.\n\n    Rückgabe:\n    Ein String, der entweder \"Right\" ist, wenn die ISBN-Prüfziffer korrekt ist, oder die korrigierte ISBN-Nummer\n    im gleichen Format wie die Eingabe, wenn die Prüfziffer falsch ist.\n\n    Beispiele:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "ha": "\n    Tabbatar da daidaiton lambar ISBN da aka bayar kuma gyara ta idan ya cancanta.\n\n    Aikin yana duba lambar ISBN da aka bayar daidai da lissafin duba daidaiton ISBN.\n    Idan lissafin duba ya yi daidai, aikin yana dawowa da \"Right\". Idan lissafin duba bai yi daidai ba,\n    aikin yana dawowa da lambar ISBN da aka gyara.\n\n    Args:\n    isbn: Wani kirtani da ke wakiltar lambar ISBN da za a tabbatar. Tsarin ya kamata ya zama 'x-xxx-xxxxx-x',\n          inda 'x' yake wakiltar lamba, kuma 'x' na ƙarshe na iya zama 'X' wanda ke wakiltar lambar duba.\n\n    Returns:\n    Wani kirtani wanda ko dai \"Right\" idan lissafin duba ISBN ya yi daidai, ko kuma lambar ISBN da aka gyara\n    a cikin tsarin daidai da shigarwar idan lissafin duba bai yi daidai ba.\n\n    Misalai:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "hi": "\n    दिए गए ISBN नंबर की शुद्धता की जाँच करें और यदि आवश्यक हो तो इसे सही करें।\n\n    फ़ंक्शन दिए गए ISBN नंबर को ISBN मानक चेकसम गणना के विरुद्ध जाँचता है।\n    यदि चेकसम सही है, तो फ़ंक्शन \"Right\" लौटाता है। यदि चेकसम गलत है,\n    तो फ़ंक्शन सही किया गया ISBN नंबर लौटाता है।\n\n    Args:\n    isbn: एक स्ट्रिंग जो सत्यापित किए जाने वाले ISBN नंबर का प्रतिनिधित्व करती है। प्रारूप 'x-xxx-xxxxx-x' होना चाहिए,\n          जहाँ 'x' एक अंक है, और अंतिम 'x' चेकसम अंक का प्रतिनिधित्व करने वाला 'X' भी हो सकता है।\n\n    Returns:\n    एक स्ट्रिंग जो या तो \"Right\" है यदि ISBN चेकसम सही है, या यदि चेकसम गलत है तो इनपुट के समान प्रारूप में सही किया गया ISBN नंबर।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "hu": "\n    Ellenőrizze egy adott ISBN szám helyességét, és szükség esetén javítsa ki.\n\n    A függvény ellenőrzi a megadott ISBN számot az ISBN szabvány ellenőrzőösszeg-számítása alapján.\n    Ha az ellenőrzőösszeg helyes, a függvény \"Right\" értéket ad vissza. Ha az ellenőrzőösszeg helytelen,\n    a függvény a javított ISBN számot adja vissza.\n\n    Paraméterek:\n    isbn: Egy karakterlánc, amely az ellenőrizendő ISBN számot képviseli. A formátumnak 'x-xxx-xxxxx-x'\n          kell lennie, ahol 'x' egy számjegy, és az utolsó 'x' lehet 'X' is, amely az ellenőrző számjegyet jelöli.\n\n    Visszatér:\n    Egy karakterlánc, amely vagy \"Right\", ha az ISBN ellenőrzőösszeg helyes, vagy a javított ISBN szám\n    azonos formátumban, mint a bemenet, ha az ellenőrzőösszeg helytelen.\n\n    Példák:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "es": "Verificar la corrección de un número ISBN dado y corregirlo si es necesario.\n\nLa función verifica el número ISBN proporcionado contra el cálculo estándar de suma de verificación de ISBN. Si la suma de verificación es correcta, la función devuelve \"Right\". Si la suma de verificación es incorrecta, la función devuelve el número ISBN corregido.\n\nArgumentos:\nisbn: Una cadena que representa el número ISBN a verificar. El formato debe ser 'x-xxx-xxxxx-x',\n      donde 'x' es un dígito, y el último 'x' también podría ser 'X' representando el dígito de suma de verificación.\n\nDevuelve:\nUna cadena que es \"Right\" si la suma de verificación del ISBN es correcta, o el número ISBN corregido\nen el mismo formato que la entrada si la suma de verificación es incorrecta.\n\nEjemplos:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'", "arb": "\n    التحقق من صحة رقم ISBN المقدم وتصحيحه إذا لزم الأمر.\n\n    تقوم الدالة بفحص رقم ISBN المقدم وفقًا لحساب التحقق القياسي لـ ISBN.\n    إذا كان التحقق صحيحًا، تُرجع الدالة \"Right\". إذا كان التحقق غير صحيح،\n    تُرجع الدالة رقم ISBN المصحح.\n\n    يعيدالحجج:\n    isbn: سلسلة تمثل رقم ISBN المراد التحقق منه. يجب أن يكون التنسيق 'x-xxx-xxxxx-x',\n          حيث 'x' هو رقم، ويمكن أن يكون 'x' الأخير أيضًا 'X' لتمثيل رقم التحقق.\n\n    يعيد:\n    سلسلة إما \"Right\" إذا كان تحقق ISBN صحيحًا، أو رقم ISBN المصحح\n    بنفس تنسيق الإدخال إذا كان التحقق غير صحيح.\n\n    امثله:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n", "sw": "\n    Thibitisha usahihi wa nambari ya ISBN iliyotolewa na uirekebishe ikiwa ni lazima.\n\n    Kazi hii inachunguza nambari ya ISBN iliyotolewa dhidi ya hesabu ya kawaida ya checksum ya ISBN.\n    Ikiwa checksum ni sahihi, kazi inarudisha \"Right\". Ikiwa checksum si sahihi,\n    kazi inarudisha nambari ya ISBN iliyorekebishwa.\n\n    Hoja:\n    isbn: Kamba inayowakilisha nambari ya ISBN inayopaswa kuthibitishwa. Muundo unapaswa kuwa 'x-xxx-xxxxx-x',\n          ambapo 'x' ni tarakimu, na 'x' ya mwisho inaweza pia kuwa 'X' inayowakilisha tarakimu ya checksum.\n\n    Inarejesha:\n    Kamba ambayo ni ama \"Right\" ikiwa checksum ya ISBN ni sahihi, au nambari ya ISBN iliyorekebishwa\n    katika muundo ule ule kama pembejeo ikiwa checksum si sahihi.\n\n    Mifano:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "tr": "\n    Verilen bir ISBN numarasının doğruluğunu kontrol edin ve gerekirse düzeltin.\n\n    Fonksiyon, sağlanan ISBN numarasını ISBN standart kontrol toplamı hesaplamasına karşı kontrol eder.\n    Eğer kontrol toplamı doğruysa, fonksiyon \"Right\" döndürür. Eğer kontrol toplamı yanlışsa,\n    fonksiyon düzeltilmiş ISBN numarasını döndürür.\n\n    Argümanlar:\n    isbn: Doğrulanacak ISBN numarasını temsil eden bir string. Format 'x-xxx-xxxxx-x' şeklinde olmalıdır,\n          burada 'x' bir rakamdır ve son 'x' kontrol basamağını temsil eden 'X' de olabilir.\n\n    Döndürür:\n    Kontrol toplamı doğruysa \"Right\" veya kontrol toplamı yanlışsa girişle aynı formatta düzeltilmiş\n    ISBN numarasını döndüren bir string.\n\n    Örnekler:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "vi": "\n    Xác minh tính chính xác của một số ISBN đã cho và sửa nó nếu cần thiết.\n\n    Hàm kiểm tra số ISBN được cung cấp dựa trên tính toán kiểm tra chuẩn của ISBN.\n    Nếu kiểm tra đúng, hàm trả về \"Right\". Nếu kiểm tra sai,\n    hàm trả về số ISBN đã được sửa.\n\n    Tham số:\n    isbn: Một chuỗi đại diện cho số ISBN cần được xác minh. Định dạng nên là 'x-xxx-xxxxx-x',\n          trong đó 'x' là một chữ số, và 'x' cuối cùng cũng có thể là 'X' đại diện cho chữ số kiểm tra.\n\n    Trả về:\n    Một chuỗi là \"Right\" nếu kiểm tra ISBN đúng, hoặc số ISBN đã được sửa\n    trong cùng định dạng như đầu vào nếu kiểm tra sai.\n\n    Ví dụ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "id": "    Verifikasi kebenaran nomor ISBN yang diberikan dan koreksi jika diperlukan.\n\n    Fungsi ini memeriksa nomor ISBN yang diberikan terhadap perhitungan checksum standar ISBN.\n    Jika checksum benar, fungsi mengembalikan \"Right\". Jika checksum salah,\n    fungsi mengembalikan nomor ISBN yang telah dikoreksi.\n\n    Args:\n    isbn: Sebuah string yang mewakili nomor ISBN yang akan diverifikasi. Formatnya harus 'x-xxx-xxxxx-x',\n          di mana 'x' adalah digit, dan 'x' terakhir juga bisa 'X' yang mewakili digit checksum.\n\n    Returns:\n    Sebuah string yang berupa \"Right\" jika checksum ISBN benar, atau nomor ISBN yang telah dikoreksi\n    dalam format yang sama dengan input jika checksum salah.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "ja": "与えられたISBN番号の正確性を確認し、必要に応じて修正します。\n\n関数は、提供されたISBN番号をISBN標準のチェックサム計算に基づいて確認します。\nチェックサムが正しい場合、関数は「Right」を返します。チェックサムが間違っている場合、\n関数は修正されたISBN番号を返します。\n\nArgs:\nisbn: 確認するISBN番号を表す文字列。形式は 'x-xxx-xxxxx-x' で、\n      ここで 'x' は数字であり、最後の 'x' はチェックサム桁を表す 'X' でもかまいません。\n\nReturns:\nISBNチェックサムが正しい場合は「Right」、チェックサムが間違っている場合は\n入力と同じ形式の修正されたISBN番号を返す文字列。\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'", "ko": "    주어진 ISBN 번호의 정확성을 확인하고 필요시 수정합니다.\n\n    이 함수는 제공된 ISBN 번호를 ISBN 표준 체크섬 계산과 대조합니다.\n    체크섬이 올바른 경우, 함수는 \"Right\"를 반환합니다. 체크섬이 올바르지 않은 경우,\n    함수는 수정된 ISBN 번호를 반환합니다.\n\n    Args:\n    isbn: 확인할 ISBN 번호를 나타내는 문자열입니다. 형식은 'x-xxx-xxxxx-x'이어야 하며,\n          여기서 'x'는 숫자이고, 마지막 'x'는 체크섬 숫자를 나타내는 'X'일 수도 있습니다.\n\n    Returns:\n    ISBN 체크섬이 올바른 경우 \"Right\" 문자열을 반환하거나, 체크섬이 올바르지 않은 경우\n    입력과 동일한 형식의 수정된 ISBN 번호를 반환합니다.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "ml": "    നൽകിയ ISBN നമ്പറിന്റെ ശരിതനിമ ഉറപ്പാക്കുക, ആവശ്യമെങ്കിൽ അത് ശരിയാക്കുക.\n\n    ISBN സ്റ്റാൻഡേർഡ് ചെക്ക്‌സം കണക്കാക്കലിനെതിരെ നൽകിയ ISBN നമ്പർ ഫംഗ്ഷൻ പരിശോധിക്കുന്നു.\n    ചെക്ക്‌സം ശരിയായിരുന്നാൽ, ഫംഗ്ഷൻ \"Right\" തിരിച്ചുനൽകുന്നു. ചെക്ക്‌സം തെറ്റാണെങ്കിൽ,\n    ഫംഗ്ഷൻ ശരിയാക്കിയ ISBN നമ്പർ തിരിച്ചുനൽകുന്നു.\n\n    Args:\n    isbn: പരിശോധിക്കേണ്ട ISBN നമ്പർ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്. ഫോർമാറ്റ് 'x-xxx-xxxxx-x' ആയിരിക്കണം,\n          ഇവിടെ 'x' ഒരു അക്കമാണ്, അവസാനത്തെ 'x' ചെക്ക്‌സം അക്കം പ്രതിനിധീകരിക്കുന്ന 'X' ആയിരിക്കും.\n\n    Returns:\n    ISBN ചെക്ക്‌സം ശരിയാണെങ്കിൽ \"Right\" അല്ലെങ്കിൽ ചെക്ക്‌സം തെറ്റാണെങ്കിൽ\n    ഇൻപുട്ട് ഫോർമാറ്റിൽ തന്നെ ശരിയാക്കിയ ISBN നമ്പർ.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'", "fa": "صحیح بودن یک شماره ISBN داده شده را بررسی کرده و در صورت لزوم آن را تصحیح کنید.\n\nتابع شماره ISBN ارائه شده را با محاسبه چک‌سام استاندارد ISBN بررسی می‌کند.\nاگر چک‌سام صحیح باشد، تابع \"Right\" را برمی‌گرداند. اگر چک‌سام نادرست باشد،\nتابع شماره ISBN تصحیح شده را برمی‌گرداند.\n\nArgs:\nisbn: رشته‌ای که شماره ISBN را برای بررسی نشان می‌دهد. فرمت باید به صورت 'x-xxx-xxxxx-x' باشد،\n      که در آن 'x' یک رقم است و آخرین 'x' می‌تواند 'X' نیز باشد که نشان‌دهنده رقم چک‌سام است.\n\nReturns:\nرشته‌ای که یا \"Right\" است اگر چک‌سام ISBN صحیح باشد، یا شماره ISBN تصحیح شده\nدر همان فرمتی که ورودی است اگر چک‌سام نادرست باشد.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'"}}
{"task_id": "Python/15", "prompt": {"en": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "sq": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimizoni vendosjen e korridoreve në një klasë për të minimizuar sasinë e bisedave midis studentëve.\n\n    Args:\n    M (int): Numri i rreshtave në klasë.\n    N (int): Numri i kolonave në klasë.\n    K (int): Numri i korridoreve horizontale për t'u shtuar.\n    L (int): Numri i korridoreve vertikale për t'u shtuar.\n    D (int): Numri i çifteve që bisedojnë në klasë.\n    chatting_pairs (list of tuples): Një listë tuples, secili përmban pozicionet (Xi, Yi) dhe (Pi, Qi) të një çifti që bisedon.\n\n    Returns:\n    (str, str): Dy vargje të ndara me hapësirë që përfaqësojnë indeksat optimalë të rreshtave dhe kolonave për korridoret.\n\n    Funksioni punon duke numëruar numrin e çifteve që bisedojnë që mund të ndahen duke shtuar një korridor në çdo pozicion të mundshëm.\n    Pastaj zgjedh pozicionet më efektive për korridoret, duke synuar të ndajë sa më shumë çifte që bisedojnë të jetë e mundur.\n\n    Shembuj:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Kthen: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Kthen: ('2', '2')\n    \"\"\"", "hy": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Օպտիմալացնել միջանցքների տեղադրումը դասարանում՝ նվազագույնի հասցնելու ուսանողների միջև զրույցների քանակը։\n\n    Արգումենտներ:\n    M (int): Դասարանի շարքերի քանակը։\n    N (int): Դասարանի սյուների քանակը։\n    K (int): Ավելացվող հորիզոնական միջանցքների քանակը։\n    L (int): Ավելացվող ուղղահայաց միջանցքների քանակը։\n    D (int): Դասարանում զրուցող զույգերի քանակը։\n    chatting_pairs (ցանկ tuple-ների): Tuple-ների ցանկ, որոնցից յուրաքանչյուրը պարունակում է զրուցող զույգի դիրքերը (Xi, Yi) և (Pi, Qi)։\n\n    Վերադարձնում է:\n    (str, str): Երկու բացատով բաժանված տողեր, որոնք ներկայացնում են միջանցքների օպտիմալ շարքի և սյունակի ինդեքսները։\n\n    Ֆունկցիան աշխատում է՝ հաշվելով զրուցող զույգերի քանակը, որոնք կարող են բաժանվել՝ յուրաքանչյուր հնարավոր դիրքում միջանցք ավելացնելով։\n    Այնուհետև ընտրում է միջանցքների ամենաարդյունավետ դիրքերը՝ նպատակ ունենալով բաժանել հնարավորինս շատ զրուցող զույգեր։\n\n    Օրինակներ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Վերադարձնում է: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Վերադարձնում է: ('2', '2')\n    \"\"\"", "bn": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    শ্রেণীকক্ষে শিক্ষার্থীদের মধ্যে কথোপকথনের পরিমাণ কমানোর জন্য আইলগুলির অবস্থান অপ্টিমাইজ করুন।\n\n    Args:\n    M (int): শ্রেণীকক্ষে সারির সংখ্যা।\n    N (int): শ্রেণীকক্ষে কলামের সংখ্যা।\n    K (int): যোগ করার জন্য অনুভূমিক আইলগুলির সংখ্যা।\n    L (int): যোগ করার জন্য উল্লম্ব আইলগুলির সংখ্যা।\n    D (int): শ্রেণীকক্ষে কথোপকথনকারী জোড়াগুলির সংখ্যা।\n    chatting_pairs (list of tuples): একটি টুপলের তালিকা, প্রতিটি টুপলে একটি কথোপকথনকারী জোড়ার অবস্থান (Xi, Yi) এবং (Pi, Qi) রয়েছে।\n\n    Returns:\n    (str, str): আইলগুলির জন্য অপ্টিমাল সারি এবং কলাম সূচকগুলি নির্দেশ করে দুটি স্পেস-বিচ্ছিন্ন স্ট্রিং।\n\n    ফাংশনটি প্রতিটি সম্ভাব্য অবস্থানে একটি আইল যোগ করার মাধ্যমে পৃথক করা যেতে পারে এমন কথোপকথনকারী জোড়াগুলির সংখ্যা গণনা করে কাজ করে।\n    তারপর এটি আইলগুলির জন্য সবচেয়ে কার্যকর অবস্থানগুলি নির্বাচন করে, যতটা সম্ভব কথোপকথনকারী জোড়াগুলিকে পৃথক করার লক্ষ্য নিয়ে।\n\n    উদাহরণ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "bg": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Оптимизирайте разположението на пътеките в класната стая, за да минимизирате количеството разговори между учениците.\n\n    Args:\n    M (int): Броят на редовете в класната стая.\n    N (int): Броят на колоните в класната стая.\n    K (int): Броят на хоризонталните пътеки, които да се добавят.\n    L (int): Броят на вертикалните пътеки, които да се добавят.\n    D (int): Броят на двойките, които разговарят в класната стая.\n    chatting_pairs (list of tuples): Списък от кортежи, всеки от които съдържа позициите (Xi, Yi) и (Pi, Qi) на двойка, която разговаря.\n\n    Returns:\n    (str, str): Два низа, разделени с интервал, представляващи оптималните индекси на редовете и колоните за пътеките.\n\n    Функцията работи, като брои броя на двойките, които могат да бъдат разделени чрез добавяне на пътека на всяка възможна позиция.\n    След това избира най-ефективните позиции за пътеки, с цел да раздели възможно най-много двойки, които разговарят.\n\n    Примери:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "zh": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    优化教室中走道的布置，以尽量减少学生之间的聊天。\n\n    参数:\n    M (int): 教室中的行数。\n    N (int): 教室中的列数。\n    K (int): 要添加的水平走道数量。\n    L (int): 要添加的垂直走道数量。\n    D (int): 教室中聊天对的数量。\n    chatting_pairs (list of tuples): 一个包含元组的列表，每个元组包含一个聊天对的位置 (Xi, Yi) 和 (Pi, Qi)。\n\n    返回:\n    (str, str): 两个空格分隔的字符串，分别表示走道的最佳行和列索引。\n\n    该函数通过计算可以通过在每个可能位置添加走道来分隔的聊天对的数量来工作。\n    然后选择最有效的走道位置，旨在分隔尽可能多的聊天对。\n\n    示例:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    返回: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    返回: ('2', '2')\n    \"\"\"", "fr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimiser le placement des allées dans une salle de classe pour minimiser la quantité de bavardage entre les étudiants.\n\n    Args:\n    M (int): Le nombre de rangées dans la salle de classe.\n    N (int): Le nombre de colonnes dans la salle de classe.\n    K (int): Le nombre d'allées horizontales à ajouter.\n    L (int): Le nombre d'allées verticales à ajouter.\n    D (int): Le nombre de paires bavardant dans la salle de classe.\n    chatting_pairs (list of tuples): Une liste de tuples, chacun contenant les positions (Xi, Yi) et (Pi, Qi) d'une paire bavardant.\n\n    Returns:\n    (str, str): Deux chaînes séparées par des espaces représentant les indices optimaux des rangées et colonnes pour les allées.\n\n    La fonction fonctionne en comptant le nombre de paires bavardant qui peuvent être séparées en ajoutant une allée à chaque position possible.\n    Elle sélectionne ensuite les positions les plus efficaces pour les allées, visant à séparer le plus grand nombre possible de paires bavardant.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "de": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimieren Sie die Platzierung der Gänge in einem Klassenzimmer, um die Menge an Gesprächen zwischen den Schülern zu minimieren.\n\n    Args:\n    M (int): Die Anzahl der Reihen im Klassenzimmer.\n    N (int): Die Anzahl der Spalten im Klassenzimmer.\n    K (int): Die Anzahl der hinzuzufügenden horizontalen Gänge.\n    L (int): Die Anzahl der hinzuzufügenden vertikalen Gänge.\n    D (int): Die Anzahl der Gesprächspaare im Klassenzimmer.\n    chatting_pairs (list of tuples): Eine Liste von Tupeln, die jeweils die Positionen (Xi, Yi) und (Pi, Qi) eines Gesprächspaares enthalten.\n\n    Returns:\n    (str, str): Zwei durch Leerzeichen getrennte Zeichenfolgen, die die optimalen Reihen- und Spaltenindizes für die Gänge darstellen.\n\n    Die Funktion arbeitet, indem sie die Anzahl der Gesprächspaare zählt, die durch das Hinzufügen eines Gangs an jeder möglichen Position getrennt werden können.\n    Anschließend wählt sie die effektivsten Positionen für die Gänge aus, um möglichst viele Gesprächspaare zu trennen.\n\n    Beispiele:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Gibt zurück: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Gibt zurück: ('2', '2')\n    \"\"\"", "ha": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Inganta wurin sanya hanyoyi a cikin aji don rage yawan hira tsakanin ɗalibai.\n\n    Args:\n    M (int): Yawan layuka a cikin aji.\n    N (int): Yawan ginshikai a cikin aji.\n    K (int): Yawan hanyoyi a kwance da za a ƙara.\n    L (int): Yawan hanyoyi a tsaye da za a ƙara.\n    D (int): Yawan ma'aurata masu hira a cikin aji.\n    chatting_pairs (list of tuples): Jerin tuples, kowanne yana ɗauke da wuraren (Xi, Yi) da (Pi, Qi) na ma'aurata masu hira.\n\n    Returns:\n    (str, str): Haruffa guda biyu da aka raba da sarari waɗanda ke wakiltar mafi kyawun layi da ginshiƙai don hanyoyin.\n\n    Aiki yana aiki ta hanyar ƙididdige yawan ma'aurata masu hira waɗanda za a iya raba ta hanyar ƙara hanya a kowanne matsayi mai yiwuwa.\n    Sannan yana zaɓar mafi kyawun wurare don hanyoyi, yana nufin raba ma'aurata masu hira da yawa gwargwadon iko.\n\n    Misalai:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "hi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    कक्षा में छात्रों के बीच बातचीत की मात्रा को कम करने के लिए गलियारों की व्यवस्था को अनुकूलित करें।\n\n    Args:\n    M (int): कक्षा में पंक्तियों की संख्या।\n    N (int): कक्षा में स्तंभों की संख्या।\n    K (int): जोड़ने के लिए क्षैतिज गलियारों की संख्या।\n    L (int): जोड़ने के लिए लंबवत गलियारों की संख्या।\n    D (int): कक्षा में बातचीत करने वाले जोड़ों की संख्या।\n    chatting_pairs (list of tuples): एक सूची जिसमें प्रत्येक जोड़ी के स्थान (Xi, Yi) और (Pi, Qi) होते हैं।\n\n    Returns:\n    (str, str): दो स्पेस से अलग किए गए स्ट्रिंग्स जो गलियारों के लिए अनुकूलतम पंक्ति और स्तंभ सूचकांक का प्रतिनिधित्व करते हैं।\n\n    यह फ़ंक्शन प्रत्येक संभावित स्थिति में गलियारा जोड़कर अलग किए जा सकने वाले बातचीत करने वाले जोड़ों की संख्या की गणना करता है।\n    फिर यह गलियारों के लिए सबसे प्रभावी स्थानों का चयन करता है, जितना संभव हो सके उतने बातचीत करने वाले जोड़ों को अलग करने का लक्ष्य रखते हुए।\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "hu": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimalizálja a folyosók elhelyezését egy tanteremben, hogy minimalizálja a diákok közötti beszélgetéseket.\n\n    Args:\n    M (int): A tanterem sorainak száma.\n    N (int): A tanterem oszlopainak száma.\n    K (int): A hozzáadandó vízszintes folyosók száma.\n    L (int): A hozzáadandó függőleges folyosók száma.\n    D (int): A tanteremben lévő beszélgető párok száma.\n    chatting_pairs (list of tuples): Egy tuple-ök listája, mindegyik tartalmazza egy beszélgető pár pozícióit (Xi, Yi) és (Pi, Qi).\n\n    Returns:\n    (str, str): Két szóközzel elválasztott karakterlánc, amelyek a folyosók optimális sor- és oszlopindexeit képviselik.\n\n    A függvény úgy működik, hogy megszámolja a beszélgető párok számát, amelyeket el lehet választani egy folyosó hozzáadásával minden lehetséges pozícióban.\n    Ezután kiválasztja a leghatékonyabb pozíciókat a folyosók számára, azzal a céllal, hogy minél több beszélgető párt elválasszon.\n\n    Példák:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Visszaadja: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Visszaadja: ('2', '2')\n    \"\"\"", "es": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimizar la colocación de pasillos en un aula para minimizar la cantidad de conversaciones entre estudiantes.\n\n    Argumentos:\n    M (int): El número de filas en el aula.\n    N (int): El número de columnas en el aula.\n    K (int): El número de pasillos horizontales a añadir.\n    L (int): El número de pasillos verticales a añadir.\n    D (int): El número de pares de estudiantes conversando en el aula.\n    chatting_pairs (list of tuples): Una lista de tuplas, cada una contiene las posiciones (Xi, Yi) y (Pi, Qi) de un par que conversa.\n\n    Devuelve:\n    (str, str): Dos cadenas separadas por espacios que representan los índices óptimos de filas y columnas para los pasillos.\n\n    La función trabaja contando el número de pares que conversan y que pueden ser separados añadiendo un pasillo en cada posición posible.\n    Luego selecciona las posiciones más efectivas para los pasillos, con el objetivo de separar la mayor cantidad posible de pares que conversan.\n\n    Ejemplos:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "arb": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    تحسين وضع الممرات في الفصل الدراسي لتقليل كمية الدردشة بين الطلاب.\n\n    يعيدالحجج:\n    M (int): عدد الصفوف في الفصل الدراسي.\n    N (int): عدد الأعمدة في الفصل الدراسي.\n    K (int): عدد الممرات الأفقية التي يجب إضافتها.\n    L (int): عدد الممرات الرأسية التي يجب إضافتها.\n    D (int): عدد الأزواج التي تتحدث في الفصل الدراسي.\n    chatting_pairs (list of tuples): قائمة من الأزواج، كل منها يحتوي على المواقع (Xi, Yi) و (Pi, Qi) لزوج يتحدث.\n\n    يعيد:\n    (str, str): سلسلتان مفصولتان بمسافات تمثلان مؤشرات الصفوف والأعمدة المثلى للممرات.\n\n    تعمل الدالة عن طريق حساب عدد الأزواج التي يمكن فصلها بإضافة ممر في كل موقع ممكن.\n    ثم تختار المواقع الأكثر فعالية للممرات، بهدف فصل أكبر عدد ممكن من الأزواج التي تتحدث.\n\n    أمثلة:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "sw": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Boresha uwekaji wa njia za kupita darasani ili kupunguza kiasi cha mazungumzo kati ya wanafunzi.\n\n    Hoja:\n    M (int): Idadi ya mistari katika darasa.\n    N (int): Idadi ya safu katika darasa.\n    K (int): Idadi ya njia za mlalo za kuongeza.\n    L (int): Idadi ya njia za wima za kuongeza.\n    D (int): Idadi ya wanandoa wanaozungumza darasani.\n    chatting_pairs (list of tuples): Orodha ya jozi, kila moja ikiwa na nafasi (Xi, Yi) na (Pi, Qi) ya wanandoa wanaozungumza.\n\n    Inarejesha:\n    (str, str): Kamba mbili zilizotenganishwa na nafasi zinazoonyesha mistari na safu bora kwa njia za kupita.\n\n    Kazi hii inafanya kazi kwa kuhesabu idadi ya wanandoa wanaozungumza ambao wanaweza kutenganishwa kwa kuongeza njia ya kupita katika kila nafasi inayowezekana.\n    Kisha huchagua nafasi bora zaidi za njia za kupita, ikilenga kutenganisha wanandoa wengi wanaozungumza iwezekanavyo.\n\n    Mifano:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "tr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Bir sınıfta öğrenciler arasındaki konuşmaları en aza indirmek için koridorların yerleşimini optimize edin.\n\n    Argümanlar:\n    M (int): Sınıftaki sıra sayısı.\n    N (int): Sınıftaki sütun sayısı.\n    K (int): Eklenecek yatay koridor sayısı.\n    L (int): Eklenecek dikey koridor sayısı.\n    D (int): Sınıftaki konuşan çiftlerin sayısı.\n    chatting_pairs (list of tuples): Her biri bir konuşan çiftin (Xi, Yi) ve (Pi, Qi) pozisyonlarını içeren bir demet listesi.\n\n    Dönüş Değeri:\n    (str, str): Koridorlar için en uygun sıra ve sütun indekslerini temsil eden iki boşlukla ayrılmış string.\n\n    Fonksiyon, her olası pozisyonda bir koridor ekleyerek ayrılabilecek konuşan çiftlerin sayısını sayarak çalışır.\n    Daha sonra, mümkün olduğunca çok konuşan çifti ayırmayı hedefleyerek koridorlar için en etkili pozisyonları seçer.\n\n    Örnekler:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Dönüş: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Dönüş: ('2', '2')\n    \"\"\"", "vi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Tối ưu hóa việc sắp xếp lối đi trong lớp học để giảm thiểu việc trò chuyện giữa các học sinh.\n\n    Tham số:\n    M (int): Số hàng trong lớp học.\n    N (int): Số cột trong lớp học.\n    K (int): Số lối đi ngang cần thêm.\n    L (int): Số lối đi dọc cần thêm.\n    D (int): Số cặp trò chuyện trong lớp học.\n    chatting_pairs (list of tuples): Danh sách các bộ giá trị, mỗi bộ chứa vị trí (Xi, Yi) và (Pi, Qi) của một cặp trò chuyện.\n\n    Trả về:\n    (str, str): Hai chuỗi cách nhau bởi dấu cách đại diện cho chỉ số hàng và cột tối ưu cho các lối đi.\n\n    Hàm hoạt động bằng cách đếm số cặp trò chuyện có thể được tách ra bằng cách thêm một lối đi ở mỗi vị trí có thể.\n    Sau đó, nó chọn các vị trí hiệu quả nhất cho các lối đi, nhằm tách càng nhiều cặp trò chuyện càng tốt.\n\n    Ví dụ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Trả về: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Trả về: ('2', '2')\n    \"\"\"", "id": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimalkan penempatan lorong di ruang kelas untuk meminimalkan jumlah percakapan antara siswa.\n\n    Args:\n    M (int): Jumlah baris di ruang kelas.\n    N (int): Jumlah kolom di ruang kelas.\n    K (int): Jumlah lorong horizontal yang akan ditambahkan.\n    L (int): Jumlah lorong vertikal yang akan ditambahkan.\n    D (int): Jumlah pasangan yang bercakap-cakap di ruang kelas.\n    chatting_pairs (list of tuples): Daftar tuple, masing-masing berisi posisi (Xi, Yi) dan (Pi, Qi) dari pasangan yang bercakap-cakap.\n\n    Returns:\n    (str, str): Dua string yang dipisahkan oleh spasi yang mewakili indeks baris dan kolom optimal untuk lorong.\n\n    Fungsi ini bekerja dengan menghitung jumlah pasangan yang bercakap-cakap yang dapat dipisahkan dengan menambahkan lorong di setiap posisi yang mungkin.\n    Kemudian memilih posisi paling efektif untuk lorong, dengan tujuan memisahkan sebanyak mungkin pasangan yang bercakap-cakap.\n\n    Contoh:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "ja": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    教室内の生徒間の会話を最小限に抑えるために、通路の配置を最適化します。\n\n    引数:\n    M (int): 教室の行数。\n    N (int): 教室の列数。\n    K (int): 追加する水平通路の数。\n    L (int): 追加する垂直通路の数。\n    D (int): 教室内の会話ペアの数。\n    chatting_pairs (list of tuples): 会話ペアの位置 (Xi, Yi) と (Pi, Qi) を含むタプルのリスト。\n\n    戻り値:\n    (str, str): 最適な行と列のインデックスを表す2つのスペース区切りの文字列。\n\n    この関数は、各可能な位置に通路を追加することで分離できる会話ペアの数を数えます。\n    そして、できるだけ多くの会話ペアを分離することを目的として、通路の最も効果的な位置を選択します。\n\n    例:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "ko": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    교실에서 학생들 간의 대화를 최소화하기 위해 통로의 배치를 최적화합니다.\n\n    매개변수:\n    M (int): 교실의 행 수.\n    N (int): 교실의 열 수.\n    K (int): 추가할 수평 통로의 수.\n    L (int): 추가할 수직 통로의 수.\n    D (int): 교실 내 대화 쌍의 수.\n    chatting_pairs (list of tuples): 각 대화 쌍의 위치 (Xi, Yi)와 (Pi, Qi)를 포함하는 튜플의 리스트.\n\n    반환값:\n    (str, str): 통로의 최적 행 및 열 인덱스를 나타내는 두 개의 공백으로 구분된 문자열.\n\n    이 함수는 각 가능한 위치에 통로를 추가하여 분리할 수 있는 대화 쌍의 수를 계산합니다.\n    그런 다음 가능한 한 많은 대화 쌍을 분리하기 위해 가장 효과적인 통로 위치를 선택합니다.\n\n    예제:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "ml": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    ക്ലാസ് മുറിയിലെ വിദ്യാർത്ഥികൾ തമ്മിലുള്ള സംഭാഷണം കുറയ്ക്കുന്നതിനായി പാതകളുടെ സ്ഥാനം മെച്ചപ്പെടുത്തുക.\n\n    Args:\n    M (int): ക്ലാസ് മുറിയിലെ നിരകളുടെ എണ്ണം.\n    N (int): ക്ലാസ് മുറിയിലെ നിരകളുടെ എണ്ണം.\n    K (int): ചേർക്കേണ്ട കിടപ്പ് പാതകളുടെ എണ്ണം.\n    L (int): ചേർക്കേണ്ട ലംബ പാതകളുടെ എണ്ണം.\n    D (int): ക്ലാസ് മുറിയിലെ സംഭാഷണ ജോഡികളുടെ എണ്ണം.\n    chatting_pairs (list of tuples): ഓരോ സംഭാഷണ ജോഡിയുടെ സ്ഥാനങ്ങൾ (Xi, Yi) and (Pi, Qi) അടങ്ങിയ ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\n    Returns:\n    (str, str): പാതകൾക്കായുള്ള ഏറ്റവും അനുയോജ്യമായ നിര, നിര സൂചികകൾ പ്രതിനിധീകരിക്കുന്ന രണ്ട് സ്പേസ്-വേർപെടുത്തിയ സ്ട്രിംഗുകൾ.\n\n    ഓരോ സാധ്യതയുള്ള സ്ഥാനത്തും ഒരു പാത ചേർത്താൽ വേർപെടുത്താൻ കഴിയുന്ന സംഭാഷണ ജോഡികളുടെ എണ്ണം എണ്ണിയതാണ് ഫംഗ്ഷൻ പ്രവർത്തിക്കുന്നത്.\n    ഇത് പാതകൾക്കായുള്ള ഏറ്റവും ഫലപ്രദമായ സ്ഥാനങ്ങൾ തിരഞ്ഞെടുക്കുന്നു, ככל സാധ്യമായത്ര സംഭാഷണ ജോഡികളെ വേർപെടുത്താൻ ലക്ഷ്യമിടുന്നു.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"", "fa": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    بهینه‌سازی قرار دادن راهروها در یک کلاس درس برای به حداقل رساندن میزان صحبت کردن بین دانش‌آموزان.\n\n    Args:\n    M (int): تعداد ردیف‌ها در کلاس درس.\n    N (int): تعداد ستون‌ها در کلاس درس.\n    K (int): تعداد راهروهای افقی که باید اضافه شود.\n    L (int): تعداد راهروهای عمودی که باید اضافه شود.\n    D (int): تعداد جفت‌های صحبت‌کننده در کلاس درس.\n    chatting_pairs (list of tuples): لیستی از جفت‌ها که هر کدام شامل موقعیت‌های (Xi, Yi) و (Pi, Qi) یک جفت صحبت‌کننده است.\n\n    Returns:\n    (str, str): دو رشته جدا شده با فاصله که نمایانگر شاخص‌های بهینه ردیف و ستون برای راهروها هستند.\n\n    این تابع با شمارش تعداد جفت‌های صحبت‌کننده که می‌توان با اضافه کردن یک راهرو در هر موقعیت ممکن جدا کرد، کار می‌کند.\n    سپس مؤثرترین موقعیت‌ها برای راهروها را انتخاب می‌کند، با هدف جدا کردن هر چه بیشتر جفت‌های صحبت‌کننده.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\""}, "canonical_solution": "# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)", "instruction": {"en": "Write a python function 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' to solve the following problem:\n\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    ", "sq": "Shkruani një funksion python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' për të zgjidhur problemin e mëposhtëm:\n\n    Optimizoni vendosjen e korridoreve në një klasë për të minimizuar sasinë e bisedave midis studentëve.\n\n    Argumentet:\n    M (int): Numri i rreshtave në klasë.\n    N (int): Numri i kolonave në klasë.\n    K (int): Numri i korridoreve horizontale për të shtuar.\n    L (int): Numri i korridoreve vertikale për të shtuar.\n    D (int): Numri i çifteve që bisedojnë në klasë.\n    chatting_pairs (list of tuples): Një listë tuples, secila përmban pozicionet (Xi, Yi) dhe (Pi, Qi) të një çifti që bisedon.\n\n    Kthen:\n    (str, str): Dy vargje të ndara me hapësirë që përfaqësojnë indeksin optimal të rreshtit dhe kolonës për korridoret.\n\n    Funksioni punon duke numëruar numrin e çifteve që bisedojnë që mund të ndahen duke shtuar një korridor në secilën pozicion të mundshëm.\n    Më pas zgjedh pozicionet më efektive për korridoret, duke synuar të ndajë sa më shumë çifte që bisedojnë të jetë e mundur.\n\n    Shembuj:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Kthen: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Kthen: ('2', '2')", "hy": "Պայթոն ֆունկցիա 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Օպտիմալացրեք դասարանում միջանցքների տեղադրումը՝ նվազեցնելու ուսանողների միջև զրույցների քանակը:\n\n    Արգումենտներ:\n    M (int): Դասարանի շարքերի քանակը:\n    N (int): Դասարանի սյուների քանակը:\n    K (int): Ավելացվող հորիզոնական միջանցքների քանակը:\n    L (int): Ավելացվող ուղղահայաց միջանցքների քանակը:\n    D (int): Դասարանում զրուցող զույգերի քանակը:\n    chatting_pairs (list of tuples): Կրկնակի ցուցակ, որը պարունակում է զրուցող զույգի դիրքերը (Xi, Yi) և (Pi, Qi):\n\n    Վերադարձնում է:\n    (str, str): Երկու տարածքով բաժանված տողեր, որոնք ներկայացնում են միջանցքների օպտիմալ շարքի և սյան ինդեքսները:\n\n    Ֆունկցիան աշխատում է՝ հաշվելով զրուցող զույգերի քանակը, որոնք կարող են բաժանվել՝ յուրաքանչյուր հնարավոր դիրքում միջանցք ավելացնելով:\n    Այնուհետև ընտրում է միջանցքների համար ամենաարդյունավետ դիրքերը՝ հնարավորինս շատ զրուցող զույգեր բաժանելու նպատակով:\n\n    Օրինակներ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Վերադարձնում է: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Վերադարձնում է: ('2', '2')", "bn": "একটি পাইথন ফাংশন 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    শ্রেণীকক্ষে পথের অবস্থানকে অপ্টিমাইজ করুন যাতে শিক্ষার্থীদের মধ্যে কথোপকথনের পরিমাণ কমানো যায়।\n\n    আর্গুমেন্টস:\n    M (int): শ্রেণীকক্ষে সারির সংখ্যা।\n    N (int): শ্রেণীকক্ষে কলামের সংখ্যা।\n    K (int): যোগ করার জন্য অনুভূমিক পথের সংখ্যা।\n    L (int): যোগ করার জন্য উল্লম্ব পথের সংখ্যা।\n    D (int): শ্রেণীকক্ষে কথোপকথনকারী জোড়ার সংখ্যা।\n    chatting_pairs (list of tuples): একটি তালিকা যা প্রতিটি জোড়ার অবস্থান (Xi, Yi) এবং (Pi, Qi) ধারণ করে।\n\n    রিটার্নস:\n    (str, str): দুটি স্পেস-আলাদা স্ট্রিং যা পথের জন্য সর্বোত্তম সারি এবং কলামের সূচক নির্দেশ করে।\n\n    ফাংশনটি কাজ করে প্রতিটি সম্ভাব্য অবস্থানে একটি পথ যোগ করে কতগুলি কথোপকথনকারী জোড়া আলাদা করা যেতে পারে তা গণনা করে।\n    তারপর এটি পথের জন্য সবচেয়ে কার্যকর অবস্থানগুলি নির্বাচন করে, যতটা সম্ভব কথোপকথনকারী জোড়া আলাদা করার লক্ষ্য নিয়ে।\n\n    উদাহরণ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    রিটার্নস: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    রিটার্নস: ('2', '2')", "bg": "Напишете Python функция 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):', за да решите следния проблем:\n\n    Оптимизирайте разположението на пътеките в класната стая, за да минимизирате количеството разговори между учениците.\n\n    Аргументи:\n    M (int): Броят на редовете в класната стая.\n    N (int): Броят на колоните в класната стая.\n    K (int): Броят на хоризонталните пътеки, които да се добавят.\n    L (int): Броят на вертикалните пътеки, които да се добавят.\n    D (int): Броят на двойките, които си говорят в класната стая.\n    chatting_pairs (списък от кортежи): Списък от кортежи, всеки съдържащ позициите (Xi, Yi) и (Pi, Qi) на двойка, която си говори.\n\n    Връща:\n    (str, str): Два стринга, разделени с интервал, представляващи оптималните индекси на редовете и колоните за пътеките.\n\n    Функцията работи, като брои броя на двойките, които могат да бъдат разделени чрез добавяне на пътека на всяка възможна позиция.\n    След това избира най-ефективните позиции за пътеките, с цел да раздели възможно най-много двойки, които си говорят.\n\n    Примери:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Връща: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Връща: ('2', '2')", "zh": "编写一个python函数 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' 来解决以下问题：\n\n    优化教室中过道的放置，以最小化学生之间的交谈量。\n\n    参数:\n    M (int): 教室中的行数。\n    N (int): 教室中的列数。\n    K (int): 要添加的水平过道数量。\n    L (int): 要添加的垂直过道数量。\n    D (int): 教室中交谈的对数。\n    chatting_pairs (list of tuples): 一个元组列表，每个元组包含一个交谈对的位置 (Xi, Yi) 和 (Pi, Qi)。\n\n    返回:\n    (str, str): 两个以空格分隔的字符串，表示过道的最佳行和列索引。\n\n    该函数通过计算在每个可能的位置添加过道可以分开的交谈对数来工作。\n    然后选择最有效的过道位置，旨在尽可能多地分开交谈对。\n\n    示例:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    返回: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    返回: ('2', '2')", "fr": "Écrivez une fonction python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' pour résoudre le problème suivant :\n\n    Optimiser le placement des allées dans une salle de classe pour minimiser la quantité de bavardage entre les étudiants.\n\n    Arguments :\n    M (int) : Le nombre de rangées dans la salle de classe.\n    N (int) : Le nombre de colonnes dans la salle de classe.\n    K (int) : Le nombre d'allées horizontales à ajouter.\n    L (int) : Le nombre d'allées verticales à ajouter.\n    D (int) : Le nombre de paires bavardantes dans la salle de classe.\n    chatting_pairs (liste de tuples) : Une liste de tuples, chacun contenant les positions (Xi, Yi) et (Pi, Qi) d'une paire bavardante.\n\n    Renvoie :\n    (str, str) : Deux chaînes séparées par des espaces représentant les indices de rangées et de colonnes optimaux pour les allées.\n\n    La fonction fonctionne en comptant le nombre de paires bavardantes qui peuvent être séparées en ajoutant une allée à chaque position possible.\n    Elle sélectionne ensuite les positions les plus efficaces pour les allées, visant à séparer autant de paires bavardantes que possible.\n\n    Exemples :\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Renvoie : ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Renvoie : ('2', '2')", "de": "Schreiben Sie eine Python-Funktion 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):', um das folgende Problem zu lösen:\n\n    Optimieren Sie die Platzierung von Gängen in einem Klassenzimmer, um die Menge an Gesprächen zwischen den Schülern zu minimieren.\n\n    Argumente:\n    M (int): Die Anzahl der Reihen im Klassenzimmer.\n    N (int): Die Anzahl der Spalten im Klassenzimmer.\n    K (int): Die Anzahl der hinzuzufügenden horizontalen Gänge.\n    L (int): Die Anzahl der hinzuzufügenden vertikalen Gänge.\n    D (int): Die Anzahl der Gesprächspaare im Klassenzimmer.\n    chatting_pairs (Liste von Tupeln): Eine Liste von Tupeln, die jeweils die Positionen (Xi, Yi) und (Pi, Qi) eines Gesprächspaares enthalten.\n\n    Rückgaben:\n    (str, str): Zwei durch Leerzeichen getrennte Zeichenfolgen, die die optimalen Reihen- und Spaltenindizes für die Gänge darstellen.\n\n    Die Funktion arbeitet, indem sie die Anzahl der Gesprächspaare zählt, die durch das Hinzufügen eines Gangs an jeder möglichen Position getrennt werden können.\n    Anschließend wählt sie die effektivsten Positionen für die Gänge aus, um so viele Gesprächspaare wie möglich zu trennen.\n\n    Beispiele:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Gibt zurück: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Gibt zurück: ('2', '2')", "ha": "Rubuta wani aikin python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' don warware matsalar mai zuwa:\n\n    Inganta wurin da za a sanya hanyoyin shiga a cikin aji don rage yawan magana tsakanin ɗalibai.\n\n    Args:\n    M (int): Yawan layuka a cikin aji.\n    N (int): Yawan ginshiƙai a cikin aji.\n    K (int): Yawan hanyoyin shiga a kwance da za a ƙara.\n    L (int): Yawan hanyoyin shiga a tsaye da za a ƙara.\n    D (int): Yawan ma'aurata masu magana a cikin aji.\n    chatting_pairs (list of tuples): Jerin tuples, kowanne yana ɗauke da wuraren (Xi, Yi) da (Pi, Qi) na ma'aurata masu magana.\n\n    Returns:\n    (str, str): Haruffa guda biyu da aka raba da sarari suna wakiltar mafi kyawun layi da ginshiƙai don hanyoyin shiga.\n\n    Aikin yana aiki ta hanyar ƙididdige yawan ma'aurata masu magana da za a iya raba ta hanyar ƙara hanya a kowanne matsayi mai yiwuwa.\n    Sannan yana zaɓar wurare mafi inganci don hanyoyin shiga, yana nufin raba ma'aurata masu magana da yawa gwargwadon iko.\n\n    Misalai:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "hi": "एक पायथन फ़ंक्शन 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    कक्षा में गलियारों के स्थान को अनुकूलित करें ताकि छात्रों के बीच बातचीत की मात्रा को कम किया जा सके।\n\n    तर्क:\n    M (int): कक्षा में पंक्तियों की संख्या।\n    N (int): कक्षा में स्तंभों की संख्या।\n    K (int): जोड़ने के लिए क्षैतिज गलियारों की संख्या।\n    L (int): जोड़ने के लिए लंबवत गलियारों की संख्या।\n    D (int): कक्षा में बातचीत करने वाले जोड़ों की संख्या।\n    chatting_pairs (list of tuples): ट्यूपल की एक सूची, जिसमें प्रत्येक में बातचीत करने वाले जोड़े की स्थिति (Xi, Yi) और (Pi, Qi) होती है।\n\n    लौटाता है:\n    (str, str): दो स्पेस सेपरेटेड स्ट्रिंग्स जो गलियारों के लिए अनुकूलतम पंक्ति और स्तंभ सूचकांक का प्रतिनिधित्व करती हैं।\n\n    फ़ंक्शन प्रत्येक संभावित स्थिति में गलियारा जोड़कर अलग किए जा सकने वाले बातचीत करने वाले जोड़ों की संख्या की गणना करके काम करता है।\n    फिर यह गलियारों के लिए सबसे प्रभावी स्थानों का चयन करता है, जिसका उद्देश्य यथासंभव अधिक से अधिक बातचीत करने वाले जोड़ों को अलग करना होता है।\n\n    उदाहरण:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "hu": "Írj egy python függvényt 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' a következő probléma megoldására:\n\n    Optimalizáld a folyosók elhelyezését egy osztályteremben, hogy minimalizáld a diákok közötti beszélgetések mennyiségét.\n\n    Argumentumok:\n    M (int): Az osztályterem sorainak száma.\n    N (int): Az osztályterem oszlopainak száma.\n    K (int): A hozzáadandó vízszintes folyosók száma.\n    L (int): A hozzáadandó függőleges folyosók száma.\n    D (int): A beszélgető párok száma az osztályteremben.\n    chatting_pairs (list of tuples): Egy listája a tuple-öknek, amelyek mindegyike tartalmazza egy beszélgető pár pozícióit (Xi, Yi) és (Pi, Qi).\n\n    Visszatérési érték:\n    (str, str): Két szóközzel elválasztott string, amelyek a folyosók optimális sor- és oszlopindexeit jelölik.\n\n    A függvény úgy működik, hogy megszámolja a beszélgető párok számát, amelyeket el lehet választani egy folyosó hozzáadásával minden lehetséges pozícióban.\n    Ezután kiválasztja a leghatékonyabb pozíciókat a folyosók számára, azzal a céllal, hogy a lehető legtöbb beszélgető párt elválassza.\n\n    Példák:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Visszatér: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Visszatér: ('2', '2')", "es": "Escribe una función de Python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' para resolver el siguiente problema:\n\n    Optimizar la colocación de pasillos en un aula para minimizar la cantidad de conversaciones entre estudiantes.\n\n    Argumentos:\n    M (int): El número de filas en el aula.\n    N (int): El número de columnas en el aula.\n    K (int): El número de pasillos horizontales a añadir.\n    L (int): El número de pasillos verticales a añadir.\n    D (int): El número de pares que conversan en el aula.\n    chatting_pairs (lista de tuplas): Una lista de tuplas, cada una contiene las posiciones (Xi, Yi) y (Pi, Qi) de un par que conversa.\n\n    Devuelve:\n    (str, str): Dos cadenas separadas por espacios que representan los índices óptimos de filas y columnas para los pasillos.\n\n    La función trabaja contando el número de pares que conversan y que pueden ser separados añadiendo un pasillo en cada posición posible.\n    Luego selecciona las posiciones más efectivas para los pasillos, con el objetivo de separar la mayor cantidad posible de pares que conversan.\n\n    Ejemplos:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Devuelve: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Devuelve: ('2', '2')", "arb": "اكتب دالة بايثون 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' لحل المشكلة التالية:\n\n    تحسين توزيع الممرات في الفصل الدراسي لتقليل كمية المحادثات بين الطلاب.\n\n    يعيدالحجج:\n    M (int): عدد الصفوف في الفصل الدراسي.\n    N (int): عدد الأعمدة في الفصل الدراسي.\n    K (int): عدد الممرات الأفقية التي يجب إضافتها.\n    L (int): عدد الممرات العمودية التي يجب إضافتها.\n    D (int): عدد الأزواج المتحدثة في الفصل الدراسي.\n    chatting_pairs (list of tuples): قائمة من الأزواج، كل منها يحتوي على المواقع (Xi, Yi) و (Pi, Qi) لزوج متحدث.\n\n    يعيد:\n    (str, str): سلسلتان مفصولتان بمسافة تمثلان مؤشرات الصفوف والأعمدة المثلى للممرات.\n\n    تعمل الدالة عن طريق حساب عدد الأزواج المتحدثة التي يمكن فصلها بإضافة ممر في كل موقع ممكن.\n    ثم تختار المواقع الأكثر فعالية للممرات، بهدف فصل أكبر عدد ممكن من الأزواج المتحدثة.\n\n    أمثلة:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    يعيد: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    يعيد: ('2', '2')", "sw": "Andika kazi ya python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' kutatua tatizo lifuatalo:\n\n    Boresha uwekaji wa njia za kupita darasani ili kupunguza kiasi cha mazungumzo kati ya wanafunzi.\n\n    Hoja:\n    M (int): Idadi ya safu katika darasa.\n    N (int): Idadi ya nguzo katika darasa.\n    K (int): Idadi ya njia za usawa za kuongeza.\n    L (int): Idadi ya njia za wima za kuongeza.\n    D (int): Idadi ya jozi zinazozungumza darasani.\n    chatting_pairs (orodha ya jozi): Orodha ya jozi, kila moja ikiwa na nafasi (Xi, Yi) na (Pi, Qi) ya jozi inayozungumza.\n\n    Inarudisha:\n    (str, str): Mistari miwili iliyotenganishwa na nafasi inayowakilisha faharasa bora za safu na nguzo kwa njia za kupita.\n\n    Kazi hufanya kazi kwa kuhesabu idadi ya jozi zinazozungumza ambazo zinaweza kutenganishwa kwa kuongeza njia ya kupita katika kila nafasi inayowezekana.\n    Kisha huchagua nafasi zenye ufanisi zaidi kwa njia za kupita, ikilenga kutenganisha jozi nyingi zinazozungumza iwezekanavyo.\n\n    Mifano:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Inarudisha: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Inarudisha: ('2', '2')", "tr": "Bir python fonksiyonu 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' yazarak aşağıdaki problemi çözün:\n\n    Bir sınıfta öğrenciler arasındaki konuşmayı en aza indirmek için koridorların yerleştirilmesini optimize edin.\n\n    Argümanlar:\n    M (int): Sınıftaki sıra sayısı.\n    N (int): Sınıftaki sütun sayısı.\n    K (int): Eklenecek yatay koridor sayısı.\n    L (int): Eklenecek dikey koridor sayısı.\n    D (int): Sınıftaki konuşan çiftlerin sayısı.\n    chatting_pairs (list of tuples): Her biri bir konuşan çiftin (Xi, Yi) ve (Pi, Qi) pozisyonlarını içeren bir demet listesi.\n\n    Döndürür:\n    (str, str): Koridorlar için en uygun sıra ve sütun indekslerini temsil eden iki boşlukla ayrılmış string.\n\n    Fonksiyon, her olası pozisyonda bir koridor ekleyerek ayrılabilecek konuşan çiftlerin sayısını sayarak çalışır.\n    Daha sonra, mümkün olduğunca çok konuşan çifti ayırmayı hedefleyerek koridorlar için en etkili pozisyonları seçer.\n\n    Örnekler:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Döndürür: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Döndürür: ('2', '2')", "vi": "Viết một hàm python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' để giải quyết vấn đề sau:\n\n    Tối ưu hóa việc bố trí lối đi trong một lớp học để giảm thiểu lượng trò chuyện giữa các học sinh.\n\n    Tham số:\n    M (int): Số hàng trong lớp học.\n    N (int): Số cột trong lớp học.\n    K (int): Số lối đi ngang cần thêm vào.\n    L (int): Số lối đi dọc cần thêm vào.\n    D (int): Số cặp trò chuyện trong lớp học.\n    chatting_pairs (list of tuples): Một danh sách các bộ giá trị, mỗi bộ chứa các vị trí (Xi, Yi) và (Pi, Qi) của một cặp trò chuyện.\n\n    Trả về:\n    (str, str): Hai chuỗi cách nhau bởi dấu cách đại diện cho chỉ số hàng và cột tối ưu cho các lối đi.\n\n    Hàm hoạt động bằng cách đếm số lượng cặp trò chuyện có thể được tách ra bằng cách thêm một lối đi ở mỗi vị trí có thể.\n    Sau đó, nó chọn các vị trí hiệu quả nhất cho các lối đi, nhằm tách ra càng nhiều cặp trò chuyện càng tốt.\n\n    Ví dụ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Trả về: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Trả về: ('2', '2')", "id": "Tulis fungsi python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' untuk menyelesaikan masalah berikut:\n\n    Optimalkan penempatan lorong di dalam kelas untuk meminimalkan jumlah percakapan antara siswa.\n\n    Args:\n    M (int): Jumlah baris di dalam kelas.\n    N (int): Jumlah kolom di dalam kelas.\n    K (int): Jumlah lorong horizontal yang akan ditambahkan.\n    L (int): Jumlah lorong vertikal yang akan ditambahkan.\n    D (int): Jumlah pasangan yang bercakap-cakap di dalam kelas.\n    chatting_pairs (list of tuples): Daftar tuple, masing-masing berisi posisi (Xi, Yi) dan (Pi, Qi) dari pasangan yang bercakap-cakap.\n\n    Returns:\n    (str, str): Dua string yang dipisahkan oleh spasi yang mewakili indeks baris dan kolom optimal untuk lorong-lorong.\n\n    Fungsi ini bekerja dengan menghitung jumlah pasangan yang bercakap-cakap yang dapat dipisahkan dengan menambahkan lorong di setiap posisi yang memungkinkan.\n    Kemudian memilih posisi paling efektif untuk lorong-lorong, dengan tujuan memisahkan sebanyak mungkin pasangan yang bercakap-cakap.\n\n    Contoh:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "ja": "Python関数 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' を作成して、以下の問題を解決してください:\n\n    教室内の通路の配置を最適化して、生徒間の会話を最小限に抑える。\n\n    引数:\n    M (int): 教室の行数。\n    N (int): 教室の列数。\n    K (int): 追加する水平通路の数。\n    L (int): 追加する垂直通路の数。\n    D (int): 教室内の会話ペアの数。\n    chatting_pairs (リストのタプル): 各タプルは、会話ペアの位置 (Xi, Yi) と (Pi, Qi) を含む。\n\n    戻り値:\n    (str, str): 通路の最適な行と列のインデックスを表す2つのスペース区切りの文字列。\n\n    この関数は、各可能な位置に通路を追加することで分離できる会話ペアの数を数えることによって機能します。\n    そして、できるだけ多くの会話ペアを分離することを目指して、通路の最も効果的な位置を選択します。\n\n    例:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    戻り値: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    戻り値: ('2', '2')", "ko": "파이썬 함수를 작성하세요 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' 다음 문제를 해결하기 위해:\n\n    교실에서 학생들 간의 대화를 최소화하기 위해 통로의 배치를 최적화하세요.\n\n    매개변수:\n    M (int): 교실의 행 수.\n    N (int): 교실의 열 수.\n    K (int): 추가할 수평 통로의 수.\n    L (int): 추가할 수직 통로의 수.\n    D (int): 교실 내 대화하는 쌍의 수.\n    chatting_pairs (list of tuples): 각 쌍의 위치 (Xi, Yi)와 (Pi, Qi)를 포함하는 튜플의 리스트.\n\n    반환값:\n    (str, str): 통로의 최적 행 및 열 인덱스를 나타내는 두 개의 공백으로 구분된 문자열.\n\n    이 함수는 각 가능한 위치에 통로를 추가하여 분리할 수 있는 대화 쌍의 수를 계산하여 작동합니다.\n    그런 다음 가능한 한 많은 대화 쌍을 분리하기 위해 가장 효과적인 통로 위치를 선택합니다.\n\n    예시:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    반환값: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    반환값: ('2', '2')", "ml": "ഒരു പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' താഴെക്കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    ക്ലാസ്സ്‌റൂമിൽ വിദ്യാർത്ഥികൾ തമ്മിലുള്ള സംവാദം കുറയ്ക്കുന്നതിനായി ഇടനാഴികളുടെ സ്ഥാനം മെച്ചപ്പെടുത്തുക.\n\n    Args:\n    M (int): ക്ലാസ്സ്‌റൂമിലെ നിരകളുടെ എണ്ണം.\n    N (int): ക്ലാസ്സ്‌റൂമിലെ നിരകളുടെ എണ്ണം.\n    K (int): ചേർക്കേണ്ട കിടക്ക ഇടനാഴികളുടെ എണ്ണം.\n    L (int): ചേർക്കേണ്ട ലംബ ഇടനാഴികളുടെ എണ്ണം.\n    D (int): ക്ലാസ്സ്‌റൂമിലെ സംവാദ ജോഡികളുടെ എണ്ണം.\n    chatting_pairs (list of tuples): ഓരോ സംവാദ ജോഡിയുടെ സ്ഥാനങ്ങൾ (Xi, Yi) and (Pi, Qi) അടങ്ങിയ ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\n    Returns:\n    (str, str): ഇടനാഴികൾക്കായി ഏറ്റവും അനുയോജ്യമായ നിര, നിരനിരകളുടെ സൂചികകൾ പ്രതിനിധീകരിക്കുന്ന രണ്ട് സ്പേസ്-വേരിയേറ്റ് ചെയ്ത സ്ട്രിംഗുകൾ.\n\n    ഓരോ സാധ്യതയുള്ള സ്ഥാനത്തും ഒരു ഇടനാഴി ചേർക്കുന്നതിലൂടെ വേർതിരിക്കാവുന്ന സംവാദ ജോഡികളുടെ എണ്ണം എണ്ണുന്നതിലൂടെ ഫംഗ്ഷൻ പ്രവർത്തിക്കുന്നു.\n    അതിനുശേഷം όσο കൂടുതൽ സംവാദ ജോഡികളെ വേർതിരിക്കാൻ കഴിയുന്ന സ്ഥാനങ്ങൾ തിരഞ്ഞെടുക്കുന്നു.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "fa": "یک تابع پایتون بنویسید 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' برای حل مسئله زیر:\n\n    جایگذاری راهروها در یک کلاس درس را بهینه کنید تا میزان صحبت کردن بین دانش‌آموزان به حداقل برسد.\n\n    آرگومان‌ها:\n    M (int): تعداد ردیف‌ها در کلاس درس.\n    N (int): تعداد ستون‌ها در کلاس درس.\n    K (int): تعداد راهروهای افقی که باید اضافه شوند.\n    L (int): تعداد راهروهای عمودی که باید اضافه شوند.\n    D (int): تعداد جفت‌های صحبت‌کننده در کلاس درس.\n    chatting_pairs (لیستی از تاپل‌ها): لیستی از تاپل‌ها که هر کدام شامل موقعیت‌های (Xi, Yi) و (Pi, Qi) یک جفت صحبت‌کننده است.\n\n    خروجی:\n    (str, str): دو رشته جدا شده با فاصله که نمایانگر شاخص‌های ردیف و ستون بهینه برای راهروها هستند.\n\n    این تابع با شمارش تعداد جفت‌های صحبت‌کننده که می‌توانند با اضافه کردن یک راهرو در هر موقعیت ممکن جدا شوند، کار می‌کند.\n    سپس مؤثرترین موقعیت‌ها برای راهروها را انتخاب می‌کند، با هدف جدا کردن هرچه بیشتر جفت‌های صحبت‌کننده.\n\n    مثال‌ها:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    خروجی: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    خروجی: ('2', '2')"}, "level": "hard", "test": "def test_optimize_seating():\n    test_cases = [\n        # Test case 1 from the provided example\n        {\n            'M': 4, 'N': 5, 'K': 1, 'L': 2, 'D': 3,\n            'chatting_pairs': [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)],\n            'expected': ('2', '2 4')\n        },\n        # Corrected Test case 2\n        {\n            'M': 5, 'N': 6, 'K': 2, 'L': 3, 'D': 4,\n            'chatting_pairs': [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 6), (5, 1, 5, 2)],\n            'expected': ('1 2', '1 2 5')  # Corrected expected output\n        },\n        # Test case 3\n        {\n            'M': 3, 'N': 3, 'K': 1, 'L': 1, 'D': 2,\n            'chatting_pairs': [(1, 2, 1, 3), (2, 1, 3, 1)],\n            'expected': ('2', '2')\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        row_output, col_output = optimize_seating(\n            test['M'], test['N'], test['K'], test['L'], test['D'], test['chatting_pairs']\n        )\n        assert row_output == test['expected'][0], f\"Test case {i} failed: row_output {row_output} does not match expected {test['expected'][0]}\"\n        assert col_output == test['expected'][1], f\"Test case {i} failed: col_output {col_output} does not match expected {test['expected'][1]}\"\n        print(f\"Test case {i} passed.\")\n\n# Run the test function\ntest_optimize_seating()", "entry_point": "optimize_seating", "signature": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):", "docstring": {"en": "\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    ", "sq": "\n    Optimizoni vendosjen e korridoreve në një klasë për të minimizuar sasinë e bisedave midis studentëve.\n\n    Argumentet:\n    M (int): Numri i rreshtave në klasë.\n    N (int): Numri i kolonave në klasë.\n    K (int): Numri i korridoreve horizontale për t'u shtuar.\n    L (int): Numri i korridoreve vertikale për t'u shtuar.\n    D (int): Numri i çifteve që bisedojnë në klasë.\n    chatting_pairs (list of tuples): Një listë tuples, secila që përmban pozicionet (Xi, Yi) dhe (Pi, Qi) të një çifti që bisedon.\n\n    Kthen:\n    (str, str): Dy vargje të ndara me hapësirë që përfaqësojnë indeksat optimalë të rreshtave dhe kolonave për korridoret.\n\n    Funksioni punon duke numëruar numrin e çifteve që bisedojnë dhe që mund të ndahen duke shtuar një korridor në secilën pozicion të mundshëm.\n    Më pas zgjedh pozicionet më efektive për korridoret, duke synuar të ndajë sa më shumë çifte që bisedojnë.\n\n    Shembuj:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Kthen: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Kthen: ('2', '2')", "hy": "\n    Դասարանում միջանցքների տեղադրումը օպտիմալացնել՝ նվազեցնելու ուսանողների միջև խոսակցությունների քանակը։\n\n    Պարամետրեր:\n    M (int): Դասարանի տողերի քանակը։\n    N (int): Դասարանի սյուների քանակը։\n    K (int): Ավելացվող հորիզոնական միջանցքների քանակը։\n    L (int): Ավելացվող ուղղահայաց միջանցքների քանակը։\n    D (int): Դասարանում խոսակցող զույգերի քանակը։\n    chatting_pairs (list of tuples): Զույգերի ցուցակ, որոնցից յուրաքանչյուրն ունի զույգի դիրքերը (Xi, Yi) և (Pi, Qi)։\n\n    Վերադարձնում է:\n    (str, str): Երկու բացատով բաժանված տողեր, որոնք ներկայացնում են միջանցքների օպտիմալ տողի և սյունակի ինդեքսները։\n\n    Ֆունկցիան աշխատում է՝ հաշվելով խոսակցող զույգերի քանակը, որոնք կարող են բաժանվել՝ յուրաքանչյուր հնարավոր դիրքում միջանցք ավելացնելով։\n    Այնուհետև ընտրում է միջանցքների ամենաարդյունավետ դիրքերը՝ նպատակ ունենալով հնարավորինս շատ զույգերի բաժանել։\n\n    Օրինակներ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Վերադարձնում է: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Վերադարձնում է: ('2', '2')", "bn": "\n    শ্রেণীকক্ষে ছাত্রদের মধ্যে কথোপকথন কমানোর জন্য আইলগুলির অবস্থান অপ্টিমাইজ করুন।\n\n    প্যারামিটার:\n    M (int): শ্রেণীকক্ষের সারির সংখ্যা।\n    N (int): শ্রেণীকক্ষের কলামের সংখ্যা।\n    K (int): যোগ করার জন্য অনুভূমিক আইলের সংখ্যা।\n    L (int): যোগ করার জন্য উল্লম্ব আইলের সংখ্যা।\n    D (int): শ্রেণীকক্ষে কথোপকথনকারী জোড়ার সংখ্যা।\n    chatting_pairs (list of tuples): একটি টুপলের তালিকা, প্রতিটি টুপলে কথোপকথনকারী জোড়ার অবস্থান (Xi, Yi) এবং (Pi, Qi) অন্তর্ভুক্ত।\n\n    রিটার্নস:\n    (str, str): দুটি স্পেস-বিচ্ছিন্ন স্ট্রিং যা আইলগুলির জন্য সর্বোত্তম সারি এবং কলামের সূচক উপস্থাপন করে।\n\n    এই ফাংশনটি প্রতিটি সম্ভাব্য অবস্থানে একটি আইল যোগ করে কতগুলি কথোপকথনকারী জোড়া আলাদা করা যায় তা গণনা করে কাজ করে।\n    তারপর এটি আইলগুলির জন্য সবচেয়ে কার্যকর অবস্থানগুলি নির্বাচন করে, যতটা সম্ভব কথোপকথনকারী জোড়া আলাদা করার লক্ষ্য নিয়ে।\n\n    উদাহরণ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    রিটার্নস: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    রিটার্নস: ('2', '2')", "bg": "\n    Оптимизирайте разположението на пътеките в класната стая, за да минимизирате количеството разговори между учениците.\n\nАргументи:\nM (int): Броят на редовете в класната стая.\nN (int): Броят на колоните в класната стая.\nK (int): Броят на хоризонталните пътеки, които да се добавят.\nL (int): Броят на вертикалните пътеки, които да се добавят.\nD (int): Броят на двойките, които разговарят в класната стая.\nchatting_pairs (list of tuples): Списък от кортежи, всеки от които съдържа позициите (Xi, Yi) и (Pi, Qi) на двойка, която разговаря.\n\nВръща:\n(str, str): Два разделени с интервал низа, представляващи оптималните индекси на редовете и колоните за пътеките.\n\nФункцията работи, като брои броя на двойките, които могат да бъдат разделени чрез добавяне на пътека на всяка възможна позиция.\nСлед това избира най-ефективните позиции за пътеки, с цел да раздели възможно най-много двойки, които разговарят.\n\nПримери:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nВръща: ('2', '2 4')\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nВръща: ('2', '2')", "zh": "\n    优化教室中过道的布局，以最小化学生之间的交谈量。\n\n    参数:\n    M (int): 教室中的行数。\n    N (int): 教室中的列数。\n    K (int): 要添加的水平过道数。\n    L (int): 要添加的垂直过道数。\n    D (int): 教室中交谈对的数量。\n    chatting_pairs (list of tuples): 一个包含元组的列表，每个元组包含一个交谈对的位置 (Xi, Yi) 和 (Pi, Qi)。\n\n    返回:\n    (str, str): 两个用空格分隔的字符串，表示过道的最佳行和列索引。\n\n    该函数通过计算可以通过在每个可能位置添加过道来分隔的交谈对的数量来工作。\n    然后选择最有效的过道位置，旨在尽可能多地分隔交谈对。\n\n    示例:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    返回: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    返回: ('2', '2')", "fr": "\n    Optimiser le placement des allées dans une salle de classe pour minimiser la quantité de bavardages entre les élèves.\n\n    Args:\n    M (int): Le nombre de rangées dans la salle de classe.\n    N (int): Le nombre de colonnes dans la salle de classe.\n    K (int): Le nombre d'allées horizontales à ajouter.\n    L (int): Le nombre d'allées verticales à ajouter.\n    D (int): Le nombre de paires bavardant dans la salle de classe.\n    chatting_pairs (list of tuples): Une liste de tuples, chacun contenant les positions (Xi, Yi) et (Pi, Qi) d'une paire bavardant.\n\n    Returns:\n    (str, str): Deux chaînes séparées par des espaces représentant les indices optimaux de rangées et de colonnes pour les allées.\n\n    La fonction fonctionne en comptant le nombre de paires bavardant qui peuvent être séparées en ajoutant une allée à chaque position possible.\n    Elle sélectionne ensuite les positions les plus efficaces pour les allées, visant à séparer autant de paires bavardant que possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "de": "\n    Optimieren Sie die Platzierung der Gänge in einem Klassenzimmer, um die Menge an Gesprächen zwischen den Schülern zu minimieren.\n\n    Args:\n    M (int): Die Anzahl der Reihen im Klassenzimmer.\n    N (int): Die Anzahl der Spalten im Klassenzimmer.\n    K (int): Die Anzahl der hinzuzufügenden horizontalen Gänge.\n    L (int): Die Anzahl der hinzuzufügenden vertikalen Gänge.\n    D (int): Die Anzahl der Gesprächspaare im Klassenzimmer.\n    chatting_pairs (list of tuples): Eine Liste von Tupeln, die jeweils die Positionen (Xi, Yi) und (Pi, Qi) eines Gesprächspaares enthalten.\n\n    Returns:\n    (str, str): Zwei durch Leerzeichen getrennte Zeichenfolgen, die die optimalen Reihen- und Spaltenindizes für die Gänge darstellen.\n\n    Die Funktion arbeitet, indem sie die Anzahl der Gesprächspaare zählt, die durch das Hinzufügen eines Gangs an jeder möglichen Position getrennt werden können.\n    Anschließend wählt sie die effektivsten Positionen für die Gänge aus, um möglichst viele Gesprächspaare zu trennen.\n\n    Beispiele:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "ha": "\n    Inganta wuraren da aka sanya hanyoyin wucewa a cikin aji don rage yawan hira tsakanin ɗalibai.\n\n    Args:\n    M (int): Yawan layukan kujeru a cikin aji.\n    N (int): Yawan ginshiƙai a cikin aji.\n    K (int): Yawan hanyoyin wucewa na kwance da za a ƙara.\n    L (int): Yawan hanyoyin wucewa na tsaye da za a ƙara.\n    D (int): Yawan ma'aurata masu hira a cikin aji.\n    chatting_pairs (list of tuples): Jerin tuples, kowanne yana ɗauke da wuraren (Xi, Yi) da (Pi, Qi) na ma'aurata masu hira.\n\n    Returns:\n    (str, str): Haruffa guda biyu da aka raba da sarari suna wakiltar wuraren layi da ginshiƙai mafi kyau don hanyoyin wucewa.\n\n    Aiki yana aiki ta hanyar ƙididdige yawan ma'aurata masu hira da za a iya raba ta hanyar ƙara hanya a kowane matsayi mai yiwuwa.\n    Sannan yana zaɓar wuraren da suka fi dacewa don hanyoyin wucewa, yana nufin raba ma'aurata masu hira da yawa gwargwadon iko.\n\n    Misalai:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "hi": "\n    कक्षा में गलियारों की व्यवस्था को इस प्रकार अनुकूलित करें कि छात्रों के बीच बातचीत की मात्रा न्यूनतम हो सके।\n\n    Args:\n    M (int): कक्षा में पंक्तियों की संख्या।\n    N (int): कक्षा में स्तंभों की संख्या।\n    K (int): जोड़ने के लिए क्षैतिज गलियारों की संख्या।\n    L (int): जोड़ने के लिए ऊर्ध्वाधर गलियारों की संख्या।\n    D (int): कक्षा में बातचीत करने वाले जोड़ों की संख्या।\n    chatting_pairs (list of tuples): एक सूची जिसमें प्रत्येक तत्व एक युग्म के स्थान (Xi, Yi) और (Pi, Qi) को दर्शाता है जो बातचीत कर रहे हैं।\n\n    Returns:\n    (str, str): दो स्पेस सेपरेटेड स्ट्रिंग्स जो गलियारों के लिए अनुकूलतम पंक्ति और स्तंभ सूचकांक दर्शाती हैं।\n\n    यह फ़ंक्शन प्रत्येक संभावित स्थिति में गलियारा जोड़कर अलग किए जा सकने वाले बातचीत करने वाले जोड़ों की संख्या की गणना करके कार्य करता है।\n    फिर यह गलियारों के लिए सबसे प्रभावी स्थानों का चयन करता है, जिसका उद्देश्य जितना संभव हो सके उतने बातचीत करने वाले जोड़ों को अलग करना है।\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "hu": "\n    Optimalizálja a folyosók elhelyezését egy osztályteremben, hogy minimalizálja a diákok közötti beszélgetés mennyiségét.\n\n    Paraméterek:\n    M (int): Az osztályterem sorainak száma.\n    N (int): Az osztályterem oszlopainak száma.\n    K (int): A hozzáadandó vízszintes folyosók száma.\n    L (int): A hozzáadandó függőleges folyosók száma.\n    D (int): A beszélgető párok száma az osztályteremben.\n    chatting_pairs (list of tuples): Egy listája a pároknak, amelyek mindegyike tartalmazza egy beszélgető pár pozícióit (Xi, Yi) és (Pi, Qi).\n\n    Visszatérési érték:\n    (str, str): Két szóközzel elválasztott karakterlánc, amelyek a folyosók optimális sor- és oszlopindexeit képviselik.\n\n    A függvény úgy működik, hogy megszámolja a beszélgető párok számát, amelyek elválaszthatók egy folyosó hozzáadásával minden lehetséges pozícióban.\n    Ezután kiválasztja a leghatékonyabb pozíciókat a folyosók számára, azzal a céllal, hogy a lehető legtöbb beszélgető párt elválassza.\n\n    Példák:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Visszatér: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Visszatér: ('2', '2')", "es": "Optimizar la colocación de pasillos en un aula para minimizar la cantidad de charlas entre estudiantes.\n\nArgumentos:\nM (int): El número de filas en el aula.\nN (int): El número de columnas en el aula.\nK (int): El número de pasillos horizontales a añadir.\nL (int): El número de pasillos verticales a añadir.\nD (int): El número de pares de charlas en el aula.\nchatting_pairs (list of tuples): Una lista de tuplas, cada una contiene las posiciones (Xi, Yi) y (Pi, Qi) de un par de charlas.\n\nDevuelve:\n(str, str): Dos cadenas separadas por espacios que representan los índices óptimos de filas y columnas para los pasillos.\n\nLa función trabaja contando el número de pares de charlas que pueden ser separados añadiendo un pasillo en cada posición posible. Luego selecciona las posiciones más efectivas para los pasillos, con el objetivo de separar la mayor cantidad posible de pares de charlas.\n\nEjemplos:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nDevuelve: ('2', '2 4')\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nDevuelve: ('2', '2')", "arb": "\n    تحسين وضع الممرات في الفصل الدراسي لتقليل كمية الدردشة بين الطلاب.\n\n    يعيدالحجج:\n    M (int): عدد الصفوف في الفصل الدراسي.\n    N (int): عدد الأعمدة في الفصل الدراسي.\n    K (int): عدد الممرات الأفقية التي سيتم إضافتها.\n    L (int): عدد الممرات العمودية التي سيتم إضافتها.\n    D (int): عدد الأزواج التي تتحدث في الفصل الدراسي.\n    chatting_pairs (list of tuples): قائمة من الأزواج، يحتوي كل زوج على المواقع (Xi, Yi) و (Pi, Qi) لزوج يتحدث.\n\n    يعيد:\n    (str, str): سلسلتان مفصولتان بمسافة تمثلان الفهارس المثلى للصفوف والأعمدة للممرات.\n\n    تعمل الدالة عن طريق حساب عدد الأزواج التي يمكن فصلها بإضافة ممر في كل موضع ممكن.\n    ثم تختار المواضع الأكثر فعالية للممرات، بهدف فصل أكبر عدد ممكن من الأزواج.\n\n    امثله:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    يعيد: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    يعيد: ('2', '2')", "sw": "\n    Boresha uwekaji wa njia za kupita darasani ili kupunguza mazungumzo kati ya wanafunzi.\n\n    Hoja:\n    M (int): Idadi ya mistari katika darasa.\n    N (int): Idadi ya safu katika darasa.\n    K (int): Idadi ya njia za usawa za kuongeza.\n    L (int): Idadi ya njia za wima za kuongeza.\n    D (int): Idadi ya wanandoa wanaozungumza darasani.\n    chatting_pairs (orodha ya jozi): Orodha ya jozi, kila moja ikiwa na nafasi (Xi, Yi) na (Pi, Qi) ya wanandoa wanaozungumza.\n\n    Inarejesha:\n    (str, str): Mistari miwili iliyotenganishwa na nafasi inayoonyesha faharasa bora za mistari na safu kwa njia za kupita.\n\n    Kazi hii inafanya kazi kwa kuhesabu idadi ya wanandoa wanaozungumza ambao wanaweza kutenganishwa kwa kuongeza njia ya kupita katika kila nafasi inayowezekana.\n    Kisha huchagua nafasi bora zaidi za njia za kupita, ikilenga kutenganisha wanandoa wengi wanaozungumza iwezekanavyo.\n\n    Mifano:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Inarudisha: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Inarudisha: ('2', '2')", "tr": "Optimize sınıftaki koridorların yerleşimini, öğrenciler arasındaki sohbet miktarını en aza indirmek için optimize edin.\n\nArgümanlar:\nM (int): Sınıftaki sıra sayısı.\nN (int): Sınıftaki sütun sayısı.\nK (int): Eklenecek yatay koridor sayısı.\nL (int): Eklenecek dikey koridor sayısı.\nD (int): Sınıftaki sohbet eden çift sayısı.\nchatting_pairs (list of tuples): Her biri sohbet eden bir çiftin (Xi, Yi) ve (Pi, Qi) pozisyonlarını içeren demetlerden oluşan bir liste.\n\nDöndürür:\n(str, str): Koridorlar için en uygun sıra ve sütun indekslerini temsil eden iki boşlukla ayrılmış string.\n\nFonksiyon, her olası pozisyonda bir koridor ekleyerek ayrılabilecek sohbet eden çiftlerin sayısını sayarak çalışır. Ardından, mümkün olduğunca çok sohbet eden çifti ayırmayı hedefleyerek koridorlar için en etkili pozisyonları seçer.\n\nÖrnekler:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nDöndürür: ('2', '2 4')\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nDöndürür: ('2', '2')", "vi": "\n    Tối ưu hóa việc bố trí lối đi trong một lớp học để giảm thiểu lượng trò chuyện giữa các học sinh.\n\n    Tham số:\n    M (int): Số hàng trong lớp học.\n    N (int): Số cột trong lớp học.\n    K (int): Số lối đi ngang cần thêm.\n    L (int): Số lối đi dọc cần thêm.\n    D (int): Số cặp trò chuyện trong lớp học.\n    chatting_pairs (list of tuples): Danh sách các bộ giá trị, mỗi bộ chứa vị trí (Xi, Yi) và (Pi, Qi) của một cặp trò chuyện.\n\n    Trả về:\n    (str, str): Hai chuỗi cách nhau bởi dấu cách đại diện cho chỉ số hàng và cột tối ưu cho các lối đi.\n\n    Hàm hoạt động bằng cách đếm số cặp trò chuyện có thể được tách ra bằng cách thêm một lối đi ở mỗi vị trí có thể.\n    Sau đó, nó chọn các vị trí hiệu quả nhất cho các lối đi, nhằm tách ra càng nhiều cặp trò chuyện càng tốt.\n\n    Ví dụ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Trả về: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Trả về: ('2', '2')", "id": "Mengoptimalkan penempatan lorong di dalam kelas untuk meminimalkan jumlah percakapan antara siswa.\n\nArgs:\nM (int): Jumlah baris di dalam kelas.\nN (int): Jumlah kolom di dalam kelas.\nK (int): Jumlah lorong horizontal yang akan ditambahkan.\nL (int): Jumlah lorong vertikal yang akan ditambahkan.\nD (int): Jumlah pasangan yang bercakap-cakap di dalam kelas.\nchatting_pairs (list of tuples): Daftar tuple, masing-masing berisi posisi (Xi, Yi) dan (Pi, Qi) dari pasangan yang bercakap-cakap.\n\nReturns:\n(str, str): Dua string yang dipisahkan oleh spasi yang mewakili indeks baris dan kolom optimal untuk lorong.\n\nFungsi ini bekerja dengan menghitung jumlah pasangan yang bercakap-cakap yang dapat dipisahkan dengan menambahkan lorong di setiap posisi yang memungkinkan. Kemudian, fungsi ini memilih posisi yang paling efektif untuk lorong, dengan tujuan memisahkan sebanyak mungkin pasangan yang bercakap-cakap.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4')\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2')", "ja": "    教室内の通路の配置を最適化し、生徒間の会話を最小限に抑えます。\n\n    Args:\n    M (int): 教室の行数。\n    N (int): 教室の列数。\n    K (int): 追加する水平通路の数。\n    L (int): 追加する垂直通路の数。\n    D (int): 教室内の会話ペアの数。\n    chatting_pairs (list of tuples): 各タプルには、会話ペアの位置 (Xi, Yi) と (Pi, Qi) が含まれます。\n\n    Returns:\n    (str, str): 通路の最適な行と列のインデックスを表す2つのスペースで区切られた文字列。\n\n    この関数は、各可能な位置に通路を追加することで分離できる会話ペアの数を数えることによって動作します。\n    そして、できるだけ多くの会話ペアを分離することを目指して、通路の最も効果的な位置を選択します。\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "ko": "교실에서 학생들 간의 대화를 최소화하기 위해 통로의 배치를 최적화합니다.\n\nArgs:\nM (int): 교실의 행 수.\nN (int): 교실의 열 수.\nK (int): 추가할 가로 통로의 수.\nL (int): 추가할 세로 통로의 수.\nD (int): 교실 내 대화하는 학생 쌍의 수.\nchatting_pairs (list of tuples): 각 쌍의 위치 (Xi, Yi)와 (Pi, Qi)를 포함하는 튜플의 리스트.\n\nReturns:\n(str, str): 통로에 대한 최적의 행 및 열 인덱스를 나타내는 두 개의 공백으로 구분된 문자열.\n\n이 함수는 각 가능한 위치에 통로를 추가하여 분리할 수 있는 대화 쌍의 수를 계산합니다. 그런 다음 가능한 한 많은 대화 쌍을 분리하기 위해 가장 효과적인 통로 위치를 선택합니다.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4')\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2')", "ml": "    ക്ലാസ്റൂമിലെ വിദ്യാർത്ഥികൾ തമ്മിലുള്ള സംഭാഷണം കുറയ്ക്കുന്നതിനായി പാതകളുടെ സ്ഥാനം മെച്ചപ്പെടുത്തുക.\n\n    Args:\n    M (int): ക്ലാസ്റൂമിലെ നിരകളുടെ എണ്ണം.\n    N (int): ക്ലാസ്റൂമിലെ നിരകളുടെ എണ്ണം.\n    K (int): ചേർക്കേണ്ട കിടക്കുന്ന പാതകളുടെ എണ്ണം.\n    L (int): ചേർക്കേണ്ട നില്ക്കുന്ന പാതകളുടെ എണ്ണം.\n    D (int): ക്ലാസ്റൂമിലെ സംഭാഷണ ജോഡികളുടെ എണ്ണം.\n    chatting_pairs (list of tuples): ഓരോ സംഭാഷണ ജോഡിയുടെ സ്ഥാനങ്ങൾ (Xi, Yi) and (Pi, Qi) ഉൾക്കൊള്ളുന്ന ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\n    Returns:\n    (str, str): പാതകൾക്കായുള്ള മികച്ച നിരയും നിരയും സൂചിപ്പിക്കുന്ന രണ്ട് സ്പേസ്-വേർതിരിച്ച സ്ട്രിംഗുകൾ.\n\n    ഓരോ സാധ്യതയുള്ള സ്ഥാനത്തും പാത ചേർത്താൽ വേർതിരിക്കാവുന്ന സംഭാഷണ ജോഡികളുടെ എണ്ണം എണ്ണുന്നതിനാൽ ഫംഗ്ഷൻ പ്രവർത്തിക്കുന്നു.\n    ഇത് പാതകൾക്കായുള്ള ഏറ്റവും ഫലപ്രദമായ സ്ഥാനങ്ങൾ തിരഞ്ഞെടുക്കുന്നു, ככל האפשר കൂടുതൽ സംഭാഷണ ജോഡികളെ വേർതിരിക്കാൻ ലക്ഷ്യമിടുന്നു.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')", "fa": "بهینه‌سازی قرارگیری راهروها در یک کلاس درس به منظور کاهش میزان صحبت کردن بین دانش‌آموزان.\n\nArgs:\nM (int): تعداد ردیف‌ها در کلاس درس.\nN (int): تعداد ستون‌ها در کلاس درس.\nK (int): تعداد راهروهای افقی که باید اضافه شوند.\nL (int): تعداد راهروهای عمودی که باید اضافه شوند.\nD (int): تعداد زوج‌های در حال صحبت در کلاس درس.\nchatting_pairs (list of tuples): لیستی از زوج‌ها، که هر کدام شامل موقعیت‌های (Xi, Yi) و (Pi, Qi) یک زوج در حال صحبت است.\n\nReturns:\n(str, str): دو رشته جدا شده با فاصله که نمایانگر شاخص‌های بهینه ردیف و ستون برای راهروها هستند.\n\nاین تابع با شمارش تعداد زوج‌های در حال صحبت که می‌توان با اضافه کردن یک راهرو در هر موقعیت ممکن جدا کرد، کار می‌کند.\nسپس مؤثرترین موقعیت‌ها برای راهروها را انتخاب می‌کند، با هدف جدا کردن بیشترین تعداد ممکن از زوج‌های در حال صحبت.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4')\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2')"}}
{"task_id": "Python/16", "prompt": {"en": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "sq": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Numëron numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve të rregulluar në një rreth\n    në mënyrë që pas 'm' kalimeve, topi të kthehet te studenti fillestar.\n\n    Funksioni përdor programimin dinamik për të përcaktuar numrin e sekuencave të kalimit. Çdo student\n    mund ta kalojë topin ose te fqinji i majtë ose te fqinji i djathtë.\n\n    Argumentet:\n    n: Numri i studentëve që qëndrojnë në një rreth.\n    m: Numri i herëve që topi kalohet.\n\n    Kthen:\n    Një numër i plotë që përfaqëson numrin e mënyrave të dallueshme të kalimit që rezultojnë në kthimin e topit\n    te studenti fillestar pas 'm' kalimeve.\n\n    Rastet:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "hy": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Հաշվում է տարբեր եղանակների քանակը, որով գնդակը կարող է փոխանցվել 'n' ուսանողների միջև, որոնք կանգնած են \n    շրջանաձև, այնպես, որ 'm' փոխանցումից հետո գնդակը վերադառնա մեկնարկային ուսանողին:\n\n    Ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ փոխանցման հաջորդականությունների քանակը որոշելու համար: \n    Յուրաքանչյուր ուսանող կարող է գնդակը փոխանցել կամ ձախ հարևանին, կամ աջ հարևանին:\n\n    Պարամետրեր:\n    n: Ուսանողների քանակը, որոնք կանգնած են շրջանաձև:\n    m: Գնդակի փոխանցման քանակը:\n\n    Վերադարձնում է:\n    Թիվ, որը ներկայացնում է տարբեր փոխանցման եղանակների քանակը, որոնք բերում են գնդակը \n    վերադարձնել մեկնարկային ուսանողին 'm' փոխանցումից հետո:\n\n    Դեպքեր:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "bn": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' জন শিক্ষার্থীকে একটি বৃত্তে সাজিয়ে বল পাস করার বিভিন্ন পদ্ধতির সংখ্যা গণনা করে \n    যাতে 'm' বার পাস করার পর বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসে।\n\n    ফাংশনটি বল পাস করার ক্রমের সংখ্যা নির্ধারণ করতে ডাইনামিক প্রোগ্রামিং ব্যবহার করে। \n    প্রতিটি শিক্ষার্থী বলটি বাম পাশের প্রতিবেশী বা ডান পাশের প্রতিবেশীর কাছে পাস করতে পারে।\n\n    Args:\n    n: বৃত্তে দাঁড়িয়ে থাকা শিক্ষার্থীর সংখ্যা।\n    m: বলটি পাস করার সংখ্যা।\n\n    Returns:\n    একটি পূর্ণসংখ্যা যা 'm' বার পাস করার পর বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসার \n    বিভিন্ন পাসিং পদ্ধতির সংখ্যা উপস্থাপন করে।\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "bg": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Брои броя на различните начини за подаване на топка между 'n' ученици, подредени в кръг,\n    така че след 'm' подавания топката да се върне при началния ученик.\n\n    Функцията използва динамично програмиране, за да определи броя на последователностите на подаване. Всеки ученик\n    може да подаде топката или на левия съсед, или на десния съсед.\n\n    Аргументи:\n    n: Броят на учениците, стоящи в кръг.\n    m: Броят на подаванията на топката.\n\n    Връща:\n    Цяло число, представляващо броя на различните начини на подаване, които водят до\n    връщане на топката при началния ученик след 'm' подавания.\n\n    Примери:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "zh": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    计算在 'n' 个学生围成一圈的情况下，传球 'm' 次后，球返回到起始学生的不同方式的数量。\n\n    该函数使用动态规划来确定传球序列的数量。每个学生可以将球传给左边的邻居或右边的邻居。\n\n    参数:\n    n: 围成一圈的学生人数。\n    m: 球被传递的次数。\n\n    返回:\n    一个整数，表示在传球 'm' 次后，球返回到起始学生的不同传球方式的数量。\n\n    示例:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "fr": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Compte le nombre de façons différentes de passer un ballon parmi 'n' étudiants disposés en cercle\n    de sorte qu'après 'm' passes, le ballon revienne à l'étudiant de départ.\n\n    La fonction utilise la programmation dynamique pour déterminer le nombre de séquences de passes. Chaque étudiant\n    peut passer le ballon soit au voisin de gauche, soit au voisin de droite.\n\n    Arguments:\n    n: Le nombre d'étudiants se tenant en cercle.\n    m: Le nombre de fois que le ballon est passé.\n\n    Retourne:\n    Un entier représentant le nombre de façons distinctes de passer le ballon qui aboutissent à ce que le ballon\n    revienne à l'étudiant de départ après 'm' passes.\n\n    Cas:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "de": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Zählt die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern zu passen, \n    die in einem Kreis angeordnet sind, sodass nach 'm' Pässen der Ball zum startenden Schüler zurückkehrt.\n\n    Die Funktion verwendet dynamische Programmierung, um die Anzahl der Pass-Sequenzen zu bestimmen. Jeder Schüler\n    kann den Ball entweder an den linken Nachbarn oder an den rechten Nachbarn weitergeben.\n\n    Argumente:\n    n: Die Anzahl der Schüler, die im Kreis stehen.\n    m: Die Anzahl der Male, die der Ball gepasst wird.\n\n    Rückgabe:\n    Eine ganze Zahl, die die Anzahl der verschiedenen Passmöglichkeiten darstellt, die dazu führen, \n    dass der Ball nach 'm' Pässen zum startenden Schüler zurückkehrt.\n\n    Fälle:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "ha": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Yana ƙididdige yawan hanyoyin daban-daban na wuce ƙwallo tsakanin 'n' ɗalibai da aka shirya a cikin \n    da'ira ta yadda bayan 'm' wucewa, ƙwallon zai dawo ga ɗalibin da ya fara.\n\n    Aikin yana amfani da shirye-shiryen motsi don tantance yawan jerin wucewa. Kowanne ɗalibi\n    na iya wuce ƙwallon ko dai ga makwabcin hagu ko ga makwabcin dama.\n\n    Args:\n    n: Yawan ɗalibai da ke tsaye a cikin da'ira.\n    m: Yawan lokutan da ake wuce ƙwallon.\n\n    Returns:\n    Lamba mai nuna yawan hanyoyin wucewa daban-daban da ke haifar da dawowar ƙwallon\n    ga ɗalibin da ya fara bayan 'm' wucewa.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "hi": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' छात्रों के बीच गेंद पास करने के विभिन्न तरीकों की संख्या गिनता है, जो एक वृत्त में व्यवस्थित हैं,\n    ताकि 'm' पास के बाद, गेंद शुरुआती छात्र के पास लौट आए।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके पासिंग अनुक्रमों की संख्या निर्धारित करता है। प्रत्येक छात्र\n    गेंद को या तो बाएं पड़ोसी को या दाएं पड़ोसी को पास कर सकता है।\n\n    Args:\n    n: एक वृत्त में खड़े छात्रों की संख्या।\n    m: गेंद पास करने की संख्या।\n\n    Returns:\n    एक पूर्णांक जो विभिन्न पासिंग तरीकों की संख्या का प्रतिनिधित्व करता है, जिसके परिणामस्वरूप\n    'm' पास के बाद गेंद शुरुआती छात्र के पास लौटती है।\n\n    मामले:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "hu": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Megszámolja, hányféleképpen lehet átadni egy labdát 'n' diák között, akik körben állnak úgy,\n    hogy 'm' passz után a labda visszatér a kiinduló diákhoz.\n\n    A függvény dinamikus programozást használ a passzolási sorozatok számának meghatározásához. \n    Minden diák vagy a bal szomszédjának, vagy a jobb szomszédjának adhatja tovább a labdát.\n\n    Paraméterek:\n    n: A körben álló diákok száma.\n    m: A labda átadásának száma.\n\n    Visszatér:\n    Egy egész szám, amely a különböző passzolási módok számát jelenti, amelyek eredményeként\n    a labda 'm' passz után visszatér a kiinduló diákhoz.\n\n    Esetek:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "es": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Cuenta el número de formas diferentes de pasar una pelota entre 'n' estudiantes dispuestos en un círculo\n    de manera que después de 'm' pases, la pelota regrese al estudiante inicial.\n\n    La función utiliza programación dinámica para determinar el número de secuencias de pases. Cada estudiante\n    puede pasar la pelota ya sea al vecino de la izquierda o al vecino de la derecha.\n\n    Argumentos:\n    n: El número de estudiantes de pie en un círculo.\n    m: El número de veces que se pasa la pelota.\n\n    Devuelve:\n    Un entero que representa el número de formas distintas de pasar la pelota que resultan en que la pelota\n    regrese al estudiante inicial después de 'm' pases.\n\n    Casos:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "arb": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' طلاب مرتبين في دائرة\n    بحيث بعد 'm' تمريرات، تعود الكرة إلى الطالب الذي بدأ التمرير.\n\n    تستخدم الدالة البرمجة الديناميكية لتحديد عدد تسلسلات التمرير. كل طالب\n    يمكنه تمرير الكرة إما إلى الجار الأيسر أو إلى الجار الأيمن.\n\n    يعيدالحجج:\n    n: عدد الطلاب الواقفين في دائرة.\n    m: عدد المرات التي يتم فيها تمرير الكرة.\n\n    يعيد:\n    عدد صحيح يمثل عدد طرق التمرير المميزة التي تؤدي إلى\n    عودة الكرة إلى الطالب الذي بدأ التمرير بعد 'm' تمريرات.\n\n    حالات:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "sw": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Inahesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliopangwa katika duara \n    kiasi kwamba baada ya 'm' kupitisha, mpira unarudi kwa mwanafunzi wa kuanzia.\n\n    Kazi hii inatumia programu ya nguvu kuamua idadi ya mfuatano wa kupitisha. Kila mwanafunzi\n    anaweza kupitisha mpira ama kwa jirani wa kushoto au kwa jirani wa kulia.\n\n    Hoja:\n    n: Idadi ya wanafunzi waliopo katika duara.\n    m: Idadi ya mara ambazo mpira unapitiwa.\n\n    Inarejesha:\n    Nambari inayowakilisha idadi ya njia tofauti za kupitisha ambazo zinasababisha mpira\n    kurudi kwa mwanafunzi wa kuanzia baada ya 'm' kupitisha.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "tr": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Bir daire şeklinde dizilmiş 'n' öğrenci arasında bir topu geçmenin farklı yollarının sayısını sayar\n    öyle ki 'm' pas sonrasında top başlangıçtaki öğrenciye geri döner.\n\n    Fonksiyon, pas dizilerinin sayısını belirlemek için dinamik programlama kullanır. Her öğrenci\n    topu ya sol komşusuna ya da sağ komşusuna geçirebilir.\n\n    Argümanlar:\n    n: Bir dairede duran öğrenci sayısı.\n    m: Topun kaç kez paslandığı.\n\n    Döndürür:\n    'm' pas sonrasında topun başlangıçtaki öğrenciye geri dönmesiyle sonuçlanan\n    farklı paslaşma yollarının sayısını temsil eden bir tamsayı.\n\n    Durumlar:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "vi": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Đếm số cách khác nhau để chuyền một quả bóng giữa 'n' học sinh được sắp xếp thành vòng tròn\n    sao cho sau 'm' lần chuyền, quả bóng trở về học sinh bắt đầu.\n\n    Hàm này sử dụng lập trình động để xác định số lượng chuỗi chuyền bóng. Mỗi học sinh\n    có thể chuyền bóng cho người bên trái hoặc người bên phải.\n\n    Tham số:\n    n: Số lượng học sinh đứng thành vòng tròn.\n    m: Số lần quả bóng được chuyền.\n\n    Trả về:\n    Một số nguyên đại diện cho số cách chuyền bóng khác nhau mà kết quả là quả bóng\n    trở về học sinh bắt đầu sau 'm' lần chuyền.\n\n    Trường hợp:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "id": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Menghitung jumlah cara berbeda untuk mengoper bola di antara 'n' siswa yang diatur dalam lingkaran\n    sedemikian rupa sehingga setelah 'm' operan, bola kembali ke siswa awal.\n\n    Fungsi ini menggunakan pemrograman dinamis untuk menentukan jumlah urutan operan. Setiap siswa\n    dapat mengoper bola baik ke tetangga kiri atau ke tetangga kanan.\n\n    Argumen:\n    n: Jumlah siswa yang berdiri dalam lingkaran.\n    m: Jumlah kali bola dioper.\n\n    Mengembalikan:\n    Sebuah bilangan bulat yang mewakili jumlah cara operan yang berbeda yang menghasilkan bola\n    kembali ke siswa awal setelah 'm' operan.\n\n    Kasus:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "ja": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' 人の学生が円形に並んでいる中で、ボールを渡す異なる方法の数を数えます。\n    'm' 回のパスの後、ボールが開始した学生に戻るようにします。\n\n    この関数は動的プログラミングを使用して、パスシーケンスの数を決定します。各学生はボールを左隣または右隣の学生に渡すことができます。\n\n    引数:\n    n: 円形に立っている学生の数。\n    m: ボールが渡される回数。\n\n    戻り値:\n    'm' 回のパスの後にボールが開始した学生に戻る結果となる、異なるパスの方法の数を表す整数。\n\n    ケース:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "ko": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n'명의 학생이 원형으로 배열되어 있을 때, 'm'번의 패스를 통해 공이 시작 학생에게 돌아오는 \n    서로 다른 방법의 수를 계산합니다.\n\n    이 함수는 동적 프로그래밍을 사용하여 패스 시퀀스의 수를 결정합니다. 각 학생은 공을 왼쪽 이웃이나 \n    오른쪽 이웃에게 전달할 수 있습니다.\n\n    Args:\n    n: 원형으로 서 있는 학생의 수.\n    m: 공이 전달되는 횟수.\n\n    Returns:\n    'm'번의 패스 후에 공이 시작 학생에게 돌아오는 서로 다른 패스 방법의 수를 나타내는 정수.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "ml": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' വിദ്യാർത്ഥികളെ വൃത്താകൃതിയിൽ നിരത്തിയ ശേഷം 'm' തവണ പന്ത് പാസ്സുചെയ്ത് പന്ത് ആരംഭിച്ച വിദ്യാർത്ഥിയിലേക്ക് മടങ്ങിയെത്തുന്ന വ്യത്യസ്ത മാർഗ്ഗങ്ങളുടെ എണ്ണം എണ്ണുന്നു.\n\n    ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് പാസ്സിംഗ് ക്രമങ്ങളുടെ എണ്ണം നിർണ്ണയിക്കുന്നു. ഓരോ വിദ്യാർത്ഥിയും പന്ത് ഇടത് അയൽക്കാർക്ക് അല്ലെങ്കിൽ വലത് അയൽക്കാർക്ക് പാസ്സുചെയ്യാം.\n\n    Args:\n    n: വൃത്തത്തിൽ നിൽക്കുന്ന വിദ്യാർത്ഥികളുടെ എണ്ണം.\n    m: പന്ത് പാസ്സുചെയ്യുന്ന തവണകളുടെ എണ്ണം.\n\n    Returns:\n    'm' തവണ പാസ്സുചെയ്ത ശേഷം പന്ത് ആരംഭിച്ച വിദ്യാർത്ഥിയിലേക്ക് മടങ്ങിയെത്തുന്ന വ്യത്യസ്ത പാസ്സിംഗ് മാർഗ്ഗങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\n    സംഭവങ്ങൾ:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"", "fa": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    تعداد روش‌های مختلف برای پاس دادن توپ بین 'n' دانش‌آموز که به صورت دایره‌ای قرار گرفته‌اند \n    را می‌شمارد به طوری که بعد از 'm' پاس، توپ به دانش‌آموز شروع کننده برگردد.\n\n    این تابع از برنامه‌نویسی پویا برای تعیین تعداد توالی‌های پاس استفاده می‌کند. هر دانش‌آموز\n    می‌تواند توپ را به همسایه چپ یا همسایه راست پاس دهد.\n\n    آرگومان‌ها:\n    n: تعداد دانش‌آموزانی که به صورت دایره‌ای ایستاده‌اند.\n    m: تعداد دفعاتی که توپ پاس داده می‌شود.\n\n    بازگشت:\n    یک عدد صحیح که نشان‌دهنده تعداد روش‌های متمایز پاس دادن است که منجر به بازگشت توپ\n    به دانش‌آموز شروع کننده بعد از 'm' پاس می‌شود.\n\n    موارد:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\""}, "canonical_solution": "    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]", "instruction": {"en": "Write a python function 'def count_passing_ways(n: int, m: int) -> int:' to solve the following problem:\n\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ", "sq": "Shkruani një funksion python 'def count_passing_ways(n: int, m: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Numëron numrin e mënyrave të ndryshme për të kaluar një top ndërmjet 'n' studentëve të rregulluar në një rreth\n    në mënyrë të tillë që pas 'm' pasimeve, topi të kthehet te studenti fillestar.\n\n    Funksioni përdor programimin dinamik për të përcaktuar numrin e sekuencave të pasimeve. Çdo student\n    mund ta kalojë topin ose te fqinji i majtë ose te fqinji i djathtë.\n\n    Args:\n    n: Numri i studentëve që qëndrojnë në një rreth.\n    m: Numri i herëve që topi kalon.\n\n    Kthen:\n    Një numër i plotë që përfaqëson numrin e mënyrave të veçanta të pasimit që rezultojnë në kthimin e topit\n    te studenti fillestar pas 'm' pasimeve.\n\n    Raste:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "hy": "Պայթոն ֆունկցիա 'def count_passing_ways(n: int, m: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվում է գնդակը 'n' ուսանողների միջև փոխանցելու տարբեր եղանակների քանակը, որոնք դասավորված են շրջանաձև այնպես,\n    որ 'm' փոխանցումներից հետո գնդակը վերադառնա մեկնարկային ուսանողին:\n\n    Ֆունկցիան օգտագործում է դինամիկ ծրագրավորում փոխանցման հաջորդականությունների քանակը որոշելու համար: Յուրաքանչյուր ուսանող\n    կարող է գնդակը փոխանցել կամ ձախ հարևանին, կամ աջ հարևանին:\n\n    Արգումենտներ:\n    n: Ուսանողների քանակը, ովքեր կանգնած են շրջանաձև:\n    m: Գնդակը փոխանցելու քանակը:\n\n    Վերադարձնում է:\n    Մի ամբողջ թիվ, որը ներկայացնում է տարբեր փոխանցման եղանակների քանակը, որի արդյունքում գնդակը\n    'm' փոխանցումներից հետո վերադառնում է մեկնարկային ուսանողին:\n\n    Դեպքեր:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "bn": "একটি পাইথন ফাংশন 'def count_passing_ways(n: int, m: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    'n' জন শিক্ষার্থীর মধ্যে বলটি কত বিভিন্ন উপায়ে পাস করা যায় তা গণনা করুন, যারা একটি বৃত্তে সাজানো আছে \n    যাতে 'm' পাসের পরে বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসে।\n\n    ফাংশনটি পাসিং সিকোয়েন্সের সংখ্যা নির্ধারণ করতে ডাইনামিক প্রোগ্রামিং ব্যবহার করে। প্রতিটি শিক্ষার্থী \n    বলটি বাম পাশের প্রতিবেশী বা ডান পাশের প্রতিবেশীর কাছে পাস করতে পারে।\n\n    আর্গস:\n    n: বৃত্তে দাঁড়িয়ে থাকা শিক্ষার্থীর সংখ্যা।\n    m: বল পাস করার সংখ্যা।\n\n    রিটার্নস:\n    একটি পূর্ণসংখ্যা যা বিভিন্ন পাসিং উপায়ের সংখ্যা উপস্থাপন করে যা 'm' পাসের পরে \n    বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসে।\n\n    কেস:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "bg": "Напишете Python функция 'def count_passing_ways(n: int, m: int) -> int:' за да решите следния проблем:\n\n    Брои броя на различните начини за предаване на топка между 'n' ученици, подредени в кръг, \n    така че след 'm' предавания топката да се върне при началния ученик.\n\n    Функцията използва динамично програмиране, за да определи броя на последователностите на предаване. Всеки ученик\n    може да предаде топката или на левия съсед, или на десния съсед.\n\n    Аргументи:\n    n: Броят на учениците, стоящи в кръг.\n    m: Броят на предаванията на топката.\n\n    Връща:\n    Цяло число, представляващо броя на различните начини на предаване, които водят до това, че топката\n    се връща при началния ученик след 'm' предавания.\n\n    Примери:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "zh": "编写一个Python函数 'def count_passing_ways(n: int, m: int) -> int:' 来解决以下问题：\n\n    计算在'n'个学生围成一圈的情况下传球的不同方式数量，\n    使得经过'm'次传球后，球返回到起始学生。\n\n    该函数使用动态规划来确定传球序列的数量。每个学生\n    可以将球传给左边的邻居或右边的邻居。\n\n    参数:\n    n: 围成一圈的学生人数。\n    m: 球被传递的次数。\n\n    返回:\n    一个整数，表示在'm'次传球后球返回到起始学生的不同传球方式的数量。\n\n    示例:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "fr": "Écrire une fonction python 'def count_passing_ways(n: int, m: int) -> int:' pour résoudre le problème suivant :\n\n    Compte le nombre de façons différentes de passer un ballon parmi 'n' étudiants disposés en cercle\n    de sorte qu'après 'm' passes, le ballon retourne à l'étudiant de départ.\n\n    La fonction utilise la programmation dynamique pour déterminer le nombre de séquences de passes. Chaque étudiant\n    peut passer le ballon soit à son voisin de gauche, soit à son voisin de droite.\n\n    Args:\n    n: Le nombre d'étudiants debout en cercle.\n    m: Le nombre de fois que le ballon est passé.\n\n    Renvoie:\n    Un entier représentant le nombre de façons distinctes de passer le ballon qui aboutissent à ce que le ballon\n    retourne à l'étudiant de départ après 'm' passes.\n\n    Cas:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "de": "Schreiben Sie eine Python-Funktion 'def count_passing_ways(n: int, m: int) -> int:', um das folgende Problem zu lösen:\n\n    Zählt die Anzahl der verschiedenen Möglichkeiten, einen Ball zwischen 'n' Schülern, die im Kreis angeordnet sind, \n    so zu passen, dass nach 'm' Pässen der Ball zum startenden Schüler zurückkehrt.\n\n    Die Funktion verwendet dynamische Programmierung, um die Anzahl der Pass-Sequenzen zu bestimmen. Jeder Schüler\n    kann den Ball entweder an den linken Nachbarn oder an den rechten Nachbarn weitergeben.\n\n    Argumente:\n    n: Die Anzahl der Schüler, die im Kreis stehen.\n    m: Die Anzahl der Male, die der Ball gepasst wird.\n\n    Rückgabewert:\n    Eine ganze Zahl, die die Anzahl der unterschiedlichen Passmöglichkeiten darstellt, die dazu führen, dass der Ball\n    nach 'm' Pässen zum startenden Schüler zurückkehrt.\n\n    Fälle:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "ha": "Rubuta wani aikin python 'def count_passing_ways(n: int, m: int) -> int:' don warware matsalar mai zuwa:\n\n    Yana ƙidaya adadin hanyoyi daban-daban don wuce ƙwallo tsakanin 'n' ɗalibai da aka shirya a cikin da'ira \n    ta yadda bayan 'm' wucewa, ƙwallon zai koma ga ɗalibin da ya fara.\n\n    Aikin yana amfani da shirye-shiryen motsi don tantance adadin jerin wucewa. Kowane ɗalibi\n    na iya wuce ƙwallon ko dai ga makwabcin hagu ko ga makwabcin dama.\n\n    Args:\n    n: Adadin ɗalibai masu tsayawa a cikin da'ira.\n    m: Adadin lokutan da aka wuce ƙwallon.\n\n    Returns:\n    Wani cikakken lamba da ke wakiltar adadin hanyoyin wucewa daban-daban da ke haifar da ƙwallon\n    dawowa ga ɗalibin da ya fara bayan 'm' wucewa.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "hi": "एक पायथन फ़ंक्शन 'def count_passing_ways(n: int, m: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    'n' छात्रों के बीच एक गेंद पास करने के विभिन्न तरीकों की संख्या गिनें जो एक वृत्त में व्यवस्थित हैं \n    ताकि 'm' पास के बाद, गेंद प्रारंभिक छात्र के पास वापस आ जाए।\n\n    फ़ंक्शन पासिंग अनुक्रमों की संख्या निर्धारित करने के लिए गतिशील प्रोग्रामिंग का उपयोग करता है। प्रत्येक छात्र\n    गेंद को या तो बाएं पड़ोसी या दाएं पड़ोसी को पास कर सकता है।\n\n    तर्क:\n    n: एक वृत्त में खड़े छात्रों की संख्या।\n    m: गेंद को पास करने की संख्या।\n\n    लौटाता है:\n    एक पूर्णांक जो विभिन्न पासिंग तरीकों की संख्या का प्रतिनिधित्व करता है जिसके परिणामस्वरूप गेंद\n    'm' पास के बाद प्रारंभिक छात्र के पास वापस आ जाती है।\n\n    मामले:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "hu": "Írj egy python függvényt 'def count_passing_ways(n: int, m: int) -> int:' a következő probléma megoldására:\n\n    Számolja meg a különböző módokat, ahogyan egy labdát 'n' diák között lehet passzolni, akik körben állnak úgy, hogy 'm' passz után a labda visszatér a kiinduló diákhoz.\n\n    A függvény dinamikus programozást használ a passzolási sorozatok számának meghatározására. Minden diák\n    átadhatja a labdát vagy a bal szomszédjának, vagy a jobb szomszédjának.\n\n    Paraméterek:\n    n: A körben álló diákok száma.\n    m: A labda passzolásának száma.\n\n    Visszatérési érték:\n    Egy egész szám, amely a különböző passzolási módokat jelöli, amelyek eredményeként a labda\n    'm' passz után visszatér a kiinduló diákhoz.\n\n    Esetek:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "es": "Escribe una función de Python 'def count_passing_ways(n: int, m: int) -> int:' para resolver el siguiente problema:\n\n    Cuenta el número de formas diferentes de pasar una pelota entre 'n' estudiantes dispuestos en un círculo \n    de tal manera que después de 'm' pases, la pelota regrese al estudiante inicial.\n\n    La función utiliza programación dinámica para determinar el número de secuencias de pases. Cada estudiante\n    puede pasar la pelota ya sea al vecino de la izquierda o al vecino de la derecha.\n\n    Args:\n    n: El número de estudiantes parados en un círculo.\n    m: El número de veces que se pasa la pelota.\n\n    Devuelve:\n    Un entero que representa el número de formas distintas de pasar la pelota que resultan en que la pelota\n    regrese al estudiante inicial después de 'm' pases.\n\n    Casos:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "arb": "اكتب دالة بايثون 'def count_passing_ways(n: int, m: int) -> int:' لحل المشكلة التالية:\n\n    تحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' طلاب مرتبين في دائرة \n    بحيث بعد 'm' تمريرات، تعود الكرة إلى الطالب الذي بدأت منه.\n\n    تستخدم الدالة البرمجة الديناميكية لتحديد عدد تسلسلات التمرير. يمكن لكل طالب\n    تمرير الكرة إما إلى الجار الأيسر أو إلى الجار الأيمن.\n\n    يعيدالحجج:\n    n: عدد الطلاب الواقفين في دائرة.\n    m: عدد المرات التي يتم فيها تمرير الكرة.\n\n    يعيد:\n    عدد صحيح يمثل عدد طرق التمرير المميزة التي تؤدي إلى عودة الكرة\n    إلى الطالب الذي بدأت منه بعد 'm' تمريرات.\n\n    حالات:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "sw": "Andika kazi ya python 'def count_passing_ways(n: int, m: int) -> int:' kutatua tatizo lifuatalo:\n\n    Inahesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliopangwa katika duara \n    kiasi kwamba baada ya 'm' kupitisha, mpira unarudi kwa mwanafunzi wa kuanzia.\n\n    Kazi hii inatumia programu ya nguvu ili kubaini idadi ya mfuatano wa kupitisha. Kila mwanafunzi\n    anaweza kupitisha mpira kwa jirani wa kushoto au kwa jirani wa kulia.\n\n    Hoja:\n    n: Idadi ya wanafunzi waliopo katika duara.\n    m: Idadi ya mara ambazo mpira unapita.\n\n    Inarejesha:\n    Nambari inayowakilisha idadi ya njia tofauti za kupitisha ambazo zinasababisha mpira\n    kurudi kwa mwanafunzi wa kuanzia baada ya 'm' kupitisha.\n\n    Matukio:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "tr": "Bir python fonksiyonu 'def count_passing_ways(n: int, m: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    'n' öğrencinin bir daire şeklinde dizildiği bir durumda, topun 'm' pas sonrasında\n    başlangıçtaki öğrenciye geri dönmesi için farklı yolların sayısını sayar.\n\n    Fonksiyon, pas dizilerinin sayısını belirlemek için dinamik programlama kullanır. Her öğrenci\n    topu ya sol komşusuna ya da sağ komşusuna paslayabilir.\n\n    Argümanlar:\n    n: Bir dairede duran öğrenci sayısı.\n    m: Topun kaç kez paslandığı.\n\n    Döndürür:\n    'm' pas sonrasında topun başlangıçtaki öğrenciye geri dönmesiyle sonuçlanan\n    farklı pas yollarının sayısını temsil eden bir tamsayı.\n\n    Durumlar:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "vi": "Viết một hàm python 'def count_passing_ways(n: int, m: int) -> int:' để giải quyết vấn đề sau:\n\n    Đếm số cách khác nhau để chuyền bóng giữa 'n' học sinh sắp xếp thành vòng tròn \n    sao cho sau 'm' lần chuyền, bóng quay lại học sinh bắt đầu.\n\n    Hàm sử dụng lập trình động để xác định số lượng chuỗi chuyền bóng. Mỗi học sinh\n    có thể chuyền bóng cho người bên trái hoặc người bên phải.\n\n    Tham số:\n    n: Số lượng học sinh đứng thành vòng tròn.\n    m: Số lần bóng được chuyền.\n\n    Trả về:\n    Một số nguyên đại diện cho số cách chuyền bóng khác nhau mà kết quả là bóng\n    quay lại học sinh bắt đầu sau 'm' lần chuyền.\n\n    Trường hợp:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "id": "Tulis fungsi python 'def count_passing_ways(n: int, m: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Menghitung jumlah cara berbeda untuk mengoper bola di antara 'n' siswa yang diatur dalam lingkaran \n    sedemikian rupa sehingga setelah 'm' operan, bola kembali ke siswa awal.\n\n    Fungsi ini menggunakan pemrograman dinamis untuk menentukan jumlah urutan operan. Setiap siswa\n    dapat mengoper bola baik ke tetangga kiri atau ke tetangga kanan.\n\n    Argumen:\n    n: Jumlah siswa yang berdiri dalam lingkaran.\n    m: Jumlah kali bola dioper.\n\n    Mengembalikan:\n    Sebuah bilangan bulat yang mewakili jumlah cara operan yang berbeda yang mengakibatkan bola\n    kembali ke siswa awal setelah 'm' operan.\n\n    Kasus:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "ja": "Python関数を書いてください。 'def count_passing_ways(n: int, m: int) -> int:' を解くための次の問題:\n\n    'n' 人の学生が円形に配置されている中で、ボールを渡す異なる方法の数を数えます。\n    'm' 回のパスの後、ボールが開始した学生に戻るようにします。\n\n    関数は動的プログラミングを使用して、パスシーケンスの数を決定します。各学生はボールを左の隣人または右の隣人に渡すことができます。\n\n    引数:\n    n: 円形に立っている学生の数。\n    m: ボールが渡される回数。\n\n    戻り値:\n    'm' 回のパスの後にボールが開始した学生に戻る結果となる、異なるパス方法の数を表す整数。\n\n    ケース:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "ko": "다음 문제를 해결하기 위해 파이썬 함수를 작성하십시오 'def count_passing_ways(n: int, m: int) -> int:':\n\n    'n'명의 학생들이 원형으로 배열되어 있을 때, 'm'번의 패스를 통해 공이 시작 학생에게 돌아오는 \n    서로 다른 방법의 수를 계산합니다.\n\n    이 함수는 동적 프로그래밍을 사용하여 패스 시퀀스의 수를 결정합니다. 각 학생은 공을 왼쪽 이웃이나 \n    오른쪽 이웃에게 전달할 수 있습니다.\n\n    인수:\n    n: 원형으로 서 있는 학생의 수.\n    m: 공이 전달되는 횟수.\n\n    반환:\n    'm'번의 패스 후 공이 시작 학생에게 돌아오는 서로 다른 패스 방법의 수를 나타내는 정수입니다.\n\n    사례:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "ml": "'def count_passing_ways(n: int, m: int) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    'n' വിദ്യാർത്ഥികളെ ഒരു വൃത്തത്തിൽ ക്രമീകരിച്ച ശേഷം 'm' തവണ പാസ് ചെയ്താൽ പന്ത് ആരംഭിക്കുന്ന വിദ്യാർത്ഥിയിലേക്ക് മടങ്ങിയെത്തുന്നതിനുള്ള വ്യത്യസ്ത മാർഗങ്ങളുടെ എണ്ണം എണ്ണുന്നു.\n\n    പാസിംഗ് സീക്വൻസുകളുടെ എണ്ണം നിർണ്ണയിക്കാൻ ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിക്കുന്നു. ഓരോ വിദ്യാർത്ഥിയും പന്ത് ഇടത് അയൽക്കാരനോ വലത് അയൽക്കാരനോക്ക് പാസ് ചെയ്യാൻ കഴിയും.\n\n    Args:\n    n: ഒരു വൃത്തത്തിൽ നിൽക്കുന്ന വിദ്യാർത്ഥികളുടെ എണ്ണം.\n    m: പന്ത് പാസ് ചെയ്യുന്ന തവണകളുടെ എണ്ണം.\n\n    Returns:\n    'm' തവണ പാസ് ചെയ്ത ശേഷം പന്ത് ആരംഭിക്കുന്ന വിദ്യാർത്ഥിയിലേക്ക് മടങ്ങിയെത്തുന്ന വ്യത്യസ്ത പാസിംഗ് മാർഗങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\n    കേസുകൾ:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "fa": "یک تابع پایتون 'def count_passing_ways(n: int, m: int) -> int:' بنویسید تا مسئله زیر را حل کند:\n\n    تعداد روش‌های مختلف برای پاس دادن توپ بین 'n' دانش‌آموز که به صورت دایره‌ای ایستاده‌اند را می‌شمارد \n    به طوری که پس از 'm' پاس، توپ به دانش‌آموز شروع‌کننده بازگردد.\n\n    تابع از برنامه‌نویسی پویا برای تعیین تعداد توالی‌های پاس استفاده می‌کند. هر دانش‌آموز\n    می‌تواند توپ را یا به همسایه چپ یا به همسایه راست پاس دهد.\n\n    آرگومان‌ها:\n    n: تعداد دانش‌آموزانی که به صورت دایره‌ای ایستاده‌اند.\n    m: تعداد دفعاتی که توپ پاس داده می‌شود.\n\n    بازمی‌گرداند:\n    یک عدد صحیح که نشان‌دهنده تعداد روش‌های متمایز پاس دادن است که منجر به بازگشت توپ\n    به دانش‌آموز شروع‌کننده پس از 'm' پاس می‌شود.\n\n    موارد:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6"}, "level": "easy", "test": "def test_count_passing_ways():\n    test_cases = [\n        # Test case 1: simple case\n        {\n            'n': 3,\n            'm': 1,\n            'expected': 0\n        },\n        # Test case 2: another simple case\n        {\n            'n': 4,\n            'm': 2,\n            'expected': 2\n        },\n        # Test case 3: larger number of students and passes\n        {\n            'n': 5,\n            'm': 3,\n            'expected': 0\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = count_passing_ways(test['n'], test['m'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_count_passing_ways()", "entry_point": "count_passing_ways", "signature": "def count_passing_ways(n: int, m: int) -> int:", "docstring": {"en": "\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ", "sq": "\n    Numëron numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve të rregulluar në një rreth\n    në mënyrë të tillë që pas 'm' kalimeve, topi të kthehet te studenti fillestar.\n\n    Funksioni përdor programimin dinamik për të përcaktuar numrin e sekuencave të kalimit. Çdo student\n    mund ta kalojë topin ose te fqinji i majtë ose te fqinji i djathtë.\n\n    Args:\n    n: Numri i studentëve që qëndrojnë në një rreth.\n    m: Numri i herëve që topi kalon.\n\n    Returns:\n    Një numër i plotë që përfaqëson numrin e mënyrave të dallueshme të kalimit që rezultojnë në kthimin e topit\n    te studenti fillestar pas 'm' kalimeve.\n\n    Rastet:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "hy": "\n    Հաշվում է գնդակը 'n' ուսանողների միջև փոխանցելու տարբեր եղանակների քանակը, որոնք դասավորված են շրջանաձև այնպես, որ 'm' փոխանցումներից հետո գնդակը վերադառնա մեկնարկային ուսանողին։\n\n    Ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ փոխանցման հաջորդականությունների քանակը որոշելու համար։ Յուրաքանչյուր ուսանող կարող է գնդակը փոխանցել կամ ձախ հարևանին, կամ աջ հարևանին։\n\n    Արգումենտներ:\n    n: Շրջանաձև կանգնած ուսանողների քանակը։\n    m: Գնդակի փոխանցումների քանակը։\n\n    Վերադարձնում է:\n    Թիվ, որը ներկայացնում է տարբեր փոխանցման եղանակների քանակը, որոնք հանգեցնում են գնդակի վերադարձին մեկնարկային ուսանողին 'm' փոխանցումներից հետո։\n\n    Դեպքեր:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "bn": "\n    'n' জন শিক্ষার্থীকে একটি বৃত্তে সাজানো অবস্থায় একটি বল পাস করার বিভিন্ন উপায়ের সংখ্যা গণনা করে \n    যাতে 'm' বার পাস করার পর, বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসে।\n\n    ফাংশনটি বল পাস করার ক্রমের সংখ্যা নির্ধারণ করতে গতিশীল প্রোগ্রামিং ব্যবহার করে। প্রতিটি শিক্ষার্থী \n    বলটি বাম পাশের প্রতিবেশী বা ডান পাশের প্রতিবেশীর কাছে পাস করতে পারে।\n\n    আর্গুমেন্ট:\n    n: বৃত্তে দাঁড়িয়ে থাকা শিক্ষার্থীর সংখ্যা।\n    m: বল পাস করার সংখ্যা।\n\n    রিটার্ন:\n    একটি পূর্ণসংখ্যা যা 'm' বার পাস করার পর বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসার ফলাফল হিসেবে \n    ভিন্ন পাসিং উপায়ের সংখ্যা উপস্থাপন করে।\n\n    কেস:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "bg": "\n    Брои броя на различните начини за предаване на топка между 'n' ученици, подредени в кръг,\n    така че след 'm' предавания топката да се върне при началния ученик.\n\n    Функцията използва динамично програмиране, за да определи броя на последователностите на предаване. Всеки ученик\n    може да предаде топката или на левия съсед, или на десния съсед.\n\n    Аргументи:\n    n: Броят на учениците, стоящи в кръг.\n    m: Броят на предаванията на топката.\n\n    Връща:\n    Цяло число, представляващо броя на различните начини на предаване, които водят до това,\n    че топката се връща при началния ученик след 'm' предавания.\n\n    Примери:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "zh": "\n    计算在 'n' 个学生围成一圈的情况下，将球传递的不同方式的数量，\n    使得经过 'm' 次传递后，球返回到起始学生。\n\n    该函数使用动态规划来确定传球序列的数量。每个学生可以将球传给左边的邻居或右边的邻居。\n\n    参数:\n    n: 围成一圈的学生数量。\n    m: 球被传递的次数。\n\n    返回:\n    一个整数，表示在 'm' 次传递后球返回到起始学生的不同传递方式的数量。\n\n    情况:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "fr": "\n    Compte le nombre de façons différentes de faire passer un ballon parmi 'n' étudiants disposés en cercle \n    de sorte qu'après 'm' passes, le ballon revienne à l'étudiant de départ.\n\n    La fonction utilise la programmation dynamique pour déterminer le nombre de séquences de passes. Chaque étudiant\n    peut passer le ballon soit à son voisin de gauche, soit à son voisin de droite.\n\n    Args:\n    n: Le nombre d'étudiants se tenant en cercle.\n    m: Le nombre de fois que le ballon est passé.\n\n    Returns:\n    Un entier représentant le nombre de façons distinctes de passer le ballon qui aboutissent à ce que le ballon\n    revienne à l'étudiant de départ après 'm' passes.\n\n    Cas:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "de": "\n    Zählt die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern, die im Kreis angeordnet sind, so zu passen, dass der Ball nach 'm' Pässen zum startenden Schüler zurückkehrt.\n\n    Die Funktion verwendet dynamische Programmierung, um die Anzahl der Passsequenzen zu bestimmen. Jeder Schüler kann den Ball entweder an den linken oder den rechten Nachbarn weitergeben.\n\n    Args:\n    n: Die Anzahl der Schüler, die im Kreis stehen.\n    m: Die Anzahl der Male, die der Ball gepasst wird.\n\n    Returns:\n    Eine ganze Zahl, die die Anzahl der unterschiedlichen Passmöglichkeiten darstellt, die dazu führen, dass der Ball nach 'm' Pässen zum startenden Schüler zurückkehrt.\n\n    Fälle:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "ha": "\n    Yana ƙididdige adadin hanyoyi daban-daban don wuce ƙwallo tsakanin 'n' ɗalibai da aka shirya a cikin da'ira \n    ta yadda bayan 'm' na wucewa, ƙwallon zai dawo ga ɗalibin da ya fara.\n\n    Aiki yana amfani da shirye-shiryen motsi don tantance adadin jerin wucewa. Kowanne ɗalibi\n    na iya wuce ƙwallon ko dai ga makwabcin hagu ko ga makwabcin dama.\n\n    Ƙayyadaddun bayanai:\n    n: Adadin ɗalibai da ke tsaye a cikin da'ira.\n    m: Adadin lokutan da aka wuce ƙwallon.\n\n    Yana dawowa:\n    Wani cikakken lamba da ke wakiltar adadin hanyoyin wucewa daban-daban da ke haifar da ƙwallon\n    dawowa ga ɗalibin da ya fara bayan 'm' na wucewa.\n\n    Misalai:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "hi": "\n    'n' छात्रों के बीच गेंद पास करने के विभिन्न तरीकों की संख्या गिनें, जो एक वृत्त में व्यवस्थित हैं, \n    ताकि 'm' पास के बाद, गेंद प्रारंभिक छात्र के पास लौट आए।\n\n    यह फ़ंक्शन पासिंग अनुक्रमों की संख्या निर्धारित करने के लिए डायनामिक प्रोग्रामिंग का उपयोग करता है। प्रत्येक छात्र \n    गेंद को या तो बाएँ पड़ोसी को या दाएँ पड़ोसी को पास कर सकता है।\n\n    तर्क:\n    n: वृत्त में खड़े छात्रों की संख्या।\n    m: गेंद को पास करने की संख्या।\n\n    वापसी:\n    एक पूर्णांक जो विभिन्न पासिंग तरीकों की संख्या का प्रतिनिधित्व करता है, जिसके परिणामस्वरूप 'm' पास के बाद गेंद \n    प्रारंभिक छात्र के पास लौटती है।\n\n    मामले:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "hu": "\n    Számolja meg, hányféleképpen lehet átadni a labdát 'n' diák között, akik körben állnak úgy, hogy 'm' átadás után a labda visszatér a kezdő diákhoz.\n\n    A függvény dinamikus programozást használ az átadási sorozatok számának meghatározásához. Minden diák vagy a bal szomszédjának, vagy a jobb szomszédjának adhatja tovább a labdát.\n\n    Paraméterek:\n    n: A körben álló diákok száma.\n    m: A labda átadásának száma.\n\n    Visszatér:\n    Egy egész szám, amely azokat a különböző átadási módokat jelenti, amelyek eredményeként a labda 'm' átadás után visszatér a kezdő diákhoz.\n\n    Esetek:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "es": "Cuenta el número de diferentes maneras de pasar una pelota entre 'n' estudiantes dispuestos en un círculo de tal manera que después de 'm' pases, la pelota regrese al estudiante inicial.\n\nLa función utiliza programación dinámica para determinar el número de secuencias de pases. Cada estudiante puede pasar la pelota ya sea al vecino de la izquierda o al vecino de la derecha.\n\nArgumentos:\nn: El número de estudiantes parados en un círculo.\nm: El número de veces que se pasa la pelota.\n\nDevuelve:\nUn entero que representa el número de formas distintas de pasar la pelota que resultan en que la pelota regrese al estudiante inicial después de 'm' pases.\n\nCases:\n>>> count_passing_ways(3, 3)\n2\n>>> count_passing_ways(5, 4)\n6", "arb": "\n    يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' من الطلاب المرتبين في دائرة \n    بحيث بعد 'm' من التمريرات، تعود الكرة إلى الطالب الذي بدأت منه.\n\n    تستخدم الدالة البرمجة الديناميكية لتحديد عدد تسلسلات التمرير. يمكن لكل طالب\n    تمرير الكرة إما إلى الجار الأيسر أو إلى الجار الأيمن.\n\n    يعيدالحجج:\n    n: عدد الطلاب الواقفين في دائرة.\n    m: عدد المرات التي يتم فيها تمرير الكرة.\n\n    يعيد:\n    عدد صحيح يمثل عدد الطرق المختلفة للتمرير التي تؤدي إلى عودة الكرة\n    إلى الطالب الذي بدأت منه بعد 'm' من التمريرات.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ", "sw": "\n    Inahesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliopangwa katika duara \n    kiasi kwamba baada ya 'm' kupitisha, mpira unarudi kwa mwanafunzi wa kuanzia.\n\n    Kazi hii inatumia programu ya nguvu ili kubaini idadi ya mfuatano wa kupitisha. Kila mwanafunzi\n    anaweza kupitisha mpira kwa jirani wa kushoto au kwa jirani wa kulia.\n\n    Hoja:\n    n: Idadi ya wanafunzi waliopo katika duara.\n    m: Idadi ya mara ambazo mpira unapita.\n\n    Inarejesha:\n    Nambari inayoashiria idadi ya njia tofauti za kupitisha ambazo zinasababisha mpira\n    kurudi kwa mwanafunzi wa kuanzia baada ya 'm' kupitisha.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ", "tr": "\n    Topun bir daire şeklinde dizilmiş 'n' öğrenci arasında kaç farklı şekilde geçirilebileceğini sayar,\n    öyle ki 'm' pas sonrasında top başlangıçtaki öğrenciye geri döner.\n\n    Fonksiyon, pas dizilerini belirlemek için dinamik programlama kullanır. Her öğrenci\n    topu ya sol komşusuna ya da sağ komşusuna geçirebilir.\n\n    Argümanlar:\n    n: Bir dairede duran öğrenci sayısı.\n    m: Topun kaç kez geçirildiği.\n\n    Döndürür:\n    Topun 'm' pas sonrasında başlangıçtaki öğrenciye geri dönmesiyle sonuçlanan\n    farklı pas yollarının sayısını temsil eden bir tamsayı.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ", "vi": "\n    Đếm số cách khác nhau để chuyền bóng giữa 'n' học sinh sắp xếp thành vòng tròn \n    sao cho sau 'm' lần chuyền, bóng quay trở lại học sinh bắt đầu.\n\n    Hàm sử dụng lập trình động để xác định số lượng chuỗi chuyền bóng. Mỗi học sinh\n    có thể chuyền bóng cho người bên trái hoặc người bên phải.\n\n    Tham số:\n    n: Số lượng học sinh đứng thành vòng tròn.\n    m: Số lần bóng được chuyền.\n\n    Trả về:\n    Một số nguyên đại diện cho số cách chuyền bóng khác nhau mà kết quả là bóng\n    quay trở lại học sinh bắt đầu sau 'm' lần chuyền.\n\n    Trường hợp:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "id": "Menghitung jumlah cara berbeda untuk mengoper bola di antara 'n' siswa yang diatur dalam lingkaran sedemikian rupa sehingga setelah 'm' operan, bola kembali ke siswa yang memulai.\n\nFungsi ini menggunakan pemrograman dinamis untuk menentukan jumlah urutan operan. Setiap siswa dapat mengoper bola ke tetangga kiri atau ke tetangga kanan.\n\nArgs:\nn: Jumlah siswa yang berdiri dalam lingkaran.\nm: Jumlah kali bola dioper.\n\nReturns:\nSebuah bilangan bulat yang mewakili jumlah cara operan yang berbeda yang mengakibatkan bola kembali ke siswa yang memulai setelah 'm' operan.\n\nCases:\n>>> count_passing_ways(3, 3)\n2\n>>> count_passing_ways(5, 4)\n6", "ja": "    'n' 人の学生が円形に並んでいる中で、ボールを渡す異なる方法の数を数えます。\n    'm' 回のパスの後、ボールが開始した学生に戻るようにします。\n\n    この関数は動的プログラミングを使用して、パスのシーケンスの数を決定します。各学生は\n    ボールを左隣または右隣の学生に渡すことができます。\n\n    引数:\n    n: 円形に立っている学生の数。\n    m: ボールが渡される回数。\n\n    戻り値:\n    'm' 回のパスの後にボールが開始した学生に戻る結果となる、異なるパスの方法の数を表す整数。\n\n    ケース:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "ko": "    'n'명의 학생들이 원형으로 배열되어 있을 때, 공이 시작 학생에게 돌아오는 'm'번의 패스 후에 공을 전달하는 서로 다른 방법의 수를 계산합니다.\n\n    이 함수는 동적 프로그래밍을 사용하여 패스 시퀀스의 수를 결정합니다. 각 학생은 공을 왼쪽 이웃이나 오른쪽 이웃에게 전달할 수 있습니다.\n\n    인수:\n    n: 원형으로 서 있는 학생의 수.\n    m: 공이 전달되는 횟수.\n\n    반환:\n    'm'번의 패스 후에 공이 시작 학생에게 돌아오는 서로 다른 패스 방법의 수를 나타내는 정수.\n\n    예시:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "ml": "    'n' വിദ്യാർത്ഥികളെ വൃത്താകൃതിയിൽ നിരത്തിയ ശേഷം 'm' തവണ പന്ത് കൈമാറിയപ്പോൾ പന്ത് ആരംഭിച്ച വിദ്യാർത്ഥിയിലേക്ക് മടങ്ങിയെത്തുന്ന വ്യത്യസ്ത മാർഗങ്ങളുടെ എണ്ണം എണ്ണുന്നു.\n\n    ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് പന്ത് കൈമാറ്റ ശൃംഖലകളുടെ എണ്ണം നിർണയിക്കുന്നതിനുള്ള ഫംഗ്ഷൻ. ഓരോ വിദ്യാർത്ഥിയും പന്ത് ഇടത് അയൽക്കാരനോ വലത് അയൽക്കാരനോക്ക് കൈമാറാം.\n\n    Args:\n    n: വൃത്തത്തിൽ നിൽക്കുന്ന വിദ്യാർത്ഥികളുടെ എണ്ണം.\n    m: പന്ത് കൈമാറുന്ന തവണകളുടെ എണ്ണം.\n\n    Returns:\n    'm' തവണ പന്ത് കൈമാറിയ ശേഷം പന്ത് ആരംഭിച്ച വിദ്യാർത്ഥിയിലേക്ക് മടങ്ങിയെത്തുന്ന വ്യത്യസ്തമായ കൈമാറ്റ മാർഗങ്ങളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6", "fa": "    تعداد راه‌های مختلف برای پاس دادن توپ بین 'n' دانش‌آموزی که به صورت دایره‌ای قرار گرفته‌اند \n    را می‌شمارد به طوری که بعد از 'm' پاس، توپ به دانش‌آموز شروع‌کننده برگردد.\n\n    این تابع از برنامه‌ریزی پویا برای تعیین تعداد دنباله‌های پاس استفاده می‌کند. هر دانش‌آموز\n    می‌تواند توپ را یا به همسایه چپ یا به همسایه راست پاس دهد.\n\n    آرگومان‌ها:\n    n: تعداد دانش‌آموزانی که در یک دایره ایستاده‌اند.\n    m: تعداد دفعاتی که توپ پاس داده می‌شود.\n\n    بازگشت:\n    یک عدد صحیح که نشان‌دهنده تعداد راه‌های متمایز پاس دادن است که منجر به بازگشت توپ\n    به دانش‌آموز شروع‌کننده بعد از 'm' پاس می‌شود.\n\n    موارد:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6"}}
{"task_id": "Python/17", "prompt": {"en": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "sq": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Hiq numrat e përsëritur nga lista e dhënë dhe kthe numrat unik të renditur.\n\n    Funksioni fillimisht konverton listën e numrave në një grup për të hequr çdo përsëritje,\n    pastaj rendit grupin e numrave unik. Kthen një dyshe që përmban numrin\n    e numrave unik dhe një listë të këtyre numrave unik në rend rritës.\n\n    Argumentet:\n    numbers (List[int]): Një listë e numrave të plotë, e cila mund të përmbajë përsëritje.\n\n    Kthen:\n    Tuple[int, List[int]]: Një dyshe me dy elemente:\n        - Një numër i plotë që përfaqëson numrin e numrave unik.\n        - Një listë e numrave unik të renditur në rend rritës.\n\n    Shembuj:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "hy": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Հեռացնել կրկնվող ամբողջ թվերը մուտքային ցուցակից և վերադարձնել դասավորված եզակի թվերը։\n\n    Ֆունկցիան նախ փոխակերպում է թվերի մուտքային ցուցակը հավաքածուի՝ հեռացնելու համար ցանկացած կրկնություն,\n    ապա դասավորում է եզակի թվերի ստացված հավաքածուն։ Այն վերադարձնում է զույգ, որը պարունակում է\n    եզակի թվերի քանակը և այդ եզակի թվերի ցուցակը աճման կարգով։\n\n    Արգումենտներ:\n    numbers (List[int]): Ամբողջ թվերի ցուցակ, որը կարող է պարունակել կրկնություններ։\n\n    Վերադարձնում է:\n    Tuple[int, List[int]]: Զույգ երկու տարրերով:\n        - Ամբողջ թիվ, որը ներկայացնում է եզակի թվերի քանակը։\n        - Եզակի թվերի ցուցակ, դասավորված աճման կարգով։\n\n    Օրինակներ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "bn": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    ইনপুট তালিকা থেকে সদৃশ পূর্ণসংখ্যা সরান এবং সাজানো অনন্য সংখ্যাগুলি ফেরত দিন।\n\n    ফাংশনটি প্রথমে ইনপুট তালিকাকে একটি সেটে রূপান্তর করে যেকোনো সদৃশ সংখ্যা সরিয়ে দেয়,\n    তারপর অনন্য সংখ্যাগুলির সেটকে সাজায়। এটি একটি টিউপল ফেরত দেয় যা অনন্য সংখ্যাগুলির\n    সংখ্যা এবং এই অনন্য সংখ্যাগুলির একটি ক্রমবর্ধমান তালিকা ধারণ করে।\n\n    আর্গুমেন্টসমূহ:\n    numbers (List[int]): পূর্ণসংখ্যার একটি তালিকা, যা সদৃশ সংখ্যা থাকতে পারে।\n\n    রিটার্নস:\n    Tuple[int, List[int]]: দুটি উপাদান সহ একটি টিউপল:\n        - অনন্য সংখ্যাগুলির সংখ্যাকে উপস্থাপনকারী একটি পূর্ণসংখ্যা।\n        - ক্রমবর্ধমানভাবে সাজানো অনন্য সংখ্যাগুলির একটি তালিকা।\n\n    উদাহরণ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "bg": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Премахнете дублиращите се цели числа от входния списък и върнете сортираните уникални числа.\n\n    Функцията първо преобразува входния списък от числа в множество, за да премахне дубликатите,\n    след това сортира полученото множество от уникални числа. Връща кортеж, съдържащ броя\n    на уникалните числа и списък с тези уникални числа в нарастващ ред.\n\n    Аргументи:\n    numbers (List[int]): Списък от цели числа, който може да съдържа дубликати.\n\n    Връща:\n    Tuple[int, List[int]]: Кортеж с два елемента:\n        - Цяло число, представляващо броя на уникалните числа.\n        - Списък с уникалните числа, сортирани в нарастващ ред.\n\n    Примери:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "zh": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    从输入列表中移除重复的整数，并返回排序后的唯一数字。\n\n    该函数首先将输入的数字列表转换为集合以去除任何重复项，\n    然后对结果的唯一数字集合进行排序。它返回一个包含两个元素的元组：\n    唯一数字的数量和按升序排列的唯一数字列表。\n\n    参数:\n    numbers (List[int]): 一个可能包含重复项的整数列表。\n\n    返回:\n    Tuple[int, List[int]]: 一个包含两个元素的元组：\n        - 一个整数，表示唯一数字的数量。\n        - 一个按升序排列的唯一数字列表。\n\n    示例:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "fr": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Supprimez les entiers en double de la liste d'entrée et retournez les nombres uniques triés.\n\n    La fonction convertit d'abord la liste d'entrée de nombres en un ensemble pour supprimer les doublons,\n    puis trie l'ensemble résultant de nombres uniques. Elle retourne un tuple contenant le nombre\n    de nombres uniques et une liste de ces nombres uniques dans l'ordre croissant.\n\n    Args:\n    numbers (List[int]): Une liste d'entiers, qui peut contenir des doublons.\n\n    Returns:\n    Tuple[int, List[int]]: Un tuple avec deux éléments :\n        - Un entier représentant le nombre de nombres uniques.\n        - Une liste des nombres uniques triés par ordre croissant.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "de": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Entfernen Sie doppelte Ganzzahlen aus der Eingabeliste und geben Sie die sortierten eindeutigen Zahlen zurück.\n\n    Die Funktion konvertiert zuerst die Eingabeliste von Zahlen in eine Menge, um Duplikate zu entfernen,\n    und sortiert dann die resultierende Menge eindeutiger Zahlen. Sie gibt ein Tupel zurück, das die Anzahl\n    der eindeutigen Zahlen und eine Liste dieser eindeutigen Zahlen in aufsteigender Reihenfolge enthält.\n\n    Args:\n    numbers (List[int]): Eine Liste von Ganzzahlen, die Duplikate enthalten kann.\n\n    Returns:\n    Tuple[int, List[int]]: Ein Tupel mit zwei Elementen:\n        - Eine Ganzzahl, die die Anzahl der eindeutigen Zahlen darstellt.\n        - Eine Liste der eindeutigen Zahlen, sortiert in aufsteigender Reihenfolge.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "ha": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Cire lambobin maimaitawa daga jerin shigarwa kuma dawo da lambobin da ba su maimaita ba a jere.\n\n    Aiki na farko yana canza jerin lambobi na shigarwa zuwa saitin don cire duk maimaitawa,\n    sannan ya jera saitin lambobin da ba su maimaita ba. Yana dawowa da tuple wanda ke dauke da adadin\n    lambobin da ba su maimaita ba da kuma jerin wadannan lambobin da ba su maimaita ba a cikin tsari mai hawa.\n\n    Args:\n    numbers (List[int]): Jerin lambobi, wanda zai iya dauke da maimaitawa.\n\n    Returns:\n    Tuple[int, List[int]]: Tuple tare da abubuwa biyu:\n        - Lamba mai nuna adadin lambobin da ba su maimaita ba.\n        - Jerin lambobin da ba su maimaita ba a cikin tsari mai hawa.\n\n    Misalai:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "hi": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    इनपुट सूची से डुप्लिकेट पूर्णांकों को हटाएं और क्रमबद्ध अद्वितीय संख्याएं लौटाएं।\n\n    यह फ़ंक्शन सबसे पहले संख्याओं की इनपुट सूची को एक सेट में परिवर्तित करता है ताकि कोई भी डुप्लिकेट हट जाए,\n    फिर अद्वितीय संख्याओं के परिणामी सेट को क्रमबद्ध करता है। यह एक ट्यूपल लौटाता है जिसमें अद्वितीय संख्याओं की गिनती\n    और इन अद्वितीय संख्याओं की आरोही क्रम में सूची होती है।\n\n    तर्क:\n    numbers (List[int]): पूर्णांकों की एक सूची, जिसमें डुप्लिकेट हो सकते हैं।\n\n    रिटर्न:\n    Tuple[int, List[int]]: एक ट्यूपल जिसमें दो तत्व होते हैं:\n        - अद्वितीय संख्याओं की गिनती को दर्शाने वाला एक पूर्णांक।\n        - अद्वितीय संख्याओं की आरोही क्रम में सूची।\n\n    उदाहरण:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "hu": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Távolítsa el a duplikált egész számokat a bemeneti listából, és adja vissza a rendezett egyedi számokat.\n\n    A függvény először átalakítja a bemeneti számok listáját egy halmazzá, hogy eltávolítsa az esetleges duplikátumokat,\n    majd rendezi az így kapott egyedi számok halmazát. Egy olyan tuple-t ad vissza, amely tartalmazza az egyedi számok\n    számát és egy listát ezekről az egyedi számokról növekvő sorrendben.\n\n    Paraméterek:\n    numbers (List[int]): Egy egész számokat tartalmazó lista, amely tartalmazhat duplikátumokat.\n\n    Visszatér:\n    Tuple[int, List[int]]: Egy tuple két elemmel:\n        - Egy egész szám, amely az egyedi számok számát jelöli.\n        - Egy lista az egyedi számokról növekvő sorrendben.\n\n    Példák:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "es": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Elimina los enteros duplicados de la lista de entrada y devuelve los números únicos ordenados.\n\n    La función primero convierte la lista de números de entrada en un conjunto para eliminar cualquier duplicado,\n    luego ordena el conjunto resultante de números únicos. Devuelve una tupla que contiene el conteo\n    de números únicos y una lista de estos números únicos en orden ascendente.\n\n    Argumentos:\n    numbers (List[int]): Una lista de enteros, que puede contener duplicados.\n\n    Devuelve:\n    Tuple[int, List[int]]: Una tupla con dos elementos:\n        - Un entero que representa el conteo de números únicos.\n        - Una lista de los números únicos ordenados en orden ascendente.\n\n    Ejemplos:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "arb": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    إزالة الأعداد الصحيحة المكررة من قائمة الإدخال وإرجاع الأرقام الفريدة المرتبة.\n\n    تقوم الدالة أولاً بتحويل قائمة الأرقام المدخلة إلى مجموعة لإزالة أي تكرارات،\n    ثم تقوم بترتيب المجموعة الناتجة من الأرقام الفريدة. تعيد الدالة زوج يحتوي على عدد\n    الأرقام الفريدة وقائمة بهذه الأرقام الفريدة بترتيب تصاعدي.\n\n    يعيدالحجج:\n    numbers (List[int]): قائمة من الأعداد الصحيحة، والتي قد تحتوي على تكرارات.\n\n    يعيد:\n    Tuple[int, List[int]]: زوج يحتوي على عنصرين:\n        - عدد صحيح يمثل عدد الأرقام الفريدة.\n        - قائمة بالأرقام الفريدة مرتبة بترتيب تصاعدي.\n\n    امثله:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "sw": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Ondoa namba za kurudia kutoka kwenye orodha ya ingizo na rudisha namba za kipekee zilizopangwa.\n\n    Kazi hii kwanza inabadilisha orodha ya namba za ingizo kuwa seti ili kuondoa marudio yoyote,\n    kisha inapanga seti inayotokana ya namba za kipekee. Inarudisha jozi inayojumuisha idadi\n    ya namba za kipekee na orodha ya namba hizi za kipekee kwa mpangilio wa kupanda.\n\n    Hoja:\n    numbers (List[int]): Orodha ya namba za mzima, ambayo inaweza kuwa na marudio.\n\n    Inarejesha:\n    Tuple[int, List[int]]: Jozi yenye vipengele viwili:\n        - Namba ya mzima inayowakilisha idadi ya namba za kipekee.\n        - Orodha ya namba za kipekee zilizopangwa kwa mpangilio wa kupanda.\n\n    Mifano:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "tr": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Girdi listesinden yinelenen tamsayıları kaldırın ve sıralanmış benzersiz sayıları döndürün.\n\n    Fonksiyon, önce girdi listesindeki sayıları bir kümeye dönüştürerek yinelenenleri kaldırır,\n    ardından benzersiz sayıların bulunduğu kümeyi sıralar. Benzersiz sayıların sayısını ve\n    bu benzersiz sayıların artan sırayla listelendiği bir liste içeren bir demet döndürür.\n\n    Argümanlar:\n    numbers (List[int]): Yinelenenler içerebilecek bir tamsayı listesi.\n\n    Dönüş:\n    Tuple[int, List[int]]: İki elemanlı bir demet:\n        - Benzersiz sayıların sayısını temsil eden bir tamsayı.\n        - Benzersiz sayıların artan sırayla sıralandığı bir liste.\n\n    Örnekler:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "vi": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Loại bỏ các số nguyên trùng lặp khỏi danh sách đầu vào và trả về các số duy nhất đã được sắp xếp.\n\n    Hàm này đầu tiên chuyển đổi danh sách các số đầu vào thành một tập hợp để loại bỏ bất kỳ trùng lặp nào,\n    sau đó sắp xếp tập hợp các số duy nhất. Nó trả về một bộ giá trị chứa số lượng\n    các số duy nhất và một danh sách các số duy nhất này theo thứ tự tăng dần.\n\n    Tham số:\n    numbers (List[int]): Một danh sách các số nguyên, có thể chứa các phần tử trùng lặp.\n\n    Trả về:\n    Tuple[int, List[int]]: Một bộ giá trị với hai phần tử:\n        - Một số nguyên đại diện cho số lượng các số duy nhất.\n        - Một danh sách các số duy nhất được sắp xếp theo thứ tự tăng dần.\n\n    Ví dụ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "id": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Hapus bilangan bulat duplikat dari daftar input dan kembalikan angka unik yang diurutkan.\n\n    Fungsi ini pertama-tama mengonversi daftar angka input menjadi satu set untuk menghapus duplikat apa pun,\n    kemudian mengurutkan set angka unik yang dihasilkan. Fungsi ini mengembalikan tuple yang berisi jumlah\n    angka unik dan daftar angka unik ini dalam urutan menaik.\n\n    Args:\n    numbers (List[int]): Daftar bilangan bulat, yang mungkin mengandung duplikat.\n\n    Returns:\n    Tuple[int, List[int]]: Sebuah tuple dengan dua elemen:\n        - Sebuah bilangan bulat yang mewakili jumlah angka unik.\n        - Daftar angka unik yang diurutkan dalam urutan menaik.\n\n    Contoh:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "ja": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    入力リストから重複する整数を削除し、ソートされたユニークな数字を返します。\n\n    この関数は、まず入力された数字のリストをセットに変換して重複を削除し、\n    次にユニークな数字のセットをソートします。ユニークな数字の数と昇順にソートされた\n    ユニークな数字のリストを含むタプルを返します。\n\n    引数:\n    numbers (List[int]): 重複を含む可能性のある整数のリスト。\n\n    戻り値:\n    Tuple[int, List[int]]: 2つの要素を持つタプル:\n        - ユニークな数字の数を表す整数。\n        - 昇順にソートされたユニークな数字のリスト。\n\n    例:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "ko": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    입력 리스트에서 중복된 정수를 제거하고 정렬된 고유 숫자를 반환합니다.\n\n    이 함수는 먼저 입력된 숫자 리스트를 집합으로 변환하여 중복을 제거한 후,\n    고유 숫자의 집합을 정렬합니다. 고유 숫자의 개수와 오름차순으로 정렬된\n    고유 숫자의 리스트를 포함하는 튜플을 반환합니다.\n\n    Args:\n    numbers (List[int]): 중복이 포함될 수 있는 정수 리스트.\n\n    Returns:\n    Tuple[int, List[int]]: 두 요소를 가진 튜플:\n        - 고유 숫자의 개수를 나타내는 정수.\n        - 오름차순으로 정렬된 고유 숫자의 리스트.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "ml": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    ഇൻപുട്ട് ലിസ്റ്റിൽ നിന്ന് പുനരാവൃത സംഖ്യകൾ നീക്കം ചെയ്ത് ക്രമീകരിച്ച യുണീക്ക് സംഖ്യകൾ തിരികെ നൽകുക.\n\n    ഫംഗ്ഷൻ ആദ്യം പുനരാവൃതികൾ നീക്കം ചെയ്യുന്നതിന് ഇൻപുട്ട് ലിസ്റ്റ് ഒരു സെറ്റാക്കി മാറ്റുന്നു,\n    തുടർന്ന് യുണീക്ക് സംഖ്യകളുടെ ഫലമായ സെറ്റ് ക്രമീകരിക്കുന്നു. ഇത് യുണീക്ക് സംഖ്യകളുടെ എണ്ണവും\n    ഉയർന്ന ക്രമത്തിൽ ക്രമീകരിച്ച ഈ യുണീക്ക് സംഖ്യകളുടെ ഒരു ലിസ്റ്റും അടങ്ങിയ ഒരു ട്യൂപ്പിൾ തിരികെ നൽകുന്നു.\n\n    Args:\n    numbers (List[int]): പുനരാവൃതികൾ അടങ്ങിയിരിക്കാവുന്ന സംഖ്യകളുടെ ഒരു ലിസ്റ്റ്.\n\n    Returns:\n    Tuple[int, List[int]]: രണ്ട് ഘടകങ്ങളുള്ള ഒരു ട്യൂപ്പിൾ:\n        - യുണീക്ക് സംഖ്യകളുടെ എണ്ണത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n        - ഉയർന്ന ക്രമത്തിൽ ക്രമീകരിച്ച യുണീക്ക് സംഖ്യകളുടെ ഒരു ലിസ്റ്റ്.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"", "fa": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    اعداد صحیح تکراری را از لیست ورودی حذف کرده و اعداد منحصر به فرد مرتب شده را برگردانید.\n\n    این تابع ابتدا لیست ورودی اعداد را به یک مجموعه تبدیل می‌کند تا هرگونه تکرار را حذف کند،\n    سپس مجموعه حاصل از اعداد منحصر به فرد را مرتب می‌کند. این تابع یک تاپل شامل تعداد\n    اعداد منحصر به فرد و یک لیست از این اعداد منحصر به فرد به ترتیب صعودی برمی‌گرداند.\n\n    آرگومان‌ها:\n    numbers (List[int]): یک لیست از اعداد صحیح که ممکن است شامل تکراری‌ها باشد.\n\n    بازگشت:\n    Tuple[int, List[int]]: یک تاپل با دو عنصر:\n        - یک عدد صحیح که نشان‌دهنده تعداد اعداد منحصر به فرد است.\n        - یک لیست از اعداد منحصر به فرد مرتب شده به ترتیب صعودی.\n\n    مثال‌ها:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\""}, "canonical_solution": "# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers", "instruction": {"en": "Write a python function 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' to solve the following problem:\n\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    ", "sq": "Shkruani një funksion python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' për të zgjidhur problemin e mëposhtëm:\n\n    Hiqni numrat e plotë të dyfishtë nga lista e hyrjes dhe ktheni numrat unik të renditur.\n\n    Funksioni së pari konverton listën e numrave të hyrjes në një set për të hequr çdo dublikatë,\n    pastaj rendit setin e rezultuar të numrave unik. Ai kthen një tuple që përmban numrin\n    e numrave unik dhe një listë të këtyre numrave unik në rend rritës.\n\n    Args:\n    numbers (List[int]): Një listë numrash të plotë, që mund të përmbajë dublikatë.\n\n    Returns:\n    Tuple[int, List[int]]: Një tuple me dy elemente:\n        - Një numër i plotë që përfaqëson numrin e numrave unik.\n        - Një listë e numrave unik të renditur në rend rritës.\n\n    Shembuj:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "hy": "Պայթոն ֆունկցիա 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հեռացրեք կրկնվող ամբողջ թվերը մուտքային ցուցակից և վերադարձեք դասավորված եզակի թվերը։\n\n    Ֆունկցիան նախ փոխակերպում է մուտքային թվերի ցուցակը հավաքածուի՝ հեռացնելու համար ցանկացած կրկնվողներ,\n    ապա դասավորում է ստացված եզակի թվերի հավաքածուն։ Այն վերադարձնում է զույգ, որը պարունակում է եզակի թվերի քանակը\n    և այս եզակի թվերի ցուցակը աճման կարգով։\n\n    Արձագանքներ:\n    numbers (List[int]): Ամբողջ թվերի ցուցակ, որը կարող է պարունակել կրկնվողներ։\n\n    Վերադարձնում է:\n    Tuple[int, List[int]]: Զույգ երկու տարրերով:\n        - Ամբողջ թիվ, որը ներկայացնում է եզակի թվերի քանակը։\n        - Եզակի թվերի ցուցակ, դասավորված աճման կարգով։\n\n    Օրինակներ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "bn": "একটি পাইথন ফাংশন 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n\n    ইনপুট তালিকা থেকে সদৃশ পূর্ণসংখ্যাগুলি সরান এবং সাজানো অনন্য সংখ্যাগুলি ফেরত দিন।\n\n    ফাংশনটি প্রথমে ইনপুট তালিকাকে একটি সেটে রূপান্তর করে যাতে কোনো সদৃশ সংখ্যা থাকে না,\n    তারপর অনন্য সংখ্যাগুলির সেটটিকে সাজায়। এটি একটি টিউপল ফেরত দেয় যা অনন্য সংখ্যাগুলির সংখ্যা \n    এবং এই অনন্য সংখ্যাগুলির একটি তালিকা ক্রমবর্ধমান ক্রমে ধারণ করে।\n\n    আর্গস:\n    numbers (List[int]): পূর্ণসংখ্যার একটি তালিকা, যা সদৃশ সংখ্যা থাকতে পারে।\n\n    রিটার্নস:\n    Tuple[int, List[int]]: একটি টিউপল যার দুটি উপাদান রয়েছে:\n        - অনন্য সংখ্যাগুলির সংখ্যা নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n        - অনন্য সংখ্যাগুলির একটি তালিকা যা ক্রমবর্ধমান ক্রমে সাজানো।\n\n    উদাহরণ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "bg": "Напишете Python функция 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' за да решите следния проблем:\n\n    Премахнете дублиращите се цели числа от входния списък и върнете сортираните уникални числа.\n\n    Функцията първо преобразува входния списък от числа в множество, за да премахне всички дубликати,\n    след това сортира полученото множество от уникални числа. Тя връща кортеж, съдържащ броя\n    на уникалните числа и списък от тези уникални числа в нарастващ ред.\n\n    Аргументи:\n    numbers (List[int]): Списък от цели числа, който може да съдържа дубликати.\n\n    Връща:\n    Tuple[int, List[int]]: Кортеж с два елемента:\n        - Цяло число, представляващо броя на уникалните числа.\n        - Списък на уникалните числа, сортирани в нарастващ ред.\n\n    Примери:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "zh": "编写一个Python函数 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' 来解决以下问题：\n\n    从输入列表中删除重复的整数，并返回排序后的唯一数字。\n\n    该函数首先将输入的数字列表转换为集合以删除任何重复项，\n    然后对结果的唯一数字集合进行排序。它返回一个包含唯一数字计数的元组\n    和一个按升序排列的唯一数字列表。\n\n    参数：\n    numbers (List[int]): 一个可能包含重复项的整数列表。\n\n    返回：\n    Tuple[int, List[int]]: 一个包含两个元素的元组：\n        - 一个表示唯一数字计数的整数。\n        - 一个按升序排列的唯一数字列表。\n\n    示例：\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "fr": "Écrivez une fonction python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' pour résoudre le problème suivant :\n\n    Supprimez les entiers en double de la liste d'entrée et renvoyez les nombres uniques triés.\n\n    La fonction convertit d'abord la liste d'entrée de nombres en un ensemble pour supprimer les doublons,\n    puis trie l'ensemble résultant de nombres uniques. Elle renvoie un tuple contenant le nombre\n    de nombres uniques et une liste de ces nombres uniques dans l'ordre croissant.\n\n    Args:\n    numbers (List[int]): Une liste d'entiers, qui peut contenir des doublons.\n\n    Returns:\n    Tuple[int, List[int]]: Un tuple avec deux éléments :\n        - Un entier représentant le nombre de nombres uniques.\n        - Une liste des nombres uniques triés dans l'ordre croissant.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "de": "Schreiben Sie eine Python-Funktion 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' um das folgende Problem zu lösen:\n\n    Entfernen Sie doppelte Ganzzahlen aus der Eingabeliste und geben Sie die sortierten eindeutigen Zahlen zurück.\n\n    Die Funktion konvertiert zuerst die Eingabeliste der Zahlen in eine Menge, um Duplikate zu entfernen,\n    und sortiert dann die resultierende Menge der eindeutigen Zahlen. Sie gibt ein Tupel zurück, das die Anzahl\n    der eindeutigen Zahlen und eine Liste dieser eindeutigen Zahlen in aufsteigender Reihenfolge enthält.\n\n    Argumente:\n    numbers (List[int]): Eine Liste von Ganzzahlen, die Duplikate enthalten kann.\n\n    Rückgabewerte:\n    Tuple[int, List[int]]: Ein Tupel mit zwei Elementen:\n        - Eine Ganzzahl, die die Anzahl der eindeutigen Zahlen darstellt.\n        - Eine Liste der eindeutigen Zahlen, sortiert in aufsteigender Reihenfolge.\n\n    Beispiele:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "ha": "Rubuta wani aikin python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' don warware matsalar mai zuwa:\n\n    Cire lambobin maimaitawa daga jerin shigarwa sannan a dawo da lambobin musamman da aka tsara.\n\n    Aikin yana fara canza jerin lambobin shigarwa zuwa saitin don cire duk wani maimaitawa,\n    sannan yana tsara saitin lambobin musamman da aka samu. Yana dawowa da tuple mai dauke da adadin\n    lambobin musamman da jerin wadannan lambobin musamman a tsari mai hauhawa.\n\n    Args:\n    numbers (List[int]): Jerin lambobi, wanda zai iya dauke da maimaitawa.\n\n    Returns:\n    Tuple[int, List[int]]: Tuple mai dauke da abubuwa biyu:\n        - Lamba mai wakiltar adadin lambobin musamman.\n        - Jerin lambobin musamman da aka tsara a tsari mai hauhawa.\n\n    Misalai:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "hi": "एक पायथन फ़ंक्शन 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    इनपुट सूची से डुप्लिकेट पूर्णांकों को हटा दें और क्रमबद्ध अद्वितीय संख्याएँ लौटाएँ।\n\n    फ़ंक्शन पहले संख्याओं की इनपुट सूची को एक सेट में परिवर्तित करता है ताकि किसी भी डुप्लिकेट को हटा सके,\n    फिर अद्वितीय संख्याओं के परिणामी सेट को क्रमबद्ध करता है। यह एक ट्यूपल लौटाता है जिसमें अद्वितीय संख्याओं की गिनती\n    और इन अद्वितीय संख्याओं की एक सूची आरोही क्रम में होती है।\n\n    तर्क:\n    numbers (List[int]): पूर्णांकों की एक सूची, जिसमें डुप्लिकेट हो सकते हैं।\n\n    लौटाता है:\n    Tuple[int, List[int]]: एक ट्यूपल जिसमें दो तत्व होते हैं:\n        - अद्वितीय संख्याओं की गिनती को दर्शाने वाला एक पूर्णांक।\n        - अद्वितीय संख्याओं की एक सूची जो आरोही क्रम में क्रमबद्ध होती है।\n\n    उदाहरण:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "hu": "Írj egy python függvényt 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' a következő probléma megoldására:\n\n    Távolítsa el a duplikált egész számokat a bemeneti listából, és adja vissza a rendezett egyedi számokat.\n\n    A függvény először átalakítja a bemeneti számok listáját egy halmazzá, hogy eltávolítsa az esetleges duplikátumokat,\n    majd rendezi az eredményül kapott egyedi számok halmazát. Egy olyan tuple-t ad vissza, amely tartalmazza\n    az egyedi számok számát és az ezekből álló listát növekvő sorrendben.\n\n    Args:\n    numbers (List[int]): Egész számok listája, amely tartalmazhat duplikátumokat.\n\n    Returns:\n    Tuple[int, List[int]]: Egy tuple két elemmel:\n        - Egy egész szám, amely az egyedi számok számát jelöli.\n        - Az egyedi számok listája növekvő sorrendben.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "es": "Escribe una función de Python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' para resolver el siguiente problema:\n\n    Eliminar números enteros duplicados de la lista de entrada y devolver los números únicos ordenados.\n\n    La función primero convierte la lista de números de entrada en un conjunto para eliminar cualquier duplicado,\n    luego ordena el conjunto resultante de números únicos. Devuelve una tupla que contiene el conteo\n    de números únicos y una lista de estos números únicos en orden ascendente.\n\n    Argumentos:\n    numbers (List[int]): Una lista de enteros, que puede contener duplicados.\n\n    Devuelve:\n    Tuple[int, List[int]]: Una tupla con dos elementos:\n        - Un entero que representa el conteo de números únicos.\n        - Una lista de los números únicos ordenados en orden ascendente.\n\n    Ejemplos:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "arb": "اكتب دالة بايثون 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' لحل المشكلة التالية:\n\n    إزالة الأعداد الصحيحة المكررة من قائمة الإدخال وإرجاع الأعداد الفريدة مرتبة.\n\n    تقوم الدالة أولاً بتحويل قائمة الأرقام المدخلة إلى مجموعة لإزالة أي تكرارات،\n    ثم تقوم بترتيب المجموعة الناتجة من الأرقام الفريدة. تُرجع الدالة زوج يحتوي على عدد\n    الأرقام الفريدة وقائمة بهذه الأرقام الفريدة مرتبة تصاعدياً.\n\n    يعيدالحجج:\n    numbers (List[int]): قائمة من الأعداد الصحيحة، قد تحتوي على تكرارات.\n\n    يعيد:\n    Tuple[int, List[int]]: زوج يحتوي على عنصرين:\n        - عدد صحيح يمثل عدد الأرقام الفريدة.\n        - قائمة بالأرقام الفريدة مرتبة تصاعدياً.\n\n    أمثلة:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "sw": "Andika kazi ya python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' kutatua tatizo lifuatalo:\n\n    Ondoa namba za kurudia kutoka kwenye orodha ya ingizo na rudisha namba za kipekee zilizopangwa.\n\n    Kazi hii kwanza inabadilisha orodha ya ingizo ya namba kuwa seti ili kuondoa nakala zozote,\n    kisha inapanga seti inayotokana na namba za kipekee. Inarudisha jozi inayojumuisha hesabu\n    ya namba za kipekee na orodha ya namba hizi za kipekee katika mpangilio wa kupanda.\n\n    Hoja:\n    numbers (List[int]): Orodha ya namba za mzima, ambayo inaweza kuwa na nakala.\n\n    Inarejesha:\n    Tuple[int, List[int]]: Jozi yenye vipengele viwili:\n        - Namba ya mzima inayowakilisha hesabu ya namba za kipekee.\n        - Orodha ya namba za kipekee zilizopangwa kwa mpangilio wa kupanda.\n\n    Mifano:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "tr": "Bir python fonksiyonu 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' yazın ve aşağıdaki problemi çözün:\n\n    Girdi listesinden tekrar eden tamsayıları kaldırın ve sıralanmış benzersiz sayıları döndürün.\n\n    Fonksiyon, ilk olarak girdi listesindeki sayıları bir sete dönüştürerek tekrar edenleri kaldırır,\n    ardından benzersiz sayıların bulunduğu seti sıralar. Fonksiyon, benzersiz sayıların sayısını ve\n    bu sayıların artan sırayla bulunduğu bir listeyi içeren bir demet döndürür.\n\n    Argümanlar:\n    numbers (List[int]): Tekrar edebilen tamsayılar içeren bir liste.\n\n    Döndürür:\n    Tuple[int, List[int]]: İki elemanlı bir demet:\n        - Benzersiz sayıların sayısını temsil eden bir tamsayı.\n        - Benzersiz sayıların artan sırayla bulunduğu bir liste.\n\n    Örnekler:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "vi": "Viết một hàm python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' để giải quyết vấn đề sau:\n\n    Loại bỏ các số nguyên trùng lặp khỏi danh sách đầu vào và trả về các số duy nhất đã được sắp xếp.\n\n    Hàm đầu tiên chuyển đổi danh sách số đầu vào thành một tập hợp để loại bỏ bất kỳ số trùng lặp nào,\n    sau đó sắp xếp tập hợp các số duy nhất kết quả. Nó trả về một bộ chứa số lượng\n    các số duy nhất và một danh sách các số duy nhất này theo thứ tự tăng dần.\n\n    Tham số:\n    numbers (List[int]): Một danh sách các số nguyên, có thể chứa các số trùng lặp.\n\n    Trả về:\n    Tuple[int, List[int]]: Một bộ với hai phần tử:\n        - Một số nguyên đại diện cho số lượng các số duy nhất.\n        - Một danh sách các số duy nhất được sắp xếp theo thứ tự tăng dần.\n\n    Ví dụ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "id": "Tulis sebuah fungsi python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' untuk menyelesaikan masalah berikut:\n\n    Hapus bilangan bulat yang duplikat dari daftar input dan kembalikan angka unik yang sudah diurutkan.\n\n    Fungsi ini pertama-tama mengubah daftar angka input menjadi sebuah set untuk menghapus duplikat,\n    kemudian mengurutkan set dari angka unik tersebut. Fungsi ini mengembalikan sebuah tuple yang berisi jumlah\n    angka unik dan sebuah daftar angka unik tersebut dalam urutan menaik.\n\n    Args:\n    numbers (List[int]): Daftar bilangan bulat, yang mungkin mengandung duplikat.\n\n    Returns:\n    Tuple[int, List[int]]: Sebuah tuple dengan dua elemen:\n        - Sebuah bilangan bulat yang mewakili jumlah angka unik.\n        - Sebuah daftar angka unik yang diurutkan dalam urutan menaik.\n\n    Contoh:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "ja": "Python関数を書いてください。 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' を解決するために以下の問題:\n\n    入力リストから重複する整数を削除し、ソートされたユニークな数を返します。\n\n    関数は最初に入力された数のリストをセットに変換して重複を削除し、\n    その後、結果として得られたユニークな数のセットをソートします。ユニークな数の\n    カウントと昇順に並べられたこれらのユニークな数のリストを含むタプルを返します。\n\n    引数:\n    numbers (List[int]): 重複を含む可能性のある整数のリスト。\n\n    戻り値:\n    Tuple[int, List[int]]: 2つの要素を持つタプル:\n        - ユニークな数のカウントを表す整数。\n        - 昇順にソートされたユニークな数のリスト。\n\n    例:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "ko": "파이썬 함수를 작성하세요 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' 다음 문제를 해결하기 위해:\n\n    입력 리스트에서 중복된 정수를 제거하고 정렬된 고유 숫자를 반환합니다.\n\n    함수는 먼저 입력된 숫자 리스트를 집합으로 변환하여 중복을 제거한 후,\n    결과적으로 얻어진 고유 숫자 집합을 정렬합니다. 이 함수는 고유 숫자의 개수와\n    오름차순으로 정렬된 고유 숫자 리스트를 포함하는 튜플을 반환합니다.\n\n    인자:\n    numbers (List[int]): 중복이 포함될 수 있는 정수 리스트.\n\n    반환값:\n    Tuple[int, List[int]]: 두 요소를 가진 튜플:\n        - 고유 숫자의 개수를 나타내는 정수.\n        - 오름차순으로 정렬된 고유 숫자 리스트.\n\n    예시:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "ml": "'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    ഇൻപുട്ട് ലിസ്റ്റിൽ നിന്ന് പുനരാവൃത സംഖ്യകൾ നീക്കം ചെയ്ത് ക്രമീകരിച്ച ഏകീകൃത സംഖ്യകൾ തിരികെ നൽകുക.\n\n    ഫംഗ്ഷൻ ആദ്യം പുനരാവൃത സംഖ്യകൾ നീക്കം ചെയ്യാൻ സംഖ്യകളുടെ ഇൻപുട്ട് ലിസ്റ്റ് ഒരു സെറ്റാക്കി മാറ്റുന്നു,\n    തുടർന്ന് ക്രമീകരിച്ച ഏകീകൃത സംഖ്യകളുടെ സെറ്റ്. ഇത് ഏകീകൃത സംഖ്യകളുടെ എണ്ണം അടങ്ങിയ ഒരു ട്യൂപ്പിളും\n    ഉയർന്ന ക്രമത്തിൽ ക്രമീകരിച്ച ഈ ഏകീകൃത സംഖ്യകളുടെ ഒരു ലിസ്റ്റും തിരികെ നൽകുന്നു.\n\n    Args:\n    numbers (List[int]): പുനരാവൃതങ്ങൾ ഉൾപ്പെടാം എന്ന സാധ്യതയുള്ള സംഖ്യകളുടെ ഒരു ലിസ്റ്റ്.\n\n    Returns:\n    Tuple[int, List[int]]: രണ്ട് ഘടകങ്ങൾ ഉള്ള ഒരു ട്യൂപ്പിൾ:\n        - ഏകീകൃത സംഖ്യകളുടെ എണ്ണത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n        - ഉയർന്ന ക്രമത്തിൽ ക്രമീകരിച്ച ഏകീകൃത സംഖ്യകളുടെ ഒരു ലിസ്റ്റ്.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "fa": "یک تابع پایتون بنویسید 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' برای حل مشکل زیر:\n\n    اعداد تکراری را از لیست ورودی حذف کنید و اعداد یکتای مرتب شده را برگردانید.\n\n    تابع ابتدا لیست ورودی از اعداد را به یک مجموعه تبدیل می‌کند تا هرگونه تکرار را حذف کند،\n    سپس مجموعه‌ی حاصل از اعداد یکتا را مرتب می‌کند. این تابع یک تاپل شامل تعداد\n    اعداد یکتا و لیستی از این اعداد یکتا به ترتیب صعودی را برمی‌گرداند.\n\n    آرگومان‌ها:\n    numbers (List[int]): یک لیست از اعداد صحیح، که ممکن است شامل تکراری‌ها باشد.\n\n    بازگشت:\n    Tuple[int, List[int]]: یک تاپل با دو عنصر:\n        - یک عدد صحیح که نشان‌دهنده تعداد اعداد یکتا است.\n        - یک لیست از اعداد یکتا که به ترتیب صعودی مرتب شده‌اند.\n\n    مثال‌ها:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])"}, "level": "easy", "test": "def test_process_random_numbers():\n    # Test case 1: Basic example with duplicates\n    assert process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15]) == (8, [15, 20, 32, 40, 67, 89, 300, 400]), \"Test case 1 failed\"\n\n    # Test case 2: All elements are the same\n    assert process_random_numbers([1, 1, 1, 1]) == (1, [1]), \"Test case 2 failed\"\n\n    # Test case 3: No duplicates\n    assert process_random_numbers([3, 1, 4, 2]) == (4, [1, 2, 3, 4]), \"Test case 3 failed\"\n\n    # Test case 4: Random numbers with single element\n    assert process_random_numbers([42]) == (1, [42]), \"Test case 4 failed\"\n\n    # Test case 5: Empty list\n    assert process_random_numbers([]) == (0, []), \"Test case 5 failed\"\n\n    # Test case 6: Random numbers with negatives and zero\n    assert process_random_numbers([0, -1, -2, -1, 0, 3]) == (4, [-2, -1, 0, 3]), \"Test case 6 failed\"\n\n    # Test case 7: Large range of numbers\n    assert process_random_numbers(list(range(1000, 0, -1))) == (1000, list(range(1, 1001))), \"Test case 7 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_process_random_numbers()", "entry_point": "process_random_numbers", "signature": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:", "docstring": {"en": "\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    ", "sq": "\n    Hiqni numrat e përsëritur nga lista e hyrjes dhe kthejeni numrat unik të renditur.\n\n    Funksioni së pari konverton listën e numrave të hyrjes në një set për të hequr çdo përsëritje,\n    pastaj rendit setin e rezultuar të numrave unik. Ai kthen një tuple që përmban numrin\n    e numrave unik dhe një listë të këtyre numrave unik në rend rritës.\n\n    Argumentet:\n    numbers (List[int]): Një listë e numrave të plotë, e cila mund të përmbajë përsëritje.\n\n    Kthen:\n    Tuple[int, List[int]]: Një tuple me dy elemente:\n        - Një numër i plotë që përfaqëson numrin e numrave unik.\n        - Një listë e numrave unik të renditur në rend rritës.\n\n    Shembuj:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "hy": "\n    Մուտքային ցուցակից հեռացնել կրկնվող ամբողջ թվերը և վերադարձնել դասավորված եզակի թվերը։\n\n    Ֆունկցիան նախ մուտքային թվերի ցուցակը փոխակերպում է բազմության՝ կրկնօրինակները հեռացնելու համար,\n    ապա դասավորում է ստացված եզակի թվերի բազմությունը։ Այն վերադարձնում է տուփ, որը պարունակում է\n    եզակի թվերի քանակը և այդ եզակի թվերի ցուցակը աճման կարգով։\n\n    Պարամետրեր:\n    numbers (List[int]): Ամբողջ թվերի ցուցակ, որը կարող է պարունակել կրկնօրինակներ։\n\n    Վերադարձնում է:\n    Tuple[int, List[int]]: Տուփ երկու տարրերով:\n        - Ամբողջ թիվ, որը ներկայացնում է եզակի թվերի քանակը։\n        - Եզակի թվերի ցուցակ, դասավորված աճման կարգով։\n\n    Օրինակներ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "bn": "\n    ইনপুট তালিকা থেকে সদৃশ পূর্ণসংখ্যাগুলি সরান এবং বাছাইকৃত অনন্য সংখ্যাগুলি ফেরত দিন।\n\n    ফাংশনটি প্রথমে ইনপুট সংখ্যার তালিকাকে একটি সেটে রূপান্তর করে যাতে কোনো সদৃশ সংখ্যা না থাকে,\n    তারপর অনন্য সংখ্যাগুলির সেটকে সাজায়। এটি একটি টুপল ফেরত দেয় যা অনন্য সংখ্যাগুলির সংখ্যা এবং \n    এই অনন্য সংখ্যাগুলির একটি তালিকা ক্রমবর্ধমান ক্রমে অন্তর্ভুক্ত করে।\n\n    প্যারাম:\n    numbers (List[int]): পূর্ণসংখ্যার একটি তালিকা, যা সদৃশ সংখ্যা থাকতে পারে।\n\n    রিটার্নস:\n    Tuple[int, List[int]]: দুটি উপাদান সহ একটি টুপল:\n        - অনন্য সংখ্যাগুলির গণনা নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n        - অনন্য সংখ্যাগুলির একটি তালিকা যা ক্রমবর্ধমান ক্রমে সাজানো।\n\n    উদাহরণ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "bg": "\n    Премахнете дублиращите се цели числа от входния списък и върнете сортираните уникални числа.\n\n    Функцията първо преобразува входния списък от числа в множество, за да премахне всички дубликати,\n    след това сортира полученото множество от уникални числа. Връща кортеж, съдържащ броя\n    на уникалните числа и списък с тези уникални числа в нарастващ ред.\n\n    Аргументи:\n    numbers (List[int]): Списък от цели числа, който може да съдържа дубликати.\n\n    Връща:\n    Tuple[int, List[int]]: Кортеж с два елемента:\n        - Цяло число, представляващо броя на уникалните числа.\n        - Списък с уникалните числа, сортирани в нарастващ ред.\n\n    Примери:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "zh": "\n    从输入列表中移除重复的整数，并返回排序后的唯一数字。\n\n    该函数首先将输入的数字列表转换为集合以去除任何重复项，\n    然后对结果的唯一数字集合进行排序。它返回一个包含唯一数字计数和这些唯一数字按升序排列的列表的元组。\n\n    参数:\n    numbers (List[int]): 一个可能包含重复项的整数列表。\n\n    返回:\n    Tuple[int, List[int]]: 一个包含两个元素的元组:\n        - 一个整数，表示唯一数字的数量。\n        - 一个按升序排列的唯一数字列表。\n\n    示例:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "fr": "\n    Supprimer les entiers dupliqués de la liste d'entrée et retourner les nombres uniques triés.\n\n    La fonction convertit d'abord la liste d'entiers en un ensemble pour supprimer les doublons,\n    puis trie l'ensemble résultant de nombres uniques. Elle retourne un tuple contenant le nombre\n    de nombres uniques et une liste de ces nombres uniques dans l'ordre croissant.\n\n    Args:\n    numbers (List[int]): Une liste d'entiers, qui peut contenir des doublons.\n\n    Returns:\n    Tuple[int, List[int]]: Un tuple avec deux éléments :\n        - Un entier représentant le nombre de nombres uniques.\n        - Une liste des nombres uniques triés par ordre croissant.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "de": "\n    Entferne doppelte ganze Zahlen aus der Eingabeliste und gib die sortierten eindeutigen Zahlen zurück.\n\n    Die Funktion wandelt zuerst die Eingabeliste von Zahlen in eine Menge um, um Duplikate zu entfernen,\n    und sortiert dann die resultierende Menge eindeutiger Zahlen. Sie gibt ein Tupel zurück, das die Anzahl\n    der eindeutigen Zahlen und eine Liste dieser eindeutigen Zahlen in aufsteigender Reihenfolge enthält.\n\n    Argumente:\n    numbers (List[int]): Eine Liste von ganzen Zahlen, die Duplikate enthalten kann.\n\n    Rückgabewerte:\n    Tuple[int, List[int]]: Ein Tupel mit zwei Elementen:\n        - Eine ganze Zahl, die die Anzahl der eindeutigen Zahlen darstellt.\n        - Eine Liste der eindeutigen Zahlen, sortiert in aufsteigender Reihenfolge.\n\n    Beispiele:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "ha": "\n    Cire lambobin maimaita daga jerin shigarwa kuma mayar da lambobin daban-daban masu tsari.\n\n    Aiki yana fara da canza jerin lambobin shigarwa zuwa saitin don cire duk wani maimaitawa,\n    sannan yana tsara saitin lambobin daban-daban da aka samu. Yana mayar da wani tuple wanda ke dauke da adadin\n    lambobin daban-daban da kuma jerin wadannan lambobin daban-daban a tsari mai hawa.\n\n    Args:\n    numbers (List[int]): Jerin lambobi, wanda zai iya dauke da maimaitawa.\n\n    Returns:\n    Tuple[int, List[int]]: Tuple tare da abubuwa biyu:\n        - Wani lamba wanda ke wakiltar adadin lambobin daban-daban.\n        - Jerin lambobin daban-daban da aka tsara a tsari mai hawa.\n\n    Misalai:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "hi": "\n    इनपुट सूची से डुप्लिकेट पूर्णांकों को हटाएं और अद्वितीय संख्याओं को क्रमबद्ध करके लौटाएं।\n\n    फ़ंक्शन पहले संख्याओं की इनपुट सूची को एक सेट में बदलता है ताकि कोई भी डुप्लिकेट हट जाएं,\n    फिर अद्वितीय संख्याओं के परिणामी सेट को क्रमबद्ध करता है। यह एक ट्यूपल लौटाता है जिसमें\n    अद्वितीय संख्याओं की गिनती और इन अद्वितीय संख्याओं की एक सूची आरोही क्रम में होती है।\n\n    तर्क:\n    numbers (List[int]): पूर्णांकों की एक सूची, जिसमें डुप्लिकेट हो सकते हैं।\n\n    रिटर्न:\n    Tuple[int, List[int]]: एक ट्यूपल जिसमें दो तत्व होते हैं:\n        - एक पूर्णांक जो अद्वितीय संख्याओं की गिनती का प्रतिनिधित्व करता है।\n        - अद्वितीय संख्याओं की एक सूची जो आरोही क्रम में होती है।\n\n    उदाहरण:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "hu": "\n    Távolítsa el a duplikált egész számokat a bemeneti listából, és adja vissza a rendezett egyedi számokat.\n\n    A függvény először a bemeneti számok listáját egy halmazzá alakítja, hogy eltávolítsa az esetleges duplikátumokat,\n    majd rendezi az így kapott egyedi számok halmazát. Egy olyan tuple-t ad vissza, amely tartalmazza az egyedi számok számát\n    és ezeknek az egyedi számoknak a listáját növekvő sorrendben.\n\n    Paraméterek:\n    numbers (List[int]): Egy egész számokat tartalmazó lista, amely tartalmazhat duplikátumokat.\n\n    Visszatérési érték:\n    Tuple[int, List[int]]: Egy két elemből álló tuple:\n        - Egy egész szám, amely az egyedi számok számát jelenti.\n        - Egy lista az egyedi számokról növekvő sorrendben.\n\n    Példák:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "es": "Eliminar números enteros duplicados de la lista de entrada y devolver los números únicos ordenados.\n\nLa función primero convierte la lista de números de entrada en un conjunto para eliminar cualquier duplicado, luego ordena el conjunto resultante de números únicos. Devuelve una tupla que contiene el conteo de números únicos y una lista de estos números únicos en orden ascendente.\n\nArgumentos:\nnumbers (List[int]): Una lista de enteros, que puede contener duplicados.\n\nDevuelve:\nTuple[int, List[int]]: Una tupla con dos elementos:\n    - Un entero que representa el conteo de números únicos.\n    - Una lista de los números únicos ordenados en orden ascendente.\n\nEjemplos:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "arb": "\n    إزالة الأعداد الصحيحة المكررة من قائمة الإدخال وإرجاع الأرقام الفريدة مرتبة.\n\n    تقوم الدالة أولاً بتحويل قائمة الأرقام المدخلة إلى مجموعة لإزالة أي تكرارات،\n    ثم تقوم بترتيب مجموعة الأرقام الفريدة الناتجة. تُرجع الدالة زوجًا يحتوي على عدد\n    الأرقام الفريدة وقائمة بهذه الأرقام الفريدة مرتبة تصاعديًا.\n\n    يعيدالحجج:\n    numbers (List[int]): قائمة من الأعداد الصحيحة، والتي قد تحتوي على تكرارات.\n\n    يعيد:\n    Tuple[int, List[int]]: زوج يحتوي على عنصرين:\n        - عدد صحيح يمثل عدد الأرقام الفريدة.\n        - قائمة بالأرقام الفريدة مرتبة تصاعديًا.\n\n    امثله:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "sw": "\n    Ondoa namba rudufu kutoka kwenye orodha ya ingizo na rudisha namba za kipekee zilizopangwa.\n\n    Kazi hii kwanza inabadilisha orodha ya namba za ingizo kuwa seti ili kuondoa rudufu zozote,\n    kisha inapanga seti inayotokana ya namba za kipekee. Inarudisha jozi inayojumuisha idadi\n    ya namba za kipekee na orodha ya namba hizi za kipekee katika mpangilio wa kupanda.\n\n    Hoja:\n    numbers (List[int]): Orodha ya namba za mzima, ambayo inaweza kuwa na rudufu.\n\n    Inarejesha:\n    Tuple[int, List[int]]: Jozi yenye vipengele viwili:\n        - Namba ya mzima inayowakilisha idadi ya namba za kipekee.\n        - Orodha ya namba za kipekee zilizopangwa kwa mpangilio wa kupanda.\n\n    Mifano:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "tr": "\n    Girdi listesinden yinelenen tamsayıları kaldırın ve sıralanmış benzersiz sayıları döndürün.\n\n    Fonksiyon, önce sayılar listesini bir kümeye dönüştürerek yinelenenleri kaldırır,\n    ardından benzersiz sayıların bulunduğu kümeyi sıralar. Benzersiz sayıların sayısını içeren bir demet\n    ve bu benzersiz sayıların artan sırayla listelendiği bir liste döndürür.\n\n    Argümanlar:\n    numbers (List[int]): Yinelenenler içerebilecek bir tamsayı listesi.\n\n    Döndürür:\n    Tuple[int, List[int]]: İki öğeden oluşan bir demet:\n        - Benzersiz sayıların sayısını temsil eden bir tamsayı.\n        - Benzersiz sayıların artan sırayla sıralandığı bir liste.\n\n    Örnekler:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "vi": "Loại bỏ các số nguyên trùng lặp khỏi danh sách đầu vào và trả về các số duy nhất đã được sắp xếp.\n\nHàm này đầu tiên chuyển đổi danh sách số đầu vào thành một tập hợp để loại bỏ bất kỳ số trùng lặp nào, sau đó sắp xếp tập hợp các số duy nhất kết quả. Nó trả về một bộ chứa số lượng các số duy nhất và một danh sách các số duy nhất này theo thứ tự tăng dần.\n\nTham số:\nnumbers (List[int]): Một danh sách các số nguyên, có thể chứa các số trùng lặp.\n\nTrả về:\nTuple[int, List[int]]: Một bộ với hai phần tử:\n    - Một số nguyên đại diện cho số lượng các số duy nhất.\n    - Một danh sách các số duy nhất được sắp xếp theo thứ tự tăng dần.\n\nVí dụ:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "id": "Menghapus bilangan bulat duplikat dari daftar input dan mengembalikan angka unik yang diurutkan.\n\nFungsi ini pertama-tama mengubah daftar angka input menjadi sebuah set untuk menghapus duplikat,\nkemudian mengurutkan set dari angka unik yang dihasilkan. Fungsi ini mengembalikan sebuah tuple yang berisi jumlah\nangka unik dan daftar angka unik ini dalam urutan menaik.\n\nArgs:\nnumbers (List[int]): Daftar bilangan bulat, yang mungkin mengandung duplikat.\n\nReturns:\nTuple[int, List[int]]: Sebuah tuple dengan dua elemen:\n- Sebuah bilangan bulat yang mewakili jumlah angka unik.\n- Sebuah daftar angka unik yang diurutkan dalam urutan menaik.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])", "ja": "    入力リストから重複する整数を削除し、ソートされたユニークな数字を返します。\n\n    この関数は最初に入力された数字のリストをセットに変換して重複を削除し、\n    その後、ユニークな数字のセットをソートします。ユニークな数字の数と、\n    昇順に並べられたこれらのユニークな数字のリストを含むタプルを返します。\n\n    引数:\n    numbers (List[int]): 重複を含む可能性のある整数のリスト。\n\n    戻り値:\n    Tuple[int, List[int]]: 2つの要素を持つタプル:\n        - ユニークな数字の数を表す整数。\n        - 昇順にソートされたユニークな数字のリスト。\n\n    例:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "ko": "    입력 리스트에서 중복된 정수를 제거하고 정렬된 고유 숫자를 반환합니다.\n\n    이 함수는 먼저 입력된 숫자 리스트를 집합으로 변환하여 중복을 제거한 후,\n    고유 숫자들로 이루어진 결과 집합을 정렬합니다. 그런 다음 고유 숫자의 개수와\n    오름차순으로 정렬된 고유 숫자 리스트를 포함하는 튜플을 반환합니다.\n\n    Args:\n    numbers (List[int]): 중복이 포함될 수 있는 정수 리스트.\n\n    Returns:\n    Tuple[int, List[int]]: 두 개의 요소를 가진 튜플:\n        - 고유 숫자의 개수를 나타내는 정수.\n        - 오름차순으로 정렬된 고유 숫자 리스트.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "ml": "    ഇൻപുട്ട് ലിസ്റ്റിൽ നിന്ന് പുനരാവൃത സംഖ്യകൾ നീക്കം ചെയ്ത് ക്രമീകരിച്ച ഏകീകൃത സംഖ്യകൾ തിരികെ നൽകുക.\n\n    ഫംഗ്ഷൻ ആദ്യം സംഖ്യകളുടെ ഇൻപുട്ട് ലിസ്റ്റിനെ ഒരു സെറ്റായി മാറ്റി പുനരാവൃതികൾ നീക്കം ചെയ്യുന്നു,\n    തുടർന്ന് ക്രമീകരിച്ച ഏകീകൃത സംഖ്യകളുടെ സെറ്റ് സോർട്ട് ചെയ്യുന്നു. ഇത് ഏകീകൃത സംഖ്യകളുടെ എണ്ണം അടങ്ങിയ ഒരു ട്യൂപ്പിൾ തിരികെ നൽകുന്നു\n    കൂടാതെ ഉയർന്ന ക്രമത്തിൽ ക്രമീകരിച്ച ഈ ഏകീകൃത സംഖ്യകളുടെ ഒരു ലിസ്റ്റും.\n\n    Args:\n    numbers (List[int]): പുനരാവൃതികൾ അടങ്ങിയിരിക്കാവുന്ന ഒരു പൂർണ്ണസംഖ്യകളുടെ ലിസ്റ്റ്.\n\n    Returns:\n    Tuple[int, List[int]]: രണ്ട് ഘടകങ്ങളുള്ള ഒരു ട്യൂപ്പിൾ:\n        - ഏകീകൃത സംഖ്യകളുടെ എണ്ണത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n        - ഉയർന്ന ക്രമത്തിൽ ക്രമീകരിച്ച ഏകീകൃത സംഖ്യകളുടെ ഒരു ലിസ്റ്റ്.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])", "fa": "حذف اعداد صحیح تکراری از لیست ورودی و بازگرداندن اعداد منحصر به فرد مرتب شده.\n\nتابع ابتدا لیست ورودی اعداد را به یک مجموعه تبدیل می‌کند تا هر گونه تکرار را حذف کند، سپس مجموعه حاصل از اعداد منحصر به فرد را مرتب می‌کند. این تابع یک تاپل شامل تعداد اعداد منحصر به فرد و یک لیست از این اعداد منحصر به فرد به ترتیب صعودی را برمی‌گرداند.\n\nArgs:\nnumbers (List[int]): لیستی از اعداد صحیح که ممکن است شامل تکرار باشد.\n\nReturns:\nTuple[int, List[int]]: یک تاپل با دو عنصر:\n- یک عدد صحیح که تعداد اعداد منحصر به فرد را نشان می‌دهد.\n- یک لیست از اعداد منحصر به فرد مرتب شده به ترتیب صعودی.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])"}}
{"task_id": "Python/18", "prompt": {"en": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "sq": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit vlerën maksimale totale të rëndësisë së artikujve që mund të blihen brenda një buxheti të caktuar.\n    \n    Kjo funksion zgjidh një variant të problemit 0-1 të çantës ku secili artikull ka një çmim dhe një \n    vlerë të lidhur rëndësie. Qëllimi është të maksimizohet shuma e vlerave të rëndësisë së një \n    përzgjedhjeje të artikujve pa e tejkaluar çmimi total buxhetin.\n    \n    Argumentet:\n    n (int): Buxheti total i disponueshëm për blerjen e artikujve.\n    m (int): Numri i artikujve të ndryshëm për të zgjedhur.\n    items (List[Tuple[int, int]]): Një listë tuplesh, ku secili tuple përmban dy numra të plotë:\n        - Numri i parë përfaqëson çmimin e artikullit.\n        - Numri i dytë përfaqëson vlerën e rëndësisë së artikullit.\n    \n    Kthen:\n    int: Vlera maksimale totale e rëndësisë që mund të arrihet pa e tejkaluar buxhetin.\n    \n    Shembuj:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "hy": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվում է ապրանքների առավելագույն ընդհանուր կարևորության արժեքը, որոնք կարելի է գնել տրված բյուջեի սահմաններում։\n    \n    Այս ֆունկցիան լուծում է 0-1 պայուսակի խնդրի տարբերակ, որտեղ յուրաքանչյուր ապրանք ունի գին և \n    կապված կարևորության արժեք։ Նպատակն է առավելագույնացնել ապրանքների ընտրության կարևորության արժեքների \n    գումարը՝ առանց ընդհանուր գինը գերազանցելու բյուջեն։\n    \n    Պարամետրեր:\n    n (int): Ապրանքներ գնելու համար հասանելի ընդհանուր բյուջեն։\n    m (int): Ընտրելու համար տարբեր ապրանքների քանակը։\n    items (List[Tuple[int, int]]): Կրկնակի թվերի ցուցակ, որտեղ յուրաքանչյուր կրկնակի պարունակում է երկու ամբողջ թիվ՝\n        - Առաջին թիվը ներկայացնում է ապրանքի գինը։\n        - Երկրորդ թիվը ներկայացնում է ապրանքի կարևորության արժեքը։\n    \n    Վերադարձնում է:\n    int: Առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է ստանալ առանց բյուջեն գերազանցելու։\n    \n    Օրինակներ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "bn": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    প্রদত্ত বাজেটের মধ্যে ক্রয় করা যেতে পারে এমন আইটেমগুলির সর্বাধিক মোট গুরুত্ব মান গণনা করে।\n    \n    এই ফাংশনটি 0-1 ন্যাপকস্যাক সমস্যার একটি ভিন্ন রূপ সমাধান করে যেখানে প্রতিটি আইটেমের একটি মূল্য এবং একটি \n    সংশ্লিষ্ট গুরুত্ব মান থাকে। লক্ষ্য হল আইটেমগুলির একটি নির্বাচনের গুরুত্ব মানগুলির যোগফল সর্বাধিক করা \n    যাতে মোট মূল্য বাজেট অতিক্রম না করে।\n    \n    আর্গুমেন্টসমূহ:\n    n (int): আইটেম ক্রয়ের জন্য উপলব্ধ মোট বাজেট।\n    m (int): নির্বাচন করার জন্য বিভিন্ন আইটেমের সংখ্যা।\n    items (List[Tuple[int, int]]): একটি টাপলের তালিকা, যেখানে প্রতিটি টাপল দুটি পূর্ণসংখ্যা ধারণ করে:\n        - প্রথম পূর্ণসংখ্যাটি আইটেমের মূল্য উপস্থাপন করে।\n        - দ্বিতীয় পূর্ণসংখ্যাটি আইটেমের গুরুত্ব মান উপস্থাপন করে।\n    \n    রিটার্নস:\n    int: বাজেট অতিক্রম না করে অর্জন করা যেতে পারে এমন সর্বাধিক মোট গুরুত্ব মান।\n    \n    উদাহরণ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "bg": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислява максималната обща стойност на важност на предметите, които могат да бъдат закупени в рамките на даден бюджет.\n    \n    Тази функция решава вариант на проблема с раницата 0-1, където всеки предмет има цена и свързана стойност на важност. \n    Целта е да се максимизира сумата от стойностите на важност на избраните предмети, без общата цена да надвишава бюджета.\n    \n    Аргументи:\n    n (int): Общият бюджет, наличен за закупуване на предмети.\n    m (int): Броят на различните предмети, от които може да се избира.\n    items (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа два цели числа:\n        - Първото число представлява цената на предмета.\n        - Второто число представлява стойността на важност на предмета.\n    \n    Връща:\n    int: Максималната обща стойност на важност, която може да бъде постигната, без да се надвишава бюджета.\n    \n    Примери:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "zh": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在给定预算内可以购买的物品的最大总重要性值。\n    \n    此函数解决了0-1背包问题的一个变体，其中每个物品都有一个价格和一个相关的重要性值。\n    目标是在不超过预算的情况下，最大化所选物品的重要性值之和。\n    \n    参数:\n    n (int): 可用于购买物品的总预算。\n    m (int): 可选择的不同物品的数量。\n    items (List[Tuple[int, int]]): 一个包含元组的列表，其中每个元组包含两个整数:\n        - 第一个整数表示物品的价格。\n        - 第二个整数表示物品的重要性值。\n    \n    返回:\n    int: 在不超过预算的情况下可以达到的最大总重要性值。\n    \n    示例:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "fr": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcule la valeur totale maximale d'importance des articles qui peuvent être achetés dans un budget donné.\n    \n    Cette fonction résout une variante du problème du sac à dos 0-1 où chaque article a un prix et une \n    valeur d'importance associée. L'objectif est de maximiser la somme des valeurs d'importance d'une \n    sélection d'articles sans que le prix total ne dépasse le budget.\n    \n    Arguments:\n    n (int): Le budget total disponible pour l'achat d'articles.\n    m (int): Le nombre d'articles différents parmi lesquels choisir.\n    items (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers :\n        - Le premier entier représente le prix de l'article.\n        - Le deuxième entier représente la valeur d'importance de l'article.\n    \n    Retourne:\n    int: La valeur totale maximale d'importance qui peut être atteinte sans dépasser le budget.\n    \n    Exemples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "de": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechnet den maximalen Gesamtwert der Wichtigkeit von Gegenständen, die innerhalb eines gegebenen Budgets gekauft werden können.\n    \n    Diese Funktion löst eine Variante des 0-1-Rucksackproblems, bei dem jeder Gegenstand einen Preis und einen \n    zugehörigen Wichtigkeitswert hat. Das Ziel ist es, die Summe der Wichtigkeitswerte einer \n    Auswahl von Gegenständen zu maximieren, ohne dass der Gesamtpreis das Budget überschreitet.\n    \n    Argumente:\n    n (int): Das insgesamt verfügbare Budget zum Kauf von Gegenständen.\n    m (int): Die Anzahl der verschiedenen Gegenstände, aus denen gewählt werden kann.\n    items (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält:\n        - Die erste Zahl repräsentiert den Preis des Gegenstands.\n        - Die zweite Zahl repräsentiert den Wichtigkeitswert des Gegenstands.\n    \n    Rückgabe:\n    int: Der maximale Gesamtwert der Wichtigkeit, der erreicht werden kann, ohne das Budget zu überschreiten.\n    \n    Beispiele:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "ha": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafa mafi girman jimlar darajar muhimmanci na kayayyakin da za a iya saya cikin kasafin kudi da aka bayar.\n    \n    Wannan aikin yana warware wani nau'i na matsalar jakar 0-1 inda kowanne kaya yana da farashi da kuma \n    darajar muhimmanci mai alaka. Manufar ita ce a kara jimlar darajar muhimmanci na zaben kayayyaki \n    ba tare da jimlar farashi ya wuce kasafin kudin ba.\n    \n    Args:\n    n (int): Jimlar kasafin kudin da ake da shi don siyan kayayyaki.\n    m (int): Yawan nau'ikan kayayyaki daban-daban da za a zaba daga ciki.\n    items (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple ya ƙunshi lambobi guda biyu:\n        - Lamba ta farko tana wakiltar farashin kayan.\n        - Lamba ta biyu tana wakiltar darajar muhimmancin kayan.\n    \n    Returns:\n    int: Mafi girman jimlar darajar muhimmanci da za a iya samu ba tare da wuce kasafin kudin ba.\n    \n    Misalai:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "hi": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    दिए गए बजट के भीतर खरीदे जा सकने वाले वस्तुओं के अधिकतम कुल महत्व मान की गणना करता है।\n    \n    यह फ़ंक्शन 0-1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ प्रत्येक वस्तु की एक कीमत और एक \n    संबंधित महत्व मान होता है। लक्ष्य यह है कि वस्तुओं के चयन के महत्व मानों के योग को अधिकतम किया जाए \n    बिना कुल कीमत बजट से अधिक हुए।\n    \n    Args:\n    n (int): वस्तुएँ खरीदने के लिए उपलब्ध कुल बजट।\n    m (int): चुनने के लिए विभिन्न वस्तुओं की संख्या।\n    items (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं:\n        - पहला पूर्णांक वस्तु की कीमत को दर्शाता है।\n        - दूसरा पूर्णांक वस्तु के महत्व मान को दर्शाता है।\n    \n    Returns:\n    int: अधिकतम कुल महत्व मान जो बजट से अधिक हुए बिना प्राप्त किया जा सकता है।\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "hu": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Kiszámítja a tárgyak maximális összesített fontossági értékét, amelyeket egy adott költségvetésen belül lehet megvásárolni.\n    \n    Ez a függvény a 0-1 hátizsák probléma egy változatát oldja meg, ahol minden tárgynak van egy ára és egy \n    hozzá tartozó fontossági értéke. A cél az, hogy maximalizáljuk a kiválasztott tárgyak fontossági értékeinek \n    összegét anélkül, hogy a teljes ár meghaladná a költségvetést.\n    \n    Paraméterek:\n    n (int): A tárgyak vásárlására rendelkezésre álló teljes költségvetés.\n    m (int): A választható különböző tárgyak száma.\n    items (List[Tuple[int, int]]): Egy listája a pároknak, ahol minden pár két egész számot tartalmaz:\n        - Az első egész szám a tárgy árát jelenti.\n        - A második egész szám a tárgy fontossági értékét jelenti.\n    \n    Visszatér:\n    int: A maximális összesített fontossági érték, amely elérhető anélkül, hogy meghaladná a költségvetést.\n    \n    Példák:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "es": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcula el valor máximo total de importancia de los artículos que se pueden comprar dentro de un presupuesto dado.\n    \n    Esta función resuelve una variante del problema de la mochila 0-1 donde cada artículo tiene un precio y un \n    valor de importancia asociado. El objetivo es maximizar la suma de los valores de importancia de una \n    selección de artículos sin que el precio total exceda el presupuesto.\n    \n    Argumentos:\n    n (int): El presupuesto total disponible para la compra de artículos.\n    m (int): El número de diferentes artículos para elegir.\n    items (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros:\n        - El primer entero representa el precio del artículo.\n        - El segundo entero representa el valor de importancia del artículo.\n    \n    Devuelve:\n    int: El valor máximo total de importancia que se puede lograr sin exceder el presupuesto.\n    \n    Ejemplos:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "arb": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    يحسب أقصى قيمة إجمالية للأهمية للعناصر التي يمكن شراؤها ضمن ميزانية معينة.\n    \n    تحل هذه الدالة نوعًا من مشكلة حقيبة الظهر 0-1 حيث أن لكل عنصر سعر وقيمة أهمية مرتبطة به. \n    الهدف هو تعظيم مجموع قيم الأهمية لمجموعة مختارة من العناصر دون أن يتجاوز السعر الإجمالي الميزانية.\n    \n    يعيدالحجج:\n    n (int): إجمالي الميزانية المتاحة لشراء العناصر.\n    m (int): عدد العناصر المختلفة للاختيار من بينها.\n    items (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين:\n        - العدد الأول يمثل سعر العنصر.\n        - العدد الثاني يمثل قيمة أهمية العنصر.\n    \n    يعيد:\n    int: أقصى قيمة إجمالية للأهمية يمكن تحقيقها دون تجاوز الميزانية.\n    \n    أمثلة:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "sw": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Inahesabu thamani ya juu kabisa ya umuhimu wa jumla ya vitu ambavyo vinaweza kununuliwa ndani ya bajeti iliyotolewa.\n    \n    Kazi hii inatatua toleo la tatizo la 0-1 knapsack ambapo kila kipengee kina bei na thamani ya umuhimu inayohusishwa. \n    Lengo ni kuongeza jumla ya thamani za umuhimu wa uteuzi wa vitu bila jumla ya bei kuzidi bajeti.\n    \n    Hoja:\n    n (int): Bajeti ya jumla inayopatikana kwa ajili ya kununua vitu.\n    m (int): Idadi ya vitu tofauti vya kuchagua.\n    items (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili:\n        - Namba ya kwanza inawakilisha bei ya kipengee.\n        - Namba ya pili inawakilisha thamani ya umuhimu ya kipengee.\n    \n    Inarejesha:\n    int: Thamani ya juu kabisa ya umuhimu wa jumla inayoweza kupatikana bila kuzidi bajeti.\n    \n    Mifano:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "tr": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli bir bütçe dahilinde satın alınabilecek eşyaların maksimum toplam önem değerini hesaplar.\n    \n    Bu fonksiyon, her bir öğenin bir fiyatı ve ona bağlı bir önem değeri olduğu 0-1 sırt çantası probleminin bir varyantını çözer. \n    Amaç, toplam fiyat bütçeyi aşmadan, bir öğe seçiminin önem değerlerinin toplamını maksimize etmektir.\n    \n    Argümanlar:\n    n (int): Eşyaları satın almak için mevcut toplam bütçe.\n    m (int): Seçilebilecek farklı eşya sayısı.\n    items (List[Tuple[int, int]]): Her birinin iki tam sayı içerdiği bir demet listesi:\n        - İlk tam sayı, eşyanın fiyatını temsil eder.\n        - İkinci tam sayı, eşyanın önem değerini temsil eder.\n    \n    Döndürür:\n    int: Bütçeyi aşmadan elde edilebilecek maksimum toplam önem değeri.\n    \n    Örnekler:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "vi": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính toán giá trị tầm quan trọng tối đa của các món hàng có thể mua trong một ngân sách cho trước.\n    \n    Hàm này giải quyết một biến thể của bài toán cái túi 0-1, trong đó mỗi món hàng có một giá và \n    một giá trị tầm quan trọng liên quan. Mục tiêu là tối đa hóa tổng giá trị tầm quan trọng của một \n    tập hợp các món hàng mà không để tổng giá vượt quá ngân sách.\n    \n    Tham số:\n    n (int): Tổng ngân sách có sẵn để mua các món hàng.\n    m (int): Số lượng món hàng khác nhau để lựa chọn.\n    items (List[Tuple[int, int]]): Một danh sách các bộ đôi, trong đó mỗi bộ đôi chứa hai số nguyên:\n        - Số nguyên đầu tiên đại diện cho giá của món hàng.\n        - Số nguyên thứ hai đại diện cho giá trị tầm quan trọng của món hàng.\n    \n    Trả về:\n    int: Giá trị tầm quan trọng tối đa có thể đạt được mà không vượt quá ngân sách.\n    \n    Ví dụ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "id": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Menghitung nilai total kepentingan maksimum dari barang-barang yang dapat dibeli dalam anggaran yang diberikan.\n    \n    Fungsi ini menyelesaikan varian dari masalah knapsack 0-1 di mana setiap barang memiliki harga dan \n    nilai kepentingan terkait. Tujuannya adalah untuk memaksimalkan jumlah nilai kepentingan dari \n    pilihan barang tanpa total harga melebihi anggaran.\n    \n    Argumen:\n    n (int): Total anggaran yang tersedia untuk membeli barang.\n    m (int): Jumlah barang berbeda yang dapat dipilih.\n    items (List[Tuple[int, int]]): Daftar tuple, di mana setiap tuple berisi dua bilangan bulat:\n        - Bilangan bulat pertama mewakili harga barang.\n        - Bilangan bulat kedua mewakili nilai kepentingan barang.\n    \n    Mengembalikan:\n    int: Nilai total kepentingan maksimum yang dapat dicapai tanpa melebihi anggaran.\n    \n    Contoh:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "ja": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    与えられた予算内で購入できるアイテムの最大の総重要度を計算します。\n    \n    この関数は、各アイテムに価格と関連する重要度がある0-1ナップサック問題の変種を解きます。 \n    目標は、予算を超えないようにアイテムの選択の重要度の合計を最大化することです。\n    \n    引数:\n    n (int): アイテムを購入するために利用可能な総予算。\n    m (int): 選択できる異なるアイテムの数。\n    items (List[Tuple[int, int]]): 各タプルが2つの整数を含むタプルのリスト:\n        - 最初の整数はアイテムの価格を表します。\n        - 2番目の整数はアイテムの重要度を表します。\n    \n    戻り値:\n    int: 予算を超えずに達成できる最大の総重要度。\n    \n    例:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "ko": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    주어진 예산 내에서 구매할 수 있는 항목들의 최대 총 중요도 값을 계산합니다.\n    \n    이 함수는 각 항목이 가격과 관련된 중요도 값을 가지는 0-1 배낭 문제의 변형을 해결합니다. 목표는 \n    총 가격이 예산을 초과하지 않으면서 항목들의 중요도 값의 합을 최대화하는 것입니다.\n    \n    인수:\n    n (int): 항목 구매를 위한 총 예산.\n    m (int): 선택할 수 있는 다양한 항목의 수.\n    items (List[Tuple[int, int]]): 각 튜플이 두 개의 정수를 포함하는 튜플의 리스트:\n        - 첫 번째 정수는 항목의 가격을 나타냅니다.\n        - 두 번째 정수는 항목의 중요도 값을 나타냅니다.\n    \n    반환:\n    int: 예산을 초과하지 않으면서 달성할 수 있는 최대 총 중요도 값.\n    \n    예제:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "ml": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    നൽകിയ ബജറ്റിനുള്ളിൽ വാങ്ങാൻ കഴിയുന്ന വസ്തുക്കളുടെ പരമാവധി ആകെ പ്രാധാന്യ മൂല്യം കണക്കാക്കുന്നു.\n    \n    ഓരോ വസ്തുവിനും വിലയും ബന്ധപ്പെട്ട പ്രാധാന്യ മൂല്യവും ഉള്ള 0-1 ക്നാപ്സാക്ക് പ്രശ്നത്തിന്റെ ഒരു വ്യത്യാസം ഈ ഫങ്ഷൻ പരിഹരിക്കുന്നു. \n    ബജറ്റ് കവിയാതെ വസ്തുക്കളുടെ ഒരു തിരഞ്ഞെടുപ്പിന്റെ പ്രാധാന്യ മൂല്യങ്ങളുടെ തുക പരമാവധി ആക്കുക എന്നതാണ് ലക്ഷ്യം.\n    \n    Args:\n    n (int): വസ്തുക്കൾ വാങ്ങുന്നതിനുള്ള മൊത്തം ബജറ്റ്.\n    m (int): തിരഞ്ഞെടുക്കാൻ കഴിയുന്ന വ്യത്യസ്ത വസ്തുക്കളുടെ എണ്ണം.\n    items (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും രണ്ട് പൂർണ്ണസംഖ്യകൾ അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക:\n        - ആദ്യ പൂർണ്ണസംഖ്യ വസ്തുവിന്റെ വിലയെ പ്രതിനിധീകരിക്കുന്നു.\n        - രണ്ടാം പൂർണ്ണസംഖ്യ വസ്തുവിന്റെ പ്രാധാന്യ മൂല്യത്തെ പ്രതിനിധീകരിക്കുന്നു.\n    \n    Returns:\n    int: ബജറ്റ് കവിയാതെ നേടാൻ കഴിയുന്ന പരമാവധി ആകെ പ്രാധാന്യ മൂല്യം.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"", "fa": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    حداکثر مقدار اهمیت کل اقلامی که می‌توان در یک بودجه معین خریداری کرد را محاسبه می‌کند.\n    \n    این تابع یک نوع از مسئله کوله‌پشتی 0-1 را حل می‌کند که در آن هر آیتم دارای یک قیمت و یک \n    مقدار اهمیت مرتبط است. هدف این است که مجموع مقادیر اهمیت انتخابی از اقلام را حداکثر کنیم \n    بدون اینکه قیمت کل از بودجه تجاوز کند.\n    \n    آرگومان‌ها:\n    n (int): بودجه کل موجود برای خرید اقلام.\n    m (int): تعداد اقلام مختلف برای انتخاب.\n    items (List[Tuple[int, int]]): لیستی از جفت‌ها، که هر جفت شامل دو عدد صحیح است:\n        - عدد اول نشان‌دهنده قیمت آیتم است.\n        - عدد دوم نشان‌دهنده مقدار اهمیت آیتم است.\n    \n    بازگشت:\n    int: حداکثر مقدار اهمیت کل که می‌توان بدون تجاوز از بودجه به دست آورد.\n    \n    مثال‌ها:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\""}, "canonical_solution": "# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]", "instruction": {"en": "Write a python function 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' to solve the following problem:\n\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    ", "sq": "Shkruani një funksion python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit vlerën maksimale totale të rëndësisë së artikujve që mund të blihen brenda një buxheti të caktuar.\n    \n    Kjo funksion zgjidh një variant të problemit të çantës 0-1 ku çdo artikull ka një çmim dhe një \n    vlerë të rëndësisë së lidhur. Qëllimi është të maksimizohet shuma e vlerave të rëndësisë së një \n    përzgjedhjeje të artikujve pa e tejkaluar çmimin total buxhetin.\n    \n    Args:\n    n (int): Buxheti total i disponueshëm për blerjen e artikujve.\n    m (int): Numri i artikujve të ndryshëm për të zgjedhur.\n    items (List[Tuple[int, int]]): Një listë e tufa, ku çdo tufë përmban dy numra të plotë:\n        - Numri i parë përfaqëson çmimin e artikullit.\n        - Numri i dytë përfaqëson vlerën e rëndësisë së artikullit.\n    \n    Returns:\n    int: Vlera maksimale totale e rëndësisë që mund të arrihet pa e tejkaluar buxhetin.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "hy": "Պայթոն ֆունկցիա 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվում է իրերի առավելագույն ընդհանուր կարևորության արժեքը, որոնք կարելի է գնել տրված բյուջեի սահմաններում:\n    \n    Այս ֆունկցիան լուծում է 0-1 ուսապարկի խնդրի մի տարբերակ, որտեղ յուրաքանչյուր իր ունի գին և \n    համապատասխան կարևորության արժեք: Նպատակն է առավելագույնացնել իրերի ընտրության \n    կարևորության արժեքների գումարը՝ առանց ընդհանուր գինը գերազանցելու բյուջեն:\n    \n    Արձ:\n    n (int): Ընդհանուր բյուջեն, որը հասանելի է իրեր գնելու համար:\n    m (int): Ընտրելու համար տարբեր իրերի քանակը:\n    items (List[Tuple[int, int]]): Կրկնորդների ցուցակ, որտեղ յուրաքանչյուր կրկնորդ պարունակում է երկու ամբողջ թիվ:\n        - Առաջին ամբողջ թիվը ներկայացնում է իրի գինը:\n        - Երկրորդ ամբողջ թիվը ներկայացնում է իրի կարևորության արժեքը:\n    \n    Վերադարձնում է:\n    int: Առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է հասնել առանց բյուջեն գերազանցելու:\n    \n    Օրինակներ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "bn": "একটি পাইথন ফাংশন 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত বাজেটের মধ্যে কেনা যেতে পারে এমন আইটেমগুলির সর্বাধিক মোট গুরুত্ব মান গণনা করে।\n    \n    এই ফাংশনটি 0-1 ন্যাপকস্যাক সমস্যার একটি প্রকরণ সমাধান করে যেখানে প্রতিটি আইটেমের একটি মূল্য এবং একটি \n    সংশ্লিষ্ট গুরুত্ব মান থাকে। লক্ষ্য হল আইটেমগুলির একটি নির্বাচনের গুরুত্ব মানগুলির যোগফল সর্বাধিক করা \n    যাতে মোট মূল্য বাজেট অতিক্রম না করে।\n    \n    আর্গুমেন্টস:\n    n (int): আইটেম কেনার জন্য উপলব্ধ মোট বাজেট।\n    m (int): নির্বাচন করার জন্য বিভিন্ন আইটেমের সংখ্যা।\n    items (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে:\n        - প্রথম পূর্ণসংখ্যাটি আইটেমের মূল্য নির্দেশ করে।\n        - দ্বিতীয় পূর্ণসংখ্যাটি আইটেমের গুরুত্ব মান নির্দেশ করে।\n    \n    রিটার্নস:\n    int: সর্বাধিক মোট গুরুত্ব মান যা বাজেট অতিক্রম না করে অর্জন করা যেতে পারে।\n    \n    উদাহরণ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "bg": "Напишете функция на Python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:', за да решите следния проблем:\n\n    Изчислява максималната обща стойност на важност на предметите, които могат да бъдат закупени в рамките на даден бюджет.\n    \n    Тази функция решава вариант на проблема с раницата (0-1 knapsack problem), където всеки предмет има цена и \n    свързана стойност на важност. Целта е да се максимизира сумата от стойностите на важност на \n    избрани предмети, без общата цена да надвишава бюджета.\n    \n    Аргументи:\n    n (int): Общият бюджет, наличен за закупуване на предмети.\n    m (int): Броят на различните предмети, от които да се избира.\n    items (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа два цели числа:\n        - Първото цяло число представлява цената на предмета.\n        - Второто цяло число представлява стойността на важност на предмета.\n    \n    Връща:\n    int: Максималната обща стойност на важност, която може да бъде постигната, без да се надвишава бюджетът.\n    \n    Примери:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "zh": "编写一个 Python 函数 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' 来解决以下问题：\n\n    计算在给定预算内可以购买的物品的最大总重要性值。\n    \n    此函数解决了 0-1 背包问题的一个变体，其中每个物品都有一个价格和一个相关的重要性值。目标是最大化所选物品的重要性值之和，而总价格不超过预算。\n    \n    参数：\n    n (int): 可用于购买物品的总预算。\n    m (int): 可选择的不同物品的数量。\n    items (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数：\n        - 第一个整数表示物品的价格。\n        - 第二个整数表示物品的重要性值。\n    \n    返回：\n    int: 在不超过预算的情况下可以实现的最大总重要性值。\n    \n    示例：\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "fr": "Écrivez une fonction python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' pour résoudre le problème suivant :\n\n    Calcule la valeur totale maximale d'importance des articles qui peuvent être achetés dans un budget donné.\n    \n    Cette fonction résout une variante du problème du sac à dos 0-1 où chaque article a un prix et une \n    valeur d'importance associée. L'objectif est de maximiser la somme des valeurs d'importance d'une \n    sélection d'articles sans que le prix total ne dépasse le budget.\n    \n    Args:\n    n (int): Le budget total disponible pour l'achat d'articles.\n    m (int): Le nombre d'articles différents parmi lesquels choisir.\n    items (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers :\n        - Le premier entier représente le prix de l'article.\n        - Le deuxième entier représente la valeur d'importance de l'article.\n    \n    Returns:\n    int: La valeur totale maximale d'importance qui peut être atteinte sans dépasser le budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "de": "Schreiben Sie eine Python-Funktion 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnet den maximalen Gesamtwert der Wichtigkeit von Gegenständen, die innerhalb eines gegebenen Budgets gekauft werden können.\n    \n    Diese Funktion löst eine Variante des 0-1-Rucksackproblems, bei dem jeder Gegenstand einen Preis und einen \n    zugehörigen Wichtigkeitswert hat. Das Ziel ist es, die Summe der Wichtigkeitswerte einer \n    Auswahl von Gegenständen zu maximieren, ohne dass der Gesamtpreis das Budget überschreitet.\n    \n    Argumente:\n    n (int): Das gesamte verfügbare Budget für den Kauf von Gegenständen.\n    m (int): Die Anzahl der verschiedenen Gegenstände, aus denen gewählt werden kann.\n    items (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält:\n        - Die erste ganze Zahl repräsentiert den Preis des Gegenstands.\n        - Die zweite ganze Zahl repräsentiert den Wichtigkeitswert des Gegenstands.\n    \n    Rückgabewert:\n    int: Der maximale Gesamtwert der Wichtigkeit, der erreicht werden kann, ohne das Budget zu überschreiten.\n    \n    Beispiele:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "ha": "Rubuta wani aikin python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa mafi girman jimillar darajar muhimmanci na abubuwan da za a iya saya a cikin kasafin kuɗi da aka bayar.\n    \n    Wannan aikin yana warware wani bambancin matsalar 0-1 knapsack inda kowanne abu yana da farashi da \n    darajar muhimmanci da aka haɗa. Manufar ita ce a ƙara yawan jimlar darajar muhimmanci na \n    zaɓin abubuwa ba tare da jimillar farashi ta wuce kasafin kuɗi ba.\n    \n    Args:\n    n (int): Jimillar kasafin kuɗi da ake da shi don sayen abubuwa.\n    m (int): Yawan abubuwa daban-daban da za a zaɓa daga.\n    items (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple ya ƙunshi lambobi guda biyu:\n        - Lamba ta farko tana wakiltar farashin abu.\n        - Lamba ta biyu tana wakiltar darajar muhimmancin abu.\n    \n    Returns:\n    int: Mafi girman jimillar darajar muhimmanci da za a iya samu ba tare da wuce kasafin kuɗi ba.\n    \n    Misalai:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "hi": "एक पायथन फ़ंक्शन 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    उन वस्तुओं के अधिकतम कुल महत्व मान की गणना करें जिन्हें दिए गए बजट के भीतर खरीदा जा सकता है।\n    \n    यह फ़ंक्शन 0-1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ प्रत्येक वस्तु की एक कीमत और \n    एक संबंधित महत्व मान होता है। उद्देश्य यह है कि वस्तुओं के चयन के महत्व मानों के योग को \n    अधिकतम किया जाए बिना कुल कीमत बजट से अधिक हुए।\n    \n    तर्क:\n    n (int): वस्तुएं खरीदने के लिए उपलब्ध कुल बजट।\n    m (int): चुनने के लिए विभिन्न वस्तुओं की संख्या।\n    items (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं:\n        - पहला पूर्णांक वस्तु की कीमत को दर्शाता है।\n        - दूसरा पूर्णांक वस्तु के महत्व मान को दर्शाता है।\n    \n    लौटाता है:\n    int: अधिकतम कुल महत्व मान जो बजट से अधिक हुए बिना प्राप्त किया जा सकता है।\n    \n    उदाहरण:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "hu": "Írj egy python függvényt 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' a következő probléma megoldására:\n\n    Kiszámítja a tárgyak maximális összfontossági értékét, amelyeket egy adott költségvetésen belül lehet megvásárolni.\n    \n    Ez a függvény megoldja a 0-1 hátizsák probléma egy változatát, ahol minden tárgynak van egy ára és egy \n    hozzá tartozó fontossági értéke. A cél az, hogy maximalizáljuk a tárgyak kiválasztásának fontossági értékeinek \n    összegét anélkül, hogy a teljes ár meghaladná a költségvetést.\n    \n    Paraméterek:\n    n (int): Az összes rendelkezésre álló költségvetés a tárgyak megvásárlásához.\n    m (int): A választható különböző tárgyak száma.\n    items (List[Tuple[int, int]]): Egy tuple-ök listája, ahol minden tuple két egész számot tartalmaz:\n        - Az első egész szám a tárgy árát jelenti.\n        - A második egész szám a tárgy fontossági értékét jelenti.\n    \n    Visszatér:\n    int: A maximális összfontossági érték, amely elérhető anélkül, hogy meghaladná a költségvetést.\n    \n    Példák:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "es": "Escribe una función de Python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' para resolver el siguiente problema:\n\nCalcula el valor máximo total de importancia de los artículos que se pueden comprar dentro de un presupuesto dado.\n\nEsta función resuelve una variante del problema de la mochila 0-1 donde cada artículo tiene un precio y un valor de importancia asociado. El objetivo es maximizar la suma de los valores de importancia de una selección de artículos sin que el precio total exceda el presupuesto.\n\nArgumentos:\nn (int): El presupuesto total disponible para la compra de artículos.\nm (int): El número de diferentes artículos para elegir.\nitems (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros:\n- El primer entero representa el precio del artículo.\n- El segundo entero representa el valor de importancia del artículo.\n\nDevuelve:\nint: El valor máximo total de importancia que se puede lograr sin exceder el presupuesto.\n\nEjemplos:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80", "arb": "اكتب دالة بايثون 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' لحل المشكلة التالية:\n\n    تحسب القيمة القصوى لأهمية العناصر التي يمكن شراؤها ضمن ميزانية معينة.\n    \n    تحل هذه الدالة نوعًا من مشكلة الحقيبة 0-1 حيث أن لكل عنصر سعر وقيمة أهمية مرتبطة به. الهدف هو تعظيم مجموع قيم الأهمية لمجموعة من العناصر دون أن يتجاوز السعر الإجمالي الميزانية.\n    \n    يعيدالحجج:\n    n (int): الميزانية الكلية المتاحة لشراء العناصر.\n    m (int): عدد العناصر المختلفة للاختيار من بينها.\n    items (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين:\n        - العدد الأول يمثل سعر العنصر.\n        - العدد الثاني يمثل قيمة أهمية العنصر.\n    \n    Returns:\n    int: القيمة القصوى الإجمالية للأهمية التي يمكن تحقيقها دون تجاوز الميزانية.\n    \n    أمثلة:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "sw": "Andika kazi ya python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' kutatua tatizo lifuatalo:\n\n    Inahesabu thamani ya juu kabisa ya umuhimu wa vitu vinavyoweza kununuliwa ndani ya bajeti iliyotolewa.\n    \n    Kazi hii inatatua toleo la tatizo la 0-1 knapsack ambapo kila kipengee kina bei na thamani ya \n    umuhimu inayohusiana. Lengo ni kuongeza jumla ya thamani za umuhimu wa uteuzi wa vitu bila jumla ya bei \n    kuzidi bajeti.\n    \n    Hoja:\n    n (int): Bajeti jumla inayopatikana kwa ununuzi wa vitu.\n    m (int): Idadi ya vitu tofauti vya kuchagua.\n    items (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili:\n        - Namba ya kwanza inawakilisha bei ya kipengee.\n        - Namba ya pili inawakilisha thamani ya umuhimu wa kipengee.\n    \n    Inarejesha:\n    int: Thamani ya juu kabisa ya umuhimu inayoweza kupatikana bila kuzidi bajeti.\n    \n    Mifano:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "tr": "Bir python fonksiyonu 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen bir bütçe dahilinde satın alınabilecek eşyaların maksimum toplam önem değerini hesaplar.\n    \n    Bu fonksiyon, her bir eşyanın bir fiyatı ve ilişkili bir önem değeri olduğu 0-1 sırt çantası probleminin bir varyantını çözer. Amaç, toplam fiyat bütçeyi aşmadan eşyaların önem değerlerinin toplamını maksimize etmektir.\n    \n    Argümanlar:\n    n (int): Eşyaları satın almak için mevcut toplam bütçe.\n    m (int): Seçilecek farklı eşya sayısı.\n    items (List[Tuple[int, int]]): Her bir demetin iki tam sayı içerdiği demetlerin listesi:\n        - İlk tam sayı, eşyanın fiyatını temsil eder.\n        - İkinci tam sayı, eşyanın önem değerini temsil eder.\n    \n    Döndürür:\n    int: Bütçeyi aşmadan elde edilebilecek maksimum toplam önem değeri.\n    \n    Örnekler:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "vi": "Viết một hàm python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán tổng giá trị quan trọng tối đa của các mặt hàng có thể mua trong một ngân sách cho trước.\n    \n    Hàm này giải quyết một biến thể của bài toán cái túi 0-1, trong đó mỗi mặt hàng có một giá và một \n    giá trị quan trọng liên quan. Mục tiêu là tối đa hóa tổng giá trị quan trọng của một \n    lựa chọn các mặt hàng mà không để tổng giá vượt quá ngân sách.\n    \n    Tham số:\n    n (int): Tổng ngân sách có sẵn để mua hàng.\n    m (int): Số lượng các mặt hàng khác nhau để lựa chọn.\n    items (List[Tuple[int, int]]): Một danh sách các bộ đôi, trong đó mỗi bộ đôi chứa hai số nguyên:\n        - Số nguyên đầu tiên đại diện cho giá của mặt hàng.\n        - Số nguyên thứ hai đại diện cho giá trị quan trọng của mặt hàng.\n    \n    Trả về:\n    int: Tổng giá trị quan trọng tối đa có thể đạt được mà không vượt quá ngân sách.\n    \n    Ví dụ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "id": "Tulis fungsi python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' untuk menyelesaikan masalah berikut:\n\n    Menghitung nilai total kepentingan maksimum dari barang-barang yang dapat dibeli dalam anggaran yang diberikan.\n    \n    Fungsi ini menyelesaikan varian dari masalah knapsack 0-1 di mana setiap barang memiliki harga dan \n    nilai kepentingan yang terkait. Tujuannya adalah untuk memaksimalkan jumlah nilai kepentingan dari \n    pilihan barang-barang tanpa melebihi total harga dari anggaran.\n    \n    Argumen:\n    n (int): Total anggaran yang tersedia untuk membeli barang.\n    m (int): Jumlah barang berbeda yang dapat dipilih.\n    items (List[Tuple[int, int]]): Daftar tuple, di mana setiap tuple berisi dua bilangan bulat:\n        - Bilangan bulat pertama mewakili harga barang.\n        - Bilangan bulat kedua mewakili nilai kepentingan barang.\n    \n    Mengembalikan:\n    int: Nilai total kepentingan maksimum yang dapat dicapai tanpa melebihi anggaran.\n    \n    Contoh:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "ja": "以下の問題を解決するためにPython関数 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' を作成してください:\n\n    与えられた予算内で購入できるアイテムの最大合計重要度値を計算します。\n    \n    この関数は、各アイテムに価格と関連する重要度値がある0-1ナップサック問題の変種を解決します。目標は、合計価格が予算を超えないようにアイテムの重要度値の合計を最大化することです。\n    \n    引数:\n    n (int): アイテム購入のために利用可能な総予算。\n    m (int): 選択可能な異なるアイテムの数。\n    items (List[Tuple[int, int]]): 各タプルが2つの整数を含むタプルのリスト:\n        - 最初の整数はアイテムの価格を表します。\n        - 2番目の整数はアイテムの重要度値を表します。\n    \n    戻り値:\n    int: 予算を超えずに達成できる最大合計重要度値。\n    \n    例:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "ko": "파이썬 함수를 작성하세요 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' 다음 문제를 해결하기 위해:\n\n    주어진 예산 내에서 구매할 수 있는 아이템의 최대 총 중요도 값을 계산합니다.\n    \n    이 함수는 각 아이템이 가격과 관련된 중요도 값을 가지는 0-1 배낭 문제의 변형을 해결합니다. 목표는 \n    총 가격이 예산을 초과하지 않으면서 선택한 아이템들의 중요도 값의 합을 최대화하는 것입니다.\n    \n    매개변수:\n    n (int): 아이템 구매를 위한 총 예산.\n    m (int): 선택할 수 있는 서로 다른 아이템의 수.\n    items (List[Tuple[int, int]]): 각 튜플이 두 개의 정수를 포함하는 튜플의 리스트:\n        - 첫 번째 정수는 아이템의 가격을 나타냅니다.\n        - 두 번째 정수는 아이템의 중요도 값을 나타냅니다.\n    \n    반환값:\n    int: 예산을 초과하지 않고 달성할 수 있는 최대 총 중요도 값.\n    \n    예제:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "ml": "'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    നൽകിയിരിക്കുന്ന ബജറ്റിനുള്ളിൽ വാങ്ങാൻ കഴിയുന്ന വസ്തുക്കളുടെ പരമാവധി ആകെ പ്രാധാന്യ മൂല്യം കണക്കാക്കുന്നു.\n    \n    ഓരോ വസ്തുവിനും ഒരു വിലയും ബന്ധപ്പെട്ട പ്രാധാന്യ മൂല്യവും ഉള്ള 0-1 ബാഗ് പ്രശ്നത്തിന്റെ ഒരു വ്യത്യസ്തത ഈ ഫംഗ്ഷൻ പരിഹരിക്കുന്നു. \n    മൊത്തം വില ബജറ്റിനെ മിക്കാതെ വസ്തുക്കളുടെ ഒരു തിരഞ്ഞെടുപ്പിന്റെ പ്രാധാന്യ മൂല്യങ്ങളുടെ മൊത്തം തുക പരമാവധി ആക്കുകയാണ് ലക്ഷ്യം.\n    \n    Args:\n    n (int): വസ്തുക്കൾ വാങ്ങുന്നതിനുള്ള മൊത്തം ലഭ്യമായ ബജറ്റ്.\n    m (int): തിരഞ്ഞെടുക്കാൻ കഴിയുന്ന വ്യത്യസ്ത വസ്തുക്കളുടെ എണ്ണം.\n    items (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും രണ്ട് പൂർണ്ണസംഖ്യകൾ അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക:\n        - ആദ്യ പൂർണ്ണസംഖ്യ വസ്തുവിന്റെ വിലയെ പ്രതിനിധീകരിക്കുന്നു.\n        - രണ്ടാം പൂർണ്ണസംഖ്യ വസ്തുവിന്റെ പ്രാധാന്യ മൂല്യത്തെ പ്രതിനിധീകരിക്കുന്നു.\n    \n    Returns:\n    int: ബജറ്റ് മിക്കാതെ കൈവരിക്കാവുന്ന പരമാവധി ആകെ പ്രാധാന്യ മൂല്യം.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "fa": "یک تابع پایتون 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' بنویسید تا مسئله زیر را حل کند:\n\n    حداکثر مقدار کل اهمیت آیتم‌هایی که می‌توان با بودجه معین خریداری کرد را محاسبه می‌کند.\n    \n    این تابع یک نوع از مسئله کوله‌پشتی 0-1 را حل می‌کند که در آن هر آیتم دارای قیمتی و \n    یک مقدار اهمیت مرتبط است. هدف این است که مجموع مقادیر اهمیت آیتم‌های انتخاب شده را \n    بدون اینکه قیمت کل از بودجه فراتر رود، به حداکثر برسانیم.\n    \n    آرگومان‌ها:\n    n (int): کل بودجه موجود برای خرید آیتم‌ها.\n    m (int): تعداد آیتم‌های مختلف برای انتخاب.\n    items (List[Tuple[int, int]]): لیستی از زوج‌ها، که هر زوج شامل دو عدد صحیح است:\n        - عدد صحیح اول قیمت آیتم را نشان می‌دهد.\n        - عدد صحیح دوم مقدار اهمیت آیتم را نشان می‌دهد.\n    \n    بازگشت:\n    int: حداکثر مقدار کل اهمیت که می‌تواند بدون تجاوز از بودجه به دست آید.\n    \n    مثال‌ها:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80"}, "level": "easy", "test": "def test_max_happiness():\n    # Test case 1: Sample provided in the problem\n    assert max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)]) == 3900, \"Test case 1 failed\"\n\n    # Test case 2: Small budget with one item\n    assert max_happiness(50, 1, [(60, 3)]) == 0, \"Test case 2 failed\"\n\n    # Test case 4: Exact budget\n    assert max_happiness(100, 2, [(50, 2), (50, 3)]) == 250, \"Test case 4 failed\"\n\n    # Test case 5: No items\n    assert max_happiness(100, 0, []) == 0, \"Test case 5 failed\"\n\n    # Test case 6: All items exceed the budget\n    assert max_happiness(10, 3, [(20, 1), (30, 2), (40, 3)]) == 0, \"Test case 6 failed\"\n\n    # Test case 7: Multiple items with the same price and importance\n    assert max_happiness(100, 4, [(25, 2), (25, 2), (25, 2), (25, 2)]) == 200, \"Test case 7 failed\"\n\n    # Test case 8: Large number of items\n    assert max_happiness(1000, 10, [(100, i) for i in range(1, 11)]) == 5500, \"Test case 8 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_max_happiness()", "entry_point": "max_happiness", "signature": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:", "docstring": {"en": "\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    ", "sq": "\n    Llogarit vlerën maksimale totale të rëndësisë së artikujve që mund të blihen brenda një buxheti të caktuar.\n    \n    Kjo funksion zgjidh një variant të problemit 0-1 të çantës ku secili artikull ka një çmim dhe një \n    vlerë të lidhur rëndësie. Qëllimi është të maksimizohet shuma e vlerave të rëndësisë së një \n    përzgjedhjeje të artikujve pa e tejkaluar çmimi total buxhetin.\n    \n    Argumentet:\n    n (int): Buxheti total i disponueshëm për blerjen e artikujve.\n    m (int): Numri i artikujve të ndryshëm për të zgjedhur.\n    items (List[Tuple[int, int]]): Një listë e tufeve, ku secila tufë përmban dy numra të plotë:\n        - Numri i parë përfaqëson çmimin e artikullit.\n        - Numri i dytë përfaqëson vlerën e rëndësisë së artikullit.\n    \n    Kthen:\n    int: Vlera maksimale totale e rëndësisë që mund të arrihet pa e tejkaluar buxhetin.\n    \n    Shembuj:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "hy": "\n    Հաշվարկում է ապրանքների առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է գնել տրված բյուջեի սահմաններում։\n    \n    Այս ֆունկցիան լուծում է 0-1 դարակաշարային խնդրի մի տարբերակ, որտեղ յուրաքանչյուր ապրանք ունի գին և \n    կապված կարևորության արժեք։ Նպատակն է առավելագույնացնել ապրանքների ընտրության կարևորության արժեքների \n    գումարը՝ առանց ընդհանուր գինը գերազանցելու բյուջեն։\n    \n    Արձանագրություններ:\n    n (int): Ապրանքներ գնելու համար հասանելի ընդհանուր բյուջեն։\n    m (int): Ընտրելու համար տարբեր ապրանքների քանակը։\n    items (List[Tuple[int, int]]): Կրկնակի թվերի ցուցակ, որտեղ յուրաքանչյուր կրկնակի թիվ պարունակում է երկու ամբողջ թիվ՝\n        - Առաջին ամբողջ թիվը ներկայացնում է ապրանքի գինը։\n        - Երկրորդ ամբողջ թիվը ներկայացնում է ապրանքի կարևորության արժեքը։\n    \n    Վերադարձնում է:\n    int: Առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է ստանալ առանց բյուջեն գերազանցելու։\n    \n    Օրինակներ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "bn": "\n    প্রদত্ত বাজেটের মধ্যে কেনা যেতে পারে এমন আইটেমগুলির সর্বাধিক মোট গুরুত্ব মান গণনা করে।\n    \n    এই ফাংশনটি 0-1 ন্যাপকস্যাক সমস্যার একটি প্রকরণ সমাধান করে যেখানে প্রতিটি আইটেমের একটি মূল্য এবং একটি \n    সংশ্লিষ্ট গুরুত্ব মান থাকে। লক্ষ্য হল এমন আইটেমগুলির একটি নির্বাচন থেকে গুরুত্ব মানগুলির যোগফল সর্বাধিক করা \n    যাতে মোট মূল্য বাজেট অতিক্রম না করে।\n    \n    Args:\n    n (int): আইটেম কেনার জন্য উপলব্ধ মোট বাজেট।\n    m (int): নির্বাচন করার জন্য বিভিন্ন আইটেমের সংখ্যা।\n    items (List[Tuple[int, int]]): টুপলের একটি তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে:\n        - প্রথম পূর্ণসংখ্যাটি আইটেমের মূল্য উপস্থাপন করে।\n        - দ্বিতীয় পূর্ণসংখ্যাটি আইটেমের গুরুত্ব মান উপস্থাপন করে।\n    \n    Returns:\n    int: বাজেট অতিক্রম না করে অর্জন করা যেতে পারে এমন সর্বাধিক মোট গুরুত্ব মান।\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "bg": "\n    Изчислява максималната обща стойност на важността на предметите, които могат да бъдат закупени в рамките на даден бюджет.\n    \n    Тази функция решава вариант на проблема с раницата (0-1 knapsack problem), където всеки предмет има цена и свързана с нея стойност на важността. Целта е да се максимизира сумата от стойностите на важността на избраните предмети, без общата цена да надвишава бюджета.\n    \n    Параметри:\n    n (int): Общият бюджет, наличен за закупуване на предмети.\n    m (int): Броят на различните предмети, от които може да се избира.\n    items (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа два цели числа:\n        - Първото число представлява цената на предмета.\n        - Второто число представлява стойността на важността на предмета.\n    \n    Връща:\n    int: Максималната обща стойност на важността, която може да бъде постигната, без да се надвишава бюджета.\n    \n    Примери:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "zh": "\n    计算在给定预算内可以购买的物品的最大总重要性值。\n    \n    该函数解决了0-1背包问题的一个变体，其中每个物品都有一个价格和一个相关的重要性值。\n    目标是在不超过预算的情况下，最大化所选物品的重要性值之和。\n    \n    参数:\n    n (int): 可用于购买物品的总预算。\n    m (int): 可供选择的不同物品的数量。\n    items (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数:\n        - 第一个整数表示物品的价格。\n        - 第二个整数表示物品的重要性值。\n    \n    返回:\n    int: 在不超过预算的情况下可以达到的最大总重要性值。\n    \n    示例:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "fr": "\n    Calcule la valeur d'importance totale maximale des articles pouvant être achetés dans un budget donné.\n    \n    Cette fonction résout une variante du problème du sac à dos 0-1 où chaque article a un prix et une \n    valeur d'importance associée. L'objectif est de maximiser la somme des valeurs d'importance d'une \n    sélection d'articles sans que le prix total ne dépasse le budget.\n    \n    Arguments:\n    n (int): Le budget total disponible pour l'achat d'articles.\n    m (int): Le nombre d'articles différents parmi lesquels choisir.\n    items (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers :\n        - Le premier entier représente le prix de l'article.\n        - Le second entier représente la valeur d'importance de l'article.\n    \n    Retourne:\n    int: La valeur d'importance totale maximale pouvant être atteinte sans dépasser le budget.\n    \n    Exemples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "de": "\n    Berechnet den maximalen Gesamtwert der Wichtigkeit von Gegenständen, die innerhalb eines gegebenen Budgets gekauft werden können.\n    \n    Diese Funktion löst eine Variante des 0-1-Rucksackproblems, bei dem jeder Gegenstand einen Preis und einen zugehörigen Wichtigkeitswert hat. Das Ziel ist es, die Summe der Wichtigkeitswerte einer Auswahl von Gegenständen zu maximieren, ohne dass der Gesamtpreis das Budget überschreitet.\n    \n    Argumente:\n    n (int): Das gesamte verfügbare Budget für den Kauf von Gegenständen.\n    m (int): Die Anzahl der verschiedenen zur Auswahl stehenden Gegenstände.\n    items (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält:\n        - Die erste ganze Zahl repräsentiert den Preis des Gegenstands.\n        - Die zweite ganze Zahl repräsentiert den Wichtigkeitswert des Gegenstands.\n    \n    Rückgabewert:\n    int: Der maximale Gesamtwert der Wichtigkeit, der erreicht werden kann, ohne das Budget zu überschreiten.\n    \n    Beispiele:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "ha": "\n    Lissafa yawan jimillar mahimmancin abubuwan da za a iya saya cikin kasafin kuɗi da aka bayar.\n    \n    Wannan aikin yana warware wani bambancin matsalar jakar 0-1 inda kowanne abu yana da farashi da kuma \n    mahimmancin da aka haɗa. Manufar ita ce a haɓaka jimillar mahimmancin zaɓin abubuwa ba tare da \n    jimillar farashin ta zarce kasafin kuɗi ba.\n    \n    Args:\n    n (int): Jimillar kasafin kuɗi da ake da shi don siyan abubuwa.\n    m (int): Yawan abubuwa daban-daban da za a zaɓa daga.\n    items (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple yana ɗauke da lambobi biyu:\n        - Lamba ta farko tana wakiltar farashin abu.\n        - Lamba ta biyu tana wakiltar mahimmancin abu.\n    \n    Returns:\n    int: Jimillar mahimmancin da za a iya samu ba tare da zarce kasafin kuɗi ba.\n    \n    Misalai:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "hi": "\n    दिए गए बजट के भीतर खरीदे जा सकने वाले वस्तुओं के अधिकतम कुल महत्व मान की गणना करता है।\n    \n    यह फ़ंक्शन 0-1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ प्रत्येक वस्तु की एक कीमत और एक \n    संबंधित महत्व मान होता है। लक्ष्य यह है कि वस्तुओं के चयन के महत्व मानों के योग को अधिकतम किया जाए \n    बिना कुल कीमत बजट से अधिक हुए।\n    \n    Args:\n    n (int): वस्तुएं खरीदने के लिए उपलब्ध कुल बजट।\n    m (int): चुनने के लिए विभिन्न वस्तुओं की संख्या।\n    items (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं:\n        - पहला पूर्णांक वस्तु की कीमत को दर्शाता है।\n        - दूसरा पूर्णांक वस्तु के महत्व मान को दर्शाता है।\n    \n    Returns:\n    int: अधिकतम कुल महत्व मान जो बजट से अधिक हुए बिना प्राप्त किया जा सकता है।\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "hu": "\n    Kiszámítja a tárgyak maximális összesített fontossági értékét, amelyeket meg lehet vásárolni egy adott költségvetésen belül.\n    \n    Ez a függvény a 0-1 hátizsák probléma egy változatát oldja meg, ahol minden tárgynak van egy ára és egy hozzá tartozó fontossági értéke. A cél az, hogy maximalizáljuk a kiválasztott tárgyak fontossági értékeinek összegét anélkül, hogy a teljes ár meghaladná a költségvetést.\n    \n    Paraméterek:\n    n (int): A tárgyak vásárlására rendelkezésre álló teljes költségvetés.\n    m (int): A választható különböző tárgyak száma.\n    items (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy két egész számot tartalmazó tuple:\n        - Az első egész szám a tárgy árát jelöli.\n        - A második egész szám a tárgy fontossági értékét jelöli.\n    \n    Visszatér:\n    int: A maximális összesített fontossági érték, amely elérhető anélkül, hogy meghaladnánk a költségvetést.\n    \n    Példák:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "es": "\n    Calcula el valor máximo total de importancia de los artículos que se pueden comprar dentro de un presupuesto dado.\n\nEsta función resuelve una variante del problema de la mochila 0-1 donde cada artículo tiene un precio y un valor de importancia asociado. El objetivo es maximizar la suma de los valores de importancia de una selección de artículos sin que el precio total exceda el presupuesto.\n\nArgumentos:\nn (int): El presupuesto total disponible para la compra de artículos.\nm (int): El número de diferentes artículos para elegir.\nitems (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros:\n    - El primer entero representa el precio del artículo.\n    - El segundo entero representa el valor de importancia del artículo.\n\nDevuelve:\nint: El valor máximo total de importancia que se puede lograr sin exceder el presupuesto.\n\nEjemplos:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80", "arb": "\n    يحسب القيمة القصوى لإجمالي الأهمية للعناصر التي يمكن شراؤها ضمن ميزانية معينة.\n    \n    تحل هذه الدالة نوعًا من مشكلة حقيبة الظهر 0-1 حيث أن لكل عنصر سعر وقيمة أهمية مرتبطة به. \n    الهدف هو تعظيم مجموع قيم الأهمية لمجموعة من العناصر دون أن يتجاوز السعر الإجمالي الميزانية.\n    \n    يعيدالحجج:\n    n (int): الميزانية الإجمالية المتاحة لشراء العناصر.\n    m (int): عدد العناصر المختلفة للاختيار من بينها.\n    items (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين:\n        - العدد الأول يمثل سعر العنصر.\n        - العدد الثاني يمثل قيمة الأهمية للعنصر.\n    \n    يعيد:\n    int: القيمة القصوى الإجمالية للأهمية التي يمكن تحقيقها دون تجاوز الميزانية.\n    \n    امثله:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "sw": "\n    Inakokotoa thamani ya juu kabisa ya umuhimu wa jumla wa vitu vinavyoweza kununuliwa ndani ya bajeti iliyotolewa.\n    \n    Kazi hii inatatua aina ya tatizo la 0-1 knapsack ambapo kila kipengee kina bei na thamani ya umuhimu inayohusiana. Lengo ni kuongeza jumla ya thamani za umuhimu wa uteuzi wa vitu bila bei ya jumla kuzidi bajeti.\n    \n    Hoja:\n    n (int): Bajeti ya jumla inayopatikana kwa ununuzi wa vitu.\n    m (int): Idadi ya vitu tofauti vya kuchagua.\n    items (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili:\n        - Namba ya kwanza inawakilisha bei ya kipengee.\n        - Namba ya pili inawakilisha thamani ya umuhimu wa kipengee.\n    \n    Inarejesha:\n    int: Thamani ya juu kabisa ya umuhimu wa jumla inayoweza kupatikana bila kuzidi bajeti.\n    \n    Mifano:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "tr": "\n    Verilen bir bütçe dahilinde satın alınabilecek eşyaların maksimum toplam önem değerini hesaplar.\n    \n    Bu fonksiyon, her bir öğenin bir fiyatı ve ilişkili bir önem değeri olduğu 0-1 sırt çantası probleminin bir varyantını çözer. Amaç, toplam fiyat bütçeyi aşmadan, bir dizi öğenin önem değerlerinin toplamını maksimize etmektir.\n    \n    Argümanlar:\n    n (int): Eşyaları satın almak için mevcut toplam bütçe.\n    m (int): Seçilecek farklı eşya sayısı.\n    items (List[Tuple[int, int]]): Her bir demetin iki tam sayı içerdiği demetlerin listesi:\n        - İlk tam sayı, eşyanın fiyatını temsil eder.\n        - İkinci tam sayı, eşyanın önem değerini temsil eder.\n    \n    Döndürür:\n    int: Bütçeyi aşmadan elde edilebilecek maksimum toplam önem değeri.\n    \n    Örnekler:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "vi": "\n    Tính toán giá trị tầm quan trọng tối đa của các món hàng có thể mua trong một ngân sách cho trước.\n    \n    Hàm này giải quyết một biến thể của bài toán ba lô 0-1, trong đó mỗi món hàng có một giá và một \n    giá trị tầm quan trọng liên quan. Mục tiêu là tối đa hóa tổng giá trị tầm quan trọng của một \n    lựa chọn các món hàng mà không để tổng giá vượt quá ngân sách.\n    \n    Tham số:\n    n (int): Tổng ngân sách có sẵn để mua các món hàng.\n    m (int): Số lượng các món hàng khác nhau để lựa chọn.\n    items (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên:\n        - Số nguyên đầu tiên đại diện cho giá của món hàng.\n        - Số nguyên thứ hai đại diện cho giá trị tầm quan trọng của món hàng.\n    \n    Trả về:\n    int: Giá trị tầm quan trọng tối đa có thể đạt được mà không vượt quá ngân sách.\n    \n    Ví dụ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "id": "Menghitung nilai total kepentingan maksimum dari barang-barang yang dapat dibeli dalam anggaran yang diberikan.\n\nFungsi ini menyelesaikan varian dari masalah knapsack 0-1 di mana setiap barang memiliki harga dan nilai kepentingan terkait. Tujuannya adalah untuk memaksimalkan jumlah nilai kepentingan dari pilihan barang-barang tanpa total harga melebihi anggaran.\n\nArgs:\nn (int): Total anggaran yang tersedia untuk membeli barang-barang.\nm (int): Jumlah barang berbeda yang dapat dipilih.\nitems (List[Tuple[int, int]]): Daftar tuple, di mana setiap tuple berisi dua bilangan bulat:\n    - Bilangan bulat pertama mewakili harga barang.\n    - Bilangan bulat kedua mewakili nilai kepentingan barang.\n\nReturns:\nint: Nilai total kepentingan maksimum yang dapat dicapai tanpa melebihi anggaran.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80", "ja": "    与えられた予算内で購入できるアイテムの最大合計重要度を計算します。\n\n    この関数は、各アイテムに価格と関連する重要度がある0-1ナップサック問題の変種を解きます。目標は、予算を超えないようにしながら、選択したアイテムの重要度の合計を最大化することです。\n\n    引数:\n    n (int): アイテムを購入するために利用可能な総予算。\n    m (int): 選択可能な異なるアイテムの数。\n    items (List[Tuple[int, int]]): タプルのリストで、各タプルは2つの整数を含みます:\n        - 最初の整数はアイテムの価格を表します。\n        - 2番目の整数はアイテムの重要度を表します。\n\n    戻り値:\n    int: 予算を超えずに達成できる最大の合計重要度。\n\n    例:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n\n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "ko": "    주어진 예산 내에서 구매할 수 있는 항목의 최대 총 중요도 값을 계산합니다.\n    \n    이 함수는 각 항목이 가격과 관련된 중요도 값을 가지는 0-1 배낭 문제의 변형을 해결합니다. 목표는 \n    총 가격이 예산을 초과하지 않으면서 항목 선택의 중요도 값의 합을 최대화하는 것입니다.\n    \n    Args:\n    n (int): 항목 구매를 위해 사용할 수 있는 총 예산.\n    m (int): 선택할 수 있는 다양한 항목의 수.\n    items (List[Tuple[int, int]]): 각 튜플이 두 개의 정수를 포함하는 튜플의 목록:\n        - 첫 번째 정수는 항목의 가격을 나타냅니다.\n        - 두 번째 정수는 항목의 중요도 값을 나타냅니다.\n    \n    Returns:\n    int: 예산을 초과하지 않으면서 달성할 수 있는 최대 총 중요도 값.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "ml": "    നൽകിയ ബജറ്റിനുള്ളിൽ വാങ്ങാൻ കഴിയുന്ന വസ്തുക്കളുടെ പരമാവധി ആകെ പ്രാധാന്യ മൂല്യം കണക്കാക്കുന്നു.\n    \n    ഓരോ വസ്തുവിനും ഒരു വിലയും ബന്ധപ്പെട്ട പ്രാധാന്യ മൂല്യവും ഉള്ള 0-1 സഞ്ചി പ്രശ്നത്തിന്റെ ഒരു വ്യതിയാനമാണ് ഈ ഫങ്ഷൻ പരിഹരിക്കുന്നത്. ആകെ വില ബജറ്റിനെ മറികടക്കാതെ വസ്തുക്കളുടെ ഒരു തിരഞ്ഞെടുപ്പിന്റെ പ്രാധാന്യ മൂല്യങ്ങളുടെ മൊത്തം തുക പരമാവധി ആക്കുക എന്നതാണ് ലക്ഷ്യം.\n    \n    Args:\n    n (int): വസ്തുക്കൾ വാങ്ങുന്നതിനുള്ള മൊത്തം ലഭ്യമായ ബജറ്റ്.\n    m (int): തിരഞ്ഞെടുക്കാൻ കഴിയുന്ന വ്യത്യസ്ത വസ്തുക്കളുടെ എണ്ണം.\n    items (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളിലും രണ്ട് പൂർണ്ണസംഖ്യകളുള്ള ട്യൂപ്പിളുകളുടെ പട്ടിക:\n        - ആദ്യ പൂർണ്ണസംഖ്യ വസ്തുവിന്റെ വിലയെ പ്രതിനിധീകരിക്കുന്നു.\n        - രണ്ടാം പൂർണ്ണസംഖ്യ വസ്തുവിന്റെ പ്രാധാന്യ മൂല്യത്തെ പ്രതിനിധീകരിക്കുന്നു.\n    \n    Returns:\n    int: ബജറ്റിനെ മറികടക്കാതെ നേടാൻ കഴിയുന്ന പരമാവധി ആകെ പ്രാധാന്യ മൂല്യം.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80", "fa": "    حداکثر مقدار کل اهمیت اقلامی که می‌توانند در یک بودجه معین خریداری شوند را محاسبه می‌کند.\n    \n    این تابع یک نوع از مسئله کوله‌پشتی 0-1 را حل می‌کند که در آن هر آیتم دارای قیمتی و یک \n    مقدار اهمیت مرتبط است. هدف این است که مجموع مقادیر اهمیت یک انتخاب از اقلام را \n    بدون اینکه قیمت کل از بودجه تجاوز کند، به حداکثر برسانیم.\n    \n    آرگومان‌ها:\n    n (int): بودجه کل موجود برای خرید اقلام.\n    m (int): تعداد اقلام مختلف برای انتخاب.\n    items (List[Tuple[int, int]]): لیستی از زوج‌ها، که هر زوج شامل دو عدد صحیح است:\n        - عدد صحیح اول قیمت آیتم را نشان می‌دهد.\n        - عدد صحیح دوم مقدار اهمیت آیتم را نشان می‌دهد.\n    \n    بازگشت:\n    int: حداکثر مقدار کل اهمیت که می‌تواند بدون تجاوز از بودجه به دست آید.\n    \n    مثال‌ها:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80"}}
{"task_id": "Python/19", "prompt": {"en": "def max_energy(beads):\n    \"\"\"\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "sq": "def max_energy(beads):\n    \"\"\"\n    Llogarit energjinë maksimale që mund të çlirohet duke bashkuar rruazat në një varëse.\n\n    Funksioni merr një listë të numrave të plotë që përfaqësojnë rruazat e energjisë në një varëse, ku\n    secila rruazë ka një vlerë koke dhe një vlerë bishti. Vlera e kokës së secilës rruazë duhet të përputhet\n    me vlerën e bishtit të rruazës së ardhshme në sekuencë. Varësja është rrethore, dhe bashkimi i dy rruazave\n    ngjitur çliron energji të barabartë me produktin e vlerës së kokës së rruazës së parë, vlerës përputhëse,\n    dhe vlerës së bishtit të rruazës së dytë.\n\n    Për të gjetur çlirimin maksimal të energjisë, funksioni konsideron të gjitha renditjet e mundshme të bashkimit\n    të rruazave dhe përdor programimin dinamik për të llogaritur energjinë maksimale të mundshme.\n\n    Args:\n        beads: Një listë e numrave të plotë ku secili numër përfaqëson vlerën e kokës së një rruaze dhe\n               vlerën e bishtit të rruazës së mëparshme. Vlera e bishtit të rruazës së fundit supozohet\n               të përputhet me vlerën e kokës së rruazës së parë për shkak të natyrës rrethore të varëses.\n\n    Returns:\n        Një numër i plotë që përfaqëson energjinë maksimale që mund të merret duke bashkuar në mënyrë optimale të gjitha rruazat.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "hy": "def max_energy(beads):\n    \"\"\"\n    Հաշվարկել առավելագույն էներգիան, որը կարող է ազատվել մարգարիտների միաձուլմամբ վզնոցում:\n\n    Ֆունկցիան ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է վզնոցի վրա գտնվող էներգիայի մարգարիտները, որտեղ\n    յուրաքանչյուր մարգարիտ ունի գլխի և պոչի արժեք: Յուրաքանչյուր մարգարիտի գլխի արժեքը պետք է համընկնի հաջորդ մարգարիտի\n    պոչի արժեքի հետ հաջորդականության մեջ: Վզնոցը շրջանաձև է, և երկու հարակից մարգարիտների միաձուլումը ազատում է էներգիա,\n    որը հավասար է առաջին մարգարիտի գլխի արժեքի, համընկնող արժեքի և երկրորդ մարգարիտի պոչի արժեքի արտադրյալին:\n\n    Առավելագույն էներգիայի ազատումը գտնելու համար ֆունկցիան հաշվի է առնում մարգարիտների միաձուլման բոլոր հնարավոր կարգերը\n    և օգտագործում է դինամիկ ծրագրավորում՝ առավելագույն հասանելի էներգիան հաշվարկելու համար:\n\n    Արգումենտներ:\n        beads: Ամբողջ թվերի ցուցակ, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է մարգարիտի գլխի արժեքը և\n               նախորդ մարգարիտի պոչի արժեքը: Վերջին մարգարիտի պոչի արժեքը ենթադրվում է, որ համընկնում է առաջին\n               մարգարիտի գլխի արժեքի հետ՝ վզնոցի շրջանաձև բնույթի պատճառով:\n\n    Վերադարձնում է:\n        Ամբողջ թիվ, որը ներկայացնում է առավելագույն էներգիան, որը կարող է ստացվել բոլոր մարգարիտների օպտիմալ միաձուլմամբ:\n\n    Օրինակներ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "bn": "def max_energy(beads):\n    \"\"\"\n    একটি মালার উপর মুক্তাগুলি একত্রিত করে যে সর্বাধিক শক্তি মুক্তি পেতে পারে তা গণনা করুন।\n\n    ফাংশনটি একটি পূর্ণসংখ্যার তালিকা গ্রহণ করে যা একটি মালার উপর শক্তি মুক্তাগুলিকে উপস্থাপন করে, যেখানে\n    প্রতিটি মুক্তার একটি মাথা এবং একটি লেজ মান থাকে। প্রতিটি মুক্তার মাথার মান অবশ্যই পরবর্তী মুক্তার\n    লেজের মানের সাথে মেলাতে হবে। মালাটি বৃত্তাকার, এবং দুটি সংলগ্ন মুক্তা একত্রিত করলে প্রথম মুক্তার\n    মাথার মান, মেলানো মান, এবং দ্বিতীয় মুক্তার লেজের মানের গুণফল সমান শক্তি মুক্তি পায়।\n\n    সর্বাধিক শক্তি মুক্তির জন্য, ফাংশনটি মুক্তাগুলি একত্রিত করার সমস্ত সম্ভাব্য ক্রম বিবেচনা করে\n    এবং গতিশীল প্রোগ্রামিং ব্যবহার করে সর্বাধিক প্রাপ্তযোগ্য শক্তি গণনা করে।\n\n    আর্গস:\n        beads: পূর্ণসংখ্যার একটি তালিকা যেখানে প্রতিটি পূর্ণসংখ্যা একটি মুক্তার মাথার মান এবং\n               পূর্ববর্তী মুক্তার লেজের মান উপস্থাপন করে। মালার বৃত্তাকার প্রকৃতির কারণে শেষ মুক্তার\n               লেজের মান প্রথম মুক্তার মাথার মানের সাথে মেলে বলে ধরা হয়।\n\n    রিটার্নস:\n        একটি পূর্ণসংখ্যা যা সমস্ত মুক্তা সর্বোত্তমভাবে একত্রিত করে প্রাপ্ত সর্বাধিক শক্তি উপস্থাপন করে।\n\n    উদাহরণ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "bg": "def max_energy(beads):\n    \"\"\"\n    Изчислява максималната енергия, която може да бъде освободена чрез обединяване на мъниста на огърлица.\n\n    Функцията приема списък от цели числа, представляващи енергийните мъниста на огърлица, където\n    всяко мънисто има стойност на глава и опашка. Стойността на главата на всяко мънисто трябва да съвпада\n    със стойността на опашката на следващото мънисто в последователността. Огърлицата е кръгова и обединяването\n    на две съседни мъниста освобождава енергия, равна на произведението от стойността на главата на първото мънисто,\n    съвпадащата стойност и стойността на опашката на второто мънисто.\n\n    За да намери максималното освобождаване на енергия, функцията разглежда всички възможни редове на обединяване на мъниста\n    и използва динамично програмиране, за да изчисли максималната енергия, която може да бъде получена.\n\n    Аргументи:\n        beads: Списък от цели числа, където всяко число представлява стойността на главата на мънисто и\n               стойността на опашката на предишното мънисто. Стойността на опашката на последното мънисто се предполага,\n               че съвпада със стойността на главата на първото мънисто поради кръговата природа на огърлицата.\n\n    Връща:\n        Цяло число, представляващо максималната енергия, която може да бъде получена чрез оптимално обединяване на всички мъниста.\n\n    Примери:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "zh": "def max_energy(beads):\n    \"\"\"\n    计算通过合并项链上的珠子可以释放的最大能量。\n\n    该函数接受一个整数列表，表示项链上的能量珠子，其中每个珠子都有一个头部和尾部值。\n    每个珠子的头部值必须与序列中下一个珠子的尾部值匹配。项链是环形的，合并两个相邻珠子\n    释放的能量等于第一个珠子的头部值、匹配值和第二个珠子的尾部值的乘积。\n\n    为了找到最大能量释放，函数考虑所有可能的合并珠子的顺序，并使用动态规划来计算可获得的最大能量。\n\n    参数:\n        beads: 一个整数列表，其中每个整数表示一个珠子的头部值和前一个珠子的尾部值。\n               由于项链的环形特性，假设最后一个珠子的尾部值与第一个珠子的头部值匹配。\n\n    返回:\n        一个整数，表示通过最佳合并所有珠子可以获得的最大能量。\n\n    示例:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "fr": "def max_energy(beads):\n    \"\"\"\n    Calculer l'énergie maximale qui peut être libérée en fusionnant des perles sur un collier.\n\n    La fonction prend une liste d'entiers représentant les perles d'énergie sur un collier, où\n    chaque perle a une valeur de tête et une valeur de queue. La valeur de tête de chaque perle doit correspondre à la valeur de queue\n    de la perle suivante dans la séquence. Le collier est circulaire, et la fusion de deux perles adjacentes\n    libère une énergie égale au produit de la valeur de tête de la première perle, de la valeur correspondante,\n    et de la valeur de queue de la deuxième perle.\n\n    Pour trouver la libération d'énergie maximale, la fonction considère tous les ordres possibles de fusion des perles\n    et utilise la programmation dynamique pour calculer l'énergie maximale obtenable.\n\n    Arguments:\n        beads: Une liste d'entiers où chaque entier représente la valeur de tête d'une perle et\n               la valeur de queue de la perle précédente. La valeur de queue de la dernière perle est supposée\n               correspondre à la valeur de tête de la première perle en raison de la nature circulaire du collier.\n\n    Retourne:\n        Un entier représentant l'énergie maximale qui peut être obtenue en fusionnant de manière optimale toutes les perles.\n\n    Exemples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "de": "def max_energy(beads):\n    \"\"\"\n    Berechne die maximale Energie, die durch das Verschmelzen von Perlen auf einer Halskette freigesetzt werden kann.\n\n    Die Funktion nimmt eine Liste von ganzen Zahlen, die die Energieperlen auf einer Halskette darstellen, wobei\n    jede Perle einen Kopf- und einen Schwanzwert hat. Der Kopfwert jeder Perle muss mit dem Schwanzwert der nächsten\n    Perle in der Sequenz übereinstimmen. Die Halskette ist kreisförmig, und das Verschmelzen von zwei benachbarten\n    Perlen setzt Energie frei, die dem Produkt des Kopfwerts der ersten Perle, dem übereinstimmenden Wert und dem\n    Schwanzwert der zweiten Perle entspricht.\n\n    Um die maximale Energiefreisetzung zu finden, berücksichtigt die Funktion alle möglichen Reihenfolgen des\n    Verschmelzens von Perlen und verwendet dynamische Programmierung, um die maximal erreichbare Energie zu berechnen.\n\n    Argumente:\n        beads: Eine Liste von ganzen Zahlen, wobei jede Zahl den Kopfwert einer Perle und den Schwanzwert der\n               vorherigen Perle darstellt. Der Schwanzwert der letzten Perle wird aufgrund der kreisförmigen\n               Natur der Halskette als übereinstimmend mit dem Kopfwert der ersten Perle angenommen.\n\n    Rückgabe:\n        Eine ganze Zahl, die die maximale Energie darstellt, die durch optimales Verschmelzen aller Perlen\n        erreicht werden kann.\n\n    Beispiele:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "ha": "def max_energy(beads):\n    \"\"\"\n    Lissafa mafi yawan kuzari da za a iya saki ta hanyar haɗa beads akan abin wuya.\n\n    Aikin yana ɗaukar jerin lambobi waɗanda ke wakiltar kuzarin beads akan abin wuya, inda\n    kowanne bead yana da ƙimar kai da ƙimar wutsiya. Dole ne ƙimar kai na kowanne bead ya dace da ƙimar wutsiya\n    na bead na gaba a jere. Abin wuya yana zagaye, kuma haɗa beads biyu masu makwabtaka\n    yana sakin kuzari daidai da samfurin ƙimar kai na bead na farko, ƙimar da ta dace,\n    da ƙimar wutsiya na bead na biyu.\n\n    Don nemo mafi yawan sakin kuzari, aikin yana la'akari da dukkan yiwuwar oda na haɗa beads\n    kuma yana amfani da shirye-shiryen motsi don lissafa mafi yawan kuzari da za a iya samu.\n\n    Args:\n        beads: Jerin lambobi inda kowanne lamba yana wakiltar ƙimar kai na bead da\n               ƙimar wutsiya na bead na baya. Ana ɗauka cewa ƙimar wutsiya na bead na ƙarshe\n               ya dace da ƙimar kai na bead na farko saboda yanayin zagaye na abin wuya.\n\n    Returns:\n        Lamba mai wakiltar mafi yawan kuzari da za a iya samu ta hanyar haɗa duk beads da kyau.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "hi": "def max_energy(beads):\n    \"\"\"\n    एक माला पर मोतियों को मिलाकर जारी की जा सकने वाली अधिकतम ऊर्जा की गणना करें।\n\n    यह फ़ंक्शन एक सूची लेता है जिसमें माला पर ऊर्जा मोतियों का प्रतिनिधित्व करने वाले पूर्णांक होते हैं,\n    जहां प्रत्येक मोती का एक सिर और एक पूंछ मान होता है। प्रत्येक मोती का सिर मान अनुक्रम में अगले मोती के\n    पूंछ मान से मेल खाना चाहिए। माला गोलाकार है, और दो सटे हुए मोतियों को मिलाने पर उतनी ऊर्जा जारी होती है\n    जितनी पहले मोती के सिर मान, मेल खाने वाले मान, और दूसरे मोती के पूंछ मान के गुणनफल के बराबर होती है।\n\n    अधिकतम ऊर्जा रिलीज़ खोजने के लिए, फ़ंक्शन मोतियों को मिलाने के सभी संभावित क्रमों पर विचार करता है\n    और गतिशील प्रोग्रामिंग का उपयोग करके प्राप्त की जा सकने वाली अधिकतम ऊर्जा की गणना करता है।\n\n    तर्क:\n        beads: पूर्णांकों की एक सूची जहां प्रत्येक पूर्णांक एक मोती के सिर मान और\n               पिछले मोती के पूंछ मान का प्रतिनिधित्व करता है। माला की गोलाकार प्रकृति के कारण\n               अंतिम मोती का पूंछ मान पहले मोती के सिर मान से मेल खाने वाला माना जाता है।\n\n    वापसी:\n        एक पूर्णांक जो सभी मोतियों को अनुकूल रूप से मिलाकर प्राप्त की जा सकने वाली अधिकतम ऊर्जा का प्रतिनिधित्व करता है।\n\n    उदाहरण:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "hu": "def max_energy(beads):\n    \"\"\"\n    Számítsa ki a maximális energiát, amely a gyöngyök összeolvasztásával szabadulhat fel egy nyakláncon.\n\n    A függvény egy egész számok listáját veszi át, amelyek a nyaklánc gyöngyeinek energiáját képviselik, ahol\n    minden gyöngynek van egy fej- és egy farokértéke. Minden gyöngy fejértékének meg kell egyeznie a következő\n    gyöngy farokértékével a sorozatban. A nyaklánc kör alakú, és két szomszédos gyöngy összeolvasztása\n    energiát szabadít fel, amely egyenlő az első gyöngy fejértékének, az egyező értéknek és a második gyöngy\n    farokértékének szorzatával.\n\n    A maximális energiafelszabadulás megtalálásához a függvény figyelembe veszi a gyöngyök összeolvasztásának\n    összes lehetséges sorrendjét, és dinamikus programozást használ a maximálisan elérhető energia kiszámításához.\n\n    Args:\n        beads: Egy egész számok listája, ahol minden egész szám egy gyöngy fejértékét és az előző gyöngy\n               farokértékét képviseli. Az utolsó gyöngy farokértéke feltételezhetően megegyezik az első\n               gyöngy fejértékével a nyaklánc körkörös jellege miatt.\n\n    Returns:\n        Egy egész szám, amely a maximális energiát képviseli, amely az összes gyöngy optimális összeolvasztásával\n        nyerhető.\n\n    Példák:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "es": "def max_energy(beads):\n    \"\"\"\n    Calcular la energía máxima que se puede liberar al fusionar cuentas en un collar.\n\n    La función toma una lista de enteros que representan las cuentas de energía en un collar, donde\n    cada cuenta tiene un valor de cabeza y un valor de cola. El valor de cabeza de cada cuenta debe coincidir\n    con el valor de cola de la siguiente cuenta en la secuencia. El collar es circular, y fusionar dos cuentas adyacentes\n    libera energía igual al producto del valor de cabeza de la primera cuenta, el valor coincidente,\n    y el valor de cola de la segunda cuenta.\n\n    Para encontrar la liberación máxima de energía, la función considera todos los órdenes posibles de fusión de cuentas\n    y utiliza programación dinámica para calcular la máxima energía obtenible.\n\n    Argumentos:\n        beads: Una lista de enteros donde cada entero representa el valor de cabeza de una cuenta y\n               el valor de cola de la cuenta anterior. Se asume que el valor de cola de la última cuenta coincide\n               con el valor de cabeza de la primera cuenta debido a la naturaleza circular del collar.\n\n    Devuelve:\n        Un entero que representa la energía máxima que se puede obtener al fusionar todas las cuentas de manera óptima.\n\n    Ejemplos:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "arb": "```python\ndef max_energy(beads):\n    \"\"\"\n    حساب الحد الأقصى للطاقة التي يمكن إطلاقها عن طريق دمج الخرزات في عقد.\n\n    تأخذ الدالة قائمة من الأعداد الصحيحة التي تمثل خرزات الطاقة في عقد، حيث\n    يحتوي كل خرزة على قيمة رأس وقيمة ذيل. يجب أن تتطابق قيمة الرأس لكل خرزة مع قيمة الذيل\n    للخرزة التالية في التسلسل. العقد دائري، ودمج خرزتين متجاورتين يطلق طاقة تساوي حاصل ضرب قيمة الرأس للخرزة الأولى،\n    والقيمة المطابقة، وقيمة الذيل للخرزة الثانية.\n\n    للعثور على الحد الأقصى لإطلاق الطاقة، تأخذ الدالة في الاعتبار جميع أوامر دمج الخرزات الممكنة\n    وتستخدم البرمجة الديناميكية لحساب الحد الأقصى للطاقة الممكن الحصول عليها.\n\n    يعيدالحجج:\n        beads: قائمة من الأعداد الصحيحة حيث يمثل كل عدد صحيح قيمة الرأس لخرزة\n               وقيمة الذيل للخرزة السابقة. يُفترض أن قيمة الذيل للخرزة الأخيرة تتطابق\n               مع قيمة الرأس للخرزة الأولى بسبب الطبيعة الدائرية للعقد.\n\n    يعيد:\n        عدد صحيح يمثل الحد الأقصى للطاقة التي يمكن الحصول عليها عن طريق دمج جميع الخرزات بشكل مثالي.\n\n    امثله:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"\n```", "sw": "def max_energy(beads):\n    \"\"\"\n    Kuhesabu nishati ya juu inayoweza kutolewa kwa kuunganisha shanga kwenye mkufu.\n\n    Kazi inachukua orodha ya nambari za mzima zinazoonyesha nishati ya shanga kwenye mkufu, ambapo\n    kila shanga ina thamani ya kichwa na mkia. Thamani ya kichwa ya kila shanga lazima ilingane na thamani ya mkia\n    ya shanga inayofuata katika mlolongo. Mkufu ni wa mviringo, na kuunganisha shanga mbili zilizo karibu\n    hutolewa nishati sawa na bidhaa ya thamani ya kichwa ya shanga ya kwanza, thamani inayolingana,\n    na thamani ya mkia ya shanga ya pili.\n\n    Ili kupata nishati ya juu inayotolewa, kazi inazingatia mpangilio wote unaowezekana wa kuunganisha shanga\n    na hutumia programu ya nguvu kuhesabu nishati ya juu inayoweza kupatikana.\n\n    Hoja:\n        beads: Orodha ya nambari za mzima ambapo kila nambari inawakilisha thamani ya kichwa ya shanga na\n               thamani ya mkia ya shanga iliyotangulia. Thamani ya mkia ya shanga ya mwisho inadhaniwa\n               kulingana na thamani ya kichwa ya shanga ya kwanza kutokana na asili ya mviringo ya mkufu.\n\n    Inarudisha:\n        Nambari ya mzima inayowakilisha nishati ya juu inayoweza kupatikana kwa kuunganisha shanga zote kwa njia bora.\n\n    Mifano:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "tr": "def max_energy(beads):\n    \"\"\"\n    Bir kolyedeki boncukları birleştirerek açığa çıkabilecek maksimum enerjiyi hesaplayın.\n\n    Fonksiyon, bir kolyedeki enerji boncuklarını temsil eden bir tamsayı listesi alır, burada\n    her boncuğun bir baş ve bir kuyruk değeri vardır. Her boncuğun baş değeri, dizideki bir sonraki\n    boncuğun kuyruk değeriyle eşleşmelidir. Kolye daireseldir ve iki bitişik boncuğu birleştirmek,\n    ilk boncuğun baş değeri, eşleşen değer ve ikinci boncuğun kuyruk değerinin çarpımına eşit enerji açığa çıkarır.\n\n    Maksimum enerji açığa çıkışını bulmak için, fonksiyon boncukları birleştirmenin tüm olası sıralarını\n    dikkate alır ve dinamik programlama kullanarak elde edilebilecek maksimum enerjiyi hesaplar.\n\n    Argümanlar:\n        beads: Her tamsayının bir boncuğun baş değerini ve önceki boncuğun kuyruk değerini temsil ettiği\n               bir tamsayı listesi. Kolyenin dairesel doğası nedeniyle, son boncuğun kuyruk değerinin\n               ilk boncuğun baş değeriyle eşleştiği varsayılır.\n\n    Döndürür:\n        Tüm boncukları optimal bir şekilde birleştirerek elde edilebilecek maksimum enerjiyi temsil eden bir tamsayı.\n\n    Örnekler:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "vi": "def max_energy(beads):\n    \"\"\"\n    Tính toán năng lượng tối đa có thể được giải phóng bằng cách hợp nhất các hạt trên một vòng cổ.\n\n    Hàm nhận vào một danh sách các số nguyên đại diện cho năng lượng của các hạt trên một vòng cổ, \n    trong đó mỗi hạt có một giá trị đầu và một giá trị đuôi. Giá trị đầu của mỗi hạt phải khớp với \n    giá trị đuôi của hạt tiếp theo trong chuỗi. Vòng cổ là vòng tròn, và việc hợp nhất hai hạt liền kề \n    giải phóng năng lượng bằng tích của giá trị đầu của hạt thứ nhất, giá trị khớp, và giá trị đuôi \n    của hạt thứ hai.\n\n    Để tìm năng lượng giải phóng tối đa, hàm xem xét tất cả các thứ tự có thể của việc hợp nhất các hạt \n    và sử dụng lập trình động để tính toán năng lượng tối đa có thể đạt được.\n\n    Tham số:\n        beads: Một danh sách các số nguyên, trong đó mỗi số nguyên đại diện cho giá trị đầu của một hạt \n               và giá trị đuôi của hạt trước đó. Giá trị đuôi của hạt cuối cùng được giả định là khớp \n               với giá trị đầu của hạt đầu tiên do tính chất vòng tròn của vòng cổ.\n\n    Trả về:\n        Một số nguyên đại diện cho năng lượng tối đa có thể đạt được bằng cách hợp nhất tối ưu tất cả các hạt.\n\n    Ví dụ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "id": "def max_energy(beads):\n    \"\"\"\n    Menghitung energi maksimum yang dapat dilepaskan dengan menggabungkan manik-manik pada kalung.\n\n    Fungsi ini menerima daftar bilangan bulat yang mewakili energi manik-manik pada kalung, di mana\n    setiap manik memiliki nilai kepala dan ekor. Nilai kepala dari setiap manik harus sesuai dengan nilai ekor\n    dari manik berikutnya dalam urutan. Kalung ini berbentuk melingkar, dan menggabungkan dua manik yang berdekatan\n    melepaskan energi yang sama dengan hasil kali dari nilai kepala manik pertama, nilai yang cocok,\n    dan nilai ekor dari manik kedua.\n\n    Untuk menemukan pelepasan energi maksimum, fungsi ini mempertimbangkan semua urutan penggabungan manik-manik yang mungkin\n    dan menggunakan pemrograman dinamis untuk menghitung energi maksimum yang dapat diperoleh.\n\n    Argumen:\n        beads: Daftar bilangan bulat di mana setiap bilangan bulat mewakili nilai kepala dari manik dan\n               nilai ekor dari manik sebelumnya. Nilai ekor dari manik terakhir diasumsikan\n               sesuai dengan nilai kepala dari manik pertama karena sifat melingkar dari kalung.\n\n    Mengembalikan:\n        Sebuah bilangan bulat yang mewakili energi maksimum yang dapat diperoleh dengan menggabungkan semua manik secara optimal.\n\n    Contoh:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "ja": "def max_energy(beads):\n    \"\"\"\n    ネックレスのビーズを合体させることで放出される最大エネルギーを計算します。\n\n    この関数は、ネックレス上のエネルギービーズを表す整数のリストを受け取り、\n    各ビーズはヘッドとテールの値を持っています。各ビーズのヘッド値は、次のビーズの\n    テール値と一致しなければなりません。ネックレスは円形であり、隣接する2つのビーズを\n    合体させると、最初のビーズのヘッド値、マッチング値、および2番目のビーズのテール値の\n    積に等しいエネルギーが放出されます。\n\n    最大エネルギー放出を見つけるために、関数はビーズを合体させるすべての可能な順序を考慮し、\n    動的プログラミングを使用して得られる最大エネルギーを計算します。\n\n    引数:\n        beads: 各整数がビーズのヘッド値と前のビーズのテール値を表す整数のリスト。\n               ネックレスの円形の性質により、最後のビーズのテール値は最初のビーズの\n               ヘッド値と一致すると仮定されます。\n\n    戻り値:\n        すべてのビーズを最適に合体させることで得られる最大エネルギーを表す整数。\n\n    例:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "ko": "def max_energy(beads):\n    \"\"\"\n    목걸이의 구슬을 합쳐서 방출할 수 있는 최대 에너지를 계산합니다.\n\n    이 함수는 목걸이의 에너지 구슬을 나타내는 정수 리스트를 입력으로 받습니다. \n    각 구슬은 머리와 꼬리 값을 가지고 있으며, 각 구슬의 머리 값은 다음 구슬의 꼬리 값과 일치해야 합니다. \n    목걸이는 원형이며, 인접한 두 구슬을 합치면 첫 번째 구슬의 머리 값, 일치하는 값, 두 번째 구슬의 꼬리 값의 곱에 해당하는 에너지가 방출됩니다.\n\n    최대 에너지 방출을 찾기 위해, 이 함수는 구슬을 합치는 모든 가능한 순서를 고려하고, \n    동적 프로그래밍을 사용하여 얻을 수 있는 최대 에너지를 계산합니다.\n\n    Args:\n        beads: 각 정수가 구슬의 머리 값을 나타내며, 이전 구슬의 꼬리 값을 나타내는 정수 리스트입니다. \n               목걸이의 원형 특성으로 인해 마지막 구슬의 꼬리 값은 첫 번째 구슬의 머리 값과 일치한다고 가정합니다.\n\n    Returns:\n        모든 구슬을 최적으로 합쳐서 얻을 수 있는 최대 에너지를 나타내는 정수입니다.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "ml": "def max_energy(beads):\n    \"\"\"\n    മാലയിലെ മുത്തുകൾ ചേർത്ത് എത്രയധികം ഊർജ്ജം പുറത്തുവിടാൻ കഴിയുമെന്ന് കണക്കാക്കുക.\n\n    ഫംഗ്ഷൻ മാലയിലെ ഊർജ്ജ മുത്തുകൾ പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ ഒരു പട്ടിക എടുക്കുന്നു, \n    ഇവിടെ ഓരോ മുത്തിനും ഒരു തലയും വാലുമുണ്ട്. ഓരോ മുത്തിന്റെയും തല മൂല്യം \n    ശ്രേണിയിലെ അടുത്ത മുത്തിന്റെ വാൽ മൂല്യവുമായി പൊരുത്തപ്പെടണം. മാല വൃത്താകൃതിയിലുള്ളതാണ്, \n    കൂടാതെ രണ്ട് ചേർന്ന മുത്തുകൾ ചേർന്നാൽ ആദ്യ മുത്തിന്റെ തല മൂല്യത്തിന്റെ ഗുണനഫലം, \n    പൊരുത്തപ്പെടുന്ന മൂല്യം, രണ്ടാം മുത്തിന്റെ വാൽ മൂല്യം എന്നിവയുടെ ഗുണനഫലത്തിന് തുല്യമായ \n    ഊർജ്ജം പുറത്തുവിടുന്നു.\n\n    പരമാവധി ഊർജ്ജം പുറത്തുവിടാൻ, ഫംഗ്ഷൻ മുത്തുകൾ ചേർക്കാനുള്ള എല്ലാ സാധ്യതാപരമായ ക്രമങ്ങളും \n    പരിഗണിക്കുന്നു, കൂടാതെ പരമാവധി ഊർജ്ജം ലഭ്യമാക്കാൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിക്കുന്നു.\n\n    Args:\n        beads: ഓരോ പൂർണ്ണസംഖ്യയും ഒരു മുത്തിന്റെ തല മൂല്യവും \n               മുമ്പത്തെ മുത്തിന്റെ വാൽ മൂല്യവും പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ ഒരു പട്ടിക. \n               മാലയുടെ വൃത്താകൃതിയുടെ സ്വഭാവം കാരണം അവസാന മുത്തിന്റെ വാൽ മൂല്യം ആദ്യ \n               മുത്തിന്റെ തല മൂല്യവുമായി പൊരുത്തപ്പെടുമെന്ന് കരുതുന്നു.\n\n    Returns:\n        എല്ലാ മുത്തുകളും ഓപ്റ്റിമൽ ആയി ചേർത്തു ലഭിക്കാവുന്ന പരമാവധി ഊർജ്ജത്തെ പ്രതിനിധീകരിക്കുന്ന \n        ഒരു പൂർണ്ണസംഖ്യ.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"", "fa": "def max_energy(beads):\n    \"\"\"\n    حداکثر انرژی که می‌توان با ادغام مهره‌ها در یک گردنبند آزاد کرد را محاسبه کنید.\n\n    این تابع لیستی از اعداد صحیح را می‌گیرد که نشان‌دهنده انرژی مهره‌ها در یک گردنبند است، \n    جایی که هر مهره دارای یک مقدار سر و یک مقدار دم است. مقدار سر هر مهره باید با مقدار دم \n    مهره بعدی در دنباله مطابقت داشته باشد. گردنبند دایره‌ای است و ادغام دو مهره مجاور انرژی \n    برابر با حاصل‌ضرب مقدار سر مهره اول، مقدار مطابقت و مقدار دم مهره دوم آزاد می‌کند.\n\n    برای یافتن حداکثر آزادسازی انرژی، تابع تمام ترتیب‌های ممکن ادغام مهره‌ها را در نظر می‌گیرد \n    و از برنامه‌ریزی پویا برای محاسبه حداکثر انرژی قابل دستیابی استفاده می‌کند.\n\n    آرگومان‌ها:\n        beads: لیستی از اعداد صحیح که هر عدد نشان‌دهنده مقدار سر یک مهره و مقدار دم مهره \n               قبلی است. مقدار دم آخرین مهره به دلیل ماهیت دایره‌ای گردنبند فرض می‌شود که \n               با مقدار سر اولین مهره مطابقت دارد.\n\n    بازگشت:\n        یک عدد صحیح که نشان‌دهنده حداکثر انرژی است که می‌توان با ادغام بهینه همه مهره‌ها به دست آورد.\n\n    مثال‌ها:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\""}, "canonical_solution": "    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))", "instruction": {"en": "Write a python function 'def max_energy(beads):' to solve the following problem:\n\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    ", "sq": "Shkruani një funksion python 'def max_energy(beads):' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni energjinë maksimale që mund të lirohet duke bashkuar rruazat në një varëse.\n\n    Funksioni merr një listë të numrave të plotë që përfaqësojnë rruazat e energjisë në një varëse, ku\n    secila rruazë ka një vlerë koke dhe një vlerë bishti. Vlera e kokës së çdo rruaze duhet të përputhet me vlerën e bishtit\n    të rruazës tjetër në sekuencë. Varësja është rrethore, dhe bashkimi i dy rruazave ngjitur\n    liron energji të barabartë me produktin e vlerës së kokës së rruazës së parë, vlerës që përputhet,\n    dhe vlerës së bishtit të rruazës së dytë.\n\n    Për të gjetur lirimin maksimal të energjisë, funksioni konsideron të gjitha renditjet e mundshme të bashkimit të rruazave\n    dhe përdor programimin dinamik për të llogaritur energjinë maksimale të arritshme.\n\n    Args:\n        beads: Një listë e numrave të plotë ku secili numër përfaqëson vlerën e kokës së një rruaze dhe\n               vlerën e bishtit të rruazës së mëparshme. Vlera e bishtit të rruazës së fundit supozohet\n               të përputhet me vlerën e kokës së rruazës së parë për shkak të natyrës rrethore të varëses.\n\n    Returns:\n        Një numër i plotë që përfaqëson energjinë maksimale që mund të merret duke bashkuar optimalisht të gjitha rruazat.\n\n    Shembuj:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "hy": "Պայթոն ֆունկցիա 'def max_energy(beads):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել առավելագույն էներգիան, որը կարող է ազատվել վզնոցի վրա գնդիկները միացնելիս:\n\n    Ֆունկցիան ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է վզնոցի վրա գտնվող էներգիայի գնդիկները, որտեղ\n    յուրաքանչյուր գնդիկ ունի գլուխ և պոչ արժեք: Յուրաքանչյուր գնդիկի գլուխ արժեքը պետք է համընկնի հաջորդ գնդիկի\n    պոչ արժեքի հետ հաջորդականության մեջ: Վզնոցը շրջանաձև է, և երկու հարակից գնդիկների միացումը ազատում է էներգիա,\n    որը հավասար է առաջին գնդիկի գլուխ արժեքի, համընկնող արժեքի և երկրորդ գնդիկի պոչ արժեքի արտադրյալին:\n\n    Առավելագույն էներգիայի ազատումը գտնելու համար ֆունկցիան հաշվի է առնում գնդիկների միացման բոլոր հնարավոր\n    կարգերը և օգտագործում է դինամիկ ծրագրավորում՝ առավելագույն էներգիան հաշվարկելու համար:\n\n    Արգումենտներ:\n        beads: Ամբողջ թվերի ցուցակ, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է գնդիկի գլուխ արժեքը և\n               նախորդ գնդիկի պոչ արժեքը: Վերջին գնդիկի պոչ արժեքը համարվում է, որ համընկնում է առաջին գնդիկի\n               գլուխ արժեքի հետ՝ վզնոցի շրջանաձև բնույթի պատճառով:\n\n    Վերադարձնում է:\n        Ամբողջ թիվ, որը ներկայացնում է առավելագույն էներգիան, որը կարող է ստացվել բոլոր գնդիկները օպտիմալ\n        միացնելիս:\n\n    Օրինակներ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "bn": "একটি পাইথন ফাংশন 'def max_energy(beads):' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    নেকলেসে থাকা পুঁতিগুলিকে একত্রিত করে যে সর্বাধিক শক্তি মুক্তি পেতে পারে তা গণনা করুন।\n\n    ফাংশনটি একটি পূর্ণসংখ্যার তালিকা গ্রহণ করে যা নেকলেসে থাকা শক্তি পুঁতিগুলিকে উপস্থাপন করে, যেখানে\n    প্রতিটি পুঁতির একটি মাথা এবং একটি লেজ মান থাকে। প্রতিটি পুঁতির মাথার মান অবশ্যই ক্রমানুসারে পরবর্তী পুঁতির\n    লেজের মানের সাথে মেলাতে হবে। নেকলেসটি বৃত্তাকার, এবং দুটি সংলগ্ন পুঁতিকে একত্রিত করলে প্রথম পুঁতির মাথার মান,\n    মিলিত মান এবং দ্বিতীয় পুঁতির লেজের মানের গুণফলের সমান শক্তি মুক্তি পায়।\n\n    সর্বাধিক শক্তি মুক্তি খুঁজে পেতে, ফাংশনটি পুঁতিগুলিকে একত্রিত করার সমস্ত সম্ভাব্য ক্রম বিবেচনা করে\n    এবং সর্বাধিক প্রাপ্তিযোগ্য শক্তি গণনা করতে ডাইনামিক প্রোগ্রামিং ব্যবহার করে।\n\n    আর্গস:\n        beads: পূর্ণসংখ্যার একটি তালিকা যেখানে প্রতিটি পূর্ণসংখ্যা একটি পুঁতির মাথার মান এবং\n               পূর্ববর্তী পুঁতির লেজের মান উপস্থাপন করে। নেকলেসের বৃত্তাকার প্রকৃতির কারণে\n               শেষ পুঁতির লেজের মান প্রথম পুঁতির মাথার মানের সাথে মেলানোর অনুমান করা হয়।\n\n    রিটার্নস:\n        একটি পূর্ণসংখ্যা যা সমস্ত পুঁতিকে সর্বোত্তমভাবে একত্রিত করে প্রাপ্ত সর্বাধিক শক্তি উপস্থাপন করে।\n\n    উদাহরণ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "bg": "Напишете Python функция 'def max_energy(beads):', за да решите следния проблем:\n\n    Изчислете максималната енергия, която може да бъде освободена чрез сливане на мъниста на огърлица.\n\n    Функцията приема списък от цели числа, представляващи енергийни мъниста на огърлица, където\n    всяко мънисто има стойност на глава и опашка. Стойността на главата на всяко мънисто трябва да съвпада със стойността на опашката\n    на следващото мънисто в последователността. Огърлицата е кръгова, и сливането на две съседни\n    мъниста освобождава енергия, равна на произведението от стойността на главата на първото мънисто, съвпадащата\n    стойност и стойността на опашката на второто мънисто.\n\n    За да намери максималното освобождаване на енергия, функцията разглежда всички възможни редове на сливане на мънистата\n    и използва динамично програмиране, за да изчисли максималната енергия, която може да бъде получена.\n\n    Аргументи:\n        beads: Списък от цели числа, където всяко число представлява стойността на главата на мънисто и\n               стойността на опашката на предходното мънисто. Стойността на опашката на последното мънисто се предполага\n               да съвпада със стойността на главата на първото мънисто поради кръговата природа на огърлицата.\n\n    Връща:\n        Цяло число, представляващо максималната енергия, която може да бъде получена чрез оптимално сливане на всички мъниста.\n\n    Примери:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "zh": "编写一个Python函数'def max_energy(beads):'来解决以下问题：\n\n    计算通过合并项链上的珠子可以释放的最大能量。\n\n    该函数接受一个整数列表，表示项链上的能量珠子，其中每个珠子都有一个头部和尾部值。每个珠子的头部值必须与序列中下一个珠子的尾部值匹配。项链是环形的，合并两个相邻的珠子释放的能量等于第一个珠子的头部值、匹配值和第二个珠子的尾部值的乘积。\n\n    为了找到最大能量释放，函数考虑所有可能的珠子合并顺序，并使用动态编程来计算可获得的最大能量。\n\n    参数：\n        beads: 一个整数列表，其中每个整数表示一个珠子的头部值和前一个珠子的尾部值。由于项链的环形特性，假设最后一个珠子的尾部值与第一个珠子的头部值匹配。\n\n    返回：\n        一个整数，表示通过最佳合并所有珠子可以获得的最大能量。\n\n    示例：\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "fr": "Écrivez une fonction python 'def max_energy(beads):' pour résoudre le problème suivant :\n\n    Calculer l'énergie maximale qui peut être libérée en fusionnant des perles sur un collier.\n\n    La fonction prend une liste d'entiers représentant les perles d'énergie sur un collier, où\n    chaque perle a une valeur de tête et de queue. La valeur de tête de chaque perle doit correspondre à la valeur de queue\n    de la perle suivante dans la séquence. Le collier est circulaire, et la fusion de deux perles adjacentes\n    libère une énergie égale au produit de la valeur de tête de la première perle, de la valeur correspondante,\n    et de la valeur de queue de la deuxième perle.\n\n    Pour trouver la libération d'énergie maximale, la fonction considère tous les ordres possibles de fusion des perles\n    et utilise la programmation dynamique pour calculer l'énergie maximale obtenable.\n\n    Args:\n        beads: Une liste d'entiers où chaque entier représente la valeur de tête d'une perle et\n               la valeur de queue de la perle précédente. La valeur de queue de la dernière perle est supposée\n               correspondre à la valeur de tête de la première perle en raison de la nature circulaire du collier.\n\n    Returns:\n        Un entier représentant l'énergie maximale qui peut être obtenue en fusionnant de manière optimale toutes les perles.\n\n    Exemples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "de": "Schreiben Sie eine Python-Funktion 'def max_energy(beads):', um das folgende Problem zu lösen:\n\n    Berechnen Sie die maximale Energie, die durch das Zusammenführen von Perlen auf einer Halskette freigesetzt werden kann.\n\n    Die Funktion nimmt eine Liste von ganzen Zahlen, die die Energieperlen auf einer Halskette darstellen, wobei\n    jede Perle einen Kopf- und einen Schwanzwert hat. Der Kopfwert jeder Perle muss mit dem Schwanzwert der nächsten\n    Perle in der Sequenz übereinstimmen. Die Halskette ist kreisförmig, und das Zusammenführen von zwei benachbarten\n    Perlen setzt Energie frei, die dem Produkt des Kopfwerts der ersten Perle, dem übereinstimmenden Wert und dem\n    Schwanzwert der zweiten Perle entspricht.\n\n    Um die maximale Energiefreisetzung zu finden, berücksichtigt die Funktion alle möglichen Reihenfolgen des\n    Zusammenführens von Perlen und verwendet dynamische Programmierung, um die maximal erreichbare Energie zu berechnen.\n\n    Argumente:\n        beads: Eine Liste von ganzen Zahlen, wobei jede ganze Zahl den Kopfwert einer Perle und den\n               Schwanzwert der vorherigen Perle darstellt. Der Schwanzwert der letzten Perle wird\n               aufgrund der kreisförmigen Natur der Halskette als mit dem Kopfwert der ersten Perle übereinstimmend angenommen.\n\n    Rückgabe:\n        Eine ganze Zahl, die die maximale Energie darstellt, die durch optimales Zusammenführen aller Perlen erzielt werden kann.\n\n    Beispiele:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "ha": "Rubuta aikin python 'def max_energy(beads):' don warware matsalar mai zuwa:\n\n    Lissafi iyakar kuzari da za a iya saki ta hanyar haɗa beads a kan abin wuya.\n\n    Aikin yana ɗaukar jerin lambobi masu wakiltar beads na kuzari a kan abin wuya, inda\n    kowanne bead yana da ƙima a kai da kuma ƙima a ƙasa. Dole ne ƙimar kai na kowanne bead yayi daidai da ƙimar ƙasa\n    na bead na gaba a jerin. Abin wuya yana da zagaye, kuma haɗa beads biyu masu makwabtaka\n    yana sakin kuzari daidai da samfurin ƙimar kai na bead na farko, ƙimar da ta dace,\n    da kuma ƙimar ƙasa na bead na biyu.\n\n    Don samun iyakar sakin kuzari, aikin yana la'akari da dukkan yiwuwar jerin haɗa beads\n    kuma yana amfani da shirye-shiryen motsi don ƙididdige iyakar kuzari da za a iya samu.\n\n    Args:\n        beads: Jerin lambobi inda kowanne lamba yana wakiltar ƙimar kai na bead da\n               ƙimar ƙasa na bead na baya. Ana ɗauka ƙimar ƙasa na bead na ƙarshe\n               yayi daidai da ƙimar kai na bead na farko saboda yanayin zagaye na abin wuya.\n\n    Returns:\n        Lamba mai wakiltar iyakar kuzari da za a iya samu ta hanyar haɗa duk beads da kyau.\n\n    Misalai:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "hi": "एक पायथन फ़ंक्शन 'def max_energy(beads):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    हार के मोतियों को मिलाकर जारी की जा सकने वाली अधिकतम ऊर्जा की गणना करें।\n\n    फ़ंक्शन एक पूर्णांकों की सूची लेता है जो हार पर ऊर्जा मोतियों का प्रतिनिधित्व करती है, जहां\n    प्रत्येक मोती का एक सिर और एक पूंछ मान होता है। अनुक्रम में अगले मोती के पूंछ मान से\n    प्रत्येक मोती का सिर मान मेल खाना चाहिए। हार वृत्ताकार है, और दो आसन्न\n    मोतियों को मिलाने पर ऊर्जा जारी होती है जो पहले मोती के सिर मान, मिलान\n    मान, और दूसरे मोती के पूंछ मान के गुणनफल के बराबर होती है।\n\n    अधिकतम ऊर्जा रिलीज़ खोजने के लिए, फ़ंक्शन मोतियों को मिलाने के सभी संभावित क्रमों पर विचार करता है\n    और प्राप्त की जा सकने वाली अधिकतम ऊर्जा की गणना करने के लिए गतिशील प्रोग्रामिंग का उपयोग करता है।\n\n    तर्क:\n        beads: पूर्णांकों की एक सूची जहां प्रत्येक पूर्णांक एक मोती के सिर मान का प्रतिनिधित्व करता है और\n               पिछले मोती का पूंछ मान। हार की वृत्ताकार प्रकृति के कारण अंतिम मोती का पूंछ मान\n               पहले मोती के सिर मान से मेल खाने वाला माना जाता है।\n\n    लौटाता है:\n        एक पूर्णांक जो सभी मोतियों को अनुकूल रूप से मिलाकर प्राप्त की जा सकने वाली अधिकतम ऊर्जा का प्रतिनिधित्व करता है।\n\n    उदाहरण:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "hu": "Írj egy python függvényt 'def max_energy(beads):' a következő probléma megoldására:\n\n    Számítsd ki a maximális energiát, amely felszabadítható a gyöngyök összefűzésével egy nyakláncon.\n\n    A függvény egy egész számokból álló listát vesz át, amely a nyaklánc gyöngyeinek energiáját képviseli, ahol\n    minden gyöngynek van egy fej- és egy farokértéke. Minden gyöngy fejértékének meg kell egyeznie a következő\n    gyöngy farokértékével a sorozatban. A nyaklánc körkörös, és két szomszédos gyöngy összefűzése olyan energiát\n    szabadít fel, amely egyenlő az első gyöngy fejértékének, az egyező értéknek és a második gyöngy farokértékének\n    szorzatával.\n\n    A maximális energia felszabadításának megtalálásához a függvény figyelembe veszi a gyöngyök összefűzésének\n    összes lehetséges sorrendjét, és dinamikus programozást használ a maximálisan elérhető energia kiszámításához.\n\n    Paraméterek:\n        beads: Egy egész számokból álló lista, ahol minden egész szám egy gyöngy fejértékét és az előző\n               gyöngy farokértékét képviseli. Az utolsó gyöngy farokértéke a nyaklánc körkörös jellege miatt\n               feltételezhetően megegyezik az első gyöngy fejértékével.\n\n    Visszatér:\n        Egy egész szám, amely a gyöngyök optimális összefűzésével elérhető maximális energiát képviseli.\n\n    Példák:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "es": "Escribe una función de Python 'def max_energy(beads):' para resolver el siguiente problema:\n\n    Calcular la energía máxima que se puede liberar al fusionar cuentas en un collar.\n\n    La función toma una lista de enteros que representan las cuentas de energía en un collar, donde\n    cada cuenta tiene un valor de cabeza y un valor de cola. El valor de cabeza de cada cuenta debe coincidir con el valor de cola\n    de la siguiente cuenta en la secuencia. El collar es circular, y fusionar dos cuentas adyacentes\n    libera energía igual al producto del valor de cabeza de la primera cuenta, el valor coincidente, y el valor de cola de la segunda cuenta.\n\n    Para encontrar la liberación máxima de energía, la función considera todos los posibles órdenes de fusión de cuentas\n    y utiliza programación dinámica para calcular la energía máxima obtenible.\n\n    Argumentos:\n        beads: Una lista de enteros donde cada entero representa el valor de cabeza de una cuenta y\n               el valor de cola de la cuenta anterior. Se asume que el valor de cola de la última cuenta coincide\n               con el valor de cabeza de la primera cuenta debido a la naturaleza circular del collar.\n\n    Devuelve:\n        Un entero que representa la energía máxima que se puede obtener al fusionar óptimamente todas las cuentas.\n\n    Ejemplos:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "arb": "اكتب دالة بايثون 'def max_energy(beads):' لحل المشكلة التالية:\n\n    حساب الحد الأقصى للطاقة التي يمكن إطلاقها عن طريق دمج الخرزات في عقد.\n\n    تأخذ الدالة قائمة من الأعداد الصحيحة التي تمثل خرزات الطاقة في عقد، حيث\n    كل خرزة لها قيمة رأس وقيمة ذيل. يجب أن تتطابق قيمة الرأس لكل خرزة مع قيمة الذيل\n    للخرزة التالية في التسلسل. العقد دائري، ودمج خرزتين متجاورتين يطلق طاقة تساوي حاصل ضرب قيمة الرأس للخرزة الأولى، والقيمة المطابقة، وقيمة الذيل للخرزة الثانية.\n\n    لإيجاد الحد الأقصى لإطلاق الطاقة، تأخذ الدالة في الاعتبار جميع أوامر دمج الخرزات الممكنة\n    وتستخدم البرمجة الديناميكية لحساب الحد الأقصى للطاقة الممكن الحصول عليها.\n\n    يعيدالحجج:\n        beads: قائمة من الأعداد الصحيحة حيث يمثل كل عدد صحيح قيمة الرأس لخرزة و\n               قيمة الذيل للخرزة السابقة. يُفترض أن قيمة الذيل للخرزة الأخيرة تتطابق\n               مع قيمة الرأس للخرزة الأولى بسبب الطبيعة الدائرية للعقد.\n\n    يعيد:\n        عدد صحيح يمثل الحد الأقصى للطاقة التي يمكن الحصول عليها عن طريق دمج جميع الخرزات بشكل مثالي.\n\n    أمثلة:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "sw": "Andika kazi ya python 'def max_energy(beads):' kutatua tatizo lifuatalo:\n\n    Hesabu nishati ya juu zaidi inayoweza kutolewa kwa kuunganisha shanga kwenye mkufu.\n\n    Kazi inachukua orodha ya nambari za mzima zinazowakilisha shanga za nishati kwenye mkufu, ambapo\n    kila shanga ina thamani ya kichwa na mkia. Thamani ya kichwa ya kila shanga lazima ilingane na thamani ya mkia\n    ya shanga inayofuata katika mlolongo. Mkufu ni wa mviringo, na kuunganisha shanga mbili zinazofuatana\n    hutoa nishati sawa na bidhaa ya thamani ya kichwa ya shanga ya kwanza, thamani inayolingana, na thamani ya mkia ya shanga ya pili.\n\n    Ili kupata utoaji wa nishati ya juu zaidi, kazi inazingatia mpangilio wote unaowezekana wa kuunganisha shanga\n    na hutumia programu ya nguvu ili kuhesabu nishati ya juu inayoweza kupatikana.\n\n    Hoja:\n        beads: Orodha ya nambari za mzima ambapo kila nambari inawakilisha thamani ya kichwa ya shanga na\n               thamani ya mkia ya shanga iliyopita. Thamani ya mkia ya shanga ya mwisho inadhaniwa\n               kulingana na thamani ya kichwa ya shanga ya kwanza kutokana na asili ya mviringo ya mkufu.\n\n    Inarejesha:\n        Nambari ya mzima inayowakilisha nishati ya juu zaidi inayoweza kupatikana kwa kuunganisha shanga zote kwa njia bora.\n\n    Mifano:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "tr": "Bir python fonksiyonu 'def max_energy(beads):' yazarak aşağıdaki problemi çözün:\n\n    Bir kolyedeki boncukları birleştirerek açığa çıkabilecek maksimum enerjiyi hesaplayın.\n\n    Fonksiyon, bir kolyedeki enerji boncuklarını temsil eden bir tamsayı listesini alır, burada\n    her boncuğun bir baş ve bir kuyruk değeri vardır. Her boncuğun baş değeri, dizideki bir sonraki boncuğun\n    kuyruk değeri ile eşleşmelidir. Kolyenin yapısı daireseldir ve iki bitişik boncuğu birleştirmek,\n    ilk boncuğun baş değeri, eşleşen değer ve ikinci boncuğun kuyruk değerinin çarpımına eşit enerji açığa çıkarır.\n\n    Maksimum enerji açığa çıkışını bulmak için, fonksiyon boncukları birleştirmenin tüm olası sıralarını dikkate alır\n    ve elde edilebilecek maksimum enerjiyi hesaplamak için dinamik programlama kullanır.\n\n    Argümanlar:\n        beads: Her tamsayının bir boncuğun baş değerini ve\n               önceki boncuğun kuyruk değerini temsil ettiği bir tamsayı listesi. Kolyenin dairesel doğası\n               nedeniyle son boncuğun kuyruk değerinin ilk boncuğun baş değeri ile eşleştiği varsayılır.\n\n    Döndürür:\n        Tüm boncukları optimal bir şekilde birleştirerek elde edilebilecek maksimum enerjiyi temsil eden bir tamsayı.\n\n    Örnekler:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "vi": "Viết một hàm python 'def max_energy(beads):' để giải quyết vấn đề sau:\n\n    Tính toán năng lượng tối đa có thể được phát ra bằng cách hợp nhất các hạt trên một chuỗi hạt.\n\n    Hàm nhận một danh sách các số nguyên đại diện cho năng lượng của các hạt trên một chuỗi hạt, trong đó\n    mỗi hạt có một giá trị đầu và một giá trị đuôi. Giá trị đầu của mỗi hạt phải khớp với giá trị đuôi\n    của hạt tiếp theo trong chuỗi. Chuỗi hạt là vòng tròn, và việc hợp nhất hai hạt liền kề\n    phát ra năng lượng bằng tích của giá trị đầu của hạt thứ nhất, giá trị khớp,\n    và giá trị đuôi của hạt thứ hai.\n\n    Để tìm năng lượng phát ra tối đa, hàm xem xét tất cả các thứ tự hợp nhất hạt có thể\n    và sử dụng lập trình động để tính toán năng lượng tối đa có thể đạt được.\n\n    Tham số:\n        beads: Một danh sách các số nguyên trong đó mỗi số nguyên đại diện cho giá trị đầu của một hạt và\n               giá trị đuôi của hạt trước đó. Giá trị đuôi của hạt cuối cùng được giả định\n               là khớp với giá trị đầu của hạt đầu tiên do tính chất vòng tròn của chuỗi hạt.\n\n    Trả về:\n        Một số nguyên đại diện cho năng lượng tối đa có thể đạt được bằng cách hợp nhất tối ưu tất cả các hạt.\n\n    Ví dụ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "id": "Tulis fungsi python 'def max_energy(beads):' untuk menyelesaikan masalah berikut:\n\n    Hitung energi maksimum yang dapat dilepaskan dengan menggabungkan manik-manik pada kalung.\n\n    Fungsi ini menerima daftar bilangan bulat yang mewakili energi manik-manik pada kalung, di mana\n    setiap manik memiliki nilai kepala dan ekor. Nilai kepala dari setiap manik harus sesuai dengan nilai ekor\n    dari manik berikutnya dalam urutan. Kalung ini bersifat melingkar, dan menggabungkan dua manik yang berdekatan\n    melepaskan energi yang sama dengan hasil kali dari nilai kepala manik pertama, nilai yang cocok, dan nilai ekor manik kedua.\n\n    Untuk menemukan pelepasan energi maksimum, fungsi ini mempertimbangkan semua urutan penggabungan manik-manik\n    yang mungkin dan menggunakan pemrograman dinamis untuk menghitung energi maksimum yang dapat diperoleh.\n\n    Argumen:\n        beads: Daftar bilangan bulat di mana setiap bilangan bulat mewakili nilai kepala dari sebuah manik dan\n               nilai ekor dari manik sebelumnya. Nilai ekor dari manik terakhir diasumsikan\n               sesuai dengan nilai kepala dari manik pertama karena sifat melingkar dari kalung.\n\n    Mengembalikan:\n        Sebuah bilangan bulat yang mewakili energi maksimum yang dapat diperoleh dengan menggabungkan semua manik secara optimal.\n\n    Contoh:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "ja": "Python関数を書いてください。 'def max_energy(beads):' 次の問題を解決するために:\n\n    ネックレスのビーズを合体させることによって放出される最大エネルギーを計算します。\n\n    この関数は、ネックレス上のエネルギービーズを表す整数のリストを受け取ります。各ビーズには頭と尾の値があり、\n    各ビーズの頭の値は次のビーズの尾の値と一致しなければなりません。ネックレスは円形であり、\n    隣接する2つのビーズを合体させると、最初のビーズの頭の値、一致する値、および2番目のビーズの尾の値の積に等しいエネルギーが放出されます。\n\n    最大エネルギー放出を見つけるために、関数はビーズを合体させるすべての可能な順序を考慮し、\n    動的プログラミングを使用して得られる最大エネルギーを計算します。\n\n    引数:\n        beads: 各整数がビーズの頭の値と前のビーズの尾の値を表す整数のリスト。\n               ネックレスの円形の性質により、最後のビーズの尾の値は最初のビーズの頭の値と一致すると仮定されます。\n\n    戻り値:\n        すべてのビーズを最適に合体させることによって得られる最大エネルギーを表す整数。\n\n    例:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "ko": "파이썬 함수를 작성하세요 'def max_energy(beads):' 다음 문제를 해결하기 위해:\n\n    목걸이의 구슬을 합쳐서 방출할 수 있는 최대 에너지를 계산합니다.\n\n    이 함수는 목걸이의 에너지 구슬을 나타내는 정수 리스트를 받습니다. 각 구슬은 머리와 꼬리 값을 가지고 있으며, \n    각 구슬의 머리 값은 다음 구슬의 꼬리 값과 일치해야 합니다. 목걸이는 원형이며, 인접한 두 구슬을 합치면 \n    첫 번째 구슬의 머리 값, 일치하는 값, 두 번째 구슬의 꼬리 값의 곱에 해당하는 에너지가 방출됩니다.\n\n    최대 에너지 방출을 찾기 위해, 이 함수는 구슬을 합치는 모든 가능한 순서를 고려하고 \n    동적 프로그래밍을 사용하여 얻을 수 있는 최대 에너지를 계산합니다.\n\n    인수:\n        beads: 각 정수가 구슬의 머리 값을 나타내고 이전 구슬의 꼬리 값을 나타내는 정수 리스트입니다. \n               목걸이의 원형 특성 때문에 마지막 구슬의 꼬리 값은 첫 번째 구슬의 머리 값과 일치한다고 가정합니다.\n\n    반환:\n        모든 구슬을 최적으로 합쳐서 얻을 수 있는 최대 에너지를 나타내는 정수입니다.\n\n    예시:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "ml": "ഒരു പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക 'def max_energy(beads):' ഈ പ്രശ്നം പരിഹരിക്കാൻ:\n\n    മാലയിലെ മണികൾ ലയിപ്പിക്കുന്നതിലൂടെ പുറത്തുവരുന്ന പരമാവധി ഊർജ്ജം കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ മാലയിലെ ഊർജ്ജ മണികളെ പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ ഒരു പട്ടിക സ്വീകരിക്കുന്നു, \n    ഓരോ മണിക്കും ഒരു തലയും വാലുമുള്ള മൂല്യം ഉണ്ട്. ഓരോ മണിയുടെ തല മൂല്യം \n    പരമ്പരയിലെ അടുത്ത മണിയുടെ വാൽ മൂല്യവുമായി പൊരുത്തപ്പെടണം. മാല വൃത്താകൃതിയിലുള്ളതാണ്, \n    കൂടെ ചേർന്നിരിക്കുന്ന രണ്ട് മണികളെ ലയിപ്പിക്കുന്നത് ആദ്യ മണിയുടെ തല മൂല്യത്തിന്റെ ഗുണനഫലം, \n    പൊരുത്തപ്പെടുന്ന മൂല്യം, രണ്ടാം മണിയുടെ വാൽ മൂല്യം എന്നിവയുടെ ഗുണനഫലത്തിന് തുല്യമായ \n    ഊർജ്ജം പുറത്തുവിടുന്നു.\n\n    പരമാവധി ഊർജ്ജം പുറത്തുവിടാൻ, ഫംഗ്ഷൻ എല്ലാ സാധ്യതയുള്ള ലയിപ്പിക്കൽ ക്രമങ്ങളും പരിഗണിക്കുന്നു \n    കൂടാതെ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് ലഭ്യമായ പരമാവധി ഊർജ്ജം കണക്കാക്കുന്നു.\n\n    Args:\n        beads: ഓരോ പൂർണ്ണസംഖ്യയും ഒരു മണിയുടെ തല മൂല്യവും \n               മുമ്പത്തെ മണിയുടെ വാൽ മൂല്യവും പ്രതിനിധീകരിക്കുന്ന \n               പൂർണ്ണസംഖ്യകളുടെ ഒരു പട്ടിക. മാലയുടെ വൃത്താകൃതിയുടെ \n               സ്വഭാവം മൂലം അവസാന മണിയുടെ വാൽ മൂല്യം ആദ്യ \n               മണിയുടെ തല മൂല്യവുമായി പൊരുത്തപ്പെടുന്നു എന്ന് \n               കരുതുന്നു.\n\n    Returns:\n        എല്ലാ മണികളും ഉചിതമായി ലയിപ്പിക്കുന്നതിലൂടെ ലഭിക്കാവുന്ന \n        പരമാവധി ഊർജ്ജത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "fa": "یک تابع پایتون 'def max_energy(beads):' بنویسید تا مسئله زیر را حل کند:\n\n    حداکثر انرژی که می‌تواند با ادغام مهره‌ها در یک گردنبند آزاد شود را محاسبه کنید.\n\n    تابع یک لیست از اعداد صحیح که نشان‌دهنده انرژی مهره‌ها در یک گردنبند هستند را می‌گیرد، به طوری که\n    هر مهره دارای یک مقدار سر و یک مقدار دم است. مقدار سر هر مهره باید با مقدار دم\n    مهره بعدی در دنباله مطابقت داشته باشد. گردنبند دایره‌ای است و ادغام دو مهره مجاور\n    انرژی برابر با حاصل‌ضرب مقدار سر مهره اول، مقدار مطابقت و مقدار دم مهره دوم آزاد می‌کند.\n\n    برای یافتن حداکثر آزادسازی انرژی، تابع تمام ترتیب‌های ممکن ادغام مهره‌ها را در نظر می‌گیرد\n    و از برنامه‌ریزی پویا برای محاسبه حداکثر انرژی قابل دستیابی استفاده می‌کند.\n\n    آرگومان‌ها:\n        beads: یک لیست از اعداد صحیح که هر عدد نشان‌دهنده مقدار سر یک مهره و\n               مقدار دم مهره قبلی است. مقدار دم آخرین مهره به دلیل ماهیت دایره‌ای گردنبند فرض می‌شود\n               که با مقدار سر اولین مهره مطابقت دارد.\n\n    بازگشت:\n        یک عدد صحیح که نشان‌دهنده حداکثر انرژی است که می‌توان با ادغام بهینه تمام مهره‌ها به دست آورد.\n\n    مثال‌ها:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48"}, "level": "middle", "test": "def test_max_energy():\n    assert max_energy([2, 3, 5, 10]) == 710, \"Testcase 1 failed\"\n    assert max_energy([1, 2, 3, 4]) == 80, \"Testcase 2 failed\"\n    assert max_energy([4, 4, 4, 4]) == 192, \"Testcase 3 failed\"\n    assert max_energy([30, 40, 50, 60]) == 372000, \"Testcase 4 failed\"\n    print(\"All testcases passed\")\n\n# Call the test function\ntest_max_energy()", "entry_point": "max_energy", "signature": "def max_energy(beads):", "docstring": {"en": "\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    ", "sq": "\n    Llogarit energjinë maksimale që mund të lirohet duke bashkuar rruazat në një gjerdan.\n\n    Funksioni merr një listë të numrave të plotë që përfaqësojnë rruazat e energjisë në një gjerdan, ku\n    secila rruazë ka një vlerë koke dhe një vlerë bishti. Vlera e kokës së secilës rruazë duhet të përputhet\n    me vlerën e bishtit të rruazës së ardhshme në sekuencë. Gjerdani është rrethor, dhe bashkimi i dy rruazave\n    ngjitur liron energji të barabartë me produktin e vlerës së kokës së rruazës së parë, vlerës që përputhet,\n    dhe vlerës së bishtit të rruazës së dytë.\n\n    Për të gjetur lirimin maksimal të energjisë, funksioni konsideron të gjitha renditjet e mundshme të bashkimit\n    të rruazave dhe përdor programimin dinamik për të llogaritur energjinë maksimale të mundshme.\n\n    Argumentet:\n        beads: Një listë e numrave të plotë ku secili numër përfaqëson vlerën e kokës së një rruaze dhe\n               vlerën e bishtit të rruazës së mëparshme. Vlera e bishtit të rruazës së fundit supozohet\n               të përputhet me vlerën e kokës së rruazës së parë për shkak të natyrës rrethore të gjerdanit.\n\n    Kthen:\n        Një numër i plotë që përfaqëson energjinë maksimale që mund të merret duke bashkuar në mënyrë optimale të gjitha rruazat.\n\n    Shembuj:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "hy": "\n    Հաշվարկել առավելագույն էներգիան, որը կարող է ազատվել մարգարիտների միաձուլմամբ վզնոցի վրա:\n\n    Ֆունկցիան ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է վզնոցի վրա մարգարիտների էներգիան, որտեղ\n    յուրաքանչյուր մարգարիտ ունի գլխի և պոչի արժեք: Յուրաքանչյուր մարգարիտի գլխի արժեքը պետք է համընկնի հաջորդ մարգարիտի\n    պոչի արժեքի հետ հաջորդականության մեջ: Վզնոցը շրջանաձև է, և երկու հարակից մարգարիտների միաձուլումը ազատում է էներգիա,\n    որը հավասար է առաջին մարգարիտի գլխի արժեքի, համընկնող արժեքի և երկրորդ մարգարիտի պոչի արժեքի արտադրյալին:\n\n    Առավելագույն էներգիայի ազատումը գտնելու համար ֆունկցիան հաշվի է առնում մարգարիտների միաձուլման բոլոր հնարավոր\n    հերթականությունները և օգտագործում է դինամիկ ծրագրավորում առավելագույն էներգիան հաշվարկելու համար:\n\n    Արգումենտներ:\n        beads: Ամբողջ թվերի ցուցակ, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է մարգարիտի գլխի արժեքը և\n               նախորդ մարգարիտի պոչի արժեքը: Վերջին մարգարիտի պոչի արժեքը համարվում է, որ համընկնում է առաջին\n               մարգարիտի գլխի արժեքի հետ վզնոցի շրջանաձև բնույթի պատճառով:\n\n    Վերադարձնում է:\n        Ամբողջ թիվ, որը ներկայացնում է առավելագույն էներգիան, որը կարելի է ստանալ բոլոր մարգարիտները օպտիմալ\n        միաձուլմամբ:\n\n    Օրինակներ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "bn": "\n    নেকলেসের পুঁতি একত্রিত করে সর্বাধিক শক্তি কতটা মুক্তি পেতে পারে তা গণনা করুন।\n\n    ফাংশনটি একটি পূর্ণসংখ্যার তালিকা নেয় যা নেকলেসের পুঁতির শক্তিকে উপস্থাপন করে, যেখানে\n    প্রতিটি পুঁতির একটি মাথা এবং একটি লেজ মান থাকে। প্রতিটি পুঁতির মাথার মান অবশ্যই পরবর্তী পুঁতির লেজের\n    মানের সাথে মিলে যেতে হবে। নেকলেসটি বৃত্তাকার, এবং দুটি সংলগ্ন পুঁতি একত্রিত করলে প্রথম পুঁতির মাথার মান,\n    মিলিত মান এবং দ্বিতীয় পুঁতির লেজের মানের গুণফলের সমান শক্তি মুক্ত হয়।\n\n    সর্বাধিক শক্তি মুক্তি পেতে, ফাংশনটি পুঁতি একত্রিত করার সমস্ত সম্ভাব্য ক্রম বিবেচনা করে\n    এবং সর্বাধিক শক্তি প্রাপ্তির জন্য ডাইনামিক প্রোগ্রামিং ব্যবহার করে।\n\n    আর্গুমেন্টসমূহ:\n        beads: পূর্ণসংখ্যার একটি তালিকা যেখানে প্রতিটি পূর্ণসংখ্যা একটি পুঁতির মাথার মান এবং\n               পূর্ববর্তী পুঁতির লেজের মান উপস্থাপন করে। নেকলেসের বৃত্তাকার প্রকৃতির কারণে\n               শেষ পুঁতির লেজের মান প্রথম পুঁতির মাথার মানের সাথে মিলে যায় বলে ধরা হয়।\n\n    রিটার্নস:\n        একটি পূর্ণসংখ্যা যা সমস্ত পুঁতি সর্বোত্তমভাবে একত্রিত করে প্রাপ্ত সর্বাধিক শক্তিকে উপস্থাপন করে।\n\n    উদাহরণ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "bg": "\n    Изчислете максималната енергия, която може да бъде освободена чрез сливане на мъниста на огърлица.\n\n    Функцията приема списък от цели числа, представляващи енергийните мъниста на огърлица, където\n    всяко мънисто има стойност на глава и опашка. Стойността на главата на всяко мънисто трябва да съвпада със стойността на опашката\n    на следващото мънисто в последователността. Огърлицата е кръгова и сливането на две съседни\n    мъниста освобождава енергия, равна на произведението на стойността на главата на първото мънисто, съвпадащата\n    стойност и стойността на опашката на второто мънисто.\n\n    За да се намери максималното освобождаване на енергия, функцията разглежда всички възможни редове на сливане на мънистата\n    и използва динамично програмиране, за да изчисли максималната енергия, която може да бъде получена.\n\n    Аргументи:\n        beads: Списък от цели числа, където всяко число представлява стойността на главата на мънисто и\n               стойността на опашката на предишното мънисто. Стойността на опашката на последното мънисто се предполага,\n               че съвпада със стойността на главата на първото мънисто поради кръговия характер на огърлицата.\n\n    Връща:\n        Цяло число, представляващо максималната енергия, която може да бъде получена чрез оптимално сливане на всички мъниста.\n\n    Примери:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "zh": "\n    计算通过合并项链上的珠子可以释放的最大能量。\n\n    该函数接受一个整数列表，表示项链上的能量珠子，其中每个珠子有一个头值和一个尾值。\n    每个珠子的头值必须与序列中下一个珠子的尾值匹配。项链是圆形的，合并两个相邻的珠子\n    释放的能量等于第一个珠子的头值、匹配值和第二个珠子的尾值的乘积。\n\n    为了找到最大能量释放，函数考虑合并珠子的所有可能顺序，并使用动态规划计算可获得的最大能量。\n\n    参数:\n        beads: 一个整数列表，其中每个整数表示一个珠子的头值和前一个珠子的尾值。\n               由于项链的圆形特性，最后一个珠子的尾值假定与第一个珠子的头值匹配。\n\n    返回:\n        一个整数，表示通过最佳合并所有珠子可以获得的最大能量。\n\n    示例:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "fr": "\n    Calculer l'énergie maximale pouvant être libérée en fusionnant des perles sur un collier.\n\n    La fonction prend une liste d'entiers représentant les perles d'énergie sur un collier, où\n    chaque perle a une valeur de tête et une valeur de queue. La valeur de tête de chaque perle doit correspondre à la valeur de queue\n    de la perle suivante dans la séquence. Le collier est circulaire, et la fusion de deux perles adjacentes\n    libère une énergie égale au produit de la valeur de tête de la première perle, de la valeur correspondante,\n    et de la valeur de queue de la deuxième perle.\n\n    Pour trouver la libération d'énergie maximale, la fonction considère tous les ordres possibles de fusion des perles\n    et utilise la programmation dynamique pour calculer l'énergie maximale obtenable.\n\n    Args:\n        beads: Une liste d'entiers où chaque entier représente la valeur de tête d'une perle et\n               la valeur de queue de la perle précédente. La valeur de queue de la dernière perle est supposée\n               correspondre à la valeur de tête de la première perle en raison de la nature circulaire du collier.\n\n    Returns:\n        Un entier représentant l'énergie maximale pouvant être obtenue en fusionnant de manière optimale toutes les perles.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "de": "\n    Berechne die maximale Energie, die durch das Verschmelzen von Perlen auf einer Halskette freigesetzt werden kann.\n\n    Die Funktion nimmt eine Liste von ganzen Zahlen, die die Energieperlen auf einer Halskette darstellen, wobei\n    jede Perle einen Kopf- und einen Schwanzwert hat. Der Kopfwert jeder Perle muss mit dem Schwanzwert der nächsten\n    Perle in der Sequenz übereinstimmen. Die Halskette ist kreisförmig, und das Verschmelzen von zwei benachbarten\n    Perlen setzt Energie frei, die dem Produkt des Kopfwerts der ersten Perle, dem übereinstimmenden Wert und dem\n    Schwanzwert der zweiten Perle entspricht.\n\n    Um die maximale Energiefreisetzung zu finden, berücksichtigt die Funktion alle möglichen Reihenfolgen des\n    Verschmelzens von Perlen und verwendet dynamische Programmierung, um die maximal erreichbare Energie zu berechnen.\n\n    Argumente:\n        beads: Eine Liste von ganzen Zahlen, wobei jede Zahl den Kopfwert einer Perle und den Schwanzwert der\n               vorherigen Perle darstellt. Der Schwanzwert der letzten Perle wird aufgrund der kreisförmigen\n               Natur der Halskette als mit dem Kopfwert der ersten Perle übereinstimmend angenommen.\n\n    Rückgabe:\n        Eine ganze Zahl, die die maximale Energie darstellt, die durch optimales Verschmelzen aller Perlen\n        gewonnen werden kann.\n\n    Beispiele:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "ha": "\n    Lissafi mafi ƙarancin kuzari da za a iya sakin ta hanyar haɗa beads akan abin wuya.\n\n    Aikin yana ɗaukar jerin lambobi waɗanda ke wakiltar beads na kuzari akan abin wuya, inda\n    kowanne bead yana da ƙima ta gaba da ƙima ta baya. Dole ne ƙimar gaba ta kowanne bead ta dace da ƙimar baya\n    ta bead na gaba a jerin. Abin wuya yana zagaye, kuma haɗa beads biyu masu makwabtaka yana sakin kuzari\n    daidai da samfurin ƙimar gaba ta bead na farko, ƙimar da ta dace, da ƙimar baya ta bead na biyu.\n\n    Don nemo mafi ƙarancin sakin kuzari, aikin yana la'akari da dukkan yiwuwar oda na haɗa beads\n    kuma yana amfani da shirye-shiryen motsi don lissafin mafi ƙarancin kuzari da za a iya samu.\n\n    Args:\n        beads: Jerin lambobi inda kowanne lamba ke wakiltar ƙimar gaba ta bead da\n               ƙimar baya ta bead na baya. Ana ɗauka cewa ƙimar baya ta bead na ƙarshe ta dace\n               da ƙimar gaba ta bead na farko saboda yanayin zagaye na abin wuya.\n\n    Returns:\n        Lamba mai wakiltar mafi ƙarancin kuzari da za a iya samu ta hanyar haɗa duk beads cikin hikima.\n\n    Misalai:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "hi": "\n    हार के मोतियों को मिलाकर अधिकतम ऊर्जा की गणना करें।\n\n    यह फ़ंक्शन हार पर ऊर्जा मोतियों का प्रतिनिधित्व करने वाली पूर्णांकों की एक सूची लेता है, \n    जहाँ प्रत्येक मोती का एक सिर और एक पूंछ मान होता है। प्रत्येक मोती का सिर मान अनुक्रम में \n    अगले मोती के पूंछ मान से मेल खाना चाहिए। हार गोलाकार है, और दो आसन्न मोतियों को मिलाने से \n    ऊर्जा निकलती है जो पहले मोती के सिर मान, मिलान मान, और दूसरे मोती के पूंछ मान के गुणनफल के \n    बराबर होती है।\n\n    अधिकतम ऊर्जा रिलीज़ खोजने के लिए, फ़ंक्शन मोतियों को मिलाने के सभी संभावित क्रमों पर विचार \n    करता है और अधिकतम ऊर्जा प्राप्त करने के लिए डायनामिक प्रोग्रामिंग का उपयोग करता है।\n\n    तर्क:\n        beads: पूर्णांकों की एक सूची जहाँ प्रत्येक पूर्णांक एक मोती के सिर मान और पिछले मोती के \n               पूंछ मान का प्रतिनिधित्व करता है। हार की गोलाकार प्रकृति के कारण अंतिम मोती का \n               पूंछ मान पहले मोती के सिर मान से मेल खाने वाला माना जाता है।\n\n    वापसी:\n        एक पूर्णांक जो सभी मोतियों को अनुकूल रूप से मिलाकर प्राप्त की जा सकने वाली अधिकतम ऊर्जा \n        का प्रतिनिधित्व करता है।\n\n    उदाहरण:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "hu": "\n    Számítsa ki a maximális energiát, amely a gyöngyök egy nyakláncon történő összeolvasztásával szabadulhat fel.\n\n    A függvény egy egész számokból álló listát vesz át, amely a nyaklánc gyöngyeinek energiáját képviseli, ahol\n    minden gyöngynek van egy fej- és egy farokértéke. Minden gyöngy fejértékének meg kell egyeznie a következő\n    gyöngy farokértékével a sorozatban. A nyaklánc körkörös, és két szomszédos gyöngy összeolvasztása olyan energiát\n    szabadít fel, amely egyenlő az első gyöngy fejértékének, az egyező értéknek és a második gyöngy farokértékének\n    szorzatával.\n\n    A maximális energiafelszabadulás megtalálásához a függvény figyelembe veszi a gyöngyök összeolvasztásának\n    összes lehetséges sorrendjét, és dinamikus programozást használ a maximálisan elérhető energia kiszámításához.\n\n    Paraméterek:\n        beads: Egy egész számokból álló lista, ahol minden egész szám egy gyöngy fejértékét és az előző\n               gyöngy farokértékét képviseli. Az utolsó gyöngy farokértékét feltételezzük, hogy megegyezik\n               az első gyöngy fejértékével a nyaklánc körkörös jellege miatt.\n\n    Visszatér:\n        Egy egész szám, amely a gyöngyök optimális összeolvasztásával elérhető maximális energiát képviseli.\n\n    Példák:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "es": "    Calcular la energía máxima que se puede liberar al fusionar cuentas en un collar.\n\n    La función toma una lista de enteros que representan las cuentas de energía en un collar, donde\n    cada cuenta tiene un valor de cabeza y un valor de cola. El valor de cabeza de cada cuenta debe coincidir con el valor de cola de la siguiente cuenta en la secuencia. El collar es circular, y fusionar dos cuentas adyacentes libera energía igual al producto del valor de cabeza de la primera cuenta, el valor coincidente, y el valor de cola de la segunda cuenta.\n\n    Para encontrar la liberación máxima de energía, la función considera todos los posibles órdenes de fusión de cuentas\n    y utiliza programación dinámica para calcular la energía máxima obtenible.\n\n    Argumentos:\n        beads: Una lista de enteros donde cada entero representa el valor de cabeza de una cuenta y\n               el valor de cola de la cuenta anterior. Se asume que el valor de cola de la última cuenta coincide\n               con el valor de cabeza de la primera cuenta debido a la naturaleza circular del collar.\n\n    Devuelve:\n        Un entero que representa la energía máxima que se puede obtener al fusionar óptimamente todas las cuentas.\n\n    Ejemplos:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "arb": "    حساب أقصى طاقة يمكن إطلاقها عن طريق دمج الخرزات في عقد.\n\n    تأخذ الدالة قائمة من الأعداد الصحيحة التي تمثل خرزات الطاقة في عقد، حيث\n    كل خرزة لها قيمة رأس وقيمة ذيل. يجب أن تتطابق قيمة الرأس لكل خرزة مع قيمة الذيل\n    للخرزة التالية في التسلسل. العقد دائري، ودمج خرزتين متجاورتين يطلق طاقة تساوي\n    حاصل ضرب قيمة الرأس للخرزة الأولى، والقيمة المطابقة، وقيمة الذيل للخرزة الثانية.\n\n    للعثور على أقصى إطلاق للطاقة، تأخذ الدالة في الاعتبار جميع أوامر دمج الخرزات الممكنة\n    وتستخدم البرمجة الديناميكية لحساب أقصى طاقة يمكن الحصول عليها.\n\n    يعيدالحجج:\n        beads: قائمة من الأعداد الصحيحة حيث يمثل كل عدد صحيح قيمة الرأس لخرزة و\n               قيمة الذيل للخرزة السابقة. يُفترض أن تتطابق قيمة الذيل للخرزة الأخيرة\n               مع قيمة الرأس للخرزة الأولى بسبب الطبيعة الدائرية للعقد.\n\n    يعيد:\n        عدد صحيح يمثل أقصى طاقة يمكن الحصول عليها عن طريق دمج جميع الخرزات بشكل مثالي.\n\n    امثله:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "sw": "    Kuhesabu nishati ya juu kabisa inayoweza kutolewa kwa kuunganisha shanga kwenye mkufu.\n\n    Kazi inachukua orodha ya nambari za mzima zinazoashiria shanga za nishati kwenye mkufu, ambapo\n    kila shanga ina thamani ya kichwa na mkia. Thamani ya kichwa ya kila shanga lazima ilingane na thamani\n    ya mkia ya shanga inayofuata katika mlolongo. Mkufu ni wa mviringo, na kuunganisha shanga mbili\n    zinazofuatana hutoa nishati sawa na bidhaa ya thamani ya kichwa ya shanga ya kwanza, thamani inayolingana,\n    na thamani ya mkia ya shanga ya pili.\n\n    Ili kupata nishati ya juu kabisa inayotolewa, kazi inazingatia mpangilio wote wa uwezekano wa kuunganisha shanga\n    na hutumia programu ya nguvu kuhesabu nishati ya juu inayoweza kupatikana.\n\n    Hoja:\n        beads: Orodha ya nambari za mzima ambapo kila nambari inawakilisha thamani ya kichwa ya shanga na\n               thamani ya mkia ya shanga iliyotangulia. Thamani ya mkia ya shanga ya mwisho inachukuliwa\n               kulingana na thamani ya kichwa ya shanga ya kwanza kutokana na asili ya mviringo ya mkufu.\n\n    Inarudisha:\n        Nambari ya mzima inayowakilisha nishati ya juu kabisa inayoweza kupatikana kwa kuunganisha shanga zote kwa ufanisi.\n\n    Mifano:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "tr": "    Boncukları bir kolyede birleştirerek serbest bırakılabilecek maksimum enerjiyi hesaplayın.\n\n    Fonksiyon, bir kolyedeki enerji boncuklarını temsil eden bir tamsayı listesini alır, burada\n    her boncuğun bir baş ve bir kuyruk değeri vardır. Her boncuğun baş değeri, dizideki bir sonraki\n    boncuğun kuyruk değeriyle eşleşmelidir. Kolyenin yapısı daireseldir ve iki bitişik boncuğun\n    birleştirilmesi, ilk boncuğun baş değeri, eşleşen değer ve ikinci boncuğun kuyruk değerinin\n    çarpımına eşit enerji serbest bırakır.\n\n    Maksimum enerji serbest bırakılmasını bulmak için, fonksiyon boncukları birleştirmenin tüm\n    olası sıralarını dikkate alır ve elde edilebilecek maksimum enerjiyi hesaplamak için dinamik\n    programlama kullanır.\n\n    Argümanlar:\n        beads: Her tamsayının bir boncuğun baş değerini ve önceki boncuğun kuyruk değerini temsil\n               ettiği bir tamsayı listesi. Kolyenin dairesel yapısı nedeniyle son boncuğun kuyruk\n               değerinin ilk boncuğun baş değeriyle eşleştiği varsayılır.\n\n    Döndürür:\n        Tüm boncukları optimal bir şekilde birleştirerek elde edilebilecek maksimum enerjiyi temsil\n        eden bir tamsayı.\n\n    Örnekler:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "vi": "    Tính toán năng lượng tối đa có thể được giải phóng bằng cách hợp nhất các hạt trên một chuỗi hạt.\n\n    Hàm này nhận một danh sách các số nguyên đại diện cho các hạt năng lượng trên một chuỗi hạt, trong đó\n    mỗi hạt có một giá trị đầu và một giá trị đuôi. Giá trị đầu của mỗi hạt phải khớp với giá trị đuôi\n    của hạt tiếp theo trong chuỗi. Chuỗi hạt là vòng tròn, và việc hợp nhất hai hạt liền kề giải phóng\n    năng lượng bằng tích của giá trị đầu của hạt thứ nhất, giá trị khớp, và giá trị đuôi của hạt thứ hai.\n\n    Để tìm năng lượng giải phóng tối đa, hàm xem xét tất cả các thứ tự hợp nhất hạt có thể có\n    và sử dụng lập trình động để tính toán năng lượng tối đa có thể đạt được.\n\n    Tham số:\n        beads: Một danh sách các số nguyên trong đó mỗi số nguyên đại diện cho giá trị đầu của một hạt và\n               giá trị đuôi của hạt trước đó. Giá trị đuôi của hạt cuối cùng được giả định\n               khớp với giá trị đầu của hạt đầu tiên do tính chất vòng tròn của chuỗi hạt.\n\n    Trả về:\n        Một số nguyên đại diện cho năng lượng tối đa có thể đạt được bằng cách hợp nhất tối ưu tất cả các hạt.\n\n   Ví dụ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "id": "    Hitung energi maksimum yang dapat dilepaskan dengan menggabungkan manik-manik pada kalung.\n\n    Fungsi ini menerima daftar bilangan bulat yang mewakili manik-manik energi pada kalung, di mana\n    setiap manik memiliki nilai kepala dan ekor. Nilai kepala dari setiap manik harus sesuai dengan nilai ekor\n    dari manik berikutnya dalam urutan. Kalung ini berbentuk melingkar, dan penggabungan dua manik yang berdekatan\n    melepaskan energi yang sama dengan hasil kali dari nilai kepala manik pertama, nilai yang cocok,\n    dan nilai ekor manik kedua.\n\n    Untuk menemukan pelepasan energi maksimum, fungsi ini mempertimbangkan semua urutan penggabungan manik-manik yang mungkin\n    dan menggunakan pemrograman dinamis untuk menghitung energi maksimum yang dapat diperoleh.\n\n    Args:\n        beads: Daftar bilangan bulat di mana setiap bilangan bulat mewakili nilai kepala dari sebuah manik dan\n               nilai ekor dari manik sebelumnya. Nilai ekor dari manik terakhir diasumsikan\n               sesuai dengan nilai kepala dari manik pertama karena sifat melingkar dari kalung.\n\n    Returns:\n        Sebuah bilangan bulat yang mewakili energi maksimum yang dapat diperoleh dengan menggabungkan semua manik secara optimal.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "ja": "    ネックレスのビーズを合体させることで放出できる最大エネルギーを計算します。\n\n    この関数は、ネックレス上のエネルギービーズを表す整数のリストを受け取り、\n    各ビーズにはヘッドとテールの値があります。各ビーズのヘッド値は、シーケンス内の次のビーズの\n    テール値と一致する必要があります。ネックレスは円形で、隣接する2つのビーズを合体させると、\n    最初のビーズのヘッド値、一致する値、および2番目のビーズのテール値の積に等しいエネルギーが放出されます。\n\n    最大エネルギー放出を見つけるために、関数はビーズを合体させるすべての可能な順序を考慮し、\n    動的プログラミングを使用して得られる最大エネルギーを計算します。\n\n    引数:\n        beads: 各整数がビーズのヘッド値と前のビーズのテール値を表す整数のリスト。\n               ネックレスの円形の性質により、最後のビーズのテール値は最初のビーズのヘッド値と一致すると仮定されます。\n\n    戻り値:\n        すべてのビーズを最適に合体させることで得られる最大エネルギーを表す整数。\n\n    例:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "ko": "    목걸이의 구슬을 합쳐서 방출할 수 있는 최대 에너지를 계산합니다.\n\n    이 함수는 목걸이의 에너지 구슬을 나타내는 정수 리스트를 입력으로 받습니다. 각 구슬은 머리와 꼬리 값을 가지며, \n    각 구슬의 머리 값은 다음 구슬의 꼬리 값과 일치해야 합니다. 목걸이는 원형이며, 인접한 두 구슬을 합치면 \n    첫 번째 구슬의 머리 값, 일치하는 값, 두 번째 구슬의 꼬리 값의 곱에 해당하는 에너지가 방출됩니다.\n\n    최대 에너지 방출을 찾기 위해, 함수는 구슬을 합치는 모든 가능한 순서를 고려하고 \n    동적 프로그래밍을 사용하여 얻을 수 있는 최대 에너지를 계산합니다.\n\n    Args:\n        beads: 각 정수가 구슬의 머리 값을 나타내고 이전 구슬의 꼬리 값을 나타내는 정수 리스트입니다. \n               목걸이의 원형 특성상 마지막 구슬의 꼬리 값은 첫 번째 구슬의 머리 값과 일치한다고 가정합니다.\n\n    Returns:\n        모든 구슬을 최적으로 합쳐서 얻을 수 있는 최대 에너지를 나타내는 정수입니다.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "ml": "    മാലയിലുള്ള മുത്തുകൾ ചേർത്ത് പരമാവധി ഊർജ്ജം പുറത്തെടുക്കുക.\n\n    ഫംഗ്ഷൻ ഒരു ലിസ്റ്റ് പാരാമീറ്ററായി സ്വീകരിക്കുന്നു, ഇത് മാലയിലെ മുത്തുകളുടെ ഊർജ്ജത്തെ പ്രതിനിധീകരിക്കുന്നു, \n    ഓരോ മുത്തിനും ഒരു തലയും വാലുമുള്ള മൂല്യമുണ്ട്. ഓരോ മുത്തിന്റെയും തല മൂല്യം \n    പരമ്പരയിലെ അടുത്ത മുത്തിന്റെ വാൽ മൂല്യത്തോട് പൊരുത്തപ്പെടണം. മാല വൃത്താകൃതിയിലുള്ളതാണ്, \n    കൂടെ ചേർന്നിരിക്കുന്ന രണ്ട് മുത്തുകൾ ചേർക്കുമ്പോൾ ആദ്യ മുത്തിന്റെ തല മൂല്യം, \n    പൊരുത്തപ്പെടുന്ന മൂല്യം, രണ്ടാമത്തെ മുത്തിന്റെ വാൽ മൂല്യം എന്നിവയുടെ ഗുണഫലത്തിന് തുല്യമായ ഊർജ്ജം പുറത്തുവരുന്നു.\n\n    പരമാവധി ഊർജ്ജം പുറത്തെടുക്കാൻ, ഫംഗ്ഷൻ മുത്തുകൾ ചേർക്കാനുള്ള എല്ലാ സാധ്യതയുള്ള ക്രമങ്ങളും പരിഗണിക്കുന്നു \n    കൂടാതെ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് പരമാവധി ലഭ്യമായ ഊർജ്ജം കണക്കാക്കുന്നു.\n\n    Args:\n        beads: ഓരോ പൂർണ്ണസംഖ്യയും ഒരു മുത്തിന്റെ തല മൂല്യവും മുൻമുത്തിന്റെ വാൽ മൂല്യവും പ്രതിനിധീകരിക്കുന്ന \n               പൂർണ്ണസംഖ്യകളുടെ ഒരു ലിസ്റ്റ്. മാലയുടെ വൃത്താകൃതിയായ സ്വഭാവം കാരണം \n               അവസാന മുത്തിന്റെ വാൽ മൂല്യം ആദ്യ മുത്തിന്റെ തല മൂല്യത്തോട് പൊരുത്തപ്പെടുമെന്ന് കരുതുന്നു.\n\n    Returns:\n        മുത്തുകൾ ഒപ്റ്റിമലായി ചേർത്ത് പരമാവധി ലഭ്യമാകുന്ന ഊർജ്ജത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യ.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48", "fa": "محاسبه حداکثر انرژی که می‌تواند با ادغام مهره‌ها روی یک گردنبند آزاد شود.\n\nتابع یک لیست از اعداد صحیح را می‌گیرد که نمایانگر مهره‌های انرژی روی یک گردنبند هستند، جایی که هر مهره دارای یک مقدار سر و یک مقدار دم است. مقدار سر هر مهره باید با مقدار دم مهره بعدی در دنباله مطابقت داشته باشد. گردنبند دایره‌ای است و ادغام دو مهره مجاور انرژی‌ای برابر با حاصل‌ضرب مقدار سر مهره اول، مقدار مطابقت، و مقدار دم مهره دوم آزاد می‌کند.\n\nبرای یافتن حداکثر آزادسازی انرژی، تابع تمام ترتیب‌های ممکن ادغام مهره‌ها را در نظر می‌گیرد و از برنامه‌ریزی پویا برای محاسبه حداکثر انرژی قابل دستیابی استفاده می‌کند.\n\nآرگومان‌ها:\n    beads: لیستی از اعداد صحیح که هر عدد نمایانگر مقدار سر یک مهره و مقدار دم مهره قبلی است. مقدار دم آخرین مهره به دلیل طبیعت دایره‌ای گردنبند فرض می‌شود که با مقدار سر اولین مهره مطابقت دارد.\n\nبازگشت:\n    یک عدد صحیح که نمایانگر حداکثر انرژی‌ای است که می‌تواند با ادغام بهینه تمام مهره‌ها به دست آید.\n\nمثال‌ها:\n    >>> max_energy([2, 3, 5, 10])\n    710\n    >>> max_energy([1, 2, 3, 4])\n    48"}}
{"task_id": "Python/20", "prompt": {"en": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "sq": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Konverton një listë të koeficientëve të polinomit në një përfaqësim të formatuar si varg.\n\n    Funksioni merr shkallën më të lartë `n` të polinomit dhe një listë të koeficientëve `coeffs`,\n    të cilët janë të renditur nga termi me shkallën më të lartë deri te termi konstant. Ai kthen një varg që\n    përfaqëson polinomin me rregullat e mëposhtme:\n    - Termat me një koeficient zero janë të lënë jashtë.\n    - Shenja e secilit term përcaktohet (+ për pozitiv, - për negativ), pa '+' në fillim për termi i parë.\n    - Vlera absolute e koeficientit tregohet përveç nëse është 1 dhe termi përfshin variablën `x`.\n    - Pjesa e variablës formatohet bazuar në shkallën e saj; `x^degree` për shkallë > 1, `x` për shkallë 1, dhe\n      asgjë për shkallë 0 (termi konstant).\n    - Termat janë të bashkuar pa hapësira shtesë, duke filluar me termi me shkallën më të lartë.\n\n    Args:\n        n (int): Shkalla më e lartë e polinomit.\n        coeffs (List[int]): Një listë e koeficientëve, duke filluar me koeficientin e termit me shkallën më të lartë.\n\n    Returns:\n        str: Përfaqësimi si varg i polinomit.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "hy": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Վերածում է բազմապատկիչ գործակիցների ցուցակը ձևաչափված տողային ներկայացման:\n\n    Ֆունկցիան ընդունում է բազմապատկիչի ամենաբարձր աստիճանը `n` և գործակիցների ցուցակը `coeffs`,\n    որոնք դասավորված են ամենաբարձր աստիճանի անդամից մինչև հաստատուն անդամ: Այն վերադարձնում է տող,\n    որը ներկայացնում է բազմապատկիչը հետևյալ կանոններով:\n    - Գործակիցը զրո ունեցող անդամները բաց են թողնվում:\n    - Յուրաքանչյուր անդամի նշանը որոշվում է (+ դրականների համար, - բացասականների համար), առաջին անդամի համար\n      առանց առաջատար '+' նշանի:\n    - Գործակցի բացարձակ արժեքը ցուցադրվում է, եթե այն 1 չէ և անդամը պարունակում է փոփոխական `x`:\n    - Փոփոխականի մասը ձևաչափվում է ըստ նրա աստիճանի; `x^աստիճան` աստիճան > 1-ի համար, `x` 1-ի համար,\n      և ոչինչ 0-ի համար (հաստատուն անդամ):\n    - Անդամները միացվում են առանց լրացուցիչ բացատների, սկսելով ամենաբարձր աստիճանի անդամից:\n\n    Արգումենտներ:\n        n (int): Բազմապատկիչի ամենաբարձր աստիճանը:\n        coeffs (List[int]): Գործակիցների ցուցակ, սկսած ամենաբարձր աստիճանի անդամի գործակցից:\n\n    Վերադարձնում է:\n        str: Բազմապատկիչի տողային ներկայացումը:\n\n    Օրինակներ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "bn": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    একটি তালিকার পলিনোমিয়াল সহগগুলিকে একটি বিন্যাসিত স্ট্রিং উপস্থাপনায় রূপান্তর করে।\n\n    ফাংশনটি পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি `n` এবং সহগগুলির একটি তালিকা `coeffs` গ্রহণ করে,\n    যা সর্বোচ্চ ডিগ্রি পদ থেকে ধ্রুবক পদ পর্যন্ত ক্রমানুসারে সাজানো থাকে। এটি একটি স্ট্রিং ফেরত দেয় যা\n    নিম্নলিখিত নিয়মগুলির সাথে পলিনোমিয়ালকে উপস্থাপন করে:\n    - সহগ শূন্য হলে সেই পদ বাদ দেওয়া হয়।\n    - প্রতিটি পদের চিহ্ন নির্ধারিত হয় (+ ধনাত্মক, - ঋণাত্মক), প্রথম পদের জন্য কোন নেতৃস্থানীয় '+' নেই।\n    - সহগের পরম মান দেখানো হয় যদি না এটি 1 হয় এবং পদটিতে চলক `x` অন্তর্ভুক্ত থাকে।\n    - চলক অংশটি তার ডিগ্রির উপর ভিত্তি করে বিন্যাসিত হয়; ডিগ্রি > 1 এর জন্য `x^degree`, ডিগ্রি 1 এর জন্য `x`, এবং\n      ডিগ্রি 0 (ধ্রুবক পদ) এর জন্য কিছুই নয়।\n    - পদগুলি অতিরিক্ত স্পেস ছাড়াই যোগ করা হয়, সর্বোচ্চ ডিগ্রি পদ দিয়ে শুরু হয়।\n\n    Args:\n        n (int): পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি।\n        coeffs (List[int]): সহগগুলির একটি তালিকা, সর্বোচ্চ ডিগ্রি পদের সহগ দিয়ে শুরু।\n\n    Returns:\n        str: পলিনোমিয়ালের স্ট্রিং উপস্থাপনা।\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "bg": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Преобразува списък от коефициенти на полином в форматирано текстово представяне.\n\n    Функцията приема най-високата степен `n` на полинома и списък от коефициенти `coeffs`,\n    които са подредени от термина с най-висока степен до константния термин. Връща низ, който\n    представя полинома със следните правила:\n    - Термини с коефициент нула се пропускат.\n    - Знакът на всеки термин се определя (+ за положителен, - за отрицателен), без водещ '+' за първия термин.\n    - Абсолютната стойност на коефициента се показва, освен ако не е 1 и терминът включва променливата `x`.\n    - Променливата част се форматира въз основа на нейната степен; `x^степен` за степен > 1, `x` за степен 1, и\n      нищо за степен 0 (константен термин).\n    - Термините се съединяват без допълнителни интервали, започвайки с термина с най-висока степен.\n\n    Аргументи:\n        n (int): Най-високата степен на полинома.\n        coeffs (List[int]): Списък от коефициенти, започващ с коефициента на термина с най-висока степен.\n\n    Връща:\n        str: Текстовото представяне на полинома.\n\n    Примери:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "zh": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    将多项式系数列表转换为格式化的字符串表示。\n\n    该函数接收多项式的最高次 `n` 和一个系数列表 `coeffs`，\n    系数按从最高次项到常数项的顺序排列。它返回一个表示多项式的字符串，规则如下：\n    - 系数为零的项被省略。\n    - 每项的符号由其正负决定（正数为 +，负数为 -），首项不带前导 '+'。\n    - 系数的绝对值被显示，除非系数为 1 且该项包含变量 `x`。\n    - 变量部分根据其次数进行格式化；次数大于 1 时为 `x^degree`，次数为 1 时为 `x`，\n      常数项（次数为 0）则不显示变量。\n    - 项之间没有额外空格，按从最高次项开始连接。\n\n    参数:\n        n (int): 多项式的最高次。\n        coeffs (List[int]): 系数列表，从最高次项的系数开始。\n\n    返回:\n        str: 多项式的字符串表示。\n\n    示例:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "fr": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Convertit une liste de coefficients de polynôme en une représentation sous forme de chaîne formatée.\n\n    La fonction prend en entrée le degré le plus élevé `n` du polynôme et une liste de coefficients `coeffs`,\n    qui sont ordonnés du terme de degré le plus élevé au terme constant. Elle renvoie une chaîne qui\n    représente le polynôme avec les règles suivantes :\n    - Les termes avec un coefficient de zéro sont omis.\n    - Le signe de chaque terme est déterminé (+ pour positif, - pour négatif), sans '+' initial pour le premier terme.\n    - La valeur absolue du coefficient est affichée sauf si elle est 1 et que le terme inclut la variable `x`.\n    - La partie variable est formatée en fonction de son degré ; `x^degree` pour un degré > 1, `x` pour un degré 1, et\n      rien pour un degré 0 (terme constant).\n    - Les termes sont joints sans espaces supplémentaires, en commençant par le terme de degré le plus élevé.\n\n    Args:\n        n (int): Le degré le plus élevé du polynôme.\n        coeffs (List[int]): Une liste de coefficients, commençant par le coefficient du terme de degré le plus élevé.\n\n    Returns:\n        str: La représentation sous forme de chaîne du polynôme.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "de": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Wandelt eine Liste von Polynomkoeffizienten in eine formatierte Zeichenfolgenrepräsentation um.\n\n    Die Funktion nimmt den höchsten Grad `n` des Polynoms und eine Liste von Koeffizienten `coeffs` entgegen,\n    die von dem Term mit dem höchsten Grad bis zum konstanten Term geordnet sind. Sie gibt eine Zeichenfolge zurück,\n    die das Polynom mit den folgenden Regeln darstellt:\n    - Terme mit einem Koeffizienten von Null werden weggelassen.\n    - Das Vorzeichen jedes Terms wird bestimmt (+ für positiv, - für negativ), ohne führendes '+' für den ersten Term.\n    - Der Absolutwert des Koeffizienten wird angezeigt, es sei denn, er ist 1 und der Term enthält die Variable `x`.\n    - Der Variablenteil wird basierend auf seinem Grad formatiert; `x^degree` für Grad > 1, `x` für Grad 1 und\n      nichts für Grad 0 (konstanter Term).\n    - Terme werden ohne zusätzliche Leerzeichen verbunden, beginnend mit dem Term höchsten Grades.\n\n    Args:\n        n (int): Der höchste Grad des Polynoms.\n        coeffs (List[int]): Eine Liste von Koeffizienten, beginnend mit dem Koeffizienten des Terms höchsten Grades.\n\n    Returns:\n        str: Die Zeichenfolgenrepräsentation des Polynoms.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "ha": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Canza jerin lambobin polynomial zuwa tsari na rubutu da aka tsara.\n\n    Aikin yana karɓar mafi girman digiri `n` na polynomial da jerin lambobi `coeffs`,\n    waɗanda aka tsara daga mafi girman digiri zuwa kalmar akai-akai. Yana dawo da rubutu wanda\n    ke wakiltar polynomial tare da waɗannan ƙa'idodin:\n    - Ana cire kalmomin da ke da lamba na sifili.\n    - Ana ƙayyade alamar kowace kalma (+ don tabbatacce, - don korau), ba tare da jagorar '+' don kalma ta farko ba.\n    - Ana nuna ƙimar lamba sai dai idan yana da 1 kuma kalmar tana haɗa da canji `x`.\n    - Ana tsara sashin canji bisa ga digirinsa; `x^degree` don digiri > 1, `x` don digiri 1, da\n      babu komai don digiri 0 (kalmar akai-akai).\n    - Ana haɗa kalmomin ba tare da ƙarin sarari ba, farawa da kalmar mafi girman digiri.\n\n    Args:\n        n (int): Mafi girman digiri na polynomial.\n        coeffs (List[int]): Jerin lambobi, farawa da lambar mafi girman digiri.\n\n    Returns:\n        str: Wakilcin rubutu na polynomial.\n\n    Misalai:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "hi": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    बहुपद गुणांक की एक सूची को स्वरूपित स्ट्रिंग प्रतिनिधित्व में परिवर्तित करता है।\n\n    फ़ंक्शन बहुपद की उच्चतम डिग्री `n` और गुणांकों की एक सूची `coeffs` लेता है,\n    जो उच्चतम डिग्री पद से स्थिरांक पद तक क्रमबद्ध होते हैं। यह एक स्ट्रिंग लौटाता है जो\n    निम्नलिखित नियमों के साथ बहुपद का प्रतिनिधित्व करता है:\n    - जिन पदों का गुणांक शून्य होता है, उन्हें छोड़ दिया जाता है।\n    - प्रत्येक पद का चिह्न निर्धारित होता है (+ सकारात्मक के लिए, - नकारात्मक के लिए), पहले पद के लिए कोई अग्रणी '+' नहीं होता।\n    - गुणांक का परिमाण दिखाया जाता है जब तक कि यह 1 नहीं होता और पद में चर `x` शामिल होता है।\n    - चर भाग को उसकी डिग्री के आधार पर स्वरूपित किया जाता है; `x^degree` डिग्री > 1 के लिए, `x` डिग्री 1 के लिए, और\n      कुछ नहीं डिग्री 0 (स्थिरांक पद) के लिए।\n    - पदों को बिना अतिरिक्त स्थान के जोड़ा जाता है, उच्चतम डिग्री पद से शुरू होता है।\n\n    Args:\n        n (int): बहुपद की उच्चतम डिग्री।\n        coeffs (List[int]): गुणांकों की एक सूची, उच्चतम डिग्री पद के गुणांक से शुरू होती है।\n\n    Returns:\n        str: बहुपद का स्ट्रिंग प्रतिनिधित्व।\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "hu": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Egy polinomiális együtthatók listáját formázott karakterlánc-reprezentációvá alakítja.\n\n    A függvény megkapja a polinom legmagasabb fokszámát `n` és egy együtthatók listáját `coeffs`,\n    amelyek a legmagasabb fokszámú tagtól a konstans tagig vannak rendezve. Visszaad egy karakterláncot,\n    amely a következő szabályok szerint ábrázolja a polinomot:\n    - Azok a tagok, amelyek együtthatója nulla, kihagyásra kerülnek.\n    - Minden tag előjele meghatározásra kerül (+ a pozitív, - a negatív esetén), az első tag előtt nincs '+' jel.\n    - Az együttható abszolút értéke megjelenik, kivéve ha 1, és a tag tartalmazza az `x` változót.\n    - A változó rész a fokszám alapján formázódik; `x^fokszám` ha a fokszám > 1, `x` ha a fokszám 1, és\n      semmi ha a fokszám 0 (konstans tag).\n    - A tagok további szóközök nélkül csatlakoznak, a legmagasabb fokszámú taggal kezdve.\n\n    Args:\n        n (int): A polinom legmagasabb fokszáma.\n        coeffs (List[int]): Egy lista az együtthatókról, a legmagasabb fokszámú tag együtthatójával kezdve.\n\n    Returns:\n        str: A polinom karakterlánc-reprezentációja.\n\n    Példák:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "es": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Convierte una lista de coeficientes de un polinomio en una representación de cadena formateada.\n\n    La función recibe el grado más alto `n` del polinomio y una lista de coeficientes `coeffs`,\n    que están ordenados desde el término de mayor grado hasta el término constante. Devuelve una cadena que\n    representa el polinomio con las siguientes reglas:\n    - Se omiten los términos con un coeficiente de cero.\n    - El signo de cada término se determina (+ para positivo, - para negativo), sin un '+' inicial para el primer término.\n    - Se muestra el valor absoluto del coeficiente a menos que sea 1 y el término incluya la variable `x`.\n    - La parte variable se formatea según su grado; `x^degree` para grado > 1, `x` para grado 1, y\n      nada para grado 0 (término constante).\n    - Los términos se unen sin espacios adicionales, comenzando con el término de mayor grado.\n\n    Argumentos:\n        n (int): El grado más alto del polinomio.\n        coeffs (List[int]): Una lista de coeficientes, comenzando con el coeficiente del término de mayor grado.\n\n    Devuelve:\n        str: La representación en cadena del polinomio.\n\n    Ejemplos:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "arb": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    يحول قائمة من معاملات متعددة الحدود إلى تمثيل سلسلة منسق.\n\n    تأخذ الدالة أعلى درجة `n` لمتعددة الحدود وقائمة من المعاملات `coeffs`،\n    التي يتم ترتيبها من الحد ذو الدرجة الأعلى إلى الحد الثابت. تعيد سلسلة تمثل\n    متعددة الحدود بالقواعد التالية:\n    - يتم حذف الحدود ذات المعامل الصفري.\n    - يتم تحديد إشارة كل حد (+ للإيجابي، - للسالب)، بدون '+' في البداية للحد الأول.\n    - يتم عرض القيمة المطلقة للمعامل إلا إذا كانت 1 والحد يتضمن المتغير `x`.\n    - يتم تنسيق الجزء المتغير بناءً على درجته؛ `x^degree` للدرجة > 1، `x` للدرجة 1، ولا شيء للدرجة 0 (الحد الثابت).\n    - يتم ربط الحدود بدون مسافات إضافية، بدءًا من الحد ذو الدرجة الأعلى.\n\n    يعيدالحجج:\n        n (int): أعلى درجة لمتعددة الحدود.\n        coeffs (List[int]): قائمة من المعاملات، تبدأ بمعامل الحد ذو الدرجة الأعلى.\n\n    يعيد:\n        str: تمثيل السلسلة لمتعددة الحدود.\n\n    أمثلة:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "sw": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Hubadilisha orodha ya vigezo vya polinomu kuwa mwakilishi wa maandishi uliopangiliwa.\n\n    Kazi inachukua kiwango cha juu zaidi `n` cha polinomu na orodha ya vigezo `coeffs`,\n    ambavyo vimepangwa kutoka kwa kiwango cha juu zaidi hadi kwa neno la mara kwa mara. Inarudisha kamba ambayo\n    inawakilisha polinomu kwa sheria zifuatazo:\n    - Maneno yenye kigezo cha sifuri hayajumuishwi.\n    - Alama ya kila neno imedhamiriwa (+ kwa chanya, - kwa hasi), bila '+' inayoongoza kwa neno la kwanza.\n    - Thamani kamili ya kigezo inaonyeshwa isipokuwa ni 1 na neno linajumuisha kigezo `x`.\n    - Sehemu ya kigezo imepangwa kulingana na kiwango chake; `x^degree` kwa kiwango > 1, `x` kwa kiwango 1, na\n      hakuna kitu kwa kiwango 0 (neno la mara kwa mara).\n    - Maneno yanaunganishwa bila nafasi za ziada, yakianza na neno la kiwango cha juu zaidi.\n\n    Hoja:\n        n (int): Kiwango cha juu zaidi cha polinomu.\n        coeffs (List[int]): Orodha ya vigezo, kuanzia na kigezo cha neno la kiwango cha juu zaidi.\n\n    Inarejesha:\n        str: Mwakilishi wa maandishi wa polinomu.\n\n    Mifano:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "tr": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Bir polinom katsayıları listesini biçimlendirilmiş bir string gösterimine dönüştürür.\n\n    Fonksiyon, polinomun en yüksek derecesi `n` ve en yüksek dereceli terimden sabit terime kadar sıralanmış\n    bir katsayılar listesi `coeffs` alır. Aşağıdaki kurallarla polinomu temsil eden bir string döndürür:\n    - Katsayısı sıfır olan terimler atlanır.\n    - Her terimin işareti belirlenir (+ pozitif için, - negatif için), ilk terim için başta '+' yoktur.\n    - Katsayının mutlak değeri gösterilir, ancak katsayı 1 ise ve terim değişken `x` içeriyorsa gösterilmez.\n    - Değişken kısmı derecesine göre biçimlendirilir; derece > 1 için `x^derece`, derece 1 için `x` ve\n      derece 0 için (sabit terim) hiçbir şey.\n    - Terimler ek boşluklar olmadan birleştirilir, en yüksek dereceli terimle başlar.\n\n    Argümanlar:\n        n (int): Polinomun en yüksek derecesi.\n        coeffs (List[int]): En yüksek dereceli terimin katsayısı ile başlayan bir katsayılar listesi.\n\n    Döndürür:\n        str: Polinomun string gösterimi.\n\n    Örnekler:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "vi": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Chuyển đổi một danh sách các hệ số đa thức thành một chuỗi định dạng.\n\n    Hàm nhận vào bậc cao nhất `n` của đa thức và một danh sách các hệ số `coeffs`,\n    được sắp xếp từ bậc cao nhất đến hằng số. Nó trả về một chuỗi đại diện cho đa thức với các quy tắc sau:\n    - Các hạng tử có hệ số bằng không sẽ bị bỏ qua.\n    - Dấu của mỗi hạng tử được xác định (+ cho dương, - cho âm), không có dấu '+' đầu tiên cho hạng tử đầu tiên.\n    - Giá trị tuyệt đối của hệ số được hiển thị trừ khi nó là 1 và hạng tử bao gồm biến `x`.\n    - Phần biến được định dạng dựa trên bậc của nó; `x^degree` cho bậc > 1, `x` cho bậc 1, và\n      không có gì cho bậc 0 (hằng số).\n    - Các hạng tử được nối với nhau mà không có khoảng trắng bổ sung, bắt đầu với hạng tử có bậc cao nhất.\n\n    Tham số:\n        n (int): Bậc cao nhất của đa thức.\n        coeffs (List[int]): Một danh sách các hệ số, bắt đầu với hệ số của hạng tử có bậc cao nhất.\n\n    Trả về:\n        str: Chuỗi đại diện cho đa thức.\n\n    Ví dụ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "id": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Mengonversi daftar koefisien polinomial menjadi representasi string yang terformat.\n\n    Fungsi ini menerima derajat tertinggi `n` dari polinomial dan daftar koefisien `coeffs`,\n    yang diurutkan dari suku dengan derajat tertinggi hingga suku konstanta. Fungsi ini mengembalikan string yang\n    mewakili polinomial dengan aturan berikut:\n    - Suku dengan koefisien nol dihilangkan.\n    - Tanda dari setiap suku ditentukan (+ untuk positif, - untuk negatif), tanpa '+' di depan untuk suku pertama.\n    - Nilai absolut dari koefisien ditampilkan kecuali jika itu 1 dan suku tersebut termasuk variabel `x`.\n    - Bagian variabel diformat berdasarkan derajatnya; `x^degree` untuk derajat > 1, `x` untuk derajat 1, dan\n      tidak ada untuk derajat 0 (suku konstanta).\n    - Suku-suku digabungkan tanpa spasi tambahan, dimulai dengan suku dengan derajat tertinggi.\n\n    Args:\n        n (int): Derajat tertinggi dari polinomial.\n        coeffs (List[int]): Daftar koefisien, dimulai dengan koefisien dari suku dengan derajat tertinggi.\n\n    Returns:\n        str: Representasi string dari polinomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "ja": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    多項式の係数のリストをフォーマットされた文字列表現に変換します。\n\n    この関数は、多項式の最高次数 `n` と、最高次数の項から定数項まで順に並んだ係数のリスト `coeffs` を受け取り、\n    以下のルールに従って多項式を表す文字列を返します:\n    - 係数がゼロの項は省略されます。\n    - 各項の符号は決定されます（正の場合は +、負の場合は -）、最初の項には先頭の '+' はありません。\n    - 係数の絶対値は、変数 `x` を含む項で係数が 1 の場合を除いて表示されます。\n    - 変数部分はその次数に基づいてフォーマットされます。次数が 1 より大きい場合は `x^degree`、次数が 1 の場合は `x`、\n      定数項の場合は何も表示されません。\n    - 項は追加のスペースなしで結合され、最高次数の項から始まります。\n\n    引数:\n        n (int): 多項式の最高次数。\n        coeffs (List[int]): 最高次数の項の係数から始まる係数のリスト。\n\n    戻り値:\n        str: 多項式の文字列表現。\n\n    例:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "ko": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    다항식 계수 목록을 형식화된 문자열 표현으로 변환합니다.\n\n    이 함수는 다항식의 최고 차수 `n`과 계수 목록 `coeffs`를 입력으로 받아,\n    최고 차수 항부터 상수 항까지 순서대로 나열된 계수를 사용하여 다항식을 문자열로 반환합니다.\n    다음 규칙을 따릅니다:\n    - 계수가 0인 항은 생략됩니다.\n    - 각 항의 부호는 결정됩니다 (+는 양수, -는 음수), 첫 번째 항에는 선행 '+'가 없습니다.\n    - 계수의 절대값은 표시되지만, 변수가 포함된 항의 경우 계수가 1이면 표시되지 않습니다.\n    - 변수 부분은 차수에 따라 형식화됩니다; 차수가 1보다 크면 `x^degree`, 차수가 1이면 `x`, \n      차수가 0이면 아무것도 표시되지 않습니다 (상수 항).\n    - 항은 추가 공백 없이 연결되며, 최고 차수 항부터 시작합니다.\n\n    Args:\n        n (int): 다항식의 최고 차수.\n        coeffs (List[int]): 최고 차수 항의 계수부터 시작하는 계수 목록.\n\n    Returns:\n        str: 다항식의 문자열 표현.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "ml": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    പാളിനോമിയൽ ഗുണകങ്ങളുടെ പട്ടികയെ ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗ് പ്രതിനിധാനമായി മാറ്റുന്നു.\n\n    ഫംഗ്ഷൻ പാളിനോമിയലിന്റെ ഏറ്റവും ഉയർന്ന ബാഹുല്യം `n`യും ഗുണകങ്ങളുടെ പട്ടിക `coeffs`ഉം സ്വീകരിക്കുന്നു,\n    അത് ഏറ്റവും ഉയർന്ന ബാഹുല്യ പദം മുതൽ സ്ഥിര പദം വരെ ക്രമീകരിച്ചിരിക്കുന്നു. ഇത് പാളിനോമിയൽ പ്രതിനിധാനം ചെയ്യുന്ന ഒരു സ്ട്രിംഗ് തിരികെ നൽകുന്നു\n    താഴെ പറയുന്ന നിയമങ്ങൾക്കനുസരിച്ച്:\n    - ഗുണകം ശൂന്യമായ പദങ്ങൾ ഒഴിവാക്കപ്പെടുന്നു.\n    - ഓരോ പദത്തിന്റെ ചിഹ്നം നിർണ്ണയിക്കപ്പെടുന്നു (+ സാന്ദ്രമായതിനും - നെഗറ്റീവായതിനും), ആദ്യ പദത്തിനായി മുൻകൂട്ടി '+' ഇല്ലാതെ.\n    - ഗുണകത്തിന്റെ പരമാവധി മൂല്യം കാണിക്കുന്നു, അത് 1 അല്ലെങ്കിൽ പദം വ്യത്യാസം `x` ഉൾക്കൊള്ളുന്നില്ലെങ്കിൽ.\n    - വ്യത്യാസഭാഗം അതിന്റെ ബാഹുല്യത്തെ അടിസ്ഥാനമാക്കി ഫോർമാറ്റ് ചെയ്യുന്നു; `x^degree` ബാഹുല്യം > 1, `x` ബാഹുല്യം 1, \n      ഒന്നുമില്ല ബാഹുല്യം 0 (സ്ഥിര പദം) ആയപ്പോൾ.\n    - പദങ്ങൾ അധിക ഇടവിടങ്ങളില്ലാതെ ചേർക്കുന്നു, ഏറ്റവും ഉയർന്ന ബാഹുല്യ പദം കൊണ്ട് ആരംഭിക്കുന്നു.\n\n    Args:\n        n (int): പാളിനോമിയലിന്റെ ഏറ്റവും ഉയർന്ന ബാഹുല്യം.\n        coeffs (List[int]): ഏറ്റവും ഉയർന്ന ബാഹുല്യ പദത്തിന്റെ ഗുണകത്തോടെ ആരംഭിക്കുന്ന ഗുണകങ്ങളുടെ പട്ടിക.\n\n    Returns:\n        str: പാളിനോമിയലിന്റെ സ്ട്രിംഗ് പ്രതിനിധാനം.\n\n    ഉദാഹരണങ്ങൾ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "fa": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    یک لیست از ضرایب چندجمله‌ای را به یک رشته قالب‌بندی شده تبدیل می‌کند.\n\n    این تابع درجه بالاترین `n` چندجمله‌ای و یک لیست از ضرایب `coeffs` را دریافت می‌کند،\n    که از جمله با درجه بالاترین تا جمله ثابت مرتب شده‌اند. این تابع یک رشته را برمی‌گرداند که\n    چندجمله‌ای را با قوانین زیر نشان می‌دهد:\n    - جملاتی با ضریب صفر حذف می‌شوند.\n    - علامت هر جمله تعیین می‌شود (+ برای مثبت، - برای منفی)، بدون '+' پیشرو برای جمله اول.\n    - مقدار مطلق ضریب نشان داده می‌شود مگر اینکه 1 باشد و جمله شامل متغیر `x` باشد.\n    - قسمت متغیر بر اساس درجه آن قالب‌بندی می‌شود؛ `x^degree` برای درجه > 1، `x` برای درجه 1، و\n      هیچ چیز برای درجه 0 (جمله ثابت).\n    - جملات بدون فضاهای اضافی به هم پیوسته می‌شوند، با شروع از جمله با درجه بالاترین.\n\n    Args:\n        n (int): بالاترین درجه چندجمله‌ای.\n        coeffs (List[int]): لیستی از ضرایب، که با ضریب جمله با درجه بالاترین شروع می‌شود.\n\n    Returns:\n        str: نمایش رشته‌ای از چندجمله‌ای.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\""}, "canonical_solution": "    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)", "instruction": {"en": "Write a python function 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' to solve the following problem:\n\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    ", "sq": "Shkruani një funksion python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Konverton një listë të koeficientëve të polinomit në një përfaqësim të formatuar si varg.\n\n    Funksioni merr shkallën më të lartë `n` të polinomit dhe një listë të koeficientëve `coeffs`,\n    të cilët janë të renditur nga termi me shkallën më të lartë deri te termi konstant. Ai kthen një varg që\n    përfaqëson polinomin me rregullat e mëposhtme:\n    - Termat me një koeficient zero janë të injoruar.\n    - Shenja e secilit term përcaktohet (+ për pozitiv, - për negativ), pa '+' në fillim për termi i parë.\n    - Vlera absolute e koeficientit tregohet përveç nëse është 1 dhe termi përfshin variablin `x`.\n    - Pjesa e variablit formatohet bazuar në shkallën e tij; `x^degree` për shkallë > 1, `x` për shkallë 1, dhe\n      asgjë për shkallë 0 (termi konstant).\n    - Termat bashkohen pa hapësira shtesë, duke filluar me termin me shkallën më të lartë.\n\n    Args:\n        n (int): Shkalla më e lartë e polinomit.\n        coeffs (List[int]): Një listë e koeficientëve, duke filluar me koeficientin e termit me shkallën më të lartë.\n\n    Returns:\n        str: Përfaqësimi si varg i polinomit.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "hy": "Պայթոն ֆունկցիա 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Փոխակերպում է բազմանդամի գործակիցների ցուցակը ձևավորված տողային ներկայացման։\n\n    Ֆունկցիան ընդունում է բազմանդամի ամենաբարձր աստիճանը `n` և գործակիցների ցուցակը `coeffs`,\n    որոնք դասավորված են ամենաբարձր աստիճանի անդամից մինչև հաստատուն անդամ։ Այն վերադարձնում է\n    բազմանդամը ներկայացնող տող հետևյալ կանոններով.\n    - Զրոյական գործակից ունեցող անդամները բաց են թողնվում։\n    - Յուրաքանչյուր անդամի նշանը որոշվում է (+ դրականների համար, - բացասականների համար), առաջին անդամի համար առանց առաջատար '+'։\n    - Գործակցի բացարձակ արժեքը ցույց է տրվում, եթե այն 1 չէ և անդամը պարունակում է փոփոխական `x`։\n    - Փոփոխականի մասը ձևավորվում է ըստ նրա աստիճանի; `x^degree` աստիճանի > 1 համար, `x` աստիճանի 1 համար, և\n      ոչինչ աստիճանի 0 (հաստատուն անդամ) համար։\n    - Անդամները միացվում են առանց լրացուցիչ բացատների, սկսելով ամենաբարձր աստիճանի անդամից։\n\n    Արգումենտներ:\n        n (int): Բազմանդամի ամենաբարձր աստիճանը։\n        coeffs (List[int]): Գործակիցների ցուցակ, սկսած ամենաբարձր աստիճանի անդամի գործակցից։\n\n    Վերադարձնում է:\n        str: Բազմանդամի տողային ներկայացումը։\n\n    Օրինակներ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "bn": "একটি পাইথন ফাংশন 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি পলিনোমিয়াল সহগের তালিকাকে একটি ফরম্যাট করা স্ট্রিং প্রতিনিধিত্বে রূপান্তর করে।\n\n    ফাংশনটি পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি `n` এবং একটি সহগের তালিকা `coeffs` গ্রহণ করে,\n    যা সর্বোচ্চ ডিগ্রি টার্ম থেকে ধ্রুবক টার্ম পর্যন্ত সাজানো থাকে। এটি একটি স্ট্রিং ফেরত দেয় যা\n    নিম্নলিখিত নিয়মগুলির সাথে পলিনোমিয়ালকে উপস্থাপন করে:\n    - শূন্য সহগের টার্মগুলি বাদ দেওয়া হয়।\n    - প্রতিটি টার্মের চিহ্ন নির্ধারিত হয় (+ ধনাত্মক, - ঋণাত্মক), প্রথম টার্মের জন্য কোন নেতৃস্থানীয় '+' ছাড়া।\n    - সহগের পরম মান দেখানো হয় যদি না এটি 1 হয় এবং টার্মটিতে ভেরিয়েবল `x` অন্তর্ভুক্ত থাকে।\n    - ভেরিয়েবল অংশটি তার ডিগ্রির উপর ভিত্তি করে ফরম্যাট করা হয়; ডিগ্রি > 1 এর জন্য `x^degree`, ডিগ্রি 1 এর জন্য `x`, এবং\n      ডিগ্রি 0 (ধ্রুবক টার্ম) এর জন্য কিছুই নয়।\n    - টার্মগুলি অতিরিক্ত স্পেস ছাড়াই যোগ করা হয়, সর্বোচ্চ ডিগ্রি টার্ম দিয়ে শুরু হয়।\n\n    Args:\n        n (int): পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি।\n        coeffs (List[int]): সহগের একটি তালিকা, সর্বোচ্চ ডিগ্রি টার্মের সহগ দিয়ে শুরু।\n\n    Returns:\n        str: পলিনোমিয়ালের স্ট্রিং প্রতিনিধিত্ব।\n\n    উদাহরণ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "bg": "Напишете Python функция 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' за решаване на следния проблем:\n\n    Преобразува списък от коефициенти на полином в форматирано текстово представяне.\n\n    Функцията приема най-високата степен `n` на полинома и списък от коефициенти `coeffs`,\n    които са подредени от терма с най-висока степен до константния терм. Тя връща низ, който\n    представя полинома със следните правила:\n    - Терми с коефициент нула се пропускат.\n    - Знакът на всеки терм се определя (+ за положителен, - за отрицателен), без водещ '+' за първия терм.\n    - Абсолютната стойност на коефициента се показва, освен ако не е 1 и термът включва променливата `x`.\n    - Променливата част се форматира въз основа на степента; `x^degree` за степен > 1, `x` за степен 1 и\n      нищо за степен 0 (константен терм).\n    - Терми се съединяват без допълнителни интервали, започвайки с терма с най-висока степен.\n\n    Args:\n        n (int): Най-високата степен на полинома.\n        coeffs (List[int]): Списък с коефициенти, започвайки с коефициента на терма с най-висока степен.\n\n    Returns:\n        str: Текстовото представяне на полинома.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "zh": "编写一个 Python 函数 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' 来解决以下问题：\n\n    将多项式系数列表转换为格式化的字符串表示。\n\n    该函数接收多项式的最高次数 `n` 和一个系数列表 `coeffs`，\n    这些系数按从最高次项到常数项的顺序排列。它返回一个字符串，\n    该字符串表示多项式，遵循以下规则：\n    - 系数为零的项被省略。\n    - 每项的符号由其决定（正数为 +，负数为 -），第一项不带前导 '+'。\n    - 除非系数为 1 且该项包含变量 `x`，否则显示系数的绝对值。\n    - 变量部分根据其次数进行格式化；当次数大于 1 时为 `x^degree`，次数为 1 时为 `x`，\n      常数项（次数为 0）则不显示变量。\n    - 各项之间不加额外空格，从最高次项开始连接。\n\n    参数：\n        n (int): 多项式的最高次数。\n        coeffs (List[int]): 系数列表，从最高次项的系数开始。\n\n    返回：\n        str: 多项式的字符串表示。\n\n    示例：\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "fr": "Écrivez une fonction python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' pour résoudre le problème suivant :\n\n    Convertit une liste de coefficients de polynôme en une représentation sous forme de chaîne formatée.\n\n    La fonction prend en entrée le degré le plus élevé `n` du polynôme et une liste de coefficients `coeffs`,\n    qui sont ordonnés du terme de degré le plus élevé au terme constant. Elle renvoie une chaîne qui\n    représente le polynôme avec les règles suivantes :\n    - Les termes avec un coefficient de zéro sont omis.\n    - Le signe de chaque terme est déterminé (+ pour positif, - pour négatif), sans '+' initial pour le premier terme.\n    - La valeur absolue du coefficient est affichée sauf si elle est 1 et que le terme inclut la variable `x`.\n    - La partie variable est formatée en fonction de son degré ; `x^degree` pour degré > 1, `x` pour degré 1, et\n      rien pour degré 0 (terme constant).\n    - Les termes sont joints sans espaces supplémentaires, en commençant par le terme de degré le plus élevé.\n\n    Args:\n        n (int): Le degré le plus élevé du polynôme.\n        coeffs (List[int]): Une liste de coefficients, en commençant par le coefficient du terme de degré le plus élevé.\n\n    Returns:\n        str: La représentation sous forme de chaîne du polynôme.\n\n    Exemples :\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "de": "Schreiben Sie eine Python-Funktion 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:', um das folgende Problem zu lösen:\n\n    Wandelt eine Liste von Polynomkoeffizienten in eine formatierte Zeichenfolgenrepräsentation um.\n\n    Die Funktion nimmt den höchsten Grad `n` des Polynoms und eine Liste von Koeffizienten `coeffs` entgegen,\n    die vom höchsten Grad-Term bis zum konstanten Term geordnet sind. Sie gibt eine Zeichenfolge zurück, die\n    das Polynom mit den folgenden Regeln darstellt:\n    - Terme mit einem Koeffizienten von null werden weggelassen.\n    - Das Vorzeichen jedes Terms wird bestimmt (+ für positiv, - für negativ), ohne führendes '+' für den ersten Term.\n    - Der absolute Wert des Koeffizienten wird angezeigt, es sei denn, er ist 1 und der Term enthält die Variable `x`.\n    - Der Variablenteil wird basierend auf seinem Grad formatiert; `x^degree` für Grad > 1, `x` für Grad 1 und\n      nichts für Grad 0 (konstanter Term).\n    - Terme werden ohne zusätzliche Leerzeichen verbunden, beginnend mit dem höchsten Grad-Term.\n\n    Args:\n        n (int): Der höchste Grad des Polynoms.\n        coeffs (List[int]): Eine Liste von Koeffizienten, beginnend mit dem Koeffizienten des höchsten Grad-Terms.\n\n    Returns:\n        str: Die Zeichenfolgenrepräsentation des Polynoms.\n\n    Beispiele:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "ha": "Rubuta wani aikin python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' don warware matsalar mai zuwa:\n\n    Yana canza jerin maki na polynomial zuwa wakilcin rubutu mai tsari.\n\n    Aikin yana karɓar mafi girman digiri `n` na polynomial da jerin maki `coeffs`,\n    waɗanda aka tsara daga mafi girman digiri zuwa kalmar akai-akai. Yana dawo da rubutu wanda\n    ke wakiltar polynomial tare da waɗannan ƙa'idodin:\n    - Ana cire kalmomi tare da maki na sifili.\n    - Ana tantance alamar kowace kalma (+ don tabbatacce, - don korau), ba tare da jagorar '+' don kalma ta farko ba.\n    - Ana nuna ƙimar coefficient sai dai idan yana da 1 kuma kalmar tana haɗa da canji `x`.\n    - Ana tsara ɓangaren canji bisa ga digirinsa; `x^degree` don digiri > 1, `x` don digiri 1, kuma\n      babu komai don digiri 0 (kalmar akai-akai).\n    - Ana haɗa kalmomi ba tare da ƙarin sarari ba, farawa da mafi girman digiri.\n\n    Args:\n        n (int): Mafi girman digiri na polynomial.\n        coeffs (List[int]): Jerin maki, farawa da maki na mafi girman digiri.\n\n    Returns:\n        str: Wakilcin rubutu na polynomial.\n\n    Misalai:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "hi": "एक पायथन फ़ंक्शन 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    बहुपद गुणांक की सूची को स्वरूपित स्ट्रिंग अभ्यRepresentation में परिवर्तित करता है।\n\n    फ़ंक्शन बहुपद की उच्चतम डिग्री `n` और गुणांक `coeffs` की एक सूची लेता है,\n    जो उच्चतम डिग्री पद से स्थिरांक पद तक क्रमबद्ध होते हैं। यह एक स्ट्रिंग लौटाता है जो\n    निम्नलिखित नियमों के साथ बहुपद का प्रतिनिधित्व करता है:\n    - शून्य गुणांक वाले पदों को छोड़ दिया जाता है।\n    - प्रत्येक पद का चिह्न निर्धारित किया जाता है (धनात्मक के लिए +, ऋणात्मक के लिए -), पहले पद के लिए कोई अग्रणी '+' नहीं।\n    - गुणांक का परिमाण दिखाया जाता है जब तक कि यह 1 न हो और पद में चर `x` शामिल हो।\n    - चर भाग को उसकी डिग्री के आधार पर स्वरूपित किया जाता है; डिग्री > 1 के लिए `x^degree`, डिग्री 1 के लिए `x`, और\n      डिग्री 0 (स्थिरांक पद) के लिए कुछ नहीं।\n    - पदों को बिना अतिरिक्त स्थान के जोड़ा जाता है, उच्चतम डिग्री पद से शुरू होता है।\n\n    तर्क:\n        n (int): बहुपद की उच्चतम डिग्री।\n        coeffs (List[int]): गुणांकों की एक सूची, उच्चतम डिग्री पद के गुणांक से शुरू होती है।\n\n    लौटाता है:\n        str: बहुपद का स्ट्रिंग अभ्यRepresentation।\n\n    उदाहरण:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "hu": "Írj egy python függvényt 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' a következő probléma megoldására:\n\n    Egy polinomiális együtthatók listáját alakítja át formázott sztring reprezentációvá.\n\n    A függvény a polinom legmagasabb fokszámát `n` és az együtthatók `coeffs` listáját veszi át,\n    amelyek a legmagasabb fokú tagtól a konstans tagig vannak rendezve. Egy olyan sztringet ad vissza,\n    amely a következő szabályok szerint ábrázolja a polinomot:\n    - A nulla együtthatójú tagok elhagyásra kerülnek.\n    - Minden tag előjele meghatározásra kerül (+ a pozitív, - a negatív esetén), az első tagnál nincs vezető '+' jel.\n    - Az együttható abszolút értéke megjelenik, kivéve ha 1, és a tag tartalmazza az `x` változót.\n    - A változó rész a fokszám alapján van formázva; `x^degree` ha a fokszám > 1, `x` ha a fokszám 1, és\n      semmi ha a fokszám 0 (konstans tag).\n    - A tagok további szóközök nélkül vannak összekapcsolva, a legmagasabb fokú taggal kezdve.\n\n    Argumentumok:\n        n (int): A polinom legmagasabb fokszáma.\n        coeffs (List[int]): Az együtthatók listája, a legmagasabb fokú tag együtthatójával kezdve.\n\n    Visszatér:\n        str: A polinom sztring reprezentációja.\n\n    Példák:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "es": "Escribe una función de Python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' para resolver el siguiente problema:\n\n    Convierte una lista de coeficientes de un polinomio en una representación de cadena formateada.\n\n    La función recibe el grado más alto `n` del polinomio y una lista de coeficientes `coeffs`,\n    que están ordenados desde el término de mayor grado hasta el término constante. Devuelve una cadena que\n    representa el polinomio con las siguientes reglas:\n    - Se omiten los términos con un coeficiente de cero.\n    - El signo de cada término se determina (+ para positivo, - para negativo), sin un '+' inicial para el primer término.\n    - Se muestra el valor absoluto del coeficiente a menos que sea 1 y el término incluya la variable `x`.\n    - La parte variable se formatea según su grado; `x^grado` para grado > 1, `x` para grado 1, y\n      nada para grado 0 (término constante).\n    - Los términos se unen sin espacios adicionales, comenzando con el término de mayor grado.\n\n    Argumentos:\n        n (int): El grado más alto del polinomio.\n        coeffs (List[int]): Una lista de coeficientes, comenzando con el coeficiente del término de mayor grado.\n\n    Devuelve:\n        str: La representación en cadena del polinomio.\n\n    Ejemplos:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "arb": "اكتب دالة بايثون 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' لحل المشكلة التالية:\n\n    تحويل قائمة من معاملات الحدوديات إلى تمثيل نصي منسق.\n\n    تأخذ الدالة الدرجة الأعلى `n` للحدودية وقائمة من المعاملات `coeffs`،\n    التي تكون مرتبة من الحد ذو الدرجة الأعلى إلى الحد الثابت. تُرجع سلسلة تمثل الحدودية بالقواعد التالية:\n    - يتم حذف الحدود ذات المعامل الصفري.\n    - يتم تحديد إشارة كل حد (+ للإيجابي، - للسلبي)، بدون '+' في البداية للحد الأول.\n    - يتم عرض القيمة المطلقة للمعامل إلا إذا كانت 1 والحد يتضمن المتغير `x`.\n    - يتم تنسيق الجزء المتغير بناءً على درجته؛ `x^degree` للدرجة > 1، `x` للدرجة 1، ولا شيء للدرجة 0 (الحد الثابت).\n    - يتم ربط الحدود بدون مسافات إضافية، بدءًا من الحد ذو الدرجة الأعلى.\n\n    يعيدالحجج:\n        n (int): الدرجة الأعلى للحدودية.\n        coeffs (List[int]): قائمة بالمعاملات، تبدأ بمعامل الحد ذو الدرجة الأعلى.\n\n    يعيد:\n        str: التمثيل النصي للحدودية.\n\n    أمثلة:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "sw": "Andika kazi ya Python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' kutatua tatizo lifuatalo:\n\n    Inabadilisha orodha ya vigezo vya polinomu kuwa mwakilishi wa maandishi uliopangwa.\n\n    Kazi inachukua kiwango cha juu zaidi `n` cha polinomu na orodha ya vigezo `coeffs`,\n    ambavyo vimepangwa kutoka kwa kiwango cha juu zaidi hadi kwa neno la kawaida. Inarudisha kamba ambayo\n    inawakilisha polinomu na sheria zifuatazo:\n    - Maneno yenye kigezo cha sifuri hayajumuishwi.\n    - Alama ya kila neno inaamuliwa (+ kwa chanya, - kwa hasi), bila '+' ya mwanzo kwa neno la kwanza.\n    - Thamani kamili ya kigezo inaonyeshwa isipokuwa ni 1 na neno linajumuisha kigezo `x`.\n    - Sehemu ya kigezo imepangwa kulingana na kiwango chake; `x^degree` kwa kiwango > 1, `x` kwa kiwango 1, na\n      hakuna kitu kwa kiwango 0 (neno la kawaida).\n    - Maneno yanaunganishwa bila nafasi za ziada, kuanzia na neno la kiwango cha juu zaidi.\n\n    Hoja:\n        n (int): Kiwango cha juu zaidi cha polinomu.\n        coeffs (List[int]): Orodha ya vigezo, kuanzia na kigezo cha neno la kiwango cha juu zaidi.\n\n    Inarejesha:\n        str: Mwakilishi wa maandishi wa polinomu.\n\n    Mifano:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "tr": "Bir python fonksiyonu 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' yazın ve aşağıdaki problemi çözün:\n\n    Bir polinom katsayıları listesini biçimlendirilmiş bir string temsilcisine dönüştürür.\n\n    Fonksiyon, polinomun en yüksek derecesi `n` ve en yüksek dereceli terimden sabit terime kadar sıralanmış\n    bir katsayı listesi `coeffs` alır. Aşağıdaki kurallarla polinomu temsil eden bir string döndürür:\n    - Katsayısı sıfır olan terimler atlanır.\n    - Her terimin işareti belirlenir (+ pozitif için, - negatif için), ilk terim için başta '+' yoktur.\n    - Katsayının mutlak değeri gösterilir, ancak katsayı 1 ise ve terim `x` değişkenini içeriyorsa gösterilmez.\n    - Değişken kısmı derecesine göre biçimlendirilir; derece > 1 için `x^derece`, derece 1 için `x` ve\n      derece 0 (sabit terim) için hiçbir şey.\n    - Terimler, en yüksek dereceli terimle başlayarak ek boşluk olmadan birleştirilir.\n\n    Argümanlar:\n        n (int): Polinomun en yüksek derecesi.\n        coeffs (List[int]): En yüksek dereceli terimin katsayısı ile başlayan bir katsayı listesi.\n\n    Döndürür:\n        str: Polinomun string temsili.\n\n    Örnekler:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "vi": "Viết một hàm python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' để giải quyết vấn đề sau:\n\n    Chuyển đổi một danh sách các hệ số đa thức thành một biểu diễn chuỗi được định dạng.\n\n    Hàm nhận vào bậc cao nhất `n` của đa thức và một danh sách các hệ số `coeffs`,\n    được sắp xếp từ hạng tử có bậc cao nhất đến hạng tử hằng số. Nó trả về một chuỗi\n    đại diện cho đa thức với các quy tắc sau:\n    - Các hạng tử có hệ số bằng không sẽ bị bỏ qua.\n    - Dấu của mỗi hạng tử được xác định (+ cho dương, - cho âm), không có dấu '+' đứng đầu cho hạng tử đầu tiên.\n    - Giá trị tuyệt đối của hệ số được hiển thị trừ khi nó là 1 và hạng tử bao gồm biến `x`.\n    - Phần biến được định dạng dựa trên bậc của nó; `x^degree` cho bậc > 1, `x` cho bậc 1, và\n      không có gì cho bậc 0 (hạng tử hằng số).\n    - Các hạng tử được nối mà không có khoảng trắng bổ sung, bắt đầu với hạng tử có bậc cao nhất.\n\n    Tham số:\n        n (int): Bậc cao nhất của đa thức.\n        coeffs (List[int]): Một danh sách các hệ số, bắt đầu với hệ số của hạng tử có bậc cao nhất.\n\n    Trả về:\n        str: Biểu diễn chuỗi của đa thức.\n\n    Ví dụ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "id": "Tulis sebuah fungsi python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' untuk menyelesaikan masalah berikut:\n\n    Mengubah daftar koefisien polinomial menjadi representasi string yang diformat.\n\n    Fungsi ini menerima derajat tertinggi `n` dari polinomial dan daftar koefisien `coeffs`,\n    yang diurutkan dari suku dengan derajat tertinggi hingga suku konstanta. Fungsi ini mengembalikan sebuah string yang\n    mewakili polinomial dengan aturan berikut:\n    - Suku dengan koefisien nol dihilangkan.\n    - Tanda dari setiap suku ditentukan (+ untuk positif, - untuk negatif), tanpa '+' di awal untuk suku pertama.\n    - Nilai mutlak dari koefisien ditampilkan kecuali jika koefisiennya 1 dan suku tersebut termasuk variabel `x`.\n    - Bagian variabel diformat berdasarkan derajatnya; `x^degree` untuk derajat > 1, `x` untuk derajat 1, dan\n      tidak ada apa-apa untuk derajat 0 (suku konstanta).\n    - Suku-suku digabungkan tanpa spasi tambahan, dimulai dengan suku dengan derajat tertinggi.\n\n    Argumen:\n        n (int): Derajat tertinggi dari polinomial.\n        coeffs (List[int]): Daftar koefisien, dimulai dengan koefisien dari suku dengan derajat tertinggi.\n\n    Mengembalikan:\n        str: Representasi string dari polinomial.\n\n    Contoh:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "ja": "Python関数 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' を作成して、次の問題を解決してください:\n\n    多項式の係数のリストをフォーマットされた文字列表現に変換します。\n\n    関数は、多項式の最高次数 `n` と、最高次数の項から定数項まで順に並んだ係数のリスト `coeffs` を受け取り、\n    次のルールに従って多項式を表す文字列を返します:\n    - 係数がゼロの項は省略されます。\n    - 各項の符号は（正の場合は+、負の場合は-）決定され、最初の項には先頭の'+'は付きません。\n    - 係数の絶対値は、係数が1で変数 `x` を含む項でない限り表示されます。\n    - 変数部分は次数に基づいてフォーマットされます。次数が1より大きい場合は `x^degree`、次数が1の場合は `x`、次数が0（定数項）の場合は何も表示されません。\n    - 項は追加のスペースなしで結合され、最高次数の項から始まります。\n\n    引数:\n        n (int): 多項式の最高次数。\n        coeffs (List[int]): 最高次数の項の係数から始まる係数のリスト。\n\n    戻り値:\n        str: 多項式の文字列表現。\n\n    例:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "ko": "파이썬 함수를 작성하세요 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' 다음 문제를 해결하기 위해:\n\n    다항식 계수 목록을 형식화된 문자열 표현으로 변환합니다.\n\n    함수는 다항식의 최고 차수 `n`과 계수 목록 `coeffs`를 입력으로 받습니다.\n    이 목록은 최고 차수 항부터 상수 항까지 순서대로 정렬되어 있습니다. 이 함수는 다음 규칙에 따라\n    다항식을 나타내는 문자열을 반환합니다:\n    - 계수가 0인 항은 생략됩니다.\n    - 각 항의 부호는 결정됩니다 (+는 양수, -는 음수), 첫 번째 항에는 선행 '+'가 없습니다.\n    - 계수의 절대값은 표시되지만, 계수가 1이고 항에 변수 `x`가 포함된 경우에는 표시되지 않습니다.\n    - 변수 부분은 차수에 따라 형식화됩니다; `x^degree`는 차수가 1보다 클 때, `x`는 차수가 1일 때,\n      차수가 0일 때는 아무것도 표시되지 않습니다 (상수 항).\n    - 항은 추가적인 공백 없이 연결되며, 최고 차수 항부터 시작합니다.\n\n    인자:\n        n (int): 다항식의 최고 차수.\n        coeffs (List[int]): 최고 차수 항의 계수부터 시작하는 계수 목록.\n\n    반환:\n        str: 다항식의 문자열 표현.\n\n    예시:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "ml": "Python ഫംഗ്ഷൻ 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    ബഹുപദത്തിന്റെ ഗുണകങ്ങളുടെ പട്ടിക ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗ് പ്രതിനിധാനത്തിലേക്ക് പരിവർത്തനം ചെയ്യുന്നു.\n\n    ഫംഗ്ഷൻ ബഹുപദത്തിന്റെ ഏറ്റവും ഉയർന്ന ബഹുഘാതം `n`യും ഗുണകങ്ങളുടെ പട്ടിക `coeffs`ഉം സ്വീകരിക്കുന്നു,\n    ഇത് ഏറ്റവും ഉയർന്ന ബഹുഘാത പദം മുതൽ സ്ഥിരാങ്ക പദം വരെ ക്രമീകരിച്ചിരിക്കുന്നു. ഇത് ബഹുപദത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് തിരികെ നൽകുന്നു\n    താഴെ പറയുന്ന നിയമങ്ങൾക്കനുസരിച്ച്:\n    - ഗുണകം പൂജ്യം ആയ പദങ്ങൾ ഒഴിവാക്കുന്നു.\n    - ഓരോ പദത്തിന്റെ ചിഹ്നം നിശ്ചയിക്കുന്നു (+ ധനാത്മകത്തിനും, - ঋണാത്മകത്തിനും), ആദ്യ പദത്തിന് മുൻപിൽ '+' ഇല്ലാതെ.\n    - ഗുണകത്തിന്റെ പരമാവധി മൂല്യം കാണിക്കുന്നു, അത് 1 അല്ലെങ്കിൽ പദം ചേരുവ `x` ഉൾക്കൊള്ളുന്നില്ലെങ്കിൽ.\n    - ചേരുവയുടെ ഭാഗം അതിന്റെ ബഹുഘാതത്തെ അടിസ്ഥാനമാക്കി ഫോർമാറ്റ് ചെയ്യുന്നു; `x^degree` ബഹുഘാതം > 1, `x` ബഹുഘാതം 1, \n      ഒന്നുമില്ല ബഹുഘാതം 0 (സ്ഥിരാങ്ക പദം) എന്നതിന്.\n    - പദങ്ങൾ അധിക ഇടവിടങ്ങളില്ലാതെ ചേർക്കുന്നു, ഏറ്റവും ഉയർന്ന ബഹുഘാത പദം കൊണ്ട് ആരംഭിക്കുന്നു.\n\n    Args:\n        n (int): ബഹുപദത്തിന്റെ ഏറ്റവും ഉയർന്ന ബഹുഘാതം.\n        coeffs (List[int]): ഏറ്റവും ഉയർന്ന ബഹുഘാത പദത്തിന്റെ ഗുണകത്തോടെ ആരംഭിക്കുന്ന ഗുണകങ്ങളുടെ പട്ടിക.\n\n    Returns:\n        str: ബഹുപദത്തിന്റെ സ്ട്രിംഗ് പ്രതിനിധാനം.\n\n    ഉദാഹരണങ്ങൾ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "fa": "یک تابع پایتون بنویسید 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' برای حل مسئله زیر:\n\n    یک لیست از ضرایب چندجمله‌ای را به یک نمایش رشته‌ای قالب‌بندی‌شده تبدیل می‌کند.\n\n    تابع بالاترین درجه `n` چندجمله‌ای و یک لیست از ضرایب `coeffs` را می‌گیرد،\n    که از جمله با بالاترین درجه تا جمله ثابت مرتب شده‌اند. این تابع یک رشته را برمی‌گرداند که\n    چندجمله‌ای را با قوانین زیر نشان می‌دهد:\n    - جملاتی که ضریب آن‌ها صفر است حذف می‌شوند.\n    - علامت هر جمله تعیین می‌شود (+ برای مثبت، - برای منفی)، بدون '+' پیشرو برای جمله اول.\n    - مقدار مطلق ضریب نشان داده می‌شود مگر اینکه 1 باشد و جمله شامل متغیر `x` باشد.\n    - بخش متغیر بر اساس درجه آن قالب‌بندی می‌شود؛ `x^degree` برای درجه > 1، `x` برای درجه 1، و\n      هیچ چیز برای درجه 0 (جمله ثابت).\n    - جملات بدون فاصله اضافی به هم متصل می‌شوند، شروع با جمله با بالاترین درجه.\n\n    آرگومان‌ها:\n        n (int): بالاترین درجه چندجمله‌ای.\n        coeffs (List[int]): لیستی از ضرایب، شروع با ضریب جمله با بالاترین درجه.\n\n    بازگشت:\n        str: نمایش رشته‌ای چندجمله‌ای.\n\n    مثال‌ها:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'"}, "level": "hard", "test": "def test_polynomial_to_string():\n    test_cases = [\n        (4, [3, -2, 0, 1, -5], \"3x^4-2x^3+x-5\"),\n        (2, [0, 4, -1], \"+4x-1\"),\n        (0, [7], \"7\"),\n        (3, [1, -1, 0, 1], \"x^3-x^2+1\"),\n    ]\n\n    for i, (n, coeffs, expected) in enumerate(test_cases):\n        result = polynomial_to_string(n, coeffs)\n\n        assert result == expected, f\"Test case {i + 1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i + 1} passed: expected {expected}, got {result}\")\n\n\ntest_polynomial_to_string()", "entry_point": "polynomial_to_string", "signature": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:", "docstring": {"en": "\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    ", "sq": "\n    Konverton një listë të koeficientëve të polinomit në një përfaqësim të formatizuar si varg.\n\n    Funksioni merr shkallën më të lartë `n` të polinomit dhe një listë të koeficientëve `coeffs`,\n    të cilët janë të renditur nga termi me shkallën më të lartë deri te termi konstant. Ai kthen një varg\n    që përfaqëson polinomin me rregullat e mëposhtme:\n    - Termat me një koeficient zero janë të lënë jashtë.\n    - Shenja e secilit term përcaktohet (+ për pozitiv, - për negativ), pa '+' në fillim për termi i parë.\n    - Vlera absolute e koeficientit tregohet përveç kur është 1 dhe termi përfshin variablën `x`.\n    - Pjesa e variablës është e formatuar bazuar në shkallën e saj; `x^degree` për shkallë > 1, `x` për shkallë 1, dhe\n      asgjë për shkallë 0 (termi konstant).\n    - Termat janë të bashkuar pa hapësira shtesë, duke filluar me termi me shkallën më të lartë.\n\n    Argumentet:\n        n (int): Shkalla më e lartë e polinomit.\n        coeffs (List[int]): Një listë e koeficientëve, duke filluar me koeficientin e termit me shkallën më të lartë.\n\n    Kthen:\n        str: Përfaqësimi si varg i polinomit.\n\n    Shembuj:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "hy": "\n    Պոլինոմի գործակիցների ցուցակը վերածում է ձևաչափված տողային ներկայացման։\n\n    Ֆունկցիան ընդունում է պոլինոմի ամենաբարձր աստիճանը `n` և գործակիցների ցուցակը `coeffs`,\n    որոնք դասավորված են ամենաբարձր աստիճանի անդամից մինչև հաստատուն անդամ։ Այն վերադարձնում է տող,\n    որը ներկայացնում է պոլինոմը հետևյալ կանոններով.\n    - Զրոյական գործակից ունեցող անդամները բաց են թողնվում։\n    - Յուրաքանչյուր անդամի նշանը որոշվում է (+ դրականների համար, - բացասականների համար), \n      առանց առաջին անդամի համար առաջատար '+' նշանի։\n    - Գործակիցի բացարձակ արժեքը ցուցադրվում է, եթե այն 1 չէ և անդամը պարունակում է փոփոխական `x`։\n    - Փոփոխականի մասը ձևաչափվում է ըստ իր աստիճանի՝ `x^աստիճան` աստիճանի համար > 1, `x` 1 աստիճանի համար,\n      և ոչինչ 0 աստիճանի համար (հաստատուն անդամ)։\n    - Անդամները միացվում են առանց լրացուցիչ բացատների, սկսելով ամենաբարձր աստիճանի անդամից։\n\n    Պարամետրեր:\n        n (int): Պոլինոմի ամենաբարձր աստիճանը։\n        coeffs (List[int]): Գործակիցների ցուցակ, սկսած ամենաբարձր աստիճանի անդամի գործակցից։\n\n    Վերադարձնում է:\n        str: Պոլինոմի տողային ներկայացումը։\n\n    Օրինակներ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "bn": "\n    পলিনোমিয়াল সহগের একটি তালিকাকে একটি ফরম্যাটেড স্ট্রিং উপস্থাপনায় রূপান্তর করে।\n\n    ফাংশনটি পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি `n` এবং সহগের একটি তালিকা `coeffs` গ্রহণ করে,\n    যা সর্বোচ্চ ডিগ্রি টার্ম থেকে ধ্রুবক টার্ম পর্যন্ত সাজানো থাকে। এটি একটি স্ট্রিং রিটার্ন করে যা\n    নিম্নলিখিত নিয়ম অনুযায়ী পলিনোমিয়াল উপস্থাপন করে:\n    - সহগ শূন্য হলে টার্মগুলি বাদ দেওয়া হয়।\n    - প্রতিটি টার্মের চিহ্ন নির্ধারিত হয় (+ ধনাত্মক, - ঋণাত্মক), প্রথম টার্মের জন্য কোনো নেতৃস্থানীয় '+' নেই।\n    - সহগের পরম মান দেখানো হয় যদি না এটি 1 হয় এবং টার্মে ভেরিয়েবল `x` অন্তর্ভুক্ত থাকে।\n    - ভেরিয়েবল অংশটি তার ডিগ্রির উপর ভিত্তি করে ফরম্যাট করা হয়; ডিগ্রি > 1 এর জন্য `x^degree`, ডিগ্রি 1 এর জন্য `x`, এবং\n      ডিগ্রি 0 (ধ্রুবক টার্ম) এর জন্য কিছুই নয়।\n    - টার্মগুলি অতিরিক্ত স্পেস ছাড়াই যোগ করা হয়, সর্বোচ্চ ডিগ্রি টার্ম দিয়ে শুরু হয়।\n\n    প্যারামিটার:\n        n (int): পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি।\n        coeffs (List[int]): সহগের একটি তালিকা, সর্বোচ্চ ডিগ্রি টার্মের সহগ দিয়ে শুরু।\n\n    রিটার্নস:\n        str: পলিনোমিয়ালের স্ট্রিং উপস্থাপনা।\n\n    উদাহরণ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "bg": "\n    Преобразува списък от коефициенти на полином в форматирано текстово представяне.\n\n    Функцията приема най-високата степен `n` на полинома и списък от коефициенти `coeffs`,\n    които са подредени от най-високата степен към константния член. Тя връща низ, който\n    представлява полинома със следните правила:\n    - Членове с коефициент нула се пропускат.\n    - Знакът на всеки член се определя (+ за положителен, - за отрицателен), без водещ '+' за първия член.\n    - Абсолютната стойност на коефициента се показва, освен ако не е 1 и членът включва променливата `x`.\n    - Променливата част се форматира според степента си; `x^степен` за степен > 1, `x` за степен 1 и\n      нищо за степен 0 (константен член).\n    - Членовете се съединяват без допълнителни интервали, започвайки с члена с най-висока степен.\n\n    Аргументи:\n        n (int): Най-високата степен на полинома.\n        coeffs (List[int]): Списък от коефициенти, започвайки с коефициента на члена с най-висока степен.\n\n    Връща:\n        str: Текстовото представяне на полинома.\n\n    Примери:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "zh": "\n    将多项式系数列表转换为格式化的字符串表示形式。\n\n    该函数接收多项式的最高次数 `n` 和一个系数列表 `coeffs`，系数按从最高次项到常数项的顺序排列。\n    它返回一个表示多项式的字符串，遵循以下规则：\n    - 系数为零的项被省略。\n    - 每项的符号由其正负决定（正数为 +，负数为 -），首项不带前导 '+'。\n    - 系数的绝对值会显示，除非系数为 1 且该项包含变量 `x`。\n    - 变量部分根据其次数进行格式化；对于次数大于 1 的项为 `x^degree`，次数为 1 的项为 `x`，常数项则无变量。\n    - 项之间不加额外空格，从最高次项开始连接。\n\n    参数:\n        n (int): 多项式的最高次数。\n        coeffs (List[int]): 系数列表，从最高次项的系数开始。\n\n    返回:\n        str: 多项式的字符串表示形式。\n\n    示例:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "fr": "\n    Convertit une liste de coefficients de polynôme en une représentation sous forme de chaîne formatée.\n\n    La fonction prend en entrée le degré le plus élevé `n` du polynôme et une liste de coefficients `coeffs`,\n    qui sont ordonnés du terme de degré le plus élevé au terme constant. Elle renvoie une chaîne qui\n    représente le polynôme avec les règles suivantes :\n    - Les termes avec un coefficient de zéro sont omis.\n    - Le signe de chaque terme est déterminé (+ pour positif, - pour négatif), sans '+' initial pour le premier terme.\n    - La valeur absolue du coefficient est affichée sauf si elle est 1 et que le terme inclut la variable `x`.\n    - La partie variable est formatée en fonction de son degré ; `x^degree` pour un degré > 1, `x` pour un degré 1, et\n      rien pour un degré 0 (terme constant).\n    - Les termes sont joints sans espaces supplémentaires, en commençant par le terme de degré le plus élevé.\n\n    Args:\n        n (int): Le degré le plus élevé du polynôme.\n        coeffs (List[int]): Une liste de coefficients, en commençant par le coefficient du terme de degré le plus élevé.\n\n    Returns:\n        str: La représentation sous forme de chaîne du polynôme.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "de": "\n    Wandelt eine Liste von Polynomkoeffizienten in eine formatierte Zeichenfolgenrepräsentation um.\n\n    Die Funktion nimmt den höchsten Grad `n` des Polynoms und eine Liste von Koeffizienten `coeffs` entgegen,\n    die von dem Term mit dem höchsten Grad bis zum konstanten Term geordnet sind. Sie gibt eine Zeichenfolge zurück,\n    die das Polynom mit den folgenden Regeln darstellt:\n    - Terme mit einem Koeffizienten von null werden weggelassen.\n    - Das Vorzeichen jedes Terms wird bestimmt (+ für positiv, - für negativ), ohne führendes '+' für den ersten Term.\n    - Der absolute Wert des Koeffizienten wird angezeigt, es sei denn, er ist 1 und der Term enthält die Variable `x`.\n    - Der Variablenteil wird basierend auf seinem Grad formatiert; `x^degree` für Grad > 1, `x` für Grad 1 und\n      nichts für Grad 0 (konstanter Term).\n    - Terme werden ohne zusätzliche Leerzeichen verbunden, beginnend mit dem Term höchsten Grades.\n\n    Argumente:\n        n (int): Der höchste Grad des Polynoms.\n        coeffs (List[int]): Eine Liste von Koeffizienten, beginnend mit dem Koeffizienten des Terms höchsten Grades.\n\n    Rückgabe:\n        str: Die Zeichenfolgenrepräsentation des Polynoms.\n\n    Beispiele:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "ha": "\n    Canza jerin abubuwan haɗin polynomial zuwa wakilcin kirtani mai tsari.\n\n    Aikin yana ɗaukar mafi girman daraja `n` na polynomial da jerin abubuwan haɗin `coeffs`,\n    waɗanda aka tsara daga mafi girman daraja zuwa abin da ba shi da canji. Yana dawowa da kirtani wanda\n    ke wakiltar polynomial tare da waɗannan ƙa'idojin:\n    - Ana cire sharuɗɗan da ke da haɗin zero.\n    - Ana tantance alamar kowanne sharadi (+ don tabbatacce, - don korau), ba tare da '+' na farko ba don sharadi na farko.\n    - Ana nuna ƙimar haɗin ba tare da la'akari da ko yana da 1 ba kuma sharadi ya haɗa da canji `x`.\n    - Ana tsara ɓangaren canji bisa ga darajarsa; `x^degree` don daraja > 1, `x` don daraja 1, da\n      babu komai don daraja 0 (abin da ba shi da canji).\n    - Ana haɗa sharuɗɗan ba tare da ƙarin sarari ba, farawa da sharadi mafi girman daraja.\n\n    Args:\n        n (int): Mafi girman daraja na polynomial.\n        coeffs (List[int]): Jerin abubuwan haɗin, farawa da haɗin sharadi mafi girman daraja.\n\n    Returns:\n        str: Wakilcin kirtani na polynomial.\n\n    Misalai:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "hi": "\n    बहुपद गुणांक की सूची को एक स्वरूपित स्ट्रिंग प्रतिनिधित्व में परिवर्तित करता है।\n\n    फ़ंक्शन बहुपद की उच्चतम डिग्री `n` और गुणांक `coeffs` की एक सूची लेता है,\n    जो उच्चतम डिग्री पद से स्थिरांक पद तक क्रमबद्ध होते हैं। यह एक स्ट्रिंग लौटाता है जो\n    निम्नलिखित नियमों के साथ बहुपद का प्रतिनिधित्व करता है:\n    - जिन पदों का गुणांक शून्य होता है, उन्हें छोड़ दिया जाता है।\n    - प्रत्येक पद का चिह्न निर्धारित किया जाता है (+ सकारात्मक के लिए, - नकारात्मक के लिए), पहले पद के लिए कोई अग्रणी '+' नहीं।\n    - गुणांक का परिमाण दिखाया जाता है जब तक कि यह 1 न हो और पद में चर `x` शामिल हो।\n    - चर भाग को उसकी डिग्री के आधार पर स्वरूपित किया जाता है; डिग्री > 1 के लिए `x^degree`, डिग्री 1 के लिए `x`, और\n      डिग्री 0 (स्थिरांक पद) के लिए कुछ नहीं।\n    - पदों को बिना अतिरिक्त स्थान के जोड़ा जाता है, उच्चतम डिग्री पद से शुरू होते हुए।\n\n    तर्क:\n        n (int): बहुपद की उच्चतम डिग्री।\n        coeffs (List[int]): गुणांकों की एक सूची, उच्चतम डिग्री पद के गुणांक से शुरू होती है।\n\n    लौटाता है:\n        str: बहुपद का स्ट्रिंग प्रतिनिधित्व।\n\n    उदाहरण:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "hu": "\n    Egy polinomiális együtthatók listáját formázott karakterlánc-reprezentációvá alakítja.\n\n    A függvény a polinom legmagasabb fokszámát `n` és egy együtthatók listáját `coeffs` veszi be,\n    amelyek a legmagasabb fokszámú tagtól a konstans tagig vannak rendezve. Egy olyan karakterláncot ad vissza,\n    amely a polinomot a következő szabályok szerint ábrázolja:\n    - Azok a tagok, amelyek együtthatója nulla, kimaradnak.\n    - Minden tag előjele meghatározott (+ a pozitív, - a negatív esetén), az első tag előtt nincs '+' jel.\n    - Az együttható abszolút értéke megjelenik, kivéve ha 1 és a tag tartalmazza az `x` változót.\n    - A változó rész a fokszám alapján van formázva; `x^degree` ha a fokszám > 1, `x` ha a fokszám 1, és\n      semmi ha a fokszám 0 (konstans tag).\n    - A tagok további szóközök nélkül vannak összekapcsolva, a legmagasabb fokszámú taggal kezdve.\n\n    Paraméterek:\n        n (int): A polinom legmagasabb fokszáma.\n        coeffs (List[int]): Egy együtthatók listája, a legmagasabb fokszámú tag együtthatójával kezdve.\n\n    Visszatér:\n        str: A polinom karakterlánc-reprezentációja.\n\n    Példák:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "es": "    Convierte una lista de coeficientes polinomiales en una representación de cadena formateada.\n\n    La función recibe el grado más alto `n` del polinomio y una lista de coeficientes `coeffs`,\n    que están ordenados desde el término de mayor grado hasta el término constante. Devuelve una cadena que\n    representa el polinomio con las siguientes reglas:\n    - Se omiten los términos con un coeficiente de cero.\n    - El signo de cada término se determina (+ para positivo, - para negativo), sin un '+' inicial para el primer término.\n    - Se muestra el valor absoluto del coeficiente a menos que sea 1 y el término incluya la variable `x`.\n    - La parte variable se formatea según su grado; `x^grado` para grado > 1, `x` para grado 1, y\n      nada para grado 0 (término constante).\n    - Los términos se unen sin espacios adicionales, comenzando con el término de mayor grado.\n\n    Argumentos:\n        n (int): El grado más alto del polinomio.\n        coeffs (List[int]): Una lista de coeficientes, comenzando con el coeficiente del término de mayor grado.\n\n    Devuelve:\n        str: La representación en cadena del polinomio.\n\n    Ejemplos:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "arb": "    يحول قائمة من معاملات كثيرات الحدود إلى تمثيل سلسلة نصية منسقة.\n\n    تأخذ الدالة أعلى درجة `n` لكثيرة الحدود وقائمة من المعاملات `coeffs`،\n    والتي تُرتب من الحد ذو الدرجة الأعلى إلى الحد الثابت. تُرجع سلسلة نصية\n    تمثل كثيرة الحدود بالقواعد التالية:\n    - يتم حذف الحدود التي معاملها صفر.\n    - يتم تحديد إشارة كل حد (+ للموجب، - للسالب)، بدون '+' في بداية الحد الأول.\n    - يتم عرض القيمة المطلقة للمعامل إلا إذا كانت 1 والحد يحتوي على المتغير `x`.\n    - يتم تنسيق الجزء المتغير بناءً على درجته؛ `x^degree` للدرجة > 1، `x` للدرجة 1،\n      ولا شيء للدرجة 0 (الحد الثابت).\n    - يتم ربط الحدود بدون مسافات إضافية، بدءًا من الحد ذو الدرجة الأعلى.\n\n    يعيدالحجج:\n        n (int): أعلى درجة لكثيرة الحدود.\n        coeffs (List[int]): قائمة بالمعاملات، تبدأ بمعامل الحد ذو الدرجة الأعلى.\n\n    يعيد:\n        str: التمثيل النصي لكثيرة الحدود.\n\n    امثله:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "sw": "    Hubadilisha orodha ya vigezo vya polinomu kuwa mwakilishi wa maandishi uliopangiliwa.\n\n    Kazi hii inachukua kiwango cha juu zaidi `n` cha polinomu na orodha ya vigezo `coeffs`,\n    ambavyo vimepangwa kuanzia kiwango cha juu zaidi hadi kiwango cha kawaida. Inarudisha kamba\n    inayowakilisha polinomu kwa sheria zifuatazo:\n    - Masharti yenye kigezo cha sifuri hayajumuishwi.\n    - Ishara ya kila neno inatambuliwa (+ kwa chanya, - kwa hasi), bila '+' ya kwanza kwa neno la kwanza.\n    - Thamani kamili ya kigezo inaonyeshwa isipokuwa ni 1 na neno linajumuisha kigezo `x`.\n    - Sehemu ya kigezo imepangwa kulingana na kiwango chake; `x^degree` kwa kiwango > 1, `x` kwa kiwango 1, na\n      hakuna kitu kwa kiwango 0 (neno la kawaida).\n    - Masharti yanaunganishwa bila nafasi za ziada, kuanzia na neno la kiwango cha juu zaidi.\n\n    Hoja:\n        n (int): Kiwango cha juu zaidi cha polinomu.\n        coeffs (List[int]): Orodha ya vigezo, ikianza na kigezo cha neno la kiwango cha juu zaidi.\n\n    Inarejesha:\n        str: Mwakilishi wa maandishi wa polinomu.\n\n    Mifano:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "tr": "    Bir polinom katsayıları listesini biçimlendirilmiş bir string gösterimine dönüştürür.\n\n    Fonksiyon, polinomun en yüksek derecesi `n` ve en yüksek dereceden sabit terime kadar sıralanan\n    `coeffs` katsayılar listesini alır. Aşağıdaki kurallarla polinomu temsil eden bir string döndürür:\n    - Katsayısı sıfır olan terimler atlanır.\n    - Her terimin işareti belirlenir (+ pozitif için, - negatif için), ilk terim için başta '+' yoktur.\n    - Katsayının mutlak değeri gösterilir, eğer 1 ise ve terim `x` değişkenini içeriyorsa gösterilmez.\n    - Değişken kısmı derecesine göre biçimlendirilir; derece > 1 için `x^derece`, derece 1 için `x` ve\n      derece 0 (sabit terim) için hiçbir şey.\n    - Terimler, en yüksek dereceli terimle başlayarak ek boşluklar olmadan birleştirilir.\n\n    Argümanlar:\n        n (int): Polinomun en yüksek derecesi.\n        coeffs (List[int]): En yüksek dereceli terimin katsayısı ile başlayan bir katsayılar listesi.\n\n    Döndürür:\n        str: Polinomun string gösterimi.\n\n    Örnekler:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "vi": "Chuyển đổi một danh sách các hệ số đa thức thành một biểu diễn chuỗi có định dạng.\n\nHàm này nhận vào bậc cao nhất `n` của đa thức và một danh sách các hệ số `coeffs`, được sắp xếp từ hạng tử có bậc cao nhất đến hạng tử hằng số. Nó trả về một chuỗi đại diện cho đa thức với các quy tắc sau:\n- Các hạng tử có hệ số bằng không sẽ bị loại bỏ.\n- Dấu của mỗi hạng tử được xác định (+ cho dương, - cho âm), không có dấu '+' đứng đầu cho hạng tử đầu tiên.\n- Giá trị tuyệt đối của hệ số được hiển thị trừ khi nó là 1 và hạng tử bao gồm biến `x`.\n- Phần biến được định dạng dựa trên bậc của nó; `x^degree` cho bậc > 1, `x` cho bậc 1, và không có gì cho bậc 0 (hạng tử hằng số).\n- Các hạng tử được nối liền mà không có khoảng trắng bổ sung, bắt đầu với hạng tử có bậc cao nhất.\n\nTham số:\n    n (int): Bậc cao nhất của đa thức.\n    coeffs (List[int]): Một danh sách các hệ số, bắt đầu với hệ số của hạng tử có bậc cao nhất.\n\nTrả về:\n    str: Chuỗi biểu diễn của đa thức.\n\nVí dụ:\n    >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n    '100x^5-x^4+x^3-3x^2+10'\n\n    >>> polynomial_to_string(3, [-50, 0, 0, 1])\n    '-50x^3+1'", "id": "    Mengubah daftar koefisien polinomial menjadi representasi string yang diformat.\n\n    Fungsi ini menerima derajat tertinggi `n` dari polinomial dan daftar koefisien `coeffs`,\n    yang diurutkan dari suku dengan derajat tertinggi hingga suku konstanta. Fungsi ini mengembalikan string yang\n    mewakili polinomial dengan aturan berikut:\n    - Suku dengan koefisien nol dihilangkan.\n    - Tanda setiap suku ditentukan (+ untuk positif, - untuk negatif), tanpa '+' di depan untuk suku pertama.\n    - Nilai absolut dari koefisien ditampilkan kecuali jika koefisiennya 1 dan suku tersebut termasuk variabel `x`.\n    - Bagian variabel diformat berdasarkan derajatnya; `x^degree` untuk derajat > 1, `x` untuk derajat 1, dan\n      tidak ada untuk derajat 0 (suku konstanta).\n    - Suku-suku digabungkan tanpa spasi tambahan, dimulai dengan suku derajat tertinggi.\n\n    Args:\n        n (int): Derajat tertinggi dari polinomial.\n        coeffs (List[int]): Daftar koefisien, dimulai dengan koefisien dari suku dengan derajat tertinggi.\n\n    Returns:\n        str: Representasi string dari polinomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "ja": "    多項式の係数のリストをフォーマットされた文字列表現に変換します。\n\n    この関数は、多項式の最高次数 `n` と、最高次数の項から定数項まで順に並んだ係数のリスト `coeffs` を受け取り、\n    以下のルールに従って多項式を表す文字列を返します:\n    - 係数がゼロの項は省略されます。\n    - 各項の符号は決定されます（正の場合は +、負の場合は -）、最初の項には先頭の '+' は付きません。\n    - 係数の絶対値は、係数が1で項に変数 `x` が含まれる場合を除き表示されます。\n    - 変数部分はその次数に基づいてフォーマットされます。次数が1より大きい場合は `x^degree`、次数が1の場合は `x`、\n      定数項（次数0）の場合は何も付きません。\n    - 項は追加のスペースなしで結合され、最高次数の項から始まります。\n\n    引数:\n        n (int): 多項式の最高次数。\n        coeffs (List[int]): 最高次数の項の係数から始まる係数のリスト。\n\n    戻り値:\n        str: 多項式の文字列表現。\n\n    例:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "ko": "    다항식 계수 목록을 형식화된 문자열 표현으로 변환합니다.\n\n    이 함수는 다항식의 최고 차수 `n`과 계수 목록 `coeffs`를 입력으로 받습니다.\n    계수는 최고 차수 항부터 상수 항까지 순서대로 정렬되어 있습니다. 이 함수는 다음 규칙에 따라\n    다항식을 나타내는 문자열을 반환합니다:\n    - 계수가 0인 항은 생략됩니다.\n    - 각 항의 부호는 결정됩니다 (+는 양수, -는 음수), 첫 번째 항에는 선행 '+'가 없습니다.\n    - 계수의 절대값은 표시되지만, 계수가 1이고 항에 변수 `x`가 포함된 경우는 제외됩니다.\n    - 변수 부분은 차수에 따라 형식화됩니다; 차수가 1보다 크면 `x^degree`, 차수가 1이면 `x`,\n      차수가 0이면 아무것도 표시되지 않습니다 (상수 항).\n    - 항은 추가 공백 없이 결합되며, 최고 차수 항부터 시작합니다.\n\n    인수:\n        n (int): 다항식의 최고 차수.\n        coeffs (List[int]): 최고 차수 항의 계수부터 시작하는 계수 목록.\n\n    반환:\n        str: 다항식의 문자열 표현.\n\n    예:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "ml": "    പോളിനോമിയൽ ഗുണകങ്ങളുടെ പട്ടിക ഫോർമാറ്റ് ചെയ്ത സ്ട്രിംഗ് പ്രതിനിധാനത്തിലേക്ക് മാറ്റുന്നു.\n\n    ഫംഗ്ഷൻ പോളിനോമിയലിന്റെ ഏറ്റവും ഉയർന്ന ബിരുദം `n`യും, ഏറ്റവും ഉയർന്ന ബിരുദം മുതൽ സ്ഥിരാങ്കം വരെ ക്രമീകരിച്ചിരിക്കുന്ന ഗുണകങ്ങളുടെ പട്ടിക `coeffs`ഉം സ്വീകരിക്കുന്നു. ഇത് പോളിനോമിയലിനെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് തിരികെ നൽകുന്നു, താഴെ പറയുന്ന നിയമങ്ങൾ പാലിച്ച്:\n    - ശൂന്യമായ ഗുണകമുള്ള പദങ്ങൾ ഒഴിവാക്കപ്പെടുന്നു.\n    - ഓരോ പദത്തിന്റെ ചിഹ്നവും (സാന്ദർഭികമായാൽ +, പ്രത്യയമായാൽ -) നിർണ്ണയിക്കപ്പെടുന്നു, ആദ്യ പദത്തിന് മുൻപിൽ '+' ഇല്ല.\n    - ഗുണകത്തിന്റെ പരമാവധി മൂല്യം കാണിക്കുന്നു, ഇത് 1 ആണെങ്കിൽ മാത്രമേ പദം `x` എന്ന വ്യത്യാസം ഉൾക്കൊള്ളുന്നുവെങ്കിൽ.\n    - വ്യത്യാസഭാഗം അതിന്റെ ബിരുദത്തിന്റെ അടിസ്ഥാനത്തിൽ ഫോർമാറ്റ് ചെയ്യപ്പെടുന്നു; ബിരുദം > 1 ആണെങ്കിൽ `x^degree`, ബിരുദം 1 ആണെങ്കിൽ `x`, ബിരുദം 0 (സ്ഥിരാങ്കം) ആണെങ്കിൽ ഒന്നുമില്ല.\n    - പദങ്ങൾ അധിക ഇടങ്ങൾ ഇല്ലാതെ ചേർക്കുന്നു, ഏറ്റവും ഉയർന്ന ബിരുദ പദം ആരംഭിക്കുന്നതോടെ.\n\n    Arguments:\n        n (int): പോളിനോമിയലിന്റെ ഏറ്റവും ഉയർന്ന ബിരുദം.\n        coeffs (List[int]): ഏറ്റവും ഉയർന്ന ബിരുദ പദത്തിന്റെ ഗുണകത്തോടെ ആരംഭിക്കുന്ന ഗുണകങ്ങളുടെ പട്ടിക.\n\n    Returns:\n        str: പോളിനോമിയലിന്റെ സ്ട്രിംഗ് പ്രതിനിധാനം.\n\n    ഉദാഹരണങ്ങൾ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'", "fa": "    تبدیل لیستی از ضرایب چندجمله‌ای به یک نمایش رشته‌ای قالب‌بندی شده.\n\n    این تابع درجه بالاترین `n` چندجمله‌ای و لیستی از ضرایب `coeffs` را می‌گیرد،\n    که از جمله با بالاترین درجه تا جمله ثابت مرتب شده‌اند. این تابع رشته‌ای را برمی‌گرداند که\n    چندجمله‌ای را با قوانین زیر نمایش می‌دهد:\n    - جملاتی که ضریب آن‌ها صفر است حذف می‌شوند.\n    - علامت هر جمله تعیین می‌شود (+ برای مثبت، - برای منفی)، بدون '+' پیشرو برای جمله اول.\n    - مقدار مطلق ضریب نشان داده می‌شود مگر اینکه 1 باشد و جمله شامل متغیر `x` باشد.\n    - بخش متغیر بر اساس درجه آن قالب‌بندی می‌شود؛ `x^degree` برای درجه > 1، `x` برای درجه 1، و\n      هیچ چیز برای درجه 0 (جمله ثابت).\n    - جملات بدون فاصله اضافی و با شروع از جمله با بالاترین درجه به هم پیوسته می‌شوند.\n\n    آرگومان‌ها:\n        n (int): بالاترین درجه چندجمله‌ای.\n        coeffs (List[int]): لیستی از ضرایب، شروع با ضریب جمله با بالاترین درجه.\n\n    بازگشت:\n        str: نمایش رشته‌ای چندجمله‌ای.\n\n    مثال‌ها:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'"}}
{"task_id": "Python/21", "prompt": {"en": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "sq": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Zgjedh dhe përcakton pragun e pikëve të intervistës dhe listën e aplikantëve që kualifikohen për procesin e intervistës.\n    \n    Funksioni rendit aplikantët bazuar në pikët e tyre të testit në rend zbritës. Nëse disa aplikantë kanë të njëjtën pikë,\n    ata pastaj renditen sipas numrit të tyre të regjistrimit në rend rritës. Pragu i pikëve të intervistës llogaritet bazuar në 150%\n    të numrit të planifikuar të rekrutëve, i rrumbullakosur poshtë. Të gjithë aplikantët me pikë të barabarta ose më të larta se pragu konsiderohen\n    të kualifikuar për intervistë.\n    \n    Argumentet:\n    - n (int): Numri total i aplikantëve.\n    - m (int): Numri i planifikuar i vullnetarëve që do të rekrutohen.\n    - applicants (List[Tuple[int, int]]): Një listë tuples ku çdo tuple përmban numrin e regjistrimit dhe pikët e testit të një aplikanti.\n    \n    Kthen:\n    - Tuple[int, List[Tuple[int, int]]]: Një tuple që përmban pragun e pikëve të intervistës dhe një listë tuples, secila prej të cilave përfshin\n      numrin e regjistrimit dhe pikët e testit të aplikantëve të kualifikuar.\n    \n    Shembuj:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "hy": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Ընտրում է և որոշում հարցազրույցի գնահատականների շեմը և դիմորդների ցանկը, ովքեր որակավորվում են հարցազրույցի գործընթացի համար։\n    \n    Ֆունկցիան դասավորում է դիմորդներին ըստ նրանց թեստային գնահատականների նվազման կարգով։ Եթե մի քանի դիմորդներ ունեն նույն գնահատականը,\n    ապա նրանք դասավորվում են ըստ իրենց գրանցման համարի աճման կարգով։ Հարցազրույցի գնահատականների շեմը հաշվարկվում է ըստ նախատեսված\n    հավաքագրման 150%-ի, կլորացված ներքև։ Բոլոր դիմորդները, որոնց գնահատականները հավասար են կամ բարձր են շեմից, համարվում են\n    որակավորված հարցազրույցի համար։\n    \n    Պարամետրեր:\n    - n (int): Դիմորդների ընդհանուր քանակը։\n    - m (int): Նախատեսված հավաքագրվող կամավորների քանակը։\n    - applicants (List[Tuple[int, int]]): Ցանկ, որտեղ յուրաքանչյուր տուփ պարունակում է դիմորդի գրանցման համարը և թեստային գնահատականը։\n    \n    Վերադարձնում է:\n    - Tuple[int, List[Tuple[int, int]]]: Տուփ, որը պարունակում է հարցազրույցի գնահատականների շեմը և տուփերի ցանկ, որոնցից յուրաքանչյուրը ներառում է\n      որակավորված դիմորդների գրանցման համարը և թեստային գնահատականը։\n    \n    Օրինակներ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "bn": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    সাক্ষাৎকারের জন্য যোগ্য আবেদনকারীদের তালিকা এবং সাক্ষাৎকারের স্কোরের কাটঅফ নির্ধারণ করে নির্বাচন করে।\n\n    ফাংশনটি আবেদনকারীদের তাদের টেস্ট স্কোর অনুযায়ী অবতরণ ক্রমে সাজায়। যদি একাধিক আবেদনকারীর একই স্কোর থাকে,\n    তাহলে তাদের রেজিস্ট্রেশন নম্বর অনুযায়ী আরোহী ক্রমে সাজানো হয়। পরিকল্পিত নিয়োগের 150% ভিত্তিতে সাক্ষাৎকারের স্কোরের কাটঅফ\n    গণনা করা হয়, যা নিচের দিকে পূর্ণসংখ্যায় পরিণত হয়। সকল আবেদনকারী যাদের স্কোর কাটঅফের সমান বা তার বেশি, তারা সাক্ষাৎকারের জন্য\n    যোগ্য বলে বিবেচিত হয়।\n\n    আর্গুমেন্টসমূহ:\n    - n (int): মোট আবেদনকারীর সংখ্যা।\n    - m (int): পরিকল্পিত স্বেচ্ছাসেবকদের সংখ্যা যারা নিয়োগ করা হবে।\n    - applicants (List[Tuple[int, int]]): একটি তালিকা যেখানে প্রতিটি টুপলে আবেদনকারীর রেজিস্ট্রেশন নম্বর এবং টেস্ট স্কোর থাকে।\n\n    রিটার্নস:\n    - Tuple[int, List[Tuple[int, int]]]: একটি টুপল যা সাক্ষাৎকারের স্কোরের কাটঅফ এবং যোগ্য আবেদনকারীদের তালিকা সহ প্রতিটি টুপল\n      অন্তর্ভুক্ত করে, যেখানে প্রতিটি টুপলে আবেদনকারীর রেজিস্ট্রেশন নম্বর এবং টেস্ট স্কোর থাকে।\n\n    উদাহরণ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "bg": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Избира и определя прага за оценка на интервюто и списъка на кандидатите, които се квалифицират за процеса на интервю.\n    \n    Функцията сортира кандидатите по техните тестови оценки в низходящ ред. Ако няколко кандидати имат една и съща оценка,\n    те се сортират по регистрационния си номер във възходящ ред. Прагът за оценка на интервюто се изчислява на базата на 150%\n    от планирания брой на наетите, закръглен надолу. Всички кандидати с оценки, равни или по-високи от прага, се считат за\n    квалифицирани за интервюто.\n    \n    Аргументи:\n    - n (int): Общият брой на кандидатите.\n    - m (int): Планираният брой на доброволците, които ще бъдат наети.\n    - applicants (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа регистрационния номер и тестовата оценка на кандидат.\n    \n    Връща:\n    - Tuple[int, List[Tuple[int, int]]]: Кортеж, съдържащ прага за оценка на интервюто и списък от кортежи, всеки от които включва\n      регистрационния номер и тестовата оценка на квалифицираните кандидати.\n    \n    Примери:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "zh": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    选择并确定面试分数线以及符合面试流程的申请人名单。\n    \n    该函数根据申请人的测试成绩按降序排序。如果多个申请人的成绩相同，则按注册号升序排序。\n    面试分数线是基于计划招募人数的150%计算的，向下取整。所有成绩等于或高于分数线的申请人被视为符合面试资格。\n    \n    参数:\n    - n (int): 申请人的总数。\n    - m (int): 计划招募的志愿者人数。\n    - applicants (List[Tuple[int, int]]): 一个包含元组的列表，每个元组包含申请人的注册号和测试成绩。\n    \n    返回:\n    - Tuple[int, List[Tuple[int, int]]]: 一个包含面试分数线和符合资格的申请人名单的元组，每个元组包括申请人的注册号和测试成绩。\n    \n    示例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "fr": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Sélectionne et détermine le seuil de score d'entretien et la liste des candidats qui se qualifient pour le processus d'entretien.\n    \n    La fonction trie les candidats en fonction de leurs scores de test par ordre décroissant. Si plusieurs candidats ont le même score,\n    ils sont ensuite triés par leur numéro d'inscription par ordre croissant. Le seuil de score d'entretien est calculé sur la base de 150%\n    du nombre prévu de recrues, arrondi à l'entier inférieur. Tous les candidats avec des scores égaux ou supérieurs au seuil sont considérés\n    comme qualifiés pour l'entretien.\n    \n    Args:\n    - n (int): Le nombre total de candidats.\n    - m (int): Le nombre prévu de volontaires à recruter.\n    - applicants (List[Tuple[int, int]]): Une liste de tuples où chaque tuple contient le numéro d'inscription et le score de test d'un candidat.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Un tuple contenant le seuil de score d'entretien et une liste de tuples, chacun incluant\n      le numéro d'inscription et le score de test des candidats qualifiés.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "de": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Wählt aus und bestimmt die Interview-Punktzahlgrenze sowie die Liste der Bewerber, die sich für den Interviewprozess qualifizieren.\n    \n    Die Funktion sortiert die Bewerber basierend auf ihren Testergebnissen in absteigender Reihenfolge. Wenn mehrere Bewerber die gleiche Punktzahl haben,\n    werden sie anschließend nach ihrer Registrierungsnummer in aufsteigender Reihenfolge sortiert. Die Interview-Punktzahlgrenze wird basierend auf 150%\n    der geplanten Anzahl von Rekruten berechnet, abgerundet. Alle Bewerber mit Punktzahlen, die gleich oder höher als die Grenze sind, gelten als\n    qualifiziert für das Interview.\n    \n    Argumente:\n    - n (int): Die Gesamtzahl der Bewerber.\n    - m (int): Die geplante Anzahl der zu rekrutierenden Freiwilligen.\n    - applicants (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die Registrierungsnummer und die Testergebnisse eines Bewerbers enthält.\n    \n    Rückgabe:\n    - Tuple[int, List[Tuple[int, int]]]: Ein Tupel, das die Interview-Punktzahlgrenze und eine Liste von Tupeln enthält, von denen jedes die\n      Registrierungsnummer und die Testergebnisse qualifizierter Bewerber umfasst.\n    \n    Beispiele:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "ha": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Zaɓi kuma ƙayyade ƙimar ƙimar hira da jerin masu nema waɗanda suka cancanci tsarin hira.\n    \n    Aikin yana tsara masu nema bisa ga maki gwajinsu a cikin tsari mai saukowa. Idan masu nema da yawa suna da maki iri ɗaya,\n    to ana tsara su ta hanyar lambar rajistarsu a cikin tsari mai hawa. Ana ƙididdige ƙimar ƙimar hira bisa ga 150%\n    na adadin masu son da aka shirya, an zagaye ƙasa. Duk masu nema da maki daidai ko mafi girma fiye da ƙimar sun cancanci\n    a ɗauke su a matsayin waɗanda suka cancanci hirar.\n    \n    Args:\n    - n (int): Jimillar adadin masu nema.\n    - m (int): Adadin masu son da aka shirya za a ɗauka.\n    - applicants (List[Tuple[int, int]]): Jerin tuples inda kowanne ya ƙunshi lambar rajista da maki gwajin mai nema.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Tuple mai ɗauke da ƙimar ƙimar hira da jerin tuples, kowanne yana ɗauke da\n      lambar rajista da maki gwajin masu nema da suka cancanta.\n    \n    Misalai:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "hi": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    साक्षात्कार स्कोर कटऑफ और उन आवेदकों की सूची का चयन और निर्धारण करता है जो साक्षात्कार प्रक्रिया के लिए योग्य हैं।\n    \n    यह फ़ंक्शन आवेदकों को उनके टेस्ट स्कोर के आधार पर अवरोही क्रम में क्रमबद्ध करता है। यदि कई आवेदकों के समान स्कोर हैं,\n    तो उन्हें उनके पंजीकरण संख्या के आधार पर आरोही क्रम में क्रमबद्ध किया जाता है। साक्षात्कार स्कोर कटऑफ की गणना नियोजित\n    भर्ती संख्या के 150% के आधार पर की जाती है, जिसे नीचे की ओर पूर्णांकित किया जाता है। सभी आवेदक जिनके स्कोर कटऑफ के\n    बराबर या उससे अधिक हैं, साक्षात्कार के लिए योग्य माने जाते हैं।\n    \n    तर्क:\n    - n (int): कुल आवेदकों की संख्या।\n    - m (int): नियोजित स्वयंसेवकों की संख्या जिन्हें भर्ती किया जाना है।\n    - applicants (List[Tuple[int, int]]): एक सूची जिसमें प्रत्येक टपल में एक आवेदक की पंजीकरण संख्या और टेस्ट स्कोर शामिल होता है।\n    \n    लौटाता है:\n    - Tuple[int, List[Tuple[int, int]]]: एक टपल जिसमें साक्षात्कार स्कोर कटऑफ और टपल की एक सूची शामिल होती है, जिनमें से प्रत्येक में\n      योग्य आवेदकों की पंजीकरण संख्या और टेस्ट स्कोर शामिल होता है।\n    \n    उदाहरण:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "hu": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Kiválasztja és meghatározza az interjú pontszám küszöböt és az interjú folyamatra kvalifikált jelentkezők listáját.\n    \n    A függvény csökkenő sorrendbe rendezi a jelentkezőket a tesztpontszámaik alapján. Ha több jelentkezőnek azonos a pontszáma,\n    akkor a regisztrációs számuk alapján növekvő sorrendbe kerülnek. Az interjú pontszám küszöböt a tervezett toborzási létszám\n    150%-a alapján számítják ki, lefelé kerekítve. Minden jelentkező, akinek a pontszáma eléri vagy meghaladja a küszöböt,\n    kvalifikáltnak tekintendő az interjúra.\n    \n    Paraméterek:\n    - n (int): A jelentkezők teljes száma.\n    - m (int): A tervezett önkéntesek száma, akiket toborozni kívánnak.\n    - applicants (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy tuple, amely tartalmazza a jelentkező\n      regisztrációs számát és tesztpontszámát.\n    \n    Visszatérési érték:\n    - Tuple[int, List[Tuple[int, int]]]: Egy tuple, amely tartalmazza az interjú pontszám küszöböt és egy listát,\n      amelyben minden elem egy tuple, amely tartalmazza a kvalifikált jelentkezők regisztrációs számát és tesztpontszámát.\n    \n    Példák:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "es": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selecciona y determina el puntaje de corte para la entrevista y la lista de solicitantes que califican para el proceso de entrevista.\n    \n    La función ordena a los solicitantes en función de sus puntajes de prueba en orden descendente. Si varios solicitantes tienen el mismo puntaje,\n    luego se ordenan por su número de registro en orden ascendente. El puntaje de corte para la entrevista se calcula en base al 150%\n    del número planeado de reclutas, redondeado hacia abajo. Todos los solicitantes con puntajes iguales o superiores al corte se consideran\n    calificados para la entrevista.\n    \n    Argumentos:\n    - n (int): El número total de solicitantes.\n    - m (int): El número planeado de voluntarios a reclutar.\n    - applicants (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla contiene el número de registro y el puntaje de prueba de un solicitante.\n    \n    Devuelve:\n    - Tuple[int, List[Tuple[int, int]]]: Una tupla que contiene el puntaje de corte para la entrevista y una lista de tuplas, cada una de las cuales incluye\n      el número de registro y el puntaje de prueba de los solicitantes calificados.\n    \n    Ejemplos:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "arb": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    يختار ويحدد درجة المقابلة الفاصلة وقائمة المتقدمين الذين يتأهلون لعملية المقابلة.\n    \n    تقوم الدالة بترتيب المتقدمين بناءً على درجات اختبارهم بترتيب تنازلي. إذا كان لدى عدة متقدمين نفس الدرجة،\n    يتم ترتيبهم بعد ذلك حسب رقم تسجيلهم بترتيب تصاعدي. يتم حساب درجة المقابلة الفاصلة بناءً على 150%\n    من العدد المخطط لتجنيد المتطوعين، مع التقريب للأسفل. جميع المتقدمين الذين لديهم درجات تساوي أو تزيد عن الفاصلة يعتبرون\n    مؤهلين للمقابلة.\n    \n    يعيدالحجج:\n    - n (int): العدد الإجمالي للمتقدمين.\n    - m (int): العدد المخطط لتجنيد المتطوعين.\n    - applicants (List[Tuple[int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على رقم التسجيل ودرجة اختبار المتقدم.\n    \n    يعيد:\n    - Tuple[int, List[Tuple[int, int]]]: زوج يحتوي على درجة المقابلة الفاصلة وقائمة من الأزواج، كل منها يشمل\n      رقم التسجيل ودرجة اختبار المتقدمين المؤهلين.\n    \n    أمثلة:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "sw": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Huchagua na kuamua alama ya mahojiano na orodha ya waombaji wanaostahili kwa mchakato wa mahojiano.\n    \n    Kazi hii hupanga waombaji kulingana na alama zao za mtihani kwa mpangilio wa kushuka. Ikiwa waombaji kadhaa wana alama sawa,\n    basi hupangwa kulingana na namba zao za usajili kwa mpangilio wa kupanda. Alama ya mahojiano inahesabiwa kwa msingi wa 150%\n    ya idadi iliyopangwa ya wanaojitolea, ikipunguzwa chini. Waombaji wote wenye alama sawa au zaidi ya alama hiyo wanachukuliwa\n    kuwa wanastahili kwa mahojiano.\n    \n    Hoja:\n    - n (int): Jumla ya idadi ya waombaji.\n    - m (int): Idadi iliyopangwa ya wanaojitolea watakaoajiriwa.\n    - applicants (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi ina namba ya usajili na alama ya mtihani ya mwombaji.\n    \n    Inarejesha:\n    - Tuple[int, List[Tuple[int, int]]]: Jozi inayoelezea alama ya mahojiano na orodha ya jozi, ambapo kila moja inajumuisha\n      namba ya usajili na alama ya mtihani ya waombaji waliostahili.\n    \n    Mifano:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "tr": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Mülakat puanı barajını ve mülakat sürecine hak kazanan başvuru sahiplerinin listesini seçer ve belirler.\n    \n    Fonksiyon, başvuru sahiplerini test puanlarına göre azalan sırayla sıralar. Birden fazla başvuru sahibi aynı puana sahipse,\n    kayıt numaralarına göre artan sırayla sıralanırlar. Mülakat puanı barajı, planlanan işe alınacak gönüllü sayısının %150'si\n    baz alınarak hesaplanır ve aşağı yuvarlanır. Puanları baraj puanına eşit veya daha yüksek olan tüm başvuru sahipleri\n    mülakat için nitelikli kabul edilir.\n    \n    Argümanlar:\n    - n (int): Toplam başvuru sahibi sayısı.\n    - m (int): Planlanan işe alınacak gönüllü sayısı.\n    - applicants (List[Tuple[int, int]]): Her bir demetin bir başvuru sahibinin kayıt numarasını ve test puanını içerdiği demetlerin listesi.\n    \n    Döndürür:\n    - Tuple[int, List[Tuple[int, int]]]: Mülakat puanı barajını ve her biri nitelikli başvuru sahiplerinin kayıt numarası ve test puanını içeren\n      demetlerin listesini içeren bir demet.\n    \n    Örnekler:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "vi": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Lựa chọn và xác định điểm phỏng vấn cắt và danh sách ứng viên đủ điều kiện cho quá trình phỏng vấn.\n    \n    Hàm sắp xếp các ứng viên dựa trên điểm thi của họ theo thứ tự giảm dần. Nếu nhiều ứng viên có cùng điểm số,\n    họ sẽ được sắp xếp theo số đăng ký theo thứ tự tăng dần. Điểm phỏng vấn cắt được tính dựa trên 150%\n    số lượng tuyển dụng dự kiến, làm tròn xuống. Tất cả các ứng viên có điểm số bằng hoặc cao hơn điểm cắt được coi là\n    đủ điều kiện cho phỏng vấn.\n    \n    Tham số:\n    - n (int): Tổng số ứng viên.\n    - m (int): Số lượng tình nguyện viên dự kiến được tuyển dụng.\n    - applicants (List[Tuple[int, int]]): Một danh sách các bộ giá trị, mỗi bộ chứa số đăng ký và điểm thi của một ứng viên.\n    \n    Trả về:\n    - Tuple[int, List[Tuple[int, int]]]: Một bộ giá trị chứa điểm phỏng vấn cắt và danh sách các bộ giá trị, mỗi bộ bao gồm\n      số đăng ký và điểm thi của các ứng viên đủ điều kiện.\n    \n    Ví dụ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "id": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Memilih dan menentukan batas skor wawancara serta daftar pelamar yang memenuhi syarat untuk proses wawancara.\n    \n    Fungsi ini mengurutkan pelamar berdasarkan skor tes mereka dalam urutan menurun. Jika beberapa pelamar memiliki skor yang sama,\n    mereka kemudian diurutkan berdasarkan nomor registrasi mereka dalam urutan naik. Batas skor wawancara dihitung berdasarkan 150%\n    dari jumlah rencana rekrutmen, dibulatkan ke bawah. Semua pelamar dengan skor sama atau lebih tinggi dari batas dianggap\n    memenuhi syarat untuk wawancara.\n    \n    Args:\n    - n (int): Jumlah total pelamar.\n    - m (int): Jumlah rencana sukarelawan yang akan direkrut.\n    - applicants (List[Tuple[int, int]]): Daftar tuple di mana setiap tuple berisi nomor registrasi dan skor tes dari seorang pelamar.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Sebuah tuple yang berisi batas skor wawancara dan daftar tuple, masing-masing termasuk\n      nomor registrasi dan skor tes dari pelamar yang memenuhi syarat.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "ja": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    面接スコアのカットオフと面接プロセスに適格な応募者のリストを選択して決定します。\n    \n    この関数は、応募者をテストスコアに基づいて降順に並べ替えます。複数の応募者が同じスコアを持つ場合、\n    彼らは登録番号で昇順に並べ替えられます。面接スコアのカットオフは、計画された採用人数の150%に基づいて計算され、\n    切り捨てられます。カットオフ以上のスコアを持つすべての応募者は、面接に適格と見なされます。\n    \n    引数:\n    - n (int): 応募者の総数。\n    - m (int): 採用予定のボランティアの人数。\n    - applicants (List[Tuple[int, int]]): 各タプルが応募者の登録番号とテストスコアを含むタプルのリスト。\n    \n    戻り値:\n    - Tuple[int, List[Tuple[int, int]]]: 面接スコアのカットオフと、適格な応募者の登録番号とテストスコアを含む\n      タプルのリストを含むタプル。\n    \n    例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "ko": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    면접 점수 컷오프와 면접 과정에 적합한 지원자 목록을 선택하고 결정합니다.\n    \n    이 함수는 지원자들을 시험 점수를 기준으로 내림차순으로 정렬합니다. 여러 지원자가 동일한 점수를 받은 경우,\n    그들은 등록 번호를 기준으로 오름차순으로 정렬됩니다. 면접 점수 컷오프는 계획된 모집 인원의 150%를 기준으로\n    계산되며, 내림됩니다. 컷오프 점수 이상을 받은 모든 지원자는 면접에 적합한 것으로 간주됩니다.\n    \n    매개변수:\n    - n (int): 지원자의 총 수.\n    - m (int): 계획된 모집 자원봉사자 수.\n    - applicants (List[Tuple[int, int]]): 각 튜플이 지원자의 등록 번호와 시험 점수를 포함하는 튜플 목록.\n    \n    반환값:\n    - Tuple[int, List[Tuple[int, int]]]: 면접 점수 컷오프와 각 튜플이 적합한 지원자의 등록 번호와 시험 점수를 포함하는\n      튜플 목록을 포함하는 튜플.\n    \n    예제:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "ml": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    അഭിമുഖ പ്രക്രിയയ്ക്ക് യോഗ്യത നേടുന്ന അപേക്ഷകരുടെ പട്ടികയും അഭിമുഖ സ്കോർ പരിധിയും തിരഞ്ഞെടുക്കുന്നു.\n    \n    ഫംഗ്ഷൻ അപേക്ഷകരെ അവരുടെ ടെസ്റ്റ് സ്കോറിന്റെ അടിസ്ഥാനത്തിൽ ഇറങ്ങുന്ന ക്രമത്തിൽ ക്രമീകരിക്കുന്നു. ഒരേ സ്കോർ ഉള്ള നിരവധി അപേക്ഷകരുണ്ടെങ്കിൽ,\n    അവർ അവരുടെ രജിസ്ട്രേഷൻ നമ്പർ ഉയർന്ന ക്രമത്തിൽ ക്രമീകരിക്കപ്പെടുന്നു. അഭിമുഖ സ്കോർ പരിധി റിക്രൂട്ട് ചെയ്യാൻ ഉദ്ദേശിക്കുന്ന വോളന്റിയർമാരുടെ 150%\n    അടിസ്ഥാനമാക്കി കണക്കാക്കുന്നു, താഴേക്ക് വട്ടമിടുന്നു. പരിധിയേക്കാൾ തുല്യമായ അല്ലെങ്കിൽ ഉയർന്ന സ്കോറുള്ള എല്ലാ അപേക്ഷകരും\n    അഭിമുഖത്തിന് യോഗ്യരായി കണക്കാക്കപ്പെടുന്നു.\n    \n    Args:\n    - n (int): മൊത്തം അപേക്ഷകരുടെ എണ്ണം.\n    - m (int): റിക്രൂട്ട് ചെയ്യാൻ ഉദ്ദേശിക്കുന്ന വോളന്റിയർമാരുടെ എണ്ണം.\n    - applicants (List[Tuple[int, int]]): ഓരോ അപേക്ഷകന്റെയും രജിസ്ട്രേഷൻ നമ്പറും ടെസ്റ്റ് സ്കോറും അടങ്ങിയ ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: അഭിമുഖ സ്കോർ പരിധിയും യോഗ്യത നേടിയ അപേക്ഷകരുടെ രജിസ്ട്രേഷൻ നമ്പറും ടെസ്റ്റ് സ്കോറും ഉൾപ്പെടുന്ന ട്യൂപ്പിളുകളുടെ പട്ടികയും അടങ്ങിയ ട്യൂപ്പിൾ.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"", "fa": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    انتخاب و تعیین حد نصاب نمره مصاحبه و لیست متقاضیانی که برای فرآیند مصاحبه واجد شرایط هستند.\n\n    این تابع متقاضیان را بر اساس نمرات آزمونشان به ترتیب نزولی مرتب می‌کند. اگر چندین متقاضی نمره یکسانی داشته باشند،\n    سپس بر اساس شماره ثبت‌نامشان به ترتیب صعودی مرتب می‌شوند. حد نصاب نمره مصاحبه بر اساس 150% تعداد برنامه‌ریزی‌شده\n    برای جذب، به پایین گرد می‌شود. تمام متقاضیانی که نمره‌ای برابر یا بالاتر از حد نصاب دارند، به عنوان واجد شرایط\n    برای مصاحبه در نظر گرفته می‌شوند.\n\n    آرگومان‌ها:\n    - n (int): تعداد کل متقاضیان.\n    - m (int): تعداد برنامه‌ریزی‌شده داوطلبانی که قرار است جذب شوند.\n    - applicants (List[Tuple[int, int]]): لیستی از زوج‌ها که هر زوج شامل شماره ثبت‌نام و نمره آزمون یک متقاضی است.\n\n    بازگشتی:\n    - Tuple[int, List[Tuple[int, int]]]: یک زوج شامل حد نصاب نمره مصاحبه و لیستی از زوج‌ها که هر کدام شامل\n      شماره ثبت‌نام و نمره آزمون متقاضیان واجد شرایط است.\n\n    مثال‌ها:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\""}, "canonical_solution": "    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants", "instruction": {"en": "Write a python function 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' to solve the following problem:\n\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    ", "sq": "Shkruani një funksion python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' për të zgjidhur problemin e mëposhtëm:\n\n    Zgjedh dhe përcakton pragun e pikëve të intervistës dhe listën e aplikantëve që kualifikohen për procesin e intervistës.\n    \n    Funksioni rendit aplikantët bazuar në pikët e tyre të testit në rend zbritës. Nëse disa aplikantë kanë të njëjtën pikë,\n    ata renditen më pas sipas numrit të tyre të regjistrimit në rend rritës. Pragu i pikëve të intervistës llogaritet bazuar në 150%\n    të numrit të planifikuar të rekrutëve, i rrumbullakosur poshtë. Të gjithë aplikantët me pikë të barabarta ose më të larta se pragu konsiderohen\n    të kualifikuar për intervistë.\n    \n    Argumentet:\n    - n (int): Numri total i aplikantëve.\n    - m (int): Numri i planifikuar i vullnetarëve që do të rekrutohen.\n    - applicants (List[Tuple[int, int]]): Një listë tuples ku çdo tuple përmban numrin e regjistrimit dhe pikët e testit të një aplikanti.\n    \n    Kthen:\n    - Tuple[int, List[Tuple[int, int]]]: Një tuple që përmban pragun e pikëve të intervistës dhe një listë tuples, secili prej të cilëve përfshin\n      numrin e regjistrimit dhe pikët e testit të aplikantëve të kualifikuar.\n    \n    Shembuj:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "hy": "Պայթոն ֆունկցիա 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Ընտրում է և որոշում հարցազրույցի միավորների շեմը և դիմորդների ցուցակը, ովքեր որակավորվում են հարցազրույցի գործընթացի համար:\n    \n    Ֆունկցիան դասավորում է դիմորդներին ըստ նրանց թեստային միավորների նվազման կարգով: Եթե մի քանի դիմորդներ ունեն նույն միավորը,\n    ապա նրանք դասավորվում են ըստ իրենց գրանցման համարի աճման կարգով: Հարցազրույցի միավորների շեմն հաշվարկվում է ըստ նախատեսված\n    հավաքագրման 150%-ի, կլորացված ներքև: Բոլոր դիմորդները, որոնց միավորները հավասար են կամ բարձր են շեմից, համարվում են\n    որակավորված հարցազրույցի համար:\n    \n    Արգումենտներ:\n    - n (int): Դիմորդների ընդհանուր քանակը:\n    - m (int): Նախատեսված հավաքագրվող կամավորների քանակը:\n    - applicants (List[Tuple[int, int]]): Ցուցակ, որտեղ յուրաքանչյուր տուփ պարունակում է դիմորդի գրանցման համարը և թեստային միավորը:\n    \n    Վերադարձնում է:\n    - Tuple[int, List[Tuple[int, int]]]: Տուփ, որը պարունակում է հարցազրույցի միավորների շեմը և տուփերի ցուցակը, որոնցից յուրաքանչյուրը ներառում է\n      որակավորված դիմորդների գրանցման համարը և թեստային միավորը:\n    \n    Օրինակներ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "bn": "একটি পাইথন ফাংশন 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    সাক্ষাৎকার স্কোরের কাটঅফ এবং সাক্ষাৎকার প্রক্রিয়ার জন্য যোগ্য আবেদনকারীদের তালিকা নির্বাচন এবং নির্ধারণ করে।\n    \n    ফাংশনটি আবেদনকারীদের তাদের পরীক্ষার স্কোরের উপর ভিত্তি করে অবতরণ ক্রমে সাজায়। যদি একাধিক আবেদনকারীর একই স্কোর থাকে,\n    তবে তাদের নিবন্ধন নম্বরের উপর ভিত্তি করে আরোহী ক্রমে সাজানো হয়। পরিকল্পিত নিয়োগের 150% এর উপর ভিত্তি করে সাক্ষাৎকার স্কোরের কাটঅফ গণনা করা হয়,\n    নিচের দিকে পূর্ণসংখ্যায় পরিণত করে। সমস্ত আবেদনকারী যারা কাটঅফের সমান বা তার চেয়ে বেশি স্কোর পায় তাদের সাক্ষাৎকারের জন্য যোগ্য বলে বিবেচনা করা হয়।\n    \n    আর্গুমেন্টস:\n    - n (int): মোট আবেদনকারীর সংখ্যা।\n    - m (int): পরিকল্পিত স্বেচ্ছাসেবকদের সংখ্যা যারা নিয়োগ করা হবে।\n    - applicants (List[Tuple[int, int]]): একটি তালিকা যেখানে প্রতিটি টিউপলে একটি আবেদনকারীর নিবন্ধন নম্বর এবং পরীক্ষার স্কোর থাকে।\n    \n    রিটার্নস:\n    - Tuple[int, List[Tuple[int, int]]]: একটি টিউপল যা সাক্ষাৎকার স্কোরের কাটঅফ এবং টিউপলের একটি তালিকা ধারণ করে, যার প্রতিটিতে\n      যোগ্য আবেদনকারীদের নিবন্ধন নম্বর এবং পরীক্ষার স্কোর অন্তর্ভুক্ত থাকে।\n    \n    উদাহরণ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "bg": "Напишете Python функция 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' за решаване на следния проблем:\n\n    Избира и определя прага за оценка на интервюто и списъка на кандидатите, които се класират за интервю процеса.\n    \n    Функцията сортира кандидатите въз основа на техните тестови оценки в низходящ ред. Ако няколко кандидати имат една и съща оценка,\n    те се сортират по регистрационен номер във възходящ ред. Прагът за оценка на интервюто се изчислява въз основа на 150%\n    от планирания брой на наетите, закръглено надолу. Всички кандидати с оценки, равни или по-високи от прага, се считат\n    за квалифицирани за интервюто.\n    \n    Аргументи:\n    - n (int): Общият брой на кандидатите.\n    - m (int): Планираният брой доброволци за наемане.\n    - applicants (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа регистрационния номер и тестовата оценка на кандидат.\n    \n    Връща:\n    - Tuple[int, List[Tuple[int, int]]]: Кортеж, съдържащ прага за оценка на интервюто и списък от кортежи, всеки от които включва\n      регистрационния номер и тестовата оценка на квалифицираните кандидати.\n    \n    Примери:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "zh": "编写一个Python函数 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' 来解决以下问题：\n\n    选择并确定面试分数的截止线以及符合面试流程的申请者名单。\n    \n    函数根据申请者的测试分数按降序排序。如果多个申请者有相同的分数，\n    则按其注册号按升序排序。面试分数的截止线是基于计划招聘人数的150%计算的，并向下取整。\n    所有分数等于或高于截止线的申请者被认为符合面试资格。\n    \n    参数:\n    - n (int): 申请者的总人数。\n    - m (int): 计划招聘的志愿者人数。\n    - applicants (List[Tuple[int, int]]): 一个包含元组的列表，每个元组包含申请者的注册号和测试分数。\n    \n    返回:\n    - Tuple[int, List[Tuple[int, int]]]: 一个包含面试分数截止线和符合资格的申请者名单的元组，\n      每个元组包含申请者的注册号和测试分数。\n    \n    示例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "fr": "Écrire une fonction python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' pour résoudre le problème suivant :\n\n    Sélectionne et détermine le seuil de score d'entretien et la liste des candidats qui se qualifient pour le processus d'entretien.\n    \n    La fonction trie les candidats en fonction de leurs scores de test par ordre décroissant. Si plusieurs candidats ont le même score,\n    ils sont ensuite triés par leur numéro d'inscription par ordre croissant. Le seuil de score d'entretien est calculé sur la base de 150%\n    du nombre prévu de recrues, arrondi à l'entier inférieur. Tous les candidats avec des scores égaux ou supérieurs au seuil sont considérés\n    comme qualifiés pour l'entretien.\n    \n    Args:\n    - n (int) : Le nombre total de candidats.\n    - m (int) : Le nombre prévu de volontaires à recruter.\n    - applicants (List[Tuple[int, int]]) : Une liste de tuples où chaque tuple contient le numéro d'inscription et le score de test d'un candidat.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]] : Un tuple contenant le seuil de score d'entretien et une liste de tuples, chacun incluant\n      le numéro d'inscription et le score de test des candidats qualifiés.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "de": "Schreiben Sie eine Python-Funktion 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' um das folgende Problem zu lösen:\n\n    Wählt aus und bestimmt die Interview-Punktzahl-Grenze und die Liste der Bewerber, die sich für den Interviewprozess qualifizieren.\n    \n    Die Funktion sortiert die Bewerber basierend auf ihren Testergebnissen in absteigender Reihenfolge. Wenn mehrere Bewerber die gleiche Punktzahl haben,\n    werden sie dann nach ihrer Registrierungsnummer in aufsteigender Reihenfolge sortiert. Die Interview-Punktzahl-Grenze wird basierend auf 150%\n    der geplanten Anzahl von Rekruten berechnet, abgerundet. Alle Bewerber mit Punktzahlen, die gleich oder höher als die Grenze sind, gelten als\n    für das Interview qualifiziert.\n    \n    Argumente:\n    - n (int): Die Gesamtzahl der Bewerber.\n    - m (int): Die geplante Anzahl der zu rekrutierenden Freiwilligen.\n    - applicants (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die Registrierungsnummer und die Testergebnisse eines Bewerbers enthält.\n    \n    Rückgabewerte:\n    - Tuple[int, List[Tuple[int, int]]]: Ein Tupel, das die Interview-Punktzahl-Grenze und eine Liste von Tupeln enthält, von denen jedes die\n      Registrierungsnummer und die Testergebnisse der qualifizierten Bewerber umfasst.\n    \n    Beispiele:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "ha": "Rubuta wani aikin python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' don warware matsalar mai zuwa:\n\n    Zabi da tantance iyakar maki na hira da jerin masu nema da suka cancanci shiga tsarin hirar.\n    \n    Aikin yana tsara masu nema bisa ga maki na gwaji daga mafi girma zuwa mafi ƙanƙanta. Idan masu nema da yawa suna da maki ɗaya,\n    to ana tsara su bisa ga lambar rajista daga mafi ƙanƙanta zuwa mafi girma. Ana lissafin iyakar maki na hira bisa ga 150%\n    na adadin masu daukar aiki da aka tsara, an zagaye ƙasa. Duk masu nema da suka samu maki daidai ko sama da iyakar ana ɗauka\n    sun cancanci shiga hirar.\n    \n    Args:\n    - n (int): Jimillar adadin masu nema.\n    - m (int): Adadin masu sa kai da aka shirya dauka.\n    - applicants (List[Tuple[int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi lambar rajista da maki na gwajin mai nema.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Tuple wanda ya ƙunshi iyakar maki na hira da jerin tuples, kowanne ya haɗa da\n      lambar rajista da maki na gwajin masu nema da suka cancanta.\n    \n    Misalai:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "hi": "एक पायथन फ़ंक्शन 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    साक्षात्कार प्रक्रिया के लिए अर्हता प्राप्त करने वाले आवेदकों की सूची और साक्षात्कार स्कोर कटऑफ का चयन और निर्धारण करता है।\n    \n    फ़ंक्शन आवेदकों को उनके टेस्ट स्कोर के आधार पर अवरोही क्रम में क्रमबद्ध करता है। यदि कई आवेदकों के समान स्कोर हैं,\n    तो उन्हें उनके पंजीकरण संख्या के आधार पर आरोही क्रम में क्रमबद्ध किया जाता है। साक्षात्कार स्कोर कटऑफ नियोजित भर्ती संख्या के 150% के आधार पर गणना की जाती है,\n    जिसे नीचे की ओर पूर्णांकित किया जाता है। सभी आवेदक जिनके स्कोर कटऑफ के बराबर या उससे अधिक हैं, उन्हें साक्षात्कार के लिए योग्य माना जाता है।\n    \n    तर्क:\n    - n (int): कुल आवेदकों की संख्या।\n    - m (int): नियोजित स्वयंसेवकों की संख्या जिन्हें भर्ती किया जाना है।\n    - applicants (List[Tuple[int, int]]): एक सूची जिसमें प्रत्येक टपल में एक आवेदक की पंजीकरण संख्या और टेस्ट स्कोर होता है।\n    \n    लौटाता है:\n    - Tuple[int, List[Tuple[int, int]]]: एक टपल जिसमें साक्षात्कार स्कोर कटऑफ और टपल की एक सूची होती है, जिसमें प्रत्येक में\n      योग्य आवेदकों की पंजीकरण संख्या और टेस्ट स्कोर शामिल होता है।\n    \n    उदाहरण:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "hu": "Írj egy python függvényt 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' a következő probléma megoldására:\n\n    Kiválasztja és meghatározza az interjú pontszám küszöbértékét és azon jelentkezők listáját, akik megfelelnek az interjú folyamatra.\n    \n    A függvény a jelentkezőket a tesztpontszámuk alapján csökkenő sorrendbe rendezi. Ha több jelentkezőnek azonos a pontszáma,\n    akkor a regisztrációs számuk alapján növekvő sorrendbe rendeződnek. Az interjú pontszám küszöbértéke a tervezett toborzási létszám 150%-a\n    alapján kerül kiszámításra, lefelé kerekítve. Minden jelentkező, akinek a pontszáma eléri vagy meghaladja a küszöbértéket,\n    alkalmasnak minősül az interjúra.\n    \n    Paraméterek:\n    - n (int): A jelentkezők összesített száma.\n    - m (int): A tervezett önkéntesek száma, akiket toborozni kívánnak.\n    - applicants (List[Tuple[int, int]]): Egy lista, amelyben minden tuple egy jelentkező regisztrációs számát és tesztpontszámát tartalmazza.\n    \n    Visszatérési érték:\n    - Tuple[int, List[Tuple[int, int]]]: Egy tuple, amely tartalmazza az interjú pontszám küszöbértékét és egy listát a tuple-ökről, amelyek\n      mindegyike tartalmazza a megfelelő jelentkezők regisztrációs számát és tesztpontszámát.\n    \n    Példák:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "es": "Escribe una función en Python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' para resolver el siguiente problema:\n\n   Selecciona y determina el puntaje de corte para la entrevista y la lista de solicitantes que califican para el proceso de entrevista.\n   \n   La función ordena a los solicitantes en función de sus puntajes de prueba en orden descendente. Si varios solicitantes tienen el mismo puntaje,\n   luego se ordenan por su número de registro en orden ascendente. El puntaje de corte para la entrevista se calcula en base al 150%\n   del número planificado de reclutas, redondeado hacia abajo. Todos los solicitantes con puntajes iguales o superiores al corte se consideran\n   calificados para la entrevista.\n   \n   Argumentos:\n   - n (int): El número total de solicitantes.\n   - m (int): El número planificado de voluntarios a reclutar.\n   - applicants (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla contiene el número de registro y el puntaje de prueba de un solicitante.\n   \n   Devuelve:\n   - Tuple[int, List[Tuple[int, int]]]: Una tupla que contiene el puntaje de corte para la entrevista y una lista de tuplas, cada una de las cuales incluye\n     el número de registro y el puntaje de prueba de los solicitantes calificados.\n   \n   Ejemplos:\n   >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n   (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "arb": "اكتب دالة بايثون 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' لحل المشكلة التالية:\n\n    يختار ويحدد درجة المقابلة الفاصلة وقائمة المتقدمين الذين يتأهلون لعملية المقابلة.\n    \n    تقوم الدالة بترتيب المتقدمين بناءً على درجات اختبارهم بترتيب تنازلي. إذا كان لدى عدة متقدمين نفس الدرجة،\n    يتم ترتيبهم بعد ذلك حسب رقم تسجيلهم بترتيب تصاعدي. يتم حساب درجة المقابلة الفاصلة بناءً على 150%\n    من العدد المخطط لتجنيد المتطوعين، ويتم تقريبها إلى الأسفل. جميع المتقدمين الذين لديهم درجات تساوي أو تزيد عن الدرجة الفاصلة يعتبرون\n    مؤهلين للمقابلة.\n    \n    يعيدالحجج:\n    - n (int): العدد الإجمالي للمتقدمين.\n    - m (int): العدد المخطط لتجنيد المتطوعين.\n    - applicants (List[Tuple[int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على رقم التسجيل ودرجة الاختبار للمتقدم.\n    \n    يعيد:\n    - Tuple[int, List[Tuple[int, int]]]: زوج يحتوي على درجة المقابلة الفاصلة وقائمة من الأزواج، يحتوي كل منها على\n      رقم التسجيل ودرجة الاختبار للمتقدمين المؤهلين.\n    \n    أمثلة:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "sw": "Andika kazi ya python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' kutatua tatizo lifuatalo:\n\n    Huchagua na kuamua alama ya mahojiano na orodha ya waombaji wanaostahili kwa mchakato wa mahojiano.\n    \n    Kazi hupanga waombaji kulingana na alama zao za mtihani kwa mpangilio wa kushuka. Ikiwa waombaji kadhaa wana alama sawa,\n    wanapangwa kisha kwa nambari zao za usajili kwa mpangilio wa kupanda. Alama ya mahojiano inahesabiwa kwa msingi wa 150%\n    ya idadi iliyopangwa ya walioajiriwa, ikipunguzwa chini. Waombaji wote wenye alama sawa au zaidi ya alama hiyo wanachukuliwa\n    kuwa wanastahili kwa mahojiano.\n    \n    Hoja:\n    - n (int): Jumla ya idadi ya waombaji.\n    - m (int): Idadi iliyopangwa ya wajitolea watakaoajiriwa.\n    - applicants (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi ina nambari ya usajili na alama ya mtihani ya mwombaji.\n    \n    Inarejesha:\n    - Tuple[int, List[Tuple[int, int]]]: Jozi inayojumuisha alama ya mahojiano na orodha ya jozi, kila moja ikiwa na\n      nambari ya usajili na alama ya mtihani ya waombaji waliostahili.\n    \n    Mifano:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "tr": "Bir python fonksiyonu 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' yazın ve aşağıdaki problemi çözün:\n\n    Mülakat süreci için mülakat puanı barajını ve başvuranların listesini seçer ve belirler.\n    \n    Fonksiyon, başvuranları test puanlarına göre azalan sırayla sıralar. Birden fazla başvuran aynı puana sahipse,\n    kayıt numaralarına göre artan sırayla sıralanırlar. Mülakat puanı barajı, planlanan işe alınacak gönüllü sayısının\n    %150'si üzerinden hesaplanır ve aşağı yuvarlanır. Baraj puanına eşit veya daha yüksek puan alan tüm başvuranlar\n    mülakat için nitelikli kabul edilir.\n    \n    Argümanlar:\n    - n (int): Toplam başvuran sayısı.\n    - m (int): Planlanan işe alınacak gönüllü sayısı.\n    - applicants (List[Tuple[int, int]]): Her bir tuple'ın bir başvuranın kayıt numarası ve test puanını içerdiği tuple'lardan oluşan bir liste.\n    \n    Döndürülenler:\n    - Tuple[int, List[Tuple[int, int]]]: Mülakat puanı barajını ve her birinin kayıt numarası ve test puanını içeren nitelikli başvuranların\n      tuple'larından oluşan bir liste içeren bir tuple.\n    \n    Örnekler:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "vi": "Viết một hàm python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' để giải quyết vấn đề sau:\n\n    Chọn và xác định điểm phỏng vấn tối thiểu và danh sách ứng viên đủ điều kiện cho quá trình phỏng vấn.\n    \n    Hàm sắp xếp các ứng viên dựa trên điểm kiểm tra của họ theo thứ tự giảm dần. Nếu nhiều ứng viên có cùng điểm số,\n    họ sẽ được sắp xếp theo số đăng ký theo thứ tự tăng dần. Điểm phỏng vấn tối thiểu được tính dựa trên 150%\n    số lượng tuyển dụng dự kiến, làm tròn xuống. Tất cả các ứng viên có điểm bằng hoặc cao hơn điểm tối thiểu được coi là\n    đủ điều kiện cho phỏng vấn.\n    \n    Tham số:\n    - n (int): Tổng số ứng viên.\n    - m (int): Số lượng tình nguyện viên dự kiến sẽ được tuyển dụng.\n    - applicants (List[Tuple[int, int]]): Một danh sách các bộ giá trị, mỗi bộ chứa số đăng ký và điểm kiểm tra của một ứng viên.\n    \n    Trả về:\n    - Tuple[int, List[Tuple[int, int]]]: Một bộ giá trị chứa điểm phỏng vấn tối thiểu và một danh sách các bộ giá trị, mỗi bộ bao gồm\n      số đăng ký và điểm kiểm tra của các ứng viên đủ điều kiện.\n    \n    Ví dụ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "id": "Tulis sebuah fungsi python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' untuk menyelesaikan masalah berikut:\n\n    Memilih dan menentukan batas skor wawancara dan daftar pelamar yang memenuhi syarat untuk proses wawancara.\n    \n    Fungsi ini mengurutkan pelamar berdasarkan skor tes mereka dalam urutan menurun. Jika beberapa pelamar memiliki skor yang sama,\n    mereka kemudian diurutkan berdasarkan nomor registrasi mereka dalam urutan naik. Batas skor wawancara dihitung berdasarkan 150%\n    dari jumlah rencana perekrutan, dibulatkan ke bawah. Semua pelamar dengan skor sama atau lebih tinggi dari batas dianggap\n    memenuhi syarat untuk wawancara.\n    \n    Argumen:\n    - n (int): Jumlah total pelamar.\n    - m (int): Jumlah rencana sukarelawan yang akan direkrut.\n    - applicants (List[Tuple[int, int]]): Daftar tuple di mana setiap tuple berisi nomor registrasi dan skor tes seorang pelamar.\n    \n    Mengembalikan:\n    - Tuple[int, List[Tuple[int, int]]]: Sebuah tuple yang berisi batas skor wawancara dan daftar tuple, yang masing-masing mencakup\n      nomor registrasi dan skor tes pelamar yang memenuhi syarat.\n    \n    Contoh:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "ja": "Python関数 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' を作成して、次の問題を解決してください:\n\n    面接プロセスに進む資格のある応募者のリストと面接スコアのカットオフを選択および決定します。\n    \n    関数は応募者をテストスコアに基づいて降順でソートします。複数の応募者が同じスコアを持つ場合、\n    彼らは登録番号に基づいて昇順でソートされます。面接スコアのカットオフは、計画された採用人数の150%に基づいて計算され、切り捨てられます。\n    カットオフ以上のスコアを持つすべての応募者は、面接の資格があると見なされます。\n    \n    引数:\n    - n (int): 応募者の総数。\n    - m (int): 計画されたボランティアの採用人数。\n    - applicants (List[Tuple[int, int]]): 各タプルが応募者の登録番号とテストスコアを含むタプルのリスト。\n    \n    戻り値:\n    - Tuple[int, List[Tuple[int, int]]]: 面接スコアのカットオフと、資格のある応募者の登録番号とテストスコアを含むタプルのリストを含むタプル。\n    \n    例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "ko": "파이썬 함수를 작성하세요 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' 다음 문제를 해결하기 위해:\n\n    인터뷰 점수 컷오프와 인터뷰 과정에 적합한 지원자 목록을 선택하고 결정합니다.\n    \n    함수는 지원자들을 그들의 시험 점수를 기준으로 내림차순으로 정렬합니다. 여러 지원자가 동일한 점수를 가진 경우,\n    그들은 등록 번호를 기준으로 오름차순으로 정렬됩니다. 인터뷰 점수 컷오프는 계획된 모집 인원의 150%를 기준으로 계산되며,\n    내림 처리됩니다. 컷오프 점수 이상을 받은 모든 지원자는 인터뷰에 적합한 것으로 간주됩니다.\n    \n    인수:\n    - n (int): 지원자의 총 수.\n    - m (int): 모집할 계획인 자원봉사자의 수.\n    - applicants (List[Tuple[int, int]]): 각 튜플이 지원자의 등록 번호와 시험 점수를 포함하는 튜플의 목록.\n    \n    반환값:\n    - Tuple[int, List[Tuple[int, int]]]: 인터뷰 점수 컷오프와 각 튜플이 적합한 지원자의 등록 번호와 시험 점수를 포함하는 튜플 목록을 포함하는 튜플.\n    \n    예시:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "ml": "'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    അഭിമുഖ പ്രക്രിയയ്ക്ക് യോഗ്യതയുള്ള അപേക്ഷകരുടെ പട്ടികയും അഭിമുഖ സ്കോർ മിതമായതും തിരഞ്ഞെടുക്കുന്നു.\n    \n    ഫംഗ്ഷൻ അപേക്ഷകരെ അവരുടെ പരീക്ഷാ സ്കോറിന്റെ അടിസ്ഥാനത്തിൽ ഇറക്കം ക്രമത്തിൽ ക്രമീകരിക്കുന്നു. ഒരേ സ്കോർ ഉള്ള നിരവധി അപേക്ഷകരുണ്ടെങ്കിൽ,\n    അവർ അവരുടെ രജിസ്ട്രേഷൻ നമ്പറിന്റെ ഉയർച്ച ക്രമത്തിൽ ക്രമീകരിച്ചിരിക്കുന്നു. 150% ആസൂത്രിത റിക്രൂട്ട്‌മെന്റിന്റെ അടിസ്ഥാനത്തിൽ അഭിമുഖ സ്കോർ മിതമായത് കണക്കാക്കപ്പെടുന്നു,\n    താഴേക്ക് വട്ടമിട്ടു. മിതമായതോ അതിലധികമോ സ്കോറുള്ള എല്ലാ അപേക്ഷകരും അഭിമുഖത്തിന് യോഗ്യതയുള്ളവരായി കണക്കാക്കപ്പെടുന്നു.\n    \n    Args:\n    - n (int): മൊത്തം അപേക്ഷകരുടെ എണ്ണം.\n    - m (int): റിക്രൂട്ട് ചെയ്യാൻ ആസൂത്രിതമായ സന്നദ്ധപ്രവർത്തകരുടെ എണ്ണം.\n    - applicants (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും ഒരു അപേക്ഷകന്റെ രജിസ്ട്രേഷൻ നമ്പറും പരീക്ഷാ സ്കോറും ഉൾക്കൊള്ളുന്ന ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: അഭിമുഖ സ്കോർ മിതമായതും ട്യൂപ്പിളുകളുടെ പട്ടികയും അടങ്ങിയ ഒരു ട്യൂപ്പിൾ, ഓരോന്നും\n      യോഗ്യതയുള്ള അപേക്ഷകരുടെ രജിസ്ട്രേഷൻ നമ്പറും പരീക്ഷാ സ്കോറും ഉൾക്കൊള്ളുന്നു.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "fa": "یک تابع پایتون بنویسید 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' برای حل مسئله زیر:\n\n    انتخاب و تعیین حد نصاب نمره مصاحبه و لیست متقاضیانی که برای فرآیند مصاحبه واجد شرایط هستند.\n    \n    تابع متقاضیان را بر اساس نمرات آزمونشان به صورت نزولی مرتب می‌کند. اگر چندین متقاضی نمره یکسانی داشته باشند،\n    سپس بر اساس شماره ثبت‌نام به صورت صعودی مرتب می‌شوند. حد نصاب نمره مصاحبه بر اساس 150%\n    از تعداد برنامه‌ریزی شده داوطلبان محاسبه می‌شود و به پایین گرد می‌شود. تمام متقاضیانی که نمره‌ای برابر یا بالاتر از حد نصاب دارند، \n    واجد شرایط مصاحبه در نظر گرفته می‌شوند.\n    \n    آرگومان‌ها:\n    - n (int): تعداد کل متقاضیان.\n    - m (int): تعداد برنامه‌ریزی شده داوطلبانی که قرار است استخدام شوند.\n    - applicants (List[Tuple[int, int]]): لیستی از تاپل‌ها که هر تاپل شامل شماره ثبت‌نام و نمره آزمون یک متقاضی است.\n    \n    بازگشت:\n    - Tuple[int, List[Tuple[int, int]]]: یک تاپل شامل حد نصاب نمره مصاحبه و لیستی از تاپل‌ها که هر کدام شامل\n      شماره ثبت‌نام و نمره آزمون متقاضیان واجد شرایط است.\n    \n    مثال‌ها:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])"}, "level": "middle", "test": "def test_select_volunteers():\n    # Define test cases\n    test_cases = [\n        (6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)],\n         (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])),\n        (5, 3, [(2000, 70), (2001, 80), (2002, 90), (2003, 85), (2004, 90)],\n         (80, [(2002, 90), (2004, 90), (2003, 85), (2001, 80)])),\n        (8, 4, [(1234, 60), (2345, 75), (3456, 85), (4567, 85), (5678, 90), (6789, 100), (7890, 65), (8901, 70)],\n         (70, [(6789, 100), (5678, 90), (3456, 85), (4567, 85), (2345, 75), (8901, 70)])),\n    ]\n\n    # Run test cases\n    for i, (n, m, applicants, expected) in enumerate(test_cases):\n        interview_line_score, final_applicants = select_volunteers(n, m, applicants)\n        assert (interview_line_score, final_applicants) == expected, f\"Test case {i + 1} failed\"\n        print(f\"Test case {i + 1} passed\")\n\n# Run the test function\ntest_select_volunteers()", "entry_point": "select_volunteers", "signature": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:", "docstring": {"en": "\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    ", "sq": "\n    Zgjedh dhe përcakton pragun e pikëve të intervistës dhe listën e aplikantëve që kualifikohen për procesin e intervistës.\n    \n    Funksioni rendit aplikantët bazuar në pikët e tyre të testit në rend zbritës. Nëse disa aplikantë kanë të njëjtën pikë,\n    ata renditen më pas sipas numrit të regjistrimit në rend rritës. Pragu i pikëve të intervistës llogaritet bazuar në 150%\n    të numrit të planifikuar të rekrutimeve, i rrumbullakosur poshtë. Të gjithë aplikantët me pikë të barabarta ose më të larta se pragu konsiderohen\n    të kualifikuar për intervistën.\n    \n    Args:\n    - n (int): Numri total i aplikantëve.\n    - m (int): Numri i planifikuar i vullnetarëve për t'u rekrutuar.\n    - applicants (List[Tuple[int, int]]): Një listë tuples ku çdo tuple përmban numrin e regjistrimit dhe pikët e testit të një aplikanti.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Një tuple që përmban pragun e pikëve të intervistës dhe një listë tuples, secila prej të cilave përfshin\n      numrin e regjistrimit dhe pikët e testit të aplikantëve të kualifikuar.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "hy": "\n    Ընտրում է և որոշում հարցազրույցի միավորների շեմը և դիմորդների ցանկը, ովքեր որակավորվում են հարցազրույցի գործընթացի համար։\n    \n    Ֆունկցիան դասավորում է դիմորդներին իրենց թեստային միավորների հիման վրա նվազման կարգով։ Եթե մի քանի դիմորդ ունեն նույն միավորը,\n    ապա նրանք դասավորվում են իրենց գրանցման համարի աճման կարգով։ Հարցազրույցի միավորների շեմը հաշվարկվում է ըստ նախատեսված\n    հավաքագրվելիք կամավորների 150%-ի, կլորացված դեպի ներքև։ Բոլոր դիմորդները, որոնց միավորները հավասար են կամ բարձր են շեմից,\n    համարվում են որակավորված հարցազրույցի համար։\n    \n    Արգումենտներ:\n    - n (int): Դիմորդների ընդհանուր քանակը։\n    - m (int): Նախատեսված հավաքագրվելիք կամավորների քանակը։\n    - applicants (List[Tuple[int, int]]): Ցանկ, որտեղ յուրաքանչյուր տուփ պարունակում է դիմորդի գրանցման համարը և թեստային միավորը։\n    \n    Վերադարձնում է:\n    - Tuple[int, List[Tuple[int, int]]]: Տուփ, որը պարունակում է հարցազրույցի միավորների շեմը և տուփերի ցանկ, որոնցից յուրաքանչյուրը ներառում է\n      որակավորված դիմորդների գրանցման համարը և թեստային միավորը։\n    \n    Օրինակներ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "bn": "\n    সাক্ষাৎকারের স্কোর কাটঅফ এবং সাক্ষাৎকার প্রক্রিয়ার জন্য যোগ্য আবেদনকারীদের তালিকা নির্বাচন এবং নির্ধারণ করে।\n    \n    ফাংশনটি আবেদনকারীদের তাদের পরীক্ষার স্কোরের উপর ভিত্তি করে অবতরণক্রমে সাজায়। যদি একাধিক আবেদনকারীর একই স্কোর থাকে,\n    তবে তাদের রেজিস্ট্রেশন নম্বর অনুযায়ী আরোহীক্রমে সাজানো হয়। সাক্ষাৎকারের স্কোর কাটঅফ পরিকল্পিত নিয়োগের 150% এর ভিত্তিতে গণনা করা হয়,\n    যা নিচের দিকে পূর্ণসংখ্যায় পরিণত হয়। সমস্ত আবেদনকারী যাদের স্কোর কাটঅফের সমান বা তার চেয়ে বেশি, তাদের সাক্ষাৎকারের জন্য যোগ্য বলে বিবেচনা করা হয়।\n    \n    আর্গুমেন্টসমূহ:\n    - n (int): মোট আবেদনকারীর সংখ্যা।\n    - m (int): পরিকল্পিত নিয়োগের স্বেচ্ছাসেবকের সংখ্যা।\n    - applicants (List[Tuple[int, int]]): একটি তালিকা যেখানে প্রতিটি টুপলে একটি আবেদনকারীর রেজিস্ট্রেশন নম্বর এবং পরীক্ষার স্কোর থাকে।\n    \n    রিটার্নস:\n    - Tuple[int, List[Tuple[int, int]]]: একটি টিউপল যা সাক্ষাৎকারের স্কোর কাটঅফ এবং একটি তালিকা ধারণ করে, যেখানে প্রতিটি টুপলে\n      যোগ্য আবেদনকারীদের রেজিস্ট্রেশন নম্বর এবং পরীক্ষার স্কোর অন্তর্ভুক্ত থাকে।\n    \n    উদাহরণ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "bg": "\n    Избира и определя прага на оценките за интервю и списъка с кандидати, които се квалифицират за процеса на интервюиране.\n    \n    Функцията сортира кандидатите въз основа на техните тестови оценки в низходящ ред. Ако няколко кандидати имат еднаква оценка,\n    те се сортират по регистрационния си номер във възходящ ред. Прагът на оценките за интервю се изчислява въз основа на 150%\n    от планирания брой наемания, закръглен надолу. Всички кандидати с оценки, равни или по-високи от прага, се считат за\n    квалифицирани за интервюто.\n    \n    Аргументи:\n    - n (int): Общият брой на кандидатите.\n    - m (int): Планираният брой доброволци, които ще бъдат наети.\n    - applicants (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа регистрационния номер и тестовата оценка на кандидат.\n    \n    Връща:\n    - Tuple[int, List[Tuple[int, int]]]: Кортеж, съдържащ прага на оценките за интервю и списък от кортежи, всеки от които включва\n      регистрационния номер и тестовата оценка на квалифицираните кандидати.\n    \n    Примери:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "zh": "\n    选择并确定面试分数线以及符合面试流程的申请人名单。\n    \n    该函数根据申请人的测试分数按降序排序。如果多个申请人的分数相同，则按注册号升序排序。\n    面试分数线是基于计划招聘人数的150%计算的，并向下取整。所有分数等于或高于分数线的申请人被认为符合面试资格。\n    \n    参数:\n    - n (int): 申请人的总数。\n    - m (int): 计划招募的志愿者人数。\n    - applicants (List[Tuple[int, int]]): 一个包含元组的列表，每个元组包含申请人的注册号和测试分数。\n    \n    返回:\n    - Tuple[int, List[Tuple[int, int]]]: 一个包含面试分数线和元组列表的元组，每个元组包括符合资格的申请人的注册号和测试分数。\n    \n    示例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    ", "fr": "\n    Sélectionne et détermine le seuil de score d'entretien et la liste des candidats qui se qualifient pour le processus d'entretien.\n    \n    La fonction trie les candidats en fonction de leurs scores de test par ordre décroissant. Si plusieurs candidats ont le même score,\n    ils sont ensuite triés par leur numéro d'inscription par ordre croissant. Le seuil de score d'entretien est calculé sur la base de 150%\n    du nombre prévu de recrues, arrondi à l'entier inférieur. Tous les candidats ayant des scores égaux ou supérieurs au seuil sont considérés\n    comme qualifiés pour l'entretien.\n    \n    Args:\n    - n (int): Le nombre total de candidats.\n    - m (int): Le nombre prévu de bénévoles à recruter.\n    - applicants (List[Tuple[int, int]]): Une liste de tuples où chaque tuple contient le numéro d'inscription et le score de test d'un candidat.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Un tuple contenant le seuil de score d'entretien et une liste de tuples, chacun incluant\n      le numéro d'inscription et le score de test des candidats qualifiés.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "de": "\n    Wählt aus und bestimmt die Punkteschwelle für das Vorstellungsgespräch sowie die Liste der Bewerber, die sich für den Interviewprozess qualifizieren.\n    \n    Die Funktion sortiert die Bewerber basierend auf ihren Testergebnissen in absteigender Reihenfolge. Wenn mehrere Bewerber die gleiche Punktzahl haben,\n    werden sie anschließend nach ihrer Registrierungsnummer in aufsteigender Reihenfolge sortiert. Die Punkteschwelle für das Vorstellungsgespräch wird basierend auf 150%\n    der geplanten Anzahl der Rekruten berechnet, abgerundet. Alle Bewerber mit Punktzahlen, die gleich oder höher als die Schwelle sind, gelten als\n    qualifiziert für das Vorstellungsgespräch.\n    \n    Argumente:\n    - n (int): Die Gesamtzahl der Bewerber.\n    - m (int): Die geplante Anzahl der zu rekrutierenden Freiwilligen.\n    - applicants (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die Registrierungsnummer und die Testergebnisse eines Bewerbers enthält.\n    \n    Rückgabewerte:\n    - Tuple[int, List[Tuple[int, int]]]: Ein Tupel, das die Punkteschwelle für das Vorstellungsgespräch und eine Liste von Tupeln enthält, von denen jedes\n      die Registrierungsnummer und die Testergebnisse der qualifizierten Bewerber umfasst.\n    \n    Beispiele:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "ha": "\n    Zaɓi kuma kayyade iyakar maki na hira da jerin masu nema waɗanda suka cancanci shiga tsarin hira.\n    \n    Aikin yana tsara masu nema bisa ga maki na gwaji a cikin tsari mai saukarwa. Idan masu nema da yawa suna da maki iri ɗaya,\n    to za a tsara su bisa ga lambar rajista a cikin tsari mai hawa. Ana lissafin iyakar maki na hira bisa ga kashi 150%\n    na adadin masu daukar aiki da aka shirya, an zagaye ƙasa. Duk masu nema da suka samu maki daidai ko sama da iyakar ana ɗaukar su\n    sun cancanci shiga hirar.\n    \n    Args:\n    - n (int): Jimlar adadin masu nema.\n    - m (int): Adadin masu sa kai da aka shirya dauka.\n    - applicants (List[Tuple[int, int]]): Jerin tuples inda kowanne tuple yana dauke da lambar rajista da maki na gwajin mai nema.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Tuple wanda ke dauke da iyakar maki na hira da jerin tuples, kowanne yana dauke da\n      lambar rajista da maki na gwajin masu nema da suka cancanta.\n    \n    Misalai:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "hi": "\n    साक्षात्कार स्कोर कटऑफ और उन आवेदकों की सूची का चयन और निर्धारण करता है जो साक्षात्कार प्रक्रिया के लिए योग्य हैं।\n    \n    यह फ़ंक्शन आवेदकों को उनके टेस्ट स्कोर के आधार पर अवरोही क्रम में क्रमबद्ध करता है। यदि कई आवेदकों के स्कोर समान हैं,\n    तो उन्हें उनके पंजीकरण संख्या के आधार पर आरोही क्रम में क्रमबद्ध किया जाता है। साक्षात्कार स्कोर कटऑफ नियोजित भर्ती संख्या के 150%\n    के आधार पर गणना की जाती है, जिसे नीचे की ओर पूर्णांकित किया जाता है। सभी आवेदक जिनके स्कोर कटऑफ के बराबर या उससे अधिक हैं, \n    उन्हें साक्षात्कार के लिए योग्य माना जाता है।\n    \n    आर्ग्स:\n    - n (int): कुल आवेदकों की संख्या।\n    - m (int): भर्ती किए जाने वाले स्वयंसेवकों की नियोजित संख्या।\n    - applicants (List[Tuple[int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल में एक आवेदक की पंजीकरण संख्या और टेस्ट स्कोर शामिल है।\n    \n    रिटर्न:\n    - Tuple[int, List[Tuple[int, int]]]: एक ट्यूपल जिसमें साक्षात्कार स्कोर कटऑफ और ट्यूपल की एक सूची शामिल है, जिसमें प्रत्येक में \n      योग्य आवेदकों की पंजीकरण संख्या और टेस्ट स्कोर शामिल है।\n    \n    उदाहरण:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "hu": "\n    Kiválasztja és meghatározza az interjú pontszám küszöböt és az interjú folyamatra jogosult jelentkezők listáját.\n    \n    A függvény a jelentkezőket a tesztpontszámaik alapján csökkenő sorrendbe rendezi. Ha több jelentkezőnek azonos a pontszáma,\n    akkor őket a regisztrációs számuk alapján növekvő sorrendbe rendezi. Az interjú pontszám küszöb a tervezett toborzási létszám\n    150%-a alapján kerül kiszámításra, lefelé kerekítve. Minden jelentkező, akinek a pontszáma eléri vagy meghaladja a küszöböt,\n    interjúra jogosultnak tekintendő.\n    \n    Paraméterek:\n    - n (int): A jelentkezők teljes száma.\n    - m (int): A tervezett toborzandó önkéntesek száma.\n    - applicants (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy tuple, amely tartalmazza a jelentkező regisztrációs számát és tesztpontszámát.\n    \n    Visszatérési érték:\n    - Tuple[int, List[Tuple[int, int]]]: Egy tuple, amely tartalmazza az interjú pontszám küszöböt és egy listát, amelyben minden elem egy tuple,\n      amely tartalmazza a jogosult jelentkezők regisztrációs számát és tesztpontszámát.\n    \n    Példák:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "es": "    Selecciona y determina el puntaje de corte para la entrevista y la lista de solicitantes que califican para el proceso de entrevista.\n    \n    La función ordena a los solicitantes en función de sus puntajes de prueba en orden descendente. Si varios solicitantes tienen el mismo puntaje,\n    luego se ordenan por su número de registro en orden ascendente. El puntaje de corte para la entrevista se calcula en base al 150%\n    del número planeado de reclutas, redondeado hacia abajo. Todos los solicitantes con puntajes iguales o superiores al corte se consideran\n    calificados para la entrevista.\n    \n    Argumentos:\n    - n (int): El número total de solicitantes.\n    - m (int): El número planeado de voluntarios a reclutar.\n    - applicants (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla contiene el número de registro y el puntaje de prueba de un solicitante.\n    \n    Devuelve:\n    - Tuple[int, List[Tuple[int, int]]]: Una tupla que contiene el puntaje de corte para la entrevista y una lista de tuplas, cada una de las cuales incluye\n      el número de registro y el puntaje de prueba de los solicitantes calificados.\n    \n    Ejemplos:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "arb": "    يختار ويحدد الحد الأدنى لدرجة المقابلة وقائمة المتقدمين الذين يتأهلون لعملية المقابلة.\n    \n    تقوم الدالة بترتيب المتقدمين بناءً على درجات اختبارهم بترتيب تنازلي. إذا كان لدى عدة متقدمين نفس الدرجة،\n    يتم ترتيبهم بعد ذلك حسب رقم التسجيل بترتيب تصاعدي. يتم حساب الحد الأدنى لدرجة المقابلة بناءً على 150%\n    من العدد المخطط للمتطوعين، مع التقريب إلى الأسفل. جميع المتقدمين الذين لديهم درجات تساوي أو تزيد عن الحد الأدنى يعتبرون\n    مؤهلين للمقابلة.\n    \n    يعيدالحجج:\n    - n (int): العدد الإجمالي للمتقدمين.\n    - m (int): العدد المخطط للمتطوعين الذين سيتم تجنيدهم.\n    - applicants (List[Tuple[int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على رقم التسجيل ودرجة اختبار المتقدم.\n    \n    يعيد:\n    - Tuple[int, List[Tuple[int, int]]]: زوج يحتوي على الحد الأدنى لدرجة المقابلة وقائمة من الأزواج، كل منها يتضمن\n      رقم التسجيل ودرجة اختبار المتقدمين المؤهلين.\n    \n    امثله:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "sw": "    Huchagua na kuamua alama ya kukatwa kwa mahojiano na orodha ya waombaji wanaostahili kwa mchakato wa mahojiano.\n    \n    Kazi hii hupanga waombaji kulingana na alama zao za mtihani kwa mpangilio wa kushuka. Ikiwa waombaji kadhaa wana alama sawa,\n    basi hupangwa kulingana na nambari zao za usajili kwa mpangilio wa kupanda. Alama ya kukatwa kwa mahojiano huhesabiwa kwa msingi wa 150%\n    ya idadi iliyopangwa ya wanaojitolea, ikipunguzwa chini. Waombaji wote wenye alama sawa au zaidi ya alama ya kukatwa wanachukuliwa\n    kuwa wamehitimu kwa mahojiano.\n    \n    Hoja:\n    - n (int): Jumla ya idadi ya waombaji.\n    - m (int): Idadi iliyopangwa ya wanaojitolea watakaoajiriwa.\n    - applicants (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi ina nambari ya usajili na alama ya mtihani ya mwombaji.\n    \n    Inarejesha:\n    - Tuple[int, List[Tuple[int, int]]]: Jozi inayojumuisha alama ya kukatwa kwa mahojiano na orodha ya jozi, kila moja ikiwa na\n      nambari ya usajili na alama ya mtihani ya waombaji waliostahili.\n    \n    Mifano:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "tr": "    Mülakat puanı barajını ve mülakat sürecine katılmaya hak kazanan başvuru sahiplerinin listesini seçer ve belirler.\n    \n    Fonksiyon, başvuru sahiplerini test puanlarına göre azalan sırada sıralar. Birden fazla başvuru sahibi aynı puana sahipse,\n    bunlar kayıt numaralarına göre artan sırada sıralanır. Mülakat puanı barajı, planlanan işe alınacak gönüllü sayısının %150'si\n    üzerinden hesaplanır ve aşağı yuvarlanır. Baraj puanına eşit veya daha yüksek puana sahip tüm başvuru sahipleri mülakata hak kazanmış sayılır.\n    \n    Argümanlar:\n    - n (int): Toplam başvuru sahibi sayısı.\n    - m (int): Planlanan işe alınacak gönüllü sayısı.\n    - applicants (List[Tuple[int, int]]): Her bir demetin bir başvuru sahibinin kayıt numarası ve test puanını içerdiği demetlerin listesi.\n    \n    Döndürür:\n    - Tuple[int, List[Tuple[int, int]]]: Mülakat puanı barajını ve her biri kayıt numarası ve hak kazanan başvuru sahiplerinin test puanını içeren\n      demetlerin listesini içeren bir demet.\n    \n    Örnekler:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "vi": "Chọn và xác định điểm phỏng vấn tối thiểu và danh sách các ứng viên đủ điều kiện cho quá trình phỏng vấn.\n\nHàm sắp xếp các ứng viên dựa trên điểm kiểm tra của họ theo thứ tự giảm dần. Nếu nhiều ứng viên có cùng điểm số, họ sẽ được sắp xếp theo số đăng ký theo thứ tự tăng dần. Điểm phỏng vấn tối thiểu được tính dựa trên 150% số lượng tuyển dụng dự kiến, làm tròn xuống. Tất cả các ứng viên có điểm số bằng hoặc cao hơn điểm tối thiểu được coi là đủ điều kiện cho phỏng vấn.\n\nTham số:\n- n (int): Tổng số ứng viên.\n- m (int): Số lượng tình nguyện viên dự kiến sẽ được tuyển dụng.\n- applicants (List[Tuple[int, int]]): Một danh sách các bộ giá trị, mỗi bộ chứa số đăng ký và điểm kiểm tra của một ứng viên.\n\nTrả về:\n- Tuple[int, List[Tuple[int, int]]]: Một bộ giá trị chứa điểm phỏng vấn tối thiểu và danh sách các bộ giá trị, mỗi bộ bao gồm số đăng ký và điểm kiểm tra của các ứng viên đủ điều kiện.\n\nVí dụ:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "id": "Memilih dan menentukan batas skor wawancara serta daftar pelamar yang memenuhi syarat untuk proses wawancara.\n\nFungsi ini mengurutkan pelamar berdasarkan skor tes mereka dalam urutan menurun. Jika beberapa pelamar memiliki skor yang sama, mereka kemudian diurutkan berdasarkan nomor registrasi dalam urutan menaik. Batas skor wawancara dihitung berdasarkan 150% dari jumlah rekrutan yang direncanakan, dibulatkan ke bawah. Semua pelamar dengan skor sama atau lebih tinggi dari batas dianggap memenuhi syarat untuk wawancara.\n\nArgs:\n- n (int): Jumlah total pelamar.\n- m (int): Jumlah sukarelawan yang direncanakan untuk direkrut.\n- applicants (List[Tuple[int, int]]): Daftar tuple di mana setiap tuple berisi nomor registrasi dan skor tes seorang pelamar.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Sebuah tuple yang berisi batas skor wawancara dan daftar tuple, yang masing-masing mencakup nomor registrasi dan skor tes pelamar yang memenuhi syarat.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "ja": "    面接スコアのカットオフと面接プロセスに適格な応募者のリストを選定および決定します。\n    \n    この関数は、応募者をテストスコアに基づいて降順でソートします。複数の応募者が同じスコアを持つ場合、\n    彼らは登録番号で昇順にソートされます。面接スコアのカットオフは、計画された採用人数の150%に基づいて計算され、\n    切り捨てられます。カットオフ以上のスコアを持つ全ての応募者が面接に適格と見なされます。\n    \n    引数:\n    - n (int): 応募者の総数。\n    - m (int): 採用予定のボランティア数。\n    - applicants (List[Tuple[int, int]]): 各タプルが応募者の登録番号とテストスコアを含むタプルのリスト。\n    \n    戻り値:\n    - Tuple[int, List[Tuple[int, int]]]: 面接スコアのカットオフと、適格な応募者の登録番号とテストスコアを含むタプルのリストを含むタプル。\n    \n    例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "ko": "    면접 점수 컷오프와 면접 과정에 적합한 지원자 목록을 선택하고 결정합니다.\n    \n    이 함수는 지원자들을 시험 점수를 기준으로 내림차순으로 정렬합니다. 여러 지원자가 동일한 점수를 받은 경우,\n    그들은 등록 번호를 기준으로 오름차순으로 정렬됩니다. 면접 점수 컷오프는 계획된 모집 인원의 150%를 기준으로 계산되며,\n    내림 처리됩니다. 컷오프 점수와 같거나 높은 점수를 받은 모든 지원자는 면접에 적합한 것으로 간주됩니다.\n    \n    Args:\n    - n (int): 지원자의 총 수.\n    - m (int): 모집할 계획인 자원봉사자의 수.\n    - applicants (List[Tuple[int, int]]): 각 튜플이 지원자의 등록 번호와 시험 점수를 포함하는 튜플의 리스트.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: 면접 점수 컷오프와 각 튜플이 적합한 지원자의 등록 번호와 시험 점수를 포함하는 튜플의 리스트를 포함하는 튜플.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "ml": "    അഭിമുഖ സ്കോർ മിതമായ പരിധി തിരഞ്ഞെടുക്കുകയും അഭിമുഖ പ്രക്രിയയ്ക്ക് യോഗ്യത നേടിയ അപേക്ഷകരുടെ പട്ടിക നിർണ്ണയിക്കുകയും ചെയ്യുന്നു.\n    \n    ഫംഗ്ഷൻ അപേക്ഷകരെ അവരുടെ പരീക്ഷാ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഇറക്കമില്ലാത്ത ക്രമത്തിൽ ക്രമീകരിക്കുന്നു. പല അപേക്ഷകർക്കും ഒരേ സ്കോർ ഉണ്ടെങ്കിൽ, \n    അവർ അവരുടെ രജിസ്ട്രേഷൻ നമ്പർ ഉയർന്ന ക്രമത്തിൽ ക്രമീകരിക്കപ്പെടുന്നു. അഭിമുഖ സ്കോർ മിതമായ പരിധി, പദ്ധതിയിട്ടിരിക്കുന്ന റിക്രൂട്ട്‌മെന്റിന്റെ 150% അടിസ്ഥാനമാക്കി \n    താഴേക്ക് വട്ടമിട്ട് കണക്കാക്കുന്നു. മിതമായ പരിധിയേക്കാൾ ഉയർന്ന അല്ലെങ്കിൽ തുല്യമായ സ്കോർ ഉള്ള എല്ലാ അപേക്ഷകരും അഭിമുഖത്തിന് യോഗ്യരായി കണക്കാക്കപ്പെടുന്നു.\n    \n    Args:\n    - n (int): ആകെ അപേക്ഷകരുടെ എണ്ണം.\n    - m (int): റിക്രൂട്ട് ചെയ്യാൻ പദ്ധതിയിട്ടിരിക്കുന്ന സ്വയംസേവകരുടെ എണ്ണം.\n    - applicants (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും ഒരു അപേക്ഷകന്റെ രജിസ്ട്രേഷൻ നമ്പറും പരീക്ഷാ സ്കോറും അടങ്ങിയ ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: അഭിമുഖ സ്കോർ മിതമായ പരിധിയും, \n      യോഗ്യത നേടിയ അപേക്ഷകരുടെ രജിസ്ട്രേഷൻ നമ്പറും പരീക്ഷാ സ്കോറും അടങ്ങിയ ഓരോ ട്യൂപ്പിളും ഉൾപ്പെടുന്ന ട്യൂപ്പിളിന്റെ പട്ടികയും അടങ്ങിയ ഒരു ട്യൂപ്പിൾ.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])", "fa": "    انتخاب و تعیین حد نصاب نمره مصاحبه و لیست متقاضیانی که برای فرآیند مصاحبه واجد شرایط هستند.\n    \n    این تابع متقاضیان را بر اساس نمرات آزمون آن‌ها به ترتیب نزولی مرتب می‌کند. اگر چندین متقاضی نمره یکسانی داشته باشند،\n    سپس بر اساس شماره ثبت نام به ترتیب صعودی مرتب می‌شوند. حد نصاب نمره مصاحبه بر اساس ۱۵۰٪\n    از تعداد برنامه‌ریزی شده داوطلبان محاسبه می‌شود و به پایین گرد می‌شود. تمام متقاضیانی که نمره‌ای برابر یا بالاتر از حد نصاب دارند\n    واجد شرایط برای مصاحبه در نظر گرفته می‌شوند.\n    \n    آرگومان‌ها:\n    - n (int): تعداد کل متقاضیان.\n    - m (int): تعداد برنامه‌ریزی شده داوطلبانی که قرار است استخدام شوند.\n    - applicants (List[Tuple[int, int]]): لیستی از زوج‌ها که هر زوج شامل شماره ثبت نام و نمره آزمون یک متقاضی است.\n    \n    بازگشت:\n    - Tuple[int, List[Tuple[int, int]]]: یک زوج شامل حد نصاب نمره مصاحبه و لیستی از زوج‌ها که هر کدام شامل\n      شماره ثبت نام و نمره آزمون متقاضیان واجد شرایط است.\n    \n    مثال‌ها:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])"}}
{"task_id": "Python/22", "prompt": {"en": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "sq": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Dekodon një mesazh të koduar duke përdorur një shifër të nxjerrë nga një çift i njohur i koduar-origjinal.\n    \n    Funksioni ndërton një hartë nga shkronjat e koduara te shkronjat e tyre origjinale dhe përdor këtë\n    hartë për të dekoduar një mesazh të dhënë të koduar. Nëse gjendet një kontradiktë gjatë ndërtimit të hartës,\n    ose nëse jo të gjitha shkronjat janë të përfaqësuara në hartë, funksioni kthen \"Dështoi\".\n    \n    Argumentet:\n    encoded (str): Një varg që përfaqëson informacionin e koduar.\n    original (str): Një varg që përfaqëson informacionin origjinal që korrespondon me vargun e koduar.\n    message (str): Një varg që përfaqëson mesazhin e koduar që do të dekodohet.\n    \n    Kthen:\n    str: Mesazhi i dekoduar nëse është i suksesshëm, ose \"Dështoi\" nëse dekodimi nuk është i mundur.\n    \n    Shembuj:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "hy": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Վերծանում է կոդավորված հաղորդագրությունը՝ օգտագործելով հայտնի կոդավորված-բնօրինակ զույգից ստացված ծածկագիրը:\n    \n    Ֆունկցիան ստեղծում է համապատասխանություն կոդավորված տառերից դեպի իրենց բնօրինակ տառերը և օգտագործում է այս\n    համապատասխանությունը՝ տրված կոդավորված հաղորդագրությունը վերծանելու համար: Եթե հակասություն է հայտնաբերվում\n    համապատասխանության կառուցման ընթացքում, կամ եթե բոլոր տառերը ներկայացված չեն համապատասխանության մեջ, ապա\n    ֆունկցիան վերադարձնում է \"Failed\":\n    \n    Փաստարկներ:\n    encoded (str): Տող, որը ներկայացնում է կոդավորված տեղեկատվությունը:\n    original (str): Տող, որը ներկայացնում է կոդավորված տողին համապատասխանող բնօրինակ տեղեկատվությունը:\n    message (str): Տող, որը ներկայացնում է վերծանման ենթակա կոդավորված հաղորդագրությունը:\n    \n    Վերադարձնում է:\n    str: Վերծանված հաղորդագրությունը, եթե հաջողված է, կամ \"Failed\", եթե վերծանումը հնարավոր չէ:\n    \n    Օրինակներ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "bn": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    একটি পরিচিত এনকোডেড-অরিজিনাল জোড়া থেকে প্রাপ্ত সাইফার ব্যবহার করে একটি এনক্রিপ্টেড বার্তা ডিকোড করে।\n    \n    ফাংশনটি এনকোডেড অক্ষর থেকে তাদের মূল অক্ষরে একটি ম্যাপিং তৈরি করে এবং এই ম্যাপিং ব্যবহার করে একটি প্রদত্ত এনক্রিপ্টেড বার্তা ডিকোড করে। ম্যাপিং নির্মাণের সময় যদি কোনো বিরোধ পাওয়া যায়, অথবা ম্যাপিংয়ে সমস্ত অক্ষর উপস্থাপিত না হয়, তাহলে ফাংশনটি \"Failed\" ফেরত দেয়।\n    \n    আর্গস:\n    encoded (str): এনকোডেড তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    original (str): এনকোডেড স্ট্রিংয়ের সাথে সম্পর্কিত মূল তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    message (str): ডিকোড করার জন্য এনক্রিপ্টেড বার্তা উপস্থাপনকারী একটি স্ট্রিং।\n    \n    রিটার্নস:\n    str: সফল হলে ডিকোড করা বার্তা, অথবা ডিকোড করা সম্ভব না হলে \"Failed\"।\n    \n    উদাহরণ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "bg": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Декодира криптирано съобщение, използвайки шифър, получен от известна кодирана-оригинална двойка.\n    \n    Функцията създава съответствие от кодирани букви към техните оригинални букви и използва това\n    съответствие, за да декодира дадено криптирано съобщение. Ако се открие противоречие по време на\n    създаването на съответствието или не всички букви са представени в съответствието, функцията връща \"Failed\".\n    \n    Аргументи:\n    encoded (str): Низ, представляващ кодираната информация.\n    original (str): Низ, представляващ оригиналната информация, съответстваща на кодирания низ.\n    message (str): Низ, представляващ криптираното съобщение, което трябва да бъде декодирано.\n    \n    Връща:\n    str: Декодираното съобщение, ако е успешно, или \"Failed\", ако декодирането не е възможно.\n    \n    Примери:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "zh": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    使用已知的编码-原始对派生的密码解码加密消息。\n    \n    该函数构建从编码字母到原始字母的映射，并使用此映射解码给定的加密消息。\n    如果在映射构建过程中发现矛盾，或者映射中没有表示所有字母，函数返回 \"Failed\"。\n    \n    参数:\n    encoded (str): 表示编码信息的字符串。\n    original (str): 表示与编码字符串对应的原始信息的字符串。\n    message (str): 表示要解码的加密消息的字符串。\n    \n    返回:\n    str: 如果解码成功则返回解码后的消息，如果解码不可能则返回 \"Failed\"。\n    \n    示例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "fr": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Décode un message chiffré en utilisant un chiffrement dérivé d'une paire encodée-originale connue.\n    \n    La fonction construit une correspondance des lettres encodées vers leurs lettres originales et utilise cette\n    correspondance pour décoder un message chiffré donné. Si une contradiction est trouvée lors de la construction\n    de la correspondance, ou si toutes les lettres ne sont pas représentées dans la correspondance, la fonction\n    retourne \"Failed\".\n    \n    Arguments:\n    encoded (str): Une chaîne représentant l'information encodée.\n    original (str): Une chaîne représentant l'information originale correspondant à la chaîne encodée.\n    message (str): Une chaîne représentant le message chiffré à décoder.\n    \n    Retourne:\n    str: Le message décodé si réussi, ou \"Failed\" si le décodage n'est pas possible.\n    \n    Exemples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "de": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Entschlüsselt eine verschlüsselte Nachricht mithilfe eines aus einem bekannten Paar von kodierten und originalen Zeichenfolgen abgeleiteten Chiffre.\n    \n    Die Funktion erstellt eine Zuordnung von kodierten Buchstaben zu ihren ursprünglichen Buchstaben und verwendet diese\n    Zuordnung, um eine gegebene verschlüsselte Nachricht zu entschlüsseln. Wenn während der Konstruktion der Zuordnung ein Widerspruch gefunden wird oder nicht alle Buchstaben in der Zuordnung vertreten sind, gibt die Funktion \"Failed\" zurück.\n    \n    Argumente:\n    encoded (str): Eine Zeichenfolge, die die kodierten Informationen darstellt.\n    original (str): Eine Zeichenfolge, die die ursprünglichen Informationen darstellt, die der kodierten Zeichenfolge entsprechen.\n    message (str): Eine Zeichenfolge, die die zu entschlüsselnde verschlüsselte Nachricht darstellt.\n    \n    Rückgabe:\n    str: Die entschlüsselte Nachricht, wenn erfolgreich, oder \"Failed\", wenn die Entschlüsselung nicht möglich ist.\n    \n    Beispiele:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "ha": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Fassar da saƙon da aka ɓoye ta amfani da wata hanyar ɓoye da aka samo daga sanannen encoded-original ɗin ma'aurata.\n    \n    Aikin yana gina taswira daga haruffan da aka ɓoye zuwa haruffan asali kuma yana amfani da wannan\n    taswira don fassar da wani saƙon da aka ɓoye. Idan an sami sabani yayin gina taswira,\n    ko kuma ba duk haruffa ne aka wakilta a cikin taswira ba, aikin yana dawowa da \"Failed\".\n    \n    Args:\n    encoded (str): Wani kirtani da ke wakiltar bayanan da aka ɓoye.\n    original (str): Wani kirtani da ke wakiltar bayanan asali da suka dace da kirtanin da aka ɓoye.\n    message (str): Wani kirtani da ke wakiltar saƙon da aka ɓoye da za a fassara.\n    \n    Returns:\n    str: Saƙon da aka fassara idan ya yi nasara, ko \"Failed\" idan ba zai yiwu a fassara ba.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "hi": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    ज्ञात एन्कोडेड-ओरिजिनल जोड़ी से व्युत्पन्न सिफर का उपयोग करके एक एन्क्रिप्टेड संदेश को डिकोड करता है।\n    \n    यह फ़ंक्शन एन्कोडेड अक्षरों से उनके मूल अक्षरों तक एक मैपिंग बनाता है और इस मैपिंग का उपयोग \n    एक दिए गए एन्क्रिप्टेड संदेश को डिकोड करने के लिए करता है। यदि मैपिंग निर्माण के दौरान कोई विरोधाभास \n    पाया जाता है, या मैपिंग में सभी अक्षर प्रतिनिधित्व नहीं करते हैं, तो फ़ंक्शन \"Failed\" लौटाता है।\n    \n    तर्क:\n    encoded (str): एन्कोडेड जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    original (str): एन्कोडेड स्ट्रिंग के अनुरूप मूल जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    message (str): डिकोड किए जाने वाले एन्क्रिप्टेड संदेश का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    \n    लौटाता है:\n    str: यदि सफल होता है तो डिकोड किया गया संदेश, या यदि डिकोडिंग संभव नहीं है तो \"Failed\"।\n    \n    उदाहरण:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "hu": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Dekódol egy titkosított üzenetet egy ismert kódolt-eredeti párból származó rejtjel használatával.\n    \n    A függvény létrehoz egy leképezést a kódolt betűkből az eredeti betűkre, és ezt a leképezést használja\n    egy adott titkosított üzenet dekódolására. Ha ellentmondás található a leképezés létrehozása során, vagy\n    nem minden betű van képviselve a leképezésben, a függvény \"Failed\" értéket ad vissza.\n    \n    Paraméterek:\n    encoded (str): Egy string, amely a kódolt információt képviseli.\n    original (str): Egy string, amely az eredeti információt képviseli, amely megfelel a kódolt stringnek.\n    message (str): Egy string, amely a dekódolandó titkosított üzenetet képviseli.\n    \n    Visszatér:\n    str: A dekódolt üzenet, ha sikeres, vagy \"Failed\", ha a dekódolás nem lehetséges.\n    \n    Példák:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "es": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodifica un mensaje encriptado utilizando un cifrado derivado de un par conocido codificado-original.\n    \n    La función construye un mapeo de letras codificadas a sus letras originales y utiliza este\n    mapeo para decodificar un mensaje encriptado dado. Si se encuentra una contradicción durante la construcción del mapeo,\n    o no todas las letras están representadas en el mapeo, la función devuelve \"Failed\".\n    \n    Argumentos:\n    encoded (str): Una cadena que representa la información codificada.\n    original (str): Una cadena que representa la información original correspondiente a la cadena codificada.\n    message (str): Una cadena que representa el mensaje encriptado a ser decodificado.\n    \n    Devuelve:\n    str: El mensaje decodificado si tiene éxito, o \"Failed\" si la decodificación no es posible.\n    \n    Ejemplos:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "arb": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    يفك تشفير رسالة مشفرة باستخدام شفرة مستمدة من زوج معروف مشفر-أصلي.\n    \n    تقوم الدالة ببناء خريطة من الحروف المشفرة إلى حروفها الأصلية وتستخدم هذه\n    الخريطة لفك تشفير رسالة مشفرة معينة. إذا تم العثور على تناقض أثناء بناء الخريطة،\n    أو لم تكن جميع الحروف ممثلة في الخريطة، فإن الدالة تعيد \"فشل\".\n    \n    يعيدالحجج:\n    encoded (str): سلسلة تمثل المعلومات المشفرة.\n    original (str): سلسلة تمثل المعلومات الأصلية المقابلة للسلسلة المشفرة.\n    message (str): سلسلة تمثل الرسالة المشفرة التي يجب فك تشفيرها.\n    \n    يعيد:\n    str: الرسالة المفكوكة إذا كانت ناجحة، أو \"فشل\" إذا لم يكن فك التشفير ممكنًا.\n    \n    أمثلة:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "sw": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Hufungua ujumbe uliofichwa kwa kutumia cipher inayotokana na jozi inayojulikana ya encoded-original.\n    \n    Kazi hii inajenga ramani kutoka kwa herufi zilizofichwa hadi herufi zao za awali na kutumia ramani hii\n    kufungua ujumbe uliofichwa uliotolewa. Ikiwa upinzani utapatikana wakati wa ujenzi wa ramani,\n    au ikiwa si herufi zote zinawakilishwa katika ramani, kazi inarudi \"Failed\".\n    \n    Hoja:\n    encoded (str): Kamba inayowakilisha taarifa iliyofichwa.\n    original (str): Kamba inayowakilisha taarifa ya awali inayolingana na kamba iliyofichwa.\n    message (str): Kamba inayowakilisha ujumbe uliofichwa unaopaswa kufunguliwa.\n    \n    Inarejesha:\n    str: Ujumbe uliofunguliwa ikiwa umefanikiwa, au \"Failed\" ikiwa ufunguzi hauwezekani.\n    \n    Mifano:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "tr": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Bilinen bir şifrelenmiş-orijinal çiftinden türetilen bir şifre kullanarak şifreli bir mesajı çözer.\n    \n    Fonksiyon, şifrelenmiş harflerden orijinal harflere bir eşleme oluşturur ve bu eşlemeyi\n    verilen şifreli mesajı çözmek için kullanır. Eşleme oluşturma sırasında bir çelişki bulunursa\n    veya tüm harfler eşlemede temsil edilmezse, fonksiyon \"Başarısız\" döner.\n    \n    Argümanlar:\n    encoded (str): Şifrelenmiş bilgiyi temsil eden bir dize.\n    original (str): Şifrelenmiş dizeye karşılık gelen orijinal bilgiyi temsil eden bir dize.\n    message (str): Çözülecek şifreli mesajı temsil eden bir dize.\n    \n    Döndürür:\n    str: Başarılıysa çözülen mesaj, aksi takdirde \"Başarısız\" döner.\n    \n    Örnekler:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "vi": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Giải mã một thông điệp được mã hóa bằng cách sử dụng một mật mã được tạo ra từ một cặp đã mã hóa-gốc đã biết.\n    \n    Hàm này xây dựng một ánh xạ từ các chữ cái đã mã hóa đến các chữ cái gốc của chúng và sử dụng ánh xạ này\n    để giải mã một thông điệp đã được mã hóa. Nếu phát hiện mâu thuẫn trong quá trình xây dựng ánh xạ,\n    hoặc không phải tất cả các chữ cái đều được đại diện trong ánh xạ, hàm sẽ trả về \"Failed\".\n    \n    Tham số:\n    encoded (str): Một chuỗi đại diện cho thông tin đã mã hóa.\n    original (str): Một chuỗi đại diện cho thông tin gốc tương ứng với chuỗi đã mã hóa.\n    message (str): Một chuỗi đại diện cho thông điệp đã được mã hóa cần giải mã.\n    \n    Trả về:\n    str: Thông điệp đã được giải mã nếu thành công, hoặc \"Failed\" nếu không thể giải mã.\n    \n    Ví dụ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "id": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Mendekripsi pesan terenkripsi menggunakan sandi yang berasal dari pasangan encoded-original yang diketahui.\n    \n    Fungsi ini membangun pemetaan dari huruf-huruf terenkripsi ke huruf-huruf aslinya dan menggunakan\n    pemetaan ini untuk mendekripsi pesan terenkripsi yang diberikan. Jika ditemukan kontradiksi selama\n    konstruksi pemetaan, atau tidak semua huruf terwakili dalam pemetaan, fungsi ini mengembalikan \"Failed\".\n    \n    Args:\n    encoded (str): Sebuah string yang mewakili informasi terenkripsi.\n    original (str): Sebuah string yang mewakili informasi asli yang sesuai dengan string terenkripsi.\n    message (str): Sebuah string yang mewakili pesan terenkripsi yang akan didekripsi.\n    \n    Returns:\n    str: Pesan yang sudah didekripsi jika berhasil, atau \"Failed\" jika dekripsi tidak memungkinkan.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "ja": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    既知のエンコード-オリジナルペアから導出された暗号を使用して暗号化されたメッセージをデコードします。\n    \n    関数は、エンコードされた文字から元の文字へのマッピングを構築し、このマッピングを使用して与えられた暗号化メッセージをデコードします。マッピングの構築中に矛盾が見つかった場合、またはすべての文字がマッピングに表現されていない場合、関数は \"Failed\" を返します。\n    \n    引数:\n    encoded (str): エンコードされた情報を表す文字列。\n    original (str): エンコードされた文字列に対応する元の情報を表す文字列。\n    message (str): デコードされるべき暗号化メッセージを表す文字列。\n    \n    戻り値:\n    str: デコードが成功した場合はデコードされたメッセージ、デコードが不可能な場合は \"Failed\"。\n    \n    例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "ko": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    알려진 인코딩-원본 쌍에서 파생된 암호를 사용하여 암호화된 메시지를 해독합니다.\n    \n    이 함수는 인코딩된 문자에서 원본 문자로의 매핑을 생성하고, 이 매핑을 사용하여 주어진 암호화된 메시지를 해독합니다. 매핑 생성 중에 모순이 발견되거나 모든 문자가 매핑에 나타나지 않는 경우, 함수는 \"Failed\"를 반환합니다.\n    \n    인수:\n    encoded (str): 인코딩된 정보를 나타내는 문자열.\n    original (str): 인코딩된 문자열에 해당하는 원본 정보를 나타내는 문자열.\n    message (str): 해독할 암호화된 메시지를 나타내는 문자열.\n    \n    반환:\n    str: 성공적인 경우 해독된 메시지, 해독이 불가능한 경우 \"Failed\".\n    \n    예제:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "ml": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    ഒരു അറിയപ്പെടുന്ന എൻകോഡഡ്-ഒറിജിനൽ ജോഡിയിൽ നിന്ന് ലഭിച്ച സൈഫർ ഉപയോഗിച്ച് എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശം ഡികോഡ് ചെയ്യുന്നു.\n    \n    ഫംഗ്ഷൻ എൻകോഡഡ് അക്ഷരങ്ങളിൽ നിന്ന് അവയുടെ ഒറിജിനൽ അക്ഷരങ്ങളിലേക്കുള്ള ഒരു മാപ്പിംഗ് നിർമ്മിക്കുന്നു, \n    ഈ മാപ്പിംഗ് ഉപയോഗിച്ച് നൽകിയ എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശം ഡികോഡ് ചെയ്യുന്നു. മാപ്പിംഗ് നിർമ്മാണത്തിനിടെ ഒരു വിരുദ്ധാഭാസം കണ്ടെത്തുകയോ, \n    അല്ലെങ്കിൽ എല്ലാ അക്ഷരങ്ങളും മാപ്പിംഗിൽ പ്രതിനിധീകരിച്ചിട്ടില്ലെങ്കിൽ, ഫംഗ്ഷൻ \"Failed\" തിരികെ നൽകുന്നു.\n    \n    Args:\n    encoded (str): എൻകോഡഡ് വിവരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    original (str): എൻകോഡഡ് സ്ട്രിംഗിനോട് അനുബന്ധിക്കുന്ന ഒറിജിനൽ വിവരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    message (str): ഡികോഡ് ചെയ്യേണ്ട എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    \n    Returns:\n    str: വിജയകരമായാൽ ഡികോഡ് ചെയ്ത സന്ദേശം, അല്ലെങ്കിൽ ഡികോഡിംഗ് സാധ്യമല്ലെങ്കിൽ \"Failed\".\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "fa": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    رمزگشایی یک پیام رمزگذاری شده با استفاده از یک رمز که از یک جفت رمزگذاری شده-اصلی شناخته شده به دست آمده است.\n\n    این تابع یک نگاشت از حروف رمزگذاری شده به حروف اصلی آن‌ها ایجاد می‌کند و از این\n    نگاشت برای رمزگشایی یک پیام رمزگذاری شده استفاده می‌کند. اگر تناقضی در طول ساخت نگاشت\n    پیدا شود، یا اگر همه حروف در نگاشت نمایانده نشده باشند، تابع \"Failed\" را برمی‌گرداند.\n\n    آرگومان‌ها:\n    encoded (str): یک رشته که اطلاعات رمزگذاری شده را نشان می‌دهد.\n    original (str): یک رشته که اطلاعات اصلی مربوط به رشته رمزگذاری شده را نشان می‌دهد.\n    message (str): یک رشته که پیام رمزگذاری شده‌ای که باید رمزگشایی شود را نشان می‌دهد.\n\n    بازگشت:\n    str: پیام رمزگشایی شده در صورت موفقیت، یا \"Failed\" اگر رمزگشایی ممکن نباشد.\n\n    مثال‌ها:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\""}, "canonical_solution": "    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message", "instruction": {"en": "Write a python function 'def decode(encoded: str, original: str, message: str) -> str:' to solve the following problem:\n\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    ", "sq": "Shkruani një funksion python 'def decode(encoded: str, original: str, message: str) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Dekodon një mesazh të koduar duke përdorur një shifër të nxjerrë nga një çift i njohur i koduar-original.\n\n    Funksioni ndërton një hartë nga shkronjat e koduara te shkronjat e tyre origjinale dhe përdor këtë\n    hartë për të dekoduar një mesazh të dhënë të koduar. Nëse gjendet një kontradiktë gjatë ndërtimit të hartës,\n    ose jo të gjitha shkronjat janë të përfaqësuara në hartë, funksioni kthen \"Failed\".\n\n    Args:\n    encoded (str): Një varg që përfaqëson informacionin e koduar.\n    original (str): Një varg që përfaqëson informacionin origjinal që korrespondon me vargun e koduar.\n    message (str): Një varg që përfaqëson mesazhin e koduar që do të dekodohet.\n\n    Returns:\n    str: Mesazhi i dekoduar nëse është i suksesshëm, ose \"Failed\" nëse dekodimi nuk është i mundur.\n\n    Shembuj:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "hy": "Պայթոն ֆունկցիա 'def decode(encoded: str, original: str, message: str) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Վերծանում է կոդավորված հաղորդագրությունը՝ օգտագործելով հայտնի կոդավորված-բնօրինակ զույգից ստացված ծածկագիրը:\n    \n    Ֆունկցիան կառուցում է համապատասխանություն կոդավորված տառերից դեպի իրենց բնօրինակ տառերը և օգտագործում է այս\n    համապատասխանությունը՝ տրված կոդավորված հաղորդագրությունը վերծանելու համար: Եթե հակասություն է հայտնաբերվում\n    համապատասխանության կառուցման ընթացքում, կամ բոլոր տառերը ներկայացված չեն համապատասխանության մեջ, ֆունկցիան վերադարձնում է \"Failed\":\n    \n    Արգումենտներ:\n    encoded (str): Տող, որը ներկայացնում է կոդավորված տեղեկատվությունը:\n    original (str): Տող, որը ներկայացնում է կոդավորված տողին համապատասխանող բնօրինակ տեղեկատվությունը:\n    message (str): Տող, որը ներկայացնում է վերծանման ենթակա կոդավորված հաղորդագրությունը:\n    \n    Վերադարձնում է:\n    str: Վերծանված հաղորդագրությունը, եթե հաջող է, կամ \"Failed\", եթե վերծանումը հնարավոր չէ:\n    \n    Օրինակներ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n", "bn": "একটি পাইথন ফাংশন 'def decode(encoded: str, original: str, message: str) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি পরিচিত এনকোডেড-অরিজিনাল জোড়া থেকে প্রাপ্ত সাইফার ব্যবহার করে একটি এনক্রিপ্টেড বার্তা ডিকোড করে।\n    \n    ফাংশনটি এনকোডেড অক্ষর থেকে তাদের মূল অক্ষরে একটি ম্যাপিং তৈরি করে এবং এই ম্যাপিং \n    ব্যবহার করে একটি প্রদত্ত এনক্রিপ্টেড বার্তা ডিকোড করে। যদি ম্যাপিং নির্মাণের সময় \n    কোনও বিরোধ পাওয়া যায়, বা ম্যাপিংয়ে সমস্ত অক্ষর উপস্থাপিত না হয়, তাহলে ফাংশনটি \"Failed\" ফেরত দেয়।\n    \n    Args:\n    encoded (str): এনকোড করা তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    original (str): এনকোড করা স্ট্রিংয়ের সাথে সংশ্লিষ্ট মূল তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    message (str): ডিকোড করার জন্য এনক্রিপ্টেড বার্তা উপস্থাপনকারী একটি স্ট্রিং।\n    \n    Returns:\n    str: ডিকোড করা বার্তা যদি সফল হয়, অথবা \"Failed\" যদি ডিকোড করা সম্ভব না হয়।\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "bg": "Напишете Python функция 'def decode(encoded: str, original: str, message: str) -> str:' за решаване на следния проблем:\n\n    Декодира криптирано съобщение, използвайки шифър, извлечен от известна двойка кодирано-оригинално.\n    \n    Функцията създава съответствие от кодирани букви към техните оригинални букви и използва това\n    съответствие за декодиране на дадено криптирано съобщение. Ако се намери противоречие по време на\n    създаването на съответствието или не всички букви са представени в съответствието, функцията връща \"Failed\".\n    \n    Аргументи:\n    encoded (str): Низ, представляващ кодираната информация.\n    original (str): Низ, представляващ оригиналната информация, съответстваща на кодирания низ.\n    message (str): Низ, представляващ криптираното съобщение, което трябва да бъде декодирано.\n    \n    Връща:\n    str: Декодираното съобщение, ако е успешно, или \"Failed\", ако декодирането не е възможно.\n    \n    Примери:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "zh": "编写一个Python函数 'def decode(encoded: str, original: str, message: str) -> str:' 来解决以下问题：\n\n    使用从已知的编码-原始对派生的密码解码加密消息。\n    \n    该函数从编码字母到其原始字母构建一个映射，并使用此映射解码给定的加密消息。\n    如果在构建映射过程中发现矛盾，或者映射中并未代表所有字母，函数返回 \"Failed\"。\n    \n    参数:\n    encoded (str): 表示编码信息的字符串。\n    original (str): 表示与编码字符串对应的原始信息的字符串。\n    message (str): 表示要解码的加密消息的字符串。\n    \n    返回:\n    str: 如果解码成功则返回解码后的消息，如果解码不可能则返回 \"Failed\"。\n    \n    示例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "fr": "Écrivez une fonction python 'def decode(encoded: str, original: str, message: str) -> str:' pour résoudre le problème suivant :\n\n    Décode un message chiffré en utilisant un chiffrement dérivé d'une paire encodée-originale connue.\n    \n    La fonction construit une correspondance des lettres encodées vers leurs lettres originales et utilise cette\n    correspondance pour décoder un message chiffré donné. Si une contradiction est trouvée lors de la construction\n    de la correspondance, ou si toutes les lettres ne sont pas représentées dans la correspondance, la fonction retourne \"Failed\".\n    \n    Args:\n    encoded (str): Une chaîne représentant l'information encodée.\n    original (str): Une chaîne représentant l'information originale correspondant à la chaîne encodée.\n    message (str): Une chaîne représentant le message chiffré à décoder.\n    \n    Returns:\n    str: Le message décodé si réussi, ou \"Failed\" si le décodage n'est pas possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "de": "Schreiben Sie eine Python-Funktion 'def decode(encoded: str, original: str, message: str) -> str:' um das folgende Problem zu lösen:\n\n    Entschlüsselt eine verschlüsselte Nachricht mit Hilfe eines Chiffre, der aus einem bekannten kodierten-originalen Paar abgeleitet ist.\n    \n    Die Funktion erstellt eine Zuordnung von kodierten Buchstaben zu ihren ursprünglichen Buchstaben und verwendet diese\n    Zuordnung, um eine gegebene verschlüsselte Nachricht zu entschlüsseln. Wenn während der Erstellung der Zuordnung ein Widerspruch gefunden wird\n    oder nicht alle Buchstaben in der Zuordnung vertreten sind, gibt die Funktion \"Failed\" zurück.\n    \n    Argumente:\n    encoded (str): Ein String, der die kodierten Informationen darstellt.\n    original (str): Ein String, der die ursprünglichen Informationen darstellt, die dem kodierten String entsprechen.\n    message (str): Ein String, der die zu entschlüsselnde verschlüsselte Nachricht darstellt.\n    \n    Rückgabewert:\n    str: Die entschlüsselte Nachricht, wenn erfolgreich, oder \"Failed\", wenn die Entschlüsselung nicht möglich ist.\n    \n    Beispiele:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "ha": "Rubuta wani aikin python 'def decode(encoded: str, original: str, message: str) -> str:' don warware matsalar mai zuwa:\n\n    Fassarawa sakon da aka ɓoye ta amfani da wani cipher da aka samo daga sanannen encoded-original nau'i biyu.\n    \n    Aikin yana gina taswira daga haruffan da aka ɓoye zuwa haruffan asali kuma yana amfani da wannan\n    taswira don fassara wani sakon da aka ɓoye. Idan aka sami sabani yayin gina taswira,\n    ko kuma ba duk haruffa suna cikin taswira ba, aikin yana dawowa da \"Failed\".\n    \n    Args:\n    encoded (str): Wani kirtani da ke wakiltar bayanan da aka ɓoye.\n    original (str): Wani kirtani da ke wakiltar bayanan asali da suka dace da kirtanin da aka ɓoye.\n    message (str): Wani kirtani da ke wakiltar sakon da aka ɓoye da za a fassara.\n    \n    Returns:\n    str: Sakon da aka fassara idan an yi nasara, ko \"Failed\" idan ba zai yiwu a fassara ba.\n    \n    Misalai:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "hi": "एक पायथन फ़ंक्शन 'def decode(encoded: str, original: str, message: str) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    ज्ञात एन्कोडेड-मूल जोड़ी से व्युत्पन्न एक सिफर का उपयोग करके एक एन्क्रिप्टेड संदेश को डिकोड करता है।\n    \n    फ़ंक्शन एन्कोडेड अक्षरों से उनके मूल अक्षरों तक एक मैपिंग बनाता है और इस मैपिंग का उपयोग \n    दिए गए एन्क्रिप्टेड संदेश को डिकोड करने के लिए करता है। यदि मैपिंग निर्माण के दौरान कोई \n    विरोधाभास पाया जाता है, या मैपिंग में सभी अक्षर प्रतिनिधित्व नहीं करते हैं, तो फ़ंक्शन \"Failed\" लौटाता है।\n    \n    तर्क:\n    encoded (str): एन्कोडेड जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    original (str): एन्कोडेड स्ट्रिंग के अनुरूप मूल जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    message (str): डिकोड किए जाने वाले एन्क्रिप्टेड संदेश का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    \n    लौटाता है:\n    str: यदि सफल होता है तो डिकोड किया गया संदेश, या यदि डिकोडिंग संभव नहीं है तो \"Failed\"।\n    \n    उदाहरण:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "hu": "Írj egy python függvényt 'def decode(encoded: str, original: str, message: str) -> str:' a következő probléma megoldására:\n\n    Dekódol egy titkosított üzenetet egy ismert kódolt-eredeti párból származó rejtjel segítségével.\n    \n    A függvény létrehoz egy leképezést a kódolt betűk és az eredeti betűk között, és ezt a\n    leképezést használja a megadott titkosított üzenet dekódolására. Ha ellentmondás található a\n    leképezés létrehozása során, vagy nem minden betű van képviselve a leképezésben, a függvény \"Failed\"-et ad vissza.\n    \n    Paraméterek:\n    encoded (str): Egy karakterlánc, amely a kódolt információt képviseli.\n    original (str): Egy karakterlánc, amely az eredeti információt képviseli, amely megfelel a kódolt karakterláncnak.\n    message (str): Egy karakterlánc, amely a dekódolandó titkosított üzenetet képviseli.\n    \n    Visszatér:\n    str: A dekódolt üzenet, ha sikeres, vagy \"Failed\", ha a dekódolás nem lehetséges.\n    \n    Példák:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "es": "Escribe una función de Python 'def decode(encoded: str, original: str, message: str) -> str:' para resolver el siguiente problema:\n\n    Decodifica un mensaje encriptado utilizando un cifrado derivado de un par conocido codificado-original.\n    \n    La función construye un mapeo de letras codificadas a sus letras originales y utiliza este\n    mapeo para decodificar un mensaje encriptado dado. Si se encuentra una contradicción durante la construcción del mapeo, o no todas las letras están representadas en el mapeo, la función devuelve \"Failed\".\n    \n    Argumentos:\n    encoded (str): Una cadena que representa la información codificada.\n    original (str): Una cadena que representa la información original correspondiente a la cadena codificada.\n    message (str): Una cadena que representa el mensaje encriptado a ser decodificado.\n    \n    Devuelve:\n    str: El mensaje decodificado si tiene éxito, o \"Failed\" si la decodificación no es posible.\n    \n    Ejemplos:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "arb": "اكتب دالة بايثون 'def decode(encoded: str, original: str, message: str) -> str:' لحل المشكلة التالية:\n\n    تقوم بفك تشفير رسالة مشفرة باستخدام شفرة مشتقة من زوج معروف من المشفر-الأصلي.\n    \n    تقوم الدالة ببناء خريطة من الحروف المشفرة إلى حروفها الأصلية وتستخدم هذه\n    الخريطة لفك تشفير رسالة مشفرة معينة. إذا تم العثور على تناقض أثناء بناء الخريطة،\n    أو لم تكن جميع الحروف ممثلة في الخريطة، فإن الدالة تُرجع \"فشل\".\n    \n    يعيدالحجج:\n    encoded (str): سلسلة تمثل المعلومات المشفرة.\n    original (str): سلسلة تمثل المعلومات الأصلية المقابلة للسلسلة المشفرة.\n    message (str): سلسلة تمثل الرسالة المشفرة التي سيتم فك تشفيرها.\n    \n    يعيد:\n    str: الرسالة المفكوكة إذا كانت ناجحة، أو \"فشل\" إذا لم يكن فك التشفير ممكنًا.\n    \n    أمثلة:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "sw": "Andika kazi ya python 'def decode(encoded: str, original: str, message: str) -> str:' kutatua tatizo lifuatalo:\n\n    Inafungua ujumbe uliofichwa kwa kutumia cipher inayotokana na jozi inayojulikana ya encoded-original.\n    \n    Kazi inajenga ramani kutoka kwa herufi zilizofichwa hadi herufi zao za asili na kutumia\n    ramani hii kufungua ujumbe uliosimbwa. Ikiwa upinzani utapatikana wakati wa ujenzi wa ramani,\n    au si herufi zote zinawakilishwa katika ramani, kazi inarudisha \"Failed\".\n    \n    Hoja:\n    encoded (str): Kamba inayowakilisha taarifa iliyosimbwa.\n    original (str): Kamba inayowakilisha taarifa ya asili inayolingana na kamba iliyosimbwa.\n    message (str): Kamba inayowakilisha ujumbe uliosimbwa ambao unahitaji kufunguliwa.\n    \n    Inarejesha:\n    str: Ujumbe uliotafsiriwa ikiwa umefanikiwa, au \"Failed\" ikiwa kutafsiri hakuezekani.\n    \n    Mifano:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "tr": "Bir python fonksiyonu 'def decode(encoded: str, original: str, message: str) -> str:' yazın ve aşağıdaki problemi çözün:\n\n    Bilinen bir kodlanmış-orijinal çiftinden türetilmiş bir şifre kullanarak şifreli bir mesajı çözer.\n    \n    Fonksiyon, kodlanmış harflerden orijinal harflere bir eşleme oluşturur ve bu\n    eşlemeyi verilen şifreli mesajı çözmek için kullanır. Eşleme oluşturma sırasında bir çelişki bulunursa veya\n    eşlemede tüm harfler temsil edilmezse, fonksiyon \"Failed\" döndürür.\n    \n    Argümanlar:\n    encoded (str): Kodlanmış bilgiyi temsil eden bir dize.\n    original (str): Kodlanmış dizeye karşılık gelen orijinal bilgiyi temsil eden bir dize.\n    message (str): Çözülecek şifreli mesajı temsil eden bir dize.\n    \n    Döndürür:\n    str: Başarılı olursa çözülen mesaj veya çözme mümkün değilse \"Failed\".\n    \n    Örnekler:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "vi": "Viết một hàm python 'def decode(encoded: str, original: str, message: str) -> str:' để giải quyết vấn đề sau:\n\n    Giải mã một thông điệp được mã hóa bằng cách sử dụng một mật mã được tạo ra từ một cặp đã mã hóa-gốc đã biết.\n    \n    Hàm xây dựng một ánh xạ từ các chữ cái đã mã hóa sang các chữ cái gốc của chúng và sử dụng ánh xạ này\n    để giải mã một thông điệp được mã hóa. Nếu tìm thấy một mâu thuẫn trong quá trình xây dựng ánh xạ,\n    hoặc không phải tất cả các chữ cái đều được đại diện trong ánh xạ, hàm trả về \"Failed\".\n    \n    Tham số:\n    encoded (str): Một chuỗi đại diện cho thông tin đã mã hóa.\n    original (str): Một chuỗi đại diện cho thông tin gốc tương ứng với chuỗi đã mã hóa.\n    message (str): Một chuỗi đại diện cho thông điệp được mã hóa cần giải mã.\n    \n    Trả về:\n    str: Thông điệp đã giải mã nếu thành công, hoặc \"Failed\" nếu không thể giải mã.\n    \n    Ví dụ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "id": "Tulis sebuah fungsi python 'def decode(encoded: str, original: str, message: str) -> str:' untuk menyelesaikan masalah berikut:\n\n    Mendekripsi sebuah pesan terenkripsi menggunakan sandi yang berasal dari pasangan encoded-original yang diketahui.\n    \n    Fungsi ini membangun pemetaan dari huruf-huruf terenkripsi ke huruf-huruf aslinya dan menggunakan\n    pemetaan ini untuk mendekripsi pesan terenkripsi yang diberikan. Jika ditemukan kontradiksi selama konstruksi pemetaan,\n    atau tidak semua huruf terwakili dalam pemetaan, fungsi mengembalikan \"Failed\".\n    \n    Argumen:\n    encoded (str): Sebuah string yang mewakili informasi terenkripsi.\n    original (str): Sebuah string yang mewakili informasi asli yang sesuai dengan string terenkripsi.\n    message (str): Sebuah string yang mewakili pesan terenkripsi yang akan didekripsi.\n    \n    Mengembalikan:\n    str: Pesan yang telah didekripsi jika berhasil, atau \"Failed\" jika dekripsi tidak memungkinkan.\n    \n    Contoh:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "ja": "Python関数 'def decode(encoded: str, original: str, message: str) -> str:' を作成して、次の問題を解決してください:\n\n    既知のエンコード-オリジナルペアから派生した暗号を使用して、暗号化されたメッセージをデコードします。\n    \n    関数は、エンコードされた文字からオリジナルの文字へのマッピングを構築し、このマッピングを使用して与えられた暗号化メッセージをデコードします。マッピングの構築中に矛盾が見つかった場合、またはすべての文字がマッピングに表現されていない場合、関数は \"Failed\" を返します。\n    \n    引数:\n    encoded (str): エンコードされた情報を表す文字列。\n    original (str): エンコードされた文字列に対応するオリジナル情報を表す文字列。\n    message (str): デコードされるべき暗号化されたメッセージを表す文字列。\n    \n    戻り値:\n    str: デコードが成功した場合はデコードされたメッセージ、デコードが不可能な場合は \"Failed\"。\n    \n    例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "ko": "파이썬 함수를 작성하세요 'def decode(encoded: str, original: str, message: str) -> str:' 다음 문제를 해결하기 위해:\n\n    알려진 인코딩-원본 쌍에서 파생된 암호를 사용하여 암호화된 메시지를 해독합니다.\n    \n    함수는 인코딩된 문자에서 원본 문자로의 매핑을 구축하고 이 매핑을 사용하여 주어진 암호화된 메시지를 해독합니다. 매핑 생성 중에 모순이 발견되거나 모든 문자가 매핑에 나타나지 않으면 함수는 \"Failed\"를 반환합니다.\n    \n    인수:\n    encoded (str): 인코딩된 정보를 나타내는 문자열입니다.\n    original (str): 인코딩된 문자열에 해당하는 원본 정보를 나타내는 문자열입니다.\n    message (str): 해독할 암호화된 메시지를 나타내는 문자열입니다.\n    \n    반환:\n    str: 성공 시 해독된 메시지, 해독이 불가능한 경우 \"Failed\"를 반환합니다.\n    \n    예제:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "ml": "'def decode(encoded: str, original: str, message: str) -> str:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെക്കാണുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    ഒരു അറിയപ്പെടുന്ന എൻകോഡഡ്-ഒറിജിനൽ ജോഡിയിൽ നിന്ന് ലഭിക്കുന്ന സൈഫർ ഉപയോഗിച്ച് എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശം ഡികോഡ് ചെയ്യുന്നു.\n    \n    എൻകോഡഡ് അക്ഷരങ്ങളിൽ നിന്ന് അവയുടെ ഒറിജിനൽ അക്ഷരങ്ങളിലേക്കുള്ള മാപ്പിംഗ് ഫംഗ്ഷൻ നിർമ്മിക്കുന്നു, ഈ മാപ്പിംഗ് ഉപയോഗിച്ച് നൽകിയ എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശം ഡികോഡ് ചെയ്യുന്നു. മാപ്പിംഗ് നിർമ്മാണത്തിനിടെ ഒരു വിരുദ്ധാഭാസം കണ്ടെത്തുകയോ, എല്ലാ അക്ഷരങ്ങളും മാപ്പിംഗിൽ പ്രതിനിധീകരിക്കപ്പെടുന്നില്ലെങ്കിൽ, ഫംഗ്ഷൻ \"Failed\" തിരികെ നൽകുന്നു.\n    \n    Args:\n    encoded (str): എൻകോഡഡ് വിവരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    original (str): എൻകോഡഡ് സ്ട്രിംഗിന് അനുബന്ധമായ ഒറിജിനൽ വിവരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    message (str): ഡികോഡ് ചെയ്യേണ്ട എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    \n    Returns:\n    str: വിജയകരമായാൽ ഡികോഡ് ചെയ്ത സന്ദേശം, അല്ലെങ്കിൽ ഡികോഡിംഗ് സാധ്യമല്ലെങ്കിൽ \"Failed\".\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "fa": "یک تابع پایتون بنویسید 'def decode(encoded: str, original: str, message: str) -> str:' تا مسئله زیر را حل کند:\n\n    یک پیام رمزگذاری‌شده را با استفاده از یک رمز که از یک جفت رمزگذاری‌شده-اصلی شناخته‌شده به دست آمده است، رمزگشایی می‌کند.\n    \n    تابع یک نگاشت از حروف رمزگذاری‌شده به حروف اصلی آن‌ها ایجاد می‌کند و از این\n    نگاشت برای رمزگشایی یک پیام رمزگذاری‌شده استفاده می‌کند. اگر در طول ساخت نگاشت تناقضی پیدا شود، یا همه حروف در نگاشت نمایانده نشوند، تابع \"Failed\" را برمی‌گرداند.\n    \n    آرگومان‌ها:\n    encoded (str): یک رشته که اطلاعات رمزگذاری‌شده را نشان می‌دهد.\n    original (str): یک رشته که اطلاعات اصلی مربوط به رشته رمزگذاری‌شده را نشان می‌دهد.\n    message (str): یک رشته که پیام رمزگذاری‌شده‌ای که باید رمزگشایی شود را نشان می‌دهد.\n    \n    بازگشتی:\n    str: پیام رمزگشایی‌شده در صورت موفقیت، یا \"Failed\" اگر رمزگشایی ممکن نباشد.\n    \n    مثال‌ها:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'"}, "level": "hard", "test": "def test_decode():\n    # Test case 1: Contradiction in mapping\n    assert decode(\"AA\", \"AB\", \"EOWIE\") == \"Failed\", \"Test case 1 failed\"\n\n    # Test case 2: Not all letters are represented\n    assert decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\") == \"Failed\", \"Test case 2 failed\"\n\n    # Test case 3: Successful decoding\n    assert decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\", \"Test case 3 failed\"\n    \n    # Test case 4: Character in message not in mapping\n    assert decode(\"ABCDEFGHIJKLM\", \"NOPQRSTUVWXYZ\", \"UVWXYZ\") == \"Failed\", \"Test case 4 failed\"\n\n    # Test case 5: Empty strings\n    assert decode(\"\", \"\", \"\") == \"Failed\", \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function to run the test cases\ntest_decode()", "entry_point": "decode", "signature": "def decode(encoded: str, original: str, message: str) -> str:", "docstring": {"en": "\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    ", "sq": "\n    Dekodon një mesazh të koduar duke përdorur një çelës të nxjerrë nga një çift i njohur i koduar-origjinal.\n    \n    Funksioni ndërton një hartë nga shkronjat e koduara te shkronjat e tyre origjinale dhe përdor këtë\n    hartë për të dekoduar një mesazh të dhënë të koduar. Nëse gjendet një kontradiktë gjatë ndërtimit të hartës,\n    ose nëse jo të gjitha shkronjat janë të përfaqësuara në hartë, funksioni kthen \"Dështoi\".\n    \n    Argumentet:\n    encoded (str): Një varg që përfaqëson informacionin e koduar.\n    original (str): Një varg që përfaqëson informacionin origjinal që korrespondon me vargun e koduar.\n    message (str): Një varg që përfaqëson mesazhin e koduar që do të dekodohet.\n    \n    Kthen:\n    str: Mesazhi i dekoduar nëse është i suksesshëm, ose \"Dështoi\" nëse dekodimi nuk është i mundur.\n    \n    Shembuj:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "hy": "\n    Վերծանում է կոդավորված հաղորդագրությունը՝ օգտագործելով հայտնի կոդավորված-բնօրինակ զույգից ստացված ծածկագիրը:\n    \n    Ֆունկցիան կառուցում է համապատասխանություն կոդավորված տառերից դեպի իրենց բնօրինակ տառերը և օգտագործում է այս\n    համապատասխանությունը՝ տրված կոդավորված հաղորդագրությունը վերծանելու համար: Եթե հակասություն է հայտնաբերվում համապատասխանության\n    կառուցման ընթացքում, կամ բոլոր տառերը ներկայացված չեն համապատասխանության մեջ, ֆունկցիան վերադարձնում է \"Failed\":\n    \n    Պարամետրեր:\n    encoded (str): Տող, որը ներկայացնում է կոդավորված տեղեկատվությունը:\n    original (str): Տող, որը ներկայացնում է կոդավորված տողի համապատասխան բնօրինակ տեղեկատվությունը:\n    message (str): Տող, որը ներկայացնում է վերծանման ենթակա կոդավորված հաղորդագրությունը:\n    \n    Վերադարձնում է:\n    str: Վերծանված հաղորդագրությունը, եթե հաջող է, կամ \"Failed\", եթե վերծանումը հնարավոր չէ:\n    \n    Օրինակներ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "bn": "\n    একটি পরিচিত এনকোডেড-অরিজিনাল জোড়া থেকে প্রাপ্ত সাইফার ব্যবহার করে একটি এনক্রিপ্টেড বার্তা ডিকোড করে।\n    \n    ফাংশনটি এনকোডেড অক্ষর থেকে তাদের মূল অক্ষরে একটি ম্যাপিং তৈরি করে এবং এই ম্যাপিং ব্যবহার করে একটি প্রদত্ত এনক্রিপ্টেড বার্তা ডিকোড করে। ম্যাপিং নির্মাণের সময় যদি কোনো বিরোধ পাওয়া যায়, বা ম্যাপিংয়ে সব অক্ষর প্রতিনিধিত্ব না করে, তাহলে ফাংশন \"Failed\" ফেরত দেয়।\n    \n    আর্গস:\n    encoded (str): এনকোডেড তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    original (str): এনকোডেড স্ট্রিংয়ের সাথে সম্পর্কিত মূল তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    message (str): ডিকোড করার জন্য এনক্রিপ্টেড বার্তা উপস্থাপনকারী একটি স্ট্রিং।\n    \n    রিটার্নস:\n    str: সফল হলে ডিকোড করা বার্তা, অথবা ডিকোডিং সম্ভব না হলে \"Failed\"।\n    \n    উদাহরণ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "bg": "\n    Декодира криптирано съобщение, използвайки шифър, извлечен от известна двойка кодирано-оригинално.\n    \n    Функцията създава съответствие от кодирани букви към техните оригинални букви и използва това\n    съответствие, за да декодира дадено криптирано съобщение. Ако бъде намерено противоречие по време на създаването на съответствието,\n    или не всички букви са представени в съответствието, функцията връща \"Failed\".\n    \n    Аргументи:\n    encoded (str): Низ, представляващ кодираната информация.\n    original (str): Низ, представляващ оригиналната информация, съответстваща на кодирания низ.\n    message (str): Низ, представляващ криптираното съобщение, което трябва да бъде декодирано.\n    \n    Връща:\n    str: Декодираното съобщение, ако е успешно, или \"Failed\", ако декодирането не е възможно.\n    \n    Примери:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "zh": "\n    使用从已知编码-原始对派生的密码解码加密消息。\n    \n    该函数从编码字母到其原始字母构建一个映射，并使用此映射解码给定的加密消息。\n    如果在映射构建过程中发现矛盾，或者映射中没有表示所有字母，函数返回 \"Failed\"。\n    \n    参数:\n    encoded (str): 表示编码信息的字符串。\n    original (str): 表示与编码字符串对应的原始信息的字符串。\n    message (str): 表示要解码的加密消息的字符串。\n    \n    返回:\n    str: 如果成功则返回解码后的消息，如果解码不可能则返回 \"Failed\"。\n    \n    示例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "fr": "\n    Décode un message chiffré en utilisant un chiffre dérivé d'une paire connue encodée-originale.\n    \n    La fonction construit une correspondance des lettres encodées vers leurs lettres originales et utilise cette\n    correspondance pour décoder un message chiffré donné. Si une contradiction est trouvée lors de la construction de la correspondance,\n    ou si toutes les lettres ne sont pas représentées dans la correspondance, la fonction retourne \"Failed\".\n    \n    Args:\n    encoded (str): Une chaîne représentant l'information encodée.\n    original (str): Une chaîne représentant l'information originale correspondant à la chaîne encodée.\n    message (str): Une chaîne représentant le message chiffré à décoder.\n    \n    Returns:\n    str: Le message décodé si réussi, ou \"Failed\" si le décodage n'est pas possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "de": "\n    Entschlüsselt eine verschlüsselte Nachricht mithilfe eines Chiffres, der aus einem bekannten Paar von kodierten und originalen Zeichenfolgen abgeleitet wurde.\n    \n    Die Funktion erstellt eine Zuordnung von kodierten Buchstaben zu ihren ursprünglichen Buchstaben und verwendet diese Zuordnung, um eine gegebene verschlüsselte Nachricht zu entschlüsseln. Wenn während der Erstellung der Zuordnung ein Widerspruch gefunden wird oder nicht alle Buchstaben in der Zuordnung vertreten sind, gibt die Funktion \"Failed\" zurück.\n    \n    Argumente:\n    encoded (str): Eine Zeichenfolge, die die kodierte Information darstellt.\n    original (str): Eine Zeichenfolge, die die ursprüngliche Information darstellt, die der kodierten Zeichenfolge entspricht.\n    message (str): Eine Zeichenfolge, die die zu entschlüsselnde verschlüsselte Nachricht darstellt.\n    \n    Rückgabe:\n    str: Die entschlüsselte Nachricht, wenn erfolgreich, oder \"Failed\", wenn die Entschlüsselung nicht möglich ist.\n    \n    Beispiele:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "ha": "\n    Fassar da saƙon da aka ɓoye ta amfani da wata hanya da aka samo daga sanannen encoded-original ma'aurata.\n    \n    Aikin yana gina taswira daga haruffan da aka ɓoye zuwa haruffan asali kuma yana amfani da wannan\n    taswira don fassara wani saƙon da aka ɓoye. Idan an sami sabani yayin gina taswira,\n    ko kuma ba duk haruffa suna cikin taswirar ba, aikin yana dawowa da \"Failed\".\n    \n    Args:\n    encoded (str): Wani kirtani da ke wakiltar bayanan da aka ɓoye.\n    original (str): Wani kirtani da ke wakiltar bayanan asali da suka dace da kirtanin da aka ɓoye.\n    message (str): Wani kirtani da ke wakiltar saƙon da aka ɓoye da za a fassara.\n    \n    Returns:\n    str: Saƙon da aka fassara idan an yi nasara, ko \"Failed\" idan ba zai yiwu a fassara ba.\n    \n    Misalai:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "hi": "\n    ज्ञात एन्कोडेड-मूल जोड़ी से व्युत्पन्न सिफर का उपयोग करके एक एन्क्रिप्टेड संदेश को डिकोड करता है।\n    \n    यह फ़ंक्शन एन्कोडेड अक्षरों से उनके मूल अक्षरों तक एक मैपिंग बनाता है और इस मैपिंग का उपयोग करके दिए गए एन्क्रिप्टेड संदेश को डिकोड करता है। यदि मैपिंग निर्माण के दौरान कोई विरोधाभास पाया जाता है, या मैपिंग में सभी अक्षरों का प्रतिनिधित्व नहीं होता है, तो फ़ंक्शन \"Failed\" लौटाता है।\n    \n    तर्क:\n    encoded (str): एन्कोडेड जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    original (str): एन्कोडेड स्ट्रिंग के अनुरूप मूल जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    message (str): डिकोड किए जाने वाले एन्क्रिप्टेड संदेश का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    \n    लौटाता है:\n    str: यदि सफल हो तो डिकोड किया गया संदेश, या यदि डिकोडिंग संभव नहीं है तो \"Failed\"।\n    \n    उदाहरण:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "hu": "\n    Dekódol egy titkosított üzenetet egy ismert kódolt-eredeti párból származó rejtjel segítségével.\n    \n    A függvény egy leképezést épít a kódolt betűk és az eredeti betűk között, és ezt a leképezést használja\n    egy adott titkosított üzenet dekódolására. Ha ellentmondást talál a leképezés építése során, vagy nem minden betű szerepel a leképezésben, a függvény \"Failed\" értéket ad vissza.\n    \n    Paraméterek:\n    encoded (str): Egy karakterlánc, amely a kódolt információt képviseli.\n    original (str): Egy karakterlánc, amely az eredeti információt képviseli, amely megfelel a kódolt karakterláncnak.\n    message (str): Egy karakterlánc, amely a dekódolandó titkosított üzenetet képviseli.\n    \n    Visszatér:\n    str: A dekódolt üzenet, ha sikeres, vagy \"Failed\", ha a dekódolás nem lehetséges.\n    \n    Példák:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "es": "    Decodifica un mensaje encriptado utilizando un cifrado derivado de un par conocido de codificado-original.\n    \n    La función construye un mapeo de letras codificadas a sus letras originales y utiliza este\n    mapeo para decodificar un mensaje encriptado dado. Si se encuentra una contradicción durante la construcción del mapeo, o no todas las letras están representadas en el mapeo, la función devuelve \"Failed\".\n    \n    Argumentos:\n    encoded (str): Una cadena que representa la información codificada.\n    original (str): Una cadena que representa la información original correspondiente a la cadena codificada.\n    message (str): Una cadena que representa el mensaje encriptado a decodificar.\n    \n    Devuelve:\n    str: El mensaje decodificado si tiene éxito, o \"Failed\" si la decodificación no es posible.\n    \n    Ejemplos:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "arb": "    يفك تشفير رسالة مشفرة باستخدام شفرة مستمدة من زوج معروف من المشفر-الأصلي.\n    \n    تقوم الدالة ببناء خريطة من الحروف المشفرة إلى حروفها الأصلية وتستخدم هذه\n    الخريطة لفك تشفير رسالة مشفرة معينة. إذا تم العثور على تناقض أثناء بناء الخريطة،\n    أو لم يتم تمثيل جميع الحروف في الخريطة، فإن الدالة تعيد \"فشل\".\n    \n    يعيدالحجج:\n    encoded (str): سلسلة تمثل المعلومات المشفرة.\n    original (str): سلسلة تمثل المعلومات الأصلية المقابلة للسلسلة المشفرة.\n    message (str): سلسلة تمثل الرسالة المشفرة التي سيتم فك تشفيرها.\n    \n    يعيد:\n    str: الرسالة المفكوكة إذا كانت ناجحة، أو \"فشل\" إذا كان فك التشفير غير ممكن.\n    \n    امثله:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "sw": "    Inafasiri ujumbe uliofichwa kwa kutumia cipher inayotokana na jozi inayojulikana ya iliyosimbwa-asili.\n    \n    Kazi hii inajenga ramani kutoka kwa herufi zilizofichwa hadi herufi zao za asili na kutumia ramani hii\n    kufasiri ujumbe uliosimbwa. Ikiwa kuna mkanganyiko unaopatikana wakati wa ujenzi wa ramani,\n    au ikiwa si herufi zote zinawakilishwa kwenye ramani, kazi hii inarudisha \"Imeshindwa\".\n    \n    Hoja:\n    encoded (str): Kamba inayowakilisha taarifa iliyosimbwa.\n    original (str): Kamba inayowakilisha taarifa ya asili inayolingana na kamba iliyosimbwa.\n    message (str): Kamba inayowakilisha ujumbe uliofichwa unaotakiwa kufasiriwa.\n    \n    Inarejesha:\n    str: Ujumbe uliofasiriwa ikiwa umefanikiwa, au \"Imeshindwa\" ikiwa kufasiri haiwezekani.\n    \n    Mifano:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "tr": "Şifreli bir mesajı, bilinen bir kodlanmış-orijinal çiftinden türetilen bir şifre kullanarak çözer.\n\nFonksiyon, kodlanmış harflerden orijinal harflere bir eşleme oluşturur ve bu eşlemeyi verilen şifreli mesajı çözmek için kullanır. Eşleme oluşturma sırasında bir çelişki bulunursa veya tüm harfler eşlemeye dahil edilmezse, fonksiyon \"Başarısız\" döndürür.\n\nArgümanlar:\nencoded (str): Kodlanmış bilgiyi temsil eden bir dize.\noriginal (str): Kodlanmış dizeye karşılık gelen orijinal bilgiyi temsil eden bir dize.\nmessage (str): Çözülecek şifreli mesajı temsil eden bir dize.\n\nDöndürür:\nstr: Başarılı olursa çözülen mesaj veya çözme mümkün değilse \"Başarısız\".\n\nÖrnekler:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'    \n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "vi": "    Giải mã một thông điệp đã được mã hóa bằng cách sử dụng một mật mã được tạo ra từ một cặp mã hóa-gốc đã biết.\n    \n    Hàm này xây dựng một ánh xạ từ các chữ cái đã mã hóa đến các chữ cái gốc của chúng và sử dụng ánh xạ này để giải mã một thông điệp đã được mã hóa. Nếu một mâu thuẫn được tìm thấy trong quá trình xây dựng ánh xạ, hoặc không phải tất cả các chữ cái đều được đại diện trong ánh xạ, hàm sẽ trả về \"Failed\".\n    \n    Tham số:\n    encoded (str): Một chuỗi đại diện cho thông tin đã mã hóa.\n    original (str): Một chuỗi đại diện cho thông tin gốc tương ứng với chuỗi đã mã hóa.\n    message (str): Một chuỗi đại diện cho thông điệp đã được mã hóa cần giải mã.\n    \n    Trả về:\n    str: Thông điệp đã giải mã nếu thành công, hoặc \"Failed\" nếu không thể giải mã.\n    \n    Ví dụ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "id": "Mendekode pesan terenkripsi menggunakan sandi yang berasal dari pasangan encoded-original yang diketahui.\n\nFungsi ini membangun pemetaan dari huruf-huruf yang dienkripsi ke huruf-huruf aslinya dan menggunakan pemetaan ini untuk mendekode pesan terenkripsi yang diberikan. Jika ditemukan kontradiksi selama konstruksi pemetaan, atau tidak semua huruf terwakili dalam pemetaan, fungsi mengembalikan \"Failed\".\n\nArgs:\nencoded (str): Sebuah string yang mewakili informasi yang dienkripsi.\noriginal (str): Sebuah string yang mewakili informasi asli yang sesuai dengan string yang dienkripsi.\nmessage (str): Sebuah string yang mewakili pesan terenkripsi yang akan didekode.\n\nReturns:\nstr: Pesan yang telah didekode jika berhasil, atau \"Failed\" jika dekoding tidak memungkinkan.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'    \n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "ja": "    既知のエンコード済みオリジナルペアから派生した暗号を使用して暗号化されたメッセージをデコードします。\n    \n    この関数は、エンコードされた文字から元の文字へのマッピングを構築し、このマッピングを使用して与えられた暗号化メッセージをデコードします。マッピングの構築中に矛盾が見つかった場合、またはすべての文字がマッピングに表現されていない場合、関数は \"Failed\" を返します。\n    \n    引数:\n    encoded (str): エンコードされた情報を表す文字列。\n    original (str): エンコードされた文字列に対応する元の情報を表す文字列。\n    message (str): デコードする暗号化されたメッセージを表す文字列。\n    \n    戻り値:\n    str: 成功した場合はデコードされたメッセージ、デコードが不可能な場合は \"Failed\"。\n    \n    例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "ko": "암호화된 메시지를 알려진 인코딩-원본 쌍에서 파생된 암호를 사용하여 해독합니다.\n\n이 함수는 인코딩된 문자에서 원본 문자로의 매핑을 구축하고, 이 매핑을 사용하여 주어진 암호화된 메시지를 해독합니다. 매핑 생성 중에 모순이 발견되거나 모든 문자가 매핑에 나타나지 않으면 함수는 \"Failed\"를 반환합니다.\n\n인수:\nencoded (str): 인코딩된 정보를 나타내는 문자열입니다.\noriginal (str): 인코딩된 문자열에 해당하는 원본 정보를 나타내는 문자열입니다.\nmessage (str): 해독할 암호화된 메시지를 나타내는 문자열입니다.\n\n반환:\nstr: 성공 시 해독된 메시지, 해독이 불가능한 경우 \"Failed\"를 반환합니다.\n\n예제:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "ml": "    ഒരു അറിയപ്പെടുന്ന കോഡുചെയ്ത-ഓർജിനൽ ജോഡിയിൽ നിന്ന് ഉരുത്തിരിഞ്ഞ സൈഫർ ഉപയോഗിച്ച് ഒരു എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശം ഡികോഡ് ചെയ്യുന്നു.\n    \n    കോഡുചെയ്ത അക്ഷരങ്ങളിൽ നിന്ന് അവയുടെ ഓർജിനൽ അക്ഷരങ്ങളിലേക്കുള്ള മാപ്പിംഗ് നിർമ്മിച്ച്, നൽകിയ എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശം ഡികോഡ് ചെയ്യാൻ ഈ മാപ്പിംഗ് ഉപയോഗിക്കുന്നു. മാപ്പിംഗ് നിർമ്മാണത്തിനിടെ ഒരു വിരുദ്ധാഭാസം കണ്ടെത്തുകയോ, അല്ലെങ്കിൽ എല്ലാ അക്ഷരങ്ങളും മാപ്പിംഗിൽ പ്രതിനിധീകരിക്കപ്പെടുന്നില്ലെങ്കിൽ, ഫങ്ഷൻ \"Failed\" തിരികെ നൽകുന്നു.\n    \n    Args:\n    encoded (str): കോഡുചെയ്ത വിവരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    original (str): കോഡുചെയ്ത സ്ട്രിംഗിനോട് അനുബന്ധിക്കുന്ന ഓർജിനൽ വിവരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    message (str): ഡികോഡ് ചെയ്യേണ്ട എൻക്രിപ്റ്റ് ചെയ്ത സന്ദേശത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ്.\n    \n    Returns:\n    str: വിജയകരമായാൽ ഡികോഡ് ചെയ്ത സന്ദേശം, അല്ലെങ്കിൽ ഡികോഡിംഗ് സാധ്യമല്ലെങ്കിൽ \"Failed\".\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'", "fa": "    رمزگذاری شده را با استفاده از یک رمزنگاری که از یک جفت رمزگذاری شده-اصلی شناخته شده مشتق شده است، رمزگشایی می‌کند.\n    \n    تابع یک نگاشت از حروف رمزگذاری شده به حروف اصلی آنها ایجاد می‌کند و از این\n    نگاشت برای رمزگشایی یک پیام رمزگذاری شده استفاده می‌کند. اگر تناقضی در طول ساخت نگاشت\n    یافت شود، یا همه حروف در نگاشت نمایندگی نشوند، تابع \"Failed\" را برمی‌گرداند.\n    \n    Args:\n    encoded (str): رشته‌ای که اطلاعات رمزگذاری شده را نشان می‌دهد.\n    original (str): رشته‌ای که اطلاعات اصلی مربوط به رشته رمزگذاری شده را نشان می‌دهد.\n    message (str): رشته‌ای که پیام رمزگذاری شده‌ای که باید رمزگشایی شود را نشان می‌دهد.\n    \n    Returns:\n    str: پیام رمزگشایی شده در صورت موفقیت، یا \"Failed\" اگر رمزگشایی ممکن نباشد.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'"}}
{"task_id": "Python/23", "prompt": {"en": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "sq": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Gjeni faktorin më të madh prim të një numri të dhënë të plotë pozitiv.\n    \n    Supozohet se numri është produkt i saktësisht dy numrave të ndryshëm prim.\n    Funksioni iteron nëpër faktorët potencialë duke filluar nga primi më i vogël (2)\n    dhe kontrollon nëse ata janë faktorë të 'n'. Nëse gjendet një faktor, funksioni kthen\n    pjesëtimin e 'n' me këtë faktor, i cili është faktori më i madh prim. Nëse nuk gjenden faktorë\n    deri në rrënjën katrore të 'n', atëherë vetë 'n' është një numër prim dhe kthehet si faktori më i madh prim.\n    \n    Args:\n    n (int): Numri i plotë pozitiv për të faktoruar, i cili është produkt i dy numrave të ndryshëm prim.\n    \n    Returns:\n    int: Më i madhi nga dy faktorët prim të 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "hy": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Գտնել տրված դրական ամբողջ թվի ամենամեծ պարզ գործակիցը։\n    \n    Ենթադրվում է, որ ամբողջ թիվը երկու տարբեր պարզ թվերի արտադրյալն է։\n    Ֆունկցիան սկսում է ամենափոքր պարզ թվից (2) և ստուգում է՝ արդյոք դրանք 'n'-ի գործակից են։\n    Եթե գործակից է գտնվում, ֆունկցիան վերադարձնում է 'n'-ը այդ գործակցով բաժանելու արդյունքը, որը ամենամեծ պարզ գործակիցն է։\n    Եթե 'n'-ի քառակուսի արմատի սահմաններում գործակիցներ չեն գտնվել, ապա 'n'-ը ինքնին պարզ թիվ է և վերադարձվում է որպես ամենամեծ պարզ գործակից։\n    \n    Արգումենտներ:\n    n (int): Դրական ամբողջ թիվը, որը պետք է գործակիցների բաժանել, որը երկու տարբեր պարզ թվերի արտադրյալն է։\n    \n    Վերադարձնում է:\n    int: 'n'-ի երկու պարզ գործակիցներից ամենամեծը։\n    \n    Օրինակներ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n", "bn": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    প্রদত্ত একটি ধনাত্মক পূর্ণসংখ্যার সর্বাধিক মৌলিক গুণনীয়ক খুঁজে বের করুন।\n    \n    পূর্ণসংখ্যাটি ঠিক দুটি ভিন্ন মৌলিক সংখ্যার গুণফল বলে অনুমান করা হয়।\n    ফাংশনটি সম্ভাব্য গুণনীয়কগুলির মধ্যে ক্ষুদ্রতম মৌলিক সংখ্যা (2) থেকে শুরু করে পুনরাবৃত্তি করে এবং পরীক্ষা করে যে তারা 'n'-এর গুণনীয়ক কিনা।\n    যদি একটি গুণনীয়ক পাওয়া যায়, ফাংশনটি 'n' কে এই গুণনীয়ক দ্বারা ভাগ করার ফলাফল ফেরত দেয়, যা বৃহত্তম মৌলিক গুণনীয়ক।\n    যদি 'n'-এর বর্গমূল পর্যন্ত কোনো গুণনীয়ক পাওয়া না যায়, তবে 'n' নিজেই একটি মৌলিক সংখ্যা এবং সর্বাধিক মৌলিক গুণনীয়ক হিসেবে ফেরত দেওয়া হয়।\n    \n    Args:\n    n (int): ধনাত্মক পূর্ণসংখ্যা যা দুটি ভিন্ন মৌলিক সংখ্যার গুণফল।\n    \n    Returns:\n    int: 'n'-এর দুটি মৌলিক গুণনীয়কের মধ্যে বৃহত্তম।\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n", "bg": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Намерете най-големия прост делител на дадено положително цяло число.\n    \n    Предполага се, че цялото число е произведение на точно две различни прости числа.\n    Функцията преминава през потенциални делители, започвайки от най-малкото просто число (2),\n    и проверява дали те са делители на 'n'. Ако се намери делител, функцията връща\n    делението на 'n' с този делител, което е по-големият прост делител. Ако не се намерят\n    делители до квадратния корен на 'n', тогава 'n' сам по себе си е просто число и се\n    връща като най-големия прост делител.\n    \n    Аргументи:\n    n (int): Положителното цяло число за факторизация, което е произведение на две различни прости числа.\n    \n    Връща:\n    int: По-големият от двата прости делителя на 'n'.\n    \n    Примери:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "zh": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    找到给定正整数的最大素因数。\n    \n    假设该整数是两个不同素数的乘积。\n    该函数从最小的素数(2)开始迭代潜在因数，并检查它们是否是 'n' 的因数。\n    如果找到一个因数，函数返回 'n' 除以该因数的结果，即较大的素因数。\n    如果在 'n' 的平方根范围内没有找到因数，则 'n' 本身是一个素数，并作为最大的素因数返回。\n    \n    参数:\n    n (int): 要分解的正整数，它是两个不同素数的乘积。\n    \n    返回:\n    int: 'n' 的两个素因数中较大的一个。\n    \n    示例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "fr": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Trouver le plus grand facteur premier d'un entier positif donné.\n    \n    L'entier est supposé être le produit de deux nombres premiers distincts exactement.\n    La fonction itère à travers les facteurs potentiels en commençant par le plus petit nombre premier (2)\n    et vérifie s'ils sont un facteur de 'n'. Si un facteur est trouvé, la fonction retourne\n    la division de 'n' par ce facteur, qui est le plus grand facteur premier. Si aucun facteur\n    n'est trouvé jusqu'à la racine carrée de 'n', alors 'n' lui-même est un nombre premier et est\n    retourné comme le plus grand facteur premier.\n    \n    Args:\n    n (int): L'entier positif à factoriser, qui est le produit de deux nombres premiers distincts.\n    \n    Returns:\n    int: Le plus grand des deux facteurs premiers de 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "de": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Finde den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n    \n    Die Zahl wird angenommen als das Produkt von genau zwei verschiedenen Primzahlen.\n    Die Funktion iteriert durch potenzielle Faktoren, beginnend mit der kleinsten Primzahl (2),\n    und prüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion\n    die Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis\n    zur Quadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl\n    und wird als der größte Primfaktor zurückgegeben.\n    \n    Argumente:\n    n (int): Die zu faktorisierende positive ganze Zahl, die das Produkt von zwei verschiedenen Primzahlen ist.\n    \n    Rückgabewert:\n    int: Der größere der beiden Primfaktoren von 'n'.\n    \n    Beispiele:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"", "ha": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Nemo mafi girman lambar farko daga wani adadi mai kyau da aka bayar.\n    \n    Ana tsammanin adadin shine samfurin lambobi biyu na farko daban-daban.\n    Aikin yana zagayawa ta hanyar abubuwan da ake iya samu daga mafi ƙarancin lamba ta farko (2)\n    kuma yana duba ko suna da alaƙa da 'n'. Idan an sami wani abu, aikin yana dawo da\n    rabon 'n' da wannan abin, wanda shine mafi girman lambar farko. Idan ba a sami\n    abubuwa ba har zuwa tushen murabba'in 'n', to 'n' kanta lamba ce ta farko kuma\n    ana dawo da ita a matsayin mafi girman lambar farko.\n    \n    Args:\n    n (int): Adadi mai kyau don yin factorize, wanda shine samfurin lambobi biyu na farko daban-daban.\n    \n    Returns:\n    int: Daya daga cikin lambobin farko biyu na 'n' wanda yafi girma.\n    \n    Misalai:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "hi": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    दिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n    \n    पूर्णांक को ठीक दो भिन्न अभाज्य संख्याओं का गुणनफल माना जाता है।\n    फ़ंक्शन संभावित गुणनखण्डों के माध्यम से सबसे छोटे अभाज्य (2) से शुरू होता है \n    और जांचता है कि क्या वे 'n' के गुणनखण्ड हैं। यदि कोई गुणनखण्ड मिलता है, तो फ़ंक्शन \n    'n' को इस गुणनखण्ड से विभाजित करके लौटाता है, जो कि बड़ा अभाज्य गुणनखण्ड होता है। \n    यदि 'n' के वर्गमूल तक कोई गुणनखण्ड नहीं मिलता है, तो 'n' स्वयं एक अभाज्य संख्या है \n    और इसे सबसे बड़े अभाज्य गुणनखण्ड के रूप में लौटाया जाता है।\n    \n    तर्क:\n    n (int): वह धनात्मक पूर्णांक जिसे गुणनखंडित करना है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\n    \n    लौटाता है:\n    int: 'n' के दो अभाज्य गुणनखण्डों में से बड़ा।\n    \n    उदाहरण:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "hu": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Keresse meg egy adott pozitív egész szám legnagyobb prímtényezőjét.\n    \n    Feltételezzük, hogy az egész szám pontosan két különböző prímszám szorzata.\n    A függvény a legkisebb prímtől (2) kezdve iterál a lehetséges tényezőkön, \n    és ellenőrzi, hogy ezek tényezői-e 'n'-nek. Ha talál tényezőt, a függvény \n    visszaadja 'n' osztását ezzel a tényezővel, ami a nagyobb prímtényező. Ha \n    'n' négyzetgyökéig nem található tényező, akkor maga 'n' prímszám, és \n    visszatér a legnagyobb prímtényezőként.\n    \n    Args:\n    n (int): A pozitív egész szám, amelyet faktorizálni kell, és amely két különböző prímszám szorzata.\n    \n    Returns:\n    int: 'n' két prímtényezője közül a nagyobb.\n    \n    Példák:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n", "es": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Encuentra el mayor factor primo de un número entero positivo dado.\n    \n    Se asume que el entero es el producto de exactamente dos números primos distintos. \n    La función itera a través de posibles factores comenzando desde el menor primo (2) \n    y verifica si son un factor de 'n'. Si se encuentra un factor, la función devuelve \n    la división de 'n' por este factor, que es el mayor factor primo. Si no se encuentran \n    factores hasta la raíz cuadrada de 'n', entonces 'n' en sí mismo es un número primo y \n    se devuelve como el mayor factor primo.\n    \n    Argumentos:\n    n (int): El número entero positivo a factorizar, que es el producto de dos primos distintos.\n    \n    Devuelve:\n    int: El mayor de los dos factores primos de 'n'.\n    \n    Ejemplos:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "arb": "```python\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    إيجاد أكبر عامل أولي لعدد صحيح موجب معين.\n    \n    يُفترض أن العدد الصحيح هو حاصل ضرب عددين أوليين مميزين بالضبط.\n    تقوم الدالة بالتحقق من العوامل المحتملة بدءًا من أصغر عدد أولي (2)\n    وتتحقق مما إذا كانت عاملاً لـ 'n'. إذا تم العثور على عامل، تقوم الدالة بإرجاع\n    قسمة 'n' على هذا العامل، والذي هو العامل الأولي الأكبر. إذا لم يتم العثور على عوامل\n    حتى الجذر التربيعي لـ 'n'، فإن 'n' نفسه هو عدد أولي ويتم\n    إرجاعه كأكبر عامل أولي.\n    \n    يعيدالحجج:\n    n (int): العدد الصحيح الموجب الذي سيتم تحليله، وهو حاصل ضرب عددين أوليين مميزين.\n    \n    يعيد:\n    int: الأكبر من بين العاملين الأوليين لـ 'n'.\n    \n    امثله:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n```", "sw": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Pata kigezo kikubwa zaidi cha namba ya kwanza ya namba nzima chanya iliyotolewa.\n    \n    Namba hiyo inadhaniwa kuwa ni zao la namba mbili za kwanza tofauti kabisa. \n    Kazi hii inazunguka kupitia viambajengo vinavyowezekana kuanzia na kigezo kidogo zaidi (2) \n    na inakagua kama ni kigezo cha 'n'. Ikiwa kigezo kinapatikana, kazi inarejesha \n    mgawanyo wa 'n' kwa kigezo hiki, ambacho ni kigezo kikubwa zaidi cha namba ya kwanza. Ikiwa hakuna viambajengo \n    vinavyopatikana hadi mzizi wa mraba wa 'n', basi 'n' yenyewe ni namba ya kwanza na inarejeshwa \n    kama kigezo kikubwa zaidi cha namba ya kwanza.\n    \n    Hoja:\n    n (int): Namba nzima chanya ya kufanyia ufafanuzi, ambayo ni zao la namba mbili za kwanza tofauti.\n    \n    Inarejesha:\n    int: Kigezo kikubwa zaidi kati ya viambajengo viwili vya kwanza vya 'n'.\n    \n    Mifano:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "tr": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Verilen pozitif bir tam sayının en büyük asal çarpanını bulun.\n    \n    Tam sayının, tam olarak iki farklı asal sayının çarpımı olduğu varsayılır.\n    Fonksiyon, en küçük asal sayıdan (2) başlayarak potansiyel çarpanlar \n    arasında iterasyon yapar ve bunların 'n' sayısının bir çarpanı olup olmadığını \n    kontrol eder. Bir çarpan bulunursa, fonksiyon bu çarpan ile 'n' sayısının \n    bölünmesini döndürür, bu da daha büyük asal çarpandır. 'n' sayısının kareköküne \n    kadar hiçbir çarpan bulunamazsa, 'n' sayısının kendisi asal bir sayıdır ve \n    en büyük asal çarpan olarak döndürülür.\n    \n    Argümanlar:\n    n (int): İki farklı asalın çarpımı olan pozitif tam sayı.\n    \n    Döndürür:\n    int: 'n' sayısının iki asal çarpanından daha büyüğü.\n    \n    Örnekler:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "vi": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Tìm ước số nguyên tố lớn nhất của một số nguyên dương cho trước.\n    \n    Số nguyên được giả định là tích của chính xác hai số nguyên tố khác nhau. \n    Hàm sẽ lặp qua các ước số tiềm năng bắt đầu từ số nguyên tố nhỏ nhất (2) \n    và kiểm tra xem chúng có phải là ước số của 'n' hay không. Nếu tìm thấy một ước số, \n    hàm sẽ trả về kết quả chia của 'n' cho ước số này, đó là ước số nguyên tố lớn hơn. \n    Nếu không tìm thấy ước số nào đến căn bậc hai của 'n', thì 'n' tự nó là một số nguyên tố \n    và được trả về như là ước số nguyên tố lớn nhất.\n    \n    Tham số:\n    n (int): Số nguyên dương cần phân tích, là tích của hai số nguyên tố khác nhau.\n    \n    Trả về:\n    int: Số nguyên tố lớn hơn trong hai ước số nguyên tố của 'n'.\n    \n    Ví dụ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "id": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Temukan faktor prima terbesar dari bilangan bulat positif yang diberikan.\n    \n    Bilangan bulat diasumsikan sebagai hasil kali dari tepat dua bilangan prima yang berbeda. \n    Fungsi ini mengiterasi melalui faktor potensial mulai dari bilangan prima terkecil (2) \n    dan memeriksa apakah mereka adalah faktor dari 'n'. Jika sebuah faktor ditemukan, fungsi \n    mengembalikan hasil pembagian 'n' dengan faktor ini, yang merupakan faktor prima yang lebih besar. \n    Jika tidak ada faktor yang ditemukan hingga akar kuadrat dari 'n', maka 'n' itu sendiri adalah \n    bilangan prima dan dikembalikan sebagai faktor prima terbesar.\n    \n    Args:\n    n (int): Bilangan bulat positif untuk difaktorkan, yang merupakan hasil kali dari dua bilangan prima yang berbeda.\n    \n    Returns:\n    int: Yang lebih besar dari dua faktor prima dari 'n'.\n    \n    Contoh:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "ja": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    与えられた正の整数の最大の素因数を見つけます。\n    \n    整数は正確に2つの異なる素数の積であると仮定されます。\n    関数は最小の素数（2）から始めて、潜在的な因数を反復し、\n    それらが 'n' の因数であるかどうかを確認します。因数が見つかった場合、\n    関数は 'n' をこの因数で割った値を返します。これはより大きな素因数です。\n    'n' の平方根まで因数が見つからない場合、'n' 自体が素数であり、\n    最大の素因数として返されます。\n    \n    引数:\n    n (int): 2つの異なる素数の積である、因数分解する正の整数。\n    \n    戻り値:\n    int: 'n' の2つの素因数のうちの大きい方。\n    \n    例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "ko": "python\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    주어진 양의 정수의 가장 큰 소인수를 찾습니다.\n    \n    정수는 정확히 두 개의 서로 다른 소수의 곱이라고 가정합니다. \n    함수는 가장 작은 소수(2)부터 시작하여 잠재적인 인수를 반복적으로 확인하고 \n    그것이 'n'의 인수인지 확인합니다. 인수가 발견되면, 함수는 'n'을 이 인수로 나눈 값을 반환하며, \n    이는 더 큰 소인수입니다. 'n'의 제곱근까지 인수가 발견되지 않으면, 'n' 자체가 소수이며 \n    가장 큰 소인수로 반환됩니다.\n    \n    매개변수:\n    n (int): 두 개의 서로 다른 소수의 곱인 양의 정수.\n    \n    반환값:\n    int: 'n'의 두 소인수 중 더 큰 값.\n    \n    예제:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n", "ml": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    നൽകിയ പോസിറ്റീവ് പൂർണ്ണസംഖ്യയുടെ ഏറ്റവും വലിയ പ്രധാന ഘടകം കണ്ടെത്തുക.\n    \n    ഈ പൂർണ്ണസംഖ്യ രണ്ട് വ്യത്യസ്തമായ പ്രധാന സംഖ്യകളുടെ ഗുണഫലമാണെന്ന് കരുതുന്നു. \n    ഫംഗ്ഷൻ ഏറ്റവും ചെറിയ പ്രധാന സംഖ്യയായ 2 മുതൽ സാധ്യതയുള്ള ഘടകങ്ങൾ പരിശോധിക്കുന്നു \n    കൂടാതെ അവ 'n' ന്റെ ഘടകമാണോ എന്ന് പരിശോധിക്കുന്നു. ഒരു ഘടകം കണ്ടെത്തിയാൽ, \n    ഫംഗ്ഷൻ 'n' നെ ഈ ഘടകത്തോടെ വിഭജിക്കുന്നതിനെ തിരിച്ചുനൽകുന്നു, \n    ഇത് വലിയ പ്രധാന ഘടകമാണ്. 'n' ന്റെ ചതുരമൂല്യത്തിലേക്ക് വരെ \n    ഘടകങ്ങൾ കണ്ടെത്തിയില്ലെങ്കിൽ, 'n' തന്നെ ഒരു പ്രധാന സംഖ്യയാണ് \n    കൂടാതെ ഏറ്റവും വലിയ പ്രധാന ഘടകമായി തിരിച്ചുനൽകുന്നു.\n    \n    Args:\n    n (int): രണ്ട് വ്യത്യസ്ത പ്രധാന സംഖ്യകളുടെ ഗുണഫലമായ ഘടകീകരിക്കേണ്ട \n    പോസിറ്റീവ് പൂർണ്ണസംഖ്യ.\n    \n    Returns:\n    int: 'n' ന്റെ രണ്ട് പ്രധാന ഘടകങ്ങളിൽ ഏറ്റവും വലിയത്.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ", "fa": "python\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    بزرگترین عامل اول یک عدد صحیح مثبت داده شده را پیدا کنید.\n    \n    فرض بر این است که عدد صحیح حاصل ضرب دقیقاً دو عدد اول متمایز است.\n    تابع از کوچکترین عدد اول (2) شروع به پیمایش عوامل بالقوه می‌کند \n    و بررسی می‌کند که آیا آن‌ها عامل 'n' هستند یا خیر. اگر عاملی پیدا شود، \n    تابع تقسیم 'n' بر این عامل را برمی‌گرداند، که عامل اول بزرگتر است. \n    اگر هیچ عاملی تا ریشه دوم 'n' پیدا نشود، در این صورت 'n' خود یک عدد اول است \n    و به عنوان بزرگترین عامل اول برگردانده می‌شود.\n    \n    آرگومان‌ها:\n    n (int): عدد صحیح مثبتی که باید تجزیه شود، که حاصل ضرب دو عدد اول متمایز است.\n    \n    بازگشت:\n    int: بزرگتر از دو عامل اول 'n'.\n    \n    مثال‌ها:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n"}, "canonical_solution": "    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor", "instruction": {"en": "Write a python function 'def largest_prime_factor(n: int) -> int:' to solve the following problem:\n\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ", "sq": "Shkruani një funksion python 'def largest_prime_factor(n: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Gjeni faktorin më të madh prim të një numri të plotë pozitiv të dhënë.\n    \n    Numri i plotë supozohet të jetë prodhimi i saktësisht dy numrave të ndryshëm prim.\n    Funksioni iteron nëpër faktorët e mundshëm duke filluar nga primi më i vogël (2)\n    dhe kontrollon nëse ata janë faktorë të 'n'. Nëse gjendet një faktor, funksioni kthen\n    pjesëtimin e 'n' me këtë faktor, i cili është faktori më i madh prim. Nëse nuk gjenden\n    faktorë deri në rrënjën katrore të 'n', atëherë 'n' vetë është një numër prim dhe\n    kthehet si faktori më i madh prim.\n    \n    Args:\n    n (int): Numri i plotë pozitiv për të faktorizuar, i cili është prodhimi i dy primeve të ndryshëm.\n    \n    Returns:\n    int: Më i madhi nga dy faktorët prim të 'n'.\n    \n    Shembuj:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "hy": "Պայթոն ֆունկցիա 'def largest_prime_factor(n: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Գտնել տրված դրական ամբողջ թվի ամենամեծ պարզ գործակիցը։\n    \n    Ամբողջ թիվը համարվում է ճիշտ երկու տարբեր պարզ թվերի արտադրյալ։ \n    Ֆունկցիան անցնում է հնարավոր գործակիցներով՝ սկսելով ամենափոքր պարզ թվից (2) \n    և ստուգում է՝ արդյոք դրանք 'n'-ի գործակից են։ Եթե գործակից է գտնվում, ֆունկցիան վերադարձնում է \n    'n'-ի բաժանումը այդ գործակցով, որը ամենամեծ պարզ գործակիցն է։ Եթե 'n'-ի \n    քառակուսի արմատի չափով գործակիցներ չեն գտնվում, ապա 'n'-ն ինքնին պարզ թիվ է և \n    վերադարձվում է որպես ամենամեծ պարզ գործակից։\n    \n    Արգումենտներ:\n    n (int): Դրական ամբողջ թիվը, որը պետք է գործակիցել, որը երկու տարբեր պարզ թվերի արտադրյալ է։\n    \n    Վերադարձնում է:\n    int: 'n'-ի երկու պարզ գործակիցներից մեծը։\n    \n    Օրինակներ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "bn": "একটি পাইথন ফাংশন 'def largest_prime_factor(n: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত ধনাত্মক পূর্ণসংখ্যার সবচেয়ে বড় মৌলিক গুণনীয়ক খুঁজুন।\n    \n    পূর্ণসংখ্যাটি ঠিক দুটি পৃথক মৌলিক সংখ্যার গুণফল হিসাবে ধরা হয়।\n    ফাংশন সম্ভাব্য গুণনীয়কগুলির মধ্য দিয়ে সবচেয়ে ছোট মৌলিক সংখ্যা (2) থেকে শুরু করে পুনরাবৃত্তি করে \n    এবং পরীক্ষা করে যে তারা 'n' এর গুণনীয়ক কিনা। যদি একটি গুণনীয়ক পাওয়া যায়, তাহলে ফাংশন \n    'n' কে এই গুণনীয়ক দ্বারা ভাগ করে, যা বড় মৌলিক গুণনীয়ক হয়, তা ফেরত দেয়। যদি 'n' এর \n    বর্গমূল পর্যন্ত কোনো গুণনীয়ক পাওয়া না যায়, তাহলে 'n' নিজেই একটি মৌলিক সংখ্যা এবং \n    সবচেয়ে বড় মৌলিক গুণনীয়ক হিসাবে ফেরত দেওয়া হয়।\n    \n    Args:\n    n (int): ধনাত্মক পূর্ণসংখ্যা যা গুণনীয়ক করতে হবে, যা দুটি পৃথক মৌলিক সংখ্যার গুণফল।\n    \n    Returns:\n    int: 'n' এর দুটি মৌলিক গুণনীয়কের মধ্যে বড়টি।\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "bg": "Напишете Python функция 'def largest_prime_factor(n: int) -> int:', за да решите следния проблем:\n\n    Намерете най-големия прост делител на дадено положително цяло число.\n    \n    Предполага се, че числото е произведение на точно две различни прости числа.\n    Функцията преминава през потенциални делители, започвайки от най-малкото просто число (2),\n    и проверява дали те са делител на 'n'. Ако се намери делител, функцията връща\n    делението на 'n' с този делител, което е по-големият прост делител. Ако не се намерят делители\n    до квадратния корен на 'n', тогава 'n' самото е просто число и се връща като най-големия прост делител.\n    \n    Аргументи:\n    n (int): Положителното цяло число за факторизиране, което е произведение на две различни прости числа.\n    \n    Връща:\n    int: По-големият от двата прости делителя на 'n'.\n    \n    Примери:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "zh": "编写一个 Python 函数 'def largest_prime_factor(n: int) -> int:' 来解决以下问题：\n\n    找到给定正整数的最大素因数。\n    \n    假设该整数是恰好两个不同素数的乘积。\n    函数从最小的素数（2）开始迭代潜在因数，并检查它们是否是 'n' 的因数。\n    如果找到一个因数，函数返回 'n' 除以该因数的结果，即较大的素因数。\n    如果在 'n' 的平方根之前没有找到因数，那么 'n' 本身就是一个素数，并作为最大的素因数返回。\n    \n    参数:\n    n (int): 要分解的正整数，是两个不同素数的乘积。\n    \n    返回:\n    int: 'n' 的两个素因数中较大的一个。\n    \n    示例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "fr": "Écrivez une fonction python 'def largest_prime_factor(n: int) -> int:' pour résoudre le problème suivant :\n\n    Trouvez le plus grand facteur premier d'un entier positif donné.\n    \n    L'entier est supposé être le produit de exactement deux nombres premiers distincts.\n    La fonction parcourt les facteurs potentiels en commençant par le plus petit nombre premier (2)\n    et vérifie s'ils sont un facteur de 'n'. Si un facteur est trouvé, la fonction retourne\n    la division de 'n' par ce facteur, qui est le plus grand facteur premier. Si aucun facteur\n    n'est trouvé jusqu'à la racine carrée de 'n', alors 'n' lui-même est un nombre premier et est\n    retourné comme le plus grand facteur premier.\n    \n    Args:\n    n (int): L'entier positif à factoriser, qui est le produit de deux nombres premiers distincts.\n    \n    Returns:\n    int: Le plus grand des deux facteurs premiers de 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "de": "Schreiben Sie eine Python-Funktion 'def largest_prime_factor(n: int) -> int:', um das folgende Problem zu lösen:\n\n    Finden Sie den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n    \n    Es wird angenommen, dass die ganze Zahl das Produkt von genau zwei verschiedenen Primzahlen ist.\n    Die Funktion iteriert durch potenzielle Faktoren, beginnend mit dem kleinsten Prim (2),\n    und überprüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion\n    die Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis zur\n    Quadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl und wird\n    als der größte Primfaktor zurückgegeben.\n    \n    Argumente:\n    n (int): Die positive ganze Zahl, die faktorisiert werden soll, welche das Produkt von zwei verschiedenen Primzahlen ist.\n    \n    Rückgabewert:\n    int: Der größere der beiden Primfaktoren von 'n'.\n    \n    Beispiele:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "ha": "Rubuta wani aikin python 'def largest_prime_factor(n: int) -> int:' don warware matsalar mai zuwa:\n\n    Nemo mafi girman abin da ba a iya raba shi ba na wani adadi mai kyau da aka bayar.\n    \n    Ana ɗaukar cewa adadin yana daidai da samfurin lambobi biyu masu rarrabe waɗanda ba a iya raba su ba.\n    Aikin yana juyawa ta hanyar abubuwan da za a iya samu farawa daga mafi ƙarancin abin da ba a iya raba shi ba (2)\n    kuma yana duba idan suna cikin abubuwan da suka hada da 'n'. Idan an sami wani abu, aikin yana mayar da\n    rabon 'n' da wannan abu, wanda shine mafi girman abin da ba a iya raba shi ba. Idan ba a sami wani abu ba har zuwa\n    tushen murabba'in 'n', to 'n' kanta lamba ce da ba a iya raba ta ba kuma ana mayar da ita a matsayin\n    mafi girman abin da ba a iya raba shi ba.\n    \n    Args:\n    n (int): Adadi mai kyau da za a raba, wanda shine samfurin lambobi biyu masu rarrabe waɗanda ba a iya raba su ba.\n    \n    Returns:\n    int: Mafi girman daga cikin abubuwan da ba a iya raba su ba guda biyu na 'n'.\n    \n    Misalai:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "hi": "एक पायथन फ़ंक्शन 'def largest_prime_factor(n: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n    \n    यह पूर्णांक ठीक दो भिन्न अभाज्य संख्याओं का गुणनफल माना जाता है।\n    फ़ंक्शन संभावित गुणनखंडों के माध्यम से सबसे छोटे अभाज्य (2) से शुरू करते हुए पुनरावृत्ति करता है \n    और जांचता है कि क्या वे 'n' के गुणनखंड हैं। यदि कोई गुणनखंड मिलता है, तो फ़ंक्शन \n    'n' को इस गुणनखंड से विभाजित करके लौटाता है, जो बड़ा अभाज्य गुणनखंड होता है। यदि 'n' \n    के वर्गमूल तक कोई गुणनखंड नहीं मिलता है, तो 'n' स्वयं एक अभाज्य संख्या है और इसे \n    सबसे बड़े अभाज्य गुणनखंड के रूप में लौटाया जाता है।\n    \n    तर्क:\n    n (int): वह धनात्मक पूर्णांक जिसे गुणनखंडित करना है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\n    \n    लौटाता है:\n    int: 'n' के दो अभाज्य गुणनखंडों में से बड़ा एक।\n    \n    उदाहरण:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "hu": "Írjon egy python függvényt 'def largest_prime_factor(n: int) -> int:' a következő probléma megoldására:\n\n    Keresse meg a megadott pozitív egész szám legnagyobb prímtényezőjét.\n    \n    Az egész számot pontosan két különböző prímszám szorzataként feltételezzük. \n    A függvény a lehetséges tényezőkön iterál a legkisebb prímtől (2) kezdve, \n    és ellenőrzi, hogy ezek a tényezők-e 'n'-nek. Ha talál tényezőt, a függvény \n    visszaadja 'n' osztását ezzel a tényezővel, amely a nagyobb prímtényező. \n    Ha nem található tényező 'n' négyzetgyökéig, akkor 'n' maga is prímszám, és \n    visszatér a legnagyobb prímtényezőként.\n    \n    Args:\n    n (int): A pozitív egész szám, amelyet tényezőkre kell bontani, és amely két különböző prímszám szorzata.\n    \n    Returns:\n    int: 'n' két prímtényezője közül a nagyobb.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "es": "Escribe una función de Python 'def largest_prime_factor(n: int) -> int:' para resolver el siguiente problema:\n\n    Encuentra el mayor factor primo de un entero positivo dado.\n    \n    Se asume que el entero es el producto de exactamente dos números primos distintos.\n    La función itera a través de posibles factores comenzando desde el primo más pequeño (2)\n    y verifica si son un factor de 'n'. Si se encuentra un factor, la función devuelve\n    la división de 'n' por este factor, que es el mayor factor primo. Si no se encuentran factores\n    hasta la raíz cuadrada de 'n', entonces 'n' en sí mismo es un número primo y se\n    devuelve como el mayor factor primo.\n    \n    Argumentos:\n    n (int): El entero positivo a factorizar, que es el producto de dos primos distintos.\n    \n    Devuelve:\n    int: El mayor de los dos factores primos de 'n'.\n    \n    Ejemplos:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "arb": "اكتب دالة بايثون 'def largest_prime_factor(n: int) -> int:' لحل المشكلة التالية:\n\n    إيجاد أكبر عامل أولي لعدد صحيح موجب معين.\n    \n    يُفترض أن العدد الصحيح هو ناتج ضرب عددين أوليين مميزين بالضبط.\n    تقوم الدالة بالتكرار عبر العوامل المحتملة بدءًا من أصغر عدد أولي (2)\n    وتتحقق مما إذا كانت عاملًا لـ 'n'. إذا تم العثور على عامل، تقوم الدالة بإرجاع\n    قسمة 'n' على هذا العامل، وهو العامل الأولي الأكبر. إذا لم يتم العثور على عوامل\n    حتى الجذر التربيعي لـ 'n'، فإن 'n' نفسه هو عدد أولي ويتم إرجاعه كأكبر عامل أولي.\n    \n    يعيدالحجج:\n    n (int): العدد الصحيح الموجب لتفكيكه، وهو ناتج ضرب عددين أوليين مميزين.\n    \n    يعيد:\n    int: الأكبر بين العاملين الأوليين لـ 'n'.\n    \n    أمثلة:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "sw": "Andika kazi ya python 'def largest_prime_factor(n: int) -> int:' kutatua tatizo lifuatalo:\n\n    Tafuta kipengele kikubwa zaidi cha nambari ya kwanza ya nambari chanya iliyotolewa.\n    \n    Nambari inadhaniwa kuwa ni zao la nambari mbili tofauti za kwanza. \n    Kazi hii inarudia kupitia vipengele vinavyowezekana kuanzia na nambari ya kwanza ndogo zaidi (2) \n    na inakagua kama ni kipengele cha 'n'. Ikiwa kipengele kinapatikana, kazi inarejesha \n    mgawanyiko wa 'n' kwa kipengele hiki, ambacho ni kipengele kikubwa zaidi cha kwanza. Ikiwa hakuna vipengele \n    vinavyopatikana hadi mzizi wa mraba wa 'n', basi 'n' yenyewe ni nambari ya kwanza na inarejeshwa \n    kama kipengele kikubwa zaidi cha kwanza.\n    \n    Hoja:\n    n (int): Nambari chanya ya kufanyia ufafanuzi, ambayo ni zao la nambari mbili tofauti za kwanza.\n    \n    Inarejesha:\n    int: Kati ya vipengele viwili vya kwanza vya 'n', kikubwa zaidi.\n    \n    Mifano:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "tr": "Bir python fonksiyonu 'def largest_prime_factor(n: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen bir pozitif tam sayının en büyük asal çarpanını bulun.\n    \n    Tam sayının tam olarak iki farklı asal sayının çarpımı olduğu varsayılır. \n    Fonksiyon, en küçük asal sayıdan (2) başlayarak potansiyel çarpanları iteratif \n    olarak kontrol eder ve bunların 'n' sayısının çarpanı olup olmadığını kontrol eder. \n    Eğer bir çarpan bulunursa, fonksiyon bu çarpan ile 'n' sayısının bölünmesini döndürür, \n    bu da daha büyük asal çarpandır. Eğer 'n' sayısının kareköküne kadar hiçbir çarpan \n    bulunamazsa, o zaman 'n' sayısının kendisi asal sayıdır ve en büyük asal çarpan olarak \n    döndürülür.\n    \n    Argümanlar:\n    n (int): İki farklı asalın çarpımı olan, çarpanlarına ayrılacak pozitif tam sayı.\n    \n    Döndürür:\n    int: 'n' sayısının iki asal çarpanından daha büyüğü.\n    \n    Örnekler:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ", "vi": "Viết một hàm python 'def largest_prime_factor(n: int) -> int:' để giải quyết vấn đề sau:\n\n    Tìm ước số nguyên tố lớn nhất của một số nguyên dương cho trước.\n    \n    Số nguyên được giả định là tích của chính xác hai số nguyên tố khác nhau.\n    Hàm lặp qua các ước số tiềm năng bắt đầu từ số nguyên tố nhỏ nhất (2)\n    và kiểm tra nếu chúng là một ước của 'n'. Nếu tìm thấy một ước, hàm trả về\n    phép chia của 'n' cho ước này, đó là ước số nguyên tố lớn hơn. Nếu không tìm thấy\n    ước nào cho đến căn bậc hai của 'n', thì 'n' tự nó là một số nguyên tố và được\n    trả về như là ước số nguyên tố lớn nhất.\n    \n    Tham số:\n    n (int): Số nguyên dương cần phân tích, là tích của hai số nguyên tố khác nhau.\n    \n    Trả về:\n    int: Số nguyên tố lớn hơn trong hai ước số nguyên tố của 'n'.\n    \n    Ví dụ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "id": "Tulis sebuah fungsi python 'def largest_prime_factor(n: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Temukan faktor prima terbesar dari bilangan bulat positif yang diberikan.\n    \n    Bilangan bulat diasumsikan sebagai hasil kali dari tepat dua bilangan prima yang berbeda.\n    Fungsi ini mengiterasi melalui faktor potensial mulai dari bilangan prima terkecil (2)\n    dan memeriksa apakah mereka adalah faktor dari 'n'. Jika sebuah faktor ditemukan, fungsi\n    mengembalikan hasil pembagian 'n' dengan faktor ini, yang merupakan faktor prima yang lebih besar.\n    Jika tidak ada faktor yang ditemukan hingga akar kuadrat dari 'n', maka 'n' sendiri adalah bilangan prima\n    dan dikembalikan sebagai faktor prima terbesar.\n    \n    Args:\n    n (int): Bilangan bulat positif untuk difaktorkan, yang merupakan hasil kali dari dua bilangan prima yang berbeda.\n    \n    Returns:\n    int: Yang lebih besar dari dua faktor prima dari 'n'.\n    \n    Contoh:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "ja": "以下の問題を解決するために、Python関数 'def largest_prime_factor(n: int) -> int:' を作成してください:\n\n    与えられた正の整数の最大の素因数を見つけます。\n    \n    整数は、正確に2つの異なる素数の積であると仮定します。\n    関数は、最小の素数（2）から始めて、潜在的な因数を順に調べ、\n    それらが 'n' の因数であるかどうかを確認します。因数が見つかった場合、\n    関数はこの因数で 'n' を割った結果を返します。これはより大きな素因数です。\n    もし 'n' の平方根まで因数が見つからない場合、'n' 自体が素数であり、\n    最大の素因数として返されます。\n    \n    引数:\n    n (int): 2つの異なる素数の積である正の整数。\n    \n    戻り値:\n    int: 'n' の2つの素因数のうちの大きい方。\n    \n    例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "ko": "다음 문제를 해결하기 위해 'def largest_prime_factor(n: int) -> int:'라는 파이썬 함수를 작성하십시오:\n\n    주어진 양의 정수의 가장 큰 소인수를 찾으십시오.\n    \n    정수는 정확히 두 개의 서로 다른 소수의 곱이라고 가정합니다. \n    함수는 가장 작은 소수(2)부터 시작하여 잠재적인 인수를 반복하고 \n    그것이 'n'의 인수인지 확인합니다. 인수가 발견되면 함수는 \n    이 인수로 'n'을 나눈 값을 반환하며, 이는 더 큰 소인수입니다. \n    'n'의 제곱근까지 인수가 발견되지 않으면 'n' 자체가 소수이며 \n    가장 큰 소인수로 반환됩니다.\n    \n    인수:\n    n (int): 두 개의 서로 다른 소수의 곱인 양의 정수.\n    \n    반환:\n    int: 'n'의 두 소인수 중 더 큰 값.\n    \n    예시:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "ml": "ഒരു പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക 'def largest_prime_factor(n: int) -> int:' താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    നൽകിയിട്ടുള്ള പോസിറ്റീവ് പൂർണ്ണസംഖ്യയുടെ ഏറ്റവും വലിയ പ്രധാന ഘടകം കണ്ടെത്തുക.\n    \n    ഈ സംഖ്യ രണ്ട് വ്യത്യസ്ത പ്രധാന സംഖ്യകളുടെ ഗുണഫലമാണെന്ന് കരുതുന്നു.\n    ഫംഗ്ഷൻ ഏറ്റവും ചെറിയ പ്രധാന സംഖ്യ (2) മുതൽ സാധ്യതയുള്ള ഘടകങ്ങൾ പരിശോധിച്ച് \n    അവ 'n' ന്റെ ഘടകമാണോ എന്ന് പരിശോധിക്കുന്നു. ഒരു ഘടകം കണ്ടെത്തിയാൽ, \n    ഫംഗ്ഷൻ 'n' നെ ഈ ഘടകത്തോടെ വിഭജിച്ച്, \n    അത് ഏറ്റവും വലിയ പ്രധാന ഘടകമായിരിക്കും. \n    'n' ന്റെ ചതുരവരം വരെ ഘടകങ്ങൾ കണ്ടെത്താനായില്ലെങ്കിൽ, \n    'n' തന്നെ ഒരു പ്രധാന സംഖ്യയാണ് \n    അതിനാൽ അത് ഏറ്റവും വലിയ പ്രധാന ഘടകമായി തിരിച്ചറിയുന്നു.\n    \n    Args:\n    n (int): രണ്ട് വ്യത്യസ്ത പ്രധാന സംഖ്യകളുടെ ഗുണഫലമായ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ.\n    \n    Returns:\n    int: 'n' ന്റെ രണ്ട് പ്രധാന ഘടകങ്ങളിൽ ഏറ്റവും വലിയത്.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "fa": "یک تابع پایتون 'def largest_prime_factor(n: int) -> int:' بنویسید تا مسئله زیر را حل کند:\n\n    بزرگترین عامل اول یک عدد صحیح مثبت داده شده را پیدا کنید.\n    \n    فرض بر این است که عدد صحیح حاصل‌ضرب دقیقاً دو عدد اول متمایز است.\n    تابع از کوچکترین عدد اول (2) شروع به پیمایش عوامل بالقوه می‌کند\n    و بررسی می‌کند که آیا آن‌ها یک عامل از 'n' هستند یا خیر. اگر عاملی پیدا شود، تابع\n    تقسیم 'n' بر این عامل را برمی‌گرداند که عامل اول بزرگتر است. اگر هیچ عاملی\n    تا جذر 'n' پیدا نشود، در این صورت 'n' خود یک عدد اول است و\n    به عنوان بزرگترین عامل اول برگردانده می‌شود.\n    \n    آرگومان‌ها:\n    n (int): عدد صحیح مثبتی که باید فاکتورگیری شود و حاصل‌ضرب دو عدد اول متمایز است.\n    \n    بازگشتی:\n    int: بزرگترین عامل اول از دو عامل اول 'n'.\n    \n    مثال‌ها:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5"}, "level": "easy", "test": "def test_largest_prime_factor():\n    test_cases = [\n        # Test case 1: composite number\n        {\n            'n': 35,  # 5 * 7\n            'expected': 7\n        },\n        # Test case 2: prime number itself\n        {\n            'n': 29,\n            'expected': 29\n        },\n        # Test case 3: composite number with a square of a prime\n        {\n            'n': 49,  # 7 * 7\n            'expected': 7\n        },\n        # Test case 4: large composite number\n        {\n            'n': 2 * 2 * 3 * 3 * 7 * 11,  # prime factors are 2, 3, 7, 11\n            'expected': 11\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = largest_prime_factor(test['n'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_largest_prime_factor()", "entry_point": "largest_prime_factor", "signature": "def largest_prime_factor(n: int) -> int:", "docstring": {"en": "\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ", "sq": "\n    Gjeni faktorin më të madh prim të një numri të dhënë të plotë pozitiv.\n    \n    Supozohet që numri i plotë është produkt i saktësisht dy numrave të ndryshëm prim.\n    Funksioni iteron nëpër faktorët e mundshëm duke filluar nga primi më i vogël (2)\n    dhe kontrollon nëse ata janë faktorë të 'n'. Nëse gjendet një faktor, funksioni kthen\n    pjesëtimin e 'n' me këtë faktor, i cili është faktori më i madh prim. Nëse nuk gjenden faktorë\n    deri në rrënjën katrore të 'n', atëherë 'n' vetë është një numër prim dhe kthehet si faktori më i madh prim.\n    \n    Args:\n    n (int): Numri i plotë pozitiv për të faktorizuar, i cili është produkt i dy primeve të ndryshëm.\n    \n    Returns:\n    int: Më i madhi nga dy faktorët prim të 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "hy": "\n    Գտնել տրված դրական ամբողջ թվի ամենամեծ պարզ գործոնը։\n    \n    Ենթադրվում է, որ ամբողջ թիվը հենց երկու տարբեր պարզ թվերի արտադրյալն է։\n    Ֆունկցիան սկսում է ամենափոքր պարզ թվից (2) և ստուգում է, արդյոք դրանք 'n'-ի գործոն են։\n    Եթե գործոն է գտնվել, ֆունկցիան վերադարձնում է 'n'-ի բաժանումը այդ գործոնով, որը ամենամեծ պարզ գործոնն է։\n    Եթե 'n'-ի քառակուսի արմատի սահմաններում գործոններ չեն գտնվել, ապա 'n'-ն ինքնին պարզ թիվ է և վերադարձվում է որպես ամենամեծ պարզ գործոն։\n    \n    Պարամետրեր:\n    n (int): Դրական ամբողջ թիվը, որը պետք է բաժանել, որը երկու տարբեր պարզ թվերի արտադրյալն է։\n    \n    Վերադարձնում է:\n    int: 'n'-ի երկու պարզ գործոններից ամենամեծը։\n    \n    Օրինակներ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "bn": "\n    প্রদত্ত একটি ধনাত্মক পূর্ণসংখ্যার বৃহত্তম মৌলিক গুণনীয়ক খুঁজুন।\n    \n    পূর্ণসংখ্যাটি ঠিক দুটি ভিন্ন মৌলিক সংখ্যার গুণফল বলে ধরা হয়।\n    ফাংশনটি সম্ভাব্য গুণনীয়কগুলির মধ্য দিয়ে ক্ষুদ্রতম মৌলিক সংখ্যা (2) থেকে শুরু করে পুনরাবৃত্তি করে এবং তারা 'n' এর গুণনীয়ক কিনা তা পরীক্ষা করে।\n    যদি একটি গুণনীয়ক পাওয়া যায়, ফাংশনটি এই গুণনীয়ক দ্বারা 'n' এর ভাগফল প্রদান করে, যা বৃহত্তম মৌলিক গুণনীয়ক।\n    যদি 'n' এর বর্গমূল পর্যন্ত কোনো গুণনীয়ক পাওয়া না যায়, তাহলে 'n' নিজেই একটি মৌলিক সংখ্যা এবং বৃহত্তম মৌলিক গুণনীয়ক হিসাবে ফেরত দেওয়া হয়।\n    \n    Args:\n    n (int): গুণনীয়ক করতে হবে এমন ধনাত্মক পূর্ণসংখ্যা, যা দুটি ভিন্ন মৌলিক সংখ্যার গুণফল।\n    \n    Returns:\n    int: 'n' এর দুটি মৌলিক গুণনীয়কের মধ্যে বৃহত্তম।\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "bg": "\n    Намерете най-големия прост делител на дадено положително цяло число.\n    \n    Предполага се, че цялото число е произведение на точно два различни прости числа.\n    Функцията обхожда потенциалните делители, започвайки от най-малкото просто число (2),\n    и проверява дали те са делители на 'n'. Ако се намери делител, функцията връща\n    резултата от делението на 'n' с този делител, което е по-големият прост делител.\n    Ако не се намерят делители до квадратния корен на 'n', тогава самото 'n' е просто число\n    и се връща като най-големия прост делител.\n    \n    Аргументи:\n    n (int): Положителното цяло число за факторизация, което е произведение на два различни прости числа.\n    \n    Връща:\n    int: По-големият от двата прости делителя на 'n'.\n    \n    Примери:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "zh": "\n    找出给定正整数的最大质因数。\n    \n    假设该整数是两个不同质数的乘积。\n    该函数从最小的质数(2)开始迭代可能的因数，并检查它们是否是 'n' 的因数。\n    如果找到一个因数，函数返回 'n' 除以该因数的结果，即较大的质因数。\n    如果在 'n' 的平方根范围内没有找到因数，那么 'n' 本身就是一个质数，并作为最大质因数返回。\n    \n    参数:\n    n (int): 要分解的正整数，它是两个不同质数的乘积。\n    \n    返回:\n    int: 'n' 的两个质因数中较大的一个。\n    \n    示例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "fr": "\n    Trouver le plus grand facteur premier d'un entier positif donné.\n    \n    L'entier est supposé être le produit de exactement deux nombres premiers distincts.\n    La fonction itère à travers les facteurs potentiels en commençant par le plus petit nombre premier (2)\n    et vérifie s'ils sont un facteur de 'n'. Si un facteur est trouvé, la fonction retourne\n    la division de 'n' par ce facteur, qui est le plus grand facteur premier. Si aucun facteur\n    n'est trouvé jusqu'à la racine carrée de 'n', alors 'n' lui-même est un nombre premier et est\n    retourné comme le plus grand facteur premier.\n    \n    Args:\n    n (int): L'entier positif à factoriser, qui est le produit de deux nombres premiers distincts.\n    \n    Returns:\n    int: Le plus grand des deux facteurs premiers de 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "de": "\n    Finde den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n    \n    Es wird angenommen, dass die ganze Zahl das Produkt von genau zwei verschiedenen Primzahlen ist.\n    Die Funktion iteriert durch potenzielle Faktoren, beginnend mit der kleinsten Primzahl (2),\n    und überprüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion\n    die Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis zur\n    Quadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl und wird\n    als größter Primfaktor zurückgegeben.\n    \n    Args:\n    n (int): Die positive ganze Zahl, die faktorisiert werden soll, welche das Produkt von zwei verschiedenen Primzahlen ist.\n    \n    Returns:\n    int: Der größere der beiden Primfaktoren von 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "ha": "\n    Nemo mafi girman lambar farko ta wani adadi mai kyau da aka bayar.\n    \n    Ana ɗaukar adadin a matsayin samfurin lambobi biyu na farko daban-daban.\n    Aiki yana zagayawa ta hanyar yiwuwar abubuwan da aka fara daga mafi ƙarancin lamba ta farko (2)\n    kuma yana duba ko su abubuwan 'n' ne. Idan an sami abu, aikin yana dawowa\n    rabon 'n' da wannan abu, wanda shine mafi girman lambar farko. Idan babu abubuwan da aka samu har zuwa tushen murabba'in 'n', to 'n' kanta lamba ta farko ce kuma ana\n    dawowa da ita a matsayin mafi girman lambar farko.\n    \n    Args:\n    n (int): Adadi mai kyau don rarrabawa, wanda shine samfurin lambobi biyu na farko daban-daban.\n    \n    Returns:\n    int: Mafi girman lambobi biyu na farko na 'n'.\n    \n    Misalai:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "hi": "\n    दिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n    \n    पूर्णांक को ठीक दो भिन्न अभाज्य संख्याओं के गुणनफल के रूप में माना जाता है।\n    यह फ़ंक्शन सबसे छोटे अभाज्य (2) से संभावित गुणनखंडों के माध्यम से पुनरावृत्ति करता है\n    और जांचता है कि क्या वे 'n' के गुणनखंड हैं। यदि कोई गुणनखंड पाया जाता है, तो फ़ंक्शन\n    'n' को इस गुणनखंड से विभाजित कर लौटाता है, जो बड़ा अभाज्य गुणनखंड होता है। यदि 'n'\n    के वर्गमूल तक कोई गुणनखंड नहीं मिलता है, तो 'n' स्वयं एक अभाज्य संख्या है और इसे\n    सबसे बड़े अभाज्य गुणनखंड के रूप में लौटाया जाता है।\n    \n    तर्क:\n    n (int): वह धनात्मक पूर्णांक जिसे गुणनखंडित करना है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\n    \n    लौटाता है:\n    int: 'n' के दो अभाज्य गुणनखंडों में से बड़ा।\n    \n    उदाहरण:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "hu": "\n    Keresse meg egy adott pozitív egész szám legnagyobb prímtényezőjét.\n    \n    Az egész szám feltételezhetően pontosan két különböző prímszám szorzata.\n    A függvény a legkisebb prímtől (2) kezdve iterál a lehetséges tényezőkön,\n    és ellenőrzi, hogy ezek a tényezők-e 'n'-nek. Ha talál tényezőt, a függvény\n    visszaadja 'n' osztását ezzel a tényezővel, ami a nagyobb prímtényező.\n    Ha 'n' négyzetgyökéig nem talál tényezőket, akkor 'n' maga is prímszám,\n    és mint a legnagyobb prímtényező kerül visszaadásra.\n    \n    Paraméterek:\n    n (int): A pozitív egész szám, amelyet faktorizálni kell, és amely két különböző prímszám szorzata.\n    \n    Visszatér:\n    int: 'n' két prímtényezője közül a nagyobbik.\n    \n    Példák:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "es": "    Encontrar el mayor factor primo de un entero positivo dado.\n    \n    Se asume que el entero es el producto de exactamente dos números primos distintos.\n    La función itera a través de posibles factores comenzando desde el menor primo (2)\n    y verifica si son un factor de 'n'. Si se encuentra un factor, la función devuelve\n    la división de 'n' por este factor, que es el mayor factor primo. Si no se encuentran\n    factores hasta la raíz cuadrada de 'n', entonces 'n' en sí mismo es un número primo\n    y se devuelve como el mayor factor primo.\n    \n    Argumentos:\n    n (int): El entero positivo a factorizar, que es el producto de dos primos distintos.\n    \n    Devuelve:\n    int: El mayor de los dos factores primos de 'n'.\n    \n    Ejemplos:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ", "arb": "    إيجاد أكبر عامل أولي لعدد صحيح موجب معين.\n    \n    يُفترض أن العدد الصحيح هو ناتج ضرب عددين أوليين مميزين بالضبط.\n    تقوم الدالة بالتكرار عبر العوامل المحتملة بدءًا من أصغر عدد أولي (2)\n    وتتحقق مما إذا كانت عاملاً لـ 'n'. إذا تم العثور على عامل، تُرجع الدالة\n    ناتج قسمة 'n' على هذا العامل، وهو العامل الأولي الأكبر. إذا لم يتم العثور\n    على عوامل حتى الجذر التربيعي لـ 'n'، فإن 'n' نفسه هو عدد أولي ويتم\n    إرجاعه كأكبر عامل أولي.\n    \n    يعيدالحجج:\n    n (int): العدد الصحيح الموجب لتحليله إلى عوامل، وهو ناتج ضرب عددين أوليين مميزين.\n    \n    يعيد:\n    int: الأكبر بين العاملين الأوليين لـ 'n'.\n    \n    امثله:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "sw": "    Pata kipengele kikubwa zaidi cha nambari ya kwanza ya nambari chanya iliyotolewa.\n    \n    Nambari inadhaniwa kuwa ni zao la nambari mbili tofauti za kwanza. \n    Kazi inazunguka kupitia vipengele vinavyowezekana kuanzia na nambari ya kwanza ndogo zaidi (2) \n    na inakagua ikiwa ni kipengele cha 'n'. Ikiwa kipengele kinapatikana, kazi inarudisha \n    mgawanyiko wa 'n' kwa kipengele hiki, ambacho ni kipengele kikubwa zaidi cha kwanza. Ikiwa hakuna vipengele \n    vinavyopatikana hadi mzizi wa mraba wa 'n', basi 'n' yenyewe ni nambari ya kwanza na inarudishwa \n    kama kipengele kikubwa zaidi cha kwanza.\n    \n    Hoja:\n    n (int): Nambari chanya ya kufanyia utafiti, ambayo ni zao la nambari mbili tofauti za kwanza.\n    \n    Inarudisha:\n    int: Kipengele kikubwa zaidi kati ya vipengele viwili vya kwanza vya 'n'.\n    \n    Mifano:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "tr": "    Verilen pozitif bir tamsayının en büyük asal çarpanını bulun.\n    \n    Tamsayının tam olarak iki farklı asal sayının çarpımı olduğu varsayılır. \n    Fonksiyon, en küçük asal sayıdan (2) başlayarak potansiyel çarpanlar arasında \n    iterasyon yapar ve bunların 'n' sayısının bir çarpanı olup olmadığını kontrol eder. \n    Eğer bir çarpan bulunursa, fonksiyon bu çarpanla 'n' sayısının bölünmesini döndürür, \n    bu da daha büyük asal çarpandır. Eğer 'n' sayısının kareköküne kadar hiçbir çarpan \n    bulunamazsa, o zaman 'n' kendisi bir asal sayıdır ve en büyük asal çarpan olarak \n    döndürülür.\n    \n    Argümanlar:\n    n (int): İki farklı asalın çarpımı olan pozitif tamsayı.\n    \n    Döndürür:\n    int: 'n' sayısının iki asal çarpanından daha büyüğü.\n    \n    Örnekler:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "vi": "    Tìm ước số nguyên tố lớn nhất của một số nguyên dương cho trước.\n    \n    Số nguyên được giả định là tích của chính xác hai số nguyên tố khác nhau. \n    Hàm này lặp qua các ước số tiềm năng bắt đầu từ số nguyên tố nhỏ nhất (2) \n    và kiểm tra xem chúng có phải là ước số của 'n' không. Nếu tìm thấy một ước số, \n    hàm trả về kết quả của 'n' chia cho ước số này, đó là ước số nguyên tố lớn hơn. \n    Nếu không tìm thấy ước số nào cho đến căn bậc hai của 'n', thì 'n' tự nó là một số nguyên tố \n    và được trả về như là ước số nguyên tố lớn nhất.\n    \n    Tham số:\n    n (int): Số nguyên dương cần phân tích, là tích của hai số nguyên tố khác nhau.\n    \n    Trả về:\n    int: Số lớn hơn trong hai ước số nguyên tố của 'n'.\n    \n    Ví dụ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "id": "Menemukan faktor prima terbesar dari bilangan bulat positif yang diberikan.\n\nBilangan bulat diasumsikan sebagai hasil kali dari tepat dua bilangan prima yang berbeda. Fungsi ini mengiterasi melalui faktor potensial mulai dari bilangan prima terkecil (2) dan memeriksa apakah mereka adalah faktor dari 'n'. Jika sebuah faktor ditemukan, fungsi mengembalikan hasil pembagian 'n' dengan faktor ini, yang merupakan faktor prima yang lebih besar. Jika tidak ada faktor yang ditemukan hingga akar kuadrat dari 'n', maka 'n' itu sendiri adalah bilangan prima dan dikembalikan sebagai faktor prima terbesar.\n\nArgs:\nn (int): Bilangan bulat positif untuk difaktorkan, yang merupakan hasil kali dari dua bilangan prima yang berbeda.\n\nReturns:\nint: Yang lebih besar dari dua faktor prima dari 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5", "ja": "    与えられた正の整数の最大の素因数を見つけます。\n    \n    整数は、正確に2つの異なる素数の積であると仮定されます。\n    関数は、最小の素数（2）から始めて潜在的な因数を反復し、\n    それらが 'n' の因数であるかどうかを確認します。因数が見つかった場合、\n    関数は 'n' をこの因数で割った結果を返します。これはより大きい素因数です。\n    'n' の平方根まで因数が見つからない場合、'n' 自体が素数であり、\n    最大の素因数として返されます。\n    \n    引数:\n    n (int): 2つの異なる素数の積である、因数分解する正の整数。\n    \n    戻り値:\n    int: 'n' の2つの素因数のうちの大きい方。\n    \n    例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "ko": "    주어진 양의 정수의 가장 큰 소인수를 찾습니다.\n    \n    정수는 정확히 두 개의 서로 다른 소수의 곱이라고 가정합니다.\n    함수는 가장 작은 소수(2)부터 시작하여 잠재적인 인수를 반복적으로 검사하고,\n    그것이 'n'의 인수인지 확인합니다. 인수가 발견되면, 함수는 이 인수로 'n'을 나눈 값을 반환하며,\n    이는 더 큰 소인수입니다. 만약 'n'의 제곱근까지 인수가 발견되지 않으면,\n    'n' 자체가 소수이며 가장 큰 소인수로 반환됩니다.\n    \n    인수:\n    n (int): 두 개의 서로 다른 소수의 곱인 양의 정수.\n    \n    반환:\n    int: 'n'의 두 소인수 중 더 큰 값.\n    \n    예제:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "ml": "    നൽകിയ പോസിറ്റീവ് പൂർണ്ണസംഖ്യയുടെ ഏറ്റവും വലിയ പ്രധാന ഘടകം കണ്ടെത്തുക.\n    \n    ഈ സംഖ്യ രണ്ട് വ്യത്യസ്ത പ്രധാന സംഖ്യകളുടെ ഗുണഫലമാണെന്ന് കരുതുന്നു.\n    ഏറ്റവും ചെറിയ പ്രധാന സംഖ്യ (2) മുതൽ സാധ്യതയുള്ള ഘടകങ്ങൾ വഴി ഫംഗ്ഷൻ ആവർത്തിക്കുന്നു\n    അവ 'n' എന്നതിന്റെ ഘടകമാണോ എന്ന് പരിശോധിക്കുന്നു. ഒരു ഘടകം കണ്ടെത്തിയാൽ, ഫംഗ്ഷൻ\n    'n' നെ ഈ ഘടകത്തിൽ വിഭജിക്കുന്ന ഫലം തിരികെ നൽകുന്നു, ഇത് വലിയ പ്രധാന ഘടകമാണ്.\n    'n' ന്റെ ചതുരമുഖം വരെ ഘടകങ്ങൾ കണ്ടെത്താനായില്ലെങ്കിൽ, 'n' തന്നെ ഒരു പ്രധാന സംഖ്യയാണ്\n    കൂടാതെ ഏറ്റവും വലിയ പ്രധാന ഘടകമായി തിരികെ നൽകുന്നു.\n    \n    Args:\n    n (int): രണ്ട് വ്യത്യസ്ത പ്രധാന സംഖ്യകളുടെ ഗുണഫലമായ ഘടകമാക്കാനുള്ള പോസിറ്റീവ് പൂർണ്ണസംഖ്യ.\n    \n    Returns:\n    int: 'n' എന്നതിന്റെ രണ്ട് പ്രധാന ഘടകങ്ങളിൽ ഏറ്റവും വലിയത്.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "fa": "بزرگترین عامل اول یک عدد صحیح مثبت داده شده را پیدا کنید.\n\nعدد صحیح فرض می‌شود که حاصل‌ضرب دقیقاً دو عدد اول متمایز است. تابع از کوچکترین عدد اول (2) شروع به پیمایش عوامل بالقوه می‌کند و بررسی می‌کند که آیا آنها یک عامل از 'n' هستند یا خیر. اگر یک عامل پیدا شود، تابع تقسیم 'n' بر این عامل را برمی‌گرداند که عامل اول بزرگتر است. اگر هیچ عاملی تا ریشه دوم 'n' پیدا نشود، در این صورت خود 'n' یک عدد اول است و به عنوان بزرگترین عامل اول برگردانده می‌شود.\n\nآرگومان‌ها:\nn (int): عدد صحیح مثبتی که باید تجزیه شود و حاصل‌ضرب دو عدد اول متمایز است.\n\nبازگشت:\nint: بزرگترین عامل اول از دو عامل اول 'n'.\n\nمثال‌ها:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5"}}
{"task_id": "Python/24", "prompt": {"en": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "sq": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Numëroni numrin e mënyrave për të ndarë një numër të plotë n në k pjesë,\n    ku secila pjesë është të paktën x dhe rendi i pjesëve nuk ka rëndësi.\n\n    Parametrat:\n    n (int): Numri i plotë që do të ndahet.\n    k (int): Numri i pjesëve në të cilat do të ndahet n.\n    x (int): Vlera minimale për secilën pjesë.\n\n    Kthen:\n    int: Numri i mënyrave të ndarjes së dallueshme.\n\n    Shembuj:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "hy": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Հաշվել, թե քանի եղանակով կարելի է n ամբողջ թիվը բաժանել k մասերի,\n    որտեղ յուրաքանչյուր մասը առնվազն x է, և մասերի հերթականությունը նշանակություն չունի։\n\n    Պարամետրեր:\n    n (int): Ամբողջ թիվը, որը պետք է բաժանել։\n    k (int): Մասերի քանակը, որոնց պետք է բաժանել n-ը։\n    x (int): Յուրաքանչյուր մասի նվազագույն արժեքը։\n\n    Վերադարձնում է:\n    int: Տարբեր բաժանումների եղանակների քանակը։\n\n    Օրինակներ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "bn": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    একটি পূর্ণসংখ্যা n কে k অংশে ভাগ করার উপায়গুলির সংখ্যা গণনা করুন,\n    যেখানে প্রতিটি অংশ কমপক্ষে x এবং অংশগুলির ক্রম গুরুত্বপূর্ণ নয়।\n\n    প্যারামিটার:\n    n (int): যে পূর্ণসংখ্যাটি ভাগ করা হবে।\n    k (int): n কে ভাগ করার জন্য অংশের সংখ্যা।\n    x (int): প্রতিটি অংশের জন্য ন্যূনতম মান।\n\n    রিটার্নস:\n    int: স্বতন্ত্র ভাগ করার উপায়গুলির সংখ্যা।\n\n    উদাহরণ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "bg": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Пребройте броя на начините за разделяне на цяло число n на k части,\n    където всяка част е поне x и редът на частите няма значение.\n\n    Параметри:\n    n (int): Цялото число, което ще бъде разделено.\n    k (int): Броят на частите, на които да се раздели n.\n    x (int): Минималната стойност за всяка част.\n\n    Връща:\n    int: Броят на различните начини за разделяне.\n\n    Примери:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "zh": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    计算将整数 n 分成 k 部分的方法数，\n    其中每部分至少为 x，并且部分的顺序不重要。\n\n    参数:\n    n (int): 要分割的整数。\n    k (int): 将 n 分成的部分数。\n    x (int): 每部分的最小值。\n\n    返回:\n    int: 不同分割方法的数量。\n\n    示例:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "fr": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Compter le nombre de façons de partitionner un entier n en k parties,\n    où chaque partie est au moins x et l'ordre des parties n'a pas d'importance.\n\n    Paramètres:\n    n (int): L'entier à partitionner.\n    k (int): Le nombre de parties pour diviser n.\n    x (int): La valeur minimale pour chaque partie.\n\n    Retourne:\n    int: Le nombre de façons de partition distinctes.\n\n    Exemples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "de": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Zähle die Anzahl der Möglichkeiten, eine ganze Zahl n in k Teile zu zerlegen,\n    wobei jeder Teil mindestens x ist und die Reihenfolge der Teile keine Rolle spielt.\n\n    Parameter:\n    n (int): Die zu zerlegende ganze Zahl.\n    k (int): Die Anzahl der Teile, in die n aufgeteilt werden soll.\n    x (int): Der Mindestwert für jeden Teil.\n\n    Rückgabe:\n    int: Die Anzahl der unterschiedlichen Zerlegungsmöglichkeiten.\n\n    Beispiele:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "ha": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Ƙirga yawan hanyoyin raba lamba n zuwa k sassa,\n    inda kowanne sashi ya kasance aƙalla x kuma tsari na sassa ba shi da mahimmanci.\n\n    Ma'auni:\n    n (int): Lambar da za a raba.\n    k (int): Yawan sassan da za a raba n zuwa.\n    x (int): Ƙimar mafi ƙaranci ga kowane sashi.\n\n    Komawa:\n    int: Yawan hanyoyin rarrabuwa daban-daban.\n\n    Misalai:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "hi": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    एक पूर्णांक n को k भागों में विभाजित करने के तरीकों की संख्या गिनें,\n    जहाँ प्रत्येक भाग कम से कम x हो और भागों का क्रम मायने नहीं रखता।\n\n    पैरामीटर्स:\n    n (int): विभाजित किया जाने वाला पूर्णांक।\n    k (int): n को विभाजित करने के लिए भागों की संख्या।\n    x (int): प्रत्येक भाग के लिए न्यूनतम मान।\n\n    रिटर्न्स:\n    int: विभाजन के विभिन्न तरीकों की संख्या।\n\n    उदाहरण:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "hu": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Számolja meg, hányféleképpen lehet egy n egész számot k részre osztani,\n    ahol minden rész legalább x, és a részek sorrendje nem számít.\n\n    Paraméterek:\n    n (int): Az egész szám, amelyet fel kell osztani.\n    k (int): A részek száma, amire n-t fel kell osztani.\n    x (int): Minden rész minimum értéke.\n\n    Visszatér:\n    int: Az eltérő felosztási módok száma.\n\n    Példák:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "es": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Cuenta el número de formas de particionar un entero n en k partes,\n    donde cada parte es al menos x y el orden de las partes no importa.\n\n    Parámetros:\n    n (int): El entero a particionar.\n    k (int): El número de partes en las que dividir n.\n    x (int): El valor mínimo para cada parte.\n\n    Devuelve:\n    int: El número de formas distintas de particionar.\n\n    Ejemplos:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "arb": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    عد عدد الطرق لتقسيم عدد صحيح n إلى k أجزاء،\n    حيث أن كل جزء لا يقل عن x ولا يهم ترتيب الأجزاء.\n\n    المعاملات:\n    n (int): العدد الصحيح المراد تقسيمه.\n    k (int): عدد الأجزاء لتقسيم n إليها.\n    x (int): القيمة الدنيا لكل جزء.\n\n    يعيد:\n    int: عدد طرق التقسيم المميزة.\n\n    أمثلة:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "sw": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Hesabu idadi ya njia za kugawanya nambari n katika sehemu k,\n    ambapo kila sehemu ni angalau x na mpangilio wa sehemu hauna umuhimu.\n\n    Vigezo:\n    n (int): Nambari ya kugawanywa.\n    k (int): Idadi ya sehemu za kugawanya n.\n    x (int): Thamani ya chini kwa kila sehemu.\n\n    Inarejesha:\n    int: Idadi ya njia tofauti za kugawanya.\n\n    Mifano:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "tr": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Bir tamsayı n'yi k parçaya ayırmanın yollarını say,\n    burada her parça en az x ve parçaların sırası önemli değil.\n\n    Parametreler:\n    n (int): Parçalanacak tamsayı.\n    k (int): n'yi bölmek için parça sayısı.\n    x (int): Her parça için minimum değer.\n\n    Dönüş:\n    int: Farklı bölme yollarının sayısı.\n\n    Örnekler:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "vi": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Đếm số cách phân hoạch một số nguyên n thành k phần,\n    trong đó mỗi phần ít nhất là x và thứ tự của các phần không quan trọng.\n\n    Tham số:\n    n (int): Số nguyên cần được phân hoạch.\n    k (int): Số phần để chia n.\n    x (int): Giá trị tối thiểu cho mỗi phần.\n\n    Trả về:\n    int: Số cách phân hoạch khác nhau.\n\n    Ví dụ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "id": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Hitung jumlah cara untuk membagi bilangan bulat n menjadi k bagian,\n    di mana setiap bagian setidaknya bernilai x dan urutan bagian tidak penting.\n\n    Parameter:\n    n (int): Bilangan bulat yang akan dibagi.\n    k (int): Jumlah bagian untuk membagi n.\n    x (int): Nilai minimum untuk setiap bagian.\n\n    Mengembalikan:\n    int: Jumlah cara pembagian yang berbeda.\n\n    Contoh:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "ja": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    整数 n を k 個の部分に分割する方法の数を数えます。\n    各部分は少なくとも x であり、部分の順序は重要ではありません。\n\n    パラメータ:\n    n (int): 分割される整数。\n    k (int): n を分割する部分の数。\n    x (int): 各部分の最小値。\n\n    戻り値:\n    int: 異なる分割方法の数。\n\n    例:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "ko": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    정수 n을 k개의 부분으로 분할하는 방법의 수를 계산합니다,\n    각 부분은 적어도 x 이상이어야 하며 부분의 순서는 중요하지 않습니다.\n\n    매개변수:\n    n (int): 분할할 정수.\n    k (int): n을 나눌 부분의 수.\n    x (int): 각 부분의 최소값.\n\n    반환값:\n    int: 서로 다른 분할 방법의 수.\n\n    예시:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "ml": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    n-നെ k ഭാഗങ്ങളായി വിഭജിക്കുന്നതിനുള്ള മാർഗ്ഗങ്ങളുടെ എണ്ണം എണ്ണുക,\n    ഓരോ ഭാഗവും കുറഞ്ഞത് x ആകുകയും ഭാഗങ്ങളുടെ ക്രമം പ്രാധാന്യമില്ലാതിരിക്കുകയും ചെയ്യുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    n (int): വിഭജിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n    k (int): n-നെ വിഭജിക്കേണ്ട ഭാഗങ്ങളുടെ എണ്ണം.\n    x (int): ഓരോ ഭാഗത്തിനും കുറഞ്ഞത് വേണ്ട മൂല്യം.\n\n    മടക്കുന്നു:\n    int: വ്യത്യസ്തമായ വിഭജന മാർഗ്ഗങ്ങളുടെ എണ്ണം.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"", "fa": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    تعداد راه‌های تقسیم یک عدد صحیح n به k بخش را بشمارید،\n    به طوری که هر بخش حداقل x باشد و ترتیب بخش‌ها مهم نباشد.\n\n    پارامترها:\n    n (int): عدد صحیحی که باید تقسیم شود.\n    k (int): تعداد بخش‌هایی که n به آن تقسیم می‌شود.\n    x (int): حداقل مقدار برای هر بخش.\n\n    بازگشت:\n    int: تعداد راه‌های تقسیم‌بندی متمایز.\n\n    مثال‌ها:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\""}, "canonical_solution": "    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count", "instruction": {"en": "Write a python function 'def count_partitions(n: int, k: int, x: int) -> int:' to solve the following problem:\n\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "sq": "Shkruani një funksion python 'def count_partitions(n: int, k: int, x: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Numëroni numrin e mënyrave për të ndarë një numër të plotë n në k pjesë,\n    ku secila pjesë është të paktën x dhe rendi i pjesëve nuk ka rëndësi.\n\n    Parametrat:\n    n (int): Numri i plotë që do të ndahet.\n    k (int): Numri i pjesëve për të ndarë n.\n    x (int): Vlera minimale për secilën pjesë.\n\n    Kthen:\n    int: Numri i mënyrave të dallueshme të ndarjes.\n\n    Shembuj:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "hy": "Պայթոն ֆունկցիա 'def count_partitions(n: int, k: int, x: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվել եղանակների քանակը, որոնցով կարելի է բաժանել n ամբողջ թիվը k մասերի,\n    որտեղ յուրաքանչյուր մասը առնվազն x է, և մասերի հերթականությունը կարևոր չէ։\n\n    Պարամետրեր:\n    n (int): Բաժանվող ամբողջ թիվը։\n    k (int): Մասերի քանակը, որոնց պետք է բաժանել n-ը։\n    x (int): Յուրաքանչյուր մասի նվազագույն արժեքը։\n\n    Վերադարձնում է:\n    int: Տարբեր բաժանումների եղանակների քանակը։\n\n    Օրինակներ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "bn": "একটি পাইথন ফাংশন 'def count_partitions(n: int, k: int, x: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি পূর্ণসংখ্যা n কে k অংশে ভাগ করার উপায়গুলির সংখ্যা গণনা করুন,\n    যেখানে প্রতিটি অংশ অন্তত x এবং অংশগুলির ক্রম বিবেচ্য নয়।\n\n    Parameters:\n    n (int): বিভাজন করার জন্য পূর্ণসংখ্যা।\n    k (int): n কে ভাগ করার জন্য অংশের সংখ্যা।\n    x (int): প্রতিটি অংশের জন্য ন্যূনতম মান।\n\n    Returns:\n    int: পৃথক বিভাজন পদ্ধতির সংখ্যা।\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "bg": "Напишете Python функция 'def count_partitions(n: int, k: int, x: int) -> int:' за да решите следния проблем:\n\n    Пребройте броя на начините да разделите цяло число n на k части,\n    където всяка част е поне x и редът на частите няма значение.\n\n    Параметри:\n    n (int): Цялото число, което ще бъде разделено.\n    k (int): Броят на частите, на които да се раздели n.\n    x (int): Минималната стойност за всяка част.\n\n    Връща:\n    int: Броят на различните начини за разделяне.\n\n    Примери:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "zh": "编写一个Python函数 'def count_partitions(n: int, k: int, x: int) -> int:' 来解决以下问题：\n\n    计算将整数n划分为k部分的方法数，\n    其中每部分至少为x，并且部分的顺序无关紧要。\n\n    参数：\n    n (int): 要划分的整数。\n    k (int): 将n划分为的部分数。\n    x (int): 每部分的最小值。\n\n    返回：\n    int: 不同划分方法的数量。\n\n    示例：\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "fr": "Écrire une fonction python 'def count_partitions(n: int, k: int, x: int) -> int:' pour résoudre le problème suivant :\n\n    Compter le nombre de façons de partitionner un entier n en k parties,\n    où chaque partie est au moins x et l'ordre des parties n'a pas d'importance.\n\n    Paramètres:\n    n (int): L'entier à partitionner.\n    k (int): Le nombre de parties pour diviser n.\n    x (int): La valeur minimale pour chaque partie.\n\n    Renvoie:\n    int: Le nombre de façons distinctes de partitionner.\n\n    Exemples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "de": "Schreiben Sie eine Python-Funktion 'def count_partitions(n: int, k: int, x: int) -> int:', um das folgende Problem zu lösen:\n\n    Zählen Sie die Anzahl der Möglichkeiten, eine ganze Zahl n in k Teile zu partitionieren,\n    wobei jeder Teil mindestens x ist und die Reihenfolge der Teile keine Rolle spielt.\n\n    Parameter:\n    n (int): Die zu partitionierende ganze Zahl.\n    k (int): Die Anzahl der Teile, in die n aufgeteilt werden soll.\n    x (int): Der Mindestwert für jeden Teil.\n\n    Rückgabewert:\n    int: Die Anzahl der unterschiedlichen Partitionierungsmöglichkeiten.\n\n    Beispiele:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "ha": "Rubuta wani aikin python 'def count_partitions(n: int, k: int, x: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa yawan hanyoyin da za a raba adadi n zuwa k sassa,\n    inda kowanne sashi ya kasance a kalla x kuma tsarin sassa ba shi da mahimmanci.\n\n    Sigogi:\n    n (int): Adadin da za a raba.\n    k (int): Yawan sassan da za a raba n zuwa.\n    x (int): Mafi karancin darajar kowane sashi.\n\n    Mayar da:\n    int: Yawan hanyoyin rarrabawa daban-daban.\n\n    Misalai:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "hi": "एक पायथन फ़ंक्शन 'def count_partitions(n: int, k: int, x: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    n को k भागों में विभाजित करने के तरीकों की संख्या गिनें,\n    जहाँ प्रत्येक भाग कम से कम x हो और भागों के क्रम का कोई महत्व न हो।\n\n    पैरामीटर्स:\n    n (int): वह पूर्णांक जिसे विभाजित करना है।\n    k (int): भागों की संख्या जिसमें n को विभाजित करना है।\n    x (int): प्रत्येक भाग के लिए न्यूनतम मान।\n\n    लौटाता है:\n    int: भिन्न विभाजन तरीकों की संख्या।\n\n    उदाहरण:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "hu": "Írj egy python függvényt 'def count_partitions(n: int, k: int, x: int) -> int:' a következő probléma megoldására:\n\n    Számold meg, hányféleképpen lehet egy n egész számot k részre osztani,\n    ahol minden rész legalább x, és a részek sorrendje nem számít.\n\n    Paraméterek:\n    n (int): Az egész szám, amelyet fel kell osztani.\n    k (int): A részek száma, amire n-t fel kell osztani.\n    x (int): Az egyes részek minimális értéke.\n\n    Visszatér:\n    int: Az eltérő felosztási módok száma.\n\n    Példák:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "es": "Escribe una función de Python 'def count_partitions(n: int, k: int, x: int) -> int:' para resolver el siguiente problema:\n\n    Cuenta el número de formas de particionar un entero n en k partes,\n    donde cada parte es al menos x y el orden de las partes no importa.\n\n    Parámetros:\n    n (int): El entero a ser particionado.\n    k (int): El número de partes en que se divide n.\n    x (int): El valor mínimo para cada parte.\n\n    Devuelve:\n    int: El número de formas distintas de particionar.\n\n    Ejemplos:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "arb": "اكتب دالة بايثون 'def count_partitions(n: int, k: int, x: int) -> int:' لحل المشكلة التالية:\n\n    احسب عدد الطرق لتقسيم عدد صحيح n إلى k أجزاء،\n    حيث أن كل جزء لا يقل عن x وترتيب الأجزاء لا يهم.\n\n    المعاملات:\n    n (int): العدد الصحيح الذي سيتم تقسيمه.\n    k (int): عدد الأجزاء لتقسيم n إليها.\n    x (int): القيمة الدنيا لكل جزء.\n\n    يعيد:\n    int: عدد طرق التقسيم المميزة.\n\n    أمثلة:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "sw": "Andika kazi ya python 'def count_partitions(n: int, k: int, x: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ya njia za kugawa nambari n katika sehemu k,\n    ambapo kila sehemu ni angalau x na mpangilio wa sehemu haujalishi.\n\n    Vigezo:\n    n (int): Nambari ya kugawanywa.\n    k (int): Idadi ya sehemu za kugawa n.\n    x (int): Thamani ya chini kwa kila sehemu.\n\n    Inarudisha:\n    int: Idadi ya njia tofauti za kugawa.\n\n    Mifano:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "tr": "Bir python fonksiyonu 'def count_partitions(n: int, k: int, x: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Bir tamsayı n'yi k parçaya ayırmanın yollarını sayın,\n    burada her parça en az x olmalı ve parçaların sırası önemli değildir.\n\n    Parametreler:\n    n (int): Parçalanacak tamsayı.\n    k (int): n'yi bölmek için parça sayısı.\n    x (int): Her parça için minimum değer.\n\n    Döndürür:\n    int: Farklı bölme yollarının sayısı.\n\n    Örnekler:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "vi": "Viết một hàm python 'def count_partitions(n: int, k: int, x: int) -> int:' để giải quyết vấn đề sau:\n\n    Đếm số cách để phân hoạch một số nguyên n thành k phần,\n    trong đó mỗi phần ít nhất là x và thứ tự các phần không quan trọng.\n\n    Tham số:\n    n (int): Số nguyên cần được phân hoạch.\n    k (int): Số phần để chia n.\n    x (int): Giá trị tối thiểu cho mỗi phần.\n\n    Trả về:\n    int: Số cách phân hoạch khác biệt.\n\n    Ví dụ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "id": "Tulis sebuah fungsi python 'def count_partitions(n: int, k: int, x: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung jumlah cara untuk membagi bilangan bulat n menjadi k bagian,\n    di mana setiap bagian setidaknya bernilai x dan urutan bagian tidak masalah.\n\n    Parameter:\n    n (int): Bilangan bulat yang akan dibagi.\n    k (int): Jumlah bagian untuk membagi n.\n    x (int): Nilai minimum untuk setiap bagian.\n\n    Mengembalikan:\n    int: Jumlah cara pembagian yang berbeda.\n\n    Contoh:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "ja": "Python関数を書いてください。 'def count_partitions(n: int, k: int, x: int) -> int:' 次の問題を解決するために:\n\n    整数 n を k 個の部分に分割する方法の数を数えます。\n    各部分は少なくとも x であり、部分の順序は関係ありません。\n\n    パラメータ:\n    n (int): 分割される整数。\n    k (int): n を分割する部分の数。\n    x (int): 各部分の最小値。\n\n    戻り値:\n    int: 異なる分割方法の数。\n\n    例:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "ko": "다음 문제를 해결하기 위해 'def count_partitions(n: int, k: int, x: int) -> int:'라는 파이썬 함수를 작성하세요:\n\n    정수 n을 k개의 부분으로 나누는 방법의 수를 세어보세요,\n    여기서 각 부분은 최소 x 이상이며 부분의 순서는 중요하지 않습니다.\n\n    매개변수:\n    n (int): 분할할 정수.\n    k (int): n을 나눌 부분의 수.\n    x (int): 각 부분의 최소값.\n\n    반환:\n    int: 서로 다른 분할 방법의 수.\n\n    예시:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "ml": "'def count_partitions(n: int, k: int, x: int) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    n എന്ന പൂർണ്ണസംഖ്യ k ഭാഗങ്ങളിലായി വിഭജിക്കുന്നതിനുള്ള മാർഗങ്ങളുടെ എണ്ണം എണ്ണുക,\n    ഓരോ ഭാഗവും കുറഞ്ഞത് x ആയിരിക്കണം, ഭാഗങ്ങളുടെ ക്രമം പ്രശ്നമല്ല.\n\n    പാരാമീറ്ററുകൾ:\n    n (int): വിഭജിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n    k (int): n നെ വിഭജിക്കേണ്ട ഭാഗങ്ങളുടെ എണ്ണം.\n    x (int): ഓരോ ഭാഗത്തിനും കുറഞ്ഞത് വേണ്ട മൂല്യം.\n\n    മടക്കുക:\n    int: വ്യത്യസ്തമായ വിഭജനം നടത്താനുള്ള മാർഗങ്ങളുടെ എണ്ണം.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "fa": "یک تابع پایتون بنویسید 'def count_partitions(n: int, k: int, x: int) -> int:' برای حل مسئله زیر:\n\n    تعداد راه‌های تقسیم یک عدد صحیح n به k قسمت را بشمارید،\n    به طوری که هر قسمت حداقل x باشد و ترتیب قسمت‌ها مهم نباشد.\n\n    پارامترها:\n    n (int): عدد صحیحی که باید تقسیم شود.\n    k (int): تعداد قسمت‌هایی که n باید به آن تقسیم شود.\n    x (int): حداقل مقدار برای هر قسمت.\n\n    بازگشت:\n    int: تعداد راه‌های تقسیم‌بندی متمایز.\n\n    مثال‌ها:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3"}, "level": "easy", "test": "def test_count_partitions():\n    # Test case 1: Simple case\n    result = count_partitions(7, 3, 1)\n    assert result == 4, f\"Expected 4, got {result}\"\n\n    # Test case 2: Another simple case\n    result = count_partitions(6, 2, 1)\n    assert result == 3, f\"Expected 3, got {result}\"\n\n    # Test case 3: Partitioning into a larger number of parts\n    result = count_partitions(8, 4, 1)\n    assert result == 5, f\"Expected 5, got {result}\"\n\n    print(\"All test cases passed successfully!\")\n\n\n# Call the test function to run the test cases\ntest_count_partitions()", "entry_point": "count_partitions", "signature": "def count_partitions(n: int, k: int, x: int) -> int:", "docstring": {"en": "\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "sq": "\n    Numëroni numrin e mënyrave për të ndarë një numër të plotë n në k pjesë,\n    ku secila pjesë është të paktën x dhe rendi i pjesëve nuk ka rëndësi.\n\n    Parametrat:\n    n (int): Numri i plotë që do të ndahet.\n    k (int): Numri i pjesëve për të ndarë n.\n    x (int): Vlera minimale për secilën pjesë.\n\n    Kthen:\n    int: Numri i mënyrave të ndarjes të dallueshme.\n\n    Shembuj:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "hy": "\n    Հաշվեք n ամբողջ թիվը k մասերի բաժանելու եղանակների քանակը,\n    որտեղ յուրաքանչյուր մասը առնվազն x է, և մասերի կարգը կարևոր չէ։\n\n    Պարամետրեր:\n    n (int): Բաժանվող ամբողջ թիվը։\n    k (int): Մասերի քանակը, որոնց պետք է բաժանել n-ը։\n    x (int): Յուրաքանչյուր մասի նվազագույն արժեքը։\n\n    Վերադարձնում է:\n    int: Տարբեր բաժանումների եղանակների քանակը։\n\n    Օրինակներ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "bn": "\n    একটি পূর্ণসংখ্যা n কে k অংশে ভাগ করার উপায়গুলির সংখ্যা গণনা করুন,\n    যেখানে প্রতিটি অংশ কমপক্ষে x এবং অংশগুলির ক্রম গুরুত্বপূর্ণ নয়।\n\n    প্যারামিটারসমূহ:\n    n (int): বিভক্ত করার জন্য পূর্ণসংখ্যা।\n    k (int): n কে ভাগ করার জন্য অংশের সংখ্যা।\n    x (int): প্রতিটি অংশের জন্য ন্যূনতম মান।\n\n    রিটার্নস:\n    int: স্বতন্ত্র বিভাজনের উপায়গুলির সংখ্যা।\n\n    উদাহরণ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "bg": "\n    Пребройте броя на начините за разделяне на цяло число n на k части,\n    където всяка част е поне x и редът на частите няма значение.\n\n    Параметри:\n    n (int): Цялото число, което ще бъде разделено.\n    k (int): Броят на частите, на които да се раздели n.\n    x (int): Минималната стойност за всяка част.\n\n    Връща:\n    int: Броят на различните начини за разделяне.\n\n    Примери:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "zh": "\n    计算将整数 n 分成 k 部分的方法数，其中每部分至少为 x，并且部分的顺序不重要。\n\n    参数:\n    n (int): 要分割的整数。\n    k (int): 将 n 分成的部分数量。\n    x (int): 每部分的最小值。\n\n    返回:\n    int: 不同分割方法的数量。\n\n    示例:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "fr": "\n    Compter le nombre de façons de partitionner un entier n en k parties,\n    où chaque partie est au moins x et l'ordre des parties n'a pas d'importance.\n\n    Paramètres:\n    n (int): L'entier à partitionner.\n    k (int): Le nombre de parties pour diviser n.\n    x (int): La valeur minimale pour chaque partie.\n\n    Retourne:\n    int: Le nombre de façons distinctes de partitionner.\n\n    Exemples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "de": "\n    Zähle die Anzahl der Möglichkeiten, eine ganze Zahl n in k Teile zu partitionieren,\n    wobei jeder Teil mindestens x ist und die Reihenfolge der Teile keine Rolle spielt.\n\n    Parameter:\n    n (int): Die zu partitionierende ganze Zahl.\n    k (int): Die Anzahl der Teile, in die n aufgeteilt werden soll.\n    x (int): Der Mindestwert für jeden Teil.\n\n    Rückgabe:\n    int: Die Anzahl der unterschiedlichen Partitionierungsmöglichkeiten.\n\n    Beispiele:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "ha": "\n    Ƙididdige yawan hanyoyin da za a iya raba lamba n zuwa k sassa,\n    inda kowane sashi ya kasance aƙalla x kuma tsari na sassa bai da mahimmanci.\n\n    Sigogi:\n    n (int): Lambar da za a raba.\n    k (int): Yawan sassa da za a raba n.\n    x (int): Ƙimar mafi ƙaranci ga kowane sashi.\n\n    Komawa:\n    int: Yawan hanyoyin rarraba daban-daban.\n\n    Misalai:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "hi": "\n    एक पूर्णांक n को k भागों में विभाजित करने के तरीकों की संख्या गिनें,\n    जहाँ प्रत्येक भाग कम से कम x हो और भागों के क्रम का कोई महत्व न हो।\n\n    पैरामीटर्स:\n    n (int): विभाजित करने के लिए पूर्णांक।\n    k (int): n को विभाजित करने के लिए भागों की संख्या।\n    x (int): प्रत्येक भाग के लिए न्यूनतम मान।\n\n    रिटर्न्स:\n    int: विभाजन के भिन्न तरीकों की संख्या।\n\n    उदाहरण:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "hu": "\n    Számolja meg, hányféleképpen lehet egy n egész számot k részre osztani,\n    ahol minden rész legalább x, és a részek sorrendje nem számít.\n\n    Paraméterek:\n    n (int): Az egész szám, amelyet fel kell osztani.\n    k (int): A részek száma, amelyekre n-t fel kell osztani.\n    x (int): Az egyes részek minimális értéke.\n\n    Visszatér:\n    int: A különböző felosztási módok száma.\n\n    Példák:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "es": "    Contar el número de formas de particionar un entero n en k partes,\n    donde cada parte es al menos x y el orden de las partes no importa.\n\n    Parámetros:\n    n (int): El entero a ser particionado.\n    k (int): El número de partes en las que dividir n.\n    x (int): El valor mínimo para cada parte.\n\n    Devuelve:\n    int: El número de formas distintas de particionamiento.\n\n    Ejemplos:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "arb": "    احسب عدد الطرق لتقسيم عدد صحيح n إلى k أجزاء،\n    حيث يكون كل جزء على الأقل x ولا يهم ترتيب الأجزاء.\n\n    المعاملات:\n    n (int): العدد الصحيح الذي سيتم تقسيمه.\n    k (int): عدد الأجزاء لتقسيم n إليها.\n    x (int): القيمة الدنيا لكل جزء.\n\n    يعيد:\n    int: عدد طرق التقسيم المتميزة.\n\n    أمثلة:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3", "sw": "    Hesabu idadi ya njia za kugawanya nambari n katika sehemu k,\n    ambapo kila sehemu ni angalau x na mpangilio wa sehemu haujalishi.\n\n    Vigezo:\n    n (int): Nambari ya kugawanywa.\n    k (int): Idadi ya sehemu za kugawa n.\n    x (int): Thamani ya chini kwa kila sehemu.\n\n    Inarejesha:\n    int: Idadi ya njia tofauti za kugawanya.\n\n    Mifano:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "tr": "    Bir tamsayı n'yi k parçaya ayırmanın kaç yolu olduğunu sayın,\n    burada her bir parça en az x ve parçaların sırası önemli değildir.\n\n    Parametreler:\n    n (int): Bölünecek tamsayı.\n    k (int): n'yi bölmek için parça sayısı.\n    x (int): Her bir parça için minimum değer.\n\n    Döndürür:\n    int: Farklı bölme yollarının sayısı.\n\n    Örnekler:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "vi": "    Đếm số cách để phân hoạch một số nguyên n thành k phần,\n    trong đó mỗi phần ít nhất là x và thứ tự của các phần không quan trọng.\n\n    Tham số:\n    n (int): Số nguyên cần được phân hoạch.\n    k (int): Số phần để chia n.\n    x (int): Giá trị tối thiểu cho mỗi phần.\n\n    Trả về:\n    int: Số cách phân hoạch khác biệt.\n\n    Ví dụ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "id": "    Hitung jumlah cara untuk membagi bilangan bulat n menjadi k bagian,\n    di mana setiap bagian setidaknya x dan urutan bagian tidak penting.\n\n    Parameter:\n    n (int): Bilangan bulat yang akan dibagi.\n    k (int): Jumlah bagian untuk membagi n.\n    x (int): Nilai minimum untuk setiap bagian.\n\n    Mengembalikan:\n    int: Jumlah cara pembagian yang berbeda.\n\n    Contoh:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "ja": "    整数 n を k 個の部分に分割する方法の数を数えます。\n    各部分は少なくとも x であり、部分の順序は重要ではありません。\n\n    パラメータ:\n    n (int): 分割される整数。\n    k (int): n を分割する部分の数。\n    x (int): 各部分の最小値。\n\n    戻り値:\n    int: 異なる分割方法の数。\n\n    例:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "ko": "    정수 n을 k개의 부분으로 분할하는 방법의 수를 계산합니다.\n    각 부분은 최소 x 이상이어야 하며 부분의 순서는 중요하지 않습니다.\n\n    매개변수:\n    n (int): 분할할 정수.\n    k (int): n을 나눌 부분의 수.\n    x (int): 각 부분의 최소값.\n\n    반환:\n    int: 서로 다른 분할 방법의 수.\n\n    예제:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "ml": "    ഒരു പൂർണ്ണസംഖ്യ n-നെ k ഭാഗങ്ങളായി വിഭജിക്കുന്നതിനുള്ള മാർഗ്ഗങ്ങളുടെ എണ്ണം കണക്കാക്കുക,\n    ഓരോ ഭാഗവും കുറഞ്ഞത് x ആയിരിക്കണം, ഭാഗങ്ങളുടെ ക്രമം പ്രാധാന്യമില്ല.\n\n    പാരാമീറ്ററുകൾ:\n    n (int): വിഭജിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n    k (int): n-നെ വിഭജിക്കേണ്ട ഭാഗങ്ങളുടെ എണ്ണം.\n    x (int): ഓരോ ഭാഗത്തിനും കുറഞ്ഞത് വേണ്ട മൂല്യം.\n\n    മടക്കുന്നു:\n    int: വ്യത്യസ്തമായ വിഭജന മാർഗ്ഗങ്ങളുടെ എണ്ണം.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ", "fa": "    تعداد راه‌های تقسیم یک عدد صحیح n به k قسمت را بشمارید،\n    به طوری که هر قسمت حداقل x باشد و ترتیب قسمت‌ها مهم نباشد.\n\n    Parameters:\n    n (int): عدد صحیحی که باید تقسیم شود.\n    k (int): تعداد قسمت‌هایی که n به آن‌ها تقسیم می‌شود.\n    x (int): حداقل مقدار برای هر قسمت.\n\n    Returns:\n    int: تعداد راه‌های تقسیم‌بندی متمایز.\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    "}}
{"task_id": "Python/25", "prompt": {"en": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "sq": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Llogarit numrin e sekuencave të vlefshme që mund të formohen sipas rregullave specifike.\n    \n    Çdo sekuencë fillon me një numër të dhënë 'n', dhe një numër i ri mund të shtohet në sekuencë\n    nëse është një numër i plotë pozitiv dhe jo më i madh se gjysma e numrit të fundit në sekuencë. \n    Kjo funksion përdor memoizimin për të ruajtur rezultatet e llogaritura më parë për të optimizuar performancën.\n    \n    Args:\n        n (int): Numri fillestar i sekuencës.\n        last (int): Numri i fundit në sekuencën aktuale.\n        memo (dict): Një fjalor i përdorur për memoizim, që ruan numrin e sekuencave të vlefshme\n                     për secilin vlerë 'last' të hasur.\n    \n    Returns:\n        int: Numri total i sekuencave të vlefshme që mund të formohen duke filluar me 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "hy": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Հաշվել վավեր հաջորդականությունների քանակը, որոնք կարող են ձևավորվել ըստ որոշակի կանոնների։\n    \n    Յուրաքանչյուր հաջորդականություն սկսվում է տրված թվով 'n', և նոր թիվը կարող է կցվել հաջորդականությանը,\n    եթե այն դրական ամբողջ թիվ է և չի գերազանցում հաջորդականության վերջին թվի կեսը։ Այս\n    ֆունկցիան օգտագործում է հիշողության օպտիմալացում՝ պահելու համար նախապես հաշվարկված արդյունքները՝\n    կատարողականությունը օպտիմալացնելու համար։\n    \n    Արգումենտներ:\n        n (int): Հաջորդականության մեկնարկային թիվը։\n        last (int): Ընթացիկ հաջորդականության վերջին թիվը։\n        memo (dict): Բառարան, որը օգտագործվում է հիշողության օպտիմալացման համար, պահելով վավեր հաջորդականությունների քանակը\n                     յուրաքանչյուր հանդիպած 'last' արժեքի համար։\n    \n    Վերադարձնում է:\n        int: Վավեր հաջորդականությունների ընդհանուր քանակը, որոնք կարող են ձևավորվել 'n'-ով սկսած։\n    \n    Օրինակներ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "bn": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    নির্দিষ্ট নিয়ম অনুযায়ী গঠন করা যেতে পারে এমন বৈধ সিকোয়েন্সের সংখ্যা গণনা করুন।\n    \n    প্রতিটি সিকোয়েন্স একটি নির্দিষ্ট সংখ্যা 'n' দিয়ে শুরু হয়, এবং একটি নতুন সংখ্যা সিকোয়েন্সে যোগ করা যেতে পারে\n    যদি এটি একটি ধনাত্মক পূর্ণসংখ্যা হয় এবং সিকোয়েন্সের শেষ সংখ্যার অর্ধেকের চেয়ে বড় না হয়। এই\n    ফাংশনটি মেমোইজেশন ব্যবহার করে পূর্বে গণনা করা ফলাফলগুলি সংরক্ষণ করে কর্মক্ষমতা উন্নত করতে।\n    \n    Args:\n        n (int): সিকোয়েন্সের শুরুর সংখ্যা।\n        last (int): বর্তমান সিকোয়েন্সের শেষ সংখ্যা।\n        memo (dict): মেমোইজেশনের জন্য ব্যবহৃত একটি ডিকশনারি, প্রতিটি 'last' মানের জন্য বৈধ সিকোয়েন্সের সংখ্যা\n                     সংরক্ষণ করে।\n    \n    Returns:\n        int: 'n' দিয়ে শুরু করে গঠন করা যেতে পারে এমন বৈধ সিকোয়েন্সের মোট সংখ্যা।\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "bg": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Изчисляване на броя на валидните последователности, които могат да бъдат формирани според специфични правила.\n    \n    Всяка последователност започва с дадено число 'n', и ново число може да бъде добавено към последователността,\n    ако е положително цяло число и не е по-голямо от половината на последното число в последователността. Тази\n    функция използва мемоизация за съхранение на предварително изчислени резултати за оптимизиране на производителността.\n    \n    Аргументи:\n        n (int): Началното число на последователността.\n        last (int): Последното число в текущата последователност.\n        memo (dict): Речник, използван за мемоизация, съхраняващ броя на валидните последователности\n                     за всяка срещната стойност на 'last'.\n    \n    Връща:\n        int: Общият брой на валидните последователности, които могат да бъдат формирани, започвайки с 'n'.\n    \n    Примери:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "zh": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    根据特定规则计算可以形成的有效序列的数量。\n    \n    每个序列以给定数字 'n' 开始，可以将一个新数字附加到序列中，\n    如果它是一个正整数且不大于序列中最后一个数字的一半。\n    此函数使用记忆化技术存储先前计算的结果以优化性能。\n    \n    参数:\n        n (int): 序列的起始数字。\n        last (int): 当前序列中的最后一个数字。\n        memo (dict): 用于记忆化的字典，存储每个遇到的 'last' 值的有效序列数量。\n    \n    返回:\n        int: 可以从 'n' 开始形成的有效序列的总数。\n    \n    示例:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "fr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculer le nombre de séquences valides qui peuvent être formées selon des règles spécifiques.\n    \n    Chaque séquence commence par un nombre donné 'n', et un nouveau nombre peut être ajouté à la séquence\n    s'il est un entier positif et n'est pas supérieur à la moitié du dernier nombre de la séquence. Cette\n    fonction utilise la mémoïsation pour stocker les résultats précédemment calculés afin d'optimiser les performances.\n    \n    Args:\n        n (int): Le nombre de départ de la séquence.\n        last (int): Le dernier nombre dans la séquence actuelle.\n        memo (dict): Un dictionnaire utilisé pour la mémoïsation, stockant le nombre de séquences valides\n                     pour chaque valeur 'last' rencontrée.\n    \n    Returns:\n        int: Le nombre total de séquences valides qui peuvent être formées en commençant par 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "de": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Berechne die Anzahl der gültigen Sequenzen, die gemäß spezifischer Regeln gebildet werden können.\n    \n    Jede Sequenz beginnt mit einer gegebenen Zahl 'n', und eine neue Zahl kann an die Sequenz angehängt werden,\n    wenn sie eine positive ganze Zahl ist und nicht größer als die Hälfte der letzten Zahl in der Sequenz.\n    Diese Funktion verwendet Memoisierung, um zuvor berechnete Ergebnisse zu speichern und die Leistung zu optimieren.\n    \n    Argumente:\n        n (int): Die Startzahl der Sequenz.\n        last (int): Die letzte Zahl in der aktuellen Sequenz.\n        memo (dict): Ein Wörterbuch, das für die Memoisierung verwendet wird und die Anzahl der gültigen Sequenzen\n                     für jeden 'last'-Wert speichert, der aufgetreten ist.\n    \n    Rückgabewert:\n        int: Die Gesamtanzahl der gültigen Sequenzen, die mit 'n' gebildet werden können.\n    \n    Beispiele:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "ha": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Lissafa adadin jerin da za a iya samarwa bisa ga wasu ƙa'idoji na musamman.\n    \n    Kowace jeri tana farawa da wani lamba 'n', kuma za a iya ƙara sabon lamba ga jerin\n    idan yana da lamba mai kyau kuma ba ya fi rabin lamba na ƙarshe a cikin jerin ba. Wannan\n    aiki yana amfani da memoization don adana sakamakon da aka ƙididdige a baya don inganta aiki.\n    \n    Args:\n        n (int): Lambar da ke farawa da jeri.\n        last (int): Lambar ƙarshe a cikin jerin yanzu.\n        memo (dict): Kamus da ake amfani da shi don memoization, yana adana adadin jerin masu inganci\n                     don kowane ƙimar 'last' da aka haɗu da shi.\n    \n    Returns:\n        int: Jimlar adadin jerin masu inganci da za a iya samarwa farawa da 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "hi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    विशिष्ट नियमों के अनुसार बनाई जा सकने वाली मान्य अनुक्रमों की संख्या की गणना करें।\n    \n    प्रत्येक अनुक्रम एक दिए गए संख्या 'n' से शुरू होता है, और अनुक्रम में एक नई संख्या जोड़ी जा सकती है\n    यदि यह एक धनात्मक पूर्णांक है और अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं है। यह\n    फ़ंक्शन प्रदर्शन को अनुकूलित करने के लिए पहले से गणना किए गए परिणामों को संग्रहीत करने के लिए स्मरणीयता का उपयोग करता है।\n    \n    तर्क:\n        n (int): अनुक्रम की प्रारंभिक संख्या।\n        last (int): वर्तमान अनुक्रम में अंतिम संख्या।\n        memo (dict): स्मरणीयता के लिए उपयोग की जाने वाली एक डिक्शनरी, प्रत्येक 'last' मान के लिए मान्य अनुक्रमों की संख्या\n                     संग्रहीत करती है।\n    \n    वापसी:\n        int: 'n' से शुरू होने वाले बनाए जा सकने वाले कुल मान्य अनुक्रमों की संख्या।\n    \n    उदाहरण:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "hu": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Számítsa ki az érvényes sorozatok számát, amelyek meghatározott szabályok szerint képezhetők.\n    \n    Minden sorozat egy adott 'n' számmal kezdődik, és egy új szám hozzáadható a sorozathoz,\n    ha pozitív egész szám, és nem nagyobb, mint a sorozat utolsó számának fele. Ez a\n    függvény memoizációt használ, hogy tárolja a korábban kiszámított eredményeket a teljesítmény optimalizálása érdekében.\n    \n    Paraméterek:\n        n (int): A sorozat kezdő száma.\n        last (int): Az aktuális sorozat utolsó száma.\n        memo (dict): Egy szótár, amelyet memoizációra használnak, és amely tárolja az érvényes sorozatok számát\n                     az egyes 'last' értékekhez, amelyekkel találkoztak.\n    \n    Visszatér:\n        int: Az összes érvényes sorozat száma, amely 'n'-nel kezdődik.\n    \n    Példák:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "es": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calcula el número de secuencias válidas que se pueden formar según reglas específicas.\n    \n    Cada secuencia comienza con un número dado 'n', y se puede añadir un nuevo número a la secuencia\n    si es un entero positivo y no es mayor que la mitad del último número en la secuencia. Esta\n    función utiliza memoización para almacenar resultados calculados previamente y optimizar el rendimiento.\n    \n    Argumentos:\n        n (int): El número inicial de la secuencia.\n        last (int): El último número en la secuencia actual.\n        memo (dict): Un diccionario utilizado para la memoización, almacenando el número de secuencias\n                     válidas para cada valor 'last' encontrado.\n    \n    Devuelve:\n        int: El número total de secuencias válidas que se pueden formar comenzando con 'n'.\n    \n    Ejemplos:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "arb": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    حساب عدد التسلسلات الصالحة التي يمكن تشكيلها وفقًا لقواعد محددة.\n    \n    يبدأ كل تسلسل برقم معين 'n'، ويمكن إضافة رقم جديد إلى التسلسل\n    إذا كان عددًا صحيحًا موجبًا ولا يزيد عن نصف الرقم الأخير في التسلسل. \n    تستخدم هذه الدالة التخزين المؤقت لتخزين النتائج المحسوبة مسبقًا لتحسين الأداء.\n    \n    يعيدالحجج:\n        n (int): الرقم الذي يبدأ به التسلسل.\n        last (int): الرقم الأخير في التسلسل الحالي.\n        memo (dict): قاموس يستخدم للتخزين المؤقت، حيث يخزن عدد التسلسلات الصالحة\n                     لكل قيمة 'last' تم مواجهتها.\n    \n    يعيد:\n        int: العدد الإجمالي للتسلسلات الصالحة التي يمكن تشكيلها بدءًا من 'n'.\n    \n    امثله:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "sw": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Kuhesabu idadi ya mfuatano halali ambayo inaweza kuundwa kulingana na sheria maalum.\n    \n    Kila mfuatano huanza na nambari fulani 'n', na nambari mpya inaweza kuongezwa kwenye mfuatano\n    ikiwa ni nambari nzima chanya na haizidi nusu ya nambari ya mwisho katika mfuatano. Kazi hii\n    hutumia memoization kuhifadhi matokeo yaliyokokotolewa awali ili kuboresha utendaji.\n    \n    Hoja:\n        n (int): Nambari ya kuanzia ya mfuatano.\n        last (int): Nambari ya mwisho katika mfuatano wa sasa.\n        memo (dict): Kamusi inayotumika kwa memoization, kuhifadhi idadi ya mfuatano halali\n                     kwa kila thamani ya 'last' iliyokutana.\n    \n    Inarejesha:\n        int: Jumla ya idadi ya mfuatano halali ambayo inaweza kuundwa kuanzia na 'n'.\n    \n    Mifano:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "tr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Belirli kurallara göre oluşturulabilecek geçerli dizilerin sayısını hesaplayın.\n    \n    Her dizi verilen bir 'n' sayısı ile başlar ve diziye yeni bir sayı eklenebilir\n    eğer pozitif bir tam sayıysa ve dizideki son sayının yarısından büyük değilse. Bu\n    fonksiyon, performansı optimize etmek için daha önce hesaplanmış sonuçları saklamak amacıyla memoizasyon kullanır.\n    \n    Argümanlar:\n        n (int): Dizinin başlangıç sayısı.\n        last (int): Mevcut dizideki son sayı.\n        memo (dict): Memoizasyon için kullanılan bir sözlük, karşılaşılan her 'last' değeri için\n                     geçerli dizilerin sayısını saklar.\n    \n    Döndürür:\n        int: 'n' ile başlayan oluşturulabilecek toplam geçerli dizi sayısı.\n    \n    Örnekler:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "vi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Tính toán số lượng dãy hợp lệ có thể được tạo thành theo các quy tắc cụ thể.\n    \n    Mỗi dãy bắt đầu với một số cho trước 'n', và một số mới có thể được thêm vào dãy\n    nếu nó là một số nguyên dương và không lớn hơn một nửa số cuối cùng trong dãy. Hàm này\n    sử dụng ghi nhớ để lưu trữ các kết quả đã tính trước đó nhằm tối ưu hóa hiệu suất.\n    \n    Tham số:\n        n (int): Số bắt đầu của dãy.\n        last (int): Số cuối cùng trong dãy hiện tại.\n        memo (dict): Một từ điển được sử dụng để ghi nhớ, lưu trữ số lượng dãy hợp lệ\n                     cho mỗi giá trị 'last' đã gặp.\n    \n    Trả về:\n        int: Tổng số dãy hợp lệ có thể được tạo thành bắt đầu với 'n'.\n    \n    Ví dụ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "id": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Hitung jumlah urutan valid yang dapat dibentuk sesuai dengan aturan tertentu.\n    \n    Setiap urutan dimulai dengan angka 'n' yang diberikan, dan angka baru dapat ditambahkan ke urutan\n    jika merupakan bilangan bulat positif dan tidak lebih besar dari setengah angka terakhir dalam urutan.\n    Fungsi ini menggunakan memoization untuk menyimpan hasil yang telah dihitung sebelumnya guna mengoptimalkan kinerja.\n    \n    Args:\n        n (int): Angka awal dari urutan.\n        last (int): Angka terakhir dalam urutan saat ini.\n        memo (dict): Sebuah kamus yang digunakan untuk memoization, menyimpan jumlah urutan valid\n                     untuk setiap nilai 'last' yang ditemukan.\n    \n    Returns:\n        int: Jumlah total urutan valid yang dapat dibentuk dimulai dengan 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "ja": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    特定のルールに従って形成できる有効なシーケンスの数を計算します。\n    \n    各シーケンスは与えられた数 'n' で始まり、シーケンスに追加できる新しい数は\n    正の整数であり、シーケンスの最後の数の半分以下でなければなりません。この\n    関数はメモ化を使用して、以前に計算された結果を保存し、パフォーマンスを最適化します。\n    \n    引数:\n        n (int): シーケンスの開始数。\n        last (int): 現在のシーケンスの最後の数。\n        memo (dict): メモ化に使用される辞書で、遭遇した各 'last' 値に対する有効なシーケンスの数を保存します。\n    \n    戻り値:\n        int: 'n' で始まる形成可能な有効なシーケンスの総数。\n    \n    例:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "ko": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    특정 규칙에 따라 형성될 수 있는 유효한 시퀀스의 수를 계산합니다.\n    \n    각 시퀀스는 주어진 숫자 'n'으로 시작하며, 시퀀스에 새 숫자를 추가할 수 있는 경우는\n    양의 정수이고 시퀀스의 마지막 숫자의 절반보다 크지 않을 때입니다. 이 함수는 메모이제이션을 사용하여\n    이전에 계산된 결과를 저장하여 성능을 최적화합니다.\n    \n    Args:\n        n (int): 시퀀스의 시작 숫자.\n        last (int): 현재 시퀀스의 마지막 숫자.\n        memo (dict): 메모이제이션에 사용되는 딕셔너리로, 각 'last' 값에 대해 만난 유효한 시퀀스의 수를 저장합니다.\n    \n    Returns:\n        int: 'n'으로 시작하는 유효한 시퀀스의 총 수.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "ml": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    പ്രത്യേക നിയമങ്ങൾ അനുസരിച്ച് രൂപീകരിക്കാവുന്ന സാധുവായ അനുക്രമങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n    \n    ഓരോ അനുക്രമവും നൽകിയിരിക്കുന്ന സംഖ്യ 'n' ഉപയോഗിച്ച് ആരംഭിക്കുന്നു, ഒരു പുതിയ സംഖ്യ \n    അനുക്രമത്തിൽ ചേർക്കാൻ കഴിയും, അത് ഒരു ധനാത്മക പൂര്‍ണ്ണസംഖ്യയായിരിക്കണം, കൂടാതെ \n    അനുക്രമത്തിലെ അവസാന സംഖ്യയുടെ പകുതിയേക്കാള്‍ കൂടുതലായിരിക്കരുത്. \n    ഈ ഫംഗ്ഷൻ മെമ്മോയ്‌സേഷൻ ഉപയോഗിച്ച് മുമ്പ് കണക്കാക്കിയ ഫലങ്ങൾ സംഭരിച്ച് പ്രകടനം \n    മെച്ചപ്പെടുത്തുന്നു.\n    \n    Args:\n        n (int): അനുക്രമത്തിന്റെ ആരംഭ സംഖ്യ.\n        last (int): നിലവിലെ അനുക്രമത്തിലെ അവസാന സംഖ്യ.\n        memo (dict): മെമ്മോയ്‌സേഷനായി ഉപയോഗിക്കുന്ന ഒരു നിഘണ്ടു, \n                     നേരിടുന്ന ഓരോ 'last' മൂല്യത്തിനും സാധുവായ \n                     അനുക്രമങ്ങളുടെ എണ്ണം സംഭരിക്കുന്നു.\n    \n    Returns:\n        int: 'n' ഉപയോഗിച്ച് ആരംഭിക്കുന്ന സാധുവായ അനുക്രമങ്ങളുടെ \n             മൊത്തം എണ്ണം.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"", "fa": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    محاسبه تعداد دنباله‌های معتبری که می‌توانند بر اساس قوانین خاصی تشکیل شوند.\n    \n    هر دنباله با یک عدد داده شده 'n' شروع می‌شود و یک عدد جدید می‌تواند به دنباله اضافه شود\n    اگر یک عدد صحیح مثبت باشد و بیشتر از نصف عدد آخر در دنباله نباشد. این\n    تابع از بهینه‌سازی برای ذخیره نتایج محاسبه‌شده قبلی برای بهبود عملکرد استفاده می‌کند.\n    \n    آرگومان‌ها:\n        n (int): عدد شروع دنباله.\n        last (int): آخرین عدد در دنباله فعلی.\n        memo (dict): یک دیکشنری که برای بهینه‌سازی استفاده می‌شود و تعداد دنباله‌های معتبر\n                     برای هر مقدار 'last' که با آن مواجه شده است را ذخیره می‌کند.\n    \n    بازگشت:\n        int: تعداد کل دنباله‌های معتبری که می‌توانند با 'n' شروع شوند.\n    \n    مثال‌ها:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\""}, "canonical_solution": "    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count", "instruction": {"en": "Write a python function 'def count_sequences(n: int, last: int, memo: dict) -> int:' to solve the following problem:\n\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    ", "sq": "Shkruani një funksion python 'def count_sequences(n: int, last: int, memo: dict) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin e sekuencave të vlefshme që mund të formohen sipas rregullave specifike.\n    \n    Çdo sekuencë fillon me një numër të dhënë 'n', dhe një numër i ri mund të shtohet në sekuencë\n    nëse është një numër i plotë pozitiv dhe jo më i madh se gjysma e numrit të fundit në sekuencë. Ky\n    funksion përdor memoizimin për të ruajtur rezultatet e llogaritura më parë për të optimizuar performancën.\n    \n    Args:\n        n (int): Numri fillestar i sekuencës.\n        last (int): Numri i fundit në sekuencën aktuale.\n        memo (dict): Një fjalor i përdorur për memoizim, duke ruajtur numrin e sekuencave të vlefshme\n                     për çdo vlerë 'last' të hasur.\n    \n    Kthen:\n        int: Numri total i sekuencave të vlefshme që mund të formohen duke filluar me 'n'.\n    \n    Shembuj:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "hy": "Պայթոն ֆունկցիա 'def count_sequences(n: int, last: int, memo: dict) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք վավեր հաջորդականությունների քանակը, որոնք կարող են կազմվել հատուկ կանոնների համաձայն:\n    \n    Յուրաքանչյուր հաջորդականություն սկսվում է տրված 'n' թվից, և նոր թիվ կարող է ավելացվել հաջորդականությանը,\n    եթե այն դրական ամբողջ թիվ է և չի գերազանցում հաջորդականության վերջին թվի կեսը: Այս \n    ֆունկցիան օգտագործում է հիշողություն՝ պահպանելու համար նախապես հաշվարկված արդյունքները՝ \n    օպտիմալացնելու կատարողականությունը:\n    \n    Արգումենտներ:\n        n (int): Հաջորդականության մեկնարկային թիվը:\n        last (int): Ընթացիկ հաջորդականության վերջին թիվը:\n        memo (dict): Բառարան, որը օգտագործվում է հիշողության համար, պահպանում է վավեր հաջորդականությունների \n                     քանակը յուրաքանչյուր հանդիպած 'last' արժեքի համար:\n    \n    Վերադարձնում է:\n        int: Վավեր հաջորդականությունների ընդհանուր քանակը, որոնք կարող են կազմվել 'n'-ով սկսած:\n    \n    Օրինակներ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "bn": "একটি পাইথন ফাংশন 'def count_sequences(n: int, last: int, memo: dict) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    নির্দিষ্ট নিয়ম অনুযায়ী গঠিত বৈধ ক্রমগুলির সংখ্যা গণনা করুন।\n    \n    প্রতিটি ক্রম একটি প্রদত্ত সংখ্যা 'n' দিয়ে শুরু হয়, এবং একটি নতুন সংখ্যা ক্রমে যোগ করা যেতে পারে\n    যদি এটি একটি ধনাত্মক পূর্ণসংখ্যা হয় এবং ক্রমের শেষ সংখ্যার অর্ধেকের বেশি না হয়। এই\n    ফাংশনটি মেমোইজেশন ব্যবহার করে পূর্বে গণনা করা ফলাফল সংরক্ষণ করতে, যা কর্মক্ষমতা উন্নত করে।\n    \n    আর্গুমেন্টস:\n        n (int): ক্রমের শুরু সংখ্যা।\n        last (int): বর্তমান ক্রমের শেষ সংখ্যা।\n        memo (dict): মেমোইজেশনের জন্য ব্যবহৃত একটি ডিকশনারি, প্রতিটি 'last' মানের জন্য বৈধ ক্রমের সংখ্যা\n                     সংরক্ষণ করে।\n    \n    রিটার্নস:\n        int: 'n' দিয়ে শুরু করে গঠিত হতে পারে এমন বৈধ ক্রমগুলির মোট সংখ্যা।\n    \n    উদাহরণ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "bg": "Напишете функция на Python 'def count_sequences(n: int, last: int, memo: dict) -> int:' за решаване на следния проблем:\n\n    Изчислете броя на валидните последователности, които могат да бъдат формирани според специфични правила.\n    \n    Всяка последователност започва с дадено число 'n', и ново число може да бъде добавено към последователността,\n    ако е положително цяло число и не е по-голямо от половината на последното число в последователността. Тази\n    функция използва мемоизация за съхранение на предварително изчислени резултати с цел оптимизация на производителността.\n    \n    Аргументи:\n        n (int): Началното число на последователността.\n        last (int): Последното число в текущата последователност.\n        memo (dict): Речник, използван за мемоизация, съхраняващ броя на валидните последователности\n                     за всяка срещната стойност на 'last'.\n    \n    Връща:\n        int: Общият брой на валидните последователности, които могат да бъдат формирани, започвайки с 'n'.\n    \n    Примери:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "zh": "编写一个 python 函数 'def count_sequences(n: int, last: int, memo: dict) -> int:' 来解决以下问题：\n\n    计算可以根据特定规则形成的有效序列的数量。\n    \n    每个序列以给定数字 'n' 开始，如果新数字是正整数且不大于序列中最后一个数字的一半，则可以将其附加到序列中。此函数使用记忆化技术存储先前计算的结果以优化性能。\n    \n    参数:\n        n (int): 序列的起始数字。\n        last (int): 当前序列中的最后一个数字。\n        memo (dict): 用于记忆化的字典，存储每个遇到的 'last' 值的有效序列数量。\n    \n    返回:\n        int: 可以以 'n' 开始形成的有效序列的总数。\n    \n    示例:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "fr": "Écrivez une fonction python 'def count_sequences(n: int, last: int, memo: dict) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nombre de séquences valides qui peuvent être formées selon des règles spécifiques.\n    \n    Chaque séquence commence par un nombre donné 'n', et un nouveau nombre peut être ajouté à la séquence\n    s'il est un entier positif et n'est pas supérieur à la moitié du dernier nombre de la séquence. Cette\n    fonction utilise la mémoïsation pour stocker les résultats précédemment calculés afin d'optimiser les performances.\n    \n    Args:\n        n (int): Le nombre de départ de la séquence.\n        last (int): Le dernier nombre dans la séquence actuelle.\n        memo (dict): Un dictionnaire utilisé pour la mémoïsation, stockant le nombre de séquences valides\n                     pour chaque valeur 'last' rencontrée.\n    \n    Returns:\n        int: Le nombre total de séquences valides qui peuvent être formées en commençant par 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "de": "Schreiben Sie eine Python-Funktion 'def count_sequences(n: int, last: int, memo: dict) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die Anzahl der gültigen Sequenzen, die gemäß spezifischen Regeln gebildet werden können.\n    \n    Jede Sequenz beginnt mit einer gegebenen Zahl 'n', und eine neue Zahl kann an die Sequenz angehängt werden,\n    wenn sie eine positive ganze Zahl ist und nicht größer als die Hälfte der letzten Zahl in der Sequenz ist. Diese\n    Funktion verwendet Memoisierung, um zuvor berechnete Ergebnisse zu speichern und die Leistung zu optimieren.\n    \n    Argumente:\n        n (int): Die Startzahl der Sequenz.\n        last (int): Die letzte Zahl in der aktuellen Sequenz.\n        memo (dict): Ein Wörterbuch, das für die Memoisierung verwendet wird und die Anzahl der gültigen Sequenzen\n                     für jeden aufgetretenen 'last'-Wert speichert.\n    \n    Rückgabewert:\n        int: Die Gesamtanzahl der gültigen Sequenzen, die mit 'n' gebildet werden können.\n    \n    Beispiele:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "ha": "Rubuta aikin python 'def count_sequences(n: int, last: int, memo: dict) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa adadin jerin sahihai da za a iya samarwa bisa ga wasu ka'idoji.\n\n    Kowace jeri tana farawa da wata lamba 'n', kuma za a iya kara wata sabuwar lamba zuwa jerin\n    idan lamba ce mai kyau kuma ba ta fi rabin lambar karshe a jerin ba. Wannan\n    aikin yana amfani da memoization don adana sakamakon da aka lissafa a baya don inganta aiki.\n\n    Args:\n        n (int): Lambar farawa na jerin.\n        last (int): Lambar karshe a cikin jerin yanzu.\n        memo (dict): Kamus da ake amfani da shi don memoization, yana adana adadin jerin sahihai\n                     don kowane darajar 'last' da aka samu.\n\n    Returns:\n        int: Jimlar adadin jerin sahihai da za a iya samarwa farawa da 'n'.\n\n    Misalai:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "hi": "एक पायथन फ़ंक्शन 'def count_sequences(n: int, last: int, memo: dict) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    विशिष्ट नियमों के अनुसार बनाए जा सकने वाले वैध अनुक्रमों की संख्या की गणना करें।\n    \n    प्रत्येक अनुक्रम एक दिए गए संख्या 'n' से शुरू होता है, और अनुक्रम में एक नई संख्या जोड़ी जा सकती है\n    यदि यह एक धनात्मक पूर्णांक है और अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं है। यह\n    फ़ंक्शन पहले से गणना किए गए परिणामों को संग्रहीत करने के लिए स्मरणशक्ति का उपयोग करता है ताकि प्रदर्शन को अनुकूलित किया जा सके।\n    \n    तर्क:\n        n (int): अनुक्रम की प्रारंभिक संख्या।\n        last (int): वर्तमान अनुक्रम में अंतिम संख्या।\n        memo (dict): स्मरणशक्ति के लिए उपयोग किया जाने वाला शब्दकोश, प्रत्येक 'last' मान के लिए वैध अनुक्रमों की संख्या संग्रहीत करता है।\n    \n    लौटाता है:\n        int: 'n' से शुरू होकर बनाए जा सकने वाले कुल वैध अनुक्रमों की संख्या।\n    \n    उदाहरण:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "hu": "Írjon egy Python függvényt 'def count_sequences(n: int, last: int, memo: dict) -> int:' a következő probléma megoldására:\n\n    Számítsa ki az érvényes sorozatok számát, amelyek meghatározott szabályok szerint alakíthatók ki.\n    \n    Minden sorozat egy adott 'n' számmal kezdődik, és egy új szám hozzáadható a sorozathoz,\n    ha pozitív egész szám, és nem nagyobb, mint a sorozat utolsó számának fele. Ez a\n    függvény memoizációt használ a korábban kiszámított eredmények tárolására a teljesítmény optimalizálása érdekében.\n    \n    Paraméterek:\n        n (int): A sorozat kezdő száma.\n        last (int): Az aktuális sorozat utolsó száma.\n        memo (dict): Egy szótár, amelyet memoizációra használnak, tárolva az érvényes sorozatok számát\n                     minden egyes 'last' értékhez, amellyel találkoztak.\n    \n    Visszatér:\n        int: Az összes érvényes sorozat száma, amely 'n'-nel kezdődik.\n    \n    Példák:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "es": "Escribe una función en Python 'def count_sequences(n: int, last: int, memo: dict) -> int:' para resolver el siguiente problema:\n\n    Calcular el número de secuencias válidas que se pueden formar según reglas específicas.\n    \n    Cada secuencia comienza con un número dado 'n', y se puede añadir un nuevo número a la secuencia\n    si es un entero positivo y no es mayor que la mitad del último número en la secuencia. Esta\n    función utiliza memoización para almacenar resultados calculados previamente y optimizar el rendimiento.\n    \n    Argumentos:\n        n (int): El número inicial de la secuencia.\n        last (int): El último número en la secuencia actual.\n        memo (dict): Un diccionario usado para la memoización, almacenando el número de secuencias válidas\n                     para cada valor 'last' encontrado.\n    \n    Devuelve:\n        int: El número total de secuencias válidas que se pueden formar comenzando con 'n'.\n    \n    Ejemplos:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "arb": "اكتب دالة بايثون 'def count_sequences(n: int, last: int, memo: dict) -> int:' لحل المشكلة التالية:\n\n    احسب عدد التسلسلات الصالحة التي يمكن تشكيلها وفقًا لقواعد محددة.\n    \n    يبدأ كل تسلسل برقم معين 'n'، ويمكن إضافة رقم جديد إلى التسلسل\n    إذا كان عددًا صحيحًا موجبًا وليس أكبر من نصف الرقم الأخير في التسلسل. هذه\n    الدالة تستخدم التخزين المؤقت لتخزين النتائج المحسوبة سابقًا لتحسين الأداء.\n    \n    يعيدالحجج:\n        n (int): الرقم الابتدائي للتسلسل.\n        last (int): الرقم الأخير في التسلسل الحالي.\n        memo (dict): قاموس يستخدم للتخزين المؤقت، ويخزن عدد التسلسلات الصالحة\n                     لكل قيمة 'last' تم مواجهتها.\n    \n    يعيد:\n        int: العدد الإجمالي للتسلسلات الصالحة التي يمكن تشكيلها بدءًا من 'n'.\n    \n    أمثلة:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "sw": "Andika kazi ya python 'def count_sequences(n: int, last: int, memo: dict) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ya mlolongo halali ambao unaweza kuundwa kulingana na sheria maalum.\n    \n    Kila mlolongo huanza na nambari fulani 'n', na nambari mpya inaweza kuongezwa kwenye mlolongo\n    ikiwa ni nambari chanya na si kubwa zaidi ya nusu ya nambari ya mwisho katika mlolongo. Hii\n    kazi hutumia memoization kuhifadhi matokeo yaliyokokotolewa awali ili kuboresha utendaji.\n    \n    Vipengele:\n        n (int): Nambari ya kuanzia ya mlolongo.\n        last (int): Nambari ya mwisho katika mlolongo wa sasa.\n        memo (dict): Kamusi inayotumika kwa memoization, ikihifadhi idadi ya milolongo halali\n                     kwa kila thamani ya 'last' iliyokutana.\n    \n    Inarejesha:\n        int: Jumla ya idadi ya milolongo halali inayoweza kuundwa kuanzia na 'n'.\n    \n    Mifano:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "tr": "Bir python fonksiyonu 'def count_sequences(n: int, last: int, memo: dict) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Belirli kurallara göre oluşturulabilecek geçerli dizilerin sayısını hesaplayın.\n    \n    Her dizi verilen bir sayı 'n' ile başlar ve diziye yeni bir sayı eklenebilir\n    eğer pozitif bir tam sayıysa ve dizideki son sayının yarısından büyük değilse. Bu\n    fonksiyon, performansı optimize etmek için daha önce hesaplanan sonuçları saklamak amacıyla memoization kullanır.\n    \n    Argümanlar:\n        n (int): Dizinin başlangıç sayısı.\n        last (int): Mevcut dizideki son sayı.\n        memo (dict): Her karşılaşılan 'last' değeri için geçerli dizilerin sayısını saklayan\n                     memoization için kullanılan bir sözlük.\n    \n    Döndürür:\n        int: 'n' ile başlayan oluşturulabilecek toplam geçerli dizi sayısı.\n    \n    Örnekler:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "vi": "Viết một hàm python 'def count_sequences(n: int, last: int, memo: dict) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán số lượng dãy hợp lệ có thể được hình thành theo các quy tắc cụ thể.\n    \n    Mỗi dãy bắt đầu với một số cho trước 'n', và một số mới có thể được thêm vào dãy\n    nếu nó là số nguyên dương và không lớn hơn một nửa số cuối cùng trong dãy. Hàm này\n    sử dụng ghi nhớ để lưu trữ các kết quả đã tính toán trước đó nhằm tối ưu hóa hiệu suất.\n    \n    Tham số:\n        n (int): Số bắt đầu của dãy.\n        last (int): Số cuối cùng trong dãy hiện tại.\n        memo (dict): Một từ điển được sử dụng để ghi nhớ, lưu trữ số lượng dãy hợp lệ\n                     cho mỗi giá trị 'last' đã gặp.\n    \n    Trả về:\n        int: Tổng số dãy hợp lệ có thể được hình thành bắt đầu với 'n'.\n    \n    Ví dụ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "id": "Tulis fungsi python 'def count_sequences(n: int, last: int, memo: dict) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung jumlah urutan valid yang dapat dibentuk sesuai dengan aturan tertentu.\n    \n    Setiap urutan dimulai dengan angka 'n' yang diberikan, dan angka baru dapat ditambahkan ke urutan\n    jika itu adalah bilangan bulat positif dan tidak lebih besar dari setengah angka terakhir dalam urutan.\n    Fungsi ini menggunakan memoization untuk menyimpan hasil yang telah dihitung sebelumnya untuk mengoptimalkan kinerja.\n    \n    Argumen:\n        n (int): Angka awal dari urutan.\n        last (int): Angka terakhir dalam urutan saat ini.\n        memo (dict): Sebuah kamus yang digunakan untuk memoization, menyimpan jumlah urutan valid\n                     untuk setiap nilai 'last' yang ditemukan.\n    \n    Mengembalikan:\n        int: Jumlah total urutan valid yang dapat dibentuk dimulai dengan 'n'.\n    \n    Contoh:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "ja": "Python関数を書いてください。 'def count_sequences(n: int, last: int, memo: dict) -> int:' を次の問題を解くために作成してください:\n\n    特定のルールに従って形成できる有効なシーケンスの数を計算します。\n    \n    各シーケンスは与えられた数 'n' で始まり、シーケンスに新しい数を追加することができます。\n    ただし、それは正の整数であり、シーケンス内の最後の数の半分以下でなければなりません。この\n    関数はメモ化を使用して、以前に計算された結果を保存し、パフォーマンスを最適化します。\n    \n    引数:\n        n (int): シーケンスの開始数。\n        last (int): 現在のシーケンスの最後の数。\n        memo (dict): メモ化に使用される辞書で、遭遇した各 'last' 値に対する有効なシーケンスの数を保存します。\n    \n    戻り値:\n        int: 'n' から始まる有効なシーケンスの総数。\n    \n    例:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "ko": "다음 문제를 해결하기 위해 'def count_sequences(n: int, last: int, memo: dict) -> int:'라는 파이썬 함수를 작성하십시오:\n\n    특정 규칙에 따라 형성될 수 있는 유효한 시퀀스의 수를 계산합니다.\n    \n    각 시퀀스는 주어진 숫자 'n'으로 시작하며, 시퀀스에 새로운 숫자를 추가할 수 있는 경우는\n    양의 정수이고 시퀀스의 마지막 숫자의 절반을 넘지 않는 경우입니다. 이 함수는 메모이제이션을 사용하여\n    이전에 계산된 결과를 저장하여 성능을 최적화합니다.\n    \n    인수:\n        n (int): 시퀀스의 시작 숫자.\n        last (int): 현재 시퀀스의 마지막 숫자.\n        memo (dict): 메모이제이션에 사용되는 사전으로, 만난 각 'last' 값에 대한 유효한 시퀀스의 수를 저장합니다.\n    \n    반환:\n        int: 'n'으로 시작하는 형성 가능한 유효한 시퀀스의 총 수.\n    \n    예제:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "ml": "'def count_sequences(n: int, last: int, memo: dict) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    പ്രത്യേക നിയമങ്ങൾക്കനുസരിച്ച് രൂപപ്പെടുത്താവുന്ന സാധുവായ ക്രമങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n    \n    ഓരോ ക്രമവും ഒരു നൽകിയ നമ്പർ 'n' ഉപയോഗിച്ച് ആരംഭിക്കുന്നു, ക്രമത്തിൽ അവസാനിക്കുന്ന നമ്പറിന്റെ \n    പകുതിയേക്കാൾ കൂടുതലല്ലാത്ത പോസിറ്റീവ് ഇന്റിജർ ആണെങ്കിൽ മാത്രമേ ഒരു പുതിയ നമ്പർ ക്രമത്തിൽ ചേർക്കാൻ കഴിയൂ. \n    ഈ ഫംഗ്ഷൻ മെമ്മോയ്‌സേഷൻ ഉപയോഗിച്ച് മുമ്പ് കണക്കാക്കിയ ഫലങ്ങൾ സംഭരിച്ച് പ്രകടനം മെച്ചപ്പെടുത്തുന്നു.\n    \n    Args:\n        n (int): ക്രമത്തിന്റെ ആരംഭ നമ്പർ.\n        last (int): നിലവിലെ ക്രമത്തിൽ അവസാനിക്കുന്ന നമ്പർ.\n        memo (dict): മെമ്മോയ്‌സേഷനായി ഉപയോഗിക്കുന്ന ഒരു ഡിക്ഷണറി, \n                     നേരിടുന്ന ഓരോ 'last' മൂല്യത്തിനും സാധുവായ ക്രമങ്ങളുടെ എണ്ണം സംഭരിക്കുന്നു.\n    \n    Returns:\n        int: 'n' ഉപയോഗിച്ച് ആരംഭിക്കുന്ന സാധുവായ ക്രമങ്ങളുടെ മൊത്തം എണ്ണം.\n    \n    ഉദാഹരണങ്ങൾ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "fa": "یک تابع پایتون 'def count_sequences(n: int, last: int, memo: dict) -> int:' بنویسید تا مسئله زیر را حل کند:\n\n    تعداد دنباله‌های معتبر که می‌توانند بر اساس قوانین خاصی تشکیل شوند را محاسبه کنید.\n    \n    هر دنباله با یک عدد داده شده 'n' شروع می‌شود و یک عدد جدید می‌تواند به دنباله اضافه شود\n    اگر یک عدد صحیح مثبت باشد و بیشتر از نصف عدد آخر در دنباله نباشد. این\n    تابع از بهینه‌سازی استفاده می‌کند تا نتایج محاسبه شده قبلی را ذخیره کند و عملکرد را بهینه کند.\n    \n    آرگومان‌ها:\n        n (int): عدد شروع دنباله.\n        last (int): آخرین عدد در دنباله فعلی.\n        memo (dict): یک دیکشنری که برای بهینه‌سازی استفاده می‌شود و تعداد دنباله‌های معتبر\n                     برای هر مقدار 'last' که مشاهده شده را ذخیره می‌کند.\n    \n    بازگشت:\n        int: تعداد کل دنباله‌های معتبر که می‌توانند با 'n' شروع شوند.\n    \n    مثال‌ها:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6"}, "level": "easy", "test": "def test_count_sequences():\n    test_cases = [\n        (6, 6),\n        (1, 1),\n        (10, 14)\n    ]\n\n    for i, (n, expected) in enumerate(test_cases):\n        memo = {}\n        result = count_sequences(n, n, memo)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: n = {n}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_sequences()", "entry_point": "count_sequences", "signature": "def count_sequences(n: int, last: int, memo: dict) -> int:", "docstring": {"en": "\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    ", "sq": "\n    Llogarit numrin e sekuencave të vlefshme që mund të formohen sipas rregullave specifike.\n    \n    Çdo sekuencë fillon me një numër të dhënë 'n', dhe një numër i ri mund t'i shtohet sekuencës\n    nëse është një numër i plotë pozitiv dhe jo më i madh se gjysma e numrit të fundit në sekuencë. Kjo\n    funksion përdor memoizimin për të ruajtur rezultatet e llogaritura më parë për të optimizuar performancën.\n    \n    Args:\n        n (int): Numri fillestar i sekuencës.\n        last (int): Numri i fundit në sekuencën aktuale.\n        memo (dict): Një fjalor i përdorur për memoizim, që ruan numrin e sekuencave të vlefshme\n                     për çdo vlerë 'last' të hasur.\n    \n    Returns:\n        int: Numri total i sekuencave të vlefshme që mund të formohen duke filluar me 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "hy": "\n    Հաշվարկել վավեր հաջորդականությունների քանակը, որոնք կարող են ձևավորվել հատուկ կանոնների համաձայն։\n    \n    Յուրաքանչյուր հաջորդականություն սկսվում է տրված 'n' թվից, և նոր թիվը կարող է ավելացվել հաջորդականությանը,\n    եթե այն դրական ամբողջ թիվ է և չի գերազանցում հաջորդականության վերջին թվի կեսը։ Այս\n    ֆունկցիան օգտագործում է հիշողություն, որպեսզի պահպանի նախապես հաշվարկված արդյունքները՝ օպտիմալացնելու համար կատարողականությունը։\n    \n    Արգումենտներ:\n        n (int): Հաջորդականության մեկնարկային թիվը։\n        last (int): Ընթացիկ հաջորդականության վերջին թիվը։\n        memo (dict): Բառարան, որը օգտագործվում է հիշողության համար, պահելով վավեր հաջորդականությունների քանակը\n                     յուրաքանչյուր 'last' արժեքի համար, որը հանդիպել է։\n    \n    Վերադարձնում է:\n        int: Վավեր հաջորդականությունների ընդհանուր քանակը, որոնք կարող են ձևավորվել 'n'-ից սկսած։\n    \n    Օրինակներ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "bn": "\n    নির্দিষ্ট নিয়ম অনুযায়ী গঠিত হতে পারে এমন বৈধ ক্রমের সংখ্যা গণনা করুন।\n    \n    প্রতিটি ক্রম একটি প্রদত্ত সংখ্যা 'n' দিয়ে শুরু হয়, এবং একটি নতুন সংখ্যা ক্রমের সাথে যুক্ত করা যেতে পারে\n    যদি এটি একটি ধনাত্মক পূর্ণসংখ্যা হয় এবং ক্রমের শেষ সংখ্যার অর্ধেকের বেশি না হয়। এই\n    ফাংশনটি কর্মক্ষমতা উন্নত করার জন্য পূর্বে গণনা করা ফলাফল সংরক্ষণ করতে মেমোইজেশন ব্যবহার করে।\n    \n    Args:\n        n (int): ক্রমের শুরু সংখ্যা।\n        last (int): বর্তমান ক্রমের শেষ সংখ্যা।\n        memo (dict): মেমোইজেশনের জন্য ব্যবহৃত একটি অভিধান, প্রতিটি 'last' মানের জন্য\n                     বৈধ ক্রমের সংখ্যা সংরক্ষণ করে।\n    \n    Returns:\n        int: 'n' দিয়ে শুরু করে গঠিত হতে পারে এমন বৈধ ক্রমের মোট সংখ্যা।\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "bg": "\n    Изчислете броя на валидните последователности, които могат да бъдат формирани според специфични правила.\n    \n    Всяка последователност започва с дадено число 'n', и ново число може да бъде добавено към последователността,\n    ако е положително цяло число и не е по-голямо от половината на последното число в последователността. Тази\n    функция използва мемоизация, за да съхранява предварително изчислени резултати за оптимизиране на производителността.\n    \n    Аргументи:\n        n (int): Началното число на последователността.\n        last (int): Последното число в текущата последователност.\n        memo (dict): Речник, използван за мемоизация, съхраняващ броя на валидните последователности\n                     за всяка срещната стойност на 'last'.\n    \n    Връща:\n        int: Общият брой на валидните последователности, които могат да бъдат формирани, започвайки с 'n'.\n    \n    Примери:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "zh": "\n    计算可以根据特定规则形成的有效序列的数量。\n    \n    每个序列以给定数字 'n' 开始，如果一个新数字是正整数且不大于序列中最后一个数字的一半，则可以将其附加到序列中。\n    该函数使用记忆化技术存储先前计算的结果以优化性能。\n    \n    参数:\n        n (int): 序列的起始数字。\n        last (int): 当前序列中的最后一个数字。\n        memo (dict): 用于记忆化的字典，存储每个遇到的 'last' 值的有效序列数量。\n    \n    返回:\n        int: 可以从 'n' 开始形成的有效序列的总数。\n    \n    示例:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "fr": "\n    Calculer le nombre de séquences valides qui peuvent être formées selon des règles spécifiques.\n    \n    Chaque séquence commence par un nombre donné 'n', et un nouveau nombre peut être ajouté à la séquence\n    s'il s'agit d'un entier positif et qu'il n'est pas supérieur à la moitié du dernier nombre de la séquence. Cette\n    fonction utilise la mémoïsation pour stocker les résultats précédemment calculés afin d'optimiser les performances.\n    \n    Args:\n        n (int): Le nombre de départ de la séquence.\n        last (int): Le dernier nombre dans la séquence actuelle.\n        memo (dict): Un dictionnaire utilisé pour la mémoïsation, stockant le nombre de séquences valides\n                     pour chaque valeur 'last' rencontrée.\n    \n    Returns:\n        int: Le nombre total de séquences valides qui peuvent être formées en commençant par 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "de": "\n    Berechne die Anzahl der gültigen Sequenzen, die gemäß spezifischer Regeln gebildet werden können.\n    \n    Jede Sequenz beginnt mit einer gegebenen Zahl 'n', und eine neue Zahl kann an die Sequenz angehängt werden,\n    wenn sie eine positive ganze Zahl ist und nicht größer als die Hälfte der letzten Zahl in der Sequenz ist.\n    Diese Funktion verwendet Memoisierung, um zuvor berechnete Ergebnisse zu speichern und die Leistung zu optimieren.\n    \n    Args:\n        n (int): Die Startzahl der Sequenz.\n        last (int): Die letzte Zahl in der aktuellen Sequenz.\n        memo (dict): Ein Wörterbuch, das für die Memoisierung verwendet wird und die Anzahl der gültigen Sequenzen\n                     für jeden 'last'-Wert speichert, der aufgetreten ist.\n    \n    Returns:\n        int: Die Gesamtanzahl der gültigen Sequenzen, die mit 'n' gebildet werden können.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "ha": "\n    Lissafa adadin jerin abubuwan da za a iya samarwa bisa ga wasu ka'idoji.\n    \n    Kowace jeri tana farawa da wani adadi 'n', kuma za a iya kara sabon adadi zuwa jerin idan\n    yana da adadi mai kyau kuma ba ya fi rabin adadin ƙarshe a cikin jerin ba. Wannan aiki yana\n    amfani da memoization don adana sakamakon da aka lissafa a baya don inganta aiki.\n    \n    Args:\n        n (int): Adadin farawa na jerin.\n        last (int): Adadin ƙarshe a cikin jerin yanzu.\n        memo (dict): Kamus da ake amfani da shi don memoization, yana adana adadin jerin abubuwan\n                     da suka dace don kowane ƙimar 'last' da aka samu.\n    \n    Returns:\n        int: Jimlar adadin jerin abubuwan da za a iya samarwa farawa da 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "hi": "\n    विशिष्ट नियमों के अनुसार बनाई जा सकने वाली वैध अनुक्रमों की संख्या की गणना करें।\n    \n    प्रत्येक अनुक्रम एक दिए गए संख्या 'n' से शुरू होता है, और अनुक्रम में एक नई संख्या जोड़ी जा सकती है \n    यदि यह एक धनात्मक पूर्णांक है और अनुक्रम की अंतिम संख्या के आधे से अधिक नहीं है। यह \n    फ़ंक्शन प्रदर्शन को अनुकूलित करने के लिए पहले से गणना किए गए परिणामों को संग्रहीत करने के लिए मेमोइज़ेशन का उपयोग करता है।\n    \n    तर्क:\n        n (int): अनुक्रम की प्रारंभिक संख्या।\n        last (int): वर्तमान अनुक्रम में अंतिम संख्या।\n        memo (dict): मेमोइज़ेशन के लिए उपयोग किया जाने वाला एक शब्दकोश, प्रत्येक 'last' मान के लिए \n                     वैध अनुक्रमों की संख्या संग्रहीत करता है।\n    \n    वापसी:\n        int: 'n' से शुरू होने वाले वैध अनुक्रमों की कुल संख्या।\n    \n    उदाहरण:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "hu": "\n    Számítsa ki az érvényes sorozatok számát, amelyek meghatározott szabályok szerint képezhetők.\n    \n    Minden sorozat egy adott 'n' számmal kezdődik, és egy új szám hozzáadható a sorozathoz,\n    ha pozitív egész szám, és nem nagyobb, mint a sorozat utolsó számának fele. Ez a\n    függvény memoizációt használ az előzőleg kiszámított eredmények tárolására a teljesítmény optimalizálása érdekében.\n    \n    Paraméterek:\n        n (int): A sorozat kezdő száma.\n        last (int): Az aktuális sorozat utolsó száma.\n        memo (dict): Egy szótár, amelyet memoizációra használnak, és az érvényes sorozatok számát tárolja\n                     minden találkozott 'last' értékre.\n    \n    Visszatér:\n        int: Az összes érvényes sorozat száma, amely 'n'-nel kezdődik.\n    \n    Példák:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "es": "    Calcular el número de secuencias válidas que se pueden formar según reglas específicas.\n    \n    Cada secuencia comienza con un número dado 'n', y se puede agregar un nuevo número a la secuencia\n    si es un entero positivo y no es mayor que la mitad del último número en la secuencia. Esta\n    función utiliza memoización para almacenar resultados calculados previamente y optimizar el rendimiento.\n    \n    Argumentos:\n        n (int): El número inicial de la secuencia.\n        last (int): El último número en la secuencia actual.\n        memo (dict): Un diccionario utilizado para la memoización, almacenando el número de secuencias válidas\n                     para cada valor 'last' encontrado.\n    \n    Devuelve:\n        int: El número total de secuencias válidas que se pueden formar comenzando con 'n'.\n    \n    Ejemplos:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "arb": "    حساب عدد التسلسلات الصالحة التي يمكن تشكيلها وفقًا لقواعد محددة.\n    \n    يبدأ كل تسلسل برقم معين 'n'، ويمكن إضافة رقم جديد إلى التسلسل\n    إذا كان عددًا صحيحًا موجبًا ولا يزيد عن نصف الرقم الأخير في التسلسل. \n    تستخدم هذه الدالة التخزين المؤقت لتخزين النتائج المحسوبة سابقًا لتحسين الأداء.\n    \n    يعيدالحجج:\n        n (int): الرقم الذي يبدأ به التسلسل.\n        last (int): الرقم الأخير في التسلسل الحالي.\n        memo (dict): قاموس يستخدم للتخزين المؤقت، حيث يتم تخزين عدد التسلسلات الصالحة\n                     لكل قيمة 'last' تم مواجهتها.\n    \n    يعيد:\n        int: العدد الإجمالي للتسلسلات الصالحة التي يمكن تشكيلها بدءًا من 'n'.\n    \n    امثله:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "sw": "    Hesabu idadi ya mlolongo halali ambao unaweza kuundwa kulingana na sheria maalum.\n    \n    Kila mlolongo huanza na nambari fulani 'n', na nambari mpya inaweza kuongezwa kwenye mlolongo\n    ikiwa ni nambari nzima chanya na si kubwa kuliko nusu ya nambari ya mwisho kwenye mlolongo. \n    Kazi hii hutumia memoization kuhifadhi matokeo yaliyokokotolewa awali ili kuboresha utendaji.\n    \n    Hoja:\n        n (int): Nambari ya kuanzia ya mlolongo.\n        last (int): Nambari ya mwisho katika mlolongo wa sasa.\n        memo (dict): Kamusi inayotumika kwa memoization, ikihifadhi idadi ya milolongo halali\n                     kwa kila thamani ya 'last' iliyokutana.\n    \n    Inarejesha:\n        int: Jumla ya idadi ya milolongo halali inayoweza kuundwa kuanzia na 'n'.\n    \n    Mifano:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "tr": "    Belirli kurallara göre oluşturulabilecek geçerli dizilerin sayısını hesaplayın.\n    \n    Her dizi verilen bir sayı 'n' ile başlar ve dizinin son sayısının yarısından büyük olmayan\n    pozitif bir tamsayı ise diziye yeni bir sayı eklenebilir. Bu fonksiyon, performansı optimize\n    etmek için daha önce hesaplanmış sonuçları saklamak amacıyla memoization kullanır.\n    \n    Argümanlar:\n        n (int): Dizinin başlangıç sayısı.\n        last (int): Mevcut dizideki son sayı.\n        memo (dict): Her karşılaşılan 'last' değeri için geçerli dizilerin sayısını saklayan,\n                     memoization için kullanılan bir sözlük.\n    \n    Döndürür:\n        int: 'n' ile başlayan oluşturulabilecek toplam geçerli dizi sayısı.\n    \n    Örnekler:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "vi": "Tính toán số lượng dãy hợp lệ có thể được hình thành theo các quy tắc cụ thể.\n\nMỗi dãy bắt đầu với một số cho trước 'n', và một số mới có thể được thêm vào dãy nếu nó là một số nguyên dương và không lớn hơn một nửa số cuối cùng trong dãy. Hàm này sử dụng ghi nhớ để lưu trữ các kết quả đã tính toán trước đó nhằm tối ưu hóa hiệu suất.\n\nTham số:\n    n (int): Số bắt đầu của dãy.\n    last (int): Số cuối cùng trong dãy hiện tại.\n    memo (dict): Một từ điển được sử dụng để ghi nhớ, lưu trữ số lượng dãy hợp lệ cho mỗi giá trị 'last' đã gặp.\n\nTrả về:\n    int: Tổng số dãy hợp lệ có thể được hình thành bắt đầu với 'n'.\n\nVí dụ:\n    >>> count_sequences(1, 1, {})\n    1\n    >>> count_sequences(6, 6, {})\n    6", "id": "    Hitung jumlah urutan valid yang dapat dibentuk sesuai dengan aturan tertentu.\n    \n    Setiap urutan dimulai dengan angka 'n' yang diberikan, dan angka baru dapat ditambahkan ke urutan\n    jika itu adalah bilangan bulat positif dan tidak lebih besar dari setengah angka terakhir dalam urutan. \n    Fungsi ini menggunakan memoization untuk menyimpan hasil yang telah dihitung sebelumnya untuk mengoptimalkan kinerja.\n    \n    Args:\n        n (int): Angka awal dari urutan.\n        last (int): Angka terakhir dalam urutan saat ini.\n        memo (dict): Sebuah kamus yang digunakan untuk memoization, menyimpan jumlah urutan valid\n                     untuk setiap nilai 'last' yang ditemukan.\n    \n    Returns:\n        int: Jumlah total urutan valid yang dapat dibentuk dimulai dengan 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "ja": "    特定のルールに従って形成できる有効なシーケンスの数を計算します。\n    \n    各シーケンスは指定された数 'n' で始まり、シーケンスに新しい数を追加できるのは、\n    それが正の整数であり、シーケンス内の最後の数の半分以下である場合のみです。\n    この関数はメモ化を使用して、以前に計算された結果を保存し、パフォーマンスを最適化します。\n    \n    引数:\n        n (int): シーケンスの開始数。\n        last (int): 現在のシーケンスの最後の数。\n        memo (dict): メモ化に使用される辞書で、遭遇した各 'last' 値に対する有効なシーケンスの数を保存します。\n    \n    戻り値:\n        int: 'n' で始まる有効なシーケンスの総数。\n    \n    例:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "ko": "    특정 규칙에 따라 형성될 수 있는 유효한 시퀀스의 수를 계산합니다.\n    \n    각 시퀀스는 주어진 숫자 'n'으로 시작하며, 시퀀스에 새 숫자를 추가할 수 있는 조건은\n    양의 정수이고 시퀀스의 마지막 숫자의 절반을 넘지 않는 경우입니다. 이 함수는 성능을\n    최적화하기 위해 메모이제이션을 사용하여 이전에 계산된 결과를 저장합니다.\n    \n    인수:\n        n (int): 시퀀스의 시작 숫자.\n        last (int): 현재 시퀀스의 마지막 숫자.\n        memo (dict): 메모이제이션에 사용되는 사전으로, 만난 각 'last' 값에 대한 유효한 시퀀스의\n                     수를 저장합니다.\n    \n    반환:\n        int: 'n'으로 시작하는 형성 가능한 유효한 시퀀스의 총 수.\n    \n    예제:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "ml": "    പ്രത്യേക നിയമങ്ങൾ പ്രകാരം രൂപീകരിക്കാവുന്ന സാധുവായ അനുക്രമങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n    \n    ഓരോ അനുക്രമവും നൽകിയിരിക്കുന്ന സംഖ്യ 'n' ഉപയോഗിച്ച് ആരംഭിക്കുന്നു, കൂടാതെ ഒരു പുതിയ സംഖ്യ\n    അനുക്രമത്തിൽ ചേർക്കാൻ കഴിയും അത് ഒരു ധനാത്മക പൂർണ്ണസംഖ്യയും അനുക്രമത്തിലെ അവസാന സംഖ്യയുടെ\n    പകുതിയേക്കാൾ കൂടുതലല്ലാത്തതും ആണെങ്കിൽ. ഈ ഫംഗ്ഷൻ മെമ്മോയ്‌സേഷൻ ഉപയോഗിച്ച്\n    മുമ്പ് കണക്കാക്കിയ ഫലങ്ങൾ സംഭരിച്ച് പ്രകടനക്ഷമത മെച്ചപ്പെടുത്തുന്നു.\n    \n    Args:\n        n (int): അനുക്രമത്തിന്റെ ആരംഭ സംഖ്യ.\n        last (int): നിലവിലെ അനുക്രമത്തിലെ അവസാന സംഖ്യ.\n        memo (dict): മെമ്മോയ്‌സേഷനായി ഉപയോഗിക്കുന്ന ഒരു നിഘണ്ടു, ഓരോ 'last' മൂല്യത്തിനും\n                     നേരിടുന്ന സാധുവായ അനുക്രമങ്ങളുടെ എണ്ണം സംഭരിക്കുന്നു.\n    \n    Returns:\n        int: 'n' ഉപയോഗിച്ച് ആരംഭിക്കാവുന്ന മൊത്തം സാധുവായ അനുക്രമങ്ങളുടെ എണ്ണം.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6", "fa": "    محاسبه تعداد دنباله‌های معتبری که می‌توان بر اساس قوانین خاصی تشکیل داد.\n    \n    هر دنباله با یک عدد داده شده 'n' شروع می‌شود و یک عدد جدید می‌تواند به دنباله اضافه شود\n    اگر یک عدد صحیح مثبت باشد و از نصف عدد آخر در دنباله بزرگ‌تر نباشد. این\n    تابع از ذخیره‌سازی نتایج محاسبه‌شده قبلی برای بهینه‌سازی عملکرد استفاده می‌کند.\n    \n    آرگومان‌ها:\n        n (int): عدد شروع دنباله.\n        last (int): آخرین عدد در دنباله فعلی.\n        memo (dict): یک دیکشنری که برای ذخیره‌سازی نتایج محاسبه‌شده (memoization) استفاده می‌شود و\n                     تعداد دنباله‌های معتبر برای هر مقدار 'last' که مواجه شده را ذخیره می‌کند.\n    \n    بازگشت:\n        int: تعداد کل دنباله‌های معتبری که می‌توان با شروع از 'n' تشکیل داد.\n    \n    مثال‌ها:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6"}}
{"task_id": "Python/26", "prompt": {"en": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "sq": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Numëron numrin e çifteve të numrave të plotë pozitivë (P, Q) të tillë që P dhe Q kanë x0 si maksimumin e tyre të përbashkët \n    dhe y0 si minimumin e tyre të përbashkët.\n\n    Argumentet:\n    x0 (int): MCD që çdo çift (P, Q) duhet të ketë.\n    y0 (int): MCM që çdo çift (P, Q) duhet të ketë.\n\n    Kthen:\n    int: Numri i të gjitha çifteve të mundshme (P, Q) që plotësojnë kriteret e specifikuara.\n\n    Funksioni iteron nëpër të gjithë faktorët e mundshëm 'a' të kuotientit 'y0 / x0'. Për çdo faktor 'a',\n    llogarit faktorin përkatës 'b' të tillë që 'a * b = y0 / x0'. Pastaj kontrollon nëse 'a' dhe 'b'\n    janë bashkëkryesorë (MCD i tyre është 1) sepse P dhe Q mund të jenë vetëm shumëfish të 'x0' nga faktorë bashkëkryesorë për të ruajtur\n    MCD si 'x0'. Nëse 'a' dhe 'b' janë bashkëkryesorë, numri rritet me 1 nëse 'a' është i njëjtë me 'b',\n    përndryshe me 2 për të llogaritur të dy çiftet (P, Q) dhe (Q, P).\n\n    Shembuj të rasteve:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "hy": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Հաշվում է դրական ամբողջ թվերի զույգերի (P, Q) քանակը, այնպես որ P-ն և Q-ն ունեն x0 որպես իրենց ամենամեծ ընդհանուր բաժանարար (GCD)\n    և y0 որպես նրանց ամենափոքր ընդհանուր բազմապատիկ (LCM)։\n\n    Արգումենտներ:\n    x0 (int): GCD, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q)։\n    y0 (int): LCM, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q)։\n\n    Վերադարձնում է:\n    int: Բոլոր հնարավոր զույգերի (P, Q) քանակը, որոնք համապատասխանում են նշված չափանիշներին։\n\n    Ֆունկցիան անցնում է 'y0 / x0' բաժանման բոլոր հնարավոր գործոնների 'a'-ով։ Յուրաքանչյուր գործոնի 'a' համար,\n    այն հաշվարկում է համապատասխան գործոն 'b', այնպես որ 'a * b = y0 / x0'։ Այնուհետև ստուգում է, արդյոք 'a' և 'b'\n    համատեղելի են (նրանց GCD-ն 1 է), քանի որ P-ն և Q-ն կարող են լինել միայն 'x0'-ի բազմապատիկներ համատեղելի գործոններով,\n    որպեսզի պահպանեն GCD-ն որպես 'x0'։ Եթե 'a' և 'b' համատեղելի են, քանակը ավելացվում է 1-ով, եթե 'a'-ն նույնն է ինչ 'b',\n    այլապես 2-ով՝ հաշվի առնելով և՛ (P, Q), և՛ (Q, P) զույգերը։\n\n    Օրինակային դեպքեր:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "bn": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    কতগুলি ধনাত্মক পূর্ণসংখ্যার জোড়া (P, Q) রয়েছে তা গণনা করে যেখানে P এবং Q এর x0 তাদের গরিষ্ঠ সাধারণ বিভাজক (GCD) \n    এবং y0 তাদের লঘিষ্ঠ সাধারণ গুণিতক (LCM)।\n\n    আর্গুমেন্টস:\n    x0 (int): GCD যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n    y0 (int): LCM যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n\n    রিটার্নস:\n    int: সমস্ত সম্ভাব্য জোড়া (P, Q) এর সংখ্যা যা নির্দিষ্ট মানদণ্ড পূরণ করে।\n\n    ফাংশনটি y0 / x0 এর ভাগফলের সমস্ত সম্ভাব্য গুণিতক 'a' এর মাধ্যমে পুনরাবৃত্তি করে। প্রতিটি গুণিতক 'a' এর জন্য,\n    এটি সংশ্লিষ্ট গুণিতক 'b' গণনা করে যাতে 'a * b = y0 / x0' হয়। তারপর এটি পরীক্ষা করে যে 'a' এবং 'b'\n    সহমিলিত (তাদের GCD হল 1) কিনা কারণ P এবং Q শুধুমাত্র 'x0' এর গুণিতক হতে পারে সহমিলিত গুণিতক দ্বারা \n    GCD কে 'x0' হিসাবে বজায় রাখতে। যদি 'a' এবং 'b' সহমিলিত হয়, তাহলে গণনা 1 দ্বারা বৃদ্ধি পায় যদি 'a' এবং 'b' \n    একই হয়, অন্যথায় 2 দ্বারা বৃদ্ধি পায় উভয় (P, Q) এবং (Q, P) জোড়া গণনা করার জন্য।\n\n    উদাহরণ কেস:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "bg": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Брои броя на двойките положителни цели числа (P, Q), такива че P и Q имат x0 като техен най-голям общ делител (НОД)\n    и y0 като тяхно най-малко общо кратно (НОК).\n\n    Аргументи:\n    x0 (int): НОД, който всяка двойка (P, Q) трябва да има.\n    y0 (int): НОК, който всяка двойка (P, Q) трябва да има.\n\n    Връща:\n    int: Броят на всички възможни двойки (P, Q), които отговарят на зададените критерии.\n\n    Функцията преминава през всички възможни фактори 'a' на частното 'y0 / x0'. За всеки фактор 'a',\n    тя изчислява съответния фактор 'b', така че 'a * b = y0 / x0'. След това проверява дали 'a' и 'b'\n    са взаимно прости (техният НОД е 1), защото P и Q могат да бъдат само кратни на 'x0' чрез взаимно прости фактори, за да се запази\n    НОД като 'x0'. Ако 'a' и 'b' са взаимно прости, броят се увеличава с 1, ако 'a' е същото като 'b',\n    иначе с 2, за да се отчетат и двете двойки (P, Q) и (Q, P).\n\n    Примерни случаи:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "zh": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    计算正整数对 (P, Q) 的数量，使得 P 和 Q 的最大公约数 (GCD) 为 x0，最小公倍数 (LCM) 为 y0。\n\n    参数:\n    x0 (int): 每对 (P, Q) 必须具有的最大公约数。\n    y0 (int): 每对 (P, Q) 必须具有的最小公倍数。\n\n    返回:\n    int: 满足指定条件的所有可能对 (P, Q) 的数量。\n\n    该函数遍历商 'y0 / x0' 的所有可能因数 'a'。对于每个因数 'a'，计算对应的因数 'b'，使得 'a * b = y0 / x0'。\n    然后检查 'a' 和 'b' 是否互质（它们的 GCD 为 1），因为 P 和 Q 只能是 'x0' 的倍数，通过互质因数来保持\n    GCD 为 'x0'。如果 'a' 和 'b' 互质，计数增加 1，如果 'a' 与 'b' 相同，否则增加 2，以考虑 (P, Q) 和 (Q, P) 两种对。\n\n    示例案例:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "fr": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Compte le nombre de paires d'entiers positifs (P, Q) tels que P et Q aient x0 comme leur plus grand commun diviseur (PGCD)\n    et y0 comme leur plus petit commun multiple (PPCM).\n\n    Args:\n    x0 (int): Le PGCD que chaque paire (P, Q) doit avoir.\n    y0 (int): Le PPCM que chaque paire (P, Q) doit avoir.\n\n    Returns:\n    int: Le nombre de toutes les paires possibles (P, Q) qui répondent aux critères spécifiés.\n\n    La fonction itère à travers tous les facteurs possibles 'a' du quotient 'y0 / x0'. Pour chaque facteur 'a',\n    elle calcule le facteur correspondant 'b' tel que 'a * b = y0 / x0'. Elle vérifie ensuite si 'a' et 'b'\n    sont copremiers (leur PGCD est 1) car P et Q ne peuvent être que des multiples de 'x0' par des facteurs copremiers pour maintenir\n    le PGCD comme 'x0'. Si 'a' et 'b' sont copremiers, le compteur est incrémenté de 1 si 'a' est le même que 'b',\n    sinon de 2 pour tenir compte des paires (P, Q) et (Q, P).\n\n    Cas d'exemple:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "de": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Zählt die Anzahl der Paare positiver ganzer Zahlen (P, Q), sodass P und Q x0 als ihren größten gemeinsamen Teiler (GCD)\n    und y0 als ihr kleinstes gemeinsames Vielfaches (LCM) haben.\n\n    Argumente:\n    x0 (int): Der GCD, den jedes Paar (P, Q) haben muss.\n    y0 (int): Das LCM, das jedes Paar (P, Q) haben muss.\n\n    Rückgabewert:\n    int: Die Anzahl aller möglichen Paare (P, Q), die die angegebenen Kriterien erfüllen.\n\n    Die Funktion iteriert durch alle möglichen Faktoren 'a' des Quotienten 'y0 / x0'. Für jeden Faktor 'a'\n    berechnet sie den entsprechenden Faktor 'b', sodass 'a * b = y0 / x0'. Sie überprüft dann, ob 'a' und 'b'\n    teilerfremd sind (ihr GCD ist 1), da P und Q nur Vielfache von 'x0' durch teilerfremde Faktoren sein können,\n    um den GCD als 'x0' beizubehalten. Wenn 'a' und 'b' teilerfremd sind, wird der Zähler um 1 erhöht, wenn 'a'\n    gleich 'b' ist, andernfalls um 2, um sowohl (P, Q) als auch (Q, P) Paare zu berücksichtigen.\n\n    Beispiel Fälle:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "ha": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Yana ƙidaya adadin ma'aurata na lambobin kirki (P, Q) ta yadda P da Q suna da x0 a matsayin babbar mai raba su (GCD)\n    kuma y0 a matsayin ƙaramin mai haɗa su (LCM).\n\n    Args:\n    x0 (int): GCD da kowace ma'aurata (P, Q) dole ne su samu.\n    y0 (int): LCM da kowace ma'aurata (P, Q) dole ne su samu.\n\n    Returns:\n    int: Adadin dukkan ma'aurata masu yiwuwa (P, Q) da suka cika ka'idodin da aka bayyana.\n\n    Aikin yana zagayawa ta dukkan masu yiwuwa 'a' na rabo 'y0 / x0'. Ga kowane mai 'a',\n    yana ƙididdige mai daidai 'b' ta yadda 'a * b = y0 / x0'. Sannan yana duba idan 'a' da 'b'\n    suna da juna (GCD nasu shine 1) domin P da Q za su iya zama sau biyu na 'x0' ta hanyar masu da juna don kiyaye\n    GCD a matsayin 'x0'. Idan 'a' da 'b' suna da juna, ana ƙara ƙidaya da 1 idan 'a' daidai yake da 'b',\n    in ba haka ba da 2 don lissafin duka ma'aurata (P, Q) da (Q, P).\n\n    Misalan Hali:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "hi": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    उन युग्मों (P, Q) की संख्या गिनता है जिनके लिए P और Q का x0 उनका महत्तम समापवर्तक (GCD) है\n    और y0 उनका लघुत्तम समापवर्त्य (LCM) है।\n\n    Args:\n    x0 (int): वह GCD जो प्रत्येक युग्म (P, Q) के पास होना चाहिए।\n    y0 (int): वह LCM जो प्रत्येक युग्म (P, Q) के पास होना चाहिए।\n\n    Returns:\n    int: सभी संभावित युग्मों (P, Q) की संख्या जो निर्दिष्ट मानदंडों को पूरा करते हैं।\n\n    यह फ़ंक्शन 'y0 / x0' के भागफल के सभी संभावित गुणकों 'a' के माध्यम से पुनरावृत्ति करता है। प्रत्येक गुणक 'a' के लिए,\n    यह संबंधित गुणक 'b' की गणना करता है ताकि 'a * b = y0 / x0' हो। फिर यह जांचता है कि 'a' और 'b'\n    सह-प्राइम हैं या नहीं (उनका GCD 1 है) क्योंकि P और Q केवल 'x0' के गुणकों के सह-प्राइम गुणकों द्वारा ही हो सकते हैं\n    ताकि GCD 'x0' बना रहे। यदि 'a' और 'b' सह-प्राइम हैं, तो गिनती को 1 से बढ़ाया जाता है यदि 'a' और 'b' समान हैं,\n    अन्यथा 2 से बढ़ाया जाता है ताकि (P, Q) और (Q, P) दोनों युग्मों के लिए खाता हो।\n\n    उदाहरण मामले:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "hu": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Megszámolja azon pozitív egész szám párok (P, Q) számát, amelyekre P és Q legnagyobb közös osztója (GCD) x0,\n    és legkisebb közös többszöröse (LCM) y0.\n\n    Paraméterek:\n    x0 (int): Az a GCD, amelyet minden (P, Q) párnak tartalmaznia kell.\n    y0 (int): Az az LCM, amelyet minden (P, Q) párnak tartalmaznia kell.\n\n    Visszatér:\n    int: Az összes lehetséges (P, Q) pár száma, amelyek megfelelnek a megadott kritériumoknak.\n\n    A függvény végigmegy az összes lehetséges 'a' tényezőn, amely a 'y0 / x0' hányados tényezője. Minden 'a' tényezőhöz\n    kiszámítja a megfelelő 'b' tényezőt úgy, hogy 'a * b = y0 / x0'. Ezután ellenőrzi, hogy 'a' és 'b' relatív prímek-e\n    (azaz a GCD-jük 1), mert P és Q csak akkor lehetnek 'x0' többszörösei, ha relatív prím tényezőkkel rendelkeznek, hogy\n    a GCD 'x0' maradjon. Ha 'a' és 'b' relatív prímek, akkor a számlálót 1-gyel növeli, ha 'a' megegyezik 'b'-vel,\n    ellenkező esetben 2-vel, hogy mind a (P, Q), mind a (Q, P) párokat figyelembe vegye.\n\n    Példa esetek:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "es": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Cuenta el número de pares de enteros positivos (P, Q) tales que P y Q tienen x0 como su máximo común divisor (GCD)\n    y y0 como su mínimo común múltiplo (LCM).\n\n    Argumentos:\n    x0 (int): El GCD que cada par (P, Q) debe tener.\n    y0 (int): El LCM que cada par (P, Q) debe tener.\n\n    Devuelve:\n    int: La cuenta de todos los pares posibles (P, Q) que cumplen con los criterios especificados.\n\n    La función itera a través de todos los posibles factores 'a' del cociente 'y0 / x0'. Para cada factor 'a',\n    calcula el factor correspondiente 'b' tal que 'a * b = y0 / x0'. Luego verifica si 'a' y 'b'\n    son coprimos (su GCD es 1) porque P y Q solo pueden ser múltiplos de 'x0' por factores coprimos para mantener\n    el GCD como 'x0'. Si 'a' y 'b' son coprimos, la cuenta se incrementa en 1 si 'a' es igual a 'b',\n    de lo contrario en 2 para contar ambos pares (P, Q) y (Q, P).\n\n    Casos de Ejemplo:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "arb": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    يحسب عدد الأزواج من الأعداد الصحيحة الموجبة (P, Q) بحيث يكون P و Q لهما x0 كأكبر قاسم مشترك (GCD)\n    و y0 كأصغر مضاعف مشترك (LCM).\n\n    يعيدالحجج:\n    x0 (int): القاسم المشترك الأكبر الذي يجب أن يكون لكل زوج (P, Q).\n    y0 (int): المضاعف المشترك الأصغر الذي يجب أن يكون لكل زوج (P, Q).\n\n    يعيد:\n    int: عدد جميع الأزواج الممكنة (P, Q) التي تفي بالمعايير المحددة.\n\n    تقوم الدالة بتكرار جميع العوامل الممكنة 'a' للناتج 'y0 / x0'. لكل عامل 'a',\n    تحسب العامل المقابل 'b' بحيث يكون 'a * b = y0 / x0'. ثم تتحقق مما إذا كانت 'a' و 'b'\n    متوافقة (GCD لهما هو 1) لأن P و Q يمكن أن يكونا فقط مضاعفات 'x0' بواسطة عوامل متوافقة للحفاظ\n    على GCD كـ 'x0'. إذا كانت 'a' و 'b' متوافقة، يتم زيادة العد بمقدار 1 إذا كانت 'a' هي نفسها 'b',\n    وإلا بمقدار 2 لحساب كلا الزوجين (P, Q) و (Q, P).\n\n    حالات المثال:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "sw": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Inahesabu idadi ya jozi za nambari chanya (P, Q) ambapo P na Q zina x0 kama kipimo chao kikuu cha pamoja (GCD)\n    na y0 kama kinyume cha chini zaidi (LCM).\n\n    Hoja:\n    x0 (int): GCD ambayo kila jozi (P, Q) lazima iwe nayo.\n    y0 (int): LCM ambayo kila jozi (P, Q) lazima iwe nayo.\n\n    Inarejesha:\n    int: Hesabu ya jozi zote zinazowezekana (P, Q) zinazokidhi vigezo vilivyobainishwa.\n\n    Kazi hii inafanya mzunguko kupitia vigezo vyote vinavyowezekana 'a' vya mgawo 'y0 / x0'. Kwa kila kigezo 'a',\n    inahesabu kigezo kinacholingana 'b' ambapo 'a * b = y0 / x0'. Kisha inakagua kama 'a' na 'b'\n    ni huru (GCD yao ni 1) kwa sababu P na Q zinaweza tu kuwa vipimo vya 'x0' kwa vigezo huru ili kudumisha\n    GCD kama 'x0'. Ikiwa 'a' na 'b' ni huru, hesabu inaongezwa kwa 1 ikiwa 'a' ni sawa na 'b',\n    vinginevyo kwa 2 ili kuzingatia jozi zote mbili (P, Q) na (Q, P).\n\n    Mifano ya Kesi:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "tr": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    x0'u en büyük ortak bölenleri (EBOB) ve y0'u en küçük ortak katları (EKOK) olan pozitif tam sayı çiftlerinin (P, Q) sayısını sayar.\n\n    Argümanlar:\n    x0 (int): Her çiftin (P, Q) sahip olması gereken EBOB.\n    y0 (int): Her çiftin (P, Q) sahip olması gereken EKOK.\n\n    Döndürür:\n    int: Belirtilen kriterleri karşılayan tüm olası çiftlerin (P, Q) sayısı.\n\n    Fonksiyon, 'y0 / x0' bölümünün tüm olası 'a' çarpanlarını iteratif olarak kontrol eder. Her 'a' çarpanı için,\n    'a * b = y0 / x0' olacak şekilde karşılık gelen 'b' çarpanını hesaplar. Daha sonra 'a' ve 'b'nin\n    aralarında asal olup olmadığını (EBOB'ları 1 ise) kontrol eder çünkü P ve Q, EBOB'u 'x0' olarak korumak için\n    sadece aralarında asal çarpanlarla 'x0' katları olabilir. Eğer 'a' ve 'b' aralarında asal ise, 'a' ve 'b' aynıysa\n    sayım 1 artırılır, aksi takdirde hem (P, Q) hem de (Q, P) çiftlerini hesaba katmak için 2 artırılır.\n\n    Örnek Durumlar:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "vi": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Đếm số cặp số nguyên dương (P, Q) sao cho P và Q có x0 là ước số chung lớn nhất (GCD)\n    và y0 là bội số chung nhỏ nhất (LCM).\n\n    Tham số:\n    x0 (int): GCD mà mỗi cặp (P, Q) phải có.\n    y0 (int): LCM mà mỗi cặp (P, Q) phải có.\n\n    Trả về:\n    int: Số lượng tất cả các cặp (P, Q) có thể đáp ứng tiêu chí đã chỉ định.\n\n    Hàm duyệt qua tất cả các ước số 'a' có thể có của thương số 'y0 / x0'. Đối với mỗi ước số 'a',\n    nó tính toán ước số tương ứng 'b' sao cho 'a * b = y0 / x0'. Sau đó, nó kiểm tra xem 'a' và 'b'\n    có phải là số nguyên tố cùng nhau (GCD của chúng là 1) vì P và Q chỉ có thể là bội số của 'x0' bởi các ước số nguyên tố cùng nhau để duy trì\n    GCD là 'x0'. Nếu 'a' và 'b' là số nguyên tố cùng nhau, số đếm được tăng thêm 1 nếu 'a' giống như 'b',\n    nếu không thì tăng thêm 2 để tính cả cặp (P, Q) và (Q, P).\n\n    Ví dụ:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "id": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Menghitung jumlah pasangan bilangan bulat positif (P, Q) sedemikian rupa sehingga P dan Q memiliki x0 sebagai pembagi\n    terbesar (GCD) dan y0 sebagai kelipatan terkecil (LCM).\n\n    Argumen:\n    x0 (int): GCD yang harus dimiliki setiap pasangan (P, Q).\n    y0 (int): LCM yang harus dimiliki setiap pasangan (P, Q).\n\n    Mengembalikan:\n    int: Jumlah semua pasangan (P, Q) yang memenuhi kriteria yang ditentukan.\n\n    Fungsi ini mengiterasi melalui semua faktor yang mungkin 'a' dari hasil bagi 'y0 / x0'. Untuk setiap faktor 'a',\n    ia menghitung faktor yang sesuai 'b' sehingga 'a * b = y0 / x0'. Kemudian memeriksa apakah 'a' dan 'b'\n    adalah relatif prima (GCD mereka adalah 1) karena P dan Q hanya dapat berupa kelipatan dari 'x0' dengan faktor\n    relatif prima untuk menjaga GCD sebagai 'x0'. Jika 'a' dan 'b' adalah relatif prima, jumlahnya ditingkatkan\n    sebesar 1 jika 'a' sama dengan 'b', jika tidak, sebesar 2 untuk memperhitungkan pasangan (P, Q) dan (Q, P).\n\n    Contoh Kasus:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "ja": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    正の整数のペア (P, Q) の数を数えます。ここで、P と Q は x0 を最大公約数 (GCD) とし、\n    y0 を最小公倍数 (LCM) とします。\n\n    引数:\n    x0 (int): 各ペア (P, Q) が持つべき GCD。\n    y0 (int): 各ペア (P, Q) が持つべき LCM。\n\n    戻り値:\n    int: 指定された条件を満たすすべての可能なペア (P, Q) の数。\n\n    関数は商 'y0 / x0' のすべての可能な因数 'a' を反復処理します。各因数 'a' に対して、\n    対応する因数 'b' を計算し、'a * b = y0 / x0' となるようにします。その後、'a' と 'b' が\n    互いに素であるか（その GCD が 1 であるか）を確認します。P と Q は 'x0' の倍数でなければならず、\n    互いに素の因数によって GCD を 'x0' に保つ必要があるためです。もし 'a' と 'b' が互いに素であれば、\n    'a' が 'b' と同じ場合はカウントを 1 増やし、そうでなければ (P, Q) と (Q, P) の両方のペアを考慮して\n    2 増やします。\n\n    例:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "ko": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    양의 정수 쌍 (P, Q) 중에서 P와 Q가 x0을 최대 공약수(GCD)로 가지고 y0을 최소 공배수(LCM)로 가지는 쌍의 수를 계산합니다.\n\n    매개변수:\n    x0 (int): 각 쌍 (P, Q)이 가져야 하는 GCD.\n    y0 (int): 각 쌍 (P, Q)이 가져야 하는 LCM.\n\n    반환값:\n    int: 지정된 기준을 충족하는 모든 가능한 쌍 (P, Q)의 수.\n\n    함수는 'y0 / x0'의 모든 가능한 인수 'a'를 반복합니다. 각 인수 'a'에 대해 'a * b = y0 / x0'를 만족하는\n    대응 인수 'b'를 계산합니다. 그런 다음 'a'와 'b'가 서로소인지(GCD가 1인지) 확인합니다. P와 Q는 'x0'의\n    배수만이 될 수 있으며, 이는 GCD를 'x0'으로 유지하기 위해 서로소 인수로만 가능합니다. 만약 'a'와 'b'가\n    서로소라면, 'a'가 'b'와 같으면 1을, 그렇지 않으면 (P, Q)와 (Q, P) 쌍 모두를 고려하여 2를 더합니다.\n\n    예제 케이스:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "ml": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    (P, Q) എന്ന ദമ്പതികളുടെ എണ്ണം എണ്ണുന്നു, അവയ്ക്ക് x0 ഏറ്റവും വലിയ പൊതുഹരവും (GCD) y0 ഏറ്റവും ചെറിയ പൊതുഹരവും (LCM) ആകണം.\n\n    Args:\n    x0 (int): ഓരോ ദമ്പതിക്കും (P, Q) ഉണ്ടായിരിക്കേണ്ട GCD.\n    y0 (int): ഓരോ ദമ്പതിക്കും (P, Q) ഉണ്ടായിരിക്കേണ്ട LCM.\n\n    Returns:\n    int: നിശ്ചിത മാനദണ്ഡങ്ങൾ പാലിക്കുന്ന എല്ലാ സാധ്യതയുള്ള ദമ്പതികളുടെ (P, Q) എണ്ണം.\n\n    ഫംഗ്ഷൻ 'y0 / x0' എന്ന ഭാഗഫലത്തിന്റെ എല്ലാ സാധ്യതയുള്ള ഘടകങ്ങൾ 'a' എന്ന നിലയിൽ ആവർത്തിക്കുന്നു. ഓരോ ഘടകത്തിനും 'a',\n    'a * b = y0 / x0' എന്നതായുള്ള അനുബന്ധ ഘടകം 'b' കണക്കാക്കുന്നു. 'a'യും 'b'യും സഹഭാജകമാണോ എന്ന് പരിശോധിക്കുന്നു (അവയുടെ GCD 1 ആണ്) കാരണം P, Q\n    'x0' ന്റെ GCD നിലനിർത്താൻ സഹഭാജക ഘടകങ്ങളുടെ ഗുണിതങ്ങൾ മാത്രമേ ആയിരിക്കൂ. 'a'യും 'b'യും സഹഭാജകമാണെങ്കിൽ, 'a' 'b' എന്നതിനെ\n    പോലെ തന്നെയാണെങ്കിൽ എണ്ണം 1 ൽ കൂട്ടിച്ചേർക്കുന്നു, അല്ലെങ്കിൽ (P, Q)യും (Q, P) ദമ്പതികൾക്കും 2 ൽ കൂട്ടിച്ചേർക്കുന്നു.\n\n    ഉദാഹരണ കേസുകൾ:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"", "fa": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    تعداد زوج‌های اعداد صحیح مثبت (P, Q) را می‌شمارد به طوری که P و Q دارای x0 به عنوان بزرگترین مقسوم علیه مشترک (GCD) \n    و y0 به عنوان کوچکترین مضرب مشترک (LCM) باشند.\n\n    آرگومان‌ها:\n    x0 (int): GCD که هر زوج (P, Q) باید داشته باشد.\n    y0 (int): LCM که هر زوج (P, Q) باید داشته باشد.\n\n    بازگشت:\n    int: تعداد تمام زوج‌های ممکن (P, Q) که معیارهای مشخص شده را برآورده می‌کنند.\n\n    تابع از طریق تمام عوامل ممکن 'a' از خارج قسمت 'y0 / x0' تکرار می‌کند. برای هر عامل 'a'، عامل متناظر 'b' را محاسبه می‌کند\n    به طوری که 'a * b = y0 / x0'. سپس بررسی می‌کند که آیا 'a' و 'b' نسبت به هم اول هستند (GCD آنها 1 است) زیرا P و Q\n    فقط می‌توانند مضرب‌های 'x0' توسط عوامل نسبت به هم اول باشند تا GCD به عنوان 'x0' باقی بماند. اگر 'a' و 'b' نسبت به هم اول باشند،\n    شمارش به اندازه 1 افزایش می‌یابد اگر 'a' با 'b' برابر باشد، در غیر این صورت به اندازه 2 برای حساب کردن هر دو زوج (P, Q) و (Q, P) افزایش می‌یابد.\n\n    مثال‌ها:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\""}, "canonical_solution": "    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count", "instruction": {"en": "Write a python function 'def count_coprime_pairs(x0: int, y0: int) -> int:' to solve the following problem:\n\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    ", "sq": "Shkruani një funksion python 'def count_coprime_pairs(x0: int, y0: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Numëron numrin e çifteve të numrave të plotë pozitivë (P, Q) të tillë që P dhe Q kanë x0 si pjesëtuesin më të madh të përbashkët (GCD)\n    dhe y0 si shumëfishin më të vogël të përbashkët (LCM).\n\n    Args:\n    x0 (int): GCD që çdo çift (P, Q) duhet të ketë.\n    y0 (int): LCM që çdo çift (P, Q) duhet të ketë.\n\n    Kthen:\n    int: Numri i të gjitha çifteve të mundshme (P, Q) që plotësojnë kriteret e specifikuara.\n\n    Funksioni iteron nëpër të gjithë faktorët e mundshëm 'a' të kuotientit 'y0 / x0'. Për çdo faktor 'a',\n    llogarit faktorin përkatës 'b' të tillë që 'a * b = y0 / x0'. Pastaj kontrollon nëse 'a' dhe 'b'\n    janë bashkë-prime (GCD i tyre është 1) sepse P dhe Q mund të jenë vetëm shumëfishë të 'x0' nga faktorët bashkë-prime për të ruajtur\n    GCD si 'x0'. Nëse 'a' dhe 'b' janë bashkë-prime, numri rritet me 1 nëse 'a' është i njëjtë me 'b',\n    përndryshe me 2 për të llogaritur të dy çiftet (P, Q) dhe (Q, P).\n\n    Shembuj Rastesh:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "hy": "Պայթոն ֆունկցիա 'def count_coprime_pairs(x0: int, y0: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվում է դրական ամբողջ թվերի զույգերի (P, Q) քանակը, այնպես որ P և Q ունեն x0 որպես իրենց ամենամեծ ընդհանուր բաժանարար (GCD)\n    և y0 որպես իրենց ամենափոքր ընդհանուր բազմապատիկ (LCM):\n\n    Արգումենտներ:\n    x0 (int): GCD, որը յուրաքանչյուր զույգ (P, Q) պետք է ունենա:\n    y0 (int): LCM, որը յուրաքանչյուր զույգ (P, Q) պետք է ունենա:\n\n    Վերադարձնում է:\n    int: Բոլոր հնարավոր զույգերի (P, Q) քանակը, որոնք համապատասխանում են նշված չափանիշներին:\n\n    Ֆունկցիան անցնում է 'y0 / x0' բաժանման բոլոր հնարավոր գործոններով 'a':ի։ Յուրաքանչյուր գործոնի 'a' համար,\n    այն հաշվարկում է համապատասխան գործոնը 'b', այնպես որ 'a * b = y0 / x0':ի։ Այնուհետև ստուգում է, արդյոք 'a' և 'b'\n    համապրիմ են (նրանց GCD-ն 1 է), քանի որ P և Q կարող են լինել միայն 'x0'-ի բազմապատիկներ համապրիմ գործոններով՝ պահպանելու համար\n    GCD-ն որպես 'x0':ի։ Եթե 'a' և 'b' համապրիմ են, հաշվարկը ավելացվում է 1-ով, եթե 'a' նույնն է 'b'-ի հետ,\n    այլապես 2-ով՝ հաշվի առնելով թե (P, Q), թե (Q, P) զույգերը:\n\n    Օրինակ դեպքեր:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "bn": "একটি পাইথন ফাংশন 'def count_coprime_pairs(x0: int, y0: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    ধনাত্মক পূর্ণসংখ্যার (P, Q) জোড়ার সংখ্যা গণনা করে যেখানে P এবং Q এর x0 তাদের সর্বাধিক সাধারণ বিভাজক (GCD) \n    এবং y0 তাদের লঘিষ্ঠ সাধারণ গুণিতক (LCM)।\n\n    Args:\n    x0 (int): GCD যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n    y0 (int): LCM যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n\n    Returns:\n    int: সমস্ত সম্ভাব্য জোড়া (P, Q) এর সংখ্যা যা নির্দিষ্ট মানদণ্ড পূরণ করে।\n\n    ফাংশনটি 'y0 / x0' এর সমস্ত সম্ভাব্য গুণক 'a' এর মাধ্যমে পুনরাবৃত্তি করে। প্রতিটি গুণক 'a' এর জন্য,\n    এটি সংশ্লিষ্ট গুণক 'b' গণনা করে যাতে 'a * b = y0 / x0' হয়। তারপর এটি পরীক্ষা করে যে 'a' এবং 'b'\n    সহমিলিত (তাদের GCD 1) কিনা কারণ P এবং Q শুধুমাত্র 'x0' এর গুণিতক হতে পারে সহমিলিত গুণকের মাধ্যমে GCD \n    'x0' বজায় রাখতে। যদি 'a' এবং 'b' সহমিলিত হয়, তাহলে গণনা 1 দ্বারা বৃদ্ধি পায় যদি 'a' এবং 'b' একই হয়,\n    অন্যথায় 2 দ্বারা বৃদ্ধি পায় যাতে উভয় (P, Q) এবং (Q, P) জোড়া গণনা করা হয়।\n\n    উদাহরণ কেস:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "bg": "Напишете Python функция 'def count_coprime_pairs(x0: int, y0: int) -> int:', за да решите следния проблем:\n\n    Брои броя на двойките положителни цели числа (P, Q), такива че P и Q имат x0 като техен най-голям общ делител (НОД)\n    и y0 като техен най-малък общ кратен (НОК).\n\n    Аргументи:\n    x0 (int): НОД, който всяка двойка (P, Q) трябва да има.\n    y0 (int): НОК, който всяка двойка (P, Q) трябва да има.\n\n    Връща:\n    int: Броят на всички възможни двойки (P, Q), които отговарят на зададените критерии.\n\n    Функцията преминава през всички възможни фактори 'a' на частното 'y0 / x0'. За всеки фактор 'a',\n    изчислява съответния фактор 'b', така че 'a * b = y0 / x0'. След това проверява дали 'a' и 'b'\n    са взаимно прости (техният НОД е 1), защото P и Q могат да бъдат само кратни на 'x0' чрез взаимно прости фактори, за да се запази\n    НОД като 'x0'. Ако 'a' и 'b' са взаимно прости, броят се увеличава с 1, ако 'a' е същото като 'b',\n    иначе с 2, за да се отчетат и двете двойки (P, Q) и (Q, P).\n\n    Примерни случаи:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "zh": "编写一个 Python 函数 'def count_coprime_pairs(x0: int, y0: int) -> int:' 来解决以下问题：\n\n    计算正整数对 (P, Q) 的数量，使得 P 和 Q 的最大公约数 (GCD) 为 x0，最小公倍数 (LCM) 为 y0。\n\n    参数:\n    x0 (int): 每对 (P, Q) 必须具有的 GCD。\n    y0 (int): 每对 (P, Q) 必须具有的 LCM。\n\n    返回:\n    int: 满足指定条件的所有可能的 (P, Q) 对的数量。\n\n    函数遍历商 'y0 / x0' 的所有可能因子 'a'。对于每个因子 'a'，\n    它计算相应的因子 'b'，使得 'a * b = y0 / x0'。然后检查 'a' 和 'b'\n    是否互质（它们的 GCD 为 1），因为 P 和 Q 只能是 'x0' 的互质因子的倍数，以保持\n    GCD 为 'x0'。如果 'a' 和 'b' 是互质的，计数增加 1 如果 'a' 等于 'b'，\n    否则增加 2 以考虑 (P, Q) 和 (Q, P) 对。\n\n    示例案例：\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "fr": "Écrivez une fonction python 'def count_coprime_pairs(x0: int, y0: int) -> int:' pour résoudre le problème suivant :\n\n    Compte le nombre de paires d'entiers positifs (P, Q) tels que P et Q ont x0 comme leur plus grand diviseur commun (PGCD)\n    et y0 comme leur plus petit commun multiple (PPCM).\n\n    Args:\n    x0 (int): Le PGCD que chaque paire (P, Q) doit avoir.\n    y0 (int): Le PPCM que chaque paire (P, Q) doit avoir.\n\n    Returns:\n    int: Le nombre de toutes les paires possibles (P, Q) qui répondent aux critères spécifiés.\n\n    La fonction itère à travers tous les facteurs possibles 'a' du quotient 'y0 / x0'. Pour chaque facteur 'a',\n    elle calcule le facteur correspondant 'b' tel que 'a * b = y0 / x0'. Elle vérifie ensuite si 'a' et 'b'\n    sont copremiers (leur PGCD est 1) car P et Q ne peuvent être que des multiples de 'x0' par des facteurs copremiers pour maintenir\n    le PGCD comme 'x0'. Si 'a' et 'b' sont copremiers, le compte est incrémenté de 1 si 'a' est le même que 'b',\n    sinon de 2 pour tenir compte des deux paires (P, Q) et (Q, P).\n\n    Cas d'exemple :\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "de": "Schreiben Sie eine Python-Funktion 'def count_coprime_pairs(x0: int, y0: int) -> int:', um das folgende Problem zu lösen:\n\n    Zählt die Anzahl der Paare positiver Ganzzahlen (P, Q), sodass P und Q x0 als ihren größten gemeinsamen Teiler (GCD)\n    und y0 als ihr kleinstes gemeinsames Vielfaches (LCM) haben.\n\n    Argumente:\n    x0 (int): Der GCD, den jedes Paar (P, Q) haben muss.\n    y0 (int): Das LCM, das jedes Paar (P, Q) haben muss.\n\n    Rückgabe:\n    int: Die Anzahl aller möglichen Paare (P, Q), die die angegebenen Kriterien erfüllen.\n\n    Die Funktion iteriert durch alle möglichen Faktoren 'a' des Quotienten 'y0 / x0'. Für jeden Faktor 'a'\n    berechnet sie den entsprechenden Faktor 'b', sodass 'a * b = y0 / x0'. Dann wird überprüft, ob 'a' und 'b'\n    teilerfremd sind (ihr GCD ist 1), da P und Q nur Vielfache von 'x0' durch teilerfremde Faktoren sein können, um\n    den GCD als 'x0' beizubehalten. Wenn 'a' und 'b' teilerfremd sind, wird der Zähler um 1 erhöht, wenn 'a' gleich 'b' ist,\n    andernfalls um 2, um sowohl die Paare (P, Q) als auch (Q, P) zu berücksichtigen.\n\n    Beispiel-Fälle:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "ha": "Rubuta wani aikin python 'def count_coprime_pairs(x0: int, y0: int) -> int:' don warware matsalar mai zuwa:\n\n    Yana ƙidaya adadin ma'aurata na lambobin integers masu kyau (P, Q) ta yadda P da Q suna da x0 a matsayin babbar mai raba su (GCD)\n    kuma y0 a matsayin ƙaramin ƙa'idar su (LCM).\n\n    Args:\n    x0 (int): GCD wanda kowace ma'aurata (P, Q) dole ne su kasance da shi.\n    y0 (int): LCM wanda kowace ma'aurata (P, Q) dole ne su kasance da shi.\n\n    Returns:\n    int: Adadin dukkan ma'aurata masu yiwuwa (P, Q) waɗanda suka cika ƙa'idodin da aka fayyace.\n\n    Aikin yana zagayawa ta dukkan yiwuwar abubuwan 'a' na rabo 'y0 / x0'. Ga kowane abu 'a',\n    yana ƙididdige abu mai dacewa 'b' ta yadda 'a * b = y0 / x0'. Sannan yana duba ko 'a' da 'b'\n    suna da juna (GCD ɗinsu shine 1) saboda P da Q na iya zama sau biyu na 'x0' kawai ta abubuwan da ba su da juna don kiyaye\n    GCD a matsayin 'x0'. Idan 'a' da 'b' suna da juna, ana ƙara ƙidaya da 1 idan 'a' daidai yake da 'b',\n    in ba haka ba da 2 don lissafin duka ma'aurata (P, Q) da (Q, P).\n\n    Misalan Hali:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "hi": "एक पायथन फ़ंक्शन 'def count_coprime_pairs(x0: int, y0: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    धनात्मक पूर्णांकों के जोड़ों (P, Q) की संख्या गिनें ताकि P और Q का x0 उनके महत्तम समापवर्तक (GCD) के रूप में हो\n    और y0 उनका लघुत्तम समापवर्त्य (LCM) हो।\n\n    तर्क:\n    x0 (int): वह GCD जो प्रत्येक जोड़े (P, Q) के पास होना चाहिए।\n    y0 (int): वह LCM जो प्रत्येक जोड़े (P, Q) के पास होना चाहिए।\n\n    लौटाता है:\n    int: सभी संभावित जोड़ों (P, Q) की गिनती जो निर्दिष्ट मानदंडों को पूरा करते हैं।\n\n    फ़ंक्शन सभी संभावित गुणनखंडों 'a' के माध्यम से y0 / x0 के भागफल की पुनरावृत्ति करता है। प्रत्येक गुणनखंड 'a' के लिए,\n    यह संबंधित गुणनखंड 'b' की गणना करता है ताकि 'a * b = y0 / x0' हो। फिर यह जांचता है कि 'a' और 'b'\n    सह-प्राइम हैं (उनका GCD 1 है) क्योंकि P और Q केवल सह-प्राइम गुणनखंडों द्वारा 'x0' के गुणज हो सकते हैं ताकि\n    GCD को 'x0' बनाए रखा जा सके। यदि 'a' और 'b' सह-प्राइम हैं, तो गिनती को 1 से बढ़ाया जाता है यदि 'a' 'b' के समान है,\n    अन्यथा 2 से बढ़ाया जाता है ताकि (P, Q) और (Q, P) दोनों जोड़ों को शामिल किया जा सके।\n\n    उदाहरण मामले:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "hu": "Írj egy python függvényt 'def count_coprime_pairs(x0: int, y0: int) -> int:' a következő probléma megoldására:\n\n    Számolja meg a pozitív egész számok (P, Q) párosainak számát úgy, hogy P és Q legnagyobb közös osztója (GCD) x0,\n    és legkisebb közös többszöröse (LCM) y0.\n\n    Argumentumok:\n    x0 (int): Az a GCD, amelyet minden (P, Q) párnak tartalmaznia kell.\n    y0 (int): Az az LCM, amelyet minden (P, Q) párnak tartalmaznia kell.\n\n    Visszatérési érték:\n    int: Az összes lehetséges (P, Q) pár száma, amely megfelel a megadott kritériumoknak.\n\n    A függvény végigmegy az összes lehetséges 'a' tényezőn a 'y0 / x0' hányados esetén. Minden 'a' tényezőhöz\n    kiszámítja a megfelelő 'b' tényezőt úgy, hogy 'a * b = y0 / x0'. Ezután ellenőrzi, hogy 'a' és 'b'\n    relatív prímek-e (GCD-jük 1), mert P és Q csak akkor lehetnek az 'x0' többszörösei, ha relatív prím tényezők,\n    hogy a GCD 'x0' maradjon. Ha 'a' és 'b' relatív prímek, a számlálót 1-gyel növeli, ha 'a' megegyezik 'b'-vel,\n    különben 2-vel, hogy mindkét (P, Q) és (Q, P) párt figyelembe vegye.\n\n    Példa esetek:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "es": "Escribe una función en Python 'def count_coprime_pairs(x0: int, y0: int) -> int:' para resolver el siguiente problema:\n\n    Cuenta el número de pares de enteros positivos (P, Q) tales que P y Q tienen x0 como su máximo común divisor (MCD)\n    y y0 como su mínimo común múltiplo (MCM).\n\n    Argumentos:\n    x0 (int): El MCD que cada par (P, Q) debe tener.\n    y0 (int): El MCM que cada par (P, Q) debe tener.\n\n    Devuelve:\n    int: La cuenta de todos los posibles pares (P, Q) que cumplen con los criterios especificados.\n\n    La función itera a través de todos los posibles factores 'a' del cociente 'y0 / x0'. Para cada factor 'a',\n    calcula el factor correspondiente 'b' tal que 'a * b = y0 / x0'. Luego verifica si 'a' y 'b'\n    son coprimos (su MCD es 1) porque P y Q solo pueden ser múltiplos de 'x0' por factores coprimos para mantener\n    el MCD como 'x0'. Si 'a' y 'b' son coprimos, la cuenta se incrementa en 1 si 'a' es igual a 'b',\n    de lo contrario en 2 para contar ambos pares (P, Q) y (Q, P).\n\n    Casos de Ejemplo:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "arb": "اكتب دالة بايثون 'def count_coprime_pairs(x0: int, y0: int) -> int:' لحل المشكلة التالية:\n\n    تحسب عدد الأزواج من الأعداد الصحيحة الموجبة (P, Q) بحيث يكون P و Q لهما x0 كأكبر قاسم مشترك (GCD)\n    و y0 كأصغر مضاعف مشترك (LCM).\n\n    يعيدالحجج:\n    x0 (int): القاسم المشترك الأكبر الذي يجب أن يكون لكل زوج (P, Q).\n    y0 (int): المضاعف المشترك الأصغر الذي يجب أن يكون لكل زوج (P, Q).\n\n    يعيد:\n    int: عدد جميع الأزواج الممكنة (P, Q) التي تفي بالمعايير المحددة.\n\n    تقوم الدالة بتكرار جميع العوامل الممكنة 'a' للناتج 'y0 / x0'. لكل عامل 'a',\n    تحسب العامل المقابل 'b' بحيث 'a * b = y0 / x0'. ثم تتحقق مما إذا كانت 'a' و 'b'\n    متوافقة (القاسم المشترك الأكبر لهما هو 1) لأن P و Q يمكن أن يكونا فقط مضاعفات 'x0' بعوامل متوافقة للحفاظ\n    على القاسم المشترك الأكبر كـ 'x0'. إذا كانت 'a' و 'b' متوافقة، يتم زيادة العد بمقدار 1 إذا كانت 'a' هي نفسها 'b',\n    وإلا بمقدار 2 لحساب كلا الزوجين (P, Q) و (Q, P).\n\n    حالات المثال:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "sw": "Andika kazi ya python 'def count_coprime_pairs(x0: int, y0: int) -> int:' kutatua tatizo lifuatalo:\n\n    Inahesabu idadi ya jozi za nambari nzima chanya (P, Q) ambapo P na Q zina x0 kama kigezo chao kikuu cha mgawanyiko (GCD)\n    na y0 kama kigezo chao kidogo cha kuzidisha (LCM).\n\n    Hoja:\n    x0 (int): GCD ambayo kila jozi (P, Q) lazima iwe nayo.\n    y0 (int): LCM ambayo kila jozi (P, Q) lazima iwe nayo.\n\n    Inarejesha:\n    int: Hesabu ya jozi zote zinazowezekana (P, Q) zinazokidhi vigezo vilivyotajwa.\n\n    Kazi hii inarudia kupitia vigezo vyote vinavyowezekana 'a' vya sehemu 'y0 / x0'. Kwa kila kigezo 'a',\n    inahesabu kigezo kinacholingana 'b' ambapo 'a * b = y0 / x0'. Kisha inakagua kama 'a' na 'b'\n    ni co-prime (GCD yao ni 1) kwa sababu P na Q zinaweza tu kuwa vizidisho vya 'x0' kwa vigezo vya co-prime ili kudumisha\n    GCD kama 'x0'. Ikiwa 'a' na 'b' ni co-prime, hesabu inaongezwa kwa 1 ikiwa 'a' ni sawa na 'b',\n    vinginevyo kwa 2 ili kuzingatia jozi zote mbili (P, Q) na (Q, P).\n\n    Mifano ya Matukio:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "tr": "Bir python fonksiyonu 'def count_coprime_pairs(x0: int, y0: int) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Pozitif tam sayı çiftlerinin (P, Q) sayısını sayar, öyle ki P ve Q'nun en büyük ortak böleni (GCD) x0 ve en küçük ortak katı (LCM) y0'dır.\n\n    Argümanlar:\n    x0 (int): Her çiftin (P, Q) sahip olması gereken GCD.\n    y0 (int): Her çiftin (P, Q) sahip olması gereken LCM.\n\n    Döndürür:\n    int: Belirtilen kriterleri karşılayan tüm olası çiftlerin (P, Q) sayısı.\n\n    Fonksiyon, 'y0 / x0' bölümünün tüm olası çarpanları 'a' üzerinden iterasyon yapar. Her çarpan 'a' için,\n    'a * b = y0 / x0' olacak şekilde karşılık gelen çarpan 'b'yi hesaplar. Daha sonra 'a' ve 'b'nin\n    aralarında asal (GCD'leri 1) olup olmadığını kontrol eder çünkü P ve Q, GCD'yi 'x0' olarak korumak için\n    yalnızca 'x0'ın çarpanları ile aralarında asal olabilir. Eğer 'a' ve 'b' aralarında asal ise, 'a' ve 'b'\n    aynıysa sayım 1 artırılır, aksi takdirde hem (P, Q) hem de (Q, P) çiftlerini hesaba katmak için 2 artırılır.\n\n    Örnek Durumlar:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "vi": "Viết một hàm python 'def count_coprime_pairs(x0: int, y0: int) -> int:' để giải quyết vấn đề sau:\n\n    Đếm số lượng cặp số nguyên dương (P, Q) sao cho P và Q có x0 là ước số chung lớn nhất (GCD)\n    và y0 là bội số chung nhỏ nhất (LCM).\n\n    Tham số:\n    x0 (int): GCD mà mỗi cặp (P, Q) phải có.\n    y0 (int): LCM mà mỗi cặp (P, Q) phải có.\n\n    Trả về:\n    int: Số lượng tất cả các cặp (P, Q) có thể đáp ứng tiêu chí đã chỉ định.\n\n    Hàm lặp qua tất cả các ước số 'a' có thể có của thương số 'y0 / x0'. Đối với mỗi ước số 'a',\n    nó tính toán ước số tương ứng 'b' sao cho 'a * b = y0 / x0'. Sau đó, nó kiểm tra nếu 'a' và 'b'\n    là các số nguyên tố cùng nhau (GCD của chúng là 1) vì P và Q chỉ có thể là bội số của 'x0' bởi các ước số nguyên tố cùng nhau để duy trì\n    GCD là 'x0'. Nếu 'a' và 'b' là các số nguyên tố cùng nhau, số đếm được tăng thêm 1 nếu 'a' giống 'b',\n    nếu không thì tăng thêm 2 để tính cả cặp (P, Q) và (Q, P).\n\n    Ví dụ:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "id": "Tulis sebuah fungsi python 'def count_coprime_pairs(x0: int, y0: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Menghitung jumlah pasangan bilangan bulat positif (P, Q) sedemikian rupa sehingga P dan Q memiliki x0 sebagai pembagi terbesar (GCD)\n    dan y0 sebagai kelipatan terkecil (LCM).\n\n    Argumen:\n    x0 (int): GCD yang harus dimiliki setiap pasangan (P, Q).\n    y0 (int): LCM yang harus dimiliki setiap pasangan (P, Q).\n\n    Mengembalikan:\n    int: Jumlah semua pasangan (P, Q) yang memenuhi kriteria yang ditentukan.\n\n    Fungsi ini mengiterasi melalui semua faktor 'a' yang mungkin dari hasil bagi 'y0 / x0'. Untuk setiap faktor 'a',\n    ia menghitung faktor yang sesuai 'b' sehingga 'a * b = y0 / x0'. Kemudian memeriksa apakah 'a' dan 'b'\n    adalah coprime (GCD mereka adalah 1) karena P dan Q hanya dapat menjadi kelipatan dari 'x0' dengan faktor coprime untuk mempertahankan\n    GCD sebagai 'x0'. Jika 'a' dan 'b' adalah coprime, hitungan ditingkatkan sebesar 1 jika 'a' sama dengan 'b',\n    jika tidak, ditingkatkan sebesar 2 untuk memperhitungkan pasangan (P, Q) dan (Q, P).\n\n    Contoh Kasus:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "ja": "Python関数 'def count_coprime_pairs(x0: int, y0: int) -> int:' を作成して、次の問題を解決してください:\n\n    正の整数のペア (P, Q) の数を数えます。ここで、P と Q は x0 を最大公約数 (GCD) とし、\n    y0 を最小公倍数 (LCM) とします。\n\n    引数:\n    x0 (int): 各ペア (P, Q) が持つべき GCD。\n    y0 (int): 各ペア (P, Q) が持つべき LCM。\n\n    戻り値:\n    int: 指定された条件を満たすすべての可能なペア (P, Q) の数。\n\n    関数は商 'y0 / x0' のすべての可能な因子 'a' を反復処理します。各因子 'a' に対して、\n    対応する因子 'b' を計算し、'a * b = y0 / x0' となるようにします。その後、'a' と 'b' が\n    互いに素（その GCD が 1）であるかどうかを確認します。P と Q は 'x0' の倍数である必要があり、\n    互いに素の因子によって GCD を 'x0' に保つためです。もし 'a' と 'b' が互いに素であれば、\n    'a' が 'b' と同じ場合はカウントを 1 増やし、そうでない場合は (P, Q) と (Q, P) の両方のペアを\n    考慮して 2 増やします。\n\n    例:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "ko": "다음 문제를 해결하기 위해 파이썬 함수를 작성하세요 'def count_coprime_pairs(x0: int, y0: int) -> int:':\n\n    양의 정수 쌍 (P, Q)의 개수를 세는데, 여기서 P와 Q는 x0을 최대공약수(GCD)로, y0을 최소공배수(LCM)로 가집니다.\n\n    매개변수:\n    x0 (int): 각 쌍 (P, Q)이 가져야 하는 GCD.\n    y0 (int): 각 쌍 (P, Q)이 가져야 하는 LCM.\n\n    반환값:\n    int: 지정된 조건을 만족하는 모든 가능한 쌍 (P, Q)의 개수.\n\n    함수는 몫 'y0 / x0'의 모든 가능한 인수 'a'를 반복합니다. 각 인수 'a'에 대해,\n    'a * b = y0 / x0'를 만족하는 대응 인수 'b'를 계산합니다. 그런 다음 'a'와 'b'가 서로소인지\n    (그들의 GCD가 1인지) 확인합니다. P와 Q는 'x0'의 배수로만 구성될 수 있으며, 이는 GCD를 'x0'으로 유지하기 위해\n    서로소 인수로 구성되어야 합니다. 만약 'a'와 'b'가 서로소라면, 'a'가 'b'와 같으면 카운트를 1 증가시키고,\n    그렇지 않으면 (P, Q)와 (Q, P) 쌍을 모두 고려하여 2를 증가시킵니다.\n\n    예제 케이스:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "ml": "ഒരു പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക 'def count_coprime_pairs(x0: int, y0: int) -> int:' ഈ പ്രശ്നം പരിഹരിക്കാൻ:\n\n    x0 ആണ് അവരുടെ ഏറ്റവും വലിയ പൊതുഹരവും (GCD) y0 ആണ് അവരുടെ ഏറ്റവും ചെറിയ പൊതുമപവും (LCM) ആയ\n    (P, Q) എന്ന പോസിറ്റീവ് ഇന്റീജർ ജോഡികളുടെ എണ്ണം എണ്ണുന്നു.\n\n    Args:\n    x0 (int): ഓരോ ജോഡിക്കും (P, Q) ഉണ്ടായിരിക്കേണ്ട GCD.\n    y0 (int): ഓരോ ജോഡിക്കും (P, Q) ഉണ്ടായിരിക്കേണ്ട LCM.\n\n    Returns:\n    int: വ്യക്തമാക്കിയ മാനദണ്ഡങ്ങൾ പാലിക്കുന്ന എല്ലാ സാധ്യതയുള്ള ജോഡികളുടെ എണ്ണം.\n\n    ഫംഗ്ഷൻ 'y0 / x0' എന്ന ഭാഗഫലത്തിന്റെ എല്ലാ സാധ്യതയുള്ള ഘടകങ്ങളായ 'a' യിലൂടെ ആവർത്തിക്കുന്നു. ഓരോ ഘടകത്തിനും 'a',\n    'a * b = y0 / x0' എന്നതായുള്ള അനുബന്ധ ഘടകമായ 'b' കണക്കാക്കുന്നു. 'a'യും 'b'യും പരസ്പരം സഹഭാജ്യമാണോ (അവയുടെ GCD 1 ആണോ)\n    എന്ന് പരിശോധിക്കുന്നു, കാരണം P, Q എന്നിവ 'x0'യുടെ ഘടകങ്ങളായ 'a', 'b' എന്നിവയുടെ സഹഭാജ്യ ഘടകങ്ങളായിരിക്കണം GCD 'x0' ആയി\n    നിലനിർത്താൻ. 'a'യും 'b'യും പരസ്പരം സഹഭാജ്യമാണെങ്കിൽ, 'a' 'b'യുമായി തുല്യമായാൽ എണ്ണം 1 ൽ കൂട്ടിച്ചേർക്കുന്നു, അല്ലെങ്കിൽ\n    (P, Q) കൂടാതെ (Q, P) ജോഡികൾക്കും 2 ൽ കൂട്ടിച്ചേർക്കുന്നു.\n\n    ഉദാഹരണ കേസുകൾ:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "fa": "یک تابع پایتون 'def count_coprime_pairs(x0: int, y0: int) -> int:' بنویسید تا مسئله زیر را حل کند:\n\n    تعداد جفت‌های اعداد صحیح مثبت (P, Q) را بشمارد به طوری که P و Q دارای x0 به عنوان بزرگترین مقسوم‌علیه مشترک (GCD) \n    و y0 به عنوان کوچکترین مضرب مشترک (LCM) باشند.\n\n    آرگومان‌ها:\n    x0 (int): GCD که هر جفت (P, Q) باید داشته باشد.\n    y0 (int): LCM که هر جفت (P, Q) باید داشته باشد.\n\n    بازگشت:\n    int: تعداد تمام جفت‌های ممکن (P, Q) که معیارهای مشخص شده را برآورده می‌کنند.\n\n    تابع از تمام عوامل ممکن 'a' از خارج قسمت 'y0 / x0' عبور می‌کند. برای هر عامل 'a'، عامل متناظر 'b' را محاسبه می‌کند\n    به طوری که 'a * b = y0 / x0'. سپس بررسی می‌کند که آیا 'a' و 'b' نسبت به هم اول هستند (GCD آنها 1 است) زیرا P و Q\n    تنها می‌توانند مضرب‌های 'x0' توسط عوامل نسبت به هم اول باشند تا GCD به عنوان 'x0' باقی بماند. اگر 'a' و 'b' نسبت به هم اول باشند،\n    تعداد با 1 افزایش می‌یابد اگر 'a' همان 'b' باشد، در غیر این صورت با 2 افزایش می‌یابد تا برای هر دو جفت (P, Q) و (Q, P) حساب شود.\n\n    مثال‌ها:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0"}, "level": "easy", "test": "def test_count_coprime_pairs():\n    test_cases = [\n        (3, 60, 4),   # The example from the problem statement\n        (2, 50, 2), \n        (6, 180, 8),  # 180/6 = 30, factors are (1, 30), (2, 15), (3, 10), (5, 6), (6, 5), (10, 3), (15, 2), (30, 1)\n    ]\n\n    for i, (x0, y0, expected) in enumerate(test_cases):\n        result = count_coprime_pairs(x0, y0)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: x0 = {x0}, y0 = {y0}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_coprime_pairs()", "entry_point": "count_coprime_pairs", "signature": "def count_coprime_pairs(x0: int, y0: int) -> int:", "docstring": {"en": "\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    ", "sq": "\n    Numëron numrin e çifteve të numrave të plotë pozitivë (P, Q) të tillë që P dhe Q kanë x0 si maksimumin e tyre të përbashkët të plotë (GCD)\n    dhe y0 si minimumin e tyre të përbashkët të shumëfishtë (LCM).\n\n    Argumentet:\n    x0 (int): GCD që çdo çift (P, Q) duhet të ketë.\n    y0 (int): LCM që çdo çift (P, Q) duhet të ketë.\n\n    Kthen:\n    int: Numri i të gjitha çifteve të mundshme (P, Q) që plotësojnë kriteret e specifikuara.\n\n    Funksioni iteron nëpër të gjithë faktorët e mundshëm 'a' të kuotientit 'y0 / x0'. Për çdo faktor 'a',\n    llogarit faktorin përkatës 'b' të tillë që 'a * b = y0 / x0'. Pastaj kontrollon nëse 'a' dhe 'b'\n    janë bashkëkryesorë (GCD i tyre është 1) sepse P dhe Q mund të jenë vetëm shumëfishë të 'x0' nga faktorë bashkëkryesorë për të ruajtur\n    GCD si 'x0'. Nëse 'a' dhe 'b' janë bashkëkryesorë, numri rritet me 1 nëse 'a' është i njëjtë me 'b',\n    përndryshe me 2 për të marrë parasysh të dy çiftet (P, Q) dhe (Q, P).\n\n    Shembuj Rastesh:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "hy": "\n    Հաշվում է դրական ամբողջ թվերի զույգերի (P, Q) քանակը, այնպես, որ P և Q ունենան x0 որպես իրենց ամենամեծ ընդհանուր բաժանարարը (GCD)\n    և y0 որպես իրենց ամենափոքր ընդհանուր բազմապատիկը (LCM):\n\n    Պարամետրեր:\n    x0 (int): GCD, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q):\n    y0 (int): LCM, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q):\n\n    Վերադարձնում է:\n    int: Բոլոր հնարավոր զույգերի (P, Q) քանակը, որոնք համապատասխանում են նշված չափանիշներին:\n\n    Ֆունկցիան անցնում է 'y0 / x0' բաժանարարի բոլոր հնարավոր գործոններով 'a':ի միջոցով: Յուրաքանչյուր գործոնի համար 'a',\n    հաշվարկվում է համապատասխան գործոնը 'b', այնպես, որ 'a * b = y0 / x0':ին: Այնուհետև ստուգվում է, արդյոք 'a' և 'b'\n    համապրիմ են (նրանց GCD-ն 1 է), քանի որ P և Q կարող են միայն 'x0'-ի բազմապատիկներ լինել համապրիմ գործոններով՝ GCD-ն 'x0' պահելու համար:\n    Եթե 'a' և 'b' համապրիմ են, ապա քանակը ավելացվում է 1-ով, եթե 'a'-ն նույնն է 'b'-ի հետ,\n    այլապես 2-ով՝ հաշվի առնելով ինչպես (P, Q), այնպես էլ (Q, P) զույգերը:\n\n    Օրինակային դեպքեր:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "bn": "\n    (P, Q) জোড়ার সংখ্যা গণনা করে যেখানে P এবং Q এর সর্বাধিক সাধারণ গুণনীয়ক (GCD) x0 এবং সর্বনিম্ন সাধারণ গুণিতক (LCM) y0।\n\n    আর্গুমেন্ট:\n    x0 (int): GCD যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n    y0 (int): LCM যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n\n    রিটার্নস:\n    int: সমস্ত সম্ভাব্য জোড়া (P, Q) এর সংখ্যা যা নির্দিষ্ট মানদণ্ড পূরণ করে।\n\n    ফাংশনটি 'y0 / x0' এর ভাগফলের সমস্ত সম্ভাব্য গুণনীয়ক 'a' এর মাধ্যমে পুনরাবৃত্তি করে। প্রতিটি গুণনীয়ক 'a' এর জন্য,\n    এটি সংশ্লিষ্ট গুণনীয়ক 'b' গণনা করে যাতে 'a * b = y0 / x0' হয়। তারপর এটি পরীক্ষা করে 'a' এবং 'b'\n    সহমৌলিক কিনা (তাদের GCD 1) কারণ P এবং Q শুধুমাত্র 'x0' এর গুণিতক হতে পারে সহমৌলিক গুণনীয়ক দ্বারা GCD\n    'x0' বজায় রাখতে। যদি 'a' এবং 'b' সহমৌলিক হয়, তাহলে গণনা 1 দ্বারা বৃদ্ধি করা হয় যদি 'a' এবং 'b' একই হয়,\n    অন্যথায় 2 দ্বারা বৃদ্ধি করা হয় (P, Q) এবং (Q, P) উভয় জোড়ার জন্য।\n\n    উদাহরণ কেস:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "bg": "\n    Брои броя на двойките положителни цели числа (P, Q), такива че P и Q имат x0 като техен най-голям общ делител (НОД)\n    и y0 като техен най-малък общ кратен (НОК).\n\n    Аргументи:\n    x0 (int): НОД, който всяка двойка (P, Q) трябва да има.\n    y0 (int): НОК, който всяка двойка (P, Q) трябва да има.\n\n    Връща:\n    int: Броят на всички възможни двойки (P, Q), които отговарят на зададените критерии.\n\n    Функцията преминава през всички възможни делители 'a' на частното 'y0 / x0'. За всеки делител 'a',\n    тя изчислява съответния делител 'b' така че 'a * b = y0 / x0'. След това проверява дали 'a' и 'b'\n    са взаимно прости (техният НОД е 1), защото P и Q могат да бъдат само кратни на 'x0' чрез взаимно прости делители, за да се запази\n    НОД като 'x0'. Ако 'a' и 'b' са взаимно прости, броят се увеличава с 1, ако 'a' е същото като 'b',\n    иначе с 2, за да се отчетат и двете двойки (P, Q) и (Q, P).\n\n    Примерни случаи:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "zh": "\n    计算正整数对 (P, Q) 的数量，使得 P 和 Q 的最大公约数 (GCD) 为 x0，最小公倍数 (LCM) 为 y0。\n\n    参数:\n    x0 (int): 每对 (P, Q) 必须具有的 GCD。\n    y0 (int): 每对 (P, Q) 必须具有的 LCM。\n\n    返回:\n    int: 满足指定条件的所有可能对 (P, Q) 的数量。\n\n    该函数遍历商 'y0 / x0' 的所有可能因数 'a'。对于每个因数 'a'，计算相应的因数 'b'，使得 'a * b = y0 / x0'。\n    然后检查 'a' 和 'b' 是否互质（它们的 GCD 为 1），因为 P 和 Q 只能是 'x0' 的倍数，通过互质因数来保持\n    GCD 为 'x0'。如果 'a' 和 'b' 互质，计数增加 1（如果 'a' 和 'b' 相同），否则增加 2，以考虑 (P, Q) 和 (Q, P) 两种情况。\n\n    示例案例:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "fr": "\n    Compte le nombre de paires d'entiers positifs (P, Q) telles que P et Q aient x0 comme leur plus grand commun diviseur (PGCD)\n    et y0 comme leur plus petit commun multiple (PPCM).\n\n    Args:\n    x0 (int): Le PGCD que chaque paire (P, Q) doit avoir.\n    y0 (int): Le PPCM que chaque paire (P, Q) doit avoir.\n\n    Returns:\n    int: Le nombre de toutes les paires possibles (P, Q) qui répondent aux critères spécifiés.\n\n    La fonction itère à travers tous les facteurs possibles 'a' du quotient 'y0 / x0'. Pour chaque facteur 'a',\n    elle calcule le facteur correspondant 'b' tel que 'a * b = y0 / x0'. Elle vérifie ensuite si 'a' et 'b'\n    sont premiers entre eux (leur PGCD est 1) car P et Q ne peuvent être que des multiples de 'x0' par des facteurs\n    premiers entre eux pour maintenir le PGCD comme 'x0'. Si 'a' et 'b' sont premiers entre eux, le compte est\n    incrémenté de 1 si 'a' est le même que 'b', sinon de 2 pour tenir compte des paires (P, Q) et (Q, P).\n\n    Cas d'exemple:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "de": "\n    Zählt die Anzahl der Paare positiver Ganzzahlen (P, Q), sodass P und Q x0 als ihren größten gemeinsamen Teiler (GCD) \n    und y0 als ihr kleinstes gemeinsames Vielfaches (LCM) haben.\n\n    Args:\n    x0 (int): Der GCD, den jedes Paar (P, Q) haben muss.\n    y0 (int): Der LCM, den jedes Paar (P, Q) haben muss.\n\n    Returns:\n    int: Die Anzahl aller möglichen Paare (P, Q), die die angegebenen Kriterien erfüllen.\n\n    Die Funktion iteriert durch alle möglichen Faktoren 'a' des Quotienten 'y0 / x0'. Für jeden Faktor 'a'\n    berechnet sie den entsprechenden Faktor 'b', sodass 'a * b = y0 / x0'. Sie prüft dann, ob 'a' und 'b'\n    teilerfremd sind (ihr GCD ist 1), da P und Q nur Vielfache von 'x0' durch teilerfremde Faktoren sein können, um \n    den GCD als 'x0' zu erhalten. Wenn 'a' und 'b' teilerfremd sind, wird der Zähler um 1 erhöht, wenn 'a' gleich 'b' ist,\n    andernfalls um 2, um sowohl für (P, Q) als auch (Q, P) Paare zu berücksichtigen.\n\n    Beispiel Fälle:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "ha": "\n    Yana kirga adadin ma'aurata na lambobin kirki (P, Q) inda P da Q suna da x0 a matsayin mafi girman abin da za a iya rabawa (GCD)\n    da y0 a matsayin mafi ƙarancin abin da za a iya ninkawa (LCM).\n\n    Args:\n    x0 (int): GCD wanda kowace ma'aurata (P, Q) dole ne su samu.\n    y0 (int): LCM wanda kowace ma'aurata (P, Q) dole ne su samu.\n\n    Returns:\n    int: Adadin dukkan ma'aurata masu yiwuwa (P, Q) da suka cika ka'idodin da aka fayyace.\n\n    Aikin yana zagayawa ta dukkan abubuwan da za a iya samu 'a' na rabon 'y0 / x0'. Ga kowane abu 'a',\n    yana lissafa abin da ya dace 'b' wanda 'a * b = y0 / x0'. Sannan yana duba idan 'a' da 'b'\n    suna da juna (GCD dinsu 1 ne) saboda P da Q za su iya kasancewa masu yawa na 'x0' ta hanyar abubuwan da ba su da juna don kiyaye\n    GCD a matsayin 'x0'. Idan 'a' da 'b' suna da juna, ana ƙara ƙidaya da 1 idan 'a' daidai yake da 'b',\n    in ba haka ba da 2 don lissafin ma'aurata biyu (P, Q) da (Q, P).\n\n    Misalan Lokuta:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "hi": "\n    गिनती करता है कि कितने जोड़े सकारात्मक पूर्णांक (P, Q) हैं जिनके लिए P और Q का x0 सबसे बड़ा सामान्य भाजक (GCD) है\n    और y0 उनका सबसे छोटा सामान्य गुणज (LCM) है।\n\n    तर्क:\n    x0 (int): वह GCD जो प्रत्येक जोड़े (P, Q) का होना चाहिए।\n    y0 (int): वह LCM जो प्रत्येक जोड़े (P, Q) का होना चाहिए।\n\n    वापसी:\n    int: सभी संभावित जोड़ों (P, Q) की गिनती जो निर्दिष्ट मानदंडों को पूरा करते हैं।\n\n    यह फ़ंक्शन सभी संभावित गुणकों 'a' के माध्यम से 'y0 / x0' के भागफल की पुनरावृत्ति करता है। प्रत्येक गुणक 'a' के लिए,\n    यह संबंधित गुणक 'b' की गणना करता है ताकि 'a * b = y0 / x0' हो। फिर यह जांचता है कि 'a' और 'b'\n    सह-प्राइम हैं (उनका GCD 1 है) क्योंकि P और Q केवल 'x0' के गुणकों के सह-प्राइम गुणकों से ही हो सकते हैं\n    ताकि GCD 'x0' बना रहे। यदि 'a' और 'b' सह-प्राइम हैं, तो गिनती में 1 की वृद्धि की जाती है यदि 'a' 'b' के समान है,\n    अन्यथा 2 की वृद्धि की जाती है ताकि दोनों (P, Q) और (Q, P) जोड़े शामिल हों।\n\n    उदाहरण मामले:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "hu": "\n    Megszámolja azon pozitív egész szám párok (P, Q) számát, amelyekre P és Q legnagyobb közös osztója (GCD) x0, \n    és legkisebb közös többszöröse (LCM) y0.\n\n    Paraméterek:\n    x0 (int): Az a GCD, amelyet minden (P, Q) párnak meg kell felelnie.\n    y0 (int): Az az LCM, amelyet minden (P, Q) párnak meg kell felelnie.\n\n    Visszatér:\n    int: Az összes lehetséges (P, Q) pár száma, amely megfelel a megadott feltételeknek.\n\n    A függvény végigmegy a 'y0 / x0' hányados összes lehetséges 'a' osztóján. Minden 'a' osztóhoz kiszámítja a megfelelő 'b' osztót úgy, \n    hogy 'a * b = y0 / x0'. Ezután ellenőrzi, hogy 'a' és 'b' relatív prímek-e (GCD-jük 1), mert P és Q csak akkor lehet 'x0' többszöröse, \n    ha relatív prím tényezők, hogy a GCD 'x0' maradjon. Ha 'a' és 'b' relatív prímek, a számláló 1-gyel nő, ha 'a' megegyezik 'b'-vel, \n    különben 2-vel, hogy mind a (P, Q), mind a (Q, P) párokat figyelembe vegye.\n\n    Példa esetek:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "es": "    Cuenta el número de pares de enteros positivos (P, Q) tales que P y Q tienen x0 como su máximo común divisor (MCD)\n    y y0 como su mínimo común múltiplo (mcm).\n\n    Argumentos:\n    x0 (int): El MCD que cada par (P, Q) debe tener.\n    y0 (int): El mcm que cada par (P, Q) debe tener.\n\n    Devuelve:\n    int: La cantidad de todos los pares posibles (P, Q) que cumplen con los criterios especificados.\n\n    La función itera a través de todos los posibles factores 'a' del cociente 'y0 / x0'. Para cada factor 'a',\n    calcula el factor correspondiente 'b' tal que 'a * b = y0 / x0'. Luego verifica si 'a' y 'b'\n    son coprimos (su MCD es 1) porque P y Q solo pueden ser múltiplos de 'x0' por factores coprimos para mantener\n    el MCD como 'x0'. Si 'a' y 'b' son coprimos, el conteo se incrementa en 1 si 'a' es igual a 'b',\n    de lo contrario, en 2 para contar ambos pares (P, Q) y (Q, P).\n\n    Casos de Ejemplo:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "arb": "    يحسب عدد الأزواج من الأعداد الصحيحة الموجبة (P، Q) بحيث يكون لـ P و Q القاسم المشترك الأكبر (GCD) x0 \n    وأصغر مضاعف مشترك (LCM) y0.\n\n    يعيدالحجج:\n    x0 (int): القاسم المشترك الأكبر الذي يجب أن يكون لكل زوج (P، Q).\n    y0 (int): أصغر مضاعف مشترك الذي يجب أن يكون لكل زوج (P، Q).\n\n    يعيد:\n    int: عدد جميع الأزواج الممكنة (P، Q) التي تفي بالمعايير المحددة.\n\n    تقوم الدالة بتكرار جميع العوامل الممكنة 'a' للناتج 'y0 / x0'. لكل عامل 'a'،\n    تحسب العامل المقابل 'b' بحيث 'a * b = y0 / x0'. ثم تتحقق مما إذا كانت 'a' و 'b'\n    متوافقة (القاسم المشترك الأكبر لهما هو 1) لأن P و Q يمكن أن يكونا مضاعفات لـ 'x0' فقط بعوامل متوافقة للحفاظ\n    على القاسم المشترك الأكبر كـ 'x0'. إذا كانت 'a' و 'b' متوافقة، يتم زيادة العداد بمقدار 1 إذا كانت 'a' هي نفسها 'b',\n    وإلا بمقدار 2 لحساب كلا الزوجين (P، Q) و (Q، P).\n\n    أمثلة الحالات:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "sw": "    Inahesabu idadi ya jozi za nambari nzima chanya (P, Q) ambapo P na Q zina x0 kama kigezo chao kikuu cha mgawanyiko (GCD)\n    na y0 kama kigezo chao cha chini cha kuzidisha (LCM).\n\n    Hoja:\n    x0 (int): GCD ambayo kila jozi (P, Q) lazima iwe nayo.\n    y0 (int): LCM ambayo kila jozi (P, Q) lazima iwe nayo.\n\n    Inarejesha:\n    int: Idadi ya jozi zote zinazowezekana (P, Q) zinazokidhi vigezo vilivyotajwa.\n\n    Kazi hii inazunguka kupitia vigezo vyote vinavyowezekana 'a' vya sehemu 'y0 / x0'. Kwa kila kigezo 'a',\n    inahesabu kigezo kinacholingana 'b' ambapo 'a * b = y0 / x0'. Kisha inakagua kama 'a' na 'b'\n    ni nambari ambazo hazina mgawanyiko wa pamoja (GCD yao ni 1) kwa sababu P na Q zinaweza kuwa tu\n    maradufu ya 'x0' kwa vigezo ambavyo havina mgawanyiko wa pamoja ili kudumisha GCD kama 'x0'.\n    Ikiwa 'a' na 'b' hazina mgawanyiko wa pamoja, hesabu inaongezwa kwa 1 ikiwa 'a' ni sawa na 'b',\n    vinginevyo kwa 2 ili kuhesabu jozi zote mbili (P, Q) na (Q, P).\n\n    Mfano wa Matukio:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "tr": "    Pozitif tam sayı çiftlerinin (P, Q) sayısını sayar, öyle ki P ve Q'nun en büyük ortak böleni (GCD) x0\n    ve en küçük ortak katı (LCM) y0'dır.\n\n    Argümanlar:\n    x0 (int): Her çiftin (P, Q) sahip olması gereken GCD.\n    y0 (int): Her çiftin (P, Q) sahip olması gereken LCM.\n\n    Döndürür:\n    int: Belirtilen kriterleri karşılayan tüm olası çiftlerin (P, Q) sayısı.\n\n    Fonksiyon, 'y0 / x0' bölümünün tüm olası 'a' çarpanlarını iterasyonla kontrol eder. Her bir 'a' çarpanı için,\n    'a * b = y0 / x0' olacak şekilde karşılık gelen 'b' çarpanını hesaplar. Daha sonra 'a' ve 'b'nin\n    aralarında asal olup olmadığını kontrol eder (GCD'leri 1 ise) çünkü P ve Q, GCD'nin 'x0' olarak kalması için\n    yalnızca aralarında asal çarpanlarla 'x0' katları olabilir. Eğer 'a' ve 'b' aralarında asal ise, sayım\n    'a' ve 'b' aynıysa 1 artırılır, aksi takdirde hem (P, Q) hem de (Q, P) çiftlerini hesaba katmak için 2 artırılır.\n\n    Örnek Durumlar:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    ", "vi": "    Đếm số cặp số nguyên dương (P, Q) sao cho P và Q có x0 là ước số chung lớn nhất (GCD)\n    và y0 là bội số chung nhỏ nhất (LCM).\n\n    Tham số:\n    x0 (int): GCD mà mỗi cặp (P, Q) phải có.\n    y0 (int): LCM mà mỗi cặp (P, Q) phải có.\n\n    Trả về:\n    int: Số lượng tất cả các cặp (P, Q) có thể đáp ứng tiêu chí đã chỉ định.\n\n    Hàm lặp qua tất cả các ước số 'a' có thể có của thương số 'y0 / x0'. Đối với mỗi ước số 'a',\n    nó tính toán ước số tương ứng 'b' sao cho 'a * b = y0 / x0'. Sau đó, nó kiểm tra nếu 'a' và 'b'\n    là các số nguyên tố cùng nhau (GCD của chúng là 1) vì P và Q chỉ có thể là bội số của 'x0' bởi các ước số nguyên tố cùng nhau để duy trì\n    GCD là 'x0'. Nếu 'a' và 'b' là các số nguyên tố cùng nhau, số đếm được tăng thêm 1 nếu 'a' giống như 'b',\n    nếu không thì tăng thêm 2 để tính cả cặp (P, Q) và (Q, P).\n\n    Ví dụ:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "id": "Menghitung jumlah pasangan bilangan bulat positif (P, Q) sedemikian sehingga P dan Q memiliki x0 sebagai pembagi terbesar (GCD) dan y0 sebagai kelipatan terkecil (LCM).\n\nArgs:\nx0 (int): GCD yang harus dimiliki setiap pasangan (P, Q).\ny0 (int): LCM yang harus dimiliki setiap pasangan (P, Q).\n\nReturns:\nint: Jumlah semua pasangan (P, Q) yang memenuhi kriteria yang ditentukan.\n\nFungsi ini mengiterasi semua faktor 'a' yang mungkin dari hasil bagi 'y0 / x0'. Untuk setiap faktor 'a', fungsi menghitung faktor 'b' yang sesuai sehingga 'a * b = y0 / x0'. Kemudian memeriksa apakah 'a' dan 'b' adalah saling prima (GCD mereka adalah 1) karena P dan Q hanya dapat menjadi kelipatan dari 'x0' oleh faktor saling prima untuk mempertahankan GCD sebagai 'x0'. Jika 'a' dan 'b' adalah saling prima, hitungan ditingkatkan sebesar 1 jika 'a' sama dengan 'b', jika tidak, sebesar 2 untuk memperhitungkan pasangan (P, Q) dan (Q, P).\n\nContoh Kasus:\n\n>>> count_coprime_pairs(3, 60)\n4\n>>> count_coprime_pairs(2, 50)\n0", "ja": "    正の整数のペア (P, Q) の数を数えます。ここで、P と Q は x0 を最大公約数 (GCD) とし、y0 を最小公倍数 (LCM) とします。\n\n    Args:\n    x0 (int): 各ペア (P, Q) が持つべき GCD。\n    y0 (int): 各ペア (P, Q) が持つべき LCM。\n\n    Returns:\n    int: 指定された条件を満たすすべての可能なペア (P, Q) の数。\n\n    関数は商 'y0 / x0' のすべての可能な因数 'a' を反復処理します。各因数 'a' に対して、\n    対応する因数 'b' を計算し、'a * b = y0 / x0' となるようにします。それから 'a' と 'b' が\n    互いに素であるかどうか（それらの GCD が 1 であるか）を確認します。P と Q は 'x0' の倍数で\n    なければならず、GCD を 'x0' に保つために互いに素の因数である必要があります。もし 'a' と 'b' が\n    互いに素であれば、'a' が 'b' と同じ場合はカウントを 1 増やし、そうでなければ (P, Q) と (Q, P) の\n    両方のペアを考慮して 2 増やします。\n\n    例:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "ko": "    양의 정수 쌍 (P, Q)의 개수를 셉니다. 이때 P와 Q는 x0을 최대 공약수(GCD)로, y0을 최소 공배수(LCM)로 가집니다.\n\n    Args:\n    x0 (int): 각 쌍 (P, Q)이 가져야 하는 GCD.\n    y0 (int): 각 쌍 (P, Q)이 가져야 하는 LCM.\n\n    Returns:\n    int: 지정된 조건을 충족하는 모든 가능한 쌍 (P, Q)의 개수.\n\n    함수는 몫 'y0 / x0'의 모든 가능한 인수 'a'를 반복합니다. 각 인수 'a'에 대해,\n    'a * b = y0 / x0'를 만족하는 대응 인수 'b'를 계산합니다. 그런 다음 'a'와 'b'가 서로소인지\n    (그들의 GCD가 1인지) 확인합니다. 왜냐하면 P와 Q는 GCD를 'x0'로 유지하기 위해 서로소 인수의\n    'x0'의 배수만 될 수 있기 때문입니다. 'a'와 'b'가 서로소이면, 'a'가 'b'와 같을 경우에는\n    카운트를 1 증가시키고, 그렇지 않으면 (P, Q)와 (Q, P) 쌍 모두를 고려하여 2를 증가시킵니다.\n\n    예제 사례:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "ml": "    പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളായ (P, Q) എന്ന ജോഡികളുടെ എണ്ണം എണ്ണുന്നു, അങ്ങനെ P, Q എന്നിവയ്ക്ക് x0 ആണ് ഏറ്റവും വലിയ പൊതുഹരവും (GCD)\n    y0 ആണ് ഏറ്റവും ചെറിയ പൊതുഗുണിതവും (LCM).\n\n    Args:\n    x0 (int): ഓരോ ജോഡിക്കും (P, Q) ഉണ്ടാകേണ്ട GCD.\n    y0 (int): ഓരോ ജോഡിക്കും (P, Q) ഉണ്ടാകേണ്ട LCM.\n\n    Returns:\n    int: നിശ്ചിത മാനദണ്ഡങ്ങൾ പാലിക്കുന്ന എല്ലാ സാധ്യതയുള്ള ജോഡികളുടെ (P, Q) എണ്ണം.\n\n    ഫംഗ്ഷൻ 'y0 / x0' എന്ന ഭാഗഫലത്തിന്റെ എല്ലാ സാധ്യതയുള്ള ഘടകങ്ങളായ 'a' യിലൂടെ ആവർത്തിക്കുന്നു. ഓരോ ഘടകത്തിനും 'a',\n    'a * b = y0 / x0' എന്നതിനെ അടിസ്ഥാനമാക്കി അനുയോജ്യമായ ഘടകമായ 'b' കണക്കാക്കുന്നു. 'a'യും 'b'യും പരസ്പരം പ്രധാനമാണോ എന്ന് പരിശോധിക്കുന്നു (അവയുടെ GCD 1 ആണ്) കാരണം GCD 'x0' ആയി നിലനിർത്താൻ P, Q എന്നിവ 'x0'യുടെ ഘടകങ്ങളായ 'a'യും 'b'യും മാത്രമേ ആകാൻ കഴിയൂ. 'a'യും 'b'യും പരസ്പരം പ്രധാനമാണെങ്കിൽ, 'a' 'b'യുമായി സമാനമാണെങ്കിൽ 1 ൽ 1 കൂട്ടിച്ചേർക്കുന്നു, അല്ലെങ്കിൽ (P, Q)യും (Q, P) ജോഡികളും കണക്കാക്കുന്നതിനായി 2 ൽ 2 കൂട്ടിച്ചേർക്കുന്നു.\n\n    ഉദാഹരണ കേസുകൾ:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0", "fa": "    تعداد زوج‌های اعداد صحیح مثبت (P, Q) را که P و Q دارای x0 به عنوان بزرگترین مقسوم‌علیه مشترک (GCD) و y0 به عنوان کوچکترین مضرب مشترک (LCM) هستند، محاسبه می‌کند.\n\n    Args:\n    x0 (int): GCD که هر زوج (P, Q) باید داشته باشد.\n    y0 (int): LCM که هر زوج (P, Q) باید داشته باشد.\n\n    Returns:\n    int: تعداد همه زوج‌های ممکن (P, Q) که معیارهای مشخص شده را برآورده می‌کنند.\n\n    تابع از طریق تمام عوامل ممکن 'a' از خارج قسمت 'y0 / x0' تکرار می‌کند. برای هر عامل 'a'، عامل مربوطه 'b' را محاسبه می‌کند به طوری که 'a * b = y0 / x0'. سپس بررسی می‌کند که آیا 'a' و 'b' نسبت به هم اول هستند (GCD آنها 1 است) زیرا P و Q تنها می‌توانند مضرب‌های 'x0' با عوامل نسبت به هم اول باشند تا GCD به عنوان 'x0' حفظ شود. اگر 'a' و 'b' نسبت به هم اول باشند، تعداد با 1 افزایش می‌یابد اگر 'a' همان 'b' باشد، در غیر این صورت با 2 افزایش می‌یابد تا هر دو زوج (P, Q) و (Q, P) را در نظر بگیرد.\n\n    مثال‌ها:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0"}}
{"task_id": "Python/27", "prompt": {"en": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "sq": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Rikonstrukton pemën binare nga renditjet e saj inorder dhe postorder dhe\n    kthen renditjen preorder si një varg.\n\n    Args:\n    inorder (str): Renditja inorder e pemës binare.\n    postorder (str): Renditja postorder e pemës binare.\n\n    Returns:\n    str: Renditja preorder e pemës binare.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "hy": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Վերականգնում է բինար ծառը իր inorder և postorder շրջանցումներից և\n    վերադարձնում է preorder շրջանցումը որպես տող։\n\n    Արգումենտներ:\n    inorder (str): Բինար ծառի inorder շրջանցումը։\n    postorder (str): Բինար ծառի postorder շրջանցումը։\n\n    Վերադարձնում է:\n    str: Բինար ծառի preorder շրջանցումը։\n\n    Օրինակ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "bn": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে বাইনারি ট্রি পুনর্গঠন করে এবং\n    প্রিঅর্ডার ট্রাভার্সাল একটি স্ট্রিং হিসেবে প্রদান করে।\n\n    প্যারামিটার:\n    inorder (str): বাইনারি ট্রির ইনঅর্ডার ট্রাভার্সাল।\n    postorder (str): বাইনারি ট্রির পোস্টঅর্ডার ট্রাভার্সাল।\n\n    রিটার্নস:\n    str: বাইনারি ট্রির প্রিঅর্ডার ট্রাভার্সাল।\n\n    উদাহরণ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "bg": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Възстановява двоичното дърво от неговите обходи по ред на възход и низход\n    и връща обхода по предред като низ.\n\n    Аргументи:\n    inorder (str): Обходът по възход на двоичното дърво.\n    postorder (str): Обходът по низход на двоичното дърво.\n\n    Връща:\n    str: Обходът по предред на двоичното дърво.\n\n    Пример:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "zh": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    从中序遍历和后序遍历重建二叉树，并返回前序遍历作为字符串。\n\n    参数:\n    inorder (str): 二叉树的中序遍历。\n    postorder (str): 二叉树的后序遍历。\n\n    返回:\n    str: 二叉树的前序遍历。\n\n    示例:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "fr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstruit l'arbre binaire à partir de ses parcours inorder et postorder et\n    renvoie le parcours preorder sous forme de chaîne.\n\n    Args:\n    inorder (str): Le parcours inorder de l'arbre binaire.\n    postorder (str): Le parcours postorder de l'arbre binaire.\n\n    Returns:\n    str: Le parcours preorder de l'arbre binaire.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "de": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Rekonstruiert den Binärbaum aus seinen Inorder- und Postorder-Traversierungen und\n    gibt die Preorder-Traversierung als Zeichenkette zurück.\n\n    Argumente:\n    inorder (str): Die Inorder-Traversierung des Binärbaums.\n    postorder (str): Die Postorder-Traversierung des Binärbaums.\n\n    Rückgabewert:\n    str: Die Preorder-Traversierung des Binärbaums.\n\n    Beispiel:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "ha": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Sake gina itacen binary daga hanyoyin inorder da postorder kuma\n    ya dawo da hanyar preorder a matsayin kirtani.\n\n    Args:\n    inorder (str): Hanyar inorder na itacen binary.\n    postorder (str): Hanyar postorder na itacen binary.\n\n    Returns:\n    str: Hanyar preorder na itacen binary.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "hi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से बाइनरी ट्री को पुनर्निर्मित करता है और\n    प्रीऑर्डर ट्रैवर्सल को एक स्ट्रिंग के रूप में लौटाता है।\n\n    Args:\n    inorder (str): बाइनरी ट्री का इनऑर्डर ट्रैवर्सल।\n    postorder (str): बाइनरी ट्री का पोस्टऑर्डर ट्रैवर्सल।\n\n    Returns:\n    str: बाइनरी ट्री का प्रीऑर्डर ट्रैवर्सल।\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "hu": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Újjáépíti a bináris fát az inorder és postorder bejárásokból, és\n    visszaadja a preorder bejárást sztringként.\n\n    Paraméterek:\n    inorder (str): A bináris fa inorder bejárása.\n    postorder (str): A bináris fa postorder bejárása.\n\n    Visszatér:\n    str: A bináris fa preorder bejárása.\n\n    Példa:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "es": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstruye el árbol binario a partir de sus recorridos inorder y postorder y\n    devuelve el recorrido preorder como una cadena.\n\n    Argumentos:\n    inorder (str): El recorrido inorder del árbol binario.\n    postorder (str): El recorrido postorder del árbol binario.\n\n    Devuelve:\n    str: El recorrido preorder del árbol binario.\n\n    Ejemplo:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "arb": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    يعيد بناء الشجرة الثنائية من ترتيباتها التتابعية واللاحقة\n    ويعيد الترتيب التمهيدي كسلسلة نصية.\n\n    يعيدالحجج:\n    inorder (str): الترتيب التتابعي للشجرة الثنائية.\n    postorder (str): الترتيب اللاحق للشجرة الثنائية.\n\n    يعيد:\n    str: الترتيب التمهيدي للشجرة الثنائية.\n\n    امثله:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "sw": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Inajenga upya mti wa binary kutoka kwa inorder na postorder traversals na\n    inarudisha preorder traversal kama kamba.\n\n    Hoja:\n    inorder (str): Inorder traversal ya mti wa binary.\n    postorder (str): Postorder traversal ya mti wa binary.\n\n    Inarejesha:\n    str: Preorder traversal ya mti wa binary.\n\n    Mfano:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "tr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    İkili ağacı inorder ve postorder traversallarından yeniden oluşturur ve\n    preorder traversalını bir string olarak döndürür.\n\n    Argümanlar:\n    inorder (str): İkili ağacın inorder traversalı.\n    postorder (str): İkili ağacın postorder traversalı.\n\n    Döndürür:\n    str: İkili ağacın preorder traversalı.\n\n    Örnek:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "vi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Tái tạo cây nhị phân từ các duyệt inorder và postorder của nó và\n    trả về duyệt preorder dưới dạng một chuỗi.\n\n    Tham số:\n    inorder (str): Duyệt inorder của cây nhị phân.\n    postorder (str): Duyệt postorder của cây nhị phân.\n\n    Trả về:\n    str: Duyệt preorder của cây nhị phân.\n\n    Ví dụ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "id": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Merekonstruksi pohon biner dari traversal inorder dan postorder-nya dan\n    mengembalikan traversal preorder sebagai string.\n\n    Args:\n    inorder (str): Traversal inorder dari pohon biner.\n    postorder (str): Traversal postorder dari pohon biner.\n\n    Returns:\n    str: Traversal preorder dari pohon biner.\n\n    Contoh:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "ja": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    inorderとpostorderの走査から二分木を再構築し、\n    preorderの走査を文字列として返します。\n\n    引数:\n    inorder (str): 二分木のinorder走査。\n    postorder (str): 二分木のpostorder走査。\n\n    戻り値:\n    str: 二分木のpreorder走査。\n\n    例:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "ko": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    중위 순회와 후위 순회에서 이진 트리를 재구성하고\n    전위 순회를 문자열로 반환합니다.\n\n    매개변수:\n    inorder (str): 이진 트리의 중위 순회.\n    postorder (str): 이진 트리의 후위 순회.\n\n    반환값:\n    str: 이진 트리의 전위 순회.\n\n    예:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "ml": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    ബൈനറി ട്രീയുടെ inorder, postorder ട്രാവേഴ്സലുകളിൽ നിന്ന് ട്രീ പുനർനിർമ്മിച്ച്\n    preorder ട്രാവേഴ്സൽ ഒരു സ്ട്രിംഗായി തിരികെ നൽകുന്നു.\n\n    Args:\n    inorder (str): ബൈനറി ട്രീയുടെ inorder ട്രാവേഴ്സൽ.\n    postorder (str): ബൈനറി ട്രീയുടെ postorder ട്രാവേഴ്സൽ.\n\n    Returns:\n    str: ബൈനറി ട്രീയുടെ preorder ട്രാവേഴ്സൽ.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"", "fa": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    بازسازی درخت دودویی از پیمایش‌های inorder و postorder آن و\n    بازگرداندن پیمایش preorder به عنوان یک رشته.\n\n    آرگومان‌ها:\n    inorder (str): پیمایش inorder درخت دودویی.\n    postorder (str): پیمایش postorder درخت دودویی.\n\n    بازگشت:\n    str: پیمایش preorder درخت دودویی.\n\n    مثال:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\""}, "canonical_solution": "    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder", "instruction": {"en": "Write a python function 'def preorder_traversal(inorder: str, postorder: str) -> str:' to solve the following problem:\n\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    ", "sq": "Shkruani një funksion python 'def preorder_traversal(inorder: str, postorder: str) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Rikonstrukton pemën binare nga renditjet e saj inorder dhe postorder dhe\n    kthen renditjen preorder si një varg.\n\n    Argumentet:\n    inorder (str): Renditja inorder e pemës binare.\n    postorder (str): Renditja postorder e pemës binare.\n\n    Kthen:\n    str: Renditja preorder e pemës binare.\n\n    Shembull:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "hy": "Պայթոն ֆունկցիա 'def preorder_traversal(inorder: str, postorder: str) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Վերականգնում է բինար ծառը իր inorder և postorder անցումներից և\n    վերադարձնում է preorder անցումը որպես տող:\n\n    Արգումենտներ:\n    inorder (str): Բինար ծառի inorder անցումը:\n    postorder (str): Բինար ծառի postorder անցումը:\n\n    Վերադարձնում է:\n    str: Բինար ծառի preorder անցումը:\n\n    Օրինակ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "bn": "একটি পাইথন ফাংশন 'def preorder_traversal(inorder: str, postorder: str) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে বাইনারি ট্রি পুনর্গঠন করে এবং\n    প্রিঅর্ডার ট্রাভার্সালকে একটি স্ট্রিং হিসাবে ফেরত দেয়।\n\n    আর্গুমেন্টসমূহ:\n    inorder (str): বাইনারি ট্রির ইনঅর্ডার ট্রাভার্সাল।\n    postorder (str): বাইনারি ট্রির পোস্টঅর্ডার ট্রাভার্সাল।\n\n    ফেরত দেয়:\n    str: বাইনারি ট্রির প্রিঅর্ডার ট্রাভার্সাল।\n\n    উদাহরণ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "bg": "Напишете Python функция 'def preorder_traversal(inorder: str, postorder: str) -> str:' за да решите следния проблем:\n\n    Възстановява двоичното дърво от неговите inorder и postorder обхождания и\n    връща preorder обхождането като низ.\n\n    Аргументи:\n    inorder (str): Inorder обхождането на двоичното дърво.\n    postorder (str): Postorder обхождането на двоичното дърво.\n\n    Връща:\n    str: Preorder обхождането на двоичното дърво.\n\n    Пример:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "zh": "编写一个python函数 'def preorder_traversal(inorder: str, postorder: str) -> str:' 来解决以下问题：\n\n    从中序和后序遍历重建二叉树，并返回前序遍历作为字符串。\n\n    参数：\n    inorder (str): 二叉树的中序遍历。\n    postorder (str): 二叉树的后序遍历。\n\n    返回：\n    str: 二叉树的前序遍历。\n\n    示例：\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "fr": "Écrivez une fonction python 'def preorder_traversal(inorder: str, postorder: str) -> str:' pour résoudre le problème suivant :\n\n    Reconstruit l'arbre binaire à partir de ses parcours inorder et postorder et\n    renvoie le parcours preorder sous forme de chaîne.\n\n    Arguments :\n    inorder (str): Le parcours inorder de l'arbre binaire.\n    postorder (str): Le parcours postorder de l'arbre binaire.\n\n    Renvoie :\n    str: Le parcours preorder de l'arbre binaire.\n\n    Exemple :\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "de": "Schreiben Sie eine Python-Funktion 'def preorder_traversal(inorder: str, postorder: str) -> str:', um das folgende Problem zu lösen:\n\n    Rekonstruiert den Binärbaum aus seinen Inorder- und Postorder-Traversierungen und\n    gibt die Preorder-Traversierung als Zeichenkette zurück.\n\n    Argumente:\n    inorder (str): Die Inorder-Traversierung des Binärbaums.\n    postorder (str): Die Postorder-Traversierung des Binärbaums.\n\n    Rückgabe:\n    str: Die Preorder-Traversierung des Binärbaums.\n\n    Beispiel:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "ha": "Rubuta wani aikin python 'def preorder_traversal(inorder: str, postorder: str) -> str:' don warware matsalar mai zuwa:\n\n    Sake gina itacen binary daga hanyoyin inorder da postorder kuma\n    ya mayar da hanyoyin preorder a matsayin kirtani.\n\n    Args:\n    inorder (str): Hanyar inorder na itacen binary.\n    postorder (str): Hanyar postorder na itacen binary.\n\n    Returns:\n    str: Hanyar preorder na itacen binary.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "hi": "एक पायथन फ़ंक्शन 'def preorder_traversal(inorder: str, postorder: str) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    इसकी इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल्स से बाइनरी ट्री का पुनर्निर्माण करता है और\n    प्रीऑर्डर ट्रैवर्सल को एक स्ट्रिंग के रूप में लौटाता है।\n\n    तर्क:\n    inorder (str): बाइनरी ट्री का इनऑर्डर ट्रैवर्सल।\n    postorder (str): बाइनरी ट्री का पोस्टऑर्डर ट्रैवर्सल।\n\n    लौटाता है:\n    str: बाइनरी ट्री का प्रीऑर्डर ट्रैवर्सल।\n\n    उदाहरण:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "hu": "Írj egy Python függvényt 'def preorder_traversal(inorder: str, postorder: str) -> str:' a következő probléma megoldására:\n\n    Rekonstruálja a bináris fát az inorder és postorder bejárásokból, és\n    visszaadja a preorder bejárást egy karakterláncként.\n\n    Argumentumok:\n    inorder (str): A bináris fa inorder bejárása.\n    postorder (str): A bináris fa postorder bejárása.\n\n    Visszatér:\n    str: A bináris fa preorder bejárása.\n\n    Példa:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "es": "Escribe una función de Python 'def preorder_traversal(inorder: str, postorder: str) -> str:' para resolver el siguiente problema:\n\n    Reconstruye el árbol binario a partir de sus recorridos inorder y postorder y\n    devuelve el recorrido preorder como una cadena.\n\n    Argumentos:\n    inorder (str): El recorrido inorder del árbol binario.\n    postorder (str): El recorrido postorder del árbol binario.\n\n    Devuelve:\n    str: El recorrido preorder del árbol binario.\n\n    Ejemplo:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "arb": "اكتب دالة بايثون 'def preorder_traversal(inorder: str, postorder: str) -> str:' لحل المشكلة التالية:\n\n    يعيد بناء الشجرة الثنائية من ترتيبها الوسطي وترتيبها اللاحق ويعيد\n    ترتيبها السابق كسلسلة نصية.\n\n    يعيدالحجج:\n    inorder (str): الترتيب الوسطي للشجرة الثنائية.\n    postorder (str): الترتيب اللاحق للشجرة الثنائية.\n\n    يعيد:\n    str: الترتيب السابق للشجرة الثنائية.\n\n    مثال:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "sw": "Andika kazi ya python 'def preorder_traversal(inorder: str, postorder: str) -> str:' kutatua tatizo lifuatalo:\n\n    Inajenga upya mti wa binary kutoka kwa inorder na postorder traversals na\n    inarudisha preorder traversal kama kamba.\n\n    Hoja:\n    inorder (str): Inorder traversal ya mti wa binary.\n    postorder (str): Postorder traversal ya mti wa binary.\n\n    Inarejesha:\n    str: Preorder traversal ya mti wa binary.\n\n    Mfano:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "tr": "Bir python fonksiyonu 'def preorder_traversal(inorder: str, postorder: str) -> str:' yazın ve aşağıdaki problemi çözün:\n\n    İkili ağacı inorder ve postorder traversallarından yeniden oluşturur ve\n    preorder traversalını bir string olarak döndürür.\n\n    Argümanlar:\n    inorder (str): İkili ağacın inorder traversalı.\n    postorder (str): İkili ağacın postorder traversalı.\n\n    Döndürür:\n    str: İkili ağacın preorder traversalı.\n\n    Örnek:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "vi": "Viết một hàm python 'def preorder_traversal(inorder: str, postorder: str) -> str:' để giải quyết vấn đề sau:\n\n    Tái tạo cây nhị phân từ các duyệt inorder và postorder của nó và\n    trả về duyệt preorder dưới dạng một chuỗi.\n\n    Tham số:\n    inorder (str): Duyệt inorder của cây nhị phân.\n    postorder (str): Duyệt postorder của cây nhị phân.\n\n    Trả về:\n    str: Duyệt preorder của cây nhị phân.\n\n    Ví dụ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "id": "Tulis fungsi python 'def preorder_traversal(inorder: str, postorder: str) -> str:' untuk menyelesaikan masalah berikut:\n\n    Merekonstruksi pohon biner dari traversal inorder dan postorder-nya dan\n    mengembalikan traversal preorder sebagai string.\n\n    Argumen:\n    inorder (str): Traversal inorder dari pohon biner.\n    postorder (str): Traversal postorder dari pohon biner.\n\n    Mengembalikan:\n    str: Traversal preorder dari pohon biner.\n\n    Contoh:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "ja": "Python関数を書いてください。 'def preorder_traversal(inorder: str, postorder: str) -> str:' を解決するための以下の問題:\n\n    中間順と後順の走査から二分木を再構築し、\n    先行順の走査を文字列として返します。\n\n    引数:\n    inorder (str): 二分木の中間順の走査。\n    postorder (str): 二分木の後順の走査。\n\n    戻り値:\n    str: 二分木の先行順の走査。\n\n    例:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "ko": "파이썬 함수를 작성하여 다음 문제를 해결하십시오 'def preorder_traversal(inorder: str, postorder: str) -> str:':\n\n    중위 순회와 후위 순회로부터 이진 트리를 재구성하고\n    전위 순회를 문자열로 반환합니다.\n\n    매개변수:\n    inorder (str): 이진 트리의 중위 순회.\n    postorder (str): 이진 트리의 후위 순회.\n\n    반환값:\n    str: 이진 트리의 전위 순회.\n\n    예시:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "ml": "'def preorder_traversal(inorder: str, postorder: str) -> str:' എന്ന python ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    ബൈനറി ട്രീയുടെ inorder, postorder ട്രാവേഴ്സലുകളിൽ നിന്ന് ബൈനറി ട്രീ പുനർനിർമ്മിച്ച്\n    പ്രീഓർഡർ ട്രാവേഴ്സൽ ഒരു സ്ട്രിംഗായി തിരികെ നൽകുന്നു.\n\n    Args:\n    inorder (str): ബൈനറി ട്രീയുടെ inorder ട്രാവേഴ്സൽ.\n    postorder (str): ബൈനറി ട്രീയുടെ postorder ട്രാവേഴ്സൽ.\n\n    Returns:\n    str: ബൈനറി ട്രീയുടെ പ്രീഓർഡർ ട്രാവേഴ്സൽ.\n\n    ഉദാഹരണം:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "fa": "یک تابع پایتون بنویسید 'def preorder_traversal(inorder: str, postorder: str) -> str:' برای حل مسئله زیر:\n\n    بازسازی درخت دودویی از پیمایش‌های inorder و postorder آن و\n    بازگشت پیمایش preorder به عنوان یک رشته.\n\n    آرگومان‌ها:\n    inorder (str): پیمایش inorder درخت دودویی.\n    postorder (str): پیمایش postorder درخت دودویی.\n\n    بازگشت:\n    str: پیمایش preorder درخت دودویی.\n\n    مثال:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'"}, "level": "hard", "test": "def test_preorder_traversal():\n    # Test case 1\n    inorder1 = \"BADC\"\n    postorder1 = \"BDCA\"\n    expected_preorder1 = \"ABCD\"\n    assert preorder_traversal(inorder1, postorder1) == expected_preorder1\n    print(f\"Test case 1 passed. Preorder: {preorder_traversal(inorder1, postorder1)}\")\n\n    # Test case 2\n    inorder2 = \"DBGEACF\"\n    postorder2 = \"DGEBFCA\"\n    expected_preorder2 = \"ABDEGCF\"\n    assert preorder_traversal(inorder2, postorder2) == expected_preorder2\n    print(f\"Test case 2 passed. Preorder: {preorder_traversal(inorder2, postorder2)}\")\n\n    # Test case 3\n    inorder3 = \"A\"\n    postorder3 = \"A\"\n    expected_preorder3 = \"A\"\n    assert preorder_traversal(inorder3, postorder3) == expected_preorder3\n    print(f\"Test case 3 passed. Preorder: {preorder_traversal(inorder3, postorder3)}\")\n\n# Run the test function\ntest_preorder_traversal()", "entry_point": "preorder_traversal", "signature": "def preorder_traversal(inorder: str, postorder: str) -> str:", "docstring": {"en": "\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    ", "sq": "\n    Rikonstrukton pemën binare nga renditja e saj në rendin e mesëm dhe pas renditjes së saj dhe\n    kthen renditjen para renditjes si një varg.\n\n    Args:\n    inorder (str): Renditja në rendin e mesëm e pemës binare.\n    postorder (str): Renditja pas renditjes e pemës binare.\n\n    Returns:\n    str: Renditja para renditjes e pemës binare.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "hy": "\n    Վերակառուցում է բինար ծառը իր inorder և postorder շրջագայություններից և\n    վերադարձնում է preorder շրջագայությունը որպես տող:\n\n    Արգումենտներ:\n    inorder (str): Բինար ծառի inorder շրջագայությունը:\n    postorder (str): Բինար ծառի postorder շրջագայությունը:\n\n    Վերադարձնում է:\n    str: Բինար ծառի preorder շրջագայությունը:\n\n    Օրինակ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "bn": "\n    ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে বাইনারি ট্রি পুনর্গঠন করে এবং \n    প্রিঅর্ডার ট্রাভার্সালকে একটি স্ট্রিং হিসেবে ফেরত দেয়।\n\n    আর্গুমেন্টসমূহ:\n    inorder (str): বাইনারি ট্রির ইনঅর্ডার ট্রাভার্সাল।\n    postorder (str): বাইনারি ট্রির পোস্টঅর্ডার ট্রাভার্সাল।\n\n    রিটার্নস:\n    str: বাইনারি ট্রির প্রিঅর্ডার ট্রাভার্সাল।\n\n    উদাহরণ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "bg": "\n    Възстановява бинарното дърво от неговите обходи по ред на възлите и след реда на възлите и\n    връща обхода по предред като низ.\n\n    Аргументи:\n    inorder (str): Обходът по ред на възлите на бинарното дърво.\n    postorder (str): Обходът след реда на възлите на бинарното дърво.\n\n    Връща:\n    str: Обходът по предред на бинарното дърво.\n\n    Пример:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "zh": "\n    从中序和后序遍历重建二叉树，并以字符串形式返回前序遍历。\n\n    参数:\n    inorder (str): 二叉树的中序遍历。\n    postorder (str): 二叉树的后序遍历。\n\n    返回:\n    str: 二叉树的前序遍历。\n\n    示例:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "fr": "\n    Reconstruit l'arbre binaire à partir de ses parcours en ordre et en post-ordre et\nretourne le parcours en pré-ordre sous forme de chaîne.\n\nParamètres:\ninorder (str): Le parcours en ordre de l'arbre binaire.\npostorder (str): Le parcours en post-ordre de l'arbre binaire.\n\nRetourne:\nstr: Le parcours en pré-ordre de l'arbre binaire.\n\nExemple:\n>>> preorder_traversal('BADC', 'BDCA')\n'ABCD'\n>>> preorder_traversal('A', 'A')\n'A'", "de": "\n    Rekonstruiert den Binärbaum aus seinen Inorder- und Postorder-Traversierungen und\n    gibt die Preorder-Traversierung als Zeichenkette zurück.\n\n    Argumente:\n    inorder (str): Die Inorder-Traversierung des Binärbaums.\n    postorder (str): Die Postorder-Traversierung des Binärbaums.\n\n    Rückgabe:\n    str: Die Preorder-Traversierung des Binärbaums.\n\n    Beispiel:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "ha": "\n    Sake gina itacen binary daga hanyoyin inorder da postorder sannan\n    ya dawo da hanyar preorder a matsayin kirtani.\n\n    Args:\n    inorder (str): Hanyar inorder na itacen binary.\n    postorder (str): Hanyar postorder na itacen binary.\n\n    Returns:\n    str: Hanyar preorder na itacen binary.\n\n    Misali:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "hi": "\n    इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से बाइनरी ट्री को पुनर्निर्मित करता है और\n    प्रीऑर्डर ट्रैवर्सल को एक स्ट्रिंग के रूप में लौटाता है।\n\n    तर्क:\n    inorder (str): बाइनरी ट्री का इनऑर्डर ट्रैवर्सल।\n    postorder (str): बाइनरी ट्री का पोस्टऑर्डर ट्रैवर्सल।\n\n    रिटर्न्स:\n    str: बाइनरी ट्री का प्रीऑर्डर ट्रैवर्सल।\n\n    उदाहरण:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "hu": "\n    Újjáépíti a bináris fát az inorder és postorder bejárásokból, és\n    visszaadja a preorder bejárást egy karakterláncként.\n\n    Paraméterek:\n    inorder (str): A bináris fa inorder bejárása.\n    postorder (str): A bináris fa postorder bejárása.\n\n    Visszatér:\n    str: A bináris fa preorder bejárása.\n\n    Példa:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "es": "Reconstruye el árbol binario a partir de sus recorridos inorder y postorder y devuelve el recorrido preorder como una cadena.\n\nArgumentos:\ninorder (str): El recorrido inorder del árbol binario.\npostorder (str): El recorrido postorder del árbol binario.\n\nDevuelve:\nstr: El recorrido preorder del árbol binario.\n\nEjemplo:\n>>> preorder_traversal('BADC', 'BDCA')\n'ABCD'\n>>> preorder_traversal('A', 'A')\n'A'", "arb": "يعيد بناء الشجرة الثنائية من ترتيبها الوسطي وترتيبها اللاحق ويعيد ترتيبها السابق كسلسلة نصية.\n\nيعيدالحجج:\ninorder (str): الترتيب الوسطي للشجرة الثنائية.\npostorder (str): الترتيب اللاحق للشجرة الثنائية.\n\nيعيد:\nstr: الترتيب السابق للشجرة الثنائية.\n\nامثله:\n>>> preorder_traversal('BADC', 'BDCA')\n'ABCD'\n>>> preorder_traversal('A', 'A')\n'A'", "sw": "    Inajenga upya mti wa binary kutoka kwa mfuatano wake wa inorder na postorder na\n    inarudisha mfuatano wa preorder kama kamba.\n\n    Hoja:\n    inorder (str): Mfuatano wa inorder wa mti wa binary.\n    postorder (str): Mfuatano wa postorder wa mti wa binary.\n\n    Inarudisha:\n    str: Mfuatano wa preorder wa mti wa binary.\n\n    Mfano:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "tr": "    İkili ağacı, inorder ve postorder geçişlerinden yeniden oluşturur ve\n    preorder geçişini bir dize olarak döndürür.\n\n    Argümanlar:\n    inorder (str): İkili ağacın inorder geçişi.\n    postorder (str): İkili ağacın postorder geçişi.\n\n    Döndürülenler:\n    str: İkili ağacın preorder geçişi.\n\n    Örnek:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "vi": "    Tái tạo cây nhị phân từ các duyệt inorder và postorder của nó và\n    trả về duyệt preorder dưới dạng chuỗi.\n\n    Tham số:\n    inorder (str): Duyệt inorder của cây nhị phân.\n    postorder (str): Duyệt postorder của cây nhị phân.\n\n    Trả về:\n    str: Duyệt preorder của cây nhị phân.\n\n    Ví dụ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "id": "Merekonstruksi pohon biner dari penelusuran inorder dan postorder-nya dan mengembalikan penelusuran preorder sebagai string.\n\nArgs:\ninorder (str): Penelusuran inorder dari pohon biner.\npostorder (str): Penelusuran postorder dari pohon biner.\n\nReturns:\nstr: Penelusuran preorder dari pohon biner.\n\nExample:\n>>> preorder_traversal('BADC', 'BDCA')\n'ABCD'\n>>> preorder_traversal('A', 'A')\n'A'", "ja": "    中間順序と後順序の走査から二分木を再構築し、前順序の走査を文字列として返します。\n\n    引数:\n    inorder (str): 二分木の中間順序の走査。\n    postorder (str): 二分木の後順序の走査。\n\n    戻り値:\n    str: 二分木の前順序の走査。\n\n    例:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "ko": "이진 트리를 중위 순회와 후위 순회로부터 재구성하고 전위 순회를 문자열로 반환합니다.\n\nArgs:\ninorder (str): 이진 트리의 중위 순회.\npostorder (str): 이진 트리의 후위 순회.\n\nReturns:\nstr: 이진 트리의 전위 순회.\n\nExample:\n>>> preorder_traversal('BADC', 'BDCA')\n'ABCD'\n>>> preorder_traversal('A', 'A')\n'A'", "ml": "    ഇൻഓർഡർ, പോസ്റ്റ്ഓർഡർ ട്രാവേഴ്സലുകളിൽ നിന്ന് ബൈനറി ട്രീ പുനർനിർമ്മിച്ച്\n    പ്രീഓർഡർ ട്രാവേഴ്സൽ ഒരു സ്ട്രിംഗായി മടക്കിക്കൊടുക്കുന്നു.\n\n    Args:\n    inorder (str): ബൈനറി ട്രീയുടെ ഇൻഓർഡർ ട്രാവേഴ്സൽ.\n    postorder (str): ബൈനറി ട്രീയുടെ പോസ്റ്റ്ഓർഡർ ട്രാവേഴ്സൽ.\n\n    Returns:\n    str: ബൈനറി ട്രീയുടെ പ്രീഓർഡർ ട്രാവേഴ്സൽ.\n\n    ഉദാഹരണം:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'", "fa": "بازسازی درخت دودویی از پیمایش‌های inorder و postorder و بازگرداندن پیمایش preorder به صورت یک رشته.\n\nArgs:\ninorder (str): پیمایش inorder از درخت دودویی.\npostorder (str): پیمایش postorder از درخت دودویی.\n\nReturns:\nstr: پیمایش preorder از درخت دودویی.\n\nExample:\n>>> preorder_traversal('BADC', 'BDCA')\n'ABCD'\n>>> preorder_traversal('A', 'A')\n'A'"}}
{"task_id": "Python/28", "prompt": {"en": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "sq": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Kryej transformimin e vargut nga A në B duke përdorur një grup rregullash transformimi.\n\n    Kjo funksion merr një varg fillestar A dhe një varg të synuar B, së bashku me një listë\n    rregullash transformimi, dhe përpiqet të transformojë A në B duke përdorur rregullat.\n    Një algoritëm Kërkimi në Gjerësi (BFS) përdoret për të eksploruar transformimet e mundshme\n    deri në një maksimum prej 10 hapash. Nëse A mund të transformohet në B brenda 10 hapash, funksioni\n    kthen numrin minimal të hapave të kërkuar. Nëse nuk është e mundur, funksioni kthen\n    \"NO ANSWER!\".\n\n    Parametrat:\n    A (str): Vargu fillestar që do të transformohet.\n    B (str): Vargu i synuar që do të arrihet.\n    rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull është një tuple\n                            që përmban nënvargun burim (që do të zëvendësohet) dhe\n                            nënvargun synim (me të cilin do të zëvendësohet).\n\n    Kthen:\n    Union[int, str]: Numri minimal i hapave të transformimit nëse është e mundur, përndryshe \"NO ANSWER!\".\n\n    Shembuj:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "hy": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Կատարել տողերի փոխակերպում A-ից դեպի B օգտագործելով փոխակերպման կանոնների հավաքածու։\n\n    Այս ֆունկցիան վերցնում է սկզբնական A տողը և նպատակային B տողը, ինչպես նաև փոխակերպման\n    կանոնների ցուցակը, և փորձում է փոխակերպել A-ն դեպի B օգտագործելով այդ կանոնները։\n    Լայնության առաջին որոնման (BFS) ալգորիթմը օգտագործվում է հնարավոր փոխակերպումները\n    ուսումնասիրելու համար մինչև առավելագույնը 10 քայլ։ Եթե A-ն հնարավոր է փոխակերպել B-ի\n    10 քայլից պակասում, ֆունկցիան վերադարձնում է անհրաժեշտ նվազագույն քայլերի քանակը։\n    Եթե դա հնարավոր չէ, ֆունկցիան վերադարձնում է \"NO ANSWER!\"։\n\n    Պարամետրեր:\n    A (str): Սկզբնական տողը, որը պետք է փոխակերպվի։\n    B (str): Նպատակային տողը, որը պետք է ստացվի։\n    rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն\n                            զույգ է, որը պարունակում է աղբյուր ենթատողը (որը պետք է փոխարինվի)\n                            և նպատակային ենթատողը (որը պետք է փոխարինի)։\n\n    Վերադարձնում է:\n    Union[int, str]: Փոխակերպման նվազագույն քայլերի քանակը, եթե հնարավոր է, հակառակ դեպքում \"NO ANSWER!\"։\n\n    Օրինակներ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "bn": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    একটি সেট রূপান্তর নিয়ম ব্যবহার করে A থেকে B এ স্ট্রিং রূপান্তর সম্পাদন করুন।\n\n    এই ফাংশনটি একটি প্রাথমিক স্ট্রিং A এবং একটি লক্ষ্য স্ট্রিং B গ্রহণ করে, \n    সাথে একটি রূপান্তর নিয়মের তালিকা, এবং নিয়মগুলি ব্যবহার করে A কে B তে রূপান্তর করার চেষ্টা করে।\n    একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) অ্যালগরিদম ব্যবহার করা হয় সম্ভাব্য রূপান্তরগুলি \n    সর্বাধিক 10 ধাপ পর্যন্ত অনুসন্ধান করতে। যদি A কে 10 ধাপের মধ্যে B তে রূপান্তর করা যায়, \n    তাহলে ফাংশনটি প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা প্রদান করে। যদি এটি সম্ভব না হয়, \n    তাহলে ফাংশনটি \"NO ANSWER!\" প্রদান করে।\n\n    Parameters:\n    A (str): প্রাথমিক স্ট্রিং যা রূপান্তরিত হবে।\n    B (str): লক্ষ্য স্ট্রিং যা অর্জন করতে হবে।\n    rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টিউপল \n                            হিসেবে থাকে যা উৎস সাবস্ট্রিং (যা প্রতিস্থাপিত হবে) এবং \n                            লক্ষ্য সাবস্ট্রিং (যা দিয়ে প্রতিস্থাপন করা হবে) ধারণ করে।\n\n    Returns:\n    Union[int, str]: যদি সম্ভব হয় তাহলে রূপান্তরের সর্বনিম্ন ধাপের সংখ্যা, অন্যথায় \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "bg": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Извършва трансформация на низ от A към B, използвайки набор от правила за трансформация.\n\n    Тази функция приема начален низ A и целеви низ B, заедно със списък от правила за трансформация,\n    и се опитва да трансформира A в B, използвайки правилата.\n    Използва се алгоритъм за обхождане в ширина (BFS), за да се изследват възможните трансформации\n    до максимум 10 стъпки. Ако A може да бъде трансформирано в B в рамките на 10 стъпки, функцията\n    връща минималния брой необходими стъпки. Ако това не е възможно, функцията връща\n    \"NO ANSWER!\".\n\n    Параметри:\n    A (str): Началният низ, който трябва да бъде трансформиран.\n    B (str): Целевият низ, който трябва да бъде постигнат.\n    rules (list of tuples): Списък от правила за трансформация, където всяко правило е кортеж,\n                            съдържащ изходния подниз (който да бъде заменен) и\n                            целевия подниз (с който да се замени).\n\n    Връща:\n    Union[int, str]: Минималният брой стъпки за трансформация, ако е възможно, в противен случай \"NO ANSWER!\".\n\n    Примери:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "zh": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    使用一组转换规则从 A 转换为 B 的字符串转换。\n\n    该函数接受一个初始字符串 A 和一个目标字符串 B，以及一个转换规则列表，\n    并尝试使用这些规则将 A 转换为 B。\n    使用广度优先搜索 (BFS) 算法来探索可能的转换，最多进行 10 步。\n    如果 A 能在 10 步内转换为 B，函数返回所需的最小步骤数。\n    如果不可能，函数返回 \"NO ANSWER!\"。\n\n    参数:\n    A (str): 要转换的初始字符串。\n    B (str): 要达到的目标字符串。\n    rules (list of tuples): 转换规则列表，其中每个规则是一个包含源子字符串（要替换）和\n                            目标子字符串（用于替换）的元组。\n\n    返回:\n    Union[int, str]: 如果可能，返回最小的转换步骤数，否则返回 \"NO ANSWER!\"。\n\n    示例:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "fr": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Effectuer une transformation de chaîne de A à B en utilisant un ensemble de règles de transformation.\n\n    Cette fonction prend une chaîne initiale A et une chaîne cible B, ainsi qu'une liste\n    de règles de transformation, et tente de transformer A en B en utilisant les règles.\n    Un algorithme de recherche en largeur (BFS) est utilisé pour explorer les transformations possibles\n    jusqu'à un maximum de 10 étapes. Si A peut être transformé en B en 10 étapes, la fonction\n    retourne le nombre minimum d'étapes requises. Si ce n'est pas possible, la fonction retourne\n    \"NO ANSWER!\".\n\n    Paramètres:\n    A (str): La chaîne initiale à transformer.\n    B (str): La chaîne cible à atteindre.\n    rules (list of tuples): Une liste de règles de transformation, où chaque règle est un tuple\n                            contenant la sous-chaîne source (à remplacer) et la\n                            sous-chaîne cible (pour remplacer).\n\n    Retourne:\n    Union[int, str]: Le nombre minimum d'étapes de transformation si possible, sinon \"NO ANSWER!\".\n\n    Exemples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "de": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Führe eine Zeichenkettenumwandlung von A nach B unter Verwendung eines Satzes von Umwandlungsregeln durch.\n\n    Diese Funktion nimmt eine Anfangszeichenkette A und eine Zielzeichenkette B sowie eine Liste\n    von Umwandlungsregeln und versucht, A unter Verwendung der Regeln in B umzuwandeln.\n    Ein Breadth-First Search (BFS)-Algorithmus wird verwendet, um die möglichen Umwandlungen\n    bis zu einem Maximum von 10 Schritten zu erkunden. Wenn A innerhalb von 10 Schritten in B\n    umgewandelt werden kann, gibt die Funktion die minimale Anzahl der erforderlichen Schritte zurück.\n    Wenn es nicht möglich ist, gibt die Funktion \"NO ANSWER!\" zurück.\n\n    Parameter:\n    A (str): Die anfängliche Zeichenkette, die umgewandelt werden soll.\n    B (str): Die Zielzeichenkette, die erreicht werden soll.\n    rules (list of tuples): Eine Liste von Umwandlungsregeln, wobei jede Regel ein Tupel ist,\n                            das das Quell-Substring (das ersetzt werden soll) und das\n                            Ziel-Substring (mit dem ersetzt wird) enthält.\n\n    Rückgabe:\n    Union[int, str]: Die minimale Anzahl der Umwandlungsschritte, falls möglich, andernfalls \"NO ANSWER!\".\n\n    Beispiele:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "ha": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Yi canjin kirtani daga A zuwa B ta amfani da saitin dokokin canji.\n\n    Wannan aikin yana ɗaukar kirtani na farko A da kirtani na manufa B, tare da jerin\n    dokokin canji, kuma yana ƙoƙarin canza A zuwa B ta amfani da dokokin.\n    Ana amfani da algorithm na Breadth-First Search (BFS) don bincika yiwuwar canje-canje\n    har zuwa matakai 10 na iyaka. Idan za a iya canza A zuwa B cikin matakai 10, aikin\n    zai dawo da mafi ƙarancin adadin matakan da ake buƙata. Idan ba zai yiwu ba, aikin zai dawo\n    da \"NO ANSWER!\".\n\n    Sigogi:\n    A (str): Kirtani na farko da za a canza.\n    B (str): Kirtani na manufa da za a cimma.\n    rules (list of tuples): Jerin dokokin canji, inda kowanne doka yake da\n                            kirtani na asali (da za a maye gurbin) da\n                            kirtani na manufa (da za a maye gurbin da shi).\n\n    Komawa:\n    Union[int, str]: Mafi ƙarancin adadin matakan canji idan zai yiwu, in ba haka ba \"NO ANSWER!\".\n\n    Misalai:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "hi": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    एक सेट के परिवर्तन नियमों का उपयोग करके A से B तक स्ट्रिंग परिवर्तन करें।\n\n    यह फ़ंक्शन एक प्रारंभिक स्ट्रिंग A और एक लक्ष्य स्ट्रिंग B लेता है, साथ ही परिवर्तन नियमों की एक सूची,\n    और नियमों का उपयोग करके A को B में बदलने का प्रयास करता है।\n    संभावित परिवर्तनों का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) एल्गोरिथ्म का उपयोग किया जाता है\n    अधिकतम 10 चरणों तक। यदि A को 10 चरणों के भीतर B में बदला जा सकता है, तो फ़ंक्शन\n    आवश्यक न्यूनतम चरणों की संख्या लौटाता है। यदि यह संभव नहीं है, तो फ़ंक्शन\n    \"NO ANSWER!\" लौटाता है।\n\n    पैरामीटर्स:\n    A (str): प्रारंभिक स्ट्रिंग जिसे परिवर्तित करना है।\n    B (str): लक्ष्य स्ट्रिंग जिसे प्राप्त करना है।\n    rules (list of tuples): परिवर्तन नियमों की एक सूची, जहां प्रत्येक नियम एक ट्यूपल होता है\n                            जिसमें स्रोत सबस्ट्रिंग (जिसे बदला जाना है) और\n                            लक्ष्य सबस्ट्रिंग (जिससे बदलना है) शामिल होता है।\n\n    रिटर्न्स:\n    Union[int, str]: यदि संभव हो तो न्यूनतम परिवर्तन चरणों की संख्या, अन्यथा \"NO ANSWER!\".\n\n    उदाहरण:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "hu": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Sztring transzformáció végrehajtása A-ból B-be egy halmaz transzformációs szabály segítségével.\n\n    Ez a függvény egy kezdeti A sztringet és egy cél B sztringet vesz át, valamint egy listát\n    a transzformációs szabályokkal, és megpróbálja A-t B-vé alakítani a szabályok segítségével.\n    Egy Szélességi Első Keresés (BFS) algoritmust használunk a lehetséges transzformációk\n    felfedezésére legfeljebb 10 lépésig. Ha A 10 lépésen belül átalakítható B-vé, a függvény\n    visszaadja a szükséges minimális lépések számát. Ha nem lehetséges, a függvény visszaadja\n    a \"NO ANSWER!\" szöveget.\n\n    Paraméterek:\n    A (str): A kezdeti sztring, amelyet át kell alakítani.\n    B (str): A cél sztring, amelyet el kell érni.\n    rules (list of tuples): Egy lista a transzformációs szabályokról, ahol minden szabály egy\n                            forrás részsztringet tartalmaz (amit le kell cserélni) és a\n                            cél részsztringet (amire le kell cserélni).\n\n    Visszatérési érték:\n    Union[int, str]: A minimális transzformációs lépések száma, ha lehetséges, különben \"NO ANSWER!\".\n\n    Példák:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "es": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Realizar la transformación de cadena de A a B utilizando un conjunto de reglas de transformación.\n\n    Esta función toma una cadena inicial A y una cadena objetivo B, junto con una lista\n    de reglas de transformación, e intenta transformar A en B usando las reglas.\n    Se utiliza un algoritmo de Búsqueda en Anchura (BFS) para explorar las posibles transformaciones\n    hasta un máximo de 10 pasos. Si A puede transformarse en B dentro de 10 pasos, la función\n    devuelve el número mínimo de pasos requeridos. Si no es posible, la función devuelve\n    \"NO ANSWER!\".\n\n    Parámetros:\n    A (str): La cadena inicial a transformar.\n    B (str): La cadena objetivo a lograr.\n    rules (list of tuples): Una lista de reglas de transformación, donde cada regla es una tupla\n                            que contiene la subcadena fuente (a ser reemplazada) y la\n                            subcadena objetivo (con la que se reemplaza).\n\n    Devuelve:\n    Union[int, str]: El número mínimo de pasos de transformación si es posible, de lo contrario \"NO ANSWER!\".\n\n    Ejemplos:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "arb": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    تنفيذ تحويل سلسلة من A إلى B باستخدام مجموعة من قواعد التحويل.\n\n    تأخذ هذه الدالة سلسلة ابتدائية A وسلسلة هدف B، مع قائمة من قواعد التحويل،\n    وتحاول تحويل A إلى B باستخدام القواعد. يتم استخدام خوارزمية البحث بعرض\n    (BFS) لاستكشاف التحويلات الممكنة حتى حد أقصى من 10 خطوات. إذا كان من الممكن\n    تحويل A إلى B في غضون 10 خطوات، فإن الدالة تعيد الحد الأدنى لعدد الخطوات\n    المطلوبة. إذا لم يكن ذلك ممكنًا، فإن الدالة تعيد \"NO ANSWER!\".\n\n    المعاملات:\n    A (str): السلسلة الابتدائية التي سيتم تحويلها.\n    B (str): سلسلة الهدف المراد تحقيقها.\n    rules (list of tuples): قائمة بقواعد التحويل، حيث تحتوي كل قاعدة على\n                            السلسلة الفرعية المصدر (التي سيتم استبدالها) والسلسلة\n                            الفرعية الهدف (التي سيتم الاستبدال بها).\n\n    العوائد:\n    Union[int, str]: الحد الأدنى لعدد خطوات التحويل إذا كان ذلك ممكنًا، وإلا \"NO ANSWER!\".\n\n    أمثلة:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "sw": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Fanya mabadiliko ya kamba kutoka A hadi B kwa kutumia seti ya sheria za mabadiliko.\n\n    Kazi hii inachukua kamba ya awali A na kamba lengwa B, pamoja na orodha\n    ya sheria za mabadiliko, na inajaribu kubadilisha A kuwa B kwa kutumia sheria hizo.\n    Algorithimu ya Utafutaji wa Upana Kwanza (BFS) inatumika kuchunguza mabadiliko yanayowezekana\n    hadi kiwango cha juu cha hatua 10. Ikiwa A inaweza kubadilishwa kuwa B ndani ya hatua 10,\n    kazi inarudisha idadi ndogo ya hatua zinazohitajika. Ikiwa haiwezekani, kazi inarudisha\n    \"NO ANSWER!\".\n\n    Vigezo:\n    A (str): Kamba ya awali inayopaswa kubadilishwa.\n    B (str): Kamba lengwa inayopaswa kufikiwa.\n    rules (list of tuples): Orodha ya sheria za mabadiliko, ambapo kila sheria ni jozi\n                            inayojumuisha sehemu ndogo ya chanzo (inayopaswa kubadilishwa) na\n                            sehemu ndogo ya lengwa (ya kubadilisha nayo).\n\n    Inarudisha:\n    Union[int, str]: Idadi ndogo ya hatua za mabadiliko ikiwa inawezekana, vinginevyo \"NO ANSWER!\".\n\n    Mifano:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "tr": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Bir dizi dönüşüm kuralı kullanarak A'dan B'ye string dönüşümü gerçekleştirin.\n\n    Bu fonksiyon, başlangıç stringi A ve hedef string B'yi, bir dizi dönüşüm kuralı ile birlikte alır\n    ve A'yı kuralları kullanarak B'ye dönüştürmeye çalışır.\n    Olası dönüşümleri maksimum 10 adımda keşfetmek için Genişlik Öncelikli Arama (BFS) algoritması kullanılır.\n    A, 10 adım içinde B'ye dönüştürülebilirse, fonksiyon gereken minimum adım sayısını döndürür.\n    Eğer mümkün değilse, fonksiyon \"NO ANSWER!\" döndürür.\n\n    Parametreler:\n    A (str): Dönüştürülecek başlangıç stringi.\n    B (str): Elde edilmesi gereken hedef string.\n    rules (list of tuples): Her bir kuralın bir kaynak alt dize (değiştirilecek) ve\n                            bir hedef alt dize (ile değiştirilecek) içerdiği dönüşüm kuralları listesi.\n\n    Döndürür:\n    Union[int, str]: Mümkünse minimum dönüşüm adım sayısı, aksi takdirde \"NO ANSWER!\".\n\n    Örnekler:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "vi": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Thực hiện chuyển đổi chuỗi từ A sang B bằng cách sử dụng một tập hợp các quy tắc chuyển đổi.\n\n    Hàm này nhận vào một chuỗi ban đầu A và một chuỗi mục tiêu B, cùng với một danh sách\n    các quy tắc chuyển đổi, và cố gắng chuyển đổi A thành B bằng cách sử dụng các quy tắc đó.\n    Thuật toán Tìm kiếm theo Chiều rộng (BFS) được sử dụng để khám phá các khả năng chuyển đổi\n    tối đa trong 10 bước. Nếu A có thể được chuyển đổi thành B trong vòng 10 bước, hàm sẽ\n    trả về số bước tối thiểu cần thiết. Nếu không thể, hàm sẽ trả về \"NO ANSWER!\".\n\n    Tham số:\n    A (str): Chuỗi ban đầu cần chuyển đổi.\n    B (str): Chuỗi mục tiêu cần đạt được.\n    rules (list of tuples): Danh sách các quy tắc chuyển đổi, trong đó mỗi quy tắc là một bộ\n                            chứa chuỗi con nguồn (cần thay thế) và chuỗi con mục tiêu (để thay thế).\n\n    Trả về:\n    Union[int, str]: Số bước chuyển đổi tối thiểu nếu có thể, nếu không thì \"NO ANSWER!\".\n\n    Ví dụ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "id": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Melakukan transformasi string dari A ke B menggunakan serangkaian aturan transformasi.\n\n    Fungsi ini mengambil string awal A dan string target B, bersama dengan daftar\n    aturan transformasi, dan mencoba untuk mentransformasi A menjadi B menggunakan aturan tersebut.\n    Algoritma Breadth-First Search (BFS) digunakan untuk menjelajahi kemungkinan transformasi\n    hingga maksimum 10 langkah. Jika A dapat ditransformasikan menjadi B dalam 10 langkah,\n    fungsi mengembalikan jumlah langkah minimum yang diperlukan. Jika tidak mungkin,\n    fungsi mengembalikan \"NO ANSWER!\".\n\n    Parameter:\n    A (str): String awal yang akan ditransformasikan.\n    B (str): String target yang ingin dicapai.\n    rules (list of tuples): Daftar aturan transformasi, di mana setiap aturan adalah tuple\n                            yang berisi substring sumber (yang akan diganti) dan\n                            substring target (untuk mengganti).\n\n    Mengembalikan:\n    Union[int, str]: Jumlah langkah transformasi minimum jika memungkinkan, jika tidak \"NO ANSWER!\".\n\n    Contoh:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "ja": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    一連の変換ルールを使用して、AからBへの文字列変換を実行します。\n\n    この関数は、初期文字列Aとターゲット文字列B、および変換ルールのリストを受け取り、\n    ルールを使用してAをBに変換しようとします。\n    幅優先探索（BFS）アルゴリズムを使用して、最大10ステップまでの可能な変換を探索します。\n    Aが10ステップ以内にBに変換できる場合、必要な最小ステップ数を返します。\n    変換が不可能な場合、関数は\"NO ANSWER!\"を返します。\n\n    パラメータ:\n    A (str): 変換される初期文字列。\n    B (str): 達成されるべきターゲット文字列。\n    rules (list of tuples): 変換ルールのリスト。各ルールは、置き換えられるソース部分文字列と\n                            置き換えるターゲット部分文字列を含むタプルです。\n\n    戻り値:\n    Union[int, str]: 変換が可能な場合は最小の変換ステップ数、それ以外の場合は\"NO ANSWER!\"。\n\n    例:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "ko": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    주어진 변환 규칙을 사용하여 문자열 A를 B로 변환합니다.\n\n    이 함수는 초기 문자열 A와 목표 문자열 B, 그리고 변환 규칙의 목록을 받아\n    규칙을 사용하여 A를 B로 변환하려고 시도합니다. 너비 우선 탐색 (BFS) 알고리즘을 사용하여\n    최대 10단계까지 가능한 변환을 탐색합니다. A가 10단계 이내에 B로 변환될 수 있으면,\n    함수는 필요한 최소 단계 수를 반환합니다. 변환이 불가능하면, 함수는 \"NO ANSWER!\"를 반환합니다.\n\n    매개변수:\n    A (str): 변환할 초기 문자열.\n    B (str): 목표로 하는 문자열.\n    rules (list of tuples): 변환 규칙의 목록으로, 각 규칙은 소스 부분 문자열(대체될 부분)과\n                            대상 부분 문자열(대체할 부분)을 포함하는 튜플입니다.\n\n    반환값:\n    Union[int, str]: 변환이 가능하면 최소 변환 단계 수, 그렇지 않으면 \"NO ANSWER!\".\n\n    예시:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "ml": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    ഒരു സെറ്റ് മാറ്റം നിയമങ്ങൾ ഉപയോഗിച്ച് A നിന്ന് B ലേക്ക് സ്ട്രിംഗ് മാറ്റം നടത്തുക.\n\n    ഈ ഫംഗ്ഷൻ ഒരു പ്രാഥമിക സ്ട്രിംഗ് A, ഒരു ലക്ഷ്യ സ്ട്രിംഗ് B, കൂടാതെ ഒരു ലിസ്റ്റ്\n    മാറ്റം നിയമങ്ങൾ സ്വീകരിക്കുന്നു, A നെ നിയമങ്ങൾ ഉപയോഗിച്ച് B ആക്കാൻ ശ്രമിക്കുന്നു.\n    ഒരു ബ്രെഡ്ത്ത്-ഫസ്റ്റ് സെർച്ച് (BFS) ആൽഗോരിതം പരമാവധി 10 ഘട്ടങ്ങൾ വരെ\n    സാധ്യതയുള്ള മാറ്റങ്ങൾ അന്വേഷിക്കാൻ ഉപയോഗിക്കുന്നു. A 10 ഘട്ടങ്ങൾക്കുള്ളിൽ B ആക്കാൻ\n    കഴിയുമെങ്കിൽ, ഫംഗ്ഷൻ ആവശ്യമായ കുറഞ്ഞ ഘട്ടങ്ങളുടെ എണ്ണം മടക്കുന്നു. അത് സാധ്യമല്ലെങ്കിൽ,\n    ഫംഗ്ഷൻ \"NO ANSWER!\" മടക്കുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    A (str): മാറ്റേണ്ട പ്രാഥമിക സ്ട്രിംഗ്.\n    B (str): നേടേണ്ട ലക്ഷ്യ സ്ട്രിംഗ്.\n    rules (list of tuples): മാറ്റം നിയമങ്ങളുടെ ഒരു ലിസ്റ്റ്, ഓരോ നിയമവും ഒരു ട്യൂപ്പിള്‍\n                            അടങ്ങിയിരിക്കുന്നു, അതിൽ സോഴ്സ് സബ്സ്ട്രിംഗ് (മാറ്റേണ്ടത്) \n                            ഉം ലക്ഷ്യ സബ്സ്ട്രിംഗ് (മാറ്റേണ്ടത്) ഉം അടങ്ങിയിരിക്കുന്നു.\n\n    മടക്കങ്ങൾ:\n    Union[int, str]: സാധ്യമെങ്കിൽ കുറഞ്ഞ മാറ്റം ഘട്ടങ്ങളുടെ എണ്ണം, അല്ലെങ്കിൽ \"NO ANSWER!\".\n\n    ഉദാഹരണങ്ങൾ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"", "fa": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    انجام تبدیل رشته از A به B با استفاده از مجموعه‌ای از قوانین تبدیل.\n\n    این تابع یک رشته اولیه A و یک رشته هدف B را به همراه لیستی از قوانین تبدیل می‌گیرد\n    و تلاش می‌کند تا A را با استفاده از قوانین به B تبدیل کند.\n    یک الگوریتم جستجوی اول سطح (BFS) برای بررسی تبدیل‌های ممکن تا حداکثر 10 مرحله استفاده می‌شود.\n    اگر A بتواند در کمتر از 10 مرحله به B تبدیل شود، تابع حداقل تعداد مراحل مورد نیاز را برمی‌گرداند.\n    اگر این امکان‌پذیر نباشد، تابع \"NO ANSWER!\" را برمی‌گرداند.\n\n    پارامترها:\n    A (str): رشته اولیه که باید تبدیل شود.\n    B (str): رشته هدف که باید به آن دست یافت.\n    rules (list of tuples): لیستی از قوانین تبدیل، که هر قانون یک تاپل شامل زیررشته منبع\n                            (که باید جایگزین شود) و زیررشته هدف (که باید با آن جایگزین شود) است.\n\n    بازگشت:\n    Union[int, str]: حداقل تعداد مراحل تبدیل در صورت امکان، در غیر این صورت \"NO ANSWER!\".\n\n    مثال‌ها:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\""}, "canonical_solution": "\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"", "instruction": {"en": "Write a python function 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' to solve the following problem:\n\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    ", "sq": "Shkruani një funksion python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' për të zgjidhur problemin e mëposhtëm:\n\n    Kryeni transformimin e vargut nga A në B duke përdorur një grup rregullash transformimi.\n\n    Kjo funksion merr një varg fillestar A dhe një varg objektiv B, së bashku me një listë\n    të rregullave të transformimit, dhe përpiqet të transformojë A në B duke përdorur rregullat.\n    Një algoritëm i Kërkimit në Gjerësi (BFS) përdoret për të eksploruar transformimet e mundshme\n    deri në një maksimum prej 10 hapash. Nëse A mund të transformohet në B brenda 10 hapash, funksioni\n    kthen numrin minimal të hapave të nevojshëm. Nëse nuk është e mundur, funksioni kthen\n    \"NO ANSWER!\".\n\n    Parametrat:\n    A (str): Vargu fillestar që do të transformohet.\n    B (str): Vargu objektiv që do të arrihet.\n    rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull është një tuple\n                            që përmban nënvargun burim (që do të zëvendësohet) dhe\n                            nënvargun objektiv (për të zëvendësuar me).\n\n    Kthen:\n    Union[int, str]: Numri minimal i hapave të transformimit nëse është e mundur, përndryshe \"NO ANSWER!\".\n\n    Shembuj:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "hy": "Պայթոն ֆունկցիա 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Կատարել տողի փոխակերպում A-ից B օգտագործելով փոխակերպման կանոնների հավաքածու:\n\n    Այս ֆունկցիան ընդունում է սկզբնական տող A և նպատակային տող B, ինչպես նաև փոխակերպման\n    կանոնների ցուցակ և փորձում է փոխակերպել A-ն B-ի՝ օգտագործելով այդ կանոնները:\n    Լայնության-առաջին որոնման (BFS) ալգորիթմը օգտագործվում է հնարավոր փոխակերպումները\n    ուսումնասիրելու համար առավելագույնը 10 քայլով: Եթե A-ն կարող է փոխակերպվել B-ի 10 քայլի\n    ընթացքում, ֆունկցիան վերադարձնում է անհրաժեշտ նվազագույն քայլերի քանակը: Եթե դա հնարավոր չէ,\n    ֆունկցիան վերադարձնում է \"NO ANSWER!\":\n\n    Պարամետրեր:\n    A (str): Սկզբնական տողը, որը պետք է փոխակերպվի:\n    B (str): Նպատակային տողը, որը պետք է ստացվի:\n    rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն\n                            զույգ է, որը պարունակում է աղբյուրի ենթատողը (որը պետք է փոխարինվի)\n                            և նպատակային ենթատողը (որով պետք է փոխարինել):\n\n    Վերադարձնում է:\n    Union[int, str]: Փոխակերպման նվազագույն քայլերի քանակը, եթե հնարավոր է, հակառակ դեպքում \"NO ANSWER!\":\n\n    Օրինակներ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "bn": "একটি পাইথন ফাংশন 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি সেট ট্রান্সফরমেশন নিয়ম ব্যবহার করে A থেকে B তে স্ট্রিং রূপান্তর সম্পাদন করুন।\n\n    এই ফাংশনটি একটি প্রাথমিক স্ট্রিং A এবং একটি লক্ষ্য স্ট্রিং B গ্রহণ করে, \n    সাথে একটি ট্রান্সফরমেশন নিয়মের তালিকা, এবং নিয়মগুলি ব্যবহার করে A কে B তে রূপান্তর করার চেষ্টা করে।\n    একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) অ্যালগরিদম ব্যবহার করা হয় সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে \n    সর্বাধিক 10 ধাপ পর্যন্ত। যদি A কে 10 ধাপের মধ্যে B তে রূপান্তর করা যায়, তাহলে ফাংশনটি \n    প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা ফেরত দেয়। যদি এটি সম্ভব না হয়, তাহলে ফাংশনটি \n    \"NO ANSWER!\" ফেরত দেয়।\n\n    Parameters:\n    A (str): প্রাথমিক স্ট্রিং যা রূপান্তরিত হবে।\n    B (str): লক্ষ্য স্ট্রিং যা অর্জন করতে হবে।\n    rules (list of tuples): একটি ট্রান্সফরমেশন নিয়মের তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল\n                            ধারণ করে উৎস সাবস্ট্রিং (যা প্রতিস্থাপিত হবে) এবং\n                            লক্ষ্য সাবস্ট্রিং (যা দিয়ে প্রতিস্থাপন করা হবে)।\n\n    Returns:\n    Union[int, str]: যদি সম্ভব হয় তাহলে রূপান্তরের সর্বনিম্ন ধাপের সংখ্যা, অন্যথায় \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "bg": "Напишете Python функция 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' за решаване на следния проблем:\n\n    Извършете трансформация на низ от A към B, използвайки набор от правила за трансформация.\n\n    Тази функция приема начален низ A и целеви низ B, заедно със списък\n    от правила за трансформация, и се опитва да трансформира A в B, използвайки правилата.\n    Алгоритъм за обхождане в ширина (BFS) се използва за изследване на възможните трансформации\n    до максимум 10 стъпки. Ако A може да бъде трансформиран в B в рамките на 10 стъпки, функцията\n    връща минималния брой необходими стъпки. Ако не е възможно, функцията връща\n    \"NO ANSWER!\".\n\n    Параметри:\n    A (str): Началният низ, който ще бъде трансформиран.\n    B (str): Целевият низ, който трябва да бъде постигнат.\n    rules (list of tuples): Списък с правила за трансформация, където всяко правило е кортеж,\n                            съдържащ изходния подниз (който ще бъде заменен) и\n                            целевия подниз (с който да се замени).\n\n    Връща:\n    Union[int, str]: Минималният брой стъпки за трансформация, ако е възможно, в противен случай \"NO ANSWER!\".\n\n    Примери:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "zh": "编写一个Python函数 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' 来解决以下问题：\n\n    使用一组转换规则从A到B执行字符串转换。\n\n    此函数接受初始字符串A和目标字符串B，以及转换规则列表，并尝试使用这些规则将A转换为B。\n    使用广度优先搜索（BFS）算法来探索可能的转换，最多10步。\n    如果A可以在10步内转换为B，函数返回所需的最小步骤数。如果不可能，函数返回\"NO ANSWER!\"。\n\n    参数:\n    A (str): 要转换的初始字符串。\n    B (str): 要达到的目标字符串。\n    rules (list of tuples): 转换规则列表，其中每个规则是一个元组，包含源子字符串（要替换的）和目标子字符串（用于替换的）。\n\n    返回:\n    Union[int, str]: 如果可能，返回最小的转换步骤数，否则返回\"NO ANSWER!\"。\n\n    示例:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "fr": "Écrivez une fonction python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' pour résoudre le problème suivant :\n\n    Effectuer la transformation de chaîne de A à B en utilisant un ensemble de règles de transformation.\n\n    Cette fonction prend une chaîne initiale A et une chaîne cible B, ainsi qu'une liste\n    de règles de transformation, et tente de transformer A en B en utilisant les règles.\n    Un algorithme de recherche en largeur (BFS) est utilisé pour explorer les transformations possibles\n    jusqu'à un maximum de 10 étapes. Si A peut être transformé en B en 10 étapes, la fonction\n    renvoie le nombre minimum d'étapes nécessaires. Si ce n'est pas possible, la fonction renvoie\n    \"NO ANSWER!\".\n\n    Paramètres:\n    A (str): La chaîne initiale à transformer.\n    B (str): La chaîne cible à atteindre.\n    rules (list of tuples): Une liste de règles de transformation, où chaque règle est un tuple\n                            contenant la sous-chaîne source (à remplacer) et la\n                            sous-chaîne cible (par laquelle remplacer).\n\n    Renvoie:\n    Union[int, str]: Le nombre minimum d'étapes de transformation si possible, sinon \"NO ANSWER!\".\n\n    Exemples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "de": "Schreiben Sie eine Python-Funktion 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' um das folgende Problem zu lösen:\n\n    Führen Sie eine Zeichenkettenumwandlung von A zu B unter Verwendung eines Satzes von Umwandlungsregeln durch.\n\n    Diese Funktion nimmt eine Anfangszeichenkette A und eine Zielzeichenkette B, zusammen mit einer Liste\n    von Umwandlungsregeln, und versucht, A mithilfe der Regeln in B umzuwandeln.\n    Ein Breadth-First Search (BFS)-Algorithmus wird verwendet, um die möglichen Umwandlungen\n    bis zu einem Maximum von 10 Schritten zu erkunden. Wenn A innerhalb von 10 Schritten in B umgewandelt werden kann, gibt die Funktion\n    die minimale Anzahl der erforderlichen Schritte zurück. Wenn es nicht möglich ist, gibt die Funktion\n    \"NO ANSWER!\" zurück.\n\n    Parameter:\n    A (str): Die anfängliche Zeichenkette, die umgewandelt werden soll.\n    B (str): Die Zielzeichenkette, die erreicht werden soll.\n    rules (list of tuples): Eine Liste von Umwandlungsregeln, wobei jede Regel ein Tupel ist,\n                            das das Quell-Substring (das ersetzt werden soll) und das\n                            Ziel-Substring (mit dem ersetzt werden soll) enthält.\n\n    Rückgabe:\n    Union[int, str]: Die minimale Anzahl der Umwandlungsschritte, wenn möglich, andernfalls \"NO ANSWER!\".\n\n    Beispiele:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "ha": "Rubuta wani aikin python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' don warware matsalar mai zuwa:\n\n    Yi sauyin kirtani daga A zuwa B ta amfani da saitin dokokin sauyi.\n\n    Wannan aikin yana ɗaukar kirtani na farko A da kirtani na manufa B, tare da jerin\n    dokokin sauyi, kuma yana ƙoƙarin sauya A zuwa B ta amfani da dokokin.\n    Ana amfani da wani algorithm na Bincike na Farko (BFS) don bincika yiwuwar sauye-sauye\n    har zuwa matakai 10 mafi girma. Idan za a iya sauya A zuwa B cikin matakai 10, aikin\n    yana dawowa da adadin matakan da ake bukata. Idan ba zai yiwu ba, aikin yana dawowa\n    \"BA AMSA!\".\n\n    Sigogi:\n    A (str): Kirtani na farko da za a sauya.\n    B (str): Kirtani na manufa da za a cimma.\n    rules (list of tuples): Jerin dokokin sauyi, inda kowanne doka yake da tuple\n                            dauke da kirtani na asali (da za a maye gurbinsa) da\n                            kirtani na manufa (da za a maye gurbinsa da shi).\n\n    Returns:\n    Union[int, str]: Mafi ƙarancin adadin matakan sauyi idan zai yiwu, in ba haka ba \"BA AMSA!\".\n\n    Misalai:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'BA AMSA!'", "hi": "एक पायथन फ़ंक्शन 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    परिवर्तन नियमों के सेट का उपयोग करके A से B तक स्ट्रिंग परिवर्तन करें।\n\n    यह फ़ंक्शन एक प्रारंभिक स्ट्रिंग A और एक लक्ष्य स्ट्रिंग B लेता है, साथ ही \n    परिवर्तन नियमों की एक सूची, और नियमों का उपयोग करके A को B में बदलने का प्रयास करता है।\n    संभावित परिवर्तनों का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) एल्गोरिदम का उपयोग किया जाता है\n    अधिकतम 10 चरणों तक। यदि A को 10 चरणों के भीतर B में बदला जा सकता है, तो फ़ंक्शन \n    आवश्यक न्यूनतम चरणों की संख्या लौटाता है। यदि यह संभव नहीं है, तो फ़ंक्शन \n    \"NO ANSWER!\" लौटाता है।\n\n    पैरामीटर्स:\n    A (str): प्रारंभिक स्ट्रिंग जिसे परिवर्तित किया जाना है।\n    B (str): लक्ष्य स्ट्रिंग जिसे प्राप्त किया जाना है।\n    rules (list of tuples): परिवर्तन नियमों की एक सूची, जहां प्रत्येक नियम एक टपल होता है\n                            जिसमें स्रोत उपस्ट्रिंग (जिसे बदला जाना है) और \n                            लक्ष्य उपस्ट्रिंग (जिससे बदलना है) होती है।\n\n    लौटाता है:\n    Union[int, str]: यदि संभव हो तो न्यूनतम परिवर्तन चरणों की संख्या, अन्यथा \"NO ANSWER!\".\n\n    उदाहरण:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "hu": "Írj egy python függvényt 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' a következő probléma megoldására:\n\n    Végezze el az A-ból B-be történő sztring transzformációt egy sor transzformációs szabály segítségével.\n\n    Ez a függvény egy kezdeti A sztringet és egy cél B sztringet vesz át, valamint egy listát\n    a transzformációs szabályokkal, és megpróbálja A-t B-vé alakítani a szabályok használatával.\n    Egy Szélességi Első Keresés (BFS) algoritmust használunk a lehetséges transzformációk\n    felfedezésére, legfeljebb 10 lépésig. Ha A 10 lépésen belül átalakítható B-vé, a függvény\n    visszaadja a szükséges minimális lépésszámot. Ha nem lehetséges, a függvény\n    \"NO ANSWER!\"-t ad vissza.\n\n    Paraméterek:\n    A (str): Az átalakítandó kezdeti sztring.\n    B (str): Az elérendő cél sztring.\n    rules (list of tuples): Egy lista a transzformációs szabályokról, ahol minden szabály egy\n                            forrás részsztringet (amit ki kell cserélni) és egy\n                            cél részsztringet (amire ki kell cserélni) tartalmazó tuple.\n\n    Visszatérési érték:\n    Union[int, str]: A transzformációs lépések minimális száma, ha lehetséges, különben \"NO ANSWER!\".\n\n    Példák:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "es": "Escribe una función de Python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' para resolver el siguiente problema:\n\n    Realizar la transformación de cadena de A a B utilizando un conjunto de reglas de transformación.\n\n    Esta función toma una cadena inicial A y una cadena objetivo B, junto con una lista\n    de reglas de transformación, e intenta transformar A en B usando las reglas.\n    Se utiliza un algoritmo de Búsqueda en Anchura (BFS) para explorar las posibles transformaciones\n    hasta un máximo de 10 pasos. Si A puede transformarse en B dentro de 10 pasos, la función\n    devuelve el número mínimo de pasos requeridos. Si no es posible, la función devuelve\n    \"NO ANSWER!\".\n\n    Parámetros:\n    A (str): La cadena inicial a transformar.\n    B (str): La cadena objetivo a alcanzar.\n    rules (list of tuples): Una lista de reglas de transformación, donde cada regla es una tupla\n                            que contiene la subcadena fuente (a ser reemplazada) y la\n                            subcadena objetivo (con la que se reemplaza).\n\n    Devuelve:\n    Union[int, str]: El número mínimo de pasos de transformación si es posible, de lo contrario \"NO ANSWER!\".\n\n    Ejemplos:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "arb": "اكتب دالة بايثون 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' لحل المشكلة التالية:\n\n    قم بإجراء تحويل سلسلة من A إلى B باستخدام مجموعة من قواعد التحويل.\n\n    تأخذ هذه الدالة سلسلة ابتدائية A وسلسلة مستهدفة B، بالإضافة إلى قائمة\n    من قواعد التحويل، وتحاول تحويل A إلى B باستخدام القواعد.\n    يتم استخدام خوارزمية البحث بالعرض (BFS) لاستكشاف التحويلات الممكنة\n    بحد أقصى 10 خطوات. إذا كان بالإمكان تحويل A إلى B في غضون 10 خطوات، فإن الدالة\n    تعيد الحد الأدنى لعدد الخطوات المطلوبة. إذا لم يكن ذلك ممكنًا، فإن الدالة تعيد\n    \"NO ANSWER!\".\n\n    المعاملات:\n    A (str): السلسلة الابتدائية التي سيتم تحويلها.\n    B (str): السلسلة المستهدفة التي يجب تحقيقها.\n    rules (list of tuples): قائمة بقواعد التحويل، حيث تكون كل قاعدة عبارة عن زوج\n                            يحتوي على الجزء الفرعي المصدر (الذي سيتم استبداله) والجزء\n                            الفرعي الهدف (الذي سيتم الاستبدال به).\n\n    العوائد:\n    Union[int, str]: الحد الأدنى لعدد خطوات التحويل إذا كان ذلك ممكنًا، وإلا \"NO ANSWER!\".\n\n    أمثلة:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "sw": "Andika kazi ya python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' kutatua tatizo lifuatalo:\n\n    Fanya mabadiliko ya kamba kutoka A hadi B kwa kutumia seti ya sheria za mabadiliko.\n\n    Kazi hii inachukua kamba ya awali A na kamba lengwa B, pamoja na orodha\n    ya sheria za mabadiliko, na inajaribu kubadilisha A kuwa B kwa kutumia sheria hizo.\n    Algorithimu ya Utafutaji wa Upana Kwanza (BFS) inatumika kuchunguza mabadiliko yanayowezekana\n    hadi kiwango cha juu cha hatua 10. Ikiwa A inaweza kubadilishwa kuwa B ndani ya hatua 10,\n    kazi inarudisha idadi ndogo ya hatua zinazohitajika. Ikiwa haiwezekani, kazi inarudisha\n    \"NO ANSWER!\".\n\n    Vigezo:\n    A (str): Kamba ya awali inayotakiwa kubadilishwa.\n    B (str): Kamba lengwa inayotakiwa kufikiwa.\n    rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria ni jozi\n                            inayojumuisha sehemu ndogo ya chanzo (itakayobadilishwa) na\n                            sehemu ndogo ya lengwa (ya kubadilisha nayo).\n\n    Inarejesha:\n    Union[int, str]: Idadi ndogo ya hatua za mabadiliko ikiwa inawezekana, vinginevyo \"NO ANSWER!\".\n\n    Mifano:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "tr": "Bir python fonksiyonu 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' yazarak aşağıdaki problemi çözün:\n\n    A'dan B'ye bir dizi dönüşüm kuralı kullanarak string dönüşümü gerçekleştirin.\n\n    Bu fonksiyon, başlangıç stringi A ve hedef string B'yi, dönüşüm kuralları listesi ile birlikte alır\n    ve A'yı B'ye kuralları kullanarak dönüştürmeye çalışır.\n    Olası dönüşümleri en fazla 10 adımda keşfetmek için Genişlik Öncelikli Arama (BFS) algoritması kullanılır.\n    Eğer A, 10 adım içinde B'ye dönüştürülebilirse, fonksiyon gereken minimum adım sayısını döndürür. \n    Eğer mümkün değilse, fonksiyon \"NO ANSWER!\" döndürür.\n\n    Parametreler:\n    A (str): Dönüştürülecek başlangıç stringi.\n    B (str): Elde edilmesi gereken hedef string.\n    rules (list of tuples): Her bir kuralın, kaynak alt dize (değiştirilecek) ve\n                            hedef alt dizeyi (ile değiştirilecek) içeren bir demet olduğu dönüşüm kuralları listesi.\n\n    Döndürür:\n    Union[int, str]: Mümkünse minimum dönüşüm adım sayısı, aksi takdirde \"NO ANSWER!\".\n\n    Örnekler:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "vi": "Viết một hàm python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' để giải quyết vấn đề sau:\n\n    Thực hiện chuyển đổi chuỗi từ A sang B sử dụng một tập hợp các quy tắc chuyển đổi.\n\n    Hàm này nhận một chuỗi ban đầu A và một chuỗi mục tiêu B, cùng với một danh sách\n    các quy tắc chuyển đổi, và cố gắng chuyển đổi A thành B sử dụng các quy tắc đó.\n    Thuật toán Tìm kiếm theo chiều rộng (BFS) được sử dụng để khám phá các chuyển đổi có thể\n    lên đến tối đa 10 bước. Nếu A có thể được chuyển đổi thành B trong vòng 10 bước, hàm\n    trả về số bước tối thiểu cần thiết. Nếu không thể, hàm trả về\n    \"NO ANSWER!\".\n\n    Tham số:\n    A (str): Chuỗi ban đầu cần chuyển đổi.\n    B (str): Chuỗi mục tiêu cần đạt được.\n    rules (list of tuples): Một danh sách các quy tắc chuyển đổi, trong đó mỗi quy tắc là một tuple\n                            chứa chuỗi con nguồn (cần thay thế) và chuỗi con mục tiêu (để thay thế).\n\n    Trả về:\n    Union[int, str]: Số bước chuyển đổi tối thiểu nếu có thể, nếu không thì \"NO ANSWER!\".\n\n    Ví dụ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "id": "Tulis fungsi python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' untuk menyelesaikan masalah berikut:\n\n    Lakukan transformasi string dari A ke B menggunakan serangkaian aturan transformasi.\n\n    Fungsi ini mengambil string awal A dan string target B, bersama dengan daftar\n    aturan transformasi, dan mencoba untuk mengubah A menjadi B menggunakan aturan-aturan tersebut.\n    Algoritma Breadth-First Search (BFS) digunakan untuk mengeksplorasi kemungkinan transformasi\n    hingga maksimum 10 langkah. Jika A dapat diubah menjadi B dalam 10 langkah, fungsi\n    mengembalikan jumlah langkah minimum yang diperlukan. Jika tidak mungkin, fungsi mengembalikan\n    \"NO ANSWER!\".\n\n    Parameter:\n    A (str): String awal yang akan diubah.\n    B (str): String target yang ingin dicapai.\n    rules (list of tuples): Daftar aturan transformasi, di mana setiap aturan adalah tuple\n                            yang berisi substring sumber (yang akan diganti) dan\n                            substring target (untuk menggantikan).\n\n    Mengembalikan:\n    Union[int, str]: Jumlah langkah transformasi minimum jika memungkinkan, jika tidak \"NO ANSWER!\".\n\n    Contoh:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "ja": "Python関数 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' を作成して、次の問題を解決してください:\n\n    一連の変換ルールを使用して、文字列AからBへの変換を実行します。\n\n    この関数は、初期文字列Aとターゲット文字列B、および変換ルールのリストを受け取り、\n    ルールを使用してAをBに変換しようとします。\n    幅優先探索（BFS）アルゴリズムを使用して、最大10ステップまでの可能な変換を探索します。\n    もしAが10ステップ以内にBに変換できる場合、関数は必要な最小ステップ数を返します。\n    変換が不可能な場合、関数は \"NO ANSWER!\" を返します。\n\n    パラメータ:\n    A (str): 変換される初期文字列。\n    B (str): 達成されるべきターゲット文字列。\n    rules (list of tuples): 変換ルールのリスト。各ルールは、置き換えられるソース部分文字列と\n                            置き換えるターゲット部分文字列を含むタプルです。\n\n    戻り値:\n    Union[int, str]: 変換が可能な場合は最小の変換ステップ数、そうでない場合は \"NO ANSWER!\"。\n\n    例:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "ko": "파이썬 함수를 작성하세요 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' 다음 문제를 해결하기 위해:\n\n    A에서 B로의 문자열 변환을 일련의 변환 규칙을 사용하여 수행합니다.\n\n    이 함수는 초기 문자열 A와 목표 문자열 B, 그리고 변환 규칙의 목록을 받아,\n    규칙을 사용하여 A를 B로 변환하려고 시도합니다.\n    너비 우선 탐색(BFS) 알고리즘을 사용하여 최대 10단계까지 가능한 변환을 탐색합니다.\n    A를 10단계 이내에 B로 변환할 수 있으면, 함수는 필요한 최소 단계 수를 반환합니다.\n    불가능할 경우, 함수는 \"NO ANSWER!\"를 반환합니다.\n\n    매개변수:\n    A (str): 변환할 초기 문자열.\n    B (str): 목표로 하는 문자열.\n    rules (list of tuples): 변환 규칙의 목록으로, 각 규칙은 소스 부분 문자열(교체할 부분)과\n                            대상 부분 문자열(교체할 내용)을 포함하는 튜플입니다.\n\n    반환값:\n    Union[int, str]: 가능한 경우 최소 변환 단계 수, 그렇지 않으면 \"NO ANSWER!\".\n\n    예시:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "ml": "'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' എന്ന പൈതൺ ഫംഗ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കുന്നതിന്:\n\n    ഒരു സെറ്റ് ട്രാൻസ്ഫർമേഷൻ നിയമങ്ങൾ ഉപയോഗിച്ച് A ൽ നിന്ന് B ലേക്ക് സ്ട്രിംഗ് ട്രാൻസ്ഫർമേഷൻ നടത്തുക.\n\n    ഈ ഫംഗ്ഷൻ ഒരു പ്രാരംഭ സ്ട്രിംഗ് A, ഒരു ലക്ഷ്യ സ്ട്രിംഗ് B, കൂടാതെ ഒരു ട്രാൻസ്ഫർമേഷൻ നിയമങ്ങളുടെ പട്ടിക സ്വീകരിക്കുന്നു,\n    നിയമങ്ങൾ ഉപയോഗിച്ച് A നെ B ആക്കി മാറ്റാൻ ശ്രമിക്കുന്നു. \n    പരമാവധി 10 ഘട്ടങ്ങൾ വരെ സാധ്യതയുള്ള ട്രാൻസ്ഫർമേഷനുകൾ പരിശോധിക്കാൻ ബ്രെഡ്ത്ത്-ഫസ്റ്റ് സെർച്ച (BFS) ആൽഗോരിതം ഉപയോഗിക്കുന്നു. \n    A നെ 10 ഘട്ടങ്ങൾക്കുള്ളിൽ B ആക്കി മാറ്റാൻ കഴിയുമെങ്കിൽ, ഫംഗ്ഷൻ ആവശ്യമായ കുറഞ്ഞ ഘട്ടങ്ങളുടെ എണ്ണം തിരികെ നൽകുന്നു. \n    അത് സാധ്യമല്ലെങ്കിൽ, ഫംഗ്ഷൻ \"NO ANSWER!\" തിരികെ നൽകുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    A (str): മാറ്റം വരുത്തേണ്ട പ്രാരംഭ സ്ട്രിംഗ്.\n    B (str): കൈവരിക്കേണ്ട ലക്ഷ്യ സ്ട്രിംഗ്.\n    rules (list of tuples): ട്രാൻസ്ഫർമേഷൻ നിയമങ്ങളുടെ പട്ടിക, ഓരോ നിയമവും ഉറവിട സബ്സ്ട്രിംഗ് (മാറ്റേണ്ടത്) \n                            കൂടാതെ ലക്ഷ്യ സബ്സ്ട്രിംഗ് (മാറ്റേണ്ടത്) അടങ്ങിയ ഒരു ട്യുപിളാണ്.\n\n    മടക്കങ്ങൾ:\n    Union[int, str]: സാധ്യമെങ്കിൽ കുറഞ്ഞ ട്രാൻസ്ഫർമേഷൻ ഘട്ടങ്ങളുടെ എണ്ണം, അല്ലെങ്കിൽ \"NO ANSWER!\".\n\n    ഉദാഹരണങ്ങൾ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "fa": "یک تابع پایتون بنویسید 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' برای حل مسئله زیر:\n\n    انجام تبدیل رشته از A به B با استفاده از مجموعه‌ای از قوانین تبدیل.\n\n    این تابع یک رشته اولیه A و یک رشته هدف B را به همراه یک لیست\n    از قوانین تبدیل می‌گیرد و تلاش می‌کند A را با استفاده از قوانین به B تبدیل کند.\n    از الگوریتم جستجوی اول سطح (BFS) برای بررسی تبدیل‌های ممکن\n    تا حداکثر 10 مرحله استفاده می‌شود. اگر A بتواند در 10 مرحله به B تبدیل شود، تابع\n    حداقل تعداد مراحل مورد نیاز را برمی‌گرداند. اگر ممکن نباشد، تابع\n    \"NO ANSWER!\" را برمی‌گرداند.\n\n    پارامترها:\n    A (str): رشته اولیه که باید تبدیل شود.\n    B (str): رشته هدف که باید به آن دست یافت.\n    rules (list of tuples): لیستی از قوانین تبدیل، که هر قانون یک جفت\n                            شامل زیررشته منبع (که باید جایگزین شود) و زیررشته هدف (که با آن جایگزین می‌شود) است.\n\n    بازگشت:\n    Union[int, str]: حداقل تعداد مراحل تبدیل اگر ممکن باشد، در غیر این صورت \"NO ANSWER!\".\n\n    مثال‌ها:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'"}, "level": "hard", "test": "def test_string_transformation():\n    # Test case 1\n    A1 = \"abcd\"\n    B1 = \"xyz\"\n    rules1 = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    expected_result1 = 3\n    assert string_transformation(A1, B1, rules1) == expected_result1, \"Test case 1 failed\"\n\n    # Test case 2\n    A2 = \"aaa\"\n    B2 = \"bbbb\"\n    rules2 = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    expected_result2 = \"NO ANSWER!\"\n    assert string_transformation(A2, B2, rules2) == expected_result2, \"Test case 2 failed\"\n\n    # Test case 3\n    A3 = \"hello\"\n    B3 = \"world\"\n    rules3 = [(\"h\", \"w\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"lol\", \"ldr\")]\n    expected_result3 = \"NO ANSWER!\"\n    assert string_transformation(A3, B3, rules3) == expected_result3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_string_transformation()", "entry_point": "string_transformation", "signature": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:", "docstring": {"en": "\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    ", "sq": "\n    Kryeni transformimin e vargut nga A në B duke përdorur një grup rregullash transformimi.\n\n    Kjo funksion merr një varg fillestar A dhe një varg të synuar B, së bashku me një listë\n    rregullash transformimi, dhe përpiqet të transformojë A në B duke përdorur rregullat.\n    Një algoritëm Kërkimi në Gjerësi (BFS) përdoret për të eksploruar transformimet e mundshme\n    deri në një maksimum prej 10 hapash. Nëse A mund të transformohet në B brenda 10 hapash, funksioni\n    kthen numrin minimal të hapave të nevojshëm. Nëse nuk është e mundur, funksioni kthen\n    \"NO ANSWER!\".\n\n    Parametrat:\n    A (str): Vargu fillestar që do të transformohet.\n    B (str): Vargu i synuar që do të arrihet.\n    rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull është një tuple\n                            që përmban nënvargun burimor (që do të zëvendësohet) dhe\n                            nënvargun e synuar (me të cilin do të zëvendësohet).\n\n    Kthen:\n    Union[int, str]: Numri minimal i hapave të transformimit nëse është e mundur, përndryshe \"NO ANSWER!\".\n\n    Shembuj:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "hy": "\n    Կատարել տողի փոխակերպում A-ից B օգտագործելով փոխակերպման կանոնների հավաքածու։\n\n    Այս ֆունկցիան վերցնում է սկզբնական տող A և նպատակային տող B, ինչպես նաև փոխակերպման կանոնների ցուցակ,\n    և փորձում է փոխակերպել A-ն B-ի՝ օգտագործելով այդ կանոնները։ Լայնության Առաջին Որոնման (BFS) ալգորիթմը\n    օգտագործվում է հնարավոր փոխակերպումները ուսումնասիրելու համար՝ առավելագույնը 10 քայլով։ Եթե A-ն հնարավոր է\n    փոխակերպել B-ի 10 քայլի ընթացքում, ֆունկցիան վերադարձնում է պահանջվող նվազագույն քայլերի քանակը։\n    Եթե դա հնարավոր չէ, ֆունկցիան վերադարձնում է \"NO ANSWER!\"։\n\n    Պարամետրեր:\n    A (str): Սկզբնական տողը, որը պետք է փոխակերպվի։\n    B (str): Նպատակային տողը, որը պետք է ստացվի։\n    rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն\n                            զույգ է, որը պարունակում է աղբյուր ենթատողը (որը պետք է փոխարինվի)\n                            և նպատակային ենթատողը (որով պետք է փոխարինել)։\n\n    Վերադարձնում է:\n    Union[int, str]: Փոխակերպման նվազագույն քայլերի քանակը, եթե հնարավոր է, հակառակ դեպքում \"NO ANSWER!\"։\n\n    Օրինակներ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "bn": "\n    একটি সেট রূপান্তর নিয়ম ব্যবহার করে স্ট্রিং A থেকে B এ রূপান্তর সম্পাদন করুন।\n\n    এই ফাংশনটি একটি প্রাথমিক স্ট্রিং A এবং একটি লক্ষ্য স্ট্রিং B গ্রহণ করে, সাথে একটি রূপান্তর নিয়মের তালিকা,\n    এবং নিয়মগুলি ব্যবহার করে A কে B তে রূপান্তর করার চেষ্টা করে। একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) অ্যালগরিদম\n    ব্যবহার করা হয় সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে সর্বাধিক 10 ধাপ পর্যন্ত। যদি A কে 10 ধাপের মধ্যে B তে\n    রূপান্তর করা যায়, ফাংশনটি প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা ফেরত দেয়। যদি এটি সম্ভব না হয়, ফাংশনটি\n    \"NO ANSWER!\" ফেরত দেয়।\n\n    প্যারামিটারসমূহ:\n    A (str): প্রাথমিক স্ট্রিং যা রূপান্তরিত হবে।\n    B (str): লক্ষ্য স্ট্রিং যা অর্জন করতে হবে।\n    rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টাপল\n                            যা উৎস সাবস্ট্রিং (প্রতিস্থাপন করতে হবে) এবং লক্ষ্য সাবস্ট্রিং\n                            (যা দিয়ে প্রতিস্থাপন করতে হবে) ধারণ করে।\n\n    রিটার্নস:\n    Union[int, str]: যদি সম্ভব হয় তবে রূপান্তরের সর্বনিম্ন ধাপের সংখ্যা, অন্যথায় \"NO ANSWER!\".\n\n    উদাহরণ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "bg": "\n    Извършете трансформация на низ от A към B, използвайки набор от правила за трансформация.\n\n    Тази функция приема начален низ A и целеви низ B, заедно със списък от правила за трансформация, и се опитва да трансформира A в B, използвайки правилата. Използва се алгоритъм за търсене в широчина (BFS), за да се изследват възможните трансформации до максимум 10 стъпки. Ако A може да бъде трансформиран в B в рамките на 10 стъпки, функцията връща минималния брой необходими стъпки. Ако не е възможно, функцията връща \"NO ANSWER!\".\n\n    Параметри:\n    A (str): Началният низ, който трябва да бъде трансформиран.\n    B (str): Целевият низ, който трябва да бъде постигнат.\n    rules (list of tuples): Списък от правила за трансформация, където всяко правило е кортеж, съдържащ изходния подниз (който да бъде заменен) и целевия подниз (с който да се замени).\n\n    Връща:\n    Union[int, str]: Минималният брой стъпки за трансформация, ако е възможно, в противен случай \"NO ANSWER!\".\n\n    Примери:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "zh": "\n    使用一组转换规则将字符串从A转换为B。\n\n    该函数接收一个初始字符串A和一个目标字符串B，以及一个转换规则列表，并尝试使用这些规则将A转换为B。\n    使用广度优先搜索(BFS)算法来探索可能的转换，最多进行10步。\n    如果A可以在10步内转换为B，函数返回所需的最小步骤数。\n    如果不可能转换，函数返回\"NO ANSWER!\"。\n\n    参数:\n    A (str): 要转换的初始字符串。\n    B (str): 要达到的目标字符串。\n    rules (list of tuples): 转换规则列表，其中每个规则是一个包含源子字符串（要替换的）和目标子字符串（用于替换）的元组。\n\n    返回:\n    Union[int, str]: 如果可能，返回最小转换步骤数，否则返回\"NO ANSWER!\"。\n\n    示例:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "fr": "\n    Effectuer une transformation de chaîne de A à B en utilisant un ensemble de règles de transformation.\n\n    Cette fonction prend une chaîne initiale A et une chaîne cible B, ainsi qu'une liste\n    de règles de transformation, et tente de transformer A en B en utilisant les règles.\n    Un algorithme de recherche en largeur (BFS) est utilisé pour explorer les transformations possibles\n    jusqu'à un maximum de 10 étapes. Si A peut être transformé en B en 10 étapes, la fonction\n    retourne le nombre minimum d'étapes requises. Si ce n'est pas possible, la fonction retourne\n    \"PAS DE RÉPONSE!\".\n\n    Paramètres:\n    A (str): La chaîne initiale à transformer.\n    B (str): La chaîne cible à atteindre.\n    rules (list of tuples): Une liste de règles de transformation, où chaque règle est un tuple\n                            contenant la sous-chaîne source (à remplacer) et la\n                            sous-chaîne cible (pour remplacer).\n\n    Renvoie:\n    Union[int, str]: Le nombre minimum d'étapes de transformation si possible, sinon \"PAS DE RÉPONSE!\".\n\n    Exemples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "de": "\n    Führe eine Zeichenkettenumwandlung von A nach B unter Verwendung eines Satzes von Umwandlungsregeln durch.\n\n    Diese Funktion nimmt eine Anfangszeichenkette A und eine Zielzeichenkette B sowie eine Liste\n    von Umwandlungsregeln und versucht, A mithilfe der Regeln in B umzuwandeln.\n    Ein Breadth-First Search (BFS) Algorithmus wird verwendet, um die möglichen Umwandlungen\n    bis zu einem Maximum von 10 Schritten zu erkunden. Wenn A innerhalb von 10 Schritten in B\n    umgewandelt werden kann, gibt die Funktion die minimale Anzahl der erforderlichen Schritte zurück.\n    Wenn es nicht möglich ist, gibt die Funktion \"NO ANSWER!\" zurück.\n\n    Parameter:\n    A (str): Die anfängliche Zeichenkette, die umgewandelt werden soll.\n    B (str): Die Zielzeichenkette, die erreicht werden soll.\n    rules (list of tuples): Eine Liste von Umwandlungsregeln, wobei jede Regel ein Tupel ist,\n                            das das Quell-Teilzeichenkette (die ersetzt werden soll) und die\n                            Ziel-Teilzeichenkette (die ersetzt werden soll) enthält.\n\n    Rückgabe:\n    Union[int, str]: Die minimale Anzahl der Umwandlungsschritte, wenn möglich, andernfalls \"NO ANSWER!\".\n\n    Beispiele:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "ha": "\n    Yi canjin kirtani daga A zuwa B ta amfani da saitin dokokin canji.\n\n    Wannan aikin yana daukar kirtani na farko A da kirtani na manufa B, tare da jerin\n    dokokin canji, kuma yana ƙoƙarin canza A zuwa B ta amfani da dokokin.\n    Ana amfani da dabarar Binciken Farko (BFS) don bincika yiwuwar canje-canje\n    har zuwa matakai 10 na sama. Idan za a iya canza A zuwa B cikin matakai 10, aikin\n    yana mayar da adadin matakan da ake bukata. Idan ba zai yiwu ba, aikin yana mayar da\n    \"BA AMSA!\".\n\n    Sigogi:\n    A (str): Kirtani na farko da za a canza.\n    B (str): Kirtani na manufa da za a cimma.\n    dokoki (jerin tuples): Jerin dokokin canji, inda kowace doka take da tuple\n                           wanda ke dauke da kirtani na asali (da za a maye gurbin) da\n                           kirtani na manufa (da za a maye gurbinsa da shi).\n\n    Komawa:\n    Union[int, str]: Mafi karancin adadin matakan canji idan zai yiwu, in ba haka ba \"BA AMSA!\".\n\n    Misalai:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "hi": "\n    A से B में स्ट्रिंग परिवर्तन एक सेट के परिवर्तन नियमों का उपयोग करके करें।\n\n    यह फ़ंक्शन एक प्रारंभिक स्ट्रिंग A और एक लक्ष्य स्ट्रिंग B लेता है, साथ ही परिवर्तन नियमों की एक सूची,\n    और नियमों का उपयोग करके A को B में बदलने का प्रयास करता है।\n    संभावित परिवर्तनों का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) एल्गोरिदम का उपयोग किया जाता है\n    अधिकतम 10 चरणों तक। यदि A को 10 चरणों के भीतर B में बदला जा सकता है, तो फ़ंक्शन\n    आवश्यक न्यूनतम चरणों की संख्या लौटाता है। यदि यह संभव नहीं है, तो फ़ंक्शन\n    \"NO ANSWER!\" लौटाता है।\n\n    पैरामीटर्स:\n    A (str): प्रारंभिक स्ट्रिंग जिसे परिवर्तित किया जाना है।\n    B (str): लक्ष्य स्ट्रिंग जिसे प्राप्त किया जाना है।\n    rules (list of tuples): परिवर्तन नियमों की एक सूची, जहाँ प्रत्येक नियम एक युग्म है\n                            जिसमें स्रोत उपस्ट्रिंग (जिसे बदला जाना है) और\n                            लक्ष्य उपस्ट्रिंग (जिससे बदला जाएगा) शामिल है।\n\n    रिटर्न्स:\n    Union[int, str]: यदि संभव हो तो न्यूनतम परिवर्तन चरणों की संख्या, अन्यथा \"NO ANSWER!\".\n\n    उदाहरण:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "hu": "\n    Végezze el az A sztring átalakítását B sztringgé egy halmaz transzformációs szabály segítségével.\n\n    Ez a függvény egy kezdeti A sztringet és egy cél B sztringet vesz át, valamint egy\n    transzformációs szabályok listáját, és megpróbálja A-t B-vé alakítani a szabályok\n    segítségével. Egy Szélességi Első Keresés (BFS) algoritmus kerül alkalmazásra a lehetséges\n    átalakítások felfedezésére legfeljebb 10 lépésig. Ha A 10 lépésen belül átalakítható B-vé,\n    a függvény visszaadja a szükséges minimális lépések számát. Ha nem lehetséges, a függvény\n    \"NO ANSWER!\"-t ad vissza.\n\n    Paraméterek:\n    A (str): Az átalakítandó kezdeti sztring.\n    B (str): Az elérendő cél sztring.\n    rules (list of tuples): Egy lista transzformációs szabályokkal, ahol minden szabály egy\n                            olyan tuple, amely tartalmazza a forrás részsztringet (amit\n                            cserélni kell) és a cél részsztringet (amire cserélni kell).\n\n    Visszatér:\n    Union[int, str]: A minimális átalakítási lépések száma, ha lehetséges, ellenkező esetben \"NO ANSWER!\".\n\n    Példák:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "es": "    Realizar la transformación de cadena de A a B utilizando un conjunto de reglas de transformación.\n\n    Esta función toma una cadena inicial A y una cadena objetivo B, junto con una lista\n    de reglas de transformación, e intenta transformar A en B utilizando las reglas.\n    Se utiliza un algoritmo de Búsqueda en Anchura (BFS) para explorar las posibles transformaciones\n    hasta un máximo de 10 pasos. Si A se puede transformar en B dentro de 10 pasos, la función\n    devuelve el número mínimo de pasos requeridos. Si no es posible, la función devuelve\n    \"¡SIN RESPUESTA!\".\n\n    Parámetros:\n    A (str): La cadena inicial a transformar.\n    B (str): La cadena objetivo a alcanzar.\n    rules (list of tuples): Una lista de reglas de transformación, donde cada regla es una tupla\n                            que contiene la subcadena fuente (a ser reemplazada) y la\n                            subcadena objetivo (para reemplazar con).\n\n    Devuelve:\n    Union[int, str]: El número mínimo de pasos de transformación si es posible, de lo contrario \"¡SIN RESPUESTA!\".\n\n    Ejemplos:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    '¡SIN RESPUESTA!'", "arb": "    إجراء تحويل سلسلة من A إلى B باستخدام مجموعة من قواعد التحويل.\n\n    تأخذ هذه الدالة سلسلة ابتدائية A وسلسلة مستهدفة B، بالإضافة إلى قائمة\n    من قواعد التحويل، وتحاول تحويل A إلى B باستخدام القواعد.\n    يتم استخدام خوارزمية البحث بعرض أول (BFS) لاستكشاف التحويلات الممكنة\n    حتى حد أقصى يبلغ 10 خطوات. إذا كان من الممكن تحويل A إلى B في غضون 10 خطوات، فإن الدالة\n    تعيد الحد الأدنى لعدد الخطوات المطلوبة. إذا لم يكن ذلك ممكنًا، فإن الدالة تعيد\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): السلسلة الابتدائية المراد تحويلها.\n    B (str): السلسلة المستهدفة المراد تحقيقها.\n    rules (list of tuples): قائمة بقواعد التحويل، حيث تكون كل قاعدة عبارة عن زوج\n                            يحتوي على الجزء الفرعي المصدر (الذي سيتم استبداله) والجزء الفرعي الهدف (الذي سيتم الاستبدال به).\n\n    يعيد:\n    Union[int, str]: الحد الأدنى لعدد خطوات التحويل إذا كان ممكنًا، وإلا \"NO ANSWER!\".\n\n    امثله:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "sw": "    Fanya mabadiliko ya kamba kutoka A hadi B kwa kutumia seti ya sheria za mabadiliko.\n\n    Kazi hii inachukua kamba ya awali A na kamba lengwa B, pamoja na orodha\n    ya sheria za mabadiliko, na inajaribu kubadilisha A kuwa B kwa kutumia sheria hizo.\n    Algorithimu ya Utafutaji wa Upana Kwanza (BFS) inatumika kuchunguza mabadiliko yanayowezekana\n    hadi kiwango cha juu cha hatua 10. Ikiwa A inaweza kubadilishwa kuwa B ndani ya hatua 10, kazi\n    inarejesha idadi ndogo ya hatua zinazohitajika. Ikiwa haiwezekani, kazi inarejesha\n    \"HAKUNA JIBU!\".\n\n    Vigezo:\n    A (str): Kamba ya awali inayopaswa kubadilishwa.\n    B (str): Kamba lengwa inayopaswa kufikiwa.\n    rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria ni jozi\n                            inayojumuisha sehemu ndogo ya chanzo (inayopaswa kubadilishwa) na\n                            sehemu ndogo ya lengwa (ya kubadilisha nayo).\n\n    Inarejesha:\n    Union[int, str]: Idadi ndogo ya hatua za mabadiliko ikiwa inawezekana, vinginevyo \"HAKUNA JIBU!\".\n\n    Mifano:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'HAKUNA JIBU!'", "tr": "    A'dan B'ye bir dizi dönüşüm kuralı kullanarak string dönüşümü gerçekleştirin.\n\n    Bu fonksiyon, başlangıç stringi A ve hedef string B'yi, dönüşüm kuralları listesiyle birlikte alır\n    ve A'yı kuralları kullanarak B'ye dönüştürmeye çalışır. Olası dönüşümleri keşfetmek için\n    Genişlik Öncelikli Arama (BFS) algoritması kullanılır ve maksimum 10 adımda gerçekleştirilir.\n    Eğer A, 10 adım içinde B'ye dönüştürülebilirse, fonksiyon gerekli minimum adım sayısını döndürür.\n    Eğer mümkün değilse, fonksiyon \"NO ANSWER!\" döndürür.\n\n    Parametreler:\n    A (str): Dönüştürülecek başlangıç stringi.\n    B (str): Elde edilmek istenen hedef string.\n    rules (list of tuples): Her kuralın, kaynak alt stringi (değiştirilecek) ve\n                            hedef alt stringi (ile değiştirilecek) içeren bir tuple olduğu\n                            dönüşüm kuralları listesi.\n\n    Döndürür:\n    Union[int, str]: Mümkünse minimum dönüşüm adım sayısı, aksi takdirde \"NO ANSWER!\".\n\n    Örnekler:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "vi": "    Thực hiện chuyển đổi chuỗi từ A sang B bằng cách sử dụng một tập hợp các quy tắc chuyển đổi.\n\n    Hàm này nhận một chuỗi ban đầu A và một chuỗi đích B, cùng với một danh sách\n    các quy tắc chuyển đổi, và cố gắng chuyển đổi A thành B bằng cách sử dụng các quy tắc.\n    Thuật toán Tìm kiếm theo chiều rộng (BFS) được sử dụng để khám phá các chuyển đổi có thể\n    lên đến tối đa 10 bước. Nếu A có thể được chuyển đổi thành B trong vòng 10 bước, hàm\n    trả về số bước tối thiểu cần thiết. Nếu không thể, hàm trả về \"NO ANSWER!\".\n\n    Tham số:\n    A (str): Chuỗi ban đầu cần được chuyển đổi.\n    B (str): Chuỗi đích cần đạt được.\n    rules (list of tuples): Danh sách các quy tắc chuyển đổi, trong đó mỗi quy tắc là một bộ\n                            chứa chuỗi con nguồn (để được thay thế) và chuỗi con đích (để thay thế).\n\n    Trả về:\n    Union[int, str]: Số bước chuyển đổi tối thiểu nếu có thể, nếu không \"NO ANSWER!\".\n\n    Ví dụ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "id": "    Melakukan transformasi string dari A ke B menggunakan serangkaian aturan transformasi.\n\n    Fungsi ini mengambil string awal A dan string target B, bersama dengan daftar\n    aturan transformasi, dan mencoba untuk mengubah A menjadi B menggunakan aturan-aturan tersebut.\n    Algoritma Breadth-First Search (BFS) digunakan untuk mengeksplorasi kemungkinan transformasi\n    hingga maksimum 10 langkah. Jika A dapat diubah menjadi B dalam 10 langkah, fungsi\n    mengembalikan jumlah langkah minimum yang diperlukan. Jika tidak mungkin, fungsi mengembalikan\n    \"NO ANSWER!\".\n\n    Parameter:\n    A (str): String awal yang akan diubah.\n    B (str): String target yang ingin dicapai.\n    rules (list of tuples): Daftar aturan transformasi, di mana setiap aturan adalah tuple\n                            yang berisi substring sumber (yang akan diganti) dan\n                            substring target (untuk mengganti).\n\n    Mengembalikan:\n    Union[int, str]: Jumlah langkah transformasi minimum jika memungkinkan, jika tidak \"NO ANSWER!\".\n\n    Contoh:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "ja": "    AからBへの文字列変換を一連の変換ルールを使用して行います。\n\n    この関数は、初期文字列Aと目標文字列B、および変換ルールのリストを受け取り、\n    ルールを使用してAをBに変換しようとします。幅優先探索（BFS）アルゴリズムを使用して、\n    最大10ステップまでの可能な変換を探索します。Aが10ステップ以内にBに変換可能な場合、\n    関数は必要な最小ステップ数を返します。変換が不可能な場合、関数は\"NO ANSWER!\"を返します。\n\n    Parameters:\n    A (str): 変換される初期文字列。\n    B (str): 達成される目標文字列。\n    rules (list of tuples): 変換ルールのリスト。各ルールは、ソース部分文字列（置き換えられるもの）と\n                            ターゲット部分文字列（置き換えるもの）を含むタプルです。\n\n    Returns:\n    Union[int, str]: 変換が可能な場合は最小の変換ステップ数、そうでない場合は\"NO ANSWER!\"。\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "ko": "    문자열 변환 규칙 집합을 사용하여 문자열 A를 B로 변환합니다.\n\n    이 함수는 초기 문자열 A와 목표 문자열 B, 그리고 변환 규칙 목록을 받아\n    규칙을 사용하여 A를 B로 변환하려고 시도합니다.\n    너비 우선 탐색(BFS) 알고리즘을 사용하여 최대 10단계까지 가능한 변환을 탐색합니다.\n    A가 10단계 이내에 B로 변환될 수 있으면, 함수는 필요한 최소 단계 수를 반환합니다.\n    가능하지 않으면, 함수는 \"NO ANSWER!\"를 반환합니다.\n\n    매개변수:\n    A (str): 변환할 초기 문자열.\n    B (str): 목표로 하는 문자열.\n    rules (list of tuples): 변환 규칙의 목록으로, 각 규칙은 소스 부분 문자열(대체할 부분)과\n                            대상 부분 문자열(대체할 부분)로 구성된 튜플입니다.\n\n    반환값:\n    Union[int, str]: 가능하면 최소 변환 단계 수, 그렇지 않으면 \"NO ANSWER!\".\n\n    예제:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "ml": "    A നെ B ആക്കാൻ ഒരു സെറ്റ് മാറ്റം ചട്ടങ്ങൾ ഉപയോഗിച്ച് സ്ട്രിംഗ് മാറ്റം നടത്തുക.\n\n    ഈ ഫംഗ്ഷൻ ഒരു പ്രാരംഭ സ്ട്രിംഗ് A, ഒരു ലക്ഷ്യ സ്ട്രിംഗ് B, കൂടാതെ ഒരു മാറ്റ ചട്ടങ്ങളുടെ പട്ടിക സ്വീകരിക്കുന്നു, \n    A നെ B ആക്കാൻ ചട്ടങ്ങൾ ഉപയോഗിച്ച് ശ്രമിക്കുന്നു. \n    പരമാവധി 10 ഘട്ടങ്ങൾ വരെ സാധ്യതയുള്ള മാറ്റങ്ങൾ അന്വേഷിക്കാൻ ബ്രെഡ്‌ത്-ഫസ്റ്റ് സെർച്ച് (BFS) ആൽഗോരിതം ഉപയോഗിക്കുന്നു. \n    A നെ 10 ഘട്ടങ്ങൾക്കുള്ളിൽ B ആക്കാൻ കഴിയുമെങ്കിൽ, ഫംഗ്ഷൻ ആവശ്യമായ കുറഞ്ഞ ഘട്ടങ്ങളുടെ എണ്ണം തിരികെ നൽകുന്നു. \n    അത് സാധ്യമല്ലെങ്കിൽ, ഫംഗ്ഷൻ \"NO ANSWER!\" തിരികെ നൽകുന്നു.\n\n    Parameters:\n    A (str): മാറ്റേണ്ട പ്രാരംഭ സ്ട്രിംഗ്.\n    B (str): നേടേണ്ട ലക്ഷ്യ സ്ട്രിംഗ്.\n    rules (list of tuples): മാറ്റ ചട്ടങ്ങളുടെ പട്ടിക, ഓരോ ചട്ടവും ഒരു ട്യൂപ്പിള്‍ ആണ്\n                            ഉറവിട സബ്‌സ്ട്രിംഗ് (മാറ്റേണ്ടത്) കൂടാതെ\n                            ലക്ഷ്യ സബ്‌സ്ട്രിംഗ് (മാറ്റേണ്ടത്) അടങ്ങിയിരിക്കും.\n\n    Returns:\n    Union[int, str]: സാധ്യമായെങ്കിൽ കുറഞ്ഞ മാറ്റ ഘട്ടങ്ങളുടെ എണ്ണം, അല്ലെങ്കിൽ \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'", "fa": "    تبدیل رشته از A به B با استفاده از مجموعه‌ای از قوانین تبدیل.\n\n    این تابع یک رشته اولیه A و یک رشته هدف B را به همراه لیستی از قوانین تبدیل می‌گیرد و تلاش می‌کند\n    A را با استفاده از قوانین به B تبدیل کند. یک الگوریتم جستجوی اول سطح (BFS) برای بررسی\n    تبدیل‌های ممکن تا حداکثر 10 مرحله استفاده می‌شود. اگر A بتواند در 10 مرحله به B تبدیل شود،\n    تابع حداقل تعداد مراحل مورد نیاز را برمی‌گرداند. اگر ممکن نباشد، تابع \"NO ANSWER!\" را برمی‌گرداند.\n\n    پارامترها:\n    A (str): رشته اولیه‌ای که باید تبدیل شود.\n    B (str): رشته هدفی که باید به دست آید.\n    rules (list of tuples): لیستی از قوانین تبدیل، که هر قانون یک تاپل شامل زیررشته منبع (که باید جایگزین شود)\n                            و زیررشته هدف (که با آن جایگزین می‌شود) است.\n\n    بازگشت:\n    Union[int, str]: حداقل تعداد مراحل تبدیل در صورت امکان، در غیر این صورت \"NO ANSWER!\".\n\n    مثال‌ها:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'"}}
{"task_id": "Python/29", "prompt": {"en": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "sq": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Llogarit numrin më të vogël të plotë pozitiv n të tillë që shuma e serisë harmonike\n    deri në 1/n të jetë më e madhe se një numër i plotë pozitiv i dhënë k.\n\n    Seria harmonike është e përcaktuar si S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentet:\n    - k (int): Një numër i plotë pozitiv që përfaqëson vlerën e pragut që shuma e serisë harmonike duhet të tejkalojë.\n\n    Kthen:\n    - int: Numri më i vogël i plotë n për të cilin shuma e serisë harmonike S_n tejkalon pragun k.\n\n    Shembuj:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "hy": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Հաշվել ամենափոքր դրական ամբողջ թիվը n, այնպես որ հարմոնիկ շարքի գումարը\n    մինչև 1/n մեծ լինի տրված դրական ամբողջ թիվ k-ից։\n\n    Հարմոնիկ շարքը սահմանվում է որպես S_n = 1 + 1/2 + 1/3 + ... + 1/n։\n\n    Պարամետրեր:\n    - k (int): Դրական ամբողջ թիվ, որը ներկայացնում է շեմային արժեքը, որը հարմոնիկ շարքի գումարը պետք է գերազանցի։\n\n    Վերադարձնում է:\n    - int: Ամենափոքր ամբողջ թիվը n, որի համար հարմոնիկ շարքի գումարը S_n գերազանցում է շեմը k։\n\n    Օրինակներ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "bn": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    এমন ক্ষুদ্রতম ধনাত্মক পূর্ণসংখ্যা n নির্ণয় করুন যাতে হারমোনিক সিরিজের \n    যোগফল 1/n পর্যন্ত প্রদত্ত ধনাত্মক পূর্ণসংখ্যা k এর চেয়ে বেশি হয়।\n\n    হারমোনিক সিরিজকে সংজ্ঞায়িত করা হয় S_n = 1 + 1/2 + 1/3 + ... + 1/n হিসাবে।\n\n    আর্গুমেন্ট:\n    - k (int): একটি ধনাত্মক পূর্ণসংখ্যা যা হারমোনিক সিরিজের যোগফলকে অতিক্রম করতে হবে এমন থ্রেশহোল্ড মানকে উপস্থাপন করে।\n\n    রিটার্নস:\n    - int: এমন ক্ষুদ্রতম পূর্ণসংখ্যা n যার জন্য হারমোনিক সিরিজের যোগফল S_n থ্রেশহোল্ড k কে অতিক্রম করে।\n\n    উদাহরণ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "bg": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Изчислява най-малкото положително цяло число n, такова че сумата на хармоничната редица\n    до 1/n е по-голяма от дадено положително цяло число k.\n\n    Хармоничната редица е дефинирана като S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Аргументи:\n    - k (int): Положително цяло число, представляващо праговата стойност, която сумата на хармоничната редица трябва да надвиши.\n\n    Връща:\n    - int: Най-малкото цяло число n, за което сумата на хармоничната редица S_n надвишава прага k.\n\n    Примери:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "zh": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    计算最小的正整数 n，使得调和级数的和\n    达到 1/n 时大于给定的正整数 k。\n\n    调和级数定义为 S_n = 1 + 1/2 + 1/3 + ... + 1/n。\n\n    参数:\n    - k (int): 表示调和级数和必须超过的阈值的正整数。\n\n    返回:\n    - int: 调和级数和 S_n 超过阈值 k 的最小整数 n。\n\n    示例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "fr": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculer le plus petit entier positif n tel que la somme de la série harmonique\n    jusqu'à 1/n soit supérieure à un entier positif donné k.\n\n    La série harmonique est définie comme S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Un entier positif représentant la valeur seuil que la somme de la série harmonique doit dépasser.\n\n    Returns:\n    - int: Le plus petit entier n pour lequel la somme de la série harmonique S_n dépasse le seuil k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "de": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Berechne die kleinste positive ganze Zahl n, sodass die Summe der harmonischen Reihe\n    bis 1/n größer ist als eine gegebene positive ganze Zahl k.\n\n    Die harmonische Reihe ist definiert als S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumente:\n    - k (int): Eine positive ganze Zahl, die den Schwellenwert darstellt, den die Summe der harmonischen Reihe überschreiten muss.\n\n    Rückgabewerte:\n    - int: Die kleinste ganze Zahl n, für die die Summe der harmonischen Reihe S_n den Schwellenwert k überschreitet.\n\n    Beispiele:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "ha": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Lissafi mafi ƙarancin lamba mai kyau n ta yadda jumlar jerin harmonic\n    har zuwa 1/n ya fi wani lamba mai kyau k.\n\n    An ayyana jerin harmonic a matsayin S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Lamba mai kyau da ke wakiltar ƙimar ƙofa da jumlar jerin harmonic dole ta wuce.\n\n    Returns:\n    - int: Mafi ƙarancin lamba n wanda jumlar jerin harmonic S_n ta wuce ƙimar ƙofa k.\n\n    Misalai:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "hi": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    उस सबसे छोटे धनात्मक पूर्णांक n की गणना करें ताकि हार्मोनिक श्रेणी का योग\n    1/n तक दिए गए धनात्मक पूर्णांक k से अधिक हो।\n\n    हार्मोनिक श्रेणी को इस प्रकार परिभाषित किया गया है: S_n = 1 + 1/2 + 1/3 + ... + 1/n।\n\n    तर्क:\n    - k (int): एक धनात्मक पूर्णांक जो उस सीमा मान का प्रतिनिधित्व करता है जिसे हार्मोनिक श्रेणी का योग पार करना चाहिए।\n\n    वापसी:\n    - int: सबसे छोटा पूर्णांक n जिसके लिए हार्मोनिक श्रेणी का योग S_n सीमा k से अधिक होता है।\n\n    उदाहरण:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "hu": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Számítsd ki a legkisebb pozitív egész számot n, amelyre a harmonikus sorozat\n    1/n-ig terjedő összege nagyobb, mint egy adott pozitív egész szám k.\n\n    A harmonikus sorozat definíciója: S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Paraméterek:\n    - k (int): Egy pozitív egész szám, amely az a küszöbérték, amit a harmonikus sorozat összegének meg kell haladnia.\n\n    Visszatér:\n    - int: A legkisebb egész szám n, amelyre a harmonikus sorozat összege S_n meghaladja a k küszöbértéket.\n\n    Példák:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "es": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calcula el entero positivo más pequeño n tal que la suma de la serie armónica\n    hasta 1/n es mayor que un entero positivo dado k.\n\n    La serie armónica se define como S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentos:\n    - k (int): Un entero positivo que representa el valor umbral que la suma de la serie armónica debe exceder.\n\n    Retorna:\n    - int: El entero más pequeño n para el cual la suma de la serie armónica S_n excede el umbral k.\n\n    Ejemplos:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "arb": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    حساب أصغر عدد صحيح موجب n بحيث يكون مجموع السلسلة التوافقية\n    حتى 1/n أكبر من عدد صحيح موجب معين k.\n\n    السلسلة التوافقية تُعرّف كالتالي S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    يعيدالحجج:\n    - k (int): عدد صحيح موجب يمثل القيمة الحدية التي يجب أن يتجاوزها مجموع السلسلة التوافقية.\n\n    يعيد:\n    - int: أصغر عدد صحيح n بحيث يتجاوز مجموع السلسلة التوافقية S_n القيمة الحدية k.\n\n    امثله:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "sw": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Hesabu namba ndogo zaidi chanya n kiasi kwamba jumla ya mfululizo wa harmonic\n    hadi 1/n ni kubwa kuliko namba chanya iliyotolewa k.\n\n    Mfululizo wa harmonic unafafanuliwa kama S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Hoja:\n    - k (int): Namba chanya inayowakilisha thamani ya kizingiti ambacho jumla ya mfululizo wa harmonic lazima izidi.\n\n    Inarejesha:\n    - int: Namba ndogo zaidi n ambayo jumla ya mfululizo wa harmonic S_n inazidi kizingiti k.\n\n    Mifano:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "tr": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Harmonik serinin toplamı 1/n'ye kadar olan en küçük pozitif tamsayı n'yi hesaplayın\n    ve bu toplam verilen pozitif tamsayı k'dan büyük olsun.\n\n    Harmonik seri S_n = 1 + 1/2 + 1/3 + ... + 1/n olarak tanımlanır.\n\n    Argümanlar:\n    - k (int): Harmonik seri toplamının aşması gereken eşik değeri temsil eden pozitif bir tamsayı.\n\n    Döndürür:\n    - int: Harmonik seri toplamı S_n'nin eşik k'yı aştığı en küçük tamsayı n.\n\n    Örnekler:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "vi": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Tính toán số nguyên dương nhỏ nhất n sao cho tổng của chuỗi điều hòa\n    đến 1/n lớn hơn một số nguyên dương cho trước k.\n\n    Chuỗi điều hòa được định nghĩa là S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Tham số:\n    - k (int): Một số nguyên dương đại diện cho giá trị ngưỡng mà tổng chuỗi điều hòa phải vượt qua.\n\n    Trả về:\n    - int: Số nguyên nhỏ nhất n mà tổng chuỗi điều hòa S_n vượt qua ngưỡng k.\n\n    Ví dụ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "id": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Hitung bilangan bulat positif terkecil n sedemikian rupa sehingga jumlah deret harmonik\n    hingga 1/n lebih besar dari bilangan bulat positif k yang diberikan.\n\n    Deret harmonik didefinisikan sebagai S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumen:\n    - k (int): Bilangan bulat positif yang mewakili nilai ambang batas yang harus dilampaui oleh jumlah deret harmonik.\n\n    Mengembalikan:\n    - int: Bilangan bulat terkecil n di mana jumlah deret harmonik S_n melebihi ambang batas k.\n\n    Contoh:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "ja": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    調和級数の和が与えられた正の整数 k より大きくなるような最小の正の整数 n を計算します。\n\n    調和級数は S_n = 1 + 1/2 + 1/3 + ... + 1/n と定義されます。\n\n    引数:\n    - k (int): 調和級数の和が超えなければならないしきい値を表す正の整数。\n\n    戻り値:\n    - int: 調和級数の和 S_n がしきい値 k を超える最小の整数 n。\n\n    例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "ko": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    주어진 양의 정수 k보다 큰 조화급수의 합을 갖는 가장 작은 양의 정수 n을 계산합니다.\n\n    조화급수는 S_n = 1 + 1/2 + 1/3 + ... + 1/n으로 정의됩니다.\n\n    매개변수:\n    - k (int): 조화급수의 합이 초과해야 하는 임계값을 나타내는 양의 정수.\n\n    반환값:\n    - int: 조화급수의 합 S_n이 임계값 k를 초과하는 가장 작은 정수 n.\n\n    예시:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "ml": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    ഹാർമോണിക് ശ്രേണിയുടെ തുക 1/n വരെ നൽകിയിരിക്കുന്ന ധനമായ പൂർണ്ണസംഖ്യ k-നെക്കാൾ \n    കൂടുതലായിരിക്കേണ്ട ഏറ്റവും ചെറിയ ധനമായ പൂർണ്ണസംഖ്യ n കണക്കാക്കുക.\n\n    ഹാർമോണിക് ശ്രേണി S_n = 1 + 1/2 + 1/3 + ... + 1/n എന്നിങ്ങനെ നിർവ്വചിച്ചിരിക്കുന്നു.\n\n    Args:\n    - k (int): ഹാർമോണിക് ശ്രേണിയുടെ തുക കവിഞ്ഞിരിക്കേണ്ട പരിധി മൂല്യം പ്രതിനിധീകരിക്കുന്ന \n      ധനമായ പൂർണ്ണസംഖ്യ.\n\n    Returns:\n    - int: ഹാർമോണിക് ശ്രേണിയുടെ തുക S_n പരിധി k-നെക്കാൾ കൂടുതലായ ഏറ്റവും ചെറിയ \n      പൂർണ്ണസംഖ്യ n.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"", "fa": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    کوچکترین عدد صحیح مثبت n را محاسبه کنید به طوری که مجموع سری هارمونیک\n    تا 1/n بیشتر از یک عدد صحیح مثبت داده شده k باشد.\n\n    سری هارمونیک به صورت S_n = 1 + 1/2 + 1/3 + ... + 1/n تعریف می‌شود.\n\n    آرگومان‌ها:\n    - k (int): یک عدد صحیح مثبت که نشان‌دهنده مقدار آستانه‌ای است که مجموع سری هارمونیک باید از آن بیشتر شود.\n\n    بازگشت:\n    - int: کوچکترین عدد صحیح n که مجموع سری هارمونیک S_n از آستانه k بیشتر شود.\n\n    مثال‌ها:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\""}, "canonical_solution": "# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1", "instruction": {"en": "Write a python function 'def find_min_n_greater_than_k(k: int) -> int:' to solve the following problem:\n\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ", "sq": "Shkruani një funksion python 'def find_min_n_greater_than_k(k: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin më të vogël të plotë pozitiv n të tillë që shuma e serisë harmonike\n    deri në 1/n është më e madhe se një numër i plotë pozitiv i dhënë k.\n\n    Seria harmonike është e përcaktuar si S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Një numër i plotë pozitiv që përfaqëson vlerën prag që shuma e serisë harmonike duhet të tejkalojë.\n\n    Kthen:\n    - int: Numri më i vogël n për të cilin shuma e serisë harmonike S_n tejkalon pragun k.\n\n    Shembuj:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "hy": "Պայթոն ֆունկցիա 'def find_min_n_greater_than_k(k: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք ամենափոքր դրական ամբողջ թիվը n, այնպես որ հարմոնիկ շարքի գումարը\n    մինչև 1/n մեծ լինի տրված դրական ամբողջ թիվ k-ից:\n\n    Հարմոնիկ շարքը սահմանվում է որպես S_n = 1 + 1/2 + 1/3 + ... + 1/n:\n\n    Արգումենտներ:\n    - k (int): Դրական ամբողջ թիվ, որը ներկայացնում է շեմային արժեքը, որը հարմոնիկ շարքի գումարը պետք է գերազանցի:\n\n    Վերադարձնում է:\n    - int: Ամենափոքր ամբողջ թիվը n, որի համար հարմոնիկ շարքի գումարը S_n գերազանցում է շեմը k:\n\n    Օրինակներ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "bn": "একটি পাইথন ফাংশন 'def find_min_n_greater_than_k(k: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    এমন ক্ষুদ্রতম ধনাত্মক পূর্ণসংখ্যা n গণনা করুন যাতে 1/n পর্যন্ত হারমোনিক সিরিজের যোগফল\n    প্রদত্ত ধনাত্মক পূর্ণসংখ্যা k এর চেয়ে বেশি হয়।\n\n    হারমোনিক সিরিজটি S_n = 1 + 1/2 + 1/3 + ... + 1/n হিসাবে সংজ্ঞায়িত।\n\n    আর্গুমেন্টসমূহ:\n    - k (int): একটি ধনাত্মক পূর্ণসংখ্যা যা হারমোনিক সিরিজের যোগফলকে অতিক্রম করতে হবে এমন সীমা মান প্রতিনিধিত্ব করে।\n\n    রিটার্নস:\n    - int: ক্ষুদ্রতম পূর্ণসংখ্যা n যার জন্য হারমোনিক সিরিজের যোগফল S_n সীমা k অতিক্রম করে।\n\n    উদাহরণ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "bg": "Напишете Python функция 'def find_min_n_greater_than_k(k: int) -> int:' за да решите следния проблем:\n\n    Изчислете най-малкото положително цяло число n, така че сумата на хармоничната редица\n    до 1/n да е по-голяма от дадено положително цяло число k.\n\n    Хармоничната редица е дефинирана като S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Аргументи:\n    - k (int): Положително цяло число, представляващо праговата стойност, която сумата на хармоничната редица трябва да надвиши.\n\n    Връща:\n    - int: Най-малкото цяло число n, за което сумата на хармоничната редица S_n надвишава прага k.\n\n    Примери:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "zh": "编写一个python函数 'def find_min_n_greater_than_k(k: int) -> int:' 来解决以下问题：\n\n    计算最小的正整数n，使得调和级数的和\n    达到1/n时大于给定的正整数k。\n\n    调和级数定义为 S_n = 1 + 1/2 + 1/3 + ... + 1/n。\n\n    参数:\n    - k (int): 表示调和级数和必须超过的阈值的正整数。\n\n    返回:\n    - int: 调和级数和 S_n 超过阈值 k 的最小整数 n。\n\n    示例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "fr": "Écrivez une fonction python 'def find_min_n_greater_than_k(k: int) -> int:' pour résoudre le problème suivant :\n\n    Calculer le plus petit entier positif n tel que la somme de la série harmonique\n    jusqu'à 1/n soit supérieure à un entier positif donné k.\n\n    La série harmonique est définie comme S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Un entier positif représentant la valeur seuil que la somme de la série harmonique doit dépasser.\n\n    Returns:\n    - int: Le plus petit entier n pour lequel la somme de la série harmonique S_n dépasse le seuil k.\n\n    Exemples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "de": "Schreiben Sie eine Python-Funktion 'def find_min_n_greater_than_k(k: int) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die kleinste positive ganze Zahl n, sodass die Summe der harmonischen Reihe\n    bis 1/n größer ist als eine gegebene positive ganze Zahl k.\n\n    Die harmonische Reihe ist definiert als S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumente:\n    - k (int): Eine positive ganze Zahl, die den Schwellenwert darstellt, den die Summe der harmonischen Reihe überschreiten muss.\n\n    Rückgabewert:\n    - int: Die kleinste ganze Zahl n, für die die Summe der harmonischen Reihe S_n den Schwellenwert k überschreitet.\n\n    Beispiele:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "ha": "Rubuta wani aikin python 'def find_min_n_greater_than_k(k: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa ƙaramin lamba mai kyau n wanda adadin jerin harmonic\n    har zuwa 1/n ya fi wani lamba mai kyau k.\n\n    Jerin harmonic an bayyana shi kamar haka S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Lamba mai kyau wanda ke wakiltar ƙimar iyaka da adadin jerin harmonic dole ne ya wuce.\n\n    Returns:\n    - int: Mafi ƙarancin lamba n wanda adadin jerin harmonic S_n ya wuce iyaka k.\n\n    Misalai:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "hi": "एक पायथन फ़ंक्शन 'def find_min_n_greater_than_k(k: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    सबसे छोटा धनात्मक पूर्णांक n गणना करें ताकि हार्मोनिक श्रेणी का योग\n    1/n तक दिए गए धनात्मक पूर्णांक k से अधिक हो।\n\n    हार्मोनिक श्रेणी को इस प्रकार परिभाषित किया गया है: S_n = 1 + 1/2 + 1/3 + ... + 1/n।\n\n    तर्क:\n    - k (int): एक धनात्मक पूर्णांक जो उस सीमा मान का प्रतिनिधित्व करता है जिसे हार्मोनिक श्रेणी का योग पार करना चाहिए।\n\n    लौटाता है:\n    - int: सबसे छोटा पूर्णांक n जिसके लिए हार्मोनिक श्रेणी का योग S_n सीमा k को पार करता है।\n\n    उदाहरण:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "hu": "Írj egy python függvényt 'def find_min_n_greater_than_k(k: int) -> int:' a következő probléma megoldására:\n\n    Számítsd ki a legkisebb pozitív egész számot n, hogy a harmonikus sorozat\n    1/n-ig terjedő összege nagyobb legyen, mint egy adott pozitív egész szám k.\n\n    A harmonikus sorozat így van definiálva: S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Paraméterek:\n    - k (int): Egy pozitív egész szám, amely a küszöbértéket jelöli, amelyet a harmonikus sorozat összegének meg kell haladnia.\n\n    Visszatérési érték:\n    - int: A legkisebb egész szám n, amelyre a harmonikus sorozat összege S_n meghaladja a k küszöbértéket.\n\n    Példák:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "es": "Escribe una función de Python 'def find_min_n_greater_than_k(k: int) -> int:' para resolver el siguiente problema:\n\n    Calcular el menor entero positivo n tal que la suma de la serie armónica\n    hasta 1/n sea mayor que un entero positivo dado k.\n\n    La serie armónica se define como S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentos:\n    - k (int): Un entero positivo que representa el valor umbral que la suma de la serie armónica debe exceder.\n\n    Devuelve:\n    - int: El menor entero n para el cual la suma de la serie armónica S_n excede el umbral k.\n\n    Ejemplos:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "arb": "اكتب دالة بايثون 'def find_min_n_greater_than_k(k: int) -> int:' لحل المشكلة التالية:\n\n    احسب أصغر عدد صحيح موجب n بحيث يكون مجموع السلسلة التوافقية\n    حتى 1/n أكبر من عدد صحيح موجب معين k.\n\n    تُعرّف السلسلة التوافقية كالتالي S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    الوسائط:\n    - k (int): عدد صحيح موجب يمثل قيمة العتبة التي يجب أن يتجاوزها مجموع السلسلة التوافقية.\n\n    يعيد:\n    - int: أصغر عدد صحيح n حيث يتجاوز مجموع السلسلة التوافقية S_n العتبة k.\n\n    أمثلة:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "sw": "Andika kazi ya python 'def find_min_n_greater_than_k(k: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu nambari ndogo zaidi chanya n kiasi kwamba jumla ya mfululizo wa harmonic\n    hadi 1/n ni kubwa kuliko nambari chanya iliyotolewa k.\n\n    Mfululizo wa harmonic unafafanuliwa kama S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Hoja:\n    - k (int): Nambari chanya inayowakilisha thamani ya kizingiti ambayo jumla ya mfululizo wa harmonic lazima izidi.\n\n    Inarejesha:\n    - int: Nambari ndogo zaidi n ambayo jumla ya mfululizo wa harmonic S_n inazidi kizingiti k.\n\n    Mifano:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "tr": "Bir python fonksiyonu 'def find_min_n_greater_than_k(k: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Harmonik serinin toplamının 1/n'ye kadar olan kısmının\n    verilen pozitif bir tamsayı k'dan büyük olduğu en küçük pozitif tamsayı n'yi hesaplayın.\n\n    Harmonik seri S_n = 1 + 1/2 + 1/3 + ... + 1/n olarak tanımlanır.\n\n    Argümanlar:\n    - k (int): Harmonik seri toplamının aşması gereken eşik değerini temsil eden pozitif bir tamsayı.\n\n    Döndürür:\n    - int: Harmonik seri toplamı S_n'nin eşik k'yı aştığı en küçük tamsayı n.\n\n    Örnekler:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "vi": "Viết một hàm python 'def find_min_n_greater_than_k(k: int) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán số nguyên dương nhỏ nhất n sao cho tổng của chuỗi điều hòa\n    lên đến 1/n lớn hơn một số nguyên dương k cho trước.\n\n    Chuỗi điều hòa được định nghĩa là S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Tham số:\n    - k (int): Một số nguyên dương đại diện cho giá trị ngưỡng mà tổng chuỗi điều hòa phải vượt qua.\n\n    Trả về:\n    - int: Số nguyên nhỏ nhất n sao cho tổng chuỗi điều hòa S_n vượt qua ngưỡng k.\n\n    Ví dụ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "id": "Tulis fungsi python 'def find_min_n_greater_than_k(k: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung bilangan bulat positif terkecil n sedemikian rupa sehingga jumlah deret harmonik\n    hingga 1/n lebih besar dari bilangan bulat positif k yang diberikan.\n\n    Deret harmonik didefinisikan sebagai S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumen:\n    - k (int): Sebuah bilangan bulat positif yang mewakili nilai ambang batas yang harus dilampaui oleh jumlah deret harmonik.\n\n    Mengembalikan:\n    - int: Bilangan bulat terkecil n di mana jumlah deret harmonik S_n melebihi ambang batas k.\n\n    Contoh:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "ja": "次の問題を解くためのPython関数 'def find_min_n_greater_than_k(k: int) -> int:' を作成してください。\n\n    調和級数の和が与えられた正の整数 k より大きくなるような最小の正の整数 n を計算します。\n\n    調和級数は S_n = 1 + 1/2 + 1/3 + ... + 1/n と定義されます。\n\n    引数:\n    - k (int): 調和級数の和が超えるべき閾値を表す正の整数。\n\n    戻り値:\n    - int: 調和級数の和 S_n が閾値 k を超える最小の整数 n。\n\n    例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "ko": "다음 문제를 해결하기 위해 파이썬 함수를 작성하세요 'def find_min_n_greater_than_k(k: int) -> int:':\n\n    주어진 양의 정수 k보다 큰 조화급수의 합을 가지는 가장 작은 양의 정수 n을 계산하세요.\n\n    조화급수는 S_n = 1 + 1/2 + 1/3 + ... + 1/n로 정의됩니다.\n\n    인수:\n    - k (int): 조화급수의 합이 초과해야 하는 임계값을 나타내는 양의 정수.\n\n    반환:\n    - int: 조화급수의 합 S_n이 임계값 k를 초과하는 가장 작은 정수 n.\n\n    예시:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "ml": "'def find_min_n_greater_than_k(k: int) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    1/n വരെ ഹാർമോണിക് സീരീസ്യുടെ മൊത്തം ഒരു നൽകിയിരിക്കുന്ന പോസിറ്റീവ് ഇൻറീജർ k-നെക്കാൾ കൂടുതലായിരിക്കേണ്ട ഏറ്റവും ചെറിയ പോസിറ്റീവ് ഇൻറീജർ n കണക്കാക്കുക.\n\n    ഹാർമോണിക് സീരീസ് S_n = 1 + 1/2 + 1/3 + ... + 1/n എന്ന രീതിയിൽ നിർവ്വചിച്ചിരിക്കുന്നു.\n\n    Args:\n    - k (int): ഹാർമോണിക് സീരീസ് മൊത്തം കടന്നുപോകേണ്ട ത്രെഷോൾഡ് മൂല്യം പ്രതിനിധീകരിക്കുന്ന ഒരു പോസിറ്റീവ് ഇൻറീജർ.\n\n    Returns:\n    - int: ഹാർമോണിക് സീരീസ് മൊത്തം S_n ത്രെഷോൾഡ് k-നെക്കാൾ കൂടുതലാകുന്ന ഏറ്റവും ചെറിയ ഇൻറീജർ n.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "fa": "یک تابع پایتون بنویسید 'def find_min_n_greater_than_k(k: int) -> int:' برای حل مسئله زیر:\n\n    کوچکترین عدد صحیح مثبت n را محاسبه کنید به طوری که مجموع سری هماهنگ\n    تا 1/n بیشتر از یک عدد صحیح مثبت داده شده k باشد.\n\n    سری هماهنگ به صورت S_n = 1 + 1/2 + 1/3 + ... + 1/n تعریف می‌شود.\n\n    آرگومان‌ها:\n    - k (int): یک عدد صحیح مثبت که نشان دهنده مقدار آستانه‌ای است که مجموع سری هماهنگ باید از آن بیشتر شود.\n\n    بازگشت:\n    - int: کوچکترین عدد صحیح n که مجموع سری هماهنگ S_n از آستانه k بیشتر شود.\n\n    مثال‌ها:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11"}, "level": "easy", "test": "def test_find_min_n_greater_than_k():\n    # Test case 1: k = 1, expected result is 2\n\n    assert find_min_n_greater_than_k(1) == 2, \"Test case 1 failed.\"\n\n    # Test case 2: k = 3, expected result is 11\n    assert find_min_n_greater_than_k(3) == 11, \"Test case 2 failed.\"\n    # Test case 3: k = 5, expected result is 83\n    assert find_min_n_greater_than_k(5) == 83, \"Test case 3 failed.\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_find_min_n_greater_than_k()", "entry_point": "find_min_n_greater_than_k", "signature": "def find_min_n_greater_than_k(k: int) -> int:", "docstring": {"en": "\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ", "sq": "\n    Llogarit numrin më të vogël pozitiv n të tillë që shuma e serisë harmonike\n    deri në 1/n është më e madhe se një numër i dhënë pozitiv k.\n\n    Seria harmonike është e përcaktuar si S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Një numër i plotë pozitiv që përfaqëson vlerën prag që shuma e serisë harmonike duhet të tejkalojë.\n\n    Returns:\n    - int: Numri më i vogël n për të cilin shuma e serisë harmonike S_n tejkalon pragun k.\n\n    Shembuj:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "hy": "\n    Հաշվեք ամենափոքր դրական ամբողջ թիվը n, որպեսզի հարմոնիկ շարքի գումարը մինչև 1/n մեծ լինի տրված դրական ամբողջ թիվ k-ից։\n\n    Հարմոնիկ շարքը սահմանվում է որպես S_n = 1 + 1/2 + 1/3 + ... + 1/n։\n\n    Պարամետրեր:\n    - k (int): Դրական ամբողջ թիվ, որը ներկայացնում է շեմի արժեքը, որը հարմոնիկ շարքի գումարը պետք է գերազանցի։\n\n    Վերադարձնում է:\n    - int: Ամենափոքր ամբողջ թիվը n, որի համար հարմոնիկ շարքի գումարը S_n գերազանցում է շեմը k։\n\n    Օրինակներ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "bn": "\n    প্রদত্ত ধনাত্মক পূর্ণসংখ্যা k এর চেয়ে বড় হওয়ার জন্য হারমোনিক সিরিজের \n    1/n পর্যন্ত যোগফল সহ সবচেয়ে ছোট ধনাত্মক পূর্ণসংখ্যা n গণনা করুন।\n\n    হারমোনিক সিরিজকে সংজ্ঞায়িত করা হয় S_n = 1 + 1/2 + 1/3 + ... + 1/n হিসাবে।\n\n    আর্গস:\n    - k (int): একটি ধনাত্মক পূর্ণসংখ্যা যা হারমোনিক সিরিজের যোগফলকে অতিক্রম করতে হবে এমন থ্রেশহোল্ড মান উপস্থাপন করে।\n\n    রিটার্নস:\n    - int: সবচেয়ে ছোট পূর্ণসংখ্যা n যার জন্য হারমোনিক সিরিজের যোগফল S_n থ্রেশহোল্ড k অতিক্রম করে।\n\n    উদাহরণ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "bg": "\n    Изчислете най-малкото положително цяло число n, така че сумата на хармоничната редица\n    до 1/n да е по-голяма от дадено положително цяло число k.\n\n    Хармоничната редица е дефинирана като S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Аргументи:\n    - k (int): Положително цяло число, представляващо праговата стойност, която сумата на хармоничната редица трябва да надвиши.\n\n    Връща:\n    - int: Най-малкото цяло число n, за което сумата на хармоничната редица S_n надвишава прага k.\n\n    Примери:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "zh": "\n    计算最小的正整数 n，使得调和级数的和达到 1/n 时大于给定的正整数 k。\n\n    调和级数定义为 S_n = 1 + 1/2 + 1/3 + ... + 1/n。\n\n    参数:\n    - k (int): 表示调和级数和必须超过的阈值的正整数。\n\n    返回:\n    - int: 调和级数和 S_n 超过阈值 k 的最小整数 n。\n\n    示例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "fr": "\n    Calculer le plus petit entier positif n tel que la somme de la série harmonique\n    jusqu'à 1/n soit supérieure à un entier positif donné k.\n\n    La série harmonique est définie comme S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Un entier positif représentant la valeur seuil que la somme de la série harmonique doit dépasser.\n\n    Returns:\n    - int: Le plus petit entier n pour lequel la somme de la série harmonique S_n dépasse le seuil k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "de": "\n    Berechne die kleinste positive ganze Zahl n, sodass die Summe der harmonischen Reihe\n    bis 1/n größer ist als eine gegebene positive ganze Zahl k.\n\n    Die harmonische Reihe ist definiert als S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumente:\n    - k (int): Eine positive ganze Zahl, die den Schwellenwert darstellt, den die Summe der harmonischen Reihe überschreiten muss.\n\n    Rückgabe:\n    - int: Die kleinste ganze Zahl n, für die die Summe der harmonischen Reihe S_n den Schwellenwert k überschreitet.\n\n    Beispiele:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "ha": "\n    Lissafa ƙaramin cikakken lamba n wanda ya fi haka, jumillar jerin lissafi\n    har zuwa 1/n ya fi wata cikakkiyar lamba k.\n\n    Jerin lissafi an bayyana shi kamar S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Ƙa'idodi:\n    - k (int): Cikakkiyar lamba mai kyau wanda ke wakiltar ƙimar ƙofa da jumillar jerin lissafi dole ta wuce.\n\n    Komawa:\n    - int: Ƙaramin lamba n wanda don shi jumillar jerin lissafi S_n ya wuce ƙimar ƙofa k.\n\n    Misalai:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "hi": "\n    दिए गए धनात्मक पूर्णांक k से अधिक होने के लिए हार्मोनिक श्रेणी के योग के लिए सबसे छोटा धनात्मक पूर्णांक n की गणना करें।\n\n    हार्मोनिक श्रेणी को S_n = 1 + 1/2 + 1/3 + ... + 1/n के रूप में परिभाषित किया गया है।\n\n    तर्क:\n    - k (int): एक धनात्मक पूर्णांक जो उस सीमा मूल्य का प्रतिनिधित्व करता है जिसे हार्मोनिक श्रेणी का योग पार करना चाहिए।\n\n    वापसी:\n    - int: सबसे छोटा पूर्णांक n जिसके लिए हार्मोनिक श्रेणी का योग S_n सीमा k से अधिक होता है।\n\n    उदाहरण:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "hu": "\n    Számítsd ki a legkisebb pozitív egész számot n, amelyre a harmonikus sorozat összege\n    1/n-ig nagyobb, mint egy adott pozitív egész szám k.\n\n    A harmonikus sorozat definíciója: S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Paraméterek:\n    - k (int): Egy pozitív egész szám, amely a küszöbértéket jelenti, amelyet a harmonikus sorozat összegének meg kell haladnia.\n\n    Visszatér:\n    - int: A legkisebb egész szám n, amelyre a harmonikus sorozat összege S_n meghaladja a k küszöbértéket.\n\n    Példák:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "es": "    Calcular el entero positivo más pequeño n tal que la suma de la serie armónica\n    hasta 1/n sea mayor que un entero positivo dado k.\n\n    La serie armónica se define como S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentos:\n    - k (int): Un entero positivo que representa el valor umbral que la suma de la serie armónica debe exceder.\n\n    Devuelve:\n    - int: El entero más pequeño n para el cual la suma de la serie armónica S_n excede el umbral k.\n\n    Ejemplos:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ", "arb": "    حساب أصغر عدد صحيح موجب n بحيث يكون مجموع السلسلة التوافقية\n    حتى 1/n أكبر من عدد صحيح موجب معين k.\n\n    السلسلة التوافقية تُعرّف كالتالي S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    يعيدالحجج:\n    - k (int): عدد صحيح موجب يمثل قيمة العتبة التي يجب أن يتجاوزها مجموع السلسلة التوافقية.\n\n    يعيد:\n    - int: أصغر عدد صحيح n حيث يتجاوز مجموع السلسلة التوافقية S_n العتبة k.\n\n    امثله:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "sw": "    Hesabu namba ndogo zaidi chanya n kama jumla ya mfululizo wa harmonic\n    hadi 1/n ni kubwa kuliko namba chanya iliyotolewa k.\n\n    Mfululizo wa harmonic unafafanuliwa kama S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Hoja:\n    - k (int): Namba chanya inayowakilisha thamani ya kizingiti ambacho jumla ya mfululizo wa harmonic lazima izidi.\n\n    Inarejesha:\n    - int: Namba ndogo zaidi n ambayo jumla ya mfululizo wa harmonic S_n inazidi kizingiti k.\n\n    Mifano:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ", "tr": "    Harmonik serinin 1/n'ye kadar olan toplamının verilen pozitif bir tamsayı k'dan büyük olması için\n    en küçük pozitif tamsayı n'yi hesaplayın.\n\n    Harmonik seri S_n = 1 + 1/2 + 1/3 + ... + 1/n olarak tanımlanır.\n\n    Argümanlar:\n    - k (int): Harmonik seri toplamının aşması gereken eşik değerini temsil eden pozitif bir tamsayı.\n\n    Döndürür:\n    - int: Harmonik seri toplamı S_n'nin eşik k'yı aştığı en küçük tamsayı n.\n\n    Örnekler:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "vi": "    Tính số nguyên dương nhỏ nhất n sao cho tổng của chuỗi điều hòa\n    đến 1/n lớn hơn một số nguyên dương cho trước k.\n\n    Chuỗi điều hòa được định nghĩa là S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Tham số:\n    - k (int): Một số nguyên dương đại diện cho giá trị ngưỡng mà tổng chuỗi điều hòa phải vượt qua.\n\n    Trả về:\n    - int: Số nguyên nhỏ nhất n sao cho tổng chuỗi điều hòa S_n vượt qua ngưỡng k.\n\n    Ví dụ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ", "id": "Menghitung bilangan bulat positif terkecil n sedemikian rupa sehingga jumlah deret harmonik hingga 1/n lebih besar dari bilangan bulat positif k yang diberikan.\n\nDeret harmonik didefinisikan sebagai S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): Bilangan bulat positif yang mewakili nilai ambang batas yang harus dilampaui oleh jumlah deret harmonik.\n\nReturns:\n- int: Bilangan bulat terkecil n untuk mana jumlah deret harmonik S_n melebihi ambang batas k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\n>>> find_min_n_greater_than_k(3)\n11", "ja": "    与えられた正の整数 k よりも大きい調和級数の和を持つ最小の正の整数 n を計算します。\n\n    調和級数は S_n = 1 + 1/2 + 1/3 + ... + 1/n と定義されます。\n\n    引数:\n    - k (int): 調和級数の和が超えるべき閾値を表す正の整数。\n\n    戻り値:\n    - int: 調和級数の和 S_n が閾値 k を超える最小の整数 n。\n\n    例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ", "ko": "    주어진 양의 정수 k보다 큰 조화급수의 합을 갖는 가장 작은 양의 정수 n을 계산합니다.\n\n    조화급수는 S_n = 1 + 1/2 + 1/3 + ... + 1/n으로 정의됩니다.\n\n    인수:\n    - k (int): 조화급수의 합이 초과해야 하는 임계값을 나타내는 양의 정수입니다.\n\n    반환:\n    - int: 조화급수의 합 S_n이 임계값 k를 초과하는 가장 작은 정수 n입니다.\n\n    예제:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ", "ml": "    ഹാർമോണിക് ശ്രേണിയുടെ തുക 1/n വരെ ഒരു നൽകിയ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ k-നെക്കാൾ കൂടുതലാകുന്ന ഏറ്റവും ചെറിയ പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n കണക്കാക്കുക.\n\n    ഹാർമോണിക് ശ്രേണി S_n = 1 + 1/2 + 1/3 + ... + 1/n എന്ന രീതിയിലാണ് നിർവചിച്ചിരിക്കുന്നത്.\n\n    Args:\n    - k (int): ഹാർമോണിക് ശ്രേണിയുടെ തുക കവിഞ്ഞിരിക്കേണ്ടത് പ്രതിനിധീകരിക്കുന്ന ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ.\n\n    Returns:\n    - int: ഹാർമോണിക് ശ്രേണിയുടെ തുക S_n പ്രതിമാന k-നെക്കാൾ കൂടുതലാകുന്ന ഏറ്റവും ചെറിയ പൂർണ്ണസംഖ്യ n.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11", "fa": "محاسبه کوچکترین عدد صحیح مثبت n به طوری که مجموع سری هارمونیک تا 1/n بیشتر از یک عدد صحیح مثبت داده شده k باشد.\n\nسری هارمونیک به صورت S_n = 1 + 1/2 + 1/3 + ... + 1/n تعریف می‌شود.\n\nآرگومان‌ها:\n- k (int): یک عدد صحیح مثبت که نشان‌دهنده مقدار آستانه‌ای است که مجموع سری هارمونیک باید از آن بیشتر شود.\n\nبازگشت:\n- int: کوچکترین عدد صحیح n که مجموع سری هارمونیک S_n از آستانه k بیشتر شود.\n\nمثال‌ها:\n>>> find_min_n_greater_than_k(1)\n2\n>>> find_min_n_greater_than_k(3)\n11"}}
{"task_id": "Python/30", "prompt": {"en": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "sq": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Përcaktoni nëse një numër i dhënë është një numër i thjeshtë.\n\n    Një numër i thjeshtë është një numër natyror më i madh se 1 që nuk ka pjesëtues pozitivë përveç 1 dhe vetvetes. Funksioni kontrollon për thjeshtësinë duke eliminuar numrat jo të thjeshtë duke përdorur disa teste. Së pari, trajton rastet e veçanta për numrat më të vegjël ose të barabartë me 1, të cilët nuk janë të thjeshtë, dhe numrat e vegjël (2 dhe 3) të cilët janë të thjeshtë. Më pas kontrollon për pjesëtueshmëri me 2 dhe 3. Për numra më të mëdhenj, përdor një optimizim 6k +/- 1 për të testuar për faktorë deri në rrënjën katrore të numrit.\n\n    Args:\n    num (int): Numri për të kontrolluar për thjeshtësi.\n\n    Returns:\n    bool: True nëse `num` është një numër i thjeshtë, False përndryshe.\n\n    Raste:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "hy": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Սահմանել, արդյոք տրված ամբողջ թիվը պարզ թիվ է:\n\n    Պարզ թիվը բնական թիվ է, որը մեծ է 1-ից և չունի դրական բաժանարարներ՝ բացի 1-ից և ինքն իրենից: Ֆունկցիան ստուգում է պարզությունը՝ բացառելով ոչ պարզ թվերը մի քանի թեստերի միջոցով: Նախ, այն մշակում է եզակի դեպքերը 1-ից փոքր կամ հավասար թվերի համար, որոնք պարզ չեն, և փոքր թվերի (2 և 3) համար, որոնք պարզ են: Այնուհետև ստուգում է բաժանելիությունը 2-ով և 3-ով: Ավելի մեծ թվերի համար այն օգտագործում է 6k +/- 1 օպտիմալացում՝ մինչև թվի քառակուսի արմատը գործոններ ստուգելու համար:\n\n    Արգումենտներ:\n    num (int): Ամբողջ թիվը, որը պետք է ստուգել պարզության համար:\n\n    Վերադարձնում է:\n    bool: True, եթե `num`-ը պարզ թիվ է, False՝ հակառակ դեպքում:\n\n    Դեպքեր:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "bn": "def is_prime(num: int) -> bool:\n    \"\"\"\n    প্রদত্ত পূর্ণসংখ্যাটি একটি মৌলিক সংখ্যা কিনা তা নির্ধারণ করুন।\n\n    একটি মৌলিক সংখ্যা হল 1 এর চেয়ে বড় একটি প্রাকৃতিক সংখ্যা যার 1 এবং নিজে ছাড়া অন্য কোনো ধনাত্মক বিভাজক নেই। \n    এই ফাংশনটি বিভিন্ন পরীক্ষা ব্যবহার করে অমৌলিক সংখ্যা বাদ দিয়ে মৌলিকতা যাচাই করে। প্রথমে, এটি 1 বা তার চেয়ে কম সংখ্যার জন্য প্রান্তিক \n    ক্ষেত্রগুলি পরিচালনা করে, যা মৌলিক নয়, এবং ছোট সংখ্যা (2 এবং 3) যা মৌলিক। তারপর এটি 2 এবং 3 দ্বারা বিভাজ্যতা পরীক্ষা করে। \n    বড় সংখ্যার জন্য, এটি সংখ্যার বর্গমূল পর্যন্ত ফ্যাক্টর পরীক্ষা করার জন্য 6k +/- 1 অপ্টিমাইজেশন ব্যবহার করে।\n\n    Args:\n    num (int): মৌলিকতা যাচাই করার জন্য পূর্ণসংখ্যা।\n\n    Returns:\n    bool: যদি `num` একটি মৌলিক সংখ্যা হয় তবে True, অন্যথায় False।\n\n    উদাহরণ:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "bg": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Определя дали дадено цяло число е просто число.\n\n    Просто число е естествено число, по-голямо от 1, което няма положителни делители, различни от 1 и самото себе си. Функцията проверява за простота, като елиминира непростите числа чрез няколко теста. Първо, тя обработва граничните случаи за числа, по-малки или равни на 1, които не са прости, и малки числа (2 и 3), които са прости. След това проверява за делимост на 2 и 3. За по-големи числа използва оптимизация 6k +/- 1, за да тества за делители до квадратния корен на числото.\n\n    Аргументи:\n    num (int): Цялото число, което да се провери за простота.\n\n    Връща:\n    bool: True ако `num` е просто число, False в противен случай.\n\n    Примери:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "zh": "def is_prime(num: int) -> bool:\n    \"\"\"\n    确定给定整数是否为素数。\n\n    素数是大于1的自然数，除了1和它本身没有其他正因数。\n    该函数通过使用几个测试来消除非素数，从而检查素性。\n    首先，它处理小于或等于1的数字的边界情况，这些数字不是素数，而小数字(2和3)是素数。\n    然后检查是否能被2和3整除。\n    对于较大的数字，它使用6k +/- 1优化来测试因数，直到数字的平方根。\n\n    参数:\n    num (int): 要检查素性的整数。\n\n    返回:\n    bool: 如果 `num` 是素数则返回 True，否则返回 False。\n\n    示例:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "fr": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Déterminer si un entier donné est un nombre premier.\n\n    Un nombre premier est un nombre naturel supérieur à 1 qui n'a pas de diviseurs positifs autres que 1 et lui-même. La fonction vérifie la primalité en éliminant les nombres non premiers à l'aide de plusieurs tests. Tout d'abord, elle gère les cas particuliers pour les nombres inférieurs ou égaux à 1, qui ne sont pas premiers, et les petits nombres (2 et 3) qui sont premiers. Elle vérifie ensuite la divisibilité par 2 et 3. Pour les nombres plus grands, elle utilise une optimisation 6k +/- 1 pour tester les facteurs jusqu'à la racine carrée du nombre.\n\n    Args:\n    num (int): L'entier à vérifier pour la primalité.\n\n    Returns:\n    bool: True si `num` est un nombre premier, False sinon.\n\n    Cas:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "de": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Bestimmen, ob eine gegebene ganze Zahl eine Primzahl ist.\n\n    Eine Primzahl ist eine natürliche Zahl größer als 1, die keine positiven Teiler außer 1 und sich selbst hat. Die Funktion überprüft die Primalität, indem sie Nicht-Primzahlen durch mehrere Tests eliminiert. Zuerst behandelt sie Sonderfälle für Zahlen kleiner oder gleich 1, die nicht prim sind, und kleine Zahlen (2 und 3), die prim sind. Dann wird die Teilbarkeit durch 2 und 3 überprüft. Für größere Zahlen wird eine 6k +/- 1 Optimierung verwendet, um nach Teilern bis zur Quadratwurzel der Zahl zu testen.\n\n    Argumente:\n    num (int): Die ganze Zahl, die auf Primalität überprüft werden soll.\n\n    Rückgabewert:\n    bool: True, wenn `num` eine Primzahl ist, andernfalls False.\n\n    Fälle:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "ha": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Tabbatar ko wani lamba cikakken lamba ne.\n\n    Cikakken lamba shi ne lamba na halitta wanda ya fi 1 girma kuma ba shi da masu raba lamba masu kyau sai dai 1 da kansa. Aikin yana duba cikakken lamba ta hanyar kawar da lambobi marasa cikakken lamba ta amfani da gwaje-gwaje da dama. Da farko, yana kula da yanayi na musamman ga lambobi da suka yi ƙasa ko daidai da 1, waɗanda ba su cikakke ba, da ƙananan lambobi (2 da 3) waɗanda su ne cikakke. Sannan yana duba rarrabewa da 2 da 3. Don manyan lambobi, yana amfani da ingantaccen 6k +/- 1 don gwada masu raba har zuwa tushen murabba'in lambar.\n\n    Args:\n    num (int): Lambar da za a duba don cikakken lamba.\n\n    Returns:\n    bool: Gaskiya idan `num` cikakken lamba ne, Karya in ba haka ba.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "hi": "def is_prime(num: int) -> bool:\n    \"\"\"\n    यह निर्धारित करें कि दिया गया पूर्णांक एक अभाज्य संख्या है या नहीं।\n\n    एक अभाज्य संख्या एक प्राकृतिक संख्या है जो 1 से बड़ी होती है और जिसका कोई धनात्मक भाजक नहीं होता है सिवाय 1 और स्वयं के। यह फ़ंक्शन कई परीक्षणों का उपयोग करके अभाज्यता की जाँच करता है, गैर-अभाज्य संख्याओं को समाप्त करता है। सबसे पहले, यह 1 से कम या बराबर संख्याओं के लिए किनारे के मामलों को संभालता है, जो अभाज्य नहीं हैं, और छोटी संख्याएँ (2 और 3) जो अभाज्य हैं। फिर यह 2 और 3 से विभाज्यता की जाँच करता है। बड़ी संख्याओं के लिए, यह संख्या के वर्गमूल तक कारकों के लिए परीक्षण करने के लिए 6k +/- 1 अनुकूलन का उपयोग करता है।\n\n    Args:\n    num (int): अभाज्यता की जाँच करने के लिए पूर्णांक।\n\n    Returns:\n    bool: True यदि `num` एक अभाज्य संख्या है, अन्यथा False।\n\n    उदाहरण:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "hu": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Határozza meg, hogy egy adott egész szám prímszám-e.\n\n    A prímszám olyan 1-nél nagyobb természetes szám, amelynek nincsenek pozitív osztói 1-en és önmagán kívül. A függvény több teszt segítségével szűri ki a nem prímszámokat. Először kezeli az 1-nél kisebb vagy egyenlő számok speciális eseteit, amelyek nem prímek, valamint a kis számokat (2 és 3), amelyek prímek. Ezután ellenőrzi az oszthatóságot 2-vel és 3-mal. Nagyobb számok esetén 6k +/- 1 optimalizálást használ a szám négyzetgyökéig terjedő osztók tesztelésére.\n\n    Paraméterek:\n    num (int): Az egész szám, amelyet a prímtesztre ellenőrzünk.\n\n    Visszatérési érték:\n    bool: Igaz, ha `num` prímszám, hamis egyébként.\n\n    Esetek:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "es": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determinar si un número entero dado es un número primo.\n\n    Un número primo es un número natural mayor que 1 que no tiene divisores positivos aparte de 1 y sí mismo. La función verifica la primalidad eliminando números no primos mediante varias pruebas. Primero, maneja casos especiales para números menores o iguales a 1, que no son primos, y números pequeños (2 y 3) que son primos. Luego verifica la divisibilidad por 2 y 3. Para números más grandes, utiliza una optimización de 6k +/- 1 para probar factores hasta la raíz cuadrada del número.\n\n    Argumentos:\n    num (int): El entero a verificar para la primalidad.\n\n    Devuelve:\n    bool: True si `num` es un número primo, False en caso contrario.\n\n    Casos:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "arb": "def is_prime(num: int) -> bool:\n    \"\"\"\n    تحديد ما إذا كان العدد الصحيح المعطى هو عدد أولي.\n\n    العدد الأولي هو عدد طبيعي أكبر من 1 وليس له قواسم موجبة غير 1 ونفسه. تقوم الدالة بالتحقق من الأولية عن طريق استبعاد الأعداد غير الأولية باستخدام عدة اختبارات. أولاً، تتعامل مع الحالات الخاصة للأعداد الأقل من أو تساوي 1، والتي ليست أولية، والأعداد الصغيرة (2 و3) التي هي أولية. ثم تتحقق من القسمة على 2 و3. بالنسبة للأعداد الأكبر، تستخدم تحسين 6k +/- 1 لاختبار العوامل حتى الجذر التربيعي للعدد.\n\n    يعيدالحجج:\n    num (int): العدد الصحيح للتحقق من أوليته.\n\n    يعيد:\n    bool: True إذا كان `num` عددًا أوليًا، False خلاف ذلك.\n\n    حالات:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "sw": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Kuamua kama nambari iliyotolewa ni nambari ya kwanza.\n\n    Nambari ya kwanza ni nambari ya asili iliyo kubwa kuliko 1 ambayo haina wagawanyaji chanya isipokuwa 1 na yenyewe. Kazi hii inakagua kama ni ya kwanza kwa kuondoa nambari zisizo za kwanza kwa kutumia vipimo kadhaa. Kwanza, inashughulikia kesi maalum kwa nambari zilizo chini au sawa na 1, ambazo si za kwanza, na nambari ndogo (2 na 3) ambazo ni za kwanza. Kisha inakagua ugawanyiko kwa 2 na 3. Kwa nambari kubwa, inatumia uboreshaji wa 6k +/- 1 ili kupima vipengele hadi mzizi wa mraba wa nambari.\n\n    Hoja:\n    num (int): Nambari ya kuangalia kama ni ya kwanza.\n\n    Inarejesha:\n    bool: Kweli ikiwa `num` ni nambari ya kwanza, uongo vinginevyo.\n\n    Kesi:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "tr": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Verilen bir tam sayının asal sayı olup olmadığını belirleyin.\n\n    Asal sayı, 1'den büyük olan ve 1 ve kendisi dışında pozitif böleni olmayan doğal sayıdır. Fonksiyon, asal olmayan sayıları birkaç test kullanarak eleyerek asal olup olmadığını kontrol eder. İlk olarak, asal olmayan 1 veya daha küçük sayılar ve asal olan küçük sayılar (2 ve 3) için özel durumları ele alır. Daha sonra 2 ve 3'e bölünebilirliği kontrol eder. Daha büyük sayılar için, sayının kareköküne kadar olan faktörleri test etmek için 6k +/- 1 optimizasyonunu kullanır.\n\n    Argümanlar:\n    num (int): Asallığı kontrol edilecek tam sayı.\n\n    Döndürür:\n    bool: `num` asal bir sayı ise True, aksi takdirde False.\n\n    Durumlar:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "vi": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Xác định xem một số nguyên cho trước có phải là số nguyên tố hay không.\n\n    Một số nguyên tố là một số tự nhiên lớn hơn 1 không có ước số dương nào khác ngoài 1 và chính nó. Hàm kiểm tra tính nguyên tố bằng cách loại bỏ các số không phải nguyên tố thông qua một số phép thử. Đầu tiên, nó xử lý các trường hợp đặc biệt cho các số nhỏ hơn hoặc bằng 1, không phải là số nguyên tố, và các số nhỏ (2 và 3) là số nguyên tố. Sau đó, nó kiểm tra tính chia hết cho 2 và 3. Đối với các số lớn hơn, nó sử dụng tối ưu hóa 6k +/- 1 để kiểm tra các ước số lên đến căn bậc hai của số đó.\n\n    Tham số:\n    num (int): Số nguyên cần kiểm tra tính nguyên tố.\n\n    Trả về:\n    bool: True nếu `num` là số nguyên tố, False nếu không phải.\n\n    Trường hợp:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "id": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Menentukan apakah bilangan bulat yang diberikan adalah bilangan prima.\n\n    Bilangan prima adalah bilangan asli yang lebih besar dari 1 yang tidak memiliki pembagi positif selain 1 dan dirinya sendiri. Fungsi ini memeriksa keprimaan dengan mengeliminasi bilangan non-prima menggunakan beberapa pengujian. Pertama, fungsi ini menangani kasus tepi untuk bilangan kurang dari atau sama dengan 1, yang bukan prima, dan bilangan kecil (2 dan 3) yang merupakan prima. Kemudian, fungsi ini memeriksa keterbagian oleh 2 dan 3. Untuk bilangan yang lebih besar, fungsi ini menggunakan optimasi 6k +/- 1 untuk menguji faktor hingga akar kuadrat dari bilangan tersebut.\n\n    Args:\n    num (int): Bilangan bulat yang akan diperiksa keprimaannya.\n\n    Returns:\n    bool: True jika `num` adalah bilangan prima, False jika tidak.\n\n    Kasus:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "ja": "def is_prime(num: int) -> bool:\n    \"\"\"\n    与えられた整数が素数かどうかを判定します。\n\n    素数は、1より大きく、1とその数自身以外に正の約数を持たない自然数です。この関数は、いくつかのテストを使用して非素数を除外することで素数性を確認します。まず、1以下の数（素数ではない）や小さな数（2と3は素数）に対する特別なケースを処理します。次に、2と3での除算可能性を確認します。より大きな数に対しては、6k +/- 1 の最適化を使用して、その数の平方根までの因数をテストします。\n\n    引数:\n    num (int): 素数性を確認する整数。\n\n    戻り値:\n    bool: `num` が素数であれば True、そうでなければ False。\n\n    ケース:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "ko": "def is_prime(num: int) -> bool:\n    \"\"\"\n    주어진 정수가 소수인지 여부를 결정합니다.\n\n    소수는 1보다 큰 자연수로, 1과 자기 자신 외에는 양의 약수가 없는 수입니다. 이 함수는 여러 테스트를 통해 소수가 아닌 수를 제거하여 소수 여부를 확인합니다. 먼저, 소수가 아닌 1 이하의 수와 소수인 작은 수(2와 3)에 대한 예외 처리를 합니다. 그런 다음 2와 3으로 나누어 떨어지는지 확인합니다. 더 큰 수의 경우, 6k +/- 1 최적화를 사용하여 수의 제곱근까지의 인수를 테스트합니다.\n\n    매개변수:\n    num (int): 소수 여부를 확인할 정수.\n\n    반환값:\n    bool: `num`이 소수이면 True, 그렇지 않으면 False.\n\n    예시:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "ml": "def is_prime(num: int) -> bool:\n    \"\"\"\n    നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യ ഒരു പ്രധാന സംഖ്യയാണോ എന്ന് നിർണയിക്കുക.\n\n    ഒരു പ്രധാന സംഖ്യ 1-ലും അതിനേക്കാൾ വലിയതുമായ സ്വാഭാവിക സംഖ്യയാണ്, 1-നും സ്വയം ഒഴികെയുള്ള അനുകൂല വിഭജകങ്ങൾ ഇല്ലാത്തത്. പ്രധാനത്വം പരിശോധിക്കുന്നതിന്, ചില പരീക്ഷണങ്ങൾ ഉപയോഗിച്ച് പ്രധാനമല്ലാത്ത സംഖ്യകളെ ഒഴിവാക്കുന്നതിലൂടെ ഫംഗ്ഷൻ പ്രവർത്തിക്കുന്നു. ആദ്യം, പ്രധാനമല്ലാത്ത 1-ൽ കുറവോ തുല്യമായ സംഖ്യകൾക്കായുള്ള എജ്ജ് കേസുകൾ കൈകാര്യം ചെയ്യുന്നു, 2, 3 എന്നീ ചെറിയ സംഖ്യകൾ പ്രധാനമാണ്. തുടർന്ന് 2, 3 എന്നിവയാൽ വിഭജ്യത പരിശോധിക്കുന്നു. വലിയ സംഖ്യകൾക്കായി, 6k +/- 1 ഓപ്റ്റിമൈസേഷൻ ഉപയോഗിച്ച് സംഖ്യയുടെ വേരിന്റെ ചതുരത്തിലേക്ക് ഘടകങ്ങൾ പരിശോധിക്കുന്നു.\n\n    Args:\n    num (int): പ്രധാനത്വം പരിശോധിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n\n    Returns:\n    bool: `num` ഒരു പ്രധാന സംഖ്യയാണെങ്കിൽ True, അല്ലെങ്കിൽ False.\n\n    കേസുകൾ:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"", "fa": "def is_prime(num: int) -> bool:\n    \"\"\"\n    تعیین می‌کند که آیا یک عدد صحیح داده شده عددی اول است یا خیر.\n\n    یک عدد اول عدد طبیعی بزرگتر از 1 است که هیچ مقسوم علیه مثبت دیگری جز 1 و خودش ندارد. این تابع برای تشخیص اول بودن، با حذف اعداد غیر اول از طریق چندین آزمون عمل می‌کند. ابتدا، موارد خاص برای اعداد کمتر یا مساوی 1 که اول نیستند و اعداد کوچک (2 و 3) که اول هستند را بررسی می‌کند. سپس قابلیت تقسیم بر 2 و 3 را بررسی می‌کند. برای اعداد بزرگتر، از بهینه‌سازی 6k +/- 1 برای آزمایش عوامل تا ریشه دوم عدد استفاده می‌کند.\n\n    آرگومان‌ها:\n    num (int): عدد صحیح برای بررسی اول بودن.\n\n    بازگشت:\n    bool: اگر `num` عددی اول باشد، True برمی‌گرداند، در غیر این صورت False.\n\n    موارد:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\""}, "canonical_solution": "    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "instruction": {"en": "Write a python function 'def is_prime(num: int) -> bool:' to solve the following problem:\n\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ", "sq": "Shkruani një funksion python 'def is_prime(num: int) -> bool:' për të zgjidhur problemin e mëposhtëm:\n\n    Përcaktoni nëse një numër i dhënë është numër i thjeshtë.\n\n    Një numër i thjeshtë është një numër natyror më i madh se 1 që nuk ka pjesëtuese pozitive përveç 1 dhe vetes. Funksioni kontrollon për thjeshtësinë duke eliminuar numrat jo të thjeshtë duke përdorur disa teste. Së pari, trajton rastet e veçanta për numrat më të vegjël ose të barabartë me 1, të cilët nuk janë të thjeshtë, dhe numrat e vegjël (2 dhe 3) të cilët janë të thjeshtë. Më pas kontrollon pjesëtueshmërinë me 2 dhe 3. Për numra më të mëdhenj, përdor një optimizim 6k +/- 1 për të testuar faktorët deri në rrënjën katrore të numrit.\n\n    Args:\n    num (int): Numri për të kontrolluar për thjeshtësi.\n\n    Returns:\n    bool: True nëse `num` është numër i thjeshtë, False përndryshe.\n\n    Rastet:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "hy": "Պայթոն ֆունկցիա 'def is_prime(num: int) -> bool:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Սահմանել, արդյոք տրված ամբողջ թիվը պարզ թիվ է:\n\n    Պարզ թիվը բնական թիվ է, որը մեծ է 1-ից և չունի դրական բաժանարարներ, բացի 1-ից և ինքն իրենից: Ֆունկցիան ստուգում է պարզությունը՝ ոչ պարզ թվերը բացառելու մի քանի թեստերի միջոցով: Նախ, այն կարգավորում է եզակի դեպքերը 1-ից փոքր կամ հավասար թվերի համար, որոնք պարզ չեն, և փոքր թվերի (2 և 3) համար, որոնք պարզ են: Այնուհետև այն ստուգում է բաժանելիությունը 2-ով և 3-ով: Ավելի մեծ թվերի համար այն օգտագործում է 6k +/- 1 օպտիմալացում՝ մինչև թվի քառակուսի արմատը գործոնները ստուգելու համար:\n\n    Արձ:\n    num (int): Ամբողջ թիվը, որը պետք է ստուգել պարզության համար:\n\n    Վերադարձնում է:\n    bool: True, եթե `num`-ը պարզ թիվ է, False՝ հակառակ դեպքում:\n\n    Դեպքեր:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "bn": "একটি পাইথন ফাংশন 'def is_prime(num: int) -> bool:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    নির্ধারণ করুন একটি প্রদত্ত পূর্ণসংখ্যা একটি মৌলিক সংখ্যা কিনা।\n\n    একটি মৌলিক সংখ্যা হল 1 এর চেয়ে বড় একটি স্বাভাবিক সংখ্যা যার কোনো ধনাত্মক গুণনীয়ক নেই 1 এবং তার নিজস্ব ছাড়া। ফাংশনটি বিভিন্ন পরীক্ষার মাধ্যমে অমৌলিক সংখ্যা বাদ দিয়ে মৌলিকতা পরীক্ষা করে। প্রথমে, এটি 1 বা তার চেয়ে ছোট সংখ্যার জন্য প্রান্তিক কেসগুলি পরিচালনা করে, যা মৌলিক নয়, এবং ছোট সংখ্যা (2 এবং 3) যা মৌলিক। তারপর এটি 2 এবং 3 দ্বারা বিভাজ্যতা পরীক্ষা করে। বড় সংখ্যার জন্য, এটি সংখ্যার বর্গমূল পর্যন্ত গুণনীয়ক পরীক্ষা করার জন্য 6k +/- 1 অপ্টিমাইজেশন ব্যবহার করে।\n\n    আর্গস:\n    num (int): মৌলিকতা পরীক্ষা করার জন্য পূর্ণসংখ্যা।\n\n    রিটার্নস:\n    bool: যদি `num` একটি মৌলিক সংখ্যা হয় তবে True, অন্যথায় False।\n\n    কেস:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "bg": "Напишете Python функция 'def is_prime(num: int) -> bool:' за да решите следния проблем:\n\n    Определете дали дадено цяло число е просто число.\n\n    Просто число е естествено число, по-голямо от 1, което няма положителни делители, различни от 1 и самото него. Функцията проверява за простота, като елиминира непростите числа чрез няколко теста. Първо, тя обработва гранични случаи за числа, по-малки или равни на 1, които не са прости, и малки числа (2 и 3), които са прости. След това проверява за делимост на 2 и 3. За по-големи числа използва оптимизация 6k +/- 1, за да тества за фактори до квадратния корен на числото.\n\n    Аргументи:\n    num (int): Цялото число, което да се провери за простота.\n\n    Връща:\n    bool: True, ако `num` е просто число, False в противен случай.\n\n    Примери:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "zh": "编写一个python函数 'def is_prime(num: int) -> bool:' 来解决以下问题：\n\n    确定给定的整数是否是一个素数。\n\n    素数是大于1的自然数，除了1和它本身没有其他正除数。该函数通过使用多种测试消除非素数来检查素数性。首先，它处理小于或等于1的数字的边界情况，这些数字不是素数，以及小数字（2和3），它们是素数。然后，它检查是否能被2和3整除。对于较大的数字，它使用6k +/- 1优化来测试直到数字平方根的因子。\n\n    参数：\n    num (int): 要检查是否为素数的整数。\n\n    返回：\n    bool: 如果 `num` 是素数则返回True，否则返回False。\n\n    示例：\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "fr": "Écrire une fonction python 'def is_prime(num: int) -> bool:' pour résoudre le problème suivant :\n\n    Déterminer si un entier donné est un nombre premier.\n\n    Un nombre premier est un nombre naturel supérieur à 1 qui n'a pas de diviseurs positifs autres que 1 et lui-même. La fonction vérifie la primalité en éliminant les nombres non premiers à l'aide de plusieurs tests. Tout d'abord, elle traite les cas particuliers pour les nombres inférieurs ou égaux à 1, qui ne sont pas premiers, et les petits nombres (2 et 3) qui sont premiers. Elle vérifie ensuite la divisibilité par 2 et 3. Pour les nombres plus grands, elle utilise une optimisation 6k +/- 1 pour tester les facteurs jusqu'à la racine carrée du nombre.\n\n    Args:\n    num (int): L'entier à vérifier pour la primalité.\n\n    Returns:\n    bool: True si `num` est un nombre premier, False sinon.\n\n    Cas:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "de": "Schreiben Sie eine Python-Funktion 'def is_prime(num: int) -> bool:', um das folgende Problem zu lösen:\n\n    Bestimmen Sie, ob eine gegebene ganze Zahl eine Primzahl ist.\n\n    Eine Primzahl ist eine natürliche Zahl größer als 1, die keine positiven Teiler außer 1 und sich selbst hat. Die Funktion überprüft die Primalität, indem sie nicht-primzahlen durch mehrere Tests eliminiert. Zuerst behandelt sie Randfälle für Zahlen kleiner oder gleich 1, die nicht prim sind, und kleine Zahlen (2 und 3), die prim sind. Dann überprüft sie die Teilbarkeit durch 2 und 3. Für größere Zahlen verwendet sie eine 6k +/- 1 Optimierung, um Faktoren bis zur Quadratwurzel der Zahl zu testen.\n\n    Argumente:\n    num (int): Die ganze Zahl, die auf Primalität überprüft werden soll.\n\n    Rückgabewert:\n    bool: True, wenn `num` eine Primzahl ist, andernfalls False.\n\n    Fälle:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "ha": "Rubuta wani aikin python 'def is_prime(num: int) -> bool:' don warware matsalar mai zuwa:\n\n    Tantance ko wani lamba mai cikakken lamba shine lamba mai lamba.\n\n    Lamba mai lamba shine lamba mai halitta da ya fi 1 girma wanda ba shi da masu raba lamba masu kyau banda 1 da kansa. Aikin yana duba ko lamba mai lamba ne ta hanyar kawar da lambobi marasa lamba mai lamba ta amfani da gwaje-gwaje da yawa. Da farko, yana kula da yanayin gefen lambobi da suka yi ƙasa ko daidai da 1, waɗanda ba su da lamba mai lamba, da ƙananan lambobi (2 da 3) waɗanda suke lamba mai lamba. Sannan yana duba ko za a iya raba shi da 2 da 3. Don lambobi masu girma, yana amfani da ingantaccen 6k +/- 1 don gwada masu raba har zuwa tushen murabba'in lambar.\n\n    Args:\n    num (int): Lambar da za a duba ko lamba mai lamba ce.\n\n    Returns:\n    bool: Gaskiya idan `num` lamba mai lamba ce, Karya in ba haka ba.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "hi": "एक पायथन फ़ंक्शन 'def is_prime(num: int) -> bool:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    यह निर्धारित करें कि दिया गया पूर्णांक एक अभाज्य संख्या है या नहीं।\n\n    एक अभाज्य संख्या 1 से बड़ी प्राकृतिक संख्या होती है जिसका कोई धनात्मक भाजक नहीं होता सिवाय 1 और स्वयं के। फ़ंक्शन कई परीक्षणों का उपयोग करके अभाज्यता की जांच करता है, गैर-अभाज्य संख्याओं को समाप्त करता है। सबसे पहले, यह 1 से कम या बराबर संख्याओं के लिए किनारे के मामलों को संभालता है, जो अभाज्य नहीं हैं, और छोटी संख्याएं (2 और 3) जो अभाज्य हैं। फिर यह 2 और 3 से विभाज्यता की जांच करता है। बड़ी संख्याओं के लिए, यह संख्या के वर्गमूल तक गुणनखंडों का परीक्षण करने के लिए 6k +/- 1 अनुकूलन का उपयोग करता है।\n\n    तर्क:\n    num (int): अभाज्यता की जांच के लिए पूर्णांक।\n\n    लौटाता है:\n    bool: True यदि `num` एक अभाज्य संख्या है, अन्यथा False।\n\n    मामले:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "hu": "Írj egy Python függvényt 'def is_prime(num: int) -> bool:' a következő probléma megoldására:\n\n    Határozd meg, hogy a megadott egész szám prím-e.\n\n    A prímszám olyan 1-nél nagyobb természetes szám, amelynek nincsenek pozitív osztói 1-en és önmagán kívül. A függvény több teszt segítségével ellenőrzi a prím tulajdonságot, kizárva a nem prím számokat. Először kezeli azokat a szélsőséges eseteket, amikor a szám kisebb vagy egyenlő 1-gyel, amelyek nem prímek, és a kis számokat (2 és 3), amelyek prímek. Ezután ellenőrzi az oszthatóságot 2-vel és 3-mal. Nagyobb számok esetén egy 6k +/- 1 optimalizálást használ, hogy tesztelje a szám négyzetgyökéig terjedő osztókat.\n\n    Args:\n    num (int): Az egész szám, amelyet a prím tulajdonság ellenőrzésére vizsgálunk.\n\n    Returns:\n    bool: Igaz, ha `num` prímszám, egyébként Hamis.\n\n    Esetek:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "es": "Escribe una función de Python 'def is_prime(num: int) -> bool:' para resolver el siguiente problema:\n\n    Determinar si un número entero dado es un número primo.\n\n    Un número primo es un número natural mayor que 1 que no tiene divisores positivos aparte de 1 y sí mismo. La función verifica la primalidad eliminando números no primos mediante varias pruebas. Primero, maneja casos especiales para números menores o iguales a 1, que no son primos, y números pequeños (2 y 3) que son primos. Luego verifica la divisibilidad por 2 y 3. Para números más grandes, utiliza una optimización de 6k +/- 1 para probar factores hasta la raíz cuadrada del número.\n\n    Argumentos:\n    num (int): El entero a verificar para primalidad.\n\n    Devuelve:\n    bool: True si `num` es un número primo, False en caso contrario.\n\n    Casos:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "arb": "اكتب دالة بايثون 'def is_prime(num: int) -> bool:' لحل المشكلة التالية:\n\n    تحديد ما إذا كان العدد الصحيح المعطى هو عدد أولي.\n\n    العدد الأولي هو عدد طبيعي أكبر من 1 وليس له قواسم موجبة أخرى غير 1 ونفسه. تقوم الدالة بالتحقق من الأولية عن طريق استبعاد الأعداد غير الأولية باستخدام عدة اختبارات. أولاً، تتعامل مع الحالات الخاصة للأعداد الأقل من أو تساوي 1، والتي ليست أولية، والأعداد الصغيرة (2 و3) التي هي أولية. ثم تتحقق من القابلية للقسمة على 2 و3. بالنسبة للأعداد الأكبر، تستخدم تحسين 6k +/- 1 لاختبار العوامل حتى الجذر التربيعي للعدد.\n\n    يعيدالحجج:\n    num (int): العدد الصحيح للتحقق من أوليته.\n\n    يعيد:\n    bool: True إذا كان `num` عددًا أوليًا، False خلاف ذلك.\n\n    حالات:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "sw": "Andika kazi ya python 'def is_prime(num: int) -> bool:' kutatua tatizo lifuatalo:\n\n    Tambua kama nambari kamili iliyotolewa ni nambari ya kwanza.\n\n    Nambari ya kwanza ni nambari asilia kubwa kuliko 1 ambayo haina wagawanyaji chanya isipokuwa 1 na yenyewe. Kazi hii inakagua uhalisia wa nambari kwa kuondoa nambari zisizo za kwanza kwa kutumia vipimo kadhaa. Kwanza, inashughulikia kesi za ukingo kwa nambari ndogo au sawa na 1, ambazo si za kwanza, na nambari ndogo (2 na 3) ambazo ni za kwanza. Kisha inakagua ugawanyiko kwa 2 na 3. Kwa nambari kubwa, inatumia uboreshaji wa 6k +/- 1 kupima vipengele hadi mzizi wa mraba wa nambari.\n\n    Hoja:\n    num (int): Nambari kamili ya kukagua uhalisia wa kuwa ya kwanza.\n\n    Inarejesha:\n    bool: Kweli ikiwa `num` ni nambari ya kwanza, Si kweli vinginevyo.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "tr": "Bir python fonksiyonu 'def is_prime(num: int) -> bool:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen bir tamsayının asal sayı olup olmadığını belirleyin.\n\n    Asal sayı, 1'den büyük ve kendisinden başka pozitif böleni olmayan doğal sayıdır. Fonksiyon, asal olmayan sayıları birkaç test kullanarak eleyerek asal olup olmadığını kontrol eder. İlk olarak, asal olmayan 1 veya daha küçük sayılar ve asal olan küçük sayılar (2 ve 3) için özel durumları ele alır. Daha sonra 2 ve 3 ile bölünebilirliği kontrol eder. Daha büyük sayılar için, sayının kareköküne kadar olan faktörleri test etmek için 6k +/- 1 optimizasyonunu kullanır.\n\n    Argümanlar:\n    num (int): Asallığı kontrol edilecek tamsayı.\n\n    Döndürür:\n    bool: `num` asal bir sayıysa True, aksi takdirde False.\n\n    Durumlar:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "vi": "Viết một hàm python 'def is_prime(num: int) -> bool:' để giải quyết vấn đề sau:\n\n    Xác định xem một số nguyên cho trước có phải là số nguyên tố hay không.\n\n    Số nguyên tố là một số tự nhiên lớn hơn 1 mà không có ước số dương nào khác ngoài 1 và chính nó. Hàm kiểm tra tính nguyên tố bằng cách loại bỏ các số không phải nguyên tố thông qua một số kiểm tra. Đầu tiên, nó xử lý các trường hợp đặc biệt cho các số nhỏ hơn hoặc bằng 1, không phải là số nguyên tố, và các số nhỏ (2 và 3) là số nguyên tố. Sau đó, nó kiểm tra tính chia hết cho 2 và 3. Đối với các số lớn hơn, nó sử dụng tối ưu hóa 6k +/- 1 để kiểm tra các yếu tố lên đến căn bậc hai của số đó.\n\n    Tham số:\n    num (int): Số nguyên cần kiểm tra tính nguyên tố.\n\n    Trả về:\n    bool: True nếu `num` là một số nguyên tố, False nếu không phải.\n\n    Trường hợp:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "id": "Tulis sebuah fungsi python 'def is_prime(num: int) -> bool:' untuk menyelesaikan masalah berikut:\n\n    Tentukan apakah bilangan bulat yang diberikan adalah bilangan prima.\n\n    Bilangan prima adalah bilangan asli yang lebih besar dari 1 yang tidak memiliki pembagi positif selain 1 dan dirinya sendiri. Fungsi ini memeriksa keprimaan dengan mengeliminasi bilangan non-prima menggunakan beberapa tes. Pertama, fungsi ini menangani kasus tepi untuk bilangan kurang dari atau sama dengan 1, yang bukan prima, dan bilangan kecil (2 dan 3) yang merupakan prima. Kemudian, fungsi ini memeriksa keterbagian oleh 2 dan 3. Untuk bilangan yang lebih besar, fungsi ini menggunakan optimasi 6k +/- 1 untuk menguji faktor hingga akar kuadrat dari bilangan tersebut.\n\n    Args:\n    num (int): Bilangan bulat yang akan diperiksa keprimaannya.\n\n    Returns:\n    bool: True jika `num` adalah bilangan prima, False jika tidak.\n\n    Kasus:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "ja": "以下の問題を解決するためのPython関数 'def is_prime(num: int) -> bool:' を作成してください。\n\n    与えられた整数が素数かどうかを判定します。\n\n    素数は、1より大きく、1とその数自身以外に正の約数を持たない自然数です。この関数は、いくつかのテストを使用して非素数を除外することにより、素数性をチェックします。まず、1以下の数は素数ではなく、2と3は素数であるというエッジケースを処理します。次に、2と3での除算可能性をチェックします。より大きな数に対しては、6k +/- 1 の最適化を使用して、その数の平方根までの因数をテストします。\n\n    引数:\n    num (int): 素数性をチェックする整数。\n\n    戻り値:\n    bool: `num`が素数であればTrue、そうでなければFalse。\n\n    ケース:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "ko": "파이썬 함수를 작성하십시오 'def is_prime(num: int) -> bool:' 다음 문제를 해결하기 위해:\n\n    주어진 정수가 소수인지 여부를 결정합니다.\n\n    소수는 1보다 큰 자연수로, 1과 자기 자신 외에는 양의 약수가 없는 수입니다. 이 함수는 여러 테스트를 통해 소수가 아닌 수를 제거하여 소수 여부를 확인합니다. 먼저, 소수가 아닌 1 이하의 숫자와 소수인 작은 숫자(2와 3)에 대한 예외 처리를 합니다. 그런 다음 2와 3으로 나누어 떨어지는지 확인합니다. 더 큰 숫자의 경우, 6k +/- 1 최적화를 사용하여 숫자의 제곱근까지의 인수를 테스트합니다.\n\n    인수:\n    num (int): 소수 여부를 확인할 정수.\n\n    반환:\n    bool: `num`이 소수이면 True, 그렇지 않으면 False.\n\n    사례:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "ml": "ഒരു പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക 'def is_prime(num: int) -> bool:' താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    നൽകിയിരിക്കുന്ന പൂർണ്ണസംഖ്യ ഒരു പ്രധാന സംഖ്യയാണോ എന്ന് നിർണയിക്കുക.\n\n    ഒരു പ്രധാന സംഖ്യ 1-ലും തന്നെതന്നെയും ഒഴികെ മറ്റ് അനുകൂല ഹരിതങ്ങൾ ഇല്ലാത്ത 1-ൽ കൂടുതലുള്ള ഒരു സ്വാഭാവിക സംഖ്യയാണ്. പ്രധാന സംഖ്യയാണോ എന്ന് പരിശോധിക്കുന്നതിന്, നിരവധി പരീക്ഷണങ്ങൾ ഉപയോഗിച്ച് പ്രധാനമല്ലാത്ത സംഖ്യകളെ ഒഴിവാക്കുന്നു. ആദ്യം, പ്രധാനമല്ലാത്ത 1-ൽ കുറവോ തുല്യമോ ആയ സംഖ്യകൾക്കായുള്ള എഡ്ജ് കേസുകൾ കൈകാര്യം ചെയ്യുന്നു, കൂടാതെ പ്രധാന സംഖ്യകളായ ചെറിയ സംഖ്യകൾ (2, 3). തുടർന്ന്, 2-നും 3-നും വേണ്ടി വിഭജ്യത പരിശോധിക്കുന്നു. വലുതായ സംഖ്യകൾക്കായി, സംഖ്യയുടെ വർഗ്ഗമൂല്യത്തിൽ വരെ ഘടകങ്ങൾ പരിശോധിക്കാൻ 6k +/- 1 ഓപ്റ്റിമൈസേഷൻ ഉപയോഗിക്കുന്നു.\n\n    Args:\n    num (int): പ്രധാന സംഖ്യയാണോ എന്ന് പരിശോധിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n\n    Returns:\n    bool: `num` ഒരു പ്രധാന സംഖ്യയായാൽ True, അല്ലെങ്കിൽ False.\n\n    കേസുകൾ:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "fa": "یک تابع پایتون 'def is_prime(num: int) -> bool:' بنویسید تا مسئله زیر را حل کند:\n\n    تعیین کنید که آیا یک عدد صحیح داده شده یک عدد اول است یا خیر.\n\n    یک عدد اول، عدد طبیعی بزرگتر از 1 است که هیچ مقسوم علیه مثبت دیگری جز 1 و خودش ندارد. تابع با حذف اعداد غیر اول با استفاده از چندین آزمون، اول بودن را بررسی می‌کند. ابتدا، موارد خاص برای اعداد کمتر یا مساوی 1 که اول نیستند و اعداد کوچک (2 و 3) که اول هستند را بررسی می‌کند. سپس برای تقسیم‌پذیری بر 2 و 3 بررسی می‌کند. برای اعداد بزرگتر، از بهینه‌سازی 6k +/- 1 برای آزمون عوامل تا جذر عدد استفاده می‌کند.\n\n    آرگومان‌ها:\n    num (int): عدد صحیحی که باید برای اول بودن بررسی شود.\n\n    بازگشت:\n    bool: اگر `num` یک عدد اول باشد، True برمی‌گرداند، در غیر این صورت False.\n\n    موارد:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False"}, "level": "easy", "test": "def test_is_prime():\n    # Test case 1: Test a prime number\n    prime_number = 29\n    assert is_prime(prime_number) == True, f\"Test case 1 failed: {prime_number} is a prime number.\"\n\n    # Test case 2: Test a non-prime number\n    non_prime_number = 21  # 21 = 3 * 7, so it's not prime\n    assert is_prime(non_prime_number) == False, f\"Test case 2 failed: {non_prime_number} is not a prime number.\"\n\n    # Test case 3: Test a number less than 2 (should not be prime)\n    less_than_two = 1\n    assert is_prime(less_than_two) == False, f\"Test case 3 failed: {less_than_two} is not a prime number.\"\n\n    # Test case 4: Test another prime number\n    another_prime_number = 97\n    assert is_prime(another_prime_number) == True, f\"Test case 4 failed: {another_prime_number} is a prime number.\"\n\n    # Test case 5: Test zero (should not be prime)\n    zero = 0\n    assert is_prime(zero) == False, f\"Test case 5 failed: {zero} is not a prime number.\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_is_prime()", "entry_point": "is_prime", "signature": "def is_prime(num: int) -> bool:", "docstring": {"en": "\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ", "sq": "\n    Përcaktoni nëse një numër i dhënë është numër i thjeshtë.\n\n    Një numër i thjeshtë është një numër natyror më i madh se 1 që nuk ka ndarës pozitivë përveç 1 dhe vetes. Funksioni kontrollon për thjeshtësinë duke eliminuar numrat jo të thjeshtë duke përdorur disa teste. Së pari, trajton rastet e veçanta për numrat më të vegjël ose të barabartë me 1, të cilët nuk janë të thjeshtë, dhe numrat e vegjël (2 dhe 3) që janë të thjeshtë. Pastaj kontrollon për pjesëtueshmëri me 2 dhe 3. Për numra më të mëdhenj, përdor një optimizim 6k +/- 1 për të testuar për faktorë deri në rrënjën katrore të numrit.\n\n    Args:\n    num (int): Numri për të kontrolluar për thjeshtësi.\n\n    Returns:\n    bool: True nëse `num` është numër i thjeshtë, False përndryshe.\n\n    Rastet:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "hy": "\n    Որոշել, արդյոք տրված ամբողջ թիվը պարզ թիվ է:\n\n    Պարզ թիվը բնական թիվ է, որը մեծ է 1-ից և չունի դրական բաժանարարներ, բացի 1-ից և իրենից: Ֆունկցիան ստուգում է պարզությունը՝ ոչ պարզ թվերը բացառելով մի քանի փորձարկումներով: Նախ, այն մշակում է 1-ից փոքր կամ հավասար թվերի եզակի դեպքերը, որոնք պարզ չեն, և փոքր թվերը (2 և 3), որոնք պարզ են: Այնուհետև ստուգում է բաժանելիությունը 2-ով և 3-ով: Ավելի մեծ թվերի համար այն օգտագործում է 6k +/- 1 օպտիմալացում՝ մինչև թվի քառակուսի արմատը գործոններ ստուգելու համար:\n\n    Պարամետրեր:\n    num (int): Ամբողջ թիվը, որը պետք է ստուգել պարզության համար:\n\n    Վերադարձնում է:\n    bool: True, եթե `num`-ը պարզ թիվ է, False՝ հակառակ դեպքում:\n\n    Դեպքեր:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "bn": "\n    একটি প্রদত্ত পূর্ণসংখ্যা একটি মৌলিক সংখ্যা কিনা তা নির্ধারণ করুন।\n\n    একটি মৌলিক সংখ্যা হল ১ এর চেয়ে বড় একটি স্বাভাবিক সংখ্যা যার কোনো ধনাত্মক গুণনীয়ক নেই ১ এবং তার নিজের বাইরে। ফাংশনটি মৌলিকতা পরীক্ষা করে অমৌলিক সংখ্যা বাদ দিয়ে বিভিন্ন পরীক্ষার মাধ্যমে। প্রথমে, এটি ১ বা তার চেয়ে ছোট সংখ্যাগুলির জন্য প্রান্তিক ক্ষেত্রগুলি পরিচালনা করে, যা মৌলিক নয়, এবং ছোট সংখ্যা (2 এবং 3) যা মৌলিক। তারপর এটি 2 এবং 3 দ্বারা বিভাজ্যতা পরীক্ষা করে। বড় সংখ্যার জন্য, এটি সংখ্যার বর্গমূল পর্যন্ত গুণনীয়ক পরীক্ষা করার জন্য 6k +/- 1 অপ্টিমাইজেশন ব্যবহার করে।\n\n    Args:\n    num (int): মৌলিকতা পরীক্ষা করার জন্য পূর্ণসংখ্যা।\n\n    Returns:\n    bool: যদি `num` একটি মৌলিক সংখ্যা হয় তবে True, অন্যথায় False।\n\n    উদাহরণ:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "bg": "\n    Определете дали дадено цяло число е просто число.\n\n    Просто число е естествено число, по-голямо от 1, което няма положителни делители, различни от 1 и самото него. Функцията проверява за простота, като елиминира не-простите числа чрез няколко теста. Първо, тя обработва граничните случаи за числа, по-малки или равни на 1, които не са прости, и малките числа (2 и 3), които са прости. След това проверява за делимост на 2 и 3. За по-големи числа използва оптимизация 6k +/- 1, за да тества за делители до квадратния корен на числото.\n\n    Аргументи:\n    num (int): Цялото число, което да се провери за простота.\n\n    Връща:\n    bool: True ако `num` е просто число, False в противен случай.\n\n    Примери:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "zh": "\n    判断给定整数是否为质数。\n\n    质数是大于1的自然数，除了1和它本身外没有其他正因数。该函数通过使用几个测试来排除非质数以检查质数性。首先，它处理小于或等于1的数字的边界情况，这些数字不是质数，而小数字（2和3）是质数。然后检查是否能被2和3整除。对于较大的数字，它使用6k +/- 1优化来测试因数，直到数字的平方根。\n\n    参数:\n    num (int): 要检查是否为质数的整数。\n\n    返回:\n    bool: 如果 `num` 是质数则返回 True，否则返回 False。\n\n    示例:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "fr": "\n    Déterminer si un entier donné est un nombre premier.\n\n    Un nombre premier est un nombre naturel supérieur à 1 qui n'a pas de diviseurs positifs autres que 1 et lui-même. La fonction vérifie la primalité en éliminant les nombres non premiers à l'aide de plusieurs tests. Tout d'abord, elle gère les cas particuliers pour les nombres inférieurs ou égaux à 1, qui ne sont pas premiers, et les petits nombres (2 et 3) qui sont premiers. Elle vérifie ensuite la divisibilité par 2 et 3. Pour les nombres plus grands, elle utilise une optimisation 6k +/- 1 pour tester les facteurs jusqu'à la racine carrée du nombre.\n\n    Args:\n    num (int): L'entier à vérifier pour la primalité.\n\n    Returns:\n    bool: True si `num` est un nombre premier, False sinon.\n\n    Cas:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "de": "\n    Bestimmen Sie, ob eine gegebene ganze Zahl eine Primzahl ist.\n\n    Eine Primzahl ist eine natürliche Zahl größer als 1, die keine positiven Teiler außer 1 und sich selbst hat. Die Funktion überprüft die Primzahl-Eigenschaft, indem sie nicht-primzahlen durch mehrere Tests eliminiert. Zuerst behandelt sie Sonderfälle für Zahlen kleiner oder gleich 1, die keine Primzahlen sind, und kleine Zahlen (2 und 3), die Primzahlen sind. Dann wird die Teilbarkeit durch 2 und 3 überprüft. Für größere Zahlen wird eine 6k +/- 1 Optimierung verwendet, um Faktoren bis zur Quadratwurzel der Zahl zu testen.\n\n    Args:\n    num (int): Die ganze Zahl, die auf Primzahl-Eigenschaft überprüft werden soll.\n\n    Returns:\n    bool: True, wenn `num` eine Primzahl ist, andernfalls False.\n\n    Fälle:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "ha": "\n    Tantance ko wani lamba cikakke shine lamba mai lamba.\n\n    Lamba mai lamba shine lamba na halitta wanda ya fi 1 wanda ba shi da masu raba lamba masu kyau sai dai 1 da kansa. Aikin yana duba cikakken lamba ta hanyar kawar da lambobin da ba su da cikakken lamba ta amfani da gwaje-gwaje da dama. Da farko, yana magance lokuta na musamman ga lambobi da suka yi ƙasa ko daidai da 1, waɗanda ba su da cikakken lamba, da ƙananan lambobi (2 da 3) waɗanda suke cikakke. Sannan yana duba rarrabuwar 2 da 3. Ga manyan lambobi, yana amfani da ingantaccen 6k +/- 1 don gwada masu raba har zuwa tushen murabba'in lambar.\n\n    Args:\n    num (int): Lambar da za a duba don cikakken lamba.\n\n    Returns:\n    bool: Gaskiya idan `num` cikakke ne, Karya in ba haka ba.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "hi": "\n    यह निर्धारित करें कि दिया गया पूर्णांक एक अभाज्य संख्या है या नहीं।\n\n    एक अभाज्य संख्या एक प्राकृतिक संख्या है जो 1 से बड़ी होती है और जिसका कोई अन्य धनात्मक भाजक नहीं होता सिवाय 1 और स्वयं के। यह फ़ंक्शन कई परीक्षणों का उपयोग करके अभाज्यता की जांच करता है, गैर-अभाज्य संख्याओं को समाप्त करता है। सबसे पहले, यह 1 से कम या बराबर संख्याओं के लिए किनारे के मामलों को संभालता है, जो अभाज्य नहीं होते, और छोटी संख्याएं (2 और 3) जो अभाज्य होती हैं। फिर यह 2 और 3 से विभाज्यता की जांच करता है। बड़ी संख्याओं के लिए, यह संख्या के वर्गमूल तक कारकों का परीक्षण करने के लिए 6k +/- 1 अनुकूलन का उपयोग करता है।\n\n    तर्क:\n    num (int): अभाज्यता की जांच के लिए पूर्णांक।\n\n    लौटाता है:\n    bool: True अगर `num` एक अभाज्य संख्या है, अन्यथा False।\n\n    मामले:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "hu": "\n    Határozza meg, hogy egy adott egész szám prímszám-e.\n\n    A prímszám olyan természetes szám, amely nagyobb, mint 1, és nincs más pozitív osztója, csak 1 és önmaga. A függvény több teszt segítségével szűri ki a nem prím számokat, hogy ellenőrizze a prím tulajdonságot. Először kezeli az 1-nél kisebb vagy egyenlő számok speciális eseteit, amelyek nem prímek, valamint a kis számokat (2 és 3), amelyek prímek. Ezután ellenőrzi az oszthatóságot 2-vel és 3-mal. Nagyobb számok esetén 6k +/- 1 optimalizálást használ, hogy tesztelje az osztókat a szám négyzetgyökéig.\n\n    Paraméterek:\n    num (int): Az egész szám, amelyet a prím tulajdonságra ellenőrzünk.\n\n    Visszatér:\n    bool: Igaz, ha `num` prímszám, egyébként Hamis.\n\n    Esetek:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "es": "    Determinar si un número entero dado es un número primo.\n\n    Un número primo es un número natural mayor que 1 que no tiene divisores positivos aparte de 1 y él mismo. La función verifica la primalidad eliminando números no primos mediante varias pruebas. Primero, maneja casos especiales para números menores o iguales a 1, que no son primos, y números pequeños (2 y 3) que son primos. Luego verifica la divisibilidad por 2 y 3. Para números más grandes, utiliza una optimización de 6k +/- 1 para probar factores hasta la raíz cuadrada del número.\n\n    Argumentos:\n    num (int): El número entero a verificar para primalidad.\n\n    Devuelve:\n    bool: True si `num` es un número primo, False en caso contrario.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ", "arb": "    تحديد ما إذا كان العدد الصحيح المعطى هو عدد أولي.\n\n    العدد الأولي هو عدد طبيعي أكبر من 1 وليس له قواسم موجبة أخرى غير 1 ونفسه. تقوم الدالة بالتحقق من الأولية عن طريق استبعاد الأعداد غير الأولية باستخدام عدة اختبارات. أولاً، تتعامل مع الحالات الخاصة للأعداد الأقل من أو تساوي 1، والتي ليست أولية، والأعداد الصغيرة (2 و 3) التي هي أولية. ثم تتحقق من القابلية للقسمة على 2 و 3. بالنسبة للأعداد الأكبر، تستخدم تحسين 6k +/- 1 لاختبار العوامل حتى الجذر التربيعي للعدد.\n\n    المتغيرات:\n    num (int): العدد الصحيح للتحقق من أوليته.\n\n    يعيد:\n    bool: True إذا كان `num` عددًا أوليًا، False خلاف ذلك.\n\n    حالات:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "sw": "    Kuamua kama nambari kamili iliyotolewa ni nambari ya kwanza.\n\n    Nambari ya kwanza ni nambari asilia kubwa kuliko 1 ambayo haina wagawanyaji chanya zaidi ya 1 na yenyewe. Kazi hii inakagua hali ya kuwa nambari ya kwanza kwa kuondoa nambari zisizo za kwanza kwa kutumia vipimo kadhaa. Kwanza, inashughulikia kesi maalum za nambari ndogo au sawa na 1, ambazo si za kwanza, na nambari ndogo (2 na 3) ambazo ni za kwanza. Kisha inakagua ugawanyiko kwa 2 na 3. Kwa nambari kubwa, inatumia uboreshaji wa 6k +/- 1 kupima vipengele hadi mzizi wa mraba wa nambari.\n\n    Hoja:\n    num (int): Nambari kamili ya kukagua hali ya kuwa nambari ya kwanza.\n\n    Inarejesha:\n    bool: Kweli ikiwa `num` ni nambari ya kwanza, Si kweli vinginevyo.\n\n    Mifano:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ", "tr": "    Verilen bir tam sayının asal sayı olup olmadığını belirleyin.\n\n    Asal sayı, 1'den büyük ve kendisi dışında pozitif böleni olmayan doğal sayıdır. Fonksiyon, asal olmayan sayıları birkaç test kullanarak eleyerek asal olup olmadığını kontrol eder. İlk olarak, asal olmayan 1 veya daha küçük sayılar ve asal olan küçük sayılar (2 ve 3) için özel durumları ele alır. Daha sonra 2 ve 3 ile bölünebilirliği kontrol eder. Daha büyük sayılar için, sayının kareköküne kadar olan faktörleri test etmek için 6k +/- 1 optimizasyonunu kullanır.\n\n    Argümanlar:\n    num (int): Asallığı kontrol edilecek tam sayı.\n\n    Döndürür:\n    bool: `num` bir asal sayı ise True, aksi takdirde False.\n\n    Durumlar:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ", "vi": "    Xác định xem một số nguyên cho trước có phải là số nguyên tố hay không.\n\n    Số nguyên tố là một số tự nhiên lớn hơn 1 không có ước số dương nào khác ngoài 1 và chính nó. Hàm kiểm tra tính nguyên tố bằng cách loại bỏ các số không phải nguyên tố thông qua một số kiểm tra. Đầu tiên, nó xử lý các trường hợp đặc biệt cho các số nhỏ hơn hoặc bằng 1, không phải là số nguyên tố, và các số nhỏ (2 và 3) là số nguyên tố. Sau đó, nó kiểm tra tính chia hết cho 2 và 3. Đối với các số lớn hơn, nó sử dụng tối ưu hóa 6k +/- 1 để kiểm tra các ước số lên đến căn bậc hai của số đó.\n\n    Tham số:\n    num (int): Số nguyên cần kiểm tra tính nguyên tố.\n\n    Trả về:\n    bool: True nếu `num` là số nguyên tố, False nếu không phải.\n\n    Trường hợp:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ", "id": "Menentukan apakah bilangan bulat yang diberikan adalah bilangan prima.\n\nBilangan prima adalah bilangan asli yang lebih besar dari 1 yang tidak memiliki pembagi positif selain 1 dan dirinya sendiri. Fungsi ini memeriksa keprimalan dengan mengeliminasi bilangan non-prima menggunakan beberapa pengujian. Pertama, fungsi ini menangani kasus tepi untuk bilangan kurang dari atau sama dengan 1, yang bukan prima, dan bilangan kecil (2 dan 3) yang merupakan prima. Kemudian, fungsi ini memeriksa keterbagian oleh 2 dan 3. Untuk bilangan yang lebih besar, fungsi ini menggunakan optimasi 6k +/- 1 untuk menguji faktor hingga akar kuadrat dari bilangan tersebut.\n\nArgs:\nnum (int): Bilangan bulat yang akan diperiksa keprimalannya.\n\nReturns:\nbool: True jika `num` adalah bilangan prima, False jika tidak.\n\nCases:\n>>> is_prime(2)\nTrue\n>>> is_prime(15)\nFalse", "ja": "    与えられた整数が素数であるかどうかを判断します。\n\n    素数は、1より大きく、1と自分自身以外に正の約数を持たない自然数です。この関数は、いくつかのテストを使用して非素数を排除することで、素数であるかどうかを確認します。まず、素数でない1以下の数と、素数である小さな数（2と3）の特別なケースを処理します。その後、2と3での除算可能性を確認します。より大きな数に対しては、6k +/- 1の最適化を使用して、その数の平方根までの因数をテストします。\n\n    引数:\n    num (int): 素数であるかを確認する整数。\n\n    戻り値:\n    bool: `num`が素数であればTrue、そうでなければFalse。\n\n    ケース:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "ko": "    주어진 정수가 소수인지 여부를 결정합니다.\n\n    소수는 1보다 큰 자연수 중에서 1과 자기 자신 외에는 양의 약수가 없는 수입니다. 이 함수는 여러 테스트를 통해 소수가 아닌 수를 제거하여 소수 여부를 확인합니다. 먼저, 소수가 아닌 1 이하의 수와 소수인 작은 수(2와 3)에 대한 예외 처리를 합니다. 그런 다음 2와 3으로 나누어지는지 확인합니다. 더 큰 수의 경우, 6k +/- 1 최적화를 사용하여 수의 제곱근까지의 인수를 테스트합니다.\n\n    인수:\n    num (int): 소수 여부를 확인할 정수입니다.\n\n    반환:\n    bool: `num`이 소수이면 True, 그렇지 않으면 False입니다.\n\n    사례:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "ml": "    നൽകിയ ഒരു പൂർണ്ണസംഖ്യ പ്രധാന സംഖ്യയാണോ എന്ന് നിർണ്ണയിക്കുക.\n\n    ഒരു പ്രധാന സംഖ്യ 1-ലധികം മൂല്യമുള്ള ഒരു സ്വാഭാവിക സംഖ്യയാണ്, 1-നും തനിക്കുമല്ലാതെ മറ്റ് അനുകൂലമായ വിഭജകങ്ങളില്ല. പ്രധാന സംഖ്യയാണോ എന്ന് പരിശോധിക്കുന്നതിന്, ഈ ഫംഗ്ഷൻ വിവിധ പരിശോധനകൾ ഉപയോഗിച്ച് പ്രധാനമല്ലാത്ത സംഖ്യകളെ ഒഴിവാക്കുന്നു. ആദ്യം, പ്രധാനമല്ലാത്ത 1-ൽ കുറവോ തുല്യമോ ആയ സംഖ്യകൾക്കായുള്ള എഡ്ജ് കേസുകൾ കൈകാര്യം ചെയ്യുന്നു, കൂടാതെ പ്രധാന സംഖ്യകളായ ചെറിയ സംഖ്യകൾ (2, 3) കൈകാര്യം ചെയ്യുന്നു. തുടർന്ന് 2, 3 എന്നിവയാൽ വിഭജ്യത പരിശോധിക്കുന്നു. വലിയ സംഖ്യകൾക്കായി, 6k +/- 1 ഓപ്റ്റിമൈസേഷൻ ഉപയോഗിച്ച് സംഖ്യയുടെ ചതുരശ്രമൂല്യത്തിൽ വരെ ഘടകങ്ങൾ പരിശോധിക്കുന്നു.\n\n    Args:\n    num (int): പ്രധാന സംഖ്യയാണോ എന്ന് പരിശോധിക്കേണ്ട പൂർണ്ണസംഖ്യ.\n\n    Returns:\n    bool: `num` ഒരു പ്രധാന സംഖ്യയായാൽ True, അല്ലെങ്കിൽ False.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False", "fa": "    تعیین کنید که آیا یک عدد صحیح داده شده یک عدد اول است یا خیر.\n\n    یک عدد اول عدد طبیعی بزرگتر از 1 است که هیچ مقسوم علیه مثبت دیگری جز 1 و خودش ندارد. این تابع با حذف اعداد غیر اول با استفاده از چندین آزمون، اول بودن را بررسی می‌کند. ابتدا، موارد خاص برای اعداد کمتر یا مساوی 1 که اول نیستند و اعداد کوچک (2 و 3) که اول هستند را بررسی می‌کند. سپس قابلیت تقسیم بر 2 و 3 را بررسی می‌کند. برای اعداد بزرگتر، از بهینه‌سازی 6k +/- 1 برای آزمون فاکتورها تا ریشه دوم عدد استفاده می‌کند.\n\n    آرگومان‌ها:\n    num (int): عدد صحیحی که باید برای اول بودن بررسی شود.\n\n    بازگشتی:\n    bool: اگر `num` یک عدد اول باشد، True و در غیر این صورت False.\n\n    موارد:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False"}}
{"task_id": "Python/31", "prompt": {"en": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "sq": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Gjeneroni të gjitha numrat unikë nga numri i dhënë duke aplikuar rregullat e transformimit.\n\n    Çdo rregull lejon që një shifër e vetme të transformohet në një tjetër. Një kërkim në gjerësi\n    (BFS) përdoret për të eksploruar të gjitha transformimet e mundshme. Funksioni kthen numrin\n    e numrave unikë që mund të gjenerohen nga numri origjinal, duke përfshirë vetë numrin.\n\n    Argumentet:\n    - n (int): Numri origjinal i plotë për të transformuar.\n    - rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull paraqitet\n                              si një tuple (x, y) që tregon se shifra x mund të transformohet në y.\n\n    Kthen:\n    - int: Numri total i numrave unikë që mund të gjenerohen.\n\n    Raste:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "hy": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Գեներացնել բոլոր եզակի թվերը տրված թվից՝ կիրառելով փոխակերպման կանոններ։\n\n    Յուրաքանչյուր կանոն թույլ է տալիս մեկ թվանշանը փոխակերպել մեկ այլ թվանշանի։ \n    Լայնության առաջին որոնում (BFS) օգտագործվում է բոլոր հնարավոր փոխակերպումները ուսումնասիրելու համար։ \n    Ֆունկցիան վերադարձնում է եզակի թվերի քանակը, որոնք կարող են գեներացվել սկզբնական թվից, ներառյալ թիվը։\n\n    Պարամետրեր:\n    - n (int): Սկզբնական ամբողջ թիվը փոխակերպելու համար։\n    - rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն ներկայացված է որպես\n                              զույգ (x, y), որը ցույց է տալիս, որ թվանշան x-ը կարող է փոխակերպվել y-ի։\n\n    Վերադարձնում է:\n    - int: Եզակի թվերի ընդհանուր քանակը, որոնք կարող են գեներացվել։\n\n    Օրինակներ:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "bn": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    প্রদত্ত সংখ্যাটি থেকে রূপান্তর নিয়ম প্রয়োগ করে সব অনন্য সংখ্যা তৈরি করুন।\n\n    প্রতিটি নিয়ম একটি একক অঙ্ককে অন্যটিতে রূপান্তর করার অনুমতি দেয়। \n    সমস্ত সম্ভাব্য রূপান্তর অন্বেষণ করতে একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) ব্যবহার করা হয়। \n    ফাংশনটি মূল সংখ্যা সহ মূল সংখ্যাটি থেকে তৈরি করা যেতে পারে এমন অনন্য সংখ্যার সংখ্যা প্রদান করে।\n\n    আর্গুমেন্টসমূহ:\n    - n (int): রূপান্তর করার মূল পূর্ণসংখ্যা সংখ্যা।\n    - rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল (x, y) \n                              হিসাবে উপস্থাপিত হয় যা নির্দেশ করে যে অঙ্ক x কে y তে রূপান্তর করা যেতে পারে।\n\n    রিটার্নস:\n    - int: অনন্য সংখ্যার মোট সংখ্যা যা তৈরি করা যেতে পারে।\n\n    কেসসমূহ:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "bg": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Генерира всички уникални числа от даденото число чрез прилагане на правила за трансформация.\n\n    Всяко правило позволява една цифра да бъде трансформирана в друга. Използва се търсене в ширина\n    (BFS), за да се изследват всички възможни трансформации. Функцията връща броя на уникалните числа,\n    които могат да бъдат генерирани от оригиналното число, включително самото число.\n\n    Аргументи:\n    - n (int): Оригиналното цяло число за трансформиране.\n    - rules (list of tuples): Списък с правила за трансформация, където всяко правило е представено\n                              като кортеж (x, y), указващ, че цифрата x може да бъде трансформирана в y.\n\n    Връща:\n    - int: Общият брой на уникалните числа, които могат да бъдат генерирани.\n\n    Примери:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "zh": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    通过应用转换规则从给定数字生成所有唯一数字。\n\n    每个规则允许将一个数字转换为另一个。使用广度优先搜索 (BFS) 来探索所有可能的转换。\n    该函数返回可以从原始数字生成的唯一数字的数量，包括数字本身。\n\n    参数:\n    - n (int): 要转换的原始整数。\n    - rules (list of tuples): 转换规则列表，其中每个规则表示为一个元组 (x, y)，\n                              表示数字 x 可以转换为 y。\n\n    返回:\n    - int: 可以生成的唯一数字的总数。\n\n    示例:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "fr": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Générer tous les nombres uniques à partir du nombre donné en appliquant des règles de transformation.\n\n    Chaque règle permet de transformer un seul chiffre en un autre. Une recherche en largeur\n    (BFS) est utilisée pour explorer toutes les transformations possibles. La fonction retourne le nombre\n    de nombres uniques qui peuvent être générés à partir du nombre original, y compris le nombre lui-même.\n\n    Args:\n    - n (int): Le nombre entier original à transformer.\n    - rules (list of tuples): Une liste de règles de transformation, où chaque règle est représentée\n                              comme un tuple (x, y) indiquant que le chiffre x peut être transformé en y.\n\n    Returns:\n    - int: Le nombre total de nombres uniques qui peuvent être générés.\n\n    Cas:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "de": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Erzeuge alle eindeutigen Zahlen aus der gegebenen Zahl durch Anwendung von Transformationsregeln.\n\n    Jede Regel erlaubt es, eine einzelne Ziffer in eine andere zu transformieren. Eine Breitensuche\n    (BFS) wird verwendet, um alle möglichen Transformationen zu erkunden. Die Funktion gibt die Anzahl\n    der eindeutigen Zahlen zurück, die aus der ursprünglichen Zahl generiert werden können, einschließlich\n    der Zahl selbst.\n\n    Argumente:\n    - n (int): Die ursprüngliche ganze Zahl, die transformiert werden soll.\n    - rules (list of tuples): Eine Liste von Transformationsregeln, wobei jede Regel als Tupel (x, y)\n                              dargestellt wird, das angibt, dass die Ziffer x in y transformiert werden kann.\n\n    Rückgaben:\n    - int: Die Gesamtanzahl der eindeutigen Zahlen, die generiert werden können.\n\n    Fälle:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "ha": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Samar da duk lambobin musamman daga lambar da aka bayar ta hanyar amfani da dokokin sauyi.\n\n    Kowace doka tana ba da damar sauya lamba guda ɗaya zuwa wata. Ana amfani da binciken faɗin-farko\n    (BFS) don bincika dukkan yiwuwar sauye-sauye. Aikin yana dawo da adadin lambobin musamman\n    da za a iya samarwa daga lambar asali, gami da lambar kanta.\n\n    Args:\n    - n (int): Lambar asali ta integer don sauyawa.\n    - rules (list of tuples): Jerin dokokin sauyi, inda kowace doka ke wakiltar\n                              ta matsayin tuple (x, y) wanda ke nuna cewa ana iya sauya lamba x zuwa y.\n\n    Returns:\n    - int: Jimlar adadin lambobin musamman da za a iya samarwa.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "hi": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    दिए गए संख्या से परिवर्तन नियम लागू करके सभी अद्वितीय संख्याएँ उत्पन्न करें।\n\n    प्रत्येक नियम एकल अंक को दूसरे में बदलने की अनुमति देता है। सभी संभावित परिवर्तनों का पता लगाने के लिए\n    ब्रेड्थ-फर्स्ट सर्च (BFS) का उपयोग किया जाता है। यह फ़ंक्शन उन अद्वितीय संख्याओं की गिनती लौटाता है\n    जो मूल संख्या से उत्पन्न की जा सकती हैं, जिसमें स्वयं संख्या भी शामिल है।\n\n    तर्क:\n    - n (int): मूल पूर्णांक संख्या जिसे परिवर्तित करना है।\n    - rules (list of tuples): परिवर्तन नियमों की एक सूची, जहाँ प्रत्येक नियम को एक ट्यूपल (x, y) के रूप में\n                              दर्शाया गया है, यह दर्शाता है कि अंक x को y में बदला जा सकता है।\n\n    लौटाता है:\n    - int: उत्पन्न की जा सकने वाली अद्वितीय संख्याओं की कुल गिनती।\n\n    उदाहरण:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "hu": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generáljon minden egyedi számot a megadott számból átalakítási szabályok alkalmazásával.\n\n    Minden szabály lehetővé teszi egyetlen számjegy átalakítását egy másikra. Egy szélességi \n    keresést (BFS) használnak az összes lehetséges átalakítás felfedezésére. A függvény visszaadja \n    az eredeti számból generálható egyedi számok számát, beleértve magát a számot is.\n\n    Paraméterek:\n    - n (int): Az eredeti egész szám, amit át kell alakítani.\n    - rules (list of tuples): Az átalakítási szabályok listája, ahol minden szabály egy \n                              (x, y) párként van megadva, jelezve, hogy az x számjegy \n                              átalakítható y-ra.\n\n    Visszatérési érték:\n    - int: Az összes generálható egyedi szám teljes száma.\n\n    Esetek:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "es": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Genera todos los números únicos a partir del número dado aplicando reglas de transformación.\n\n    Cada regla permite transformar un solo dígito en otro. Se utiliza una búsqueda en anchura\n    (BFS) para explorar todas las posibles transformaciones. La función devuelve la cantidad\n    de números únicos que se pueden generar a partir del número original, incluyendo el número mismo.\n\n    Argumentos:\n    - n (int): El número entero original a transformar.\n    - rules (list of tuples): Una lista de reglas de transformación, donde cada regla se representa\n                              como una tupla (x, y) indicando que el dígito x puede transformarse en y.\n\n    Devuelve:\n    - int: La cantidad total de números únicos que se pueden generar.\n\n    Casos:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "arb": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    توليد جميع الأرقام الفريدة من الرقم المعطى عن طريق تطبيق قواعد التحويل.\n\n    كل قاعدة تسمح بتحويل رقم واحد إلى آخر. يتم استخدام البحث بعرض أول\n    (BFS) لاستكشاف جميع التحويلات الممكنة. تقوم الدالة بإرجاع عدد\n    الأرقام الفريدة التي يمكن توليدها من الرقم الأصلي، بما في ذلك الرقم نفسه.\n\n    Args:\n    - n (int): الرقم الصحيح الأصلي للتحويل.\n    - rules (list of tuples): قائمة بقواعد التحويل، حيث يتم تمثيل كل قاعدة\n                              كزوج (x, y) يشير إلى أن الرقم x يمكن تحويله إلى y.\n\n    يعيد:\n    - int: العدد الإجمالي للأرقام الفريدة التي يمكن توليدها.\n\n    حالات:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "sw": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Tengeneza namba zote za kipekee kutoka kwa namba iliyotolewa kwa kutumia sheria za mabadiliko.\n\n    Kila sheria inaruhusu tarakimu moja kubadilishwa kuwa nyingine. Utafutaji wa kwanza kwa upana\n    (BFS) unatumika kuchunguza mabadiliko yote yanayowezekana. Kazi hii inarejesha idadi\n    ya namba za kipekee ambazo zinaweza kutengenezwa kutoka kwa namba ya awali, ikiwa ni pamoja na namba yenyewe.\n\n    Hoja:\n    - n (int): Namba ya awali ya integer ya kubadilisha.\n    - rules (list of tuples): Orodha ya sheria za mabadiliko, ambapo kila sheria inawakilishwa\n                              kama jozi (x, y) ikionyesha kwamba tarakimu x inaweza kubadilishwa kuwa y.\n\n    Inarejesha:\n    - int: Jumla ya idadi ya namba za kipekee ambazo zinaweza kutengenezwa.\n\n    Matukio:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "tr": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Verilen sayıyı dönüşüm kurallarını uygulayarak tüm benzersiz sayıları oluşturun.\n\n    Her kural, tek bir rakamın başka bir rakama dönüştürülmesine izin verir. Tüm olası dönüşümleri\n    keşfetmek için genişlik öncelikli arama (BFS) kullanılır. Fonksiyon, orijinal sayı da dahil olmak üzere\n    orijinal sayıdan üretilebilecek benzersiz sayıların sayısını döndürür.\n\n    Argümanlar:\n    - n (int): Dönüştürülecek orijinal tam sayı.\n    - rules (list of tuples): Her kuralın (x, y) şeklinde bir demet olarak temsil edildiği dönüşüm kuralları listesi,\n                              burada x rakamı y'ye dönüştürülebilir.\n\n    Döner:\n    - int: Üretilebilecek benzersiz sayıların toplam sayısı.\n\n    Durumlar:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "vi": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Tạo tất cả các số duy nhất từ số đã cho bằng cách áp dụng các quy tắc biến đổi.\n\n    Mỗi quy tắc cho phép một chữ số được biến đổi thành chữ số khác. Tìm kiếm theo chiều rộng\n    (BFS) được sử dụng để khám phá tất cả các biến đổi có thể. Hàm trả về số lượng\n    các số duy nhất có thể được tạo ra từ số gốc, bao gồm cả số đó.\n\n    Tham số:\n    - n (int): Số nguyên gốc cần biến đổi.\n    - rules (list of tuples): Danh sách các quy tắc biến đổi, trong đó mỗi quy tắc được biểu diễn\n                              dưới dạng một bộ (x, y) chỉ ra rằng chữ số x có thể được biến đổi thành y.\n\n    Trả về:\n    - int: Tổng số lượng các số duy nhất có thể được tạo ra.\n\n    Trường hợp:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "id": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Menghasilkan semua angka unik dari angka yang diberikan dengan menerapkan aturan transformasi.\n\n    Setiap aturan memungkinkan satu digit untuk diubah menjadi digit lain. Pencarian pertama-breadth\n    (BFS) digunakan untuk menjelajahi semua kemungkinan transformasi. Fungsi ini mengembalikan jumlah\n    angka unik yang dapat dihasilkan dari angka asli, termasuk angka itu sendiri.\n\n    Argumen:\n    - n (int): Angka integer asli untuk ditransformasikan.\n    - rules (list of tuples): Daftar aturan transformasi, di mana setiap aturan direpresentasikan\n                              sebagai tuple (x, y) yang menunjukkan bahwa digit x dapat diubah menjadi y.\n\n    Mengembalikan:\n    - int: Jumlah total angka unik yang dapat dihasilkan.\n\n    Kasus:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "ja": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    与えられた数から変換ルールを適用してすべてのユニークな数を生成します。\n\n    各ルールは、1つの数字を別の数字に変換することを許可します。幅優先探索\n    (BFS) を使用して、すべての可能な変換を探索します。この関数は、元の数から生成できる\n    ユニークな数の数を返します。元の数自体も含みます。\n\n    引数:\n    - n (int): 変換する元の整数。\n    - rules (list of tuples): 変換ルールのリスト。各ルールはタプル (x, y) として表され、\n                              数字 x が y に変換できることを示します。\n\n    戻り値:\n    - int: 生成できるユニークな数の総数。\n\n    ケース:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "ko": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    주어진 숫자에서 변환 규칙을 적용하여 모든 고유한 숫자를 생성합니다.\n\n    각 규칙은 한 자리 숫자를 다른 숫자로 변환할 수 있도록 합니다. 너비 우선 탐색\n    (BFS)을 사용하여 가능한 모든 변환을 탐색합니다. 이 함수는 원래 숫자를 포함하여\n    원래 숫자에서 생성할 수 있는 고유한 숫자의 개수를 반환합니다.\n\n    매개변수:\n    - n (int): 변환할 원래 정수 숫자.\n    - rules (list of tuples): 각 규칙이 (x, y) 튜플로 표현되는 변환 규칙 목록으로,\n                              이는 숫자 x가 y로 변환될 수 있음을 나타냅니다.\n\n    반환값:\n    - int: 생성할 수 있는 고유한 숫자의 총 개수.\n\n    예시:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "ml": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    നൽകിയിരിക്കുന്ന സംഖ്യയിൽ നിന്ന് പരിവർത്തന നിയമങ്ങൾ പ്രയോഗിച്ച് എല്ലാ അതുല്യമായ സംഖ്യകളും സൃഷ്ടിക്കുക.\n\n    ഓരോ നിയമവും ഒരു അക്കത്തെ മറ്റൊന്നായി പരിവർത്തനം ചെയ്യാൻ അനുവദിക്കുന്നു. എല്ലാ സാധ്യതയുള്ള പരിവർത്തനങ്ങളും \n    അന്വേഷിക്കാൻ ബ്രെഡ്ത്ത്-ഫസ്റ്റ് തിരച്ചിൽ (BFS) ഉപയോഗിക്കുന്നു. ഫംഗ്ഷൻ, സംഖ്യയെയും ഉൾപ്പെടെ, \n    മൂല സംഖ്യയിൽ നിന്ന് സൃഷ്ടിക്കാവുന്ന അതുല്യമായ സംഖ്യകളുടെ എണ്ണം തിരിച്ചുനൽകുന്നു.\n\n    Args:\n    - n (int): പരിവർത്തനം ചെയ്യേണ്ട മൂല പൂർണ്ണസംഖ്യ.\n    - rules (list of tuples): പരിവർത്തന നിയമങ്ങളുടെ പട്ടിക, ഓരോ നിയമവും (x, y) എന്ന രൂപത്തിൽ പ്രതിനിധീകരിക്കുന്നു, \n                              ഇവിടെ x എന്ന അക്കം y ആയി പരിവർത്തനം ചെയ്യാം.\n\n    Returns:\n    - int: സൃഷ്ടിക്കാവുന്ന അതുല്യമായ സംഖ്യകളുടെ മൊത്തം എണ്ണം.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"", "fa": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    تولید تمام اعداد یکتا از عدد داده شده با اعمال قوانین تبدیل.\n\n    هر قانون اجازه می‌دهد که یک رقم به رقم دیگری تبدیل شود. از جستجوی اول-به-عرض\n    (BFS) برای بررسی تمام تبدیلات ممکن استفاده می‌شود. این تابع تعداد اعداد یکتایی\n    که می‌توانند از عدد اصلی تولید شوند، شامل خود عدد، را برمی‌گرداند.\n\n    آرگومان‌ها:\n    - n (int): عدد صحیح اصلی که باید تبدیل شود.\n    - rules (list of tuples): لیستی از قوانین تبدیل، که هر قانون به صورت\n                              یک تاپل (x, y) نشان داده می‌شود که نشان می‌دهد رقم x می‌تواند به y تبدیل شود.\n\n    بازگشت:\n    - int: تعداد کل اعداد یکتایی که می‌توانند تولید شوند.\n\n    موارد:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\""}, "canonical_solution": "    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)", "instruction": {"en": "Write a python function 'def generate_numbers(n, rules) -> int:' to solve the following problem:\n\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    ", "sq": "Shkruani një funksion python 'def generate_numbers(n, rules) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Gjeneroni të gjitha numrat unikë nga numri i dhënë duke aplikuar rregullat e transformimit.\n\n    Çdo rregull lejon që një shifër e vetme të transformohet në një tjetër. Një kërkim i parë në gjerësi\n    (BFS) përdoret për të eksploruar të gjitha transformimet e mundshme. Funksioni kthen numrin\n    e numrave unikë që mund të gjenerohen nga numri origjinal, përfshirë vetë numrin.\n\n    Args:\n    - n (int): Numri origjinal i plotë për t'u transformuar.\n    - rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull përfaqësohet\n                              si një tuple (x, y) që tregon se shifra x mund të transformohet në y.\n\n    Kthen:\n    - int: Numri total i numrave unikë që mund të gjenerohen.\n\n    Rastet:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "hy": "Պայթոն ֆունկցիա 'def generate_numbers(n, rules) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Տրված թվից ստեղծել բոլոր եզակի թվերը՝ կիրառելով փոխակերպման կանոններ:\n\n    Յուրաքանչյուր կանոն թույլ է տալիս մեկ թվանշանը փոխակերպել մեկ այլ թվանշանի: Լայնությամբ առաջին որոնում \n    (BFS) օգտագործվում է բոլոր հնարավոր փոխակերպումները ուսումնասիրելու համար: Ֆունկցիան վերադարձնում է \n    եզակի թվերի քանակը, որոնք կարող են ստեղծվել սկզբնական թվից, ներառյալ ինքը՝ թիվը:\n\n    Args:\n    - n (int): Փոխակերպման ենթակա սկզբնական ամբողջ թիվը:\n    - rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն ներկայացված է\n                              որպես կույտ (x, y), որը ցույց է տալիս, որ թվանշան x-ը կարող է փոխակերպվել y-ի:\n\n    Returns:\n    - int: Եզակի թվերի ընդհանուր քանակը, որոնք կարող են ստեղծվել:\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "bn": "একটি পাইথন ফাংশন 'def generate_numbers(n, rules) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    রূপান্তর নিয়ম প্রয়োগ করে প্রদত্ত সংখ্যাটি থেকে সমস্ত অনন্য সংখ্যা তৈরি করুন।\n\n    প্রতিটি নিয়ম একটি একক অঙ্ককে অন্যটিতে রূপান্তর করার অনুমতি দেয়। সমস্ত সম্ভাব্য রূপান্তর অন্বেষণ করতে \n    একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) ব্যবহার করা হয়। ফাংশনটি মূল সংখ্যাটি সহ মূল সংখ্যা থেকে \n    তৈরি করা যেতে পারে এমন অনন্য সংখ্যার গণনা প্রদান করে।\n\n    আর্গুমেন্ট:\n    - n (int): রূপান্তর করার জন্য মূল পূর্ণসংখ্যা।\n    - rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল (x, y) \n                              হিসাবে উপস্থাপিত হয় যা নির্দেশ করে যে অঙ্ক x কে y তে রূপান্তর করা যেতে পারে।\n\n    রিটার্নস:\n    - int: অনন্য সংখ্যার মোট গণনা যা তৈরি করা যেতে পারে।\n\n    উদাহরণ:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "bg": "Напишете Python функция 'def generate_numbers(n, rules) -> int:', за да решите следния проблем:\n\n    Генерирайте всички уникални числа от даденото число, като приложите правила за трансформация.\n\n    Всяко правило позволява една цифра да бъде трансформирана в друга. Използва се търсене в ширина\n    (BFS), за да се изследват всички възможни трансформации. Функцията връща броя\n    на уникалните числа, които могат да бъдат генерирани от оригиналното число, включително самото число.\n\n    Аргументи:\n    - n (int): Оригиналното цяло число за трансформиране.\n    - rules (list of tuples): Списък с правила за трансформация, където всяко правило е представено\n                              като кортеж (x, y), указващ, че цифрата x може да бъде трансформирана в y.\n\n    Връща:\n    - int: Общият брой на уникалните числа, които могат да бъдат генерирани.\n\n    Примери:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "zh": "编写一个 Python 函数 'def generate_numbers(n, rules) -> int:' 以解决以下问题：\n\n    通过应用转换规则，从给定数字生成所有唯一的数字。\n\n    每个规则允许将一个数字转换为另一个数字。使用广度优先搜索 (BFS) 来探索所有可能的转换。\n    函数返回可以从原始数字生成的唯一数字的数量，包括数字本身。\n\n    参数：\n    - n (int): 要转换的原始整数。\n    - rules (list of tuples): 转换规则的列表，其中每个规则表示为一个元组 (x, y)，\n                              表示数字 x 可以转换为 y。\n\n    返回：\n    - int: 可以生成的唯一数字的总数。\n\n    示例：\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "fr": "Écrire une fonction python 'def generate_numbers(n, rules) -> int:' pour résoudre le problème suivant :\n\n    Générer tous les nombres uniques à partir du nombre donné en appliquant des règles de transformation.\n\n    Chaque règle permet de transformer un chiffre unique en un autre. Une recherche en largeur\n    (BFS) est utilisée pour explorer toutes les transformations possibles. La fonction retourne le nombre\n    de nombres uniques qui peuvent être générés à partir du nombre original, y compris le nombre lui-même.\n\n    Args:\n    - n (int): Le nombre entier original à transformer.\n    - rules (liste de tuples): Une liste de règles de transformation, où chaque règle est représentée\n                               comme un tuple (x, y) indiquant que le chiffre x peut être transformé en y.\n\n    Retourne:\n    - int: Le nombre total de nombres uniques qui peuvent être générés.\n\n    Cas:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "de": "Schreiben Sie eine Python-Funktion 'def generate_numbers(n, rules) -> int:', um das folgende Problem zu lösen:\n\n    Erzeugen Sie alle eindeutigen Zahlen aus der gegebenen Zahl, indem Sie Transformationsregeln anwenden.\n\n    Jede Regel erlaubt es, eine einzelne Ziffer in eine andere zu transformieren. Eine Breitensuche\n    (BFS) wird verwendet, um alle möglichen Transformationen zu erkunden. Die Funktion gibt die Anzahl\n    der eindeutigen Zahlen zurück, die aus der ursprünglichen Zahl generiert werden können, einschließlich der Zahl selbst.\n\n    Argumente:\n    - n (int): Die ursprüngliche ganze Zahl, die transformiert werden soll.\n    - rules (Liste von Tupeln): Eine Liste von Transformationsregeln, wobei jede Regel als\n                                Tupel (x, y) dargestellt wird, das angibt, dass die Ziffer x in y transformiert werden kann.\n\n    Rückgabewert:\n    - int: Die Gesamtanzahl der eindeutigen Zahlen, die generiert werden können.\n\n    Fälle:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "ha": "Rubuta aikin python 'def generate_numbers(n, rules) -> int:' don warware matsalar mai zuwa:\n\n    Samar da duk lambobin musamman daga lambar da aka bayar ta hanyar amfani da dokokin sauyi.\n\n    Kowace doka tana ba da damar canza lamba ɗaya zuwa wata. Ana amfani da binciken farko na faɗi\n    (BFS) don bincika dukkan sauye-sauye masu yiwuwa. Aikin yana mayar da yawan\n    lambobin musamman da za a iya samarwa daga lambar asali, ciki har da lambar kanta.\n\n    Args:\n    - n (int): Lambar cikakken lamba ta asali don canzawa.\n    - rules (jerin tuples): Jerin dokokin sauyi, inda kowace doka take wakilta\n                              a matsayin tuple (x, y) wanda ke nuna cewa za a iya canza lamba x zuwa y.\n\n    Returns:\n    - int: Jimlar adadin lambobin musamman da za a iya samarwa.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "hi": "एक पायथन फ़ंक्शन 'def generate_numbers(n, rules) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    परिवर्तन नियमों को लागू करके दिए गए संख्या से सभी अद्वितीय संख्याएँ उत्पन्न करें।\n\n    प्रत्येक नियम एकल अंक को दूसरे में बदलने की अनुमति देता है। सभी संभावित परिवर्तनों का पता लगाने के लिए \n    एक ब्रेड्थ-फर्स्ट सर्च (BFS) का उपयोग किया जाता है। फ़ंक्शन उस अद्वितीय संख्याओं की गिनती लौटाता है \n    जो मूल संख्या से उत्पन्न की जा सकती हैं, जिसमें संख्या स्वयं भी शामिल है।\n\n    तर्क:\n    - n (int): वह मूल पूर्णांक संख्या जिसे बदलना है।\n    - rules (list of tuples): परिवर्तन नियमों की एक सूची, जहाँ प्रत्येक नियम को एक युग्म (x, y) के रूप में \n                              दर्शाया गया है, जो इंगित करता है कि अंक x को y में बदला जा सकता है।\n\n    लौटाता है:\n    - int: उत्पन्न की जा सकने वाली अद्वितीय संख्याओं की कुल गिनती।\n\n    मामले:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "hu": "Írj egy python függvényt 'def generate_numbers(n, rules) -> int:' a következő probléma megoldására:\n\n    Generálj minden egyedi számot a megadott számból átalakítási szabályok alkalmazásával.\n\n    Minden szabály lehetővé teszi, hogy egyetlen számjegy átalakuljon egy másikba. Egy szélességi keresést\n    (BFS) használnak az összes lehetséges átalakítás felfedezésére. A függvény visszaadja az eredeti számból\n    generálható egyedi számok számát, beleértve magát a számot is.\n\n    Argumentumok:\n    - n (int): Az eredeti egész szám, amit átalakítunk.\n    - rules (list of tuples): Az átalakítási szabályok listája, ahol minden szabály egy (x, y) \n                              tuple-ként van megadva, jelezve, hogy az x számjegy átalakulhat y-ra.\n\n    Visszatér:\n    - int: Az összes generálható egyedi szám száma.\n\n    Esetek:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "es": "Escribe una función de Python 'def generate_numbers(n, rules) -> int:' para resolver el siguiente problema:\n\n    Generar todos los números únicos a partir del número dado aplicando reglas de transformación.\n\n    Cada regla permite que un solo dígito se transforme en otro. Se utiliza una búsqueda en anchura\n    (BFS) para explorar todas las posibles transformaciones. La función devuelve la cantidad\n    de números únicos que se pueden generar a partir del número original, incluyendo el número en sí mismo.\n\n    Argumentos:\n    - n (int): El número entero original a transformar.\n    - rules (lista de tuplas): Una lista de reglas de transformación, donde cada regla se representa\n                               como una tupla (x, y) que indica que el dígito x puede transformarse en y.\n\n    Devuelve:\n    - int: El conteo total de números únicos que se pueden generar.\n\n    Casos:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "arb": "اكتب دالة بايثون 'def generate_numbers(n, rules) -> int:' لحل المشكلة التالية:\n\n    توليد جميع الأرقام الفريدة من الرقم المعطى عن طريق تطبيق قواعد التحويل.\n\n    كل قاعدة تسمح بتحويل رقم واحد إلى آخر. يتم استخدام البحث بالعرض\n    (BFS) لاستكشاف جميع التحويلات الممكنة. تعيد الدالة عدد\n    الأرقام الفريدة التي يمكن توليدها من الرقم الأصلي، بما في ذلك الرقم نفسه.\n\n    يعيدالحجج:\n    - n (int): الرقم الصحيح الأصلي للتحويل.\n    - rules (list of tuples): قائمة بقواعد التحويل، حيث تمثل كل قاعدة\n                              كزوج (x, y) يشير إلى أن الرقم x يمكن تحويله إلى y.\n\n    يعيد:\n    - int: العدد الإجمالي للأرقام الفريدة التي يمكن توليدها.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "sw": "Andika kazi ya python 'def generate_numbers(n, rules) -> int:' kutatua tatizo lifuatalo:\n\n    Tengeneza namba zote za kipekee kutoka kwa namba iliyotolewa kwa kutumia sheria za mabadiliko.\n\n    Kila sheria inaruhusu tarakimu moja kubadilishwa kuwa nyingine. Utafutaji wa kina kwanza\n    (BFS) unatumika kuchunguza mabadiliko yote yanayowezekana. Kazi inarudisha idadi\n    ya namba za kipekee ambazo zinaweza kutengenezwa kutoka kwa namba ya awali, ikijumuisha namba yenyewe.\n\n    Hoja:\n    - n (int): Namba ya awali ya integer ya kubadilisha.\n    - rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria inawakilishwa\n                              kama jozi (x, y) ikionyesha kwamba tarakimu x inaweza kubadilishwa kuwa y.\n\n    Inarudisha:\n    - int: Jumla ya idadi ya namba za kipekee ambazo zinaweza kutengenezwa.\n\n    Mifano:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "tr": "Bir python fonksiyonu 'def generate_numbers(n, rules) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen sayıyı dönüştürme kurallarını uygulayarak tüm benzersiz sayıları oluşturun.\n\n    Her kural, tek bir rakamın başka bir rakama dönüştürülmesine izin verir. Tüm olası dönüşümleri\n    keşfetmek için genişlik öncelikli arama (BFS) kullanılır. Fonksiyon, orijinal sayı da dahil olmak üzere\n    oluşturulabilecek benzersiz sayıların sayısını döndürür.\n\n    Argümanlar:\n    - n (int): Dönüştürülecek orijinal tamsayı.\n    - rules (list of tuples): Her kuralın, x rakamının y'ye dönüştürülebileceğini belirten\n                              bir (x, y) demeti olarak temsil edildiği dönüşüm kuralları listesi.\n\n    Döndürür:\n    - int: Oluşturulabilecek benzersiz sayıların toplam sayısı.\n\n    Durumlar:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "vi": "Viết một hàm python 'def generate_numbers(n, rules) -> int:' để giải quyết vấn đề sau:\n\n    Tạo tất cả các số duy nhất từ số đã cho bằng cách áp dụng các quy tắc biến đổi.\n\n    Mỗi quy tắc cho phép một chữ số được biến đổi thành chữ số khác. Tìm kiếm theo chiều rộng\n    (BFS) được sử dụng để khám phá tất cả các biến đổi có thể. Hàm trả về số lượng\n    các số duy nhất có thể được tạo ra từ số gốc, bao gồm cả số đó.\n\n    Tham số:\n    - n (int): Số nguyên gốc cần biến đổi.\n    - rules (list of tuples): Danh sách các quy tắc biến đổi, trong đó mỗi quy tắc được biểu diễn\n                              dưới dạng một bộ (x, y) cho biết chữ số x có thể được biến đổi thành y.\n\n    Trả về:\n    - int: Tổng số các số duy nhất có thể được tạo ra.\n\n    Trường hợp:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "id": "Tulis fungsi python 'def generate_numbers(n, rules) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hasilkan semua angka unik dari angka yang diberikan dengan menerapkan aturan transformasi.\n\n    Setiap aturan memungkinkan satu digit diubah menjadi digit lain. Pencarian pertama-lebar\n    (BFS) digunakan untuk menjelajahi semua kemungkinan transformasi. Fungsi mengembalikan jumlah\n    angka unik yang dapat dihasilkan dari angka asli, termasuk angka itu sendiri.\n\n    Argumen:\n    - n (int): Angka integer asli untuk ditransformasikan.\n    - rules (list of tuples): Daftar aturan transformasi, di mana setiap aturan direpresentasikan\n                              sebagai tuple (x, y) yang menunjukkan bahwa digit x dapat diubah menjadi y.\n\n    Mengembalikan:\n    - int: Jumlah total angka unik yang dapat dihasilkan.\n\n    Kasus:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "ja": "Python関数 'def generate_numbers(n, rules) -> int:' を作成して、次の問題を解決してください:\n\n    与えられた数から変換ルールを適用して、すべてのユニークな数を生成します。\n\n    各ルールは、1つの数字を別の数字に変換することを許可します。幅優先探索\n    (BFS) を使用して、すべての可能な変換を探索します。この関数は、元の数を含めて、\n    元の数から生成できるユニークな数の数を返します。\n\n    引数:\n    - n (int): 変換する元の整数。\n    - rules (list of tuples): 変換ルールのリストで、各ルールはタプル (x, y) として表され、\n                              数字 x が y に変換できることを示します。\n\n    戻り値:\n    - int: 生成できるユニークな数の総数。\n\n    ケース:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "ko": "파이썬 함수를 작성하세요 'def generate_numbers(n, rules) -> int:' 다음 문제를 해결하기 위해:\n\n    변환 규칙을 적용하여 주어진 숫자로부터 모든 고유한 숫자를 생성합니다.\n\n    각 규칙은 한 자리 숫자를 다른 숫자로 변환할 수 있게 합니다. 너비 우선 탐색(BFS)을 사용하여\n    가능한 모든 변환을 탐색합니다. 함수는 원래 숫자를 포함하여 원래 숫자로부터 생성할 수 있는\n    고유한 숫자의 개수를 반환합니다.\n\n    매개변수:\n    - n (int): 변환할 원래 정수 숫자.\n    - rules (list of tuples): 변환 규칙의 리스트로, 각 규칙은 (x, y) 튜플로 표현되어\n                              숫자 x가 y로 변환될 수 있음을 나타냅니다.\n\n    반환값:\n    - int: 생성할 수 있는 고유한 숫자의 총 개수.\n\n    사례:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "ml": "ഒരു പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക 'def generate_numbers(n, rules) -> int:' താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    നൽകിയിരിക്കുന്ന സംഖ്യയിൽ നിന്ന് മാറ്റം വരുത്താനുള്ള നിയമങ്ങൾ പ്രയോഗിച്ച് എല്ലാ അനന്യ സംഖ്യകളും സൃഷ്ടിക്കുക.\n\n    ഓരോ നിയമവും ഒരു അക്കത്തെ മറ്റൊന്നായി മാറ്റാൻ അനുവദിക്കുന്നു. എല്ലാ സാധ്യതാപരമായ മാറ്റങ്ങളും\n    പരിശോധിക്കാൻ വീതി-ആദ്യ തിരച്ചിൽ (BFS) ഉപയോഗിക്കുന്നു. മൂല സംഖ്യ ഉൾപ്പെടെ, \n    മൂല സംഖ്യയിൽ നിന്ന് സൃഷ്ടിക്കാവുന്ന അനന്യ സംഖ്യകളുടെ എണ്ണം ഫംഗ്ഷൻ തിരികെ നൽകുന്നു.\n\n    Args:\n    - n (int): മാറ്റം വരുത്താനുള്ള മൂല പൂർണ്ണ സംഖ്യ.\n    - rules (list of tuples): മാറ്റം വരുത്താനുള്ള നിയമങ്ങളുടെ പട്ടിക, ഓരോ നിയമവും \n                              (x, y) എന്ന രൂപത്തിൽ പ്രതിനിധീകരിക്കുന്നു, \n                              ഇത് x എന്ന അക്കത്തെ y ആയി മാറ്റാൻ കഴിയുമെന്ന് സൂചിപ്പിക്കുന്നു.\n\n    Returns:\n    - int: സൃഷ്ടിക്കാവുന്ന അനന്യ സംഖ്യകളുടെ ആകെ എണ്ണം.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "fa": "یک تابع پایتون 'def generate_numbers(n, rules) -> int:' بنویسید تا مسئله زیر را حل کند:\n\n    همه اعداد یکتا را از عدد داده شده با اعمال قوانین تبدیل تولید کنید.\n\n    هر قانون اجازه می‌دهد یک رقم به رقم دیگری تبدیل شود. از جستجوی اول عرض (BFS) برای بررسی\n    همه تبدیل‌های ممکن استفاده می‌شود. تابع تعداد اعداد یکتایی که می‌توان از عدد اصلی تولید کرد،\n    شامل خود عدد را برمی‌گرداند.\n\n    آرگومان‌ها:\n    - n (int): عدد صحیح اصلی برای تبدیل.\n    - rules (list of tuples): لیستی از قوانین تبدیل، که هر قانون به صورت یک تاپل (x, y) نشان داده می‌شود\n                              که نشان می‌دهد رقم x می‌تواند به y تبدیل شود.\n\n    بازگشت:\n    - int: تعداد کل اعداد یکتایی که می‌توان تولید کرد.\n\n    موارد:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2"}, "level": "hard", "test": "def test_generate_numbers():\n    # Test case 1\n    n1, k1 = 234, 2\n    rules1 = [(2, 5), (3, 6)]\n    assert generate_numbers(n1, rules1) == 4, \"Test case 1 failed\"\n\n    # Test case 2\n    n2, k2 = 123, 3\n    rules2 = [(1, 9), (2, 8), (3, 7)]\n    assert generate_numbers(n2, rules2) == 8, \"Test case 2 failed\"\n\n    # Test case 3\n    n3, k3 = 999, 1\n    rules3 = [(9, 1)]\n    assert generate_numbers(n3, rules3) == 8, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function\ntest_generate_numbers()", "entry_point": "generate_numbers", "signature": "def generate_numbers(n, rules) -> int:", "docstring": {"en": "\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    ", "sq": "\n    Gjeneroni të gjitha numrat unikë nga numri i dhënë duke zbatuar rregullat e transformimit.\n\n    Çdo rregull lejon që një shifër e vetme të transformohet në një tjetër. Një kërkim në gjerësi\n    (BFS) përdoret për të eksploruar të gjitha transformimet e mundshme. Funksioni kthen numrin\n    e numrave unikë që mund të gjenerohen nga numri origjinal, duke përfshirë vetë numrin.\n\n    Argumentet:\n    - n (int): Numri origjinal i plotë për të transformuar.\n    - rules (listë e treshave): Një listë e rregullave të transformimit, ku çdo rregull përfaqësohet\n                                si një treshe (x, y) që tregon se shifra x mund të transformohet në y.\n\n    Kthen:\n    - int: Numri total i numrave unikë që mund të gjenerohen.\n\n    Rastet:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "hy": "\n    Գեներացրեք բոլոր եզակի թվերը տրված թվից՝ կիրառելով փոխակերպման կանոնները։\n\n    Յուրաքանչյուր կանոն թույլ է տալիս մեկ թվանշանը փոխակերպել մեկ այլ թվանշանի։ Լայնության առաջին որոնումը (BFS) օգտագործվում է բոլոր հնարավոր փոխակերպումները ուսումնասիրելու համար։ Ֆունկցիան վերադարձնում է եզակի թվերի քանակը, որոնք կարող են գեներացվել սկզբնական թվից, ներառյալ ինքը՝ թիվը։\n\n    Արգումենտներ:\n    - n (int): Սկզբնական ամբողջ թիվը՝ փոխակերպելու համար։\n    - rules (ցանկ՝ զույգերի): Փոխակերպման կանոնների ցանկ, որտեղ յուրաքանչյուր կանոն ներկայացված է որպես զույգ (x, y), որը ցույց է տալիս, որ թվանշան x-ը կարող է փոխակերպվել y-ի։\n\n    Վերադարձնում է:\n    - int: Եզակի թվերի ընդհանուր քանակը, որոնք կարող են գեներացվել։\n\n    Դեպքեր:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "bn": "\n    প্রদত্ত সংখ্যাটি থেকে রূপান্তর নিয়ম প্রয়োগ করে সমস্ত অনন্য সংখ্যা তৈরি করুন।\n\n    প্রতিটি নিয়ম একটি একক অঙ্ককে অন্যটিতে রূপান্তর করার অনুমতি দেয়। সমস্ত সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) ব্যবহার করা হয়। ফাংশনটি মূল সংখ্যাটি সহ মূল সংখ্যাটি থেকে তৈরি করা যেতে পারে এমন অনন্য সংখ্যার সংখ্যা প্রদান করে।\n\n    আর্গস:\n    - n (int): রূপান্তর করার মূল পূর্ণসংখ্যা।\n    - rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল (x, y) হিসাবে উপস্থাপিত হয় যা নির্দেশ করে যে অঙ্ক x কে y তে রূপান্তর করা যেতে পারে।\n\n    রিটার্নস:\n    - int: মোট অনন্য সংখ্যার সংখ্যা যা তৈরি করা যেতে পারে।\n\n    কেস:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "bg": "\n    Генерирайте всички уникални числа от даденото число, като приложите правила за трансформация.\n\n    Всяко правило позволява една цифра да бъде трансформирана в друга. Използва се търсене в ширина\n    (BFS), за да се изследват всички възможни трансформации. Функцията връща броя на уникалните числа,\n    които могат да бъдат генерирани от оригиналното число, включително самото число.\n\n    Аргументи:\n    - n (int): Оригиналното цяло число за трансформация.\n    - rules (list of tuples): Списък с правила за трансформация, където всяко правило е представено\n                              като кортеж (x, y), указващ, че цифрата x може да бъде трансформирана в y.\n\n    Връща:\n    - int: Общият брой на уникалните числа, които могат да бъдат генерирани.\n\n    Примери:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "zh": "\n    通过应用转换规则生成给定数字的所有唯一数字。\n\n    每个规则允许将一个数字转换为另一个数字。使用广度优先搜索 (BFS) 来探索所有可能的转换。\n    该函数返回可以从原始数字生成的唯一数字的数量，包括数字本身。\n\n    参数:\n    - n (int): 要转换的原始整数。\n    - rules (list of tuples): 转换规则列表，其中每个规则表示为一个元组 (x, y)，表示数字 x 可以转换为 y。\n\n    返回:\n    - int: 可以生成的唯一数字的总数。\n\n    示例:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "fr": "\n    Générer tous les nombres uniques à partir du nombre donné en appliquant des règles de transformation.\n\n    Chaque règle permet de transformer un seul chiffre en un autre. Une recherche en largeur (BFS) \n    est utilisée pour explorer toutes les transformations possibles. La fonction retourne le nombre \n    de nombres uniques qui peuvent être générés à partir du nombre original, y compris le nombre lui-même.\n\n    Args:\n    - n (int): Le nombre entier original à transformer.\n    - rules (list of tuples): Une liste de règles de transformation, où chaque règle est représentée \n                              comme un tuple (x, y) indiquant que le chiffre x peut être transformé en y.\n\n    Returns:\n    - int: Le nombre total de nombres uniques qui peuvent être générés.\n\n    Cas:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "de": "\n    Erzeuge alle eindeutigen Zahlen aus der gegebenen Zahl durch Anwendung von Transformationsregeln.\n\n    Jede Regel erlaubt es, eine einzelne Ziffer in eine andere zu transformieren. Eine Breitensuche\n    (BFS) wird verwendet, um alle möglichen Transformationen zu erkunden. Die Funktion gibt die Anzahl\n    der eindeutigen Zahlen zurück, die aus der ursprünglichen Zahl generiert werden können, einschließlich der Zahl selbst.\n\n    Argumente:\n    - n (int): Die ursprüngliche ganze Zahl, die transformiert werden soll.\n    - rules (list of tuples): Eine Liste von Transformationsregeln, wobei jede Regel als Tupel (x, y) dargestellt wird,\n                              das angibt, dass die Ziffer x in y transformiert werden kann.\n\n    Rückgabewert:\n    - int: Die Gesamtanzahl der eindeutigen Zahlen, die generiert werden können.\n\n    Fälle:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "ha": "\n    Samar da duk lambobin musamman daga lambar da aka bayar ta hanyar amfani da dokokin sauyawa.\n\n    Kowace doka tana ba da damar canza lamba guda ɗaya zuwa wani. Ana amfani da bincike na farko\n    (BFS) don bincika dukkan yiwuwar sauye-sauye. Aikin yana dawo da adadin lambobin musamman\n    da za a iya samarwa daga lambar asali, gami da lambar kanta.\n\n    Args:\n    - n (int): Lambar asali ta integer don sauyawa.\n    - rules (list of tuples): Jerin dokokin sauyawa, inda kowace doka ke wakiltar\n                              a matsayin tuple (x, y) yana nuna cewa ana iya sauya lamba x zuwa y.\n\n    Returns:\n    - int: Jimillar adadin lambobin musamman da za a iya samarwa.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "hi": "\n    दिए गए संख्या से सभी अद्वितीय संख्याएँ उत्पन्न करें, परिवर्तन नियम लागू करके।\n\n    प्रत्येक नियम एकल अंक को दूसरे में बदलने की अनुमति देता है। सभी संभावित परिवर्तनों का पता लगाने के लिए \n    ब्रेड्थ-फर्स्ट सर्च (BFS) का उपयोग किया जाता है। फ़ंक्शन उस मूल संख्या सहित उत्पन्न की जा सकने वाली \n    अद्वितीय संख्याओं की गिनती लौटाता है।\n\n    तर्क:\n    - n (int): परिवर्तित करने के लिए मूल पूर्णांक संख्या।\n    - rules (list of tuples): परिवर्तन नियमों की सूची, जहाँ प्रत्येक नियम को एक टपल (x, y) के रूप में \n                              दर्शाया गया है, जो इंगित करता है कि अंक x को y में बदला जा सकता है।\n\n    रिटर्न:\n    - int: उत्पन्न की जा सकने वाली अद्वितीय संख्याओं की कुल गिनती।\n\n    उदाहरण:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "hu": "\n    Generálja az összes egyedi számot a megadott számból átalakítási szabályok alkalmazásával.\n\n    Minden szabály lehetővé teszi, hogy egyetlen számjegy átalakuljon egy másikra. Szélességi keresést\n    (BFS) használunk az összes lehetséges átalakítás felfedezésére. A függvény visszaadja az eredeti számból\n    generálható egyedi számok számát, beleértve magát a számot is.\n\n    Paraméterek:\n    - n (int): Az eredeti egész szám, amelyet át kell alakítani.\n    - rules (list of tuples): Az átalakítási szabályok listája, ahol minden szabály egy\n                              (x, y) alakú tuple, amely jelzi, hogy az x számjegy átalakulhat y-ra.\n\n    Visszatér:\n    - int: Az összes generálható egyedi szám száma.\n\n    Esetek:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "es": "Generar todos los números únicos a partir del número dado aplicando reglas de transformación.\n\nCada regla permite transformar un solo dígito en otro. Se utiliza una búsqueda en anchura\n(BFS) para explorar todas las posibles transformaciones. La función devuelve el conteo\nde números únicos que se pueden generar a partir del número original, incluyendo el número en sí mismo.\n\nArgumentos:\n- n (int): El número entero original a transformar.\n- rules (list of tuples): Una lista de reglas de transformación, donde cada regla se representa\n                          como una tupla (x, y) indicando que el dígito x puede transformarse en y.\n\nDevuelve:\n- int: El conteo total de números únicos que se pueden generar.\n\nCases:\n>>> generate_numbers(234, [(2, 5), (3, 6)])\n4\n>>> generate_numbers(100, [(1, 9)])\n2", "arb": "    توليد جميع الأرقام الفريدة من الرقم المعطى عن طريق تطبيق قواعد التحويل.\n\n    تسمح كل قاعدة بتحويل رقم واحد إلى آخر. يتم استخدام البحث بعرض أول (BFS)\n    لاستكشاف جميع التحويلات الممكنة. تُرجع الدالة عدد الأرقام الفريدة التي يمكن توليدها من الرقم الأصلي، بما في ذلك الرقم نفسه.\n\n    يعيدالحجج:\n    - n (int): الرقم الصحيح الأصلي للتحويل.\n    - rules (list of tuples): قائمة بقواعد التحويل، حيث يتم تمثيل كل قاعدة\n                              كزوج (x, y) يشير إلى أن الرقم x يمكن تحويله إلى y.\n\n    يعيد:\n    - int: العدد الإجمالي للأرقام الفريدة التي يمكن توليدها.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "sw": "    Tengeneza namba zote za kipekee kutoka kwa namba iliyotolewa kwa kutumia sheria za mabadiliko.\n\n    Kila sheria inaruhusu tarakimu moja kubadilishwa kuwa nyingine. Utafutaji wa kina kwanza\n    (BFS) unatumika kuchunguza mabadiliko yote yanayowezekana. Kazi inarejesha idadi\n    ya namba za kipekee ambazo zinaweza kutengenezwa kutoka kwa namba ya awali, ikijumuisha namba yenyewe.\n\n    Vipengele:\n    - n (int): Namba ya awali ya integer kubadilishwa.\n    - rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria inawakilishwa\n                              kama jozi (x, y) ikionyesha kwamba tarakimu x inaweza kubadilishwa kuwa y.\n\n    Inarejesha:\n    - int: Jumla ya idadi ya namba za kipekee ambazo zinaweza kutengenezwa.\n\n    Matukio:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    ", "tr": "    Verilen sayıdan dönüşüm kuralları uygulanarak tüm benzersiz sayıları üretin.\n\n    Her kural, tek bir rakamın başka bir rakama dönüştürülmesine izin verir. Tüm olası dönüşümleri\n    keşfetmek için genişlik öncelikli arama (BFS) kullanılır. Fonksiyon, orijinal sayı da dahil olmak üzere\n    orijinal sayıdan üretilebilecek benzersiz sayıların sayısını döndürür.\n\n    Argümanlar:\n    - n (int): Dönüştürülecek orijinal tamsayı.\n    - rules (list of tuples): Her kuralın (x, y) şeklinde bir demet olarak temsil edildiği,\n                              rakam x'in y'ye dönüştürülebileceğini belirten dönüşüm kuralları listesi.\n\n    Döndürür:\n    - int: Üretilebilecek benzersiz sayıların toplam sayısı.\n\n    Örnekler:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "vi": "    Tạo tất cả các số duy nhất từ số đã cho bằng cách áp dụng các quy tắc biến đổi.\n\n    Mỗi quy tắc cho phép một chữ số được biến đổi thành chữ số khác. Tìm kiếm theo chiều rộng\n    (BFS) được sử dụng để khám phá tất cả các biến đổi có thể. Hàm trả về số lượng\n    các số duy nhất có thể được tạo ra từ số gốc, bao gồm cả số đó.\n\n    Tham số:\n    - n (int): Số nguyên gốc để biến đổi.\n    - rules (list of tuples): Danh sách các quy tắc biến đổi, trong đó mỗi quy tắc được biểu diễn\n                              dưới dạng một bộ (x, y) chỉ ra rằng chữ số x có thể được biến đổi thành y.\n\n    Trả về:\n    - int: Tổng số lượng các số duy nhất có thể được tạo ra.\n\n    Trường hợp:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "id": "Menghasilkan semua angka unik dari angka yang diberikan dengan menerapkan aturan transformasi.\n\nSetiap aturan memungkinkan satu digit untuk diubah menjadi digit lain. Pencarian pertama-besar (BFS) digunakan untuk menjelajahi semua kemungkinan transformasi. Fungsi ini mengembalikan jumlah angka unik yang dapat dihasilkan dari angka asli, termasuk angka itu sendiri.\n\nArgs:\n- n (int): Angka integer asli untuk ditransformasi.\n- rules (list of tuples): Daftar aturan transformasi, di mana setiap aturan diwakili\n                          sebagai tuple (x, y) yang menunjukkan bahwa digit x dapat diubah menjadi y.\n\nReturns:\n- int: Jumlah total angka unik yang dapat dihasilkan.\n\nCases:\n>>> generate_numbers(234, [(2, 5), (3, 6)])\n4\n>>> generate_numbers(100, [(1, 9)])\n2", "ja": "    与えられた数から変換ルールを適用して、すべてのユニークな数を生成します。\n\n    各ルールは、1つの数字を別の数字に変換することを許可します。幅優先探索（BFS）を使用して、すべての可能な変換を探索します。この関数は、元の数自体を含め、元の数から生成できるユニークな数の数を返します。\n\n    引数:\n    - n (int): 変換する元の整数。\n    - rules (list of tuples): 変換ルールのリスト。各ルールはタプル (x, y) として表され、数字 x を y に変換できることを示します。\n\n    戻り値:\n    - int: 生成可能なユニークな数の総数。\n\n    例:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "ko": "    주어진 숫자로부터 변환 규칙을 적용하여 모든 고유 숫자를 생성합니다.\n\n    각 규칙은 하나의 숫자를 다른 숫자로 변환할 수 있도록 허용합니다. 너비 우선 탐색(BFS)을 사용하여\n    모든 가능한 변환을 탐색합니다. 이 함수는 원래 숫자를 포함하여 원래 숫자로부터 생성할 수 있는\n    고유 숫자의 개수를 반환합니다.\n\n    Args:\n    - n (int): 변환할 원래 정수 숫자.\n    - rules (list of tuples): 변환 규칙의 목록으로, 각 규칙은 튜플 (x, y)로 표시되며,\n                              숫자 x가 y로 변환될 수 있음을 나타냅니다.\n\n    Returns:\n    - int: 생성할 수 있는 고유 숫자의 총 개수.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "ml": "    നൽകിയ നമ്പറിൽ നിന്ന് മാറ്റം വരുത്തുന്ന നിയമങ്ങൾ പ്രയോഗിച്ച് എല്ലാ അതുല്യമായ നമ്പറുകളും സൃഷ്ടിക്കുക.\n\n    ഓരോ നിയമവും ഒരു അക്കത്തെ മറ്റൊന്നായി മാറ്റാൻ അനുവദിക്കുന്നു. എല്ലാ സാധ്യതയുള്ള മാറ്റങ്ങളും അന്വേഷിക്കാൻ ബ്രെഡ്ത്-ഫസ്റ്റ് തിരയൽ (BFS) ഉപയോഗിക്കുന്നു. മൂല നമ്പർ ഉൾപ്പെടെ, ആദിയനമ്പറിൽ നിന്ന് സൃഷ്ടിക്കാവുന്ന അതുല്യ നമ്പറുകളുടെ എണ്ണം ഫംഗ്ഷൻ തിരികെ നൽകുന്നു.\n\n    Arguments:\n    - n (int): മാറ്റം വരുത്തേണ്ട യഥാർത്ഥ പൂർണ്ണസംഖ്യ.\n    - rules (list of tuples): ഓരോ നിയമവും (x, y) എന്ന രൂപത്തിൽ പ്രതിനിധീകരിക്കുന്ന\n                              മാറ്റം വരുത്തുന്ന നിയമങ്ങളുടെ പട്ടിക, ഇവിടെ x എന്ന അക്കം y ആയി മാറ്റാവുന്നതാണ്.\n\n    Returns:\n    - int: സൃഷ്ടിക്കാവുന്ന അതുല്യ നമ്പറുകളുടെ മൊത്തം എണ്ണം.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2", "fa": "تولید تمام اعداد یکتا از عدد داده شده با اعمال قوانین تبدیل.\n\nهر قانون اجازه می‌دهد یک رقم به رقم دیگری تبدیل شود. از جستجوی اول سطح (BFS) برای بررسی تمام تبدیل‌های ممکن استفاده می‌شود. تابع تعداد اعداد یکتایی که می‌توان از عدد اصلی تولید کرد، شامل خود عدد، را برمی‌گرداند.\n\nآرگومان‌ها:\n- n (int): عدد صحیح اصلی که باید تبدیل شود.\n- rules (list of tuples): لیستی از قوانین تبدیل، که هر قانون به صورت یک زوج مرتب (x, y) نمایش داده می‌شود که نشان می‌دهد رقم x می‌تواند به y تبدیل شود.\n\nبازگشت:\n- int: تعداد کل اعداد یکتایی که می‌توان تولید کرد.\n\nموارد:\n>>> generate_numbers(234, [(2, 5), (3, 6)])\n4\n>>> generate_numbers(100, [(1, 9)])\n2"}}
{"task_id": "Python/32", "prompt": {"en": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "sq": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Vlerëson konsistencën e një skenari ku një pjesëmarrës është krimineli bazuar në deklaratat e dhëna.\n\n    Kjo funksion merr emrin e një krimineli të mundshëm (skenari) dhe një grup gënjeshtarësh (liar_count) dhe kontrollon\n    nëse deklaratat e bëra nga të gjithë pjesëmarrësit janë konsistente me këtë skenar, duke injoruar çdo deklaratë\n    rreth ditës së javës.\n\n    Parametrat:\n    - scenario (str): Emri i pjesëmarrësit që testohet si krimineli i mundshëm.\n    - liar_count (set): Një grup emrash të pjesëmarrësve që supozohet të jenë gënjeshtarë.\n    - statements (dict): Një fjalor që lidh emrat e pjesëmarrësve me listat e deklaratave të tyre përkatëse.\n    - days_of_week (set): Një grup vargjesh që përfaqësojnë ditët e javës.\n\n    Kthen:\n    - bool: True nëse skenari është konsistent me deklaratat, False përndryshe.\n\n    Raste Testimi:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "hy": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Գնահատում է սցենարի համահունչությունը, որտեղ մեկ մասնակիցը հանցագործ է՝ հիմնված տրված հայտարարությունների վրա։\n\n    Այս ֆունկցիան վերցնում է հնարավոր հանցագործի անունը (սցենար) և ստախոսների հավաքածու (liar_count) և ստուգում է, \n    արդյոք բոլոր մասնակիցների կողմից արված հայտարարությունները համահունչ են այս սցենարին՝ անտեսելով շաբաթվա օրվա վերաբերյալ \n    ցանկացած հայտարարություն։\n\n    Պարամետրեր:\n    - scenario (str): Մասնակցի անունը, որը փորձարկվում է որպես հնարավոր հանցագործ։\n    - liar_count (set): Մասնակիցների անունների հավաքածու, որոնք ենթադրվում են ստախոսներ։\n    - statements (dict): Բառարան, որը քարտեզում է մասնակիցների անունները նրանց համապատասխան հայտարարությունների ցուցակներին։\n    - days_of_week (set): Տողերի հավաքածու, որը ներկայացնում է շաբաթվա օրերը։\n\n    Վերադարձնում է:\n    - bool: True, եթե սցենարը համահունչ է հայտարարություններին, False՝ հակառակ դեպքում։\n\n    Թեստային դեպքեր:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "bn": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    প্রদত্ত বিবৃতির ভিত্তিতে একজন অংশগ্রহণকারী অপরাধী কিনা তা যাচাই করে একটি দৃশ্যের সামঞ্জস্য মূল্যায়ন করে।\n\n    এই ফাংশনটি একটি সম্ভাব্য অপরাধীর নাম (scenario) এবং মিথ্যাবাদীদের একটি সেট (liar_count) গ্রহণ করে এবং \n    সমস্ত অংশগ্রহণকারীর বিবৃতিগুলি এই দৃশ্যের সাথে সামঞ্জস্যপূর্ণ কিনা তা পরীক্ষা করে, সপ্তাহের দিনের \n    বিবৃতি উপেক্ষা করে।\n\n    প্যারামিটার:\n    - scenario (str): সম্ভাব্য অপরাধী হিসাবে পরীক্ষাধীন অংশগ্রহণকারীর নাম।\n    - liar_count (set): অংশগ্রহণকারীদের নামের একটি সেট যারা মিথ্যাবাদী বলে ধরা হয়।\n    - statements (dict): অংশগ্রহণকারীদের নামের সাথে তাদের সংশ্লিষ্ট বিবৃতির তালিকা ম্যাপ করা একটি অভিধান।\n    - days_of_week (set): সপ্তাহের দিনগুলি উপস্থাপনকারী স্ট্রিংগুলির একটি সেট।\n\n    রিটার্নস:\n    - bool: যদি দৃশ্যটি বিবৃতির সাথে সামঞ্জস্যপূর্ণ হয় তবে True, অন্যথায় False।\n\n    টেস্ট কেস:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "bg": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Оценява последователността на сценарий, в който един участник е престъпник въз основа на дадените изявления.\n\n    Тази функция приема името на потенциалния престъпник (scenario) и множество от лъжци (liar_count) и проверява дали\n    изявленията, направени от всички участници, са последователни с този сценарий, като се пренебрегват всички изявления\n    относно деня от седмицата.\n\n    Параметри:\n    - scenario (str): Името на участника, който се тества като потенциален престъпник.\n    - liar_count (set): Множество от имена на участници, които се приемат за лъжци.\n    - statements (dict): Речник, който свързва имената на участниците със списъци на техните съответни изявления.\n    - days_of_week (set): Множество от низове, представляващи дните от седмицата.\n\n    Връща:\n    - bool: True, ако сценарият е последователен с изявленията, False в противен случай.\n\n    Тестови случаи:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "zh": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    评估一个参与者是罪犯的场景在给定陈述下的一致性。\n\n    此函数接受一个潜在罪犯的名字（scenario）和一组撒谎者（liar_count），并检查所有参与者的陈述是否与此场景一致，\n    忽略关于星期几的任何陈述。\n\n    参数:\n    - scenario (str): 被测试为潜在罪犯的参与者的名字。\n    - liar_count (set): 假定为撒谎者的参与者名字集合。\n    - statements (dict): 一个字典，将参与者名字映射到他们各自陈述的列表。\n    - days_of_week (set): 表示星期几的字符串集合。\n\n    返回:\n    - bool: 如果场景与陈述一致则为 True，否则为 False。\n\n    测试用例:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "fr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Évalue la cohérence d'un scénario où un participant est le criminel en fonction des déclarations données.\n\n    Cette fonction prend le nom d'un criminel potentiel (scenario) et un ensemble de menteurs (liar_count) et vérifie si\n    les déclarations faites par tous les participants sont cohérentes avec ce scénario, en ignorant toute déclaration\n    concernant le jour de la semaine.\n\n    Paramètres:\n    - scenario (str): Le nom du participant testé en tant que criminel potentiel.\n    - liar_count (set): Un ensemble de noms de participants supposés être des menteurs.\n    - statements (dict): Un dictionnaire associant les noms des participants à des listes de leurs déclarations respectives.\n    - days_of_week (set): Un ensemble de chaînes représentant les jours de la semaine.\n\n    Renvoie:\n    - bool: True si le scénario est cohérent avec les déclarations, False sinon.\n\n    Cas de test:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "de": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Bewertet die Konsistenz eines Szenarios, in dem ein Teilnehmer der Täter ist, basierend auf den gegebenen Aussagen.\n\n    Diese Funktion nimmt den Namen eines potenziellen Täters (Szenario) und eine Menge von Lügnern (liar_count) und überprüft,\n    ob die von allen Teilnehmern gemachten Aussagen mit diesem Szenario konsistent sind, wobei Aussagen über den Wochentag ignoriert werden.\n\n    Parameter:\n    - scenario (str): Der Name des Teilnehmers, der als potenzieller Täter getestet wird.\n    - liar_count (set): Eine Menge von Namen der Teilnehmer, die als Lügner angenommen werden.\n    - statements (dict): Ein Wörterbuch, das Teilnehmernamen auf Listen ihrer jeweiligen Aussagen abbildet.\n    - days_of_week (set): Eine Menge von Zeichenfolgen, die die Wochentage repräsentieren.\n\n    Rückgabe:\n    - bool: True, wenn das Szenario mit den Aussagen konsistent ist, andernfalls False.\n\n    Testfälle:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "ha": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Kimanta daidaiton wani yanayi inda ɗaya daga cikin mahalarta shine mai laifi bisa ga bayanan da aka bayar.\n\n    Wannan aikin yana ɗaukar sunan mai laifi mai yuwuwa (scenario) da kuma saitin maƙaryata (liar_count) sannan yana duba idan\n    bayanan da duk mahalarta suka bayar suna daidai da wannan yanayin, ba tare da la'akari da duk wani bayani\n    game da ranar mako ba.\n\n    Sigogi:\n    - scenario (str): Sunan mahalartin da ake gwadawa a matsayin mai laifi mai yuwuwa.\n    - liar_count (set): Saitin sunayen mahalarta da ake ɗauka a matsayin maƙaryata.\n    - statements (dict): Kamus mai alaƙa da sunayen mahalarta zuwa jerin bayanan su na musamman.\n    - days_of_week (set): Saitin kirtani da ke wakiltar ranakun mako.\n\n    Komawa:\n    - bool: Gaskiya idan yanayin yana daidai da bayanan, Karya idan ba haka ba.\n\n    Gwaje-gwaje:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "hi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    दिए गए बयानों के आधार पर किसी परिदृश्य की संगति का मूल्यांकन करता है जहाँ एक प्रतिभागी अपराधी है।\n\n    यह फ़ंक्शन एक संभावित अपराधी का नाम (scenario) और झूठ बोलने वालों का एक सेट (liar_count) लेता है और\n    यह जांचता है कि क्या सभी प्रतिभागियों द्वारा दिए गए बयान इस परिदृश्य के साथ संगत हैं, सप्ताह के दिन के \n    बारे में किसी भी बयान को नजरअंदाज करते हुए।\n\n    पैरामीटर्स:\n    - scenario (str): उस प्रतिभागी का नाम जिसकी संभावित अपराधी के रूप में जांच की जा रही है।\n    - liar_count (set): उन प्रतिभागियों के नामों का सेट जिन्हें झूठा माना जा रहा है।\n    - statements (dict): प्रतिभागियों के नामों को उनके संबंधित बयानों की सूचियों से जोड़ने वाला एक शब्दकोश।\n    - days_of_week (set): सप्ताह के दिनों का प्रतिनिधित्व करने वाले स्ट्रिंग्स का एक सेट।\n\n    रिटर्न्स:\n    - bool: यदि परिदृश्य बयानों के साथ संगत है तो True, अन्यथा False।\n\n    परीक्षण मामले:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "hu": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Kiértékeli egy olyan forgatókönyv következetességét, ahol az egyik résztvevő a bűnös a megadott állítások alapján.\n\n    Ez a függvény egy potenciális bűnös nevét (forgatókönyv) és egy hazugok halmazát (liar_count) veszi figyelembe, és ellenőrzi, hogy\n    az összes résztvevő által tett állítások következetesek-e ezzel a forgatókönyvvel, figyelmen kívül hagyva a hét napjairól szóló állításokat.\n\n    Paraméterek:\n    - scenario (str): A vizsgált potenciális bűnös résztvevő neve.\n    - liar_count (set): A hazugnak feltételezett résztvevők neveinek halmaza.\n    - statements (dict): Egy szótár, amely a résztvevők neveit a megfelelő állításaik listájához rendeli.\n    - days_of_week (set): A hét napjait reprezentáló karakterláncok halmaza.\n\n    Visszatérési érték:\n    - bool: True, ha a forgatókönyv következetes az állításokkal, ellenkező esetben False.\n\n    Tesztesetek:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "es": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evalúa la consistencia de un escenario donde un participante es el criminal basado en las declaraciones dadas.\n\n    Esta función toma el nombre de un posible criminal (scenario) y un conjunto de mentirosos (liar_count) y verifica si\n    las declaraciones hechas por todos los participantes son consistentes con este escenario, sin tener en cuenta ninguna declaración\n    sobre el día de la semana.\n\n    Parámetros:\n    - scenario (str): El nombre del participante que se está probando como el posible criminal.\n    - liar_count (set): Un conjunto de nombres de participantes que se asumen como mentirosos.\n    - statements (dict): Un diccionario que asigna nombres de participantes a listas de sus respectivas declaraciones.\n    - days_of_week (set): Un conjunto de cadenas que representan los días de la semana.\n\n    Retorna:\n    - bool: True si el escenario es consistente con las declaraciones, False en caso contrario.\n\n    Casos de prueba:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "arb": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    يقيم اتساق السيناريو حيث يكون أحد المشاركين هو المجرم بناءً على التصريحات المقدمة.\n\n    تأخذ هذه الدالة اسم المجرم المحتمل (السيناريو) ومجموعة من الكذابين (liar_count) وتتحقق مما إذا كانت\n    التصريحات التي أدلى بها جميع المشاركين متسقة مع هذا السيناريو، متجاهلة أي تصريحات\n    حول يوم الأسبوع.\n\n    المعاملات:\n    - scenario (str): اسم المشارك الذي يتم اختباره كمجرم محتمل.\n    - liar_count (set): مجموعة من أسماء المشاركين الذين يُفترض أنهم كذابون.\n    - statements (dict): قاموس يربط أسماء المشاركين بقوائم تصريحاتهم الخاصة.\n    - days_of_week (set): مجموعة من السلاسل النصية التي تمثل أيام الأسبوع.\n\n    يعيد:\n    - bool: True إذا كان السيناريو متسقًا مع التصريحات، False خلاف ذلك.\n\n    حالات الاختبار:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "sw": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Inatathmini uthabiti wa tukio ambapo mshiriki mmoja ni mhalifu kulingana na kauli zilizotolewa.\n\n    Kazi hii inachukua jina la mhalifu anayewezekana (scenario) na seti ya waongo (liar_count) na inakagua kama\n    kauli zilizotolewa na washiriki wote zinashabihiana na tukio hili, bila kujali kauli zozote\n    kuhusu siku ya juma.\n\n    Vigezo:\n    - scenario (str): Jina la mshiriki anayepimwa kama mhalifu anayewezekana.\n    - liar_count (set): Seti ya majina ya washiriki wanaodhaniwa kuwa waongo.\n    - statements (dict): Kamusi inayohusisha majina ya washiriki na orodha ya kauli zao husika.\n    - days_of_week (set): Seti ya mistari inayowakilisha siku za juma.\n\n    Inarudisha:\n    - bool: Kweli ikiwa tukio linashabihiana na kauli, La sivyo.\n\n    Mifano ya Majaribio:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "tr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Verilen ifadeler temelinde bir katılımcının suçlu olduğu bir senaryonun tutarlılığını değerlendirir.\n\n    Bu fonksiyon, potansiyel suçlunun adını (senaryo) ve yalancı olarak kabul edilen katılımcıların bir kümesini (liar_count) alır ve\n    tüm katılımcılar tarafından yapılan ifadelerin bu senaryo ile tutarlı olup olmadığını kontrol eder, haftanın günü hakkındaki ifadeleri dikkate almaz.\n\n    Parametreler:\n    - scenario (str): Potansiyel suçlu olarak test edilen katılımcının adı.\n    - liar_count (set): Yalancı olduğu varsayılan katılımcıların adlarını içeren bir küme.\n    - statements (dict): Katılımcı adlarını, onların ilgili ifadelerinin listelerine eşleyen bir sözlük.\n    - days_of_week (set): Haftanın günlerini temsil eden stringlerin bir kümesi.\n\n    Döndürür:\n    - bool: Senaryo ifadelerle tutarlıysa True, aksi takdirde False.\n\n    Test Durumları:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "vi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Đánh giá tính nhất quán của một kịch bản nơi một người tham gia là tội phạm dựa trên các tuyên bố đã cho.\n\n    Hàm này nhận tên của một người bị nghi là tội phạm (scenario) và một tập hợp những người nói dối (liar_count) và kiểm tra xem\n    các tuyên bố của tất cả người tham gia có nhất quán với kịch bản này không, bỏ qua bất kỳ tuyên bố nào\n    về ngày trong tuần.\n\n    Tham số:\n    - scenario (str): Tên của người tham gia đang được kiểm tra như là tội phạm tiềm năng.\n    - liar_count (set): Một tập hợp tên của những người tham gia được cho là nói dối.\n    - statements (dict): Một từ điển ánh xạ tên người tham gia tới danh sách các tuyên bố tương ứng của họ.\n    - days_of_week (set): Một tập hợp các chuỗi đại diện cho các ngày trong tuần.\n\n    Trả về:\n    - bool: True nếu kịch bản nhất quán với các tuyên bố, False nếu không.\n\n    Các trường hợp kiểm tra:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "id": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Mengevaluasi konsistensi dari sebuah skenario di mana satu peserta adalah pelaku berdasarkan pernyataan yang diberikan.\n\n    Fungsi ini mengambil nama pelaku potensial (skenario) dan satu set pembohong (liar_count) dan memeriksa apakah\n    pernyataan yang dibuat oleh semua peserta konsisten dengan skenario ini, mengabaikan pernyataan\n    tentang hari dalam seminggu.\n\n    Parameter:\n    - scenario (str): Nama peserta yang diuji sebagai pelaku potensial.\n    - liar_count (set): Satu set nama peserta yang diasumsikan sebagai pembohong.\n    - statements (dict): Sebuah kamus yang memetakan nama peserta ke daftar pernyataan mereka masing-masing.\n    - days_of_week (set): Satu set string yang mewakili hari-hari dalam seminggu.\n\n    Mengembalikan:\n    - bool: True jika skenario konsisten dengan pernyataan, False jika tidak.\n\n    Kasus Uji:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "ja": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    与えられた証言に基づいて、1人の参加者が犯罪者であるというシナリオの一貫性を評価します。\n\n    この関数は、潜在的な犯罪者の名前（シナリオ）と嘘つきのセット（liar_count）を受け取り、\n    すべての参加者によってなされた証言がこのシナリオと一致するかどうかを確認します。\n    曜日に関する証言は無視されます。\n\n    パラメータ:\n    - scenario (str): 潜在的な犯罪者としてテストされている参加者の名前。\n    - liar_count (set): 嘘つきと仮定されている参加者の名前のセット。\n    - statements (dict): 参加者の名前をそれぞれの証言のリストにマッピングする辞書。\n    - days_of_week (set): 曜日を表す文字列のセット。\n\n    戻り値:\n    - bool: シナリオが証言と一致する場合はTrue、一致しない場合はFalse。\n\n    テストケース:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "ko": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    주어진 진술에 기반하여 한 참가자가 범인인 시나리오의 일관성을 평가합니다.\n\n    이 함수는 잠재적인 범인의 이름(scenario)과 거짓말쟁이로 가정된 참가자들의 집합(liar_count)을 받아\n    모든 참가자들이 한 진술이 이 시나리오와 일관성이 있는지를 확인합니다. 요일에 대한 진술은 무시합니다.\n\n    매개변수:\n    - scenario (str): 잠재적인 범인으로 테스트되는 참가자의 이름.\n    - liar_count (set): 거짓말쟁이로 가정된 참가자들의 이름 집합.\n    - statements (dict): 참가자 이름을 그들의 각각의 진술 목록으로 매핑하는 사전.\n    - days_of_week (set): 요일을 나타내는 문자열의 집합.\n\n    반환값:\n    - bool: 시나리오가 진술과 일관성이 있으면 True, 그렇지 않으면 False.\n\n    테스트 케이스:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "ml": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    ഒരു പങ്കാളി കുറ്റവാളിയാണെന്ന സിദ്ധാന്തത്തിന്റെ സുസ്ഥിരത നൽകിയ പ്രസ്താവനകളുടെ അടിസ്ഥാനത്തിൽ വിലയിരുത്തുന്നു.\n\n    ഈ ഫംഗ്ഷൻ ഒരു സാധ്യതയുള്ള കുറ്റവാളിയുടെ പേര് (scenario) കൂടാതെ ഒരു സെറ്റ് കള്ളന്മാർ (liar_count) സ്വീകരിക്കുന്നു, \n    എല്ലാ പങ്കാളികളും നൽകിയ പ്രസ്താവനകൾ ഈ സിദ്ധാന്തവുമായി സുസ്ഥിരമാണോ എന്ന് പരിശോധിക്കുന്നു, ആഴ്ചയിലെ ദിവസത്തെക്കുറിച്ചുള്ള \n    പ്രസ്താവനകൾ അവഗണിക്കുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    - scenario (str): സാധ്യതയുള്ള കുറ്റവാളിയായി പരിശോധിക്കുന്ന പങ്കാളിയുടെ പേര്.\n    - liar_count (set): കള്ളന്മാരായി കരുതുന്ന പങ്കാളികളുടെ പേരുകളുടെ ഒരു സെറ്റ്.\n    - statements (dict): പങ്കാളികളുടെ പേരുകൾ അവരുടെ അനുബന്ധ പ്രസ്താവനകളുടെ പട്ടികകളിലേക്ക് മാപ്പ് ചെയ്യുന്ന ഒരു നിഘണ്ടു.\n    - days_of_week (set): ആഴ്ചയിലെ ദിവസങ്ങളെ പ്രതിനിധീകരിക്കുന്ന സ്ട്രിംഗുകളുടെ ഒരു സെറ്റ്.\n\n    മടക്കുന്നു:\n    - bool: സിദ്ധാന്തം പ്രസ്താവനകളുമായി സുസ്ഥിരമാണെങ്കിൽ True, അല്ലെങ്കിൽ False.\n\n    ടെസ്റ്റ് കേസുകൾ:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"", "fa": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    ارزیابی سازگاری یک سناریو که در آن یک شرکت‌کننده مجرم است بر اساس اظهارات داده شده.\n\n    این تابع نام یک مجرم احتمالی (سناریو) و مجموعه‌ای از دروغگوها (liar_count) را می‌گیرد و بررسی می‌کند که آیا\n    اظهاراتی که توسط همه شرکت‌کنندگان ارائه شده با این سناریو سازگار است یا خیر، بدون توجه به اظهارات\n    درباره روز هفته.\n\n    پارامترها:\n    - scenario (str): نام شرکت‌کننده‌ای که به عنوان مجرم احتمالی آزمایش می‌شود.\n    - liar_count (set): مجموعه‌ای از نام‌های شرکت‌کنندگانی که فرض می‌شود دروغگو هستند.\n    - statements (dict): یک دیکشنری که نام شرکت‌کنندگان را به لیستی از اظهارات مربوطه آنها نگاشت می‌کند.\n    - days_of_week (set): مجموعه‌ای از رشته‌ها که روزهای هفته را نشان می‌دهند.\n\n    بازگشت:\n    - bool: True اگر سناریو با اظهارات سازگار باشد، در غیر این صورت False.\n\n    موارد آزمایشی:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\""}, "canonical_solution": "    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True", "instruction": {"en": "Write a python function 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' to solve the following problem:\n\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    ", "sq": "Shkruani një funksion python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' për të zgjidhur problemin e mëposhtëm:\n\n    Vlerëson konsistencën e një skenari ku një pjesëmarrës është krimineli bazuar në deklaratat e dhëna.\n\n    Ky funksion merr emrin e një krimineli të mundshëm (skenari) dhe një grup gënjeshtarësh (liar_count) dhe kontrollon nëse\n    deklaratat e bëra nga të gjithë pjesëmarrësit janë në përputhje me këtë skenar, duke injoruar çdo deklaratë\n    rreth ditës së javës.\n\n    Parametrat:\n    - scenario (str): Emri i pjesëmarrësit që po testohet si kriminel i mundshëm.\n    - liar_count (set): Një grup emrash të pjesëmarrësve që supozohet të jenë gënjeshtarë.\n    - statements (dict): Një fjalor që lidh emrat e pjesëmarrësve me listat e deklaratave të tyre përkatëse.\n    - days_of_week (set): Një grup vargjesh që përfaqësojnë ditët e javës.\n\n    Kthen:\n    - bool: True nëse skenari është në përputhje me deklaratat, False përndryshe.\n\n    Rastet e Testit:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "hy": "Պայթոն ֆունկցիա 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Գնահատում է սցենարի համահունչությունը, որտեղ մեկ մասնակիցը հանցագործ է՝ հիմնվելով տրված հայտարարությունների վրա։\n\n    Այս ֆունկցիան վերցնում է հնարավոր հանցագործի անունը (scenario) և ստախոսների հավաքածու (liar_count) և ստուգում է՝\n    արդյոք բոլոր մասնակիցների հայտարարությունները համահունչ են այս սցենարին՝ անտեսելով շաբաթվա օրվա վերաբերյալ ցանկացած հայտարարություն։\n\n    Պարամետրեր:\n    - scenario (str): Մասնակցի անունը, որը փորձարկվում է որպես հնարավոր հանցագործ։\n    - liar_count (set): Մասնակիցների անունների հավաքածու, որոնք համարվում են ստախոսներ։\n    - statements (dict): Բառարան, որը մասնակիցների անունները կապում է նրանց համապատասխան հայտարարությունների ցուցակների հետ։\n    - days_of_week (set): Շաբաթվա օրերը ներկայացնող տողերի հավաքածու։\n\n    Վերադարձնում է:\n    - bool: True, եթե սցենարը համահունչ է հայտարարություններին, հակառակ դեպքում՝ False։\n\n    Թեստային դեպքեր:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "bn": "একটি পাইথন ফাংশন 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত বিবৃতির ভিত্তিতে যেখানে একজন অংশগ্রহণকারী অপরাধী, সেই পরিস্থিতির সামঞ্জস্য মূল্যায়ন করে।\n\n    এই ফাংশনটি সম্ভাব্য অপরাধীর নাম (scenario) এবং মিথ্যাবাদীদের একটি সেট (liar_count) গ্রহণ করে এবং পরীক্ষা করে \n    যে সমস্ত অংশগ্রহণকারীর দ্বারা প্রদত্ত বিবৃতিগুলি এই পরিস্থিতির সাথে সামঞ্জস্যপূর্ণ কিনা, সপ্তাহের দিনের \n    বিষয়ে কোনো বিবৃতি উপেক্ষা করে।\n\n    প্যারামিটার:\n    - scenario (str): সম্ভাব্য অপরাধী হিসাবে পরীক্ষা করা অংশগ্রহণকারীর নাম।\n    - liar_count (set): অংশগ্রহণকারীদের নামের একটি সেট যারা মিথ্যাবাদী বলে মনে করা হয়।\n    - statements (dict): অংশগ্রহণকারীদের নামকে তাদের সংশ্লিষ্ট বিবৃতির তালিকায় ম্যাপ করা একটি অভিধান।\n    - days_of_week (set): সপ্তাহের দিনগুলিকে উপস্থাপনকারী স্ট্রিংগুলির একটি সেট।\n\n    রিটার্ন করে:\n    - bool: যদি পরিস্থিতি বিবৃতির সাথে সামঞ্জস্যপূর্ণ হয় তবে True, অন্যথায় False।\n\n    টেস্ট কেস:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "bg": "Напишете Python функция 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' за решаване на следния проблем:\n\n    Оценява последователността на сценарий, в който един участник е престъпникът, базирано на дадените изявления.\n\n    Тази функция приема името на потенциалния престъпник (scenario) и множество от лъжци (liar_count) и проверява дали\n    изявленията, направени от всички участници, са последователни с този сценарий, като се пренебрегват всички изявления\n    относно деня от седмицата.\n\n    Параметри:\n    - scenario (str): Името на участника, който се тества като потенциален престъпник.\n    - liar_count (set): Множество от имена на участници, които се приемат за лъжци.\n    - statements (dict): Речник, който свързва имената на участниците със списъци на техните съответни изявления.\n    - days_of_week (set): Множество от низове, представляващи дните от седмицата.\n\n    Връща:\n    - bool: True, ако сценарият е последователен с изявленията, False в противен случай.\n\n    Тестови случаи:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "zh": "编写一个python函数 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' 来解决以下问题:\n\n    评估一个场景的连贯性，其中一个参与者是基于给定陈述的罪犯。\n\n    此函数接受一个潜在罪犯的名字（scenario）和一组撒谎者（liar_count），并检查所有参与者所做的陈述是否与此场景一致，忽略任何关于星期几的陈述。\n\n    参数:\n    - scenario (str): 被测试为潜在罪犯的参与者的名字。\n    - liar_count (set): 假定为撒谎者的参与者名字集合。\n    - statements (dict): 一个字典，将参与者名字映射到各自陈述的列表。\n    - days_of_week (set): 表示星期几的字符串集合。\n\n    返回:\n    - bool: 如果场景与陈述一致则为True，否则为False。\n\n    测试用例:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "fr": "Écrivez une fonction python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' pour résoudre le problème suivant :\n\n    Évalue la cohérence d'un scénario où un participant est le criminel basé sur les déclarations données.\n\n    Cette fonction prend le nom d'un criminel potentiel (scenario) et un ensemble de menteurs (liar_count) et vérifie si\n    les déclarations faites par tous les participants sont cohérentes avec ce scénario, en ignorant toute déclaration\n    concernant le jour de la semaine.\n\n    Paramètres:\n    - scenario (str): Le nom du participant testé en tant que criminel potentiel.\n    - liar_count (set): Un ensemble de noms de participants supposés être des menteurs.\n    - statements (dict): Un dictionnaire associant les noms des participants à des listes de leurs déclarations respectives.\n    - days_of_week (set): Un ensemble de chaînes représentant les jours de la semaine.\n\n    Renvoie:\n    - bool: True si le scénario est cohérent avec les déclarations, False sinon.\n\n    Cas de test:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "de": "Schreiben Sie eine Python-Funktion 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:', um das folgende Problem zu lösen:\n\n    Bewertet die Konsistenz eines Szenarios, in dem ein Teilnehmer basierend auf den gegebenen Aussagen der Täter ist.\n\n    Diese Funktion nimmt den Namen eines potenziellen Täters (Szenario) und eine Menge von Lügnern (liar_count) und überprüft,\n    ob die von allen Teilnehmern gemachten Aussagen mit diesem Szenario konsistent sind, wobei Aussagen über den Wochentag ignoriert werden.\n\n    Parameter:\n    - scenario (str): Der Name des Teilnehmers, der als potenzieller Täter getestet wird.\n    - liar_count (set): Eine Menge von Namen von Teilnehmern, die als Lügner angenommen werden.\n    - statements (dict): Ein Wörterbuch, das Teilnehmernamen auf Listen ihrer jeweiligen Aussagen abbildet.\n    - days_of_week (set): Eine Menge von Zeichenfolgen, die die Wochentage darstellen.\n\n    Rückgabewerte:\n    - bool: True, wenn das Szenario mit den Aussagen konsistent ist, andernfalls False.\n\n    Testfälle:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "ha": "Rubuta wani aikin python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' don warware matsalar mai zuwa:\n\n    Kimanta daidaiton wani yanayi inda wani mahalarta shine mai laifi bisa ga bayanan da aka bayar.\n\n    Wannan aikin yana daukar sunan mai laifi mai yuwuwa (scenario) da kuma saitin makaryata (liar_count) kuma yana duba idan\n    bayanan da duk mahalarta suka yi suna daidai da wannan yanayin, tare da watsi da duk wani bayani\n    game da ranar mako.\n\n    Sigogi:\n    - scenario (str): Sunan mahalarta da ake gwadawa a matsayin mai laifi mai yuwuwa.\n    - liar_count (set): Saitin sunayen mahalarta da ake tsammanin makaryata ne.\n    - statements (dict): Kamus mai danganta sunayen mahalarta zuwa jerin bayanan su na musamman.\n    - days_of_week (set): Saitin kirtani da ke wakiltar ranakun mako.\n\n    Komawa:\n    - bool: Gaskiya idan yanayin yana daidai da bayanan, Karya idan ba haka ba.\n\n    Gwajin Lokuta:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "hi": "एक पायथन फ़ंक्शन 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए बयानों के आधार पर एक परिदृश्य की संगति का मूल्यांकन करता है जहां एक प्रतिभागी अपराधी है।\n\n    यह फ़ंक्शन एक संभावित अपराधी का नाम (scenario) और झूठे लोगों का एक सेट (liar_count) लेता है और जांचता है कि\n    सभी प्रतिभागियों द्वारा दिए गए बयान इस परिदृश्य के साथ संगत हैं या नहीं, सप्ताह के दिन के बारे में किसी भी बयान को नजरअंदाज करते हुए।\n\n    पैरामीटर्स:\n    - scenario (str): उस प्रतिभागी का नाम जिसे संभावित अपराधी के रूप में परीक्षण किया जा रहा है।\n    - liar_count (set): उन प्रतिभागियों के नामों का सेट जिन्हें झूठा माना जाता है।\n    - statements (dict): प्रतिभागियों के नामों को उनके संबंधित बयानों की सूची से मैप करने वाली एक डिक्शनरी।\n    - days_of_week (set): सप्ताह के दिनों का प्रतिनिधित्व करने वाले स्ट्रिंग्स का एक सेट।\n\n    लौटाता है:\n    - bool: True यदि परिदृश्य बयानों के साथ संगत है, अन्यथा False।\n\n    परीक्षण मामले:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "hu": "Írj egy Python függvényt 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' a következő probléma megoldására:\n\n    Értékeli egy olyan forgatókönyv konzisztenciáját, ahol az egyik résztvevő a bűnös a megadott állítások alapján.\n\n    Ez a függvény egy potenciális bűnös nevét (scenario) és egy hazugok halmazát (liar_count) veszi, és ellenőrzi, hogy\n    az összes résztvevő által tett állítások konzisztens-e ezzel a forgatókönyvvel, figyelmen kívül hagyva a hét napjával\n    kapcsolatos bármely állítást.\n\n    Paraméterek:\n    - scenario (str): A résztvevő neve, akit potenciális bűnösként tesztelnek.\n    - liar_count (set): A hazugnak feltételezett résztvevők neveinek halmaza.\n    - statements (dict): Egy szótár, amely a résztvevők neveit a megfelelő állításaik listájához rendeli.\n    - days_of_week (set): A hét napjait képviselő karakterláncok halmaza.\n\n    Visszatérési érték:\n    - bool: Igaz, ha a forgatókönyv konzisztens az állításokkal, hamis egyébként.\n\n    Tesztesetek:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "es": "Escribe una función en Python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' para resolver el siguiente problema:\n\n    Evalúa la consistencia de un escenario donde un participante es el criminal basado en las declaraciones dadas.\n\n    Esta función toma el nombre de un posible criminal (scenario) y un conjunto de mentirosos (liar_count) y verifica si\n    las declaraciones hechas por todos los participantes son consistentes con este escenario, sin tener en cuenta ninguna declaración\n    sobre el día de la semana.\n\n    Parámetros:\n    - scenario (str): El nombre del participante que se está probando como el posible criminal.\n    - liar_count (set): Un conjunto de nombres de participantes que se asumen como mentirosos.\n    - statements (dict): Un diccionario que mapea nombres de participantes a listas de sus respectivas declaraciones.\n    - days_of_week (set): Un conjunto de cadenas que representan los días de la semana.\n\n    Retorna:\n    - bool: True si el escenario es consistente con las declaraciones, False en caso contrario.\n\n    Casos de prueba:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "arb": "اكتب دالة بايثون 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' لحل المشكلة التالية:\n\n    تقييم اتساق سيناريو حيث يكون أحد المشاركين هو المجرم بناءً على التصريحات المعطاة.\n\n    تأخذ هذه الدالة اسم المجرم المحتمل (scenario) ومجموعة من الكاذبين (liar_count) وتتحقق مما إذا كانت\n    التصريحات التي أدلى بها جميع المشاركين متسقة مع هذا السيناريو، متجاهلة أي تصريحات\n    حول يوم الأسبوع.\n\n    المعاملات:\n    - scenario (str): اسم المشارك الذي يتم اختباره كمجرم محتمل.\n    - liar_count (set): مجموعة من أسماء المشاركين الذين يُفترض أنهم كاذبون.\n    - statements (dict): قاموس يربط أسماء المشاركين بقوائم تصريحاتهم الخاصة.\n    - days_of_week (set): مجموعة من السلاسل النصية التي تمثل أيام الأسبوع.\n\n    العوائد:\n    - bool: صحيح إذا كان السيناريو متسقًا مع التصريحات، خطأ خلاف ذلك.\n\n    حالات الاختبار:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "sw": "Andika kazi ya python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' kutatua tatizo lifuatalo:\n\n    Inatathmini uthabiti wa hali ambapo mshiriki mmoja ni mhalifu kulingana na kauli zilizotolewa.\n\n    Kazi hii inachukua jina la mhalifu anayewezekana (scenario) na seti ya waongo (liar_count) na inakagua kama\n    kauli zilizotolewa na washiriki wote zinakubaliana na hali hii, bila kujali kauli zozote kuhusu siku ya wiki.\n\n    Vigezo:\n    - scenario (str): Jina la mshiriki anayejaribiwa kama mhalifu anayewezekana.\n    - liar_count (set): Seti ya majina ya washiriki wanaodhaniwa kuwa waongo.\n    - statements (dict): Kamusi inayochanganua majina ya washiriki na orodha za kauli zao husika.\n    - days_of_week (set): Seti ya mistari inayowakilisha siku za wiki.\n\n    Inarudisha:\n    - bool: Kweli ikiwa hali inakubaliana na kauli, Vinginevyo uongo.\n\n    Mifano ya Majaribio:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "tr": "Bir python fonksiyonu 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen ifadelere dayanarak bir katılımcının suçlu olduğu bir senaryonun tutarlılığını değerlendirir.\n\n    Bu fonksiyon potansiyel suçlunun adını (scenario) ve yalancıların bir kümesini (liar_count) alır ve\n    tüm katılımcılar tarafından yapılan ifadelerin bu senaryoyla tutarlı olup olmadığını kontrol eder, haftanın günü hakkındaki\n    ifadeleri göz ardı eder.\n\n    Parametreler:\n    - scenario (str): Potansiyel suçlu olarak test edilen katılımcının adı.\n    - liar_count (set): Yalancı olduğu varsayılan katılımcıların adlarının bulunduğu bir küme.\n    - statements (dict): Katılımcı adlarını, onların ilgili ifadelerinin listelerine eşleyen bir sözlük.\n    - days_of_week (set): Haftanın günlerini temsil eden stringlerin bulunduğu bir küme.\n\n    Döndürür:\n    - bool: Eğer senaryo ifadelerle tutarlıysa True, aksi takdirde False.\n\n    Test Durumları:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "vi": "Viết một hàm python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' để giải quyết vấn đề sau:\n\n    Đánh giá tính nhất quán của một kịch bản nơi một người tham gia là tội phạm dựa trên các tuyên bố đã cho.\n\n    Hàm này nhận tên của một tội phạm tiềm năng (scenario) và một tập hợp những kẻ nói dối (liar_count) và kiểm tra xem\n    các tuyên bố được đưa ra bởi tất cả người tham gia có nhất quán với kịch bản này hay không, bỏ qua bất kỳ tuyên bố nào\n    về ngày trong tuần.\n\n    Tham số:\n    - scenario (str): Tên của người tham gia đang được kiểm tra như là tội phạm tiềm năng.\n    - liar_count (set): Một tập hợp tên của những người tham gia được giả định là kẻ nói dối.\n    - statements (dict): Một từ điển ánh xạ tên người tham gia tới danh sách các tuyên bố tương ứng của họ.\n    - days_of_week (set): Một tập hợp các chuỗi đại diện cho các ngày trong tuần.\n\n    Trả về:\n    - bool: True nếu kịch bản nhất quán với các tuyên bố, False nếu không.\n\n    Trường hợp kiểm tra:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "id": "Tulis fungsi python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' untuk menyelesaikan masalah berikut:\n\n    Mengevaluasi konsistensi dari sebuah skenario di mana satu peserta adalah kriminal berdasarkan pernyataan yang diberikan.\n\n    Fungsi ini mengambil nama calon kriminal (scenario) dan satu set pembohong (liar_count) dan memeriksa apakah\n    pernyataan yang dibuat oleh semua peserta konsisten dengan skenario ini, mengabaikan pernyataan\n    tentang hari dalam seminggu.\n\n    Parameter:\n    - scenario (str): Nama peserta yang diuji sebagai calon kriminal.\n    - liar_count (set): Satu set nama peserta yang diasumsikan sebagai pembohong.\n    - statements (dict): Sebuah kamus yang memetakan nama peserta ke daftar pernyataan mereka masing-masing.\n    - days_of_week (set): Satu set string yang mewakili hari dalam seminggu.\n\n    Mengembalikan:\n    - bool: True jika skenario konsisten dengan pernyataan, False jika tidak.\n\n    Kasus Uji:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "ja": "Python関数 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' を作成して、次の問題を解決してください:\n\n    与えられた証言に基づいて、1人の参加者が犯人であるシナリオの一貫性を評価します。\n\n    この関数は、潜在的な犯人の名前 (scenario) と嘘つきの集合 (liar_count) を受け取り、\n    すべての参加者によって行われた証言がこのシナリオと一致するかどうかを確認します。\n    曜日に関する証言は無視されます。\n\n    パラメータ:\n    - scenario (str): 潜在的な犯人としてテストされている参加者の名前。\n    - liar_count (set): 嘘つきと仮定される参加者の名前の集合。\n    - statements (dict): 参加者の名前をそれぞれの証言のリストにマッピングする辞書。\n    - days_of_week (set): 曜日を表す文字列の集合。\n\n    戻り値:\n    - bool: シナリオが証言と一致する場合はTrue、一致しない場合はFalse。\n\n    テストケース:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "ko": "파이썬 함수를 작성하세요 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' 다음 문제를 해결하기 위해:\n\n    주어진 진술에 기반하여 한 참가자가 범인인 시나리오의 일관성을 평가합니다.\n\n    이 함수는 잠재적인 범인의 이름(scenario)과 거짓말쟁이의 집합(liar_count)을 받아서\n    모든 참가자가 한 진술이 이 시나리오와 일관성이 있는지, 요일에 대한 진술은 무시하고 확인합니다.\n\n    매개변수:\n    - scenario (str): 잠재적인 범인으로 테스트되는 참가자의 이름.\n    - liar_count (set): 거짓말쟁이로 가정되는 참가자들의 이름 집합.\n    - statements (dict): 참가자 이름을 그들의 각각의 진술 목록에 매핑하는 사전.\n    - days_of_week (set): 요일을 나타내는 문자열의 집합.\n\n    반환값:\n    - bool: 시나리오가 진술과 일관성이 있으면 True, 그렇지 않으면 False.\n\n    테스트 케이스:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    ", "ml": "'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    നൽകിയിരിക്കുന്ന പ്രസ്താവനകളുടെ അടിസ്ഥാനത്തിൽ ഒരു പങ്കാളി കുറ്റവാളിയാണ് എന്ന ഒരു സാഹചര്യത്തിന്റെ സുസ്ഥിരത വിലയിരുത്തുന്നു.\n\n    ഈ ഫംഗ്ഷൻ ഒരു സാധ്യതയുള്ള കുറ്റവാളിയുടെ പേര് (scenario) കൂടാതെ കള്ളന്മാരുടെ ഒരു സെറ്റ് (liar_count) എടുക്കുന്നു, \n    എല്ലാ പങ്കാളികളും നൽകിയ പ്രസ്താവനകൾ ഈ സാഹചര്യവുമായി സുസ്ഥിരമാണോ എന്ന് പരിശോധിക്കുന്നു, ആഴ്ചയിലെ ദിവസത്തെക്കുറിച്ചുള്ള \n    ഏതെങ്കിലും പ്രസ്താവനകൾ അവഗണിക്കുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    - scenario (str): സാധ്യതയുള്ള കുറ്റവാളിയായി പരിശോധിക്കുന്ന പങ്കാളിയുടെ പേര്.\n    - liar_count (set): കള്ളന്മാരാണെന്ന് കരുതുന്ന പങ്കാളികളുടെ പേരുകളുടെ ഒരു സെറ്റ്.\n    - statements (dict): പങ്കാളികളുടെ പേരുകളെ അവരുടെ പ്രസ്താവനകളുടെ പട്ടികയുമായി മാപ്പ് ചെയ്യുന്ന ഒരു നിഘണ്ടു.\n    - days_of_week (set): ആഴ്ചയിലെ ദിവസങ്ങളെ പ്രതിനിധീകരിക്കുന്ന സ്ട്രിംഗുകളുടെ ഒരു സെറ്റ്.\n\n    തിരികെ നൽകുന്നു:\n    - bool: പ്രസ്താവനകളുമായി ഈ സാഹചര്യത്തിന്റെ സുസ്ഥിരതയുണ്ടെങ്കിൽ True, അല്ലെങ്കിൽ False.\n\n    ടെസ്റ്റ് കേസുകൾ:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "fa": "یک تابع پایتون بنویسید 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' تا مسئله زیر را حل کند:\n\n    سازگاری یک سناریو را ارزیابی می‌کند که در آن یک شرکت‌کننده مجرم است بر اساس اظهارات داده شده.\n\n    این تابع نام یک مجرم بالقوه (scenario) و مجموعه‌ای از دروغگوها (liar_count) را می‌گیرد و بررسی می‌کند که آیا\n    اظهارات ارائه شده توسط همه شرکت‌کنندگان با این سناریو سازگار هستند یا خیر، بدون توجه به هرگونه اظهارات\n    درباره روز هفته.\n\n    پارامترها:\n    - scenario (str): نام شرکت‌کننده‌ای که به عنوان مجرم بالقوه مورد آزمایش قرار می‌گیرد.\n    - liar_count (set): مجموعه‌ای از نام‌های شرکت‌کنندگانی که فرض می‌شود دروغگو هستند.\n    - statements (dict): دیکشنری که نام شرکت‌کنندگان را به لیستی از اظهارات مربوطه آن‌ها نگاشت می‌کند.\n    - days_of_week (set): مجموعه‌ای از رشته‌ها که روزهای هفته را نشان می‌دهند.\n\n    خروجی:\n    - bool: True اگر سناریو با اظهارات سازگار باشد، در غیر این صورت False.\n\n    موارد آزمایشی:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True"}, "level": "hard", "test": "def test_check_scenario():\n    # Define a set of days of the week for the test cases\n    days_of_week = set([\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\", \"SUNDAY\"])\n\n    # Test case 1: Simple case where the scenario is correct\n    statements_test1 = {\n        \"ALICE\": [\"I am not guilty.\", \"BOB is guilty.\"],\n        \"BOB\": [\"ALICE is not guilty.\", \"Today is MONDAY\"],\n        \"CHARLIE\": [\"I am guilty.\"]\n    }\n    scenario_test1 = \"CHARLIE\"\n    liar_count_test1 = {\"ALICE\", \"BOB\"}\n    assert check_scenario(scenario_test1, liar_count_test1, statements_test1, days_of_week) == False, \"Test case 1 failed\"\n\n    # Test case 2: Scenario with contradictory statements\n    statements_test2 = {\n        \"ALICE\": [\"I am guilty.\"],\n        \"BOB\": [\"I am not guilty.\", \"ALICE is guilty.\"],\n        \"CHARLIE\": [\"I am not guilty.\", \"Today is TUESDAY\"]\n    }\n    scenario_test2 = \"ALICE\"\n    liar_count_test2 = {\"BOB\", \"CHARLIE\"}\n    assert check_scenario(scenario_test2, liar_count_test2, statements_test2, days_of_week) == False, \"Test case 2 failed\"\n\n    # Test case 3: Scenario where the statements are ambiguous\n    statements_test3 = {\n        \"ALICE\": [\"I am not guilty.\", \"Today is WEDNESDAY\"],\n        \"BOB\": [\"I am not guilty.\", \"CHARLIE is guilty.\"],\n        \"CHARLIE\": [\"BOB is not guilty.\"]\n    }\n    scenario_test3 = \"BOB\"\n    liar_count_test3 = {\"ALICE\", \"CHARLIE\"}\n    assert check_scenario(scenario_test3, liar_count_test3, statements_test3, days_of_week) == False, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_check_scenario()", "entry_point": "check_scenario", "signature": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:", "docstring": {"en": "\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    ", "sq": "\n    Vlerëson konsistencën e një skenari ku një pjesëmarrës është krimineli bazuar në deklaratat e dhëna.\n\n    Kjo funksion merr emrin e një të dyshuari potencial (skenari) dhe një grup gënjeshtarësh (liar_count) dhe kontrollon nëse\n    deklaratat e bëra nga të gjithë pjesëmarrësit janë në përputhje me këtë skenar, duke injoruar çdo deklaratë\n    rreth ditës së javës.\n\n    Parametrat:\n    - scenario (str): Emri i pjesëmarrësit që po testohet si kriminel potencial.\n    - liar_count (set): Një grup emrash të pjesëmarrësve që supozohen të jenë gënjeshtarë.\n    - statements (dict): Një fjalor që lidh emrat e pjesëmarrësve me listat e deklaratave të tyre përkatëse.\n    - days_of_week (set): Një grup vargjesh që përfaqësojnë ditët e javës.\n\n    Kthen:\n    - bool: True nëse skenari është në përputhje me deklaratat, False përndryshe.\n\n    Rastet e Testimit:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "hy": "\n    Գնահատում է սցենարի հետևողականությունը, որտեղ մեկ մասնակիցը հանցագործ է՝ հիմնվելով տրված հայտարարությունների վրա։\n\n    Այս ֆունկցիան վերցնում է հնարավոր հանցագործի անունը (սցենար) և ստախոսների հավաքածու (liar_count) և ստուգում է՝ արդյոք\n    բոլոր մասնակիցների հայտարարությունները համահունչ են այս սցենարի հետ՝ անտեսելով շաբաթվա օրվա մասին հայտարարությունները։\n\n    Պարամետրեր:\n    - scenario (str): Մասնակցի անունը, որը փորձարկվում է որպես հնարավոր հանցագործ։\n    - liar_count (set): Մասնակիցների անունների հավաքածու, որոնք համարվում են ստախոսներ։\n    - statements (dict): Բառարան, որը մասնակիցների անունները կապում է նրանց համապատասխան հայտարարությունների ցուցակների հետ։\n    - days_of_week (set): Տողերի հավաքածու, որը ներկայացնում է շաբաթվա օրերը։\n\n    Վերադարձնում է:\n    - bool: True, եթե սցենարը համահունչ է հայտարարություններին, հակառակ դեպքում՝ False։\n\n    Թեստային դեպքեր:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "bn": "\n    প্রদত্ত বিবৃতির ভিত্তিতে একজন অংশগ্রহণকারী অপরাধী এমন একটি পরিস্থিতির সামঞ্জস্য মূল্যায়ন করে।\n\n    এই ফাংশনটি একটি সম্ভাব্য অপরাধীর নাম (scenario) এবং মিথ্যাবাদীদের একটি সেট (liar_count) গ্রহণ করে এবং\n    সমস্ত অংশগ্রহণকারীদের দ্বারা প্রদত্ত বিবৃতিগুলি এই পরিস্থিতির সাথে সামঞ্জস্যপূর্ণ কিনা তা পরীক্ষা করে, সপ্তাহের দিনের \n    সম্পর্কে কোনও বিবৃতি উপেক্ষা করে।\n\n    প্যারামিটার:\n    - scenario (str): সম্ভাব্য অপরাধী হিসাবে পরীক্ষিত অংশগ্রহণকারীর নাম।\n    - liar_count (set): অংশগ্রহণকারীদের নামের একটি সেট যারা মিথ্যাবাদী বলে ধারণা করা হয়।\n    - statements (dict): অংশগ্রহণকারীদের নামকে তাদের সংশ্লিষ্ট বিবৃতির তালিকার সাথে মানচিত্র করে এমন একটি অভিধান।\n    - days_of_week (set): সপ্তাহের দিনগুলিকে উপস্থাপনকারী স্ট্রিংগুলির একটি সেট।\n\n    রিটার্ন:\n    - bool: যদি পরিস্থিতি বিবৃতির সাথে সামঞ্জস্যপূর্ণ হয় তবে True, অন্যথায় False।\n\n    টেস্ট কেস:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "bg": "\n    Оценява последователността на сценарий, при който един участник е престъпникът въз основа на дадените изявления.\n\n    Тази функция приема името на потенциалния престъпник (scenario) и набор от лъжци (liar_count) и проверява дали\n    изявленията, направени от всички участници, са последователни с този сценарий, пренебрегвайки всякакви изявления\n    за деня от седмицата.\n\n    Параметри:\n    - scenario (str): Името на участника, който се тества като потенциален престъпник.\n    - liar_count (set): Набор от имена на участници, които се приемат за лъжци.\n    - statements (dict): Речник, който свързва имената на участниците със списъци на техните съответни изявления.\n    - days_of_week (set): Набор от низове, представляващи дните от седмицата.\n\n    Връща:\n    - bool: True, ако сценарият е последователен с изявленията, False в противен случай.\n\n    Тестови случаи:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "zh": "\n    评估一个场景的连贯性，其中一个参与者是基于给定陈述的罪犯。\n\n    该函数接受一个潜在罪犯的名字（scenario）和一组说谎者（liar_count），并检查所有参与者的陈述是否与该场景一致，忽略任何关于星期几的陈述。\n\n    参数:\n    - scenario (str): 被测试为潜在罪犯的参与者的名字。\n    - liar_count (set): 被假定为说谎者的参与者名字集合。\n    - statements (dict): 一个字典，将参与者的名字映射到他们各自陈述的列表。\n    - days_of_week (set): 表示星期几的字符串集合。\n\n    返回:\n    - bool: 如果场景与陈述一致则为 True，否则为 False。\n\n    测试用例:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "fr": "\n    Évalue la cohérence d'un scénario où un participant est le criminel basé sur les déclarations données.\n\n    Cette fonction prend le nom d'un criminel potentiel (scenario) et un ensemble de menteurs (liar_count) et vérifie si\n    les déclarations faites par tous les participants sont cohérentes avec ce scénario, en ignorant toute déclaration\n    concernant le jour de la semaine.\n\n    Paramètres:\n    - scenario (str): Le nom du participant testé comme criminel potentiel.\n    - liar_count (set): Un ensemble de noms de participants supposés être des menteurs.\n    - statements (dict): Un dictionnaire associant les noms des participants à des listes de leurs déclarations respectives.\n    - days_of_week (set): Un ensemble de chaînes représentant les jours de la semaine.\n\n    Renvoie:\n    - bool: True si le scénario est cohérent avec les déclarations, False sinon.\n\n    Cas de test:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "de": "\n    Bewertet die Konsistenz eines Szenarios, in dem ein Teilnehmer basierend auf den gegebenen Aussagen der Täter ist.\n\n    Diese Funktion nimmt den Namen eines potenziellen Täters (scenario) und eine Menge von Lügnern (liar_count) und überprüft, ob die von allen Teilnehmern gemachten Aussagen mit diesem Szenario übereinstimmen, wobei Aussagen über den Wochentag ignoriert werden.\n\n    Parameter:\n    - scenario (str): Der Name des Teilnehmers, der als potenzieller Täter getestet wird.\n    - liar_count (set): Eine Menge von Namen der Teilnehmer, die als Lügner angenommen werden.\n    - statements (dict): Ein Wörterbuch, das Teilnehmernamen auf Listen ihrer jeweiligen Aussagen abbildet.\n    - days_of_week (set): Eine Menge von Zeichenfolgen, die die Wochentage darstellen.\n\n    Rückgabewert:\n    - bool: True, wenn das Szenario mit den Aussagen konsistent ist, andernfalls False.\n\n    Testfälle:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "ha": "\n    Kimanta daidaiton yanayi inda ɗaya daga cikin mahalarta shine mai laifi bisa ga bayanan da aka bayar.\n\n    Wannan aikin yana ɗaukar sunan mai laifi mai yuwuwa (scenario) da kuma saitin makaryata (liar_count) kuma yana duba idan\n    bayanan da duk mahalarta suka bayar suna daidaita da wannan yanayi, ba tare da la'akari da duk wani bayani\n    game da ranar mako ba.\n\n    Sigogi:\n    - scenario (str): Sunan mahalartin da ake gwadawa a matsayin mai laifi mai yuwuwa.\n    - liar_count (set): Saiti na sunayen mahalarta da ake ɗauka a matsayin makaryata.\n    - statements (dict): Kamus mai haɗa sunayen mahalarta da jerin bayanan su na musamman.\n    - days_of_week (set): Saiti na kirtani da ke wakiltar ranakun mako.\n\n    Abin da ake dawowa da shi:\n    - bool: Gaskiya idan yanayin yana daidaita da bayanan, Karya idan ba haka ba.\n\n    Gwaje-gwajen:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "hi": "\n    दिए गए बयानों के आधार पर एक परिदृश्य की संगति का मूल्यांकन करता है जहां एक प्रतिभागी अपराधी है।\n\n    यह फ़ंक्शन एक संभावित अपराधी का नाम (scenario) और झूठे व्यक्तियों का एक सेट (liar_count) लेता है और जांचता है कि\n    क्या सभी प्रतिभागियों द्वारा दिए गए बयान इस परिदृश्य के साथ संगत हैं, सप्ताह के दिन के बारे में किसी भी बयान को नजरअंदाज करते हुए।\n\n    पैरामीटर्स:\n    - scenario (str): उस प्रतिभागी का नाम जिसका संभावित अपराधी के रूप में परीक्षण किया जा रहा है।\n    - liar_count (set): प्रतिभागियों के नामों का एक सेट जिन्हें झूठा माना जा रहा है।\n    - statements (dict): प्रतिभागियों के नामों को उनके संबंधित बयानों की सूचियों के साथ मैप करने वाली एक डिक्शनरी।\n    - days_of_week (set): सप्ताह के दिनों का प्रतिनिधित्व करने वाले स्ट्रिंग्स का एक सेट।\n\n    रिटर्न्स:\n    - bool: True यदि परिदृश्य बयानों के साथ संगत है, अन्यथा False।\n\n    परीक्षण मामले:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "hu": "\n    Értékeli annak a forgatókönyvnek a következetességét, ahol az egyik résztvevő a bűnös a megadott állítások alapján.\n\n    Ez a függvény egy potenciális bűnös nevét (forgatókönyv) és egy hazugok halmazát (hazugok_száma) veszi, és ellenőrzi, hogy az összes résztvevő által tett állítások következetesek-e ezzel a forgatókönyvvel, figyelmen kívül hagyva a hét napjaira vonatkozó állításokat.\n\n    Paraméterek:\n    - scenario (str): A résztvevő neve, akit potenciális bűnösként vizsgálnak.\n    - liar_count (set): A résztvevők neveinek halmaza, akiket hazugnak feltételezünk.\n    - statements (dict): Egy szótár, amely a résztvevők neveit a saját állításaik listájához rendeli.\n    - days_of_week (set): A hét napjait képviselő karakterláncok halmaza.\n\n    Visszatérési érték:\n    - bool: Igaz, ha a forgatókönyv következetes az állításokkal, hamis egyébként.\n\n    Tesztesetek:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "es": "Evalúa la consistencia de un escenario donde un participante es el criminal basado en las declaraciones dadas.\n\nEsta función toma el nombre de un posible criminal (scenario) y un conjunto de mentirosos (liar_count) y verifica si las declaraciones hechas por todos los participantes son consistentes con este escenario, ignorando cualquier declaración sobre el día de la semana.\n\nParámetros:\n- scenario (str): El nombre del participante que se está probando como el posible criminal.\n- liar_count (set): Un conjunto de nombres de participantes que se asumen como mentirosos.\n- statements (dict): Un diccionario que mapea nombres de participantes a listas de sus respectivas declaraciones.\n- days_of_week (set): Un conjunto de cadenas que representan los días de la semana.\n\nDevuelve:\n- bool: True si el escenario es consistente con las declaraciones, False en caso contrario.\n\nCasos de prueba:\n>>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\nTrue", "arb": "    يقيم اتساق سيناريو حيث يكون أحد المشاركين هو المجرم بناءً على التصريحات المقدمة.\n\n    تأخذ هذه الدالة اسم المجرم المحتمل (scenario) ومجموعة من الكاذبين (liar_count) وتتحقق مما إذا كانت\n    التصريحات التي أدلى بها جميع المشاركين متسقة مع هذا السيناريو، مع تجاهل أي تصريحات\n    تتعلق بيوم الأسبوع.\n\n    المعاملات:\n    - scenario (str): اسم المشارك الذي يتم اختباره كمجرم محتمل.\n    - liar_count (set): مجموعة من أسماء المشاركين الذين يُفترض أنهم كاذبون.\n    - statements (dict): قاموس يربط أسماء المشاركين بقوائم تصريحاتهم الخاصة.\n    - days_of_week (set): مجموعة من السلاسل النصية التي تمثل أيام الأسبوع.\n\n    يعيد:\n    - bool: True إذا كان السيناريو متسقًا مع التصريحات، False خلاف ذلك.\n\n    حالات الاختبار:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "sw": "Hupima uthabiti wa hali ambapo mshiriki mmoja ni mhalifu kulingana na kauli zilizotolewa.\n\nKazi hii inachukua jina la mhalifu anayewezekana (hali) na seti ya waongo (liar_count) na inakagua kama kauli zilizotolewa na washiriki wote zinakubaliana na hali hii, bila kujali kauli zozote kuhusu siku ya wiki.\n\nVigezo:\n- scenario (str): Jina la mshiriki anayepimwa kama mhalifu anayewezekana.\n- liar_count (set): Seti ya majina ya washiriki wanaodhaniwa kuwa waongo.\n- statements (dict): Kamusi inayochanganua majina ya washiriki na orodha za kauli zao husika.\n- days_of_week (set): Seti ya mistari inayowakilisha siku za wiki.\n\nInarejesha:\n- bool: Kweli ikiwa hali inakubaliana na kauli, Si kweli vinginevyo.\n\nMifano ya Majaribio:\n>>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\nTrue", "tr": "    Bir katılımcının suçlu olduğu bir senaryonun verilen ifadelere göre tutarlılığını değerlendirir.\n\n    Bu fonksiyon, potansiyel bir suçlunun adını (senaryo) ve bir dizi yalancıyı (liar_count) alır ve\n    tüm katılımcılar tarafından yapılan ifadelerin bu senaryo ile tutarlı olup olmadığını, haftanın günü hakkındaki\n    ifadeleri görmezden gelerek kontrol eder.\n\n    Parametreler:\n    - scenario (str): Potansiyel suçlu olarak test edilen katılımcının adı.\n    - liar_count (set): Yalancı olduğu varsayılan katılımcıların isimlerinden oluşan bir küme.\n    - statements (dict): Katılımcı isimlerini, onların ifadelerinin listelerine eşleyen bir sözlük.\n    - days_of_week (set): Haftanın günlerini temsil eden stringlerden oluşan bir küme.\n\n    Döndürür:\n    - bool: Senaryo ifadelerle tutarlıysa True, aksi takdirde False.\n\n    Test Durumları:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "vi": "    Đánh giá tính nhất quán của một kịch bản nơi một người tham gia là tội phạm dựa trên các tuyên bố đã cho.\n\n    Hàm này nhận tên của một người có thể là tội phạm (scenario) và một tập hợp những người nói dối (liar_count) và kiểm tra xem\n    các tuyên bố của tất cả các người tham gia có nhất quán với kịch bản này không, bỏ qua bất kỳ tuyên bố nào\n    về ngày trong tuần.\n\n    Tham số:\n    - scenario (str): Tên của người tham gia đang được kiểm tra như là tội phạm tiềm năng.\n    - liar_count (set): Một tập hợp tên của những người tham gia được giả định là người nói dối.\n    - statements (dict): Một từ điển ánh xạ tên người tham gia tới danh sách các tuyên bố tương ứng của họ.\n    - days_of_week (set): Một tập hợp các chuỗi đại diện cho các ngày trong tuần.\n\n    Trả về:\n    - bool: True nếu kịch bản nhất quán với các tuyên bố, False nếu không.\n\n    Các trường hợp kiểm tra:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "id": "    Mengevaluasi konsistensi dari sebuah skenario di mana satu peserta adalah pelaku berdasarkan pernyataan yang diberikan.\n\n    Fungsi ini mengambil nama pelaku potensial (skenario) dan satu set pembohong (liar_count) dan memeriksa apakah\n    pernyataan yang dibuat oleh semua peserta konsisten dengan skenario ini, mengabaikan pernyataan\n    tentang hari dalam seminggu.\n\n    Parameter:\n    - scenario (str): Nama peserta yang diuji sebagai pelaku potensial.\n    - liar_count (set): Satu set nama peserta yang diasumsikan sebagai pembohong.\n    - statements (dict): Sebuah kamus yang memetakan nama peserta ke daftar pernyataan mereka masing-masing.\n    - days_of_week (set): Satu set string yang mewakili hari-hari dalam seminggu.\n\n    Mengembalikan:\n    - bool: True jika skenario konsisten dengan pernyataan, False jika tidak.\n\n    Kasus Uji:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    ", "ja": "    ある参加者が犯罪者であるというシナリオの一貫性を、与えられた証言に基づいて評価します。\n\n    この関数は、潜在的な犯罪者の名前（シナリオ）と嘘つきの集合（liar_count）を受け取り、\n    すべての参加者によってなされた証言がこのシナリオと一致するかどうかを確認します。\n    曜日に関する証言は無視されます。\n\n    パラメータ:\n    - scenario (str): 潜在的な犯罪者としてテストされている参加者の名前。\n    - liar_count (set): 嘘つきと仮定される参加者の名前の集合。\n    - statements (dict): 参加者の名前をそれぞれの証言のリストにマッピングする辞書。\n    - days_of_week (set): 曜日を表す文字列の集合。\n\n    戻り値:\n    - bool: シナリオが証言と一致する場合はTrue、一致しない場合はFalse。\n\n    テストケース:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "ko": "    주어진 진술에 기반하여 한 참가자가 범인인 시나리오의 일관성을 평가합니다.\n\n    이 함수는 잠재적 범인의 이름(시나리오)과 거짓말쟁이 집합(liar_count)을 받아\n    모든 참가자가 한 진술이 이 시나리오와 일관성이 있는지, 요일에 대한 진술은 무시하고 확인합니다.\n\n    매개변수:\n    - scenario (str): 잠재적 범인으로 테스트되는 참가자의 이름.\n    - liar_count (set): 거짓말쟁이로 가정되는 참가자들의 이름 집합.\n    - statements (dict): 참가자 이름을 그들의 각각의 진술 목록에 매핑한 사전.\n    - days_of_week (set): 요일을 나타내는 문자열 집합.\n\n    반환:\n    - bool: 시나리오가 진술과 일관성이 있으면 True, 그렇지 않으면 False.\n\n    테스트 케이스:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "ml": "    ഒരു പങ്കാളി കുറ്റവാളിയാണെന്ന സാഹചര്യത്തിന്റെ സ്ഥിരത നൽകിയ പ്രസ്താവനകളുടെ അടിസ്ഥാനത്തിൽ വിലയിരുത്തുന്നു.\n\n    ഈ ഫംഗ്ഷൻ ഒരു സാധ്യതയുള്ള കുറ്റവാളിയുടെ പേര് (scenario) കൂടാതെ ഒരു കള്ളന്മാരുടെ സെറ്റ് (liar_count) എടുത്ത്\n    എല്ലാ പങ്കാളികളും നടത്തിയ പ്രസ്താവനകൾ ഈ സാഹചര്യത്തോട് സ്ഥിരതയുള്ളതാണോ എന്ന് പരിശോധിക്കുന്നു, ആഴ്ചയുടെ ദിവസത്തെക്കുറിച്ചുള്ള\n    പ്രസ്താവനകൾ അവഗണിക്കുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    - scenario (str): സാധ്യതയുള്ള കുറ്റവാളിയായി പരിശോധിക്കുന്ന പങ്കാളിയുടെ പേര്.\n    - liar_count (set): കള്ളന്മാരാണെന്ന് കരുതുന്ന പങ്കാളികളുടെ പേരുകളുടെ ഒരു സെറ്റ്.\n    - statements (dict): പങ്കാളികളുടെ പേരുകളെ അവരുടെ പ്രസ്താവനകളുടെ പട്ടികയിലേക്ക് മാപ്പ് ചെയ്യുന്ന ഒരു നിഘണ്ടു.\n    - days_of_week (set): ആഴ്ചയിലെ ദിവസങ്ങളെ പ്രതിനിധീകരിക്കുന്ന സ്ട്രിംഗുകളുടെ ഒരു സെറ്റ്.\n\n    മടക്കങ്ങൾ:\n    - bool: ഈ സാഹചര്യവും പ്രസ്താവനകളും തമ്മിൽ സ്ഥിരതയുള്ളതാണെങ്കിൽ True, അല്ലെങ്കിൽ False.\n\n    പരീക്ഷണ കേസുകൾ:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True", "fa": "ارزیابی سازگاری یک سناریو که در آن یک شرکت‌کننده مجرم است بر اساس اظهارات داده شده.\n\nاین تابع نام یک مجرم بالقوه (scenario) و مجموعه‌ای از دروغگوها (liar_count) را می‌گیرد و بررسی می‌کند که آیا اظهاراتی که توسط همه شرکت‌کنندگان ارائه شده است با این سناریو سازگار هستند یا خیر، بدون توجه به اظهاراتی که درباره روز هفته است.\n\nپارامترها:\n- scenario (str): نام شرکت‌کننده‌ای که به عنوان مجرم بالقوه آزمایش می‌شود.\n- liar_count (set): مجموعه‌ای از نام‌های شرکت‌کنندگانی که فرض می‌شود دروغگو هستند.\n- statements (dict): یک دیکشنری که نام شرکت‌کنندگان را به لیست اظهارات مربوطه آنها نگاشت می‌کند.\n- days_of_week (set): مجموعه‌ای از رشته‌ها که روزهای هفته را نشان می‌دهند.\n\nبازگشت:\n- bool: True اگر سناریو با اظهارات سازگار باشد، در غیر این صورت False.\n\nموارد آزمون:\n>>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\nTrue"}}
{"task_id": "Python/33", "prompt": {"en": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "sq": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Llogarit rezultatin e një serie lojërash ping-pong bazuar në sistemin e dhënë të pikëve.\n\n    Kjo funksion merr sistemin e dëshiruar të pikëve (ose 11 ose 21 pikë) dhe një varg \n    që përfaqëson sekuencën e pikëve të fituara nga lojtari ('W') dhe kundërshtari ('L'). \n    Funksioni përpunon vargun dhe kthen një listë të rezultateve të lojërave të formatuara si \"rezultati_i_lojtari:rezultati_i_kundërshtarit\".\n\n    Loja konsiderohet e përfunduar kur një lojtar arrin numrin e kërkuar të pikëve të sistemit \n    (11 ose 21) me të paktën një avantazh prej 2 pikësh. Nëse sekuenca e pikëve përfundon në mes të një loje, \n    rezultati aktual i asaj loje gjithashtu përfshihet në rezultat.\n\n    Argumentet:\n    - system (int): Numri i pikëve të kërkuara për të fituar një lojë (ose 11 ose 21).\n    - points (str): Një varg me karaktere 'W' dhe 'L' që tregojnë pikët e fituara nga lojtari dhe kundërshtari.\n\n    Kthen:\n    - list: Një listë me vargje që përfaqësojnë rezultatin e secilës lojë.\n\n    Rastet:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "hy": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Հաշվարկել սեղանի թենիսի խաղերի մի շարքերի միավորները՝ հիմնված տրամադրված միավորների համակարգի վրա։\n\n    Այս ֆունկցիան ընդունում է ցանկալի միավորների համակարգը (կամ 11 կամ 21 միավոր) և տող, \n    որը ներկայացնում է խաղացողի ('W') և հակառակորդի ('L') շահած միավորների հաջորդականությունը։ \n    Ֆունկցիան մշակում է տողը և վերադարձնում խաղերի միավորների ցուցակ՝ ձևաչափված որպես \"խաղացողի_միավոր:հակառակորդի_միավոր\"։\n\n    Խաղը համարվում է ավարտված, երբ մի խաղացող հասնում է համակարգի պահանջվող միավորների քանակին \n    (11 կամ 21) առնվազն 2 միավորի առավելությամբ։ Եթե միավորների հաջորդականությունը ավարտվում է խաղի կեսին, \n    այդ խաղի ընթացիկ միավորն էլ ներառվում է արդյունքի մեջ։\n\n    Պարամետրեր:\n    - system (int): Խաղը շահելու համար պահանջվող միավորների քանակը (կամ 11 կամ 21)։\n    - points (str): 'W' և 'L' տառերի տող, որը նշում է խաղացողի և հակառակորդի շահած միավորները։\n\n    Վերադարձնում է:\n    - list: Տողերի ցուցակ, որը ներկայացնում է յուրաքանչյուր խաղի միավորը։\n\n    Օրինակներ:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "bn": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    প্রদত্ত স্কোরিং সিস্টেমের ভিত্তিতে পিং-পং গেমগুলোর একটি সিরিজের স্কোর গণনা করুন।\n\n    এই ফাংশনটি পছন্দের স্কোরিং সিস্টেম (১১ বা ২১ পয়েন্ট) এবং একটি স্ট্রিং নেয় \n    যা খেলোয়াড় ('W') এবং প্রতিপক্ষ ('L') দ্বারা জেতা পয়েন্টগুলির ক্রম উপস্থাপন করে। \n    ফাংশনটি স্ট্রিং প্রক্রিয়া করে এবং গেম স্কোরের একটি তালিকা ফেরত দেয় যা \"player_score:opponent_score\" \n    হিসাবে ফরম্যাট করা হয়।\n\n    যখন একজন খেলোয়াড় সিস্টেমের প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১) কমপক্ষে ২ পয়েন্টের \n    ব্যবধানে পৌঁছে যায়, তখন গেমটি শেষ হয়েছে বলে বিবেচিত হয়। যদি পয়েন্টের ক্রম একটি গেমের \n    মাঝখানে শেষ হয়, সেই গেমের বর্তমান স্কোরও আউটপুটে অন্তর্ভুক্ত করা হয়।\n\n    আর্গুমেন্টস:\n    - system (int): একটি গেম জিততে প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১ এর মধ্যে একটি)।\n    - points (str): 'W' এবং 'L' অক্ষরের একটি স্ট্রিং যা খেলোয়াড় এবং প্রতিপক্ষ দ্বারা জেতা পয়েন্টগুলি নির্দেশ করে।\n\n    রিটার্নস:\n    - list: প্রতিটি গেমের স্কোর উপস্থাপনকারী স্ট্রিংগুলির একটি তালিকা।\n\n    উদাহরণ:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "bg": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Изчисляване на резултата от серия пинг-понг игри въз основа на предоставената система за точкуване.\n\n    Тази функция приема желаната система за точкуване (или 11, или 21 точки) и низ, \n    представляващ последователността от точки, спечелени от играча ('W') и опонента ('L'). \n    Функцията обработва низа и връща списък с резултати от игрите, форматирани като \"player_score:opponent_score\".\n\n    Играта се счита за завършена, когато един играч достигне необходимия брой точки според системата \n    (11 или 21) с поне 2 точки преднина. Ако последователността от точки завърши в средата на игра, \n    текущият резултат от тази игра също се включва в изхода.\n\n    Аргументи:\n    - system (int): Броят точки, необходими за спечелване на игра (или 11, или 21).\n    - points (str): Низ от символи 'W' и 'L', обозначаващи точки, спечелени от играча и опонента.\n\n    Връща:\n    - list: Списък от низове, представляващи резултата от всяка игра.\n\n    Примери:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "zh": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    根据提供的计分系统计算一系列乒乓球比赛的得分。\n\n    该函数接受所需的计分系统（11分或21分）和一个字符串，\n    该字符串表示玩家（'W'）和对手（'L'）赢得的分数序列。\n    该函数处理字符串并返回格式为 \"player_score:opponent_score\" 的比赛得分列表。\n\n    当一名玩家以至少2分的领先优势达到系统要求的分数（11或21分）时，比赛被视为结束。\n    如果分数序列在比赛中途结束，则该场比赛的当前得分也会包含在输出中。\n\n    参数:\n    - system (int): 赢得比赛所需的分数（11或21分）。\n    - points (str): 一个由 'W' 和 'L' 字符组成的字符串，表示玩家和对手赢得的分数。\n\n    返回:\n    - list: 表示每场比赛得分的字符串列表。\n\n    示例:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "fr": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculer le score d'une série de matchs de ping-pong en fonction du système de score fourni.\n\n    Cette fonction prend en entrée le système de score souhaité (soit 11 ou 21 points) et une chaîne \n    représentant la séquence de points gagnés par le joueur ('W') et l'adversaire ('L').\n    La fonction traite la chaîne et renvoie une liste de scores de match formatés comme \"player_score:opponent_score\".\n\n    Le match est considéré comme terminé lorsqu'un joueur atteint le nombre de points requis par le système \n    (11 ou 21) avec au moins 2 points d'avance. Si la séquence de points se termine au milieu d'un match, \n    le score actuel de ce match est également inclus dans le résultat.\n\n    Arguments:\n    - system (int): Le nombre de points requis pour gagner un match (soit 11 ou 21).\n    - points (str): Une chaîne de caractères 'W' et 'L' indiquant les points gagnés par le joueur et l'adversaire.\n\n    Renvoie:\n    - list: Une liste de chaînes représentant le score de chaque match.\n\n    Cas:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "de": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Berechne die Punktzahl einer Reihe von Tischtennisspielen basierend auf dem bereitgestellten Punktesystem.\n\n    Diese Funktion nimmt das gewünschte Punktesystem (entweder 11 oder 21 Punkte) und einen String, \n    der die Abfolge der vom Spieler ('W') und vom Gegner ('L') gewonnenen Punkte darstellt, entgegen. \n    Die Funktion verarbeitet den String und gibt eine Liste von Spielergebnissen im Format \"player_score:opponent_score\" zurück.\n\n    Das Spiel gilt als beendet, wenn ein Spieler die erforderliche Punktzahl des Systems erreicht \n    (11 oder 21) und mindestens einen Vorsprung von 2 Punkten hat. Wenn die Punktfolge mitten in einem Spiel endet, \n    wird der aktuelle Spielstand dieses Spiels ebenfalls in der Ausgabe enthalten.\n\n    Argumente:\n    - system (int): Die Anzahl der Punkte, die erforderlich sind, um ein Spiel zu gewinnen (entweder 11 oder 21).\n    - points (str): Ein String aus 'W'- und 'L'-Zeichen, die die vom Spieler und Gegner gewonnenen Punkte anzeigen.\n\n    Rückgabe:\n    - list: Eine Liste von Strings, die die Punktzahl jedes Spiels darstellen.\n\n    Fälle:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "ha": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Lissafa maki na jerin wasannin ping-pong bisa tsarin maki da aka bayar.\n\n    Wannan aikin yana karɓar tsarin maki da ake so (ko dai maki 11 ko 21) da kuma igiyar \n    haruffa da ke wakiltar jerin maki da ɗan wasa ('W') da abokin hamayya ('L') suka ci. \n    Aikin yana aiwatar da igiyar kuma yana dawo da jerin maki na wasanni da aka tsara a matsayin \"maki_dan_wasa:maki_abokin_hamayya\".\n\n    Ana ɗaukar wasan ya ƙare idan ɗan wasa ɗaya ya kai adadin maki da tsarin ya tanada \n    (11 ko 21) tare da tazarar maki 2 aƙalla. Idan jerin maki ya ƙare a tsakiyar wasa, \n    ana haɗa maki na wannan wasan a cikin sakamakon.\n\n    Args:\n    - system (int): Adadin maki da ake buƙata don cin nasara a wasa (ko dai 11 ko 21).\n    - points (str): Igiyar haruffa 'W' da 'L' da ke nuna maki da ɗan wasa da abokin hamayya suka ci.\n\n    Returns:\n    - list: Jerin igiyoyi da ke wakiltar maki na kowane wasa.\n\n    Misalai:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "hi": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    प्रदान की गई स्कोरिंग प्रणाली के आधार पर पिंग-पोंग खेलों की एक श्रृंखला का स्कोर गणना करें।\n\n    यह फ़ंक्शन वांछित स्कोरिंग प्रणाली (या तो 11 या 21 अंक) और एक स्ट्रिंग लेता है \n    जो खिलाड़ी ('W') और प्रतिद्वंद्वी ('L') द्वारा जीते गए अंकों के क्रम का प्रतिनिधित्व करता है। \n    फ़ंक्शन स्ट्रिंग को प्रोसेस करता है और गेम स्कोर की एक सूची लौटाता है जो \"player_score:opponent_score\" के रूप में स्वरूपित होती है।\n\n    खेल को समाप्त माना जाता है जब एक खिलाड़ी प्रणाली द्वारा आवश्यक अंकों की संख्या (11 या 21) \n    कम से कम 2 अंकों की बढ़त के साथ प्राप्त कर लेता है। यदि अंकों का क्रम खेल के बीच में समाप्त होता है, \n    तो उस खेल का वर्तमान स्कोर भी आउटपुट में शामिल किया जाता है।\n\n    तर्क:\n    - system (int): एक खेल जीतने के लिए आवश्यक अंकों की संख्या (या तो 11 या 21)।\n    - points (str): 'W' और 'L' वर्णों की एक स्ट्रिंग जो खिलाड़ी और प्रतिद्वंद्वी द्वारा जीते गए अंकों को दर्शाती है।\n\n    लौटाता है:\n    - list: प्रत्येक खेल के स्कोर का प्रतिनिधित्व करने वाली स्ट्रिंग्स की एक सूची।\n\n    उदाहरण:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "hu": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Számítsa ki egy sor pingpong játék pontszámát a megadott pontozási rendszer alapján.\n\n    Ez a függvény a kívánt pontozási rendszert (vagy 11 vagy 21 pont) és egy karakterláncot vesz fel, \n    amely a játékos ('W') és az ellenfél ('L') által nyert pontok sorozatát ábrázolja. \n    A függvény feldolgozza a karakterláncot, és visszaad egy listát a játék pontszámokkal, \n    amelyek \"játékos_pontszám:ellenfél_pontszám\" formátumban vannak.\n\n    A játék akkor tekinthető befejezettnek, amikor az egyik játékos eléri a rendszer által \n    megkövetelt pontszámot (11 vagy 21) legalább 2 pontos előnnyel. Ha a pontok sorozata \n    egy játék közepén ér véget, akkor annak a játéknak az aktuális pontszáma is szerepel a kimenetben.\n\n    Paraméterek:\n    - system (int): A játék megnyeréséhez szükséges pontok száma (vagy 11 vagy 21).\n    - points (str): Egy 'W' és 'L' karakterekből álló karakterlánc, amely a játékos és az ellenfél által nyert pontokat jelöli.\n\n    Visszatér:\n    - list: Egy karakterláncokból álló lista, amely az egyes játékok pontszámát ábrázolja.\n\n    Esetek:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "es": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calcula el puntaje de una serie de juegos de ping-pong basado en el sistema de puntuación proporcionado.\n\n    Esta función toma el sistema de puntuación deseado (ya sea 11 o 21 puntos) y una cadena \n    que representa la secuencia de puntos ganados por el jugador ('W') y el oponente ('L'). \n    La función procesa la cadena y devuelve una lista de puntuaciones de los juegos formateadas como \"player_score:opponent_score\".\n\n    El juego se considera terminado cuando un jugador alcanza el número de puntos requerido por el sistema \n    (11 o 21) con al menos una ventaja de 2 puntos. Si la secuencia de puntos termina en medio de un juego, \n    la puntuación actual de ese juego también se incluye en la salida.\n\n    Argumentos:\n    - system (int): El número de puntos requeridos para ganar un juego (ya sea 11 o 21).\n    - points (str): Una cadena de caracteres 'W' y 'L' que denotan puntos ganados por el jugador y el oponente.\n\n    Devuelve:\n    - list: Una lista de cadenas que representan la puntuación de cada juego.\n\n    Casos:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "arb": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    حساب النتيجة لسلسلة من مباريات كرة الطاولة بناءً على نظام النقاط المقدم.\n\n    تأخذ هذه الدالة نظام النقاط المطلوب (إما 11 أو 21 نقطة) وسلسلة تمثل تسلسل النقاط \n    التي فاز بها اللاعب ('W') والمنافس ('L'). تقوم الدالة بمعالجة السلسلة وتعيد قائمة \n    بنتائج المباريات بصيغة \"player_score:opponent_score\".\n\n    تعتبر اللعبة منتهية عندما يصل أحد اللاعبين إلى العدد المطلوب من النقاط \n    (11 أو 21) بفارق نقطتين على الأقل. إذا انتهى تسلسل النقاط في منتصف اللعبة، \n    يتم تضمين النتيجة الحالية لتلك اللعبة في المخرجات أيضًا.\n\n    يعيدالحجج:\n    - system (int): عدد النقاط المطلوبة للفوز باللعبة (إما 11 أو 21).\n    - points (str): سلسلة من الأحرف 'W' و 'L' تشير إلى النقاط التي فاز بها اللاعب والمنافس.\n\n    يعيد:\n    - list: قائمة من السلاسل تمثل نتيجة كل لعبة.\n\n    حالات:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "sw": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Kuhesabu alama za mfululizo wa michezo ya ping-pong kulingana na mfumo wa alama uliotolewa.\n\n    Kazi hii inachukua mfumo wa alama unaotakiwa (ama pointi 11 au 21) na kamba \n    inayowakilisha mfululizo wa pointi zilizoshindwa na mchezaji ('W') na mpinzani ('L'). \n    Kazi hii inachakata kamba hiyo na kurudisha orodha ya alama za mchezo zilizopangwa kama \"alama_ya_mchezaji:alama_ya_mpinzani\".\n\n    Mchezo unachukuliwa kuwa umemalizika wakati mchezaji mmoja anafikia idadi ya pointi inayotakiwa na mfumo \n    (11 au 21) akiwa na uongozi wa angalau pointi 2. Ikiwa mfululizo wa pointi unamalizika katikati ya mchezo, \n    alama za mchezo huo pia zinajumuishwa katika matokeo.\n\n    Hoja:\n    - system (int): Idadi ya pointi zinazohitajika kushinda mchezo (ama 11 au 21).\n    - points (str): Kamba ya herufi 'W' na 'L' inayoashiria pointi zilizoshindwa na mchezaji na mpinzani.\n\n    Inarejesha:\n    - list: Orodha ya kamba zinazowakilisha alama za kila mchezo.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "tr": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Sağlanan puanlama sistemine göre bir dizi masa tenisi oyununun skorunu hesaplayın.\n\n    Bu fonksiyon, istenen puanlama sistemini (ya 11 ya da 21 puan) ve oyuncu ('W') ile rakibin ('L') \n    kazandığı puanların dizisini temsil eden bir dize alır. Fonksiyon diziyi işler ve oyun skorlarını \n    \"oyuncu_skoru:rakip_skoru\" formatında bir liste olarak döndürür.\n\n    Bir oyuncu, sistemin gerektirdiği puan sayısına (11 veya 21) en az 2 puan farkla ulaştığında oyun \n    bitmiş kabul edilir. Eğer puan dizisi bir oyunun ortasında sona ererse, o oyunun mevcut skoru da \n    çıktıya dahil edilir.\n\n    Argümanlar:\n    - system (int): Bir oyunu kazanmak için gereken puan sayısı (ya 11 ya da 21).\n    - points (str): Oyuncu ve rakibin kazandığı puanları belirten 'W' ve 'L' karakterlerinden oluşan bir dize.\n\n    Döndürür:\n    - list: Her oyunun skorunu temsil eden dizelerin bir listesi.\n\n    Durumlar:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "vi": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Tính điểm của một loạt các trận đấu bóng bàn dựa trên hệ thống tính điểm được cung cấp.\n\n    Hàm này nhận vào hệ thống tính điểm mong muốn (hoặc 11 hoặc 21 điểm) và một chuỗi \n    đại diện cho trình tự các điểm mà người chơi ('W') và đối thủ ('L') giành được. \n    Hàm xử lý chuỗi và trả về một danh sách các điểm số trận đấu được định dạng dưới dạng \"player_score:opponent_score\".\n\n    Trận đấu được coi là kết thúc khi một người chơi đạt đến số điểm yêu cầu của hệ thống \n    (11 hoặc 21) với ít nhất 2 điểm dẫn trước. Nếu chuỗi điểm kết thúc giữa chừng một trận đấu, \n    điểm số hiện tại của trận đấu đó cũng được bao gồm trong đầu ra.\n\n    Tham số:\n    - system (int): Số điểm cần thiết để thắng một trận đấu (hoặc 11 hoặc 21).\n    - points (str): Một chuỗi các ký tự 'W' và 'L' biểu thị các điểm mà người chơi và đối thủ giành được.\n\n    Trả về:\n    - list: Một danh sách các chuỗi đại diện cho điểm số của mỗi trận đấu.\n\n    Trường hợp:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "id": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Hitung skor dari serangkaian permainan ping-pong berdasarkan sistem penilaian yang diberikan.\n\n    Fungsi ini menerima sistem penilaian yang diinginkan (baik 11 atau 21 poin) dan sebuah string \n    yang mewakili urutan poin yang dimenangkan oleh pemain ('W') dan lawan ('L'). \n    Fungsi ini memproses string dan mengembalikan daftar skor permainan yang diformat sebagai \"player_score:opponent_score\".\n\n    Permainan dianggap selesai ketika satu pemain mencapai jumlah poin yang dibutuhkan oleh sistem \n    (11 atau 21) dengan keunggulan setidaknya 2 poin. Jika urutan poin berakhir di tengah permainan, \n    skor permainan saat itu juga disertakan dalam output.\n\n    Argumen:\n    - system (int): Jumlah poin yang dibutuhkan untuk memenangkan permainan (baik 11 atau 21).\n    - points (str): Sebuah string karakter 'W' dan 'L' yang menunjukkan poin yang dimenangkan oleh pemain dan lawan.\n\n    Mengembalikan:\n    - list: Daftar string yang mewakili skor setiap permainan.\n\n    Kasus:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "ja": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    提供されたスコアリングシステムに基づいて、ピンポンゲームの一連のスコアを計算します。\n\n    この関数は、希望するスコアリングシステム（11点または21点）と、プレイヤー（'W'）と対戦相手（'L'）が獲得したポイントのシーケンスを表す文字列を受け取ります。\n    関数は文字列を処理し、\"player_score:opponent_score\"という形式でゲームのスコアのリストを返します。\n\n    ゲームは、あるプレイヤーがシステムで要求されるポイント数（11または21）に少なくとも2ポイントのリードで到達したときに終了と見なされます。\n    ポイントのシーケンスがゲームの途中で終了した場合、そのゲームの現在のスコアも出力に含まれます。\n\n    引数:\n    - system (int): ゲームに勝つために必要なポイント数（11または21のいずれか）。\n    - points (str): プレイヤーと対戦相手が獲得したポイントを示す 'W' と 'L' の文字列。\n\n    戻り値:\n    - list: 各ゲームのスコアを表す文字列のリスト。\n\n    ケース:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "ko": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    제공된 점수 시스템을 기반으로 일련의 탁구 게임의 점수를 계산합니다.\n\n    이 함수는 원하는 점수 시스템(11점 또는 21점)과 플레이어('W')와 상대방('L')이 획득한 \n    점수를 나타내는 문자열을 입력받습니다. 함수는 문자열을 처리하고 \"player_score:opponent_score\" \n    형식으로 게임 점수 목록을 반환합니다.\n\n    한 플레이어가 시스템에서 요구하는 점수(11점 또는 21점)에 최소 2점 차이로 도달하면 \n    게임이 종료된 것으로 간주됩니다. 점수 시퀀스가 게임 중간에 끝나면, 그 게임의 현재 점수도 \n    출력에 포함됩니다.\n\n    매개변수:\n    - system (int): 게임에서 승리하기 위해 필요한 점수(11점 또는 21점).\n    - points (str): 플레이어와 상대방이 획득한 점수를 나타내는 'W'와 'L' 문자로 구성된 문자열.\n\n    반환값:\n    - list: 각 게임의 점수를 나타내는 문자열 목록.\n\n    예시:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "ml": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    നൽകിയ സ്കോറിംഗ് സിസ്റ്റത്തെ അടിസ്ഥാനമാക്കി പിംഗ്-പോങ്ങ് കളികളുടെ ഒരു പരമ്പരയുടെ സ്കോർ കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ആവശ്യമായ സ്കോറിംഗ് സിസ്റ്റം (11 അല്ലെങ്കിൽ 21 പോയിന്റുകൾ) \n    കൂടാതെ കളിക്കാരൻ ('W') \n    എതിരാളി ('L') നേടിയ പോയിന്റുകളുടെ ക്രമം പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് \n    സ്വീകരിക്കുന്നു. ഫംഗ്ഷൻ സ്ട്രിംഗ് പ്രോസസ്സ് ചെയ്ത് \n    \"player_score:opponent_score\" എന്ന ഫോർമാറ്റിലുള്ള ഗെയിം സ്കോറുകളുടെ \n    ഒരു പട്ടിക തിരികെ നൽകുന്നു.\n\n    ഒരു കളിക്കാരൻ കുറഞ്ഞത് 2-പോയിന്റ് ലീഡോടെ സിസ്റ്റത്തിന്റെ ആവശ്യമായ \n    പോയിന്റുകളുടെ എണ്ണം (11 അല്ലെങ്കിൽ 21) എത്തുമ്പോൾ \n    ഗെയിം പൂർത്തിയായി എന്ന് കണക്കാക്കുന്നു. പോയിന്റുകളുടെ \n    പരമ്പര ഒരു ഗെയിമിന്റെ മധ്യത്തിൽ അവസാനിക്കുന്നുവെങ്കിൽ, \n    ആ ഗെയിമിന്റെ നിലവിലെ സ്കോർ ഔട്ട്പുട്ടിൽ ഉൾപ്പെടുത്തുകയും ചെയ്യുന്നു.\n\n    Args:\n    - system (int): ഒരു ഗെയിം ജയിക്കാൻ ആവശ്യമായ പോയിന്റുകളുടെ എണ്ണം (11 അല്ലെങ്കിൽ 21).\n    - points (str): കളിക്കാരനും എതിരാളിയും നേടിയ പോയിന്റുകൾ സൂചിപ്പിക്കുന്ന 'W' \n      കൂടാതെ 'L' പ്രതീകങ്ങളുള്ള ഒരു സ്ട്രിംഗ്.\n\n    Returns:\n    - list: ഓരോ ഗെയിമിന്റെയും സ്കോർ പ്രതിനിധീകരിക്കുന്ന സ്ട്രിംഗുകളുടെ ഒരു പട്ടിക.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"", "fa": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    امتیاز یک سری بازی پینگ‌پنگ را بر اساس سیستم امتیازدهی ارائه شده محاسبه کنید.\n\n    این تابع سیستم امتیازدهی مورد نظر (یا 11 یا 21 امتیاز) و یک رشته که \n    توالی امتیازات برنده شده توسط بازیکن ('W') و حریف ('L') را نشان می‌دهد، می‌گیرد. \n    تابع رشته را پردازش کرده و لیستی از امتیازات بازی‌ها را به صورت \"player_score:opponent_score\" برمی‌گرداند.\n\n    بازی زمانی تمام شده در نظر گرفته می‌شود که یکی از بازیکنان به تعداد امتیاز مورد نیاز سیستم \n    (11 یا 21) با حداقل 2 امتیاز برتری برسد. اگر توالی امتیازات در وسط یک بازی به پایان برسد، \n    امتیاز فعلی آن بازی نیز در خروجی گنجانده می‌شود.\n\n    آرگومان‌ها:\n    - system (int): تعداد امتیاز مورد نیاز برای برنده شدن در یک بازی (یا 11 یا 21).\n    - points (str): رشته‌ای از کاراکترهای 'W' و 'L' که امتیازات برنده شده توسط بازیکن و حریف را نشان می‌دهد.\n\n    بازگشت‌ها:\n    - list: لیستی از رشته‌ها که امتیاز هر بازی را نشان می‌دهد.\n\n    موارد:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\""}, "canonical_solution": "    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores", "instruction": {"en": "Write a python function 'def calculate_score(system: int, points: str) -> list:' to solve the following problem:\n\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    ", "sq": "Shkruani një funksion python 'def calculate_score(system: int, points: str) -> list:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni rezultatin e një serie lojërash ping-pong bazuar në sistemin e dhënë të pikëve.\n\n    Kjo funksion merr sistemin e dëshiruar të pikëve (ose 11 ose 21 pikë) dhe një varg \n    që përfaqëson sekuencën e pikëve të fituara nga lojtari ('W') dhe kundërshtari ('L'). \n    Funksioni përpunon vargun dhe kthen një listë të rezultateve të lojërave të formatuara si \"player_score:opponent_score\".\n\n    Loja konsiderohet e përfunduar kur një lojtar arrin numrin e kërkuar të pikëve të sistemit \n    (11 ose 21) me të paktën një epërsi prej 2 pikësh. Nëse sekuenca e pikëve përfundon në mes të një loje, \n    rezultati aktual i asaj loje përfshihet gjithashtu në rezultat.\n\n    Args:\n    - system (int): Numri i pikëve të nevojshme për të fituar një lojë (ose 11 ose 21).\n    - points (str): Një varg me karaktere 'W' dhe 'L' që tregojnë pikët e fituara nga lojtari dhe kundërshtari.\n\n    Returns:\n    - list: Një listë e vargjeve që përfaqësojnë rezultatin e secilës lojë.\n\n    Rastet:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "hy": "Պայթոն ֆունկցիա 'def calculate_score(system: int, points: str) -> list:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել սերիական պինգ-պոնգ խաղերի հաշիվը՝ հիմնվելով տրամադրված միավորների համակարգի վրա։\n\n    Այս ֆունկցիան ընդունում է ցանկալի միավորների համակարգը (կամ 11 կամ 21 միավոր) և տող, \n    որը ներկայացնում է խաղացողի ('W') և մրցակցի ('L') կողմից շահած միավորների հաջորդականությունը։ \n    Ֆունկցիան մշակում է տողը և վերադարձնում խաղերի հաշիվների ցանկը, ձևաչափված որպես \"player_score:opponent_score\"։\n\n    Խաղը համարվում է ավարտված, երբ մեկ խաղացող հասնում է համակարգի պահանջվող միավորների քանակին \n    (11 կամ 21) առնվազն 2 միավորի առավելությամբ։ Եթե միավորների հաջորդականությունը ավարտվում է խաղի կեսին, \n    այդ խաղի ընթացիկ հաշիվը նույնպես ներառվում է արդյունքի մեջ։\n\n    Արգումենտներ:\n    - system (int): Խաղը հաղթելու համար պահանջվող միավորների քանակը (կամ 11 կամ 21)։\n    - points (str): 'W' և 'L' նիշերի տող, որը նշում է խաղացողի և մրցակցի կողմից շահած միավորները։\n\n    Վերադարձնում է:\n    - list: Տողերի ցանկ, որը ներկայացնում է յուրաքանչյուր խաղի հաշիվը։\n\n    Դեպքեր:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "bn": "একটি পাইথন ফাংশন 'def calculate_score(system: int, points: str) -> list:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত স্কোরিং সিস্টেমের উপর ভিত্তি করে একটি সিরিজ পিং-পং গেমের স্কোর গণনা করুন।\n\n    এই ফাংশনটি কাঙ্ক্ষিত স্কোরিং সিস্টেম (১১ অথবা ২১ পয়েন্ট) এবং একটি স্ট্রিং গ্রহণ করে \n    যা খেলোয়াড় ('W') এবং প্রতিপক্ষ ('L') দ্বারা জয়ী পয়েন্টগুলির ক্রমকে উপস্থাপন করে। \n    ফাংশনটি স্ট্রিংটি প্রক্রিয়া করে এবং \"player_score:opponent_score\" ফরম্যাটে গেমের স্কোরের একটি তালিকা প্রদান করে।\n\n    গেমটি শেষ হয়েছে বলে বিবেচিত হয় যখন একজন খেলোয়াড় সিস্টেমের প্রয়োজনীয় পয়েন্ট সংখ্যা \n    (১১ অথবা ২১) কমপক্ষে ২ পয়েন্টের লিড সহ পৌঁছে যায়। যদি পয়েন্টের ক্রমটি একটি গেমের মাঝখানে শেষ হয়, \n    তবে সেই গেমের বর্তমান স্কোরও আউটপুটে অন্তর্ভুক্ত করা হয়।\n\n    আর্গুমেন্ট:\n    - system (int): একটি গেম জিততে প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ অথবা ২১)।\n    - points (str): খেলোয়াড় এবং প্রতিপক্ষ দ্বারা জয়ী পয়েন্টগুলি নির্দেশ করে 'W' এবং 'L' অক্ষরের একটি স্ট্রিং।\n\n    রিটার্ন:\n    - list: প্রতিটি গেমের স্কোর উপস্থাপনকারী স্ট্রিংগুলির একটি তালিকা।\n\n    কেস:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "bg": "Напишете Python функция 'def calculate_score(system: int, points: str) -> list:' за решаване на следния проблем:\n\n    Изчислете резултата от серия пинг-понг игри на базата на предоставената система за точкуване.\n\n    Тази функция приема желаната система за точкуване (или 11, или 21 точки) и низ, \n    представляващ последователността от точки, спечелени от играча ('W') и противника ('L'). \n    Функцията обработва низа и връща списък от резултати на игрите, форматирани като \"player_score:opponent_score\".\n\n    Играта се счита за завършена, когато един играч достигне изисквания брой точки на системата \n    (11 или 21) с поне 2 точки преднина. Ако последователността от точки свършва в средата на игра, \n    текущият резултат на тази игра също е включен в изхода.\n\n    Аргументи:\n    - system (int): Броят точки, необходими за спечелване на игра (или 11, или 21).\n    - points (str): Низ от символи 'W' и 'L', обозначаващи точките, спечелени от играча и противника.\n\n    Връща:\n    - list: Списък от низове, представляващи резултата от всяка игра.\n\n    Примери:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "zh": "编写一个 Python 函数 'def calculate_score(system: int, points: str) -> list:' 来解决以下问题：\n\n    根据提供的计分系统计算一系列乒乓球比赛的得分。\n\n    此函数接受所需的计分系统（11或21分）和一个字符串，表示玩家（'W'）和对手（'L'）赢得的分数序列。\n    函数处理该字符串并返回一个游戏得分列表，格式为 \"player_score:opponent_score\"。\n\n    当一名玩家达到系统要求的分数（11或21分）并至少领先2分时，比赛被认为结束。\n    如果分数序列在比赛中途结束，该场比赛的当前得分也会包含在输出中。\n\n    参数：\n    - system (int): 赢得比赛所需的分数（11或21）。\n    - points (str): 一个由 'W' 和 'L' 字符组成的字符串，表示玩家和对手赢得的分数。\n\n    返回：\n    - list: 一个字符串列表，表示每场比赛的得分。\n\n    示例：\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "fr": "Écrivez une fonction python 'def calculate_score(system: int, points: str) -> list:' pour résoudre le problème suivant :\n\n    Calculer le score d'une série de parties de ping-pong en fonction du système de score fourni.\n\n    Cette fonction prend en entrée le système de score souhaité (soit 11 ou 21 points) et une chaîne \n    représentant la séquence de points gagnés par le joueur ('W') et l'adversaire ('L'). \n    La fonction traite la chaîne et renvoie une liste de scores de jeu formatés comme \"player_score:opponent_score\".\n\n    Le jeu est considéré comme terminé lorsqu'un joueur atteint le nombre de points requis par le système \n    (11 ou 21) avec au moins 2 points d'avance. Si la séquence de points se termine au milieu d'un jeu, \n    le score actuel de ce jeu est également inclus dans la sortie.\n\n    Args:\n    - system (int): Le nombre de points requis pour gagner un jeu (soit 11 ou 21).\n    - points (str): Une chaîne de caractères 'W' et 'L' indiquant les points gagnés par le joueur et l'adversaire.\n\n    Returns:\n    - list: Une liste de chaînes représentant le score de chaque jeu.\n\n    Cas:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "de": "Schreiben Sie eine Python-Funktion 'def calculate_score(system: int, points: str) -> list:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die Punktzahl einer Reihe von Tischtennisspielen basierend auf dem bereitgestellten Punktesystem.\n\n    Diese Funktion nimmt das gewünschte Punktesystem (entweder 11 oder 21 Punkte) und einen String \n    entgegen, der die Abfolge der vom Spieler ('W') und vom Gegner ('L') gewonnenen Punkte darstellt. \n    Die Funktion verarbeitet den String und gibt eine Liste von Spielständen im Format \"player_score:opponent_score\" zurück.\n\n    Das Spiel gilt als beendet, wenn ein Spieler die erforderliche Punktzahl des Systems erreicht \n    (11 oder 21) und dabei mindestens 2 Punkte Vorsprung hat. Wenn die Punktesequenz mitten in einem Spiel endet, \n    wird der aktuelle Spielstand ebenfalls in die Ausgabe aufgenommen.\n\n    Argumente:\n    - system (int): Die Anzahl der Punkte, die erforderlich sind, um ein Spiel zu gewinnen (entweder 11 oder 21).\n    - points (str): Ein String aus 'W'- und 'L'-Zeichen, die die vom Spieler und Gegner gewonnenen Punkte anzeigen.\n\n    Rückgabe:\n    - list: Eine Liste von Strings, die die Punktzahl jedes Spiels darstellen.\n\n    Fälle:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "ha": "Rubuta wani aikin python 'def calculate_score(system: int, points: str) -> list:' don warware matsalar mai zuwa:\n\n    Lissafa maki na jerin wasannin ping-pong bisa tsarin maki da aka bayar.\n\n    Wannan aikin yana karɓar tsarin maki da ake so (ko dai maki 11 ko 21) da kuma wani igiyar \n    da ke wakiltar jerin maki da ɗan wasa ('W') da abokin hamayya ('L') suka ci. \n    Aikin yana sarrafa igiyar kuma yana mayar da jerin maki na wasanni da aka tsara a matsayin \"player_score:opponent_score\".\n\n    Ana ɗaukar wasan ya ƙare lokacin da ɗan wasa ɗaya ya kai adadin maki da tsarin ya buƙata \n    (11 ko 21) tare da akalla tazarar maki 2. Idan jerin maki ya ƙare a tsakiyar wasa, \n    ana haɗa maki na yanzu na wannan wasan a cikin fitarwa.\n\n    Args:\n    - system (int): Adadin maki da ake buƙata don cin nasara a wasa (ko dai 11 ko 21).\n    - points (str): Igiyar haruffa 'W' da 'L' da ke nuna maki da ɗan wasa da abokin hamayya suka ci.\n\n    Returns:\n    - list: Jerin igiyoyi da ke wakiltar maki na kowanne wasa.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "hi": "एक पायथन फ़ंक्शन 'def calculate_score(system: int, points: str) -> list:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए स्कोरिंग सिस्टम के आधार पर पिंग-पोंग खेलों की एक श्रृंखला का स्कोर गणना करें।\n\n    यह फ़ंक्शन वांछित स्कोरिंग सिस्टम (या तो 11 या 21 अंक) और एक स्ट्रिंग लेता है \n    जो खिलाड़ी ('W') और प्रतिद्वंद्वी ('L') द्वारा जीते गए अंकों के अनुक्रम का प्रतिनिधित्व करता है। \n    फ़ंक्शन स्ट्रिंग को प्रोसेस करता है और खेल स्कोर की एक सूची को \"player_score:opponent_score\" के रूप में स्वरूपित करके लौटाता है।\n\n    खेल को समाप्त माना जाता है जब एक खिलाड़ी सिस्टम द्वारा आवश्यक अंकों की संख्या (11 या 21) \n    कम से कम 2 अंकों की बढ़त के साथ प्राप्त कर लेता है। यदि अंकों का अनुक्रम खेल के बीच में समाप्त होता है, \n    तो उस खेल का वर्तमान स्कोर भी आउटपुट में शामिल किया जाता है।\n\n    तर्क:\n    - system (int): खेल जीतने के लिए आवश्यक अंकों की संख्या (या तो 11 या 21)।\n    - points (str): 'W' और 'L' वर्णों की एक स्ट्रिंग जो खिलाड़ी और प्रतिद्वंद्वी द्वारा जीते गए अंकों को दर्शाती है।\n\n    लौटाता है:\n    - list: प्रत्येक खेल के स्कोर का प्रतिनिधित्व करने वाली स्ट्रिंग्स की एक सूची।\n\n    मामले:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "hu": "Írj egy python függvényt 'def calculate_score(system: int, points: str) -> list:' a következő probléma megoldására:\n\n    Számítsd ki egy sorozat ping-pong játék eredményét a megadott pontozási rendszer alapján.\n\n    Ez a függvény a kívánt pontozási rendszert (vagy 11 vagy 21 pont) és egy karakterláncot \n    vesz át, amely a játékos ('W') és az ellenfél ('L') által nyert pontok sorrendjét ábrázolja. \n    A függvény feldolgozza a karakterláncot, és visszaad egy listát a játék eredményeivel, \n    \"player_score:opponent_score\" formátumban.\n\n    A játék befejezettnek tekinthető, amikor az egyik játékos eléri a rendszer által megkövetelt \n    pontszámot (11 vagy 21) legalább 2 pontos előnnyel. Ha a pontok sorrendje egy játék közepén ér véget, \n    akkor annak a játéknak az aktuális eredménye is szerepel a kimenetben.\n\n    Argok:\n    - system (int): A játék megnyeréséhez szükséges pontok száma (vagy 11 vagy 21).\n    - points (str): Egy 'W' és 'L' karakterekből álló karakterlánc, amely a játékos és az ellenfél által nyert pontokat jelöli.\n\n    Visszatér:\n    - list: Egy karakterláncokból álló lista, amely az egyes játékok eredményét ábrázolja.\n\n    Esetek:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "es": "Escribe una función de Python 'def calculate_score(system: int, points: str) -> list:' para resolver el siguiente problema:\n\n    Calcular la puntuación de una serie de juegos de ping-pong basados en el sistema de puntuación proporcionado.\n\n    Esta función recibe el sistema de puntuación deseado (ya sea 11 o 21 puntos) y una cadena \n    que representa la secuencia de puntos ganados por el jugador ('W') y el oponente ('L'). \n    La función procesa la cadena y devuelve una lista de puntuaciones de los juegos formateadas como \"player_score:opponent_score\".\n\n    El juego se considera terminado cuando un jugador alcanza el número de puntos requerido por el sistema \n    (11 o 21) con al menos una ventaja de 2 puntos. Si la secuencia de puntos termina en medio de un juego, \n    la puntuación actual de ese juego también se incluye en la salida.\n\n    Argumentos:\n    - system (int): El número de puntos requeridos para ganar un juego (ya sea 11 o 21).\n    - points (str): Una cadena de caracteres 'W' y 'L' que denotan puntos ganados por el jugador y el oponente.\n\n    Devuelve:\n    - list: Una lista de cadenas que representan la puntuación de cada juego.\n\n    Casos:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "arb": "اكتب دالة بايثون 'def calculate_score(system: int, points: str) -> list:' لحل المشكلة التالية:\n\n    حساب النتيجة لسلسلة من مباريات تنس الطاولة بناءً على نظام التسجيل المقدم.\n\n    تأخذ هذه الدالة نظام التسجيل المطلوب (إما 11 أو 21 نقطة) وسلسلة تمثل تسلسل النقاط التي فاز بها اللاعب ('W') والمنافس ('L'). \n    تقوم الدالة بمعالجة السلسلة وتعيد قائمة بنتائج المباريات بتنسيق \"player_score:opponent_score\".\n\n    تعتبر اللعبة منتهية عندما يصل أحد اللاعبين إلى العدد المطلوب من النقاط في النظام \n    (11 أو 21) مع تقدم لا يقل عن نقطتين. إذا انتهى تسلسل النقاط في منتصف اللعبة، \n    يتم تضمين النتيجة الحالية لتلك اللعبة أيضًا في المخرجات.\n\n    يعيدالحجج:\n    - system (int): عدد النقاط المطلوبة للفوز باللعبة (إما 11 أو 21).\n    - points (str): سلسلة من الأحرف 'W' و 'L' تشير إلى النقاط التي فاز بها اللاعب والمنافس.\n\n    يعيد:\n    - list: قائمة من السلاسل تمثل نتيجة كل لعبة.\n\n    حالات:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "sw": "Andika kazi ya python 'def calculate_score(system: int, points: str) -> list:' kutatua tatizo lifuatalo:\n\n    Hesabu alama za mfululizo wa michezo ya ping-pong kulingana na mfumo wa alama uliotolewa.\n\n    Kazi hii inachukua mfumo wa alama unaotakiwa (ama pointi 11 au 21) na kamba \n    inayowakilisha mfululizo wa pointi zilizoshindwa na mchezaji ('W') na mpinzani ('L'). \n    Kazi hii inachakata kamba na kurudisha orodha ya alama za mchezo zilizopangwa kama \"alama_ya_mchezaji:alama_ya_mpinzani\".\n\n    Mchezo unachukuliwa kuwa umemalizika wakati mchezaji mmoja anafikia idadi ya pointi inayohitajika na mfumo \n    (11 au 21) akiwa na uongozi wa angalau pointi 2. Ikiwa mfululizo wa pointi unamalizika katikati ya mchezo, \n    alama za mchezo huo pia zinajumuishwa katika matokeo.\n\n    Hoja:\n    - system (int): Idadi ya pointi zinazohitajika kushinda mchezo (ama 11 au 21).\n    - points (str): Kamba ya herufi 'W' na 'L' inayoashiria pointi zilizoshindwa na mchezaji na mpinzani.\n\n    Inarejesha:\n    - list: Orodha ya kamba zinazowakilisha alama za kila mchezo.\n\n    Matukio:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "tr": "Bir python fonksiyonu 'def calculate_score(system: int, points: str) -> list:' aşağıdaki problemi çözmek için yazın:\n\n    Sağlanan puanlama sistemine göre bir dizi masa tenisi oyununun skorunu hesaplayın.\n\n    Bu fonksiyon, istenen puanlama sistemini (ya 11 ya da 21 puan) ve oyuncu ('W') ile rakibin ('L') \n    kazandığı puanların dizisini temsil eden bir dize alır. Fonksiyon diziyi işler ve \"oyuncu_skoru:rakip_skoru\" \n    formatında oyun skorlarının bir listesini döndürür.\n\n    Bir oyuncu, sistemin gerektirdiği puan sayısına (11 veya 21) en az 2 puan farkla ulaştığında oyun bitmiş sayılır. \n    Eğer puan dizisi bir oyunun ortasında sona ererse, o oyunun mevcut skoru da çıktıya dahil edilir.\n\n    Argümanlar:\n    - system (int): Bir oyunu kazanmak için gereken puan sayısı (ya 11 ya da 21).\n    - points (str): Oyuncu ve rakibin kazandığı puanları belirten 'W' ve 'L' karakterlerinden oluşan bir dize.\n\n    Döndürür:\n    - list: Her oyunun skorunu temsil eden dizelerin bir listesi.\n\n    Durumlar:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "vi": "Viết một hàm python 'def calculate_score(system: int, points: str) -> list:' để giải quyết vấn đề sau:\n\n    Tính điểm của một loạt các trận đấu bóng bàn dựa trên hệ thống tính điểm được cung cấp.\n\n    Hàm này nhận vào hệ thống tính điểm mong muốn (hoặc 11 hoặc 21 điểm) và một chuỗi \n    đại diện cho chuỗi điểm mà người chơi ('W') và đối thủ ('L') giành được. \n    Hàm xử lý chuỗi và trả về một danh sách các điểm số trận đấu được định dạng dưới dạng \"player_score:opponent_score\".\n\n    Trận đấu được coi là kết thúc khi một người chơi đạt đến số điểm yêu cầu của hệ thống \n    (11 hoặc 21) với ít nhất 2 điểm dẫn trước. Nếu chuỗi điểm kết thúc giữa chừng một trận đấu, \n    điểm số hiện tại của trận đấu đó cũng được bao gồm trong kết quả đầu ra.\n\n    Tham số:\n    - system (int): Số điểm cần thiết để thắng một trận đấu (hoặc 11 hoặc 21).\n    - points (str): Một chuỗi các ký tự 'W' và 'L' biểu thị điểm mà người chơi và đối thủ giành được.\n\n    Trả về:\n    - list: Một danh sách các chuỗi đại diện cho điểm số của mỗi trận đấu.\n\n    Trường hợp:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "id": "Tulis sebuah fungsi python 'def calculate_score(system: int, points: str) -> list:' untuk menyelesaikan masalah berikut:\n\n    Hitung skor dari serangkaian permainan ping-pong berdasarkan sistem penilaian yang diberikan.\n\n    Fungsi ini menerima sistem penilaian yang diinginkan (baik 11 atau 21 poin) dan sebuah string \n    yang mewakili urutan poin yang dimenangkan oleh pemain ('W') dan lawan ('L'). \n    Fungsi memproses string tersebut dan mengembalikan daftar skor permainan yang diformat sebagai \"player_score:opponent_score\".\n\n    Permainan dianggap selesai ketika satu pemain mencapai jumlah poin yang dibutuhkan oleh sistem \n    (11 atau 21) dengan keunggulan setidaknya 2 poin. Jika urutan poin berakhir di tengah permainan, \n    skor permainan saat ini juga disertakan dalam output.\n\n    Args:\n    - system (int): Jumlah poin yang dibutuhkan untuk memenangkan permainan (baik 11 atau 21).\n    - points (str): Sebuah string dari karakter 'W' dan 'L' yang menunjukkan poin yang dimenangkan oleh pemain dan lawan.\n\n    Returns:\n    - list: Daftar string yang mewakili skor dari setiap permainan.\n\n    Kasus:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "ja": "Python関数 'def calculate_score(system: int, points: str) -> list:' を作成して、以下の問題を解決してください。\n\n    提供されたスコアリングシステムに基づいて、一連の卓球ゲームのスコアを計算します。\n\n    この関数は、希望するスコアリングシステム（11または21ポイント）と、プレイヤー（'W'）および相手（'L'）が獲得したポイントのシーケンスを表す文字列を受け取ります。 \n    関数は文字列を処理し、\"player_score:opponent_score\"の形式でゲームスコアのリストを返します。\n\n    ゲームは、1人のプレイヤーがシステムで要求されるポイント数（11または21）に少なくとも2ポイントのリードで到達したときに終了したと見なされます。 \n    ポイントのシーケンスがゲームの途中で終了した場合、そのゲームの現在のスコアも出力に含まれます。\n\n    引数:\n    - system (int): ゲームに勝つために必要なポイント数（11または21のいずれか）。\n    - points (str): プレイヤーと相手が獲得したポイントを示す'W'と'L'の文字列。\n\n    戻り値:\n    - list: 各ゲームのスコアを表す文字列のリスト。\n\n    ケース:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "ko": "파이썬 함수를 작성하세요 'def calculate_score(system: int, points: str) -> list:' 다음 문제를 해결하기 위해:\n\n    제공된 점수 시스템에 따라 일련의 탁구 게임의 점수를 계산합니다.\n\n    이 함수는 원하는 점수 시스템(11점 또는 21점)과 플레이어('W')와 상대방('L')이 획득한 점수의 \n    시퀀스를 나타내는 문자열을 입력으로 받습니다. 함수는 문자열을 처리하고 \"player_score:opponent_score\" 형식의 \n    게임 점수 목록을 반환합니다.\n\n    한 플레이어가 시스템에서 요구하는 점수(11 또는 21점)에 최소 2점 차이로 도달하면 게임이 종료된 것으로 간주됩니다. \n    점수 시퀀스가 게임 중간에 끝나면 해당 게임의 현재 점수도 출력에 포함됩니다.\n\n    인수:\n    - system (int): 게임에서 승리하기 위해 필요한 점수(11 또는 21 중 하나).\n    - points (str): 플레이어와 상대방이 획득한 점수를 나타내는 'W'와 'L' 문자로 이루어진 문자열.\n\n    반환:\n    - list: 각 게임의 점수를 나타내는 문자열 목록.\n\n    사례:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "ml": "ഒരു പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക 'def calculate_score(system: int, points: str) -> list:' താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    നൽകിയ സ്കോറിംഗ് സിസ്റ്റം അടിസ്ഥാനമാക്കി പിംഗ്-പോങ്ങ് ഗെയിമുകളുടെ ഒരു പരമ്പരയുടെ സ്കോർ കണക്കാക്കുക.\n\n    ഈ ഫങ്ഷൻ ആവശ്യമായ സ്കോറിംഗ് സിസ്റ്റം (11 അല്ലെങ്കിൽ 21 പോയിന്റുകൾ) \n    ഒരു സ്ട്രിംഗ് ആയി സ്വീകരിക്കുന്നു, അത് കളിക്കാരൻ ('W') \n    എതിരാളി ('L') നേടിയ പോയിന്റുകളുടെ ക്രമം പ്രതിനിധീകരിക്കുന്നു. \n    സ്ട്രിംഗ് പ്രോസസ്സ് ചെയ്ത് \"player_score:opponent_score\" എന്ന ഫോർമാറ്റിൽ \n    ഗെയിം സ്കോറുകളുടെ ഒരു ലിസ്റ്റ് ഫങ്ഷൻ തിരികെ നൽകുന്നു.\n\n    ഒരു കളിക്കാരൻ സിസ്റ്റത്തിന്റെ ആവശ്യമായ പോയിന്റുകളുടെ \n    എണ്ണം (11 അല്ലെങ്കിൽ 21) കുറഞ്ഞത് 2-പോയിന്റ് ലീഡ് \n    ഉള്ളപ്പോൾ ഗെയിം പൂർത്തിയായി എന്ന് കരുതുന്നു. പോയിന്റുകളുടെ \n    ക്രമം ഒരു ഗെയിമിന്റെ മധ്യത്തിൽ അവസാനിക്കുന്നുവെങ്കിൽ, \n    ആ ഗെയിമിന്റെ നിലവിലെ സ്കോർ ഔട്ട്പുട്ടിൽ ഉൾപ്പെടുത്തുന്നു.\n\n    Args:\n    - system (int): ഒരു ഗെയിം ജയിക്കാൻ ആവശ്യമായ പോയിന്റുകളുടെ എണ്ണം (11 അല്ലെങ്കിൽ 21).\n    - points (str): കളിക്കാരനും എതിരാളിയും നേടിയ പോയിന്റുകൾ സൂചിപ്പിക്കുന്ന 'W' \n      'L' പ്രതീകങ്ങളുടെ ഒരു സ്ട്രിംഗ്.\n\n    Returns:\n    - list: ഓരോ ഗെയിമിന്റെയും സ്കോർ പ്രതിനിധീകരിക്കുന്ന സ്ട്രിംഗുകളുടെ ഒരു ലിസ്റ്റ്.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "fa": "یک تابع پایتون 'def calculate_score(system: int, points: str) -> list:' بنویسید تا مسئله زیر را حل کند:\n\n    امتیاز یک سری بازی‌های پینگ‌پنگ را بر اساس سیستم امتیازدهی ارائه شده محاسبه کنید.\n\n    این تابع سیستم امتیازدهی مورد نظر (یا 11 یا 21 امتیاز) و یک رشته \n    که دنباله‌ای از امتیازات برده شده توسط بازیکن ('W') و حریف ('L') را نشان می‌دهد، می‌گیرد. \n    تابع رشته را پردازش کرده و لیستی از امتیازات بازی‌ها را به فرمت \"player_score:opponent_score\" برمی‌گرداند.\n\n    بازی زمانی تمام شده در نظر گرفته می‌شود که یک بازیکن به تعداد امتیاز مورد نیاز سیستم \n    (11 یا 21) با حداقل 2 امتیاز برتری برسد. اگر دنباله امتیازات در وسط یک بازی به پایان برسد، \n    امتیاز فعلی آن بازی نیز در خروجی گنجانده می‌شود.\n\n    آرگومان‌ها:\n    - system (int): تعداد امتیاز مورد نیاز برای بردن یک بازی (یا 11 یا 21).\n    - points (str): رشته‌ای از کاراکترهای 'W' و 'L' که امتیازات برده شده توسط بازیکن و حریف را نشان می‌دهد.\n\n    بازگشت:\n    - list: لیستی از رشته‌ها که امتیاز هر بازی را نشان می‌دهد.\n\n    موارد:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]"}, "level": "middle", "test": "def test_calculate_score():\n    # Test case 1: A single game in both systems, with a clear winner.\n    points = \"WWWWWWWWWWL\"\n    expected_11 = [\"10:1\"]\n    expected_21 = [\"10:1\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 1 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 1 (21-point) failed\"\n\n    # Test case 2: Multiple games, some completed and one in progress.\n    points = \"WWLWWLWWLWWLWE\"\n    expected_11 = [\"9:4\"]\n    expected_21 = [\"9:4\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 2 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 2 (21-point) failed\"\n\n    # Test case 3: A longer sequence with many games and a final unfinished game.\n    points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"\n    expected_11 = ['12:10', '5:4']\n    expected_21 = ['17:14']\n    assert calculate_score(11, points) == expected_11, \"Test case 3 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 3 (21-point) failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_calculate_score()", "entry_point": "calculate_score", "signature": "def calculate_score(system: int, points: str) -> list:", "docstring": {"en": "\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    ", "sq": "\n    Llogaritni rezultatin e një serie lojërash ping-pong bazuar në sistemin e dhënë të pikëve.\n\n    Kjo funksion merr sistemin e dëshiruar të pikëve (ose 11 ose 21 pikë) dhe një varg \n    që përfaqëson sekuencën e pikëve të fituara nga lojtari ('W') dhe kundërshtari ('L'). \n    Funksioni përpunon vargun dhe kthen një listë të rezultateve të lojërave të formatuara si \"rezultati_i_lojtari:rezultati_i_kundërshtari\".\n\n    Loja konsiderohet e përfunduar kur një lojtar arrin numrin e kërkuar të pikëve të sistemit \n    (11 ose 21) me të paktën një avantazh prej 2 pikësh. Nëse sekuenca e pikëve përfundon në mes të një loje, \n    rezultati aktual i asaj loje përfshihet gjithashtu në dalje.\n\n    Args:\n    - system (int): Numri i pikëve të kërkuara për të fituar një lojë (ose 11 ose 21).\n    - points (str): Një varg me karaktere 'W' dhe 'L' që tregojnë pikët e fituara nga lojtari dhe kundërshtari.\n\n    Returns:\n    - list: Një listë me vargje që përfaqësojnë rezultatin e secilës lojë.\n\n    Raste:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "hy": "\n    Հաշվեք սերիայի պինգ-պոնգ խաղերի միավորները ըստ տրված միավորների համակարգի:\n\n    Այս ֆունկցիան ընդունում է ցանկալի միավորների համակարգը (կամ 11 կամ 21 միավոր) և տող, \n    որը ներկայացնում է խաղացողի ('W') և հակառակորդի ('L') շահած միավորների հաջորդականությունը: \n    Ֆունկցիան մշակում է տողը և վերադարձնում խաղերի միավորների ցուցակը, ձևաչափված որպես \"խաղացողի_միավոր:հակառակորդի_միավոր\":\n\n    Խաղը համարվում է ավարտված, երբ խաղացողներից մեկը հասնում է համակարգի պահանջվող միավորների քանակին \n    (11 կամ 21) առնվազն 2 միավորի առավելությամբ: Եթե միավորների հաջորդականությունը ավարտվում է խաղի \n    ընթացքում, այդ խաղի ընթացիկ միավորն էլ ներառվում է արդյունքի մեջ:\n\n    Արգումենտներ:\n    - system (int): Խաղը հաղթելու համար պահանջվող միավորների քանակը (կամ 11 կամ 21):\n    - points (str): 'W' և 'L' տառերի տող, որը նշում է խաղացողի և հակառակորդի շահած միավորները:\n\n    Վերադարձնում է:\n    - list: Տողերի ցուցակ, որը ներկայացնում է յուրաքանչյուր խաղի միավորը:\n\n    Օրինակներ:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "bn": "\n    প্রদত্ত স্কোরিং সিস্টেমের ভিত্তিতে একাধিক পিং-পং গেমের স্কোর গণনা করুন।\n\n    এই ফাংশনটি কাঙ্ক্ষিত স্কোরিং সিস্টেম (১১ বা ২১ পয়েন্ট) এবং একটি স্ট্রিং গ্রহণ করে \n    যা খেলোয়াড় ('W') এবং প্রতিপক্ষ ('L') দ্বারা জিতেছে এমন পয়েন্টগুলির ক্রম উপস্থাপন করে। \n    ফাংশনটি স্ট্রিংটি প্রক্রিয়া করে এবং \"player_score:opponent_score\" হিসাবে ফরম্যাট করা গেম স্কোরের একটি তালিকা প্রদান করে।\n\n    যখন কোনো খেলোয়াড় সিস্টেমের প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১) কমপক্ষে ২-পয়েন্ট লিড সহ পৌঁছে যায়, \n    তখন গেমটি শেষ হয়েছে বলে বিবেচিত হয়। যদি পয়েন্টের ক্রম গেমের মাঝখানে শেষ হয়, \n    তাহলে সেই গেমের বর্তমান স্কোরও আউটপুটে অন্তর্ভুক্ত করা হয়।\n\n    আর্গুমেন্ট:\n    - system (int): একটি গেম জিততে প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১ এর মধ্যে একটি)।\n    - points (str): 'W' এবং 'L' অক্ষরের একটি স্ট্রিং যা খেলোয়াড় এবং প্রতিপক্ষ দ্বারা জিতেছে এমন পয়েন্টগুলি নির্দেশ করে।\n\n    রিটার্ন:\n    - list: প্রতিটি গেমের স্কোর উপস্থাপনকারী স্ট্রিংগুলির একটি তালিকা।\n\n    উদাহরণ:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "bg": "\n    Изчислете резултата от серия пинг-понг игри въз основа на предоставената система за точкуване.\n\n    Тази функция приема желаната система за точкуване (или 11, или 21 точки) и низ, \n    представляващ последователността от точки, спечелени от играча ('W') и противника ('L'). \n    Функцията обработва низа и връща списък с резултати от игрите, форматирани като \"резултат_на_играча:резултат_на_противника\".\n\n    Играта се счита за завършена, когато един играч достигне изисквания брой точки на системата \n    (11 или 21) с поне 2 точки преднина. Ако последователността от точки завърши в средата на игра, \n    текущият резултат на тази игра също се включва в изхода.\n\n    Аргументи:\n    - system (int): Броят точки, необходими за спечелване на игра (или 11, или 21).\n    - points (str): Низ от символи 'W' и 'L', обозначаващи точки, спечелени от играча и противника.\n\n    Връща:\n    - list: Списък от низове, представляващи резултата от всяка игра.\n\n    Примери:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "zh": "\n    根据提供的计分系统计算一系列乒乓球比赛的得分。\n\n    该函数接收所需的计分系统（11分或21分）和一个表示玩家（'W'）和对手（'L'）赢得的分数序列的字符串。\n    函数处理该字符串并返回格式为 \"player_score:opponent_score\" 的比赛得分列表。\n\n    当一名玩家达到系统要求的分数（11分或21分）并至少领先2分时，比赛被视为结束。\n    如果分数序列在比赛中途结束，该比赛的当前得分也将包含在输出中。\n\n    参数:\n    - system (int): 赢得比赛所需的分数（11分或21分）。\n    - points (str): 一个由 'W' 和 'L' 字符组成的字符串，表示玩家和对手赢得的分数。\n\n    返回:\n    - list: 表示每场比赛得分的字符串列表。\n\n    示例:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "fr": "\n    Calculer le score d'une série de matchs de ping-pong en fonction du système de score fourni.\n\nCette fonction prend en entrée le système de score souhaité (soit 11 ou 21 points) et une chaîne \nreprésentant la séquence de points gagnés par le joueur ('W') et l'adversaire ('L'). \nLa fonction traite la chaîne et renvoie une liste de scores de matchs formatés comme \"score_joueur:score_adversaire\".\n\nLe match est considéré comme terminé lorsqu'un joueur atteint le nombre de points requis par le système \n(11 ou 21) avec au moins 2 points d'avance. Si la séquence de points se termine au milieu d'un match, \nle score actuel de ce match est également inclus dans le résultat.\n\nArguments:\n- system (int): Le nombre de points requis pour gagner un match (soit 11 ou 21).\n- points (str): Une chaîne de caractères 'W' et 'L' indiquant les points gagnés par le joueur et l'adversaire.\n\nRenvoie:\n- list: Une liste de chaînes représentant le score de chaque match.\n\nCas:\n>>> calculate_score(11, \"WWWWWWWWWWL\")\n[\"10:1\"]", "de": "\n    Berechne die Punktzahl einer Serie von Tischtennisspielen basierend auf dem bereitgestellten Punktesystem.\n\n    Diese Funktion nimmt das gewünschte Punktesystem (entweder 11 oder 21 Punkte) und einen String \n    entgegen, der die Abfolge der vom Spieler ('W') und vom Gegner ('L') gewonnenen Punkte darstellt. \n    Die Funktion verarbeitet den String und gibt eine Liste von Spielständen im Format \"player_score:opponent_score\" zurück.\n\n    Das Spiel gilt als beendet, wenn ein Spieler die erforderliche Punktzahl des Systems erreicht \n    (11 oder 21) und dabei mindestens einen Vorsprung von 2 Punkten hat. Wenn die Punktesequenz mitten in einem Spiel endet, \n    wird der aktuelle Spielstand ebenfalls in die Ausgabe aufgenommen.\n\n    Argumente:\n    - system (int): Die Anzahl der Punkte, die erforderlich sind, um ein Spiel zu gewinnen (entweder 11 oder 21).\n    - points (str): Ein String aus 'W'- und 'L'-Zeichen, die die vom Spieler und Gegner gewonnenen Punkte kennzeichnen.\n\n    Rückgabe:\n    - list: Eine Liste von Strings, die den Spielstand jedes Spiels darstellen.\n\n    Fälle:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "ha": "\n    Lissafa maki na jerin wasannin ping-pong bisa tsarin maki da aka bayar.\n\n    Wannan aikin yana karɓar tsarin maki da ake so (ko dai maki 11 ko 21) da kuma wani zare \n    da ke wakiltar jerin maki da ɗan wasa ('W') da abokin hamayya ('L') suka ci. \n    Aikin yana sarrafa zaren kuma yana dawo da jerin maki na wasanni da aka tsara kamar \"maki_ɗan_wasa:maki_abokin_hamayya\".\n\n    Ana ɗaukar wasan ya ƙare lokacin da ɗan wasa ɗaya ya kai adadin maki da tsarin ke buƙata \n    (11 ko 21) tare da tazarar maki 2 aƙalla. Idan jerin maki ya ƙare a tsakiyar wasa, \n    ana haɗa maki na wannan wasan a cikin sakamakon da aka bayar.\n\n    Args:\n    - system (int): Adadin maki da ake buƙata don cin nasara a wasa (ko dai 11 ko 21).\n    - points (str): Zaren haruffa 'W' da 'L' da ke nuna maki da ɗan wasa da abokin hamayya suka ci.\n\n    Returns:\n    - list: Jerin zaren da ke wakiltar maki na kowane wasa.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "hi": "\n    एक श्रृंखला के पिंग-पोंग खेलों का स्कोर दिए गए स्कोरिंग सिस्टम के आधार पर गणना करें।\n\n    यह फ़ंक्शन वांछित स्कोरिंग सिस्टम (या तो 11 या 21 अंक) और एक स्ट्रिंग लेता है \n    जो खिलाड़ी ('W') और प्रतिद्वंद्वी ('L') द्वारा जीते गए अंकों के क्रम का प्रतिनिधित्व करता है। \n    फ़ंक्शन स्ट्रिंग को प्रोसेस करता है और गेम स्कोर की एक सूची लौटाता है जो \"player_score:opponent_score\" के रूप में स्वरूपित होती है।\n\n    खेल को समाप्त माना जाता है जब एक खिलाड़ी सिस्टम द्वारा आवश्यक अंकों की संख्या तक पहुँच जाता है \n    (11 या 21) कम से कम 2 अंकों की बढ़त के साथ। यदि अंकों का क्रम खेल के बीच में समाप्त होता है, \n    तो उस खेल का वर्तमान स्कोर भी आउटपुट में शामिल किया जाता है।\n\n    आर्ग्स:\n    - system (int): एक खेल जीतने के लिए आवश्यक अंकों की संख्या (या तो 11 या 21)।\n    - points (str): 'W' और 'L' वर्णों की एक स्ट्रिंग जो खिलाड़ी और प्रतिद्वंद्वी द्वारा जीते गए अंकों को दर्शाती है।\n\n    रिटर्न्स:\n    - list: प्रत्येक खेल के स्कोर का प्रतिनिधित्व करने वाली स्ट्रिंग्स की एक सूची।\n\n    मामले:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "hu": "\n    Számítsa ki egy sor pingpong játék pontszámát a megadott pontozási rendszer alapján.\n\n    Ez a függvény a kívánt pontozási rendszert (vagy 11 vagy 21 pont) és egy karakterláncot vesz be, \n    amely a játékos ('W') és az ellenfél ('L') által nyert pontok sorozatát jelöli. \n    A függvény feldolgozza a karakterláncot, és visszaad egy listát a játék pontszámairól, \n    \"játékos_pontszám:ellenfél_pontszám\" formátumban.\n\n    A játék akkor tekinthető befejezettnek, amikor az egyik játékos eléri a rendszer által megkövetelt \n    pontszámot (11 vagy 21) legalább 2 pontos előnnyel. Ha a pontok sorozata egy játék közepén ér véget, \n    akkor annak a játéknak az aktuális pontszáma is szerepel a kimenetben.\n\n    Paraméterek:\n    - system (int): A játék megnyeréséhez szükséges pontok száma (vagy 11 vagy 21).\n    - points (str): Egy 'W' és 'L' karakterekből álló karakterlánc, amely a játékos és az ellenfél által nyert pontokat jelöli.\n\n    Visszatér:\n    - list: Egy karakterláncokból álló lista, amely az egyes játékok pontszámát jelöli.\n\n    Esetek:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "es": "    Calcular la puntuación de una serie de juegos de ping-pong según el sistema de puntuación proporcionado.\n\n    Esta función toma el sistema de puntuación deseado (ya sea 11 o 21 puntos) y una cadena \n    que representa la secuencia de puntos ganados por el jugador ('W') y el oponente ('L'). \n    La función procesa la cadena y devuelve una lista de puntuaciones de juegos formateadas como \"puntuación_jugador:puntuación_oponente\".\n\n    El juego se considera terminado cuando un jugador alcanza el número de puntos requerido por el sistema \n    (11 o 21) con al menos una ventaja de 2 puntos. Si la secuencia de puntos termina en medio de un juego, \n    la puntuación actual de ese juego también se incluye en la salida.\n\n    Argumentos:\n    - system (int): El número de puntos requeridos para ganar un juego (ya sea 11 o 21).\n    - points (str): Una cadena de caracteres 'W' y 'L' que denotan puntos ganados por el jugador y el oponente.\n\n    Devuelve:\n    - list: Una lista de cadenas que representan la puntuación de cada juego.\n\n    Casos:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "arb": "    حساب نتيجة سلسلة من مباريات كرة الطاولة بناءً على نظام التسجيل المقدم.\n\n    تأخذ هذه الدالة نظام التسجيل المطلوب (إما 11 أو 21 نقطة) وسلسلة تمثل تسلسل النقاط التي فاز بها اللاعب ('W') والخصم ('L'). \n    تقوم الدالة بمعالجة السلسلة وتعيد قائمة بنتائج المباريات بتنسيق \"player_score:opponent_score\".\n\n    تعتبر المباراة منتهية عندما يصل أحد اللاعبين إلى عدد النقاط المطلوب من النظام \n    (11 أو 21) بفارق لا يقل عن نقطتين. إذا انتهى تسلسل النقاط في منتصف المباراة، \n    يتم تضمين النتيجة الحالية لتلك المباراة في الناتج أيضًا.\n\n    يعيدالحجج:\n    - system (int): عدد النقاط المطلوبة للفوز بالمباراة (إما 11 أو 21).\n    - points (str): سلسلة من الأحرف 'W' و'L' تمثل النقاط التي فاز بها اللاعب والخصم.\n\n    يعيد:\n    - list: قائمة من السلاسل النصية تمثل نتيجة كل مباراة.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "sw": "    Hesabu alama za mfululizo wa michezo ya ping-pong kulingana na mfumo wa alama uliotolewa.\n\n    Kazi hii inachukua mfumo wa alama unaotakiwa (ama pointi 11 au 21) na kamba \n    inayowakilisha mlolongo wa pointi zilizoshindwa na mchezaji ('W') na mpinzani ('L'). \n    Kazi hii inachakata kamba na kurudisha orodha ya alama za mchezo zilizopangwa kama \"alama_ya_mchezaji:alama_ya_mpinzani\".\n\n    Mchezo unachukuliwa kuwa umemalizika wakati mchezaji mmoja anafikia idadi ya pointi inayotakiwa \n    na mfumo (11 au 21) akiwa na uongozi wa angalau pointi 2. Ikiwa mlolongo wa pointi unamalizika katikati ya mchezo, \n    alama ya sasa ya mchezo huo pia inajumuishwa katika matokeo.\n\n    Hoja:\n    - system (int): Idadi ya pointi zinazohitajika kushinda mchezo (ama 11 au 21).\n    - points (str): Kamba ya herufi 'W' na 'L' inayowakilisha pointi zilizoshindwa na mchezaji na mpinzani.\n\n    Inarejesha:\n    - list: Orodha ya kamba zinazowakilisha alama za kila mchezo.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "tr": "    Sağlanan puanlama sistemine göre bir dizi masa tenisi oyununun skorunu hesaplayın.\n\n    Bu fonksiyon, istenen puanlama sistemini (ya 11 ya da 21 puan) ve oyuncu ('W') ve rakip ('L') tarafından kazanılan puanların dizisini temsil eden bir string alır. \n    Fonksiyon, stringi işler ve \"oyuncu_skoru:rakip_skoru\" formatında oyun skorlarının bir listesini döndürür.\n\n    Bir oyuncu, sistemin gerektirdiği puan sayısına (11 veya 21) en az 2 puan farkla ulaştığında oyun bitmiş sayılır. \n    Eğer puan dizisi bir oyunun ortasında sona ererse, o oyunun mevcut skoru da çıktıya dahil edilir.\n\n    Argümanlar:\n    - system (int): Bir oyunu kazanmak için gereken puan sayısı (ya 11 ya da 21).\n    - points (str): Oyuncu ve rakip tarafından kazanılan puanları belirten 'W' ve 'L' karakterlerinden oluşan bir string.\n\n    Döndürür:\n    - list: Her oyunun skorunu temsil eden stringlerin bir listesi.\n\n    Durumlar:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "vi": "    Tính điểm của một loạt các trận đấu bóng bàn dựa trên hệ thống tính điểm được cung cấp.\n\n    Hàm này nhận vào hệ thống tính điểm mong muốn (hoặc 11 hoặc 21 điểm) và một chuỗi \n    đại diện cho chuỗi điểm mà người chơi ('W') và đối thủ ('L') giành được. \n    Hàm xử lý chuỗi và trả về một danh sách các điểm số trận đấu được định dạng dưới dạng \"điểm_người_chơi:điểm_đối_thủ\".\n\n    Trận đấu được coi là kết thúc khi một người chơi đạt đến số điểm yêu cầu của hệ thống \n    (11 hoặc 21) với ít nhất 2 điểm dẫn trước. Nếu chuỗi điểm kết thúc giữa chừng một trận đấu, \n    điểm số hiện tại của trận đấu đó cũng được bao gồm trong đầu ra.\n\n    Tham số:\n    - system (int): Số điểm cần thiết để thắng một trận đấu (hoặc 11 hoặc 21).\n    - points (str): Một chuỗi các ký tự 'W' và 'L' biểu thị điểm mà người chơi và đối thủ giành được.\n\n    Trả về:\n    - list: Một danh sách các chuỗi đại diện cho điểm số của mỗi trận đấu.\n\n    Trường hợp:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "id": "    Hitung skor dari serangkaian permainan ping-pong berdasarkan sistem penilaian yang diberikan.\n\n    Fungsi ini menerima sistem penilaian yang diinginkan (baik 11 atau 21 poin) dan sebuah string \n    yang mewakili urutan poin yang dimenangkan oleh pemain ('W') dan lawan ('L'). \n    Fungsi ini memproses string dan mengembalikan daftar skor permainan yang diformat sebagai \"skor_pemain:skor_lawan\".\n\n    Permainan dianggap selesai ketika salah satu pemain mencapai jumlah poin yang dibutuhkan oleh sistem \n    (11 atau 21) dengan keunggulan setidaknya 2 poin. Jika urutan poin berakhir di tengah permainan, \n    skor permainan saat ini juga disertakan dalam output.\n\n    Args:\n    - system (int): Jumlah poin yang dibutuhkan untuk memenangkan permainan (baik 11 atau 21).\n    - points (str): Sebuah string karakter 'W' dan 'L' yang menunjukkan poin yang dimenangkan oleh pemain dan lawan.\n\n    Returns:\n    - list: Daftar string yang mewakili skor setiap permainan.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "ja": "    一連の卓球ゲームのスコアを、提供されたスコアリングシステムに基づいて計算します。\n\n    この関数は、希望するスコアリングシステム（11点または21点）と、プレイヤーが獲得したポイントを表す文字列（'W'）と相手が獲得したポイントを表す文字列（'L'）を受け取ります。関数はこの文字列を処理し、ゲームのスコアを \"player_score:opponent_score\" の形式でリストとして返します。\n\n    ゲームは、あるプレイヤーがシステムで要求されるポイント数（11または21）に少なくとも2ポイントのリードを持って到達したときに終了と見なされます。ポイントのシーケンスがゲームの途中で終了した場合、そのゲームの現在のスコアも出力に含まれます。\n\n    引数:\n    - system (int): ゲームに勝つために必要なポイント数（11または21のいずれか）。\n    - points (str): プレイヤーと相手が獲得したポイントを示す 'W' と 'L' の文字列。\n\n    戻り値:\n    - list: 各ゲームのスコアを表す文字列のリスト。\n\n    ケース:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "ko": "    일련의 탁구 게임 점수를 제공된 점수 시스템에 따라 계산합니다.\n\n    이 함수는 원하는 점수 시스템(11점 또는 21점)과 플레이어('W')와 상대방('L')이 획득한 \n    점수 시퀀스를 나타내는 문자열을 입력으로 받습니다. 함수는 문자열을 처리하여 \n    \"player_score:opponent_score\" 형식의 게임 점수 목록을 반환합니다.\n\n    게임은 한 플레이어가 시스템에서 요구하는 점수(11점 또는 21점)에 최소 2점 차이로 도달하면 \n    종료된 것으로 간주됩니다. 점수 시퀀스가 게임 중간에 끝나면, 해당 게임의 현재 점수도 \n    출력에 포함됩니다.\n\n    인수:\n    - system (int): 게임에서 승리하기 위해 필요한 점수 (11 또는 21 중 하나).\n    - points (str): 플레이어와 상대방이 획득한 점수를 나타내는 'W'와 'L' 문자로 구성된 문자열.\n\n    반환:\n    - list: 각 게임의 점수를 나타내는 문자열 목록.\n\n    사례:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "ml": "    ഒരു പരമ്പര പിംഗ്-പോംഗ് കളികളുടെ സ്കോർ നൽകിയ സ്കോറിംഗ് സിസ്റ്റം അടിസ്ഥാനമാക്കി കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ ആവശ്യമായ സ്കോറിംഗ് സിസ്റ്റം (11 അല്ലെങ്കിൽ 21 പോയിന്റുകൾ) \n    കൂടാതെ കളിക്കാരൻ ('W')  ജയിച്ച പോയിന്റുകളുടെ ക്രമം \n    എതിരാളി ('L')  ജയിച്ച പോയിന്റുകളുടെ ക്രമം പ്രതിനിധീകരിക്കുന്ന ഒരു \n    സ്ട്രിംഗ്  സ്വീകരിക്കുന്നു. സ്ട്രിംഗ് പ്രോസസ്സ് ചെയ്ത് \"player_score:opponent_score\" \n    എന്ന ഫോർമാറ്റിൽ ഗെയിം സ്കോറുകളുടെ ഒരു ലിസ്റ്റ് തിരികെ നൽകുന്നു.\n\n    ഒരു കളിക്കാരൻ സിസ്റ്റത്തിന്റെ ആവശ്യമായ പോയിന്റുകളുടെ എണ്ണം \n    (11 അല്ലെങ്കിൽ 21) കുറഞ്ഞത് 2-പോയിന്റ് ലീഡ് സഹിതം \n    എത്തുമ്പോൾ ഗെയിം പൂർത്തിയായതായി കണക്കാക്കുന്നു. പോയിന്റുകളുടെ \n    ക്രമം ഒരു ഗെയിമിന്റെ മധ്യത്തിൽ അവസാനിക്കുകയാണെങ്കിൽ, \n    ആ ഗെയിമിന്റെ നിലവിലെ സ്കോറും ഔട്ട്പുട്ടിൽ ഉൾപ്പെടുത്തുന്നു.\n\n    Args:\n    - system (int): ഒരു ഗെയിം ജയിക്കാൻ ആവശ്യമായ പോയിന്റുകളുടെ എണ്ണം (11 അല്ലെങ്കിൽ 21).\n    - points (str): കളിക്കാരനും എതിരാളിയും ജയിച്ച പോയിന്റുകൾ സൂചിപ്പിക്കുന്ന 'W' \n      and 'L' പ്രതീകങ്ങളുള്ള ഒരു സ്ട്രിംഗ്.\n\n    Returns:\n    - list: ഓരോ ഗെയിമിന്റെയും സ്കോർ പ്രതിനിധീകരിക്കുന്ന സ്ട്രിംഗുകളുടെ ലിസ്റ്റ്.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]", "fa": "    محاسبه امتیاز یک سری بازی‌های پینگ‌پنگ بر اساس سیستم امتیازدهی ارائه شده.\n\n    این تابع سیستم امتیازدهی مورد نظر (یا 11 یا 21 امتیاز) و یک رشته \n    که نشان‌دهنده توالی امتیازات برده شده توسط بازیکن ('W') و حریف ('L') است را دریافت می‌کند. \n    تابع رشته را پردازش کرده و لیستی از امتیازات بازی‌ها را به صورت \"player_score:opponent_score\" برمی‌گرداند.\n\n    بازی زمانی تمام‌شده در نظر گرفته می‌شود که یکی از بازیکنان به تعداد امتیاز مورد نیاز سیستم \n    (11 یا 21) با حداقل 2 امتیاز برتری برسد. اگر توالی امتیازات در وسط یک بازی به پایان برسد، \n    امتیاز فعلی آن بازی نیز در خروجی گنجانده می‌شود.\n\n    آرگومان‌ها:\n    - system (int): تعداد امتیاز مورد نیاز برای بردن یک بازی (یا 11 یا 21).\n    - points (str): رشته‌ای از کاراکترهای 'W' و 'L' که نشان‌دهنده امتیازات برده شده توسط بازیکن و حریف است.\n\n    بازگشت:\n    - list: لیستی از رشته‌ها که نشان‌دهنده امتیاز هر بازی است.\n\n    موارد:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]"}}
{"task_id": "Python/34", "prompt": {"en": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    \"\"\"", "sq": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Llogarit numrin e n-të të Catalan-it.\n\n    Funksioni llogarit numrin e n-të të Catalan-it duke përdorur programimin dinamik. Numrat e Catalan-it janë një sekuencë \n    e numrave natyrorë që kanë shumë aplikime në matematikën kombinatorike, duke përfshirë numërimin e disa llojeve të shtigjeve \n    në rrjetë, numrin e shprehjeve që përmbajnë n çifte kllapash që janë të përputhura saktë, numrin e mënyrave të ndryshme si \n    faktorët n+1 mund të vendosen plotësisht në kllapa, dhe më shumë.\n\n    Args:\n    - n (int): Pozicioni në sekuencën e numrave të Catalan-it për të llogaritur (duhet të jetë jo-negativ).\n\n    Returns:\n    - int: Numri i n-të i Catalan-it.\n\n    Raste:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Shënim:\n    Llogaritja bazohet në formulën rekursive:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ku C(0) është 1.\n    \"\"\"", "hy": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Հաշվել n-րդ Կատալանի թիվը։\n\n    Ֆունկցիան հաշվում է n-րդ Կատալանի թիվը դինամիկ ծրագրավորման միջոցով։ Կատալանի թվերը բնական թվերի հաջորդականություն են, \n    որոնք ունեն բազմաթիվ կիրառություններ կոմբինատորիկ մաթեմատիկայում, ներառյալ որոշ տեսակների ցանցային ուղիների հաշվարկը, \n    n զույգ փակագծեր պարունակող արտահայտությունների քանակը, որոնք ճիշտ համընկնում են, n+1 գործոնների ամբողջական փակագծման տարբեր եղանակների քանակը և ավելին։\n\n    Արգումենտներ:\n    - n (int): Կատալանի թվերի հաջորդականության դիրքը, որը պետք է հաշվել (պետք է լինի ոչ բացասական)։\n\n    Վերադարձնում է:\n    - int: n-րդ Կատալանի թիվը։\n\n    Դեպքեր:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Նշում:\n    Հաշվարկը հիմնված է ռեկուրսիվ բանաձևի վրա:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    որտեղ C(0) հավասար է 1:\n    \"\"\"", "bn": "def catalan_number(n: int) -> int:\n    \"\"\"\n    nth ক্যাটালান সংখ্যা গণনা করুন।\n\n    ফাংশনটি ডাইনামিক প্রোগ্রামিং ব্যবহার করে nth ক্যাটালান সংখ্যা গণনা করে। ক্যাটালান সংখ্যা একটি প্রাকৃতিক সংখ্যা \n    ক্রম যা সমাবেশিক গণিতে অনেক প্রয়োগ রয়েছে, যার মধ্যে নির্দিষ্ট ধরনের ল্যাটিস পথের গণনা, n জোড়া বন্ধনী \n    ধারণকারী প্রকাশের সংখ্যা যা সঠিকভাবে মেলানো হয়েছে, n+1 ফ্যাক্টর সম্পূর্ণভাবে বন্ধনীযুক্ত করার বিভিন্ন \n    উপায়ের সংখ্যা, এবং আরও অনেক কিছু।\n\n    আর্গুমেন্ট:\n    - n (int): ক্যাটালান সংখ্যা ক্রমে গণনা করার অবস্থান (অবশ্যই অ-নেতিবাচক হতে হবে)।\n\n    রিটার্নস:\n    - int: nth ক্যাটালান সংখ্যা।\n\n    কেস:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    নোট:\n    গণনা পুনরাবৃত্ত সূত্রের উপর ভিত্তি করে:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    যেখানে C(0) হল 1।\n    \"\"\"", "bg": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Изчисляване на n-тото число на Каталан.\n\n    Функцията изчислява n-тото число на Каталан, използвайки динамично програмиране. Числата на Каталан са редица от естествени \n    числа, които имат много приложения в комбинаторната математика, включително броене на определени видове решетъчни пътища, \n    броят на изразите, съдържащи n двойки скоби, които са правилно съчетани, броят на различните начини, по които n+1 \n    фактора могат да бъдат напълно скобирани, и други.\n\n    Аргументи:\n    - n (int): Позицията в редицата на числата на Каталан, която да се изчисли (трябва да е неотрицателно).\n\n    Връща:\n    - int: n-тото число на Каталан.\n\n    Примери:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Забележка:\n    Изчислението се базира на рекурсивната формула:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    където C(0) е 1.\n    \"\"\"", "zh": "def catalan_number(n: int) -> int:\n    \"\"\"\n    计算第 n 个 Catalan 数。\n\n    该函数使用动态规划计算第 n 个 Catalan 数。Catalan 数是一系列自然数，在组合数学中有许多应用，\n    包括计数某些类型的格路径、包含 n 对括号的表达式的正确匹配数、n+1 个因子完全括号化的不同方式数等。\n\n    参数:\n    - n (int): 要计算的 Catalan 数序列中的位置（必须是非负数）。\n\n    返回:\n    - int: 第 n 个 Catalan 数。\n\n    示例:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    注意:\n    计算基于递归公式:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    其中 C(0) 为 1。\n    \"\"\"", "fr": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculer le nième nombre de Catalan.\n\n    La fonction calcule le nième nombre de Catalan en utilisant la programmation dynamique. Les nombres de Catalan sont une séquence de nombres naturels \n    qui ont de nombreuses applications en mathématiques combinatoires, y compris le comptage de certains types de chemins de grille, \n    le nombre d'expressions contenant n paires de parenthèses correctement appariées, le nombre de façons différentes dont n+1 \n    facteurs peuvent être complètement parenthésés, et plus encore.\n\n    Args:\n    - n (int): La position dans la séquence des nombres de Catalan à calculer (doit être non négative).\n\n    Returns:\n    - int: Le nième nombre de Catalan.\n\n    Cas:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Remarque:\n    Le calcul est basé sur la formule récursive :\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    où C(0) est 1.\n    \"\"\"", "de": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Berechne die n-te Catalan-Zahl.\n\n    Die Funktion berechnet die n-te Catalan-Zahl unter Verwendung der dynamischen Programmierung. Catalan-Zahlen sind eine \n    Folge natürlicher Zahlen, die viele Anwendungen in der kombinatorischen Mathematik haben, einschließlich der Zählung \n    bestimmter Arten von Gitterpfaden, der Anzahl der Ausdrücke, die n korrekt gepaarte Klammern enthalten, der Anzahl der \n    verschiedenen Möglichkeiten, n+1 Faktoren vollständig zu klammern, und mehr.\n\n    Argumente:\n    - n (int): Die Position in der Catalan-Zahlenfolge, die berechnet werden soll (muss nicht-negativ sein).\n\n    Rückgabewert:\n    - int: Die n-te Catalan-Zahl.\n\n    Fälle:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Hinweis:\n    Die Berechnung basiert auf der rekursiven Formel:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    wobei C(0) gleich 1 ist.\n    \"\"\"", "ha": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Lissafi na Catalan na n.\n\n    Aikin yana lissafin lambar Catalan ta n ta amfani da shirye-shiryen motsi. Lambobin Catalan suna da jerin lambobin halitta \n    waɗanda suke da aikace-aikace da yawa a cikin lissafin haɗuwa, ciki har da ƙididdigar wasu nau'ikan hanyoyin lattice, \n    adadin jimlolin da ke ɗauke da nau'i-nau'i na ma'aurata waɗanda aka daidaita daidai, adadin hanyoyin daban-daban na n+1 \n    abubuwa za a iya sanya su cikin ma'aurata gaba ɗaya, da sauransu.\n\n    Args:\n    - n (int): Matsayi a cikin jerin lambobin Catalan da za a lissafa (dole ne ya zama mara kyau).\n\n    Returns:\n    - int: Lambar Catalan ta n.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    Lissafin yana dogara ne akan tsarin maimaitawa:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    inda C(0) shine 1.\n    \"\"\"", "hi": "def catalan_number(n: int) -> int:\n    \"\"\"\n    nth कैटलन संख्या की गणना करें।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके nth कैटलन संख्या की गणना करता है। कैटलन संख्याएँ प्राकृतिक संख्याओं का एक अनुक्रम हैं \n    जिनके संयोज्य गणित में कई अनुप्रयोग हैं, जिनमें कुछ प्रकार के जाली पथों की गिनती, n जोड़े कोष्ठकों वाली अभिव्यक्तियों की संख्या \n    जो सही ढंग से मेल खाते हैं, n+1 कारकों को पूरी तरह से कोष्ठक में रखने के विभिन्न तरीकों की संख्या, और भी बहुत कुछ शामिल हैं।\n\n    तर्क:\n    - n (int): कैटलन संख्या अनुक्रम में गणना करने के लिए स्थिति (गैर-ऋणात्मक होनी चाहिए)।\n\n    लौटाता है:\n    - int: nth कैटलन संख्या।\n\n    मामले:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    नोट:\n    गणना पुनरावर्ती सूत्र पर आधारित है:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    जहाँ C(0) 1 है।\n    \"\"\"", "hu": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Számítsa ki az n-edik Catalan számot.\n\n    A függvény dinamikus programozás segítségével számítja ki az n-edik Catalan számot. A Catalan számok egy olyan természetes \n    számok sorozata, amely számos alkalmazással bír a kombinatorikus matematikában, beleértve bizonyos típusú rácsos utak számolását, \n    az n pár zárójelet tartalmazó kifejezések számát, amelyek helyesen vannak párosítva, az n+1 tényező különböző módon történő teljes \n    zárójelezésének számát, és még sok más.\n\n    Paraméterek:\n    - n (int): A Catalan szám sorozatban lévő pozíció, amelyet ki kell számítani (nem lehet negatív).\n\n    Visszatér:\n    - int: Az n-edik Catalan szám.\n\n    Esetek:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Megjegyzés:\n    A számítás az alábbi rekurzív képleten alapul:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ahol C(0) értéke 1.\n    \"\"\"", "es": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calcular el número de Catalan enésimo.\n\n    La función calcula el número de Catalan enésimo utilizando programación dinámica. Los números de Catalan son una secuencia \n    de números naturales que tienen muchas aplicaciones en matemáticas combinatorias, incluyendo el conteo de ciertos tipos de \n    caminos en una cuadrícula, el número de expresiones que contienen n pares de paréntesis que están correctamente emparejados, \n    el número de diferentes maneras en que n+1 factores pueden ser completamente parentizados, y más.\n\n    Argumentos:\n    - n (int): La posición en la secuencia de números de Catalan a calcular (debe ser no negativa).\n\n    Devuelve:\n    - int: El número de Catalan enésimo.\n\n    Casos:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Nota:\n    El cálculo se basa en la fórmula recursiva:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    donde C(0) es 1.\n    \"\"\"", "arb": "def catalan_number(n: int) -> int:\n    \"\"\"\n    حساب العدد النوني من أعداد كاتالان.\n\n    تقوم الدالة بحساب العدد النوني من أعداد كاتالان باستخدام البرمجة الديناميكية. أعداد كاتالان هي سلسلة من الأعداد الطبيعية \n    التي لها العديد من التطبيقات في الرياضيات التوافقية، بما في ذلك عد أنواع معينة من المسارات الشبكية، \n    عدد التعبيرات التي تحتوي على n زوجًا من الأقواس المتطابقة بشكل صحيح، عدد الطرق المختلفة التي يمكن بها \n    تحويط n+1 عاملاً بشكل كامل، والمزيد.\n\n    يعيدالحجج:\n    - n (int): الموضع في سلسلة أعداد كاتالان للحساب (يجب أن يكون غير سالب).\n\n    يعيد:\n    - int: العدد النوني من أعداد كاتالان.\n\n    حالات:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    ملاحظة:\n    يعتمد الحساب على الصيغة التكرارية:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    حيث أن C(0) هو 1.\n    \"\"\"", "sw": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Kuhesabu nambari ya Catalan ya n.\n\n    Kazi hii inakokotoa nambari ya Catalan ya n kwa kutumia programu ya nguvu. Nambari za Catalan ni mlolongo wa nambari \n    asilia ambazo zina matumizi mengi katika hesabu za mchanganyiko, ikiwa ni pamoja na kuhesabu aina fulani za njia za \n    gridi, idadi ya maonyesho yanayojumuisha jozi n za mabano ambayo yameunganishwa kwa usahihi, idadi ya njia tofauti \n    ambazo vipengele n+1 vinaweza kuwekwa mabano kikamilifu, na zaidi.\n\n    Hoja:\n    - n (int): Nafasi katika mlolongo wa nambari za Catalan ya kuhesabu (lazima iwe isiyo hasi).\n\n    Inarejesha:\n    - int: Nambari ya Catalan ya n.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    Hisabati inategemea kanuni ya kurudia:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ambapo C(0) ni 1.\n    \"\"\"", "tr": "def catalan_number(n: int) -> int:\n    \"\"\"\n    n. Katalan sayısını hesapla.\n\n    Fonksiyon, dinamik programlama kullanarak n. Katalan sayısını hesaplar. Katalan sayıları, kombinatoryal matematikte birçok \n    uygulamaya sahip doğal sayıların bir dizisidir. Bunlar arasında belirli türdeki kafes yollarının sayılması, n çift parantez \n    içeren ifadelerin doğru şekilde eşleşmiş olması, n+1 faktörün tamamen parantezlenebileceği farklı yolların sayısı ve daha fazlası bulunur.\n\n    Argümanlar:\n    - n (int): Hesaplanacak Katalan sayısı dizisindeki konum (negatif olmamalıdır).\n\n    Dönüş:\n    - int: n. Katalan sayısı.\n\n    Durumlar:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Not:\n    Hesaplama, aşağıdaki özyinelemeli formüle dayanmaktadır:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    burada C(0) 1'dir.\n    \"\"\"", "vi": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Tính số Catalan thứ n.\n\n    Hàm này tính số Catalan thứ n sử dụng lập trình động. Các số Catalan là một dãy số tự nhiên có nhiều ứng dụng trong \n    toán học tổ hợp, bao gồm việc đếm số lượng các đường đi trong lưới nhất định, số lượng biểu thức chứa n cặp dấu ngoặc \n    được ghép đúng cách, số lượng cách khác nhau mà n+1 yếu tố có thể được ngoặc hoàn toàn, và nhiều hơn nữa.\n\n    Tham số:\n    - n (int): Vị trí trong dãy số Catalan cần tính (phải là số không âm).\n\n    Trả về:\n    - int: Số Catalan thứ n.\n\n    Trường hợp:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Lưu ý:\n    Việc tính toán dựa trên công thức đệ quy:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    trong đó C(0) là 1.\n    \"\"\"", "id": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Menghitung bilangan Catalan ke-n.\n\n    Fungsi ini menghitung bilangan Catalan ke-n menggunakan pemrograman dinamis. Bilangan Catalan adalah urutan bilangan \n    alami yang memiliki banyak aplikasi dalam matematika kombinatorial, termasuk penghitungan jenis jalur kisi tertentu, \n    jumlah ekspresi yang mengandung n pasang tanda kurung yang dipasangkan dengan benar, jumlah cara berbeda n+1 \n    faktor dapat sepenuhnya dipasangkan dengan tanda kurung, dan lainnya.\n\n    Argumen:\n    - n (int): Posisi dalam urutan bilangan Catalan yang akan dihitung (harus tidak negatif).\n\n    Mengembalikan:\n    - int: Bilangan Catalan ke-n.\n\n    Kasus:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Catatan:\n    Perhitungan didasarkan pada rumus rekursif:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    di mana C(0) adalah 1.\n    \"\"\"", "ja": "def catalan_number(n: int) -> int:\n    \"\"\"\n    n番目のカタラン数を計算します。\n\n    この関数は動的プログラミングを使用してn番目のカタラン数を計算します。カタラン数は組合せ数学において多くの応用があり、特定の種類の格子パスの数、n組の括弧を含む式が正しく対応している数、n+1個の要素を完全に括弧で囲む異なる方法の数などに関連しています。\n\n    引数:\n    - n (int): 計算するカタラン数列の位置（非負でなければなりません）。\n\n    戻り値:\n    - int: n番目のカタラン数。\n\n    ケース:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    注意:\n    計算は次の再帰式に基づいています:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ここでC(0)は1です。\n    \"\"\"", "ko": "def catalan_number(n: int) -> int:\n    \"\"\"\n    n번째 Catalan 수를 계산합니다.\n\n    이 함수는 동적 프로그래밍을 사용하여 n번째 Catalan 수를 계산합니다. Catalan 수는 조합 수학에서 여러 응용을 가지는 자연수의 \n    수열로, 특정 유형의 격자 경로의 수, n 쌍의 괄호가 올바르게 짝지어진 표현식의 수, n+1 개의 요소가 완전히 괄호로 묶일 수 있는 \n    서로 다른 방법의 수 등을 포함합니다.\n\n    매개변수:\n    - n (int): 계산할 Catalan 수열의 위치 (0 이상의 정수여야 함).\n\n    반환값:\n    - int: n번째 Catalan 수.\n\n    사례:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    참고:\n    계산은 다음의 재귀 공식에 기반합니다:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    여기서 C(0)은 1입니다.\n    \"\"\"", "ml": "def catalan_number(n: int) -> int:\n    \"\"\"\n    n-ാം കാറ്റലാൻ സംഖ്യ കണക്കാക്കുക.\n\n    ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് n-ാം കാറ്റലാൻ സംഖ്യ കണക്കാക്കുന്നു. കാറ്റലാൻ സംഖ്യകൾ സംയോജക ഗണിതശാസ്ത്രത്തിൽ \n    നിരവധി പ്രയോഗങ്ങൾ ഉണ്ട്, ഇതിൽ ചില പ്രത്യേക തരം ലാറ്റിസ് പാതകളുടെ എണ്ണവും, ശരിയായി പൊരുത്തപ്പെടുന്ന n ജോഡി വക്രകോഷ്ടകങ്ങൾ \n    അടങ്ങിയ വ്യാകരണങ്ങളുടെ എണ്ണവും, n+1 ഘടകങ്ങളെ പൂർണ്ണമായും വക്രകോഷ്ടകങ്ങളാൽ അടയ്ക്കാനുള്ള വ്യത്യസ്ത മാർഗ്ഗങ്ങളുടെ \n    എണ്ണവും ഉൾപ്പെടുന്നു.\n\n    Args:\n    - n (int): കാറ്റലാൻ സംഖ്യാ ക്രമത്തിലെ കണക്കാക്കേണ്ട സ്ഥാനം (നോൺ-നെഗറ്റീവ് ആയിരിക്കണം).\n\n    Returns:\n    - int: n-ാം കാറ്റലാൻ സംഖ്യ.\n\n    ഉദാഹരണങ്ങൾ:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    കുറിപ്പ്:\n    കണക്കുകൂട്ടൽ പുനരാവർത്തന സൂത്രവാക്യത്തെ അടിസ്ഥാനമാക്കിയുള്ളതാണ്:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ഇവിടെ C(0) 1 ആണ്.\n    \"\"\"", "fa": "def catalan_number(n: int) -> int:\n    \"\"\"\n    محاسبه عدد کاتالان nام.\n\n    این تابع عدد کاتالان nام را با استفاده از برنامه‌نویسی پویا محاسبه می‌کند. اعداد کاتالان دنباله‌ای از اعداد طبیعی \n    هستند که کاربردهای زیادی در ریاضیات ترکیبیاتی دارند، از جمله شمارش انواع خاصی از مسیرهای شبکه، تعداد عبارات حاوی \n    n جفت پرانتز که به درستی جفت شده‌اند، تعداد روش‌های مختلفی که n+1 عامل می‌توانند به طور کامل پرانتزگذاری شوند، و بیشتر.\n\n    آرگومان‌ها:\n    - n (int): موقعیت در دنباله عدد کاتالان برای محاسبه (باید غیرمنفی باشد).\n\n    بازگشت:\n    - int: عدد کاتالان nام.\n\n    موارد:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    توجه:\n    محاسبه بر اساس فرمول بازگشتی است:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    که در آن C(0) برابر 1 است.\n    \"\"\""}, "canonical_solution": "    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]", "instruction": {"en": "Write a python function 'def catalan_number(n: int) -> int:' to solve the following problem:\n\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    ", "sq": "Shkruani një funksion python 'def catalan_number(n: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit numrin e n-të të Katalanit.\n\n    Funksioni llogarit numrin e n-të të Katalanit duke përdorur programimin dinamik. Numrat e Katalanit janë një sekuencë \n    numrash natyrorë që kanë shumë aplikime në matematikën kombinatorike, duke përfshirë numërimin e llojeve të caktuara të shtigjeve të rrjetit, \n    numrin e shprehjeve që përmbajnë n çifte kllapash që janë të lidhura saktë, numrin e mënyrave të ndryshme që n+1 \n    faktorë mund të parentezohen plotësisht, dhe më shumë.\n\n    Args:\n    - n (int): Pozicioni në sekuencën e numrave të Katalanit për të llogaritur (duhet të jetë jo-negativ).\n\n    Returns:\n    - int: Numri i n-të i Katalanit.\n\n    Rastet:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Shënim:\n    Llogaritja bazohet në formulën rekursive:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ku C(0) është 1.", "hy": "Պայթոն ֆունկցիա 'def catalan_number(n: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել n-րդ Կատալանի թիվը։\n\n    Ֆունկցիան հաշվարկում է n-րդ Կատալանի թիվը դինամիկ ծրագրավորման միջոցով։ Կատալանի թվերը բնական \n    թվերի հաջորդականություն են, որոնք ունեն բազմաթիվ կիրառություններ կոմբինատորիկ մաթեմատիկայում, ներառյալ որոշակի \n    տեսակների ցանցային ուղիների հաշվարկը, n զույգ փակագծեր պարունակող արտահայտությունների քանակը, որոնք ճիշտ են համընկնում, \n    n+1 գործոնների ամբողջական փակագծման տարբեր եղանակների քանակը և ավելին։\n\n    Արգումենտներ:\n    - n (int): Կատալանի թվերի հաջորդականության դիրքը, որը պետք է հաշվարկվի (պետք է լինի ոչ բացասական)։\n\n    Վերադարձնում է:\n    - int: n-րդ Կատալանի թիվը։\n\n    Դեպքեր:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Նշում:\n    Հաշվարկը հիմնված է ռեկուրսիվ բանաձևի վրա:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    որտեղ C(0) հավասար է 1։", "bn": "একটি পাইথন ফাংশন 'def catalan_number(n: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    nth ক্যাটালান সংখ্যা গণনা করুন।\n\n    ফাংশনটি ডাইনামিক প্রোগ্রামিং ব্যবহার করে nth ক্যাটালান সংখ্যা গণনা করে। ক্যাটালান সংখ্যা একটি প্রাকৃতিক সংখ্যার ক্রম যা সমাবেশিক গণিতে অনেক প্রয়োগ রয়েছে, \n    যার মধ্যে কিছু প্রকারের ল্যাটিস পথের গণনা, n জোড়া বন্ধনী ধারণকারী সঠিকভাবে মিলিত প্রকাশের সংখ্যা, n+1 ফ্যাক্টর সম্পূর্ণভাবে বন্ধনীযুক্ত করার বিভিন্ন উপায়ের সংখ্যা, এবং আরও অনেক কিছু অন্তর্ভুক্ত।\n\n    Args:\n    - n (int): ক্যাটালান সংখ্যা ক্রমে গণনা করার অবস্থান (অবশ্যই অ-ঋণাত্মক হতে হবে)।\n\n    Returns:\n    - int: nth ক্যাটালান সংখ্যা।\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    গণনা পুনরাবৃত্তিমূলক সূত্রের উপর ভিত্তি করে:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    যেখানে C(0) হল 1।", "bg": "Напишете Python функция 'def catalan_number(n: int) -> int:' за да решите следния проблем:\n\n    Изчислете n-тото число на Каталан.\n\n    Функцията изчислява n-тото число на Каталан, използвайки динамично програмиране. Числата на Каталан са последователност \n    от естествени числа, които имат много приложения в комбинаторната математика, включително броене на определени видове \n    решетъчни пътеки, броя на изразите, съдържащи n двойки скоби, които са правилно съчетани, броя на различните начини, \n    по които n+1 фактори могат да бъдат напълно скобирани, и други.\n\n    Аргументи:\n    - n (int): Позицията в последователността на числата на Каталан, която да се изчисли (трябва да бъде неотрицателна).\n\n    Връща:\n    - int: n-тото число на Каталан.\n\n    Примери:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Забележка:\n    Изчислението се основава на рекурсивната формула:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    където C(0) е 1.", "zh": "编写一个 Python 函数 'def catalan_number(n: int) -> int:' 来解决以下问题：\n\n    计算第 n 个 Catalan 数。\n\n    该函数使用动态规划计算第 n 个 Catalan 数。Catalan 数是一个自然数序列，\n    在组合数学中有许多应用，包括计数某些类型的格路径、包含 n 对正确匹配的括号的表达式数量、\n    n+1 个因子可以完全括号化的不同方式数量等。\n\n    参数:\n    - n (int): 要计算的 Catalan 数序列中的位置（必须是非负数）。\n\n    返回:\n    - int: 第 n 个 Catalan 数。\n\n    示例:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    注意:\n    计算基于递归公式：\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    其中 C(0) 为 1。", "fr": "Écrire une fonction python 'def catalan_number(n: int) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nième nombre de Catalan.\n\n    La fonction calcule le nième nombre de Catalan en utilisant la programmation dynamique. Les nombres de Catalan sont une séquence de nombres naturels \n    qui ont de nombreuses applications en mathématiques combinatoires, y compris le comptage de certains types de chemins de réseau, \n    le nombre d'expressions contenant n paires de parenthèses correctement appariées, le nombre de façons différentes dont n+1 \n    facteurs peuvent être complètement parenthésés, et plus encore.\n\n    Arguments :\n    - n (int) : La position dans la séquence des nombres de Catalan à calculer (doit être non négative).\n\n    Renvoie :\n    - int : Le nième nombre de Catalan.\n\n    Cas :\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Remarque :\n    Le calcul est basé sur la formule récursive :\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    où C(0) est 1.", "de": "Schreiben Sie eine Python-Funktion 'def catalan_number(n: int) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die n-te Catalan-Zahl.\n\n    Die Funktion berechnet die n-te Catalan-Zahl unter Verwendung der dynamischen Programmierung. Catalan-Zahlen sind eine Sequenz von natürlichen \n    Zahlen, die viele Anwendungen in der kombinatorischen Mathematik haben, einschließlich der Zählung bestimmter Arten von Gitterpfaden, \n    der Anzahl der Ausdrücke, die n korrekt gepaarte Klammerpaare enthalten, der Anzahl der verschiedenen Möglichkeiten, n+1 \n    Faktoren vollständig zu klammern, und mehr.\n\n    Argumente:\n    - n (int): Die Position in der Catalan-Zahlen-Sequenz, die berechnet werden soll (muss nicht-negativ sein).\n\n    Rückgabewert:\n    - int: Die n-te Catalan-Zahl.\n\n    Fälle:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Hinweis:\n    Die Berechnung basiert auf der rekursiven Formel:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    wobei C(0) gleich 1 ist.", "ha": "Rubuta wani aikin python 'def catalan_number(n: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa lambar Catalan ta n.\n\n    Aikin yana lissafin lambar Catalan ta n ta amfani da shirye-shiryen motsi. Lambobin Catalan suna jerin lambobin halitta \n    waɗanda ke da aikace-aikace da yawa a cikin lissafin haɗin gwiwa, gami da ƙididdigar wasu nau'ikan hanyoyin lattice, \n    adadin maganganun da ke ɗauke da nau'i-nau'i na n waɗanda aka haɗa su daidai, adadin hanyoyin daban-daban na n+1 \n    abubuwan da za a iya rufe su gaba ɗaya, da ƙari.\n\n    Args:\n    - n (int): Matsayin a cikin jerin lambobin Catalan don lissafawa (dole ne ya zama mara kyau).\n\n    Returns:\n    - int: Lambar Catalan ta n.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    Lissafin yana dogara ne akan tsarin maimaitawa:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    inda C(0) shine 1.", "hi": "एक पायथन फ़ंक्शन 'def catalan_number(n: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    nth कैटलन संख्या की गणना करें।\n\n    फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके nth कैटलन संख्या की गणना करता है। कैटलन संख्याएँ प्राकृतिक \n    संख्याओं का एक अनुक्रम हैं जिनका संयोजकीय गणित में कई अनुप्रयोग होते हैं, जिनमें कुछ प्रकार के लैटिस पथों की गिनती, \n    n जोड़े कोष्ठकों वाले अभिव्यक्तियों की संख्या जो सही ढंग से मेल खाते हैं, n+1 \n    कारकों को पूरी तरह से कोष्ठक में रखने के विभिन्न तरीकों की संख्या, और अधिक शामिल हैं।\n\n    तर्क:\n    - n (int): कैटलन संख्या अनुक्रम में गणना करने की स्थिति (अ-ऋणात्मक होनी चाहिए)।\n\n    लौटाता है:\n    - int: nth कैटलन संख्या।\n\n    मामले:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    नोट:\n    गणना पुनरावर्ती सूत्र पर आधारित है:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    जहाँ C(0) 1 है।", "hu": "Írj egy python függvényt 'def catalan_number(n: int) -> int:' a következő probléma megoldására:\n\n    Számítsd ki az n-edik Catalan számot.\n\n    A függvény dinamikus programozás segítségével számítja ki az n-edik Catalan számot. A Catalan számok egy természetes számokból álló sorozat, amelynek számos alkalmazása van a kombinatorikus matematikában, beleértve bizonyos típusú rácsútvonalak számolását, az n pár zárójelet tartalmazó kifejezések számát, amelyek helyesen vannak párosítva, az n+1 tényező különböző módon történő teljes zárójelezésének számát, és még sok mást.\n\n    Argumentumok:\n    - n (int): A Catalan szám sorozatban kiszámítandó pozíció (nem lehet negatív).\n\n    Visszatér:\n    - int: Az n-edik Catalan szám.\n\n    Esetek:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Megjegyzés:\n    A számítás a rekurzív képleten alapul:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ahol C(0) értéke 1.", "es": "Escribe una función de Python 'def catalan_number(n: int) -> int:' para resolver el siguiente problema:\n\n    Calcular el enésimo número de Catalan.\n\n    La función calcula el enésimo número de Catalan utilizando programación dinámica. Los números de Catalan son una secuencia de \n    números naturales que tienen muchas aplicaciones en matemáticas combinatorias, incluyendo el conteo de ciertos tipos de caminos \n    en una cuadrícula, el número de expresiones que contienen n pares de paréntesis que están correctamente emparejados, el número \n    de diferentes maneras en que n+1 factores pueden ser completamente parentizados, y más.\n\n    Argumentos:\n    - n (int): La posición en la secuencia de números de Catalan a calcular (debe ser no negativa).\n\n    Devuelve:\n    - int: El enésimo número de Catalan.\n\n    Casos:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Nota:\n    El cálculo se basa en la fórmula recursiva:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    donde C(0) es 1.", "arb": "اكتب دالة بايثون 'def catalan_number(n: int) -> int:' لحل المشكلة التالية:\n\n    حساب العدد الكاتالاني nth.\n\n    تقوم الدالة بحساب العدد الكاتالاني nth باستخدام البرمجة الديناميكية. الأعداد الكاتالانية هي سلسلة من الأعداد الطبيعية \n    التي لها العديد من التطبيقات في الرياضيات التوافقية، بما في ذلك عد أنواع معينة من المسارات الشبكية، \n    عدد التعبيرات التي تحتوي على n زوج من الأقواس المتطابقة بشكل صحيح، عدد الطرق المختلفة التي يمكن بها \n    وضع n+1 عامل بين أقواس بشكل كامل، وأكثر.\n\n    يعيدالحجج:\n    - n (int): الموضع في سلسلة الأعداد الكاتالانية للحساب (يجب أن يكون غير سالب).\n\n    يعيد:\n    - int: العدد الكاتالاني nth.\n\n    حالات:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    ملاحظة:\n    يعتمد الحساب على الصيغة التكرارية:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    حيث أن C(0) هو 1.", "sw": "Andika kazi ya python 'def catalan_number(n: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu nambari ya Catalan ya nth.\n\n    Kazi inahesabu nambari ya Catalan ya nth kwa kutumia programu ya nguvu. Nambari za Catalan ni mlolongo wa nambari \n    za asili ambazo zina matumizi mengi katika hisabati ya mchanganyiko, ikiwa ni pamoja na kuhesabu aina fulani za njia za \n    lattice, idadi ya maneno yanayojumuisha jozi n za mabano ambayo yameunganishwa kwa usahihi, idadi ya njia tofauti ambazo \n    n+1 vipengele vinaweza kuwekwa mabano kikamilifu, na zaidi.\n\n    Hoja:\n    - n (int): Nafasi katika mlolongo wa nambari za Catalan ya kuhesabu (lazima iwe isiyo hasi).\n\n    Inarejesha:\n    - int: Nambari ya Catalan ya nth.\n\n    Kesi:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Kumbuka:\n    Hesabu inategemea fomula ya kurudi:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ambapo C(0) ni 1.", "tr": "Bir python fonksiyonu 'def catalan_number(n: int) -> int:' yazarak aşağıdaki problemi çözün:\n\n    n'inci Catalan sayısını hesaplayın.\n\n    Fonksiyon, dinamik programlama kullanarak n'inci Catalan sayısını hesaplar. Catalan sayıları, kombinatoryal matematikte birçok \n    uygulamaya sahip doğal sayıların bir dizisidir. Bunlar arasında belirli türdeki kafes yollarının sayılması, n çift parantez içeren \n    ifadelerin doğru şekilde eşleşmiş olması, n+1 faktörünün tamamen parantezlenebileceği farklı yolların sayısı ve daha fazlası bulunur.\n\n    Argümanlar:\n    - n (int): Hesaplanacak Catalan sayısı dizisindeki pozisyon (negatif olmamalıdır).\n\n    Döndürür:\n    - int: n'inci Catalan sayısı.\n\n    Durumlar:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Not:\n    Hesaplama, aşağıdaki özyinelemeli formüle dayanır:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    burada C(0) 1'dir.", "vi": "Viết một hàm python 'def catalan_number(n: int) -> int:' để giải quyết vấn đề sau:\n\n    Tính số Catalan thứ n.\n\n    Hàm này tính số Catalan thứ n sử dụng lập trình động. Số Catalan là một dãy số tự nhiên có nhiều ứng dụng trong toán học tổ hợp, \n    bao gồm việc đếm số lượng các loại đường đi trên lưới, số lượng biểu thức chứa n cặp dấu ngoặc được ghép đúng, số lượng cách khác nhau mà n+1 \n    yếu tố có thể được ngoặc hoàn toàn, và nhiều hơn nữa.\n\n    Tham số:\n    - n (int): Vị trí trong dãy số Catalan cần tính (phải là số không âm).\n\n    Trả về:\n    - int: Số Catalan thứ n.\n\n    Trường hợp:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Lưu ý:\n    Việc tính toán dựa trên công thức đệ quy:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    trong đó C(0) là 1.", "id": "Tulis fungsi python 'def catalan_number(n: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung bilangan Catalan ke-n.\n\n    Fungsi ini menghitung bilangan Catalan ke-n menggunakan pemrograman dinamis. Bilangan Catalan adalah urutan bilangan \n    alami yang memiliki banyak aplikasi dalam matematika kombinatorial, termasuk penghitungan jenis jalur kisi tertentu, \n    jumlah ekspresi yang mengandung n pasang tanda kurung yang dipasangkan dengan benar, jumlah cara berbeda n+1 \n    faktor dapat sepenuhnya diberi tanda kurung, dan lainnya.\n\n    Argumen:\n    - n (int): Posisi dalam urutan bilangan Catalan yang akan dihitung (harus non-negatif).\n\n    Mengembalikan:\n    - int: Bilangan Catalan ke-n.\n\n    Kasus:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Catatan:\n    Perhitungan didasarkan pada rumus rekursif:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    di mana C(0) adalah 1.", "ja": "Python関数を書いてください。 'def catalan_number(n: int) -> int:' を作成して、次の問題を解決してください:\n\n    n番目のカタラン数を計算します。\n\n    この関数は動的プログラミングを使用してn番目のカタラン数を計算します。カタラン数は、組合せ数学において多くの応用を持つ自然数の列であり、特定の種類の格子経路の数、n組の括弧を正しく対応付ける表現の数、n+1個の要素を完全に括弧で囲む異なる方法の数などが含まれます。\n\n    引数:\n    - n (int): 計算するカタラン数列の位置（非負である必要があります）。\n\n    戻り値:\n    - int: n番目のカタラン数。\n\n    ケース:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    注意:\n    計算は次の再帰式に基づいています:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ここでC(0)は1です。", "ko": "파이썬 함수를 작성하세요 'def catalan_number(n: int) -> int:' 다음 문제를 해결하기 위해:\n\n    n번째 카탈란 수를 계산합니다.\n\n    이 함수는 동적 프로그래밍을 사용하여 n번째 카탈란 수를 계산합니다. 카탈란 수는 조합 수학에서 여러 응용을 가지는 자연수의 \n    수열로, 특정 유형의 격자 경로의 개수, n 쌍의 괄호가 올바르게 짝지어진 표현식의 개수, n+1 개의 요소를 완전히 괄호화할 수 있는 \n    서로 다른 방법의 수 등을 포함합니다.\n\n    인수:\n    - n (int): 계산할 카탈란 수열의 위치 (0 이상의 정수여야 함).\n\n    반환:\n    - int: n번째 카탈란 수.\n\n    사례:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    참고:\n    계산은 재귀 공식에 기반합니다:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    여기서 C(0)은 1입니다.", "ml": "'def catalan_number(n: int) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    n-ാം കാറ്റലാൻ സംഖ്യ കണക്കാക്കുക.\n\n    ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് n-ാം കാറ്റലാൻ സംഖ്യ കണക്കാക്കുന്നു. കാറ്റലാൻ സംഖ്യകൾ കോമ്പിനേറ്റോറിയൽ ഗണിതശാസ്ത്രത്തിൽ നിരവധി \n    പ്രയോഗങ്ങൾ ഉള്ള ഒരു സ്വാഭാവിക സംഖ്യകളുടെ അനുക്രമമാണ്, ഇതിൽ ചില ലാറ്റിസ് പാതകളുടെ എണ്ണവും, n ജോഡികൾ ഉള്ള പാരന്തസിസ് ശരിയായി \n    പൊരുത്തപ്പെടുന്ന പ്രകടനങ്ങളുടെ എണ്ണവും, n+1 ഘടകങ്ങൾ പൂർണ്ണമായും പാരന്തസിസ് ചെയ്യാൻ ഉള്ള വ്യത്യസ്ത മാർഗ്ഗങ്ങളുടെ എണ്ണവും ഉൾപ്പെടുന്നു.\n\n    Args:\n    - n (int): കാറ്റലാൻ സംഖ്യാ അനുക്രമത്തിലെ സ്ഥാനം കണക്കാക്കുക (നോൺ-നെഗറ്റീവ് ആയിരിക്കണം).\n\n    Returns:\n    - int: n-ാം കാറ്റലാൻ സംഖ്യ.\n\n    കേസുകൾ:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    കുറിപ്പ്:\n    കണക്കാക്കൽ പുനരാവർത്തന സൂത്രവാക്യത്തെ അടിസ്ഥാനമാക്കിയുള്ളതാണ്:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ഇവിടെ C(0) 1 ആണ്.", "fa": "یک تابع پایتون 'def catalan_number(n: int) -> int:' بنویسید تا مسئله زیر را حل کند:\n\n    عدد کاتالان nام را محاسبه کنید.\n\n    تابع عدد کاتالان nام را با استفاده از برنامه‌نویسی پویا محاسبه می‌کند. اعداد کاتالان دنباله‌ای از اعداد طبیعی هستند \n    که کاربردهای زیادی در ریاضیات ترکیبیاتی دارند، از جمله شمارش انواع خاصی از مسیرهای شبکه، تعداد عبارات حاوی n جفت \n    پرانتز که به درستی جفت شده‌اند، تعداد روش‌های مختلفی که n+1 عامل می‌توانند به طور کامل پرانتزگذاری شوند، و بیشتر.\n\n    آرگومان‌ها:\n    - n (int): موقعیت در دنباله عدد کاتالان برای محاسبه (باید غیرمنفی باشد).\n\n    بازگشت:\n    - int: عدد کاتالان nام.\n\n    موارد:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    توجه:\n    محاسبه بر اساس فرمول بازگشتی است:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    که در آن C(0) برابر 1 است."}, "level": "easy", "test": "def test_catalan_number():\n    # Test case 1: The first Catalan number (base case)\n    n1 = 0\n    expected_output1 = 1\n    assert catalan_number(n1) == expected_output1, f\"Test case 1 failed: expected {expected_output1}, got {catalan_number(n1)}\"\n\n    # Test case 2: The third Catalan number\n    n2 = 3\n    expected_output2 = 5\n    assert catalan_number(n2) == expected_output2, f\"Test case 2 failed: expected {expected_output2}, got {catalan_number(n2)}\"\n\n    # Test case 3: The fifth Catalan number\n    n3 = 5\n    expected_output3 = 42\n    assert catalan_number(n3) == expected_output3, f\"Test case 3 failed: expected {expected_output3}, got {catalan_number(n3)}\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_catalan_number()", "entry_point": "catalan_number", "signature": "def catalan_number(n: int) -> int:", "docstring": {"en": "\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    ", "sq": "\n    Llogarit numrin e n-të të Catalan.\n\n    Funksioni llogarit numrin e n-të të Catalan duke përdorur programimin dinamik. Numrat Catalan janë një sekuencë \n    numrash natyralë që kanë shumë aplikime në matematikën kombinatorike, duke përfshirë numërimin e disa llojeve të \n    shtigjeve të rrjetit, numrin e shprehjeve që përmbajnë n çifte kllapash që janë të përputhura saktësisht, numrin e \n    mënyrave të ndryshme që n+1 faktorë mund të parantezohen plotësisht, dhe më shumë.\n\n    Argumentet:\n    - n (int): Pozicioni në sekuencën e numrave të Catalan për të llogaritur (duhet të jetë jo-negativ).\n\n    Kthen:\n    - int: Numri i n-të i Catalan.\n\n    Raste:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Shënim:\n    Llogaritja bazohet në formulën rekursive:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ku C(0) është 1.\n    ", "hy": "\n    Հաշվեք n-րդ Կատալանի թիվը։\n\n    Ֆունկցիան հաշվարկում է n-րդ Կատալանի թիվը դինամիկ ծրագրավորման միջոցով։ Կատալանի թվերը բնական թվերի հաջորդականություն են, \n    որոնք ունեն բազմաթիվ կիրառություններ կոմբինատորական մաթեմատիկայում, ներառյալ որոշ տեսակների ցանցային ուղիների հաշվարկը, \n    n զույգ փակագծեր պարունակող արտահայտությունների քանակը, որոնք ճիշտ են համընկնում, n+1 գործոնների ամբողջական փակագծման \n    տարբեր եղանակների քանակը և այլն։\n\n    Արգումենտներ:\n    - n (int): Կատալանի թվերի հաջորդականության դիրքը, որը պետք է հաշվարկել (պետք է լինի ոչ բացասական)։\n\n    Վերադարձնում է:\n    - int: n-րդ Կատալանի թիվը։\n\n    Դեպքեր:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Նշում:\n    Հաշվարկը հիմնված է ռեկուրսիվ բանաձևի վրա:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    որտեղ C(0)-ը 1 է։\n    ", "bn": "\n    nth Catalan সংখ্যা গণনা করুন।\n\n    ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে nth Catalan সংখ্যা গণনা করে। Catalan সংখ্যা হল প্রাকৃতিক সংখ্যার একটি ক্রম, \n    যার অনেক প্রয়োগ রয়েছে সমাবেশিক গণিতে, যার মধ্যে রয়েছে নির্দিষ্ট ধরনের ল্যাটিস পথের গণনা, \n    n জোড়া বন্ধনী ধারণকারী অভিব্যক্তির সংখ্যা যা সঠিকভাবে মেলানো হয়েছে, n+1 ফ্যাক্টর সম্পূর্ণভাবে বন্ধনীযুক্ত \n    করার বিভিন্ন উপায়ের সংখ্যা, এবং আরও অনেক কিছু।\n\n    আর্গুমেন্ট:\n    - n (int): Catalan সংখ্যা ক্রমে গণনা করার অবস্থান (অবশ্যই অ-ঋণাত্মক হতে হবে)।\n\n    রিটার্ন:\n    - int: nth Catalan সংখ্যা।\n\n    কেস:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    নোট:\n    গণনাটি পুনরাবৃত্ত সূত্রের উপর ভিত্তি করে:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    যেখানে C(0) হল 1।\n    ", "bg": "\n    Изчислете n-тото число на Каталан.\n\n    Функцията изчислява n-тото число на Каталан, използвайки динамично програмиране. Числата на Каталан са последователност от \n    естествени числа, които имат много приложения в комбинаторната математика, включително преброяване на определени видове \n    решетъчни пътища, броя на изразите, съдържащи n двойки скоби, които са правилно съчетани, броя на различните начини, по които \n    n+1 фактора могат да бъдат напълно скобирани, и други.\n\n    Аргументи:\n    - n (int): Позицията в последователността на числата на Каталан, която трябва да се изчисли (трябва да е неотрицателна).\n\n    Връща:\n    - int: n-тото число на Каталан.\n\n    Примери:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Забележка:\n    Изчислението се основава на рекурсивната формула:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    където C(0) е 1.\n    ", "zh": "\n    计算第 n 个 Catalan 数。\n\n    该函数使用动态规划计算第 n 个 Catalan 数。Catalan 数是一系列自然数，在组合数学中有许多应用，包括计数某些类型的格路径、包含 n 对括号的正确匹配表达式的数量、n+1 个因子可以完全括起来的不同方式的数量等。\n\n    参数:\n    - n (int): 要计算的 Catalan 数序列中的位置（必须是非负的）。\n\n    返回:\n    - int: 第 n 个 Catalan 数。\n\n    情况:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    注意:\n    计算基于递归公式:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    其中 C(0) 是 1。\n    ", "fr": "\n    Calculer le nième nombre de Catalan.\n\n    La fonction calcule le nième nombre de Catalan en utilisant la programmation dynamique. Les nombres de Catalan sont une \n    séquence de nombres naturels qui ont de nombreuses applications en mathématiques combinatoires, y compris le comptage de \n    certains types de chemins de grille, le nombre d'expressions contenant n paires de parenthèses correctement appariées, \n    le nombre de façons différentes dont n+1 facteurs peuvent être complètement parenthésés, et plus encore.\n\n    Args:\n    - n (int): La position dans la séquence des nombres de Catalan à calculer (doit être non-négative).\n\n    Returns:\n    - int: Le nième nombre de Catalan.\n\n    Cas:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    Le calcul est basé sur la formule récursive :\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    où C(0) est 1.\n    ", "de": "\n    Berechne die n-te Catalan-Zahl.\n\n    Die Funktion berechnet die n-te Catalan-Zahl unter Verwendung der dynamischen Programmierung. Catalan-Zahlen sind eine \n    Folge von natürlichen Zahlen, die viele Anwendungen in der kombinatorischen Mathematik haben, einschließlich der Zählung \n    bestimmter Arten von Gitterpfaden, der Anzahl der Ausdrücke, die n korrekt gepaarte Klammern enthalten, der Anzahl der \n    verschiedenen Möglichkeiten, n+1 Faktoren vollständig zu klammern, und mehr.\n\n    Argumente:\n    - n (int): Die Position in der Catalan-Zahlenfolge, die berechnet werden soll (muss nicht negativ sein).\n\n    Rückgabe:\n    - int: Die n-te Catalan-Zahl.\n\n    Fälle:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Hinweis:\n    Die Berechnung basiert auf der rekursiven Formel:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    wobei C(0) gleich 1 ist.\n    ", "ha": "\n    Lissafi lamba ta Catalan ta n.\n\n    Aikin yana lissafin lamba ta Catalan ta n ta amfani da shirye-shiryen motsi. Lambobin Catalan jerin lambobi ne na halitta \n    waɗanda suke da aikace-aikace da yawa a cikin lissafin haɗin gwiwa, ciki har da ƙididdigar wasu nau'ikan hanyoyin lattice, \n    adadin jimlolin da ke ɗauke da nau'i-nau'i na ma'aurata waɗanda aka haɗa daidai, adadin hanyoyin daban-daban na n+1 \n    abubuwa za a iya raba su gaba ɗaya, da ƙari.\n\n    Args:\n    - n (int): Matsayi a cikin jerin lambobin Catalan da za a lissafa (dole ne ya zama mara kyau).\n\n    Returns:\n    - int: Lamba ta Catalan ta n.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Lura:\n    Lissafin yana dogara ne akan tsarin maimaitawa:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    inda C(0) shine 1.\n    ", "hi": "\n    nth Catalan संख्या की गणना करें।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके nth Catalan संख्या की गणना करता है। Catalan संख्याएँ प्राकृतिक संख्याओं की एक श्रृंखला हैं जिनका संयोजक गणित में कई अनुप्रयोग हैं, जिसमें कुछ प्रकार के जाली पथों की गिनती, n जोड़े कोष्ठकों वाले अभिव्यक्तियों की संख्या जो सही ढंग से मेल खाते हैं, n+1 कारकों को पूरी तरह से कोष्ठक में रखने के विभिन्न तरीकों की संख्या, और अधिक शामिल हैं।\n\n    तर्क:\n    - n (int): Catalan संख्या अनुक्रम में गणना करने के लिए स्थिति (गैर-ऋणात्मक होनी चाहिए)।\n\n    लौटाता है:\n    - int: nth Catalan संख्या।\n\n    मामले:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    नोट:\n    गणना पुनरावर्ती सूत्र पर आधारित है:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    जहाँ C(0) 1 है।", "hu": "\n    Számítsa ki az n-edik Catalan számot.\n\n    A függvény dinamikus programozás segítségével számítja ki az n-edik Catalan számot. A Catalan számok olyan természetes számok sorozata, amelyeknek számos alkalmazása van a kombinatorikus matematikában, beleértve bizonyos típusú rácsos utak számolását, az n pár zárójelet tartalmazó kifejezések számát, amelyek helyesen párosítottak, az n+1 tényező teljes zárójelezésének különböző módjait, és még sok mást.\n\n    Paraméterek:\n    - n (int): A Catalan szám sorozatban a kiszámítandó pozíció (nem lehet negatív).\n\n    Visszatér:\n    - int: Az n-edik Catalan szám.\n\n    Esetek:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Megjegyzés:\n    A számítás az alábbi rekurzív képleten alapul:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ahol C(0) értéke 1.\n    ", "es": "    Calcular el enésimo número de Catalan.\n\n    La función calcula el enésimo número de Catalan utilizando programación dinámica. Los números de Catalan son una secuencia \n    de números naturales que tienen muchas aplicaciones en matemáticas combinatorias, incluyendo el conteo de ciertos tipos de \n    caminos en una cuadrícula, el número de expresiones que contienen n pares de paréntesis que están correctamente emparejados, \n    el número de diferentes maneras en que n+1 factores pueden ser completamente parentizados, y más.\n\n    Argumentos:\n    - n (int): La posición en la secuencia de números de Catalan a calcular (debe ser no negativa).\n\n    Devuelve:\n    - int: El enésimo número de Catalan.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    La computación se basa en la fórmula recursiva:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    donde C(0) es 1.", "arb": "    حساب العدد الكاتالاني nth.\n\n    تقوم الدالة بحساب العدد الكاتالاني nth باستخدام البرمجة الديناميكية. الأعداد الكاتالانية هي تسلسل من الأعداد الطبيعية التي لها العديد من التطبيقات في الرياضيات التوافقية، بما في ذلك عد أنواع معينة من مسارات الشبكة، عدد التعبيرات التي تحتوي على n من الأزواج من الأقواس المتطابقة بشكل صحيح، عدد الطرق المختلفة التي يمكن فيها وضع الأقواس بالكامل لعوامل n+1، وأكثر من ذلك.\n\n    يعيدالحجج:\n    - n (int): الموضع في تسلسل الأعداد الكاتالانية للحساب (يجب أن يكون غير سالب).\n\n    يعيد:\n    - int: العدد الكاتالاني nth.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    يعتمد الحساب على الصيغة التكرارية:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    حيث C(0) هو 1.", "sw": "    Hesabu nambari ya Catalan ya nth.\n\n    Kazi hii inahesabu nambari ya Catalan ya nth kwa kutumia programu ya nguvu. Nambari za Catalan ni mlolongo wa nambari \n    za asili ambazo zina matumizi mengi katika hisabati ya mchanganyiko, ikiwa ni pamoja na kuhesabu aina fulani za njia za \n    lattice, idadi ya maonyesho yanayojumuisha jozi n za mabano ambayo yameunganishwa kwa usahihi, idadi ya njia tofauti \n    ambazo vipengele n+1 vinaweza kuwekwa mabano kabisa, na zaidi.\n\n    Hoja:\n    - n (int): Nafasi katika mlolongo wa nambari za Catalan ya kuhesabu (lazima iwe isiyo hasi).\n\n    Inarejesha:\n    - int: Nambari ya Catalan ya nth.\n\n    Matukio:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Kumbuka:\n    Hesabu inategemea fomula ya kurudiarudia:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ambapo C(0) ni 1.", "tr": "    n. Katalan sayısını hesaplayın.\n\n    Fonksiyon, dinamik programlama kullanarak n. Katalan sayısını hesaplar. Katalan sayıları, kombinatoryal matematikte birçok \n    uygulamaya sahip doğal sayı dizisidir; belirli türdeki kafes yollarının sayısı, n çift parantez içeren ve doğru eşleşen ifadelerin \n    sayısı, n+1 faktörün tamamen parantezlenebileceği farklı yolların sayısı ve daha fazlası gibi.\n\n    Argümanlar:\n    - n (int): Hesaplanacak Katalan sayısı dizisindeki konum (negatif olmamalıdır).\n\n    Döndürür:\n    - int: n. Katalan sayısı.\n\n    Örnekler:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Not:\n    Hesaplama, aşağıdaki özyinelemeli formüle dayanır:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    burada C(0) 1'dir.", "vi": "    Tính số Catalan thứ n.\n\n    Hàm này tính số Catalan thứ n bằng cách sử dụng lập trình động. Các số Catalan là một dãy số tự nhiên có nhiều ứng dụng \n    trong toán học tổ hợp, bao gồm việc đếm một số loại đường đi trên lưới, số biểu thức chứa n cặp dấu ngoặc được ghép đúng, \n    số cách khác nhau mà n+1 thừa số có thể được đặt dấu ngoặc hoàn toàn, và nhiều hơn nữa.\n\n    Tham số:\n    - n (int): Vị trí trong dãy số Catalan cần tính (phải là số không âm).\n\n    Trả về:\n    - int: Số Catalan thứ n.\n\n    Trường hợp:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Lưu ý:\n    Việc tính toán dựa trên công thức đệ quy:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    trong đó C(0) là 1.", "id": "    Hitung bilangan Catalan ke-n.\n\n    Fungsi ini menghitung bilangan Catalan ke-n menggunakan pemrograman dinamis. Bilangan Catalan adalah urutan bilangan \n    alami yang memiliki banyak aplikasi dalam matematika kombinatorial, termasuk penghitungan jenis jalur kisi tertentu, \n    jumlah ekspresi yang mengandung n pasang tanda kurung yang cocok dengan benar, jumlah cara berbeda n+1 faktor dapat \n    sepenuhnya diberi tanda kurung, dan lainnya.\n\n    Args:\n    - n (int): Posisi dalam urutan bilangan Catalan yang akan dihitung (harus tidak negatif).\n\n    Returns:\n    - int: Bilangan Catalan ke-n.\n\n    Kasus:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Catatan:\n    Perhitungan didasarkan pada rumus rekursif:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    di mana C(0) adalah 1.", "ja": "    n番目のカタラン数を計算します。\n\n    この関数は動的プログラミングを使用してn番目のカタラン数を計算します。カタラン数は、組合せ数学において多くの応用を持つ自然数の列であり、特定の種類の格子経路の数、正しく対応するn組の括弧を含む式の数、n+1個の要素を完全に括弧で囲む異なる方法の数などがあります。\n\n    引数:\n    - n (int): 計算するカタラン数列の位置（非負でなければなりません）。\n\n    戻り値:\n    - int: n番目のカタラン数。\n\n    ケース:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    注意:\n    計算は以下の再帰的な式に基づいています:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ここで、C(0)は1です。", "ko": "    n번째 카탈란 수를 계산합니다.\n\n    이 함수는 동적 프로그래밍을 사용하여 n번째 카탈란 수를 계산합니다. 카탈란 수는 조합 수학에서 여러 응용을 가지는 자연수의 \n    수열로, 특정 유형의 격자 경로를 세는 것, n 쌍의 괄호가 올바르게 짝지어지는 표현식의 수, n+1개의 요소를 완전히 괄호화할 수 있는 \n    서로 다른 방법의 수 등을 포함합니다.\n\n    Args:\n    - n (int): 계산할 카탈란 수열의 위치 (음수가 아니어야 함).\n\n    Returns:\n    - int: n번째 카탈란 수.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    계산은 다음의 재귀 공식에 기반합니다:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    여기서 C(0)은 1입니다.", "ml": "    n-ആം കാറ്റലാൻ സംഖ്യ കണക്കാക്കുക.\n\n    ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് ഉപയോഗിച്ച് n-ആം കാറ്റലാൻ സംഖ്യ കണക്കാക്കുന്നു. കാറ്റലാൻ സംഖ്യകൾ സംയോജക ഗണിതശാസ്ത്രത്തിൽ \n    നിരവധി പ്രയോഗങ്ങൾ ഉള്ള പ്രകൃതിസംഖ്യകളുടെ ഒരു ശ്രേണിയാണ്, ഇതിൽ ചില തരത്തിലുള്ള ലാറ്റീസ് പാതകൾ എണ്ണൽ, ശരിയായി പൊരുത്തപ്പെടുന്ന \n    n ജോഡികളുള്ള വാക്യങ്ങൾ, n+1 ഘടകങ്ങൾ പൂർണ്ണമായും വാക്യഘടന ചെയ്യാൻ ഉള്ള വ്യത്യസ്ത മാർഗ്ഗങ്ങളുടെ എണ്ണം എന്നിവ ഉൾപ്പെടുന്നു.\n\n    Args:\n    - n (int): കണക്കാക്കേണ്ട കാറ്റലാൻ സംഖ്യാ ശ്രേണിയിലെ സ്ഥാനം (അനുകൂലമായിരിക്കണം).\n\n    Returns:\n    - int: n-ആം കാറ്റലാൻ സംഖ്യ.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    കണക്കാക്കൽ പുനരാവർത്തന സൂത്രവാക്യത്തിൽ അടിസ്ഥാനമാക്കിയുള്ളതാണ്:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ഇവിടെ C(0) 1 ആണ്.", "fa": "    محاسبه nاُمین عدد کاتالان.\n\n    این تابع nاُمین عدد کاتالان را با استفاده از برنامه‌نویسی پویا محاسبه می‌کند. اعداد کاتالان دنباله‌ای از اعداد طبیعی \n    هستند که کاربردهای زیادی در ریاضیات ترکیبیاتی دارند، از جمله شمارش انواع خاصی از مسیرهای شبکه، تعداد عبارات حاوی n جفت \n    پرانتز که به درستی جفت شده‌اند، تعداد روش‌های مختلفی که n+1 عامل می‌توانند به طور کامل پرانتزگذاری شوند، و بیشتر.\n\n    Args:\n    - n (int): موقعیت در دنباله عدد کاتالان برای محاسبه (باید غیرمنفی باشد).\n\n    Returns:\n    - int: nاُمین عدد کاتالان.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    محاسبه بر اساس فرمول بازگشتی است:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    که در آن C(0) برابر 1 است."}}
{"task_id": "Python/35", "prompt": {"en": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "sq": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Llogarit numrin e mollëve që Tao Tao mund të arrijë.\n\n    Args:\n    apple_heights (List[int]): Lartësitë e mollëve nga toka (në centimetra).\n    tao_reach (int): Lartësia maksimale që Tao Tao mund të arrijë me dorën e saj të shtrirë lart (në centimetra).\n\n    Returns:\n    int: Numri i mollëve që Tao Tao mund të arrijë me ose pa qëndruar në një stol 30cm.\n\n    Kjo funksion kalon nëpër listën e lartësive të mollëve dhe numëron sa prej tyre janë brenda arritjes së Tao Tao,\n    duke marrë parasysh një shtesë prej 30cm që ofron stoli.\n\n    Shembuj rastesh:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "hy": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Հաշվել այն խնձորների քանակը, որոնք Թաո Թաոն կարող է հասնել։\n\n    Պարամետրեր:\n    apple_heights (List[int]): Խնձորների բարձրությունները գետնից (սանտիմետրերով)։\n    tao_reach (int): Առավելագույն բարձրությունը, որին Թաո Թաոն կարող է հասնել իր ձեռքը վեր բարձրացնելիս (սանտիմետրերով)։\n\n    Վերադարձնում է:\n    int: Խնձորների քանակը, որոնց Թաո Թաոն կարող է հասնել՝ կանգնած կամ առանց 30 սմ բարձրության նստարանի։\n\n    Այս ֆունկցիան անցնում է խնձորների բարձրությունների ցանկով և հաշվում, թե դրանցից քանիսն են Թաո Թաոյի հասանելիության սահմաններում՝\n    հաշվի առնելով 30 սմ հավելյալ բարձրությունը, որը տրամադրում է նստարանը։\n\n    Օրինակներ:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> վերադարձնում է 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> վերադարձնում է 0\n    \"\"\"", "bn": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    কতগুলি আপেল তাও তাও পৌঁছাতে পারে তা গণনা করুন।\n\n    Args:\n    apple_heights (List[int]): মাটি থেকে আপেলের উচ্চতা (সেন্টিমিটারে)।\n    tao_reach (int): তাও তাও তার হাত প্রসারিত করে পৌঁছাতে পারে এমন সর্বাধিক উচ্চতা (সেন্টিমিটারে)।\n\n    Returns:\n    int: তাও তাও একটি 30cm স্টুলে দাঁড়িয়ে বা না দাঁড়িয়ে কতগুলি আপেল পৌঁছাতে পারে।\n\n    এই ফাংশনটি আপেলের উচ্চতার তালিকার উপর পুনরাবৃত্তি করে এবং তাদের মধ্যে কতগুলি তাও তাও এর নাগালের মধ্যে আছে তা গণনা করে,\n    স্টুলটি যে অতিরিক্ত 30cm প্রদান করে তা বিবেচনা করে।\n\n    উদাহরণ কেস:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "bg": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Изчислете броя на ябълките, до които Тао Тао може да достигне.\n\n    Аргументи:\n    apple_heights (List[int]): Височините на ябълките от земята (в сантиметри).\n    tao_reach (int): Максималната височина, до която Тао Тао може да достигне с протегната ръка нагоре (в сантиметри).\n\n    Връща:\n    int: Броят на ябълките, до които Тао Тао може да достигне със или без да стои на столче от 30 см.\n\n    Тази функция преминава през списъка с височини на ябълките и брои колко от тях са в обсега на Тао Тао,\n    като се вземат предвид допълнителните 30 см, които столчето предоставя.\n\n    Примерни случаи:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "zh": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    计算陶陶可以够到的苹果数量。\n\n    参数:\n    apple_heights (List[int]): 苹果距离地面的高度（以厘米为单位）。\n    tao_reach (int): 陶陶伸手向上可以达到的最大高度（以厘米为单位）。\n\n    返回:\n    int: 陶陶站在30厘米高的凳子上或不站凳子上可以够到的苹果数量。\n\n    该函数遍历苹果高度列表，并计算其中有多少在陶陶的可达范围内，\n    考虑到凳子提供的额外30厘米。\n\n    示例案例:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "fr": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculer le nombre de pommes que Tao Tao peut atteindre.\n\n    Args:\n    apple_heights (List[int]): Les hauteurs des pommes à partir du sol (en centimètres).\n    tao_reach (int): La hauteur maximale que Tao Tao peut atteindre avec sa main tendue vers le haut (en centimètres).\n\n    Returns:\n    int: Le nombre de pommes que Tao Tao peut atteindre avec ou sans se tenir sur un tabouret de 30 cm.\n\n    Cette fonction parcourt la liste des hauteurs des pommes et compte combien d'entre elles sont à la portée de Tao Tao,\n    en considérant un supplément de 30 cm que le tabouret fournit.\n\n    Exemples de cas :\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "de": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Berechne die Anzahl der Äpfel, die Tao Tao erreichen kann.\n\n    Args:\n    apple_heights (List[int]): Die Höhen der Äpfel vom Boden aus (in Zentimetern).\n    tao_reach (int): Die maximale Höhe, die Tao Tao mit ausgestreckter Hand erreichen kann (in Zentimetern).\n\n    Returns:\n    int: Die Anzahl der Äpfel, die Tao Tao mit oder ohne einen 30cm hohen Hocker erreichen kann.\n\n    Diese Funktion iteriert über die Liste der Apfelhöhen und zählt, wie viele davon in Reichweite von Tao Tao sind,\n    wobei zusätzliche 30cm berücksichtigt werden, die der Hocker bietet.\n\n    Beispielhafte Fälle:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "ha": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Lissafa yawan tuffaɗan da Tao Tao za ta iya kaiwa.\n\n    Args:\n    apple_heights (List[int]): Tsayin tuffaɗan daga ƙasa (a santimita).\n    tao_reach (int): Matsakaicin tsayin da Tao Tao za ta iya kaiwa da hannunta a miƙe sama (a santimita).\n\n    Returns:\n    int: Yawan tuffaɗan da Tao Tao za ta iya kaiwa tare da ko ba tare da tsayawa a kan kujerar 30cm ba.\n\n    Wannan aikin yana zagayawa cikin jerin tsayin tuffaɗan kuma yana ƙirga nawa daga cikinsu suke cikin isar Tao Tao,\n    la'akari da ƙarin 30cm da kujerar ke bayarwa.\n\n    Misalan lokuta:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "hi": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    गणना करें कि ताओ ताओ कितने सेब तक पहुँच सकती है।\n\n    Args:\n    apple_heights (List[int]): जमीन से सेबों की ऊँचाई (सेंटीमीटर में)।\n    tao_reach (int): अधिकतम ऊँचाई तक ताओ ताओ अपने हाथ को ऊपर की ओर खींचकर पहुँच सकती है (सेंटीमीटर में)।\n\n    Returns:\n    int: सेबों की संख्या जिन तक ताओ ताओ 30 सेमी स्टूल पर खड़े होकर या बिना खड़े होकर पहुँच सकती है।\n\n    यह फ़ंक्शन सेबों की ऊँचाई की सूची पर इटरेट करता है और गिनता है कि उनमें से कितने ताओ ताओ की पहुँच के भीतर हैं,\n    30 सेमी की अतिरिक्त ऊँचाई को ध्यान में रखते हुए जो स्टूल प्रदान करता है।\n\n    उदाहरण मामले:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "hu": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Számítsd ki, hogy hány almát ér el Tao Tao.\n\n    Paraméterek:\n    apple_heights (List[int]): Az almák magassága a talajtól (centiméterben).\n    tao_reach (int): A maximális magasság, amit Tao Tao elérhet kinyújtott kézzel (centiméterben).\n\n    Visszatér:\n    int: Az almák száma, amelyeket Tao Tao elérhet akár egy 30 cm-es zsámolyon állva is.\n\n    Ez a függvény végigmegy az almák magasságának listáján, és megszámolja, hány közülük van Tao Tao elérhetőségi tartományában,\n    figyelembe véve a zsámoly által biztosított további 30 cm-t.\n\n    Példa esetek:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> visszaadja 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> visszaadja 0\n    \"\"\"", "es": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calcular el número de manzanas que Tao Tao puede alcanzar.\n\n    Argumentos:\n    apple_heights (List[int]): Las alturas de las manzanas desde el suelo (en centímetros).\n    tao_reach (int): La altura máxima que Tao Tao puede alcanzar con su mano estirada hacia arriba (en centímetros).\n\n    Devuelve:\n    int: El número de manzanas que Tao Tao puede alcanzar con o sin pararse en un taburete de 30 cm.\n\n    Esta función itera sobre la lista de alturas de las manzanas y cuenta cuántas de ellas están al alcance de Tao Tao,\n    considerando un adicional de 30 cm que proporciona el taburete.\n\n    Casos de ejemplo:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> devuelve 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> devuelve 0\n    \"\"\"", "arb": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    حساب عدد التفاح الذي يمكن لـ تاو تاو الوصول إليه.\n\n    يعيدالحجج:\n    apple_heights (List[int]): ارتفاعات التفاح من الأرض (بالسنتيمترات).\n    tao_reach (int): أقصى ارتفاع يمكن لـ تاو تاو الوصول إليه بيدها ممدودة للأعلى (بالسنتيمترات).\n\n    يعيد:\n    int: عدد التفاح الذي يمكن لـ تاو تاو الوصول إليه مع أو بدون الوقوف على كرسي بارتفاع 30 سم.\n\n    تقوم هذه الدالة بالتكرار على قائمة ارتفاعات التفاح وتحصي عدد التفاح الذي يقع ضمن مدى وصول تاو تاو،\n    مع الأخذ في الاعتبار 30 سم إضافية يوفرها الكرسي.\n\n    أمثلة الحالات:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> يعيد 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> يعيد 0\n    \"\"\"", "sw": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Kuhesabu idadi ya maapulo ambayo Tao Tao anaweza kuyafikia.\n\n    Hoja:\n    apple_heights (List[int]): Urefu wa maapulo kutoka ardhini (katika sentimita).\n    tao_reach (int): Urefu wa juu zaidi ambao Tao Tao anaweza kufikia kwa mkono wake ulionyoshwa juu (katika sentimita).\n\n    Inarejesha:\n    int: Idadi ya maapulo ambayo Tao Tao anaweza kuyafikia akiwa amesimama au bila kusimama kwenye kigoda cha sentimita 30.\n\n    Kazi hii inazunguka kwenye orodha ya urefu wa maapulo na kuhesabu ni mangapi kati yao yako ndani ya uwezo wa kufikiwa na Tao Tao,\n    ikizingatia sentimita 30 za ziada ambazo kigoda kinatoa.\n\n    Mifano ya kesi:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> inarejesha 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> inarejesha 0\n    \"\"\"", "tr": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tao Tao'nun ulaşabileceği elma sayısını hesaplayın.\n\n    Argümanlar:\n    apple_heights (List[int]): Elmaların yerden yüksekliği (santimetre cinsinden).\n    tao_reach (int): Tao Tao'nun elini yukarı doğru uzattığında ulaşabileceği maksimum yükseklik (santimetre cinsinden).\n\n    Döndürür:\n    int: Tao Tao'nun 30cm'lik bir tabureye çıkıp çıkmadan ulaşabileceği elma sayısı.\n\n    Bu fonksiyon, elma yükseklikleri listesini dolaşır ve taburenin sağladığı ek 30cm'yi dikkate alarak,\n    kaç tanesinin Tao Tao'nun erişim alanında olduğunu sayar.\n\n    Örnek durumlar:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 10 döndürür\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 0 döndürür \n    \"\"\"", "vi": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tính số lượng táo mà Tao Tao có thể với tới.\n\n    Tham số:\n    apple_heights (List[int]): Chiều cao của các quả táo từ mặt đất (tính bằng centimet).\n    tao_reach (int): Chiều cao tối đa mà Tao Tao có thể với tới khi giơ tay lên (tính bằng centimet).\n\n    Trả về:\n    int: Số lượng táo mà Tao Tao có thể với tới có hoặc không đứng trên ghế đẩu cao 30cm.\n\n    Hàm này duyệt qua danh sách chiều cao của các quả táo và đếm xem có bao nhiêu quả trong tầm với của Tao Tao,\n    xét thêm 30cm mà ghế đẩu cung cấp.\n\n    Ví dụ:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> trả về 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> trả về 0\n    \"\"\"", "id": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Hitung jumlah apel yang dapat dijangkau oleh Tao Tao.\n\n    Args:\n    apple_heights (List[int]): Tinggi apel dari tanah (dalam sentimeter).\n    tao_reach (int): Tinggi maksimum yang dapat dijangkau Tao Tao dengan tangannya terentang ke atas (dalam sentimeter).\n\n    Returns:\n    int: Jumlah apel yang dapat dijangkau Tao Tao dengan atau tanpa berdiri di atas bangku setinggi 30cm.\n\n    Fungsi ini mengiterasi daftar tinggi apel dan menghitung berapa banyak dari mereka yang berada dalam jangkauan Tao Tao,\n    dengan mempertimbangkan tambahan 30cm yang diberikan oleh bangku.\n\n    Contoh kasus:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> mengembalikan 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> mengembalikan 0\n    \"\"\"", "ja": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tao Taoが届くリンゴの数を計算します。\n\n    Args:\n    apple_heights (List[int]): 地面からのリンゴの高さ（センチメートル単位）。\n    tao_reach (int): Tao Taoが手を伸ばして届く最大の高さ（センチメートル単位）。\n\n    Returns:\n    int: Tao Taoが30cmの踏み台を使うか使わないかで届くリンゴの数。\n\n    この関数はリンゴの高さのリストを反復処理し、踏み台が提供する追加の30cmを考慮して、\n    Tao Taoの手の届く範囲にあるリンゴの数を数えます。\n\n    例:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "ko": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tao Tao가 닿을 수 있는 사과의 개수를 계산합니다.\n\n    매개변수:\n    apple_heights (List[int]): 땅에서부터 사과까지의 높이 (센티미터 단위).\n    tao_reach (int): Tao Tao가 손을 뻗었을 때 닿을 수 있는 최대 높이 (센티미터 단위).\n\n    반환값:\n    int: Tao Tao가 30cm 발판에 서 있거나 서 있지 않을 때 닿을 수 있는 사과의 개수.\n\n    이 함수는 사과 높이 목록을 순회하며 Tao Tao의 닿을 수 있는 범위 내에 있는 사과의 개수를 셉니다.\n    발판이 제공하는 추가 30cm를 고려합니다.\n\n    예제:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "ml": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    ടാവോ ടാവോക്ക് എത്തിച്ചേരാൻ കഴിയുന്ന ആപ്പിളുകളുടെ എണ്ണം കണക്കാക്കുക.\n\n    Args:\n    apple_heights (List[int]): നിലത്ത് നിന്ന് ആപ്പിളുകളുടെ ഉയരം (സെ.മീ.ൽ).\n    tao_reach (int): ടാവോ ടാവോക്ക് കൈ ഉയർത്തി നീട്ടിയപ്പോൾ എത്തിച്ചേരാൻ കഴിയുന്ന പരമാവധി ഉയരം (സെ.മീ.ൽ).\n\n    Returns:\n    int: 30cm സ്റ്റൂൾ ഉപയോഗിച്ച് അല്ലാതെയോ ടാവോ ടാവോക്ക് എത്തിച്ചേരാൻ കഴിയുന്ന ആപ്പിളുകളുടെ എണ്ണം.\n\n    ഈ ഫംഗ്ഷൻ ആപ്പിളിന്റെ ഉയരങ്ങളുടെ പട്ടികയിലൂടെ ആവർത്തിച്ച്, ടാവോ ടാവോയുടെ എത്തിച്ചേരലിനുള്ള പരിധിക്കുള്ളിൽ എത്ര എണ്ണം ആപ്പിളുകൾ വരുന്നതാണെന്ന് എണ്ണുന്നു,\n    സ്റ്റൂൾ നൽകുന്ന അധിക 30cm പരിഗണിച്ച്.\n\n    ഉദാഹരണ കേസുകൾ:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"", "fa": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    تعداد سیب‌هایی که تائو تائو می‌تواند به آنها برسد را محاسبه کنید.\n\n    Args:\n    apple_heights (List[int]): ارتفاع سیب‌ها از زمین (به سانتی‌متر).\n    tao_reach (int): حداکثر ارتفاعی که تائو تائو می‌تواند با دست کشیده به بالا برسد (به سانتی‌متر).\n\n    Returns:\n    int: تعداد سیب‌هایی که تائو تائو می‌تواند با یا بدون ایستادن روی یک چهارپایه ۳۰ سانتی‌متری به آنها برسد.\n\n    این تابع بر روی لیست ارتفاع سیب‌ها تکرار می‌شود و تعداد سیب‌هایی که در دسترس تائو تائو هستند را می‌شمارد،\n    با در نظر گرفتن ۳۰ سانتی‌متر اضافی که چهارپایه فراهم می‌کند.\n\n    مثال‌ها:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\""}, "canonical_solution": "    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples", "instruction": {"en": "Write a python function 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' to solve the following problem:\n\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    ", "sq": "Shkruani një funksion python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit numrin e mollëve që Tao Tao mund të arrijë.\n\n    Args:\n    apple_heights (List[int]): Lartësitë e mollëve nga toka (në centimetra).\n    tao_reach (int): Lartësia maksimale që Tao Tao mund të arrijë me dorën e saj të shtrirë lart (në centimetra).\n\n    Returns:\n    int: Numri i mollëve që Tao Tao mund të arrijë me ose pa qëndruar në një stol 30cm.\n\n    Kjo funksion kalon nëpër listën e lartësive të mollëve dhe numëron sa prej tyre janë brenda arritjes së Tao Tao,\n    duke marrë parasysh një shtesë prej 30cm që stoli ofron.\n\n    Raste shembuj:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "hy": "Պայթոն ֆունկցիա 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք այն խնձորների քանակը, որոնց Թաո Թաոն կարող է հասնել։\n\n    Արգումենտներ:\n    apple_heights (List[int]): Խնձորների բարձրությունները գետնից (սանտիմետրերով)։\n    tao_reach (int): Առավելագույն բարձրությունը, որին Թաո Թաոն կարող է հասնել՝ ձեռքը վեր պարզելով (սանտիմետրերով)։\n\n    Վերադարձնում է:\n    int: Խնձորների քանակը, որոնց Թաո Թաոն կարող է հասնել՝ կանգնելով կամ չկանգնելով 30 սմ բարձրության նստարանի վրա։\n\n    Այս ֆունկցիան անցնում է խնձորների բարձրությունների ցուցակի միջով և հաշվում, թե դրանցից քանիսն են Թաո Թաոի հասանելիության սահմաններում՝ հաշվի առնելով 30 սմ լրացուցիչ բարձրությունը, որը տրամադրում է նստարանը։\n\n    Օրինակներ:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> վերադարձնում է 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> վերադարձնում է 0", "bn": "একটি পাইথন ফাংশন 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    তাও তাও কতগুলি আপেল পৌঁছাতে পারে তা গণনা করুন।\n\n    আর্গুমেন্টস:\n    apple_heights (List[int]): মাটি থেকে আপেলগুলির উচ্চতা (সেন্টিমিটারে)।\n    tao_reach (int): তাও তাও তার হাত প্রসারিত করে সর্বাধিক যে উচ্চতায় পৌঁছাতে পারে (সেন্টিমিটারে)।\n\n    রিটার্নস:\n    int: তাও তাও একটি 30cm স্টুলের উপর দাঁড়িয়ে বা না দাঁড়িয়ে কতগুলি আপেল পৌঁছাতে পারে।\n\n    এই ফাংশনটি আপেলগুলির উচ্চতার তালিকার উপর পুনরাবৃত্তি করে এবং তাদের মধ্যে কতগুলি তাও তাও এর নাগালের মধ্যে রয়েছে তা গণনা করে,\n    স্টুলটি যে অতিরিক্ত 30cm প্রদান করে তা বিবেচনা করে।\n\n    উদাহরণ কেস:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "bg": "Напишете Python функция 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:', за да решите следния проблем:\n\n    Изчислете броя на ябълките, които Тао Тао може да достигне.\n\n    Аргументи:\n    apple_heights (List[int]): Височините на ябълките от земята (в сантиметри).\n    tao_reach (int): Максималната височина, която Тао Тао може да достигне с протегната ръка нагоре (в сантиметри).\n\n    Връща:\n    int: Броят на ябълките, които Тао Тао може да достигне със или без да стои на 30см столче.\n\n    Тази функция преминава през списъка с височини на ябълките и преброява колко от тях са в обсега на Тао Тао,\n    като се вземат предвид допълнителните 30см, които предоставя столчето.\n\n    Примерни случаи:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> връща 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> връща 0", "zh": "编写一个Python函数 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' 来解决以下问题：\n\n    计算陶陶可以够到的苹果数量。\n\n    参数：\n    apple_heights (List[int]): 苹果距离地面的高度（以厘米为单位）。\n    tao_reach (int): 陶陶伸手向上可以达到的最大高度（以厘米为单位）。\n\n    返回：\n    int: 陶陶在站上30厘米高的凳子上或不站凳子时可以够到的苹果数量。\n\n    此函数遍历苹果高度列表，并计算有多少苹果在陶陶的可及范围内，\n    考虑到凳子提供的额外30厘米。\n\n    示例案例：\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 返回 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 返回 0", "fr": "Écrivez une fonction python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nombre de pommes que Tao Tao peut atteindre.\n\n    Args:\n    apple_heights (List[int]): Les hauteurs des pommes à partir du sol (en centimètres).\n    tao_reach (int): La hauteur maximale que Tao Tao peut atteindre avec sa main tendue vers le haut (en centimètres).\n\n    Returns:\n    int: Le nombre de pommes que Tao Tao peut atteindre avec ou sans se tenir sur un tabouret de 30 cm.\n\n    Cette fonction parcourt la liste des hauteurs des pommes et compte combien d'entre elles sont à la portée de Tao Tao,\n    en tenant compte d'un supplément de 30 cm que le tabouret fournit.\n\n    Cas d'exemple :\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "de": "Schreiben Sie eine Python-Funktion 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die Anzahl der Äpfel, die Tao Tao erreichen kann.\n\n    Argumente:\n    apple_heights (List[int]): Die Höhen der Äpfel vom Boden aus (in Zentimetern).\n    tao_reach (int): Die maximale Höhe, die Tao Tao mit ausgestreckter Hand erreichen kann (in Zentimetern).\n\n    Rückgabewert:\n    int: Die Anzahl der Äpfel, die Tao Tao mit oder ohne Stehen auf einem 30cm hohen Hocker erreichen kann.\n\n    Diese Funktion durchläuft die Liste der Apfelhöhen und zählt, wie viele davon innerhalb der Reichweite von Tao Tao liegen,\n    wobei zusätzlich 30cm berücksichtigt werden, die der Hocker bietet.\n\n    Beispiel-Fälle:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> gibt 10 zurück\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> gibt 0 zurück", "ha": "Rubuta wani aikin python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa yawan tuffa da Tao Tao za ta iya kaiwa.\n\n    Args:\n    apple_heights (List[int]): Tsayin tuffa daga ƙasa (a cikin santimita).\n    tao_reach (int): Matsakaicin tsayin da Tao Tao za ta iya kaiwa tare da hannunta a miƙe sama (a cikin santimita).\n\n    Returns:\n    int: Yawan tuffa da Tao Tao za ta iya kaiwa tare da ko ba tare da tsayawa a kan kujerar 30cm ba.\n\n    Wannan aikin yana juyawa ta jerin tsayin tuffa kuma yana ƙidaya nawa daga cikinsu suke cikin isar Tao Tao,\n    la'akari da ƙarin 30cm da kujerar ke bayarwa.\n\n    Misalan lokuta:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "hi": "एक पायथन फ़ंक्शन 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    उन सेबों की संख्या की गणना करें जिन्हें ताओ ताओ पहुंच सकती है।\n\n    तर्क:\n    apple_heights (List[int]): जमीन से सेबों की ऊंचाई (सेंटीमीटर में)।\n    tao_reach (int): अधिकतम ऊंचाई जिसे ताओ ताओ अपने हाथ को ऊपर की ओर खींचकर पहुंच सकती है (सेंटीमीटर में)।\n\n    लौटाता है:\n    int: उन सेबों की संख्या जिन्हें ताओ ताओ 30 सेमी स्टूल पर खड़े होकर या बिना खड़े हुए पहुंच सकती है।\n\n    यह फ़ंक्शन सेब की ऊंचाइयों की सूची पर पुनरावृत्ति करता है और गिनता है कि उनमें से कितने ताओ ताओ की पहुंच के भीतर हैं,\n    स्टूल द्वारा प्रदान किए गए अतिरिक्त 30 सेमी को ध्यान में रखते हुए।\n\n    उदाहरण मामले:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "hu": "Írj egy python függvényt 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' a következő probléma megoldására:\n\n    Számítsd ki, hány almát ér el Tao Tao.\n\n    Args:\n    apple_heights (List[int]): Az almák magassága a talajtól (centiméterben).\n    tao_reach (int): A maximális magasság, amit Tao Tao elérhet kinyújtott kézzel (centiméterben).\n\n    Visszatér:\n    int: Az almák száma, amelyeket Tao Tao elérhet akár 30 cm-es sámlin állva, akár anélkül.\n\n    Ez a függvény végigmegy az alma magasságok listáján, és megszámolja, hány van közülük Tao Tao elérhetőségi tartományában,\n    figyelembe véve a sámi által biztosított további 30 cm-t.\n\n    Példa esetek:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> visszatér 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> visszatér 0", "es": "Escribe una función de Python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' para resolver el siguiente problema:\n\n    Calcular el número de manzanas que Tao Tao puede alcanzar.\n\n    Argumentos:\n    apple_heights (List[int]): Las alturas de las manzanas desde el suelo (en centímetros).\n    tao_reach (int): La altura máxima que Tao Tao puede alcanzar con su mano estirada hacia arriba (en centímetros).\n\n    Devuelve:\n    int: El número de manzanas que Tao Tao puede alcanzar con o sin pararse en un taburete de 30 cm.\n\n    Esta función itera sobre la lista de alturas de las manzanas y cuenta cuántas de ellas están al alcance de Tao Tao,\n    considerando un adicional de 30 cm que proporciona el taburete.\n\n    Casos de ejemplo:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> devuelve 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> devuelve 0", "arb": "اكتب دالة بايثون 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' لحل المشكلة التالية:\n\n    احسب عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه.\n\n    يعيدالحجج:\n    apple_heights (List[int]): ارتفاعات التفاح من الأرض (بالسنتيمترات).\n    tao_reach (int): أقصى ارتفاع يمكن لـ Tao Tao الوصول إليه بيدها ممدودة للأعلى (بالسنتيمترات).\n\n    يعيد:\n    int: عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه مع أو بدون الوقوف على كرسي بارتفاع 30 سم.\n\n    تقوم هذه الدالة بتكرار قائمة ارتفاعات التفاح وتحصي عدد التفاح الذي يمكن الوصول إليه ضمن مدى Tao Tao،\n    مع الأخذ في الاعتبار 30 سم إضافية التي يوفرها الكرسي.\n\n    أمثلة الحالات:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> يعيد 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> يعيد 0", "sw": "Andika kazi ya python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ya maapulo ambayo Tao Tao anaweza kuyafikia.\n\n    Hoja:\n    apple_heights (List[int]): Urefu wa maapulo kutoka ardhini (katika sentimita).\n    tao_reach (int): Urefu wa juu zaidi ambao Tao Tao anaweza kufikia kwa mkono wake ukiwa umenyooka juu (katika sentimita).\n\n    Inarejesha:\n    int: Idadi ya maapulo ambayo Tao Tao anaweza kuyafikia akiwa amesimama au bila kusimama kwenye kigoda cha sentimita 30.\n\n    Kazi hii inazunguka kwenye orodha ya urefu wa maapulo na kuhesabu ni mangapi kati yao yako ndani ya uwezo wa kufikiwa na Tao Tao,\n    ikizingatia sentimita 30 za ziada ambazo kigoda kinatoa.\n\n    Mifano ya kesi:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> inarejesha 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> inarejesha 0", "tr": "Bir python fonksiyonu 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Tao Tao'nun ulaşabileceği elma sayısını hesaplayın.\n\n    Argümanlar:\n    apple_heights (List[int]): Elmaların yerden yüksekliği (santimetre cinsinden).\n    tao_reach (int): Tao Tao'nun elini yukarı doğru uzattığında ulaşabileceği maksimum yükseklik (santimetre cinsinden).\n\n    Döndürür:\n    int: Tao Tao'nun 30cm tabureye çıkmadan veya çıkmadan ulaşabileceği elma sayısı.\n\n    Bu fonksiyon, elma yükseklikleri listesini dolaşır ve taburenin sağladığı ek 30cm'yi dikkate alarak Tao Tao'nun erişebileceği kaç tanesini sayar.\n\n    Örnek durumlar:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 10 döndürür\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 0 döndürür", "vi": "Viết một hàm python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' để giải quyết vấn đề sau:\n\n    Tính số lượng táo mà Tao Tao có thể với tới.\n\n    Tham số:\n    apple_heights (List[int]): Chiều cao của các quả táo tính từ mặt đất (tính bằng cm).\n    tao_reach (int): Chiều cao tối đa mà Tao Tao có thể với tới khi giơ tay lên (tính bằng cm).\n\n    Trả về:\n    int: Số lượng táo mà Tao Tao có thể với tới, có hoặc không đứng trên ghế đẩu cao 30cm.\n\n    Hàm này duyệt qua danh sách chiều cao của các quả táo và đếm xem có bao nhiêu quả nằm trong tầm với của Tao Tao,\n    bao gồm cả 30cm thêm mà ghế đẩu cung cấp.\n\n    Ví dụ:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> trả về 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> trả về 0", "id": "Tulis sebuah fungsi python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung jumlah apel yang dapat dijangkau oleh Tao Tao.\n\n    Argumen:\n    apple_heights (List[int]): Tinggi apel dari tanah (dalam sentimeter).\n    tao_reach (int): Tinggi maksimum yang dapat dijangkau Tao Tao dengan tangannya terentang ke atas (dalam sentimeter).\n\n    Mengembalikan:\n    int: Jumlah apel yang dapat dijangkau Tao Tao dengan atau tanpa berdiri di atas bangku setinggi 30cm.\n\n    Fungsi ini mengiterasi daftar tinggi apel dan menghitung berapa banyak dari mereka yang berada dalam jangkauan Tao Tao,\n    dengan mempertimbangkan tambahan 30cm yang diberikan oleh bangku.\n\n    Contoh kasus:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> mengembalikan 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> mengembalikan 0", "ja": "Python関数を書いてください。 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' を使用して、次の問題を解決してください:\n\n    Tao Taoが届くリンゴの数を計算します。\n\n    Args:\n    apple_heights (List[int]): 地面からのリンゴの高さ（センチメートル単位）。\n    tao_reach (int): Tao Taoが手を伸ばして届く最大の高さ（センチメートル単位）。\n\n    Returns:\n    int: Tao Taoが30cmの踏み台を使っても使わなくても届くリンゴの数。\n\n    この関数はリンゴの高さのリストを反復処理し、踏み台が提供する追加の30cmを考慮して、Tao Taoの手が届くリンゴの数を数えます。\n\n    例:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "ko": "파이썬 함수를 작성하세요 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' 다음 문제를 해결하기 위해:\n\n    타오 타오가 닿을 수 있는 사과의 수를 계산합니다.\n\n    매개변수:\n    apple_heights (List[int]): 땅에서부터 사과의 높이 (센티미터 단위).\n    tao_reach (int): 타오 타오가 손을 뻗었을 때 닿을 수 있는 최대 높이 (센티미터 단위).\n\n    반환값:\n    int: 타오 타오가 30cm 의자에 서 있거나 서 있지 않을 때 닿을 수 있는 사과의 수.\n\n    이 함수는 사과 높이 목록을 순회하며, 의자가 제공하는 추가 30cm를 고려하여 타오 타오가 닿을 수 있는 사과의 수를 셉니다.\n\n    예시 사례:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "ml": "'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' എന്ന പൈതൺ ഫംഗ്ഷൻ എഴുതുക താഴെ കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    താവോ താവോക്ക് എത്താൻ കഴിയുന്ന ആപ്പിളുകളുടെ എണ്ണം കണക്കാക്കുക.\n\n    Args:\n    apple_heights (List[int]): നിലത്തു നിന്ന് ആപ്പിളുകളുടെ ഉയരങ്ങൾ (സെ.മീ.യിൽ).\n    tao_reach (int): താവോ താവോക്ക് കൈ ഉയർത്തിയാൽ എത്താൻ കഴിയുന്ന പരമാവധി ഉയരം (സെ.മീ.യിൽ).\n\n    Returns:\n    int: താവോ താവോക്ക് 30cm സ്റ്റൂൾ ഉപയോഗിച്ച് അല്ലാതെയോ എത്താൻ കഴിയുന്ന ആപ്പിളുകളുടെ എണ്ണം.\n\n    ഈ ഫംഗ്ഷൻ ആപ്പിളുകളുടെ ഉയരങ്ങളുടെ പട്ടികയിൽ ആവർത്തിച്ച്, സ്റ്റൂൾ നൽകുന്ന 30cm അധികം പരിഗണിച്ച്, \n    താവോ താവോയുടെ എത്തിനോട്ടത്തിൽ എത്ര എണ്ണം ആപ്പിളുകൾ വരുന്നു എന്ന് എണ്ണുന്നു.\n\n    ഉദാഹരണ കേസുകൾ:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "fa": "یک تابع پایتون بنویسید 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' برای حل مسئله زیر:\n\n    تعداد سیب‌هایی که تائو تائو می‌تواند به آن‌ها برسد را محاسبه کنید.\n\n    آرگومان‌ها:\n    apple_heights (List[int]): ارتفاع سیب‌ها از زمین (به سانتی‌متر).\n    tao_reach (int): حداکثر ارتفاعی که تائو تائو می‌تواند با دست کشیده به بالا برسد (به سانتی‌متر).\n\n    بازگشت:\n    int: تعداد سیب‌هایی که تائو تائو می‌تواند با یا بدون ایستادن روی یک چهارپایه ۳۰ سانتی‌متری به آن‌ها برسد.\n\n    این تابع بر روی لیست ارتفاع سیب‌ها تکرار می‌کند و تعداد آن‌هایی که در دسترس تائو تائو هستند را می‌شمارد،\n    با در نظر گرفتن ۳۰ سانتی‌متر اضافی که چهارپایه فراهم می‌کند.\n\n    مثال‌ها:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0"}, "level": "easy", "test": "import unittest\n\nclass TestTaoTaoApplePicking(unittest.TestCase):\n    def test_count_apples_reachable(self):\n        # Test case 1: Tao Tao can reach all apples\n        apples_1 = [100, 105, 110, 115, 120, 125, 130, 135, 140, 145]\n        tao_reach_1 = 120\n        self.assertEqual(count_apples_reachable(apples_1, tao_reach_1), 10)\n\n        # Test case 2: Tao Tao can't reach any apples\n        apples_2 = [200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n        tao_reach_2 = 100\n        self.assertEqual(count_apples_reachable(apples_2, tao_reach_2), 0)\n\n        # Test case 3: Tao Tao can reach some of the apples\n        apples_3 = [160, 150, 140, 170, 180, 190, 160, 150, 145, 155]\n        tao_reach_3 = 115\n        self.assertEqual(count_apples_reachable(apples_3, tao_reach_3), 2)\n\n# To run the tests\nif __name__ == '__main__':\n    unittest.main()", "entry_point": "count_apples_reachable", "signature": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:", "docstring": {"en": "\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    ", "sq": "\n    Llogarit numrin e mollëve që Tao Tao mund të arrijë.\n\n    Args:\n    apple_heights (List[int]): Lartësitë e mollëve nga toka (në centimetra).\n    tao_reach (int): Lartësia maksimale që Tao Tao mund të arrijë me dorën e saj të shtrirë lart (në centimetra).\n\n    Returns:\n    int: Numri i mollëve që Tao Tao mund të arrijë me ose pa qëndruar në një stol 30cm.\n\n    Kjo funksion iteron mbi listën e lartësive të mollëve dhe numëron sa prej tyre janë brenda arritjes së Tao Tao,\n    duke marrë parasysh një shtesë prej 30cm që ofron stoli.\n\n    Shembuj të rasteve:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "hy": "\n    Հաշվեք այն խնձորների քանակը, որոնք Թաո Թաոն կարող է հասնել։\n\n    Փաստարկներ:\n    apple_heights (List[int]): Խնձորների բարձրությունները գետնից (սանտիմետրերով)։\n    tao_reach (int): Առավելագույն բարձրությունը, որին Թաո Թաոն կարող է հասնել ձեռքը վեր պարզած (սանտիմետրերով)։\n\n    Վերադարձնում է:\n    int: Խնձորների քանակը, որոնց Թաո Թաոն կարող է հասնել՝ կանգնած կամ չկանգնած 30սմ բարձակի վրա։\n\n    Այս ֆունկցիան անցնում է խնձորների բարձրությունների ցուցակի վրայով և հաշվում, թե դրանցից քանիսն են Թաո Թաոյի հասանելիության սահմաններում՝ հաշվի առնելով լրացուցիչ 30սմ, որ տալիս է բարձակը։\n\n    Օրինակ դեպքեր:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> վերադարձնում է 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> վերադարձնում է 0", "bn": "\n    তাও তাও কতগুলি আপেল পৌঁছাতে পারে তা গণনা করুন।\n\n    Args:\n    apple_heights (List[int]): মাটি থেকে আপেলের উচ্চতা (সেন্টিমিটারে)।\n    tao_reach (int): তাও তাও তার হাত প্রসারিত করে পৌঁছাতে পারে এমন সর্বাধিক উচ্চতা (সেন্টিমিটারে)।\n\n    Returns:\n    int: তাও তাও একটি 30 সেমি স্টুলে দাঁড়িয়ে বা না দাঁড়িয়ে কতগুলি আপেল পৌঁছাতে পারে।\n\n    এই ফাংশনটি আপেলের উচ্চতার তালিকার উপর পুনরাবৃত্তি করে এবং তাদের মধ্যে কতগুলি তাও তাও এর নাগালের মধ্যে আছে তা গণনা করে,\n    স্টুল যে অতিরিক্ত 30 সেমি প্রদান করে তা বিবেচনা করে।\n\n    উদাহরণ কেস:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "bg": "\n    Изчислете броя на ябълките, които Тао Тао може да достигне.\n\n    Аргументи:\n    apple_heights (List[int]): Височините на ябълките от земята (в сантиметри).\n    tao_reach (int): Максималната височина, която Тао Тао може да достигне с протегната ръка нагоре (в сантиметри).\n\n    Връща:\n    int: Броят на ябълките, които Тао Тао може да достигне със или без да стои на 30см столче.\n\n    Тази функция обхожда списъка с височини на ябълките и брои колко от тях са в обсега на Тао Тао,\n    като се вземат предвид допълнителните 30см, които столчето предоставя.\n\n    Примерни случаи:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> връща 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> връща 0", "zh": "\n    计算涛涛可以够到的苹果数量。\n\n    参数:\n    apple_heights (List[int]): 苹果距离地面的高度（厘米）。\n    tao_reach (int): 涛涛伸手向上时能达到的最大高度（厘米）。\n\n    返回:\n    int: 涛涛在有无站在30厘米高的凳子上时可以够到的苹果数量。\n\n    这个函数遍历苹果高度列表，并计算其中有多少在涛涛的够到范围内，考虑到凳子提供的额外30厘米。\n\n    示例案例:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "fr": "\n    Calculer le nombre de pommes que Tao Tao peut atteindre.\n\n    Args:\n    apple_heights (List[int]): Les hauteurs des pommes à partir du sol (en centimètres).\n    tao_reach (int): La hauteur maximale que Tao Tao peut atteindre avec sa main tendue vers le haut (en centimètres).\n\n    Returns:\n    int: Le nombre de pommes que Tao Tao peut atteindre avec ou sans se tenir sur un tabouret de 30 cm.\n\n    Cette fonction parcourt la liste des hauteurs des pommes et compte combien d'entre elles sont à la portée de Tao Tao,\n    en considérant un ajout de 30 cm que le tabouret fournit.\n\n    Exemples de cas :\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "de": "\n    Berechne die Anzahl der Äpfel, die Tao Tao erreichen kann.\n\n    Args:\n    apple_heights (List[int]): Die Höhen der Äpfel vom Boden aus (in Zentimetern).\n    tao_reach (int): Die maximale Höhe, die Tao Tao mit ausgestreckter Hand erreichen kann (in Zentimetern).\n\n    Returns:\n    int: Die Anzahl der Äpfel, die Tao Tao mit oder ohne einen 30cm hohen Hocker erreichen kann.\n\n    Diese Funktion iteriert über die Liste der Apfelhöhen und zählt, wie viele davon in Tao Taos Reichweite liegen,\n    wobei zusätzliche 30cm berücksichtigt werden, die der Hocker bietet.\n\n    Beispielhafte Fälle:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "ha": "\n    Lissafa yawan tuffa da Tao Tao za ta iya kaiwa.\n\n    Args:\n    apple_heights (List[int]): Tsayin tuffa daga ƙasa (a cikin santimita).\n    tao_reach (int): Matsakaicin tsayin da Tao Tao za ta iya kaiwa da hannunta a miƙe sama (a cikin santimita).\n\n    Returns:\n    int: Yawan tuffa da Tao Tao za ta iya kaiwa tare da ko ba tare da tsayawa a kan kujera mai tsayin 30cm ba.\n\n    Wannan aikin yana zagayawa ta cikin jerin tsayin tuffa kuma yana ƙidaya nawa daga cikinsu suke cikin isar Tao Tao,\n    la'akari da ƙarin 30cm da kujerar ke bayarwa.\n\n    Misalan lamura:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "hi": "\n    ताओ ताओ कितने सेब तक पहुँच सकती है, यह गणना करें।\n\n    तर्क:\n    apple_heights (List[int]): जमीन से सेब की ऊँचाई (सेंटीमीटर में)।\n    tao_reach (int): अधिकतम ऊँचाई तक ताओ ताओ अपने हाथ को ऊपर की ओर खींच सकती है (सेंटीमीटर में)।\n\n    रिटर्न:\n    int: सेबों की संख्या जिन तक ताओ ताओ 30 सेमी स्टूल पर खड़े होकर या बिना खड़े पहुँच सकती है।\n\n    यह फ़ंक्शन सेब की ऊँचाई की सूची पर इटरेट करता है और गिनता है कि उनमें से कितने ताओ ताओ की पहुँच के भीतर हैं,\n    30 सेमी की अतिरिक्त ऊँचाई को ध्यान में रखते हुए जो स्टूल प्रदान करता है।\n\n    उदाहरण मामले:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "hu": "\n    Számítsd ki, hogy Tao Tao hány almát ér el.\n\n    Args:\n    apple_heights (List[int]): Az almák magassága a földtől (centiméterben).\n    tao_reach (int): A maximális magasság, amit Tao Tao elérhet, ha a kezét felfelé nyújtja (centiméterben).\n\n    Returns:\n    int: Az almák száma, amelyeket Tao Tao elérhet akár egy 30 cm-es zsámolyon állva, akár anélkül.\n\n    Ez a függvény végigmegy az almák magasságának listáján, és megszámolja, hány van közülük Tao Tao elérhető magasságában,\n    figyelembe véve a zsámoly által biztosított további 30 cm-t.\n\n    Példa esetek:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> visszaadja 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> visszaadja 0", "es": "Calcular el número de manzanas a las que Tao Tao puede alcanzar.\n\nArgumentos:\napple_heights (List[int]): Las alturas de las manzanas desde el suelo (en centímetros).\ntao_reach (int): La altura máxima que Tao Tao puede alcanzar con su mano estirada hacia arriba (en centímetros).\n\nDevuelve:\nint: El número de manzanas a las que Tao Tao puede alcanzar con o sin pararse en un taburete de 30 cm.\n\nEsta función itera sobre la lista de alturas de las manzanas y cuenta cuántas de ellas están al alcance de Tao Tao,\nconsiderando un adicional de 30 cm que proporciona el taburete.\n\nCasos de ejemplo:\n   count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> devuelve 10\n   count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> devuelve 0", "arb": "    حساب عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه.\n\n    يعيدالحجج:\n    apple_heights (List[int]): ارتفاعات التفاح من الأرض (بالسنتيمترات).\n    tao_reach (int): أقصى ارتفاع يمكن لـ Tao Tao الوصول إليه بيدها ممدودة للأعلى (بالسنتيمترات).\n\n    يعيد:\n    int: عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه مع أو بدون الوقوف على كرسي بارتفاع 30 سم.\n\n    تقوم هذه الدالة بتكرار قائمة ارتفاعات التفاح وتحصي عدد التفاح الذي يمكن الوصول إليه من قبل Tao Tao،\n    مع الأخذ في الاعتبار 30 سم إضافية التي يوفرها الكرسي.\n\n    أمثلة الحالات:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> يعيد 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> يعيد 0", "sw": "Hesabu idadi ya maapulo ambayo Tao Tao anaweza kuyafikia.\n\nHoja:\napple_heights (List[int]): Urefu wa maapulo kutoka ardhini (katika sentimita).\ntao_reach (int): Urefu wa juu zaidi ambao Tao Tao anaweza kufikia kwa kunyoosha mkono wake juu (katika sentimita).\n\nInarejesha:\nint: Idadi ya maapulo ambayo Tao Tao anaweza kuyafikia akiwa amesimama au bila kusimama kwenye kigoda cha sentimita 30.\n\nKazi hii inazunguka kwenye orodha ya urefu wa maapulo na kuhesabu ni mangapi kati yao yako ndani ya uwezo wa kufikiwa na Tao Tao,\nikizingatia ongezeko la sentimita 30 ambalo kigoda kinatoa.\n\nMifano ya kesi:\n   count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> inarudisha 10\n   count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> inarudisha 0", "tr": "Tao Tao'nun ulaşabileceği elma sayısını hesaplayın.\n\nArgümanlar:\napple_heights (List[int]): Yerden elmalara olan yükseklikler (santimetre cinsinden).\ntao_reach (int): Tao Tao'nun elini yukarı doğru uzattığında ulaşabileceği maksimum yükseklik (santimetre cinsinden).\n\nDöndürür:\nint: Tao Tao'nun 30cm'lik bir tabureye çıkıp çıkmamasına bakılmaksızın ulaşabileceği elma sayısı.\n\nBu fonksiyon, elma yükseklikleri listesini dolaşır ve bunlardan kaç tanesinin Tao Tao'nun ulaşabileceği mesafede olduğunu,\ntaburenin sağladığı ek 30cm'yi dikkate alarak sayar.\n\nÖrnek durumlar:\n   count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 10 döndürür\n   count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 0 döndürür", "vi": "Tính số lượng táo mà Tao Tao có thể với tới.\n\nTham số:\napple_heights (List[int]): Chiều cao của những quả táo tính từ mặt đất (tính bằng centimet).\ntao_reach (int): Chiều cao tối đa mà Tao Tao có thể với tới khi giơ tay lên (tính bằng centimet).\n\nTrả về:\nint: Số lượng táo mà Tao Tao có thể với tới dù có hoặc không đứng trên ghế đẩu cao 30cm.\n\nHàm này duyệt qua danh sách chiều cao của các quả táo và đếm xem có bao nhiêu quả nằm trong tầm với của Tao Tao,\nxét thêm 30cm mà ghế đẩu cung cấp.\n\nVí dụ trường hợp:\n   count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> trả về 10\n   count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> trả về 0", "id": "Menghitung jumlah apel yang dapat dijangkau oleh Tao Tao.\n\nArgs:\napple_heights (List[int]): Tinggi apel dari tanah (dalam sentimeter).\ntao_reach (int): Tinggi maksimum yang dapat dijangkau Tao Tao dengan tangan terulur ke atas (dalam sentimeter).\n\nReturns:\nint: Jumlah apel yang dapat dijangkau oleh Tao Tao dengan atau tanpa berdiri di atas bangku setinggi 30cm.\n\nFungsi ini mengiterasi daftar tinggi apel dan menghitung berapa banyak dari mereka yang berada dalam jangkauan Tao Tao,\ndengan mempertimbangkan tambahan 30cm yang disediakan oleh bangku.\n\nContoh kasus:\n   count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> mengembalikan 10\n   count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> mengembalikan 0", "ja": "    Tao Taoが届くことができるリンゴの数を計算します。\n\n    Args:\n    apple_heights (List[int]): 地面からのリンゴの高さ（センチメートル単位）。\n    tao_reach (int): Tao Taoが手を伸ばして届くことができる最大の高さ（センチメートル単位）。\n\n    Returns:\n    int: Tao Taoが30cmの踏み台を使うか使わないかで届くことができるリンゴの数。\n\n    この関数はリンゴの高さのリストを反復処理し、踏み台が提供する追加の30cmを考慮して、\n    Tao Taoの手の届く範囲内にあるリンゴの数を数えます。\n\n    例:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "ko": "Tao Tao가 도달할 수 있는 사과의 수를 계산합니다.\n\nArgs:\napple_heights (List[int]): 땅에서부터 사과까지의 높이 (센티미터 단위).\ntao_reach (int): Tao Tao가 손을 뻗었을 때 도달할 수 있는 최대 높이 (센티미터 단위).\n\nReturns:\nint: Tao Tao가 30cm 의자에 서 있거나 서 있지 않을 때 도달할 수 있는 사과의 수.\n\n이 함수는 사과 높이 목록을 반복하여 의자가 제공하는 추가 30cm를 고려했을 때 Tao Tao가 도달할 수 있는 사과의 수를 셉니다.\n\nExample cases:\n   count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n   count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "ml": "    ടാവോ ടാവോക്ക് എത്തിച്ചേരാൻ കഴിയുന്ന ആപ്പിളുകളുടെ എണ്ണം കണക്കാക്കുക.\n\n    Args:\n    apple_heights (List[int]): നിലത്തു നിന്ന് ആപ്പിളുകളുടെ ഉയരം (സെന്റിമീറ്ററിൽ).\n    tao_reach (int): ടാവോ ടാവോക്ക് കൈ നീട്ടി മുകളിലേക്ക് എത്താൻ കഴിയുന്ന പരമാവധി ഉയരം (സെന്റിമീറ്ററിൽ).\n\n    Returns:\n    int: 30cm ഉയരമുള്ള ഒരു സ്റ്റൂൾ ഉപയോഗിച്ച് അല്ലെങ്കിൽ ഇല്ലാതെ ടാവോ ടാവോക്ക് എത്തിച്ചേരാൻ കഴിയുന്ന ആപ്പിളുകളുടെ എണ്ണം.\n\n    ഈ ഫംഗ്ഷൻ ആപ്പിളുകളുടെ ഉയരങ്ങളുടെ പട്ടികയിലൂടെ ആവർത്തിച്ച്, ടാവോ ടാവോക്ക് സ്റ്റൂൾ നൽകുന്ന 30cm അധികം പരിഗണിച്ച്\n    അവളുടെ എത്തിച്ചേരലിൽ ഉള്ളവ എത്രയാണെന്ന് എണ്ണുന്നു.\n\n    ഉദാഹരണ കേസുകൾ:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0", "fa": "محاسبه تعداد سیب‌هایی که تائو تائو می‌تواند به آن‌ها برسد.\n\nArgs:\napple_heights (List[int]): ارتفاع سیب‌ها از سطح زمین (به سانتی‌متر).\ntao_reach (int): حداکثر ارتفاعی که تائو تائو می‌تواند با دست کشیده به بالا برسد (به سانتی‌متر).\n\nReturns:\nint: تعداد سیب‌هایی که تائو تائو می‌تواند با یا بدون ایستادن روی یک چهارپایه ۳۰ سانتی‌متری به آن‌ها برسد.\n\nاین تابع بر روی لیست ارتفاعات سیب‌ها تکرار می‌کند و تعداد آن‌هایی که در دسترس تائو تائو هستند را می‌شمارد،\nبا در نظر گرفتن ۳۰ سانتی‌متر اضافی که چهارپایه فراهم می‌کند.\n\nمثال‌ها:\n   count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n   count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0"}}
{"task_id": "Python/36", "prompt": {"en": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20.\n    \"\"\"", "sq": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit numrin e pemëve të mbetura përgjatë një rruge pasi zona specifike janë pastruar.\n\n    Rruga përfaqësohet si një vijë e drejtë me gjatësi 'l' dhe fillimisht është e mbushur me pemë.\n    Çdo zonë e planifikuar për pastrim specifikohet si një çift numrash të plotë (fillimi, fundi), \n    që përfaqëson intervalin përfshirës përgjatë rrugës ku pemët do të hiqen.\n\n    Argumentet:\n    - l (int): Gjatësia e rrugës.\n    - areas (List[Tuple[int, int]]): Një listë e tufeve ku çdo tufë përfaqëson një zonë të pastruar në rrugë.\n    \n    Kthen:\n    - int: Numri total i pemëve të mbetura përgjatë rrugës pasi zonat e specifikuara janë pastruar.\n    \n    Shembuj:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) do të kthejë 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) do të kthejë 20.\n    \"\"\"", "hy": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվել ճանապարհի երկայնքով մնացած ծառերի քանակը այն բանից հետո, երբ որոշակի տարածքներ մաքրվել են։\n\n    Ճանապարհը ներկայացված է որպես ուղիղ գիծ, որի երկարությունը 'l' է և սկզբում լցված է ծառերով։\n    Յուրաքանչյուր մաքրման ենթակա տարածք նշված է որպես ամբողջ թվերի զույգ (սկիզբ, վերջ), որը ներկայացնում է\n    ճանապարհի երկայնքով ընդգրկուն միջակայքը, որտեղ ծառերը կհեռացվեն։\n\n    Արգումենտներ:\n    - l (int): Ճանապարհի երկարությունը։\n    - areas (List[Tuple[int, int]]): Զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ ներկայացնում է ճանապարհի մաքրված տարածք։\n    \n    Վերադարձնում է:\n    - int: Ճանապարհի երկայնքով մնացած ծառերի ընդհանուր քանակը այն բանից հետո, երբ նշված տարածքները մաքրվել են։\n    \n    Օրինակներ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) կվերադարձնի 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) կվերադարձնի 20.\n    \"\"\"", "bn": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    নির্দিষ্ট এলাকা পরিষ্কার করার পর রাস্তার পাশে অবশিষ্ট গাছের সংখ্যা গণনা করুন।\n\n    রাস্তা একটি সরল রেখা হিসাবে 'l' দৈর্ঘ্যের প্রতিনিধিত্ব করে এবং প্রাথমিকভাবে গাছ দিয়ে পূর্ণ থাকে।\n    প্রতিটি নির্ধারিত পরিষ্কার এলাকা দুটি পূর্ণসংখ্যার জোড়া (শুরু, শেষ) হিসাবে নির্দিষ্ট করা হয়,\n    যা রাস্তার বরাবর অন্তর্ভুক্ত পরিসরকে উপস্থাপন করে যেখানে গাছগুলি সরানো হবে।\n\n    আর্গস:\n    - l (int): রাস্তার দৈর্ঘ্য।\n    - areas (List[Tuple[int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপল রাস্তার উপর একটি পরিষ্কার এলাকা উপস্থাপন করে।\n    \n    রিটার্নস:\n    - int: নির্দিষ্ট এলাকা পরিষ্কার করার পর রাস্তার পাশে অবশিষ্ট মোট গাছের সংখ্যা।\n    \n    উদাহরণ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 ফেরত দেবে    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 ফেরত দেবে।\n    \"\"\"", "bg": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислете броя на останалите дървета по пътя след изчистването на специфични зони.\n\n    Пътят е представен като права линия с дължина 'l' и първоначално е запълнен с дървета.\n    Всяка зона, предвидена за изчистване, е посочена като двойка цели числа (начало, край), представляващи\n    включителния диапазон по пътя, където дърветата ще бъдат премахнати.\n\n    Аргументи:\n    - l (int): Дължината на пътя.\n    - areas (List[Tuple[int, int]]): Списък от двойки, където всяка двойка представлява изчистена зона на пътя.\n    \n    Връща:\n    - int: Общият брой на дърветата, останали по пътя след изчистването на посочените зони.\n    \n    Примери:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ще върне 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ще върне 20.\n    \"\"\"", "zh": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在特定区域被清除后沿道路剩余的树木数量。\n\n    道路表示为长度为 'l' 的直线，最初布满了树木。\n    每个计划清除的区域由一对整数 (start, end) 指定，表示将要移除树木的道路上的包含范围。\n\n    参数:\n    - l (int): 道路的长度。\n    - areas (List[Tuple[int, int]]): 一个元组列表，每个元组表示道路上的一个清除区域。\n    \n    返回:\n    - int: 在指定区域被清除后沿道路剩余的树木总数。\n    \n    示例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20.\n    \"\"\"", "fr": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculer le nombre d'arbres restants le long d'une route après que des zones spécifiques ont été défrichées.\n\n    La route est représentée comme une ligne droite de longueur 'l' et est initialement remplie d'arbres.\n    Chaque zone prévue pour le défrichage est spécifiée comme une paire d'entiers (début, fin), représentant\n    la plage inclusive le long de la route où les arbres seront enlevés.\n\n    Arguments:\n    - l (int): La longueur de la route.\n    - areas (List[Tuple[int, int]]): Une liste de tuples où chaque tuple représente une zone défrichée sur la route.\n    \n    Retourne:\n    - int: Le nombre total d'arbres restants le long de la route après que les zones spécifiées ont été défrichées.\n    \n    Exemples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) renverra 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) renverra 20.\n    \"\"\"", "de": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechne die Anzahl der verbleibenden Bäume entlang einer Straße, nachdem bestimmte Bereiche gerodet wurden.\n\n    Die Straße wird als gerade Linie der Länge 'l' dargestellt und ist anfangs mit Bäumen gefüllt.\n    Jeder zur Rodung vorgesehene Bereich wird als Paar von ganzen Zahlen (Start, Ende) angegeben, \n    das den inklusiven Bereich entlang der Straße darstellt, in dem die Bäume entfernt werden.\n\n    Argumente:\n    - l (int): Die Länge der Straße.\n    - areas (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel einen gerodeten Bereich auf der Straße darstellt.\n    \n    Rückgabewert:\n    - int: Die Gesamtanzahl der verbleibenden Bäume entlang der Straße, nachdem die angegebenen Bereiche gerodet wurden.\n    \n    Beispiele:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) gibt 5 zurück    \n    - remaining_trees_after_clearing(100, [(10, 90)]) gibt 20 zurück.\n    \"\"\"", "ha": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafa adadin bishiyoyin da suka rage a gefen hanya bayan an share wasu wurare.\n\n    Ana wakilta hanyar a matsayin layi madaidaici mai tsawon 'l' kuma a farko cike take da bishiyoyi.\n    Kowanne yanki da aka shirya sharewa an bayyana shi a matsayin ma'aurata na lambobi (farko, ƙarshe), \n    wanda ke wakiltar kewayon da aka haɗa a gefen hanya inda za a cire bishiyoyin.\n\n    Args:\n    - l (int): Tsawon hanyar.\n    - areas (List[Tuple[int, int]]): Jerin ma'aurata inda kowanne ma'aurata ke wakiltar yanki da aka share a kan hanya.\n    \n    Returns:\n    - int: Jimillar adadin bishiyoyin da suka rage a gefen hanya bayan an share wuraren da aka bayyana.\n    \n    Misalai:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) zai dawo da 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) zai dawo da 20.\n    \"\"\"", "hi": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    विशेष क्षेत्रों को साफ़ करने के बाद सड़क के किनारे बचे हुए पेड़ों की संख्या की गणना करें।\n\n    सड़क को 'l' लंबाई की एक सीधी रेखा के रूप में दर्शाया गया है और यह प्रारंभ में पेड़ों से भरी होती है।\n    प्रत्येक क्षेत्र जिसे साफ़ करने के लिए निर्धारित किया गया है, दो पूर्णांकों (start, end) के जोड़े के रूप में निर्दिष्ट किया गया है,\n    जो सड़क के साथ समावेशी सीमा का प्रतिनिधित्व करता है जहां पेड़ों को हटाया जाएगा।\n\n    आर्ग्स:\n    - l (int): सड़क की लंबाई।\n    - areas (List[Tuple[int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल सड़क पर एक साफ़ क्षेत्र का प्रतिनिधित्व करता है।\n    \n    रिटर्न:\n    - int: निर्दिष्ट क्षेत्रों को साफ़ करने के बाद सड़क के किनारे बचे हुए पेड़ों की कुल संख्या।\n    \n    उदाहरण:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 लौटाएगा    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 लौटाएगा।\n    \"\"\"", "hu": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Számítsa ki a megmaradt fák számát egy út mentén, miután meghatározott területeket megtisztítottak.\n\n    Az utat egy 'l' hosszúságú egyenes vonal képviseli, amely kezdetben fákkal van tele.\n    Minden tisztításra ütemezett területet egy egész számokból álló pár (kezdő, vég) jelöl,\n    amely az út mentén azt a tartományt jelöli, ahol a fákat eltávolítják.\n\n    Paraméterek:\n    - l (int): Az út hossza.\n    - areas (List[Tuple[int, int]]): Egy listája a pároknak, ahol minden pár egy tisztított területet jelöl az úton.\n    \n    Visszatérési érték:\n    - int: A megmaradt fák teljes száma az út mentén a meghatározott területek megtisztítása után.\n    \n    Példák:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) visszaadja az 5-öt    \n    - remaining_trees_after_clearing(100, [(10, 90)]) visszaadja a 20-at.\n    \"\"\"", "es": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcular el número de árboles restantes a lo largo de una carretera después de que se hayan despejado áreas específicas.\n\n    La carretera se representa como una línea recta de longitud 'l' y está inicialmente llena de árboles.\n    Cada área programada para despejarse se especifica como un par de enteros (inicio, fin), que representa\n    el rango inclusivo a lo largo de la carretera donde se eliminarán los árboles.\n\n    Argumentos:\n    - l (int): La longitud de la carretera.\n    - areas (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla representa un área despejada en la carretera.\n    \n    Devuelve:\n    - int: El número total de árboles restantes a lo largo de la carretera después de que se hayan despejado las áreas especificadas.\n    \n    Ejemplos:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) devolverá 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) devolverá 20.\n    \"\"\"", "arb": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    اكتب دالة بايثون 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' لحل المشكلة التالية:\n\n    احسب عدد الأشجار المتبقية على طول الطريق بعد إزالة مناطق محددة.\n\n    يُمثل الطريق كخط مستقيم بطول 'l' ومليء بالأشجار في البداية.\n    كل منطقة مجدولة للإزالة تُحدد كزوج من الأعداد الصحيحة (بداية، نهاية)، والتي تمثل\n    النطاق الشامل على طول الطريق حيث ستتم إزالة الأشجار.\n\n    الوسائط:\n    - l (int): طول الطريق.\n    - areas (List[Tuple[int, int]]): قائمة من الأزواج حيث يمثل كل زوج منطقة تمت إزالتها على الطريق.\n    \n    يعيد:\n    - int: العدد الإجمالي للأشجار المتبقية على طول الطريق بعد إزالة المناطق المحددة.\n    \n    أمثلة:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ستعيد 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ستعيد 20.\n    \"\"\"", "sw": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Kuhesabu idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\n    Barabara inawakilishwa kama mstari wa moja kwa moja wa urefu 'l' na awali imejaa miti.\n    Kila eneo lililopangwa kusafishwa limeainishwa kama jozi ya nambari (kuanzia, mwisho), inayowakilisha\n    safu jumuishi kando ya barabara ambapo miti itaondolewa.\n\n    Hoja:\n    - l (int): Urefu wa barabara.\n    - areas (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi inawakilisha eneo lililosafishwa kwenye barabara.\n    \n    Inarejesha:\n    - int: Jumla ya idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n    \n    Mifano:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) itarudisha 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) itarudisha 20.\n    \"\"\"", "tr": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli alanlar temizlendikten sonra bir yol boyunca kalan ağaçların sayısını hesaplayın.\n\n    Yol, uzunluğu 'l' olan düz bir çizgi olarak temsil edilir ve başlangıçta ağaçlarla doludur.\n    Temizlenmesi planlanan her alan, ağaçların kaldırılacağı yol boyunca kapsayıcı aralığı temsil eden\n    iki tam sayı (başlangıç, bitiş) çifti olarak belirtilir.\n\n    Argümanlar:\n    - l (int): Yolun uzunluğu.\n    - areas (List[Tuple[int, int]]): Her bir demetin yoldaki temizlenmiş bir alanı temsil ettiği demetlerin listesi.\n    \n    Döndürür:\n    - int: Belirtilen alanlar temizlendikten sonra yol boyunca kalan toplam ağaç sayısı.\n    \n    Örnekler:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 döndürecektir.\n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 döndürecektir.\n    \"\"\"", "vi": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính toán số lượng cây còn lại dọc theo con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n\n    Con đường được biểu diễn như một đường thẳng có độ dài 'l' và ban đầu được lấp đầy bởi cây cối.\n    Mỗi khu vực được lên lịch dọn dẹp được chỉ định như một cặp số nguyên (bắt đầu, kết thúc), đại diện\n    cho phạm vi bao gồm dọc theo con đường nơi cây sẽ bị loại bỏ.\n\n    Tham số:\n    - l (int): Độ dài của con đường.\n    - areas (List[Tuple[int, int]]): Một danh sách các cặp số nguyên mà mỗi cặp đại diện cho một khu vực đã được dọn dẹp trên con đường.\n    \n    Trả về:\n    - int: Tổng số cây còn lại dọc theo con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n    \n    Ví dụ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) sẽ trả về 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) sẽ trả về 20.\n    \"\"\"", "id": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Menghitung jumlah pohon yang tersisa di sepanjang jalan setelah area tertentu telah dibersihkan.\n\n    Jalan diwakili sebagai garis lurus dengan panjang 'l' dan awalnya dipenuhi dengan pohon.\n    Setiap area yang dijadwalkan untuk dibersihkan ditentukan sebagai pasangan bilangan bulat (mulai, akhir), \n    yang mewakili rentang inklusif di sepanjang jalan di mana pohon akan dihilangkan.\n\n    Argumen:\n    - l (int): Panjang jalan.\n    - areas (List[Tuple[int, int]]): Daftar tuple di mana setiap tuple mewakili area yang dibersihkan di jalan.\n    \n    Mengembalikan:\n    - int: Jumlah total pohon yang tersisa di sepanjang jalan setelah area yang ditentukan telah dibersihkan.\n    \n    Contoh:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) akan mengembalikan 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) akan mengembalikan 20.\n    \"\"\"", "ja": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    特定のエリアが伐採された後の道路沿いに残る木の数を計算します。\n\n    道路は長さ 'l' の直線として表され、最初は木でいっぱいです。\n    伐採が予定されている各エリアは、道路に沿って木が取り除かれる範囲を表す整数のペア (start, end) として指定されます。\n\n    引数:\n    - l (int): 道路の長さ。\n    - areas (List[Tuple[int, int]]): 各タプルが道路上の伐採エリアを表すタプルのリスト。\n    \n    戻り値:\n    - int: 指定されたエリアが伐採された後に道路沿いに残る木の総数。\n    \n    例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) は 5 を返します。\n    - remaining_trees_after_clearing(100, [(10, 90)]) は 20 を返します。\n    \"\"\"", "ko": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    특정 구역이 제거된 후 도로를 따라 남아 있는 나무의 수를 계산합니다.\n\n    도로는 길이 'l'로 표현되는 직선이며 처음에는 나무로 가득 차 있습니다.\n    제거할 예정인 각 구역은 (start, end)로 지정된 정수 쌍으로, 나무가 제거될 도로의 포함 범위를 나타냅니다.\n\n    인수:\n    - l (int): 도로의 길이.\n    - areas (List[Tuple[int, int]]): 각 튜플이 도로의 제거된 구역을 나타내는 튜플의 리스트.\n    \n    반환:\n    - int: 지정된 구역이 제거된 후 도로를 따라 남아 있는 나무의 총 수.\n    \n    예제:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)])는 5를 반환합니다.\n    - remaining_trees_after_clearing(100, [(10, 90)])는 20을 반환합니다.\n    \"\"\"", "ml": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    പ്രത്യേക പ്രദേശങ്ങൾ മുറിച്ചുനീക്കപ്പെട്ടതിന് ശേഷം ഒരു റോഡിനരികിലെ ശേഷിക്കുന്ന വൃക്ഷങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n\n    റോഡ് 'l' നീളമുള്ള നേരായ രേഖയായി പ്രതിനിധീകരിക്കപ്പെടുന്നു, ഇത് ആദ്യം വൃക്ഷങ്ങളാൽ നിറഞ്ഞിരിക്കുന്നു.\n    മുറിച്ചുനീക്കാനുള്ള ഓരോ പ്രദേശവും (ആരംഭം, അവസാനം) എന്ന രണ്ട് പൂർണ്ണസംഖ്യകളുടെ ജോഡിയായി വ്യക്തമാക്കപ്പെടുന്നു,\n    വൃക്ഷങ്ങൾ നീക്കംചെയ്യപ്പെടുന്ന റോഡിനരികിലെ ഉൾപ്പെട്ട പരിധി പ്രതിനിധീകരിക്കുന്നു.\n\n    Args:\n    - l (int): റോഡിന്റെ നീളം.\n    - areas (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും റോഡിലെ മുറിച്ചുനീക്കപ്പെട്ട പ്രദേശത്തെ പ്രതിനിധീകരിക്കുന്ന ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    Returns:\n    - int: നിർദ്ദിഷ്ട പ്രദേശങ്ങൾ മുറിച്ചുനീക്കപ്പെട്ടതിന് ശേഷം റോഡിനരികിൽ ശേഷിക്കുന്ന മൊത്തം വൃക്ഷങ്ങളുടെ എണ്ണം.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20.\n    \"\"\"", "fa": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    محاسبه تعداد درختان باقی‌مانده در طول یک جاده پس از پاکسازی مناطق خاص.\n\n    جاده به صورت یک خط مستقیم به طول 'l' نمایش داده می‌شود و در ابتدا با درختان پر شده است.\n    هر منطقه‌ای که برای پاکسازی برنامه‌ریزی شده است به صورت یک جفت عدد صحیح (شروع، پایان) مشخص می‌شود،\n    که محدوده شامل بر روی جاده را نشان می‌دهد که در آن درختان برداشته خواهند شد.\n\n    آرگومان‌ها:\n    - l (int): طول جاده.\n    - areas (List[Tuple[int, int]]): لیستی از جفت‌ها که هر جفت نشان‌دهنده یک منطقه پاکسازی شده بر روی جاده است.\n    \n    بازگشت:\n    - int: تعداد کل درختان باقی‌مانده در طول جاده پس از پاکسازی مناطق مشخص شده.\n    \n    مثال‌ها:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) مقدار 5 را برمی‌گرداند.\n    - remaining_trees_after_clearing(100, [(10, 90)]) مقدار 20 را برمی‌گرداند.\n    \"\"\""}, "canonical_solution": "    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees", "instruction": {"en": "Write a python function 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' to solve the following problem:\n\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20.\n    ", "sq": "Shkruani një funksion python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin e pemëve të mbetura përgjatë një rruge pasi zonat specifike janë pastruar.\n\n    Rruga përfaqësohet si një vijë e drejtë me gjatësi 'l' dhe fillimisht është e mbushur me pemë.\n    Çdo zonë e planifikuar për pastrim specifikohet si një çift numrash të plotë (fillimi, fundi), që përfaqësojnë\n    intervalin përfshirës përgjatë rrugës ku pemët do të hiqen.\n\n    Args:\n    - l (int): Gjatësia e rrugës.\n    - areas (List[Tuple[int, int]]): Një listë e tufeve ku çdo tufë përfaqëson një zonë të pastruar në rrugë.\n    \n    Returns:\n    - int: Numri total i pemëve të mbetura përgjatë rrugës pasi zonat e specifikuara janë pastruar.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) do të kthejë 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) do të kthejë 20.", "hy": "Պայթոն ֆունկցիա 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել ճանապարհի երկայնքով մնացած ծառերի քանակը այն բանից հետո, երբ որոշակի տարածքներ մաքրվել են:\n\n    Ճանապարհը ներկայացված է որպես երկարությամբ 'l' ուղիղ գիծ և սկզբում լցված է ծառերով:\n    Յուրաքանչյուր մաքրման համար նախատեսված տարածք նշված է որպես ամբողջ թվերի զույգ (սկիզբ, վերջ), \n    որը ներկայացնում է ճանապարհի երկայնքով ներառական տիրույթը, որտեղ ծառերը կհանվեն:\n\n    Արգումենտներ:\n    - l (int): Ճանապարհի երկարությունը:\n    - areas (List[Tuple[int, int]]): Զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ ներկայացնում է ճանապարհի մաքրված տարածք:\n    \n    Վերադարձնում է:\n    - int: Ճանապարհի երկայնքով մնացած ծառերի ընդհանուր քանակը այն բանից հետո, երբ նշված տարածքները մաքրվել են:\n    \n    Օրինակներ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) կվերադարձնի 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) կվերադարձնի 20.", "bn": "একটি পাইথন ফাংশন 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    নির্দিষ্ট এলাকাগুলি পরিষ্কার করার পরে একটি রাস্তার পাশে অবশিষ্ট গাছের সংখ্যা গণনা করুন।\n\n    রাস্তা 'l' দৈর্ঘ্যের একটি সরল রেখা হিসাবে উপস্থাপিত হয় এবং প্রাথমিকভাবে গাছ দিয়ে পূর্ণ থাকে।\n    পরিষ্কারের জন্য নির্ধারিত প্রতিটি এলাকা দুটি পূর্ণসংখ্যার (start, end) জোড়া হিসাবে নির্দিষ্ট করা হয়,\n    যা রাস্তার বরাবর অন্তর্ভুক্ত পরিসীমা উপস্থাপন করে যেখানে গাছগুলি সরানো হবে।\n\n    আর্গুমেন্টস:\n    - l (int): রাস্তার দৈর্ঘ্য।\n    - areas (List[Tuple[int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপল রাস্তার একটি পরিষ্কার করা এলাকা উপস্থাপন করে।\n    \n    রিটার্নস:\n    - int: নির্দিষ্ট এলাকাগুলি পরিষ্কার করার পরে রাস্তার পাশে অবশিষ্ট মোট গাছের সংখ্যা।\n    \n    উদাহরণ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 ফেরত দেবে    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 ফেরত দেবে।", "bg": "Напишете Python функция 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:', за да решите следния проблем:\n\n    Изчислете броя на останалите дървета по пътя, след като определени зони са били изчистени.\n\n    Пътят е представен като права линия с дължина 'l' и първоначално е запълнен с дървета.\n    Всяка зона, планирана за изчистване, е посочена като двойка от цели числа (начало, край), представляващи\n    включителния диапазон по пътя, където дърветата ще бъдат премахнати.\n\n    Аргументи:\n    - l (int): Дължината на пътя.\n    - areas (List[Tuple[int, int]]): Списък от двойки, където всяка двойка представлява изчистена зона по пътя.\n    \n    Връща:\n    - int: Общият брой на дърветата, останали по пътя след изчистването на определените зони.\n    \n    Примери:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ще върне 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ще върне 20.", "zh": "编写一个 python 函数 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' 来解决以下问题：\n\n    计算在特定区域被清除后沿道路剩余的树木数量。\n\n    道路表示为长度为 'l' 的直线，最初布满了树木。\n    每个计划清除的区域都指定为一对整数 (start, end)，表示沿道路将要移除树木的包含范围。\n\n    参数:\n    - l (int): 道路的长度。\n    - areas (List[Tuple[int, int]]): 一个元组列表，其中每个元组表示道路上的一个清除区域。\n    \n    返回:\n    - int: 在指定区域被清除后沿道路剩余的树木总数。\n    \n    示例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20。", "fr": "Écrivez une fonction python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nombre d'arbres restants le long d'une route après que des zones spécifiques ont été dégagées.\n\n    La route est représentée comme une ligne droite de longueur 'l' et est initialement remplie d'arbres.\n    Chaque zone prévue pour être dégagée est spécifiée comme une paire d'entiers (début, fin), représentant\n    la plage inclusive le long de la route où les arbres seront enlevés.\n\n    Args:\n    - l (int): La longueur de la route.\n    - areas (List[Tuple[int, int]]): Une liste de tuples où chaque tuple représente une zone dégagée sur la route.\n    \n    Returns:\n    - int: Le nombre total d'arbres restants le long de la route après que les zones spécifiées ont été dégagées.\n    \n    Exemples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) renverra 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) renverra 20.", "de": "Schreiben Sie eine Python-Funktion 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die Anzahl der verbleibenden Bäume entlang einer Straße, nachdem bestimmte Bereiche gerodet wurden.\n\n    Die Straße wird als gerade Linie der Länge 'l' dargestellt und ist zunächst mit Bäumen gefüllt.\n    Jeder für die Rodung vorgesehene Bereich wird als Paar von ganzen Zahlen (Start, Ende) angegeben, \n    das den inklusiven Bereich entlang der Straße darstellt, in dem die Bäume entfernt werden.\n\n    Argumente:\n    - l (int): Die Länge der Straße.\n    - areas (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel einen gerodeten Bereich auf der Straße darstellt.\n    \n    Rückgabewert:\n    - int: Die Gesamtanzahl der Bäume, die entlang der Straße verbleiben, nachdem die angegebenen Bereiche gerodet wurden.\n    \n    Beispiele:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) wird 5 zurückgeben    \n    - remaining_trees_after_clearing(100, [(10, 90)]) wird 20 zurückgeben.", "ha": "Rubuta wani aikin python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa adadin itatuwan da suka rage a gefen hanya bayan an share wurare na musamman.\n\n    Ana wakiltar hanyar a matsayin layi madaidaici mai tsawon 'l' kuma a farko an cika ta da itatuwa.\n    Kowanne wuri da aka shirya don sharewa an bayyana shi a matsayin ma'aurata na lambobi (farko, ƙarshe), \n    wanda ke wakiltar kewayon da aka haɗa a gefen hanya inda za a cire itatuwan.\n\n    Args:\n    - l (int): Tsawon hanyar.\n    - areas (List[Tuple[int, int]]): Jerin ma'aurata inda kowanne ma'aurata ke wakiltar wuri da aka share a kan hanya.\n    \n    Returns:\n    - int: Jimillar adadin itatuwan da suka rage a gefen hanya bayan an share wuraren da aka bayyana.\n    \n    Misalai:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) zai dawo da 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) zai dawo da 20.", "hi": "एक पायथन फ़ंक्शन 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    विशिष्ट क्षेत्रों को साफ़ करने के बाद सड़क के किनारे बचे हुए पेड़ों की संख्या की गणना करें।\n\n    सड़क को 'l' लंबाई की एक सीधी रेखा के रूप में दर्शाया गया है और यह प्रारंभ में पेड़ों से भरी होती है।\n    प्रत्येक क्षेत्र जिसे साफ़ करने के लिए निर्धारित किया गया है, को पूर्णांकों की एक जोड़ी (प्रारंभ, अंत) के रूप में निर्दिष्ट किया गया है,\n    जो सड़क के साथ समावेशी सीमा का प्रतिनिधित्व करता है जहां पेड़ों को हटाया जाएगा।\n\n    तर्क:\n    - l (int): सड़क की लंबाई।\n    - areas (List[Tuple[int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल सड़क पर साफ़ किए गए क्षेत्र का प्रतिनिधित्व करता है।\n    \n    लौटाता है:\n    - int: निर्दिष्ट क्षेत्रों को साफ़ करने के बाद सड़क के किनारे बचे हुए पेड़ों की कुल संख्या।\n    \n    उदाहरण:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 लौटाएगा    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 लौटाएगा।", "hu": "Írj egy python függvényt 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' a következő probléma megoldására:\n\n    Számítsd ki az út mentén megmaradt fák számát, miután bizonyos területeket megtisztítottak.\n\n    Az utat egy 'l' hosszúságú egyenes vonalként ábrázoljuk, amely kezdetben fákkal van tele.\n    Minden tisztításra ütemezett területet egy egész szám pár (kezdő, vég) jelöl, amely az út mentén\n    azt a tartományt képviseli, ahol a fákat eltávolítják.\n\n    Argumentumok:\n    - l (int): Az út hossza.\n    - areas (List[Tuple[int, int]]): Egy listája a pároknak, ahol minden pár egy tisztított területet képvisel az úton.\n    \n    Visszatér:\n    - int: Az út mentén megmaradt fák teljes száma, miután a megadott területeket megtisztították.\n    \n    Példák:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) visszaadja 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) visszaadja 20.", "es": "Escribe una función de Python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' para resolver el siguiente problema:\n\n    Calcular el número de árboles restantes a lo largo de una carretera después de que se hayan despejado áreas específicas.\n\n    La carretera se representa como una línea recta de longitud 'l' y está inicialmente llena de árboles.\n    Cada área programada para despejarse se especifica como un par de enteros (inicio, fin), que representa\n    el rango inclusivo a lo largo de la carretera donde se eliminarán los árboles.\n\n    Argumentos:\n    - l (int): La longitud de la carretera.\n    - areas (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla representa un área despejada en la carretera.\n    \n    Devuelve:\n    - int: El número total de árboles restantes a lo largo de la carretera después de que se hayan despejado las áreas especificadas.\n    \n    Ejemplos:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) devolverá 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) devolverá 20.", "arb": "اكتب دالة بايثون 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' لحل المشكلة التالية:\n\n    احسب عدد الأشجار المتبقية على طول الطريق بعد إزالة مناطق محددة.\n\n    يُمثل الطريق كخط مستقيم بطول 'l' ومليء بالأشجار في البداية.\n    كل منطقة مجدولة للإزالة تُحدد كزوج من الأعداد الصحيحة (بداية، نهاية)، والتي تمثل\n    النطاق الشامل على طول الطريق حيث ستتم إزالة الأشجار.\n\n    الوسائط:\n    - l (int): طول الطريق.\n    - areas (List[Tuple[int, int]]): قائمة من الأزواج حيث يمثل كل زوج منطقة تمت إزالتها على الطريق.\n    \n    يعيد:\n    - int: العدد الإجمالي للأشجار المتبقية على طول الطريق بعد إزالة المناطق المحددة.\n    \n    أمثلة:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ستعيد 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ستعيد 20.", "sw": "Andika kazi ya python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\n    Barabara inawakilishwa kama mstari wa moja kwa moja wa urefu 'l' na awali imejaa miti.\n    Kila eneo lililopangwa kusafishwa limeainishwa kama jozi ya nambari (mwanzo, mwisho), inayowakilisha\n    safu jumuishi kando ya barabara ambapo miti itaondolewa.\n\n    Hoja:\n    - l (int): Urefu wa barabara.\n    - areas (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi inawakilisha eneo lililosafishwa kwenye barabara.\n    \n    Inarejesha:\n    - int: Jumla ya idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n    \n    Mifano:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) itarudisha 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) itarudisha 20.", "tr": "Bir python fonksiyonu 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Belirli alanlar temizlendikten sonra yol boyunca kalan ağaçların sayısını hesaplayın.\n\n    Yol, uzunluğu 'l' olan düz bir çizgi olarak temsil edilir ve başlangıçta ağaçlarla doludur.\n    Temizlenmesi planlanan her alan, yol boyunca ağaçların kaldırılacağı kapsayıcı aralığı temsil eden\n    bir çift tamsayı (başlangıç, bitiş) olarak belirtilir.\n\n    Argümanlar:\n    - l (int): Yolun uzunluğu.\n    - areas (List[Tuple[int, int]]): Her bir demetin yoldaki temizlenmiş bir alanı temsil ettiği demetlerin bir listesi.\n    \n    Döndürür:\n    - int: Belirtilen alanlar temizlendikten sonra yol boyunca kalan toplam ağaç sayısı.\n    \n    Örnekler:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 döndürecektir.\n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 döndürecektir.", "vi": "Viết một hàm python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' để giải quyết vấn đề sau:\n\n    Tính số lượng cây còn lại dọc theo một con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n\n    Con đường được biểu diễn như một đường thẳng có độ dài 'l' và ban đầu được lấp đầy bởi cây cối.\n    Mỗi khu vực dự kiến dọn dẹp được chỉ định như một cặp số nguyên (bắt đầu, kết thúc), đại diện cho\n    phạm vi bao gồm dọc theo con đường nơi cây sẽ bị loại bỏ.\n\n    Tham số:\n    - l (int): Độ dài của con đường.\n    - areas (List[Tuple[int, int]]): Một danh sách các bộ giá trị, mỗi bộ đại diện cho một khu vực đã được dọn dẹp trên con đường.\n    \n    Trả về:\n    - int: Tổng số cây còn lại dọc theo con đường sau khi các khu vực đã được dọn dẹp.\n    \n    Ví dụ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) sẽ trả về 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) sẽ trả về 20.", "id": "Tulis sebuah fungsi python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung jumlah pohon yang tersisa di sepanjang jalan setelah area tertentu telah dibersihkan.\n\n    Jalan tersebut direpresentasikan sebagai garis lurus dengan panjang 'l' dan awalnya dipenuhi dengan pohon.\n    Setiap area yang dijadwalkan untuk dibersihkan ditentukan sebagai pasangan bilangan bulat (start, end), yang mewakili\n    rentang inklusif di sepanjang jalan di mana pohon akan dihilangkan.\n\n    Argumen:\n    - l (int): Panjang jalan.\n    - areas (List[Tuple[int, int]]): Daftar tuple di mana setiap tuple mewakili area yang dibersihkan di jalan.\n    \n    Mengembalikan:\n    - int: Jumlah total pohon yang tersisa di sepanjang jalan setelah area yang ditentukan telah dibersihkan.\n    \n    Contoh:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) akan mengembalikan 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) akan mengembalikan 20.", "ja": "Python関数を書いてください。 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' を解決するために以下の問題:\n\n    特定のエリアが伐採された後の道路沿いに残っている木の数を計算します。\n\n    道路は長さ 'l' の直線として表され、最初は木でいっぱいです。\n    伐採が予定されている各エリアは、道路に沿って木が除去される範囲を示す整数のペア (start, end) として指定されます。\n\n    引数:\n    - l (int): 道路の長さ。\n    - areas (List[Tuple[int, int]]): 各タプルが道路上の伐採エリアを表すタプルのリスト。\n    \n    戻り値:\n    - int: 指定されたエリアが伐採された後に道路沿いに残る木の総数。\n    \n    例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) は 5 を返します。\n    - remaining_trees_after_clearing(100, [(10, 90)]) は 20 を返します。", "ko": "파이썬 함수를 작성하세요 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' 다음 문제를 해결하기 위해:\n\n    특정 구역이 제거된 후 도로를 따라 남아 있는 나무의 수를 계산합니다.\n\n    도로는 길이 'l'로 표현되며 처음에는 나무로 가득 차 있습니다.\n    제거될 예정인 각 구역은 (start, end)로 지정된 정수 쌍으로,\n    도로를 따라 나무가 제거될 포함 범위를 나타냅니다.\n\n    매개변수:\n    - l (int): 도로의 길이.\n    - areas (List[Tuple[int, int]]): 각 튜플이 도로의 제거된 구역을 나타내는 튜플의 리스트.\n    \n    반환값:\n    - int: 지정된 구역이 제거된 후 도로를 따라 남아 있는 나무의 총 수.\n    \n    예시:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)])는 5를 반환합니다.\n    - remaining_trees_after_clearing(100, [(10, 90)])는 20을 반환합니다.", "ml": "'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെക്കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    പ്രത്യേക പ്രദേശങ്ങൾ മുറിച്ചുമാറ്റിയ ശേഷം ഒരു റോഡിനൊപ്പം ശേഷിക്കുന്ന മരങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n\n    റോഡ് 'l' നീളമുള്ള ഒരു നേരായ രേഖയായി പ്രതിനിധീകരിക്കപ്പെടുന്നു, തുടക്കത്തിൽ മരങ്ങളാൽ നിറഞ്ഞിരിക്കുന്നു.\n    മുറിച്ചുമാറ്റാൻ നിശ്ചയിച്ചിരിക്കുന്ന ഓരോ പ്രദേശവും (ആരംഭം, അവസാനം) എന്ന ഇന്റീജർ ജോഡികളായി വ്യക്തമാക്കപ്പെടുന്നു,\n    റോഡിനൊപ്പം മരങ്ങൾ നീക്കംചെയ്യപ്പെടുന്ന ഉൾപ്പെടുന്ന പരിധി പ്രതിനിധീകരിക്കുന്നു.\n\n    Args:\n    - l (int): റോഡിന്റെ നീളം.\n    - areas (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും റോഡിലെ മുറിച്ചുമാറ്റിയ പ്രദേശത്തെ പ്രതിനിധീകരിക്കുന്ന ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    Returns:\n    - int: നിശ്ചയിച്ച പ്രദേശങ്ങൾ മുറിച്ചുമാറ്റിയ ശേഷം റോഡിനൊപ്പം ശേഷിക്കുന്ന മൊത്തം മരങ്ങളുടെ എണ്ണം.\n    \n    ഉദാഹരണങ്ങൾ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 മടങ്ങി തിരികെ നൽകും    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 മടങ്ങി തിരികെ നൽകും.", "fa": "یک تابع پایتون بنویسید 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' برای حل مسئله زیر:\n\n    تعداد درختان باقی‌مانده در طول یک جاده را پس از پاکسازی مناطق خاص محاسبه کنید.\n\n    جاده به صورت یک خط مستقیم به طول 'l' نمایش داده می‌شود و در ابتدا با درختان پر شده است.\n    هر منطقه‌ای که برای پاکسازی برنامه‌ریزی شده است به صورت یک جفت عدد صحیح (start, end) مشخص می‌شود که\n    محدوده شامل بر روی جاده را که در آن درختان برداشته خواهند شد، نشان می‌دهد.\n\n    آرگومان‌ها:\n    - l (int): طول جاده.\n    - areas (List[Tuple[int, int]]): لیستی از تاپل‌ها که هر تاپل یک منطقه پاکسازی شده بر روی جاده را نشان می‌دهد.\n    \n    بازگشت:\n    - int: تعداد کل درختان باقی‌مانده در طول جاده پس از پاکسازی مناطق مشخص شده.\n    \n    مثال‌ها:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) مقدار 5 را برمی‌گرداند\n    - remaining_trees_after_clearing(100, [(10, 90)]) مقدار 20 را برمی‌گرداند."}, "level": "easy", "test": "def test_remaining_trees_after_clearing():\n    test_cases = [\n        (500, [(150, 300), (100, 200), (470, 471)], 298),\n        (1000, [(0, 100), (200, 300), (400, 500), (600, 700), (800, 900)], 496),\n        (10, [(3, 4), (7, 9)], 6),\n    ]\n\n    for i, (l, areas, expected) in enumerate(test_cases, 1):\n        result = remaining_trees_after_clearing(l, areas)\n        assert result == expected, f\"Test case {i} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i} passed.\")\n\n\ntest_remaining_trees_after_clearing()", "entry_point": "remaining_trees_after_clearing", "signature": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:", "docstring": {"en": "\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20.\n    ", "sq": "\n    Llogarit numrin e pemëve të mbetura përgjatë një rruge pasi zona të caktuara janë pastruar.\n\n    Rruga përfaqësohet si një vijë e drejtë me gjatësi 'l' dhe fillimisht është e mbushur me pemë.\n    Çdo zonë e planifikuar për pastrim specifikohet si një çift numrash të plotë (fillimi, fundi), që përfaqëson\n    intervalin përfshirës përgjatë rrugës ku pemët do të hiqen.\n\n    Argumentet:\n    - l (int): Gjatësia e rrugës.\n    - areas (List[Tuple[int, int]]): Një listë e tufeve ku çdo tufë përfaqëson një zonë të pastruar në rrugë.\n    \n    Kthen:\n    - int: Numri total i pemëve të mbetura përgjatë rrugës pasi zonat e specifikuara janë pastruar.\n    \n    Shembuj:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) do të kthejë 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) do të kthejë 20.", "hy": "\n    Հաշվեք ճանապարհի երկայնքով մնացած ծառերի քանակը այն բանից հետո, երբ որոշակի տարածքներ մաքրվել են։\n\n    Ճանապարհը ներկայացված է որպես ուղիղ գիծ՝ 'l' երկարությամբ, և սկզբում լցված է ծառերով։\n    Յուրաքանչյուր մաքրման ենթակա տարածք նշված է որպես ամբողջ թվերի զույգ (սկիզբ, վերջ), որը ներկայացնում է\n    ճանապարհի այն ընդգրկուն հատվածը, որտեղից ծառերը կհեռացվեն։\n\n    Պարամետրեր:\n    - l (int): Ճանապարհի երկարությունը։\n    - areas (List[Tuple[int, int]]): Զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ ներկայացնում է ճանապարհի վրա մաքրված տարածք։\n    \n    Վերադարձնում է:\n    - int: Ճանապարհի երկայնքով մնացած ծառերի ընդհանուր քանակը այն բանից հետո, երբ նշված տարածքները մաքրվել են։\n    \n    Օրինակներ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) կվերադարձնի 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) կվերադարձնի 20.", "bn": "\n    রাস্তার পাশে নির্দিষ্ট এলাকা পরিষ্কার করার পর অবশিষ্ট গাছের সংখ্যা গণনা করুন।\n\n    রাস্তা একটি সরল রেখা হিসাবে প্রতিনিধিত্ব করা হয় যার দৈর্ঘ্য 'l' এবং প্রাথমিকভাবে গাছ দ্বারা পূর্ণ।\n    প্রতিটি এলাকা পরিষ্কার করার জন্য নির্ধারিত হয় একটি পূর্ণসংখ্যার জোড়া (start, end) হিসাবে, যা রাস্তার বরাবর অন্তর্ভুক্তিকৃত পরিসীমা প্রতিনিধিত্ব করে যেখানে গাছগুলি সরানো হবে।\n\n    আর্গুমেন্ট:\n    - l (int): রাস্তার দৈর্ঘ্য।\n    - areas (List[Tuple[int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপল রাস্তার উপর একটি পরিষ্কার এলাকা প্রতিনিধিত্ব করে।\n    \n    রিটার্নস:\n    - int: নির্দিষ্ট এলাকা পরিষ্কার করার পর রাস্তার পাশে অবশিষ্ট মোট গাছের সংখ্যা।\n    \n    উদাহরণ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 রিটার্ন করবে    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 রিটার্ন করবে।", "bg": "\n    Изчислете броя на останалите дървета по пътя след като определени зони са били изчистени.\n\n    Пътят е представен като права линия с дължина 'l' и първоначално е запълнен с дървета.\n    Всяка зона, предвидена за изчистване, е посочена като двойка цели числа (начало, край), представляващи\n    включителния диапазон по пътя, където дърветата ще бъдат премахнати.\n\n    Аргументи:\n    - l (int): Дължината на пътя.\n    - areas (List[Tuple[int, int]]): Списък от двойки, където всяка двойка представлява изчистена зона на пътя.\n    \n    Връща:\n    - int: Общият брой на останалите дървета по пътя след като определените зони са били изчистени.\n    \n    Примери:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ще върне 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ще върне 20.", "zh": "\n    计算在特定区域被清除后沿道路剩余的树木数量。\n\n    道路表示为长度为 'l' 的直线，最初布满了树木。\n    每个计划清除的区域由一对整数 (start, end) 指定，表示沿道路将要移除树木的包含范围。\n\n    参数:\n    - l (int): 道路的长度。\n    - areas (List[Tuple[int, int]]): 一个元组列表，其中每个元组代表道路上的一个清除区域。\n    \n    返回:\n    - int: 在指定区域被清除后沿道路剩余的树木总数。\n    \n    示例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20.", "fr": "\n    Calculer le nombre d'arbres restants le long d'une route après que des zones spécifiques ont été défrichées.\n\nLa route est représentée comme une ligne droite de longueur 'l' et est initialement remplie d'arbres. Chaque zone prévue pour le défrichage est spécifiée comme une paire d'entiers (début, fin), représentant la plage inclusive le long de la route où les arbres seront enlevés.\n\nArgs:\n- l (int): La longueur de la route.\n- areas (List[Tuple[int, int]]): Une liste de tuples où chaque tuple représente une zone défrichée sur la route.\n\nReturns:\n- int: Le nombre total d'arbres restants le long de la route après que les zones spécifiées ont été défrichées.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) renverra 5    \n- remaining_trees_after_clearing(100, [(10, 90)]) renverra 20.", "de": "\n    Berechne die Anzahl der verbleibenden Bäume entlang einer Straße, nachdem bestimmte Bereiche gerodet wurden.\n\nDie Straße wird als gerade Linie der Länge 'l' dargestellt und ist anfänglich mit Bäumen gefüllt.\nJeder zur Rodung vorgesehene Bereich wird als Paar von ganzen Zahlen (start, end) angegeben, das den inklusiven Bereich entlang der Straße darstellt, in dem die Bäume entfernt werden.\n\nArgumente:\n- l (int): Die Länge der Straße.\n- areas (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel einen gerodeten Bereich auf der Straße darstellt.\n\nRückgabewert:\n- int: Die Gesamtanzahl der verbleibenden Bäume entlang der Straße, nachdem die angegebenen Bereiche gerodet wurden.\n\nBeispiele:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) wird 5 zurückgeben\n- remaining_trees_after_clearing(100, [(10, 90)]) wird 20 zurückgeben.", "ha": "\n    Lissafa adadin bishiyoyin da suka rage a gefen hanya bayan an share wasu wurare.\n\n    Ana wakilta hanyar a matsayin layi madaidaici mai tsawon 'l' kuma a farko tana cike da bishiyoyi.\n    Kowanne wuri da aka tsara don sharewa ana bayyana shi a matsayin ma'aurata na lambobi (farawa, ƙarewa), \n    wanda ke wakiltar kewayon da aka haɗa a gefen hanya inda za a cire bishiyoyin.\n\n    Args:\n    - l (int): Tsawon hanyar.\n    - areas (List[Tuple[int, int]]): Jerin ma'aurata inda kowanne ma'aurata ke wakiltar wuri da aka share a kan hanya.\n    \n    Returns:\n    - int: Jimillar adadin bishiyoyin da suka rage a gefen hanya bayan an share wuraren da aka ambata.\n    \n    Misalai:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) zai dawo da 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) zai dawo da 20.", "hi": "\n    सड़क के किनारे कुछ विशेष क्षेत्रों को साफ़ करने के बाद बचे हुए पेड़ों की संख्या की गणना करें।\n\n    सड़क को 'l' लंबाई की एक सीधी रेखा के रूप में दर्शाया गया है और शुरुआत में यह पेड़ों से भरी होती है।\n    प्रत्येक क्षेत्र जो साफ़ करने के लिए निर्धारित है, उसे दो पूर्णांकों (start, end) के जोड़े के रूप में निर्दिष्ट किया गया है,\n    जो सड़क के साथ वह समावेशी सीमा दर्शाता है जहां पेड़ों को हटाया जाएगा।\n\n    तर्क:\n    - l (int): सड़क की लंबाई।\n    - areas (List[Tuple[int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल सड़क पर साफ़ किए गए क्षेत्र का प्रतिनिधित्व करता है।\n    \n    लौटाता है:\n    - int: सड़क के साथ कुल बचे हुए पेड़ों की संख्या, निर्दिष्ट क्षेत्रों को साफ़ करने के बाद।\n    \n    उदाहरण:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 लौटाएगा   \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 लौटाएगा।", "hu": "\n    Számítsd ki az út mentén megmaradó fák számát, miután bizonyos területeket megtisztítottak.\n\n    Az út egy 'l' hosszúságú egyenes vonalként van ábrázolva, és kezdetben fákkal van tele.\n    Minden megtisztításra tervezett területet egy egész szám pár (kezdő, vég) jelöl, amely az út mentén\n    azt a tartományt jelenti, ahol a fákat eltávolítják.\n\n    Paraméterek:\n    - l (int): Az út hossza.\n    - areas (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy pár, amely az út egy megtisztított területét jelöli.\n    \n    Visszatérési érték:\n    - int: Az út mentén megmaradó fák teljes száma a megadott területek megtisztítása után.\n    \n    Példák:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) visszaadja az 5-öt    \n    - remaining_trees_after_clearing(100, [(10, 90)]) visszaadja a 20-at.", "es": "Calcula el número de árboles restantes a lo largo de una carretera después de que se hayan despejado áreas específicas.\n\nLa carretera se representa como una línea recta de longitud 'l' y está inicialmente llena de árboles. Cada área programada para despeje se especifica como un par de enteros (inicio, fin), que representa el rango inclusivo a lo largo de la carretera donde se eliminarán los árboles.\n\nArgumentos:\n- l (int): La longitud de la carretera.\n- areas (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla representa un área despejada en la carretera.\n\nDevuelve:\n- int: El número total de árboles restantes a lo largo de la carretera después de que las áreas especificadas hayan sido despejadas.\n\nEjemplos:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) devolverá 5\n- remaining_trees_after_clearing(100, [(10, 90)]) devolverá 20.", "arb": "    حساب عدد الأشجار المتبقية على طول الطريق بعد إزالة مناطق محددة.\n\n    يتم تمثيل الطريق كخط مستقيم بطول 'l' ومليء بالأشجار في البداية.\n    يتم تحديد كل منطقة مبرمجة للإزالة كزوج من الأعداد الصحيحة (start, end)، والتي تمثل\n    النطاق الشامل على طول الطريق حيث سيتم إزالة الأشجار.\n\n    يعيدالحجج:\n    - l (int): طول الطريق.\n    - areas (List[Tuple[int, int]]): قائمة من الأزواج حيث يمثل كل زوج منطقة تم إزالتها على الطريق.\n    \n    يعيد:\n    - int: العدد الإجمالي للأشجار المتبقية على طول الطريق بعد إزالة المناطق المحددة.\n    \n    امثله:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) سيعيد 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) سيعيد 20.", "sw": "Hesabu idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\nBarabara inawakilishwa kama mstari wa moja kwa moja wa urefu 'l' na awali imejaa miti. \nKila eneo lililopangwa kusafishwa limetajwa kama jozi ya nambari mbili (mwanzo, mwisho), inayowakilisha \neneo la pamoja kando ya barabara ambapo miti itaondolewa.\n\nHoja:\n- l (int): Urefu wa barabara.\n- areas (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi inawakilisha eneo lililosafishwa kwenye barabara.\n\nInarejesha:\n- int: Jumla ya idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\nMifano:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) itarudisha 5    \n- remaining_trees_after_clearing(100, [(10, 90)]) itarudisha 20.", "tr": "    Belirli alanlar temizlendikten sonra bir yol boyunca kalan ağaçların sayısını hesaplayın.\n\n    Yol, uzunluğu 'l' olan düz bir çizgi olarak temsil edilir ve başlangıçta ağaçlarla doludur.\n    Temizlenmesi planlanan her alan, yol boyunca ağaçların kaldırılacağı kapsayıcı aralığı temsil eden\n    bir çift tam sayı (başlangıç, bitiş) olarak belirtilir.\n\n    Argümanlar:\n    - l (int): Yolun uzunluğu.\n    - areas (List[Tuple[int, int]]): Her bir çiftin yoldaki temizlenmiş bir alanı temsil ettiği bir demet listesi.\n    \n    Döndürür:\n    - int: Belirtilen alanlar temizlendikten sonra yol boyunca kalan toplam ağaç sayısı.\n    \n    Örnekler:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 döndürecektir.    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 döndürecektir.", "vi": "    Tính số cây còn lại dọc theo một con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n\n    Con đường được biểu diễn như một đường thẳng có độ dài 'l' và ban đầu được phủ đầy cây.\n    Mỗi khu vực dự kiến dọn dẹp được chỉ định dưới dạng một cặp số nguyên (start, end), đại diện\n    cho phạm vi bao gồm dọc theo con đường nơi cây sẽ bị loại bỏ.\n\n    Tham số:\n    - l (int): Độ dài của con đường.\n    - areas (List[Tuple[int, int]]): Một danh sách các bộ giá trị mà mỗi bộ đại diện cho một khu vực đã dọn dẹp trên con đường.\n    \n    Trả về:\n    - int: Tổng số cây còn lại dọc theo con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n    \n    Ví dụ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) sẽ trả về 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) sẽ trả về 20.", "id": "Menghitung jumlah pohon yang tersisa di sepanjang jalan setelah area tertentu telah dibersihkan.\n\nJalan tersebut diwakili sebagai garis lurus dengan panjang 'l' dan awalnya dipenuhi dengan pohon. Setiap area yang dijadwalkan untuk dibersihkan ditentukan sebagai pasangan bilangan bulat (mulai, akhir), yang mewakili rentang inklusif di sepanjang jalan di mana pohon akan dihapus.\n\nArgs:\n- l (int): Panjang jalan.\n- areas (List[Tuple[int, int]]): Daftar tuple di mana setiap tuple mewakili area yang dibersihkan di jalan.\n\nReturns:\n- int: Jumlah total pohon yang tersisa di sepanjang jalan setelah area yang ditentukan telah dibersihkan.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) akan mengembalikan 5\n- remaining_trees_after_clearing(100, [(10, 90)]) akan mengembalikan 20.", "ja": "    特定の区域が伐採された後の道路沿いに残っている木の数を計算します。\n\n    道路は長さ 'l' の直線で表され、最初は木で満たされています。\n    伐採が予定されている各区域は、道路に沿って木が除去される範囲を表す整数のペア (start, end) として指定されます。\n\n    引数:\n    - l (int): 道路の長さ。\n    - areas (List[Tuple[int, int]]): 各タプルが道路上の伐採区域を表すタプルのリスト。\n    \n    戻り値:\n    - int: 指定された区域が伐採された後に道路沿いに残っている木の総数。\n    \n    例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) は 5 を返します。\n    - remaining_trees_after_clearing(100, [(10, 90)]) は 20 を返します。", "ko": "    특정 지역이 제거된 후 도로를 따라 남아있는 나무의 수를 계산합니다.\n\n    도로는 길이 'l'의 직선으로 표현되며 처음에는 나무로 가득 차 있습니다.\n    제거할 예정인 각 지역은 (start, end) 쌍의 정수로 지정되며, 이는 나무가 제거될 도로의 포함 범위를 나타냅니다.\n\n    인수:\n    - l (int): 도로의 길이.\n    - areas (List[Tuple[int, int]]): 각 튜플이 도로에서 제거된 지역을 나타내는 튜플의 리스트.\n    \n    반환:\n    - int: 지정된 지역이 제거된 후 도로를 따라 남아있는 나무의 총 수.\n    \n    예제:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)])는 5를 반환합니다.\n    - remaining_trees_after_clearing(100, [(10, 90)])는 20을 반환합니다.", "ml": "    പ്രത്യേക പ്രദേശങ്ങൾ വെട്ടി നീക്കിയ ശേഷം ഒരു റോഡിനോട് ചേർന്നുള്ള ശേഷിക്കുന്ന മരങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n\n    റോഡ് 'l' നീളമുള്ള ഒരു നേരിയ രേഖയായി പ്രതിനിധീകരിക്കപ്പെടുന്നു, ഇത് ആദ്യം മരങ്ങളാൽ നിറഞ്ഞിരിക്കും.\n    വെട്ടി നീക്കാൻ നിശ്ചയിച്ചിരിക്കുന്ന ഓരോ പ്രദേശവും (ആരംഭം, അവസാനം) എന്ന രണ്ട് പൂർണ്ണസംഖ്യകളുടെ ജോഡിയായി വ്യക്തമാക്കപ്പെടുന്നു, \n    മരങ്ങൾ നീക്കം ചെയ്യപ്പെടുന്ന റോഡിനോടനുബന്ധിച്ചുള്ള ഉൾപ്പെടുന്ന പരിധി പ്രതിനിധീകരിക്കുന്നു.\n\n    Args:\n    - l (int): റോഡിന്റെ നീളം.\n    - areas (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും റോഡിലെ വെട്ടി നീക്കിയ പ്രദേശത്തെ പ്രതിനിധീകരിക്കുന്ന ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    Returns:\n    - int: നിശ്ചയിച്ച പ്രദേശങ്ങൾ വെട്ടി നീക്കിയ ശേഷം റോഡിനോട് ചേർന്നുള്ള മൊത്തത്തിലുള്ള ശേഷിക്കുന്ന മരങ്ങളുടെ എണ്ണം.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20.", "fa": "محاسبه تعداد درختان باقی‌مانده در طول یک جاده پس از پاکسازی مناطق خاص.\n\nجاده به صورت یک خط مستقیم به طول 'l' نمایش داده می‌شود و در ابتدا با درختان پر شده است.\nهر منطقه‌ای که برای پاکسازی برنامه‌ریزی شده است به صورت یک جفت عدد صحیح (شروع، پایان) مشخص می‌شود که\nمحدوده شامل در طول جاده را نشان می‌دهد که در آن درختان برداشته خواهند شد.\n\nآرگومان‌ها:\n- l (int): طول جاده.\n- areas (List[Tuple[int, int]]): لیستی از جفت‌ها که هر جفت نمایانگر یک منطقه پاکسازی شده در جاده است.\n\nبازگشت:\n- int: تعداد کل درختان باقی‌مانده در طول جاده پس از پاکسازی مناطق مشخص شده.\n\nمثال‌ها:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) مقدار 5 را برمی‌گرداند.\n- remaining_trees_after_clearing(100, [(10, 90)]) مقدار 20 را برمی‌گرداند."}}
{"task_id": "Python/37", "prompt": {"en": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "sq": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohe.\n\n    Kjo funksion zgjidh një variant të problemit të çantës 0/1 ku qëllimi është të maksimizohet\n    vlera totale e bimëve të mbledhura pa tejkaluar kufirin e kohës. Çdo bimë mund të mblidhet\n    maksimumi një herë dhe ka një kosto kohe dhe vlerë të lidhur.\n\n    Argumentet:\n    - T (int): Koha totale e disponueshme për mbledhjen e bimëve.\n    - M (int): Numri i bimëve të ndryshme në shpellë.\n    - herbs (List[Tuple[int, int]]): Një listë tuplesh, ku çdo tuple përmban dy numra të plotë\n      që përfaqësojnë kohën e kërkuar për të mbledhur bimën dhe vlerën e bimës, përkatësisht.\n\n    Kthen:\n    - int: Vlera maksimale totale e bimëve që mund të mblidhen brenda kufirit të kohës.\n\n    Shembuj:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "hy": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվել խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակային սահմանափակման մեջ:\n\n    Այս ֆունկցիան լուծում է 0/1 դանակապանակի խնդրի տարբերակը, որտեղ նպատակն է առավելագույնացնել\n    հավաքված խոտաբույսերի ընդհանուր արժեքը՝ առանց ժամանակային սահմանափակումը գերազանցելու: Յուրաքանչյուր խոտաբույս\n    կարելի է հավաքել առավելագույնը մեկ անգամ և ունի համապատասխան ժամանակային արժեք և արժեք:\n\n    Արգումենտներ:\n    - T (int): Ընդհանուր ժամանակը, որը հասանելի է խոտաբույսեր հավաքելու համար:\n    - M (int): Տարբեր խոտաբույսերի քանակը քարանձավում:\n    - herbs (List[Tuple[int, int]]): Կրկնորդների ցուցակ, որտեղ յուրաքանչյուր կրկնորդ պարունակում է երկու ամբողջ թիվ,\n      որոնք ներկայացնում են խոտաբույսը հավաքելու համար պահանջվող ժամանակը և խոտաբույսի արժեքը, համապատասխանաբար:\n\n    Վերադարձնում է:\n    - int: Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել ժամանակային սահմանափակման մեջ:\n\n    Օրինակներ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "bn": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    একটি নির্দিষ্ট সময়সীমার মধ্যে যতটা সম্ভব বেশি মূল্যবান ভেষজ সংগ্রহের সর্বাধিক মোট মূল্য হিসাব করুন।\n\n    এই ফাংশনটি 0/1 ন্যাপকস্যাক সমস্যার একটি বৈকল্পিক সমাধান করে যেখানে লক্ষ্য হল সময়সীমা অতিক্রম না করে\n    সংগ্রহ করা ভেষজের মোট মূল্য সর্বাধিক করা। প্রতিটি ভেষজ সর্বাধিক একবারই সংগ্রহ করা যেতে পারে এবং এর সাথে\n    একটি নির্দিষ্ট সময় খরচ এবং মূল্য যুক্ত থাকে।\n\n    আর্গুমেন্ট:\n    - T (int): ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    - M (int): গুহায় বিভিন্ন ভেষজের সংখ্যা।\n    - herbs (List[Tuple[int, int]]): একটি টাপল তালিকা, যেখানে প্রতিটি টাপল দুটি পূর্ণসংখ্যা ধারণ করে\n      যা যথাক্রমে ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং ভেষজের মূল্য উপস্থাপন করে।\n\n    রিটার্নস:\n    - int: সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্য।\n\n    উদাহরণ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "bg": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n\n    Тази функция решава вариация на проблема с раницата 0/1, където целта е да се максимизира\n    общата стойност на събраните билки, без да се превишава времевият лимит. Всяка билка може да бъде събрана\n    най-много веднъж и има свързани времеви разходи и стойност.\n\n    Аргументи:\n    - T (int): Общото време, налично за събиране на билки.\n    - M (int): Броят на различните билки в пещерата.\n    - herbs (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа две цели числа,\n      представляващи времето, необходимо за събиране на билката и стойността на билката, съответно.\n\n    Връща:\n    - int: Максималната обща стойност на билките, които могат да бъдат събрани в рамките на времевия лимит.\n\n    Примери:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "zh": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在给定时间限制内可以采摘的草药的最大总价值。\n\n    此函数解决了0/1背包问题的变体，其目标是在不超过时间限制的情况下最大化采摘草药的总价值。\n    每种草药最多可以采摘一次，并且具有相关的时间成本和价值。\n\n    参数:\n    - T (int): 可用于采摘草药的总时间。\n    - M (int): 洞穴中不同草药的数量。\n    - herbs (List[Tuple[int, int]]): 一个元组列表，每个元组包含两个整数，分别表示采摘草药所需的时间和草药的价值。\n\n    返回:\n    - int: 在时间限制内可以采摘的草药的最大总价值。\n\n    示例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "fr": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculer la valeur totale maximale des herbes pouvant être cueillies dans un délai donné.\n\n    Cette fonction résout une variation du problème du sac à dos 0/1 où l'objectif est de maximiser\n    la valeur totale des herbes cueillies sans dépasser la limite de temps. Chaque herbe peut être cueillie\n    au plus une fois et a un coût en temps et une valeur associés.\n\n    Arguments:\n    - T (int): Le temps total disponible pour cueillir des herbes.\n    - M (int): Le nombre d'herbes différentes dans la grotte.\n    - herbs (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers\n      représentant le temps nécessaire pour cueillir l'herbe et la valeur de l'herbe, respectivement.\n\n    Renvoie:\n    - int: La valeur totale maximale des herbes pouvant être cueillies dans le délai imparti.\n\n    Exemples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "de": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechne den maximalen Gesamtwert der Kräuter, die innerhalb eines gegebenen Zeitlimits gepflückt werden können.\n\n    Diese Funktion löst eine Variante des 0/1-Rucksackproblems, bei dem das Ziel darin besteht,\n    den Gesamtwert der gepflückten Kräuter zu maximieren, ohne das Zeitlimit zu überschreiten.\n    Jedes Kraut kann höchstens einmal gepflückt werden und hat eine zugehörige Zeitkosten und einen Wert.\n\n    Argumente:\n    - T (int): Die insgesamt verfügbare Zeit zum Pflücken der Kräuter.\n    - M (int): Die Anzahl der verschiedenen Kräuter in der Höhle.\n    - herbs (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält,\n      die die zum Pflücken des Krauts erforderliche Zeit und den Wert des Krauts darstellen.\n\n    Rückgabewert:\n    - int: Der maximale Gesamtwert der Kräuter, die innerhalb des Zeitlimits gepflückt werden können.\n\n    Beispiele:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "ha": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafa mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka cikin iyakar lokaci da aka bayar.\n\n    Wannan aikin yana warware wani bambancin matsalar jakar 0/1 inda burin shine a ƙara\n    jimillar ƙimar ganyayyaki da aka ɗauka ba tare da wuce iyakar lokaci ba. Ana iya ɗaukar kowanne ganye\n    sau ɗaya kawai kuma yana da alaƙa da farashin lokaci da ƙima.\n\n    Args:\n    - T (int): Jimillar lokacin da ake da shi don ɗaukar ganyayyaki.\n    - M (int): Yawan nau'ikan ganyayyaki daban-daban a cikin kogon.\n    - herbs (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple yana ɗauke da lambobi biyu\n      suna wakiltar lokacin da ake buƙata don ɗaukar ganyen da kuma ƙimar ganyen, bi da bi.\n\n    Returns:\n    - int: Mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka cikin iyakar lokaci.\n\n    Misalai:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "hi": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    दिए गए समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करें।\n\n    यह फ़ंक्शन 0/1 नॉapsack समस्या के एक प्रकार को हल करता है जहाँ लक्ष्य है\n    चुनी गई जड़ी-बूटियों के कुल मूल्य को अधिकतम करना बिना समय सीमा को पार किए। प्रत्येक जड़ी-बूटी को\n    अधिकतम एक बार चुना जा सकता है और इसके साथ एक संबंधित समय लागत और मूल्य होता है।\n\n    तर्क:\n    - T (int): जड़ी-बूटियों को चुनने के लिए उपलब्ध कुल समय।\n    - M (int): गुफा में विभिन्न जड़ी-बूटियों की संख्या।\n    - herbs (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं\n      जो क्रमशः जड़ी-बूटी को चुनने के लिए आवश्यक समय और जड़ी-बूटी का मूल्य दर्शाते हैं।\n\n    वापसी:\n    - int: समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    उदाहरण:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "hu": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Számítsa ki a gyógynövények maximális összértékét, amelyet adott időkorláton belül lehet összegyűjteni.\n\n    Ez a függvény egy 0/1 hátizsák probléma variációját oldja meg, ahol a cél a gyógynövények összértékének\n    maximalizálása anélkül, hogy túllépnénk az időkorlátot. Minden gyógynövényt legfeljebb egyszer lehet\n    összegyűjteni, és mindegyikhez társul egy időráfordítás és egy érték.\n\n    Paraméterek:\n    - T (int): Az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\n    - M (int): A barlangban található különböző gyógynövények száma.\n    - herbs (List[Tuple[int, int]]): Egy listája a tuple-öknek, ahol minden tuple két egész számot tartalmaz,\n      amelyek a gyógynövény összegyűjtéséhez szükséges időt és a gyógynövény értékét képviselik.\n\n    Visszatér:\n    - int: A gyógynövények maximális összértéke, amelyet az időkorláton belül lehet összegyűjteni.\n\n    Példák:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "es": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcular el valor total máximo de hierbas que se pueden recoger dentro de un límite de tiempo dado.\n\n    Esta función resuelve una variación del problema de la mochila 0/1 donde el objetivo es maximizar\n    el valor total de las hierbas recogidas sin exceder el límite de tiempo. Cada hierba se puede recoger\n    como máximo una vez y tiene un costo de tiempo y un valor asociado.\n\n    Argumentos:\n    - T (int): El tiempo total disponible para recoger hierbas.\n    - M (int): El número de diferentes hierbas en la cueva.\n    - herbs (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros\n      que representan el tiempo requerido para recoger la hierba y el valor de la hierba, respectivamente.\n\n    Devuelve:\n    - int: El valor total máximo de hierbas que se pueden recoger dentro del límite de tiempo.\n\n    Ejemplos:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "arb": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    حساب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n\n    تحل هذه الدالة نوعًا من مشكلة الحقيبة 0/1 حيث يكون الهدف هو تعظيم\n    القيمة الإجمالية للأعشاب المجمعة دون تجاوز الحد الزمني. يمكن جمع كل عشب\n    مرة واحدة على الأكثر وله تكلفة زمنية وقيمة مرتبطة به.\n\n    يعيدالحجج:\n    - T (int): الوقت الإجمالي المتاح لجمع الأعشاب.\n    - M (int): عدد الأعشاب المختلفة في الكهف.\n    - herbs (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين\n      يمثلان الوقت المطلوب لجمع العشب وقيمة العشب، على التوالي.\n\n    يعيد:\n    - int: القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الحد الزمني.\n\n    امثله:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "sw": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Kuhesabu thamani ya juu kabisa ya mimea ambayo inaweza kuchumwa ndani ya muda uliowekwa.\n\n    Kazi hii inatatua tofauti ya tatizo la 0/1 knapsack ambapo lengo ni kuongeza\n    thamani ya jumla ya mimea iliyochumwa bila kuzidi kikomo cha muda. Kila mmea unaweza kuchumwa\n    mara moja tu na una gharama ya muda na thamani inayohusiana.\n\n    Hoja:\n    - T (int): Jumla ya muda unaopatikana kwa ajili ya kuchuma mimea.\n    - M (int): Idadi ya mimea tofauti kwenye pango.\n    - herbs (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili\n      zinazowakilisha muda unaohitajika kuchuma mmea na thamani ya mmea, mtawalia.\n\n    Inarejesha:\n    - int: Thamani ya juu kabisa ya mimea ambayo inaweza kuchumwa ndani ya kikomo cha muda.\n\n    Mifano:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "tr": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplayın.\n\n    Bu fonksiyon, zaman sınırını aşmadan toplanan otların toplam değerini maksimize etmeyi amaçlayan\n    0/1 sırt çantası probleminin bir varyasyonunu çözer. Her ot en fazla bir kez toplanabilir ve\n    her birinin ilişkili bir zaman maliyeti ve değeri vardır.\n\n    Argümanlar:\n    - T (int): Ot toplamak için mevcut toplam zaman.\n    - M (int): Mağaradaki farklı otların sayısı.\n    - herbs (List[Tuple[int, int]]): Her biri otu toplamak için gereken zamanı ve otun değerini\n      temsil eden iki tam sayı içeren bir demet listesi.\n\n    Döndürür:\n    - int: Zaman sınırı içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "vi": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính toán giá trị tổng tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian cho phép.\n\n    Hàm này giải quyết một biến thể của bài toán ba lô 0/1, trong đó mục tiêu là tối đa hóa\n    tổng giá trị của các loại thảo mộc được hái mà không vượt quá giới hạn thời gian. Mỗi loại thảo mộc có thể được hái\n    tối đa một lần và có chi phí thời gian và giá trị liên quan.\n\n    Tham số:\n    - T (int): Tổng thời gian có sẵn để hái thảo mộc.\n    - M (int): Số lượng các loại thảo mộc khác nhau trong hang động.\n    - herbs (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên\n      đại diện cho thời gian cần thiết để hái thảo mộc và giá trị của thảo mộc đó, tương ứng.\n\n    Trả về:\n    - int: Giá trị tổng tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian.\n\n    Ví dụ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "id": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Hitung nilai total maksimum dari herbal yang dapat dipetik dalam batas waktu yang diberikan.\n\n    Fungsi ini menyelesaikan variasi dari masalah knapsack 0/1 di mana tujuannya adalah untuk memaksimalkan\n    nilai total dari herbal yang dipetik tanpa melebihi batas waktu. Setiap herbal dapat dipetik\n    paling banyak sekali dan memiliki biaya waktu dan nilai yang terkait.\n\n    Argumen:\n    - T (int): Total waktu yang tersedia untuk memetik herbal.\n    - M (int): Jumlah jenis herbal yang berbeda di dalam gua.\n    - herbs (List[Tuple[int, int]]): Daftar tuple, di mana setiap tuple berisi dua bilangan bulat\n      yang mewakili waktu yang dibutuhkan untuk memetik herbal dan nilai herbal tersebut, masing-masing.\n\n    Mengembalikan:\n    - int: Nilai total maksimum dari herbal yang dapat dipetik dalam batas waktu.\n\n    Contoh:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "ja": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    与えられた時間制限内で摘むことができるハーブの最大総価値を計算します。\n\n    この関数は、0/1ナップサック問題の変種を解決します。ここでの目標は、\n    時間制限を超えずに摘むハーブの総価値を最大化することです。各ハーブは\n    多くても一度だけ摘むことができ、関連する時間コストと価値があります。\n\n    引数:\n    - T (int): ハーブを摘むために利用可能な総時間。\n    - M (int): 洞窟内の異なるハーブの数。\n    - herbs (List[Tuple[int, int]]): 各タプルがハーブを摘むのに必要な時間と\n      ハーブの価値をそれぞれ表す2つの整数を含むタプルのリスト。\n\n    戻り値:\n    - int: 時間制限内で摘むことができるハーブの最大総価値。\n\n    例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "ko": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    주어진 시간 제한 내에서 채집할 수 있는 약초의 최대 총 가치를 계산합니다.\n\n    이 함수는 0/1 배낭 문제의 변형을 해결하며, 목표는 시간 제한을 초과하지 않고\n    채집한 약초의 총 가치를 최대화하는 것입니다. 각 약초는 최대 한 번만 채집할 수 있으며,\n    관련된 시간 비용과 가치가 있습니다.\n\n    Args:\n    - T (int): 약초 채집에 사용할 수 있는 총 시간.\n    - M (int): 동굴 내의 서로 다른 약초의 수.\n    - herbs (List[Tuple[int, int]]): 각 튜플이 약초를 채집하는 데 필요한 시간과\n      약초의 가치를 각각 나타내는 두 개의 정수를 포함하는 튜플의 리스트.\n\n    Returns:\n    - int: 시간 제한 내에서 채집할 수 있는 약초의 최대 총 가치.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "ml": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    നൽകിയിരിക്കുന്ന സമയപരിധിക്കുള്ളിൽ തിരഞ്ഞെടുക്കാൻ കഴിയുന്ന ഔഷധസസ്യങ്ങളുടെ പരമാവധി മൊത്തം മൂല്യം കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ 0/1 നാപ്സാക്ക് പ്രശ്നത്തിന്റെ ഒരു വ്യതിയാനത്തെ പരിഹരിക്കുന്നു, ഇവിടെ ലക്ഷ്യം\n    സമയപരിധി കവിയാതെ തിരഞ്ഞെടുക്കുന്ന ഔഷധസസ്യങ്ങളുടെ മൊത്തം മൂല്യം പരമാവധി ആക്കുകയാണ്. ഓരോ ഔഷധസസ്യവും\n    പരമാവധി ഒരിക്കൽ മാത്രമേ തിരഞ്ഞെടുക്കാൻ കഴിയൂ, കൂടാതെ ഓരോന്നിനും ബന്ധപ്പെട്ട സമയ ചെലവും മൂല്യവും ഉണ്ട്.\n\n    Args:\n    - T (int): ഔഷധസസ്യങ്ങൾ തിരഞ്ഞെടുക്കുന്നതിനുള്ള മൊത്തം ലഭ്യമായ സമയം.\n    - M (int): ഗുഹയിലെ വ്യത്യസ്തമായ ഔഷധസസ്യങ്ങളുടെ എണ്ണം.\n    - herbs (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും രണ്ട് പൂർണ്ണസംഖ്യകളടങ്ങിയ ഒരു പട്ടിക,\n      അവയിൽ ഓരോന്നും ഔഷധസസ്യം തിരഞ്ഞെടുക്കുന്നതിനാവശ്യമായ സമയവും ഔഷധസസ്യത്തിന്റെ മൂല്യവും പ്രതിനിധീകരിക്കുന്നു.\n\n    Returns:\n    - int: സമയപരിധിക്കുള്ളിൽ തിരഞ്ഞെടുക്കാൻ കഴിയുന്ന ഔഷധസസ്യങ്ങളുടെ പരമാവധി മൊത്തം മൂല്യം.\n\n    ഉദാഹരണങ്ങൾ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"", "fa": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    محاسبه حداکثر ارزش کل گیاهانی که می‌توان در یک محدودیت زمانی معین چید.\n\n    این تابع یک نوع تغییر یافته از مسئله کوله‌پشتی 0/1 را حل می‌کند که هدف آن حداکثر کردن\n    ارزش کل گیاهان چیده شده بدون تجاوز از محدودیت زمانی است. هر گیاه را می‌توان حداکثر یک بار چید\n    و هر گیاه دارای هزینه زمانی و ارزش مرتبطی است.\n\n    آرگومان‌ها:\n    - T (int): کل زمان موجود برای چیدن گیاهان.\n    - M (int): تعداد گیاهان مختلف در غار.\n    - herbs (List[Tuple[int, int]]): لیستی از زوج‌ها، که هر زوج شامل دو عدد صحیح است\n      که به ترتیب زمان مورد نیاز برای چیدن گیاه و ارزش گیاه را نشان می‌دهند.\n\n    بازگشت:\n    - int: حداکثر ارزش کل گیاهانی که می‌توان در محدودیت زمانی چید.\n\n    مثال‌ها:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\""}, "canonical_solution": "    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]", "instruction": {"en": "Write a python function 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' to solve the following problem:\n\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    ", "sq": "Shkruani një funksion python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohor.\n\n    Ky funksion zgjidh një variant të problemit të çantës 0/1 ku qëllimi është të maksimizohet\n    vlera totale e bimëve të mbledhura pa tejkaluar kufirin kohor. Çdo bimë mund të mblidhet\n    maksimumi një herë dhe ka një kosto kohe dhe vlerë të lidhur.\n\n    Args:\n    - T (int): Koha totale e disponueshme për mbledhjen e bimëve.\n    - M (int): Numri i bimëve të ndryshme në shpellë.\n    - herbs (List[Tuple[int, int]]): Një listë tuples, ku çdo tuple përmban dy numra të plotë\n      që përfaqësojnë kohën e nevojshme për të mbledhur bimën dhe vlerën e bimës, përkatësisht.\n\n    Kthen:\n    - int: Vlera maksimale totale e bimëve që mund të mblidhen brenda kufirit kohor.\n\n    Shembuj:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "hy": "Պայթոն ֆունկցիա 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվել խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակի սահմաններում:\n\n    Այս ֆունկցիան լուծում է 0/1 պայուսակի խնդրի տարբերակը, որտեղ նպատակը \n    խոտաբույսերի ընդհանուր արժեքի առավելագույնացումն է՝ առանց ժամանակի սահմանը գերազանցելու: Յուրաքանչյուր խոտաբույս կարելի է հավաքել \n    առավելագույնը մեկ անգամ և ունի կապված ժամանակի արժեք և արժեք:\n\n    Արձ:\n    - T (int): Խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը:\n    - M (int): Քարանձավում տարբեր խոտաբույսերի քանակը:\n    - herbs (List[Tuple[int, int]]): Կրկնակի թվերի ցուցակ, որտեղ յուրաքանչյուր կրկնակի թիվ պարունակում է երկու ամբողջ թիվ,\n      որոնք համապատասխանաբար ներկայացնում են խոտաբույսը հավաքելու համար պահանջվող ժամանակը և խոտաբույսի արժեքը:\n\n    Վերադարձնում է:\n    - int: Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել ժամանակի սահմաններում:\n\n    Օրինակներ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "bn": "একটি পাইথন ফাংশন 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত সময়সীমার মধ্যে যতটা সম্ভব সর্বাধিক মোট মূল্যবান ভেষজ সংগ্রহ করা যায় তা গণনা করুন।\n\n    এই ফাংশনটি 0/1 ন্যাপকস্যাক সমস্যার একটি রূপ সমাধান করে যেখানে লক্ষ্য হল সময়সীমা অতিক্রম না করে\n    সংগ্রহ করা ভেষজগুলির মোট মূল্য সর্বাধিক করা। প্রতিটি ভেষজ সর্বাধিক একবার সংগ্রহ করা যেতে পারে এবং এর সাথে\n    একটি নির্দিষ্ট সময় খরচ এবং মূল্য যুক্ত থাকে।\n\n    আর্গস:\n    - T (int): ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    - M (int): গুহায় বিভিন্ন ভেষজের সংখ্যা।\n    - herbs (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে\n      যা ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং ভেষজের মূল্য প্রতিনিধিত্ব করে।\n\n    রিটার্নস:\n    - int: সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজগুলির সর্বাধিক মোট মূল্য।\n\n    উদাহরণ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "bg": "Напишете функция на Python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' за решаване на следния проблем:\n\n    Изчислете максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n\n    Тази функция решава вариант на проблема с раницата 0/1, където целта е да се максимизира\n    общата стойност на събраните билки, без да се надвишава времевият лимит. Всяка билка може да бъде събрана\n    най-много веднъж и има свързани времеви разходи и стойност.\n\n    Аргументи:\n    - T (int): Общото време, налично за събиране на билки.\n    - M (int): Броят на различните билки в пещерата.\n    - herbs (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа две цели числа,\n      представляващи времето, необходимо за събиране на билката и стойността на билката, съответно.\n\n    Връща:\n    - int: Максималната обща стойност на билките, които могат да бъдат събрани в рамките на времевия лимит.\n\n    Примери:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "zh": "编写一个python函数'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:'来解决以下问题：\n\n    计算在给定时间限制内可以采摘的草药的最大总价值。\n\n    此函数解决了0/1背包问题的一个变体，其目标是在不超过时间限制的情况下最大化\n    采摘的草药的总价值。每种草药最多只能采摘一次，并且具有相关的时间成本和价值。\n\n    参数:\n    - T (int): 可用于采摘草药的总时间。\n    - M (int): 洞穴中不同草药的数量。\n    - herbs (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数，\n      分别表示采摘草药所需的时间和草药的价值。\n\n    返回:\n    - int: 在时间限制内可以采摘的草药的最大总价值。\n\n    示例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "fr": "Écrivez une fonction python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' pour résoudre le problème suivant :\n\n    Calculer la valeur totale maximale des herbes qui peuvent être cueillies dans un délai donné.\n\n    Cette fonction résout une variation du problème du sac à dos 0/1 où l'objectif est de maximiser\n    la valeur totale des herbes cueillies sans dépasser la limite de temps. Chaque herbe peut être cueillie\n    au plus une fois et a un coût en temps et une valeur associés.\n\n    Arguments:\n    - T (int): Le temps total disponible pour cueillir les herbes.\n    - M (int): Le nombre d'herbes différentes dans la grotte.\n    - herbs (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers\n      représentant le temps nécessaire pour cueillir l'herbe et la valeur de l'herbe, respectivement.\n\n    Renvoie:\n    - int: La valeur totale maximale des herbes qui peuvent être cueillies dans la limite de temps.\n\n    Exemples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "de": "Schreiben Sie eine Python-Funktion 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie den maximalen Gesamtwert der Kräuter, die innerhalb eines gegebenen Zeitlimits gesammelt werden können.\n\n    Diese Funktion löst eine Variante des 0/1-Rucksackproblems, bei dem das Ziel darin besteht,\n    den Gesamtwert der gesammelten Kräuter zu maximieren, ohne das Zeitlimit zu überschreiten. Jedes Kraut kann\n    höchstens einmal gesammelt werden und hat eine zugehörige Zeitkosten und einen Wert.\n\n    Argumente:\n    - T (int): Die insgesamt verfügbare Zeit zum Sammeln von Kräutern.\n    - M (int): Die Anzahl der verschiedenen Kräuter in der Höhle.\n    - herbs (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält,\n      die jeweils die Zeit repräsentieren, die benötigt wird, um das Kraut zu sammeln, und den Wert des Krauts.\n\n    Rückgabe:\n    - int: Der maximale Gesamtwert der Kräuter, die innerhalb des Zeitlimits gesammelt werden können.\n\n    Beispiele:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "ha": "Rubuta wani aikin python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka a cikin iyakar lokaci da aka bayar.\n\n    Wannan aikin yana warware bambancin matsalar 0/1 knapsack inda burin shine a ƙara\n    jimillar ƙimar ganyayyaki da aka ɗauka ba tare da wuce iyakar lokaci ba. Kowace ganye za a iya ɗauka\n    sau ɗaya kawai kuma tana da alaƙa da farashin lokaci da ƙima.\n\n    Args:\n    - T (int): Jimillar lokacin da ake da shi don ɗaukar ganyayyaki.\n    - M (int): Yawan nau'ikan ganyayyaki daban-daban a cikin kogon.\n    - herbs (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple ya ƙunshi lambobi biyu\n      suna wakiltar lokacin da ake buƙata don ɗaukar ganyen da ƙimar ganyen, bi da bi.\n\n    Returns:\n    - int: Mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka a cikin iyakar lokaci.\n\n    Misalai:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "hi": "एक पायथन फ़ंक्शन 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करें।\n\n    यह फ़ंक्शन 0/1 नॅपसैक समस्या के एक भिन्न रूप को हल करता है जहां लक्ष्य \n    समय सीमा को पार किए बिना चुनी गई जड़ी-बूटियों के कुल मूल्य को अधिकतम करना है। प्रत्येक जड़ी-बूटी को \n    अधिकतम एक बार चुना जा सकता है और इसके साथ एक संबंधित समय लागत और मूल्य होता है।\n\n    तर्क:\n    - T (int): जड़ी-बूटियों को चुनने के लिए उपलब्ध कुल समय।\n    - M (int): गुफा में विभिन्न जड़ी-बूटियों की संख्या।\n    - herbs (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहां प्रत्येक ट्यूपल में दो पूर्णांक होते हैं\n      जो क्रमशः जड़ी-बूटी को चुनने के लिए आवश्यक समय और जड़ी-बूटी का मूल्य दर्शाते हैं।\n\n    लौटाता है:\n    - int: समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    उदाहरण:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "hu": "Írj egy python függvényt 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' a következő probléma megoldására:\n\n    Számítsd ki a gyógynövények maximális összértékét, amelyet egy adott időkorláton belül lehet összegyűjteni.\n\n    Ez a függvény a 0/1 hátizsák probléma egy változatát oldja meg, ahol a cél a gyógynövények\n    összértékének maximalizálása az időkorlát túllépése nélkül. Minden gyógynövényt legfeljebb egyszer lehet\n    összegyűjteni, és van hozzá rendelve egy időráfordítás és egy érték.\n\n    Paraméterek:\n    - T (int): Az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\n    - M (int): A barlangban található különböző gyógynövények száma.\n    - herbs (List[Tuple[int, int]]): Egy tuple-ök listája, ahol minden tuple két egész számot tartalmaz,\n      amelyek a gyógynövény összegyűjtéséhez szükséges időt és a gyógynövény értékét képviselik.\n\n    Visszatér:\n    - int: A gyógynövények maximális összértéke, amelyet az időkorláton belül lehet összegyűjteni.\n\n    Példák:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "es": "Escribe una función en Python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' para resolver el siguiente problema:\n\n    Calcula el valor total máximo de hierbas que se pueden recoger dentro de un límite de tiempo dado.\n\n    Esta función resuelve una variación del problema de la mochila 0/1 donde el objetivo es maximizar\n    el valor total de las hierbas recogidas sin exceder el límite de tiempo. Cada hierba se puede recoger\n    como máximo una vez y tiene un costo de tiempo y un valor asociados.\n\n    Argumentos:\n    - T (int): El tiempo total disponible para recoger hierbas.\n    - M (int): El número de diferentes hierbas en la cueva.\n    - herbs (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros\n      que representan el tiempo requerido para recoger la hierba y el valor de la hierba, respectivamente.\n\n    Devuelve:\n    - int: El valor total máximo de hierbas que se pueden recoger dentro del límite de tiempo.\n\n    Ejemplos:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "arb": "اكتب دالة بايثون 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' لحل المشكلة التالية:\n\n    احسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n\n    تحل هذه الدالة نوعًا من مشكلة الحقيبة 0/1 حيث يكون الهدف هو تعظيم\n    القيمة الإجمالية للأعشاب المجمعة دون تجاوز الحد الزمني. يمكن جمع كل عشب\n    مرة واحدة على الأكثر وله تكلفة زمنية وقيمة مرتبطة به.\n\n    المعاملات:\n    - T (int): الوقت الإجمالي المتاح لجمع الأعشاب.\n    - M (int): عدد الأعشاب المختلفة في الكهف.\n    - herbs (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين\n      يمثلان الوقت المطلوب لجمع العشب وقيمة العشب، على التوالي.\n\n    يعيد:\n    - int: القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الحد الزمني.\n\n    أمثلة:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "sw": "Andika kazi ya python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu thamani ya juu kabisa ya jumla ya mimea ambayo inaweza kuchukuliwa ndani ya kikomo cha muda kilichopewa.\n\n    Kazi hii inatatua tofauti ya tatizo la 0/1 knapsack ambapo lengo ni kuongeza\n    thamani ya jumla ya mimea iliyochukuliwa bila kuzidi kikomo cha muda. Kila mmea unaweza kuchukuliwa\n    mara moja tu na una gharama ya muda na thamani inayohusiana.\n\n    Hoja:\n    - T (int): Jumla ya muda unaopatikana kwa ajili ya kuchukua mimea.\n    - M (int): Idadi ya mimea tofauti kwenye pango.\n    - herbs (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili za mzima\n      zinazowakilisha muda unaohitajika kuchukua mmea na thamani ya mmea, mtawalia.\n\n    Inarudisha:\n    - int: Thamani ya juu kabisa ya jumla ya mimea inayoweza kuchukuliwa ndani ya kikomo cha muda.\n\n    Mifano:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "tr": "Bir Python fonksiyonu 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Belirli bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplayın.\n\n    Bu fonksiyon, zaman sınırını aşmadan toplanan otların toplam değerini maksimize etmeyi amaçlayan\n    0/1 sırt çantası probleminin bir varyasyonunu çözer. Her ot en fazla bir kez toplanabilir ve\n    her birinin bir zaman maliyeti ve değeri vardır.\n\n    Argümanlar:\n    - T (int): Ot toplamak için mevcut toplam zaman.\n    - M (int): Mağaradaki farklı otların sayısı.\n    - herbs (List[Tuple[int, int]]): Her bir demetin ot toplamak için gereken zamanı ve otun değerini\n      temsil eden iki tam sayı içeren bir demet listesi.\n\n    Döndürür:\n    - int: Zaman sınırı içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "vi": "Viết một hàm python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' để giải quyết vấn đề sau:\n\n    Tính tổng giá trị tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian cho phép.\n\n    Hàm này giải quyết một biến thể của bài toán cái túi 0/1, trong đó mục tiêu là tối đa hóa\n    tổng giá trị của các loại thảo mộc được hái mà không vượt quá giới hạn thời gian. Mỗi loại thảo mộc có thể được hái\n    nhiều nhất một lần và có chi phí thời gian và giá trị tương ứng.\n\n    Tham số:\n    - T (int): Tổng thời gian có sẵn để hái thảo mộc.\n    - M (int): Số lượng các loại thảo mộc khác nhau trong hang động.\n    - herbs (List[Tuple[int, int]]): Một danh sách các bộ đôi, trong đó mỗi bộ đôi chứa hai số nguyên\n      đại diện cho thời gian cần để hái thảo mộc và giá trị của thảo mộc đó, tương ứng.\n\n    Trả về:\n    - int: Tổng giá trị tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian.\n\n    Ví dụ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "id": "Tulis sebuah fungsi python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung nilai total maksimum dari ramuan yang dapat dipetik dalam batas waktu yang diberikan.\n\n    Fungsi ini menyelesaikan variasi dari masalah knapsack 0/1 di mana tujuannya adalah untuk memaksimalkan\n    nilai total ramuan yang dipetik tanpa melebihi batas waktu. Setiap ramuan dapat dipetik\n    paling banyak sekali dan memiliki biaya waktu serta nilai yang terkait.\n\n    Argumen:\n    - T (int): Total waktu yang tersedia untuk memetik ramuan.\n    - M (int): Jumlah jenis ramuan yang berbeda di dalam gua.\n    - herbs (List[Tuple[int, int]]): Daftar tuple, di mana setiap tuple berisi dua bilangan bulat\n      yang mewakili waktu yang dibutuhkan untuk memetik ramuan dan nilai ramuan tersebut, masing-masing.\n\n    Mengembalikan:\n    - int: Nilai total maksimum dari ramuan yang dapat dipetik dalam batas waktu.\n\n    Contoh:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "ja": "`def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:`というPython関数を作成して、次の問題を解決してください:\n\n    与えられた時間制限内で採取できるハーブの最大合計価値を計算します。\n\n    この関数は、0/1ナップサック問題の変種を解決します。ここでの目標は、時間制限を超えずに採取するハーブの\n    合計価値を最大化することです。各ハーブは最大1回採取でき、関連する時間コストと価値があります。\n\n    引数:\n    - T (int): ハーブを採取するために利用可能な総時間。\n    - M (int): 洞窟内の異なるハーブの数。\n    - herbs (List[Tuple[int, int]]): 各タプルがハーブを採取するのに必要な時間と\n      ハーブの価値を表す2つの整数を含むタプルのリスト。\n\n    戻り値:\n    - int: 時間制限内で採取できるハーブの最大合計価値。\n\n    例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "ko": "파이썬 함수를 작성하세요 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' 다음 문제를 해결하기 위해:\n\n    주어진 시간 제한 내에서 채집할 수 있는 약초의 최대 총 가치를 계산합니다.\n\n    이 함수는 0/1 배낭 문제의 변형을 해결하며, 목표는 시간 제한을 초과하지 않고\n    채집한 약초의 총 가치를 극대화하는 것입니다. 각 약초는 최대 한 번만 채집할 수 있으며\n    관련된 시간 비용과 가치가 있습니다.\n\n    매개변수:\n    - T (int): 약초를 채집할 수 있는 총 시간.\n    - M (int): 동굴 내의 다양한 약초의 수.\n    - herbs (List[Tuple[int, int]]): 각 튜플이 약초를 채집하는 데 필요한 시간과\n      약초의 가치를 나타내는 두 개의 정수를 포함하는 튜플의 리스트.\n\n    반환값:\n    - int: 시간 제한 내에서 채집할 수 있는 약초의 최대 총 가치.\n\n    예시:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "ml": "'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' എന്ന python ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    നൽകിയിരിക്കുന്ന സമയപരിധിക്കുള്ളിൽ തിരുകെടുക്കാവുന്ന ഔഷധസസ്യങ്ങളുടെ പരമാവധി മൊത്തം മൂല്യം കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ 0/1 നാപ്സാക്ക് പ്രശ്നത്തിന്റെ ഒരു വ്യത്യാസം പരിഹരിക്കുന്നു, ഇവിടെ ലക്ഷ്യം\n    സമയപരിധി കവിയാതെ തിരുകെടുക്കുന്ന ഔഷധസസ്യങ്ങളുടെ മൊത്തം മൂല്യം പരമാവധി ആക്കുക എന്നതാണ്. ഓരോ ഔഷധസസ്യവും\n    പരമാവധി ഒരിക്കൽ മാത്രമേ തിരുകെടുക്കാൻ കഴിയൂ, കൂടാതെ ഓരോന്നിനും ബന്ധപ്പെട്ട സമയ ചെലവും മൂല്യവും ഉണ്ട്.\n\n    Args:\n    - T (int): ഔഷധസസ്യങ്ങൾ തിരുകെടുക്കാൻ ലഭ്യമായ മൊത്തം സമയം.\n    - M (int): ഗുഹയിലെ വ്യത്യസ്തമായ ഔഷധസസ്യങ്ങളുടെ എണ്ണം.\n    - herbs (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും ഔഷധസസ്യം തിരുകെടുക്കാൻ ആവശ്യമായ സമയവും\n      ഔഷധസസ്യത്തിന്റെ മൂല്യവും പ്രതിനിധീകരിക്കുന്ന രണ്ട് പൂർണ്ണസംഖ്യകൾ അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\n    Returns:\n    - int: സമയപരിധിക്കുള്ളിൽ തിരുകെടുക്കാവുന്ന ഔഷധസസ്യങ്ങളുടെ പരമാവധി മൊത്തം മൂല്യം.\n\n    ഉദാഹരണങ്ങൾ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "fa": "یک تابع پایتون بنویسید 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' تا مسئله زیر را حل کند:\n\n    حداکثر ارزش کل گیاهانی که می‌توان در یک محدودیت زمانی معین چید را محاسبه کنید.\n\n    این تابع یک نوع از مسئله کوله‌پشتی 0/1 را حل می‌کند که هدف آن به حداکثر رساندن\n    ارزش کل گیاهان چیده شده بدون تجاوز از محدودیت زمانی است. هر گیاه را می‌توان\n    حداکثر یک بار چید و دارای هزینه زمانی و ارزش مرتبط است.\n\n    آرگومان‌ها:\n    - T (int): کل زمان موجود برای چیدن گیاهان.\n    - M (int): تعداد گیاهان مختلف در غار.\n    - herbs (List[Tuple[int, int]]): لیستی از تاپل‌ها که هر تاپل شامل دو عدد صحیح است\n      که زمان مورد نیاز برای چیدن گیاه و ارزش گیاه را نشان می‌دهد.\n\n    بازگشت:\n    - int: حداکثر ارزش کل گیاهانی که می‌توان در محدودیت زمانی چید.\n\n    مثال‌ها:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10"}, "level": "easy", "test": "def test_max_herb_value():\n    # Test case 1: Given example in the problem statement\n    T1, M1 = 70, 3\n    herbs1 = [(71, 100), (69, 1), (1, 2)]\n    expected1 = 3\n    assert max_herb_value(T1, M1,\n                          herbs1) == expected1, f\"Test case 1 failed: expected {expected1}, got {max_herb_value(T1, M1, herbs1)}\"\n\n    # Test case 2: Multiple herbs can be picked within the time limit\n    T2, M2 = 10, 4\n    herbs2 = [(1, 10), (2, 15), (3, 20), (4, 30)]\n    expected2 = 75  # We can pick herbs with time 1, 2 and 3 to get maximum value 10 + 15 + 20\n    assert max_herb_value(T2, M2,\n                          herbs2) == expected2, f\"Test case 2 failed: expected {expected2}, got {max_herb_value(T2, M2, herbs2)}\"\n\n    # Test case 3: Only one herb can be picked due to time constraint\n    T3, M3 = 5, 3\n    herbs3 = [(5, 10), (4, 7), (6, 12)]\n    expected3 = 10  # We can only pick the first herb\n    assert max_herb_value(T3, M3,\n                          herbs3) == expected3, f\"Test case 3 failed: expected {expected3}, got {max_herb_value(T3, M3, herbs3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\ntest_max_herb_value()", "entry_point": "max_herb_value", "signature": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:", "docstring": {"en": "\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    ", "sq": "\n    Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri kohor të caktuar.\n\n    Kjo funksion zgjidh një variant të problemit 0/1 të çantës së shpinës ku qëllimi është të maksimizohet\n    vlera totale e bimëve të mbledhura pa tejkaluar kufirin kohor. Çdo bimë mund të mblidhet\n    më së shumti një herë dhe ka një kosto kohe dhe vlerë të lidhur.\n\n    Argumentet:\n    - T (int): Koha totale e disponueshme për mbledhjen e bimëve.\n    - M (int): Numri i bimëve të ndryshme në shpellë.\n    - herbs (List[Tuple[int, int]]): Një listë tuplesh, ku çdo tuple përmban dy numra të plotë\n      që përfaqësojnë kohën e nevojshme për të mbledhur bimën dhe vlerën e bimës, përkatësisht.\n\n    Kthen:\n    - int: Vlera maksimale totale e bimëve që mund të mblidhen brenda kufirit kohor.\n\n    Shembuj:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "hy": "\n    Հաշվել խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել տրված ժամանակի սահմանափակման մեջ:\n\n    Այս ֆունկցիան լուծում է 0/1 տոպրակի խնդրի մի տարբերակ, որտեղ նպատակը խոտաբույսերի ընդհանուր արժեքի առավելագույնացումն է՝ առանց ժամանակի սահմանափակման գերազանցման: Յուրաքանչյուր խոտաբույս կարելի է հավաքել առավելագույնը մեկ անգամ և ունի կապված ժամանակի արժեք և արժեք:\n\n    Պարամետրեր:\n    - T (int): Ընդհանուր ժամանակը, որը հասանելի է խոտաբույսեր հավաքելու համար:\n    - M (int): Քարանձավում տարբեր խոտաբույսերի քանակը:\n    - herbs (List[Tuple[int, int]]): Թվային զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ պարունակում է երկու ամբողջ թիվ, որոնք ներկայացնում են խոտաբույսի հավաքման համար պահանջվող ժամանակը և խոտաբույսի արժեքը, համապատասխանաբար:\n\n    Վերադարձնում է:\n    - int: Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել ժամանակի սահմանափակման մեջ:\n\n    Օրինակներ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "bn": "\n    প্রদত্ত সময়সীমার মধ্যে যতটা সম্ভব সর্বাধিক মূল্যবান ভেষজ সংগ্রহের হিসাব করুন।\n\n    এই ফাংশনটি 0/1 ন্যাপকস্যাক সমস্যার একটি ভিন্নতা সমাধান করে যেখানে লক্ষ্য হল \n    সময়সীমা অতিক্রম না করে ভেষজ সংগ্রহের মোট মূল্য সর্বাধিক করা। প্রতিটি ভেষজ \n    সর্বাধিক একবার সংগ্রহ করা যেতে পারে এবং এর সাথে একটি সময় খরচ এবং মূল্য \n    যুক্ত থাকে।\n\n    আর্গুমেন্টসমূহ:\n    - T (int): ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    - M (int): গুহায় বিভিন্ন ভেষজের সংখ্যা।\n    - herbs (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে \n      দুটি পূর্ণসংখ্যা থাকে যা যথাক্রমে ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং \n      ভেষজের মূল্য উপস্থাপন করে।\n\n    রিটার্নস:\n    - int: সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্য।\n\n    উদাহরণ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "bg": "\n    Изчислете максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n\n    Тази функция решава вариация на проблема с раницата 0/1, където целта е да се максимизира\n    общата стойност на събраните билки, без да се превишава времевият лимит. Всяка билка може да бъде събрана\n    най-много веднъж и има свързани времеви разходи и стойност.\n\n    Аргументи:\n    - T (int): Общото време, налично за събиране на билки.\n    - M (int): Броят на различните билки в пещерата.\n    - herbs (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа два цели числа,\n      представляващи времето, необходимо за събиране на билката и стойността на билката, съответно.\n\n    Връща:\n    - int: Максималната обща стойност на билките, които могат да бъдат събрани в рамките на времевия лимит.\n\n    Примери:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "zh": "\n    计算在给定时间限制内可以采摘的药草的最大总价值。\n\n    该函数解决了0/1背包问题的一个变体，其目标是在不超过时间限制的情况下最大化采摘药草的总价值。每种药草最多只能采摘一次，并且有一个相关的时间成本和价值。\n\n    参数:\n    - T (int): 可用于采摘药草的总时间。\n    - M (int): 洞穴中不同药草的数量。\n    - herbs (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数，分别表示采摘药草所需的时间和药草的价值。\n\n    返回:\n    - int: 在时间限制内可以采摘的药草的最大总价值。\n\n    示例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "fr": "\n    Calculer la valeur totale maximale des herbes qui peuvent être cueillies dans un délai donné.\n\n    Cette fonction résout une variation du problème du sac à dos 0/1 où l'objectif est de maximiser\n    la valeur totale des herbes cueillies sans dépasser la limite de temps. Chaque herbe peut être cueillie\n    au plus une fois et a un coût en temps et une valeur associés.\n\n    Args:\n    - T (int): Le temps total disponible pour cueillir des herbes.\n    - M (int): Le nombre d'herbes différentes dans la grotte.\n    - herbs (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers\n      représentant le temps nécessaire pour cueillir l'herbe et la valeur de l'herbe, respectivement.\n\n    Returns:\n    - int: La valeur totale maximale des herbes qui peuvent être cueillies dans le délai imparti.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "de": "\n    Berechne den maximalen Gesamtwert der Kräuter, die innerhalb eines vorgegebenen Zeitlimits gesammelt werden können.\n\n    Diese Funktion löst eine Variation des 0/1-Rucksackproblems, bei dem das Ziel darin besteht, den Gesamtwert der gesammelten Kräuter zu maximieren, ohne das Zeitlimit zu überschreiten. Jedes Kraut kann höchstens einmal gesammelt werden und hat eine zugehörige Zeitkosten und einen Wert.\n\n    Args:\n    - T (int): Die insgesamt verfügbare Zeit zum Sammeln der Kräuter.\n    - M (int): Die Anzahl der verschiedenen Kräuter in der Höhle.\n    - herbs (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält, die die zum Sammeln des Krauts benötigte Zeit und den Wert des Krauts darstellen.\n\n    Returns:\n    - int: Der maximale Gesamtwert der Kräuter, die innerhalb des Zeitlimits gesammelt werden können.\n\n    Beispiele:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "ha": "\n    Lissafa jimillar ƙimar ganyayyaki mafi girma da za a iya tattara cikin iyakar lokaci da aka bayar.\n\n    Wannan aikin yana warware wani bambanci na matsalar jakar 0/1 inda burin shine a haɓaka\n    jimillar ƙimar ganyayyaki da aka tattara ba tare da wuce iyakar lokaci ba. Kowace ganye za a iya tattara\n    sau ɗaya kawai kuma tana da alaƙa da farashin lokaci da ƙima.\n\n    Args:\n    - T (int): Jimillar lokacin da ake da shi don tattara ganyayyaki.\n    - M (int): Yawan nau'ikan ganyayyaki daban-daban a cikin kogon.\n    - herbs (List[Tuple[int, int]]): Jerin tuples, inda kowane tuple ya ƙunshi lambobi biyu\n      suna wakiltar lokacin da ake buƙata don tattara ganyen da ƙimar ganyen, bi da bi.\n\n    Returns:\n    - int: Jimillar ƙimar ganyayyaki mafi girma da za a iya tattara cikin iyakar lokaci.\n\n    Misalai:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "hi": "\n    दिए गए समय सीमा के भीतर जितनी अधिकतम कुल मूल्य की जड़ी-बूटियाँ चुनी जा सकती हैं, उसकी गणना करें।\n\n    यह फ़ंक्शन 0/1 नॅपसैक समस्या के एक भिन्न रूप को हल करता है, जहाँ लक्ष्य है कि समय सीमा को पार किए बिना चुनी गई जड़ी-बूटियों के कुल मूल्य को अधिकतम करना। प्रत्येक जड़ी-बूटी को अधिकतम एक बार चुना जा सकता है और इसके साथ जुड़ी समय लागत और मूल्य होता है।\n\n    Args:\n    - T (int): जड़ी-बूटियाँ चुनने के लिए उपलब्ध कुल समय।\n    - M (int): गुफा में विभिन्न जड़ी-बूटियों की संख्या।\n    - herbs (List[Tuple[int, int]]): एक सूची जिसमें प्रत्येक ट्यूपल में दो पूर्णांक होते हैं जो क्रमशः जड़ी-बूटी चुनने के लिए आवश्यक समय और जड़ी-बूटी का मूल्य दर्शाते हैं।\n\n    Returns:\n    - int: दिए गए समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "hu": "\n    Számítsa ki a maximális összértéket a gyógynövényeknek, amelyeket egy adott időkorláton belül lehet összegyűjteni.\n\n    Ez a függvény a 0/1 hátizsák probléma egy változatát oldja meg, ahol a cél az összegyűjtött gyógynövények összértékének maximalizálása anélkül, hogy túllépnénk az időkorlátot. Minden gyógynövényt legfeljebb egyszer lehet összegyűjteni, és mindegyikhez egy időráfordítás és egy érték társul.\n\n    Paraméterek:\n    - T (int): Az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\n    - M (int): A barlangban található különböző gyógynövények száma.\n    - herbs (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy-egy tuple, amely két egész számot tartalmaz, amelyek a gyógynövény összegyűjtéséhez szükséges időt és a gyógynövény értékét képviselik.\n\n    Visszatérési érték:\n    - int: A maximális összérték a gyógynövényeknek, amelyeket az időkorláton belül lehet összegyűjteni.\n\n    Példák:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "es": "    Calcular el valor total máximo de hierbas que se pueden recoger dentro de un límite de tiempo dado.\n\n    Esta función resuelve una variación del problema de la mochila 0/1 donde el objetivo es maximizar\n    el valor total de las hierbas recogidas sin exceder el límite de tiempo. Cada hierba se puede recoger\n    como máximo una vez y tiene un costo de tiempo y un valor asociados.\n\n    Argumentos:\n    - T (int): El tiempo total disponible para recoger hierbas.\n    - M (int): El número de diferentes hierbas en la cueva.\n    - herbs (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros\n      que representan el tiempo requerido para recoger la hierba y el valor de la hierba, respectivamente.\n\n    Devuelve:\n    - int: El valor total máximo de hierbas que se pueden recoger dentro del límite de tiempo.\n\n    Ejemplos:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "arb": "    حساب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n\n    تحل هذه الدالة نوعًا من مشكلة حقيبة الظهر 0/1 حيث يكون الهدف هو تعظيم\n    القيمة الإجمالية للأعشاب المجمعة دون تجاوز الحد الزمني. يمكن جمع كل عشب\n    مرة واحدة على الأكثر وله تكلفة زمنية وقيمة مرتبطة به.\n\n    يعيدالحجج:\n    - T (int): إجمالي الوقت المتاح لجمع الأعشاب.\n    - M (int): عدد الأعشاب المختلفة في الكهف.\n    - herbs (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين\n      يمثلان الوقت المطلوب لجمع العشب وقيمة العشب، على التوالي.\n\n    يعيد:\n    - int: القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الحد الزمني.\n\n    امثله:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "sw": "    Kuhesabu thamani ya juu kabisa ya mimea ambayo inaweza kuvunwa ndani ya kikomo cha muda kilichopewa.\n\n    Kazi hii inatatua tofauti ya tatizo la 0/1 knapsack ambapo lengo ni kuongeza\n    thamani ya jumla ya mimea iliyovunwa bila kuzidi kikomo cha muda. Kila mmea unaweza kuvunwa\n    mara moja tu na una gharama ya muda na thamani inayohusiana.\n\n    Hoja:\n    - T (int): Jumla ya muda unaopatikana kwa kuvuna mimea.\n    - M (int): Idadi ya mimea tofauti kwenye pango.\n    - herbs (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili\n      zinazowakilisha muda unaohitajika kuvuna mmea na thamani ya mmea, mtawalia.\n\n    Inarejesha:\n    - int: Thamani ya juu kabisa ya mimea ambayo inaweza kuvunwa ndani ya kikomo cha muda.\n\n    Mifano:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "tr": "    Belirli bir zaman sınırı içinde toplanabilecek maksimum toplam ot değerini hesaplayın.\n\n    Bu fonksiyon, zaman sınırını aşmadan toplanan otların toplam değerini en üst düzeye çıkarmayı\n    amaçlayan 0/1 sırt çantası probleminin bir varyasyonunu çözer. Her ot en fazla bir kez\n    toplanabilir ve buna bağlı bir zaman maliyeti ve değeri vardır.\n\n    Argümanlar:\n    - T (int): Ot toplamak için mevcut toplam zaman.\n    - M (int): Mağaradaki farklı otların sayısı.\n    - herbs (List[Tuple[int, int]]): Her bir demetin, otu toplamak için gereken zamanı ve\n      otun değerini temsil eden iki tam sayı içeren bir demet listesi.\n\n    Döndürür:\n    - int: Zaman sınırı içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "vi": "    Tính tổng giá trị tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian cho phép.\n\n    Hàm này giải quyết một biến thể của bài toán cái túi 0/1, trong đó mục tiêu là tối đa hóa\n    tổng giá trị của các loại thảo mộc được hái mà không vượt quá giới hạn thời gian. Mỗi loại thảo mộc có thể được hái\n    nhiều nhất một lần và có chi phí thời gian và giá trị liên quan.\n\n    Tham số:\n    - T (int): Tổng thời gian có sẵn để hái thảo mộc.\n    - M (int): Số lượng các loại thảo mộc khác nhau trong hang động.\n    - herbs (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên\n      đại diện cho thời gian cần thiết để hái thảo mộc và giá trị của thảo mộc đó, tương ứng.\n\n    Trả về:\n    - int: Tổng giá trị tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian.\n\n    Ví dụ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "id": "Menghitung nilai total maksimum dari ramuan yang dapat dipetik dalam batas waktu yang diberikan.\n\nFungsi ini menyelesaikan variasi dari masalah knapsack 0/1 di mana tujuannya adalah untuk memaksimalkan nilai total ramuan yang dipetik tanpa melebihi batas waktu. Setiap ramuan dapat dipetik paling banyak sekali dan memiliki biaya waktu serta nilai yang terkait.\n\nArgs:\n- T (int): Total waktu yang tersedia untuk memetik ramuan.\n- M (int): Jumlah jenis ramuan yang berbeda di dalam gua.\n- herbs (List[Tuple[int, int]]): Daftar tuple, di mana setiap tuple berisi dua bilangan bulat yang mewakili waktu yang diperlukan untuk memetik ramuan dan nilai ramuan tersebut, masing-masing.\n\nReturns:\n- int: Nilai total maksimum dari ramuan yang dapat dipetik dalam batas waktu.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "ja": "    与えられた時間制限内で摘むことができるハーブの最大合計価値を計算します。\n\n    この関数は、0/1ナップサック問題の変種を解決します。ここでの目標は、時間制限を超えずに\n    摘むハーブの合計価値を最大化することです。各ハーブは最大で一度だけ摘むことができ、\n    関連する時間コストと価値があります。\n\n    引数:\n    - T (int): ハーブを摘むために利用可能な総時間。\n    - M (int): 洞窟内の異なるハーブの数。\n    - herbs (List[Tuple[int, int]]): 各タプルがハーブを摘むのに必要な時間と\n      ハーブの価値を表す2つの整数を含むタプルのリスト。\n\n    戻り値:\n    - int: 時間制限内で摘むことができるハーブの最大合計価値。\n\n    例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "ko": "    주어진 시간 제한 내에서 채집할 수 있는 약초의 최대 총 가치를 계산합니다.\n\n    이 함수는 0/1 배낭 문제의 변형을 해결하며, 목표는 시간 제한을 초과하지 않고\n    채집한 약초의 총 가치를 최대화하는 것입니다. 각 약초는 최대 한 번만 채집할 수 있으며,\n    관련된 시간 비용과 가치가 있습니다.\n\n    인수:\n    - T (int): 약초를 채집할 수 있는 총 시간.\n    - M (int): 동굴 내의 다양한 약초의 수.\n    - herbs (List[Tuple[int, int]]): 각 튜플이 약초를 채집하는 데 필요한 시간과\n      약초의 가치를 각각 나타내는 두 개의 정수를 포함하는 튜플의 리스트.\n\n    반환값:\n    - int: 시간 제한 내에서 채집할 수 있는 약초의 최대 총 가치.\n\n    예제:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "ml": "    നൽകിയ സമയപരിധിക്കുള്ളിൽ എത്രയും കൂടുതൽ മൂല്യമുള്ള ഔഷധങ്ങൾ എടുക്കാൻ കഴിയുമെന്ന് കണക്കാക്കുക.\n\n    ഈ ഫംഗ്ഷൻ 0/1 ക്നാപ്സാക്ക് പ്രശ്നത്തിന്റെ ഒരു വ്യത്യാസം പരിഹരിക്കുന്നു, ഇവിടെ ലക്ഷ്യം\n    സമയപരിധി ലംഘിക്കാതെ എടുക്കുന്ന ഔഷധങ്ങളുടെ ആകെ മൂല്യം പരമാവധി ആക്കുകയാണ്. ഓരോ ഔഷധവും\n    പരമാവധി ഒരിക്കൽ മാത്രമേ എടുക്കാൻ കഴിയൂ, കൂടാതെ അതിനൊപ്പം ബന്ധപ്പെട്ട സമയ ചെലവും മൂല്യവും ഉണ്ട്.\n\n    Arguments:\n    - T (int): ഔഷധങ്ങൾ എടുക്കാൻ ലഭ്യമായ മൊത്തം സമയം.\n    - M (int): ഗുഹയിൽ ഉള്ള വ്യത്യസ്ത ഔഷധങ്ങളുടെ എണ്ണം.\n    - herbs (List[Tuple[int, int]]): ഓരോ ട്യൂപ്പിളും ഔഷധം എടുക്കാൻ ആവശ്യമായ സമയം\n      കൂടാതെ ഔഷധത്തിന്റെ മൂല്യം പ്രതിനിധീകരിക്കുന്ന രണ്ട് പൂർണ്ണസംഖ്യകൾ അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക.\n\n    Returns:\n    - int: സമയപരിധിക്കുള്ളിൽ എടുക്കാൻ കഴിയുന്ന ഔഷധങ്ങളുടെ പരമാവധി ആകെ മൂല്യം.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10", "fa": "محاسبه حداکثر ارزش کل گیاهانی که می‌توان در یک محدودیت زمانی معین چید.\n\nاین تابع یک نوع تغییر یافته از مسئله کوله‌پشتی 0/1 را حل می‌کند که هدف آن حداکثر کردن ارزش کل گیاهان چیده شده بدون تجاوز از محدودیت زمانی است. هر گیاه می‌تواند حداکثر یک بار چیده شود و دارای هزینه زمانی و ارزش مرتبط است.\n\nArgs:\n- T (int): کل زمان موجود برای چیدن گیاهان.\n- M (int): تعداد گیاهان مختلف در غار.\n- herbs (List[Tuple[int, int]]): لیستی از زوج‌ها، که هر زوج شامل دو عدد صحیح است که به ترتیب زمان مورد نیاز برای چیدن گیاه و ارزش گیاه را نشان می‌دهند.\n\nReturns:\n- int: حداکثر ارزش کل گیاهانی که می‌توان در محدودیت زمانی چید.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10"}}
{"task_id": "Python/38", "prompt": {"en": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "sq": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Llogarit hapësirën minimale të mbetur në një kuti pasi të përpiqesh të vendosësh një numër artikujsh me vëllime të dhëna.\n    \n    Kjo funksion përdor një qasje të programimit dinamik për të përcaktuar vëllimin maksimal që mund të zërë\n    në kuti nga çdo nënbashkësi e artikujve të dhënë. Më pas kthen diferencën midis kapacitetit total të kutisë\n    dhe këtij vëllimi maksimal të zënë, që është hapësira minimale e mbetur.\n\n    Argumentet:\n    - V (int): Kapaciteti total i kutisë.\n    - n (int): Numri i artikujve që do të konsiderohen për paketim në kuti.\n    - volumes (List[int]): Një listë e vëllimeve të n artikujve.\n\n    Kthen:\n    - int: Hapësira minimale e mbetur në kuti pas vendosjes së artikujve.\n\n    Shembuj:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "hy": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Հաշվարկել արկղում մնացած նվազագույն տարածքը այն բանից հետո, երբ փորձել ենք տեղավորել որոշակի ծավալներով իրեր։\n\n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար առավելագույն ծավալը, որը կարող է զբաղեցվել\n    արկղում տրված իրերի ցանկացած ենթաբազմությամբ։ Այնուհետև վերադարձնում է արկղի ընդհանուր տարողության և այս առավելագույն զբաղեցված ծավալի տարբերությունը, որը նվազագույն մնացած տարածքն է։\n\n    Պարամետրեր:\n    - V (int): Արկղի ընդհանուր տարողությունը։\n    - n (int): Իրերի քանակը, որոնք պետք է հաշվի առնել արկղում տեղավորելու համար։\n    - volumes (List[int]): n իրերի ծավալների ցանկը։\n\n    Վերադարձնում է:\n    - int: Արկղում մնացած նվազագույն տարածքը իրերը տեղավորելուց հետո։\n\n    Օրինակներ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "bn": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    প্রদত্ত ভলিউম সহ কিছু আইটেম ফিট করার চেষ্টা করার পরে একটি বাক্সে ন্যূনতম অবশিষ্ট স্থান গণনা করুন।\n    \n    এই ফাংশনটি একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে নির্ধারণ করে যে প্রদত্ত আইটেমগুলির যেকোনো উপসেট দ্বারা বাক্সে সর্বাধিক কতটুকু ভলিউম দখল করা যেতে পারে।\n    এরপর এটি বাক্সের মোট ক্ষমতা এবং এই সর্বাধিক দখলকৃত ভলিউমের মধ্যে পার্থক্য প্রদান করে, যা ন্যূনতম অবশিষ্ট স্থান।\n\n    আর্গুমেন্টসমূহ:\n    - V (int): বাক্সের মোট ক্ষমতা।\n    - n (int): বাক্সে প্যাক করার জন্য বিবেচনা করা আইটেমের সংখ্যা।\n    - volumes (List[int]): n আইটেমের ভলিউমের একটি তালিকা।\n\n    রিটার্নস:\n    - int: আইটেমগুলি ফিট করার পরে বাক্সে ন্যূনতম অবশিষ্ট স্থান।\n\n    উদাহরণ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "bg": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Изчисляване на минималното оставащо пространство в кутия след опит за поставяне на брой предмети с дадени обеми.\n    \n    Тази функция използва подход на динамично програмиране, за да определи максималния обем, който може да бъде зает\n    в кутията от всяко подмножество на дадените предмети. След това връща разликата между общия капацитет на кутията\n    и този максимално зает обем, което е минималното оставащо пространство.\n\n    Аргументи:\n    - V (int): Общият капацитет на кутията.\n    - n (int): Броят на предметите, които да се разгледат за опаковане в кутията.\n    - volumes (List[int]): Списък с обемите на n-те предмета.\n\n    Връща:\n    - int: Минималното оставащо пространство в кутията след поставяне на предметите.\n\n    Примери:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "zh": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    计算在尝试将给定体积的若干物品放入箱子后，箱子中剩余的最小空间。\n    \n    该函数使用动态规划方法来确定给定物品的任意子集可以占据的最大体积。\n    然后返回箱子总容量与该最大占用体积之间的差值，即最小剩余空间。\n\n    参数:\n    - V (int): 箱子的总容量。\n    - n (int): 要考虑放入箱子的物品数量。\n    - volumes (List[int]): n 个物品的体积列表。\n\n    返回:\n    - int: 将物品放入后箱子中剩余的最小空间。\n\n    示例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "fr": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculer l'espace restant minimum dans une boîte après avoir essayé de placer un certain nombre d'articles avec des volumes donnés.\n    \n    Cette fonction utilise une approche de programmation dynamique pour déterminer le volume maximum qui peut être occupé\n    dans la boîte par n'importe quel sous-ensemble des articles donnés. Elle retourne ensuite la différence entre la capacité totale de la boîte\n    et ce volume occupé maximum, qui est l'espace restant minimum.\n\n    Arguments:\n    - V (int): La capacité totale de la boîte.\n    - n (int): Le nombre d'articles à considérer pour le rangement dans la boîte.\n    - volumes (List[int]): Une liste des volumes des n articles.\n\n    Retourne:\n    - int: L'espace restant minimum dans la boîte après avoir placé les articles.\n\n    Exemples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "de": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Berechne den minimal verbleibenden Platz in einer Box, nachdem versucht wurde, eine Anzahl von Gegenständen mit gegebenen Volumina unterzubringen.\n    \n    Diese Funktion verwendet einen dynamischen Programmieransatz, um das maximale Volumen zu bestimmen, das durch eine beliebige Teilmenge der gegebenen Gegenstände in der Box belegt werden kann. Anschließend gibt sie die Differenz zwischen der Gesamtkapazität der Box und diesem maximal belegten Volumen zurück, was dem minimal verbleibenden Platz entspricht.\n\n    Argumente:\n    - V (int): Die Gesamtkapazität der Box.\n    - n (int): Die Anzahl der Gegenstände, die für das Verpacken in die Box in Betracht gezogen werden.\n    - volumes (List[int]): Eine Liste der Volumina der n Gegenstände.\n\n    Rückgabewert:\n    - int: Der minimal verbleibende Platz in der Box nach dem Unterbringen der Gegenstände.\n\n    Beispiele:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "ha": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Lissafa ƙaramin sarari da ya rage a cikin akwatin bayan ƙoƙarin sanya adadin abubuwa tare da ƙayyadaddun girma.\n\n    Wannan aikin yana amfani da hanyar shirye-shiryen motsi don ƙayyade mafi girman girman da za a iya mamaye\n    a cikin akwatin ta kowanne rukuni na abubuwan da aka bayar. Sannan yana mayar da bambanci tsakanin jimlar ƙarfin akwatin\n    da wannan mafi girman girman da aka mamaye, wanda shine ƙaramin sarari da ya rage.\n\n    Args:\n    - V (int): Jimlar ƙarfin akwatin.\n    - n (int): Adadin abubuwan da za a yi la'akari da su don shiryawa cikin akwatin.\n    - volumes (List[int]): Jerin girman abubuwan n.\n\n    Returns:\n    - int: Ƙaramin sarari da ya rage a cikin akwatin bayan shiryawa abubuwan.\n\n    Misalai:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "hi": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    दिए गए वॉल्यूम के साथ वस्तुओं की संख्या को फिट करने के बाद बॉक्स में बची हुई न्यूनतम जगह की गणना करें।\n    \n    यह फ़ंक्शन एक गतिशील प्रोग्रामिंग दृष्टिकोण का उपयोग करता है ताकि यह निर्धारित किया जा सके कि दिए गए वस्तुओं के किसी भी उपसमूह द्वारा बॉक्स में अधिकतम वॉल्यूम कितना भरा जा सकता है।\n    फिर यह बॉक्स की कुल क्षमता और इस अधिकतम भरे हुए वॉल्यूम के बीच का अंतर लौटाता है, जो कि बची हुई न्यूनतम जगह है।\n\n    तर्क:\n    - V (int): बॉक्स की कुल क्षमता।\n    - n (int): बॉक्स में पैक करने के लिए विचार की जाने वाली वस्तुओं की संख्या।\n    - volumes (List[int]): n वस्तुओं के वॉल्यूम की सूची।\n\n    रिटर्न:\n    - int: वस्तुओं को फिट करने के बाद बॉक्स में बची हुई न्यूनतम जगह।\n\n    उदाहरण:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "hu": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Számítsa ki a minimális fennmaradó helyet egy dobozban, miután megpróbált beilleszteni egy adott térfogatú tárgyakat.\n\n    Ez a függvény dinamikus programozási megközelítést alkalmaz annak meghatározására, hogy a megadott tárgyak bármely részhalmazával\n    mekkora maximális térfogat foglalható el a dobozban. Ezután visszaadja a doboz teljes kapacitása és a maximálisan elfoglalt térfogat\n    közötti különbséget, ami a minimális fennmaradó hely.\n\n    Paraméterek:\n    - V (int): A doboz teljes kapacitása.\n    - n (int): A figyelembe veendő tárgyak száma a dobozba való csomagoláshoz.\n    - volumes (List[int]): Az n tárgy térfogatainak listája.\n\n    Visszatér:\n    - int: A minimális fennmaradó hely a dobozban a tárgyak beillesztése után.\n\n    Példák:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "es": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calcular el espacio mínimo restante en una caja después de intentar encajar un número de artículos con volúmenes dados.\n    \n    Esta función utiliza un enfoque de programación dinámica para determinar el volumen máximo que se puede ocupar\n    en la caja por cualquier subconjunto de los artículos dados. Luego devuelve la diferencia entre la capacidad total de la caja\n    y este volumen máximo ocupado, que es el espacio mínimo restante.\n\n    Argumentos:\n    - V (int): La capacidad total de la caja.\n    - n (int): El número de artículos a considerar para empacar en la caja.\n    - volumes (List[int]): Una lista de los volúmenes de los n artículos.\n\n    Devuelve:\n    - int: El espacio mínimo restante en la caja después de encajar los artículos.\n\n    Ejemplos:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "arb": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    حساب الحد الأدنى للمساحة المتبقية في صندوق بعد محاولة وضع عدد من العناصر ذات الأحجام المعطاة.\n\n    تستخدم هذه الدالة نهج البرمجة الديناميكية لتحديد الحجم الأقصى الذي يمكن شغله في الصندوق بواسطة أي مجموعة فرعية من العناصر المعطاة. ثم تعيد الفرق بين السعة الإجمالية للصندوق وهذا الحجم المشغول الأقصى، وهو الحد الأدنى للمساحة المتبقية.\n\n    يعيدالحجج:\n    - V (int): السعة الإجمالية للصندوق.\n    - n (int): عدد العناصر التي يجب أخذها بعين الاعتبار لوضعها في الصندوق.\n    - volumes (List[int]): قائمة بأحجام العناصر n.\n\n    يعيد:\n    - int: الحد الأدنى للمساحة المتبقية في الصندوق بعد وضع العناصر.\n\n    امثله:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "sw": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Kuhesabu nafasi ndogo inayobaki kwenye sanduku baada ya kujaribu kutoshea idadi ya vitu vilivyo na ujazo uliotolewa.\n    \n    Kazi hii inatumia mbinu ya programu ya nguvu ili kubaini ujazo wa juu zaidi ambao unaweza kujazwa\n    kwenye sanduku na seti yoyote ndogo ya vitu vilivyopewa. Kisha inarejesha tofauti kati ya uwezo wa jumla wa sanduku\n    na huu ujazo wa juu uliotumika, ambayo ndiyo nafasi ndogo inayobaki.\n\n    Hoja:\n    - V (int): Uwezo wa jumla wa sanduku.\n    - n (int): Idadi ya vitu vya kuzingatia kwa kufunga kwenye sanduku.\n    - volumes (List[int]): Orodha ya ujazo wa vitu n.\n\n    Inarejesha:\n    - int: Nafasi ndogo inayobaki kwenye sanduku baada ya kutoshea vitu.\n\n    Mifano:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "tr": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Verilen hacimlere sahip bir dizi öğeyi sığdırmaya çalıştıktan sonra bir kutuda kalan minimum alanı hesaplayın.\n    \n    Bu fonksiyon, verilen öğelerin herhangi bir alt kümesi tarafından kutuda işgal edilebilecek maksimum hacmi belirlemek için dinamik programlama yaklaşımı kullanır. Daha sonra kutunun toplam kapasitesi ile bu maksimum işgal edilen hacim arasındaki farkı döndürür, bu da kalan minimum alandır.\n\n    Argümanlar:\n    - V (int): Kutunun toplam kapasitesi.\n    - n (int): Kutuda paketlemeyi düşünmek için öğe sayısı.\n    - volumes (List[int]): n öğesinin hacimlerinin bir listesi.\n\n    Döndürür:\n    - int: Öğeleri yerleştirdikten sonra kutuda kalan minimum alan.\n\n    Örnekler:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "vi": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Tính toán không gian còn lại tối thiểu trong một hộp sau khi cố gắng đặt một số lượng đồ vật với các thể tích cho trước.\n\n    Hàm này sử dụng phương pháp lập trình động để xác định thể tích tối đa có thể được chiếm trong hộp\n    bởi bất kỳ tập hợp con nào của các đồ vật cho trước. Sau đó, nó trả về sự khác biệt giữa tổng dung tích của hộp\n    và thể tích chiếm tối đa này, đó là không gian còn lại tối thiểu.\n\n    Tham số:\n    - V (int): Tổng dung tích của hộp.\n    - n (int): Số lượng đồ vật cần xem xét để đóng gói vào hộp.\n    - volumes (List[int]): Danh sách thể tích của n đồ vật.\n\n    Trả về:\n    - int: Không gian còn lại tối thiểu trong hộp sau khi đặt các đồ vật.\n\n    Ví dụ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "id": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Menghitung ruang tersisa minimum dalam sebuah kotak setelah mencoba memasukkan sejumlah barang dengan volume tertentu.\n    \n    Fungsi ini menggunakan pendekatan pemrograman dinamis untuk menentukan volume maksimum yang dapat ditempati\n    dalam kotak oleh setiap subset dari barang-barang yang diberikan. Kemudian mengembalikan selisih antara kapasitas total kotak\n    dan volume maksimum yang ditempati ini, yang merupakan ruang tersisa minimum.\n\n    Argumen:\n    - V (int): Kapasitas total kotak.\n    - n (int): Jumlah barang yang dipertimbangkan untuk dimasukkan ke dalam kotak.\n    - volumes (List[int]): Daftar volume dari n barang.\n\n    Mengembalikan:\n    - int: Ruang tersisa minimum dalam kotak setelah memasukkan barang-barang.\n\n    Contoh:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "ja": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    与えられた体積を持つアイテムを箱に収めようとした後の最小残りスペースを計算します。\n    \n    この関数は動的計画法を使用して、与えられたアイテムの任意の部分集合によって箱に占められる最大体積を決定します。\n    その後、箱の総容量とこの最大占有体積の差を返します。これが最小残りスペースです。\n\n    引数:\n    - V (int): 箱の総容量。\n    - n (int): 箱に詰めることを考慮するアイテムの数。\n    - volumes (List[int]): n個のアイテムの体積のリスト。\n\n    戻り値:\n    - int: アイテムを収めた後の箱の最小残りスペース。\n\n    例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "ko": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    주어진 부피를 가진 여러 아이템을 상자에 맞추려고 시도한 후 남은 최소 공간을 계산합니다.\n    \n    이 함수는 주어진 아이템의 부분 집합에 의해 상자에서 차지할 수 있는 최대 부피를 결정하기 위해 동적 프로그래밍 접근법을 사용합니다. 그런 다음 상자의 총 용량과 이 최대 점유 부피의 차이를 반환하며, 이는 남은 최소 공간입니다.\n\n    Args:\n    - V (int): 상자의 총 용량.\n    - n (int): 상자에 포장할 아이템의 수.\n    - volumes (List[int]): n개의 아이템의 부피 목록.\n\n    Returns:\n    - int: 아이템을 맞춘 후 상자에 남은 최소 공간.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "ml": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    നൽകിയ വോളിയങ്ങളുള്ള ഒരു എണ്ണം വസ്തുക്കൾ ഒതുക്കാൻ ശ്രമിച്ച ശേഷം ഒരു ബോക്സിലെ കുറഞ്ഞ ശേഷിക്കുന്ന സ്ഥലം കണക്കാക്കുക.\n    \n    ഈ ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് സമീപനം ഉപയോഗിച്ച് നൽകിയ വസ്തുക്കളുടെ ഏതെങ്കിലും ഉപസമൂഹം ബോക്സിൽ കൈവശം വയ്ക്കുന്ന പരമാവധി വോളിയം നിർണ്ണയിക്കുന്നു. \n    തുടർന്ന് ബോക്സിന്റെ മൊത്തം ശേഷിയും ഈ പരമാവധി കൈവശം വോളിയവും തമ്മിലുള്ള വ്യത്യാസം തിരികെ നൽകുന്നു, \n    ഇത് കുറഞ്ഞ ശേഷിക്കുന്ന സ്ഥലം ആണ്.\n\n    Args:\n    - V (int): ബോക്സിന്റെ മൊത്തം ശേഷി.\n    - n (int): ബോക്സിൽ പായ്ക്ക് ചെയ്യാൻ പരിഗണിക്കേണ്ട വസ്തുക്കളുടെ എണ്ണം.\n    - volumes (List[int]): n വസ്തുക്കളുടെ വോളിയങ്ങളുടെ പട്ടിക.\n\n    Returns:\n    - int: വസ്തുക്കൾ ഒതുക്കിയ ശേഷം ബോക്സിലെ കുറഞ്ഞ ശേഷിക്കുന്ന സ്ഥലം.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"", "fa": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    حداقل فضای باقی‌مانده در یک جعبه را پس از تلاش برای جا دادن تعدادی آیتم با حجم‌های داده شده محاسبه کنید.\n    \n    این تابع از یک روش برنامه‌ریزی پویا برای تعیین حداکثر حجمی که می‌تواند توسط هر زیرمجموعه‌ای از آیتم‌های داده شده\n    در جعبه اشغال شود، استفاده می‌کند. سپس تفاوت بین ظرفیت کل جعبه و این حداکثر حجم اشغال شده را برمی‌گرداند، که همان\n    حداقل فضای باقی‌مانده است.\n\n    آرگومان‌ها:\n    - V (int): ظرفیت کل جعبه.\n    - n (int): تعداد آیتم‌هایی که باید برای بسته‌بندی در جعبه در نظر گرفته شوند.\n    - volumes (List[int]): لیستی از حجم‌های n آیتم.\n\n    بازگشت:\n    - int: حداقل فضای باقی‌مانده در جعبه پس از جا دادن آیتم‌ها.\n\n    مثال‌ها:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\""}, "canonical_solution": "    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]", "instruction": {"en": "Write a python function 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' to solve the following problem:\n\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    ", "sq": "Shkruani një funksion python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni hapësirën minimale të mbetur në një kuti pasi të përpiqeni të vendosni një numër artikujsh me vëllime të dhëna.\n    \n    Ky funksion përdor një qasje të programimit dinamik për të përcaktuar vëllimin maksimal që mund të zërë\n    në kuti nga çdo nëngrup i artikujve të dhënë. Pastaj kthen diferencën midis kapacitetit total të kutisë\n    dhe këtij vëllimi maksimal të zënë, i cili është hapësira minimale e mbetur.\n\n    Argumentet:\n    - V (int): Kapaciteti total i kutisë.\n    - n (int): Numri i artikujve që do të konsiderohen për paketim në kuti.\n    - volumes (List[int]): Një listë e vëllimeve të n artikujve.\n\n    Kthen:\n    - int: Hapësira minimale e mbetur në kuti pas vendosjes së artikujve.\n\n    Shembuj:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "hy": "Պայթոն ֆունկցիա 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել տուփի մեջ մնացած նվազագույն տարածքը, երբ փորձվում է տեղավորել որոշակի ծավալներով տրված իրեր:\n    \n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար առավելագույն ծավալը,\n    որը կարող է զբաղեցվել տուփի մեջ տրված իրերի ցանկացած ենթաբազմությամբ: Այնուհետև վերադարձնում է\n    տուփի ընդհանուր տարողության և այս առավելագույն զբաղեցրած ծավալի տարբերությունը, որը նվազագույն մնացած տարածքն է:\n\n    Արգումենտներ:\n    - V (int): Տուփի ընդհանուր տարողությունը:\n    - n (int): Տուփի մեջ փաթեթավորելու համար նախատեսված իրերի քանակը:\n    - volumes (List[int]): n իրերի ծավալների ցուցակը:\n\n    Վերադարձնում է:\n    - int: Տուփի մեջ մնացած նվազագույն տարածքը իրերը տեղավորելուց հետո:\n\n    Օրինակներ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "bn": "একটি পাইথন ফাংশন 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    প্রদত্ত ভলিউম সহ কিছু আইটেম ফিট করার চেষ্টা করার পর একটি বাক্সে ন্যূনতম অবশিষ্ট স্থান গণনা করুন।\n    \n    এই ফাংশনটি একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে নির্ধারণ করে যে প্রদত্ত আইটেমগুলির যে কোনও উপসেট দ্বারা বাক্সে সর্বাধিক কত ভলিউম দখল করা যেতে পারে। এটি তারপর বাক্সের মোট ক্ষমতা এবং এই সর্বাধিক দখলকৃত ভলিউমের মধ্যে পার্থক্যটি ফেরত দেয়, যা ন্যূনতম অবশিষ্ট স্থান।\n\n    আর্গস:\n    - V (int): বাক্সের মোট ক্ষমতা।\n    - n (int): বাক্সে প্যাক করার জন্য বিবেচনা করা আইটেমের সংখ্যা।\n    - volumes (List[int]): n আইটেমের ভলিউমের একটি তালিকা।\n\n    রিটার্নস:\n    - int: আইটেম ফিট করার পর বাক্সে ন্যূনতম অবশিষ্ট স্থান।\n\n    উদাহরণ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "bg": "Напишете Python функция 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:', за да решите следния проблем:\n\n    Изчислете минималното оставащо пространство в кутия, след като се опитате да поставите определен брой предмети с дадени обеми.\n    \n    Тази функция използва подход на динамично програмиране, за да определи максималния обем, който може да бъде зает\n    в кутията от която и да е подмножество на дадените предмети. След това връща разликата между общия капацитет на кутията\n    и този максимален зает обем, което е минималното оставащо пространство.\n\n    Аргументи:\n    - V (int): Общият капацитет на кутията.\n    - n (int): Броят на предметите, които да се разгледат за опаковане в кутията.\n    - volumes (List[int]): Списък с обемите на n-те предмета.\n\n    Връща:\n    - int: Минималното оставащо пространство в кутията след поставянето на предметите.\n\n    Примери:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "zh": "编写一个 Python 函数 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' 来解决以下问题：\n\n    计算在尝试将给定体积的若干物品放入箱子后，箱子中剩余的最小空间。\n    \n    此函数使用动态规划方法来确定给定物品的任意子集在箱子中可以占据的最大体积。\n    然后返回箱子的总容量与此最大占用体积之间的差值，即最小剩余空间。\n\n    参数:\n    - V (int): 箱子的总容量。\n    - n (int): 考虑放入箱子的物品数量。\n    - volumes (List[int]): n 个物品的体积列表。\n\n    返回:\n    - int: 在放入物品后箱子中剩余的最小空间。\n\n    示例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "fr": "Écrivez une fonction python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' pour résoudre le problème suivant :\n\n    Calculer l'espace restant minimum dans une boîte après avoir essayé d'y placer un certain nombre d'articles avec des volumes donnés.\n    \n    Cette fonction utilise une approche de programmation dynamique pour déterminer le volume maximum qui peut être occupé\n    dans la boîte par n'importe quel sous-ensemble des articles donnés. Elle retourne ensuite la différence entre la capacité totale de la boîte\n    et ce volume maximum occupé, qui est l'espace restant minimum.\n\n    Args:\n    - V (int): La capacité totale de la boîte.\n    - n (int): Le nombre d'articles à considérer pour le rangement dans la boîte.\n    - volumes (List[int]): Une liste des volumes des n articles.\n\n    Returns:\n    - int: L'espace restant minimum dans la boîte après avoir placé les articles.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "de": "Schreiben Sie eine Python-Funktion 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie den minimal verbleibenden Raum in einer Box, nachdem versucht wurde, eine Anzahl von Gegenständen mit gegebenen Volumen unterzubringen.\n    \n    Diese Funktion verwendet einen dynamischen Programmierungsansatz, um das maximale Volumen zu bestimmen, das durch eine beliebige Teilmenge der gegebenen Gegenstände in der Box belegt werden kann. Anschließend gibt sie die Differenz zwischen der Gesamtkapazität der Box und diesem maximal belegten Volumen zurück, was den minimal verbleibenden Raum darstellt.\n\n    Argumente:\n    - V (int): Die Gesamtkapazität der Box.\n    - n (int): Die Anzahl der Gegenstände, die für das Packen in die Box in Betracht gezogen werden.\n    - volumes (List[int]): Eine Liste der Volumen der n Gegenstände.\n\n    Rückgabewert:\n    - int: Der minimal verbleibende Raum in der Box nach dem Einpacken der Gegenstände.\n\n    Beispiele:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "ha": "Rubuta wani aikin python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa mafi ƙarancin sarari da ya rage a cikin akwati bayan ƙoƙarin sanya adadin abubuwa tare da ƙayyadadden girma.\n\n    Wannan aikin yana amfani da hanyar shirye-shiryen motsi don tantance mafi girman girma da za a iya mamaye\n    a cikin akwatin ta kowanne rukuni na abubuwan da aka bayar. Sannan yana mayar da bambanci tsakanin jimlar ƙarfin akwatin\n    da wannan mafi girman girman da aka mamaye, wanda shine mafi ƙarancin sarari da ya rage.\n\n    Args:\n    - V (int): Jimlar ƙarfin akwatin.\n    - n (int): Yawan abubuwan da za a yi la'akari da su don shiryawa cikin akwatin.\n    - volumes (List[int]): Jerin girman abubuwan n.\n\n    Returns:\n    - int: Mafi ƙarancin sarari da ya rage a cikin akwatin bayan sanya abubuwan.\n\n    Misalai:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "hi": "एक पायथन फ़ंक्शन 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए वॉल्यूम के साथ कई वस्तुओं को फिट करने की कोशिश के बाद बॉक्स में न्यूनतम शेष स्थान की गणना करें।\n    \n    यह फ़ंक्शन दिए गए वस्तुओं के किसी भी उपसमुच्चय द्वारा बॉक्स में कब्जा किए जा सकने वाले अधिकतम वॉल्यूम को निर्धारित करने के लिए एक गतिशील प्रोग्रामिंग दृष्टिकोण का उपयोग करता है। फिर यह बॉक्स की कुल क्षमता और इस अधिकतम कब्जा किए गए वॉल्यूम के बीच का अंतर लौटाता है, जो न्यूनतम शेष स्थान है।\n\n    तर्क:\n    - V (int): बॉक्स की कुल क्षमता।\n    - n (int): बॉक्स में पैकिंग के लिए विचार करने वाली वस्तुओं की संख्या।\n    - volumes (List[int]): n वस्तुओं के वॉल्यूम की सूची।\n\n    लौटाता है:\n    - int: वस्तुओं को फिट करने के बाद बॉक्स में न्यूनतम शेष स्थान।\n\n    उदाहरण:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "hu": "Írj egy python függvényt 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' a következő probléma megoldására:\n\n    Számítsd ki a minimális fennmaradó helyet egy dobozban, miután megpróbáltad elhelyezni a megadott térfogatú tárgyakat.\n    \n    Ez a függvény dinamikus programozási megközelítést alkalmaz annak meghatározására, hogy a megadott tárgyak bármely részhalmaza\n    által a dobozban elfoglalt maximális térfogat mekkora lehet. Ezután visszaadja a doboz teljes kapacitása és \n    az elfoglalt maximális térfogat közötti különbséget, ami a minimális fennmaradó hely.\n\n    Paraméterek:\n    - V (int): A doboz teljes kapacitása.\n    - n (int): A tárgyak száma, amelyeket figyelembe kell venni a dobozba csomagoláskor.\n    - volumes (List[int]): Az n tárgy térfogatainak listája.\n\n    Visszatérési érték:\n    - int: A minimális fennmaradó hely a dobozban a tárgyak elhelyezése után.\n\n    Példák:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "es": "Escribe una función de Python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' para resolver el siguiente problema:\n\n    Calcular el espacio mínimo restante en una caja después de intentar encajar un número de artículos con volúmenes dados.\n    \n    Esta función utiliza un enfoque de programación dinámica para determinar el volumen máximo que puede ser ocupado\n    en la caja por cualquier subconjunto de los artículos dados. Luego devuelve la diferencia entre la capacidad total de la caja\n    y este volumen máximo ocupado, que es el espacio mínimo restante.\n\n    Argumentos:\n    - V (int): La capacidad total de la caja.\n    - n (int): El número de artículos a considerar para empacar en la caja.\n    - volumes (List[int]): Una lista de los volúmenes de los n artículos.\n\n    Devuelve:\n    - int: El espacio mínimo restante en la caja después de encajar los artículos.\n\n    Ejemplos:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "arb": "اكتب دالة بايثون 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' لحل المشكلة التالية:\n\n    احسب الحد الأدنى للمساحة المتبقية في صندوق بعد محاولة وضع عدد من العناصر ذات الأحجام المعطاة.\n\n    تستخدم هذه الدالة نهج البرمجة الديناميكية لتحديد الحد الأقصى للحجم الذي يمكن شغله\n    في الصندوق بواسطة أي مجموعة فرعية من العناصر المعطاة. ثم تعيد الفرق بين السعة الكلية للصندوق\n    وهذا الحجم المشغول الأقصى، وهو الحد الأدنى للمساحة المتبقية.\n\n    الوسائط:\n    - V (int): السعة الكلية للصندوق.\n    - n (int): عدد العناصر المراد النظر فيها للتعبئة في الصندوق.\n    - volumes (List[int]): قائمة بأحجام العناصر n.\n\n    يعيد:\n    - int: الحد الأدنى للمساحة المتبقية في الصندوق بعد وضع العناصر.\n\n    أمثلة:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "sw": "Andika kazi ya python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu nafasi ndogo zaidi iliyobaki kwenye sanduku baada ya kujaribu kutoshea idadi ya vitu vilivyo na ujazo uliotolewa.\n    \n    Kazi hii inatumia mbinu ya programu ya nguvu ili kubaini ujazo wa juu zaidi ambao unaweza kujazwa\n    kwenye sanduku na seti yoyote ndogo ya vitu vilivyotolewa. Kisha inarudisha tofauti kati ya uwezo wa jumla wa sanduku\n    na ujazo huu wa juu ulioshikiliwa, ambayo ni nafasi ndogo zaidi iliyobaki.\n\n    Hoja:\n    - V (int): Uwezo wa jumla wa sanduku.\n    - n (int): Idadi ya vitu vya kuzingatia kwa kufunga kwenye sanduku.\n    - volumes (List[int]): Orodha ya ujazo wa vitu n.\n\n    Inarudisha:\n    - int: Nafasi ndogo zaidi iliyobaki kwenye sanduku baada ya kutoshea vitu.\n\n    Mifano:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "tr": "Bir python fonksiyonu 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen hacimlere sahip bir dizi öğeyi kutuya sığdırmaya çalıştıktan sonra kutuda kalan minimum alanı hesaplayın.\n    \n    Bu fonksiyon, verilen öğelerin herhangi bir alt kümesi tarafından kutuda işgal edilebilecek maksimum hacmi belirlemek için dinamik programlama yaklaşımını kullanır. Daha sonra kutunun toplam kapasitesi ile bu maksimum işgal edilen hacim arasındaki farkı döndürür, bu da minimum kalan alandır.\n\n    Argümanlar:\n    - V (int): Kutunun toplam kapasitesi.\n    - n (int): Kutuda paketlenmesi düşünülen öğe sayısı.\n    - volumes (List[int]): n öğesinin hacimlerinin bir listesi.\n\n    Döndürür:\n    - int: Öğeleri yerleştirdikten sonra kutuda kalan minimum alan.\n\n    Örnekler:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "vi": "Viết một hàm python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán không gian còn lại tối thiểu trong một hộp sau khi cố gắng xếp một số lượng đồ vật với các thể tích đã cho.\n    \n    Hàm này sử dụng phương pháp lập trình động để xác định thể tích tối đa có thể chiếm trong hộp bởi bất kỳ tập hợp con nào của các đồ vật đã cho. Sau đó, nó trả về sự khác biệt giữa tổng dung tích của hộp và thể tích tối đa đã chiếm, đó là không gian còn lại tối thiểu.\n\n    Tham số:\n    - V (int): Tổng dung tích của hộp.\n    - n (int): Số lượng đồ vật cần xem xét để xếp vào hộp.\n    - volumes (List[int]): Một danh sách các thể tích của n đồ vật.\n\n    Trả về:\n    - int: Không gian còn lại tối thiểu trong hộp sau khi xếp các đồ vật.\n\n    Ví dụ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "id": "Tulis fungsi python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung ruang tersisa minimum dalam sebuah kotak setelah mencoba memasukkan sejumlah barang dengan volume yang diberikan.\n    \n    Fungsi ini menggunakan pendekatan pemrograman dinamis untuk menentukan volume maksimum yang dapat ditempati\n    dalam kotak oleh setiap subset dari barang-barang yang diberikan. Kemudian mengembalikan selisih antara kapasitas total kotak\n    dan volume maksimum yang ditempati ini, yang merupakan ruang tersisa minimum.\n\n    Argumen:\n    - V (int): Kapasitas total kotak.\n    - n (int): Jumlah barang yang dipertimbangkan untuk dimasukkan ke dalam kotak.\n    - volumes (List[int]): Daftar volume dari n barang.\n\n    Mengembalikan:\n    - int: Ruang tersisa minimum dalam kotak setelah memasukkan barang-barang.\n\n    Contoh:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "ja": "以下の問題を解決するために、Python関数 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' を作成してください。\n\n    与えられた体積のアイテムをいくつか箱に詰めた後の、箱の最小残りスペースを計算します。\n\n    この関数は、与えられたアイテムの任意の部分集合によって箱の中で占めることができる最大体積を決定するために、動的計画法を使用します。次に、箱の総容量とこの最大占有体積との差を返します。これが最小残りスペースです。\n\n    引数:\n    - V (int): 箱の総容量。\n    - n (int): 箱に詰めることを考慮するアイテムの数。\n    - volumes (List[int]): n個のアイテムの体積のリスト。\n\n    戻り値:\n    - int: アイテムを詰めた後の箱の最小残りスペース。\n\n    例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "ko": "다음 문제를 해결하기 위해 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:'라는 파이썬 함수를 작성하세요:\n\n    주어진 부피를 가진 여러 항목을 상자에 맞추려고 시도한 후 남은 최소 공간을 계산합니다.\n    \n    이 함수는 주어진 항목의 하위 집합에 의해 상자에 차지될 수 있는 최대 부피를 결정하기 위해 동적 프로그래밍 접근 방식을 사용합니다. 그런 다음 상자의 총 용량과 이 최대 차지 부피의 차이를 반환하며, 이는 남은 최소 공간입니다.\n\n    인수:\n    - V (int): 상자의 총 용량.\n    - n (int): 상자에 포장할 항목의 수.\n    - volumes (List[int]): n개의 항목의 부피 목록.\n\n    반환:\n    - int: 항목을 맞춘 후 상자에 남은 최소 공간.\n\n    예:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "ml": "'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' എന്ന python function എഴുതുക താഴെ നൽകിയിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    നൽകിയ വോളിയങ്ങൾ ഉള്ള ഒരു നിരവധിപ്രമാണങ്ങൾ ബോക്സിൽ ഇടാൻ ശ്രമിച്ചതിന് ശേഷം ബോക്സിൽ ശേഷിക്കുന്ന ഏറ്റവും കുറഞ്ഞ സ്ഥലം കണക്കാക്കുക.\n    \n    ഈ function ഒരു ഡൈനാമിക് പ്രോഗ്രാമിംഗ് സമീപനം ഉപയോഗിച്ച് നൽകിയിരിക്കുന്ന വസ്തുക്കളുടെ ഏതെങ്കിലും ഉപസമൂഹം ബോക്സിൽ കൈവശം വെക്കാവുന്ന പരമാവധി വോളിയം നിർണ്ണയിക്കുന്നു. \n    തുടർന്ന്, ബോക്സിന്റെ മൊത്തം ശേഷിയും ഈ പരമാവധി കൈവശം വെച്ച വോളിയവും തമ്മിലുള്ള വ്യത്യാസം തിരികെ നൽകുന്നു, \n    അത് ശേഷിക്കുന്ന ഏറ്റവും കുറഞ്ഞ സ്ഥലം ആണ്.\n\n    Args:\n    - V (int): ബോക്സിന്റെ മൊത്തം ശേഷി.\n    - n (int): ബോക്സിൽ പായ്ക്കുചെയ്യാൻ പരിഗണിക്കുന്ന വസ്തുക്കളുടെ എണ്ണം.\n    - volumes (List[int]): n വസ്തുക്കളുടെ വോളിയങ്ങളുടെ പട്ടിക.\n\n    Returns:\n    - int: വസ്തുക്കൾ ഇടുന്നതിന് ശേഷം ബോക്സിൽ ശേഷിക്കുന്ന ഏറ്റവും കുറഞ്ഞ സ്ഥലം.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "fa": "یک تابع پایتون بنویسید 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' تا مسئله زیر را حل کند:\n\n    حداقل فضای باقی‌مانده در یک جعبه را پس از تلاش برای جا دادن تعدادی آیتم با حجم‌های داده شده محاسبه کنید.\n    \n    این تابع از یک روش برنامه‌ریزی پویا برای تعیین حداکثر حجمی که می‌تواند توسط هر زیرمجموعه‌ای از آیتم‌های داده شده\n    در جعبه اشغال شود، استفاده می‌کند. سپس تفاوت بین ظرفیت کل جعبه و این حجم اشغال شده حداکثر را برمی‌گرداند، که همان\n    حداقل فضای باقی‌مانده است.\n\n    آرگومان‌ها:\n    - V (int): ظرفیت کل جعبه.\n    - n (int): تعداد آیتم‌هایی که باید برای بسته‌بندی در جعبه در نظر گرفته شوند.\n    - volumes (List[int]): لیستی از حجم‌های n آیتم.\n\n    بازگشت:\n    - int: حداقل فضای باقی‌مانده در جعبه پس از جا دادن آیتم‌ها.\n\n    مثال‌ها:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5"}, "level": "easy", "test": "def test_min_remaining_space():\n    # Test case 1: Sample provided in the problem statement where all items can fit perfectly\n    V1, n1 = 24, 6\n    volumes1 = [8, 3, 12, 7, 9, 7]\n    expected1 = 0\n    assert min_remaining_space(V1, n1,\n                               volumes1) == expected1, f\"Test case 1 failed: expected {expected1}, got {min_remaining_space(V1, n1, volumes1)}\"\n\n    # Test case 2: Some space is expected to remain in the box\n    V2, n2 = 10, 4\n    volumes2 = [3, 5, 3, 2]\n    expected2 = 0  # Possible packing: 3, 5, and 3, leaves 2 units of space\n    assert min_remaining_space(V2, n2,\n                               volumes2) == expected2, f\"Test case 2 failed: expected {expected2}, got {min_remaining_space(V2, n2, volumes2)}\"\n\n    # Test case 3: No items can fit due to the items being larger than the box capacity\n    V3, n3 = 5, 3\n    volumes3 = [6, 7, 8]\n    expected3 = 5  # No items fit, so all 5 units of space remain\n    assert min_remaining_space(V3, n3,\n                               volumes3) == expected3, f\"Test case 3 failed: expected {expected3}, got {min_remaining_space(V3, n3, volumes3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_min_remaining_space()", "entry_point": "min_remaining_space", "signature": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:", "docstring": {"en": "\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    ", "sq": "\n    Llogarit hapësirën minimale të mbetur në një kuti pasi të përpiqesh të vendosësh një numër artikujsh me vëllime të dhëna.\n    \n    Kjo funksion përdor një qasje të programimit dinamik për të përcaktuar vëllimin maksimal që mund të zërë\n    në kuti nga çdo nëngrup i artikujve të dhënë. Pastaj kthen diferencën midis kapacitetit total të kutisë\n    dhe këtij vëllimi maksimal të zënë, që është hapësira minimale e mbetur.\n\n    Args:\n    - V (int): Kapaciteti total i kutisë.\n    - n (int): Numri i artikujve për t'u konsideruar për paketim në kuti.\n    - volumes (List[int]): Një listë e vëllimeve të n artikujve.\n\n    Returns:\n    - int: Hapësira minimale e mbetur në kuti pas vendosjes së artikujve.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "hy": "\n    Հաշվեք տուփում մնացած նվազագույն տարածքը այն բանից հետո, երբ փորձեք տեղավորել որոշակի ծավալներով իրեր։\n    \n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար տուփում ցանկացած ենթաբազմության միջոցով զբաղեցված առավելագույն ծավալը։\n    Այնուհետև վերադարձնում է տուփի ընդհանուր տարողության և այս առավելագույն զբաղեցված ծավալի տարբերությունը, որը նվազագույն մնացած տարածքն է։\n\n    Պարամետրեր:\n    - V (int): Տուփի ընդհանուր տարողությունը։\n    - n (int): Տուփի մեջ տեղավորելու համար հաշվի առնվող իրերի քանակը։\n    - volumes (List[int]): n իրերի ծավալների ցուցակ։\n\n    Վերադարձնում է:\n    - int: Տուփում մնացած նվազագույն տարածքը իրերի տեղավորումից հետո։\n\n    Օրինակներ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "bn": "\n    একটি বাক্সে নির্দিষ্ট আয়তনের কিছু আইটেম ফিট করার পর বাক্সে অবশিষ্ট সর্বনিম্ন স্থান গণনা করুন।\n    \n    এই ফাংশনটি একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে যে কোনও প্রদত্ত আইটেমের উপসেট দ্বারা বাক্সে দখল করা সর্বাধিক আয়তন নির্ধারণ করতে। তারপর এটি বাক্সের মোট ক্ষমতা এবং এই সর্বাধিক দখলকৃত আয়তনের মধ্যে পার্থক্য প্রদান করে, যা অবশিষ্ট সর্বনিম্ন স্থান।\n    \n    আর্গুমেন্টসমূহ:\n    - V (int): বাক্সের মোট ক্ষমতা।\n    - n (int): বাক্সে প্যাক করার জন্য বিবেচিত আইটেমের সংখ্যা।\n    - volumes (List[int]): n আইটেমের আয়তনের একটি তালিকা।\n    \n    রিটার্নস:\n    - int: আইটেম ফিট করার পর বাক্সে অবশিষ্ট সর্বনিম্ন স্থান।\n    \n    উদাহরণ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "bg": "\n    Изчислете минималното оставащо пространство в кутия след опит за поставяне на определен брой предмети с дадени обеми.\n    \n    Тази функция използва подход на динамично програмиране, за да определи максималния обем, който може да бъде зает\n    в кутията от всяко подмножество на дадените предмети. След това връща разликата между общия капацитет на кутията\n    и този максимален зает обем, което е минималното оставащо пространство.\n\n    Аргументи:\n    - V (int): Общият капацитет на кутията.\n    - n (int): Броят на предметите, които да се разглеждат за опаковане в кутията.\n    - volumes (List[int]): Списък с обемите на n предмета.\n\n    Връща:\n    - int: Минималното оставащо пространство в кутията след поставяне на предметите.\n\n    Примери:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "zh": "\n    计算在尝试将若干具有给定体积的物品放入箱子后，箱子中剩余的最小空间。\n    \n    该函数使用动态规划方法来确定给定物品的任意子集在箱子中可以占据的最大体积。\n    然后返回箱子总容量与该最大占用体积之间的差值，即最小剩余空间。\n\n    参数:\n    - V (int): 箱子的总容量。\n    - n (int): 考虑放入箱子的物品数量。\n    - volumes (List[int]): n 个物品的体积列表。\n\n    返回:\n    - int: 将物品放入后箱子中剩余的最小空间。\n\n    示例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "fr": "\n    Calculer l'espace restant minimum dans une boîte après avoir essayé d'y placer un certain nombre d'articles avec des volumes donnés.\n    \n    Cette fonction utilise une approche de programmation dynamique pour déterminer le volume maximum qui peut être occupé\n    dans la boîte par n'importe quel sous-ensemble des articles donnés. Elle retourne ensuite la différence entre la capacité totale de la boîte\n    et ce volume maximum occupé, qui est l'espace restant minimum.\n\n    Args:\n    - V (int): La capacité totale de la boîte.\n    - n (int): Le nombre d'articles à considérer pour le rangement dans la boîte.\n    - volumes (List[int]): Une liste des volumes des n articles.\n\n    Returns:\n    - int: L'espace restant minimum dans la boîte après avoir placé les articles.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "de": "\n    Berechne den minimalen verbleibenden Raum in einer Box, nachdem versucht wurde, eine Anzahl von Gegenständen mit gegebenen Volumina unterzubringen.\n    \n    Diese Funktion verwendet einen dynamischen Programmieransatz, um das maximale Volumen zu bestimmen, das durch eine beliebige Teilmenge der gegebenen Gegenstände in der Box belegt werden kann. Sie gibt dann die Differenz zwischen der Gesamtkapazität der Box und diesem maximal belegten Volumen zurück, was den minimalen verbleibenden Raum darstellt.\n\n    Argumente:\n    - V (int): Die Gesamtkapazität der Box.\n    - n (int): Die Anzahl der Gegenstände, die in die Box gepackt werden sollen.\n    - volumes (List[int]): Eine Liste der Volumina der n Gegenstände.\n\n    Rückgabewert:\n    - int: Der minimale verbleibende Raum in der Box nach dem Unterbringen der Gegenstände.\n\n    Beispiele:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "ha": "\n    Lissafa ƙaramin sarari da ya rage a cikin akwati bayan ƙoƙarin sanya adadin abubuwa tare da ƙayyadaddun ƙarar.\n\n    Wannan aikin yana amfani da hanyar shirye-shiryen motsi don ƙayyade mafi girman ƙarar da za a iya cika\n    a cikin akwatin ta kowace ƙungiya daga cikin abubuwan da aka bayar. Sannan yana mayar da bambanci tsakanin jimillar ƙarfin akwatin\n    da wannan mafi girman ƙarar da aka cika, wanda shine ƙaramin sarari da ya rage.\n\n    Args:\n    - V (int): Jimillar ƙarfin akwatin.\n    - n (int): Adadin abubuwan da za a yi la'akari da su don cika cikin akwatin.\n    - volumes (List[int]): Jerin ƙarar abubuwan n.\n\n    Returns:\n    - int: Ƙaramin sarari da ya rage a cikin akwatin bayan sanya abubuwan.\n\n    Misalai:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "hi": "\n    एक बॉक्स में दिए गए वॉल्यूम वाले वस्तुओं की संख्या को फिट करने के बाद बची हुई न्यूनतम जगह की गणना करें।\n    \n    यह फ़ंक्शन एक डायनेमिक प्रोग्रामिंग दृष्टिकोण का उपयोग करता है यह निर्धारित करने के लिए कि दिए गए वस्तुओं के किसी भी उपसमूह द्वारा बॉक्स में अधिकतम वॉल्यूम कितना भरा जा सकता है। फिर यह बॉक्स की कुल क्षमता और इस अधिकतम भरे हुए वॉल्यूम के बीच का अंतर लौटाता है, जो कि बची हुई न्यूनतम जगह है।\n\n    तर्क:\n    - V (int): बॉक्स की कुल क्षमता।\n    - n (int): बॉक्स में पैक करने के लिए विचार करने वाली वस्तुओं की संख्या।\n    - volumes (List[int]): n वस्तुओं के वॉल्यूम की सूची।\n\n    रिटर्न:\n    - int: वस्तुओं को फिट करने के बाद बॉक्स में बची हुई न्यूनतम जगह।\n\n    उदाहरण:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "hu": "\n    Számítsa ki a minimális fennmaradó helyet egy dobozban, miután megpróbált egy adott térfogatú tárgyakat elhelyezni benne.\n    \n    Ez a függvény dinamikus programozási megközelítést alkalmaz annak meghatározására, hogy a dobozban a megadott tárgyak bármely részhalmaza által elfoglalt maximális térfogat mekkora lehet.\n    Ezután visszaadja a doboz teljes kapacitása és a maximálisan elfoglalt térfogat közötti különbséget, ami a minimális fennmaradó hely.\n\n    Paraméterek:\n    - V (int): A doboz teljes kapacitása.\n    - n (int): A figyelembe veendő tárgyak száma a dobozba való csomagoláshoz.\n    - volumes (List[int]): Az n tárgy térfogatának listája.\n\n    Visszatér:\n    - int: A minimális fennmaradó hely a dobozban a tárgyak elhelyezése után.\n\n    Példák:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "es": "    Calcular el espacio mínimo restante en una caja después de intentar encajar un número de artículos con volúmenes dados.\n    \n    Esta función utiliza un enfoque de programación dinámica para determinar el volumen máximo que puede ser ocupado\n    en la caja por cualquier subconjunto de los artículos dados. Luego devuelve la diferencia entre la capacidad total de la caja\n    y este volumen máximo ocupado, que es el espacio mínimo restante.\n\n    Argumentos:\n    - V (int): La capacidad total de la caja.\n    - n (int): El número de artículos a considerar para empacar en la caja.\n    - volumes (List[int]): Una lista de los volúmenes de los n artículos.\n\n    Devuelve:\n    - int: El espacio mínimo restante en la caja después de encajar los artículos.\n\n    Ejemplos:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "arb": "    حساب الحد الأدنى من المساحة المتبقية في صندوق بعد محاولة وضع عدد من العناصر ذات الأحجام المعطاة.\n    \n    تستخدم هذه الدالة نهج البرمجة الديناميكية لتحديد الحد الأقصى للحجم الذي يمكن أن يشغله أي مجموعة فرعية من العناصر المعطاة في الصندوق. ثم تعيد الفرق بين السعة الإجمالية للصندوق وهذا الحجم المشغول الأقصى، وهو الحد الأدنى من المساحة المتبقية.\n\n    يعيدالحجج:\n    - V (int): السعة الإجمالية للصندوق.\n    - n (int): عدد العناصر التي يجب أخذها بعين الاعتبار لوضعها في الصندوق.\n    - volumes (List[int]): قائمة بأحجام العناصر n.\n\n    يعيد:\n    - int: الحد الأدنى من المساحة المتبقية في الصندوق بعد وضع العناصر.\n\n    امثله:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "sw": "    Kuhesabu nafasi ndogo iliyobaki katika sanduku baada ya kujaribu kutoshea idadi ya vitu vyenye ujazo uliotolewa.\n    \n    Kazi hii inatumia mbinu ya programu ya nguvu ili kubaini ujazo wa juu zaidi ambao unaweza kujazwa\n    kwenye sanduku na seti yoyote ndogo ya vitu vilivyotolewa. Kisha inarudisha tofauti kati ya uwezo wa jumla wa sanduku\n    na ujazo huu wa juu uliotumika, ambayo ni nafasi ndogo iliyobaki.\n\n    Hoja:\n    - V (int): Uwezo wa jumla wa sanduku.\n    - n (int): Idadi ya vitu vya kuzingatia kwa kufunga kwenye sanduku.\n    - volumes (List[int]): Orodha ya ujazo wa vitu n.\n\n    Inarejesha:\n    - int: Nafasi ndogo iliyobaki katika sanduku baada ya kutoshea vitu.\n\n    Mifano:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "tr": "    Bir kutuya verilen hacimlere sahip bir dizi öğeyi sığdırmaya çalıştıktan sonra kalan minimum boş alanı hesaplayın.\n    \n    Bu fonksiyon, verilen öğelerin herhangi bir alt kümesi tarafından kutuda kaplanabilecek maksimum hacmi belirlemek için dinamik programlama yaklaşımı kullanır. Daha sonra kutunun toplam kapasitesi ile bu maksimum dolu hacim arasındaki farkı döndürür, bu da minimum kalan alandır.\n\n    Argümanlar:\n    - V (int): Kutunun toplam kapasitesi.\n    - n (int): Kutunun içine yerleştirilmesi düşünülen öğe sayısı.\n    - volumes (List[int]): n öğesinin hacimlerinin listesi.\n\n    Döndürülenler:\n    - int: Öğeleri yerleştirdikten sonra kutuda kalan minimum boş alan.\n\n    Örnekler:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "vi": "    Tính toán không gian còn lại tối thiểu trong một hộp sau khi cố gắng xếp một số lượng đồ vật với thể tích cho trước.\n    \n    Hàm này sử dụng phương pháp lập trình động để xác định thể tích tối đa có thể chiếm trong hộp bởi bất kỳ tập hợp con nào của các đồ vật cho trước. Sau đó, nó trả về sự khác biệt giữa tổng dung tích của hộp và thể tích tối đa đã chiếm này, đó là không gian còn lại tối thiểu.\n\n    Tham số:\n    - V (int): Tổng dung tích của hộp.\n    - n (int): Số lượng đồ vật cần xem xét để xếp vào hộp.\n    - volumes (List[int]): Một danh sách thể tích của n đồ vật.\n\n    Trả về:\n    - int: Không gian còn lại tối thiểu trong hộp sau khi xếp các đồ vật.\n\n    Ví dụ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "id": "Menghitung ruang sisa minimum dalam sebuah kotak setelah mencoba memasukkan sejumlah barang dengan volume tertentu.\n\nFungsi ini menggunakan pendekatan pemrograman dinamis untuk menentukan volume maksimum yang dapat ditempati dalam kotak oleh subset dari barang-barang yang diberikan. Kemudian mengembalikan selisih antara kapasitas total kotak dan volume maksimum yang ditempati ini, yang merupakan ruang sisa minimum.\n\nArgs:\n- V (int): Kapasitas total kotak.\n- n (int): Jumlah barang yang dipertimbangkan untuk dimasukkan ke dalam kotak.\n- volumes (List[int]): Daftar volume dari n barang.\n\nReturns:\n- int: Ruang sisa minimum dalam kotak setelah memasukkan barang-barang.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5", "ja": "    アイテムの体積を考慮して、ボックス内に収まる最小の残りスペースを計算します。\n    \n    この関数は動的プログラミングアプローチを使用して、与えられたアイテムの任意の部分集合によって\n    ボックス内に占められる最大体積を決定します。その後、ボックスの総容量とこの最大占有体積の差を返します。\n    これが最小の残りスペースです。\n\n    引数:\n    - V (int): ボックスの総容量。\n    - n (int): ボックスに詰めることを考慮するアイテムの数。\n    - volumes (List[int]): n個のアイテムの体積のリスト。\n\n    戻り値:\n    - int: アイテムを収めた後のボックス内の最小の残りスペース。\n\n    例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "ko": "상자에 주어진 부피를 가진 여러 항목을 맞춘 후 남은 최소 공간을 계산합니다.\n\n이 함수는 동적 프로그래밍 접근 방식을 사용하여 주어진 항목의 모든 부분 집합이 상자에서 차지할 수 있는 최대 부피를 결정합니다. 그런 다음 상자의 총 용량과 이 최대 점유 부피의 차이를 반환하며, 이는 남은 최소 공간입니다.\n\n인수:\n- V (int): 상자의 총 용량.\n- n (int): 상자에 포장할 항목의 수.\n- volumes (List[int]): n개의 항목의 부피 목록.\n\n반환:\n- int: 항목을 맞춘 후 상자에 남은 최소 공간.\n\n예제:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5", "ml": "    ഒരു നിശ്ചിത വോളിയം ഉള്ള നിരവധി വസ്തുക്കൾ ഉൾക്കൊള്ളിക്കാൻ ശ്രമിച്ചതിന് ശേഷം ഒരു ബോക്സിൽ ശേഷിക്കുന്ന കുറഞ്ഞ സ്ഥലം കണക്കാക്കുക.\n    \n    നൽകിയ വസ്തുക്കളുടെ ഏതെങ്കിലും ഉപസമൂഹം ഉപയോഗിച്ച് ബോക്സിൽ ഉൾക്കൊള്ളാവുന്ന പരമാവധി വോളിയം നിർണ്ണയിക്കാൻ ഈ ഫംഗ്ഷൻ ഡൈനാമിക് പ്രോഗ്രാമിംഗ് സമീപനം ഉപയോഗിക്കുന്നു. \n    തുടർന്ന്, ബോക്സിന്റെ ആകെ ശേഷിയും ഈ പരമാവധി ഉൾക്കൊള്ളുന്ന വോളിയവും തമ്മിലുള്ള വ്യത്യാസം ഇത് തിരികെ നൽകുന്നു, \n    ഇത് കുറഞ്ഞ ശേഷിക്കുന്ന സ്ഥലം ആണ്.\n\n    Args:\n    - V (int): ബോക്സിന്റെ ആകെ ശേഷി.\n    - n (int): ബോക്സിൽ പാക്ക് ചെയ്യാൻ പരിഗണിക്കുന്ന വസ്തുക്കളുടെ എണ്ണം.\n    - volumes (List[int]): n വസ്തുക്കളുടെ വോളിയം ലിസ്റ്റ്.\n\n    Returns:\n    - int: വസ്തുക്കൾ ഉൾക്കൊള്ളിച്ചതിന് ശേഷം ബോക്സിൽ ശേഷിക്കുന്ന കുറഞ്ഞ സ്ഥലം.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5", "fa": "محاسبه حداقل فضای باقی‌مانده در یک جعبه پس از تلاش برای جا دادن تعدادی آیتم با حجم‌های داده شده.\n\nاین تابع از یک روش برنامه‌ریزی پویا برای تعیین حداکثر حجمی که می‌تواند توسط هر زیرمجموعه‌ای از آیتم‌های داده شده در جعبه اشغال شود، استفاده می‌کند. سپس تفاوت بین ظرفیت کل جعبه و این حداکثر حجم اشغال شده را برمی‌گرداند که حداقل فضای باقی‌مانده است.\n\nArgs:\n- V (int): ظرفیت کل جعبه.\n- n (int): تعداد آیتم‌هایی که باید برای بسته‌بندی در جعبه در نظر گرفته شوند.\n- volumes (List[int]): لیستی از حجم‌های n آیتم.\n\nReturns:\n- int: حداقل فضای باقی‌مانده در جعبه پس از جا دادن آیتم‌ها.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5"}}
{"task_id": "Python/39", "prompt": {"en": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"", "sq": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Llogarit numrin e mënyrave për të rregulluar m vazo me lule duke përdorur deri në n lloje,\n    ku lloji i-të mund të ketë maksimumi a[i] vazo, dhe rregullimi duhet të jetë në\n    rend rritës të llojeve të luleve.\n\n    Args:\n    - n (int): Numri i llojeve të luleve të disponueshme.\n    - m (int): Numri total i vazove me lule për t'u rregulluar.\n    - a (list of int): Një listë ku a[i] është numri maksimal i vazove për llojin e i-të të luleve.\n\n    Returns:\n    - int: Numri i rregullimeve të dallueshme modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"", "hy": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Հաշվել ծաղիկների m կաթսաների դասավորությունների քանակը մինչև n տեսակներ օգտագործելով,\n    որտեղ i-րդ տեսակը կարող է ունենալ առավելագույնը a[i] կաթսաներ, և դասավորությունը պետք է լինի\n    ծաղիկների տեսակների աճման կարգով:\n\n    Արձանագրություններ:\n    - n (int): Առկա ծաղիկների տեսակների քանակը:\n    - m (int): Դասավորելու ընդհանուր ծաղիկների կաթսաների քանակը:\n    - a (list of int): Ցանկ, որտեղ a[i]-ն i-րդ տեսակի ծաղիկների առավելագույն կաթսաների քանակն է:\n\n    Վերադարձնում է:\n    - int: Տարբեր դասավորությունների քանակը մոդուլո (10^6 + 7):\n\n    Օրինակներ:\n    - calculate_arrangements(2, 4, [3, 2]) վերադարձնում է 2:\n    - calculate_arrangements(3, 3, [1, 2, 3]) վերադարձնում է 6:\n    \"\"\"", "bn": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    n প্রকারের ফুল ব্যবহার করে m টি ফুলের পাত্র সাজানোর উপায়ের সংখ্যা গণনা করুন,\n    যেখানে i তম প্রকারের সর্বাধিক a[i] টি পাত্র থাকতে পারে, এবং সাজানোটি ফুলের প্রকারের \n    ক্রমবর্ধমান ক্রমে হতে হবে।\n\n    Args:\n    - n (int): উপলব্ধ ফুলের প্রকারের সংখ্যা।\n    - m (int): সাজানোর জন্য মোট ফুলের পাত্রের সংখ্যা।\n    - a (list of int): একটি তালিকা যেখানে a[i] হল i তম প্রকারের ফুলের জন্য সর্বাধিক পাত্রের সংখ্যা।\n\n    Returns:\n    - int: ভিন্ন ভিন্ন সাজানোর সংখ্যা মডুলো (10^6 + 7)।\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"", "bg": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Изчислява броя на начините за подреждане на m саксии с цветя, използвайки до n типа,\n    където i-тият тип може да има най-много a[i] саксии, и подреждането трябва да бъде в\n    нарастващ ред на типовете цветя.\n\n    Аргументи:\n    - n (int): Броят на наличните типове цветя.\n    - m (int): Общият брой саксии с цветя за подреждане.\n    - a (list of int): Списък, където a[i] е максималният брой саксии за i-тия тип цветя.\n\n    Връща:\n    - int: Броят на различните подреждания по модул (10^6 + 7).\n\n    Примери:\n    - calculate_arrangements(2, 4, [3, 2]) връща 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) връща 6.\n    \"\"\"", "zh": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    计算使用最多 n 种类型的 m 个花盆的排列方式，\n    其中第 i 种类型最多可以有 a[i] 个花盆，并且排列必须按花的类型递增顺序。\n\n    参数:\n    - n (int): 可用的花的种类数。\n    - m (int): 要排列的花盆总数。\n    - a (list of int): 一个列表，其中 a[i] 是第 i 种花的最大花盆数。\n\n    返回:\n    - int: 不同排列的数量，结果对 (10^6 + 7) 取模。\n\n    示例:\n    - calculate_arrangements(2, 4, [3, 2]) 返回 2。\n    - calculate_arrangements(3, 3, [1, 2, 3]) 返回 6。\n    \"\"\"", "fr": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Calculer le nombre de façons d'organiser m pots de fleurs en utilisant jusqu'à n types,\n    où le ième type peut avoir au plus a[i] pots, et l'arrangement doit être dans\n    l'ordre croissant des types de fleurs.\n\n    Args:\n    - n (int): Le nombre de types de fleurs disponibles.\n    - m (int): Le nombre total de pots de fleurs à organiser.\n    - a (list of int): Une liste où a[i] est le nombre maximum de pots pour le ième type de fleur.\n\n    Returns:\n    - int: Le nombre d'arrangements distincts modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"", "de": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Berechne die Anzahl der Möglichkeiten, m Blumentöpfe unter Verwendung von bis zu n Typen anzuordnen,\n    wobei der i-te Typ höchstens a[i] Töpfe haben kann und die Anordnung in aufsteigender Reihenfolge\n    der Blumentypen erfolgen muss.\n\n    Argumente:\n    - n (int): Die Anzahl der verfügbaren Blumentypen.\n    - m (int): Die Gesamtanzahl der anzuordnenden Blumentöpfe.\n    - a (list of int): Eine Liste, in der a[i] die maximale Anzahl von Töpfen für den i-ten Blumentyp ist.\n\n    Rückgabewert:\n    - int: Die Anzahl der verschiedenen Anordnungen modulo (10^6 + 7).\n\n    Beispiele:\n    - calculate_arrangements(2, 4, [3, 2]) gibt 2 zurück.\n    - calculate_arrangements(3, 3, [1, 2, 3]) gibt 6 zurück.\n    \"\"\"", "ha": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Lissafa yawan hanyoyin shirya tukwane m na furanni ta amfani da nau'ikan n,\n    inda nau'in na i zai iya samun mafi yawan tukwane a[i], kuma shiryawa dole ne ya kasance a\n    cikin tsari mai ƙaruwa na nau'ikan furanni.\n\n    Args:\n    - n (int): Yawan nau'ikan furanni da ake da su.\n    - m (int): Jimlar yawan tukwane furanni da za a shirya.\n    - a (list of int): Jerin inda a[i] shine mafi yawan tukwane don nau'in furanni na i.\n\n    Returns:\n    - int: Yawan shirye-shiryen daban-daban modulo (10^6 + 7).\n\n    Misalai:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"", "hi": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    अधिकतम n प्रकारों का उपयोग करके m फूलों के गमलों को सजाने के तरीकों की संख्या की गणना करें,\n    जहाँ iवें प्रकार के पास अधिकतम a[i] गमले हो सकते हैं, और सजावट फूलों के प्रकारों के \n    बढ़ते क्रम में होनी चाहिए।\n\n    तर्क:\n    - n (int): उपलब्ध फूलों के प्रकारों की संख्या।\n    - m (int): सजाने के लिए कुल फूलों के गमलों की संख्या।\n    - a (list of int): एक सूची जहाँ a[i] iवें प्रकार के फूल के लिए अधिकतम गमलों की संख्या है।\n\n    वापसी:\n    - int: विशिष्ट सजावटों की संख्या (10^6 + 7) के मापांक के साथ।\n\n    उदाहरण:\n    - calculate_arrangements(2, 4, [3, 2]) 2 लौटाता है।\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 लौटाता है।\n    \"\"\"", "hu": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Számítsa ki, hányféleképpen lehet elrendezni m virágcserepet legfeljebb n típus használatával,\n    ahol az i-edik típusnak legfeljebb a[i] cserép lehet, és az elrendezésnek növekvő sorrendben kell lennie\n    a virágtípusok szerint.\n\n    Paraméterek:\n    - n (int): A rendelkezésre álló virágtípusok száma.\n    - m (int): Az elrendezendő virágcserepek teljes száma.\n    - a (list of int): Egy lista, ahol a[i] az i-edik virágtípus maximális cserépszáma.\n\n    Visszatér:\n    - int: A különböző elrendezések száma modulo (10^6 + 7).\n\n    Példák:\n    - calculate_arrangements(2, 4, [3, 2]) visszaadja 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) visszaadja 6.\n    \"\"\"", "es": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Calcula el número de formas de organizar m macetas de flores utilizando hasta n tipos,\n    donde el tipo i puede tener como máximo a[i] macetas, y la disposición debe estar en\n    orden creciente de tipos de flores.\n\n    Argumentos:\n    - n (int): El número de tipos de flores disponibles.\n    - m (int): El número total de macetas de flores a organizar.\n    - a (list of int): Una lista donde a[i] es el número máximo de macetas para el tipo i de flor.\n\n    Devuelve:\n    - int: El número de disposiciones distintas módulo (10^6 + 7).\n\n    Ejemplos:\n    - calculate_arrangements(2, 4, [3, 2]) devuelve 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) devuelve 6.\n    \"\"\"", "arb": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    حساب عدد الطرق لترتيب m من الأواني الزهرية باستخدام ما يصل إلى n نوعًا،\n    حيث يمكن أن يحتوي النوع i على ما لا يزيد عن a[i] من الأواني، ويجب أن يكون الترتيب\n    بترتيب تصاعدي لأنواع الزهور.\n\n    يعيدالحجج:\n    - n (int): عدد أنواع الزهور المتاحة.\n    - m (int): العدد الإجمالي للأواني الزهرية لترتيبها.\n    - a (list of int): قائمة حيث a[i] هو الحد الأقصى لعدد الأواني لنوع الزهرة i.\n\n    يعيد:\n    - int: عدد الترتيبات المميزة مودولو (10^6 + 7).\n\n    امثله:\n    - calculate_arrangements(2, 4, [3, 2]) يعيد 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) يعيد 6.\n    \"\"\"", "sw": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Hesabu idadi ya njia za kupanga sufuria m za maua kwa kutumia hadi aina n,\n    ambapo aina ya i inaweza kuwa na sufuria a[i] kwa kiwango cha juu, na mpangilio lazima uwe\n    katika mpangilio wa kuongezeka wa aina za maua.\n\n    Hoja:\n    - n (int): Idadi ya aina za maua zinazopatikana.\n    - m (int): Jumla ya idadi ya sufuria za maua za kupanga.\n    - a (orodha ya int): Orodha ambapo a[i] ni idadi ya juu ya sufuria kwa aina ya i ya maua.\n\n    Inarejesha:\n    - int: Idadi ya mipangilio tofauti modulo (10^6 + 7).\n\n    Mifano:\n    - calculate_arrangements(2, 4, [3, 2]) inarudisha 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) inarudisha 6.\n    \"\"\"", "tr": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    En fazla n türü kullanarak m çiçek saksısını düzenlemenin yollarını hesaplayın,\n    burada i'inci tür en fazla a[i] saksıya sahip olabilir ve düzenleme çiçek türlerinin\n    artan sırasına göre olmalıdır.\n\n    Argümanlar:\n    - n (int): Mevcut çiçek türlerinin sayısı.\n    - m (int): Düzenlenecek toplam çiçek saksısı sayısı.\n    - a (list of int): a[i] i'inci çiçek türü için maksimum saksı sayısını belirten bir liste.\n\n    Döndürür:\n    - int: Farklı düzenlemelerin sayısı, (10^6 + 7) modunda.\n\n    Örnekler:\n    - calculate_arrangements(2, 4, [3, 2]) 2 döndürür.\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 döndürür.\n    \"\"\"", "vi": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Tính số cách sắp xếp m chậu hoa sử dụng tối đa n loại,\n    trong đó loại thứ i có thể có tối đa a[i] chậu, và cách sắp xếp phải theo\n    thứ tự tăng dần của các loại hoa.\n\n    Tham số:\n    - n (int): Số loại hoa có sẵn.\n    - m (int): Tổng số chậu hoa cần sắp xếp.\n    - a (list of int): Danh sách mà a[i] là số chậu tối đa cho loại hoa thứ i.\n\n    Trả về:\n    - int: Số cách sắp xếp khác nhau theo modulo (10^6 + 7).\n\n    Ví dụ:\n    - calculate_arrangements(2, 4, [3, 2]) trả về 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) trả về 6.\n    \"\"\"", "id": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Hitung jumlah cara untuk mengatur m pot bunga menggunakan hingga n jenis,\n    di mana jenis ke-i dapat memiliki paling banyak a[i] pot, dan pengaturan harus dalam\n    urutan menaik dari jenis bunga.\n\n    Args:\n    - n (int): Jumlah jenis bunga yang tersedia.\n    - m (int): Jumlah total pot bunga yang akan diatur.\n    - a (list of int): Daftar di mana a[i] adalah jumlah maksimum pot untuk jenis bunga ke-i.\n\n    Returns:\n    - int: Jumlah pengaturan yang berbeda modulo (10^6 + 7).\n\n    Contoh:\n    - calculate_arrangements(2, 4, [3, 2]) mengembalikan 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) mengembalikan 6.\n    \"\"\"", "ja": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    最大でn種類の花を使用してm個の花鉢を配置する方法の数を計算します。\n    ここで、i番目の種類は最大でa[i]個の鉢を持つことができ、配置は花の種類の\n    昇順でなければなりません。\n\n    引数:\n    - n (int): 利用可能な花の種類の数。\n    - m (int): 配置する花鉢の総数。\n    - a (list of int): a[i]がi番目の種類の花の最大鉢数であるリスト。\n\n    戻り値:\n    - int: (10^6 + 7)での異なる配置の数。\n\n    例:\n    - calculate_arrangements(2, 4, [3, 2]) は 2 を返します。\n    - calculate_arrangements(3, 3, [1, 2, 3]) は 6 を返します。\n    \"\"\"", "ko": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    최대 n 종류를 사용하여 m 개의 꽃 화분을 배열하는 방법의 수를 계산합니다.\n    여기서 i번째 종류는 최대 a[i] 개의 화분을 가질 수 있으며, 배열은 꽃 종류의\n    증가하는 순서로 이루어져야 합니다.\n\n    매개변수:\n    - n (int): 사용할 수 있는 꽃 종류의 수.\n    - m (int): 배열할 꽃 화분의 총 수.\n    - a (list of int): a[i]가 i번째 꽃 종류의 최대 화분 수인 리스트.\n\n    반환:\n    - int: 서로 다른 배열의 수를 (10^6 + 7)로 나눈 나머지.\n\n    예제:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"", "ml": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    m പാത്രങ്ങൾ പൂക്കൾ ഉപയോഗിച്ച് ക്രമീകരിക്കുന്നതിനുള്ള വഴികളുടെ എണ്ണം കണക്കാക്കുക\n    n തരം വരെ ഉപയോഗിച്ച്, ith തരം പരമാവധി a[i] പാത്രങ്ങൾ ഉണ്ടാകാം, കൂടാതെ ക്രമീകരണം\n    പൂക്കളുടെ തരം വർദ്ധിക്കുന്ന ക്രമത്തിൽ ആയിരിക്കണം.\n\n    Args:\n    - n (int): ലഭ്യമായ പൂക്കളുടെ തരം.\n    - m (int): ക്രമീകരിക്കേണ്ട ആകെ പൂക്കളുടെ പാത്രങ്ങളുടെ എണ്ണം.\n    - a (list of int): ഒരു ലിസ്റ്റ്, ഇവിടെ a[i] പൂക്കളുടെ ith തരം പരമാവധി പാത്രങ്ങളുടെ എണ്ണം.\n\n    Returns:\n    - int: വ്യത്യസ്തമായ ക്രമീകരണങ്ങളുടെ എണ്ണം (10^6 + 7) മോഡുലോ.\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"", "fa": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    محاسبه تعداد روش‌های چیدمان m گلدان گل با استفاده از حداکثر n نوع،\n    به طوری که نوع iام می‌تواند حداکثر a[i] گلدان داشته باشد و چیدمان باید به\n    ترتیب صعودی از نوع گل‌ها باشد.\n\n    آرگومان‌ها:\n    - n (int): تعداد انواع گل‌های موجود.\n    - m (int): تعداد کل گلدان‌های گل برای چیدمان.\n    - a (list of int): لیستی که در آن a[i] حداکثر تعداد گلدان‌ها برای نوع iام گل است.\n\n    بازگشت:\n    - int: تعداد چیدمان‌های متمایز به پیمانه (10^6 + 7).\n\n    مثال‌ها:\n    - calculate_arrangements(2, 4, [3, 2]) برمی‌گرداند 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) برمی‌گرداند 6.\n    \"\"\""}, "canonical_solution": "    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]", "instruction": {"en": "Write a python function 'def calculate_arrangements(n, m, a) -> int:' to solve the following problem:\n\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    ", "sq": "Shkruani një funksion python 'def calculate_arrangements(n, m, a) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin e mënyrave për të rregulluar m vazo me lule duke përdorur deri në n lloje,\n    ku lloji i-të mund të ketë maksimumi a[i] vazo, dhe rregullimi duhet të jetë në\n    rend rritës të llojeve të luleve.\n\n    Args:\n    - n (int): Numri i llojeve të luleve të disponueshme.\n    - m (int): Numri total i vazove me lule për t'u rregulluar.\n    - a (list of int): Një listë ku a[i] është numri maksimal i vazove për llojin i-të të luleve.\n\n    Kthen:\n    - int: Numri i rregullimeve të dallueshme modulo (10^6 + 7).\n\n    Shembuj:\n    - calculate_arrangements(2, 4, [3, 2]) kthen 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) kthen 6.", "hy": "Պայթոն ֆունկցիա 'def calculate_arrangements(n, m, a) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք, թե քանի եղանակով կարելի է դասավորել m ծաղկամաններ՝ օգտագործելով մինչև n տեսակներ,\n    որտեղ i-րդ տեսակը կարող է ունենալ առավելագույնը a[i] ծաղկամաններ, և դասավորությունը պետք է լինի\n    ծաղիկների տեսակների աճման կարգով:\n\n    Արգումենտներ:\n    - n (int): Առկա ծաղիկների տեսակների քանակը:\n    - m (int): Ընդհանուր դասավորելի ծաղկամանների քանակը:\n    - a (list of int): Ցանկ, որտեղ a[i]-ը i-րդ տեսակի ծաղիկների առավելագույն ծաղկամանների քանակն է:\n\n    Վերադարձնում է:\n    - int: Տարբեր դասավորությունների քանակը մոդուլո (10^6 + 7):\n\n    Օրինակներ:\n    - calculate_arrangements(2, 4, [3, 2]) վերադարձնում է 2:\n    - calculate_arrangements(3, 3, [1, 2, 3]) վերադարձնում է 6:", "bn": "একটি পাইথন ফাংশন 'def calculate_arrangements(n, m, a) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    n প্রকারের মধ্যে m টি ফুলের পাত্র সাজানোর উপায়ের সংখ্যা গণনা করুন,\n    যেখানে i তম প্রকারের সর্বাধিক a[i] পাত্র থাকতে পারে, এবং বিন্যাসটি\n    ফুলের প্রকারের ক্রমবর্ধমান ক্রমে হতে হবে।\n\n    আর্গুমেন্টস:\n    - n (int): উপলব্ধ ফুলের প্রকারের সংখ্যা।\n    - m (int): সাজানোর জন্য মোট ফুলের পাত্রের সংখ্যা।\n    - a (list of int): একটি তালিকা যেখানে a[i] হল i তম প্রকারের ফুলের জন্য সর্বাধিক পাত্রের সংখ্যা।\n\n    রিটার্নস:\n    - int: পৃথক বিন্যাসের সংখ্যা মডুলো (10^6 + 7)।\n\n    উদাহরণ:\n    - calculate_arrangements(2, 4, [3, 2]) 2 ফেরত দেয়।\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 ফেরত দেয়।", "bg": "Напишете функция на Python 'def calculate_arrangements(n, m, a) -> int:', за да решите следния проблем:\n\n    Изчислете броя на начините за подреждане на m саксии с цветя, използвайки до n типа,\n    където i-тият тип може да има най-много a[i] саксии, и подреждането трябва да бъде в\n    нарастващ ред на типовете цветя.\n\n    Аргументи:\n    - n (int): Броят на наличните типове цветя.\n    - m (int): Общият брой саксии с цветя за подреждане.\n    - a (списък от int): Списък, където a[i] е максималният брой саксии за i-тия тип цвете.\n\n    Връща:\n    - int: Броят на различните подреждания по модул (10^6 + 7).\n\n    Примери:\n    - calculate_arrangements(2, 4, [3, 2]) връща 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) връща 6.", "zh": "编写一个Python函数 'def calculate_arrangements(n, m, a) -> int:' 来解决以下问题：\n\n    计算使用最多n种类型的花盆来排列m个花盆的方法数，\n    其中第i种类型最多可以有a[i]个花盆，并且排列必须按照花的类型递增顺序。\n\n    参数:\n    - n (int): 可用的花的类型数量。\n    - m (int): 要排列的花盆总数。\n    - a (list of int): 一个列表，其中a[i]是第i种花的最大花盆数量。\n\n    返回:\n    - int: 不同排列的数量，结果取模(10^6 + 7)。\n\n    示例:\n    - calculate_arrangements(2, 4, [3, 2]) 返回 2。\n    - calculate_arrangements(3, 3, [1, 2, 3]) 返回 6。", "fr": "Écrire une fonction python 'def calculate_arrangements(n, m, a) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nombre de façons d'arranger m pots de fleurs en utilisant jusqu'à n types,\n    où le ième type peut avoir au maximum a[i] pots, et l'arrangement doit être dans\n    l'ordre croissant des types de fleurs.\n\n    Args:\n    - n (int): Le nombre de types de fleurs disponibles.\n    - m (int): Le nombre total de pots de fleurs à arranger.\n    - a (list of int): Une liste où a[i] est le nombre maximum de pots pour le ième type de fleur.\n\n    Retourne:\n    - int: Le nombre d'arrangements distincts modulo (10^6 + 7).\n\n    Exemples:\n    - calculate_arrangements(2, 4, [3, 2]) retourne 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) retourne 6.", "de": "Schreiben Sie eine Python-Funktion 'def calculate_arrangements(n, m, a) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die Anzahl der Möglichkeiten, m Blumentöpfe mit bis zu n Typen anzuordnen,\n    wobei der i-te Typ höchstens a[i] Töpfe haben kann und die Anordnung in\n    aufsteigender Reihenfolge der Blumentypen erfolgen muss.\n\n    Argumente:\n    - n (int): Die Anzahl der verfügbaren Blumentypen.\n    - m (int): Die Gesamtanzahl der anzuordnenden Blumentöpfe.\n    - a (Liste von int): Eine Liste, in der a[i] die maximale Anzahl von Töpfen für den i-ten Blumentyp ist.\n\n    Rückgabewert:\n    - int: Die Anzahl der verschiedenen Anordnungen modulo (10^6 + 7).\n\n    Beispiele:\n    - calculate_arrangements(2, 4, [3, 2]) gibt 2 zurück.\n    - calculate_arrangements(3, 3, [1, 2, 3]) gibt 6 zurück.", "ha": "Rubuta wani aikin python 'def calculate_arrangements(n, m, a) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa yawan hanyoyin shirya tukwane m na furanni ta amfani da nau'ikan n,\n    inda nau'in na i zai iya samun mafi yawan tukwane a[i], kuma shirin dole ne ya kasance a cikin\n    tsari mai ƙaruwa na nau'ikan furanni.\n\n    Args:\n    - n (int): Yawan nau'ikan furanni da ake da su.\n    - m (int): Jimlar yawan tukwane furanni da za a shirya.\n    - a (jerin int): Jerin inda a[i] shine mafi yawan tukwane don nau'in na i na fure.\n\n    Returns:\n    - int: Yawan shirye-shirye masu bambanta modulo (10^6 + 7).\n\n    Misalai:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.", "hi": "एक पायथन फ़ंक्शन 'def calculate_arrangements(n, m, a) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    m फूलों के गमलों को n प्रकारों का उपयोग करके व्यवस्थित करने के तरीकों की संख्या की गणना करें,\n    जहाँ ith प्रकार के पास अधिकतम a[i] गमले हो सकते हैं, और व्यवस्था फूलों के प्रकारों के \n    बढ़ते क्रम में होनी चाहिए।\n\n    तर्क:\n    - n (int): उपलब्ध फूलों के प्रकारों की संख्या।\n    - m (int): कुल फूलों के गमलों की संख्या जिन्हें व्यवस्थित करना है।\n    - a (list of int): एक सूची जहाँ a[i] ith प्रकार के फूल के लिए अधिकतम गमलों की संख्या है।\n\n    लौटाता है:\n    - int: भिन्न व्यवस्थाओं की संख्या (10^6 + 7) के मापांक के साथ।\n\n    उदाहरण:\n    - calculate_arrangements(2, 4, [3, 2]) 2 लौटाता है।\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 लौटाता है।", "hu": "Írj egy python függvényt 'def calculate_arrangements(n, m, a) -> int:' a következő probléma megoldására:\n\n    Számítsd ki, hányféleképpen lehet elrendezni m virágcserepet legfeljebb n típus használatával,\n    ahol az i-edik típusnak legfeljebb a[i] cserepe lehet, és az elrendezésnek növekvő\n    sorrendben kell lennie a virágtípusok szerint.\n\n    Argumentumok:\n    - n (int): A rendelkezésre álló virágtípusok száma.\n    - m (int): Az elrendezendő virágcserepek teljes száma.\n    - a (list of int): Egy lista, ahol a[i] az i-edik virágtípus maximális cserépszáma.\n\n    Visszatér:\n    - int: Az eltérő elrendezések száma modulo (10^6 + 7).\n\n    Példák:\n    - calculate_arrangements(2, 4, [3, 2]) visszatér 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) visszatér 6.", "es": "Escribe una función de Python 'def calculate_arrangements(n, m, a) -> int:' para resolver el siguiente problema:\n\n    Calcula el número de formas de arreglar m macetas de flores usando hasta n tipos,\n    donde el tipo i puede tener como máximo a[i] macetas, y el arreglo debe estar en\n    orden creciente de tipos de flores.\n\n    Argumentos:\n    - n (int): El número de tipos de flores disponibles.\n    - m (int): El número total de macetas de flores a arreglar.\n    - a (list of int): Una lista donde a[i] es el número máximo de macetas para el tipo i de flor.\n\n    Devuelve:\n    - int: El número de arreglos distintos módulo (10^6 + 7).\n\n    Ejemplos:\n    - calculate_arrangements(2, 4, [3, 2]) devuelve 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) devuelve 6.", "arb": "اكتب دالة بايثون 'def calculate_arrangements(n, m, a) -> int:' لحل المشكلة التالية:\n\n    احسب عدد الطرق لترتيب m من أواني الزهور باستخدام ما يصل إلى n أنواع،\n    حيث يمكن أن يحتوي النوع i على ما لا يزيد عن a[i] من الأواني، ويجب أن يكون الترتيب\n    بترتيب تصاعدي لأنواع الزهور.\n\n    يعيدالحجج:\n    - n (int): عدد أنواع الزهور المتاحة.\n    - m (int): العدد الإجمالي لأواني الزهور لترتيبها.\n    - a (list of int): قائمة حيث a[i] هو الحد الأقصى لعدد الأواني لنوع الزهور i.\n\n    يعيد:\n    - int: عدد الترتيبات المميزة موديولو (10^6 + 7).\n\n    امثله:\n    - calculate_arrangements(2, 4, [3, 2]) يعيد 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) يعيد 6.", "sw": "Andika kazi ya python 'def calculate_arrangements(n, m, a) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ya njia za kupanga sufuria m za maua kwa kutumia hadi aina n,\n    ambapo aina ya ith inaweza kuwa na sufuria a[i] kwa zaidi, na mpangilio lazima uwe katika\n    mpangilio wa kuongezeka wa aina za maua.\n\n    Hoja:\n    - n (int): Idadi ya aina za maua zinazopatikana.\n    - m (int): Jumla ya idadi ya sufuria za maua za kupanga.\n    - a (orodha ya int): Orodha ambapo a[i] ni idadi ya juu ya sufuria kwa aina ya ith ya maua.\n\n    Inarejesha:\n    - int: Idadi ya mipangilio tofauti modulo (10^6 + 7).\n\n    Mifano:\n    - calculate_arrangements(2, 4, [3, 2]) inarejesha 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) inarejesha 6.", "tr": "Bir python fonksiyonu 'def calculate_arrangements(n, m, a) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    m çiçek saksısını, n türüne kadar kullanarak düzenlemenin yollarını hesaplayın,\n    burada i. tür en fazla a[i] saksıya sahip olabilir ve düzenleme\n    çiçek türlerinin artan sırasına göre olmalıdır.\n\n    Argümanlar:\n    - n (int): Mevcut çiçek türü sayısı.\n    - m (int): Düzenlenecek toplam çiçek saksısı sayısı.\n    - a (list of int): a[i], i. tür çiçek için maksimum saksı sayısını belirten bir liste.\n\n    Döndürür:\n    - int: Farklı düzenlemelerin sayısı mod (10^6 + 7).\n\n    Örnekler:\n    - calculate_arrangements(2, 4, [3, 2]) 2 döndürür.\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 döndürür.", "vi": "Viết một hàm python 'def calculate_arrangements(n, m, a) -> int:' để giải quyết vấn đề sau:\n\n    Tính số cách sắp xếp m chậu hoa sử dụng tối đa n loại,\n    trong đó loại thứ i có thể có tối đa a[i] chậu, và cách sắp xếp phải theo\n    thứ tự tăng dần của các loại hoa.\n\n    Tham số:\n    - n (int): Số loại hoa có sẵn.\n    - m (int): Tổng số chậu hoa cần sắp xếp.\n    - a (list of int): Danh sách mà a[i] là số chậu tối đa cho loại hoa thứ i.\n\n    Trả về:\n    - int: Số cách sắp xếp khác nhau theo modulo (10^6 + 7).\n\n    Ví dụ:\n    - calculate_arrangements(2, 4, [3, 2]) trả về 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) trả về 6.", "id": "Tulis sebuah fungsi python 'def calculate_arrangements(n, m, a) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung jumlah cara untuk mengatur m pot bunga menggunakan hingga n jenis,\n    di mana jenis ke-i dapat memiliki paling banyak a[i] pot, dan pengaturan harus dalam\n    urutan menaik dari jenis bunga.\n\n    Argumen:\n    - n (int): Jumlah jenis bunga yang tersedia.\n    - m (int): Jumlah total pot bunga yang akan diatur.\n    - a (list of int): Daftar di mana a[i] adalah jumlah maksimum pot untuk jenis bunga ke-i.\n\n    Mengembalikan:\n    - int: Jumlah pengaturan yang berbeda modulo (10^6 + 7).\n\n    Contoh:\n    - calculate_arrangements(2, 4, [3, 2]) mengembalikan 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) mengembalikan 6.", "ja": "Python関数を書いてください。 'def calculate_arrangements(n, m, a) -> int:' を解決するために以下の問題:\n\n    最大で n 種類を使用して m 個の花の鉢を配置する方法の数を計算します。\n    ここで、i 番目の種類は最大で a[i] 個の鉢を持つことができ、配置は\n    花の種類の昇順でなければなりません。\n\n    引数:\n    - n (int): 利用可能な花の種類の数。\n    - m (int): 配置する花の鉢の総数。\n    - a (list of int): a[i] が i 番目の花の種類の最大鉢数であるリスト。\n\n    戻り値:\n    - int: 異なる配置の数を (10^6 + 7) で割った余り。\n\n    例:\n    - calculate_arrangements(2, 4, [3, 2]) は 2 を返します。\n    - calculate_arrangements(3, 3, [1, 2, 3]) は 6 を返します。", "ko": "다음 문제를 해결하기 위해 파이썬 함수를 작성하세요 'def calculate_arrangements(n, m, a) -> int:':\n\n    최대 n 종류를 사용하여 m 개의 꽃 화분을 배열하는 방법의 수를 계산합니다.\n    여기서 i번째 종류는 최대 a[i] 개의 화분을 가질 수 있으며, 배열은 꽃 종류의\n    증가하는 순서로 이루어져야 합니다.\n\n    매개변수:\n    - n (int): 사용 가능한 꽃 종류의 수.\n    - m (int): 배열할 꽃 화분의 총 수.\n    - a (list of int): a[i]가 i번째 꽃 종류의 최대 화분 수인 리스트.\n\n    반환값:\n    - int: (10^6 + 7)로 나눈 나머지로 구한 서로 다른 배열의 수.\n\n    예시:\n    - calculate_arrangements(2, 4, [3, 2])는 2를 반환합니다.\n    - calculate_arrangements(3, 3, [1, 2, 3])는 6을 반환합니다.", "ml": "'def calculate_arrangements(n, m, a) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    n തരം വരെ ഉപയോഗിച്ച് m പൂന്തോട്ട പാത്രങ്ങൾ ക്രമീകരിക്കുന്നതിനുള്ള മാർഗങ്ങളുടെ എണ്ണം\n    കണക്കാക്കുക, ഇവിടെ i-ആം തരം പരമാവധി a[i] പാത്രങ്ങൾ ഉണ്ടാകാം, കൂടാതെ ക്രമീകരണം\n    പൂക്കളുടെ തരം വർദ്ധന ക്രമത്തിൽ ആയിരിക്കണം.\n\n    Args:\n    - n (int): ലഭ്യമായ പൂക്കളുടെ തരം.\n    - m (int): ക്രമീകരിക്കേണ്ട ആകെ പൂന്തോട്ട പാത്രങ്ങളുടെ എണ്ണം.\n    - a (list of int): a[i] എന്നത് i-ആം തരം പൂക്കളുടെ പരമാവധി പാത്രങ്ങളുടെ എണ്ണം ഉള്ള ഒരു പട്ടിക.\n\n    Returns:\n    - int: വ്യത്യസ്തമായ ക്രമീകരണങ്ങളുടെ എണ്ണം (10^6 + 7) മൊഡുലോ.\n\n    ഉദാഹരണങ്ങൾ:\n    - calculate_arrangements(2, 4, [3, 2]) 2 തിരികെ നൽകുന്നു.\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 തിരികെ നൽകുന്നു.", "fa": "یک تابع پایتون 'def calculate_arrangements(n, m, a) -> int:' بنویسید تا مسئله زیر را حل کند:\n\n    تعداد روش‌های چیدمان m گلدان گل با استفاده از حداکثر n نوع را محاسبه کنید،\n    به طوری که نوع iام می‌تواند حداکثر a[i] گلدان داشته باشد و چیدمان باید به\n    ترتیب صعودی از نوع گل‌ها باشد.\n\n    آرگومان‌ها:\n    - n (int): تعداد انواع گل‌های موجود.\n    - m (int): تعداد کل گلدان‌های گلی که باید چیده شوند.\n    - a (list of int): لیستی که در آن a[i] حداکثر تعداد گلدان‌ها برای نوع iام گل است.\n\n    بازگشت:\n    - int: تعداد چیدمان‌های متمایز به پیمانه (10^6 + 7).\n\n    مثال‌ها:\n    - calculate_arrangements(2, 4, [3, 2]) مقدار 2 را برمی‌گرداند.\n    - calculate_arrangements(3, 3, [1, 2, 3]) مقدار 6 را برمی‌گرداند."}, "level": "easy", "test": "def test_calculate_arrangements():\n    # Helper function to compare expected and actual results\n    def assert_equal(actual, expected, message):\n        assert actual == expected, message\n\n    # Test Case 1\n    n, m, a = 2, 4, [3, 2]\n    expected = 2\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 1 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 2\n    n, m, a = 3, 3, [1, 2, 3]\n    expected = 6\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 2 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 3\n    n, m, a = 1, 5, [5]\n    expected = 1\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 3 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_calculate_arrangements()", "entry_point": "calculate_arrangements", "signature": "def calculate_arrangements(n, m, a) -> int:", "docstring": {"en": "\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    ", "sq": "\n    Llogarit numrin e mënyrave për të rregulluar m vazo lulesh duke përdorur deri në n lloje,\n    ku lloji i-të mund të ketë më së shumti a[i] vazo, dhe rregullimi duhet të jetë në\n    rend rritës të llojeve të luleve.\n\n    Args:\n    - n (int): Numri i llojeve të luleve të disponueshme.\n    - m (int): Numri total i vazove të luleve për t'u rregulluar.\n    - a (listë e int): Një listë ku a[i] është numri maksimal i vazove për llojin i-të të luleve.\n\n    Returns:\n    - int: Numri i rregullimeve të veçanta modulo (10^6 + 7).\n\n    Shembuj:\n    - calculate_arrangements(2, 4, [3, 2]) kthen 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) kthen 6.", "hy": "\n    Հաշվել, թե քանի եղանակով կարելի է դասավորել m ծաղկամաններ՝ օգտագործելով մինչև n տեսակներ,\n    որտեղ i-րդ տեսակը կարող է ունենալ առավելագույնը a[i] ծաղկաման, և դասավորությունը պետք է լինի\n    ծաղիկների տեսակների աճման կարգով:\n\n    Պարամետրեր:\n    - n (int): Առկա ծաղիկների տեսակների քանակը:\n    - m (int): Դասավորելու ընդհանուր ծաղկամանների քանակը:\n    - a (list of int): Ցուցակ, որտեղ a[i]-ը ծաղիկների i-րդ տեսակի համար առավելագույն ծաղկամանների քանակն է:\n\n    Վերադարձնում է:\n    - int: Տարբեր դասավորությունների քանակը մոդուլո (10^6 + 7):\n\n    Օրինակներ:\n    - calculate_arrangements(2, 4, [3, 2]) վերադարձնում է 2:\n    - calculate_arrangements(3, 3, [1, 2, 3]) վերադարձնում է 6:", "bn": "\n    m টি ফুলের টব সাজানোর উপায়ের সংখ্যা গণনা করুন n প্রকারের ফুল ব্যবহার করে,\n    যেখানে iতম প্রকারের ফুলের সর্বাধিক a[i] টি টব থাকতে পারে, এবং সাজানো\n    অবশ্যই ফুলের প্রকারের ক্রমবর্ধমান ক্রমে হতে হবে।\n\n    আর্গুমেন্টসমূহ:\n    - n (int): উপলব্ধ ফুলের প্রকারের সংখ্যা।\n    - m (int): সাজানোর জন্য মোট ফুলের টবের সংখ্যা।\n    - a (list of int): একটি তালিকা যেখানে a[i] হল iতম প্রকারের ফুলের জন্য সর্বাধিক টবের সংখ্যা।\n\n    রিটার্ন:\n    - int: পৃথক সাজানোর সংখ্যা মডুলো (10^6 + 7)।\n\n    উদাহরণ:\n    - calculate_arrangements(2, 4, [3, 2]) 2 রিটার্ন করে।\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 রিটার্ন করে।", "bg": "\n    Изчислете броя на начините за подреждане на m саксии с цветя, използвайки до n типа,\n    като i-тият тип може да има най-много a[i] саксии, а подреждането трябва да бъде в\n    нарастващ ред на типовете цветя.\n\n    Аргументи:\n    - n (int): Броят на наличните типове цветя.\n    - m (int): Общият брой саксии с цветя за подреждане.\n    - a (list of int): Списък, където a[i] е максималният брой саксии за i-тия тип цветя.\n\n    Връща:\n    - int: Броят на различните подреждания по модул (10^6 + 7).\n\n    Примери:\n    - calculate_arrangements(2, 4, [3, 2]) връща 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) връща 6.", "zh": "\n    计算使用最多 n 种类型的 m 个花盆的排列方式，其中第 i 种类型最多可以有 a[i] 个花盆，并且排列必须按照花的类型递增顺序。\n\n    参数:\n    - n (int): 可用的花的种类数。\n    - m (int): 要排列的花盆总数。\n    - a (list of int): 一个列表，其中 a[i] 是第 i 种花的最大花盆数。\n\n    返回:\n    - int: 不同排列的数量，结果取模 (10^6 + 7)。\n\n    示例:\n    - calculate_arrangements(2, 4, [3, 2]) 返回 2。\n    - calculate_arrangements(3, 3, [1, 2, 3]) 返回 6。", "fr": "\n    Calculer le nombre de façons d'arranger m pots de fleurs en utilisant jusqu'à n types,\n    où le ième type peut avoir au plus a[i] pots, et l'arrangement doit être dans\n    l'ordre croissant des types de fleurs.\n\n    Args:\n    - n (int): Le nombre de types de fleurs disponibles.\n    - m (int): Le nombre total de pots de fleurs à arranger.\n    - a (list of int): Une liste où a[i] est le nombre maximum de pots pour le ième type de fleur.\n\n    Returns:\n    - int: Le nombre d'arrangements distincts modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.", "de": "\n    Berechne die Anzahl der Möglichkeiten, m Blumentöpfe mit bis zu n Typen anzuordnen,\n    wobei der i-te Typ höchstens a[i] Töpfe haben kann und die Anordnung in\n    aufsteigender Reihenfolge der Blumentypen erfolgen muss.\n\n    Argumente:\n    - n (int): Die Anzahl der verfügbaren Blumentypen.\n    - m (int): Die Gesamtzahl der anzuordnenden Blumentöpfe.\n    - a (Liste von int): Eine Liste, in der a[i] die maximale Anzahl von Töpfen für den i-ten Blumentyp ist.\n\n    Rückgabe:\n    - int: Die Anzahl der unterschiedlichen Anordnungen modulo (10^6 + 7).\n\n    Beispiele:\n    - calculate_arrangements(2, 4, [3, 2]) gibt 2 zurück.\n    - calculate_arrangements(3, 3, [1, 2, 3]) gibt 6 zurück.", "ha": "\n    Lissafa adadin hanyoyin da za a tsara tukwane m na furanni ta amfani da har zuwa nau'ikan n,\n    inda nau'in na i na iya samun a kalla tukwane a[i], kuma tsarawa dole ne ya kasance a cikin\n    tsari mai karuwa na nau'ikan furanni.\n\n    Args:\n    - n (int): Adadin nau'ikan furanni da ake da su.\n    - m (int): Jimillar adadin tukwane na furanni da za a tsara.\n    - a (list of int): Jerin inda a[i] shine mafi yawan tukwane don nau'in furanni na i.\n\n    Returns:\n    - int: Adadin tsaruka masu bambanci modulo (10^6 + 7).\n\n    Misalai:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.", "hi": "\n    m गमलों को n प्रकारों तक का उपयोग करके फूलों की व्यवस्था करने के तरीकों की संख्या की गणना करें,\n    जहाँ ith प्रकार में अधिकतम a[i] गमले हो सकते हैं, और व्यवस्था फूलों के प्रकारों के बढ़ते क्रम में होनी चाहिए।\n\n    तर्क:\n    - n (int): उपलब्ध फूलों के प्रकारों की संख्या।\n    - m (int): कुल गमलों की संख्या जिन्हें व्यवस्थित करना है।\n    - a (list of int): एक सूची जहाँ a[i] ith प्रकार के फूल के लिए गमलों की अधिकतम संख्या है।\n\n    लौटाता है:\n    - int: विशिष्ट व्यवस्थाओं की संख्या, (10^6 + 7) के मापांक के साथ।\n\n    उदाहरण:\n    - calculate_arrangements(2, 4, [3, 2]) 2 लौटाता है।\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 लौटाता है।", "hu": "\n    Számítsuk ki, hányféleképpen lehet elrendezni m virágcserepet legfeljebb n típus felhasználásával, ahol az i-edik típusnak legfeljebb a[i] cserép lehet, és az elrendezésnek növekvő sorrendben kell lennie a virágtípusok szerint.\n\n    Paraméterek:\n    - n (int): A rendelkezésre álló virágtípusok száma.\n    - m (int): Az elrendezendő virágcserepek teljes száma.\n    - a (list of int): Egy lista, ahol a[i] az i-edik virágtípus maximális cserépszáma.\n\n    Visszatér:\n    - int: A különböző elrendezések száma modulo (10^6 + 7).\n\n    Példák:\n    - calculate_arrangements(2, 4, [3, 2]) visszaadja 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) visszaadja 6.", "es": "    Calcular el número de formas de organizar m macetas de flores usando hasta n tipos,\n    donde el tipo i puede tener como máximo a[i] macetas, y la disposición debe estar en\n    orden creciente de tipos de flores.\n\n    Argumentos:\n    - n (int): El número de tipos de flores disponibles.\n    - m (int): El número total de macetas de flores a organizar.\n    - a (list of int): Una lista donde a[i] es el número máximo de macetas para el tipo i de flor.\n\n    Devuelve:\n    - int: El número de disposiciones distintas módulo (10^6 + 7).\n\n    Ejemplos:\n    - calculate_arrangements(2, 4, [3, 2]) devuelve 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) devuelve 6.", "arb": "    حساب عدد الطرق لترتيب m من الأواني الزهرية باستخدام ما يصل إلى n من الأنواع،\n    حيث يمكن أن يحتوي النوع i على a[i] من الأواني كحد أقصى، ويجب أن يكون الترتيب\n    بترتيب تصاعدي لأنواع الزهور.\n\n    يعيدالحجج:\n    - n (int): عدد أنواع الزهور المتاحة.\n    - m (int): العدد الإجمالي للأواني الزهرية لترتيبها.\n    - a (list of int): قائمة حيث a[i] هو العدد الأقصى من الأواني لنوع الزهرة i.\n\n    يعيد:\n    - int: عدد الترتيبات المختلفة موديولو (10^6 + 7).\n\n    امثله:\n    - calculate_arrangements(2, 4, [3, 2]) يعيد 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) يعيد 6.", "sw": "Hesabu idadi ya njia za kupanga sufuria m za maua kwa kutumia hadi aina n, ambapo aina ya ith inaweza kuwa na sufuria a[i] kwa zaidi, na mpangilio lazima uwe kwa mpangilio wa aina za maua unaoongezeka.\n\nHoja:\n- n (int): Idadi ya aina za maua zinazopatikana.\n- m (int): Jumla ya idadi ya sufuria za maua za kupanga.\n- a (orodha ya int): Orodha ambapo a[i] ni idadi ya juu ya sufuria kwa aina ya ith ya maua.\n\nInarejesha:\n- int: Idadi ya mipangilio tofauti modulo (10^6 + 7).\n\nMifano:\n- calculate_arrangements(2, 4, [3, 2]) inarudisha 2.\n- calculate_arrangements(3, 3, [1, 2, 3]) inarudisha 6.", "tr": "Çiçek türlerinin artan sırasına göre düzenlemenin gerektiği durumda, en fazla n türü kullanarak m çiçek saksısını düzenlemenin yollarının sayısını hesaplayın. Burada i'inci tür en fazla a[i] saksıya sahip olabilir.\n\nArgümanlar:\n- n (int): Mevcut çiçek türlerinin sayısı.\n- m (int): Düzenlenecek toplam çiçek saksısı sayısı.\n- a (list of int): a[i], i'inci çiçek türü için maksimum saksı sayısını belirten bir listedir.\n\nDöndürür:\n- int: Farklı düzenlemelerin sayısı mod (10^6 + 7).\n\nÖrnekler:\n- calculate_arrangements(2, 4, [3, 2]) 2 döndürür.\n- calculate_arrangements(3, 3, [1, 2, 3]) 6 döndürür.", "vi": "Tính số cách sắp xếp m chậu hoa sử dụng tối đa n loại,\ntrong đó loại thứ i có thể có tối đa a[i] chậu, và cách sắp xếp phải theo\nthứ tự tăng dần của các loại hoa.\n\nTham số:\n- n (int): Số lượng loại hoa có sẵn.\n- m (int): Tổng số chậu hoa cần sắp xếp.\n- a (list of int): Danh sách mà a[i] là số lượng chậu tối đa cho loại hoa thứ i.\n\nTrả về:\n- int: Số lượng cách sắp xếp khác nhau theo modulo (10^6 + 7).\n\nVí dụ:\n- calculate_arrangements(2, 4, [3, 2]) trả về 2.\n- calculate_arrangements(3, 3, [1, 2, 3]) trả về 6.", "id": "Menghitung jumlah cara untuk menyusun m pot bunga menggunakan hingga n jenis,\ndi mana jenis ke-i dapat memiliki paling banyak a[i] pot, dan susunan harus dalam\nurutan menaik dari jenis bunga.\n\nArgs:\n- n (int): Jumlah jenis bunga yang tersedia.\n- m (int): Jumlah total pot bunga yang akan disusun.\n- a (list of int): Daftar di mana a[i] adalah jumlah maksimum pot untuk jenis bunga ke-i.\n\nReturns:\n- int: Jumlah susunan yang berbeda modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) mengembalikan 2.\n- calculate_arrangements(3, 3, [1, 2, 3]) mengembalikan 6.", "ja": "花の種類を最大n種類使用してm個の花鉢を配置する方法の数を計算します。ここで、i番目の種類は最大でa[i]個の鉢を持つことができ、配置は花の種類の昇順でなければなりません。\n\nArgs:\n- n (int): 利用可能な花の種類の数。\n- m (int): 配置する花鉢の総数。\n- a (list of int): a[i]がi番目の花の種類の最大鉢数であるリスト。\n\nReturns:\n- int: 異なる配置の数を(10^6 + 7)で割った余り。\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) は2を返します。\n- calculate_arrangements(3, 3, [1, 2, 3]) は6を返します。", "ko": "꽃병 m개를 최대 n개의 종류를 사용하여 배열하는 방법의 수를 계산합니다. 여기서 i번째 종류는 최대 a[i]개의 꽃병을 가질 수 있으며, 배열은 꽃 종류의 증가하는 순서로 이루어져야 합니다.\n\nArgs:\n- n (int): 사용 가능한 꽃 종류의 수.\n- m (int): 배열할 꽃병의 총 수.\n- a (list of int): a[i]가 i번째 종류의 꽃에 대한 최대 꽃병 수인 리스트.\n\nReturns:\n- int: 서로 다른 배열의 수를 (10^6 + 7)로 나눈 나머지.\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2])는 2를 반환합니다.\n- calculate_arrangements(3, 3, [1, 2, 3])는 6을 반환합니다.", "ml": "    m പുഷ്പക്കുടങ്ങൾ ക്രമീകരിക്കുന്നതിനുള്ള മാർഗങ്ങളുടെ എണ്ണം കണക്കാക്കുക, n തരം വരെ ഉപയോഗിച്ച്, \n    ഇവിടെ i-ാം തരം പരമാവധി a[i] പാത്രങ്ങൾക്കുള്ളതായിരിക്കാം, കൂടാതെ ക്രമീകരണം പുഷ്പ തരം വർദ്ധിക്കുന്ന \n    ക്രമത്തിൽ ആയിരിക്കണം.\n\n    Arguments:\n    - n (int): ലഭ്യമായ പുഷ്പ തരം.\n    - m (int): ക്രമീകരിക്കേണ്ട പുഷ്പക്കുടങ്ങളുടെ ആകെ എണ്ണം.\n    - a (list of int): a[i] എന്നത് i-ാം തരം പുഷ്പത്തിനുള്ള പരമാവധി പാത്രങ്ങളുടെ എണ്ണം സൂചിപ്പിക്കുന്ന ഒരു ലിസ്റ്റ്.\n\n    Returns:\n    - int: വ്യത്യസ്ത ക്രമീകരണങ്ങളുടെ എണ്ണം (10^6 + 7) ന്റെ മോഡുലോ.\n\n    ഉദാഹരണങ്ങൾ:\n    - calculate_arrangements(2, 4, [3, 2]) 2 നു മടങ്ങുന്നു.\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 നു മടങ്ങുന്നു.", "fa": "    محاسبه تعداد روش‌های چیدمان m گلدان گل با استفاده از حداکثر n نوع،\n    به طوری که نوع iام می‌تواند حداکثر a[i] گلدان داشته باشد و چیدمان باید\n    به ترتیب صعودی نوع گل‌ها باشد.\n\n    آرگومان‌ها:\n    - n (int): تعداد انواع گل‌های موجود.\n    - m (int): تعداد کل گلدان‌های گل برای چیدمان.\n    - a (list of int): لیستی که در آن a[i] حداکثر تعداد گلدان‌ها برای نوع iام گل است.\n\n    بازگشت:\n    - int: تعداد چیدمان‌های متمایز به پیمانه (10^6 + 7).\n\n    مثال‌ها:\n    - calculate_arrangements(2, 4, [3, 2]) مقدار 2 را برمی‌گرداند.\n    - calculate_arrangements(3, 3, [1, 2, 3]) مقدار 6 را برمی‌گرداند."}}
{"task_id": "Python/40", "prompt": {"en": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "sq": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Dekripton një tekst të koduar me shifrën Vigenère duke përdorur çelësin e dhënë.\n    \n    Shifra Vigenère është një metodë për të koduar tekstin alfabetik duke përdorur një seri\n    shifrash Caesar bazuar në shkronjat e një fjale kyçe. Kjo funksion kthen procesin\n    për të rikuperuar tekstin origjinal nga teksti i koduar.\n\n    Args:\n        key (str): Çelësi i enkriptimit i përdorur për të koduar tekstin origjinal.\n                   Ky çelës duhet të përmbajë vetëm karaktere alfabetike.\n        ciphertext (str): Teksti i koduar që duhet të dekriptohet.\n                          Teksti i koduar duhet të përmbajë vetëm karaktere alfabetike.\n\n    Returns:\n        str: Teksti i dekriptuar që korrespondon me tekstin e koduar të dhënë.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "hy": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Վերջնական տեքստի ապակոդավորումը, որը կոդավորված է Վիժեների շիֆրով օգտագործելով տրամադրված բանալին։\n    \n    Վիժեների շիֆրը այբբենական տեքստի կոդավորման մեթոդ է, որը օգտագործում է Կեսարի շիֆրերի շարք՝ հիմնված բանալի բառի տառերի վրա։ Այս ֆունկցիան հակադարձում է գործընթացը՝ վերականգնելու սկզբնական տեքստը կոդավորված տեքստից։\n\n    Արգումենտներ:\n        key (str): Կոդավորման բանալին, որը օգտագործվել է սկզբնական տեքստը կոդավորելու համար։\n                   Այս բանալին պետք է պարունակի միայն այբբենական նիշեր։\n        ciphertext (str): Կոդավորված տեքստը, որը պետք է ապակոդավորվի։\n                          Կոդավորված տեքստը պետք է պարունակի միայն այբբենական նիշեր։\n\n    Վերադարձնում է:\n        str: Ապակոդավորված տեքստը, որը համապատասխանում է մուտքային կոդավորված տեքստին։\n\n    Օրինակներ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "bn": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    প্রদত্ত কী ব্যবহার করে ভিজেনার সাইফার দিয়ে এনক্রিপ্ট করা সাইফারটেক্সট ডিক্রিপ্ট করে।\n\n    ভিজেনার সাইফার হল একটি পদ্ধতি যা একটি কীওয়ার্ডের অক্ষরগুলির উপর ভিত্তি করে\n    সিজার সাইফারের একটি সিরিজ ব্যবহার করে বর্ণমালার পাঠ্য এনক্রিপ্ট করে। \n    এই ফাংশনটি প্রক্রিয়াটি উল্টে দেয় যাতে সাইফারটেক্সট থেকে মূল প্লেইনটেক্সট পুনরুদ্ধার করা যায়।\n\n    আর্গুমেন্টস:\n        key (str): মূল প্লেইনটেক্সট এনক্রিপ্ট করতে ব্যবহৃত এনক্রিপশন কী।\n                   এই কী শুধুমাত্র বর্ণমালার অক্ষর নিয়ে গঠিত হওয়া উচিত।\n        ciphertext (str): এনক্রিপ্ট করা পাঠ্য যা ডিক্রিপ্ট করা প্রয়োজন।\n                          সাইফারটেক্সট শুধুমাত্র বর্ণমালার অক্ষর নিয়ে গঠিত হওয়া উচিত।\n\n    রিটার্নস:\n        str: ইনপুট সাইফারটেক্সটের সাথে সম্পর্কিত ডিক্রিপ্ট করা প্লেইনটেক্সট।\n\n    উদাহরণ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "bg": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Дешифрира шифротекст, криптиран с шифъра на Виженер, използвайки предоставения ключ.\n    \n    Шифърът на Виженер е метод за криптиране на азбучен текст чрез използване на серия от\n    шифри на Цезар, базирани на буквите от ключова дума. Тази функция обръща процеса,\n    за да възстанови оригиналния обикновен текст от шифротекста.\n\n    Аргументи:\n        key (str): Ключът за криптиране, използван за криптиране на оригиналния обикновен текст.\n                   Този ключ трябва да се състои само от азбучни символи.\n        ciphertext (str): Криптираният текст, който трябва да бъде дешифриран.\n                          Шифротекстът трябва да се състои само от азбучни символи.\n\n    Връща:\n        str: Дешифрираният обикновен текст, съответстващ на входния шифротекст.\n\n    Примери:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "zh": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    使用提供的密钥解密用维吉尼亚密码加密的密文。\n    \n    维吉尼亚密码是一种通过使用基于关键词字母的凯撒密码系列来加密字母文本的方法。\n    此函数反转该过程以从密文中恢复原始明文。\n\n    参数:\n        key (str): 用于加密原始明文的加密密钥。\n                   此密钥应仅由字母字符组成。\n        ciphertext (str): 需要解密的加密文本。\n                          密文应仅由字母字符组成。\n\n    返回:\n        str: 与输入密文对应的解密明文。\n\n    示例:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "fr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Déchiffre un texte chiffré avec le chiffre de Vigenère en utilisant la clé fournie.\n    \n    Le chiffre de Vigenère est une méthode de chiffrement de texte alphabétique en utilisant une série de\n    chiffres de César basés sur les lettres d'un mot-clé. Cette fonction inverse le processus\n    pour récupérer le texte en clair original à partir du texte chiffré.\n\n    Args:\n        key (str): La clé de chiffrement utilisée pour chiffrer le texte en clair original.\n                   Cette clé doit être composée uniquement de caractères alphabétiques.\n        ciphertext (str): Le texte chiffré qui doit être déchiffré.\n                          Le texte chiffré doit être composé uniquement de caractères alphabétiques.\n\n    Returns:\n        str: Le texte en clair déchiffré correspondant au texte chiffré d'entrée.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "de": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Entschlüsselt einen mit der Vigenère-Verschlüsselung verschlüsselten Geheimtext unter Verwendung des bereitgestellten Schlüssels.\n    \n    Die Vigenère-Verschlüsselung ist eine Methode zur Verschlüsselung von alphabetischem Text durch die Verwendung einer Reihe von\n    Caesar-Verschlüsselungen, die auf den Buchstaben eines Schlüsselworts basieren. Diese Funktion kehrt den Prozess um,\n    um den ursprünglichen Klartext aus dem Geheimtext wiederherzustellen.\n\n    Argumente:\n        key (str): Der Verschlüsselungsschlüssel, der zur Verschlüsselung des ursprünglichen Klartexts verwendet wurde.\n                   Dieser Schlüssel sollte nur aus alphabetischen Zeichen bestehen.\n        ciphertext (str): Der verschlüsselte Text, der entschlüsselt werden muss.\n                          Der Geheimtext sollte nur aus alphabetischen Zeichen bestehen.\n\n    Rückgabe:\n        str: Der entschlüsselte Klartext, der dem Eingabe-Geheimtext entspricht.\n\n    Beispiele:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "ha": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Sakewa rubutun da aka ɓoye tare da Vigenère cipher ta amfani da mabuɗin da aka bayar.\n    \n    Vigenère cipher wata hanya ce ta ɓoye rubutun haruffa ta amfani da jerin\n    Caesar ciphers bisa ga haruffan kalmar sirri. Wannan aikin yana juyar da tsarin\n    don dawo da ainihin rubutun daga rubutun da aka ɓoye.\n\n    Args:\n        key (str): Mabuɗin ɓoyewa da aka yi amfani da shi don ɓoye ainihin rubutun.\n                   Wannan mabuɗin ya kamata ya ƙunshi haruffa kawai.\n        ciphertext (str): Rubutun da aka ɓoye wanda ake buƙatar a sakewa.\n                          Rubutun da aka ɓoye ya kamata ya ƙunshi haruffa kawai.\n\n    Returns:\n        str: Rubutun da aka sakewa wanda ya dace da rubutun da aka bayar.\n\n    Misalai:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "hi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    दिए गए कुंजी का उपयोग करके Vigenère सिफर से एन्क्रिप्ट किए गए सिफरटेक्स्ट को डिक्रिप्ट करता है।\n    \n    Vigenère सिफर एक कीवर्ड के अक्षरों के आधार पर सीज़र सिफर की एक श्रृंखला का उपयोग करके वर्णमाला पाठ को एन्क्रिप्ट करने की एक विधि है। \n    यह फ़ंक्शन प्रक्रिया को उलट देता है ताकि सिफरटेक्स्ट से मूल प्लेनटेक्स्ट को पुनः प्राप्त किया जा सके।\n\n    Args:\n        key (str): एन्क्रिप्शन कुंजी जिसका उपयोग मूल प्लेनटेक्स्ट को एन्क्रिप्ट करने के लिए किया गया था।\n                   इस कुंजी में केवल वर्णमाला के अक्षर होने चाहिए।\n        ciphertext (str): एन्क्रिप्ट किया गया पाठ जिसे डिक्रिप्ट करने की आवश्यकता है।\n                          सिफरटेक्स्ट में केवल वर्णमाला के अक्षर होने चाहिए।\n\n    Returns:\n        str: इनपुट सिफरटेक्स्ट के अनुरूप डिक्रिप्ट किया गया प्लेनटेक्स्ट।\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "hu": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Egy Vigenère-rejtjel segítségével titkosított szöveg visszafejtése a megadott kulcs használatával.\n    \n    A Vigenère-rejtjel egy módszer az alfabetikus szöveg titkosítására, amely egy kulcsszó betűin alapuló\n    Caesar-rejtvények sorozatát használja. Ez a függvény visszafordítja a folyamatot, hogy visszanyerje\n    az eredeti szöveget a titkosított szövegből.\n\n    Paraméterek:\n        key (str): Az eredeti szöveg titkosításához használt kulcs.\n                   Ez a kulcs csak alfabetikus karaktereket tartalmazhat.\n        ciphertext (str): A visszafejtendő titkosított szöveg.\n                          A titkosított szöveg csak alfabetikus karaktereket tartalmazhat.\n\n    Visszatér:\n        str: A visszafejtett szöveg, amely megfelel a bemeneti titkosított szövegnek.\n\n    Példák:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "es": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Descifra un texto cifrado con el cifrado de Vigenère utilizando la clave proporcionada.\n    \n    El cifrado de Vigenère es un método de cifrado de texto alfabético mediante el uso de una serie de\n    cifrados César basados en las letras de una palabra clave. Esta función revierte el proceso\n    para recuperar el texto original a partir del texto cifrado.\n\n    Argumentos:\n        key (str): La clave de cifrado utilizada para cifrar el texto original.\n                   Esta clave debe consistir solo en caracteres alfabéticos.\n        ciphertext (str): El texto cifrado que necesita ser descifrado.\n                          El texto cifrado debe consistir solo en caracteres alfabéticos.\n\n    Devuelve:\n        str: El texto descifrado correspondiente al texto cifrado de entrada.\n\n    Ejemplos:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "arb": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    يفك تشفير النص المشفر باستخدام شفرة فيجنير باستخدام المفتاح المقدم.\n    \n    شفرة فيجنير هي طريقة لتشفير النصوص الأبجدية باستخدام سلسلة من شفرات قيصر\n    بناءً على حروف كلمة مفتاحية. تقوم هذه الدالة بعكس العملية لاستعادة النص الأصلي\n    من النص المشفر.\n\n    يعيدالحجج:\n        key (str): المفتاح المستخدم لتشفير النص الأصلي.\n                   يجب أن يتكون هذا المفتاح فقط من حروف أبجدية.\n        ciphertext (str): النص المشفر الذي يحتاج إلى فك تشفير.\n                          يجب أن يتكون النص المشفر فقط من حروف أبجدية.\n\n    يعيد:\n        str: النص الأصلي المفكوك تشفيره والذي يتوافق مع النص المشفر المدخل.\n\n    امثله:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "sw": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Inafungua maandishi ya siri yaliyofichwa kwa kutumia Vigenère cipher kwa kutumia ufunguo uliotolewa.\n    \n    Vigenère cipher ni mbinu ya kuficha maandishi ya alfabeti kwa kutumia mfululizo wa\n    Caesar ciphers kulingana na herufi za neno la ufunguo. Kazi hii inarudisha mchakato\n    ili kurejesha maandishi asilia kutoka kwa maandishi ya siri.\n\n    Hoja:\n        key (str): Ufunguo wa usimbaji ulio tumika kuficha maandishi asilia.\n                   Ufunguo huu unapaswa kuwa na herufi za alfabeti pekee.\n        ciphertext (str): Maandishi ya siri yanayohitaji kufunguliwa.\n                          Maandishi ya siri yanapaswa kuwa na herufi za alfabeti pekee.\n\n    Inarejesha:\n        str: Maandishi asilia yaliyofunguliwa yanayolingana na maandishi ya siri yaliyoingizwa.\n\n    Mifano:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "tr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Sağlanan anahtarı kullanarak Vigenère şifreleme yöntemiyle şifrelenmiş bir şifreli metni çözer.\n    \n    Vigenère şifreleme, alfabetik metni bir anahtar kelimenin harflerine dayanan bir dizi Caesar şifresi kullanarak şifreleme yöntemidir.\n    Bu fonksiyon, şifreli metinden orijinal düz metni geri kazanmak için işlemi tersine çevirir.\n\n    Argümanlar:\n        key (str): Orijinal düz metni şifrelemek için kullanılan şifreleme anahtarı.\n                   Bu anahtar yalnızca alfabetik karakterlerden oluşmalıdır.\n        ciphertext (str): Çözülmesi gereken şifreli metin.\n                          Şifreli metin yalnızca alfabetik karakterlerden oluşmalıdır.\n\n    Döndürür:\n        str: Girdi şifreli metnine karşılık gelen çözülmüş düz metin.\n\n    Örnekler:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "vi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Giải mã một văn bản mã hóa bằng mật mã Vigenère sử dụng khóa được cung cấp.\n    \n    Mật mã Vigenère là một phương pháp mã hóa văn bản chữ cái bằng cách sử dụng một loạt\n    các mật mã Caesar dựa trên các chữ cái của một từ khóa. Hàm này đảo ngược quá trình\n    để khôi phục văn bản gốc từ văn bản mã hóa.\n\n    Tham số:\n        key (str): Khóa mã hóa được sử dụng để mã hóa văn bản gốc.\n                   Khóa này chỉ nên bao gồm các ký tự chữ cái.\n        ciphertext (str): Văn bản mã hóa cần được giải mã.\n                          Văn bản mã hóa chỉ nên bao gồm các ký tự chữ cái.\n\n    Trả về:\n        str: Văn bản gốc đã được giải mã tương ứng với văn bản mã hóa đầu vào.\n\n    Ví dụ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "id": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Mendekripsi sebuah ciphertext yang dienkripsi dengan sandi Vigenère menggunakan kunci yang diberikan.\n    \n    Sandi Vigenère adalah metode enkripsi teks alfabet dengan menggunakan serangkaian\n    sandi Caesar berdasarkan huruf dari sebuah kata kunci. Fungsi ini membalikkan proses\n    untuk memulihkan plaintext asli dari ciphertext.\n\n    Args:\n        key (str): Kunci enkripsi yang digunakan untuk mengenkripsi plaintext asli.\n                   Kunci ini harus hanya terdiri dari karakter alfabet.\n        ciphertext (str): Teks terenkripsi yang perlu didekripsi.\n                          Ciphertext harus hanya terdiri dari karakter alfabet.\n\n    Returns:\n        str: Plaintext yang telah didekripsi yang sesuai dengan input ciphertext.\n\n    Contoh:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "ja": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    提供されたキーを使用して、ヴィジュネル暗号で暗号化された暗号文を復号します。\n    \n    ヴィジュネル暗号は、キーワードの文字に基づいた一連のシーザー暗号を使用して\n    アルファベットのテキストを暗号化する方法です。この関数はそのプロセスを逆にして、\n    暗号文から元の平文を復元します。\n\n    Args:\n        key (str): 元の平文を暗号化するために使用された暗号キー。\n                   このキーはアルファベットの文字のみで構成されている必要があります。\n        ciphertext (str): 復号する必要のある暗号化されたテキスト。\n                          暗号文はアルファベットの文字のみで構成されている必要があります。\n\n    Returns:\n        str: 入力された暗号文に対応する復号された平文。\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "ko": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    제공된 키를 사용하여 비제네르 암호로 암호화된 암호문을 복호화합니다.\n    \n    비제네르 암호는 키워드의 문자에 기반한 일련의 시저 암호를 사용하여 알파벳 텍스트를 암호화하는 방법입니다.\n    이 함수는 암호문에서 원래 평문을 복구하기 위해 이 과정을 반대로 수행합니다.\n\n    Args:\n        key (str): 원래 평문을 암호화하는 데 사용된 암호화 키.\n                   이 키는 알파벳 문자로만 구성되어야 합니다.\n        ciphertext (str): 복호화해야 하는 암호화된 텍스트.\n                          암호문은 알파벳 문자로만 구성되어야 합니다.\n\n    Returns:\n        str: 입력된 암호문에 해당하는 복호화된 평문.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "ml": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    നൽകിയ കീ ഉപയോഗിച്ച് Vigenère സൈഫർ ഉപയോഗിച്ച് എൻക്രിപ്റ്റ് ചെയ്ത സൈഫർടെക്സ്റ്റ് ഡീക്രിപ്റ്റ് ചെയ്യുന്നു.\n    \n    Vigenère സൈഫർ എന്നത് ഒരു കീവേഡ് ഉള്ള അക്ഷരമാലാ ടെക്സ്റ്റ് എൻക്രിപ്റ്റ് ചെയ്യാൻ സീസർ സൈഫറുകളുടെ ഒരു പരമ്പര ഉപയോഗിക്കുന്ന ഒരു രീതിയാണ്. \n    സൈഫർടെക്സ്റ്റിൽ നിന്ന് യഥാർത്ഥ പ്ലെയിൻടെക്സ്റ്റ് വീണ്ടെടുക്കാൻ ഈ ഫംഗ്ഷൻ പ്രക്രിയ മറിച്ചുനടത്തുന്നു.\n\n    Args:\n        key (str): യഥാർത്ഥ പ്ലെയിൻടെക്സ്റ്റ് എൻക്രിപ്റ്റ് ചെയ്യാൻ ഉപയോഗിച്ച എൻക്രിപ്ഷൻ കീ.\n                   ഈ കീ അക്ഷരമാലാ പ്രതീകങ്ങൾ മാത്രം ഉൾക്കൊള്ളണം.\n        ciphertext (str): ഡീക്രിപ്റ്റ് ചെയ്യേണ്ട എൻക്രിപ്റ്റ് ചെയ്ത ടെക്സ്റ്റ്.\n                          സൈഫർടെക്സ്റ്റ് അക്ഷരമാലാ പ്രതീകങ്ങൾ മാത്രം ഉൾക്കൊള്ളണം.\n\n    Returns:\n        str: ഇൻപുട്ട് സൈഫർടെക്സ്റ്റിന് അനുയോജ്യമായ ഡീക്രിപ്റ്റ് ചെയ്ത പ്ലെയിൻടെക്സ്റ്റ്.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"", "fa": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    رمزگشایی یک متن رمز شده با رمز ویژنر با استفاده از کلید ارائه شده.\n\n    رمز ویژنر روشی برای رمزگذاری متن الفبایی است که با استفاده از یک سری\n    رمزهای سزار بر اساس حروف یک کلمه کلیدی انجام می‌شود. این تابع فرآیند را معکوس می‌کند\n    تا متن اصلی را از متن رمز شده بازیابی کند.\n\n    آرگومان‌ها:\n        key (str): کلید رمزگذاری که برای رمزگذاری متن اصلی استفاده شده است.\n                   این کلید باید فقط شامل حروف الفبایی باشد.\n        ciphertext (str): متنی که رمز شده و نیاز به رمزگشایی دارد.\n                          متن رمز شده باید فقط شامل حروف الفبایی باشد.\n\n    بازمی‌گرداند:\n        str: متن اصلی رمزگشایی شده که متناظر با متن رمز شده ورودی است.\n\n    مثال‌ها:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\""}, "canonical_solution": "    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)", "instruction": {"en": "Write a python function 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' to solve the following problem:\n\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    ", "sq": "Shkruani një funksion python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Dekripton një tekst të koduar me shifrën Vigenère duke përdorur çelësin e dhënë.\n    \n    Shifra Vigenère është një metodë e enkriptimit të tekstit alfabetik duke përdorur një seri\n    shifrash Caesar bazuar në shkronjat e një fjalë kyçe. Ky funksion kthen procesin\n    për të rikuperuar tekstin origjinal nga teksti i koduar.\n\n    Args:\n        key (str): Çelësi i enkriptimit i përdorur për të enkriptuar tekstin origjinal.\n                   Ky çelës duhet të përmbajë vetëm karaktere alfabetike.\n        ciphertext (str): Teksti i koduar që duhet të dekriptohet.\n                          Teksti i koduar duhet të përmbajë vetëm karaktere alfabetike.\n\n    Returns:\n        str: Teksti i dekriptuar që korrespondon me tekstin e koduar të dhënë.\n\n    Shembuj:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "hy": "Պայթոն ֆունկցիա 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Վիջենեռի ծածկագրով կոդավորված ծածկագիրը ապակոդավորում է օգտագործելով տրամադրված բանալին:\n    \n    Վիջենեռի ծածկագիրը այբբենական տեքստը կոդավորելու մեթոդ է՝ օգտագործելով Կեսարի \n    ծածկագրերի շարք, հիմնված բանալի բառի տառերի վրա: Այս ֆունկցիան հակադարձում է \n    գործընթացը՝ վերականգնելու սկզբնական պարզ տեքստը ծածկագրից:\n\n    Արձանագրեր:\n        key (str): Կոդավորման բանալին, որն օգտագործվել է սկզբնական պարզ տեքստը կոդավորելու համար:\n                   Այս բանալին պետք է բաղկացած լինի միայն այբբենական նիշերից:\n        ciphertext (str): Կոդավորված տեքստը, որը պետք է ապակոդավորվի:\n                          Ծածկագիրը պետք է բաղկացած լինի միայն այբբենական նիշերից:\n\n    Վերադարձնում է:\n        str: Ապակոդավորված պարզ տեքստը, որը համապատասխանում է մուտքային ծածկագրին:\n\n    Օրինակներ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "bn": "একটি পাইথন ফাংশন 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত কী ব্যবহার করে Vigenère cipher দিয়ে এনক্রিপ্ট করা একটি সাইফারটেক্সট ডিক্রিপ্ট করে।\n    \n    Vigenère cipher হল একটি পদ্ধতি যা একটি কীওয়ার্ডের অক্ষরগুলির উপর ভিত্তি করে একটি সিরিজ\n    সিজার সাইফার ব্যবহার করে বর্ণানুক্রমিক পাঠ্য এনক্রিপ্ট করে। এই ফাংশনটি প্রক্রিয়াটি বিপরীত\n    করে সাইফারটেক্সট থেকে মূল প্লেইনটেক্সট পুনরুদ্ধার করে।\n\n    Args:\n        key (str): মূল প্লেইনটেক্সট এনক্রিপ্ট করতে ব্যবহৃত এনক্রিপশন কী।\n                   এই কী শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n        ciphertext (str): এনক্রিপ্ট করা পাঠ্য যা ডিক্রিপ্ট করতে হবে।\n                          সাইফারটেক্সট শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n\n    Returns:\n        str: ইনপুট সাইফারটেক্সটের সাথে সম্পর্কিত ডিক্রিপ্ট করা প্লেইনটেক্সট।\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "bg": "Напишете функция на Python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' за решаване на следния проблем:\n\n    Декриптира шифротекст, криптиран с шифъра на Виженер, използвайки предоставения ключ.\n    \n    Шифърът на Виженер е метод за криптиране на азбучен текст чрез използване на серия от\n    Цезарови шифри, базирани на буквите на ключова дума. Тази функция обръща процеса\n    за възстановяване на оригиналния открит текст от шифротекста.\n\n    Аргументи:\n        key (str): Ключът за криптиране, използван за криптиране на оригиналния открит текст.\n                   Този ключ трябва да съдържа само азбучни символи.\n        ciphertext (str): Криптираният текст, който трябва да бъде декриптиран.\n                          Шифротекстът трябва да съдържа само азбучни символи.\n\n    Връща:\n        str: Декриптираният открит текст, съответстващ на входния шифротекст.\n\n    Примери:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "zh": "编写一个Python函数 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' 来解决以下问题：\n\n    使用提供的密钥解密用维吉尼亚密码加密的密文。\n    \n    维吉尼亚密码是一种通过使用基于关键字字母的一系列凯撒密码来加密字母文本的方法。此函数反转该过程以从密文中恢复原始明文。\n\n    参数：\n        key (str): 用于加密原始明文的加密密钥。\n                   此密钥应仅由字母字符组成。\n        ciphertext (str): 需要解密的加密文本。\n                          密文应仅由字母字符组成。\n\n    返回：\n        str: 与输入密文相对应的解密明文。\n\n    示例：\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "fr": "Écrivez une fonction python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' pour résoudre le problème suivant :\n\n    Décrypte un texte chiffré avec le chiffre de Vigenère en utilisant la clé fournie.\n    \n    Le chiffre de Vigenère est une méthode de chiffrement de texte alphabétique en utilisant une série de\n    chiffres de César basés sur les lettres d'un mot-clé. Cette fonction inverse le processus\n    pour récupérer le texte original à partir du texte chiffré.\n\n    Args:\n        key (str): La clé de chiffrement utilisée pour chiffrer le texte original.\n                   Cette clé doit être composée uniquement de caractères alphabétiques.\n        ciphertext (str): Le texte chiffré qui doit être déchiffré.\n                          Le texte chiffré doit être composé uniquement de caractères alphabétiques.\n\n    Returns:\n        str: Le texte déchiffré correspondant au texte chiffré d'entrée.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "de": "Schreiben Sie eine Python-Funktion 'def vigenere_decrypt(key: str, ciphertext: str) -> str:', um das folgende Problem zu lösen:\n\n    Entschlüsselt einen mit dem Vigenère-Chiffre verschlüsselten Geheimtext unter Verwendung des angegebenen Schlüssels.\n    \n    Das Vigenère-Chiffre ist eine Methode zur Verschlüsselung von alphabetischem Text durch die Verwendung einer Reihe von\n    Caesar-Chiffren basierend auf den Buchstaben eines Schlüsselworts. Diese Funktion kehrt den Prozess um,\n    um den ursprünglichen Klartext aus dem Geheimtext wiederherzustellen.\n\n    Argumente:\n        key (str): Der Verschlüsselungsschlüssel, der zur Verschlüsselung des ursprünglichen Klartexts verwendet wurde.\n                   Dieser Schlüssel sollte nur aus alphabetischen Zeichen bestehen.\n        ciphertext (str): Der verschlüsselte Text, der entschlüsselt werden muss.\n                          Der Geheimtext sollte nur aus alphabetischen Zeichen bestehen.\n\n    Rückgabe:\n        str: Der entschlüsselte Klartext, der dem Eingabe-Geheimtext entspricht.\n\n    Beispiele:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "ha": "Rubuta wani aikin python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' don warware matsalar mai zuwa:\n\n    Yana fassara rubutun da aka ɓoye tare da Vigenère cipher ta amfani da mabuɗin da aka bayar.\n    \n    Vigenère cipher wata hanya ce ta ɓoye rubutun haruffa ta amfani da jerin\n    Caesar ciphers bisa haruffan kalmar sirri. Wannan aikin yana juyar da tsarin\n    don dawo da ainihin rubutun daga rubutun da aka ɓoye.\n\n    Args:\n        key (str): Mabuɗin ɓoyewa da aka yi amfani da shi don ɓoye ainihin rubutun.\n                   Wannan mabuɗin ya kamata ya ƙunshi haruffa kawai.\n        ciphertext (str): Rubutun da aka ɓoye wanda ake buƙatar a fassara.\n                          Rubutun da aka ɓoye ya kamata ya ƙunshi haruffa kawai.\n\n    Returns:\n        str: Rubutun da aka fassara wanda ya dace da rubutun da aka shigar.\n\n    Misalai:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "hi": "एक पायथन फ़ंक्शन 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए कुंजी का उपयोग करके Vigenère सिफर के साथ एन्क्रिप्ट किए गए सिफरटेक्स्ट को डिक्रिप्ट करता है।\n    \n    Vigenère सिफर एक कीवर्ड के अक्षरों के आधार पर सीज़र सिफर की एक श्रृंखला का उपयोग करके वर्णमाला पाठ को एन्क्रिप्ट करने की एक विधि है। \n    यह फ़ंक्शन प्रक्रिया को उलट देता है ताकि सिफरटेक्स्ट से मूल प्लेनटेक्स्ट को पुनः प्राप्त किया जा सके।\n\n    तर्क:\n        key (str): एन्क्रिप्शन कुंजी जो मूल प्लेनटेक्स्ट को एन्क्रिप्ट करने के लिए उपयोग की गई थी।\n                   इस कुंजी में केवल वर्णमाला के अक्षर होने चाहिए।\n        ciphertext (str): एन्क्रिप्टेड पाठ जिसे डिक्रिप्ट करने की आवश्यकता है।\n                          सिफरटेक्स्ट में केवल वर्णमाला के अक्षर होने चाहिए।\n\n    लौटाता है:\n        str: इनपुट सिफरटेक्स्ट के अनुरूप डिक्रिप्ट किया गया प्लेनटेक्स्ट।\n\n    उदाहरण:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "hu": "Írj egy python függvényt 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' a következő probléma megoldására:\n\n    Visszafejt egy Vigenère titkosítással kódolt szöveget a megadott kulcs használatával.\n    \n    A Vigenère titkosítás egy módszer az alfabetikus szöveg titkosítására, amely egy kulcsszó betűin alapuló\n    Caesar-titkosítások sorozatát használja. Ez a függvény visszafordítja a folyamatot, hogy visszanyerje az\n    eredeti nyílt szöveget a titkosított szövegből.\n\n    Paraméterek:\n        key (str): Az eredeti nyílt szöveg titkosításához használt kulcs.\n                   Ennek a kulcsnak csak alfabetikus karakterekből kell állnia.\n        ciphertext (str): A titkosított szöveg, amelyet vissza kell fejteni.\n                          A titkosított szövegnek csak alfabetikus karakterekből kell állnia.\n\n    Visszatér:\n        str: A visszafejtett nyílt szöveg, amely megfelel a bemeneti titkosított szövegnek.\n\n    Példák:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "es": "Escribe una función de Python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' para resolver el siguiente problema:\n\n    Descifra un texto cifrado con el cifrado Vigenère utilizando la clave proporcionada.\n    \n    El cifrado Vigenère es un método de cifrado de texto alfabético que utiliza una serie de\n    cifrados César basados en las letras de una palabra clave. Esta función invierte el proceso\n    para recuperar el texto plano original del texto cifrado.\n\n    Argumentos:\n        key (str): La clave de cifrado utilizada para cifrar el texto plano original.\n                   Esta clave debe consistir solo en caracteres alfabéticos.\n        ciphertext (str): El texto cifrado que necesita ser descifrado.\n                          El texto cifrado debe consistir solo en caracteres alfabéticos.\n\n    Devuelve:\n        str: El texto plano descifrado correspondiente al texto cifrado de entrada.\n\n    Ejemplos:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "arb": "اكتب دالة بايثون 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' لحل المشكلة التالية:\n\n    يفك تشفير النص المشفر باستخدام شفرة فيجينير باستخدام المفتاح المقدم.\n    \n    شفرة فيجينير هي طريقة لتشفير النصوص الأبجدية باستخدام سلسلة من شفرات قيصر\n    بناءً على حروف كلمة مفتاحية. تقوم هذه الدالة بعكس العملية لاستعادة النص الأصلي\n    من النص المشفر.\n\n    يعيدالحجج:\n        key (str): مفتاح التشفير المستخدم لتشفير النص الأصلي.\n                   يجب أن يتكون هذا المفتاح فقط من حروف أبجدية.\n        ciphertext (str): النص المشفر الذي يحتاج إلى فك التشفير.\n                          يجب أن يتكون النص المشفر فقط من حروف أبجدية.\n\n    يعيد:\n        str: النص الأصلي المفكوك تشفيره الذي يتوافق مع النص المشفر المدخل.\n\n    أمثلة:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "sw": "Andika kazi ya python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' kutatua tatizo lifuatalo:\n\n    Kufungua maandishi yaliyofichwa kwa kutumia Vigenère cipher kwa kutumia ufunguo uliotolewa.\n    \n    Vigenère cipher ni mbinu ya kuficha maandishi ya alfabeti kwa kutumia mfululizo wa\n    Caesar ciphers kulingana na herufi za neno la ufunguo. Kazi hii inarudisha mchakato\n    ili kupata maandishi asilia kutoka kwa maandishi yaliyofichwa.\n\n    Hoja:\n        key (str): Ufunguo wa usimbaji uliotumika kuficha maandishi asilia.\n                   Ufunguo huu unapaswa kuwa na herufi za alfabeti pekee.\n        ciphertext (str): Maandishi yaliyofichwa yanayohitaji kufunguliwa.\n                          Maandishi yaliyofichwa yanapaswa kuwa na herufi za alfabeti pekee.\n\n    Inarejesha:\n        str: Maandishi asilia yaliyofunguliwa yanayolingana na maandishi yaliyofichwa yaliyoingizwa.\n\n    Mifano:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "tr": "Bir python fonksiyonu 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' yazın ve aşağıdaki problemi çözün:\n\n    Sağlanan anahtarı kullanarak Vigenère şifreleme yöntemiyle şifrelenmiş bir şifreli metni çözmek.\n    \n    Vigenère şifresi, bir anahtar kelimenin harflerine dayanan bir dizi Sezar şifresi kullanarak alfabetik metni şifreleme yöntemidir. Bu fonksiyon, şifreli metinden orijinal düz metni geri kazanmak için süreci tersine çevirir.\n\n    Argümanlar:\n        key (str): Orijinal düz metni şifrelemek için kullanılan şifreleme anahtarı.\n                   Bu anahtar yalnızca alfabetik karakterlerden oluşmalıdır.\n        ciphertext (str): Çözülmesi gereken şifreli metin.\n                          Şifreli metin yalnızca alfabetik karakterlerden oluşmalıdır.\n\n    Döndürür:\n        str: Girdi şifreli metnine karşılık gelen çözülmüş düz metin.\n\n    Örnekler:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "vi": "Viết một hàm python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' để giải quyết vấn đề sau:\n\n    Giải mã một văn bản mã hóa được mã hóa bằng mật mã Vigenère sử dụng khóa được cung cấp.\n    \n    Mật mã Vigenère là một phương pháp mã hóa văn bản chữ cái bằng cách sử dụng một loạt\n    mã hóa Caesar dựa trên các chữ cái của một từ khóa. Hàm này đảo ngược quá trình\n    để khôi phục văn bản gốc từ văn bản mã hóa.\n\n    Tham số:\n        key (str): Khóa mã hóa được sử dụng để mã hóa văn bản gốc.\n                   Khóa này chỉ nên bao gồm các ký tự chữ cái.\n        ciphertext (str): Văn bản mã hóa cần được giải mã.\n                          Văn bản mã hóa chỉ nên bao gồm các ký tự chữ cái.\n\n    Trả về:\n        str: Văn bản gốc đã được giải mã tương ứng với văn bản mã hóa đầu vào.\n\n    Ví dụ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "id": "Tulis sebuah fungsi python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' untuk menyelesaikan masalah berikut:\n\n    Mendekripsi sebuah ciphertext yang dienkripsi dengan sandi Vigenère menggunakan kunci yang diberikan.\n    \n    Sandi Vigenère adalah metode enkripsi teks alfabet dengan menggunakan serangkaian\n    sandi Caesar berdasarkan huruf dari sebuah kata kunci. Fungsi ini membalikkan proses tersebut\n    untuk memulihkan plaintext asli dari ciphertext.\n\n    Args:\n        key (str): Kunci enkripsi yang digunakan untuk mengenkripsi plaintext asli.\n                   Kunci ini harus hanya terdiri dari karakter alfabet.\n        ciphertext (str): Teks terenkripsi yang perlu didekripsi.\n                          Ciphertext harus hanya terdiri dari karakter alfabet.\n\n    Returns:\n        str: Plaintext yang didekripsi yang sesuai dengan input ciphertext.\n\n    Contoh:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "ja": "Python関数 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' を作成して、次の問題を解決してください:\n\n    提供されたキーを使用して、Vigenère暗号で暗号化された暗号文を復号します。\n    \n    Vigenère暗号は、キーワードの文字に基づいた一連のシーザー暗号を使用してアルファベットのテキストを暗号化する方法です。この関数は、暗号文から元の平文を復元するプロセスを逆にします。\n\n    引数:\n        key (str): 元の平文を暗号化するために使用された暗号キー。\n                   このキーはアルファベットの文字のみで構成されている必要があります。\n        ciphertext (str): 復号する必要がある暗号化されたテキスト。\n                          暗号文はアルファベットの文字のみで構成されている必要があります。\n\n    戻り値:\n        str: 入力された暗号文に対応する復号された平文。\n\n    例:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "ko": "파이썬 함수를 작성하세요 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' 다음 문제를 해결하기 위해:\n\n    제공된 키를 사용하여 비제네르 암호로 암호화된 암호문을 해독합니다.\n    \n    비제네르 암호는 키워드의 문자에 기반한 일련의 시저 암호를 사용하여\n    알파벳 텍스트를 암호화하는 방법입니다. 이 함수는 암호문에서 원래 평문을\n    복구하기 위해 이 과정을 반대로 수행합니다.\n\n    매개변수:\n        key (str): 원래 평문을 암호화하는 데 사용된 암호화 키.\n                   이 키는 알파벳 문자로만 구성되어야 합니다.\n        ciphertext (str): 해독해야 하는 암호화된 텍스트.\n                          암호문은 알파벳 문자로만 구성되어야 합니다.\n\n    반환값:\n        str: 입력된 암호문에 해당하는 해독된 평문.\n\n    예시:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "ml": "Python ഫങ്ഷൻ 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    നൽകിയിരിക്കുന്ന കീ ഉപയോഗിച്ച് Vigenère സൈഫർ ഉപയോഗിച്ച് എൻക്രിപ്റ്റ് ചെയ്ത സൈഫർടെക്സ്റ്റ് ഡിക്രിപ്റ്റ് ചെയ്യുന്നു.\n    \n    Vigenère സൈഫർ എന്നത് ഒരു കീവേഡിലെ അക്ഷരങ്ങളെ അടിസ്ഥാനമാക്കി സീസർ സൈഫറുകളുടെ ഒരു പരമ്പര ഉപയോഗിച്ച് അക്ഷരമാലാ ടെക്സ്റ്റ് എൻക്രിപ്റ്റ് ചെയ്യുന്ന ഒരു രീതിയാണ്. സൈഫർടെക്സ്റ്റിൽ നിന്ന് യഥാർത്ഥ പ്ലെയിൻടെക്സ്റ്റ് വീണ്ടെടുക്കാൻ ഈ ഫങ്ഷൻ പ്രക്രിയ പുനഃസ്ഥാപിക്കുന്നു.\n\n    Args:\n        key (str): യഥാർത്ഥ പ്ലെയിൻടെക്സ്റ്റ് എൻക്രിപ്റ്റ് ചെയ്യാൻ ഉപയോഗിച്ച എൻക്രിപ്ഷൻ കീ.\n                   ഈ കീ അക്ഷരമാലാ അക്ഷരങ്ങൾ മാത്രമേ അടങ്ങിയിരിക്കൂ.\n        ciphertext (str): ഡിക്രിപ്റ്റ് ചെയ്യേണ്ട എൻക്രിപ്റ്റ് ചെയ്ത ടെക്സ്റ്റ്.\n                          സൈഫർടെക്സ്റ്റ് അക്ഷരമാലാ അക്ഷരങ്ങൾ മാത്രമേ അടങ്ങിയിരിക്കൂ.\n\n    Returns:\n        str: ഇൻപുട്ട് സൈഫർടെക്സ്റ്റിനോട് അനുബന്ധിക്കുന്ന ഡിക്രിപ്റ്റ് ചെയ്ത പ്ലെയിൻടെക്സ്റ്റ്.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "fa": "یک تابع پایتون بنویسید 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' برای حل مسئله زیر:\n\n    رمزگشایی یک متن رمزگذاری شده با استفاده از رمز ویژنر با استفاده از کلید ارائه شده.\n    \n    رمز ویژنر روشی برای رمزگذاری متن الفبایی است که با استفاده از مجموعه‌ای از\n    رمزهای سزار بر اساس حروف یک کلمه کلیدی انجام می‌شود. این تابع فرآیند را معکوس می‌کند\n    تا متن اصلی را از متن رمزگذاری شده بازیابی کند.\n\n    آرگومان‌ها:\n        key (str): کلید رمزگذاری که برای رمزگذاری متن اصلی استفاده شده است.\n                   این کلید باید فقط شامل حروف الفبایی باشد.\n        ciphertext (str): متنی که رمزگذاری شده و نیاز به رمزگشایی دارد.\n                          متن رمزگذاری شده باید فقط شامل حروف الفبایی باشد.\n\n    بازگشت:\n        str: متن اصلی رمزگشایی شده که متناظر با متن رمزگذاری شده ورودی است.\n\n    مثال‌ها:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'"}, "level": "hard", "test": "def test_vigenere_decrypt():\n    # Test case 1: Example provided in the problem statement\n    key1 = \"CompleteVictory\"\n    ciphertext1 = \"Yvqgpxaimmklongnzfwpvxmniytm\"\n    expected_plaintext1 = \"Wherethereisawillthereisaway\"\n    assert vigenere_decrypt(key1, ciphertext1) == expected_plaintext1, \"Test case 1 failed\"\n\n    # Test case 2: All uppercase characters\n    key2 = \"ABC\"\n    ciphertext2 = \"DEF\"\n    expected_plaintext2 = \"DDD\"\n    assert vigenere_decrypt(key2, ciphertext2) == expected_plaintext2, \"Test case 2 failed\"\n\n    # Test case 3: All lowercase characters\n    key3 = \"xyz\"\n    ciphertext3 = \"abc\"\n    expected_plaintext3 = \"ddd\"\n    assert vigenere_decrypt(key3, ciphertext3) == expected_plaintext3, \"Test case 3 failed\"\n\n    # Test case 4: Mixed case characters\n    key4 = \"MiXeD\"\n    ciphertext4 = \"JpOeR\"\n    expected_plaintext4 = \"XhRaO\"\n    assert vigenere_decrypt(key4, ciphertext4) == expected_plaintext4, \"Test case 4 failed\"\n\n    # Test case 5: Key shorter than ciphertext\n    key5 = \"short\"\n    ciphertext5 = \"PqrsPqrsPq\"\n    expected_plaintext5 = \"XjdbWykeYx\"\n    assert vigenere_decrypt(key5, ciphertext5) == expected_plaintext5, \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_vigenere_decrypt()", "entry_point": "vigenere_decrypt", "signature": "def vigenere_decrypt(key: str, ciphertext: str) -> str:", "docstring": {"en": "\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    ", "sq": "\n    Dekriptimi i një teksti të koduar me shifrën Vigenère duke përdorur çelësin e dhënë.\n    \n    Shifra Vigenère është një metodë e kodimit të tekstit alfabetik duke përdorur një seri\n    shifrash Caesar bazuar në shkronjat e një fjale kyçe. Kjo funksion kthen procesin\n    për të rikuperuar tekstin origjinal nga teksti i koduar.\n\n    Argumentet:\n        key (str): Çelësi i kodimit i përdorur për të koduar tekstin origjinal.\n                   Ky çelës duhet të përmbajë vetëm karaktere alfabetike.\n        ciphertext (str): Teksti i koduar që duhet të dekriptohet.\n                          Teksti i koduar duhet të përmbajë vetëm karaktere alfabetike.\n\n    Kthen:\n        str: Teksti i dekriptuar që korrespondon me tekstin e koduar të dhënë.\n\n    Shembuj:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "hy": "\n    Վերծանում է Վիժեների ծածկագրով կոդավորված գաղտնագիրը՝ օգտագործելով տրամադրված բանալին։\n    \n    Վիժեների ծածկագիրը այբբենական տեքստի կոդավորման մեթոդ է, որը հիմնված է բանալի բառի տառերի վրա\n    Կեսարի մի շարք ծածկագրերի օգտագործմամբ։ Այս ֆունկցիան հակադարձում է գործընթացը՝\n    վերականգնելու սկզբնական պարզ տեքստը գաղտնագրից։\n\n    Արգումենտներ:\n        key (str): Կոդավորման բանալին, որը օգտագործվել է սկզբնական պարզ տեքստը կոդավորելու համար։\n                   Այս բանալին պետք է բաղկացած լինի միայն այբբենական նիշերից։\n        ciphertext (str): Կոդավորված տեքստը, որը պետք է վերծանել։\n                          Գաղտնագիրը պետք է բաղկացած լինի միայն այբբենական նիշերից։\n\n    Վերադարձնում է:\n        str: Վերծանված պարզ տեքստը, որը համապատասխանում է մուտքային գաղտնագրին։\n\n    Օրինակներ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "bn": "\n    প্রদত্ত কী ব্যবহার করে Vigenère সাইফার দিয়ে এনক্রিপ্ট করা সাইফারটেক্সট ডিক্রিপ্ট করে।\n    \n    Vigenère সাইফার হল একটি পদ্ধতি যা একটি কীওয়ার্ডের অক্ষরগুলির উপর ভিত্তি করে একাধিক Caesar সাইফার ব্যবহার করে বর্ণানুক্রমিক পাঠ্য এনক্রিপ্ট করে। \n    এই ফাংশন প্রক্রিয়াটি বিপরীত করে সাইফারটেক্সট থেকে মূল প্লেইনটেক্সট পুনরুদ্ধার করে।\n\n    আর্গুমেন্টস:\n        key (str): মূল প্লেইনটেক্সট এনক্রিপ্ট করতে ব্যবহৃত এনক্রিপশন কী।\n                   এই কী শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n        ciphertext (str): এনক্রিপ্ট করা পাঠ্য যা ডিক্রিপ্ট করা প্রয়োজন।\n                          সাইফারটেক্সট শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n\n    রিটার্নস:\n        str: ইনপুট সাইফারটেক্সটের সাথে সম্পর্কিত ডিক্রিপ্ট করা প্লেইনটেক্সট।\n\n    উদাহরণ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "bg": "\n    Декриптира шифротекст, шифрован с шифъра на Виженер, използвайки предоставения ключ.\n    \n    Шифърът на Виженер е метод за шифроване на азбучен текст чрез използване на серия от\n    шифри на Цезар, базирани на буквите от ключова дума. Тази функция обръща процеса,\n    за да възстанови оригиналния обикновен текст от шифротекста.\n\n    Аргументи:\n        key (str): Ключът за шифроване, използван за шифроване на оригиналния обикновен текст.\n                   Този ключ трябва да съдържа само азбучни символи.\n        ciphertext (str): Шифрован текст, който трябва да бъде декриптиран.\n                          Шифротекстът трябва да съдържа само азбучни символи.\n\n    Връща:\n        str: Декриптираният обикновен текст, съответстващ на входния шифротекст.\n\n    Примери:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "zh": "\n    使用提供的密钥解密用维吉尼亚密码加密的密文。\n    \n    维吉尼亚密码是一种通过使用基于关键字字母的凯撒密码系列来加密字母文本的方法。\n    此函数反转该过程以从密文中恢复原始明文。\n\n    参数:\n        key (str): 用于加密原始明文的加密密钥。\n                   此密钥应仅由字母字符组成。\n        ciphertext (str): 需要解密的加密文本。\n                          密文应仅由字母字符组成。\n\n    返回:\n        str: 与输入密文对应的解密明文。\n\n    示例:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "fr": "\n    Déchiffre un texte chiffré avec le chiffre de Vigenère en utilisant la clé fournie.\n    \n    Le chiffre de Vigenère est une méthode de chiffrement de texte alphabétique en utilisant une série de\n    chiffres de César basés sur les lettres d'un mot-clé. Cette fonction inverse le processus\n    pour récupérer le texte original à partir du texte chiffré.\n\n    Args:\n        key (str): La clé de chiffrement utilisée pour chiffrer le texte original.\n                   Cette clé doit être composée uniquement de caractères alphabétiques.\n        ciphertext (str): Le texte chiffré qui doit être déchiffré.\n                          Le texte chiffré doit être composé uniquement de caractères alphabétiques.\n\n    Returns:\n        str: Le texte déchiffré correspondant au texte chiffré d'entrée.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "de": "\n    Entschlüsselt einen mit der Vigenère-Verschlüsselung verschlüsselten Geheimtext unter Verwendung des bereitgestellten Schlüssels.\n    \n    Die Vigenère-Verschlüsselung ist eine Methode zur Verschlüsselung von alphabetischem Text durch die Verwendung einer Reihe von Caesar-Verschlüsselungen basierend auf den Buchstaben eines Schlüsselworts. Diese Funktion kehrt den Prozess um, um den ursprünglichen Klartext aus dem Geheimtext wiederherzustellen.\n\n    Argumente:\n        key (str): Der Verschlüsselungsschlüssel, der zur Verschlüsselung des ursprünglichen Klartexts verwendet wurde.\n                   Dieser Schlüssel sollte nur aus alphabetischen Zeichen bestehen.\n        ciphertext (str): Der verschlüsselte Text, der entschlüsselt werden muss.\n                          Der Geheimtext sollte nur aus alphabetischen Zeichen bestehen.\n\n    Rückgabewert:\n        str: Der entschlüsselte Klartext, der dem Eingabe-Geheimtext entspricht.\n\n    Beispiele:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "ha": "\n    Fassar da rubutun da aka ɓoye tare da Vigenère cipher ta amfani da mabuɗin da aka bayar.\n    \n    Vigenère cipher wata hanya ce ta ɓoye rubutun haruffa ta hanyar amfani da jerin\n    Caesar ciphers bisa kan haruffan kalmar sirri. Wannan aikin yana juyar da tsarin\n    don dawo da ainihin rubutun daga rubutun da aka ɓoye.\n\n    Args:\n        key (str): Mabuɗin ɓoyewa da aka yi amfani da shi don ɓoye ainihin rubutun.\n                   Wannan mabuɗin ya kamata ya ƙunshi haruffa kawai.\n        ciphertext (str): Rubutun da aka ɓoye wanda ake buƙatar a fassara.\n                          Rubutun da aka ɓoye ya kamata ya ƙunshi haruffa kawai.\n\n    Returns:\n        str: Rubutun da aka fassara wanda ya dace da rubutun da aka bayar.\n\n    Misalai:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "hi": "\n    दिए गए कुंजी का उपयोग करके Vigenère सिफर के साथ एन्क्रिप्ट किए गए सिफरटेक्स्ट को डिक्रिप्ट करता है।\n    \n    Vigenère सिफर वर्णमाला पाठ को एन्क्रिप्ट करने की एक विधि है जो एक कुंजी शब्द के अक्षरों पर आधारित\n    कई Caesar सिफर का उपयोग करती है। यह फ़ंक्शन प्रक्रिया को उलटता है ताकि सिफरटेक्स्ट से मूल प्लेनटेक्स्ट\n    को पुनः प्राप्त किया जा सके।\n\n    तर्क:\n        key (str): एन्क्रिप्शन कुंजी जिसका उपयोग मूल प्लेनटेक्स्ट को एन्क्रिप्ट करने के लिए किया गया था।\n                   इस कुंजी में केवल वर्णमाला के अक्षर होने चाहिए।\n        ciphertext (str): एन्क्रिप्ट किया गया पाठ जिसे डिक्रिप्ट करने की आवश्यकता है।\n                          सिफरटेक्स्ट में केवल वर्णमाला के अक्षर होने चाहिए।\n\n    वापसी:\n        str: इनपुट सिफरटेक्स्ट के अनुरूप डिक्रिप्ट किया गया प्लेनटेक्स्ट।\n\n    उदाहरण:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "hu": "\n    Dekódolja a Vigenère-rejtjel segítségével titkosított rejtjelezett szöveget a megadott kulcs használatával.\n    \n    A Vigenère-rejtjel egy módszer az alfabetikus szöveg titkosítására, amely egy kulcsszó betűin alapuló\n    Caesar-rejtjelek sorozatát használja. Ez a függvény visszafordítja a folyamatot, hogy visszanyerje az\n    eredeti nyílt szöveget a rejtjelezett szövegből.\n\n    Paraméterek:\n        key (str): Az eredeti nyílt szöveg titkosítására használt kulcs.\n                   Ennek a kulcsnak csak alfabetikus karaktereket kell tartalmaznia.\n        ciphertext (str): A dekódolni kívánt titkosított szöveg.\n                          A rejtjelezett szövegnek csak alfabetikus karaktereket kell tartalmaznia.\n\n    Visszatér:\n        str: A bemeneti rejtjelezett szövegnek megfelelő dekódolt nyílt szöveg.\n\n    Példák:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "es": "    Descifra un texto cifrado con el cifrado de Vigenère utilizando la clave proporcionada.\n    \n    El cifrado de Vigenère es un método de cifrado de texto alfabético mediante el uso de una serie de\n    cifrados de César basados en las letras de una palabra clave. Esta función revierte el proceso\n    para recuperar el texto original a partir del texto cifrado.\n\n    Argumentos:\n        key (str): La clave de cifrado utilizada para cifrar el texto original.\n                   Esta clave debe consistir solo en caracteres alfabéticos.\n        ciphertext (str): El texto cifrado que necesita ser descifrado.\n                          El texto cifrado debe consistir solo en caracteres alfabéticos.\n\n    Devuelve:\n        str: El texto descifrado correspondiente al texto cifrado de entrada.\n\n    Ejemplos:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "arb": "    يفك تشفير النص المشفر باستخدام شفرة فيجينير باستخدام المفتاح المقدم.\n    \n    شفرة فيجينير هي طريقة لتشفير النصوص الأبجدية باستخدام سلسلة من شفرات قيصر\n    بناءً على حروف كلمة مفتاحية. تقوم هذه الدالة بعكس العملية لاستعادة النص الأصلي\n    من النص المشفر.\n\n    يعيدالحجج:\n        key (str): مفتاح التشفير المستخدم لتشفير النص الأصلي.\n                   يجب أن يتكون هذا المفتاح من حروف أبجدية فقط.\n        ciphertext (str): النص المشفر الذي يحتاج إلى فك تشفيره.\n                          يجب أن يتكون النص المشفر من حروف أبجدية فقط.\n\n    يعيد:\n        str: النص الأصلي المفكوك تشفيره والمطابق للنص المشفر المدخل.\n\n    امثله:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "sw": "    Inafungua maandishi yaliyofichwa kwa kutumia Vigenère cipher kwa kutumia ufunguo uliotolewa.\n    \n    Vigenère cipher ni mbinu ya kuficha maandishi ya alfabeti kwa kutumia mfululizo wa\n    Caesar ciphers kulingana na herufi za neno kuu. Kazi hii inarudisha mchakato\n    ili kurejesha maandishi asilia kutoka kwenye maandishi yaliyofichwa.\n\n    Hoja:\n        key (str): Ufunguo wa usimbaji ulio tumika kuficha maandishi asilia.\n                   Ufunguo huu unapaswa kuwa na herufi za alfabeti pekee.\n        ciphertext (str): Maandishi yaliyofichwa ambayo yanahitaji kufunguliwa.\n                          Maandishi yaliyofichwa yanapaswa kuwa na herufi za alfabeti pekee.\n\n    Inarejesha:\n        str: Maandishi asilia yaliyofunguliwa yanayolingana na maandishi yaliyofichwa yaliyoingizwa.\n\n    Mifano:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "tr": "    Sağlanan anahtarı kullanarak Vigenère şifresiyle şifrelenmiş bir şifreli metni çözer.\n\n    Vigenère şifresi, bir anahtar kelimenin harflerine dayalı bir dizi Sezar şifresi kullanarak alfabetik metni şifreleme yöntemidir. Bu fonksiyon, şifreli metinden orijinal düz metni geri kazanmak için süreci tersine çevirir.\n\n    Argümanlar:\n        key (str): Orijinal düz metni şifrelemek için kullanılan şifreleme anahtarı.\n                   Bu anahtar yalnızca alfabetik karakterlerden oluşmalıdır.\n        ciphertext (str): Çözülmesi gereken şifreli metin.\n                          Şifreli metin yalnızca alfabetik karakterlerden oluşmalıdır.\n\n    Döndürür:\n        str: Girdi şifreli metnine karşılık gelen çözülmüş düz metin.\n\n    Örnekler:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "vi": "Giải mã một văn bản mã hóa được mã hóa bằng mật mã Vigenère sử dụng khóa được cung cấp.\n\nMật mã Vigenère là một phương pháp mã hóa văn bản chữ cái bằng cách sử dụng một chuỗi các mật mã Caesar dựa trên các chữ cái của một từ khóa. Hàm này đảo ngược quá trình để khôi phục văn bản gốc từ văn bản mã hóa.\n\nTham số:\n    key (str): Khóa mã hóa được sử dụng để mã hóa văn bản gốc.\n               Khóa này chỉ nên bao gồm các ký tự chữ cái.\n    ciphertext (str): Văn bản mã hóa cần được giải mã.\n                      Văn bản mã hóa chỉ nên bao gồm các ký tự chữ cái.\n\nTrả về:\n    str: Văn bản gốc đã được giải mã tương ứng với văn bản mã hóa đầu vào.\n\nVí dụ:\n    >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n    'Wherethereisawillthereisaway'\n\n    >>> vigenere_decrypt(\"ABC\", \"DEF\")\n    'DCB'", "id": "Mendekripsi teks sandi yang dienkripsi dengan sandi Vigenère menggunakan kunci yang disediakan.\n\nSandi Vigenère adalah metode enkripsi teks alfabet dengan menggunakan serangkaian sandi Caesar berdasarkan huruf dari kata kunci. Fungsi ini membalikkan proses tersebut untuk memulihkan teks asli dari teks sandi.\n\nArgs:\n    key (str): Kunci enkripsi yang digunakan untuk mengenkripsi teks asli.\n               Kunci ini harus hanya terdiri dari karakter alfabet.\n    ciphertext (str): Teks terenkripsi yang perlu didekripsi.\n                      Teks sandi harus hanya terdiri dari karakter alfabet.\n\nReturns:\n    str: Teks asli yang didekripsi sesuai dengan teks sandi yang dimasukkan.\n\nExamples:\n    >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n    'Wherethereisawillthereisaway'\n\n    >>> vigenere_decrypt(\"ABC\", \"DEF\")\n    'DCB'", "ja": "    提供された鍵を使用して、ヴィジュネル暗号で暗号化された暗号文を復号します。\n    \n    ヴィジュネル暗号は、キーワードの文字に基づく一連のシーザー暗号を使用してアルファベットのテキストを暗号化する方法です。この関数はそのプロセスを逆にして、暗号文から元の平文を復元します。\n\n    引数:\n        key (str): 元の平文を暗号化するために使用された暗号鍵。\n                   この鍵はアルファベット文字のみで構成されている必要があります。\n        ciphertext (str): 復号する必要がある暗号化されたテキスト。\n                          暗号文はアルファベット文字のみで構成されている必要があります。\n\n    戻り値:\n        str: 入力された暗号文に対応する復号された平文。\n\n    例:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "ko": "암호문을 제공된 키를 사용하여 비제네르 암호로 복호화합니다.\n\n비제네르 암호는 키워드의 문자에 기반한 일련의 시저 암호를 사용하여 알파벳 텍스트를 암호화하는 방법입니다. 이 함수는 암호문에서 원래 평문을 복구하기 위해 이 과정을 역으로 수행합니다.\n\nArgs:\n    key (str): 원래 평문을 암호화하는 데 사용된 암호화 키.\n               이 키는 알파벳 문자로만 구성되어야 합니다.\n    ciphertext (str): 복호화가 필요한 암호화된 텍스트.\n                      암호문은 알파벳 문자로만 구성되어야 합니다.\n\nReturns:\n    str: 입력 암호문에 해당하는 복호화된 평문.\n\nExamples:\n    >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n    'Wherethereisawillthereisaway'\n\n    >>> vigenere_decrypt(\"ABC\", \"DEF\")\n    'DCB'", "ml": "    നൽകിയ കീ ഉപയോഗിച്ച് Vigenère സൈഫർ ഉപയോഗിച്ച് എൻക്രിപ്റ്റ് ചെയ്ത സൈഫർടെക്സ്റ്റ് ഡീക്രിപ്റ്റ് ചെയ്യുന്നു.\n    \n    Vigenère സൈഫർ എന്നത് ഒരു കീവേഡിന്റെ അക്ഷരങ്ങളെ അടിസ്ഥാനമാക്കി സീസർ സൈഫറുകളുടെ ഒരു പരമ്പര ഉപയോഗിച്ച് അക്ഷരമാലാ ടെക്സ്റ്റ് എൻക്രിപ്റ്റ് ചെയ്യാനുള്ള ഒരു രീതിയാണ്. സൈഫർടെക്സ്റ്റിൽ നിന്ന് യഥാർത്ഥ പ്ലെയിൻടെക്സ്റ്റ് വീണ്ടെടുക്കാൻ ഈ ഫംഗ്ഷൻ പ്രക്രിയ മറിച്ചുവയ്ക്കുന്നു.\n\n    Args:\n        key (str): യഥാർത്ഥ പ്ലെയിൻടെക്സ്റ്റ് എൻക്രിപ്റ്റ് ചെയ്യാൻ ഉപയോഗിച്ച എൻക്രിപ്ഷൻ കീ.\n                   ഈ കീ അക്ഷരമാലാ അക്ഷരങ്ങൾ മാത്രമേ അടങ്ങിയിരിക്കൂ.\n        ciphertext (str): ഡീക്രിപ്റ്റ് ചെയ്യേണ്ട എൻക്രിപ്റ്റ് ചെയ്ത ടെക്സ്റ്റ്.\n                          സൈഫർടെക്സ്റ്റ് അക്ഷരമാലാ അക്ഷരങ്ങൾ മാത്രമേ അടങ്ങിയിരിക്കൂ.\n\n    Returns:\n        str: ഇൻപുട്ട് സൈഫർടെക്സ്റ്റിനോട് അനുബന്ധിച്ച ഡീക്രിപ്റ്റ് ചെയ്ത പ്ലെയിൻടെക്സ്റ്റ്.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'", "fa": "    رمزنگاری شده با رمز ویژنر را با استفاده از کلید ارائه شده رمزگشایی می‌کند.\n    \n    رمز ویژنر روشی برای رمزنگاری متن الفبایی است که با استفاده از مجموعه‌ای از\n    رمزهای سزار بر اساس حروف یک کلمه کلیدی انجام می‌شود. این تابع فرآیند را معکوس می‌کند\n    تا متن اصلی را از متن رمزنگاری شده بازیابی کند.\n\n    Args:\n        key (str): کلید رمزنگاری که برای رمزنگاری متن اصلی استفاده شده است.\n                   این کلید باید فقط شامل حروف الفبایی باشد.\n        ciphertext (str): متنی که رمزنگاری شده و نیاز به رمزگشایی دارد.\n                          متن رمزنگاری شده باید فقط شامل حروف الفبایی باشد.\n\n    Returns:\n        str: متن اصلی رمزگشایی شده که متن رمزنگاری شده ورودی را نشان می‌دهد.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'"}}
{"task_id": "Python/41", "prompt": {"en": "def mod_inverse(a, b):\n    \"\"\"\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "sq": "def mod_inverse(a, b):\n    \"\"\"\n    Llogarit inversin modular multiplikativ të `a` modulo `b`.\n    \n    Kjo funksion gjen një numër të plotë `x` të tillë që (a * x) % b == 1, me kusht që\n    `a` dhe `b` të jenë bashkëkryesorë (d.m.th., gcd(a, b) == 1). Përdor Algoritmin e Zgjeruar të Euklidit\n    për të llogaritur inversin. Nëse `a` dhe `b` nuk janë bashkëkryesorë, inversi modular nuk ekziston, dhe funksioni kthen `None`.\n    \n    Argumentet:\n      a (int): Numri i plotë për të cilin do të gjendet inversi modular.\n      b (int): Moduli me të cilin kërkohet inversi.\n    \n    Kthen:\n      int: Inversi modular i `a` modulo `b` nëse ekziston, përndryshe `None`.\n    \n    Shembuj:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "hy": "def mod_inverse(a, b):\n    \"\"\"\n    Հաշվել `a`-ի մոդուլային բազմապատկիչ հակադարձը `b`-ի մոդուլով:\n    \n    Այս ֆունկցիան գտնում է այնպիսի ամբողջ թիվ `x`, որ (a * x) % b == 1, ենթադրելով, որ\n    `a` և `b` փոխադարձաբար պարզ են (այսինքն՝ gcd(a, b) == 1): Այն օգտագործում է ընդլայնված\n    Եվկլիդյան ալգորիթմը հակադարձը հաշվարկելու համար: Եթե `a` և `b` փոխադարձաբար պարզ չեն,\n    ապա մոդուլային հակադարձը գոյություն չունի, և ֆունկցիան վերադարձնում է `None`:\n    \n    Արգումենտներ:\n      a (int): Ամբողջ թիվ, որի մոդուլային հակադարձը պետք է գտնվի:\n      b (int): Մոդուլը, որի նկատմամբ հակադարձը փնտրվում է:\n    \n    Վերադարձնում է:\n      int: `a`-ի մոդուլային հակադարձը `b`-ի մոդուլով, եթե այն գոյություն ունի, հակառակ դեպքում `None`:\n    \n    Օրինակներ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "bn": "def mod_inverse(a, b):\n    \"\"\"\n    `a` এর মডুলার গুণনীয় বিপরীত `b` মডুলোর হিসাব করুন।\n    \n    এই ফাংশন একটি পূর্ণসংখ্যা `x` খুঁজে বের করে যাতে (a * x) % b == 1 হয়, যদি\n    `a` এবং `b` পরস্পর সহমৌলিক হয় (অর্থাৎ, gcd(a, b) == 1)। এটি Extended Euclidean\n    Algorithm ব্যবহার করে বিপরীত হিসাব করে। যদি `a` এবং `b` পরস্পর সহমৌলিক না হয়, \n    তাহলে মডুলার বিপরীত থাকে না, এবং ফাংশন `None` প্রদান করে।\n    \n    Args:\n      a (int): পূর্ণসংখ্যা যার মডুলার বিপরীত খুঁজে বের করতে হবে।\n      b (int): মডুলাস যার সাথে বিপরীত খোঁজা হচ্ছে।\n    \n    Returns:\n      int: যদি থাকে তবে `a` এর মডুলার বিপরীত `b` মডুলোর, অন্যথায় `None`।\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "bg": "def mod_inverse(a, b):\n    \"\"\"\n    Изчисляване на модулната мултипликативна обратна стойност на `a` модул `b`.\n    \n    Тази функция намира цяло число `x` такова, че (a * x) % b == 1, при условие че\n    `a` и `b` са взаимно прости (т.е., gcd(a, b) == 1). Използва разширения алгоритъм на Евклид\n    за изчисляване на обратната стойност. Ако `a` и `b` не са взаимно прости, модулната\n    обратна стойност не съществува и функцията връща `None`.\n    \n    Аргументи:\n      a (int): Цялото число, чиято модулна обратна стойност трябва да бъде намерена.\n      b (int): Модулът, спрямо който се търси обратната стойност.\n    \n    Връща:\n      int: Модулната обратна стойност на `a` модул `b`, ако съществува, в противен случай `None`.\n    \n    Примери:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "zh": "def mod_inverse(a, b):\n    \"\"\"\n    计算 `a` 模 `b` 的模逆。\n    \n    此函数找到一个整数 `x`，使得 (a * x) % b == 1，前提是 `a` 和 `b` 互质（即 gcd(a, b) == 1）。\n    它使用扩展欧几里得算法来计算逆元。如果 `a` 和 `b` 不是互质的，则模逆不存在，函数返回 `None`。\n    \n    参数:\n      a (int): 要找到模逆的整数。\n      b (int): 寻找逆元的模数。\n    \n    返回:\n      int: 如果存在，则为 `a` 模 `b` 的模逆，否则为 `None`。\n    \n    示例:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "fr": "def mod_inverse(a, b):\n    \"\"\"\n    Calculer l'inverse multiplicatif modulaire de `a` modulo `b`.\n    \n    Cette fonction trouve un entier `x` tel que (a * x) % b == 1, à condition que\n    `a` et `b` soient premiers entre eux (c'est-à-dire, gcd(a, b) == 1). Elle utilise\n    l'algorithme d'Euclide étendu pour calculer l'inverse. Si `a` et `b` ne sont pas\n    premiers entre eux, l'inverse modulaire n'existe pas, et la fonction retourne `None`.\n    \n    Arguments:\n      a (int): L'entier dont l'inverse modulaire doit être trouvé.\n      b (int): Le module par rapport auquel l'inverse est recherché.\n    \n    Retourne:\n      int: L'inverse modulaire de `a` modulo `b` s'il existe, sinon `None`.\n    \n    Exemples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "de": "def mod_inverse(a, b):\n    \"\"\"\n    Berechne das modulare multiplikative Inverse von `a` modulo `b`.\n    \n    Diese Funktion findet eine ganze Zahl `x`, sodass (a * x) % b == 1, vorausgesetzt,\n    `a` und `b` sind teilerfremd (d.h., gcd(a, b) == 1). Sie verwendet den erweiterten\n    euklidischen Algorithmus, um das Inverse zu berechnen. Wenn `a` und `b` nicht\n    teilerfremd sind, existiert das modulare Inverse nicht, und die Funktion gibt `None` zurück.\n    \n    Argumente:\n      a (int): Die ganze Zahl, deren modulares Inverse gefunden werden soll.\n      b (int): Der Modulus, bezüglich dessen das Inverse gesucht wird.\n    \n    Rückgabewert:\n      int: Das modulare Inverse von `a` modulo `b`, falls es existiert, ansonsten `None`.\n    \n    Beispiele:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "ha": "def mod_inverse(a, b):\n    \"\"\"\n    Lissafi modular multiplicative inverse na `a` modulo `b`.\n    \n    Wannan aikin yana nemo wani cikakken lamba `x` wanda (a * x) % b == 1, idan aka ba da cewa\n    `a` da `b` ba su da rabo (watau, gcd(a, b) == 1). Yana amfani da Tsarin Euclidean\n    Algorithm don lissafa inverse. Idan `a` da `b` ba su da rabo, to modular\n    inverse ba ya wanzu, kuma aikin yana dawowa da `None`.\n    \n    Args:\n      a (int): Cikakken lambar da za a nemo modular inverse ɗinta.\n      b (int): Modulus wanda za a nema inverse dangane da shi.\n    \n    Returns:\n      int: Modular inverse na `a` modulo `b` idan yana wanzu, in ba haka ba `None`.\n    \n    Misalai:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "hi": "def mod_inverse(a, b):\n    \"\"\"\n    `a` का `b` के मापांक के साथ गुणात्मक प्रतिलोम गणना करें।\n    \n    यह फ़ंक्शन एक पूर्णांक `x` ढूंढता है ताकि (a * x) % b == 1 हो, बशर्ते कि\n    `a` और `b` सहप्राइम हों (अर्थात, gcd(a, b) == 1)। यह प्रतिलोम की गणना के लिए\n    विस्तारित यूक्लिडियन एल्गोरिदम का उपयोग करता है। यदि `a` और `b` सहप्राइम नहीं हैं,\n    तो गुणात्मक प्रतिलोम मौजूद नहीं होता है, और फ़ंक्शन `None` लौटाता है।\n    \n    तर्क:\n      a (int): वह पूर्णांक जिसका गुणात्मक प्रतिलोम ढूंढना है।\n      b (int): वह मापांक जिसके संदर्भ में प्रतिलोम खोजा जा रहा है।\n    \n    लौटाता है:\n      int: यदि `a` का `b` के मापांक के साथ गुणात्मक प्रतिलोम मौजूद है तो उसे लौटाता है, अन्यथा `None`।\n    \n    उदाहरण:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "hu": "def mod_inverse(a, b):\n    \"\"\"\n    Számítsa ki `a` moduláris multiplikatív inverzét `b` modulo szerint.\n    \n    Ez a függvény olyan egész számot talál `x`, amelyre (a * x) % b == 1, feltéve, hogy\n    `a` és `b` relatív prímek (azaz gcd(a, b) == 1). Az inverz kiszámításához az\n    kiterjesztett euklideszi algoritmust használja. Ha `a` és `b` nem relatív prímek,\n    a moduláris inverz nem létezik, és a függvény `None`-t ad vissza.\n    \n    Paraméterek:\n      a (int): Az egész szám, amelynek moduláris inverzét meg kell találni.\n      b (int): A modulus, amelyhez képest az inverz keresendő.\n    \n    Visszatér:\n      int: `a` moduláris inverze `b` modulo szerint, ha létezik, különben `None`.\n    \n    Példák:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "es": "def mod_inverse(a, b):\n    \"\"\"\n    Calcular el inverso multiplicativo modular de `a` módulo `b`.\n    \n    Esta función encuentra un entero `x` tal que (a * x) % b == 1, siempre que\n    `a` y `b` sean coprimos (es decir, gcd(a, b) == 1). Utiliza el Algoritmo\n    Euclidiano Extendido para calcular el inverso. Si `a` y `b` no son coprimos,\n    el inverso modular no existe, y la función devuelve `None`.\n    \n    Argumentos:\n      a (int): El entero cuyo inverso modular se va a encontrar.\n      b (int): El módulo respecto al cual se busca el inverso.\n    \n    Devuelve:\n      int: El inverso modular de `a` módulo `b` si existe, de lo contrario `None`.\n    \n    Ejemplos:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "arb": "def mod_inverse(a, b):\n    \"\"\"\n    حساب المعكوس الضربي المعياري لـ `a` بالنسبة لـ `b`.\n    \n    هذه الدالة تجد عدداً صحيحاً `x` بحيث يكون (a * x) % b == 1، بشرط أن يكون\n    `a` و `b` أوليين فيما بينهما (أي أن gcd(a, b) == 1). تستخدم خوارزمية\n    إقليدس الموسعة لحساب المعكوس. إذا لم يكن `a` و `b` أوليين فيما بينهما، فإن\n    المعكوس المعياري لا يوجد، وتعيد الدالة `None`.\n    \n    يعيدالحجج:\n      a (int): العدد الصحيح الذي يراد إيجاد معكوسه المعياري.\n      b (int): المودولوس الذي يُبحث بالنسبة له عن المعكوس.\n    \n    يعيد:\n      int: المعكوس المعياري لـ `a` بالنسبة لـ `b` إذا كان موجوداً، وإلا `None`.\n    \n    امثله:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "sw": "def mod_inverse(a, b):\n    \"\"\"\n    Kuhesabu kinyume cha kuzidisha cha moduli cha `a` modulo `b`.\n    \n    Kazi hii inapata namba nzima `x` kama kwamba (a * x) % b == 1, mradi\n    `a` na `b` ni coprime (yaani, gcd(a, b) == 1). Inatumia Algorithm ya Euclidean\n    Iliyoenea ili kuhesabu kinyume. Ikiwa `a` na `b` si coprime, kinyume cha moduli\n    hakipo, na kazi inarudisha `None`.\n    \n    Hoja:\n      a (int): Namba nzima ambayo kinyume cha moduli kinapaswa kupatikana.\n      b (int): Moduli ambayo kinyume kinatafutwa.\n    \n    Inarejesha:\n      int: Kinyume cha moduli cha `a` modulo `b` ikiwa kipo, vinginevyo `None`.\n    \n    Mifano:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "tr": "def mod_inverse(a, b):\n    \"\"\"\n    `a` sayısının `b` modülüne göre modüler çarpımsal tersini hesapla.\n    \n    Bu fonksiyon, (a * x) % b == 1 olacak şekilde bir tamsayı `x` bulur, \n    `a` ve `b` aralarında asal olduğunda (yani, gcd(a, b) == 1). \n    Tersi hesaplamak için Genişletilmiş Öklid Algoritması'nı kullanır. \n    Eğer `a` ve `b` aralarında asal değilse, modüler ters yoktur ve \n    fonksiyon `None` döner.\n    \n    Argümanlar:\n      a (int): Modüler tersi bulunacak tamsayı.\n      b (int): Tersinin arandığı modül.\n    \n    Döndürür:\n      int: `a` sayısının `b` modülüne göre modüler tersi varsa, aksi takdirde `None`.\n    \n    Örnekler:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "vi": "def mod_inverse(a, b):\n    \"\"\"\n    Tính nghịch đảo nhân modulo của `a` modulo `b`.\n    \n    Hàm này tìm một số nguyên `x` sao cho (a * x) % b == 1, với điều kiện\n    `a` và `b` là nguyên tố cùng nhau (tức là, gcd(a, b) == 1). Nó sử dụng\n    Thuật toán Euclid mở rộng để tính nghịch đảo. Nếu `a` và `b` không phải\n    là nguyên tố cùng nhau, nghịch đảo modulo không tồn tại, và hàm trả về `None`.\n    \n    Tham số:\n      a (int): Số nguyên cần tìm nghịch đảo modulo.\n      b (int): Modulus mà nghịch đảo được tìm kiếm.\n    \n    Trả về:\n      int: Nghịch đảo modulo của `a` modulo `b` nếu tồn tại, ngược lại `None`.\n    \n    Ví dụ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "id": "def mod_inverse(a, b):\n    \"\"\"\n    Hitung invers perkalian modular dari `a` modulo `b`.\n    \n    Fungsi ini menemukan bilangan bulat `x` sehingga (a * x) % b == 1, dengan syarat\n    `a` dan `b` adalah coprime (yaitu, gcd(a, b) == 1). Ini menggunakan Algoritma\n    Euclidean yang Diperluas untuk menghitung invers. Jika `a` dan `b` bukan coprime,\n    invers modular tidak ada, dan fungsi mengembalikan `None`.\n    \n    Args:\n      a (int): Bilangan bulat yang invers modularnya akan ditemukan.\n      b (int): Modulus sehubungan dengan mana invers dicari.\n    \n    Returns:\n      int: Invers modular dari `a` modulo `b` jika ada, jika tidak `None`.\n    \n    Contoh:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "ja": "def mod_inverse(a, b):\n    \"\"\"\n    `a`の`b`におけるモジュラ乗法逆数を計算します。\n    \n    この関数は、(a * x) % b == 1 となる整数 `x` を見つけます。ただし、\n    `a` と `b` は互いに素である必要があります（つまり、gcd(a, b) == 1）。\n    拡張ユークリッドのアルゴリズムを使用して逆数を計算します。\n    `a` と `b` が互いに素でない場合、モジュラ逆数は存在せず、関数は `None` を返します。\n    \n    引数:\n      a (int): モジュラ逆数を見つける整数。\n      b (int): 逆数を求めるための法。\n    \n    戻り値:\n      int: 存在する場合は`a`の`b`におけるモジュラ逆数、存在しない場合は`None`。\n    \n    例:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "ko": "def mod_inverse(a, b):\n    \"\"\"\n    `a`의 모듈러 곱셈 역원을 `b` 모듈로 계산합니다.\n    \n    이 함수는 (a * x) % b == 1이 되는 정수 `x`를 찾습니다. 여기서 `a`와 `b`는 서로소여야 합니다\n    (즉, gcd(a, b) == 1). 확장 유클리드 알고리즘을 사용하여 역원을 계산합니다. \n    `a`와 `b`가 서로소가 아닌 경우, 모듈러 역원은 존재하지 않으며 함수는 `None`을 반환합니다.\n    \n    인수:\n      a (int): 모듈러 역원을 찾고자 하는 정수.\n      b (int): 역원을 구하고자 하는 모듈러.\n    \n    반환:\n      int: `a`의 모듈러 역원이 존재하면 그 값을 반환하고, 그렇지 않으면 `None`을 반환합니다.\n    \n    예제:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "ml": "def mod_inverse(a, b):\n    \"\"\"\n    `a` ന്റെ `b` മോടുലോയിലെ ഗുണിതക പ്രതിലോമം കണക്കാക്കുക.\n    \n    ഈ ഫംഗ്ഷൻ (a * x) % b == 1 എന്നതിനെ തൃപ്തിപ്പെടുത്തുന്ന ഒരു പൂർണ്ണസംഖ്യ `x` കണ്ടെത്തുന്നു, \n    `a`യും `b`യും പരസ്പര പ്രധാനമാണെങ്കിൽ (അഥവാ, gcd(a, b) == 1). പ്രതിലോമം കണക്കാക്കാൻ \n    വിപുലമായ യൂക്ലിഡിയൻ ആൽഗോരിതം ഉപയോഗിക്കുന്നു. `a`യും `b`യും പരസ്പര പ്രധാനമല്ലെങ്കിൽ, \n    മോടുലോ പ്രതിലോമം നിലവിലില്ല, ഫംഗ്ഷൻ `None` മടക്കുന്നു.\n    \n    Args:\n      a (int): മോടുലോ പ്രതിലോമം കണ്ടെത്തേണ്ട പൂർണ്ണസംഖ്യ.\n      b (int): പ്രതിലോമം തേടുന്ന മോടുലസ്.\n    \n    Returns:\n      int: `a` ന്റെ `b` മോടുലോയിലെ പ്രതിലോമം നിലവിലുണ്ടെങ്കിൽ, അല്ലെങ്കിൽ `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"", "fa": "def mod_inverse(a, b):\n    \"\"\"\n    محاسبه معکوس ضربی مدولار `a` به پیمانه `b`.\n    \n    این تابع یک عدد صحیح `x` را پیدا می‌کند به طوری که (a * x) % b == 1، به شرطی که\n    `a` و `b` نسبت به هم اول باشند (یعنی gcd(a, b) == 1). این تابع از\n    الگوریتم توسعه‌یافته اقلیدسی برای محاسبه معکوس استفاده می‌کند. اگر `a` و `b` نسبت به هم اول نباشند، \n    معکوس مدولار وجود ندارد و تابع `None` را برمی‌گرداند.\n    \n    آرگومان‌ها:\n      a (int): عدد صحیحی که معکوس مدولار آن باید پیدا شود.\n      b (int): پیمانه‌ای که معکوس نسبت به آن جستجو می‌شود.\n    \n    بازگشت:\n      int: معکوس مدولار `a` به پیمانه `b` اگر وجود داشته باشد، در غیر این صورت `None`.\n    \n    مثال‌ها:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\""}, "canonical_solution": "    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b", "instruction": {"en": "Write a python function 'def mod_inverse(a, b):' to solve the following problem:\n\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    ", "sq": "Shkruani një funksion python 'def mod_inverse(a, b):' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni inversin modular multiplikativ të `a` modulo `b`.\n    \n    Kjo funksion gjen një numër të plotë `x` të tillë që (a * x) % b == 1, me kusht që\n    `a` dhe `b` të jenë bashkëkryesorë (d.m.th., gcd(a, b) == 1). Ai përdor Algoritmin\n    Euklidian të Zgjeruar për të llogaritur inversin. Nëse `a` dhe `b` nuk janë bashkëkryesorë,\n    inversi modular nuk ekziston, dhe funksioni kthen `None`.\n    \n    Args:\n      a (int): Numri i plotë për të cilin duhet gjetur inversi modular.\n      b (int): Moduli në lidhje me të cilin kërkohet inversi.\n    \n    Returns:\n      int: Inversi modular i `a` modulo `b` nëse ekziston, përndryshe `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "hy": "Պայթոն ֆունկցիա 'def mod_inverse(a, b):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք `a`-ի մոդուլյար բազմապատկիչ հակադարձը `b` մոդուլով:\n    \n    Այս ֆունկցիան գտնում է ամբողջ թիվ `x`, այնպես որ (a * x) % b == 1, եթե\n    `a` և `b` փոխադարձաբար պարզ են (այսինքն՝ gcd(a, b) == 1): Այն օգտագործում է ընդլայնված Էվկլիդեսյան\n    ալգորիթմը հակադարձը հաշվարկելու համար: Եթե `a` և `b` փոխադարձաբար պարզ չեն, ապա մոդուլյար\n    հակադարձը գոյություն չունի, և ֆունկցիան վերադարձնում է `None`:\n    \n    Արգումենտներ:\n      a (int): Ամբողջ թիվը, որի մոդուլյար հակադարձը պետք է գտնվի:\n      b (int): Մոդուլը, որի նկատմամբ հակադարձը որոնվում է:\n    \n    Վերադարձնում է:\n      int: `a`-ի մոդուլյար հակադարձը `b` մոդուլով, եթե այն գոյություն ունի, այլապես `None`:\n    \n    Օրինակներ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "bn": "একটি পাইথন ফাংশন 'def mod_inverse(a, b):' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n\n    `a` এর মডুলার গুণনীয় বিপরীত `b` মডুলোর হিসাব করুন।\n    \n    এই ফাংশন একটি পূর্ণসংখ্যা `x` খুঁজে পায় যাতে (a * x) % b == 1 হয়, যদি \n    `a` এবং `b` পরস্পর সহমিত হয় (অর্থাৎ, gcd(a, b) == 1)। এটি ইনভার্স গণনা করতে \n    Extended Euclidean Algorithm ব্যবহার করে। যদি `a` এবং `b` পরস্পর সহমিত না হয়, \n    তাহলে মডুলার বিপরীত বিদ্যমান নেই এবং ফাংশন `None` ফেরত দেয়।\n    \n    আর্গুমেন্টস:\n      a (int): পূর্ণসংখ্যা যার মডুলার বিপরীত খুঁজে বের করতে হবে।\n      b (int): মডুলাস যার সাথে বিপরীত খোঁজা হচ্ছে।\n    \n    রিটার্নস:\n      int: `a` এর মডুলার বিপরীত `b` মডুলোর যদি বিদ্যমান থাকে, অন্যথায় `None`।\n    \n    উদাহরণ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "bg": "Напишете Python функция 'def mod_inverse(a, b):', за да решите следния проблем:\n\n    Изчислете модулната мултипликативна обратна стойност на `a` модул `b`.\n    \n    Тази функция намира цяло число `x`, такова че (a * x) % b == 1, при условие че\n    `a` и `b` са взаимно прости (т.е. gcd(a, b) == 1). Използва разширения алгоритъм на Евклид\n    за изчисляване на обратната стойност. Ако `a` и `b` не са взаимно прости, модулната\n    обратна стойност не съществува и функцията връща `None`.\n    \n    Аргументи:\n      a (int): Цялото число, чиято модулна обратна стойност трябва да се намери.\n      b (int): Модулът, спрямо който се търси обратната стойност.\n    \n    Връща:\n      int: Модулната обратна стойност на `a` модул `b`, ако съществува, в противен случай `None`.\n    \n    Примери:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "zh": "编写一个 Python 函数 'def mod_inverse(a, b):' 来解决以下问题：\n\n    计算 `a` 模 `b` 的模乘逆。\n    \n    此函数找到一个整数 `x`，使得 (a * x) % b == 1，前提是 `a` 和 `b` 互质（即 gcd(a, b) == 1）。它使用扩展欧几里得算法来计算逆。如果 `a` 和 `b` 不是互质的，则模逆不存在，函数返回 `None`。\n    \n    参数:\n      a (int): 要找到模逆的整数。\n      b (int): 寻找逆的模数。\n    \n    返回:\n      int: 如果存在，返回 `a` 模 `b` 的模逆，否则返回 `None`。\n    \n    示例:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "fr": "Écrivez une fonction python 'def mod_inverse(a, b):' pour résoudre le problème suivant :\n\n    Calculer l'inverse multiplicatif modulaire de `a` modulo `b`.\n    \n    Cette fonction trouve un entier `x` tel que (a * x) % b == 1, à condition que\n    `a` et `b` soient premiers entre eux (c'est-à-dire, gcd(a, b) == 1). Elle utilise l'algorithme\n    d'Euclide étendu pour calculer l'inverse. Si `a` et `b` ne sont pas premiers entre eux, l'inverse\n    modulaire n'existe pas, et la fonction retourne `None`.\n    \n    Args:\n      a (int): L'entier dont l'inverse modulaire doit être trouvé.\n      b (int): Le module par rapport auquel l'inverse est recherché.\n    \n    Returns:\n      int: L'inverse modulaire de `a` modulo `b` s'il existe, sinon `None`.\n    \n    Exemples :\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "de": "Schreiben Sie eine Python-Funktion 'def mod_inverse(a, b):', um das folgende Problem zu lösen:\n\n    Berechnen Sie das modulare multiplikative Inverse von `a` modulo `b`.\n    \n    Diese Funktion findet eine ganze Zahl `x`, so dass (a * x) % b == 1, vorausgesetzt,\n    `a` und `b` sind teilerfremd (d.h., gcd(a, b) == 1). Sie verwendet den erweiterten\n    euklidischen Algorithmus, um das Inverse zu berechnen. Wenn `a` und `b` nicht teilerfremd sind, \n    existiert das modulare Inverse nicht, und die Funktion gibt `None` zurück.\n    \n    Argumente:\n      a (int): Die ganze Zahl, deren modulares Inverses gefunden werden soll.\n      b (int): Der Modulus, in Bezug auf den das Inverse gesucht wird.\n    \n    Rückgabewert:\n      int: Das modulare Inverse von `a` modulo `b`, falls es existiert, andernfalls `None`.\n    \n    Beispiele:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "ha": "Rubuta wani aikin python 'def mod_inverse(a, b):' don warware matsalar mai zuwa:\n\n    Lissafa modular multiplicative inverse na `a` modulo `b`.\n    \n    Wannan aikin yana samun wani cikakken lamba `x` wanda (a * x) % b == 1, idan aka\n    ba da cewa `a` da `b` suna da juna (watau, gcd(a, b) == 1). Yana amfani da Tsarin\n    Euclidean na ci gaba don lissafin inverse. Idan `a` da `b` ba su da juna, to modular\n    inverse ba ya wanzu, kuma aikin yana mayar da `None`.\n    \n    Args:\n      a (int): Cikakken lambar da za a nemo modular inverse ɗinta.\n      b (int): Modulus wanda ake nema inverse ɗinsa.\n    \n    Returns:\n      int: Modular inverse na `a` modulo `b` idan yana wanzu, in ba haka ba `None`.\n    \n    Misalai:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "hi": "एक पायथन फ़ंक्शन 'def mod_inverse(a, b):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    `a` का `b` के मापांक के अनुसार मापांक गुणात्मक प्रतिलोम गणना करें।\n    \n    यह फ़ंक्शन एक पूर्णांक `x` खोजता है ताकि (a * x) % b == 1 हो, बशर्ते कि\n    `a` और `b` सह-प्राइम हों (अर्थात, gcd(a, b) == 1)। यह प्रतिलोम की गणना के लिए\n    विस्तारित यूक्लिडियन एल्गोरिदम का उपयोग करता है। यदि `a` और `b` सह-प्राइम नहीं हैं, \n    तो मापांक प्रतिलोम अस्तित्व में नहीं होता है, और फ़ंक्शन `None` लौटाता है।\n    \n    तर्क:\n      a (int): वह पूर्णांक जिसका मापांक प्रतिलोम खोजा जाना है।\n      b (int): वह मापांक जिसके अनुसार प्रतिलोम खोजा जा रहा है।\n    \n    लौटाता है:\n      int: यदि यह अस्तित्व में है तो `a` का `b` के मापांक के अनुसार मापांक प्रतिलोम, अन्यथा `None`।\n    \n    उदाहरण:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "hu": "Írj egy python függvényt 'def mod_inverse(a, b):' a következő probléma megoldására:\n\n    Számítsd ki `a` moduláris multiplikatív inverzét `b` modulo szerint.\n    \n    Ez a függvény egy olyan egész számot talál `x`, amelyre (a * x) % b == 1, feltéve, hogy\n    `a` és `b` relatív prímek (azaz gcd(a, b) == 1). Az inverz kiszámításához az\n    kiterjesztett euklideszi algoritmust használja. Ha `a` és `b` nem relatív prímek, a moduláris\n    inverz nem létezik, és a függvény `None`-t ad vissza.\n    \n    Paraméterek:\n      a (int): Az egész szám, amelynek a moduláris inverzét meg kell találni.\n      b (int): Az a modulus, amelyhez képest az inverz keresendő.\n    \n    Visszatér:\n      int: `a` moduláris inverze `b` modulo szerint, ha létezik, különben `None`.\n    \n    Példák:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "es": "Escribe una función de Python 'def mod_inverse(a, b):' para resolver el siguiente problema:\n\n    Calcular el inverso multiplicativo modular de `a` módulo `b`.\n    \n    Esta función encuentra un entero `x` tal que (a * x) % b == 1, siempre que\n    `a` y `b` sean coprimos (es decir, gcd(a, b) == 1). Utiliza el Algoritmo\n    Euclidiano Extendido para calcular el inverso. Si `a` y `b` no son coprimos,\n    el inverso modular no existe, y la función devuelve `None`.\n    \n    Argumentos:\n      a (int): El entero cuyo inverso modular se va a encontrar.\n      b (int): El módulo respecto al cual se busca el inverso.\n    \n    Devuelve:\n      int: El inverso modular de `a` módulo `b` si existe, de lo contrario `None`.\n    \n    Ejemplos:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "arb": "اكتب دالة بايثون 'def mod_inverse(a, b):' لحل المشكلة التالية:\n\n    حساب المعكوس الضربي المعياري لـ `a` بالنسبة إلى `b`.\n    \n    هذه الدالة تجد عددًا صحيحًا `x` بحيث يكون (a * x) % b == 1، بشرط أن\n    `a` و `b` هما عددان أوليان فيما بينهما (أي أن gcd(a, b) == 1). تستخدم\n    خوارزمية إقليدس الموسعة لحساب المعكوس. إذا لم يكن `a` و `b` أوليان فيما بينهما،\n    فإن المعكوس المعياري لا يوجد، وتعيد الدالة `None`.\n    \n    يعيدالحجج:\n      a (int): العدد الصحيح الذي يراد إيجاد معكوسه المعياري.\n      b (int): الموديلوس الذي يُبحث بالنسبة له عن المعكوس.\n    \n    يعيد:\n      int: المعكوس المعياري لـ `a` بالنسبة إلى `b` إذا كان موجودًا، وإلا `None`.\n    \n    أمثلة:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "sw": "Andika kazi ya python 'def mod_inverse(a, b):' kutatua tatizo lifuatalo:\n\n    Hesabu kinyume cha kuzidisha cha moduli cha `a` modulo `b`.\n    \n    Kazi hii inapata nambari kamili `x` kama (a * x) % b == 1, mradi tu\n    `a` na `b` ni coprime (yaani, gcd(a, b) == 1). Inatumia Algorithm ya Euclidean\n    Iliyopanuliwa kuhesabu kinyume. Ikiwa `a` na `b` si coprime, kinyume cha moduli hakipo, na kazi inarudisha `None`.\n    \n    Hoja:\n      a (int): Nambari kamili ambayo kinyume cha moduli kinapaswa kupatikana.\n      b (int): Moduli ambayo kinyume kinatafutwa.\n    \n    Inarejesha:\n      int: Kinyume cha moduli cha `a` modulo `b` ikiwa kipo, vinginevyo `None`.\n    \n    Mifano:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "tr": "Bir python fonksiyonu 'def mod_inverse(a, b):' yazın ve aşağıdaki problemi çözün:\n\n    `a` sayısının `b` modülüne göre modular çarpımsal tersini hesaplayın.\n    \n    Bu fonksiyon, (a * x) % b == 1 olacak şekilde bir tamsayı `x` bulur, bu koşul\n    `a` ve `b` aralarında asal olduğunda sağlanır (yani, gcd(a, b) == 1). Tersi\n    hesaplamak için Genişletilmiş Öklid Algoritmasını kullanır. Eğer `a` ve `b`\n    aralarında asal değilse, modular ters mevcut değildir ve fonksiyon `None`\n    döndürür.\n    \n    Argümanlar:\n      a (int): Modular tersi bulunacak tamsayı.\n      b (int): Tersinin arandığı modül.\n    \n    Dönüş:\n      int: Eğer mevcutsa `a`'nın `b` modülüne göre modular tersi, aksi takdirde `None`.\n    \n    Örnekler:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "vi": "Viết một hàm python 'def mod_inverse(a, b):' để giải quyết vấn đề sau:\n\n    Tính nghịch đảo nhân modulo của `a` modulo `b`.\n    \n    Hàm này tìm một số nguyên `x` sao cho (a * x) % b == 1, với điều kiện\n    `a` và `b` là nguyên tố cùng nhau (tức là, gcd(a, b) == 1). Nó sử dụng\n    Thuật toán Euclid mở rộng để tính nghịch đảo. Nếu `a` và `b` không phải là\n    nguyên tố cùng nhau, nghịch đảo modulo không tồn tại, và hàm trả về `None`.\n    \n    Tham số:\n      a (int): Số nguyên mà nghịch đảo modulo cần tìm.\n      b (int): Modulus mà nghịch đảo được tìm kiếm.\n    \n    Trả về:\n      int: Nghịch đảo modulo của `a` modulo `b` nếu tồn tại, nếu không thì `None`.\n    \n    Ví dụ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "id": "Tulis fungsi python 'def mod_inverse(a, b):' untuk menyelesaikan masalah berikut:\n\n    Hitung invers perkalian modular dari `a` modulo `b`.\n    \n    Fungsi ini menemukan bilangan bulat `x` sehingga (a * x) % b == 1, dengan syarat\n    `a` dan `b` adalah coprime (yaitu, gcd(a, b) == 1). Ini menggunakan Algoritma\n    Euclidean yang Diperluas untuk menghitung invers. Jika `a` dan `b` bukan coprime,\n    invers modular tidak ada, dan fungsi mengembalikan `None`.\n    \n    Args:\n      a (int): Bilangan bulat yang invers modularnya akan ditemukan.\n      b (int): Modulus sehubungan dengan mana invers dicari.\n    \n    Returns:\n      int: Invers modular dari `a` modulo `b` jika ada, jika tidak `None`.\n    \n    Contoh:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "ja": "Python関数を書いてください。 'def mod_inverse(a, b):' を用いて次の問題を解決してください:\n\n    `a` の `b` に対するモジュラ逆数を計算します。\n    \n    この関数は、(a * x) % b == 1 となる整数 `x` を見つけます。ただし、\n    `a` と `b` は互いに素である必要があります（つまり、gcd(a, b) == 1）。\n    拡張ユークリッドのアルゴリズムを使用して逆数を計算します。`a` と `b` が\n    互いに素でない場合、モジュラ逆数は存在せず、関数は `None` を返します。\n    \n    引数:\n      a (int): モジュラ逆数を見つける整数。\n      b (int): 逆数を求める際の法。\n    \n    戻り値:\n      int: `a` の `b` に対するモジュラ逆数が存在する場合はその値、存在しない場合は `None`。\n    \n    例:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "ko": "다음 문제를 해결하기 위해 'def mod_inverse(a, b):'라는 파이썬 함수를 작성하십시오:\n\n    `a`를 `b`로 나눈 나머지의 모듈러 곱셈 역수를 계산합니다.\n    \n    이 함수는 (a * x) % b == 1이 되는 정수 `x`를 찾습니다. 여기서 `a`와 `b`는 서로소여야 합니다 (즉, gcd(a, b) == 1). 확장 유클리드 알고리즘을 사용하여 역수를 계산합니다. `a`와 `b`가 서로소가 아니면 모듈러 역수는 존재하지 않으며, 함수는 `None`을 반환합니다.\n    \n    매개변수:\n      a (int): 모듈러 역수를 찾고자 하는 정수.\n      b (int): 역수를 구하고자 하는 모듈러스.\n    \n    반환값:\n      int: `a`의 모듈러 역수가 존재하면 그 값을 반환하고, 그렇지 않으면 `None`을 반환합니다.\n    \n    예제:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "ml": "'def mod_inverse(a, b):' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    `a` ന്റെ മോഡുലാർ മൾട്ടിപ്ലിക്കേറ്റീവ് ഇൻവേഴ്സ് `b` മോഡുലോ കണക്കാക്കുക.\n    \n    ഈ ഫംഗ്ഷൻ (a * x) % b == 1 ആകുന്ന ഒരു പൂർണ്ണസംഖ്യ `x` കണ്ടെത്തുന്നു, بشرط أن\n    `a`യും `b`യും കോപ്രൈം ആണെങ്കിൽ (അത്, gcd(a, b) == 1). ഇൻവേഴ്സ് കണക്കാക്കാൻ ഇത് വിപുലമായ യൂക്ലിഡിയൻ\n    ആൽഗോരിതം ഉപയോഗിക്കുന്നു. `a`യും `b`യും കോപ്രൈം അല്ലെങ്കിൽ, മോഡുലാർ\n    ഇൻവേഴ്സ് നിലവിലില്ല, ഫംഗ്ഷൻ `None` മടക്കുന്നു.\n    \n    Args:\n      a (int): മോഡുലാർ ഇൻവേഴ്സ് കണ്ടെത്തേണ്ട പൂർണ്ണസംഖ്യ.\n      b (int): ഇൻവേഴ്സ് അന്വേഷിക്കുന്ന മോഡുലസ്.\n    \n    Returns:\n      int: `a` ന്റെ മോഡുലാർ ഇൻവേഴ്സ് `b` മോഡുലോ നിലവിലുണ്ടെങ്കിൽ, അല്ലെങ്കിൽ `None`.\n    \n    ഉദാഹരണങ്ങൾ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "fa": "یک تابع پایتون 'def mod_inverse(a, b):' بنویسید تا مسئله زیر را حل کند:\n\n    محاسبه معکوس ضربی مدولار `a` مد `b`.\n    \n    این تابع یک عدد صحیح `x` را پیدا می‌کند به طوری که (a * x) % b == 1، به شرطی که\n    `a` و `b` نسبت به هم اول باشند (یعنی gcd(a, b) == 1). این از\n    الگوریتم بسط یافته اقلیدسی برای محاسبه معکوس استفاده می‌کند. اگر `a` و `b` نسبت به هم اول نباشند، \n    معکوس مدولار وجود ندارد و تابع `None` را برمی‌گرداند.\n    \n    آرگومان‌ها:\n      a (int): عدد صحیحی که معکوس مدولار آن باید پیدا شود.\n      b (int): مدی که نسبت به آن معکوس جستجو می‌شود.\n    \n    بازگشت:\n      int: معکوس مدولار `a` مد `b` اگر وجود داشته باشد، در غیر این صورت `None`.\n    \n    مثال‌ها:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None"}, "level": "easy", "test": "def test_mod_inverse():\n    test_cases = [\n        (3, 10),  # Test case 1: gcd(3, 10) = 1, inverse should be 7\n        (17, 3120),  # Test case 2: gcd(17, 3120) = 1, inverse should be 2753\n        (42, 2017),  # Test case 3: gcd(42, 2017) = 1, inverse should be 1969\n    ]\n    expected_results = [\n        7,  # Expected result for test case 1\n        2753,  # Expected result for test case 2\n        1969,  # Expected result for test case 3\n    ]\n\n    for i, (a, b) in enumerate(test_cases):\n        actual_result = mod_inverse(a, b)\n        expected_result = expected_results[i]\n        assert actual_result == expected_result, f\"Test case {i+1} failed: expected {expected_result}, got {actual_result}\"\n        print(f\"Test case {i+1} passed: a={a}, b={b}, x0={actual_result}\")\n\n# Run the test function\ntest_mod_inverse()", "entry_point": "mod_inverse", "signature": "def mod_inverse(a, b):", "docstring": {"en": "\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    ", "sq": "\n    Llogaritni inversin modular multiplikativ të `a` modulo `b`.\n    \n    Kjo funksion gjen një numër të plotë `x` të tillë që (a * x) % b == 1, me kusht që\n    `a` dhe `b` të jenë të bashkëkryqëzuar (d.m.th., gcd(a, b) == 1). Përdor Algoritmin\n    e Zgjeruar të Euklidit për të llogaritur inversin. Nëse `a` dhe `b` nuk janë të\n    bashkëkryqëzuar, inversi modular nuk ekziston, dhe funksioni kthen `None`.\n    \n    Argumentet:\n      a (int): Numri i plotë për të cilin duhet gjetur inversi modular.\n      b (int): Moduli me të cilin kërkohet inversi.\n    \n    Kthen:\n      int: Inversi modular i `a` modulo `b` nëse ekziston, përndryshe `None`.\n    \n    Shembuj:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "hy": "\n    Հաշվեք `a`-ի մոդուլային բազմապատիկ հակադարձը `b` մոդուլով:\n    \n    Այս ֆունկցիան գտնում է ամբողջ թիվ `x`, այնպես, որ (a * x) % b == 1, պայմանով, որ\n    `a` և `b` փոխադարձաբար պարզ են (այսինքն, gcd(a, b) == 1): Այն օգտագործում է ընդլայնված\n    Եվկլիդյան ալգորիթմը հակադարձը հաշվարկելու համար: Եթե `a` և `b` փոխադարձաբար պարզ չեն, \n    մոդուլային հակադարձը գոյություն չունի, և ֆունկցիան վերադարձնում է `None`:\n    \n    Արգումենտներ:\n      a (int): Ամբողջ թիվ, որի մոդուլային հակադարձը պետք է գտնվի:\n      b (int): Մոդուլը, որի նկատմամբ հակադարձը փնտրվում է:\n    \n    Վերադարձնում է:\n      int: `a`-ի մոդուլային հակադարձը `b` մոդուլով, եթե այն գոյություն ունի, հակառակ դեպքում `None`:\n    \n    Օրինակներ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "bn": "\n    `a` এর মডুলার গুণাত্মক বিপরীত `b` মডুলোর হিসাব করুন।\n    \n    এই ফাংশনটি একটি পূর্ণসংখ্যা `x` খুঁজে বের করে যাতে (a * x) % b == 1 হয়, যদি\n    `a` এবং `b` পরস্পর সহমরী (অর্থাৎ, gcd(a, b) == 1) হয়। এটি Extended Euclidean\n    Algorithm ব্যবহার করে বিপরীত হিসাব করে। যদি `a` এবং `b` পরস্পর সহমরী না হয়, তাহলে মডুলার\n    বিপরীত বিদ্যমান নেই, এবং ফাংশনটি `None` ফেরত দেয়।\n    \n    আর্গস:\n      a (int): পূর্ণসংখ্যা যার মডুলার বিপরীত খুঁজে বের করতে হবে।\n      b (int): মডুলাস যার সাথে বিপরীত খোঁজা হচ্ছে।\n    \n    রিটার্নস:\n      int: `a` এর মডুলার বিপরীত `b` মডুলোর যদি এটি বিদ্যমান থাকে, অন্যথায় `None`।\n    \n    উদাহরণ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "bg": "\n    Изчислете модулната мултипликативна обратна стойност на `a` по модул `b`.\n    \n    Тази функция намира цяло число `x`, такова че (a * x) % b == 1, при условие че\n    `a` и `b` са взаимно прости (т.е., gcd(a, b) == 1). Използва разширения алгоритъм на Евклид\n    за изчисляване на обратната стойност. Ако `a` и `b` не са взаимно прости, модулната\n    обратна стойност не съществува и функцията връща `None`.\n    \n    Аргументи:\n      a (int): Цяло число, чиято модулна обратна стойност трябва да бъде намерена.\n      b (int): Модулът, спрямо който се търси обратната стойност.\n    \n    Връща:\n      int: Модулната обратна стойност на `a` по модул `b`, ако съществува, в противен случай `None`.\n    \n    Примери:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "zh": "\n    计算 `a` 模 `b` 的模逆。\n    \n    该函数找到一个整数 `x`，使得 (a * x) % b == 1，前提是 `a` 和 `b` 互质（即 gcd(a, b) == 1）。\n    它使用扩展欧几里得算法来计算逆。如果 `a` 和 `b` 不是互质的，则模逆不存在，函数返回 `None`。\n    \n    参数:\n      a (int): 要找到模逆的整数。\n      b (int): 寻找逆的模数。\n    \n    返回:\n      int: 如果存在，返回 `a` 模 `b` 的模逆，否则返回 `None`。\n    \n    示例:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "fr": "\n    Calculer l'inverse modulaire multiplicatif de `a` modulo `b`.\n    \n    Cette fonction trouve un entier `x` tel que (a * x) % b == 1, à condition que\n    `a` et `b` soient copremiers (c'est-à-dire, gcd(a, b) == 1). Elle utilise l'algorithme\n    d'Euclide étendu pour calculer l'inverse. Si `a` et `b` ne sont pas copremiers, l'inverse\n    modulaire n'existe pas, et la fonction retourne `None`.\n    \n    Args:\n      a (int): L'entier dont l'inverse modulaire doit être trouvé.\n      b (int): Le module par rapport auquel l'inverse est recherché.\n    \n    Returns:\n      int: L'inverse modulaire de `a` modulo `b` s'il existe, sinon `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "de": "\n    Berechne das modulare multiplikative Inverse von `a` modulo `b`.\n    \n    Diese Funktion findet eine ganze Zahl `x`, so dass (a * x) % b == 1, vorausgesetzt,\n    dass `a` und `b` teilerfremd sind (d.h., gcd(a, b) == 1). Sie verwendet den erweiterten\n    euklidischen Algorithmus, um das Inverse zu berechnen. Wenn `a` und `b` nicht teilerfremd sind,\n    existiert das modulare Inverse nicht, und die Funktion gibt `None` zurück.\n    \n    Argumente:\n      a (int): Die ganze Zahl, deren modulares Inverse gefunden werden soll.\n      b (int): Der Modulus, in Bezug auf den das Inverse gesucht wird.\n    \n    Rückgabewert:\n      int: Das modulare Inverse von `a` modulo `b`, falls es existiert, andernfalls `None`.\n    \n    Beispiele:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "ha": "\n    Lissafi maimaitawar haɗin kai na `a` modulo `b`.\n    \n    Wannan aikin yana nemo wani cikakken lamba `x` wanda (a * x) % b == 1, idan aka tanadi cewa\n    `a` da `b` ba su da rabo (wato, gcd(a, b) == 1). Yana amfani da Tsarin Euclidean\n    da aka faɗaɗa don lissafin maimaitawar. Idan `a` da `b` ba su da rabo, maimaitawar\n    haɗin kai ba ya wanzu, kuma aikin yana mayar da `None`.\n    \n    Args:\n      a (int): Cikakken lambar da za a nemo maimaitawar haɗin kai.\n      b (int): Modulus da za a nema maimaitawar a kansa.\n    \n    Returns:\n      int: Maimaitawar haɗin kai na `a` modulo `b` idan yana wanzu, in ba haka ba `None`.\n    \n    Misalai:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "hi": "\n    `a` का `b` के मापांक के अनुसार गुणात्मक व्युत्क्रम (modular multiplicative inverse) गणना करें।\n    \n    यह फ़ंक्शन एक पूर्णांक `x` खोजता है ताकि (a * x) % b == 1 हो, बशर्ते कि `a` और `b` सह-प्राइम हों (अर्थात, gcd(a, b) == 1)। यह व्युत्क्रम की गणना के लिए विस्तारित यूक्लिडियन एल्गोरिदम का उपयोग करता है। यदि `a` और `b` सह-प्राइम नहीं हैं, तो मापांक व्युत्क्रम मौजूद नहीं होता है, और फ़ंक्शन `None` लौटाता है।\n    \n    तर्क:\n      a (int): वह पूर्णांक जिसका मापांक व्युत्क्रम खोजा जाना है।\n      b (int): वह मापांक जिसके संदर्भ में व्युत्क्रम खोजा जा रहा है।\n    \n    वापसी:\n      int: यदि मौजूद है तो `a` का `b` के मापांक के अनुसार व्युत्क्रम, अन्यथा `None`।\n    \n    उदाहरण:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "hu": "\n    Számítsa ki `a` moduláris multiplikatív inverzét `b` modulo szerint.\n    \n    Ez a függvény olyan egész számot talál `x`, amelyre (a * x) % b == 1, feltéve, hogy\n    `a` és `b` relatív prímek (azaz gcd(a, b) == 1). Az inverz kiszámításához az\n    kiterjesztett euklideszi algoritmust használja. Ha `a` és `b` nem relatív prímek,\n    a moduláris inverz nem létezik, és a függvény `None`-t ad vissza.\n    \n    Paraméterek:\n      a (int): Az egész szám, amelynek moduláris inverzét meg kell találni.\n      b (int): A modulus, amelyhez képest az inverz keresendő.\n    \n    Visszatér:\n      int: `a` moduláris inverze `b` modulo szerint, ha létezik, különben `None`.\n    \n    Példák:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "es": "    Calcular el inverso multiplicativo modular de `a` módulo `b`.\n    \n    Esta función encuentra un entero `x` tal que (a * x) % b == 1, siempre que\n    `a` y `b` sean coprimos (es decir, gcd(a, b) == 1). Utiliza el Algoritmo\n    Euclidiano Extendido para calcular el inverso. Si `a` y `b` no son coprimos,\n    el inverso modular no existe, y la función devuelve `None`.\n    \n    Argumentos:\n      a (int): El entero cuyo inverso modular se va a encontrar.\n      b (int): El módulo respecto al cual se busca el inverso.\n    \n    Devuelve:\n      int: El inverso modular de `a` módulo `b` si existe, de lo contrario `None`.\n    \n    Ejemplos:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "arb": "    حساب المعكوس الضربي المعياري لـ `a` بالنسبة إلى `b`.\n    \n    هذه الدالة تجد عددًا صحيحًا `x` بحيث أن (a * x) % b == 1، بشرط أن\n    `a` و `b` هما عددان أوليان فيما بينهما (أي، gcd(a, b) == 1). تستخدم\n    خوارزمية إقليدس الموسعة لحساب المعكوس. إذا لم يكن `a` و `b` عددان أوليان فيما بينهما، فإن\n    المعكوس المعياري لا يوجد، وتعيد الدالة `None`.\n    \n    يعيدالحجج:\n      a (int): العدد الصحيح الذي يُراد إيجاد معكوسه المعياري.\n      b (int): المقياس الذي يُراد إيجاد المعكوس بالنسبة له.\n    \n    يعيد:\n      int: المعكوس المعياري لـ `a` بالنسبة إلى `b` إذا كان موجودًا، وإلا `None`.\n    \n    امثله:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "sw": "    Kuhesabu kinyume cha kuzidisha cha moduli cha `a` modulo `b`.\n    \n    Kazi hii inapata nambari nzima `x` kama kwamba (a * x) % b == 1, mradi\n    `a` na `b` ni coprime (yaani, gcd(a, b) == 1). Inatumia Algorithm ya Euclidean\n    Iliyoenea ili kuhesabu kinyume. Ikiwa `a` na `b` si coprime, kinyume cha moduli\n    hakipo, na kazi inarudisha `None`.\n    \n    Hoja:\n      a (int): Nambari nzima ambayo kinyume cha moduli kinapaswa kupatikana.\n      b (int): Moduli ambayo kinyume kinatafutwa.\n    \n    Inarudisha:\n      int: Kinyume cha moduli cha `a` modulo `b` ikiwa kipo, vinginevyo `None`.\n    \n    Mifano:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "tr": "`a` sayısının `b` modülüne göre modüler çarpımsal tersini hesaplayın.\n\nBu fonksiyon, (a * x) % b == 1 olacak şekilde bir tamsayı `x` bulur, bu koşul `a` ve `b` aralarında asal olduğunda (yani, gcd(a, b) == 1) sağlanır. Tersi hesaplamak için Genişletilmiş Öklid Algoritmasını kullanır. Eğer `a` ve `b` aralarında asal değilse, modüler ters mevcut değildir ve fonksiyon `None` döndürür.\n\nArgümanlar:\n  a (int): Modüler tersi bulunacak tamsayı.\n  b (int): Tersinin aranacağı modül.\n\nDöndürür:\n  int: Eğer mevcutsa `a` sayısının `b` modülüne göre modüler tersi, aksi takdirde `None`.\n\nÖrnekler:\n  >>> mod_inverse(3, 10)\n  7\n\n  >>> mod_inverse(42, 2017)\n  None", "vi": "    Tính nghịch đảo nhân theo modulo của `a` theo modulo `b`.\n    \n    Hàm này tìm một số nguyên `x` sao cho (a * x) % b == 1, với điều kiện\n    `a` và `b` là nguyên tố cùng nhau (tức là, gcd(a, b) == 1). Nó sử dụng\n    Thuật toán Euclid mở rộng để tính nghịch đảo. Nếu `a` và `b` không phải là\n    nguyên tố cùng nhau, nghịch đảo theo modulo không tồn tại, và hàm trả về `None`.\n    \n    Tham số:\n      a (int): Số nguyên cần tìm nghịch đảo theo modulo.\n      b (int): Modulo theo đó nghịch đảo được tìm kiếm.\n    \n    Trả về:\n      int: Nghịch đảo theo modulo của `a` theo modulo `b` nếu tồn tại, ngược lại `None`.\n    \n    Ví dụ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "id": "    Hitung invers perkalian modular dari `a` modulo `b`.\n    \n    Fungsi ini menemukan bilangan bulat `x` sehingga (a * x) % b == 1, dengan syarat\n    `a` dan `b` adalah coprime (yaitu, gcd(a, b) == 1). Ini menggunakan Algoritma\n    Euclidean yang Diperluas untuk menghitung invers. Jika `a` dan `b` bukan coprime,\n    invers modular tidak ada, dan fungsi mengembalikan `None`.\n    \n    Args:\n      a (int): Bilangan bulat yang invers modularnya akan ditemukan.\n      b (int): Modulus sehubungan dengan mana invers dicari.\n    \n    Returns:\n      int: Invers modular dari `a` modulo `b` jika ada, jika tidak `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "ja": "    `a` の `b` によるモジュラ逆数を計算します。\n    \n    この関数は、(a * x) % b == 1 となる整数 `x` を見つけます。ただし、`a` と `b` は互いに素である必要があります（つまり、gcd(a, b) == 1）。拡張ユークリッドアルゴリズムを使用して逆数を計算します。`a` と `b` が互いに素でない場合、モジュラ逆数は存在せず、関数は `None` を返します。\n    \n    引数:\n      a (int): モジュラ逆数を見つける整数。\n      b (int): 逆数を求める対象の法。\n    \n    戻り値:\n      int: `a` の `b` によるモジュラ逆数が存在する場合はその値、存在しない場合は `None`。\n    \n    例:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "ko": "    `a`의 모듈러 곱셈 역원을 `b`로 계산합니다.\n    \n    이 함수는 (a * x) % b == 1이 되는 정수 `x`를 찾습니다. 여기서 `a`와 `b`는 서로소여야 합니다 (즉, gcd(a, b) == 1). 확장 유클리드 알고리즘을 사용하여 역원을 계산합니다. `a`와 `b`가 서로소가 아닌 경우, 모듈러 역원은 존재하지 않으며 함수는 `None`을 반환합니다.\n    \n    인수:\n      a (int): 모듈러 역원을 찾고자 하는 정수.\n      b (int): 역원을 구하고자 하는 모듈러스.\n    \n    반환:\n      int: `a`의 모듈러 `b`에 대한 역원이 존재하면 그 값을 반환하고, 그렇지 않으면 `None`을 반환합니다.\n    \n    예제:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "ml": "    `a` ന്റെ മോഡുലാർ മൾട്ടിപ്ലിക്കേറ്റീവ് ഇൻവേഴ്സ് `b` മോഡുലോ കണക്കാക്കുക.\n    \n    ഈ ഫംഗ്ഷൻ (a * x) % b == 1 ആകുന്ന ഒരു പൂർണ്ണസംഖ്യ `x` കണ്ടെത്തുന്നു, `a`യും `b`യും പരസ്പരം പ്രധാനമാണെങ്കിൽ (അഥവാ, gcd(a, b) == 1). ഇൻവേഴ്സ് കണക്കാക്കാൻ ഇത് വിപുലമായ യൂക്ലിഡിയൻ ആൽഗോരിതം ഉപയോഗിക്കുന്നു. `a`യും `b`യും പരസ്പരം പ്രധാനമല്ലെങ്കിൽ, മോഡുലാർ ഇൻവേഴ്സ് നിലനിൽക്കില്ല, ഫംഗ്ഷൻ `None` മടക്കുന്നു.\n    \n   _ARGS:_\n      a (int): മോഡുലാർ ഇൻവേഴ്സ് കണ്ടെത്തേണ്ട പൂർണ്ണസംഖ്യ.\n      b (int): ഇൻവേഴ്സ് അന്വേഷിക്കുന്ന മോഡുലസ്.\n    \n    _Returns:_\n      int: `a` ന്റെ മോഡുലാർ ഇൻവേഴ്സ് `b` മോഡുലോ നിലനിൽക്കുകയാണെങ്കിൽ, അല്ലെങ്കിൽ `None`.\n    \n    _Examples:_\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None", "fa": "    محاسبه معکوس ضربی پیمانه‌ای `a` به پیمانه `b`.\n    \n    این تابع عدد صحیح `x` را پیدا می‌کند به طوری که (a * x) % b == 1، به شرطی که\n    `a` و `b` نسبت به هم اول باشند (یعنی، gcd(a, b) == 1). این تابع از الگوریتم\n    توسعه‌یافته اقلیدسی برای محاسبه معکوس استفاده می‌کند. اگر `a` و `b` نسبت به هم اول نباشند،\n    معکوس پیمانه‌ای وجود ندارد و تابع `None` را برمی‌گرداند.\n    \n    آرگومان‌ها:\n      a (int): عدد صحیحی که معکوس پیمانه‌ای آن باید پیدا شود.\n      b (int): پیمانه‌ای که نسبت به آن معکوس جستجو می‌شود.\n    \n    بازگشت:\n      int: معکوس پیمانه‌ای `a` به پیمانه `b` اگر وجود داشته باشد، در غیر این صورت `None`.\n    \n    مثال‌ها:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None"}}
{"task_id": "Python/42", "prompt": {"en": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "sq": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Llogarit ditën e javës kur Jinjin është më e pakënaqur bazuar në orarin e saj.\n    \n    Jinjin është e pakënaqur nëse orët totale të kaluara në shkollë dhe klasa shtesë tejkalojnë 8 orë në një ditë.\n    Funksioni gjen ditën kur pakënaqësia e saj është më e madhe, që është dita kur orët totale janë më shumë mbi pragun.\n    Nëse ka disa ditë me të njëjtin nivel të pakënaqësisë maksimale, kthehet dita më e hershme. Nëse Jinjin nuk është e pakënaqur në asnjë ditë,\n    funksioni kthen 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Një listë prej 7 treshesh, ku çdo treshe përfaqëson\n                                           numrin e orëve të kaluara në shkollë dhe në klasa shtesë\n                                           për çdo ditë të javës, përkatësisht.\n                                           \n    Returns:\n        int: Dita e javës kur Jinjin është më e pakënaqur (1-7 për të hënën deri të dielën) ose 0\n             nëse ajo nuk është kurrë e pakënaqur.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "hy": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Հաշվարկել այն շաբաթվա օրը, երբ Ջինջինը ամենից դժգոհ է իր ժամանակացույցի հիման վրա։\n    \n    Ջինջինը դժգոհ է, եթե դպրոցում և լրացուցիչ դասերում անցկացրած ժամերի ընդհանուր քանակը գերազանցում է 8 ժամը մեկ օրվա ընթացքում։ \n    Ֆունկցիան գտնում է այն օրը, երբ նրա դժգոհությունը առավելագույնն է, այսինքն՝ այն օրը, երբ ընդհանուր ժամերը առավելագույնս \n    գերազանցում են շեմը։ Եթե կան մի քանի օրեր նույն մակարդակի առավելագույն դժգոհությամբ, վերադարձվում է ամենավաղ օրը։ Եթե Ջինջինը \n    ոչ մի օր դժգոհ չէ, ֆունկցիան վերադարձնում է 0։\n    \n    Արգումենտներ:\n        schedule (list[tuple[int, int]]): Ցուցակ 7 տուփերով, որտեղ յուրաքանչյուր տուփ ներկայացնում է \n                                           դպրոցում և լրացուցիչ դասերում անցկացրած ժամերի քանակը \n                                           շաբաթվա յուրաքանչյուր օրվա համար, համապատասխանաբար։\n                                           \n    Վերադարձնում է:\n        int: Շաբաթվա այն օրը, երբ Ջինջինը ամենից դժգոհ է (1-7՝ երկուշաբթիից կիրակի) կամ 0, \n             եթե նա երբեք դժգոհ չէ։\n    \n    Օրինակներ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "bn": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    জিনজিনের সময়সূচির উপর ভিত্তি করে সপ্তাহের যে দিনটি সে সবচেয়ে অসুখী তা গণনা করুন।\n    \n    যদি জিনজিন স্কুল এবং অতিরিক্ত ক্লাসে মোট সময় ৮ ঘণ্টার বেশি ব্যয় করে তবে সে অসুখী হয়।\n    ফাংশনটি সেই দিনটি খুঁজে বের করে যখন তার অসুখীতা সবচেয়ে বেশি, অর্থাৎ সেই দিনটি যখন মোট\n    সময়সীমা সবচেয়ে বেশি অতিক্রম করে। যদি একাধিক দিনের সর্বাধিক অসুখীতা একই হয়, তবে প্রথম\n    দিনটি ফেরত দেওয়া হয়। যদি জিনজিন কোনো দিনই অসুখী না হয়, তাহলে ফাংশনটি 0 ফেরত দেয়।\n    \n    আর্গুমেন্টসমূহ:\n        schedule (list[tuple[int, int]]): ৭টি টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল\n                                           সপ্তাহের প্রতিদিনের জন্য স্কুল এবং অতিরিক্ত ক্লাসে\n                                           ব্যয়িত সময়ের সংখ্যা উপস্থাপন করে।\n                                           \n    রিটার্নস:\n        int: সপ্তাহের যে দিনটি জিনজিন সবচেয়ে অসুখী (সোমবার থেকে রবিবারের জন্য ১-৭) অথবা 0\n             যদি সে কখনোই অসুখী না হয়।\n    \n    উদাহরণসমূহ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "bg": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Изчислете деня от седмицата, когато Джинджин е най-нещастна въз основа на нейния график.\n    \n    Джинджин е нещастна, ако общият брой часове, прекарани в училище и допълнителни класове, надвишава 8 часа на ден.\n    Функцията намира деня, когато нейното нещастие е най-голямо, което е денят, когато общият брой часове е най-много над прага.\n    Ако има няколко дни със същото ниво на максимално нещастие, се връща най-ранният ден. \n    Ако Джинджин не е нещастна в нито един ден, функцията връща 0.\n    \n    Аргументи:\n        schedule (list[tuple[int, int]]): Списък от 7 кортежа, където всеки кортеж представлява\n                                           броя на часовете, прекарани в училище и в допълнителни класове\n                                           за всеки ден от седмицата, съответно.\n                                           \n    Връща:\n        int: Денят от седмицата, когато Джинджин е най-нещастна (1-7 за понеделник до неделя) или 0\n             ако тя никога не е нещастна.\n    \n    Примери:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "zh": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    根据日程计算金金最不开心的一天。\n    \n    如果金金在学校和额外课程中度过的总时间超过一天8小时，她就会不开心。\n    该函数找到她不开心程度最大的那一天，即总时间超过阈值最多的一天。\n    如果有多天达到相同的不开心程度，则返回最早的一天。\n    如果金金在任何一天都不感到不开心，函数返回0。\n    \n    参数:\n        schedule (list[tuple[int, int]]): 一个包含7个元组的列表，每个元组分别代表\n                                           一周中每天在学校和额外课程中度过的小时数。\n                                           \n    返回:\n        int: 金金最不开心的一天（1-7表示周一到周日），如果她从不不开心，则返回0。\n    \n    示例:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "fr": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculer le jour de la semaine où Jinjin est la plus malheureuse en fonction de son emploi du temps.\n    \n    Jinjin est malheureuse si le total des heures passées à l'école et en cours supplémentaires dépasse 8 heures par jour.\n    La fonction trouve le jour où son malheur est le plus grand, c'est-à-dire le jour où le total\n    des heures dépasse le plus le seuil. S'il y a plusieurs jours avec le même niveau de\n    malheur maximal, le premier jour est retourné. Si Jinjin n'est pas malheureuse un seul jour, la\n    fonction retourne 0.\n    \n    Arguments:\n        schedule (list[tuple[int, int]]): Une liste de 7 tuples, où chaque tuple représente le\n                                           nombre d'heures passées à l'école et en cours supplémentaires\n                                           pour chaque jour de la semaine, respectivement.\n                                           \n    Retourne:\n        int: Le jour de la semaine où Jinjin est la plus malheureuse (1-7 pour lundi à dimanche) ou 0\n             si elle n'est jamais malheureuse.\n    \n    Cas:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "de": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Berechne den Wochentag, an dem Jinjin am unglücklichsten ist, basierend auf ihrem Stundenplan.\n    \n    Jinjin ist unglücklich, wenn die Gesamtstunden, die sie in der Schule und in zusätzlichen Kursen verbringt, \n    an einem Tag 8 Stunden überschreiten. Die Funktion findet den Tag, an dem ihr Unglück am größten ist, \n    was der Tag ist, an dem die Gesamtstunden am weitesten über dem Schwellenwert liegen. Wenn es mehrere Tage \n    mit demselben Grad an maximalem Unglück gibt, wird der früheste Tag zurückgegeben. Wenn Jinjin an keinem \n    Tag unglücklich ist, gibt die Funktion 0 zurück.\n    \n    Argumente:\n        schedule (list[tuple[int, int]]): Eine Liste von 7 Tupeln, wobei jedes Tupel die Anzahl der Stunden \n                                           darstellt, die an jedem Wochentag in der Schule und in zusätzlichen \n                                           Kursen verbracht werden.\n                                           \n    Rückgabewert:\n        int: Der Wochentag, an dem Jinjin am unglücklichsten ist (1-7 für Montag bis Sonntag) oder 0, \n             wenn sie nie unglücklich ist.\n    \n    Fälle:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "ha": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Lissafa ranar mako inda Jinjin take cikin rashin jin daɗi mafi yawa bisa ga jadawalinta.\n    \n    Jinjin tana cikin rashin jin daɗi idan jimillar awanni da aka kwashe a makaranta da ƙarin aji sun wuce awanni 8 a rana.\n    Aikin yana gano ranar da rashin jin daɗinta ya fi girma, wato ranar da jimillar awanni suka fi nisa sama da ƙayyadadden matakin.\n    Idan akwai ranaku da yawa da suke da irin wannan matakin rashin jin daɗi mafi girma, za a dawo da ranar farko.\n    Idan Jinjin ba ta cikin rashin jin daɗi a kowace rana, aikin zai dawo da 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Jerin tuples guda 7, inda kowanne tuple ke wakiltar \n                                           adadin awanni da aka kwashe a makaranta da kuma a ƙarin aji\n                                           don kowace rana ta mako, bi da bi.\n                                           \n    Returns:\n        int: Ranar mako inda Jinjin take cikin rashin jin daɗi mafi yawa (1-7 don Litinin zuwa Lahadi) ko 0 \n             idan ba ta taɓa rashin jin daɗi ba.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "hi": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    उसके कार्यक्रम के आधार पर जिनजिन किस दिन सबसे ज्यादा दुखी है, यह गणना करें।\n    \n    अगर जिनजिन स्कूल और अतिरिक्त कक्षाओं में कुल 8 घंटे से अधिक समय बिताती है तो वह दुखी होती है।\n    यह फ़ंक्शन उस दिन को ढूंढता है जब उसकी दुख की मात्रा सबसे अधिक होती है, जो वह दिन होता है जब कुल\n    घंटे सीमा से सबसे अधिक ऊपर होते हैं। यदि कई दिनों में अधिकतम दुख का समान स्तर होता है, तो सबसे पहले\n    वाला दिन लौटाया जाता है। यदि जिनजिन किसी भी दिन दुखी नहीं होती है, तो फ़ंक्शन 0 लौटाता है।\n    \n    तर्क:\n        schedule (list[tuple[int, int]]): 7 ट्यूपल की एक सूची, जहां प्रत्येक ट्यूपल सप्ताह के प्रत्येक दिन के लिए\n                                           स्कूल और अतिरिक्त कक्षाओं में बिताए गए घंटों की संख्या का प्रतिनिधित्व करता है।\n                                           \n    लौटाता है:\n        int: वह दिन जब जिनजिन सबसे ज्यादा दुखी होती है (सोमवार से रविवार के लिए 1-7) या 0 \n             अगर वह कभी दुखी नहीं होती है।\n    \n    मामले:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "hu": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Számítsa ki a hét azon napját, amikor Jinjin a legboldogtalanabb a menetrendje alapján.\n    \n    Jinjin boldogtalan, ha az iskolában és az extra órákon eltöltött összes idő meghaladja a napi 8 órát.\n    A függvény megtalálja azt a napot, amikor a boldogtalansága a legnagyobb, ami az a nap, amikor az összes\n    óra a legtávolabb van a küszöbtől. Ha több nap is azonos szintű maximális boldogtalansággal bír, akkor\n    a legkorábbi nap kerül visszaadásra. Ha Jinjin egy napon sem boldogtalan, a függvény 0-t ad vissza.\n    \n    Paraméterek:\n        schedule (list[tuple[int, int]]): Egy 7 elemből álló lista, ahol minden elem egy-egy tuple,\n                                          amely az iskolában és az extra órákon eltöltött órák számát\n                                          jelenti a hét minden napjára vonatkozóan.\n                                           \n    Visszatérési érték:\n        int: A hét azon napja, amikor Jinjin a legboldogtalanabb (1-7 hétfőtől vasárnapig), vagy 0,\n             ha soha nem boldogtalan.\n    \n    Esetek:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "es": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calcula el día de la semana en que Jinjin está más infeliz según su horario.\n    \n    Jinjin está infeliz si el total de horas pasadas en la escuela y clases extra excede 8 horas en un día.\n    La función encuentra el día en que su infelicidad es mayor, que es el día cuando el total\n    de horas está más por encima del umbral. Si hay múltiples días con el mismo nivel de \n    máxima infelicidad, se devuelve el primer día. Si Jinjin no está infeliz en ningún día, la \n    función devuelve 0.\n    \n    Argumentos:\n        schedule (list[tuple[int, int]]): Una lista de 7 tuplas, donde cada tupla representa el \n                                           número de horas pasadas en la escuela y en clases extra\n                                           para cada día de la semana, respectivamente.\n                                           \n    Devuelve:\n        int: El día de la semana en que Jinjin está más infeliz (1-7 para lunes a domingo) o 0 \n             si nunca está infeliz.\n    \n    Casos:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "arb": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    حساب اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة بناءً على جدولها.\n    \n    جينجين تكون تعيسة إذا تجاوز إجمالي الساعات التي تقضيها في المدرسة والدروس الإضافية 8 ساعات في اليوم.\n    تقوم الدالة بالعثور على اليوم الذي تكون فيه تعاستها في أقصى حد، وهو اليوم الذي تكون فيه الساعات\n    الإجمالية أبعد ما يكون عن العتبة. إذا كان هناك عدة أيام بنفس مستوى التعاسة القصوى، يتم إرجاع\n    اليوم الأسبق. إذا لم تكن جينجين تعيسة في أي يوم، تقوم الدالة بإرجاع 0.\n    \n    يعيدالحجج:\n        schedule (list[tuple[int, int]]): قائمة من 7 مجموعات، حيث تمثل كل مجموعة عدد الساعات\n                                           التي تقضيها في المدرسة والدروس الإضافية لكل يوم من أيام\n                                           الأسبوع، على التوالي.\n                                           \n    يعيد:\n        int: اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة (1-7 من الاثنين إلى الأحد) أو 0\n             إذا لم تكن تعيسة أبدًا.\n    \n    حالات:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "sw": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Hesabu siku ya wiki ambayo Jinjin ana huzuni zaidi kulingana na ratiba yake.\n    \n    Jinjin ana huzuni ikiwa jumla ya masaa yaliyotumika shuleni na madarasa ya ziada yanazidi masaa 8 kwa siku.\n    Kazi hii inatafuta siku ambayo huzuni yake ni kubwa zaidi, ambayo ni siku ambapo jumla ya masaa\n    ni zaidi ya kiwango cha juu zaidi. Ikiwa kuna siku nyingi zenye kiwango sawa cha huzuni kubwa zaidi,\n    siku ya mapema zaidi inarejeshwa. Ikiwa Jinjin hana huzuni siku yoyote, kazi inarejesha 0.\n    \n    Hoja:\n        schedule (list[tuple[int, int]]): Orodha ya jozi 7, ambapo kila jozi inawakilisha \n                                           idadi ya masaa yaliyotumika shuleni na katika madarasa ya ziada\n                                           kwa kila siku ya wiki, mtawalia.\n                                           \n    Inarejesha:\n        int: Siku ya wiki ambayo Jinjin ana huzuni zaidi (1-7 kwa Jumatatu hadi Jumapili) au 0 \n             ikiwa hana huzuni kamwe.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "tr": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Jinjin'in programına göre en mutsuz olduğu haftanın gününü hesaplayın.\n    \n    Jinjin, bir günde okulda ve ek derslerde geçirilen toplam saatler 8 saati aştığında mutsuz olur.\n    Fonksiyon, mutsuzluğunun en fazla olduğu günü bulur, bu da toplam saatlerin eşik değerin en fazla\n    üzerinde olduğu gündür. Eğer birden fazla gün aynı seviyede maksimum mutsuzluk içeriyorsa, en\n    erken gün döndürülür. Jinjin hiçbir gün mutsuz değilse, fonksiyon 0 döndürür.\n    \n    Argümanlar:\n        schedule (list[tuple[int, int]]): Her bir demetin haftanın her günü için okulda ve ek derslerde\n                                           geçirilen saat sayısını temsil ettiği 7 demetlik bir liste.\n                                           \n    Döndürür:\n        int: Jinjin'in en mutsuz olduğu haftanın günü (Pazartesi'den Pazar'a 1-7) veya hiç mutsuz değilse 0.\n    \n    Örnekler:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "vi": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Tính toán ngày trong tuần khi Jinjin cảm thấy không vui nhất dựa trên lịch trình của cô ấy.\n    \n    Jinjin cảm thấy không vui nếu tổng số giờ ở trường và lớp học thêm vượt quá 8 giờ trong một ngày.\n    Hàm này tìm ngày mà sự không vui của cô ấy là lớn nhất, tức là ngày mà tổng số giờ vượt quá ngưỡng\n    nhiều nhất. Nếu có nhiều ngày có mức độ không vui tối đa giống nhau, ngày sớm nhất sẽ được trả về.\n    Nếu Jinjin không cảm thấy không vui vào bất kỳ ngày nào, hàm trả về 0.\n    \n    Tham số:\n        schedule (list[tuple[int, int]]): Một danh sách gồm 7 bộ giá trị, mỗi bộ đại diện cho số giờ\n                                           ở trường và lớp học thêm cho mỗi ngày trong tuần, tương ứng.\n                                           \n    Trả về:\n        int: Ngày trong tuần khi Jinjin cảm thấy không vui nhất (1-7 cho Thứ Hai đến Chủ Nhật) hoặc 0\n             nếu cô ấy không bao giờ cảm thấy không vui.\n    \n    Trường hợp:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "id": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Hitung hari dalam seminggu ketika Jinjin paling tidak bahagia berdasarkan jadwalnya.\n    \n    Jinjin tidak bahagia jika total jam yang dihabiskan di sekolah dan kelas tambahan melebihi 8 jam dalam sehari.\n    Fungsi ini menemukan hari ketika ketidakbahagiaannya paling besar, yaitu hari ketika total\n    jam paling jauh di atas ambang batas. Jika ada beberapa hari dengan tingkat ketidakbahagiaan maksimum yang sama,\n    hari paling awal yang dikembalikan. Jika Jinjin tidak tidak bahagia pada hari apa pun,\n    fungsi mengembalikan 0.\n    \n    Argumen:\n        schedule (list[tuple[int, int]]): Daftar 7 tuple, di mana setiap tuple mewakili\n                                           jumlah jam yang dihabiskan di sekolah dan di kelas tambahan\n                                           untuk setiap hari dalam seminggu, masing-masing.\n                                           \n    Mengembalikan:\n        int: Hari dalam seminggu ketika Jinjin paling tidak bahagia (1-7 untuk Senin hingga Minggu) atau 0\n             jika dia tidak pernah tidak bahagia.\n    \n    Kasus:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "ja": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Jinjinのスケジュールに基づいて、最も不幸な曜日を計算します。\n    \n    Jinjinは、学校と追加クラスに費やす合計時間が1日に8時間を超えると不幸になります。\n    この関数は、彼女の不幸が最も大きい日、つまり合計時間が閾値を最も超えている日を見つけます。\n    最大の不幸レベルが同じ複数の日がある場合、最も早い日が返されます。Jinjinがどの日にも\n    不幸でない場合、この関数は0を返します。\n    \n    引数:\n        schedule (list[tuple[int, int]]): 各タプルがそれぞれの曜日の学校と追加クラスで\n                                           費やした時間を表す7つのタプルのリスト。\n                                           \n    戻り値:\n        int: Jinjinが最も不幸な曜日（1-7で月曜日から日曜日）または彼女が一度も不幸でない場合は0。\n    \n    ケース:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "ko": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Jinjin의 일정에 따라 Jinjin이 가장 불행한 요일을 계산합니다.\n    \n    Jinjin은 하루에 학교와 추가 수업에서 보낸 총 시간이 8시간을 초과하면 불행합니다. \n    이 함수는 Jinjin의 불행이 가장 큰 날, 즉 총 시간이 임계값을 가장 많이 초과하는 날을 찾습니다. \n    최대 불행 수준이 같은 날이 여러 개 있을 경우, 가장 빠른 날을 반환합니다. \n    Jinjin이 어느 날에도 불행하지 않으면, 함수는 0을 반환합니다.\n    \n    Args:\n        schedule (list[tuple[int, int]]): 각 요일에 대해 학교와 추가 수업에서 보낸 시간을 나타내는 \n                                           7개의 튜플로 구성된 리스트입니다.\n                                           \n    Returns:\n        int: Jinjin이 가장 불행한 요일 (월요일부터 일요일까지 1-7) 또는 그녀가 전혀 불행하지 않을 경우 0을 반환합니다.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "ml": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    ജിൻജിൻ തന്റെ ഷെഡ്യൂളിനെ അടിസ്ഥാനമാക്കി ഏറ്റവും അസന്തുഷ്ടമായ ആഴ്ചയിലെ ദിവസം കണക്കാക്കുക.\n    \n    ഒരു ദിവസം സ്കൂളിലും അധിക ക്ലാസ്സുകളിലും ചെലവഴിക്കുന്ന ആകെ മണിക്കൂറുകൾ 8 മണിക്കൂറുകൾക്കു മുകളിൽ ആയാൽ ജിൻജിൻ അസന്തുഷ്ടയാണ്. \n    ആകെ മണിക്കൂറുകൾ ഈ പരിധിയ്ക്ക് മുകളിലുള്ള ദിവസമാണ് അവളുടെ ഏറ്റവും വലിയ അസന്തോഷം ഉള്ളത്. \n    ഒരേ നിലവാരത്തിലുള്ള പരമാവധി അസന്തോഷമുള്ള നിരവധി ദിവസങ്ങൾ ഉണ്ടെങ്കിൽ, ഏറ്റവും ആദ്യം വരുന്ന ദിവസം തിരികെ നൽകുന്നു. \n    ജിൻജിൻ ഏതെങ്കിലും ദിവസവും അസന്തുഷ്ടയല്ലെങ്കിൽ, ഫങ്ഷൻ 0 തിരികെ നൽകുന്നു.\n    \n    Args:\n        schedule (list[tuple[int, int]]): 7 ട്യൂപ്പിളുകളുടെ ഒരു ലിസ്റ്റ്, ഓരോ ട്യൂപ്പിളും സ്കൂളിലും \n                                           അധിക ക്ലാസ്സുകളിലും ചെലവഴിക്കുന്ന മണിക്കൂറുകളുടെ എണ്ണം \n                                           ആഴ്ചയിലെ ഓരോ ദിവസത്തിനും യഥാക്രമം പ്രതിനിധീകരിക്കുന്നു.\n                                           \n    Returns:\n        int: ജിൻജിൻ ഏറ്റവും അസന്തുഷ്ടയായ ആഴ്ചയിലെ ദിവസം (തിങ്കളാഴ്ച മുതൽ ഞായറാഴ്ച വരെ 1-7) അല്ലെങ്കിൽ \n             അവൾ ഒരിക്കലും അസന്തുഷ്ടയല്ലെങ്കിൽ 0.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"", "fa": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    محاسبه روزی از هفته که جینجین بر اساس برنامه‌اش بیشترین ناراحتی را دارد.\n\n    جینجین ناراحت است اگر مجموع ساعات صرف شده در مدرسه و کلاس‌های اضافی در یک روز بیش از 8 ساعت باشد.\n    این تابع روزی را پیدا می‌کند که ناراحتی او بیشترین است، یعنی روزی که مجموع ساعات بیشترین فاصله را \n    از حد آستانه دارد. اگر چندین روز با همان سطح حداکثر ناراحتی وجود داشته باشد، اولین روز بازگردانده می‌شود.\n    اگر جینجین در هیچ روزی ناراحت نباشد، تابع 0 را برمی‌گرداند.\n\n    Args:\n        schedule (list[tuple[int, int]]): لیستی از 7 تاپل، که هر تاپل نشان‌دهنده تعداد ساعات صرف شده \n                                           در مدرسه و کلاس‌های اضافی برای هر روز از هفته است.\n\n    Returns:\n        int: روزی از هفته که جینجین بیشترین ناراحتی را دارد (1-7 برای دوشنبه تا یکشنبه) یا 0 \n             اگر او هرگز ناراحت نباشد.\n\n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\""}, "canonical_solution": "    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day", "instruction": {"en": "Write a python function 'def find_most_unhappy_day(schedule) -> int:' to solve the following problem:\n\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    ", "sq": "Shkruani një funksion python 'def find_most_unhappy_day(schedule) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni ditën e javës kur Jinjin është më e pakënaqur bazuar në orarin e saj.\n    \n    Jinjin është e pakënaqur nëse orët totale të kaluara në shkollë dhe në klasa shtesë tejkalojnë 8 orë në një ditë.\n    Funksioni gjen ditën kur pakënaqësia e saj është më e madhe, që është dita kur orët totale janë më larg pragut.\n    Nëse ka disa ditë me të njëjtin nivel të pakënaqësisë maksimale, kthehet dita më e hershme. Nëse Jinjin nuk është e\n    pakënaqur në asnjë ditë, funksioni kthen 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Një listë prej 7 treshesh, ku secili treshe përfaqëson\n                                           numrin e orëve të kaluara në shkollë dhe në klasa shtesë\n                                           për secilën ditë të javës, përkatësisht.\n                                           \n    Returns:\n        int: Dita e javës kur Jinjin është më e pakënaqur (1-7 për të hënën deri të dielën) ose 0 \n             nëse ajo nuk është kurrë e pakënaqur.\n    \n    Rastet:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "hy": "Պայթոն ֆունկցիա 'def find_most_unhappy_day(schedule) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել շաբաթվա այն օրը, երբ Ջինջինը ամենից դժգոհ է իր ժամանակացույցի հիման վրա։\n    \n    Ջինջինը դժգոհ է, եթե դպրոցում և լրացուցիչ դասերում անցկացրած ընդհանուր ժամերը գերազանցում են 8 ժամը մեկ օրում։ \n    Ֆունկցիան գտնում է այն օրը, երբ նրա դժգոհությունը ամենամեծն է, այսինքն այն օրը, երբ ընդհանուր \n    ժամերը ամենից շատ են գերազանցում շեմը։ Եթե կան մի քանի օրեր նույն մակարդակի \n    առավելագույն դժգոհությամբ, վերադարձվում է ամենավաղ օրը։ Եթե Ջինջինը ոչ մի օր դժգոհ չէ, \n    ֆունկցիան վերադարձնում է 0։\n    \n    Արգումենտներ:\n        schedule (list[tuple[int, int]]): 7 տուփերի ցուցակ, որտեղ յուրաքանչյուր տուփ ներկայացնում է \n                                           դպրոցում և լրացուցիչ դասերում անցկացրած ժամերի \n                                           քանակը շաբաթվա յուրաքանչյուր օրվա համար, համապատասխանաբար։\n                                           \n    Վերադարձնում է:\n        int: Շաբաթվա այն օրը, երբ Ջինջինը ամենից դժգոհ է (1-7 երկուշաբթիից կիրակի) կամ 0 \n             եթե նա երբեք դժգոհ չէ։\n    \n    Օրինակներ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "bn": "একটি পাইথন ফাংশন 'def find_most_unhappy_day(schedule) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    তার সময়সূচির উপর ভিত্তি করে সপ্তাহের কোন দিনে জিনজিন সবচেয়ে অসুখী তা গণনা করুন।\n    \n    জিনজিন অসুখী হয় যদি স্কুল এবং অতিরিক্ত ক্লাসে ব্যয় করা মোট সময় এক দিনে ৮ ঘণ্টার বেশি হয়।\n    ফাংশনটি সেই দিনটি খুঁজে বের করে যখন তার অসুখীতা সর্বাধিক হয়, যা সেই দিন যখন মোট\n    সময় সীমার উপরে সবচেয়ে বেশি থাকে। যদি একই স্তরের সর্বাধিক অসুখীতা সহ একাধিক দিন থাকে,\n    তাহলে প্রথম দিনটি ফেরত দেওয়া হয়। যদি জিনজিন কোনো দিনেই অসুখী না হয়, তাহলে\n    ফাংশনটি 0 ফেরত দেয়।\n    \n    আর্গুমেন্টস:\n        schedule (list[tuple[int, int]]): ৭টি টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল\n                                           সপ্তাহের প্রতিটি দিনের জন্য স্কুল এবং অতিরিক্ত ক্লাসে\n                                           ব্যয় করা ঘন্টার সংখ্যা প্রতিনিধিত্ব করে।\n                                           \n    রিটার্নস:\n        int: সপ্তাহের দিন যখন জিনজিন সবচেয়ে অসুখী (সোমবার থেকে রবিবারের জন্য ১-৭) অথবা ০\n             যদি সে কখনও অসুখী না হয়।\n    \n    কেস:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "bg": "Напишете Python функция 'def find_most_unhappy_day(schedule) -> int:', за да решите следния проблем:\n\n    Изчислете деня от седмицата, когато Джинджин е най-нещастна въз основа на нейния график.\n    \n    Джинджин е нещастна, ако общият брой часове, прекарани в училище и допълнителни класове, надвишава 8 часа на ден.\n    Функцията намира деня, когато нейното нещастие е най-голямо, което е денят, когато общият\n    брой часове е най-далеч над прага. Ако има няколко дни с едно и също ниво на\n    максимално нещастие, връща се най-ранният ден. Ако Джинджин не е нещастна в нито един ден,\n    функцията връща 0.\n    \n    Аргументи:\n        schedule (list[tuple[int, int]]): Списък от 7 кортежа, където всеки кортеж представлява\n                                           броя на часовете, прекарани в училище и в допълнителни класове\n                                           за всеки ден от седмицата, съответно.\n                                           \n    Връща:\n        int: Денят от седмицата, когато Джинджин е най-нещастна (1-7 за понеделник до неделя) или 0\n             ако никога не е нещастна.\n    \n    Примери:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "zh": "编写一个 Python 函数 'def find_most_unhappy_day(schedule) -> int:' 来解决以下问题：\n\n    根据她的日程安排计算 Jinjin 最不开心的一天。\n    \n    如果在学校和额外课程上花费的总时间超过一天 8 小时，Jinjin 就会不开心。\n    该函数找到她最不开心的一天，即总时间超过阈值最多的一天。\n    如果有多天达到相同的最大不开心程度，则返回最早的一天。\n    如果 Jinjin 在任何一天都不不开心，函数返回 0。\n    \n    参数:\n        schedule (list[tuple[int, int]]): 一个包含 7 个元组的列表，其中每个元组分别表示\n                                           每周每天在学校和额外课程上花费的小时数。\n                                           \n    返回:\n        int: Jinjin 最不开心的星期几（1-7 表示周一到周日）或如果她从不不开心则返回 0。\n    \n    示例:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "fr": "Écrivez une fonction python 'def find_most_unhappy_day(schedule) -> int:' pour résoudre le problème suivant :\n\n    Calculez le jour de la semaine où Jinjin est le plus malheureuse en fonction de son emploi du temps.\n    \n    Jinjin est malheureuse si le nombre total d'heures passées à l'école et en cours supplémentaires dépasse 8 heures par jour. \n    La fonction trouve le jour où son malheur est le plus grand, c'est-à-dire le jour où le total\n    d'heures dépasse le plus le seuil. S'il y a plusieurs jours avec le même niveau de \n    malheur maximal, le premier jour est retourné. Si Jinjin n'est pas malheureuse un jour quelconque, la \n    fonction retourne 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Une liste de 7 tuples, où chaque tuple représente le \n                                           nombre d'heures passées à l'école et en cours supplémentaires\n                                           pour chaque jour de la semaine, respectivement.\n                                           \n    Returns:\n        int: Le jour de la semaine où Jinjin est le plus malheureuse (1-7 pour lundi à dimanche) ou 0 \n             si elle n'est jamais malheureuse.\n    \n    Cas :\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "de": "Schreiben Sie eine Python-Funktion 'def find_most_unhappy_day(schedule) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie den Wochentag, an dem Jinjin basierend auf ihrem Stundenplan am unglücklichsten ist.\n    \n    Jinjin ist unglücklich, wenn die Gesamtstunden, die in der Schule und in zusätzlichen Klassen verbracht werden, 8 Stunden an einem Tag überschreiten. \n    Die Funktion findet den Tag, an dem ihr Unglück am größten ist, was der Tag ist, an dem die Gesamtstunden am weitesten über dem Schwellenwert liegen. Wenn es mehrere Tage mit dem gleichen Maß an maximalem Unglück gibt, wird der früheste Tag zurückgegeben. Wenn Jinjin an keinem Tag unglücklich ist, gibt die Funktion 0 zurück.\n    \n    Argumente:\n        schedule (list[tuple[int, int]]): Eine Liste von 7 Tupeln, wobei jedes Tupel die \n                                           Anzahl der Stunden darstellt, die in der Schule und in zusätzlichen Klassen\n                                           für jeden Tag der Woche verbracht werden.\n                                           \n    Rückgabe:\n        int: Der Wochentag, an dem Jinjin am unglücklichsten ist (1-7 für Montag bis Sonntag) oder 0, \n             wenn sie niemals unglücklich ist.\n    \n    Fälle:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "ha": "Rubuta wani aikin python 'def find_most_unhappy_day(schedule) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa ranar mako inda Jinjin take cikin rashin jin daɗi mafi yawa bisa jadawalin ta.\n    \n    Jinjin ba ta farin ciki ba idan jimlar awanni da aka kwashe a makaranta da karin aji sun wuce awanni 8 a rana.\n    Aikin yana gano ranar da rashin jin daɗin ta ya fi yawa, wato ranar da jimlar\n    awanni suka fi nesa da iyaka. Idan akwai ranaku da yawa tare da irin wannan matakin\n    na rashin jin daɗi mafi girma, ranar farko ce ake dawowa. Idan Jinjin ba ta cikin rashin jin daɗi a kowace rana, \n    aikin yana dawowa 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Jerin tuples guda 7, inda kowane tuple ke wakiltar \n                                           adadin awanni da aka kwashe a makaranta da karin aji\n                                           a kowane rana na mako, bi da bi.\n                                           \n    Returns:\n        int: Ranar mako inda Jinjin take cikin rashin jin daɗi mafi yawa (1-7 don Litinin zuwa Lahadi) ko 0 \n             idan ba ta taɓa kasancewa cikin rashin jin daɗi ba.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "hi": "एक पायथन फ़ंक्शन 'def find_most_unhappy_day(schedule) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    उसके कार्यक्रम के आधार पर उस सप्ताह के दिन की गणना करें जब जिनजिन सबसे अधिक दुखी होती है।\n    \n    जिनजिन दुखी होती है यदि स्कूल और अतिरिक्त कक्षाओं में बिताए गए कुल घंटे एक दिन में 8 घंटे से अधिक होते हैं।\n    फ़ंक्शन उस दिन को खोजता है जब उसकी दुख की स्थिति सबसे अधिक होती है, जो वह दिन होता है जब कुल घंटे\n    सीमा से सबसे अधिक ऊपर होते हैं। यदि अधिकतम दुख के समान स्तर वाले कई दिन हैं, तो सबसे पहला दिन लौटाया जाता है।\n    यदि जिनजिन किसी भी दिन दुखी नहीं होती है, तो फ़ंक्शन 0 लौटाता है।\n    \n    तर्क:\n        schedule (list[tuple[int, int]]): 7 ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल क्रमशः \n                                           सप्ताह के प्रत्येक दिन के लिए स्कूल और अतिरिक्त कक्षाओं में \n                                           बिताए गए घंटों की संख्या को दर्शाता है।\n                                           \n    लौटाता है:\n        int: वह सप्ताह का दिन जब जिनजिन सबसे अधिक दुखी होती है (सोमवार से रविवार के लिए 1-7) या 0 \n             यदि वह कभी दुखी नहीं होती है।\n    \n    मामले:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "hu": "Írj egy python függvényt 'def find_most_unhappy_day(schedule) -> int:' a következő probléma megoldására:\n\n    Számítsd ki, hogy a hét melyik napján a legboldogtalanabb Jinjin a beosztása alapján.\n    \n    Jinjin boldogtalan, ha az iskolában és a különórákon eltöltött összes óra meghaladja a napi 8 órát.\n    A függvény megkeresi azt a napot, amikor a boldogtalansága a legnagyobb, ami az a nap, amikor az összes\n    óra a legnagyobb mértékben haladja meg a küszöböt. Ha több nap is van azonos szintű maximális\n    boldogtalansággal, akkor a legkorábbi napot adja vissza. Ha Jinjin egyetlen napon sem boldogtalan,\n    a függvény 0-t ad vissza.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Egy 7 elemből álló lista, ahol minden elem egy tuple, amely\n                                           az iskolában és a különórákon eltöltött órák számát jelenti\n                                           a hét minden napjára vonatkozóan.\n                                           \n    Returns:\n        int: A hét azon napja, amikor Jinjin a legboldogtalanabb (1-7 hétfőtől vasárnapig) vagy 0,\n             ha soha nem boldogtalan.\n    \n    Esetek:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "es": "Escribe una función en Python 'def find_most_unhappy_day(schedule) -> int:' para resolver el siguiente problema:\n\n    Calcula el día de la semana en que Jinjin está más infeliz según su horario.\n    \n    Jinjin está infeliz si el total de horas pasadas en la escuela y clases extra excede las 8 horas en un día. \n    La función encuentra el día en que su infelicidad es mayor, que es el día cuando el total\n    de horas está más por encima del umbral. Si hay múltiples días con el mismo nivel de \n    máxima infelicidad, se devuelve el día más temprano. Si Jinjin no está infeliz en ningún día, la \n    función devuelve 0.\n    \n    Argumentos:\n        schedule (list[tuple[int, int]]): Una lista de 7 tuplas, donde cada tupla representa el \n                                           número de horas pasadas en la escuela y en clases extra\n                                           para cada día de la semana, respectivamente.\n                                           \n    Devuelve:\n        int: El día de la semana en que Jinjin está más infeliz (1-7 para lunes a domingo) o 0 \n             si nunca está infeliz.\n    \n    Casos:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "arb": "اكتب دالة بايثون 'def find_most_unhappy_day(schedule) -> int:' لحل المشكلة التالية:\n\n    احسب اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة بناءً على جدولها الزمني.\n    \n    تكون جينجين غير سعيدة إذا تجاوز إجمالي الساعات التي تقضيها في المدرسة والدروس الإضافية 8 ساعات في اليوم.\n    تبحث الدالة عن اليوم الذي تكون فيه تعاستها هي الأكبر، وهو اليوم الذي يكون فيه إجمالي\n    الساعات هو الأبعد عن الحد الأدنى. إذا كان هناك عدة أيام بنفس مستوى\n    التعاسة القصوى، يتم إرجاع اليوم الأسبق. إذا لم تكن جينجين غير سعيدة في أي يوم،\n    تعيد الدالة 0.\n    \n    يعيدالحجج:\n        schedule (list[tuple[int, int]]): قائمة من 7 مجموعات، حيث تمثل كل مجموعة\n                                           عدد الساعات التي تقضيها في المدرسة وفي الدروس الإضافية\n                                           لكل يوم من أيام الأسبوع، على التوالي.\n                                           \n    يعيد:\n        int: اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة (1-7 من الاثنين إلى الأحد) أو 0\n             إذا لم تكن غير سعيدة أبدًا.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "sw": "Andika kazi ya python 'def find_most_unhappy_day(schedule) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu siku ya wiki ambayo Jinjin ana huzuni zaidi kulingana na ratiba yake.\n    \n    Jinjin ana huzuni ikiwa jumla ya masaa yaliyotumika shuleni na madarasa ya ziada yanazidi masaa 8 kwa siku. \n    Kazi inapata siku ambayo huzuni yake ni kubwa zaidi, ambayo ni siku ambapo jumla ya masaa ni zaidi ya kiwango\n    cha juu. Ikiwa kuna siku nyingi zenye kiwango sawa cha huzuni ya juu, siku ya mapema zaidi inarudishwa. Ikiwa \n    Jinjin hana huzuni siku yoyote, kazi inarudisha 0.\n    \n    Hoja:\n        schedule (list[tuple[int, int]]): Orodha ya jozi 7, ambapo kila jozi inawakilisha \n                                           idadi ya masaa yaliyotumika shuleni na katika madarasa ya ziada\n                                           kwa kila siku ya wiki, mtawalia.\n                                           \n    Inarejesha:\n        int: Siku ya wiki ambayo Jinjin ana huzuni zaidi (1-7 kwa Jumatatu hadi Jumapili) au 0 \n             ikiwa hajawahi kuwa na huzuni.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "tr": "Bir python fonksiyonu 'def find_most_unhappy_day(schedule) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Jinjin'in programına göre en mutsuz olduğu haftanın gününü hesaplayın.\n    \n    Jinjin, bir gün içinde okulda ve ek derslerde geçirilen toplam saatler 8 saati aşıyorsa mutsuz olur. \n    Fonksiyon, mutsuzluğun en fazla olduğu günü bulur; bu, toplam saatlerin eşik değerin en fazla \n    üzerinde olduğu gündür. Eğer birden fazla gün aynı seviyede maksimum mutsuzluk içeriyorsa, en \n    erken gün döndürülür. Jinjin herhangi bir günde mutsuz değilse, fonksiyon 0 döndürür.\n    \n    Argümanlar:\n        schedule (list[tuple[int, int]]): Her bir gün için okulda ve ek derslerde geçirilen saat \n                                           sayısını temsil eden 7 demetlik bir liste.\n                                           \n    Döndürür:\n        int: Jinjin'in en mutsuz olduğu haftanın günü (Pazartesi'den Pazar'a 1-7) veya hiç mutsuz \n             değilse 0.\n    \n    Durumlar:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "vi": "Viết một hàm python 'def find_most_unhappy_day(schedule) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán ngày trong tuần khi Jinjin cảm thấy không vui nhất dựa trên lịch trình của cô ấy.\n    \n    Jinjin cảm thấy không vui nếu tổng số giờ ở trường và lớp học thêm vượt quá 8 giờ trong một ngày.\n    Hàm tìm ngày mà sự không vui của cô ấy là lớn nhất, đó là ngày khi tổng số giờ vượt quá ngưỡng nhiều nhất. \n    Nếu có nhiều ngày có mức độ không vui tối đa giống nhau, ngày sớm nhất sẽ được trả về. \n    Nếu Jinjin không cảm thấy không vui vào bất kỳ ngày nào, hàm trả về 0.\n    \n    Tham số:\n        schedule (list[tuple[int, int]]): Một danh sách gồm 7 bộ giá trị, mỗi bộ giá trị đại diện cho\n                                           số giờ ở trường và lớp học thêm cho mỗi ngày trong tuần, tương ứng.\n                                           \n    Trả về:\n        int: Ngày trong tuần khi Jinjin cảm thấy không vui nhất (1-7 cho Thứ Hai đến Chủ Nhật) hoặc 0\n             nếu cô ấy không bao giờ cảm thấy không vui.\n    \n    Trường hợp:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "id": "Tulis sebuah fungsi python 'def find_most_unhappy_day(schedule) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung hari dalam seminggu ketika Jinjin paling tidak bahagia berdasarkan jadwalnya.\n    \n    Jinjin tidak bahagia jika total jam yang dihabiskan di sekolah dan kelas tambahan melebihi 8 jam dalam sehari.\n    Fungsi ini menemukan hari ketika ketidakbahagiaannya paling besar, yaitu hari ketika total\n    jam paling jauh di atas ambang batas. Jika ada beberapa hari dengan tingkat ketidakbahagiaan maksimum yang sama,\n    hari yang paling awal dikembalikan. Jika Jinjin tidak tidak bahagia pada hari apa pun,\n    fungsi mengembalikan 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Daftar 7 tuple, di mana setiap tuple mewakili\n                                           jumlah jam yang dihabiskan di sekolah dan di kelas tambahan\n                                           untuk setiap hari dalam seminggu, masing-masing.\n                                           \n    Returns:\n        int: Hari dalam seminggu ketika Jinjin paling tidak bahagia (1-7 untuk Senin hingga Minggu) atau 0\n             jika dia tidak pernah tidak bahagia.\n    \n    Kasus:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "ja": "Python関数を書いてください。 'def find_most_unhappy_day(schedule) -> int:' を作成して、次の問題を解決してください:\n\n    Jinjinのスケジュールに基づいて、彼女が最も不幸な曜日を計算します。\n    \n    Jinjinは、学校と追加クラスで過ごす合計時間が1日に8時間を超えると不幸になります。\n    この関数は、彼女の不幸が最も大きい日、つまり合計時間が閾値を最も超えている日を見つけます。\n    最大の不幸のレベルが同じ日が複数ある場合、最も早い日を返します。Jinjinがどの日も不幸でない場合、\n    関数は0を返します。\n    \n    Args:\n        schedule (list[tuple[int, int]]): 各曜日における学校と追加クラスで過ごす時間を表す\n                                           7つのタプルのリスト。\n                                           \n    Returns:\n        int: Jinjinが最も不幸な曜日（1-7で月曜日から日曜日）または彼女が決して不幸でない場合は0。\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "ko": "파이썬 함수를 작성하세요 'def find_most_unhappy_day(schedule) -> int:' 다음 문제를 해결하기 위해:\n\n    Jinjin의 일정에 따라 Jinjin이 가장 불행한 요일을 계산합니다.\n    \n    Jinjin은 학교와 추가 수업에서 보낸 총 시간이 하루에 8시간을 초과하면 불행합니다.\n    이 함수는 그녀의 불행이 가장 큰 날, 즉 총 시간이 임계값을 가장 많이 초과하는 날을 찾습니다.\n    최대 불행 수준이 같은 날이 여러 날인 경우 가장 빠른 날을 반환합니다. Jinjin이 어떤 날에도 불행하지 않으면,\n    함수는 0을 반환합니다.\n    \n    인수:\n        schedule (list[tuple[int, int]]): 각 튜플이 각각의 요일에 학교와 추가 수업에서 보낸 시간을 나타내는\n                                           7개의 튜플의 리스트입니다.\n                                           \n    반환:\n        int: Jinjin이 가장 불행한 요일 (월요일부터 일요일까지 1-7) 또는 그녀가 전혀 불행하지 않으면 0을 반환합니다.\n    \n    사례:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "ml": "'def find_most_unhappy_day(schedule) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    ജിൻജിന്റെ ഷെഡ്യൂളിനെ അടിസ്ഥാനമാക്കി അവൾ ഏറ്റവും അസന്തുഷ്ടയായ ദിവസത്തെ കണക്കാക്കുക.\n    \n    ഒരു ദിവസം സ്കൂളിലും അധിക ക്ലാസ്സുകളിലും ചെലവഴിക്കുന്ന മൊത്തം മണിക്കൂറുകൾ 8 മണിക്കൂറുകൾക്കു മുകളിൽ ആയാൽ ജിൻജിൻ അസന്തുഷ്ടയാണ്. \n    അവളുടെ അസന്തോഷം ഏറ്റവും കൂടുതലായ ദിവസം ഫംഗ്ഷൻ കണ്ടെത്തുന്നു, ഇത് മൊത്തം മണിക്കൂറുകൾ പരിധിയ്ക്കു മുകളിൽ ഏറ്റവും കൂടുതലായ ദിവസമാണ്. \n    ഒരേ തോതിലുള്ള പരമാവധി അസന്തോഷമുള്ള നിരവധി ദിവസങ്ങൾ ഉണ്ടെങ്കിൽ, ഏറ്റവും ആദ്യത്തെ ദിവസം തിരികെ നൽകുന്നു. \n    ജിൻജിൻ ഏതെങ്കിലും ദിവസവും അസന്തുഷ്ടയല്ലെങ്കിൽ, ഫംഗ്ഷൻ 0 തിരികെ നൽകുന്നു.\n    \n    Args:\n        schedule (list[tuple[int, int]]): 7 ട്യൂപ്പിളുകളുടെ ഒരു ലിസ്റ്റ്, ഓരോ ട്യൂപ്പിളും \n                                           ആഴ്ചയിലെ ഓരോ ദിവസവും സ്കൂളിലും അധിക ക്ലാസ്സുകളിലും \n                                           ചെലവഴിക്കുന്ന മണിക്കൂറുകളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്നു.\n                                           \n    Returns:\n        int: ജിൻജിൻ ഏറ്റവും അസന്തുഷ്ടയായ ആഴ്ചയിലെ ദിവസം (തിങ്കളാഴ്ച മുതൽ ഞായറാഴ്ച വരെ 1-7) അല്ലെങ്കിൽ \n             അവൾ ഒരിക്കലും അസന്തുഷ്ടയല്ലെങ്കിൽ 0.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "fa": "یک تابع پایتون 'def find_most_unhappy_day(schedule) -> int:' بنویسید تا مسئله زیر را حل کند:\n\n    روزی از هفته را محاسبه کنید که جینجین بر اساس برنامه‌اش بیشتر ناراضی است.\n    \n    جینجین ناراضی است اگر مجموع ساعات صرف شده در مدرسه و کلاس‌های اضافی در یک روز بیش از 8 ساعت باشد.\n    تابع روزی را پیدا می‌کند که ناراحتی او بیشترین است، که همان روزی است که مجموع ساعات بیشترین فاصله را\n    از حد آستانه دارد. اگر چندین روز با همان سطح حداکثر ناراحتی وجود داشته باشد، اولین روز بازگردانده می‌شود.\n    اگر جینجین در هیچ روزی ناراضی نباشد، تابع 0 را برمی‌گرداند.\n    \n    آرگومان‌ها:\n        schedule (list[tuple[int, int]]): یک لیست از 7 تاپل، که هر تاپل نشان‌دهنده \n                                           تعداد ساعات صرف شده در مدرسه و کلاس‌های اضافی\n                                           برای هر روز هفته است.\n                                           \n    بازگشت:\n        int: روزی از هفته که جینجین بیشتر ناراضی است (1-7 برای دوشنبه تا یکشنبه) یا 0 \n             اگر او هرگز ناراضی نباشد.\n    \n    موارد:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0"}, "level": "easy", "test": "def test_find_most_unhappy_day():\n    # Test case 1: Provided example where Jinjin is most unhappy on Wednesday\n    schedule1 = [\n        (5, 3),\n        (6, 2),\n        (7, 2),\n        (5, 3),\n        (5, 4),\n        (0, 4),\n        (0, 6)\n    ]\n    assert find_most_unhappy_day(schedule1) == 3, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin is never unhappy\n    schedule2 = [\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule2) == 0, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin is most unhappy on Monday and Thursday, but Monday should be returned\n    schedule3 = [\n        (6, 3),\n        (6, 2),\n        (6, 2),\n        (6, 3),\n        (6, 2),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule3) == 1, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_find_most_unhappy_day()", "entry_point": "find_most_unhappy_day", "signature": "def find_most_unhappy_day(schedule) -> int:", "docstring": {"en": "\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    ", "sq": "\n    Llogarit ditën e javës kur Jinjin është më e pakënaqur bazuar në orarin e saj.\n    \n    Jinjin është e pakënaqur nëse orët totale të kaluara në shkollë dhe klasa shtesë tejkalojnë 8 orë në një ditë.\n    Funksioni gjen ditën kur pakënaqësia e saj është më e madhe, që është dita kur orët totale janë më larg mbi pragun.\n    Nëse ka disa ditë me të njëjtin nivel të pakënaqësisë maksimale, kthehet dita më e hershme.\n    Nëse Jinjin nuk është e pakënaqur në asnjë ditë, funksioni kthen 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Një listë prej 7 treshesh, ku çdo treshe përfaqëson\n                                           numrin e orëve të kaluara në shkollë dhe në klasa shtesë\n                                           për çdo ditë të javës, respektivisht.\n                                           \n    Returns:\n        int: Dita e javës kur Jinjin është më e pakënaqur (1-7 për të hënën deri të dielën) ose 0\n             nëse ajo nuk është kurrë e pakënaqur.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "hy": "\n    Հաշվեք շաբաթվա այն օրը, երբ Ջինջինը ամենաանհաջողն է իր ժամանակացույցի հիման վրա։\n    \n    Ջինջինը դժգոհ է, եթե դպրոցում և լրացուցիչ դասերին անցկացրած ընդհանուր ժամերը գերազանցում են 8 ժամը մեկ օրվա ընթացքում։\n    Ֆունկցիան գտնում է այն օրը, երբ նրա դժգոհությունը ամենամեծն է, այսինքն՝ այն օրը, երբ ընդհանուր ժամերը առավելագույնս գերազանցում են շեմը։\n    Եթե կան մի քանի օրեր նույն մակարդակի առավելագույն դժգոհությամբ, վերադարձվում է ամենավաղ օրը։\n    Եթե Ջինջինը ոչ մի օր դժգոհ չէ, ֆունկցիան վերադարձնում է 0։\n    \n    Արգումենտներ:\n        schedule (list[tuple[int, int]]): 7 տուփերի ցուցակ, որտեղ յուրաքանչյուր տուփ ներկայացնում է\n                                           դպրոցում և լրացուցիչ դասերին անցկացրած ժամերի քանակը\n                                           շաբաթվա յուրաքանչյուր օրվա համար, համապատասխանաբար։\n                                           \n    Վերադարձնում է:\n        int: Շաբաթվա այն օրը, երբ Ջինջինը ամենաանհաջողն է (1-7 երկուշաբթիից կիրակի) կամ 0,\n             եթե նա երբեք դժգոհ չէ։\n    \n    Օրինակներ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "bn": "\n    জিনজিনের সময়সূচির উপর ভিত্তি করে সপ্তাহের কোন দিনটি তার সবচেয়ে অখুশি দিন তা হিসাব করুন।\n    \n    যদি জিনজিনের স্কুল এবং অতিরিক্ত ক্লাসে ব্যয় করা মোট সময় এক দিনে 8 ঘন্টা অতিক্রম করে, তবে সে অখুশি হয়। \n    ফাংশনটি সেই দিনটি খুঁজে বের করে যখন তার অখুশি হওয়ার মাত্রা সবচেয়ে বেশি, অর্থাৎ যেদিন মোট সময় \n    থ্রেশহোল্ডের উপরে সবচেয়ে বেশি। যদি একই স্তরের সর্বাধিক অখুশি হওয়ার একাধিক দিন থাকে, তবে সবচেয়ে \n    প্রথম দিনটি ফেরত দেওয়া হয়। যদি জিনজিন কোনও দিনই অখুশি না হয়, তবে ফাংশনটি 0 ফেরত দেয়।\n    \n    Args:\n        schedule (list[tuple[int, int]]): 7টি টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল \n                                           সপ্তাহের প্রতিদিনের জন্য স্কুল এবং অতিরিক্ত ক্লাসে \n                                           ব্যয় করা ঘন্টার সংখ্যা উপস্থাপন করে।\n                                           \n    Returns:\n        int: সপ্তাহের দিনটি যখন জিনজিন সবচেয়ে অখুশি (সোমবার থেকে রবিবারের জন্য 1-7) বা \n             0 যদি সে কখনও অখুশি না হয়।\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "bg": "\n    Изчислете деня от седмицата, когато Джинджин е най-нещастна въз основа на нейния график.\n    \n    Джинджин е нещастна, ако общият брой часове, прекарани в училище и допълнителни часове, надвишава 8 часа на ден.\n    Функцията намира деня, когато нещастието й е най-голямо, което е денят, когато общият брой часове е най-далеч\n    над прага. Ако има няколко дни със същото ниво на максимално нещастие, се връща най-ранният ден. Ако Джинджин\n    не е нещастна в нито един ден, функцията връща 0.\n    \n    Аргументи:\n        schedule (list[tuple[int, int]]): Списък от 7 кортежа, където всеки кортеж представлява\n                                           броя часове, прекарани в училище и в допълнителни часове\n                                           за всеки ден от седмицата, съответно.\n                                           \n    Връща:\n        int: Денят от седмицата, когато Джинджин е най-нещастна (1-7 за понеделник до неделя) или 0\n             ако никога не е нещастна.\n    \n    Примери:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "zh": "\n    计算根据金金的日程安排她最不开心的那一天。\n    \n    如果金金在学校和额外课程中度过的总时间超过8小时，她就会不开心。\n    该函数找到她不开心程度最大的那一天，即总小时数最远超过阈值的那一天。\n    如果有多天具有相同程度的最大不开心，返回最早的一天。\n    如果金金在任何一天都不不开心，函数返回0。\n    \n    参数:\n        schedule (list[tuple[int, int]]): 一个包含7个元组的列表，每个元组分别表示\n                                           每周每天在学校和额外课程中度过的小时数。\n                                           \n    返回:\n        int: 金金最不开心的那一天（1-7表示周一到周日），如果她从未不开心则返回0。\n    \n    示例:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "fr": "\n    Calculer le jour de la semaine où Jinjin est le plus malheureuse en fonction de son emploi du temps.\n    \n    Jinjin est malheureuse si le total des heures passées à l'école et aux cours supplémentaires dépasse 8 heures par jour.\n    La fonction trouve le jour où son malheur est le plus grand, c'est-à-dire le jour où le total des heures dépasse le plus le seuil.\n    S'il y a plusieurs jours avec le même niveau de malheur maximal, le premier jour est retourné. Si Jinjin n'est malheureuse aucun jour,\n    la fonction retourne 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Une liste de 7 tuples, où chaque tuple représente le\n                                           nombre d'heures passées à l'école et aux cours supplémentaires\n                                           pour chaque jour de la semaine, respectivement.\n                                           \n    Returns:\n        int: Le jour de la semaine où Jinjin est le plus malheureuse (1-7 pour lundi à dimanche) ou 0\n             si elle n'est jamais malheureuse.\n    \n    Cas:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "de": "\n    Berechne den Wochentag, an dem Jinjin am unglücklichsten ist, basierend auf ihrem Stundenplan.\n    \n    Jinjin ist unglücklich, wenn die Gesamtstunden, die sie in der Schule und in zusätzlichen Kursen verbringt, an einem Tag 8 Stunden überschreiten.\n    Die Funktion findet den Tag, an dem ihr Unglück am größten ist, also den Tag, an dem die Gesamtstunden am weitesten über dem Schwellenwert liegen.\n    Wenn es mehrere Tage mit dem gleichen Maß an maximalem Unglück gibt, wird der früheste Tag zurückgegeben.\n    Wenn Jinjin an keinem Tag unglücklich ist, gibt die Funktion 0 zurück.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Eine Liste von 7 Tupeln, wobei jedes Tupel die Anzahl der Stunden darstellt,\n                                           die an jedem Wochentag in der Schule und in zusätzlichen Kursen verbracht werden.\n                                           \n    Returns:\n        int: Der Wochentag, an dem Jinjin am unglücklichsten ist (1-7 für Montag bis Sonntag) oder 0, wenn sie nie unglücklich ist.\n    \n    Fälle:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "ha": "\n    Lissafa ranar mako lokacin da Jinjin take cikin rashin farin ciki mafi yawa bisa ga jadawalin ta.\n    \n    Jinjin tana cikin rashin farin ciki idan adadin awanni da aka kwashe a makaranta da kuma karin azuzuwan sun wuce awanni 8 a rana.\n    Aikin yana gano ranar da rashin farin cikinta ya fi yawa, wato ranar da adadin awanni ya fi nesa da iyaka.\n    Idan akwai ranaku da dama da ke da irin wannan matakin rashin farin ciki mafi girma, ranar da ta zo da wuri za a mayar.\n    Idan Jinjin ba ta cikin rashin farin ciki a kowace rana, aikin yana mayar da 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Jerin tuples guda 7, inda kowanne tuple ke wakiltar \n                                           adadin awanni da aka kwashe a makaranta da kuma karin azuzuwan\n                                           don kowace rana ta mako, bi da bi.\n                                           \n    Returns:\n        int: Ranar mako lokacin da Jinjin take cikin rashin farin ciki mafi yawa (1-7 don Litinin zuwa Lahadi) ko 0 \n             idan ba ta taɓa kasancewa cikin rashin farin ciki ba.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "hi": "\n    जिनजिन के शेड्यूल के आधार पर वह किस दिन सबसे ज्यादा दुखी होती है, यह गणना करें।\n    \n    जिनजिन दुखी होती है यदि स्कूल और अतिरिक्त कक्षाओं में बिताए गए कुल घंटे किसी दिन में 8 घंटे से अधिक हो जाते हैं। \n    यह फ़ंक्शन उस दिन को ढूंढता है जब उसकी दुख की मात्रा सबसे अधिक होती है, अर्थात वह दिन जब कुल घंटे सीमा से सबसे अधिक ऊपर होते हैं। \n    यदि कई दिनों में समान स्तर की अधिकतम दुख होती है, तो सबसे पहले आने वाला दिन लौटाया जाता है। \n    यदि जिनजिन किसी भी दिन दुखी नहीं होती है, तो फ़ंक्शन 0 लौटाता है।\n    \n    तर्क:\n        schedule (list[tuple[int, int]]): 7 ट्यूपल की एक सूची, जहां प्रत्येक ट्यूपल सप्ताह के प्रत्येक दिन के लिए \n                                           स्कूल और अतिरिक्त कक्षाओं में बिताए गए घंटों की संख्या का प्रतिनिधित्व करता है।\n                                           \n    लौटाता है:\n        int: वह सप्ताह का दिन जब जिनजिन सबसे ज्यादा दुखी होती है (सोमवार से रविवार के लिए 1-7) या 0 \n             यदि वह कभी दुखी नहीं होती है।\n    \n    उदाहरण:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "hu": "\n    Számítsd ki, hogy a hét melyik napján a legboldogtalanabb Jinjin a napirendje alapján.\n    \n    Jinjin boldogtalan, ha az iskolában és a különórákon töltött összes idő meghaladja a napi 8 órát. \n    A függvény megtalálja azt a napot, amikor a boldogtalansága a legnagyobb, ami az a nap, amikor az \n    összóraszám a legjobban meghaladja a küszöböt. Ha több nap is azonos szintű maximális boldogtalanságot \n    mutat, akkor a legkorábbi napot adja vissza. Ha Jinjin egy napon sem boldogtalan, a függvény 0-t ad vissza.\n    \n    Paraméterek:\n        schedule (list[tuple[int, int]]): Egy 7 elemből álló lista, ahol minden elem egy tuple, amely az \n                                           iskolában és a különórákon töltött órák számát jelenti a hét \n                                           minden napjára vonatkozóan.\n                                           \n    Visszatérési érték:\n        int: A hét azon napja, amikor Jinjin a legboldogtalanabb (1-7 hétfőtől vasárnapig) vagy 0, \n             ha soha nem boldogtalan.\n    \n    Esetek:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "es": "    Calcular el día de la semana cuando Jinjin está más infeliz según su horario.\n    \n    Jinjin está infeliz si el total de horas pasadas en la escuela y clases extra excede 8 horas en un día.\n    La función encuentra el día cuando su infelicidad es mayor, que es el día cuando el total\n    de horas está más por encima del umbral. Si hay múltiples días con el mismo nivel de\n    máxima infelicidad, se devuelve el primer día. Si Jinjin no está infeliz en ningún día, la\n    función devuelve 0.\n    \n    Argumentos:\n        schedule (list[tuple[int, int]]): Una lista de 7 tuplas, donde cada tupla representa el \n                                           número de horas pasadas en la escuela y en clases extra\n                                           para cada día de la semana, respectivamente.\n                                           \n    Devuelve:\n        int: El día de la semana cuando Jinjin está más infeliz (1-7 para lunes a domingo) o 0 \n             si nunca está infeliz.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "arb": "    حساب اليوم الذي تكون فيه جينجين الأكثر تعاسة بناءً على جدولها الزمني.\n    \n    تكون جينجين غير سعيدة إذا تجاوز إجمالي الساعات التي تقضيها في المدرسة والدروس الإضافية 8 ساعات في اليوم.\n    تقوم الدالة بالعثور على اليوم الذي تكون فيه تعاستها في أقصى حد، وهو اليوم الذي يكون فيه إجمالي\n    الساعات أبعد ما يكون عن العتبة. إذا كان هناك عدة أيام بنفس مستوى التعاسة القصوى، يتم إرجاع اليوم\n    الأسبق. إذا لم تكن جينجين غير سعيدة في أي يوم، تقوم الدالة بإرجاع 0.\n    \n    يعيدالحجج:\n        schedule (list[tuple[int, int]]): قائمة تحتوي على 7 مجموعات، حيث تمثل كل مجموعة\n                                           عدد الساعات التي تقضيها في المدرسة والدروس الإضافية\n                                           لكل يوم من أيام الأسبوع، على التوالي.\n                                           \n    يعيد:\n        int: اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة (1-7 من الاثنين إلى الأحد) أو 0\n             إذا لم تكن غير سعيدة أبداً.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "sw": "    Hesabu siku ya wiki ambayo Jinjin ana huzuni zaidi kulingana na ratiba yake.\n    \n    Jinjin ana huzuni ikiwa jumla ya saa zilizotumika shuleni na madarasa ya ziada inazidi saa 8 kwa siku. \n    Kazi hii inapata siku ambayo huzuni yake ni kubwa zaidi, ambayo ni siku ambapo jumla ya saa ni zaidi \n    ya kiwango cha juu zaidi. Ikiwa kuna siku nyingi zilizo na kiwango sawa cha huzuni ya juu zaidi, siku \n    ya mapema zaidi inarejeshwa. Ikiwa Jinjin hana huzuni siku yoyote, kazi inarejesha 0.\n    \n    Hoja:\n        schedule (list[tuple[int, int]]): Orodha ya jozi 7, ambapo kila jozi inawakilisha \n                                           idadi ya saa zilizotumika shuleni na katika madarasa ya ziada\n                                           kwa kila siku ya wiki, mtawalia.\n                                           \n    Inarejesha:\n        int: Siku ya wiki ambayo Jinjin ana huzuni zaidi (1-7 kwa Jumatatu hadi Jumapili) au 0 \n             ikiwa hana huzuni kamwe.\n    \n    Mifano:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "tr": "    Jinjin'in programına göre en mutsuz olduğu günü hesaplayın.\n    \n    Jinjin, okulda ve ek derslerde geçirilen toplam saatlerin bir günde 8 saati aşması durumunda mutsuz olur.\n    Fonksiyon, mutsuzluğunun en fazla olduğu günü bulur, bu da toplam saatlerin eşik değerin en fazla üzerinde\n    olduğu gündür. Eğer birden fazla gün aynı seviyede maksimum mutsuzluk içeriyorsa, en erken gün döndürülür.\n    Jinjin herhangi bir günde mutsuz değilse, fonksiyon 0 döndürür.\n    \n    Argümanlar:\n        schedule (list[tuple[int, int]]): Her bir gün için sırasıyla okulda ve ek derslerde geçirilen\n                                           saatleri temsil eden 7 demetlik bir liste.\n                                           \n    Döndürür:\n        int: Jinjin'in en mutsuz olduğu haftanın günü (Pazartesi için 1, Pazar için 7) veya hiç mutsuz\n             değilse 0.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "vi": "    Tính toán ngày trong tuần khi Jinjin cảm thấy không vui nhất dựa trên lịch trình của cô ấy.\n    \n    Jinjin cảm thấy không vui nếu tổng số giờ ở trường và lớp học thêm vượt quá 8 giờ trong một ngày.\n    Hàm này tìm ra ngày mà sự không vui của cô ấy là lớn nhất, đó là ngày mà tổng số giờ vượt quá\n    ngưỡng nhiều nhất. Nếu có nhiều ngày có mức độ không vui tối đa giống nhau, ngày sớm nhất sẽ\n    được trả về. Nếu Jinjin không cảm thấy không vui vào bất kỳ ngày nào, hàm sẽ trả về 0.\n    \n    Tham số:\n        schedule (list[tuple[int, int]]): Một danh sách gồm 7 bộ giá trị, mỗi bộ đại diện cho\n                                           số giờ ở trường và lớp học thêm cho mỗi ngày trong tuần.\n                                           \n    Trả về:\n        int: Ngày trong tuần khi Jinjin cảm thấy không vui nhất (1-7 cho Thứ Hai đến Chủ Nhật) hoặc 0\n             nếu cô ấy không bao giờ cảm thấy không vui.\n    \n    Ví dụ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "id": "    Hitung hari dalam seminggu ketika Jinjin paling tidak bahagia berdasarkan jadwalnya.\n    \n    Jinjin tidak bahagia jika total jam yang dihabiskan di sekolah dan kelas tambahan melebihi 8 jam dalam sehari.\n    Fungsi ini menemukan hari ketika ketidakbahagiaannya paling besar, yaitu hari ketika total\n    jam paling jauh di atas ambang batas. Jika ada beberapa hari dengan tingkat ketidakbahagiaan maksimum yang sama,\n    hari yang paling awal dikembalikan. Jika Jinjin tidak tidak bahagia pada hari apa pun,\n    fungsi mengembalikan 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Daftar 7 tuple, di mana setiap tuple mewakili\n                                           jumlah jam yang dihabiskan di sekolah dan di kelas tambahan\n                                           untuk setiap hari dalam seminggu, masing-masing.\n                                           \n    Returns:\n        int: Hari dalam seminggu ketika Jinjin paling tidak bahagia (1-7 untuk Senin hingga Minggu) atau 0\n             jika dia tidak pernah tidak bahagia.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "ja": "    Jinjinのスケジュールに基づいて、最も不幸な曜日を計算します。\n    \n    Jinjinは、学校と追加授業に費やす合計時間が1日で8時間を超えると不幸になります。\n    この関数は、彼女の不幸が最も大きい日を見つけます。それは、合計時間が閾値を最も超えている日です。\n    最大の不幸のレベルが同じ日が複数ある場合、最も早い日が返されます。Jinjinがどの日にも不幸でない場合、関数は0を返します。\n    \n    引数:\n        schedule (list[tuple[int, int]]): 各タプルがそれぞれ週の各日の学校と追加授業に費やした時間を表す\n                                           7つのタプルのリスト。\n                                           \n    戻り値:\n        int: Jinjinが最も不幸な曜日（1-7で月曜日から日曜日）または彼女が決して不幸でない場合は0。\n    \n    ケース:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "ko": "    Jinjin이 그녀의 일정에 따라 가장 불행한 요일을 계산합니다.\n    \n    Jinjin은 학교와 보충 수업에 보낸 총 시간이 하루에 8시간을 초과하면 불행합니다.\n    이 함수는 그녀의 불행이 가장 큰 날을 찾습니다. 이는 총 시간이 임계값을 가장 많이 초과한 날입니다.\n    최대 불행 수준이 같은 날이 여러 개 있는 경우, 가장 이른 날이 반환됩니다. Jinjin이 어떤 날에도 불행하지 않으면,\n    함수는 0을 반환합니다.\n    \n    인수:\n        schedule (list[tuple[int, int]]): 각 튜플이 각각 주중 하루의 학교와 보충 수업에 보낸 시간을 나타내는\n                                           7개의 튜플로 구성된 리스트입니다.\n                                           \n    반환:\n        int: Jinjin이 가장 불행한 요일 (월요일부터 일요일까지 1-7) 또는 그녀가 전혀 불행하지 않다면 0입니다.\n    \n    사례:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "ml": "    ജിൻജിൻ ഏറ്റവും അസന്തുഷ്ടയാകുന്ന ആഴ്ചയിലെ ദിവസം അവളുടെ സമയക്രമത്തെ അടിസ്ഥാനമാക്കി കണക്കാക്കുക.\n    \n    ഒരു ദിവസത്തിൽ സ്കൂളിലും അധിക ക്ലാസുകളിലും ചെലവഴിക്കുന്ന മൊത്തം മണിക്കൂറുകൾ 8 മണിക്കൂറുകൾക്ക് മുകളിൽ ആയാൽ ജിൻജിൻ അസന്തുഷ്ടയാകുന്നു.\n    ഈ ഫംഗ്ഷൻ അവളുടെ അസന്തോഷം ഏറ്റവും കൂടിയ ദിവസത്തെ കണ്ടെത്തുന്നു, അതായത് മൊത്തം മണിക്കൂറുകൾ പരിധിയേക്കാൾ ഏറ്റവും കൂടുതൽ ആയിരിക്കുന്ന ദിവസമാണ്.\n    പരമാവധി അസന്തോഷം ഒരേ നിലയിലുള്ള നിരവധി ദിവസങ്ങൾ ഉണ്ടെങ്കിൽ, ഏറ്റവും ആദ്യം വരുന്ന ദിവസം തിരികെ നൽകപ്പെടുന്നു.\n    ജിൻജിൻ ഒരു ദിവസത്തിലും അസന്തുഷ്ടയല്ലെങ്കിൽ, ഫംഗ്ഷൻ 0 തിരികെ നൽകുന്നു.\n    \n    Args:\n        schedule (list[tuple[int, int]]): 7 ട്യൂപ്പിളുകളുടെ ഒരു പട്ടിക, ഓരോ ട്യൂപ്പിളും ഓരോ ദിവസവും സ്കൂളിലും അധിക ക്ലാസുകളിലും ചെലവഴിക്കുന്ന \n                                           മണിക്കൂറുകളുടെ എണ്ണം പ്രതിനിധീകരിക്കുന്നു.\n                                           \n    Returns:\n        int: ജിൻജിൻ ഏറ്റവും അസന്തുഷ്ടയാകുന്ന ആഴ്ചയിലെ ദിവസം (തിങ്കളാഴ്ച മുതൽ ഞായറാഴ്ച വരെ 1-7) അല്ലെങ്കിൽ അവൾ ഒരിക്കലും അസന്തുഷ്ടയല്ലെങ്കിൽ 0.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0", "fa": "محاسبه کنید که کدام روز هفته جینجین بیشترین ناراحتی را بر اساس برنامه‌اش دارد.\n\nجینجین ناراحت است اگر مجموع ساعت‌های صرف شده در مدرسه و کلاس‌های اضافی در یک روز بیش از ۸ ساعت باشد. این تابع روزی را پیدا می‌کند که ناراحتی او بیشترین است، یعنی روزی که مجموع ساعت‌ها بیشترین فاصله را از حد آستانه دارد. اگر چندین روز با همان سطح حداکثر ناراحتی وجود داشته باشد، اولین روز برگردانده می‌شود. اگر جینجین در هیچ روزی ناراحت نباشد، تابع ۰ را برمی‌گرداند.\n\nArgs:\n    schedule (list[tuple[int, int]]): لیستی از ۷ تاپل، که هر تاپل نشان‌دهنده تعداد ساعت‌های صرف شده در مدرسه و کلاس‌های اضافی برای هر روز هفته است.\n\nReturns:\n    int: روز هفته که جینجین بیشترین ناراحتی را دارد (۱-۷ برای دوشنبه تا یکشنبه) یا ۰ اگر او هرگز ناراحت نیست.\n\nCases:\n>>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n3\n>>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n0"}}
{"task_id": "Python/43", "prompt": {"en": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "sq": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transformon permutimin hyrës në permutimin e ardhshëm në rend leksikografik.\n    \n    Funksioni gjen numrin e parë nga fundi që është më i vogël se numri që e ndjek\n    dhe e ndërron atë me numrin më të vogël që është më i madh dhe vjen pas tij. Pastaj e kthen\n    rendin e numrave pas numrit të parë origjinal më të vogël. Nëse hyrja është permutimi i fundit\n    (në rend zbritës), funksioni kthen False, duke treguar se nuk është i mundur asnjë permutim tjetër.\n    \n    Argumentet:\n    perm (list): Një listë e numrave të plotë që përfaqëson permutimin aktual.\n    \n    Kthen:\n    bool: True nëse permutimi u transformua me sukses, False nëse ishte permutimi i fundit.\n    \n    Shembuj:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "hy": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Փոխակերպում է մուտքային փոխատեղումը հաջորդ փոխատեղման՝ բառարանային կարգով։\n    \n    Ֆունկցիան գտնում է վերջից առաջին թիվը, որը փոքր է իրեն հաջորդող թվից և փոխանակում է այն \n    ամենափոքր թվի հետ, որը մեծ է և գտնվում է դրանից հետո։ Այնուհետև այն շրջում է թվերի \n    կարգը սկզբնական առաջին փոքր թվից հետո։ Եթե մուտքը վերջին փոխատեղումն է (նվազող կարգով), \n    ֆունկցիան վերադարձնում է False, ցույց տալով, որ հաջորդ փոխատեղումը հնարավոր չէ։\n    \n    Պարամետրեր:\n    perm (list): Թվերի ցուցակ, որը ներկայացնում է ընթացիկ փոխատեղումը։\n    \n    Վերադարձնում է:\n    bool: True, եթե փոխատեղումը հաջողությամբ փոխակերպվեց, False, եթե դա վերջին փոխատեղումն էր։\n    \n    Օրինակներ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "bn": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    ইনপুট ক্রমবিন্যাসকে লেক্সিকোগ্রাফিক ক্রমে পরবর্তী ক্রমবিন্যাসে রূপান্তর করে।\n\n    ফাংশনটি শেষ থেকে প্রথম যে সংখ্যাটি তার পরবর্তী সংখ্যার চেয়ে ছোট তা খুঁজে বের করে এবং \n    এটি তার পরবর্তী এবং বড় সংখ্যার সাথে অদলবদল করে। তারপর এটি মূল প্রথম ছোট সংখ্যার পরের \n    সংখ্যাগুলির ক্রম উল্টে দেয়। যদি ইনপুটটি শেষ ক্রমবিন্যাস হয় (অধোগামী ক্রমে), ফাংশনটি \n    False ফেরত দেয়, যা নির্দেশ করে যে পরবর্তী কোনো ক্রমবিন্যাস সম্ভব নয়।\n\n    আর্গুমেন্টসমূহ:\n    perm (list): বর্তমান ক্রমবিন্যাসের প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    bool: যদি ক্রমবিন্যাসটি সফলভাবে রূপান্তরিত হয় তবে True, যদি এটি শেষ ক্রমবিন্যাস হয় তবে False।\n\n    উদাহরণ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "bg": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Преобразува входната пермутация в следващата пермутация в лексикографски ред.\n    \n    Функцията намира първото число от края, което е по-малко от следващото число, \n    и го разменя с най-малкото число, което е по-голямо и идва след него. След това \n    обръща реда на числата след първоначалното по-малко число. Ако входът е последната \n    пермутация (в низходящ ред), функцията връща False, което показва, че няма възможна \n    следваща пермутация.\n    \n    Аргументи:\n    perm (list): Списък от цели числа, представляващи текущата пермутация.\n    \n    Връща:\n    bool: True, ако пермутацията е успешно преобразувана, False, ако е последната пермутация.\n    \n    Примери:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "zh": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    将输入排列转换为字典序中的下一个排列。\n    \n    该函数从末尾开始找到第一个小于其后面的数字的数字，并将其与后面较大且最小的数字交换。\n    然后反转原始第一个较小数字之后的数字顺序。\n    如果输入是最后一个排列（降序排列），函数返回 False，表示没有下一个排列可能。\n    \n    参数:\n    perm (list): 表示当前排列的整数列表。\n    \n    返回:\n    bool: 如果排列成功转换则为 True，如果是最后一个排列则为 False。\n    \n    示例:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "fr": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforme la permutation d'entrée en la permutation suivante dans l'ordre lexicographique.\n    \n    La fonction trouve le premier nombre depuis la fin qui est plus petit que le nombre qui le suit \n    et l'échange avec le plus petit nombre qui est plus grand et qui vient après lui. Ensuite, elle inverse \n    l'ordre des nombres après le premier nombre plus petit d'origine. Si l'entrée est la dernière permutation \n    (en ordre décroissant), la fonction renvoie False, indiquant qu'aucune permutation suivante n'est possible.\n    \n    Args:\n    perm (list): Une liste d'entiers représentant la permutation actuelle.\n    \n    Returns:\n    bool: True si la permutation a été transformée avec succès, False si c'était la dernière permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "de": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transformiert die Eingabepermutation in die nächste Permutation in lexikografischer Reihenfolge.\n    \n    Die Funktion findet die erste Zahl vom Ende her, die kleiner ist als die folgende Zahl,\n    und tauscht sie mit der kleinsten Zahl, die größer ist und danach kommt. Dann kehrt sie die\n    Reihenfolge der Zahlen nach der ursprünglichen ersten kleineren Zahl um. Wenn die Eingabe die\n    letzte Permutation ist (in absteigender Reihenfolge), gibt die Funktion False zurück, was anzeigt,\n    dass keine nächste Permutation möglich ist.\n    \n    Argumente:\n    perm (list): Eine Liste von ganzen Zahlen, die die aktuelle Permutation darstellt.\n    \n    Rückgabe:\n    bool: True, wenn die Permutation erfolgreich transformiert wurde, False, wenn es die letzte Permutation war.\n    \n    Beispiele:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "ha": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Canza shigarwar da aka bayar zuwa juyin halitta na gaba a cikin tsarin haruffa.\n    \n    Aikin yana samun lamba ta farko daga ƙarshen da ta fi ƙarami fiye da lambar da ke biyo baya \n    kuma yana musanya ta da mafi ƙarancin lamba wadda ta fi girma kuma tana zuwa bayan ta. Sannan yana juyar da \n    tsarin lambobi bayan asalin lambar farko mafi ƙaranci. Idan shigarwar ita ce juyin halitta na ƙarshe \n    (a cikin tsarin saukowa), aikin yana dawowa da False, yana nuna babu wani juyin halitta na gaba da zai yiwu.\n    \n    Args:\n    perm (list): Jerin lambobi da ke wakiltar juyin halitta na yanzu.\n    \n    Returns:\n    bool: True idan an yi nasarar canza juyin halitta, False idan ita ce juyin halitta na ƙarshe.\n    \n    Misalai:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "hi": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    इनपुट क्रमचय को शब्दकोशीय क्रम में अगले क्रमचय में बदलता है।\n    \n    यह फ़ंक्शन अंत से पहला ऐसा संख्या ढूंढता है जो उसके बाद आने वाली संख्या से छोटी होती है \n    और इसे उसके बाद आने वाली सबसे छोटी और बड़ी संख्या के साथ बदल देता है। फिर यह मूल \n    पहली छोटी संख्या के बाद की संख्याओं के क्रम को उलट देता है। यदि इनपुट अंतिम क्रमचय \n    (अवरोही क्रम में) है, तो फ़ंक्शन False लौटाता है, यह दर्शाता है कि कोई अगला क्रमचय \n    संभव नहीं है।\n    \n    Args:\n    perm (list): वर्तमान क्रमचय का प्रतिनिधित्व करने वाली पूर्णांकों की सूची।\n    \n    Returns:\n    bool: True यदि क्रमचय को सफलतापूर्वक बदला गया, False यदि यह अंतिम क्रमचय था।\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "hu": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Az input permutációt a lexikografikus sorrendben következő permutációvá alakítja.\n    \n    A függvény megkeresi az első számot a végéről, amely kisebb, mint az utána következő szám,\n    és kicseréli a legkisebb számmal, amely nagyobb és utána következik. Ezután megfordítja\n    az eredeti első kisebb szám utáni számok sorrendjét. Ha az input az utolsó permutáció\n    (csökkenő sorrendben), a függvény False-t ad vissza, jelezve, hogy nincs következő permutáció.\n    \n    Paraméterek:\n    perm (list): Egész számok listája, amely a jelenlegi permutációt képviseli.\n    \n    Visszatérési érték:\n    bool: True, ha a permutációt sikeresen átalakították, False, ha az utolsó permutáció volt.\n    \n    Példák:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "es": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforma la permutación de entrada a la siguiente permutación en orden lexicográfico.\n    \n    La función encuentra el primer número desde el final que es más pequeño que el número que lo sigue \n    y lo intercambia con el número más pequeño que es mayor y viene después de él. Luego invierte el \n    orden de los números después del primer número más pequeño original. Si la entrada es la última \n    permutación (en orden descendente), la función devuelve False, indicando que no es posible una \n    siguiente permutación.\n    \n    Argumentos:\n    perm (list): Una lista de enteros que representa la permutación actual.\n    \n    Devuelve:\n    bool: True si la permutación fue transformada exitosamente, False si era la última permutación.\n    \n    Ejemplos:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "arb": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    يحول ترتيب الإدخال إلى الترتيب التالي في الترتيب المعجمي.\n    \n    تجد الدالة أول رقم من النهاية يكون أصغر من الرقم الذي يليه \n    وتقوم بتبديله مع أصغر رقم يكون أكبر ويأتي بعده. ثم تعكس \n    ترتيب الأرقام بعد الرقم الأصغر الأصلي. إذا كان الإدخال هو الترتيب الأخير \n    (بترتيب تنازلي)، تعيد الدالة False، مما يشير إلى أنه لا يوجد ترتيب تالي ممكن.\n    \n    يعيدالحجج:\n    perm (list): قائمة من الأعداد الصحيحة تمثل الترتيب الحالي.\n    \n    يعيد:\n    bool: True إذا تم تحويل الترتيب بنجاح، False إذا كان الترتيب الأخير.\n    \n    أمثلة:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "sw": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Hubadilisha mpangilio wa kuingiza kuwa mpangilio unaofuata katika mpangilio wa lexicographic.\n    \n    Kazi hii inapata namba ya kwanza kutoka mwisho ambayo ni ndogo kuliko namba inayofuata \n    na kuibadilisha na namba ndogo zaidi ambayo ni kubwa na inakuja baada yake. Kisha inageuza \n    mpangilio wa namba baada ya namba ya kwanza ndogo ya awali. Ikiwa ingizo ni mpangilio wa mwisho \n    (katika mpangilio wa kushuka), kazi inarudisha False, ikionyesha hakuna mpangilio unaofuata unaowezekana.\n    \n    Hoja:\n    perm (list): Orodha ya namba za mzima zinazowakilisha mpangilio wa sasa.\n    \n    Inarejesha:\n    bool: True ikiwa mpangilio umebadilishwa kwa mafanikio, False ikiwa ulikuwa mpangilio wa mwisho.\n    \n    Mifano:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "tr": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Girdi permütasyonunu sözlük sırasındaki bir sonraki permütasyona dönüştürür.\n    \n    Fonksiyon, sondan başlayarak kendisinden sonra gelen sayıdan daha küçük olan ilk sayıyı bulur \n    ve bunu, kendisinden sonra gelen ve daha büyük olan en küçük sayı ile değiştirir. Ardından, \n    orijinal ilk küçük sayıdan sonraki sayıların sırasını tersine çevirir. Eğer girdi son permütasyon \n    ise (azalan sırada), fonksiyon False döndürerek bir sonraki permütasyonun mümkün olmadığını belirtir.\n    \n    Argümanlar:\n    perm (list): Mevcut permütasyonu temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    bool: Permütasyon başarıyla dönüştürüldüyse True, son permütasyon ise False.\n    \n    Örnekler:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "vi": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Chuyển đổi hoán vị đầu vào thành hoán vị tiếp theo theo thứ tự từ điển.\n    \n    Hàm tìm số đầu tiên từ cuối mà nhỏ hơn số theo sau nó và hoán đổi nó với số nhỏ nhất \n    lớn hơn và đến sau nó. Sau đó, nó đảo ngược thứ tự các số sau số nhỏ hơn đầu tiên ban đầu. \n    Nếu đầu vào là hoán vị cuối cùng (theo thứ tự giảm dần), hàm trả về False, cho biết không có \n    hoán vị tiếp theo nào khả thi.\n    \n    Tham số:\n    perm (list): Một danh sách các số nguyên đại diện cho hoán vị hiện tại.\n    \n    Trả về:\n    bool: True nếu hoán vị được chuyển đổi thành công, False nếu đó là hoán vị cuối cùng.\n    \n    Ví dụ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "id": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Mengubah permutasi input ke permutasi berikutnya dalam urutan leksikografis.\n    \n    Fungsi ini menemukan angka pertama dari akhir yang lebih kecil dari angka yang mengikutinya \n    dan menukarnya dengan angka terkecil yang lebih besar dan datang setelahnya. Kemudian membalikkan \n    urutan angka setelah angka pertama yang lebih kecil tersebut. Jika input adalah permutasi terakhir \n    (dalam urutan menurun), fungsi mengembalikan False, menunjukkan tidak ada permutasi berikutnya yang mungkin.\n    \n    Args:\n    perm (list): Daftar bilangan bulat yang mewakili permutasi saat ini.\n    \n    Returns:\n    bool: True jika permutasi berhasil diubah, False jika itu adalah permutasi terakhir.\n    \n    Contoh:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "ja": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    入力された順列を辞書式順序で次の順列に変換します。\n    \n    関数は、末尾から見て最初に次の数より小さい数を見つけ、それをその後に来るより大きい最小の数と交換します。\n    その後、元の最初の小さい数の後の数の順序を逆にします。入力が最後の順列（降順）である場合、関数は\n    次の順列が不可能であることを示すためにFalseを返します。\n    \n    引数:\n    perm (list): 現在の順列を表す整数のリスト。\n    \n    戻り値:\n    bool: 順列が正常に変換された場合はTrue、最後の順列であった場合はFalse。\n    \n    例:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "ko": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    입력된 순열을 사전식 순서로 다음 순열로 변환합니다.\n    \n    함수는 끝에서부터 다음 숫자보다 작은 첫 번째 숫자를 찾아서 그 뒤에 있는 더 크고 가장 작은 숫자와 교환합니다. \n    그런 다음 원래의 첫 번째 작은 숫자 이후의 숫자들의 순서를 뒤집습니다. \n    입력이 마지막 순열(내림차순)인 경우, 함수는 False를 반환하여 다음 순열이 불가능함을 나타냅니다.\n    \n    Args:\n    perm (list): 현재 순열을 나타내는 정수 리스트.\n    \n    Returns:\n    bool: 순열이 성공적으로 변환되면 True, 마지막 순열이면 False.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "ml": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    ഇൻപുട്ട് പെർമ്യൂട്ടേഷൻ ലെക്സികോഗ്രാഫിക് ക്രമത്തിൽ അടുത്ത പെർമ്യൂട്ടേഷനിലേക്ക് മാറ്റുന്നു.\n    \n    ഫംഗ്ഷൻ അവസാനത്തിൽ നിന്ന് അടുത്ത നമ്പറിനേക്കാൾ ചെറിയ ആദ്യ നമ്പർ കണ്ടെത്തി \n    അതിനുശേഷം വരുന്ന ഏറ്റവും ചെറിയ, വലിയ നമ്പറുമായി അത് മാറ്റി വയ്ക്കുന്നു. \n    പിന്നെ, ആദ്യത്തെ ചെറിയ നമ്പറിന് ശേഷം നമ്പറുകളുടെ ക്രമം മറിച്ചുവയ്ക്കുന്നു. \n    ഇൻപുട്ട് അവസാനത്തെ പെർമ്യൂട്ടേഷൻ (ഇറക്കിയ ക്രമത്തിൽ) ആണെങ്കിൽ, \n    ഫംഗ്ഷൻ False തിരികെ നൽകുന്നു, അടുത്ത പെർമ്യൂട്ടേഷൻ സാധ്യമല്ലെന്ന് സൂചിപ്പിക്കുന്നു.\n    \n    Args:\n    perm (list): നിലവിലെ പെർമ്യൂട്ടേഷൻ പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യകളുടെ ലിസ്റ്റ്.\n    \n    Returns:\n    bool: പെർമ്യൂട്ടേഷൻ വിജയകരമായി മാറ്റിയെങ്കിൽ True, \n    അത് അവസാനത്തെ പെർമ്യൂട്ടേഷൻ ആയിരുന്നെങ്കിൽ False.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"", "fa": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    ترتیب ورودی را به ترتیب بعدی در ترتیب لغت‌نامه‌ای تبدیل می‌کند.\n    \n    این تابع اولین عدد از انتها که کوچکتر از عدد بعدی است را پیدا می‌کند و آن را با کوچکترین \n    عددی که بزرگتر است و بعد از آن می‌آید تعویض می‌کند. سپس ترتیب اعداد بعد از اولین عدد \n    کوچکتر اصلی را معکوس می‌کند. اگر ورودی آخرین ترتیب (به ترتیب نزولی) باشد، تابع \n    False را برمی‌گرداند که نشان می‌دهد هیچ ترتیب بعدی ممکن نیست.\n    \n    آرگومان‌ها:\n    perm (list): لیستی از اعداد صحیح که ترتیب فعلی را نشان می‌دهد.\n    \n    بازگشت‌ها:\n    bool: True اگر ترتیب با موفقیت تغییر کرد، False اگر آخرین ترتیب بود.\n    \n    مثال‌ها:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\""}, "canonical_solution": "    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True", "instruction": {"en": "Write a python function 'def next_permutation(perm: list) -> bool:' to solve the following problem:\n\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    ", "sq": "Shkruani një funksion python 'def next_permutation(perm: list) -> bool:' për të zgjidhur problemin e mëposhtëm:\n\n    Transformon permutimin hyrës në permutimin e ardhshëm në rend leksikografik.\n    \n    Funksioni gjen numrin e parë nga fundi që është më i vogël se numri që e ndjek \n    dhe e shkëmben atë me numrin më të vogël që është më i madh dhe vjen pas tij. Pastaj e kthen \n    rendin e numrave pas numrit të parë origjinal më të vogël. Nëse hyrja është permutimi i fundit \n    (në rend zbritës), funksioni kthen False, duke treguar se nuk është e mundur një permutim tjetër.\n    \n    Args:\n    perm (list): Një listë e numrave të plotë që përfaqëson permutimin aktual.\n    \n    Returns:\n    bool: True nëse permutimi u transformua me sukses, False nëse ishte permutimi i fundit.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "hy": "Պայթոն ֆունկցիա 'def next_permutation(perm: list) -> bool:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Մուտքագրված փոխատեղումը փոխակերպում է հաջորդ փոխատեղման՝ բառարանային կարգով:\n    \n    Ֆունկցիան գտնում է վերջից առաջին թիվը, որը փոքր է հաջորդ թվից \n    և այն փոխանակում է ամենափոքր թվի հետ, որը մեծ է և գալիս է դրանից հետո: Այնուհետև այն շրջում է \n    թվերի կարգը սկզբնական առաջին փոքր թվից հետո: Եթե մուտքագրվածը վերջին փոխատեղումն է \n    (նվազման կարգով), ֆունկցիան վերադարձնում է False, ցույց տալով, որ հաջորդ փոխատեղումը հնարավոր չէ:\n    \n    Արգումենտներ:\n    perm (list): Թվերի ցուցակ, որը ներկայացնում է ընթացիկ փոխատեղումը:\n    \n    Վերադարձնում է:\n    bool: True, եթե փոխատեղումը հաջողությամբ փոխակերպվել է, False, եթե այն վերջին փոխատեղումն էր:\n    \n    Օրինակներ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "bn": "একটি পাইথন ফাংশন 'def next_permutation(perm: list) -> bool:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    ইনপুট পারমুটেশনকে লেক্সিকোগ্রাফিক ক্রমে পরবর্তী পারমুটেশনে রূপান্তর করে।\n\n    ফাংশনটি শেষ থেকে প্রথম সংখ্যাটি খুঁজে বের করে যা তার পরবর্তী সংখ্যার চেয়ে ছোট \n    এবং এটি তার পরবর্তী এবং বড় সংখ্যার সাথে অদলবদল করে। তারপর এটি মূল প্রথম ছোট সংখ্যার \n    পরের সংখ্যাগুলির ক্রম উল্টে দেয়। যদি ইনপুটটি শেষ পারমুটেশন হয় (অবতরণ ক্রমে), \n    ফাংশনটি False ফেরত দেয়, যা নির্দেশ করে যে পরবর্তী কোনো পারমুটেশন সম্ভব নয়।\n\n    Args:\n    perm (list): বর্তমান পারমুটেশন প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    Returns:\n    bool: যদি পারমুটেশন সফলভাবে রূপান্তরিত হয় তবে True, যদি এটি শেষ পারমুটেশন হয় তবে False।\n\n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "bg": "Напишете Python функция 'def next_permutation(perm: list) -> bool:' за решаване на следния проблем:\n\n    Преобразува входната пермутация в следващата пермутация в лексикографски ред.\n    \n    Функцията намира първото число от края, което е по-малко от следващото число \n    и го разменя с най-малкото число, което е по-голямо и се намира след него. След това \n    обръща реда на числата след първоначалното първо по-малко число. Ако входът е последната \n    пермутация (в низходящ ред), функцията връща False, което означава, че не е възможна следваща пермутация.\n    \n    Args:\n    perm (list): Списък от цели числа, представляващи текущата пермутация.\n    \n    Returns:\n    bool: True, ако пермутацията е успешно преобразувана, False, ако е последната пермутация.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "zh": "编写一个 Python 函数 'def next_permutation(perm: list) -> bool:' 来解决以下问题：\n\n    将输入的排列转换为字典序中的下一个排列。\n    \n    该函数从末尾开始找到第一个比其后面的数字小的数字，并将其与后面比它大的最小数字交换。然后，它反转原始第一个较小数字之后的数字顺序。如果输入是最后一个排列（降序排列），函数返回 False，表示没有下一个排列可能。\n    \n    参数：\n    perm (list): 表示当前排列的整数列表。\n    \n    返回：\n    bool: 如果排列成功转换，返回 True；如果是最后一个排列，返回 False。\n    \n    示例：\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "fr": "Écrire une fonction python 'def next_permutation(perm: list) -> bool:' pour résoudre le problème suivant :\n\n    Transforme la permutation d'entrée en la permutation suivante dans l'ordre lexicographique.\n    \n    La fonction trouve le premier nombre depuis la fin qui est plus petit que le nombre qui le suit \n    et l'échange avec le plus petit nombre qui est plus grand et vient après lui. Ensuite, elle inverse \n    l'ordre des nombres après le premier plus petit nombre original. Si l'entrée est la dernière permutation \n    (en ordre décroissant), la fonction retourne False, indiquant qu'aucune permutation suivante n'est possible.\n    \n    Args:\n    perm (list): Une liste d'entiers représentant la permutation actuelle.\n    \n    Renvoie:\n    bool: True si la permutation a été transformée avec succès, False si c'était la dernière permutation.\n    \n    Exemples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "de": "Schreiben Sie eine Python-Funktion 'def next_permutation(perm: list) -> bool:', um das folgende Problem zu lösen:\n\n    Transformiert die Eingabepermutation in die nächste Permutation in lexikographischer Reihenfolge.\n    \n    Die Funktion findet die erste Zahl vom Ende, die kleiner ist als die folgende Zahl, \n    und tauscht sie mit der kleinsten Zahl, die größer ist und danach kommt. Dann kehrt sie die \n    Reihenfolge der Zahlen nach der ursprünglichen ersten kleineren Zahl um. Wenn die Eingabe die \n    letzte Permutation (in absteigender Reihenfolge) ist, gibt die Funktion False zurück, was anzeigt, \n    dass keine nächste Permutation möglich ist.\n    \n    Args:\n    perm (list): Eine Liste von ganzen Zahlen, die die aktuelle Permutation darstellt.\n    \n    Returns:\n    bool: True, wenn die Permutation erfolgreich transformiert wurde, False, wenn es die letzte Permutation war.\n    \n    Beispiele:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "ha": "Rubuta wani aikin python 'def next_permutation(perm: list) -> bool:' don warware matsalar mai zuwa:\n\n    Canza permutation ɗin shigarwa zuwa permutation na gaba a cikin tsarin lexicographic.\n    \n    Aikin yana nemo lambar farko daga ƙarshen da ta fi ƙarama fiye da lambar da ke biyo baya \n    kuma yana musanya ta da mafi ƙarancin lamba da ta fi girma kuma ta biyo baya. Sannan yana juyar da \n    tsarin lambobin bayan lambar farko da ta fi ƙarama ta asali. Idan shigarwar ita ce permutation na ƙarshe \n    (a cikin tsarin saukowa), aikin yana dawowa da False, yana nuna babu wani permutation na gaba da zai yiwu.\n    \n    Args:\n    perm (list): Jerin lambobin da ke wakiltar permutation na yanzu.\n    \n    Returns:\n    bool: True idan permutation ɗin an canza shi cikin nasara, False idan ita ce permutation na ƙarshe.\n    \n    Misalai:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "hi": "एक पायथन फ़ंक्शन 'def next_permutation(perm: list) -> bool:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    इनपुट क्रमचय को शब्दकोशीय क्रम में अगले क्रमचय में परिवर्तित करता है।\n    \n    फ़ंक्शन अंत से पहला ऐसा संख्या खोजता है जो इसके बाद आने वाली संख्या से छोटी हो \n    और इसे सबसे छोटी संख्या के साथ बदल देता है जो बड़ी हो और इसके बाद आती हो। फिर यह \n    मूल पहले छोटे संख्या के बाद की संख्याओं के क्रम को उलट देता है। यदि इनपुट अंतिम क्रमचय \n    (अवरोही क्रम में) है, तो फ़ंक्शन False लौटाता है, यह दर्शाता है कि कोई अगला क्रमचय संभव नहीं है।\n    \n    तर्क:\n    perm (list): पूर्णांकों की एक सूची जो वर्तमान क्रमचय का प्रतिनिधित्व करती है।\n    \n    लौटाता है:\n    bool: True यदि क्रमचय को सफलतापूर्वक परिवर्तित किया गया, False यदि यह अंतिम क्रमचय था।\n    \n    उदाहरण:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "hu": "Írj egy python függvényt 'def next_permutation(perm: list) -> bool:' a következő probléma megoldására:\n\n    Az input permutációt átalakítja a következő permutációvá lexikografikus sorrendben.\n    \n    A függvény megkeresi az első számot a végéről, amely kisebb, mint az utána következő szám, \n    és kicseréli a legkisebb, nála nagyobb számmal, amely utána következik. Ezután megfordítja \n    az eredeti első kisebb szám utáni számok sorrendjét. Ha az input az utolsó permutáció \n    (csökkenő sorrendben), a függvény False-t ad vissza, jelezve, hogy nincs következő permutáció.\n    \n    Args:\n    perm (list): Egész számok listája, amely a jelenlegi permutációt képviseli.\n    \n    Returns:\n    bool: True, ha a permutáció sikeresen átalakult, False, ha az utolsó permutáció volt.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "es": "Escribe una función de Python 'def next_permutation(perm: list) -> bool:' para resolver el siguiente problema:\n\n    Transforma la permutación de entrada a la siguiente permutación en orden lexicográfico.\n    \n    La función encuentra el primer número desde el final que es más pequeño que el número que le sigue \n    y lo intercambia con el número más pequeño que es mayor y viene después de él. Luego invierte el \n    orden de los números después del primer número más pequeño original. Si la entrada es la última permutación \n    (en orden descendente), la función devuelve False, indicando que no es posible una siguiente permutación.\n    \n    Argumentos:\n    perm (list): Una lista de enteros que representa la permutación actual.\n    \n    Devuelve:\n    bool: True si la permutación fue transformada con éxito, False si era la última permutación.\n    \n    Ejemplos:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "arb": "اكتب دالة بايثون 'def next_permutation(perm: list) -> bool:' لحل المشكلة التالية:\n\n    تحول التبديل المدخل إلى التبديل التالي بترتيب معجمي.\n    \n    تجد الدالة أول رقم من النهاية يكون أصغر من الرقم الذي يليه \n    وتقوم بتبديله مع أصغر رقم يكون أكبر ويأتي بعده. ثم تعكس \n    ترتيب الأرقام بعد الرقم الأصغر الأصلي. إذا كان المدخل هو التبديل الأخير \n    (بترتيب تنازلي)، تعيد الدالة False، مشيرة إلى أنه لا يوجد تبديل تالي ممكن.\n    \n    يعيدالحجج:\n    perm (list): قائمة من الأعداد الصحيحة تمثل التبديل الحالي.\n    \n    يعيد:\n    bool: True إذا تم تحويل التبديل بنجاح، False إذا كان التبديل الأخير.\n    \n    أمثلة:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "sw": "Andika kazi ya python 'def next_permutation(perm: list) -> bool:' kutatua tatizo lifuatalo:\n\n    Inabadilisha mpangilio wa pembejeo kuwa mpangilio unaofuata katika mpangilio wa lexicographic.\n    \n    Kazi inapata namba ya kwanza kutoka mwisho ambayo ni ndogo kuliko namba inayofuata \n    na inabadilisha na namba ndogo zaidi ambayo ni kubwa na inakuja baada yake. Kisha inageuza \n    mpangilio wa namba baada ya namba ya kwanza ndogo ya awali. Ikiwa pembejeo ni mpangilio wa mwisho \n    (katika mpangilio wa kushuka), kazi inarudisha False, ikionyesha kuwa hakuna mpangilio unaofuata unaowezekana.\n    \n    Hoja:\n    perm (list): Orodha ya namba za integer zinazowakilisha mpangilio wa sasa.\n    \n    Inarejesha:\n    bool: True ikiwa mpangilio ulibadilishwa kwa mafanikio, False ikiwa ulikuwa mpangilio wa mwisho.\n    \n    Mifano:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "tr": "Bir python fonksiyonu 'def next_permutation(perm: list) -> bool:' yazarak aşağıdaki problemi çözün:\n\n    Girdi olarak verilen permütasyonu, sözlük sırasındaki bir sonraki permütasyona dönüştürür.\n    \n    Fonksiyon, sondan başlayarak kendisinden sonra gelen sayıdan daha küçük olan ilk sayıyı bulur \n    ve bunu, kendisinden sonra gelen ve daha büyük olan en küçük sayı ile değiştirir. Ardından, \n    orijinal ilk küçük sayıdan sonraki sayıların sırasını tersine çevirir. Girdi, son permütasyon \n    ise (azalan sıradaysa), fonksiyon False döndürür, bu da bir sonraki permütasyonun mümkün olmadığını belirtir.\n    \n    Argümanlar:\n    perm (list): Mevcut permütasyonu temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    bool: Permütasyon başarıyla dönüştürüldüyse True, son permütasyon ise False.\n    \n    Örnekler:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "vi": "Viết một hàm python 'def next_permutation(perm: list) -> bool:' để giải quyết vấn đề sau:\n\n    Chuyển đổi hoán vị đầu vào thành hoán vị tiếp theo theo thứ tự từ điển.\n    \n    Hàm tìm số đầu tiên từ cuối mà nhỏ hơn số theo sau nó và hoán đổi nó với số nhỏ nhất lớn hơn và xuất hiện sau nó. Sau đó, nó đảo ngược thứ tự các số sau số nhỏ hơn đầu tiên ban đầu. Nếu đầu vào là hoán vị cuối cùng (theo thứ tự giảm dần), hàm trả về False, cho biết không có hoán vị tiếp theo nào khả thi.\n    \n    Tham số:\n    perm (list): Một danh sách các số nguyên đại diện cho hoán vị hiện tại.\n    \n    Trả về:\n    bool: True nếu hoán vị đã được chuyển đổi thành công, False nếu nó là hoán vị cuối cùng.\n    \n    Ví dụ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "id": "Tulis fungsi python 'def next_permutation(perm: list) -> bool:' untuk menyelesaikan masalah berikut:\n\n    Mengubah permutasi input ke permutasi berikutnya dalam urutan leksikografis.\n    \n    Fungsi ini menemukan angka pertama dari akhir yang lebih kecil dari angka yang mengikutinya \n    dan menukarnya dengan angka terkecil yang lebih besar dan datang setelahnya. Kemudian membalik \n    urutan angka setelah angka pertama yang lebih kecil tersebut. Jika input adalah permutasi terakhir \n    (dalam urutan menurun), fungsi mengembalikan False, menunjukkan bahwa tidak ada permutasi berikutnya yang mungkin.\n    \n    Argumen:\n    perm (list): Daftar bilangan bulat yang mewakili permutasi saat ini.\n    \n    Mengembalikan:\n    bool: True jika permutasi berhasil diubah, False jika itu adalah permutasi terakhir.\n    \n    Contoh:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "ja": "Python関数を書いてください。 'def next_permutation(perm: list) -> bool:' を使用して次の問題を解決します。\n\n    入力された順列を辞書式順序で次の順列に変換します。\n    \n    関数は、末尾から始めて、次の数より小さい最初の数を見つけ、それを後に続くより大きい最小の数と交換します。次に、元の最初の小さい数の後の数の順序を逆にします。入力が最後の順列（降順）である場合、関数は False を返し、次の順列が不可能であることを示します。\n    \n    引数:\n    perm (list): 現在の順列を表す整数のリスト。\n    \n    戻り値:\n    bool: 順列が正常に変換された場合は True、最後の順列だった場合は False。\n    \n    例:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "ko": "파이썬 함수를 작성하세요 'def next_permutation(perm: list) -> bool:' 다음 문제를 해결하기 위해:\n\n    입력 순열을 사전식 순서에서 다음 순열로 변환합니다.\n    \n    함수는 끝에서부터 시작하여 다음 숫자보다 작은 첫 번째 숫자를 찾아서 \n    그 뒤에 오는 더 큰 숫자 중 가장 작은 숫자와 교환합니다. 그런 다음 원래의 첫 번째 작은 숫자 이후의 숫자들의 순서를 뒤집습니다. \n    입력이 마지막 순열(내림차순)인 경우, 함수는 다음 순열이 불가능함을 나타내는 False를 반환합니다.\n    \n    매개변수:\n    perm (list): 현재 순열을 나타내는 정수 리스트.\n    \n    반환값:\n    bool: 순열이 성공적으로 변환되면 True, 마지막 순열이면 False.\n    \n    예제:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "ml": "'def next_permutation(perm: list) -> bool:' എന്ന python function എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    ഇൻപുട്ട് permutation നെ ലെക്സികോഗ്രാഫിക് ക്രമത്തിൽ അടുത്ത permutation ആയി മാറ്റുന്നു.\n    \n    function അവസാനത്തുനിന്നും ആദ്യ smaller number നെ കണ്ടെത്തി, അതിന് ശേഷം വരുന്ന ഏറ്റവും ചെറിയ \n    വലിയ number നെ അതുമായി മാറ്റുന്നു. തുടർന്ന്, ഓരിജിനൽ smaller number നു ശേഷം വരുന്ന \n    നമ്പറുകളുടെ ക്രമം മറിക്കുന്നു. ഇൻപുട്ട് അവസാന permutation (അവരോധന ക്രമത്തിൽ) ആണെങ്കിൽ, \n    function False തിരികെ നൽകുന്നു, അടുത്ത permutation സാധ്യമല്ലെന്ന് സൂചിപ്പിക്കുന്നു.\n    \n    Args:\n    perm (list): നിലവിലെ permutation പ്രതിനിധീകരിക്കുന്ന ഒരു integer ലിസ്റ്റ്.\n    \n    Returns:\n    bool: permutation വിജയകരമായി മാറ്റിയെങ്കിൽ True, അത് അവസാന permutation ആയിരുന്നെങ്കിൽ False.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "fa": "یک تابع پایتون 'def next_permutation(perm: list) -> bool:' بنویسید تا مسئله زیر را حل کند:\n\n    ورودی جایگشت را به جایگشت بعدی در ترتیب لغت‌نامه‌ای تبدیل می‌کند.\n    \n    تابع اولین عدد از انتها که کوچکتر از عدد بعدی است را پیدا می‌کند و آن را با کوچکترین عددی که بزرگتر است و بعد از آن می‌آید، جابجا می‌کند. سپس ترتیب اعداد بعد از اولین عدد کوچکتر اصلی را معکوس می‌کند. اگر ورودی آخرین جایگشت (به ترتیب نزولی) باشد، تابع False برمی‌گرداند که نشان می‌دهد جایگشت بعدی ممکن نیست.\n    \n    آرگومان‌ها:\n    perm (list): لیستی از اعداد صحیح که جایگشت فعلی را نشان می‌دهد.\n    \n    بازگشتی:\n    bool: True اگر جایگشت با موفقیت تبدیل شد، False اگر آخرین جایگشت بود.\n    \n    مثال‌ها:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]"}, "level": "middle", "test": "def test_next_permutation():\n    # Test case 1: ordinary case\n    perm1 = [1, 2, 3]\n    assert next_permutation(perm1) == True, \"Test case 1 failed: next_permutation([1, 2, 3]) should return True\"\n    assert perm1 == [1, 3, 2], \"Test case 1 failed: perm1 should be [1, 3, 2]\"\n    \n    # Test case 2: last permutation, should return False\n    perm2 = [3, 2, 1]\n    assert next_permutation(perm2) == False, \"Test case 2 failed: next_permutation([3, 2, 1]) should return False\"\n    assert perm2 == [3, 2, 1], \"Test case 2 failed: perm2 should be [3, 2, 1] (unchanged)\"\n    \n    # Test case 3: permutation with repeated elements\n    perm3 = [1, 5, 1]\n    assert next_permutation(perm3) == True, \"Test case 3 failed: next_permutation([1, 5, 1]) should return True\"\n    assert perm3 == [5, 1, 1], \"Test case 3 failed: perm3 should be [5, 1, 1]\"\n\n    # Test case 4: permutation with all elements equal\n    perm4 = [1, 1, 1]\n    assert next_permutation(perm4) == False, \"Test case 4 failed: next_permutation([1, 1, 1]) should return False\"\n    assert perm4 == [1, 1, 1], \"Test case 4 failed: perm4 should be [1, 1, 1] (unchanged)\"\n    \n    # Test case 5: permutation with only one element\n    perm5 = [42]\n    assert next_permutation(perm5) == False, \"Test case 5 failed: next_permutation([42]) should return False\"\n    assert perm5 == [42], \"Test case 5 failed: perm5 should be [42] (unchanged)\"\n    \n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_next_permutation()", "entry_point": "next_permutation", "signature": "def next_permutation(perm: list) -> bool:", "docstring": {"en": "\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    ", "sq": "\n    Transformon permutimin e dhënë në permutimin e radhës në rend leksikografik.\n    \n    Funksioni gjen numrin e parë nga fundi që është më i vogël se numri që e ndjek \n    dhe e ndërron atë me numrin më të vogël që është më i madh dhe vjen pas tij. Pastaj kthen \n    rendin e numrave pas numrit të parë origjinal më të vogël. Nëse hyrja është permutimi i fundit \n    (në rend zbritës), funksioni kthen False, duke treguar se nuk është e mundur një permutim tjetër.\n    \n    Argumentet:\n    perm (list): Një listë e numrave të plotë që përfaqëson permutimin aktual.\n    \n    Kthen:\n    bool: True nëse permutimi u transformua me sukses, False nëse ishte permutimi i fundit.\n    \n    Shembuj:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "hy": "\n    Մուտքային փոխատեղումը փոխակերպում է հաջորդ փոխատեղման դեպի բառարանային կարգով հաջորդը։\n    \n    Ֆունկցիան գտնում է առաջին թիվը վերջից, որը փոքր է իրեն հաջորդող թվից և փոխանակում է այն ամենափոքր թվի հետ, որը մեծ է և գալիս է դրանից հետո։ Այնուհետև այն շրջում է թվերի կարգը սկզբնական առաջին փոքր թվից հետո։ Եթե մուտքը վերջին փոխատեղումն է (նվազող կարգով), ֆունկցիան վերադարձնում է False, ցույց տալով, որ հաջորդ փոխատեղումը հնարավոր չէ։\n    \n    Պարամետրեր:\n    perm (list): Ցուցակ ամբողջ թվերի, որոնք ներկայացնում են ընթացիկ փոխատեղումը։\n    \n    Վերադարձնում է:\n    bool: True, եթե փոխատեղումը հաջողությամբ փոխակերպվել է, False, եթե դա վերջին փոխատեղումն էր։\n    \n    Օրինակներ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "bn": "\n    ইনপুট পারমুটেশনকে লেক্সিকোগ্রাফিক ক্রমে পরবর্তী পারমুটেশনে রূপান্তর করে।\n    \n    ফাংশনটি শেষ থেকে প্রথম সংখ্যা খুঁজে বের করে যা তার পরবর্তী সংখ্যার চেয়ে ছোট এবং \n    এটি তার পরবর্তী এবং বড় সংখ্যার সাথে অদলবদল করে। তারপর এটি মূল প্রথম ছোট সংখ্যার \n    পরবর্তী সংখ্যাগুলির ক্রম উল্টে দেয়। যদি ইনপুটটি শেষ পারমুটেশন হয় (অবতরণ ক্রমে), \n    ফাংশনটি False ফেরত দেয়, যা নির্দেশ করে যে কোনো পরবর্তী পারমুটেশন সম্ভব নয়।\n    \n    Args:\n    perm (list): বর্তমান পারমুটেশন প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি তালিকা।\n    \n    Returns:\n    bool: যদি পারমুটেশন সফলভাবে রূপান্তরিত হয় তবে True, যদি এটি শেষ পারমুটেশন হয় তবে False।\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "bg": "\n    Преобразува входната пермутация в следващата пермутация в лексикографски ред.\n    \n    Функцията намира първото число от края, което е по-малко от следващото число, и го разменя с най-малкото число, което е по-голямо и идва след него. След това обръща реда на числата след първоначалното по-малко число. Ако входът е последната пермутация (в низходящ ред), функцията връща False, което показва, че няма възможна следваща пермутация.\n    \n    Аргументи:\n    perm (list): Списък от цели числа, представляващи текущата пермутация.\n    \n    Връща:\n    bool: True, ако пермутацията е успешно преобразувана, False, ако е последната пермутация.\n    \n    Примери:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "zh": "\n    将输入排列转换为字典序中的下一个排列。\n    \n    该函数从末尾开始找到第一个比后面的数字小的数字，并将其与后面比它大的最小数字交换。\n    然后反转原始第一个较小数字之后的数字顺序。\n    如果输入是最后一个排列（降序排列），函数返回 False，表示没有下一个排列。\n    \n    参数:\n    perm (list): 表示当前排列的整数列表。\n    \n    返回:\n    bool: 如果排列成功转换则为 True，如果是最后一个排列则为 False。\n    \n    示例:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "fr": "\n    Transforme la permutation d'entrée en la permutation suivante dans l'ordre lexicographique.\n    \n    La fonction trouve le premier nombre depuis la fin qui est plus petit que le nombre qui le suit \n    et l'échange avec le plus petit nombre qui est plus grand et vient après lui. Ensuite, elle inverse \n    l'ordre des nombres après le premier nombre plus petit d'origine. Si l'entrée est la dernière permutation \n    (en ordre décroissant), la fonction retourne False, indiquant qu'aucune permutation suivante n'est possible.\n    \n    Args:\n    perm (list): Une liste d'entiers représentant la permutation actuelle.\n    \n    Returns:\n    bool: True si la permutation a été transformée avec succès, False si c'était la dernière permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "de": "\n    Transformiert die Eingabepermutation in die nächste Permutation in lexikographischer Reihenfolge.\n    \n    Die Funktion findet die erste Zahl von hinten, die kleiner ist als die folgende Zahl, \n    und tauscht sie mit der kleinsten Zahl, die größer ist und danach kommt. Dann kehrt sie die \n    Reihenfolge der Zahlen nach der ursprünglich kleineren Zahl um. Wenn die Eingabe die letzte \n    Permutation (in absteigender Reihenfolge) ist, gibt die Funktion False zurück, was anzeigt, \n    dass keine nächste Permutation möglich ist.\n    \n    Args:\n    perm (list): Eine Liste von ganzen Zahlen, die die aktuelle Permutation darstellt.\n    \n    Returns:\n    bool: True, wenn die Permutation erfolgreich transformiert wurde, False, wenn es die letzte Permutation war.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "ha": "\n    Canza shigarwar permutation zuwa permutation na gaba a cikin tsarin lexicographic.\n    \n    Aikin yana nemo lambar farko daga ƙarshe wadda ta fi ƙarama fiye da lambar da ke biye da ita \n    kuma yana musanya ta da ƙaramin lamba wadda ta fi girma kuma tana zuwa bayan ta. Sannan yana juyawa \n    tsarin lambobi bayan lambar farko mafi ƙarama ta asali. Idan shigarwar ita ce permutation na ƙarshe \n    (a cikin tsarin saukowa), aikin yana dawo da Karya, yana nuna babu wani permutation na gaba da zai yiwu.\n    \n    Args:\n    perm (list): Jerin lambobi masu wakiltar permutation na yanzu.\n    \n    Returns:\n    bool: Gaskiya idan an sami nasarar canza permutation, Karya idan permutation na ƙarshe ne.\n    \n    Misalai:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "hi": "\n    इनपुट क्रमचय को शब्दकोश क्रम में अगले क्रमचय में बदलता है।\n    \n    फ़ंक्शन अंत से पहला ऐसा नंबर ढूंढता है जो उसके बाद आने वाले नंबर से छोटा हो \n    और उसे उसके बाद आने वाले सबसे छोटे बड़े नंबर के साथ बदल देता है। फिर यह \n    मूल पहले छोटे नंबर के बाद के नंबरों के क्रम को उलट देता है। यदि इनपुट अंतिम क्रमचय \n    (अवरोही क्रम में) है, तो फ़ंक्शन False लौटाता है, यह दर्शाता है कि कोई अगला क्रमचय संभव नहीं है।\n    \n    तर्क:\n    perm (list): पूर्णांकों की एक सूची जो वर्तमान क्रमचय का प्रतिनिधित्व करती है।\n    \n    लौटाता है:\n    bool: True यदि क्रमचय को सफलतापूर्वक बदला गया, False यदि यह अंतिम क्रमचय था।\n    \n    उदाहरण:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "hu": "\n    Az input permutációt átalakítja a következő lekszikografikus sorrendű permutációvá.\n    \n    A függvény megkeresi az első számot a végéről, amely kisebb, mint az utána következő szám, \n    és kicseréli a legkisebb, de nála nagyobb számmal, amely utána következik. Ezután megfordítja \n    az eredeti első kisebb szám utáni számok sorrendjét. Ha az input az utolsó permutáció \n    (csökkenő sorrendben), a függvény False-t ad vissza, jelezve, hogy nincs lehetséges következő permutáció.\n    \n    Paraméterek:\n    perm (list): Egész számok listája, amely a jelenlegi permutációt képviseli.\n    \n    Visszatérési érték:\n    bool: True, ha a permutáció sikeresen átalakult, False, ha az utolsó permutáció volt.\n    \n    Példák:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "es": "    Transforma la permutación de entrada a la siguiente permutación en orden lexicográfico.\n    \n    La función encuentra el primer número desde el final que es menor que el número que le sigue \n    y lo intercambia con el número más pequeño que es mayor y viene después de él. Luego invierte el \n    orden de los números después del primer número más pequeño original. Si la entrada es la última \n    permutación (en orden descendente), la función devuelve False, indicando que no es posible una siguiente permutación.\n    \n    Argumentos:\n    perm (list): Una lista de enteros que representa la permutación actual.\n    \n    Devuelve:\n    bool: True si la permutación fue transformada exitosamente, False si era la última permutación.\n    \n    Ejemplos:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "arb": "    يحول ترتيب الإدخال إلى الترتيب التالي في الترتيب المعجمي.\n    \n    تجد الدالة أول رقم من النهاية يكون أصغر من الرقم الذي يليه \n    وتقوم بتبديله بأصغر رقم يكون أكبر ويأتي بعده. ثم تعكس ترتيب \n    الأرقام بعد الرقم الأصغر الأصلي. إذا كان الإدخال هو الترتيب الأخير \n    (بترتيب تنازلي)، فإن الدالة تُرجع False، مما يشير إلى عدم إمكانية وجود ترتيب تالي.\n    \n    يعيدالحجج:\n    perm (list): قائمة من الأعداد الصحيحة تمثل الترتيب الحالي.\n    \n    يعيد:\n    bool: True إذا تم تحويل الترتيب بنجاح، False إذا كان الترتيب هو الأخير.\n    \n    امثله:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "sw": "    Hubadilisha mpangilio wa ingizo kuwa mpangilio unaofuata katika mpangilio wa lexicographic.\n    \n    Kazi hii inapata namba ya kwanza kutoka mwisho ambayo ni ndogo kuliko namba inayofuata \n    na kuibadilisha na namba ndogo zaidi ambayo ni kubwa na inakuja baada yake. Kisha inageuza \n    mpangilio wa namba baada ya namba ya kwanza ndogo ya awali. Ikiwa ingizo ni mpangilio wa mwisho \n    (katika mpangilio wa kushuka), kazi inarudisha False, ikionyesha hakuna mpangilio unaofuata unaowezekana.\n    \n    Hoja:\n    perm (list): Orodha ya namba nzima inayowakilisha mpangilio wa sasa.\n    \n    Inarudisha:\n    bool: True ikiwa mpangilio ulibadilishwa kwa mafanikio, False ikiwa ulikuwa mpangilio wa mwisho.\n    \n    Mifano:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "tr": "    Girdi permütasyonunu sözlükbilimsel sıradaki bir sonraki permütasyona dönüştürür.\n    \n    Fonksiyon, sondan başlayarak kendisinden sonra gelen sayıdan daha küçük olan ilk sayıyı bulur \n    ve onu, kendisinden sonra gelen daha büyük olan en küçük sayıyla değiştirir. Ardından, \n    orijinal ilk küçük sayıdan sonraki sayıların sırasını tersine çevirir. Eğer girdi son permütasyon \n    ise (azalan sırada), fonksiyon False döndürür, bu da başka bir sonraki permütasyonun mümkün \n    olmadığını belirtir.\n    \n    Argümanlar:\n    perm (list): Mevcut permütasyonu temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    bool: Permütasyon başarıyla dönüştürüldüyse True, son permütasyon ise False.\n    \n    Örnekler:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "vi": "Chuyển đổi hoán vị đầu vào thành hoán vị tiếp theo theo thứ tự từ điển.\n\nHàm tìm số đầu tiên từ cuối nhỏ hơn số theo sau nó và hoán đổi nó với số nhỏ nhất lớn hơn và xuất hiện sau nó. Sau đó, nó đảo ngược thứ tự các số sau số nhỏ hơn đầu tiên ban đầu. Nếu đầu vào là hoán vị cuối cùng (theo thứ tự giảm dần), hàm trả về False, cho biết không có hoán vị tiếp theo nào khả thi.\n\nTham số:\nperm (list): Một danh sách các số nguyên đại diện cho hoán vị hiện tại.\n\nTrả về:\nbool: True nếu hoán vị đã được chuyển đổi thành công, False nếu đó là hoán vị cuối cùng.\n\nVí dụ:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]", "id": "    Mengubah permutasi input ke permutasi berikutnya dalam urutan leksikografis.\n    \n    Fungsi ini menemukan angka pertama dari akhir yang lebih kecil dari angka yang mengikutinya \n    dan menukarnya dengan angka terkecil yang lebih besar dan datang setelahnya. Kemudian fungsi ini \n    membalikkan urutan angka setelah angka pertama yang lebih kecil dari aslinya. Jika input adalah \n    permutasi terakhir (dalam urutan menurun), fungsi mengembalikan False, menunjukkan bahwa tidak \n    ada permutasi berikutnya yang mungkin.\n    \n    Args:\n    perm (list): Daftar bilangan bulat yang mewakili permutasi saat ini.\n    \n    Returns:\n    bool: True jika permutasi berhasil diubah, False jika itu adalah permutasi terakhir.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "ja": "    入力された順列を辞書式順序で次の順列に変換します。\n    \n    この関数は、末尾から始めて、次の数よりも小さい最初の数を見つけ、それをその後に来るより大きい最小の数と交換します。その後、元の最初の小さい数の後の数の順序を逆にします。入力が最後の順列（降順）の場合、関数は False を返し、次の順列が不可能であることを示します。\n    \n    引数:\n    perm (list): 現在の順列を表す整数のリスト。\n    \n    戻り値:\n    bool: 順列が正常に変換された場合は True、最後の順列だった場合は False。\n    \n    例:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "ko": "    입력 순열을 사전식 순서의 다음 순열로 변환합니다.\n    \n    이 함수는 끝에서부터 시작하여 다음 숫자보다 작은 첫 번째 숫자를 찾아서, \n    그 뒤에 오는 숫자 중 더 크고 가장 작은 숫자와 교환합니다. 그런 다음 원래의 첫 번째 작은 숫자 뒤의 숫자들의 순서를 반전시킵니다. \n    입력이 마지막 순열(내림차순)인 경우, 함수는 False를 반환하여 다음 순열이 불가능함을 나타냅니다.\n    \n    Args:\n    perm (list): 현재 순열을 나타내는 정수 리스트.\n    \n    Returns:\n    bool: 순열이 성공적으로 변환되었으면 True, 마지막 순열이면 False.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "ml": "    ഇൻപുട്ട് പെർമ്യൂട്ടേഷൻ ലെക്സികോഗ്രാഫിക് ക്രമത്തിൽ അടുത്ത പെർമ്യൂട്ടേഷനിലേക്ക് മാറ്റുന്നു.\n    \n    അവസാനം നിന്ന് ആദ്യ smaller സംഖ്യയെ കണ്ടെത്തി, അതിനെ പിന്തുടരുന്ന സംഖ്യയേക്കാൾ ചെറിയതും \n    അതിനെക്കാൾ വലിയതുമായ ഏറ്റവും ചെറിയ സംഖ്യയുമായി സ്വാപ്പ് ചെയ്യുന്നു. പിന്നെ, \n    ആദ്യത്തെ smaller സംഖ്യയുടെ ശേഷം വരുന്ന സംഖ്യകളുടെ ക്രമം മറിച്ചും. \n    ഇൻപുട്ട് അവസാനത്തെ പെർമ്യൂട്ടേഷൻ (അവരോഹണ ക്രമത്തിൽ) ആണെങ്കിൽ, \n    അടുത്ത പെർമ്യൂട്ടേഷൻ സാധ്യമല്ല എന്ന് സൂചിപ്പിച്ച് ഫംഗ്ഷൻ False റിട്ടേൺ ചെയ്യുന്നു.\n    \n    Args:\n    perm (list): നിലവിലെ പെർമ്യൂട്ടേഷനെ പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n    \n    Returns:\n    bool: പെർമ്യൂട്ടേഷൻ വിജയകരമായി മാറ്റിയെങ്കിൽ True, അവസാനത്തെ പെർമ്യൂട്ടേഷൻ ആയിരുന്നെങ്കിൽ False.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]", "fa": "    تبدیل جایگشت ورودی به جایگشت بعدی در ترتیب لغت‌نامه‌ای.\n    \n    این تابع اولین عدد از انتها که کوچکتر از عدد بعدی است را پیدا کرده و با کوچکترین عددی که بزرگتر است و بعد از آن می‌آید، جابجا می‌کند. سپس ترتیب اعداد بعد از اولین عدد کوچکتر اصلی را معکوس می‌کند. اگر ورودی آخرین جایگشت (به ترتیب نزولی) باشد، تابع مقدار False را برمی‌گرداند که نشان می‌دهد جایگشت بعدی ممکن نیست.\n    \n    آرگومان‌ها:\n    perm (list): لیستی از اعداد صحیح که جایگشت فعلی را نشان می‌دهد.\n    \n    بازگشت:\n    bool: True اگر جایگشت با موفقیت تغییر کرد، False اگر آخرین جایگشت بود.\n    \n    مثال‌ها:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]"}}
{"task_id": "Python/44", "prompt": {"en": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "sq": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Llogarit shumën totale të parave që Jinjin do të ketë deri në fund të vitit\n    pas ndjekjes së planit të saj të kursimeve me nënën e saj. Çdo muaj, ajo mund të kursejë\n    shumëfish të 100 nga paratë e saj të xhepit (300 në muaj) nëse parashikon të ketë\n    të paktën 100 njësi të mbetura pas shpenzimeve. Paratë e kursyera do të fitojnë 20%\n    interes në fund të vitit.\n\n    Parametrat:\n    budgets (List[int]): Një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n\n    Kthen:\n    int: Shuma totale e parave që Jinjin do të ketë në fund të vitit pas interesit.\n         Nëse Jinjin mbetet pa para në ndonjë muaj të caktuar, kthen vlerën negative të\n         atij muaji (-X, ku X është numri i muajit).\n\n    Shembuj:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "hy": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Հաշվարկում է գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում՝\n    իր մայրիկի հետ խնայողությունների պլանին հետևելուց հետո։ Ամեն ամիս նա կարող է\n    իր գրպանի գումարից (300 ամսական) խնայել 100-ի բազմապատիկներ, եթե կանխատեսում է,\n    որ ծախսերից հետո առնվազն 100 միավոր կմնա։ Խնայված գումարը կստանա 20% տոկոսադրույք\n    տարվա վերջում։\n\n    Պարամետրեր:\n    budgets (List[int]): 12 ամբողջ թվերի ցուցակ, որը ներկայացնում է Ջինջինի ամսական բյուջեն։\n\n    Վերադարձնում է:\n    int: Գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում՝ տոկոսադրույքից հետո։\n         Եթե Ջինջինը որևէ ամսում գումարից դուրս է գալիս, վերադարձնում է\n         այդ ամսվա բացասական արժեքը (-X, որտեղ X-ը ամսվա համարանիշն է)։\n\n    Օրինակներ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "bn": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    বছরের শেষে জিনজিনের কত টাকা থাকবে তা গণনা করে\n    তার মায়ের সাথে তার সঞ্চয় পরিকল্পনা অনুসরণ করার পরে। প্রতি মাসে, সে তার পকেটের টাকা থেকে\n    (প্রতি মাসে 300) 100 এর গুণিতক সঞ্চয় করতে পারে যদি সে পূর্বাভাস দেয় যে খরচের পরে অন্তত 100 ইউনিট অবশিষ্ট থাকবে। \n    সঞ্চিত অর্থ বছরের শেষে 20% সুদ অর্জন করবে।\n\n    প্যারামিটার:\n    budgets (List[int]): জিনজিনের মাসিক বাজেটের প্রতিনিধিত্বকারী 12টি পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: বছরের শেষে সুদের পরে জিনজিনের মোট অর্থের পরিমাণ।\n         যদি জিনজিন কোনো মাসে অর্থের বাইরে চলে যায়, তাহলে সেই মাসের ঋণাত্মক মান (-X, যেখানে X হল মাসের সংখ্যা) ফেরত দেয়।\n\n    উদাহরণ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "bg": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Изчислява общата сума пари, която Джинджин ще има в края на годината\n    след като следва плана си за спестявания с майка си. Всеки месец тя може да спести\n    кратни на 100 от джобните си пари (300 на месец), ако предвижда да има\n    поне 100 единици, останали след разходите. Спестените пари ще получат 20%\n    лихва в края на годината.\n\n    Параметри:\n    budgets (List[int]): Списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n\n    Връща:\n    int: Общата сума пари, която Джинджин ще има в края на годината след лихвата.\n         Ако Джинджин остане без пари в който и да е месец, връща отрицателната стойност на\n         този месец (-X, където X е номерът на месеца).\n\n    Примери:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "zh": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    计算金金在年底按照她和妈妈的储蓄计划后将拥有的总金额。\n    每个月，如果她预测在支出后至少剩余100单位，她可以从她的零花钱中（每月300）储蓄100的倍数。\n    储蓄的钱将在年底获得20%的利息。\n\n    参数:\n    budgets (List[int]): 一个包含12个整数的列表，表示金金每月的预算。\n\n    返回:\n    int: 年底金金在利息后的总金额。\n         如果金金在任何一个月用完了钱，返回该月份的负值（-X，其中X是月份编号）。\n\n    示例:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "fr": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calcule le montant total d'argent que Jinjin aura à la fin de l'année\n    après avoir suivi son plan d'épargne avec sa mère. Chaque mois, elle peut\n    économiser des multiples de 100 de son argent de poche (300 par mois) si elle prévoit\n    d'avoir au moins 100 unités restantes après les dépenses. L'argent économisé gagnera 20%\n    d'intérêt à la fin de l'année.\n\n    Paramètres:\n    budgets (List[int]): Une liste de 12 entiers représentant le budget mensuel de Jinjin.\n\n    Retourne:\n    int: Le montant total d'argent que Jinjin aura à la fin de l'année après les intérêts.\n         Si Jinjin manque d'argent à un moment donné du mois, retourne la valeur négative\n         de ce mois (-X, où X est le numéro du mois).\n\n    Exemples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "de": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Berechnet den Gesamtbetrag an Geld, den Jinjin am Ende des Jahres haben wird,\n    nachdem sie ihren Sparplan mit ihrer Mutter befolgt hat. Jeden Monat kann sie\n    Vielfache von 100 von ihrem Taschengeld (300 pro Monat) sparen, wenn sie \n    voraussagt, dass nach den Ausgaben mindestens 100 Einheiten übrig bleiben. \n    Das gesparte Geld wird am Ende des Jahres 20% Zinsen erhalten.\n\n    Parameter:\n    budgets (List[int]): Eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n\n    Rückgabewert:\n    int: Der Gesamtbetrag an Geld, den Jinjin am Ende des Jahres nach Zinsen haben wird.\n         Wenn Jinjin in einem bestimmten Monat kein Geld mehr hat, wird der negative Wert\n         dieses Monats zurückgegeben (-X, wobei X die Monatsnummer ist).\n\n    Beispiele:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "ha": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Lissafa jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara\n    bayan bin shirin ajiyarta tare da mahaifiyarta. Kowanne wata, za ta iya ajiye\n    ninki na 100 daga kuɗin aljihunta (300 a kowane wata) idan ta yi hasashen samun\n    a kalla raka'a 100 da suka rage bayan kashe-kashe. Kuɗin da aka ajiye zai samu\n    riba ta kashi 20% a ƙarshen shekara.\n\n    Sigogi:\n    budgets (List[int]): Jerin lambobi 12 da ke wakiltar kasafin kuɗin wata-wata na Jinjin.\n\n    Komawa:\n    int: Jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara bayan riba.\n         Idan Jinjin ta ƙare da kuɗi a kowanne wata, za a mayar da ƙimar watan nan a matsayin\n         ƙima mara kyau (-X, inda X shine lambar watan).\n\n    Misalai:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "hi": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    वर्ष के अंत तक जिनजिन के पास कुल कितनी राशि होगी की गणना करता है\n    अपनी माँ के साथ उसकी बचत योजना का पालन करने के बाद। प्रत्येक महीने, वह\n    अपने पॉकेट मनी (प्रति माह 300) से 100 के गुणक बचा सकती है यदि वह अनुमान लगाती है कि\n    खर्चों के बाद कम से कम 100 यूनिट शेष रहेंगे। बचाई गई राशि को वर्ष के अंत में 20%\n    ब्याज मिलेगा।\n\n    पैरामीटर्स:\n    budgets (List[int]): जिनजिन के मासिक बजट का प्रतिनिधित्व करने वाले 12 पूर्णांकों की सूची।\n\n    रिटर्न्स:\n    int: वर्ष के अंत में ब्याज के बाद जिनजिन के पास कुल राशि होगी।\n         यदि जिनजिन किसी भी महीने में पैसे से बाहर हो जाती है, तो उस महीने का नकारात्मक मान लौटाता है (-X, जहाँ X महीने का नंबर है)।\n\n    उदाहरण:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "hu": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Kiszámítja, hogy mennyi pénze lesz Jinjinnek az év végére, miután követi\n    a megtakarítási tervét az anyukájával. Minden hónapban 100 többszöröseit\n    tudja megtakarítani a zsebpénzéből (300 havonta), ha előre látja, hogy\n    legalább 100 egység marad a kiadások után. A megtakarított pénz az év\n    végén 20% kamatot kap.\n\n    Paraméterek:\n    budgets (List[int]): Egy lista, amely 12 egész számot tartalmaz, Jinjin havi költségvetését.\n\n    Visszatér:\n    int: Az összeg, amivel Jinjin az év végén rendelkezni fog a kamatok után.\n         Ha Jinjin bármelyik hónapban kifogy a pénzből, akkor az adott hónap\n         negatív értékével tér vissza (-X, ahol X a hónap száma).\n\n    Példák:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "es": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calcula la cantidad total de dinero que Jinjin tendrá al final del año\n    después de seguir su plan de ahorros con su madre. Cada mes, puede ahorrar\n    múltiplos de 100 de su dinero de bolsillo (300 por mes) si predice tener\n    al menos 100 unidades restantes después de los gastos. El dinero ahorrado ganará un 20%\n    de interés al final del año.\n\n    Parámetros:\n    budgets (List[int]): Una lista de 12 enteros que representa el presupuesto mensual de Jinjin.\n\n    Devuelve:\n    int: La cantidad total de dinero que Jinjin tendrá al final del año después de los intereses.\n         Si Jinjin se queda sin dinero en cualquier mes, devuelve el valor negativo de\n         ese mes (-X, donde X es el número del mes).\n\n    Ejemplos:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "arb": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    يحسب إجمالي المبلغ الذي ستحصل عليه جينجين بحلول نهاية العام\n    بعد اتباع خطة التوفير الخاصة بها مع والدتها. كل شهر، يمكنها توفير\n    مضاعفات 100 من مصروفها الشهري (300 شهريًا) إذا توقعت أن يكون لديها\n    على الأقل 100 وحدة متبقية بعد النفقات. الأموال المدخرة ستحصل على فائدة بنسبة 20%\n    في نهاية العام.\n\n    المعلمات:\n    budgets (List[int]): قائمة تحتوي على 12 عددًا صحيحًا تمثل ميزانية جينجين الشهرية.\n\n    العوائد:\n    int: إجمالي المبلغ الذي ستحصل عليه جينجين في نهاية العام بعد الفائدة.\n         إذا نفدت أموال جينجين في أي شهر معين، يتم إرجاع القيمة السلبية\n         لذلك الشهر (-X، حيث X هو رقم الشهر).\n\n    أمثلة:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "sw": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Inakokotoa jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka\n    baada ya kufuata mpango wake wa akiba na mama yake. Kila mwezi, anaweza kuweka\n    akiba ya mara 100 kutoka kwenye pesa zake za mfukoni (300 kwa mwezi) ikiwa anatarajia kuwa\n    na angalau vitengo 100 vilivyobaki baada ya matumizi. Pesa zilizowekwa akiba zitapata riba ya 20%\n    mwishoni mwa mwaka.\n\n    Vigezo:\n    budgets (List[int]): Orodha ya namba 12 zinazowakilisha bajeti ya kila mwezi ya Jinjin.\n\n    Inarudisha:\n    int: Jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya riba.\n         Ikiwa Jinjin atamaliza pesa katika mwezi wowote, inarudisha thamani hasi ya\n         mwezi huo (-X, ambapo X ni namba ya mwezi).\n\n    Mifano:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "tr": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Jinjin'in annesiyle yaptığı tasarruf planını takip ettikten sonra yıl sonunda\n    ne kadar parası olacağını hesaplar. Her ay, masraflardan sonra en az 100 birim\n    kalacağını öngörürse, cep harçlığından (ayda 300) 100'ün katları kadar tasarruf\n    edebilir. Biriktirilen para yıl sonunda %20 faiz kazanacaktır.\n\n    Parametreler:\n    budgets (List[int]): Jinjin'in aylık bütçesini temsil eden 12 tam sayıdan oluşan bir liste.\n\n    Döndürür:\n    int: Faizden sonra yıl sonunda Jinjin'in sahip olacağı toplam para miktarı.\n         Jinjin herhangi bir ayda parasız kalırsa, o ayın negatif değeri döndürülür (-X, burada X ay numarasıdır).\n\n    Örnekler:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "vi": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Tính tổng số tiền mà Jinjin sẽ có vào cuối năm\n    sau khi thực hiện kế hoạch tiết kiệm với mẹ của cô ấy. Mỗi tháng, cô ấy có thể tiết kiệm\n    bội số của 100 từ tiền tiêu vặt của mình (300 mỗi tháng) nếu cô ấy dự đoán còn lại\n    ít nhất 100 đơn vị sau khi chi tiêu. Số tiền tiết kiệm sẽ được lãi 20%\n    vào cuối năm.\n\n    Tham số:\n    budgets (List[int]): Một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n\n    Trả về:\n    int: Tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi có lãi.\n         Nếu Jinjin hết tiền trong bất kỳ tháng nào, trả về giá trị âm của\n         tháng đó (-X, trong đó X là số tháng).\n\n    Ví dụ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "id": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Menghitung jumlah total uang yang akan dimiliki Jinjin pada akhir tahun\n    setelah mengikuti rencana tabungannya dengan ibunya. Setiap bulan, dia dapat menabung\n    kelipatan 100 dari uang sakunya (300 per bulan) jika dia memprediksi memiliki\n    setidaknya 100 unit tersisa setelah pengeluaran. Uang yang ditabung akan mendapatkan bunga 20%\n    pada akhir tahun.\n\n    Parameter:\n    budgets (List[int]): Daftar 12 bilangan bulat yang mewakili anggaran bulanan Jinjin.\n\n    Mengembalikan:\n    int: Jumlah total uang yang akan dimiliki Jinjin pada akhir tahun setelah bunga.\n         Jika Jinjin kehabisan uang di bulan tertentu, mengembalikan nilai negatif dari\n         bulan tersebut (-X, di mana X adalah nomor bulan).\n\n    Contoh:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "ja": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    年末までにJinjinが母親と一緒に貯金計画を実行した場合に持つ合計金額を計算します。\n    各月、彼女は少なくとも100単位が経費後に残ると予測される場合、毎月の小遣い（毎月300）から\n    100の倍数を貯金することができます。貯金したお金は年末に20%の利息を得ます。\n\n    パラメータ:\n    budgets (List[int]): Jinjinの月ごとの予算を表す12個の整数のリスト。\n\n    戻り値:\n    int: 年末に利息後にJinjinが持つ合計金額。\n         もしJinjinが任意の月にお金が足りなくなった場合、その月の負の値を返します（-X、ここでXは月の番号）。\n\n    例:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "ko": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Jinjin이 그녀의 어머니와 함께하는 저축 계획을 따른 후 연말까지 갖게 될 총 금액을 계산합니다.\n    매달 그녀는 비용 후에 최소 100 단위가 남을 것으로 예상되면 용돈(월 300)에서 100의 배수를 저축할 수 있습니다.\n    저축한 돈은 연말에 20%의 이자를 얻게 됩니다.\n\n    매개변수:\n    budgets (List[int]): Jinjin의 월별 예산을 나타내는 12개의 정수 리스트.\n\n    반환값:\n    int: 이자 후 연말에 Jinjin이 갖게 될 총 금액.\n         Jinjin이 어떤 달에 돈이 부족해지면, 그 달의 음수 값(-X, 여기서 X는 달 번호)을 반환합니다.\n\n    예시:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "ml": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    ജിൻജിൻ അവളുടെ അമ്മയുമായി ചേർന്ന് അനുശീലിക്കുന്ന സമ്പാദ്യ പദ്ധതിയെ തുടർന്ന്\n    വർഷാവസാനത്തോടെ അവൾക്ക് എത്രത്തോളം പണം ഉണ്ടാകുമെന്ന് കണക്കാക്കുന്നു. ഓരോ മാസവും,\n    ചെലവുകൾക്ക് ശേഷം കുറഞ്ഞത് 100 യൂണിറ്റ് ശേഷിക്കുമെന്ന് പ്രവചിച്ചാൽ, അവൾക്ക്\n    അവളുടെ പോക്കറ്റ് മണിയിൽ നിന്ന് (മാസത്തിൽ 300) 100ന്റെ ഗുണിതകങ്ങൾ\n    സമ്പാദിക്കാൻ കഴിയും. സമ്പാദിച്ച പണം വർഷാവസാനത്തിൽ 20% പലിശ നേടും.\n\n    പാരാമീറ്ററുകൾ:\n    budgets (List[int]): ജിൻജിൻ്റെ മാസാന്ത ബജറ്റ് പ്രതിനിധീകരിക്കുന്ന 12 പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n\n    മടക്കങ്ങൾ:\n    int: പലിശയ്ക്കുശേഷം വർഷാവസാനത്തിൽ ജിൻജിൻക്ക് ഉണ്ടാകുന്ന പണത്തിന്റെ മൊത്തം തുക.\n         ജിൻജിൻ ഏത് മാസത്തിലും പണം തീർന്നുപോകുകയാണെങ്കിൽ, ആ മാസത്തിന്റെ\n         നെഗറ്റീവ് മൂല്യം (-X, X മാസ സംഖ്യയാണ്) മടക്കുന്നു.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"", "fa": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    محاسبه مقدار کل پولی که جینجین تا پایان سال پس از پیروی از برنامه پس‌انداز خود با مادرش خواهد داشت.\n    هر ماه، او می‌تواند مضرب‌های 100 از پول توجیبی خود (300 در ماه) را پس‌انداز کند اگر پیش‌بینی کند که\n    حداقل 100 واحد پس از هزینه‌ها باقی می‌ماند. پول پس‌انداز شده در پایان سال 20% سود دریافت خواهد کرد.\n\n    پارامترها:\n    budgets (List[int]): لیستی از 12 عدد صحیح که بودجه ماهانه جینجین را نشان می‌دهد.\n\n    بازگشت:\n    int: مقدار کل پولی که جینجین در پایان سال پس از سود خواهد داشت.\n         اگر جینجین در هر ماهی پولش تمام شود، مقدار منفی آن ماه را برمی‌گرداند (-X، جایی که X شماره ماه است).\n\n    مثال‌ها:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\""}, "canonical_solution": "    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money", "instruction": {"en": "Write a python function 'def jinjin_savings_plan(budgets: List[int]) -> int:' to solve the following problem:\n\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    ", "sq": "Shkruani një funksion python 'def jinjin_savings_plan(budgets: List[int]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit shumën totale të parave që Jinjin do të ketë deri në fund të vitit\n    pasi të ndjekë planin e saj të kursimeve me nënën e saj. Çdo muaj, ajo mund të kursejë\n    shumëfish të 100 nga paratë e saj të xhepit (300 në muaj) nëse parashikon se do të ketë\n    të paktën 100 njësi të mbetura pas shpenzimeve. Paratë e kursyera do të fitojnë 20%\n    interes në fund të vitit.\n\n    Parametrat:\n    budgets (List[int]): Një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n\n    Kthen:\n    int: Shuma totale e parave që Jinjin do të ketë në fund të vitit pas interesit.\n         Nëse Jinjin mbetet pa para në ndonjë muaj të caktuar, kthen vlerën negative të\n         atij muaji (-X, ku X është numri i muajit).\n\n    Shembuj:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "hy": "Պայթոն ֆունկցիա 'def jinjin_savings_plan(budgets: List[int]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկում է գումարի ընդհանուր քանակը, որը Ջինջինը կունենա տարվա վերջում\n    իր մայրիկի հետ խնայողությունների պլանին հետևելուց հետո: Ամեն ամիս, նա կարող է խնայել\n    100-ի բազմապատիկներ իր գրպանի գումարից (300 ամսական), եթե կանխատեսում է, որ\n    ծախսերից հետո առնվազն 100 միավոր կմնա: Խնայված գումարը կստանա 20%\n    տոկոսադրույք տարվա վերջում:\n\n    Պարամետրեր:\n    budgets (List[int]): 12 ամբողջ թվերի ցուցակ, որը ներկայացնում է Ջինջինի ամսական բյուջեն:\n\n    Վերադարձնում է:\n    int: Գումարի ընդհանուր քանակը, որը Ջինջինը կունենա տարվա վերջում տոկոսադրույքից հետո:\n         Եթե Ջինջինը որևէ ամսում գումարից դուրս է գալիս, վերադարձնում է\n         այդ ամսվա բացասական արժեքը (-X, որտեղ X-ը ամսվա համարանիշն է):\n\n    Օրինակներ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "bn": "একটি পাইথন ফাংশন 'def jinjin_savings_plan(budgets: List[int]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    জিনজিন তার মায়ের সাথে তার সঞ্চয় পরিকল্পনা অনুসরণ করার পরে বছরের শেষে তার কাছে মোট কত টাকা থাকবে তা গণনা করে। \n    প্রতিটি মাসে, সে তার পকেট মানি (প্রতি মাসে 300) থেকে 100 এর গুণিতক সঞ্চয় করতে পারে যদি সে পূর্বাভাস দেয় যে \n    খরচের পরে অন্তত 100 ইউনিট অবশিষ্ট থাকবে। সঞ্চিত অর্থ বছরের শেষে 20% সুদ অর্জন করবে।\n\n    প্যারামিটার:\n    budgets (List[int]): জিনজিনের মাসিক বাজেটের প্রতিনিধিত্বকারী 12টি পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্ন:\n    int: বছরের শেষে সুদের পরে জিনজিনের কাছে মোট কত টাকা থাকবে।\n         যদি জিনজিন কোনো নির্দিষ্ট মাসে টাকা শেষ হয়ে যায়, তাহলে সেই মাসের ঋণাত্মক মান (-X, যেখানে X হল মাসের সংখ্যা) ফেরত দেয়।\n\n    উদাহরণ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "bg": "Напишете Python функция 'def jinjin_savings_plan(budgets: List[int]) -> int:' за решаване на следния проблем:\n\n    Изчислява общата сума пари, която Джинджин ще има в края на годината\n    след като следва своя план за спестявания с майка си. Всеки месец тя може да спестява\n    кратни на 100 от джобните си пари (300 на месец), ако предвижда да има\n    поне 100 единици, оставащи след разходите. Спестените пари ще натрупат 20%\n    лихва в края на годината.\n\n    Параметри:\n    budgets (List[int]): Списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n\n    Връща:\n    int: Общата сума пари, която Джинджин ще има в края на годината след лихвата.\n         Ако Джинджин остане без пари в който и да е месец, връща отрицателната стойност на\n         този месец (-X, където X е номерът на месеца).\n\n    Примери:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "zh": "编写一个Python函数 'def jinjin_savings_plan(budgets: List[int]) -> int:' 来解决以下问题：\n\n    计算Jinjin在年底时根据她和她母亲的储蓄计划将拥有的总金额。每个月，如果她预计在支出后至少剩余100单位，她可以从她的零用钱（每月300）中储蓄100的倍数。储蓄的钱将在年底获得20%的利息。\n\n    参数:\n    budgets (List[int]): 一个包含12个整数的列表，表示Jinjin的每月预算。\n\n    返回:\n    int: Jinjin在年底获得利息后的总金额。\n         如果Jinjin在任何一个月用完了钱，返回该月的负值 (-X，其中X是月份编号)。\n\n    示例:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "fr": "Écrivez une fonction python 'def jinjin_savings_plan(budgets: List[int]) -> int:' pour résoudre le problème suivant :\n\n    Calcule le montant total d'argent que Jinjin aura à la fin de l'année\n    après avoir suivi son plan d'épargne avec sa mère. Chaque mois, elle peut économiser\n    des multiples de 100 de son argent de poche (300 par mois) si elle prévoit d'avoir\n    au moins 100 unités restantes après les dépenses. L'argent économisé gagnera 20%\n    d'intérêt à la fin de l'année.\n\n    Paramètres:\n    budgets (List[int]): Une liste de 12 entiers représentant le budget mensuel de Jinjin.\n\n    Renvoie:\n    int: Le montant total d'argent que Jinjin aura à la fin de l'année après intérêts.\n         Si Jinjin manque d'argent à un mois donné, renvoie la valeur négative de\n         ce mois (-X, où X est le numéro du mois).\n\n    Exemples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "de": "Schreiben Sie eine Python-Funktion 'def jinjin_savings_plan(budgets: List[int]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnet den Gesamtbetrag an Geld, den Jinjin am Ende des Jahres haben wird,\n    nachdem sie ihren Sparplan mit ihrer Mutter befolgt hat. Jeden Monat kann sie\n    Vielfache von 100 von ihrem Taschengeld (300 pro Monat) sparen, wenn sie vorhersieht,\n    dass nach den Ausgaben mindestens 100 Einheiten übrig bleiben. Das gesparte Geld wird\n    am Ende des Jahres 20% Zinsen erhalten.\n\n    Parameter:\n    budgets (List[int]): Eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n\n    Rückgabewert:\n    int: Der Gesamtbetrag an Geld, den Jinjin am Ende des Jahres nach Zinsen haben wird.\n         Wenn Jinjin in einem bestimmten Monat kein Geld mehr hat, wird der negative Wert\n         dieses Monats zurückgegeben (-X, wobei X die Monatsnummer ist).\n\n    Beispiele:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "ha": "Rubuta wani aikin python 'def jinjin_savings_plan(budgets: List[int]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara\n    bayan bin shirin ajiyar kuɗinta tare da mahaifiyarta. Kowanne wata, za ta iya ajiye\n    sau na 100 daga aljihun kuɗinta (300 a kowane wata) idan ta hango cewa za ta rage\n    aƙalla raka'a 100 bayan kashe-kashe. Kuɗin da aka ajiye zai samu riba ta 20%\n    a ƙarshen shekara.\n\n    Sigogi:\n    budgets (List[int]): Jerin lambobi 12 da ke wakiltar kasafin kuɗin wata-wata na Jinjin.\n\n    Mayarwa:\n    int: Jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara bayan riba.\n         Idan Jinjin ta ƙare da kuɗi a kowanne wata, za ta mayar da ƙimar\n         wannan watan a matsayin mummunan adadi (-X, inda X shine lambar watan).\n\n    Misalai:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "hi": "एक पायथन फ़ंक्शन 'def jinjin_savings_plan(budgets: List[int]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    वर्ष के अंत तक जिंजिन के पास कुल कितनी राशि होगी, यह उसकी बचत योजना का पालन करने के बाद \n    उसकी माँ के साथ गणना करता है। प्रत्येक महीने, वह अपनी पॉकेट मनी (प्रति माह 300) से \n    100 के गुणांक बचा सकती है यदि वह अनुमान लगाती है कि खर्चों के बाद कम से कम 100 इकाइयाँ \n    शेष रहेंगी। बचाई गई राशि को वर्ष के अंत में 20% ब्याज मिलेगा।\n\n    पैरामीटर्स:\n    budgets (List[int]): जिंजिन के मासिक बजट का प्रतिनिधित्व करने वाले 12 पूर्णांकों की एक सूची।\n\n    लौटाता है:\n    int: वर्ष के अंत में ब्याज के बाद जिंजिन के पास कुल कितनी राशि होगी।\n         यदि जिंजिन किसी भी महीने में पैसे से बाहर हो जाती है, तो उस महीने का नकारात्मक \n         मान लौटाता है (-X, जहाँ X महीने का नंबर है)।\n\n    उदाहरण:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "hu": "Írj egy python függvényt 'def jinjin_savings_plan(budgets: List[int]) -> int:' a következő probléma megoldására:\n\n    Kiszámítja a teljes pénzösszeget, amivel Jinjin az év végére rendelkezni fog,\n    miután követte a megtakarítási tervét az anyjával. Minden hónapban megtakaríthat\n    100-as többszöröseit a zsebpénzéből (300 havonta), ha előre látja, hogy a kiadások után\n    legalább 100 egység marad. A megtakarított pénz az év végén 20%-os\n    kamatot fog kapni.\n\n    Paraméterek:\n    budgets (List[int]): Egy lista, amely 12 egész számot tartalmaz Jinjin havi költségvetéséről.\n\n    Visszatérési érték:\n    int: A teljes pénzösszeg, amivel Jinjin az év végén rendelkezni fog a kamatok után.\n         Ha Jinjin bármelyik hónapban kifogy a pénzből, akkor az adott hónap negatív értékét adja vissza\n         (-X, ahol X a hónap száma).\n\n    Példák:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "es": "Escribe una función de Python 'def jinjin_savings_plan(budgets: List[int]) -> int:' para resolver el siguiente problema:\n\nCalcula la cantidad total de dinero que Jinjin tendrá al final del año después de seguir su plan de ahorros con su madre. Cada mes, ella puede ahorrar múltiplos de 100 de su dinero de bolsillo (300 por mes) si predice tener al menos 100 unidades restantes después de los gastos. El dinero ahorrado ganará un interés del 20% al final del año.\n\nParámetros:\nbudgets (List[int]): Una lista de 12 enteros que representan el presupuesto mensual de Jinjin.\n\nDevuelve:\nint: La cantidad total de dinero que Jinjin tendrá al final del año después de los intereses. Si Jinjin se queda sin dinero en cualquier mes, devuelve el valor negativo de ese mes (-X, donde X es el número del mes).\n\nEjemplos:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580", "arb": "اكتب دالة بايثون 'def jinjin_savings_plan(budgets: List[int]) -> int:' لحل المشكلة التالية:\n\n    تحسب المبلغ الإجمالي من المال الذي ستحصل عليه جينجين بحلول نهاية العام\n    بعد اتباع خطة التوفير الخاصة بها مع والدتها. كل شهر، يمكنها توفير\n    مضاعفات 100 من مصروفها الشهري (300 شهريًا) إذا توقعت بقاء\n    على الأقل 100 وحدة بعد النفقات. المال المدخر سيحصل على فائدة بنسبة 20%\n    في نهاية العام.\n\n    المعاملات:\n    budgets (List[int]): قائمة مكونة من 12 عددًا صحيحًا تمثل الميزانية الشهرية لجينجين.\n\n    يعيد:\n    int: المبلغ الإجمالي من المال الذي ستحصل عليه جينجين في نهاية العام بعد الفائدة.\n         إذا نفد المال من جينجين في أي شهر معين، يعيد القيمة السالبة لذلك الشهر (-X، حيث X هو رقم الشهر).\n\n    أمثلة:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "sw": "Andika kazi ya python 'def jinjin_savings_plan(budgets: List[int]) -> int:' kutatua tatizo lifuatalo:\n\n    Inahesabu jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka\n    baada ya kufuata mpango wake wa akiba na mama yake. Kila mwezi, anaweza kuweka\n    akiba ya mara 100 kutoka kwenye pesa zake za mfukoni (300 kwa mwezi) ikiwa anatarajia kuwa\n    na angalau vitengo 100 vilivyobaki baada ya matumizi. Pesa zilizowekwa akiba zitapata riba ya 20%\n    mwishoni mwa mwaka.\n\n    Vigezo:\n    budgets (List[int]): Orodha ya namba 12 zinazowakilisha bajeti ya kila mwezi ya Jinjin.\n\n    Inarudisha:\n    int: Jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya riba.\n         Ikiwa Jinjin atamaliza pesa katika mwezi wowote, inarudisha thamani hasi ya\n         mwezi huo (-X, ambapo X ni namba ya mwezi).\n\n    Mifano:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "tr": "Bir python fonksiyonu 'def jinjin_savings_plan(budgets: List[int]) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Jinjin'in annesiyle birlikte takip ettiği tasarruf planı sonucunda yıl sonunda\n    ne kadar parası olacağını hesaplar. Her ay, harcamalardan sonra en az 100 birim\n    kalacağını tahmin ederse, cep harçlığından (ayda 300) 100'ün katları kadar\n    tasarruf edebilir. Tasarruf edilen para yıl sonunda %20 faiz kazanacaktır.\n\n    Parametreler:\n    budgets (List[int]): Jinjin'in aylık bütçesini temsil eden 12 tamsayıdan oluşan bir liste.\n\n    Döndürülenler:\n    int: Jinjin'in yıl sonunda faizle birlikte sahip olacağı toplam para miktarı.\n         Eğer Jinjin herhangi bir ayda parasız kalırsa, o ayın negatif değerini döndürür\n         (-X, burada X ay numarasıdır).\n\n    Örnekler:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "vi": "Viết một hàm python 'def jinjin_savings_plan(budgets: List[int]) -> int:' để giải quyết vấn đề sau:\n\n    Tính tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi thực hiện kế hoạch tiết kiệm với mẹ của cô ấy. Mỗi tháng, cô ấy có thể tiết kiệm bội số của 100 từ tiền tiêu vặt của mình (300 mỗi tháng) nếu cô ấy dự đoán còn lại ít nhất 100 đơn vị sau khi chi tiêu. Số tiền tiết kiệm sẽ được hưởng lãi suất 20% vào cuối năm.\n\n    Tham số:\n    budgets (List[int]): Một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n\n    Trả về:\n    int: Tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi tính lãi.\n         Nếu Jinjin hết tiền trong bất kỳ tháng nào, trả về giá trị âm của tháng đó (-X, trong đó X là số tháng).\n\n    Ví dụ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "id": "Tulis fungsi python 'def jinjin_savings_plan(budgets: List[int]) -> int:' untuk menyelesaikan masalah berikut:\n\n    Menghitung jumlah total uang yang akan dimiliki Jinjin pada akhir tahun\n    setelah mengikuti rencana tabungannya dengan ibunya. Setiap bulan, dia dapat menabung\n    kelipatan 100 dari uang sakunya (300 per bulan) jika dia memperkirakan memiliki\n    setidaknya 100 unit tersisa setelah pengeluaran. Uang yang ditabung akan mendapatkan bunga 20%\n    pada akhir tahun.\n\n    Parameter:\n    budgets (List[int]): Daftar 12 bilangan bulat yang mewakili anggaran bulanan Jinjin.\n\n    Mengembalikan:\n    int: Jumlah total uang yang akan dimiliki Jinjin pada akhir tahun setelah bunga.\n         Jika Jinjin kehabisan uang di bulan mana pun, kembalikan nilai negatif dari\n         bulan tersebut (-X, di mana X adalah nomor bulan).\n\n    Contoh:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "ja": "Python関数を書いてください。 'def jinjin_savings_plan(budgets: List[int]) -> int:' を解決するために以下の問題を:\n\n    年末までにJinjinが貯金計画に従ってどれだけのお金を持つことになるかを計算します。彼女は毎月、少なくとも100単位が経費後に残ると予測できる場合、毎月の小遣い（毎月300）から100の倍数を貯金することができます。貯金したお金は年末に20％の利息を得ます。\n\n    パラメータ:\n    budgets (List[int]): Jinjinの毎月の予算を表す12個の整数のリスト。\n\n    戻り値:\n    int: 年末に利息を含めてJinjinが持つことになる総額。\n         Jinjinがどの月でもお金を使い果たした場合、その月の負の値を返します (-X, ここでXは月の番号です)。\n\n    例:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "ko": "파이썬 함수를 작성하십시오 'def jinjin_savings_plan(budgets: List[int]) -> int:' 다음 문제를 해결하기 위해:\n\n    Jinjin이 그녀의 어머니와 함께 저축 계획을 따름으로써 연말까지 갖게 될 총 금액을 계산합니다.\n    매달 그녀는 지출 후 최소 100 단위가 남을 것으로 예상되면 용돈(월 300)에서 100의 배수를 저축할 수 있습니다.\n    저축한 돈은 연말에 20%의 이자를 얻게 됩니다.\n\n    매개변수:\n    budgets (List[int]): Jinjin의 월별 예산을 나타내는 12개의 정수 리스트.\n\n    반환값:\n    int: 이자 후 Jinjin이 연말에 갖게 될 총 금액.\n         Jinjin이 어떤 달에 돈이 떨어지면, 그 달의 음수 값을 반환합니다 (-X, 여기서 X는 달 번호입니다).\n\n    예시:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "ml": "ഒരു പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക 'def jinjin_savings_plan(budgets: List[int]) -> int:' താഴെക്കൊടുത്തിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    വർഷാവസാനത്തോടെ ജിൻജിനിന് അവളുടെ അമ്മയോടൊപ്പം നടത്തിവരുന്ന സേവിംഗ്സ് പ്ലാൻ\n    അനുസരിച്ച് എത്രത്തോളം പണം ഉണ്ടാകുമെന്ന് കണക്കാക്കുക. ഓരോ മാസവും, അവൾക്ക്\n    100യുടെ ഗുണിതകങ്ങൾ അവളുടെ പോക്കറ്റ് മണിയിൽ നിന്ന് (മാസത്തിൽ 300) സംരക്ഷിക്കാൻ\n    കഴിയും, ചെലവുകൾക്ക് ശേഷം കുറഞ്ഞത് 100 യൂണിറ്റ് ശേഷിക്കുന്നതായി പ്രവചിച്ചാൽ.\n    സംരക്ഷിച്ച പണം വർഷാവസാനത്തിൽ 20% പലിശ നേടും.\n\n    പാരാമീറ്ററുകൾ:\n    budgets (List[int]): ജിൻജിന്റെ മാസാന്ത ബജറ്റ് പ്രതിനിധീകരിക്കുന്ന 12 പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n\n    മടക്കങ്ങൾ:\n    int: പലിശയ്ക്കുശേഷം വർഷാവസാനത്തിൽ ജിൻജിനിന് ഉണ്ടാകുന്ന പണത്തിന്റെ മൊത്തം തുക.\n         ജിൻജിൻ ഏതെങ്കിലും മാസത്തിൽ പണം തീർന്നാൽ, ആ മാസത്തിന്റെ\n         നെഗറ്റീവ് മൂല്യം (-X, എവിടെ X മാസ സംഖ്യയാണ്) മടക്കുന്നു.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "fa": "یک تابع پایتون بنویسید 'def jinjin_savings_plan(budgets: List[int]) -> int:' برای حل مسئله زیر:\n\n    محاسبه می‌کند که جینجین تا پایان سال پس از دنبال کردن برنامه پس‌انداز خود با مادرش چقدر پول خواهد داشت.\n    هر ماه، او می‌تواند مضربی از 100 از پول جیبی خود (300 در ماه) پس‌انداز کند اگر پیش‌بینی کند که حداقل 100 واحد پس از هزینه‌ها باقی می‌ماند.\n    پول پس‌انداز شده در پایان سال 20% سود خواهد داشت.\n\n    پارامترها:\n    budgets (List[int]): لیستی از 12 عدد صحیح که بودجه ماهانه جینجین را نشان می‌دهد.\n\n    بازگشت:\n    int: مقدار کل پولی که جینجین در پایان سال پس از سود خواهد داشت.\n         اگر جینجین در هر ماهی پولش تمام شود، مقدار منفی آن ماه را برمی‌گرداند (-X، که X شماره ماه است).\n\n    مثال‌ها:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580"}, "level": "middle", "test": "def test_jinjin_savings_plan():\n    # Test case 1: Jinjin runs out of money in July (the 7th month)\n    budgets1 = [290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets1) == -7, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin has 1580 units of currency by the end of the year\n    budgets2 = [290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets2) == 1580, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin manages her budget perfectly and has a specific amount by the end\n    budgets3 = [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300]\n    assert jinjin_savings_plan(budgets3) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Jinjin does not need to save any money and spends exactly the amount she receives\n    budgets4 = [300, 290, 280, 270, 260, 250, 240, 230, 220, 210, 200, 190]\n    assert jinjin_savings_plan(budgets4) == 780, \"Test case 4 failed\"\n\n    # Test case 5: Jinjin runs out of money in the first month\n    budgets5 = [350, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n    assert jinjin_savings_plan(budgets5) == -1, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_jinjin_savings_plan()", "entry_point": "jinjin_savings_plan", "signature": "def jinjin_savings_plan(budgets: List[int]) -> int:", "docstring": {"en": "\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    ", "sq": "\n    Llogarit shumën totale të parave që Jinjin do të ketë deri në fund të vitit\n    pasi të ndjekë planin e saj të kursimeve me nënën e saj. Çdo muaj, ajo mund të kursejë\n    shumëfish të 100 nga paratë e saj të xhepit (300 në muaj) nëse parashikon të ketë\n    të paktën 100 njësi të mbetura pas shpenzimeve. Paratë e kursyera do të fitojnë 20%\n    interes në fund të vitit.\n\n    Parametrat:\n    budgets (List[int]): Një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n\n    Kthen:\n    int: Shuma totale e parave që Jinjin do të ketë në fund të vitit pas interesit.\n         Nëse Jinjin mbetet pa para në ndonjë muaj të caktuar, kthen vlerën negative të\n         atij muaji (-X, ku X është numri i muajit).\n\n    Shembuj:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "hy": "\n    Հաշվում է գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում\n    իր խնայողությունների պլանը մոր հետ հետևելուց հետո: Ամեն ամիս նա կարող է խնայել\n    100-ի բազմապատիկներ իր գրպանի գումարից (300 ամսական), եթե կանխատեսում է, որ կունենա\n    առնվազն 100 միավոր մնացորդ ծախսերից հետո: Խնայված գումարը կստանա 20%\n    տոկոսադրույք տարվա վերջում:\n\n    Պարամետրեր:\n    budgets (List[int]): 12 ամբողջ թվերի ցուցակ, որը ներկայացնում է Ջինջինի ամսական բյուջեն:\n\n    Վերադարձնում է:\n    int: Գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում տոկոսադրույքից հետո:\n         Եթե Ջինջինը որևէ ամսում գումարը սպառի, վերադարձնում է\n         այդ ամսվա բացասական արժեքը (-X, որտեղ X-ը ամսվա համարանիշն է):\n\n    Օրինակներ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "bn": "\n    বছরের শেষে জিনজিন তার সঞ্চয় পরিকল্পনা অনুসরণ করে তার মায়ের সাথে কত টাকা থাকবে তা গণনা করে।\n    প্রতি মাসে, সে তার পকেট মানি (প্রতি মাসে 300) থেকে 100 এর গুণিতক সঞ্চয় করতে পারে যদি সে পূর্বাভাস দেয় যে খরচের পরে কমপক্ষে 100 ইউনিট অবশিষ্ট থাকবে। সঞ্চিত অর্থ বছরের শেষে 20% সুদ অর্জন করবে।\n\n    প্যারামিটার:\n    budgets (List[int]): জিনজিনের মাসিক বাজেট উপস্থাপনকারী 12টি পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: বছরের শেষে সুদের পরে জিনজিনের মোট অর্থের পরিমাণ।\n         যদি জিনজিন কোনো মাসে অর্থ শেষ করে ফেলে, তাহলে সেই মাসের ঋণাত্মক মান (-X, যেখানে X হল মাসের সংখ্যা) রিটার্ন করে।\n\n    উদাহরণ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "bg": "\n    Изчислява общата сума пари, която Джинджин ще има в края на годината\n    следвайки нейния план за спестявания с майка си. Всеки месец тя може да спести\n    кратни на 100 от джобните си пари (300 на месец), ако предвижда да има\n    поне 100 единици оставащи след разходите. Спестените пари ще натрупат 20%\n    лихва в края на годината.\n\n    Параметри:\n    budgets (List[int]): Списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n\n    Връща:\n    int: Общата сума пари, която Джинджин ще има в края на годината след лихвата.\n         Ако Джинджин остане без пари в който и да е месец, връща отрицателната стойност на\n         този месец (-X, където X е номерът на месеца).\n\n    Примери:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "zh": "\n    计算金金在年末根据她和母亲的储蓄计划将拥有的总金额。每个月，如果她预测在支出后至少剩余100单位，她可以从她的零用钱（每月300）中储蓄100的倍数。储蓄的钱将在年末获得20%的利息。\n\n    参数:\n    budgets (List[int]): 一个包含12个整数的列表，表示金金每月的预算。\n\n    返回:\n    int: 金金在年末加上利息后的总金额。\n         如果金金在任何一个月用完了钱，返回该月份的负值（-X，其中X是月份编号）。\n\n    示例:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "fr": "\n    Calcule le montant total d'argent que Jinjin aura à la fin de l'année\n    après avoir suivi son plan d'épargne avec sa mère. Chaque mois, elle peut économiser\n    des multiples de 100 de son argent de poche (300 par mois) si elle prévoit d'avoir\n    au moins 100 unités restantes après les dépenses. L'argent économisé gagnera 20%\n    d'intérêt à la fin de l'année.\n\n    Paramètres:\n    budgets (List[int]): Une liste de 12 entiers représentant le budget mensuel de Jinjin.\n\n    Retourne:\n    int: Le montant total d'argent que Jinjin aura à la fin de l'année après les intérêts.\n         Si Jinjin manque d'argent à un moment donné du mois, retourne la valeur négative\n         de ce mois (-X, où X est le numéro du mois).\n\n    Exemples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "de": "\n    Berechnet den Gesamtbetrag an Geld, den Jinjin am Ende des Jahres haben wird,\n    nachdem sie ihren Sparplan mit ihrer Mutter befolgt hat. Jeden Monat kann sie\n    Vielfache von 100 von ihrem Taschengeld (300 pro Monat) sparen, wenn sie vorhersagt,\n    dass sie nach den Ausgaben mindestens 100 Einheiten übrig hat. Das gesparte Geld\n    wird am Ende des Jahres 20% Zinsen erhalten.\n\n    Parameter:\n    budgets (List[int]): Eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n\n    Rückgabe:\n    int: Der Gesamtbetrag an Geld, den Jinjin am Ende des Jahres nach Zinsen haben wird.\n         Wenn Jinjin in einem beliebigen Monat kein Geld mehr hat, wird der negative Wert\n         dieses Monats zurückgegeben (-X, wobei X die Monatsnummer ist).\n\n    Beispiele:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "ha": "\n    Lissafa jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara\n    bayan bin shirin ajiyar kuɗi tare da mahaifiyarta. Kowanne wata, za ta iya ajiye\n    sau na 100 daga aljihun kuɗinta (300 a kowane wata) idan ta hango samun\n    aƙalla raka'a 100 da suka rage bayan kashe kuɗi. Kuɗin da aka ajiye zai samu riba\n    na 20% a ƙarshen shekara.\n\n    Sigogi:\n    budgets (List[int]): Jerin lambobi 12 da ke wakiltar kasafin kuɗin wata-wata na Jinjin.\n\n    Returns:\n    int: Jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara bayan riba.\n         Idan Jinjin ta ƙare da kuɗi a kowane wata, za a dawo da ƙimar da ta zama\n         mara kyau na wannan watan (-X, inda X shine lambar watan).\n\n    Misalai:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "hi": "\n    वर्ष के अंत तक Jinjin के पास कुल कितनी धनराशि होगी, यह उसकी बचत योजना का पालन करने के बाद पता चलता है।\n    प्रत्येक माह, वह अपनी पॉकेट मनी (प्रति माह 300) से 100 के गुणक बचा सकती है यदि वह खर्चों के बाद कम से कम 100 इकाइयाँ बचने की भविष्यवाणी करती है। \n    बचाई गई धनराशि पर वर्ष के अंत में 20% ब्याज मिलेगा।\n\n    पैरामीटर्स:\n    budgets (List[int]): Jinjin के मासिक बजट का प्रतिनिधित्व करने वाले 12 पूर्णांकों की सूची।\n\n    रिटर्न्स:\n    int: वर्ष के अंत में ब्याज के बाद Jinjin के पास कुल धनराशि।\n         यदि किसी भी माह में Jinjin के पास धन समाप्त हो जाता है, तो उस माह का ऋणात्मक मान लौटाता है (-X, जहाँ X माह संख्या है)।\n\n    उदाहरण:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "hu": "\n    Kiszámítja, hogy mennyi pénze lesz Jinjinnek az év végére, miután követi az anyjával\n    közösen kidolgozott megtakarítási tervét. Minden hónapban 100 többszöröseit tudja\n    megtakarítani a zsebpénzéből (havonta 300), ha előre látja, hogy legalább 100 egység\n    marad a kiadások után. A megtakarított pénz az év végén 20% kamatot kap.\n\n    Paraméterek:\n    budgets (List[int]): Egy 12 egész számot tartalmazó lista, amely Jinjin havi költségvetését jelöli.\n\n    Visszatér:\n    int: Az év végén Jinjin összes pénze a kamat után.\n         Ha Jinjin bármelyik hónapban kifogy a pénzből, akkor visszatér a hónap negatív értékével\n         (-X, ahol X a hónap száma).\n\n    Példák:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "es": "Calcula la cantidad total de dinero que Jinjin tendrá al final del año después de seguir su plan de ahorros con su madre. Cada mes, puede ahorrar múltiplos de 100 de su dinero de bolsillo (300 por mes) si predice tener al menos 100 unidades restantes después de los gastos. El dinero ahorrado ganará un 20% de interés al final del año.\n\nParámetros:\nbudgets (List[int]): Una lista de 12 enteros que representan el presupuesto mensual de Jinjin.\n\nDevuelve:\nint: La cantidad total de dinero que Jinjin tendrá al final del año después del interés. Si Jinjin se queda sin dinero en cualquier mes, devuelve el valor negativo de ese mes (-X, donde X es el número del mes).\n\nEjemplos:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580", "arb": "    يحسب إجمالي المبلغ الذي ستحصل عليه جينجين بحلول نهاية العام\n    بعد اتباع خطة التوفير الخاصة بها مع والدتها. كل شهر، يمكنها توفير\n    مضاعفات 100 من مصروفها الشخصي (300 شهريًا) إذا توقعت أن يكون لديها\n    على الأقل 100 وحدة متبقية بعد النفقات. الأموال المدخرة ستحصل على فائدة بنسبة 20%\n    في نهاية العام.\n\n    المعاملات:\n    budgets (List[int]): قائمة مكونة من 12 عددًا صحيحًا تمثل الميزانية الشهرية لجينجين.\n\n    العوائد:\n    int: إجمالي المبلغ الذي ستحصل عليه جينجين في نهاية العام بعد الفائدة.\n         إذا نفدت أموال جينجين في أي شهر معين، يتم إرجاع القيمة السلبية\n         لذلك الشهر (-X، حيث X هو رقم الشهر).\n\n    أمثلة:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "sw": "    Inahesabu jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka\n    baada ya kufuata mpango wake wa akiba na mama yake. Kila mwezi, anaweza kuweka\n    akiba ya mara 100 kutoka kwenye pesa zake za mfukoni (300 kwa mwezi) ikiwa anatarajia kuwa na\n    angalau vitengo 100 vilivyobaki baada ya matumizi. Pesa zilizowekwa akiba zitapata riba ya 20%\n    mwishoni mwa mwaka.\n\n    Parameters:\n    budgets (List[int]): Orodha ya namba 12 zinazoashiria bajeti ya kila mwezi ya Jinjin.\n\n    Inarejesha:\n    int: Jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya riba.\n         Ikiwa Jinjin atamaliza pesa katika mwezi wowote, inarudisha thamani hasi ya\n         mwezi huo (-X, ambapo X ni namba ya mwezi).\n\n    Mifano:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "tr": "    Jinjin'in annesiyle yaptığı tasarruf planını takip ettikten sonra yıl sonunda sahip olacağı toplam para miktarını hesaplar. Her ay, en az 100 birim harcamalardan sonra kalacağını tahmin ederse, cep harçlığından (ayda 300) 100'ün katları kadar tasarruf edebilir. Biriktirilen para yıl sonunda %20 faiz kazanacaktır.\n\n    Parametreler:\n    budgets (List[int]): Jinjin'in aylık bütçesini temsil eden 12 tam sayıdan oluşan bir liste.\n\n    Döndürür:\n    int: Faizden sonra yıl sonunda Jinjin'in sahip olacağı toplam para miktarı.\n         Eğer Jinjin herhangi bir ayda parasız kalırsa, o ayın negatif değerini döndürür\n         (-X, burada X ay numarasıdır).\n\n    Örnekler:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "vi": "    Tính tổng số tiền Jinjin sẽ có vào cuối năm\n    sau khi thực hiện kế hoạch tiết kiệm với mẹ của mình. Mỗi tháng, cô ấy có thể tiết kiệm\n    bội số của 100 từ tiền tiêu vặt của mình (300 mỗi tháng) nếu cô ấy dự đoán còn lại\n    ít nhất 100 đơn vị sau khi chi tiêu. Số tiền tiết kiệm sẽ được hưởng lãi suất 20%\n    vào cuối năm.\n\n    Tham số:\n    budgets (List[int]): Một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n\n    Trả về:\n    int: Tổng số tiền Jinjin sẽ có vào cuối năm sau khi có lãi.\n         Nếu Jinjin hết tiền trong bất kỳ tháng nào, trả về giá trị âm của\n         tháng đó (-X, trong đó X là số tháng).\n\n    Ví dụ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "id": "Menghitung jumlah total uang yang akan dimiliki Jinjin pada akhir tahun setelah mengikuti rencana tabungannya dengan ibunya. Setiap bulan, dia dapat menabung kelipatan 100 dari uang sakunya (300 per bulan) jika dia memperkirakan memiliki setidaknya 100 unit tersisa setelah pengeluaran. Uang yang ditabung akan mendapatkan bunga 20% pada akhir tahun.\n\nParameter:\nbudgets (List[int]): Daftar 12 bilangan bulat yang mewakili anggaran bulanan Jinjin.\n\nMengembalikan:\nint: Jumlah total uang yang akan dimiliki Jinjin pada akhir tahun setelah bunga. Jika Jinjin kehabisan uang di bulan tertentu, mengembalikan nilai negatif dari bulan tersebut (-X, di mana X adalah nomor bulan).\n\nContoh:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580", "ja": "    ジンジンが母親との貯金計画に従った結果、年末までに持つことになる総額を計算します。\n    毎月、彼女は少なくとも100単位が出費後に残ると予測できる場合、ポケットマネー（毎月300）から100の倍数を貯金できます。\n    貯金したお金は年末に20%の利息を得ます。\n\n    パラメータ:\n    budgets (List[int]): ジンジンの月ごとの予算を表す12個の整数のリスト。\n\n    戻り値:\n    int: 利息後にジンジンが年末に持つことになる総額。\n         ジンジンが任意の月でお金が足りなくなった場合、その月の負の値を返します（-X、ここでXは月の番号です）。\n\n    例:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "ko": "    진진이 어머니와 함께하는 저축 계획에 따라 연말까지 가지게 될 총 금액을 계산합니다.\n    매달, 그녀는 용돈(월 300)에서 지출 후 최소 100 단위가 남을 것으로 예상되면 100의 배수를 저축할 수 있습니다.\n    저축한 돈은 연말에 20%의 이자를 얻게 됩니다.\n\n    매개변수:\n    budgets (List[int]): 진진의 월별 예산을 나타내는 12개의 정수 리스트.\n\n    반환:\n    int: 이자 후 연말에 진진이 가지게 될 총 금액.\n         진진이 어떤 달에 돈이 떨어지면, 그 달의 음수 값(-X, 여기서 X는 달 번호)을 반환합니다.\n\n    예제:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "ml": "    വർഷാവസാനത്തോടെ ജിൻജിൻ തന്റെ അമ്മയുമായി ചേർന്ന് പിന്തുടരുന്ന സമ്പാദ്യ പദ്ധതിയിലൂടെ എത്ര പണം ഉണ്ടാകും എന്ന് കണക്കാക്കുന്നു. \n    ഓരോ മാസവും, ചെലവുകൾക്ക് ശേഷം കുറഞ്ഞത് 100 യൂണിറ്റ് ശേഷിക്കുമെന്ന് പ്രവചിച്ചാൽ, അവൾക്ക് മാസവേതനത്തിൽ നിന്ന് (മാസത്തിൽ 300) 100ന്റെ ഗുണിതകങ്ങൾ \n    സമ്പാദിക്കാം. സംരക്ഷിച്ച പണത്തിന് വർഷാവസാനത്തിൽ 20% പലിശ ലഭിക്കും.\n\n    Parameters:\n    budgets (List[int]): ജിൻജിന്റെ മാസാന്ത ബജറ്റ് പ്രതിനിധീകരിക്കുന്ന 12 പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n\n    Returns:\n    int: പലിശയ്ക്കുശേഷം വർഷാവസാനത്തിൽ ജിൻജിന് ഉണ്ടാകുന്ന മൊത്തം പണം. \n         ഏതെങ്കിലും മാസത്തിൽ ജിൻജിന് പണം തീർന്നാൽ, ആ മാസത്തിന്റെ നെഗറ്റീവ് മൂല്യം (-X, X മാസ സംഖ്യയാണ്) തിരിച്ചുനൽകുന്നു.\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580", "fa": "    محاسبه مقدار کل پولی که جینجین تا پایان سال پس از پیروی از برنامه پس‌انداز خود با مادرش خواهد داشت.\n    هر ماه، او می‌تواند مضرب‌های ۱۰۰ از پول توجیبی خود (۳۰۰ در ماه) را پس‌انداز کند اگر پیش‌بینی کند که حداقل ۱۰۰ واحد پس از هزینه‌ها باقی خواهد ماند. پول پس‌انداز شده در پایان سال ۲۰٪ سود خواهد داشت.\n\n    پارامترها:\n    budgets (List[int]): لیستی از ۱۲ عدد صحیح که بودجه ماهانه جینجین را نشان می‌دهد.\n\n    بازگشت:\n    int: مقدار کل پولی که جینجین در پایان سال پس از سود خواهد داشت.\n         اگر جینجین در هر ماهی پولش تمام شود، مقدار منفی آن ماه را برمی‌گرداند (-X، که X شماره ماه است).\n\n    مثال‌ها:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580"}}
{"task_id": "Python/45", "prompt": {"en": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "sq": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Llogarit koston minimale totale për të bashkuar disa grumbuj frutash në një grumbull të vetëm.\n    Kostoja e bashkimit të dy grumbujve është e barabartë me shumën e peshave të tyre. Funksioni përdor\n    një algoritëm lakmitar me një grumbull minimal (radhë prioriteti) për të siguruar që grumbujt më të vegjël të bashkohen së pari,\n    duke minimizuar koston totale.\n\n    Parametrat:\n    fruit_counts (List[int]): Një listë e numrave të plotë që përfaqësojnë numrin e secilit lloj fruti.\n\n    Kthen:\n    int: Kostoja minimale totale e kërkuar për të bashkuar të gjithë grumbujt e frutave.\n\n    Shembuj:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "hy": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Հաշվում է մրգերի մի քանի կույտերը մեկ կույտի մեջ միացնելու նվազագույն ընդհանուր արժեքը:\n    Երկու կույտերի միացման արժեքը հավասար է դրանց քաշերի գումարին: Ֆունկցիան օգտագործում է\n    ագահ ալգորիթմ մին-կույտով (առաջնահերթության հերթ)՝ ապահովելու համար, որ ամենափոքր կույտերը\n    առաջինն են միացվում՝ նվազագույնի հասցնելով ընդհանուր արժեքը:\n\n    Պարամետրեր:\n    fruit_counts (List[int]): Ցուցակ, որը ներկայացնում է յուրաքանչյուր տեսակի մրգի քանակը:\n\n    Վերադարձնում է:\n    int: Մրգերի բոլոր կույտերը միացնելու համար պահանջվող նվազագույն ընդհանուր արժեքը:\n\n    Օրինակներ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "bn": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    একক হিপে একাধিক ফলের হিপ একত্রিত করার জন্য ন্যূনতম মোট খরচ গণনা করে।\n    দুটি হিপ একত্রিত করার খরচ তাদের ওজনের সমান। ফাংশনটি একটি লোভী অ্যালগরিদম ব্যবহার করে\n    একটি মিন-হিপ (অগ্রাধিকার কিউ) সহ নিশ্চিত করে যে ছোট হিপগুলি প্রথমে একত্রিত হয়,\n    মোট খরচ কমিয়ে দেয়।\n\n    প্যারামিটার:\n    fruit_counts (List[int]): প্রতিটি ধরণের ফলের গণনা উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: সমস্ত ফলের হিপ একত্রিত করার জন্য প্রয়োজনীয় ন্যূনতম মোট খরচ।\n\n    উদাহরণ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "bg": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Изчислява минималната обща цена за сливане на множество купчини плодове в една купчина.\n    Цената за сливане на две купчини е равна на сумата от техните тегла. Функцията използва\n    жаден алгоритъм с минимална купчина (приоритетна опашка), за да гарантира, че най-малките купчини се сливат първи,\n    минимизирайки общата цена.\n\n    Параметри:\n    fruit_counts (List[int]): Списък от цели числа, представляващи броя на всеки вид плод.\n\n    Връща:\n    int: Минималната обща цена, необходима за сливане на всички купчини плодове.\n\n    Примери:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "zh": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    计算将多个水果堆合并成一个堆的最小总成本。\n    合并两个堆的成本等于它们重量的总和。该函数利用带有最小堆（优先队列）的贪心算法，\n    以确保首先合并最小的堆，从而最小化总成本。\n\n    参数:\n    fruit_counts (List[int]): 一个整数列表，表示每种水果的数量。\n\n    返回:\n    int: 合并所有水果堆所需的最小总成本。\n\n    示例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "fr": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calcule le coût total minimum pour fusionner plusieurs tas de fruits en un seul tas.\n    Le coût de fusion de deux tas est égal à la somme de leurs poids. La fonction utilise\n    un algorithme glouton avec un tas min (file de priorité) pour s'assurer que les plus petits tas sont fusionnés en premier,\n    minimisant ainsi le coût total.\n\n    Paramètres:\n    fruit_counts (List[int]): Une liste d'entiers représentant le nombre de chaque type de fruit.\n\n    Retourne:\n    int: Le coût total minimum requis pour fusionner tous les tas de fruits.\n\n    Exemples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "de": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Berechnet die minimalen Gesamtkosten, um mehrere Haufen von Früchten zu einem einzigen Haufen zu verschmelzen.\n    Die Kosten für das Verschmelzen von zwei Haufen entsprechen der Summe ihrer Gewichte. Die Funktion verwendet\n    einen gierigen Algorithmus mit einem Min-Heap (Prioritätswarteschlange), um sicherzustellen, dass die kleinsten\n    Haufen zuerst verschmolzen werden, wodurch die Gesamtkosten minimiert werden.\n\n    Parameter:\n    fruit_counts (List[int]): Eine Liste von ganzen Zahlen, die die Anzahl der Früchte jeder Art darstellen.\n\n    Rückgabe:\n    int: Die minimalen Gesamtkosten, die erforderlich sind, um alle Haufen von Früchten zu verschmelzen.\n\n    Beispiele:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "ha": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Lissafa mafi ƙarancin jimillar kuɗi don haɗa ɗimbin 'ya'yan itatuwa zuwa taru guda.\n    Farashin haɗa taru biyu yana daidai da jimillar nauyinsu. Aikin yana amfani da\n    dabarar kwaikwayo tare da ƙaramin taru (layin fifiko) don tabbatar da cewa an haɗa ƙananan taru da farko,\n    yana rage jimillar kuɗi.\n\n    Sigogi:\n    fruit_counts (List[int]): Jerin lambobi da ke wakiltar adadin kowane nau'in 'ya'yan itace.\n\n    Returns:\n    int: Mafi ƙarancin jimillar kuɗi da ake buƙata don haɗa dukkan tarin 'ya'yan itatuwa.\n\n    Misalai:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "hi": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    कई ढेरों फलों को एक ही ढेर में मिलाने की न्यूनतम कुल लागत की गणना करता है।\n    दो ढेरों को मिलाने की लागत उनके भार के योग के बराबर होती है। यह फ़ंक्शन सुनिश्चित करने के लिए\n    एक लालची एल्गोरिदम के साथ एक मिन-हीप (प्राथमिकता कतार) का उपयोग करता है कि सबसे छोटे ढेर पहले मिलाए जाएं,\n    जिससे कुल लागत न्यूनतम हो।\n\n    पैरामीटर्स:\n    fruit_counts (List[int]): प्रत्येक प्रकार के फल की गिनती का प्रतिनिधित्व करने वाली पूर्णांकों की सूची।\n\n    रिटर्न्स:\n    int: सभी फलों के ढेरों को मिलाने के लिए आवश्यक न्यूनतम कुल लागत।\n\n    उदाहरण:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "hu": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Kiszámítja a minimális összköltséget több gyümölcshalom egyetlen halommá történő egyesítéséhez.\n    Két halom egyesítésének költsége egyenlő a súlyuk összegével. A függvény egy mohó algoritmust\n    használ egy min-halommal (prioritási sor), hogy biztosítsa a legkisebb halmok elsőként történő\n    egyesítését, minimalizálva az összköltséget.\n\n    Paraméterek:\n    fruit_counts (List[int]): Egész számokat tartalmazó lista, amely az egyes gyümölcstípusok számát jelöli.\n\n    Visszatér:\n    int: A minimális összköltség, amely szükséges az összes gyümölcshalom egyesítéséhez.\n\n    Példák:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "es": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calcula el costo total mínimo para fusionar múltiples montones de frutas en un solo montón.\n    El costo de fusionar dos montones es igual a la suma de sus pesos. La función utiliza\n    un algoritmo voraz con un montículo mínimo (cola de prioridad) para asegurar que los montones más pequeños se fusionen primero,\n    minimizando el costo total.\n\n    Parámetros:\n    fruit_counts (List[int]): Una lista de enteros que representa las cantidades de cada tipo de fruta.\n\n    Devuelve:\n    int: El costo total mínimo requerido para fusionar todos los montones de frutas.\n\n    Ejemplos:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "arb": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    يحسب الحد الأدنى للتكلفة الإجمالية لدمج أكوام متعددة من الفواكه في كومة واحدة.\n    تكلفة دمج كومتين تساوي مجموع أوزانهما. تستخدم الدالة خوارزمية جشعة مع كومة صغيرة (قائمة انتظار ذات أولوية)\n    لضمان دمج أصغر الأكوام أولاً، مما يقلل التكلفة الإجمالية.\n\n    المعاملات:\n    fruit_counts (List[int]): قائمة من الأعداد الصحيحة تمثل عدد كل نوع من الفاكهة.\n\n    العوائد:\n    int: الحد الأدنى للتكلفة الإجمالية المطلوبة لدمج جميع أكوام الفواكه.\n\n    أمثلة:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "sw": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Inakokotoa gharama ndogo kabisa ya jumla ya kuunganisha mirundo mingi ya matunda kuwa rundo moja.\n    Gharama ya kuunganisha mirundo miwili ni sawa na jumla ya uzito wao. Kazi hii inatumia\n    algorithimu ya pupa na rundo la chini (foleni ya kipaumbele) kuhakikisha mirundo midogo inaunganishwa kwanza,\n    kupunguza gharama ya jumla.\n\n    Vigezo:\n    fruit_counts (List[int]): Orodha ya nambari zinazowakilisha idadi ya kila aina ya matunda.\n\n    Inarejesha:\n    int: Gharama ndogo kabisa ya jumla inayohitajika kuunganisha mirundo yote ya matunda.\n\n    Mifano:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "tr": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Birden fazla meyve yığınını tek bir yığın halinde birleştirmek için gereken minimum toplam maliyeti hesaplar.\n    İki yığını birleştirmenin maliyeti, ağırlıklarının toplamına eşittir. Fonksiyon, en küçük yığınların önce birleştirilmesini\n    sağlamak ve toplam maliyeti en aza indirmek için min-heap (öncelik kuyruğu) ile bir açgözlü algoritma kullanır.\n\n    Parametreler:\n    fruit_counts (List[int]): Her tür meyvenin sayısını temsil eden bir tamsayı listesi.\n\n    Döndürür:\n    int: Tüm meyve yığınlarını birleştirmek için gereken minimum toplam maliyet.\n\n    Örnekler:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "vi": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Tính toán tổng chi phí tối thiểu để gộp nhiều đống trái cây thành một đống duy nhất.\n    Chi phí để gộp hai đống bằng tổng trọng lượng của chúng. Hàm này sử dụng\n    thuật toán tham lam với một heap nhỏ nhất (hàng đợi ưu tiên) để đảm bảo các đống nhỏ nhất được gộp trước,\n    giảm thiểu tổng chi phí.\n\n    Tham số:\n    fruit_counts (List[int]): Một danh sách các số nguyên đại diện cho số lượng của mỗi loại trái cây.\n\n    Trả về:\n    int: Tổng chi phí tối thiểu cần thiết để gộp tất cả các đống trái cây.\n\n    Ví dụ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "id": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Menghitung biaya total minimum untuk menggabungkan beberapa tumpukan buah menjadi satu tumpukan.\n    Biaya penggabungan dua tumpukan sama dengan jumlah beratnya. Fungsi ini menggunakan\n    algoritma greedy dengan min-heap (antrian prioritas) untuk memastikan tumpukan terkecil digabungkan terlebih dahulu,\n    meminimalkan total biaya.\n\n    Parameter:\n    fruit_counts (List[int]): Daftar bilangan bulat yang mewakili jumlah setiap jenis buah.\n\n    Mengembalikan:\n    int: Biaya total minimum yang diperlukan untuk menggabungkan semua tumpukan buah.\n\n    Contoh:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "ja": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    複数の果物の山を1つの山にまとめるための最小の総コストを計算します。\n    2つの山を合併するコストは、それらの重さの合計に等しいです。この関数は、\n    最小ヒープ（優先度付きキュー）を使用した貪欲アルゴリズムを利用して、\n    最小の山を最初に合併し、総コストを最小化します。\n\n    パラメータ:\n    fruit_counts (List[int]): 各種類の果物の数を表す整数のリスト。\n\n    戻り値:\n    int: すべての果物の山を合併するために必要な最小の総コスト。\n\n    例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "ko": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    여러 더미의 과일을 하나의 더미로 병합하는 데 필요한 최소 총 비용을 계산합니다.\n    두 더미를 병합하는 비용은 그들의 무게 합과 같습니다. 이 함수는\n    가장 작은 더미가 먼저 병합되도록 보장하는 최소 힙(우선순위 큐)을 사용한\n    탐욕 알고리즘을 활용하여 총 비용을 최소화합니다.\n\n    매개변수:\n    fruit_counts (List[int]): 각 종류의 과일 개수를 나타내는 정수 리스트.\n\n    반환값:\n    int: 모든 과일 더미를 병합하는 데 필요한 최소 총 비용.\n\n    예시:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "ml": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    പല ഹീപുകളിലായി ഉള്ള പഴങ്ങൾ ഒറ്റ ഹീപാക്കി ലയിപ്പിക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ് കണക്കാക്കുന്നു.\n    രണ്ട് ഹീപുകൾ ലയിപ്പിക്കുന്നതിനുള്ള ചെലവ് അവയുടെ ഭാരങ്ങളുടെ മൊത്തം തുല്യമാണ്. \n    ഏറ്റവും ചെറിയ ഹീപുകൾ ആദ്യം ലയിപ്പിക്കപ്പെടുന്നുവെന്ന് ഉറപ്പാക്കാൻ മിൻ-ഹീപ് (പ്രാധാന്യ ക്യൂ) ഉപയോഗിച്ച് ഒരു ഗ്രീഡി ആൾഗൊരിതം ഉപയോഗിക്കുന്നു,\n    മൊത്തം ചെലവ് കുറയ്ക്കുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    fruit_counts (List[int]): ഓരോ തരം പഴത്തിന്റെയും എണ്ണത്തെ പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n\n    തിരികെ നൽകുന്നു:\n    int: എല്ലാ പഴങ്ങളുടെ ഹീപുകളും ലയിപ്പിക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ്.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"", "fa": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    حداقل هزینه کل برای ادغام چندین توده میوه به یک توده واحد را محاسبه می‌کند.\n    هزینه ادغام دو توده برابر با مجموع وزن‌های آن‌ها است. این تابع از یک الگوریتم حریصانه\n    با یک توده کمینه (صف اولویت) استفاده می‌کند تا اطمینان حاصل شود که کوچک‌ترین توده‌ها\n    ابتدا ادغام می‌شوند و هزینه کل به حداقل می‌رسد.\n\n    پارامترها:\n    fruit_counts (List[int]): لیستی از اعداد صحیح که تعداد هر نوع میوه را نشان می‌دهد.\n\n    بازگشت:\n    int: حداقل هزینه کل مورد نیاز برای ادغام تمام توده‌های میوه.\n\n    مثال‌ها:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\""}, "canonical_solution": "    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost", "instruction": {"en": "Write a python function 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' to solve the following problem:\n\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    ", "sq": "Shkruani një funksion python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit koston minimale totale për të bashkuar disa grumbuj frutash në një grumbull të vetëm.\n    Kostoja e bashkimit të dy grumbujve është e barabartë me shumën e peshave të tyre. Funksioni përdor\n    një algoritëm lakmitar me një grumbull minimal (radhë me përparësi) për të siguruar që grumbujt më të vegjël të bashkohen të parët,\n    duke minimizuar koston totale.\n\n    Parametrat:\n    fruit_counts (List[int]): Një listë e numrave të plotë që përfaqësojnë numrin e secilit lloj fruti.\n\n    Kthen:\n    int: Kostoja minimale totale e kërkuar për të bashkuar të gjithë grumbujt e frutave.\n\n    Shembuj:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "hy": "Պայթոն ֆունկցիա 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվում է մրգերի բազմաթիվ կույտերը մեկ կույտի մեջ միացնելու նվազագույն ընդհանուր արժեքը:\n    Երկու կույտերի միացման արժեքը հավասար է նրանց քաշերի գումարին: Ֆունկցիան օգտագործում է\n    ագահ ալգորիթմ մին-կույտով (առաջնահերթության հերթ)՝ ապահովելու համար, որ ամենափոքր կույտերը\n    առաջինը միացվեն՝ նվազեցնելով ընդհանուր արժեքը:\n\n    Պարամետրեր:\n    fruit_counts (List[int]): Թվերի ցուցակ, որը ներկայացնում է յուրաքանչյուր տեսակի մրգերի քանակները:\n\n    Վերադարձնում է:\n    int: Մրգերի բոլոր կույտերը միացնելու համար պահանջվող նվազագույն ընդհանուր արժեքը:\n\n    Օրինակներ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "bn": "একটি পাইথন ফাংশন 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    একাধিক ফলের স্তূপকে একক স্তূপে একত্রিত করার জন্য সর্বনিম্ন মোট খরচ গণনা করে।\n    দুটি স্তূপ একত্রিত করার খরচ তাদের ওজনের সমান। ফাংশনটি একটি লোভী অ্যালগরিদম ব্যবহার করে\n    একটি মিন-হীপ (প্রায়োরিটি কিউ) সহ নিশ্চিত করে যে ছোট স্তূপগুলি প্রথমে একত্রিত হয়,\n    মোট খরচ কমায়।\n\n    প্যারামিটার:\n    fruit_counts (List[int]): প্রতিটি ধরণের ফলের গণনা উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: সমস্ত ফলের স্তূপ একত্রিত করার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ।\n\n    উদাহরণ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "bg": "Напишете Python функция 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:', за да решите следния проблем:\n\n    Изчислява минималната обща цена за обединяване на множество купчини плодове в една единствена купчина.\n    Цената за обединяване на две купчини е равна на сумата от техните тегла. Функцията използва\n    алчен алгоритъм с мин-купа (приоритетна опашка), за да гарантира, че най-малките купчини се обединяват първи,\n    минимизирайки общата цена.\n\n    Параметри:\n    fruit_counts (List[int]): Списък от цели числа, представляващи броя на всеки вид плодове.\n\n    Връща:\n    int: Минималната обща цена, необходима за обединяване на всички купчини плодове.\n\n    Примери:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "zh": "编写一个 Python 函数 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' 来解决以下问题：\n\n    计算将多个水果堆合并成一个堆的最小总成本。\n    合并两个堆的成本等于它们重量的总和。该函数利用\n    带有最小堆（优先队列）的贪心算法来确保首先合并最小的堆，\n    从而最小化总成本。\n\n    参数:\n    fruit_counts (List[int]): 一个整数列表，表示每种水果的数量。\n\n    返回:\n    int: 合并所有水果堆所需的最小总成本。\n\n    示例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300", "fr": "Écrivez une fonction python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' pour résoudre le problème suivant :\n\n    Calcule le coût total minimum pour fusionner plusieurs tas de fruits en un seul tas.\n    Le coût de fusion de deux tas est égal à la somme de leurs poids. La fonction utilise\n    un algorithme glouton avec un tas minimum (file de priorité) pour s'assurer que les plus petits tas sont fusionnés en premier,\n    minimisant ainsi le coût total.\n\n    Paramètres:\n    fruit_counts (List[int]): Une liste d'entiers représentant le nombre de chaque type de fruit.\n\n    Renvoie:\n    int: Le coût total minimum nécessaire pour fusionner tous les tas de fruits.\n\n    Exemples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "de": "Schreiben Sie eine Python-Funktion 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnet die minimalen Gesamtkosten, um mehrere Haufen von Früchten zu einem einzigen Haufen zu verschmelzen.\n    Die Kosten für das Verschmelzen von zwei Haufen entsprechen der Summe ihrer Gewichte. Die Funktion verwendet\n    einen gierigen Algorithmus mit einem Min-Heap (Prioritätswarteschlange), um sicherzustellen, dass die kleinsten Haufen zuerst verschmolzen werden,\n    wodurch die Gesamtkosten minimiert werden.\n\n    Parameter:\n    fruit_counts (List[int]): Eine Liste von ganzen Zahlen, die die Anzahl jeder Fruchtart darstellen.\n\n    Rückgabewert:\n    int: Die minimalen Gesamtkosten, die erforderlich sind, um alle Fruchthaufen zu verschmelzen.\n\n    Beispiele:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "ha": "Rubuta wani aikin python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafi mafi ƙarancin jimlar kuɗi don haɗa tarin 'ya'yan itatuwa masu yawa zuwa tarin guda.\n    Farashin haɗa tarin biyu yayi daidai da jimlar nauyinsu. Aikin yana amfani\n    da dabarar kwaikwayo tare da ƙaramin tarin (priority queue) don tabbatar da cewa an haɗa ƙananan tarin farko,\n    rage jimlar kuɗi.\n\n    Sigogi:\n    fruit_counts (List[int]): Jerin lambobi da ke wakiltar adadin kowane nau'in 'ya'yan itace.\n\n    Yana dawowa:\n    int: Mafi ƙarancin jimlar kuɗi da ake buƙata don haɗa dukkan tarin 'ya'yan itatuwa.\n\n    Misalai:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "hi": "एक पायथन फ़ंक्शन 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    फलों के कई ढेरों को एक ही ढेर में मिलाने की न्यूनतम कुल लागत की गणना करें।\n    दो ढेरों को मिलाने की लागत उनके भार के योग के बराबर होती है। फ़ंक्शन एक लालची एल्गोरिदम का उपयोग करता है\n    जिसमें एक मिन-हीप (प्राथमिकता कतार) होती है ताकि यह सुनिश्चित किया जा सके कि सबसे छोटे ढेर पहले मिलाए जाएं,\n    जिससे कुल लागत कम से कम हो।\n\n    पैरामीटर्स:\n    fruit_counts (List[int]): प्रत्येक प्रकार के फल की गिनती का प्रतिनिधित्व करने वाली पूर्णांकों की एक सूची।\n\n    लौटाता है:\n    int: सभी फलों के ढेरों को मिलाने के लिए आवश्यक न्यूनतम कुल लागत।\n\n    उदाहरण:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "hu": "Írj egy python függvényt 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' a következő probléma megoldására:\n\n    Kiszámítja a minimális összköltséget, hogy több gyümölcs halmot egyetlen halommá egyesítsen.\n    Két halom egyesítésének költsége egyenlő a súlyuk összegével. A függvény egy mohó algoritmust\n    használ egy min-halommal (prioritási sor), hogy biztosítsa, hogy a legkisebb halmok kerüljenek először egyesítésre,\n    minimalizálva az összköltséget.\n\n    Paraméterek:\n    fruit_counts (List[int]): Egész számok listája, amely az egyes gyümölcsfajták számát képviseli.\n\n    Visszatér:\n    int: A minimális összköltség, amely szükséges az összes gyümölcshalom egyesítéséhez.\n\n    Példák:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "es": "Escribe una función de Python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' para resolver el siguiente problema:\n\nCalcula el costo total mínimo para fusionar múltiples montones de frutas en un solo montón. El costo de fusionar dos montones es igual a la suma de sus pesos. La función utiliza un algoritmo voraz con un montículo mínimo (cola de prioridad) para asegurar que los montones más pequeños se fusionen primero, minimizando el costo total.\n\nParámetros:\nfruit_counts (List[int]): Una lista de enteros que representa las cantidades de cada tipo de fruta.\n\nDevuelve:\nint: El costo total mínimo requerido para fusionar todos los montones de frutas.\n\nEjemplos:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 .", "arb": "اكتب دالة بايثون 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' لحل المشكلة التالية:\n\n    تحسب التكلفة الإجمالية الدنيا لدمج أكوام متعددة من الفواكه في كومة واحدة.\n    تكلفة دمج كومتين تساوي مجموع أوزانهما. تستخدم الدالة\n    خوارزمية جشعة مع كومة ذات أولوية (قائمة انتظار ذات أولوية) لضمان دمج الأصغر أولاً،\n    مما يقلل التكلفة الإجمالية.\n\n    المعاملات:\n    fruit_counts (List[int]): قائمة من الأعداد الصحيحة تمثل عدد كل نوع من الفاكهة.\n\n    العوائد:\n    int: التكلفة الإجمالية الدنيا المطلوبة لدمج جميع أكوام الفواكه.\n\n    أمثلة:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "sw": "Andika kazi ya python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' kutatua tatizo lifuatalo:\n\n    Inakokotoa gharama ndogo kabisa ya jumla ya kuunganisha marundo mengi ya matunda kuwa rundo moja.\n    Gharama ya kuunganisha marundo mawili ni sawa na jumla ya uzito wao. Kazi hii inatumia\n    algoriti ya pupa na min-heap (foleni ya kipaumbele) kuhakikisha marundo madogo yanaunganishwa kwanza,\n    kupunguza gharama ya jumla.\n\n    Vigezo:\n    fruit_counts (List[int]): Orodha ya namba zinazoashiria idadi ya kila aina ya tunda.\n\n    Inarudisha:\n    int: Gharama ndogo kabisa ya jumla inayohitajika kuunganisha marundo yote ya matunda.\n\n    Mifano:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "tr": "Bir python fonksiyonu 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Birden fazla meyve yığınını tek bir yığın halinde birleştirmek için minimum toplam maliyeti hesaplar.\n    İki yığını birleştirmenin maliyeti, ağırlıklarının toplamına eşittir. Fonksiyon, toplam maliyeti\n    en aza indirmek için en küçük yığınların önce birleştirildiğinden emin olmak amacıyla bir min-heap\n    (öncelik kuyruğu) ile açgözlü bir algoritma kullanır.\n\n    Parametreler:\n    fruit_counts (List[int]): Her bir meyve türünün sayısını temsil eden bir tamsayı listesi.\n\n    Döndürür:\n    int: Tüm meyve yığınlarını birleştirmek için gereken minimum toplam maliyet.\n\n    Örnekler:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "vi": "Viết một hàm python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán tổng chi phí tối thiểu để gộp nhiều đống trái cây thành một đống duy nhất.\n    Chi phí gộp hai đống bằng tổng trọng lượng của chúng. Hàm sử dụng\n    một thuật toán tham lam với một đống ưu tiên (hàng đợi ưu tiên) để đảm bảo các đống nhỏ nhất được gộp trước,\n    giảm thiểu tổng chi phí.\n\n    Tham số:\n    fruit_counts (List[int]): Một danh sách các số nguyên đại diện cho số lượng của mỗi loại trái cây.\n\n    Trả về:\n    int: Tổng chi phí tối thiểu cần thiết để gộp tất cả các đống trái cây.\n\n    Ví dụ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "id": "Tulis sebuah fungsi python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' untuk menyelesaikan masalah berikut:\n\n    Menghitung biaya total minimum untuk menggabungkan beberapa tumpukan buah menjadi satu tumpukan.\n    Biaya penggabungan dua tumpukan sama dengan jumlah beratnya. Fungsi ini menggunakan\n    algoritma greedy dengan min-heap (priority queue) untuk memastikan tumpukan terkecil digabungkan terlebih dahulu,\n    meminimalkan total biaya.\n\n    Parameter:\n    fruit_counts (List[int]): Sebuah daftar integer yang mewakili jumlah setiap jenis buah.\n\n    Mengembalikan:\n    int: Biaya total minimum yang diperlukan untuk menggabungkan semua tumpukan buah.\n\n    Contoh:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "ja": "以下の問題を解決するために、Python関数 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' を作成してください。\n\n    複数の果物の山を1つの山に統合するための最小の総コストを計算します。\n    2つの山を統合するコストは、それらの重さの合計に等しいです。関数は、\n    貪欲アルゴリズムと最小ヒープ（優先度キュー）を使用して、最小の山が最初に統合されるようにし、\n    総コストを最小限に抑えます。\n\n    パラメータ:\n    fruit_counts (List[int]): 各種類の果物の数を表す整数のリスト。\n\n    戻り値:\n    int: すべての果物の山を統合するために必要な最小の総コスト。\n\n    例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300", "ko": "파이썬 함수를 작성하세요 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' 다음 문제를 해결하기 위해:\n\n    여러 더미의 과일을 하나의 더미로 합치는 데 필요한 최소 총 비용을 계산합니다.\n    두 더미를 합치는 비용은 그들의 무게의 합과 같습니다. 이 함수는\n    최소 힙(우선순위 큐)을 사용한 탐욕 알고리즘을 활용하여 가장 작은 더미가 먼저 합쳐지도록 하여\n    총 비용을 최소화합니다.\n\n    매개변수:\n    fruit_counts (List[int]): 각 종류의 과일 개수를 나타내는 정수 리스트입니다.\n\n    반환값:\n    int: 모든 과일 더미를 합치는 데 필요한 최소 총 비용입니다.\n\n    예제:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "ml": "'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ നൽകിയിരിക്കുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    പല കൂമ്പാരങ്ങളിലായുള്ള പഴങ്ങൾ ഒരു കൂമ്പാരമാക്കി ലയിപ്പിക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ് കണക്കാക്കുന്നു.\n    രണ്ട് കൂമ്പാരങ്ങൾ ലയിപ്പിക്കുന്നതിനുള്ള ചെലവ് അവയുടെ ഭാരങ്ങളുടെ മൊത്തം തുല്യമാണ്. \n    ഫംഗ്ഷൻ ഒരു ഗ്രീഡി ആൽഗൊരിതം ഒരു മിൻ-ഹീപ് (പ്രാഥമിക ക്യൂ) ഉപയോഗിച്ച് ഉറപ്പാക്കുന്നു \n    ചെറുതായ കൂമ്പാരങ്ങൾ ആദ്യം ലയിപ്പിക്കപ്പെടുന്നു, മൊത്തം ചെലവ് കുറയ്ക്കുന്നു.\n\n    പാരാമീറ്ററുകൾ:\n    fruit_counts (List[int]): ഓരോ തരം പഴത്തിന്റെയും എണ്ണത്തെ പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ ഒരു ലിസ്റ്റ്.\n\n    റിട്ടേൺസ്:\n    int: എല്ലാ കൂമ്പാരങ്ങളിലെയും പഴങ്ങൾ ലയിപ്പിക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ്.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "fa": "یک تابع پایتون بنویسید 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' برای حل مسئله زیر:\n\n    حداقل هزینه کل را برای ادغام چندین توده میوه به یک توده محاسبه می‌کند.\n    هزینه ادغام دو توده برابر با مجموع وزن‌های آن‌ها است. تابع از یک الگوریتم حریصانه با یک مین-هیپ (صف اولویت) استفاده می‌کند\n    تا اطمینان حاصل کند که کوچکترین توده‌ها ابتدا ادغام می‌شوند و هزینه کل به حداقل می‌رسد.\n\n    پارامترها:\n    fruit_counts (List[int]): لیستی از اعداد صحیح که تعداد هر نوع میوه را نشان می‌دهد.\n\n    بازگشت:\n    int: حداقل هزینه کل مورد نیاز برای ادغام تمام توده‌های میوه.\n\n    مثال‌ها:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 ."}, "level": "middle", "test": "def test_minimum_cost_to_merge_fruits():\n    # Test case 1: As provided in the problem statement example\n    fruits1 = [1, 2, 9]\n    assert minimum_cost_to_merge_fruits(fruits1) == 15, \"Test case 1 failed\"\n\n    # Test case 2: Simple case with only two types of fruits\n    fruits2 = [5, 5]\n    assert minimum_cost_to_merge_fruits(fruits2) == 10, \"Test case 2 failed\"\n\n    # Test case 3: More complex case with multiple types of fruits\n    fruits3 = [10, 20, 30, 40, 50]\n    assert minimum_cost_to_merge_fruits(fruits3) == 330, \"Test case 3 failed\"\n\n    # Test case 4: Case with fruits having the same count\n    fruits4 = [3, 3, 3, 3]\n    assert minimum_cost_to_merge_fruits(fruits4) == 24, \"Test case 4 failed\"\n\n    # Test case 5: Case with a single type of fruit\n    fruits5 = [7]\n    assert minimum_cost_to_merge_fruits(fruits5) == 0, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_minimum_cost_to_merge_fruits()", "entry_point": "minimum_cost_to_merge_fruits", "signature": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:", "docstring": {"en": "\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    ", "sq": "\n    Llogarit koston minimale totale për të bashkuar disa grumbuj frutash në një grumbull të vetëm.\n    Kostoja e bashkimit të dy grumbujve është e barabartë me shumën e peshave të tyre. Funksioni përdor\n    një algoritëm lakmitar me një grumbull minimal (radhë përparësie) për të siguruar që grumbujt më të vegjël të bashkohen të parët,\n    duke minimizuar koston totale.\n\n    Parametrat:\n    fruit_counts (List[int]): Një listë e numrave të plotë që përfaqësojnë numrat e secilit lloj fruti.\n\n    Kthen:\n    int: Kostoja minimale totale e nevojshme për të bashkuar të gjithë grumbujt e frutave.\n\n    Shembuj:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "hy": "\n    Հաշվում է մի քանի պտուղների կույտերը մեկ կույտի մեջ միավորելու նվազագույն ընդհանուր արժեքը:\n    Երկու կույտերի միավորման արժեքը հավասար է նրանց քաշերի գումարին: Ֆունկցիան օգտագործում է ագահ ալգորիթմ \n    մին-կույտով (նախապատվության հերթ)՝ ապահովելու համար, որ ամենափոքր կույտերը առաջինը միավորվեն՝ \n    նվազագույնի հասցնելով ընդհանուր արժեքը:\n\n    Պարամետրեր:\n    fruit_counts (List[int]): Ցուցակ, որը ներկայացնում է յուրաքանչյուր տեսակի պտղի քանակները:\n\n    Վերադարձնում է:\n    int: Նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր պտուղների կույտերը միավորելու համար:\n\n    Օրինակներ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "bn": "\n    একক হীপে একাধিক ফলের হীপ একত্রিত করার জন্য ন্যূনতম মোট খরচ গণনা করে।\n    দুটি হীপ একত্রিত করার খরচ তাদের ওজনের সমান। ফাংশনটি একটি লোভী অ্যালগরিদম ব্যবহার করে\n    একটি মিন-হীপ (অগ্রাধিকার সারি) সহ, যাতে ছোট হীপগুলি প্রথমে একত্রিত হয়,\n    মোট খরচ কমানো যায়।\n\n    প্যারামিটারসমূহ:\n    fruit_counts (List[int]): প্রতিটি প্রকারের ফলের সংখ্যা উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: সমস্ত ফলের হীপ একত্রিত করার জন্য প্রয়োজনীয় ন্যূনতম মোট খরচ।\n\n    উদাহরণ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "bg": "\n    Изчислява минималната обща цена за сливане на множество купчини плодове в една купчина.\n    Цената за сливане на две купчини е равна на сумата от техните тегла. Функцията използва\n    жаден алгоритъм с мин-купа (приоритетна опашка), за да гарантира, че най-малките купчини се сливат първи,\n    минимизирайки общата цена.\n\n    Параметри:\n    fruit_counts (List[int]): Списък от цели числа, представляващи броя на всеки вид плодове.\n\n    Връща:\n    int: Минималната обща цена, необходима за сливане на всички купчини плодове.\n\n    Примери:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "zh": "\n    计算将多个水果堆合并成一个堆的最小总成本。\n    合并两个堆的成本等于它们重量的总和。该函数利用贪心算法和最小堆（优先队列）来确保首先合并最小的堆，从而最小化总成本。\n\n    参数:\n    fruit_counts (List[int]): 一个整数列表，表示每种水果的数量。\n\n    返回:\n    int: 合并所有水果堆所需的最小总成本。\n\n    示例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "fr": "\n    Calcule le coût total minimum pour fusionner plusieurs tas de fruits en un seul tas.\n    Le coût de fusion de deux tas est égal à la somme de leurs poids. La fonction utilise\n    un algorithme glouton avec un tas min (file de priorité) pour s'assurer que les plus petits tas sont fusionnés en premier,\n    minimisant ainsi le coût total.\n\n    Paramètres:\n    fruit_counts (List[int]): Une liste d'entiers représentant le nombre de chaque type de fruit.\n\n    Retourne:\n    int: Le coût total minimum nécessaire pour fusionner tous les tas de fruits.\n\n    Exemples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "de": "\n    Berechnet die minimalen Gesamtkosten, um mehrere Haufen von Früchten zu einem einzigen Haufen zu verschmelzen.\n    Die Kosten für das Verschmelzen von zwei Haufen entsprechen der Summe ihrer Gewichte. Die Funktion verwendet\n    einen gierigen Algorithmus mit einem Min-Heap (Prioritätswarteschlange), um sicherzustellen, dass die kleinsten Haufen zuerst verschmolzen werden,\n    wodurch die Gesamtkosten minimiert werden.\n\n    Parameter:\n    fruit_counts (List[int]): Eine Liste von ganzen Zahlen, die die Anzahl jeder Fruchtart darstellen.\n\n    Rückgabe:\n    int: Die minimalen Gesamtkosten, die erforderlich sind, um alle Haufen von Früchten zu verschmelzen.\n\n    Beispiele:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "ha": "\n    Lissafa mafi ƙarancin jimillar kuɗi don haɗa tarin 'ya'yan itatuwa masu yawa zuwa tarin guda.\n    Farashin haɗa tarin biyu yana daidai da jimillar nauyinsu. Aikin yana amfani da\n    dabarar kwaikwayo tare da ƙaramin tarin (min-heap) don tabbatar da cewa an fara haɗa ƙananan tarin,\n    yana rage jimillar kuɗi.\n\n    Sigogi:\n    fruit_counts (List[int]): Jerin lambobi da ke wakiltar adadin kowane nau'in 'ya'yan itace.\n\n    Returns:\n    int: Mafi ƙarancin jimillar kuɗi da ake buƙata don haɗa dukkan tarin 'ya'yan itatuwa.\n\n    Misalai:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "hi": "\n    कई ढेरों फलों को एक ही ढेर में मिलाने की न्यूनतम कुल लागत की गणना करता है।\n    दो ढेरों को मिलाने की लागत उनके भार के योग के बराबर होती है। यह फ़ंक्शन\n    एक लालची एल्गोरिदम का उपयोग करता है जिसमें सबसे छोटे ढेर पहले मिलाए जाते हैं,\n    जिससे कुल लागत न्यूनतम हो जाती है।\n\n    पैरामीटर्स:\n    fruit_counts (List[int]): प्रत्येक प्रकार के फल की गिनती को दर्शाने वाली पूर्णांकों की सूची।\n\n    रिटर्न्स:\n    int: सभी फलों के ढेरों को मिलाने के लिए आवश्यक न्यूनतम कुल लागत।\n\n    उदाहरण:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "hu": "\n    Kiszámítja a minimális összköltséget több gyümölcshalom egyetlen halommá való egyesítéséhez.\n    Két halom egyesítésének költsége megegyezik a súlyuk összegével. A függvény egy mohó algoritmust\n    használ egy min-halommal (prioritási sor) annak biztosítására, hogy a legkisebb halmokat egyesítik először,\n    minimalizálva az összköltséget.\n\n    Paraméterek:\n    fruit_counts (List[int]): Egész számokat tartalmazó lista, amely a gyümölcsök típusonkénti mennyiségét jelöli.\n\n    Visszatér:\n    int: A minimális összköltség, amely szükséges az összes gyümölcshalom egyesítéséhez.\n\n    Példák:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "es": "Calcula el costo total mínimo para fusionar múltiples montones de frutas en un solo montón. El costo de fusionar dos montones es igual a la suma de sus pesos. La función utiliza un algoritmo voraz con un montículo mínimo (cola de prioridad) para asegurar que los montones más pequeños se fusionen primero, minimizando el costo total.\n\nParámetros:\nfruit_counts (List[int]): Una lista de enteros que representa las cantidades de cada tipo de fruta.\n\nDevuelve:\nint: El costo total mínimo requerido para fusionar todos los montones de frutas.\n\nEjemplos:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 .", "arb": "    يحسب الحد الأدنى للتكلفة الإجمالية لدمج أكوام متعددة من الفواكه في كومة واحدة.\n    تكلفة دمج كومتين تساوي مجموع أوزانهما. تستخدم الدالة\n    خوارزمية جشعة مع كومة صغيرة (قائمة انتظار ذات أولوية) لضمان دمج أصغر الأكوام أولاً،\n    مما يقلل من التكلفة الإجمالية.\n\n    Parameters:\n    fruit_counts (List[int]): قائمة من الأعداد الصحيحة التي تمثل عدد كل نوع من الفاكهة.\n\n    يعيد:\n    int: الحد الأدنى للتكلفة الإجمالية المطلوبة لدمج جميع أكوام الفواكه.\n\n    امثله:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "sw": "Inakokotoa gharama ndogo kabisa ya jumla ya kuunganisha marundo mengi ya matunda kuwa rundo moja. \nGharama ya kuunganisha marundo mawili ni sawa na jumla ya uzito wao. Kazi hii inatumia \nalgoriti ya pupa na min-heap (foleni ya kipaumbele) kuhakikisha marundo madogo yanaunganishwa kwanza, \nikidhibiti gharama ya jumla.\n\nVigezo:\nfruit_counts (List[int]): Orodha ya namba inayoonyesha idadi ya kila aina ya tunda.\n\nInarejesha:\nint: Gharama ndogo kabisa ya jumla inayohitajika kuunganisha marundo yote ya matunda.\n\nMifano:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 .", "tr": "    Birden fazla meyve yığınını tek bir yığında birleştirmek için minimum toplam maliyeti hesaplar.\n    İki yığını birleştirmenin maliyeti, ağırlıklarının toplamına eşittir. Fonksiyon, toplam maliyeti\n    en aza indirmek için en küçük yığınların önce birleştirilmesini sağlayan bir min-yığın (öncelik kuyruğu)\n    ile açgözlü bir algoritma kullanır.\n\n    Parametreler:\n    fruit_counts (List[int]): Her tür meyvenin sayısını temsil eden bir tamsayı listesi.\n\n    Döndürür:\n    int: Tüm meyve yığınlarını birleştirmek için gereken minimum toplam maliyet.\n\n    Örnekler:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "vi": "    Tính toán tổng chi phí tối thiểu để gộp nhiều đống trái cây thành một đống duy nhất.\n    Chi phí gộp hai đống bằng tổng trọng lượng của chúng. Hàm sử dụng\n    một thuật toán tham lam với một min-heap (hàng đợi ưu tiên) để đảm bảo các đống nhỏ nhất được gộp trước,\n    giảm thiểu tổng chi phí.\n\n    Tham số:\n    fruit_counts (List[int]): Một danh sách các số nguyên đại diện cho số lượng của mỗi loại trái cây.\n\n    Trả về:\n    int: Tổng chi phí tối thiểu cần thiết để gộp tất cả các đống trái cây.\n\n    Ví dụ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "id": "Menghitung biaya total minimum untuk menggabungkan beberapa tumpukan buah menjadi satu tumpukan. Biaya penggabungan dua tumpukan sama dengan jumlah beratnya. Fungsi ini menggunakan algoritma greedy dengan min-heap (antrian prioritas) untuk memastikan tumpukan terkecil digabungkan terlebih dahulu, meminimalkan biaya total.\n\nParameter:\nfruit_counts (List[int]): Daftar bilangan bulat yang mewakili jumlah setiap jenis buah.\n\nMengembalikan:\nint: Biaya total minimum yang diperlukan untuk menggabungkan semua tumpukan buah.\n\nContoh:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 .", "ja": "    複数の果物の山を1つの山に統合するための最小総コストを計算します。\n    2つの山を統合するコストは、それらの重さの合計に等しいです。この関数は、\n    最小ヒープ（優先度キュー）を使用した貪欲アルゴリズムを利用して、最小の山が最初に統合されるようにし、\n    総コストを最小化します。\n\n    パラメータ:\n    fruit_counts (List[int]): 各種類の果物の数を表す整数のリスト。\n\n    戻り値:\n    int: すべての果物の山を統合するために必要な最小総コスト。\n\n    例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "ko": "    여러 과일 더미를 하나의 더미로 합치는 데 필요한 최소 총 비용을 계산합니다.\n    두 더미를 합치는 비용은 그들의 무게의 합과 같습니다. 이 함수는\n    가장 작은 더미가 먼저 합쳐지도록 보장하는 최소 힙(우선순위 큐)을 사용한\n    탐욕 알고리즘을 활용하여 총 비용을 최소화합니다.\n\n    Parameters:\n    fruit_counts (List[int]): 각 과일 유형의 개수를 나타내는 정수 리스트입니다.\n\n    Returns:\n    int: 모든 과일 더미를 합치는 데 필요한 최소 총 비용입니다.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "ml": "    പല ഫലങ്ങളുടെ കൂമ്പാരങ്ങളെ ഒരു കൂമ്പാരമാക്കി ലയിപ്പിക്കുന്നതിനുള്ള കുറഞ്ഞ മൊത്തം ചെലവ് കണക്കാക്കുന്നു.\n    രണ്ട് കൂമ്പാരങ്ങളെ ലയിപ്പിക്കുന്നതിനുള്ള ചെലവ് അവയുടെ ഭാരങ്ങളുടെ തുല്യമാണ്. \n    മൊത്തം ചെലവ് കുറയ്ക്കുന്നതിനായി ഏറ്റവും ചെറിയ കൂമ്പാരങ്ങൾ ആദ്യം ലയിപ്പിക്കപ്പെടുന്നുവെന്ന് ഉറപ്പാക്കാൻ \n    ഈ ഫംഗ്ഷൻ ഒരു മിൻ-ഹീപ്പ് (പ്രാഥമിക ക്യൂ) ഉപയോഗിക്കുന്ന ഒരു ലോഭിയായ ആൽഗോരിതം ഉപയോഗിക്കുന്നു.\n\n    Parameters:\n    fruit_counts (List[int]): ഓരോ തരം ഫലത്തിന്റെയും എണ്ണങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n\n    Returns:\n    int: എല്ലാ ഫലങ്ങളുടെ കൂമ്പാരങ്ങളും ലയിപ്പിക്കാൻ ആവശ്യമായ കുറഞ്ഞ മൊത്തം ചെലവ്.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .", "fa": "    حداقل هزینه کل برای ادغام چندین توده میوه به یک توده را محاسبه می‌کند.\n    هزینه ادغام دو توده برابر با مجموع وزن‌های آن‌ها است. این تابع از یک الگوریتم حریصانه\n    با یک توده کوچک (صف اولویت) استفاده می‌کند تا اطمینان حاصل شود که کوچکترین توده‌ها\n    ابتدا ادغام می‌شوند و هزینه کل به حداقل می‌رسد.\n\n    پارامترها:\n    fruit_counts (List[int]): یک لیست از اعداد صحیح که تعداد هر نوع میوه را نشان می‌دهد.\n\n    بازگشت:\n    int: حداقل هزینه کل مورد نیاز برای ادغام تمام توده‌های میوه.\n\n    مثال‌ها:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 ."}}
{"task_id": "Python/46", "prompt": {"en": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    \"\"\"", "sq": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Llogarit numrin minimal të studentëve që duhet të largohen për të formuar një formacion kori.\n    Një formacion kori përcaktohet në mënyrë të tillë që për një pozicion 'i', lartësitë e studentëve\n    rriten nga fillimi deri te 'i' dhe ulen nga 'i' deri në fund të formacionit.\n\n    Args:\n    heights (List[int]): Një listë e lartësive të studentëve.\n\n    Returns:\n    int: Numri minimal i studentëve që duhet të largohen.\n    \"\"\"", "hy": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Հաշվել նվազագույն թվով ուսանողներին, որոնք պետք է հեռանան երգչախմբի կազմ ձևավորելու համար։\n    Երգչախմբի կազմը սահմանված է այնպես, որ որոշ դիրքում 'i', ուսանողների բարձրությունները\n    աճում են սկզբից մինչև 'i' և նվազում են 'i'-ից մինչև կազմի վերջը։\n\n    Արգումենտներ:\n    heights (List[int]): Ուսանողների բարձրությունների ցուցակ։\n\n    Վերադարձնում է:\n    int: Նվազագույն թվով ուսանողներին, որոնք պետք է հեռանան։\n    \"\"\"", "bn": "def minimum_students_to_leave(heights):\n    \"\"\"\n    একটি গায়কদলের গঠন তৈরি করতে ন্যূনতম কতজন ছাত্রকে চলে যেতে হবে তা হিসাব করুন।\n    একটি গায়কদলের গঠন এমনভাবে সংজ্ঞায়িত করা হয় যে কিছু অবস্থান 'i' এর জন্য,\n    ছাত্রদের উচ্চতা শুরু থেকে 'i' পর্যন্ত বৃদ্ধি পায় এবং 'i' থেকে গঠনের শেষ পর্যন্ত হ্রাস পায়।\n\n    আর্গুমেন্টসমূহ:\n    heights (List[int]): ছাত্রদের উচ্চতার একটি তালিকা।\n\n    রিটার্নস:\n    int: ন্যূনতম কতজন ছাত্রকে চলে যেতে হবে।\n    \"\"\"", "bg": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Изчислете минималния брой ученици, които трябва да напуснат, за да се формира хорова формация.\n    Хоровата формация е определена така, че за някаква позиция 'i', височините на учениците\n    се увеличават от началото до 'i' и намаляват от 'i' до края на формацията.\n\n    Аргументи:\n    heights (List[int]): Списък с височините на учениците.\n\n    Връща:\n    int: Минималният брой ученици, които трябва да напуснат.\n    \"\"\"", "zh": "def minimum_students_to_leave(heights):\n    \"\"\"\n    计算需要离开的最少学生人数以形成合唱队形。\n    合唱队形定义为，对于某个位置 'i'，学生的身高从开始到 'i' 增加，并从 'i' 到队形结束减少。\n\n    参数:\n    heights (List[int]): 学生身高的列表。\n\n    返回:\n    int: 需要离开的最少学生人数。\n    \"\"\"", "fr": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculer le nombre minimum d'élèves qui doivent partir pour former une chorale.\n    Une formation de chorale est définie de telle sorte que pour une position 'i', les hauteurs des élèves\n    augmentent du début à 'i' et diminuent de 'i' à la fin de la formation.\n\n    Args:\n    heights (List[int]): Une liste des hauteurs des élèves.\n\n    Returns:\n    int: Le nombre minimum d'élèves qui doivent partir.\n    \"\"\"", "de": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Berechne die minimale Anzahl von Schülern, die gehen müssen, um eine Chorformation zu bilden.\n    Eine Chorformation ist so definiert, dass für eine Position 'i' die Höhen der Schüler\n    vom Anfang bis 'i' zunehmen und von 'i' bis zum Ende der Formation abnehmen.\n\n    Argumente:\n    heights (List[int]): Eine Liste von Schülerhöhen.\n\n    Rückgabewert:\n    int: Die minimale Anzahl von Schülern, die gehen müssen.\n    \"\"\"", "ha": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Lissafa mafi ƙarancin yawan ɗaliban da ake buƙata su bar don samar da tsarin ƙungiya.\n    Ana ayyana tsarin ƙungiya ta yadda don wasu matsayi 'i', tsayin ɗalibai\n    yana ƙaruwa daga farkon zuwa 'i' kuma yana raguwa daga 'i' zuwa ƙarshen tsarin.\n\n    Args:\n    heights (List[int]): Jerin tsayin ɗalibai.\n\n    Returns:\n    int: Mafi ƙarancin yawan ɗaliban da ake buƙata su bar.\n    \"\"\"", "hi": "def minimum_students_to_leave(heights):\n    \"\"\"\n    गायक मण्डली गठन बनाने के लिए न्यूनतम कितने छात्रों को छोड़ना होगा, इसकी गणना करें।\n    गायक मण्डली गठन इस प्रकार परिभाषित है कि किसी स्थिति 'i' के लिए, छात्रों की ऊँचाई\n    शुरुआत से 'i' तक बढ़ती है और 'i' से गठन के अंत तक घटती है।\n\n    तर्क:\n    heights (List[int]): छात्रों की ऊँचाई की सूची।\n\n    लौटाता है:\n    int: न्यूनतम कितने छात्रों को छोड़ना होगा।\n    \"\"\"", "hu": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Számítsa ki a minimális számú diákot, akinek távoznia kell, hogy kórusformációt alkossanak.\n    Egy kórusformáció úgy van meghatározva, hogy egy 'i' pozícióra a diákok magassága\n    növekszik a kezdettől 'i'-ig, majd csökken 'i'-től a formáció végéig.\n\n    Paraméterek:\n    heights (List[int]): A diákok magasságának listája.\n\n    Visszatér:\n    int: A minimális számú diák, akinek távoznia kell.\n    \"\"\"", "es": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calcular el número mínimo de estudiantes que deben salir para formar una formación de coro.\n    Se define una formación de coro tal que, para alguna posición 'i', las alturas de los estudiantes\n    aumentan desde el inicio hasta 'i' y disminuyen desde 'i' hasta el final de la formación.\n\n    Argumentos:\n    heights (List[int]): Una lista de alturas de estudiantes.\n\n    Devuelve:\n    int: El número mínimo de estudiantes que deben salir.\n    \"\"\"", "arb": "def minimum_students_to_leave(heights):\n    \"\"\"\n    حساب الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة لتشكيل جوقة.\n    يتم تعريف تشكيل الجوقة بحيث أنه بالنسبة لموضع ما 'i'، تزداد أطوال الطلاب\n    من البداية إلى 'i' وتتناقص من 'i' إلى نهاية التشكيل.\n\n    يعيدالحجج:\n    heights (List[int]): قائمة بأطوال الطلاب.\n\n    يعيد:\n    int: الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة.\n    \"\"\"", "sw": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Kuhesabu idadi ndogo zaidi ya wanafunzi wanaohitajika kuondoka ili kuunda safu ya kwaya.\n    Safu ya kwaya inafafanuliwa kwamba kwa nafasi fulani 'i', urefu wa wanafunzi\n    huongezeka kutoka mwanzo hadi 'i' na kupungua kutoka 'i' hadi mwisho wa safu.\n\n    Hoja:\n    heights (List[int]): Orodha ya urefu wa wanafunzi.\n\n    Inarejesha:\n    int: Idadi ndogo zaidi ya wanafunzi wanaohitajika kuondoka.\n    \"\"\"", "tr": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Bir koro formasyonu oluşturmak için ayrılması gereken minimum öğrenci sayısını hesaplayın.\n    Bir koro formasyonu, bazı 'i' pozisyonu için, öğrencilerin boylarının başlangıçtan 'i'ye kadar\n    arttığı ve 'i'den formasyonun sonuna kadar azaldığı şekilde tanımlanır.\n\n    Argümanlar:\n    heights (List[int]): Öğrenci boylarının listesi.\n\n    Döndürür:\n    int: Ayrılması gereken minimum öğrenci sayısı.\n    \"\"\"", "vi": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Tính toán số lượng học sinh tối thiểu cần rời đi để tạo thành một đội hợp xướng.\n    Một đội hợp xướng được định nghĩa sao cho tại một vị trí 'i', chiều cao của học sinh\n    tăng từ đầu đến 'i' và giảm từ 'i' đến cuối đội hình.\n\n    Tham số:\n    heights (List[int]): Một danh sách chiều cao của học sinh.\n\n    Trả về:\n    int: Số lượng học sinh tối thiểu cần rời đi.\n    \"\"\"", "id": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Hitung jumlah minimum siswa yang perlu meninggalkan untuk membentuk formasi paduan suara.\n    Formasi paduan suara didefinisikan sedemikian rupa sehingga untuk beberapa posisi 'i', tinggi siswa\n    meningkat dari awal hingga 'i' dan menurun dari 'i' hingga akhir formasi.\n\n    Args:\n    heights (List[int]): Daftar tinggi siswa.\n\n    Returns:\n    int: Jumlah minimum siswa yang perlu meninggalkan.\n    \"\"\"", "ja": "def minimum_students_to_leave(heights):\n    \"\"\"\n    合唱隊の隊形を形成するために退場する必要がある最小の学生数を計算します。\n    合唱隊の隊形は、ある位置 'i' に対して、学生の身長が開始から 'i' まで増加し、\n    'i' から隊形の終わりまで減少するように定義されます。\n\n    引数:\n    heights (List[int]): 学生の身長のリスト。\n\n    戻り値:\n    int: 退場する必要がある最小の学生数。\n    \"\"\"", "ko": "def minimum_students_to_leave(heights):\n    \"\"\"\n    합창단 형성을 위해 떠나야 하는 학생의 최소 수를 계산합니다.\n    합창단 형성은 위치 'i'에 대해 학생들의 키가 시작부터 'i'까지 증가하고\n    'i'부터 형성의 끝까지 감소하는 것으로 정의됩니다.\n\n    Args:\n    heights (List[int]): 학생들의 키 목록.\n\n    Returns:\n    int: 떠나야 하는 학생의 최소 수.\n    \"\"\"", "ml": "def minimum_students_to_leave(heights):\n    \"\"\"\n    ഒരു ഗായക സംഘ രൂപം ഉണ്ടാക്കാൻ എത്ര കുറഞ്ഞ വിദ്യാർത്ഥികളെ പുറത്താക്കേണ്ടി വരുമെന്ന് കണക്കാക്കുക.\n    ഒരു ഗായക സംഘ രൂപം അങ്ങനെ നിർവചിക്കപ്പെടുന്നു, ഏതെങ്കിലും 'i' സ്ഥാനത്തേക്ക്, വിദ്യാർത്ഥികളുടെ ഉയരങ്ങൾ\n    ആരംഭത്തിൽ നിന്ന് 'i' വരെ വർദ്ധിക്കുകയും രൂപത്തിന്റെ അവസാനം 'i' മുതൽ കുറയുകയും ചെയ്യുന്നു.\n\n    Args:\n    heights (List[int]): വിദ്യാർത്ഥികളുടെ ഉയരങ്ങളുടെ പട്ടിക.\n\n    Returns:\n    int: എത്ര കുറഞ്ഞ വിദ്യാർത്ഥികളെ പുറത്താക്കേണ്ടി വരും.\n    \"\"\"", "fa": "def minimum_students_to_leave(heights):\n    \"\"\"\n    حداقل تعداد دانش‌آموزانی را که باید ترک کنند تا یک تشکیل گروه کر ایجاد شود محاسبه کنید.\n    یک تشکیل گروه کر به گونه‌ای تعریف می‌شود که برای موقعیت 'i'، قد دانش‌آموزان\n    از ابتدا تا 'i' افزایش یافته و از 'i' تا انتهای تشکیل کاهش می‌یابد.\n\n    Args:\n    heights (List[int]): لیستی از قد دانش‌آموزان.\n\n    Returns:\n    int: حداقل تعداد دانش‌آموزانی که باید ترک کنند.\n    \"\"\""}, "canonical_solution": "    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length", "instruction": {"en": "Write a python function 'def minimum_students_to_leave(heights):' to solve the following problem:\n\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    ", "sq": "Shkruani një funksion Python 'def minimum_students_to_leave(heights):' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin minimal të studentëve që duhet të largohen për të formuar një formacion kori.\n    Një formacion kori përcaktohet në mënyrë të tillë që për një pozicion 'i', lartësitë e studentëve\n    rriten nga fillimi deri te 'i' dhe ulen nga 'i' deri në fund të formacionit.\n\n    Args:\n    heights (List[int]): Një listë e lartësive të studentëve.\n\n    Kthen:\n    int: Numri minimal i studentëve që duhet të largohen.", "hy": "Պայթոն ֆունկցիա 'def minimum_students_to_leave(heights):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել նվազագույն ուսանողների քանակը, որոնք պետք է հեռանան, որպեսզի կազմվի երգչախմբի կազմավորում:\n    Երգչախմբի կազմավորումը սահմանվում է այնպես, որ որոշ դիրքի 'i' համար ուսանողների բարձրությունները\n    աճում են սկզբից մինչև 'i' և նվազում են 'i'-ից մինչև կազմավորման վերջը:\n\n    Արձ:\n    heights (List[int]): Ուսանողների բարձրությունների ցուցակ:\n\n    Վերադարձնում է:\n    int: Նվազագույն ուսանողների քանակը, որոնք պետք է հեռանան.", "bn": "একটি পাইথন ফাংশন 'def minimum_students_to_leave(heights):' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    একটি গায়কদলের গঠন তৈরি করতে যে ন্যূনতম সংখ্যক ছাত্রদের চলে যেতে হবে তা গণনা করুন।\n    একটি গায়কদলের গঠন এমনভাবে সংজ্ঞায়িত করা হয় যে কিছু অবস্থান 'i' এর জন্য, ছাত্রদের উচ্চতা\n    শুরু থেকে 'i' পর্যন্ত বৃদ্ধি পায় এবং 'i' থেকে গঠনের শেষ পর্যন্ত হ্রাস পায়।\n\n    আর্গুমেন্টস:\n    heights (List[int]): ছাত্রদের উচ্চতার একটি তালিকা।\n\n    রিটার্নস:\n    int: যে ন্যূনতম সংখ্যক ছাত্রদের চলে যেতে হবে।", "bg": "Напишете функция на Python 'def minimum_students_to_leave(heights):', за да решите следния проблем:\n\n    Изчислете минималния брой ученици, които трябва да напуснат, за да се формира хорова формация.\n    Хоровата формация е дефинирана така, че за някаква позиция 'i', височините на учениците\n    се увеличават от началото до 'i' и намаляват от 'i' до края на формацията.\n\n    Аргументи:\n    heights (List[int]): Списък с височините на учениците.\n\n    Връща:\n    int: Минималният брой ученици, които трябва да напуснат.", "zh": "编写一个Python函数 'def minimum_students_to_leave(heights):' 来解决以下问题：\n\n    计算需要离开的最少学生人数以形成合唱队形。\n    合唱队形的定义是，对于某个位置 'i'，学生的身高从开始到 'i' 增加，并从 'i' 到队形的结尾减少。\n\n    参数:\n    heights (List[int]): 学生身高的列表。\n\n    返回:\n    int: 需要离开的最少学生人数。", "fr": "Écrivez une fonction python 'def minimum_students_to_leave(heights):' pour résoudre le problème suivant :\n\n    Calculer le nombre minimum d'étudiants qui doivent partir pour former une formation de chorale.\n    Une formation de chorale est définie de telle sorte que pour une certaine position 'i', les hauteurs des étudiants\n    augmentent du début à 'i' et diminuent de 'i' à la fin de la formation.\n\n    Args:\n    heights (List[int]): Une liste des hauteurs des étudiants.\n\n    Returns:\n    int: Le nombre minimum d'étudiants qui doivent partir.", "de": "Schreiben Sie eine Python-Funktion 'def minimum_students_to_leave(heights):', um das folgende Problem zu lösen:\n\n    Berechnen Sie die minimale Anzahl von Schülern, die gehen müssen, um eine Chorformation zu bilden.\n    Eine Chorformation ist so definiert, dass für eine Position 'i' die Höhen der Schüler\n    vom Anfang bis 'i' zunehmen und von 'i' bis zum Ende der Formation abnehmen.\n\n    Argumente:\n    heights (List[int]): Eine Liste von Schülerhöhen.\n\n    Rückgabe:\n    int: Die minimale Anzahl von Schülern, die gehen müssen.", "ha": "Rubuta wani aikin python 'def minimum_students_to_leave(heights):' don warware matsalar mai zuwa:\n\n    Lissafa mafi karancin adadin daliban da ya kamata su bar don kafa tsarin rera waka.\n    An ayyana tsarin rera waka ta yadda a wani matsayi 'i', tsayin dalibai\n    yana karuwa daga farkon zuwa 'i' kuma yana raguwa daga 'i' zuwa ƙarshen tsarin.\n\n    Args:\n    heights (List[int]): Jerin tsayin dalibai.\n\n    Returns:\n    int: Mafi karancin adadin daliban da ya kamata su bar.", "hi": "एक पायथन फ़ंक्शन 'def minimum_students_to_leave(heights):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    गायक मंडली की संरचना बनाने के लिए कितने न्यूनतम छात्रों को छोड़ना होगा, इसकी गणना करें।\n    एक गायक मंडली की संरचना इस प्रकार परिभाषित की जाती है कि किसी स्थिति 'i' के लिए, छात्रों की ऊंचाई\n    शुरुआत से 'i' तक बढ़ती है और 'i' से संरचना के अंत तक घटती है।\n\n    तर्क:\n    heights (List[int]): छात्रों की ऊंचाई की एक सूची।\n\n    लौटाता है:\n    int: न्यूनतम छात्रों की संख्या जिन्हें छोड़ना आवश्यक है।", "hu": "Írj egy python függvényt 'def minimum_students_to_leave(heights):' a következő probléma megoldására:\n\n    Számítsd ki a minimális számú diákot, akinek távoznia kell, hogy egy kórusformációt alkossanak.\n    Egy kórusformáció úgy van definiálva, hogy egy bizonyos 'i' pozíciónál a diákok magassága\n    növekszik a kezdetektől 'i'-ig, majd csökken 'i'-től a formáció végéig.\n\n    Paraméterek:\n    heights (List[int]): A diákok magasságainak listája.\n\n    Visszatérési érték:\n    int: A minimális számú diák, akinek távoznia kell.", "es": "Escribe una función de Python 'def minimum_students_to_leave(heights):' para resolver el siguiente problema:\n\n    Calcular el número mínimo de estudiantes que deben salir para formar una formación de coro.\n    Se define una formación de coro tal que para alguna posición 'i', las alturas de los estudiantes\n    aumentan desde el inicio hasta 'i' y disminuyen desde 'i' hasta el final de la formación.\n\n    Argumentos:\n    heights (List[int]): Una lista de alturas de los estudiantes.\n\n    Devuelve:\n    int: El número mínimo de estudiantes que deben salir.", "arb": "اكتب دالة بايثون 'def minimum_students_to_leave(heights):' لحل المشكلة التالية:\n\n    احسب الحد الأدنى لعدد الطلاب الذين يحتاجون للمغادرة لتشكيل جوقة.\n    يتم تعريف تشكيل الجوقة بحيث أنه لبعض المواضع 'i'، تزداد أطوال الطلاب من البداية إلى 'i' وتتناقص من 'i' إلى نهاية التشكيل.\n\n    يعيدالحجج:\n    heights (List[int]): قائمة بأطوال الطلاب.\n\n    يعيد:\n    int: الحد الأدنى لعدد الطلاب الذين يحتاجون للمغادرة.", "sw": "Andika kazi ya python 'def minimum_students_to_leave(heights):' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ndogo zaidi ya wanafunzi wanaohitajika kuondoka ili kuunda mpangilio wa kwaya.\n    Mpangilio wa kwaya unafafanuliwa kwamba kwa nafasi fulani 'i', urefu wa wanafunzi\n    unaongezeka kutoka mwanzo hadi 'i' na kupungua kutoka 'i' hadi mwisho wa mpangilio.\n\n    Hoja:\n    heights (List[int]): Orodha ya urefu wa wanafunzi.\n\n    Inarejesha:\n    int: Idadi ndogo zaidi ya wanafunzi wanaohitajika kuondoka.", "tr": "Bir python fonksiyonu 'def minimum_students_to_leave(heights):' yazın ve aşağıdaki problemi çözün:\n\n    Bir koro formasyonu oluşturmak için ayrılması gereken minimum öğrenci sayısını hesaplayın.\n    Bir koro formasyonu, bazı 'i' pozisyonu için, öğrencilerin boylarının başlangıçtan 'i'ye kadar\n    arttığı ve 'i'den formasyonun sonuna kadar azaldığı şekilde tanımlanır.\n\n    Argümanlar:\n    heights (List[int]): Öğrenci boylarının bir listesi.\n\n    Döndürür:\n    int: Ayrılması gereken minimum öğrenci sayısı.", "vi": "Viết một hàm python 'def minimum_students_to_leave(heights):' để giải quyết vấn đề sau:\n\n    Tính toán số lượng tối thiểu học sinh cần rời đi để tạo thành một đội hình hợp xướng.\n    Một đội hình hợp xướng được định nghĩa sao cho tại một vị trí 'i', chiều cao của học sinh\n    tăng từ đầu đến 'i' và giảm từ 'i' đến cuối đội hình.\n\n    Tham số:\n    heights (List[int]): Một danh sách chiều cao của học sinh.\n\n    Trả về:\n    int: Số lượng tối thiểu học sinh cần rời đi.", "id": "Tulis sebuah fungsi python 'def minimum_students_to_leave(heights):' untuk menyelesaikan masalah berikut:\n\n    Hitung jumlah minimum siswa yang perlu meninggalkan untuk membentuk formasi paduan suara.\n    Sebuah formasi paduan suara didefinisikan sedemikian rupa sehingga untuk beberapa posisi 'i', tinggi siswa\n    meningkat dari awal hingga 'i' dan menurun dari 'i' hingga akhir formasi.\n\n    Argumen:\n    heights (List[int]): Sebuah daftar tinggi siswa.\n\n    Mengembalikan:\n    int: Jumlah minimum siswa yang perlu meninggalkan.", "ja": "Python関数 'def minimum_students_to_leave(heights):' を作成して、次の問題を解決してください:\n\n    合唱隊の隊形を形成するために退場する必要がある学生の最小数を計算します。\n    合唱隊の隊形は、ある位置 'i' に対して、学生の身長が開始から 'i' まで増加し、\n    'i' から隊形の終わりまで減少するように定義されます。\n\n    引数:\n    heights (List[int]): 学生の身長のリスト。\n\n    戻り値:\n    int: 退場する必要がある学生の最小数。", "ko": "'def minimum_students_to_leave(heights):'라는 파이썬 함수를 작성하여 다음 문제를 해결하십시오:\n\n    합창단 대형을 형성하기 위해 떠나야 하는 최소 학생 수를 계산합니다.\n    합창단 대형은 어떤 위치 'i'에 대해 학생들의 키가 시작부터 'i'까지 증가하고\n    'i'부터 대형의 끝까지 감소하는 것으로 정의됩니다.\n\n    매개변수:\n    heights (List[int]): 학생들의 키 목록.\n\n    반환값:\n    int: 떠나야 하는 최소 학생 수.", "ml": "'def minimum_students_to_leave(heights):' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    ഒരു ഗായകസംഘം രൂപീകരണം ഉണ്ടാക്കാൻ എത്ര കുറഞ്ഞ വിദ്യാർത്ഥികളെ പുറത്താക്കേണ്ടി വരും എന്ന് കണക്കാക്കുക.\n    ഒരു ഗായകസംഘം രൂപീകരണം ഇങ്ങനെ നിർവ്വചിക്കപ്പെടുന്നു, ഏതെങ്കിലും 'i' സ്ഥാനത്തേക്ക്, വിദ്യാർത്ഥികളുടെ ഉയരങ്ങൾ\n    ആരംഭത്തിൽ നിന്ന് 'i' വരെ ഉയരുകയും 'i' മുതൽ രൂപീകരണത്തിന്റെ അവസാനം വരെ താഴുകയും ചെയ്യുന്നു.\n\n    Args:\n    heights (List[int]): വിദ്യാർത്ഥികളുടെ ഉയരങ്ങളുടെ പട്ടിക.\n\n    Returns:\n    int: എത്ര കുറഞ്ഞ വിദ്യാർത്ഥികളെ പുറത്താക്കേണ്ടി വരും.", "fa": "یک تابع پایتون بنویسید 'def minimum_students_to_leave(heights):' برای حل مسئله زیر:\n\n    حداقل تعداد دانش‌آموزانی که باید خارج شوند تا یک تشکیل گروه کر ایجاد شود را محاسبه کنید.\n    یک تشکیل گروه کر به‌گونه‌ای تعریف می‌شود که برای موقعیت 'i'، قد دانش‌آموزان\n    از ابتدا تا 'i' افزایش یافته و از 'i' تا انتهای تشکیل کاهش یابد.\n\n    آرگومان‌ها:\n    heights (List[int]): یک لیست از قدهای دانش‌آموزان.\n\n    بازگشت:\n    int: حداقل تعداد دانش‌آموزانی که باید خارج شوند."}, "level": "middle", "test": "def test_minimum_students_to_leave():\n    # Test case 1: Provided example\n    assert minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220]) == 4, \"Test case 1 failed\"\n\n    # Test case 2: All students have the same height\n    assert minimum_students_to_leave([150, 150, 150, 150, 150]) == 4, \"Test case 2 failed\"\n\n    # Test case 3: Students are already in a choir formation\n    assert minimum_students_to_leave([130, 150, 170, 190, 170, 150, 130]) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Students are in strictly increasing order\n    assert minimum_students_to_leave([130, 135, 140, 145, 150, 155]) == 0, \"Test case 4 failed\"\n\n    # Test case 5: Students are in strictly decreasing order\n    assert minimum_students_to_leave([155, 150, 145, 140, 135, 130]) == 0, \"Test case 5 failed\"\n\n    # Test case 6: Optimal choir formation is not including the first or last student\n    assert minimum_students_to_leave([200, 180, 190, 170, 210, 160, 220]) == 3, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_minimum_students_to_leave()", "entry_point": "minimum_students_to_leave", "signature": "def minimum_students_to_leave(heights):", "docstring": {"en": "\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    ", "sq": "\n    Llogarit numrin minimal të studentëve që duhet të largohen për të formuar një formacion kori.\n    Një formacion kori përcaktohet në mënyrë të tillë që për një pozicion 'i', lartësitë e studentëve\n    rriten nga fillimi deri në 'i' dhe ulen nga 'i' deri në fund të formacionit.\n\n    Args:\n    heights (List[int]): Një listë e lartësive të studentëve.\n\n    Returns:\n    int: Numri minimal i studentëve që duhet të largohen.", "hy": "\n    Հաշվեք նվազագույն թվով ուսանողներին, ովքեր պետք է հեռանան երգչախմբի կազմավորման համար:\n    Երգչախմբի կազմավորումը սահմանվում է այնպես, որ որոշ դիրքի 'i' համար ուսանողների բարձրությունները\n    աճում են սկզբից մինչև 'i' և նվազում են 'i'-ից մինչև կազմավորման վերջը:\n\n    Պարամետրեր:\n    heights (List[int]): Ուսանողների բարձրությունների ցուցակ:\n\n    Վերադարձնում է:\n    int: Նվազագույն թվով ուսանողներ, ովքեր պետք է հեռանան։", "bn": "\n    কতজন শিক্ষার্থীকে ছেড়ে দিতে হবে তা গণনা করুন যাতে একটি গায়কদল গঠন করা যায়।\n    একটি গায়কদল গঠন এমনভাবে সংজ্ঞায়িত করা হয় যে কোনো অবস্থান 'i' এর জন্য, শিক্ষার্থীদের উচ্চতা শুরু থেকে 'i' পর্যন্ত বৃদ্ধি পায় এবং 'i' থেকে গঠন শেষ পর্যন্ত হ্রাস পায়।\n\n    Args:\n    heights (List[int]): শিক্ষার্থীদের উচ্চতার একটি তালিকা।\n\n    Returns:\n    int: ন্যূনতম কতজন শিক্ষার্থীকে ছেড়ে দিতে হবে।", "bg": "\n    Изчислете минималния брой ученици, които трябва да напуснат, за да се формира хорова формация.\n    Хоровата формация е определена така, че за някаква позиция 'i', височините на учениците\n    се увеличават от началото до 'i' и намаляват от 'i' до края на формацията.\n\n    Параметри:\n    heights (List[int]): Списък с височините на учениците.\n\n    Връща:\n    int: Минималният брой ученици, които трябва да напуснат.", "zh": "\n    计算需要离开的最少学生人数以形成合唱队形。\n    合唱队形被定义为，对于某个位置 'i'，学生的身高从开始到 'i' 增加，并从 'i' 到队形的末尾减少。\n\n    参数:\n    heights (List[int]): 学生身高的列表。\n\n    返回:\n    int: 需要离开的最少学生人数。", "fr": "\n    Calculer le nombre minimum d'élèves qui doivent partir pour former une chorale.\n    Une formation de chorale est définie de telle sorte que pour une position 'i', les hauteurs des élèves\n    augmentent du début jusqu'à 'i' et diminuent de 'i' jusqu'à la fin de la formation.\n\n    Args:\n    heights (List[int]): Une liste des hauteurs des élèves.\n\n    Returns:\n    int: Le nombre minimum d'élèves qui doivent partir.", "de": "\n    Berechne die minimale Anzahl von Schülern, die gehen müssen, um eine Chorformation zu bilden.\n    Eine Chorformation ist so definiert, dass für eine Position 'i' die Höhen der Schüler\n    vom Anfang bis 'i' zunehmen und von 'i' bis zum Ende der Formation abnehmen.\n\n    Args:\n    heights (List[int]): Eine Liste von Schülerhöhen.\n\n    Returns:\n    int: Die minimale Anzahl von Schülern, die gehen müssen.", "ha": "\n    Lissafa mafi ƙarancin adadin ɗalibai da ya kamata su bar wurin don samar da tsarin rera waka.\n    An ayyana tsarin rera waka ta yadda don wani matsayi 'i', tsayin ɗalibai yana ƙaruwa daga farkon zuwa 'i' kuma yana raguwa daga 'i' zuwa ƙarshen tsarin.\n\n    Args:\n    heights (List[int]): Jerin tsayin ɗalibai.\n\n    Returns:\n    int: Mafi ƙarancin adadin ɗalibai da ya kamata su bar wurin.", "hi": "\n    न्यूनतम संख्या में छात्रों की गणना करें जिन्हें एक गाना मंडली का गठन करने के लिए छोड़ना होगा। \n    एक गाना मंडली का गठन इस प्रकार परिभाषित किया जाता है कि किसी स्थिति 'i' के लिए, छात्रों की ऊँचाई \n    शुरुआत से 'i' तक बढ़ती है और 'i' से गठन के अंत तक घटती है।\n\n    Args:\n    heights (List[int]): छात्रों की ऊँचाइयों की सूची।\n\n    Returns:\n    int: न्यूनतम संख्या में छात्रों की संख्या जिन्हें छोड़ना होगा।", "hu": "\n    Számítsa ki a minimális számú diákot, akinek távoznia kell, hogy kórusformációt alkossanak.\n    Egy kórusformáció úgy van meghatározva, hogy egy 'i' pozíció esetén a diákok magassága\n    növekszik a kezdetektől 'i'-ig, majd csökken 'i'-től a formáció végéig.\n\n    Paraméterek:\n    heights (List[int]): A diákok magasságának listája.\n\n    Visszatér:\n    int: A minimális számú diák, akinek távoznia kell.", "es": "    Calcular el número mínimo de estudiantes que necesitan salir para formar una formación de coro.\n    Se define una formación de coro tal que para alguna posición 'i', las alturas de los estudiantes\n    aumentan desde el inicio hasta 'i' y disminuyen desde 'i' hasta el final de la formación.\n\n    Argumentos:\n    heights (List[int]): Una lista de alturas de estudiantes.\n\n    Devuelve:\n    int: El número mínimo de estudiantes que necesitan salir.", "arb": "    حساب الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة لتشكيل جوقة.\n    يتم تعريف تشكيل الجوقة بحيث أنه بالنسبة لموقع معين 'i'، تزداد أطوال الطلاب\n    من البداية إلى 'i' وتتناقص من 'i' إلى نهاية التشكيل.\n\n    يعيدالحجج:\n    heights (List[int]): قائمة بأطوال الطلاب.\n\n    يعيد:\n    int: الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة.", "sw": "    Hesabu idadi ndogo ya wanafunzi wanaohitajika kuondoka ili kuunda mpangilio wa kwaya.\n    Mpangilio wa kwaya unafafanuliwa kwamba kwa nafasi fulani 'i', urefu wa wanafunzi\n    unaongezeka kutoka mwanzo hadi 'i' na kupungua kutoka 'i' hadi mwisho wa mpangilio.\n\n    Hoja:\n    heights (List[int]): Orodha ya urefu wa wanafunzi.\n\n    Inarejesha:\n    int: Idadi ndogo ya wanafunzi wanaohitajika kuondoka.", "tr": "    Bir koro formasyonu oluşturmak için ayrılması gereken minimum öğrenci sayısını hesaplayın.\n    Bir koro formasyonu, 'i' konumu için, öğrencilerin boylarının başlangıçtan 'i'ye kadar arttığı\n    ve formasyonun sonuna kadar 'i'den azaldığı şekilde tanımlanır.\n\n    Argümanlar:\n    heights (List[int]): Öğrenci boylarının bir listesi.\n\n    Döndürür:\n    int: Ayrılması gereken minimum öğrenci sayısı.", "vi": "    Tính toán số lượng học sinh tối thiểu cần rời đi để tạo thành một đội hợp xướng.\n    Một đội hợp xướng được định nghĩa sao cho tại một vị trí 'i', chiều cao của học sinh\n    tăng từ đầu đến 'i' và giảm từ 'i' đến cuối đội hình.\n\n    Tham số:\n    heights (List[int]): Một danh sách chiều cao của học sinh.\n\n    Trả về:\n    int: Số lượng học sinh tối thiểu cần rời đi.", "id": "Menghitung jumlah minimum siswa yang perlu keluar untuk membentuk formasi paduan suara. Formasi paduan suara didefinisikan sedemikian rupa sehingga untuk beberapa posisi 'i', tinggi siswa meningkat dari awal hingga 'i' dan menurun dari 'i' hingga akhir formasi.\n\nArgs:\nheights (List[int]): Daftar tinggi siswa.\n\nReturns:\nint: Jumlah minimum siswa yang perlu keluar.", "ja": "    合唱隊の編成を形成するために退場する必要がある学生の最小数を計算します。\n    合唱隊の編成は、ある位置 'i' に対して、学生の身長が開始から 'i' まで増加し、'i' から編成の終わりまで減少するように定義されます。\n\n    引数:\n    heights (List[int]): 学生の身長のリスト。\n\n    戻り値:\n    int: 退場する必要がある学生の最小数。", "ko": "    합창단 구성을 형성하기 위해 떠나야 하는 최소 학생 수를 계산합니다.\n    합창단 구성은 어떤 위치 'i'에 대해 학생들의 키가 시작부터 'i'까지 증가하고\n    'i'부터 구성이 끝날 때까지 감소하는 것으로 정의됩니다.\n\n    Args:\n    heights (List[int]): 학생들의 키 목록.\n\n    Returns:\n    int: 떠나야 하는 최소 학생 수.", "ml": "    ഒരു ഗായകസംഘ രൂപീകരണം നടത്താൻ എത്ര കുറഞ്ഞ വിദ്യാർത്ഥികൾ പുറത്തുപോകേണ്ടിവരും എന്ന് കണക്കാക്കുക.\n    ഒരു ഗായകസംഘ രൂപീകരണം അങ്ങനെ നിർവ്വചിക്കപ്പെടുന്നു, ഏതെങ്കിലും 'i' സ്ഥാനത്തിനായി, വിദ്യാർത്ഥികളുടെ ഉയരങ്ങൾ\n    ആരംഭത്തിൽ നിന്ന് 'i' വരെ വർദ്ധിക്കുകയും 'i' മുതൽ രൂപീകരണത്തിന്റെ അവസാനം വരെ കുറയുകയും ചെയ്യുന്നു.\n\n    Args:\n    heights (List[int]): വിദ്യാർത്ഥികളുടെ ഉയരങ്ങളുടെ പട്ടിക.\n\n    Returns:\n    int: എത്ര കുറഞ്ഞ വിദ്യാർത്ഥികൾ പുറത്തുപോകേണ്ടിവരും.", "fa": "    حداقل تعداد دانش‌آموزانی که باید خارج شوند تا یک تشکیل گروه کر شکل گیرد را محاسبه کنید.\n    یک تشکیل گروه کر به گونه‌ای تعریف می‌شود که برای موقعیت 'i'، قد دانش‌آموزان از ابتدا تا 'i' افزایش یافته و از 'i' تا انتهای تشکیل کاهش می‌یابد.\n\n    آرگومان‌ها:\n    heights (List[int]): لیستی از قد دانش‌آموزان.\n\n    بازگشت:\n    int: حداقل تعداد دانش‌آموزانی که باید خارج شوند."}}
{"task_id": "Python/47", "prompt": {"en": "def sort_students(student_scores):\n    \"\"\"\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "sq": "def sort_students(student_scores):\n    \"\"\"\n    Rendit një listë studentësh bazuar në pikët e tyre. Studentët renditen kryesisht sipas pikëve totale (në zbritje),\n    pastaj sipas pikëve në gjuhën kineze (në zbritje), dhe më në fund sipas numrit të studentit (në rritje) në rast barazimi.\n    \n    Args:\n    student_scores (list): Një listë me tufa, ku secila tufë përbëhet nga (numri_i_studentit, pikët_totale, pikët_kineze).\n    \n    Returns:\n    list: Një listë me tufa të renditura sipas rregullave të mësipërme.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "hy": "def sort_students(student_scores):\n    \"\"\"\n    Դասավորում է ուսանողների ցուցակը՝ հիմնված նրանց գնահատականների վրա։ Ուսանողները հիմնականում դասավորվում են ըստ իրենց ընդհանուր գնահատականի (նվազման կարգով),\n    ապա՝ ըստ իրենց չինարեն գնահատականի (նվազման կարգով), և վերջապես՝ ըստ ուսանողի համարի (աճման կարգով)՝ հավասարության դեպքում։\n    \n    Արգումենտներ:\n    student_scores (list): Թվերի ցուցակ, որտեղ յուրաքանչյուր թվային տուփ բաղկացած է (ուսանողի համար, ընդհանուր գնահատական, չինարեն գնահատական)։\n    \n    Վերադարձնում է:\n    list: Թվերի ցուցակ, որը դասավորված է ըստ վերոնշյալ կանոնների։\n    \n    Օրինակներ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "bn": "def sort_students(student_scores):\n    \"\"\"\n    ছাত্রদের স্কোরের ভিত্তিতে একটি তালিকা সাজায়। ছাত্রদের প্রথমে তাদের মোট স্কোর (অবতরণক্রমে) দ্বারা সাজানো হয়,\n    তারপর তাদের চীনা স্কোর (অবতরণক্রমে) দ্বারা, এবং অবশেষে টাই হলে তাদের ছাত্র নম্বর (আরোহণক্রমে) দ্বারা সাজানো হয়।\n    \n    Args:\n    student_scores (list): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপল (student_number, total_score, Chinese_score) নিয়ে গঠিত।\n    \n    Returns:\n    list: উপরের নিয়ম অনুযায়ী সাজানো টুপলের একটি তালিকা।\n    \n    উদাহরণ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "bg": "def sort_students(student_scores):\n    \"\"\"\n    Сортира списък от студенти въз основа на техните оценки. Студентите се сортират основно по общия им резултат (в низходящ ред),\n    след това по оценката им по китайски (в низходящ ред), и накрая по номера на студента (във възходящ ред) в случай на равенство.\n    \n    Args:\n    student_scores (list): Списък от кортежи, където всеки кортеж се състои от (номер на студент, общ резултат, оценка по китайски).\n    \n    Returns:\n    list: Списък от кортежи, сортирани според горепосочените правила.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "zh": "def sort_students(student_scores):\n    \"\"\"\n    根据学生的成绩对学生列表进行排序。学生首先根据总成绩（降序）排序，\n    然后根据语文成绩（降序）排序，最后在成绩相同的情况下根据学号（升序）排序。\n    \n    参数:\n    student_scores (list): 一个包含元组的列表，每个元组由 (学号, 总成绩, 语文成绩) 组成。\n    \n    返回:\n    list: 根据上述规则排序的元组列表。\n    \n    示例:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "fr": "def sort_students(student_scores):\n    \"\"\"\n    Trie une liste d'étudiants en fonction de leurs scores. Les étudiants sont triés principalement par leur score total (décroissant),\n    puis par leur score en chinois (décroissant), et enfin par leur numéro d'étudiant (croissant) en cas d'égalité.\n    \n    Args:\n    student_scores (list): Une liste de tuples, où chaque tuple se compose de (numéro_étudiant, score_total, score_chinois).\n    \n    Returns:\n    list: Une liste de tuples triés selon les règles ci-dessus.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "de": "def sort_students(student_scores):\n    \"\"\"\n    Sortiert eine Liste von Studenten basierend auf ihren Punktzahlen. Die Studenten werden hauptsächlich nach ihrer Gesamtpunktzahl (absteigend) sortiert,\n    dann nach ihrer Chinesisch-Punktzahl (absteigend) und schließlich nach ihrer Studentennummer (aufsteigend) im Falle eines Gleichstands.\n    \n    Args:\n    student_scores (list): Eine Liste von Tupeln, wobei jedes Tupel aus (Studentennummer, Gesamtpunktzahl, Chinesisch-Punktzahl) besteht.\n    \n    Returns:\n    list: Eine Liste von Tupeln, die gemäß den obigen Regeln sortiert ist.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "ha": "def sort_students(student_scores):\n    \"\"\"\n    Tana tsara jerin ɗalibai bisa ga maki nasu. Ana tsara ɗaliban ne da farko bisa ga jimlar maki nasu (daga mafi girma zuwa ƙanana),\n    sannan bisa ga maki na Sinanci (daga mafi girma zuwa ƙanana), kuma a ƙarshe bisa ga lambar ɗalibi (daga ƙanana zuwa mafi girma) idan aka yi daidai.\n    \n    Args:\n    student_scores (list): Jerin tuples, inda kowanne tuple ya ƙunshi (lambar_ɗalibi, jimlar_maki, maki_na_Sinanci).\n    \n    Returns:\n    list: Jerin tuples da aka tsara bisa ga ƙa'idodin da ke sama.\n    \n    Misalai:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "hi": "def sort_students(student_scores):\n    \"\"\"\n    छात्रों की सूची को उनके अंकों के आधार पर क्रमबद्ध करता है। छात्रों को मुख्य रूप से उनके कुल अंकों (अवरोही क्रम में) के आधार पर क्रमबद्ध किया जाता है,\n    फिर उनके चीनी अंकों (अवरोही क्रम में) के आधार पर, और अंत में टाई की स्थिति में उनके छात्र संख्या (आरोही क्रम में) के आधार पर।\n    \n    Args:\n    student_scores (list): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में (student_number, total_score, Chinese_score) होते हैं।\n    \n    Returns:\n    list: उपरोक्त नियमों के अनुसार क्रमबद्ध ट्यूपल की एक सूची।\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "hu": "def sort_students(student_scores):\n    \"\"\"\n    Rendez egy listát a diákokról a pontszámaik alapján. A diákokat elsősorban az összpontszámuk szerint (csökkenő sorrendben),\n    majd a kínai pontszámuk szerint (csökkenő sorrendben), és végül a diák számuk szerint (növekvő sorrendben) rendezi döntetlen esetén.\n    \n    Args:\n    student_scores (list): Egy lista, amelyben minden elem egy tuple, amely a következőket tartalmazza: (diák_szám, összpontszám, kínai_pontszám).\n    \n    Returns:\n    list: Egy lista, amely a fenti szabályok szerint rendezett tuple-öket tartalmazza.\n    \n    Példák:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "es": "def sort_students(student_scores):\n    \"\"\"\n    Ordena una lista de estudiantes según sus puntajes. Los estudiantes se ordenan principalmente por su puntaje total (descendente),\n    luego por su puntaje en Chino (descendente), y finalmente por su número de estudiante (ascendente) en caso de empate.\n    \n    Argumentos:\n    student_scores (list): Una lista de tuplas, donde cada tupla consiste en (número_estudiante, puntaje_total, puntaje_Chino).\n    \n    Devuelve:\n    list: Una lista de tuplas ordenadas según las reglas anteriores.\n    \n    Ejemplos:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "arb": "def sort_students(student_scores):\n    \"\"\"\n    يقوم بفرز قائمة الطلاب بناءً على درجاتهم. يتم فرز الطلاب بشكل أساسي حسب مجموع درجاتهم (تنازليًا)،\n    ثم حسب درجاتهم في اللغة الصينية (تنازليًا)، وأخيرًا حسب رقم الطالب (تصاعديًا) في حالة التعادل.\n    \n    يعيدالحجج:\n    student_scores (list): قائمة من الأزواج، حيث يتكون كل زوج من (رقم الطالب، مجموع الدرجات، درجة اللغة الصينية).\n    \n    يعيد:\n    list: قائمة من الأزواج مرتبة وفقًا للقواعد المذكورة أعلاه.\n    \n    امثله:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "sw": "def sort_students(student_scores):\n    \"\"\"\n    Hupanga orodha ya wanafunzi kulingana na alama zao. Wanafunzi wanapangwa kimsingi kwa alama zao jumla (kutoka juu kwenda chini),\n    kisha kwa alama zao za Kichina (kutoka juu kwenda chini), na hatimaye kwa namba zao za mwanafunzi (kutoka chini kwenda juu) iwapo kuna sare.\n    \n    Hoja:\n    student_scores (list): Orodha ya jozi, ambapo kila jozi inajumuisha (namba_ya_mwanafunzi, alama_jumla, alama_za_Kichina).\n    \n    Inarejesha:\n    list: Orodha ya jozi zilizopangwa kulingana na sheria zilizo hapo juu.\n    \n    Mifano:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "tr": "def sort_students(student_scores):\n    \"\"\"\n    Öğrencileri puanlarına göre sıralar. Öğrenciler öncelikle toplam puanlarına göre (azalan), \n    ardından Çince puanlarına göre (azalan) ve son olarak eşitlik durumunda öğrenci numarasına göre (artan) sıralanır.\n    \n    Argümanlar:\n    student_scores (list): Her bir demetin (öğrenci_numarası, toplam_puan, Çince_puanı) içerdiği demetlerden oluşan bir liste.\n    \n    Döndürür:\n    list: Yukarıdaki kurallara göre sıralanmış demetlerden oluşan bir liste.\n    \n    Örnekler:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "vi": "def sort_students(student_scores):\n    \"\"\"\n    Sắp xếp danh sách học sinh dựa trên điểm số của họ. Các học sinh được sắp xếp chủ yếu theo tổng điểm (giảm dần),\n    sau đó theo điểm môn Ngữ văn (giảm dần), và cuối cùng theo số thứ tự học sinh (tăng dần) trong trường hợp bằng điểm.\n    \n    Tham số:\n    student_scores (list): Một danh sách các bộ giá trị, trong đó mỗi bộ bao gồm (số_thứ_tự_học_sinh, tổng_điểm, điểm_Ngữ_văn).\n    \n    Trả về:\n    list: Một danh sách các bộ giá trị được sắp xếp theo các quy tắc trên.\n    \n    Ví dụ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "id": "def sort_students(student_scores):\n    \"\"\"\n    Mengurutkan daftar siswa berdasarkan skor mereka. Siswa diurutkan terutama berdasarkan skor total mereka (menurun),\n    kemudian berdasarkan skor Bahasa Cina mereka (menurun), dan akhirnya berdasarkan nomor siswa mereka (menaik) jika terjadi seri.\n    \n    Args:\n    student_scores (list): Daftar tuple, di mana setiap tuple terdiri dari (nomor_siswa, skor_total, skor_Bahasa_Cina).\n    \n    Returns:\n    list: Daftar tuple yang diurutkan sesuai dengan aturan di atas.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "ja": "def sort_students(student_scores):\n    \"\"\"\n    学生のリストをスコアに基づいてソートします。学生は主に合計スコア（降順）、次に中国語のスコア（降順）、同点の場合は学生番号（昇順）でソートされます。\n    \n    Args:\n    student_scores (list): 各タプルが (student_number, total_score, Chinese_score) で構成されるタプルのリスト。\n    \n    Returns:\n    list: 上記のルールに従ってソートされたタプルのリスト。\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "ko": "def sort_students(student_scores):\n    \"\"\"\n    학생들의 점수를 기준으로 학생 목록을 정렬합니다. 학생들은 주로 총점(내림차순)으로 정렬되며,\n    그 다음으로 중국어 점수(내림차순), 그리고 동점일 경우 학번(오름차순)으로 정렬됩니다.\n    \n    Args:\n    student_scores (list): 각 튜플이 (학번, 총점, 중국어 점수)로 구성된 튜플의 목록입니다.\n    \n    Returns:\n    list: 위의 규칙에 따라 정렬된 튜플의 목록입니다.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "ml": "def sort_students(student_scores):\n    \"\"\"\n    വിദ്യാർത്ഥികളുടെ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഒരു പട്ടിക ക്രമീകരിക്കുന്നു. വിദ്യാർത്ഥികളെ പ്രധാനമായും അവരുടെ മൊത്തം സ്കോർ (ഇറക്കം ക്രമത്തിൽ),\n    തുടർന്ന് അവരുടെ ചൈനീസ് സ്കോർ (ഇറക്കം ക്രമത്തിൽ), ഒടുവിൽ ടൈ ഉണ്ടെങ്കിൽ അവരുടെ വിദ്യാർത്ഥി നമ്പർ (ആരോഹണ ക്രമത്തിൽ) പ്രകാരം ക്രമീകരിക്കുന്നു.\n    \n    Args:\n    student_scores (list): ഓരോ ട്യൂപ്പിളും (student_number, total_score, Chinese_score) അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    Returns:\n    list: മുകളിൽ പറഞ്ഞിരിക്കുന്ന നിയമങ്ങൾ അനുസരിച്ച് ക്രമീകരിച്ച ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"", "fa": "def sort_students(student_scores):\n    \"\"\"\n    لیست دانش‌آموزان را بر اساس نمراتشان مرتب می‌کند. دانش‌آموزان ابتدا بر اساس نمره کل (نزولی)،\n    سپس بر اساس نمره چینی (نزولی)، و در نهایت در صورت تساوی بر اساس شماره دانش‌آموز (صعودی) مرتب می‌شوند.\n    \n    آرگومان‌ها:\n    student_scores (list): لیستی از تاپل‌ها، که هر تاپل شامل (شماره دانش‌آموز، نمره کل، نمره چینی) است.\n    \n    بازگشت:\n    list: لیستی از تاپل‌ها که بر اساس قوانین فوق مرتب شده‌اند.\n    \n    مثال‌ها:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\""}, "canonical_solution": "    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students", "instruction": {"en": "Write a python function 'def sort_students(student_scores):' to solve the following problem:\n\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    ", "sq": "Shkruani një funksion python 'def sort_students(student_scores):' për të zgjidhur problemin e mëposhtëm:\n\n    Rendit një listë studentësh bazuar në pikët e tyre. Studentët renditen kryesisht sipas pikëve totale (në zbritje),\n    pastaj sipas pikëve në gjuhën kineze (në zbritje), dhe përfundimisht sipas numrit të studentit (në rritje) në rast barazimi.\n    \n    Argumentet:\n    student_scores (list): Një listë tuples, ku çdo tuple përbëhet nga (numri_i_studentit, pikët_totale, pikët_kineze).\n    \n    Kthen:\n    list: Një listë tuples e renditur sipas rregullave të mësipërme.\n    \n    Shembuj:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "hy": "Պայթոն ֆունկցիա 'def sort_students(student_scores):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Դասավորում է ուսանողների ցուցակը ըստ նրանց գնահատականների: Ուսանողները դասավորվում են նախ և առաջ ըստ ընդհանուր գնահատականի (նվազման կարգով),\n    ապա ըստ չինարենի գնահատականի (նվազման կարգով), և վերջապես ըստ ուսանողի համարի (աճման կարգով)՝ եթե գնահատականները հավասար են:\n    \n    Արձանագրություններ:\n    student_scores (list): Թվակազմերի ցուցակ, որտեղ յուրաքանչյուր թվակազմ բաղկացած է (ուսանողի համար, ընդհանուր գնահատական, չինարենի գնահատական)։\n    \n    Վերադարձնում է:\n    list: Թվակազմերի ցուցակ, դասավորված ըստ վերը նշված կանոնների:\n    \n    Օրինակներ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "bn": "একটি পাইথন ফাংশন 'def sort_students(student_scores):' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    শিক্ষার্থীদের একটি তালিকা তাদের স্কোরের ভিত্তিতে সাজানো হয়। শিক্ষার্থীদের প্রথমে তাদের মোট স্কোর (অবতরণক্রমে) \n    দ্বারা সাজানো হয়, তারপর তাদের চীনা স্কোর (অবতরণক্রমে), এবং অবশেষে টাই হলে তাদের ছাত্র নম্বর (আরোহণক্রমে) দ্বারা সাজানো হয়।\n    \n    Args:\n    student_scores (list): একটি টাপলগুলির তালিকা, যেখানে প্রতিটি টাপল (student_number, total_score, Chinese_score) নিয়ে গঠিত।\n    \n    Returns:\n    list: উপরের নিয়ম অনুযায়ী সাজানো টাপলগুলির একটি তালিকা।\n    \n    উদাহরণ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "bg": "Напишете Python функция 'def sort_students(student_scores):' за решаване на следния проблем:\n\n    Сортира списък от ученици въз основа на техните оценки. Учениците се сортират основно по общия им резултат (в низходящ ред),\n    след това по оценката им по китайски (в низходящ ред) и накрая по номера на ученика (във възходящ ред) в случай на равенство.\n    \n    Args:\n    student_scores (list): Списък от кортежи, където всеки кортеж се състои от (номер на ученик, общ резултат, оценка по китайски).\n    \n    Returns:\n    list: Списък от кортежи, сортирани според горепосочените правила.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "zh": "编写一个 Python 函数 'def sort_students(student_scores):' 来解决以下问题：\n\n    根据学生的分数对学生列表进行排序。学生主要根据他们的总分（降序）排序，\n    然后根据他们的语文分数（降序）排序，最后在平分的情况下根据学号（升序）排序。\n    \n    参数：\n    student_scores (list): 一个元组列表，其中每个元组由 (student_number, total_score, Chinese_score) 组成。\n    \n    返回：\n    list: 一个根据上述规则排序的元组列表。\n    \n    示例：\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "fr": "Écrivez une fonction python 'def sort_students(student_scores):' pour résoudre le problème suivant :\n\n    Trie une liste d'étudiants en fonction de leurs scores. Les étudiants sont triés principalement par leur score total (décroissant),\n    puis par leur score en chinois (décroissant), et enfin par leur numéro d'étudiant (croissant) en cas d'égalité.\n    \n    Args:\n    student_scores (list): Une liste de tuples, où chaque tuple se compose de (numéro_étudiant, score_total, score_chinois).\n    \n    Returns:\n    list: Une liste de tuples triés selon les règles ci-dessus.\n    \n    Exemples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "de": "Schreiben Sie eine Python-Funktion 'def sort_students(student_scores):', um das folgende Problem zu lösen:\n\n    Sortiert eine Liste von Studenten basierend auf ihren Punktzahlen. Die Studenten werden hauptsächlich nach ihrer Gesamtpunktzahl (absteigend) sortiert,\n    dann nach ihrer Chinesisch-Punktzahl (absteigend) und schließlich nach ihrer Studentennummer (aufsteigend) im Falle eines Gleichstands.\n    \n    Argumente:\n    student_scores (list): Eine Liste von Tupeln, wobei jedes Tupel aus (student_number, total_score, Chinese_score) besteht.\n    \n    Rückgabe:\n    list: Eine Liste von Tupeln, die gemäß den obigen Regeln sortiert ist.\n    \n    Beispiele:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\nSchreiben Sie eine Python-Funktion 'def largest_prime_factor(n: int) -> int:', um das folgende Problem zu lösen:\n\n    Finden Sie den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n    \n    Die Zahl wird als das Produkt von genau zwei verschiedenen Primzahlen angenommen. \n    Die Funktion iteriert durch mögliche Faktoren, beginnend mit dem kleinsten Prim (2), \n    und prüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion \n    die Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis zur Quadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl und wird \n    als größter Primfaktor zurückgegeben.\n    \n    Argumente:\n    n (int): Die positive ganze Zahl, die faktorisiert werden soll, die das Produkt von zwei verschiedenen Primzahlen ist.\n    \n    Rückgabe:\n    int: Der größere der beiden Primfaktoren von 'n'.\n    \n    Beispiele:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5", "ha": "Rubuta wani aikin python 'def sort_students(student_scores):' don warware matsalar mai zuwa:\n\n    Yana tsara jerin ɗalibai bisa ga maki nasu. Ana tsara ɗaliban ne da farko bisa ga jimillar maki nasu (daga mafi girma zuwa ƙasa),\n    sannan bisa ga maki na Sinanci (daga mafi girma zuwa ƙasa), kuma a ƙarshe bisa ga lambar ɗalibi (daga ƙasa zuwa mafi girma) idan akwai daidaituwa.\n    \n    Args:\n    student_scores (list): Jerin tuples, inda kowanne tuple ya ƙunshi (lambar_ɗalibi, jimillar_maki, maki_na_Sinanci).\n    \n    Returns:\n    list: Jerin tuples da aka tsara bisa ga dokokin da ke sama.\n    \n    Misalai:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "hi": "एक पायथन फ़ंक्शन 'def sort_students(student_scores):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    छात्रों की सूची को उनके अंकों के आधार पर क्रमबद्ध करता है। छात्रों को मुख्य रूप से उनके कुल अंक (अवरोही क्रम में) के आधार पर क्रमबद्ध किया जाता है,\n    फिर उनके चीनी अंक (अवरोही क्रम में), और अंत में टाई की स्थिति में उनके छात्र संख्या (आरोही क्रम में) के आधार पर।\n    \n    तर्क:\n    student_scores (list): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में (student_number, total_score, Chinese_score) होते हैं।\n    \n    लौटाता है:\n    list: उपरोक्त नियमों के अनुसार क्रमबद्ध ट्यूपल की एक सूची।\n    \n    उदाहरण:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "hu": "Írj egy python függvényt 'def sort_students(student_scores):' a következő probléma megoldására:\n\n    Rendez egy listát a diákokról a pontszámaik alapján. A diákok elsősorban az összpontszámuk szerint (csökkenő sorrendben),\n    majd a kínai pontszámuk szerint (csökkenő sorrendben), végül pedig a diák számuk szerint (növekvő sorrendben) kerülnek rendezésre, ha azonos pontszámuk van.\n    \n    Args:\n    student_scores (list): Egy listája a tuple-öknek, ahol minden tuple (student_number, total_score, Chinese_score) elemekből áll.\n    \n    Returns:\n    list: Egy listája a tuple-öknek, a fenti szabályok szerint rendezve.\n    \n    Példák:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "es": "Escribe una función de Python 'def sort_students(student_scores):' para resolver el siguiente problema:\n\n    Ordena una lista de estudiantes basándose en sus puntuaciones. Los estudiantes se ordenan principalmente por su puntuación total (descendente),\n    luego por su puntuación en Chino (descendente), y finalmente por su número de estudiante (ascendente) en caso de empate.\n    \n    Argumentos:\n    student_scores (list): Una lista de tuplas, donde cada tupla consiste en (número_de_estudiante, puntuación_total, puntuación_Chino).\n    \n    Devuelve:\n    list: Una lista de tuplas ordenadas de acuerdo con las reglas anteriores.\n    \n    Ejemplos:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "arb": "اكتب دالة بايثون 'def sort_students(student_scores):' لحل المشكلة التالية:\n\n    ترتيب قائمة الطلاب بناءً على درجاتهم. يتم ترتيب الطلاب أساسًا حسب مجموع درجاتهم (تنازليًا)،\n    ثم حسب درجاتهم في اللغة الصينية (تنازليًا)، وأخيرًا حسب رقم الطالب (تصاعديًا) في حالة التعادل.\n    \n    يعيدالحجج:\n    student_scores (list): قائمة من المجموعات، حيث تتكون كل مجموعة من (رقم الطالب، مجموع الدرجات، درجة اللغة الصينية).\n    \n    يعيد:\n    list: قائمة من المجموعات مرتبة وفقًا للقواعد المذكورة أعلاه.\n    \n    أمثلة:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "sw": "Andika kazi ya python 'def sort_students(student_scores):' kutatua tatizo lifuatalo:\n\n    Panga orodha ya wanafunzi kulingana na alama zao. Wanafunzi wanapangwa kimsingi kwa alama zao za jumla (kutoka juu kwenda chini),\n    kisha kwa alama zao za Kichina (kutoka juu kwenda chini), na hatimaye kwa namba zao za mwanafunzi (kutoka chini kwenda juu) iwapo kuna usawa.\n    \n    Hoja:\n    student_scores (list): Orodha ya jozi, ambapo kila jozi inajumuisha (namba ya mwanafunzi, alama ya jumla, alama ya Kichina).\n    \n    Inarejesha:\n    list: Orodha ya jozi zilizopangwa kulingana na sheria zilizo hapo juu.\n    \n    Mifano:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "tr": "Bir python fonksiyonu 'def sort_students(student_scores):' yazarak aşağıdaki problemi çözün:\n\n    Öğrencilerin bir listesini puanlarına göre sıralar. Öğrenciler öncelikle toplam puanlarına göre (azalan),\n    ardından Çin puanlarına göre (azalan) ve son olarak eşitlik durumunda öğrenci numarasına göre (artan) sıralanır.\n    \n    Argümanlar:\n    student_scores (list): Her bir demetin (öğrenci_numarası, toplam_puan, Çin_puanı) içerdiği demetlerin bir listesi.\n    \n    Döndürür:\n    list: Yukarıdaki kurallara göre sıralanmış demetlerin bir listesi.\n    \n    Örnekler:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "vi": "Viết một hàm python 'def sort_students(student_scores):' để giải quyết vấn đề sau:\n\n    Sắp xếp một danh sách sinh viên dựa trên điểm số của họ. Các sinh viên được sắp xếp chủ yếu theo tổng điểm (giảm dần),\n    sau đó theo điểm tiếng Trung (giảm dần), và cuối cùng theo số thứ tự sinh viên (tăng dần) trong trường hợp hòa điểm.\n    \n    Tham số:\n    student_scores (list): Một danh sách các bộ giá trị, trong đó mỗi bộ giá trị bao gồm (số thứ tự sinh viên, tổng điểm, điểm tiếng Trung).\n    \n    Trả về:\n    list: Một danh sách các bộ giá trị được sắp xếp theo các quy tắc trên.\n    \n    Ví dụ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "id": "Tulis fungsi python 'def sort_students(student_scores):' untuk menyelesaikan masalah berikut:\n\n    Mengurutkan daftar siswa berdasarkan skor mereka. Siswa diurutkan terutama berdasarkan skor total mereka (menurun),\n    kemudian berdasarkan skor Bahasa Mandarin mereka (menurun), dan akhirnya berdasarkan nomor siswa mereka (menaik) jika ada skor yang sama.\n    \n    Argumen:\n    student_scores (list): Daftar tuple, di mana setiap tuple terdiri dari (nomor_siswa, skor_total, skor_Bahasa_Mandarin).\n    \n    Mengembalikan:\n    list: Daftar tuple yang diurutkan sesuai dengan aturan di atas.\n    \n    Contoh:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "ja": "Python関数 'def sort_students(student_scores):' を作成して、次の問題を解決してください:\n\n    学生のリストをスコアに基づいてソートします。学生は、まず総合スコア（降順）でソートされ、\n    次に中国語のスコア（降順）でソートされ、同点の場合は学生番号（昇順）でソートされます。\n    \n    引数:\n    student_scores (list): 各タプルが (student_number, total_score, Chinese_score) から成るタプルのリスト。\n    \n    戻り値:\n    list: 上記のルールに従ってソートされたタプルのリスト。\n    \n    例:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "ko": "파이썬 함수를 작성하세요 'def sort_students(student_scores):' 다음 문제를 해결하기 위해:\n\n    학생들의 점수를 기준으로 학생 목록을 정렬합니다. 학생들은 주로 총점(내림차순)으로 정렬되고,\n    그 다음 중국어 점수(내림차순), 동점인 경우 학생 번호(오름차순)로 정렬됩니다.\n    \n    매개변수:\n    student_scores (list): 각 튜플이 (student_number, total_score, Chinese_score)로 구성된 튜플의 목록입니다.\n    \n    반환값:\n    list: 위의 규칙에 따라 정렬된 튜플의 목록입니다.\n    \n    예시:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "ml": "Python ഫംഗ്ഷൻ 'def sort_students(student_scores):' എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    വിദ്യാർത്ഥികളുടെ സ്കോറുകൾ അടിസ്ഥാനമാക്കി ഒരു പട്ടിക ക്രമീകരിക്കുന്നു. വിദ്യാർത്ഥികളെ അവരുടെ മൊത്തം സ്കോർ (ഇറക്കത്തിൽ) അടിസ്ഥാനമാക്കി പ്രാഥമികമായി ക്രമീകരിക്കുന്നു,\n    പിന്നെ അവരുടെ ചൈനീസ് സ്കോർ (ഇറക്കത്തിൽ) അടിസ്ഥാനമാക്കി, ഒടുവിൽ സമനിലയുണ്ടെങ്കിൽ അവരുടെ വിദ്യാർത്ഥി നമ്പർ (ഏറത്തിൽ) അടിസ്ഥാനമാക്കി.\n    \n    Args:\n    student_scores (list): ഓരോ ട്യൂപ്പിളും (student_number, total_score, Chinese_score) അടങ്ങിയ ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    Returns:\n    list: മുകളിൽ പറയുന്ന നിയമങ്ങൾ അനുസരിച്ച് ക്രമീകരിച്ച ഒരു ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "fa": "یک تابع پایتون بنویسید 'def sort_students(student_scores):' برای حل مسئله زیر:\n\n    لیستی از دانش‌آموزان را بر اساس نمراتشان مرتب می‌کند. دانش‌آموزان ابتدا بر اساس نمره کل (نزولی)،\n    سپس بر اساس نمره زبان چینی (نزولی)، و در نهایت در صورت تساوی بر اساس شماره دانش‌آموز (صعودی) مرتب می‌شوند.\n    \n    آرگومان‌ها:\n    student_scores (لیست): لیستی از تاپل‌ها، که هر تاپل شامل (شماره دانش‌آموز، نمره کل، نمره زبان چینی) است.\n    \n    بازگشت:\n    لیست: لیستی از تاپل‌ها که بر اساس قوانین فوق مرتب شده‌اند.\n    \n    مثال‌ها:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]"}, "level": "easy", "test": "def test_sort_students():\n    # Test case 1\n    input_scores = [(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)]\n    expected_output = [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 1 failed\"\n\n    # Test case 2\n    input_scores = [(1, 258, 80), (2, 264, 88), (3, 258, 90), (4, 244, 87), (5, 258, 78), (6, 264, 88), (7, 220, 67), (8, 265, 78)]\n    expected_output = [(8, 265, 78), (2, 264, 88), (6, 264, 88), (3, 258, 90), (1, 258, 80), (5, 258, 78), (4, 244, 87), (7, 220, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 2 failed\"\n\n    # Test case 3\n    input_scores = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    expected_output = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    assert sort_students(input_scores) == expected_output, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_sort_students()", "entry_point": "sort_students", "signature": "def sort_students(student_scores):", "docstring": {"en": "\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    ", "sq": "\n    Rendit një listë studentësh bazuar në pikët e tyre. Studentët renditen kryesisht sipas pikëve totale (në zbritje),\n    pastaj sipas pikëve në gjuhën kineze (në zbritje), dhe së fundi sipas numrit të studentit (në rritje) në rast barazimi.\n    \n    Args:\n    student_scores (list): Një listë tuples, ku secili tuple përbëhet nga (numri_studentit, pikët_totale, pikët_kineze).\n    \n    Returns:\n    list: Një listë tuples e renditur sipas rregullave të mësipërme.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "hy": "\n    Ուսանողների ցուցակը դասավորում է ըստ նրանց գնահատականների։ Ուսանողները հիմնականում դասավորվում են ըստ իրենց ընդհանուր գնահատականի (նվազման կարգով),\n    ապա՝ ըստ իրենց չինարենի գնահատականի (նվազման կարգով), և վերջապես՝ ըստ իրենց ուսանողական համարի (աճման կարգով)՝ եթե գնահատականները հավասար են։\n    \n    Պարամետրեր:\n    student_scores (list): Ցուցակ, որը բաղկացած է տուփերից, որտեղ յուրաքանչյուր տուփ բաղկացած է (ուսանողական համար, ընդհանուր գնահատական, չինարենի գնահատական)։\n    \n    Վերադարձնում է:\n    list: Տուփերի ցուցակ, դասավորված ըստ վերը նշված կանոնների։\n    \n    Օրինակներ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "bn": "\n    শিক্ষার্থীদের একটি তালিকা তাদের স্কোরের ভিত্তিতে সাজানো হয়। শিক্ষার্থীদের প্রথমে তাদের মোট স্কোর (অবতরণী ক্রমে) দ্বারা সাজানো হয়,\n    তারপর তাদের চীনা স্কোর (অবতরণী ক্রমে) দ্বারা, এবং শেষে সমতার ক্ষেত্রে তাদের ছাত্র নম্বর (আরোহী ক্রমে) দ্বারা সাজানো হয়।\n    \n    আর্গুমেন্টসমূহ:\n    student_scores (list): একটি টাপল-এর তালিকা, যেখানে প্রতিটি টাপল (student_number, total_score, Chinese_score) নিয়ে গঠিত।\n    \n    রিটার্নস:\n    list: উপরের নিয়ম অনুযায়ী সাজানো টাপল-এর একটি তালিকা।\n    \n    উদাহরণ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "bg": "\n    Сортира списък от студенти въз основа на техните оценки. Студентите се сортират основно по техния общ резултат (в низходящ ред),\n    след това по оценката им по китайски език (в низходящ ред) и накрая по техния студентски номер (във възходящ ред) в случай на равенство.\n    \n    Аргументи:\n    student_scores (list): Списък от кортежи, където всеки кортеж се състои от (студентски номер, общ резултат, оценка по китайски език).\n    \n    Връща:\n    list: Списък от кортежи, сортирани според горепосочените правила.\n    \n    Примери:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "zh": "\n    根据学生的成绩对学生列表进行排序。学生首先根据总成绩（降序）排序，\n    然后根据语文成绩（降序）排序，最后在成绩相同的情况下根据学号（升序）排序。\n    \n    参数:\n    student_scores (list): 一个包含元组的列表，每个元组由 (student_number, total_score, Chinese_score) 组成。\n    \n    返回:\n    list: 一个根据上述规则排序的元组列表。\n    \n    示例:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "fr": "\n    Trie une liste d'étudiants en fonction de leurs scores. Les étudiants sont triés principalement par leur score total (décroissant),\n    puis par leur score en chinois (décroissant), et enfin par leur numéro d'étudiant (croissant) en cas d'égalité.\n    \n    Args:\n    student_scores (list): Une liste de tuples, où chaque tuple se compose de (numéro_étudiant, score_total, score_chinois).\n    \n    Returns:\n    list: Une liste de tuples triés selon les règles ci-dessus.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "de": "\n    Sortiert eine Liste von Studenten basierend auf ihren Punktzahlen. Die Studenten werden hauptsächlich nach ihrer Gesamtpunktzahl (absteigend) sortiert,\n    dann nach ihrer Chinesisch-Punktzahl (absteigend) und schließlich nach ihrer Studentennummer (aufsteigend) im Falle eines Gleichstands.\n    \n    Args:\n    student_scores (list): Eine Liste von Tupeln, wobei jedes Tupel aus (student_number, total_score, Chinese_score) besteht.\n    \n    Returns:\n    list: Eine Liste von Tupeln, die gemäß den obigen Regeln sortiert ist.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "ha": "\n    Tana tsara jerin ɗalibai bisa ga maki nasu. Ana tsara ɗaliban ne da farko bisa ga jimillar maki (daga mafi girma zuwa ƙasa),\n    sannan bisa ga maki na Sinanci (daga mafi girma zuwa ƙasa), kuma a ƙarshe bisa ga lambar ɗalibi (daga ƙasa zuwa mafi girma) idan akwai daidaito.\n    \n    Args:\n    student_scores (list): Jerin tuples, inda kowanne tuple ya ƙunshi (lambar_ɗalibi, jimillar_maki, maki_na_Sinanci).\n    \n    Returns:\n    list: Jerin tuples da aka tsara bisa ga ƙa'idodin da ke sama.\n    \n    Misalai:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "hi": "\n    छात्रों की सूची को उनके अंकों के आधार पर क्रमबद्ध करता है। छात्रों को मुख्य रूप से उनके कुल अंकों (अवरोही क्रम में) के आधार पर क्रमबद्ध किया जाता है, फिर उनके चीनी अंकों (अवरोही क्रम में) के आधार पर, और अंत में टाई होने की स्थिति में उनके छात्र संख्या (आरोही क्रम में) के आधार पर।\n    \n    तर्क:\n    student_scores (list): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में (student_number, total_score, Chinese_score) होते हैं।\n    \n    लौटाता है:\n    list: उपरोक्त नियमों के अनुसार क्रमबद्ध ट्यूपल की एक सूची।\n    \n    उदाहरण:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "hu": "\n    Rendez egy listát a diákokról a pontszámaik alapján. A diákokat elsősorban az összpontszámuk szerint (csökkenő sorrendben),\n    majd a kínai pontszámuk szerint (csökkenő sorrendben), és végül a diák számuk szerint (növekvő sorrendben) rendezi döntetlen esetén.\n    \n    Argok:\n    student_scores (list): Egy lista, amelyben minden elem egy tuple, amely (diák_szám, összpontszám, kínai_pontszám) elemekből áll.\n    \n    Visszatér:\n    list: Egy lista, amely a fenti szabályok szerint rendezett tuple-öket tartalmazza.\n    \n    Példák:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "es": "Ordena una lista de estudiantes en función de sus puntuaciones. Los estudiantes se ordenan principalmente por su puntuación total (descendente), luego por su puntuación en Chino (descendente), y finalmente por su número de estudiante (ascendente) en caso de empate.\n\nArgumentos:\nstudent_scores (list): Una lista de tuplas, donde cada tupla consiste en (número_de_estudiante, puntuación_total, puntuación_Chino).\n\nDevuelve:\nlist: Una lista de tuplas ordenadas según las reglas anteriores.\n\nEjemplos:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "arb": "    يقوم بترتيب قائمة الطلاب بناءً على درجاتهم. يتم ترتيب الطلاب بشكل أساسي حسب مجموع درجاتهم (تنازليًا)،\n    ثم حسب درجاتهم في اللغة الصينية (تنازليًا)، وأخيرًا حسب رقم الطالب (تصاعديًا) في حالة التعادل.\n    \n    يعيدالحجج:\n    student_scores (list): قائمة من الأزواج، حيث يتكون كل زوج من (رقم الطالب، مجموع الدرجات، درجة اللغة الصينية).\n    \n    يعيد:\n    list: قائمة من الأزواج مرتبة وفقًا للقواعد المذكورة أعلاه.\n    \n    امثله:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "sw": "    Hupanga orodha ya wanafunzi kulingana na alama zao. Wanafunzi wanapangwa kimsingi kwa alama zao jumla (kutoka juu kwenda chini),\n    kisha kwa alama zao za Kichina (kutoka juu kwenda chini), na hatimaye kwa nambari zao za mwanafunzi (kutoka chini kwenda juu) iwapo kuna usawa.\n    \n    Hoja:\n    student_scores (list): Orodha ya jozi, ambapo kila jozi inajumuisha (nambari_ya_mwanafunzi, alama_jumla, alama_ya_Kichina).\n    \n    Inarudisha:\n    list: Orodha ya jozi zilizopangwa kulingana na sheria zilizo juu.\n    \n    Mifano:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "tr": "    Öğrencilerin bir listesini puanlarına göre sıralar. Öğrenciler öncelikle toplam puanlarına göre (azalan),\n    ardından Çince puanlarına göre (azalan) ve son olarak eşitlik durumunda öğrenci numarasına göre (artan) sıralanır.\n    \n    Argümanlar:\n    student_scores (list): Her bir demetin (öğrenci_numarası, toplam_puan, Çince_puan) içeren demetlerden oluşan bir liste.\n    \n    Döndürülenler:\n    list: Yukarıdaki kurallara göre sıralanmış demetlerden oluşan bir liste.\n    \n    Örnekler:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "vi": "Sắp xếp danh sách sinh viên dựa trên điểm số của họ. Các sinh viên được sắp xếp chủ yếu theo tổng điểm (giảm dần), sau đó theo điểm tiếng Trung (giảm dần), và cuối cùng theo số thứ tự sinh viên (tăng dần) trong trường hợp điểm bằng nhau.\n\nTham số:\nstudent_scores (list): Một danh sách các bộ giá trị, trong đó mỗi bộ giá trị bao gồm (số_thứ_tự_sinh_viên, tổng_điểm, điểm_tiếng_Trung).\n\nTrả về:\nlist: Một danh sách các bộ giá trị được sắp xếp theo các quy tắc trên.\n\nVí dụs:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "id": "Mengurutkan daftar siswa berdasarkan skor mereka. Siswa diurutkan terutama berdasarkan skor total mereka (menurun),\n    kemudian berdasarkan skor Bahasa Cina mereka (menurun), dan akhirnya berdasarkan nomor siswa mereka (menaik) jika terjadi seri.\n\nMengurutkan daftar siswa berdasarkan nilai mereka. Siswa diurutkan terutama berdasarkan nilai total mereka (menurun),\nkemudian berdasarkan nilai Bahasa Mandarin mereka (menurun), dan akhirnya berdasarkan nomor siswa mereka (menaik) jika ada kesamaan.\n\nArgs:\nstudent_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n\nArgumen:\nstudent_scores (list): Daftar tuple, di mana setiap tuple terdiri dari (nomor_siswa, nilai_total, nilai_Bahasa_Mandarin).\n\nReturns:\nlist: A list of tuples sorted according to the above rules.\n\nMengembalikan:\nlist: Daftar tuple yang diurutkan sesuai dengan aturan di atas.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\nContoh:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n", "ja": "    学生のリストをスコアに基づいてソートします。学生は主に総合スコア（降順）でソートされ、次に中国語のスコア（降順）でソートされ、同点の場合は学生番号（昇順）でソートされます。\n    \n    引数:\n    student_scores (list): 各タプルが (student_number, total_score, Chinese_score) から成るタプルのリスト。\n    \n    戻り値:\n    list: 上記のルールに従ってソートされたタプルのリスト。\n    \n    例:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "ko": "    학생들의 점수를 기준으로 목록을 정렬합니다. 학생들은 주로 총점(내림차순), 그 다음으로 중국어 점수(내림차순),\n    동점일 경우 학번(오름차순)으로 정렬됩니다.\n    \n    Args:\n    student_scores (list): 각 튜플이 (student_number, total_score, Chinese_score)로 구성된 튜플의 목록입니다.\n    \n    Returns:\n    list: 위의 규칙에 따라 정렬된 튜플의 목록입니다.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "ml": "    വിദ്യാർത്ഥികളുടെ പട്ടിക അവരുടെ സ്കോറുകളുടെ അടിസ്ഥാനത്തിൽ ക്രമീകരിക്കുന്നു. വിദ്യാർത്ഥികളെ അവരുടെ മൊത്തം സ്കോർ (ഇറക്കം ക്രമത്തിൽ),\n    തുടർന്ന് അവരുടെ ചൈനീസ് സ്കോർ (ഇറക്കം ക്രമത്തിൽ), ഒടുവിൽ ടൈ ഉണ്ടെങ്കിൽ അവരുടെ വിദ്യാർത്ഥി നമ്പർ (ആരോഹണ ക്രമത്തിൽ) പ്രകാരം ക്രമീകരിക്കുന്നു.\n    \n    Arguments:\n    student_scores (list): ഓരോ ട്യൂപ്പിളും (student_number, total_score, Chinese_score) അടങ്ങിയ ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    Returns:\n    list: മുകളിൽ പറഞ്ഞിരിക്കുന്ന നിയമങ്ങൾ പ്രകാരം ക്രമീകരിച്ച ട്യൂപ്പിളുകളുടെ പട്ടിക.\n    \n    ഉദാഹരണങ്ങൾ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]", "fa": "    لیستی از دانش‌آموزان را بر اساس نمرات آن‌ها مرتب می‌کند. دانش‌آموزان ابتدا بر اساس نمره کل (نزولی)، سپس بر اساس نمره زبان چینی (نزولی)، و در نهایت در صورت تساوی بر اساس شماره دانش‌آموز (صعودی) مرتب می‌شوند.\n    \n    آرگومان‌ها:\n    student_scores (list): لیستی از تاپل‌ها، که هر تاپل شامل (شماره دانش‌آموز، نمره کل، نمره زبان چینی) است.\n    \n    بازگشت:\n    list: لیستی از تاپل‌ها که بر اساس قوانین فوق مرتب شده‌اند.\n    \n    مثال‌ها:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]"}}
{"task_id": "Python/48", "prompt": {"en": "def min_groups(w, n, prices):\n    \"\"\"\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "sq": "def min_groups(w, n, prices):\n    \"\"\"\n    Përcakton numrin minimal të grupeve të nevojshme për të shpërndarë suveniret me një kufizim në çmimin total të grupit.\n    \n    Suveniret grupohen në çifte në mënyrë që çmimi total i secilit grup të mos tejkalojë kufirin `w`. \n    Funksioni synon të minimizojë numrin e grupeve të krijuara nën këtë kufizim.\n    \n    Args:\n    w (int): Shuma maksimale e lejuar e çmimeve për çdo grup suveniresh.\n    n (int): Numri total i suvenireve.\n    prices (list): Një listë e numrave të plotë që përfaqësojnë çmimin e secilit suvenir.\n    \n    Returns:\n    int: Numri minimal i grupeve të nevojshme për të shpërndarë të gjitha suveniret.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "hy": "def min_groups(w, n, prices):\n    \"\"\"\n    Որոշում է անհրաժեշտ խմբերի նվազագույն քանակը, որպեսզի բաշխի հուշանվերները՝ հաշվի առնելով խմբի ընդհանուր գնի սահմանափակումը։\n    \n    Հուշանվերները խմբավորվում են զույգերով այնպես, որ յուրաքանչյուր խմբի ընդհանուր գինը չգերազանցի `w` սահմանը։ \n    Ֆունկցիան նպատակ ունի նվազագույնացնել ստեղծված խմբերի քանակը այս սահմանափակման ներքո։\n    \n    Արգումենտներ:\n    w (int): Հուշանվերների ցանկացած խմբի համար թույլատրելի գների գումարի առավելագույն սահմանը։\n    n (int): Հուշանվերների ընդհանուր քանակը։\n    prices (list): Ցուցակ, որը ներկայացնում է յուրաքանչյուր հուշանվերի գինը։\n    \n    Վերադարձնում է:\n    int: Նվազագույն խմբերի քանակը, որը անհրաժեշտ է բոլոր հուշանվերները բաշխելու համար։\n\n    Օրինակներ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "bn": "def min_groups(w, n, prices):\n    \"\"\"\n    একটি দলের মোট মূল্যের সীমাবদ্ধতার সাথে স্মারক বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন দলের সংখ্যা নির্ধারণ করে।\n    \n    স্মারকগুলি জোড়ায় জোড়ায় গোষ্ঠীবদ্ধ করা হয় যাতে প্রতিটি দলের মোট মূল্য সীমা `w` অতিক্রম না করে।\n    এই সীমাবদ্ধতার অধীনে তৈরি দলের সংখ্যা সর্বনিম্ন করার লক্ষ্য রাখে ফাংশনটি।\n    \n    আর্গস:\n    w (int): যে কোনো স্মারকের দলের জন্য অনুমোদিত সর্বাধিক মূল্যের যোগফল।\n    n (int): স্মারকের মোট সংখ্যা।\n    prices (list): প্রতিটি স্মারকের মূল্য উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n    \n    রিটার্নস:\n    int: সমস্ত স্মারক বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন দলের সংখ্যা।\n\n    উদাহরণ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "bg": "def min_groups(w, n, prices):\n    \"\"\"\n    Определя минималния брой групи, необходими за разпределяне на сувенири с ограничение върху общата цена на групата.\n    \n    Сувенирите се групират по двойки така, че общата цена на всяка група да не надвишава лимита `w`.\n    Функцията цели да минимизира броя на създадените групи при това ограничение.\n    \n    Аргументи:\n    w (int): Максимално допустимата сума на цените за която и да е група сувенири.\n    n (int): Общият брой на сувенирите.\n    prices (list): Списък от цели числа, представляващи цената на всеки сувенир.\n    \n    Връща:\n    int: Минималният брой групи, необходими за разпределяне на всички сувенири.\n\n    Примери:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "zh": "def min_groups(w, n, prices):\n    \"\"\"\n    确定在对组的总价格有限制的情况下分配纪念品所需的最小组数。\n    \n    纪念品成对分组，使得每组的总价格不超过限制 `w`。\n    该函数旨在在此限制下最小化创建的组数。\n    \n    参数:\n    w (int): 任何纪念品组允许的最大价格总和。\n    n (int): 纪念品的总数量。\n    prices (list): 一个整数列表，表示每个纪念品的价格。\n    \n    返回:\n    int: 分配所有纪念品所需的最小组数。\n\n    示例:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "fr": "def min_groups(w, n, prices):\n    \"\"\"\n    Détermine le nombre minimum de groupes nécessaires pour distribuer des souvenirs avec une contrainte sur le prix total du groupe.\n    \n    Les souvenirs sont regroupés par paires de sorte que le prix total de chaque groupe ne dépasse pas la limite `w`.\n    La fonction vise à minimiser le nombre de groupes créés sous cette contrainte.\n    \n    Args:\n    w (int): La somme maximale autorisée des prix pour tout groupe de souvenirs.\n    n (int): Le nombre total de souvenirs.\n    prices (list): Une liste d'entiers représentant le prix de chaque souvenir.\n    \n    Returns:\n    int: Le nombre minimum de groupes nécessaires pour distribuer tous les souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "de": "def min_groups(w, n, prices):\n    \"\"\"\n    Bestimmt die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs mit einer Einschränkung des Gesamtpreises der Gruppe zu verteilen.\n    \n    Die Souvenirs werden paarweise gruppiert, sodass der Gesamtpreis jeder Gruppe das Limit `w` nicht überschreitet.\n    Die Funktion zielt darauf ab, die Anzahl der unter dieser Einschränkung erstellten Gruppen zu minimieren.\n    \n    Args:\n    w (int): Die maximal erlaubte Summe der Preise für jede Gruppe von Souvenirs.\n    n (int): Die Gesamtanzahl der Souvenirs.\n    prices (list): Eine Liste von ganzen Zahlen, die den Preis jedes Souvenirs darstellen.\n    \n    Returns:\n    int: Die minimale Anzahl von Gruppen, die erforderlich sind, um alle Souvenirs zu verteilen.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "ha": "def min_groups(w, n, prices):\n    \"\"\"\n    Tabbatar da mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kayan kyauta tare da ƙuntatawa akan jimillar farashin ƙungiyar.\n\n    Ana haɗa kayan kyauta a cikin ma'aurata ta yadda jimillar farashin kowace ƙungiya ba ta wuce iyaka `w`. \n    Aikin wannan aikin shi ne rage yawan ƙungiyoyin da aka ƙirƙira a ƙarƙashin wannan ƙuntatawa.\n\n    Args:\n    w (int): Mafi girman adadin farashin da aka yarda don kowace ƙungiyar kayan kyauta.\n    n (int): Jimillar adadin kayan kyauta.\n    prices (list): Jerin lambobi masu wakiltar farashin kowane kayan kyauta.\n\n    Returns:\n    int: Mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba duk kayan kyauta.\n\n    Misalai:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "hi": "def min_groups(w, n, prices):\n    \"\"\"\n    स्मृति चिह्नों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करता है जिसमें समूह की कुल कीमत पर एक बाधा होती है।\n    \n    स्मृति चिह्नों को जोड़ों में समूहित किया जाता है ताकि प्रत्येक समूह की कुल कीमत `w` की सीमा से अधिक न हो। \n    यह फ़ंक्शन इस बाधा के तहत बनाए गए समूहों की संख्या को न्यूनतम करने का प्रयास करता है।\n    \n    Args:\n    w (int): किसी भी स्मृति चिह्न समूह के लिए अनुमत अधिकतम कीमत का योग।\n    n (int): स्मृति चिह्नों की कुल संख्या।\n    prices (list): प्रत्येक स्मृति चिह्न की कीमत को दर्शाने वाली पूर्णांकों की सूची।\n    \n    Returns:\n    int: सभी स्मृति चिह्नों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या।\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "hu": "def min_groups(w, n, prices):\n    \"\"\"\n    Meghatározza a szükséges csoportok minimális számát az ajándéktárgyak elosztásához, figyelembe véve a csoportok összárára vonatkozó korlátozást.\n    \n    Az ajándéktárgyakat párokba csoportosítják úgy, hogy minden csoport összára ne haladja meg a `w` határt.\n    A függvény célja a létrehozott csoportok számának minimalizálása ezen korlátozás mellett.\n    \n    Args:\n    w (int): Az ajándéktárgyak bármely csoportjára megengedett maximális árösszeg.\n    n (int): Az ajándéktárgyak teljes száma.\n    prices (list): Egész számokat tartalmazó lista, amely az egyes ajándéktárgyak árát reprezentálja.\n    \n    Returns:\n    int: A szükséges csoportok minimális száma az összes ajándéktárgy elosztásához.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "es": "def min_groups(w, n, prices):\n    \"\"\"\n    Determina el número mínimo de grupos necesarios para distribuir recuerdos con una restricción en el precio total del grupo.\n    \n    Los recuerdos se agrupan en pares de manera que el precio total de cada grupo no exceda el límite `w`. \n    La función tiene como objetivo minimizar el número de grupos creados bajo esta restricción.\n    \n    Argumentos:\n    w (int): La suma máxima permitida de precios para cualquier grupo de recuerdos.\n    n (int): El número total de recuerdos.\n    prices (list): Una lista de enteros que representa el precio de cada recuerdo.\n    \n    Devuelve:\n    int: El número mínimo de grupos necesarios para distribuir todos los recuerdos.\n\n    Ejemplos:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "arb": "def min_groups(w, n, prices):\n    \"\"\"\n    يحدد الحد الأدنى لعدد المجموعات اللازمة لتوزيع التذكارات مع وجود قيد على السعر الإجمالي للمجموعة.\n    \n    يتم تجميع التذكارات في أزواج بحيث لا يتجاوز السعر الإجمالي لكل مجموعة الحد `w`. \n    تهدف الدالة إلى تقليل عدد المجموعات التي تم إنشاؤها تحت هذا القيد.\n    \n    يعيدالحجج:\n    w (int): الحد الأقصى المسموح به لمجموع أسعار أي مجموعة من التذكارات.\n    n (int): العدد الإجمالي للتذكارات.\n    prices (list): قائمة من الأعداد الصحيحة تمثل سعر كل تذكار.\n    \n    يعيد:\n    int: الحد الأدنى لعدد المجموعات المطلوبة لتوزيع جميع التذكارات.\n\n    امثله:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "sw": "def min_groups(w, n, prices):\n    \"\"\"\n    Inabainisha idadi ndogo ya makundi yanayohitajika kugawa zawadi zenye kizuizi kwenye jumla ya bei ya kundi.\n\n    Zawadi zimepangwa katika jozi ili jumla ya bei ya kila kundi isizidi kikomo `w`.\n    Kazi hii inalenga kupunguza idadi ya makundi yanayoundwa chini ya kizuizi hiki.\n\n    Hoja:\n    w (int): Jumla ya juu inayoruhusiwa ya bei kwa kundi lolote la zawadi.\n    n (int): Jumla ya idadi ya zawadi.\n    prices (list): Orodha ya namba ambazo zinawakilisha bei ya kila zawadi.\n\n    Inarejesha:\n    int: Idadi ndogo ya makundi yanayohitajika kugawa zawadi zote.\n\n    Mifano:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "tr": "def min_groups(w, n, prices):\n    \"\"\"\n    Hatıra eşyalarını, grubun toplam fiyatı üzerinde bir kısıtlama ile dağıtmak için gereken minimum grup sayısını belirler.\n    \n    Hatıra eşyaları, her bir grubun toplam fiyatı `w` limitini aşmayacak şekilde çiftler halinde gruplanır.\n    Fonksiyon, bu kısıtlama altında oluşturulan grup sayısını en aza indirmeyi amaçlar.\n    \n    Argümanlar:\n    w (int): Herhangi bir hatıra eşyası grubunun izin verilen maksimum fiyat toplamı.\n    n (int): Toplam hatıra eşyası sayısı.\n    prices (list): Her bir hatıra eşyasının fiyatını temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    int: Tüm hatıra eşyalarını dağıtmak için gereken minimum grup sayısı.\n\n    Örnekler:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "vi": "def min_groups(w, n, prices):\n    \"\"\"\n    Xác định số nhóm tối thiểu cần thiết để phân phối quà lưu niệm với một giới hạn về tổng giá của nhóm.\n    \n    Các quà lưu niệm được nhóm thành từng cặp sao cho tổng giá của mỗi nhóm không vượt quá giới hạn `w`. \n    Hàm này nhằm mục đích giảm thiểu số lượng nhóm được tạo ra dưới giới hạn này.\n    \n    Tham số:\n    w (int): Tổng giá tối đa được phép cho bất kỳ nhóm quà lưu niệm nào.\n    n (int): Tổng số quà lưu niệm.\n    prices (list): Một danh sách các số nguyên đại diện cho giá của mỗi quà lưu niệm.\n    \n    Trả về:\n    int: Số nhóm tối thiểu cần thiết để phân phối tất cả quà lưu niệm.\n\n    Ví dụ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "id": "def min_groups(w, n, prices):\n    \"\"\"\n    Menentukan jumlah minimum kelompok yang dibutuhkan untuk mendistribusikan suvenir dengan batasan pada total harga kelompok.\n    \n    Suvenir dikelompokkan dalam pasangan sedemikian rupa sehingga total harga setiap kelompok tidak melebihi batas `w`. \n    Fungsi ini bertujuan untuk meminimalkan jumlah kelompok yang dibuat di bawah batasan ini.\n    \n    Argumen:\n    w (int): Jumlah maksimum yang diizinkan dari harga untuk setiap kelompok suvenir.\n    n (int): Jumlah total suvenir.\n    prices (list): Daftar bilangan bulat yang mewakili harga setiap suvenir.\n    \n    Mengembalikan:\n    int: Jumlah minimum kelompok yang diperlukan untuk mendistribusikan semua suvenir.\n\n    Contoh:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "ja": "def min_groups(w, n, prices):\n    \"\"\"\n    グループの合計価格に制約がある状態で、土産物を配布するために必要な最小のグループ数を決定します。\n    \n    土産物はペアでグループ化され、各グループの合計価格が制限 `w` を超えないようにします。\n    この制約の下で作成されるグループの数を最小化することを目的としています。\n    \n    Args:\n    w (int): 土産物のグループの合計価格として許可される最大値。\n    n (int): 土産物の総数。\n    prices (list): 各土産物の価格を表す整数のリスト。\n    \n    Returns:\n    int: すべての土産物を配布するために必要な最小のグループ数。\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "ko": "def min_groups(w, n, prices):\n    \"\"\"\n    그룹의 총 가격에 대한 제약 조건을 가지고 기념품을 배포하는 데 필요한 최소 그룹 수를 결정합니다.\n    \n    기념품은 각 그룹의 총 가격이 `w`를 초과하지 않도록 쌍으로 그룹화됩니다.\n    이 함수는 이 제약 조건 하에서 생성되는 그룹의 수를 최소화하는 것을 목표로 합니다.\n    \n    Args:\n    w (int): 기념품 그룹의 가격 합계에 허용되는 최대 값.\n    n (int): 기념품의 총 수.\n    prices (list): 각 기념품의 가격을 나타내는 정수 리스트.\n    \n    Returns:\n    int: 모든 기념품을 배포하는 데 필요한 최소 그룹 수.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "ml": "def min_groups(w, n, prices):\n    \"\"\"\n    ഒരു ഗ്രൂപ്പിന്റെ മൊത്തം വിലയിൽ നിയന്ത്രണം ഉള്ള സ്മരണികകൾ വിതരണം ചെയ്യാൻ ആവശ്യമായ കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം നിർണയിക്കുന്നു.\n    \n    സ്മരണികകൾ ഓരോ ഗ്രൂപ്പിന്റെയും മൊത്തം വില `w` എന്ന പരിധി കവിയാത്ത വിധത്തിൽ ജോഡികളായി ഗ്രൂപ്പുചെയ്യുന്നു. \n    ഈ നിയന്ത്രണത്തിന് കീഴിൽ സൃഷ്ടിക്കുന്ന ഗ്രൂപ്പുകളുടെ എണ്ണം കുറയ്ക്കുന്നതാണ് ഫങ്ഷന്റെ ലക്ഷ്യം.\n    \n    Args:\n    w (int): ഏതെങ്കിലും ഗ്രൂപ്പിലെ സ്മരണികകളുടെ വിലയുടെ പരമാവധി അനുവദനീയമായ മൊത്തം.\n    n (int): സ്മരണികകളുടെ ആകെ എണ്ണം.\n    prices (list): ഓരോ സ്മരണികയുടെ വില പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n    \n    Returns:\n    int: എല്ലാ സ്മരണികകളും വിതരണം ചെയ്യാൻ ആവശ്യമായ കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "fa": "def min_groups(w, n, prices):\n    \"\"\"\n    تعیین حداقل تعداد گروه‌های مورد نیاز برای توزیع سوغاتی‌ها با محدودیت در مجموع قیمت گروه.\n    \n    سوغاتی‌ها به صورت جفت گروه‌بندی می‌شوند به طوری که مجموع قیمت هر گروه از حد `w` تجاوز نکند.\n    هدف تابع، کمینه‌سازی تعداد گروه‌های ایجاد شده تحت این محدودیت است.\n    \n    آرگومان‌ها:\n    w (int): حداکثر مجموع قیمت‌های مجاز برای هر گروه از سوغاتی‌ها.\n    n (int): تعداد کل سوغاتی‌ها.\n    prices (list): لیستی از اعداد صحیح که قیمت هر سوغاتی را نشان می‌دهد.\n    \n    بازگشت:\n    int: حداقل تعداد گروه‌های مورد نیاز برای توزیع تمام سوغاتی‌ها.\n\n    مثال‌ها:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\""}, "canonical_solution": "    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups", "instruction": {"en": "Write a python function 'def min_groups(w, n, prices):' to solve the following problem:\n\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ", "sq": "Shkruani një funksion python 'def min_groups(w, n, prices):' për të zgjidhur problemin e mëposhtëm:\n\n    Përcakton numrin minimal të grupeve të nevojshme për të shpërndarë suvenire me një kufizim në çmimin total të grupit.\n    \n    Suveniret grupohen në çifte në mënyrë të tillë që çmimi total i çdo grupi të mos tejkalojë kufirin `w`. \n    Funksioni synon të minimizojë numrin e grupeve të krijuara nën këtë kufizim.\n    \n    Args:\n    w (int): Shuma maksimale e lejuar e çmimeve për çdo grup suveniresh.\n    n (int): Numri total i suvenireve.\n    prices (list): Një listë e numrave të plotë që përfaqësojnë çmimin e secilit suvenir.\n    \n    Kthen:\n    int: Numri minimal i grupeve të nevojshme për të shpërndarë të gjitha suveniret.\n\n    Shembuj:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "hy": "Պայթոն ֆունկցիա 'def min_groups(w, n, prices):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Որոշում է նվազագույն խմբերի քանակը, որոնք անհրաժեշտ են հուշանվերները բաշխելու համար՝ խմբի ընդհանուր գնի սահմանափակմամբ:\n    \n    Հուշանվերները խմբավորվում են զույգերով այնպես, որ յուրաքանչյուր խմբի ընդհանուր գինը չգերազանցի սահմանը `w`:\n    Ֆունկցիան նպատակ ունի նվազագույնի հասցնել ստեղծված խմբերի քանակը այս սահմանափակման ներքո:\n    \n    Արգումենտներ:\n    w (int): Հուշանվերների ցանկացած խմբի համար թույլատրված գների առավելագույն գումարը:\n    n (int): Հուշանվերների ընդհանուր քանակը:\n    prices (list): Ցուցակ, որը ներկայացնում է յուրաքանչյուր հուշանվերի գինը ամբողջ թվերով:\n    \n    Վերադարձնում է:\n    int: Նվազագույն խմբերի քանակը, որոնք անհրաժեշտ են բոլոր հուշանվերները բաշխելու համար:\n\n    Օրինակներ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "bn": "একটি পাইথন ফাংশন 'def min_groups(w, n, prices):' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n\n    স্মারক বিতরণ করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ নির্ধারণ করে যেখানে গ্রুপের মোট মূল্যের উপর একটি সীমাবদ্ধতা রয়েছে।\n    \n    স্মারকগুলি জোড়ায় জোড়ায় গ্রুপ করা হয় যাতে প্রতিটি গ্রুপের মোট মূল্য সীমা `w` অতিক্রম না করে। \n    এই সীমাবদ্ধতার অধীনে তৈরি গ্রুপের সংখ্যা কমানোর লক্ষ্য ফাংশনের।\n    \n    আর্গস:\n    w (int): যে কোনো স্মারক গ্রুপের জন্য অনুমোদিত সর্বাধিক মূল্যের যোগফল।\n    n (int): স্মারকের মোট সংখ্যা।\n    prices (list): প্রতিটি স্মারকের মূল্য উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n    \n    রিটার্নস:\n    int: সমস্ত স্মারক বিতরণ করতে প্রয়োজনীয় সর্বনিম্ন গ্রুপ সংখ্যা।\n\n    উদাহরণ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "bg": "Напишете Python функция 'def min_groups(w, n, prices):', за да решите следния проблем:\n\n    Определя минималния брой групи, необходими за разпределяне на сувенири с ограничение върху общата цена на групата.\n    \n    Сувенирите са групирани по двойки така, че общата цена на всяка група да не надвишава лимита `w`. \n    Функцията цели да минимизира броя на създадените групи при това ограничение.\n    \n    Аргументи:\n    w (int): Максималната допустима сума на цените за всяка група сувенири.\n    n (int): Общият брой на сувенирите.\n    prices (list): Списък от цели числа, представляващи цената на всеки сувенир.\n    \n    Връща:\n    int: Минималният брой групи, необходими за разпределяне на всички сувенири.\n\n    Примери:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "zh": "编写一个 Python 函数 'def min_groups(w, n, prices):' 来解决以下问题：\n\n    确定在对组的总价格有限制的情况下分配纪念品所需的最小组数。\n    \n    纪念品成对分组，使得每组的总价格不超过限制 `w`。\n    该函数旨在在此限制下最小化创建的组数。\n    \n    参数:\n    w (int): 任何纪念品组允许的最大价格总和。\n    n (int): 纪念品的总数量。\n    prices (list): 一个整数列表，表示每个纪念品的价格。\n    \n    返回:\n    int: 分配所有纪念品所需的最小组数。\n\n    示例:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "fr": "Écrire une fonction python 'def min_groups(w, n, prices):' pour résoudre le problème suivant :\n\n    Détermine le nombre minimum de groupes nécessaires pour distribuer des souvenirs avec une contrainte sur le prix total du groupe.\n    \n    Les souvenirs sont groupés par paires de sorte que le prix total de chaque groupe ne dépasse pas la limite `w`. \n    La fonction vise à minimiser le nombre de groupes créés sous cette contrainte.\n    \n    Args:\n    w (int): La somme maximale autorisée des prix pour tout groupe de souvenirs.\n    n (int): Le nombre total de souvenirs.\n    prices (list): Une liste d'entiers représentant le prix de chaque souvenir.\n    \n    Returns:\n    int: Le nombre minimum de groupes nécessaires pour distribuer tous les souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "de": "Schreiben Sie eine Python-Funktion 'def min_groups(w, n, prices):', um das folgende Problem zu lösen:\n\n    Bestimmt die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs mit einer Einschränkung des Gesamtpreises der Gruppe zu verteilen.\n    \n    Die Souvenirs werden paarweise gruppiert, sodass der Gesamtpreis jeder Gruppe das Limit `w` nicht überschreitet. \n    Die Funktion zielt darauf ab, die Anzahl der unter dieser Einschränkung erstellten Gruppen zu minimieren.\n    \n    Argumente:\n    w (int): Die maximal zulässige Summe der Preise für jede Gruppe von Souvenirs.\n    n (int): Die Gesamtanzahl der Souvenirs.\n    prices (list): Eine Liste von ganzen Zahlen, die den Preis jedes Souvenirs darstellen.\n    \n    Rückgabewert:\n    int: Die minimale Anzahl von Gruppen, die erforderlich sind, um alle Souvenirs zu verteilen.\n\n    Beispiele:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "ha": "Rubuta wani aikin python 'def min_groups(w, n, prices):' don warware matsalar mai zuwa:\n\n    Tabbatar da mafi ƙarancin adadin rukuni da ake buƙata don rarraba abubuwan tunawa tare da iyaka akan jimillar farashin rukunin.\n    \n    Ana haɗa abubuwan tunawa a cikin ma'aurata ta yadda jimillar farashin kowanne rukuni ba zai wuce iyakar `w` ba. \n    Aikin yana nufin rage adadin rukunin da aka ƙirƙira a ƙarƙashin wannan iyaka.\n    \n    Args:\n    w (int): Mafi girman adadin farashin da aka yarda don kowanne rukuni na abubuwan tunawa.\n    n (int): Jimillar adadin abubuwan tunawa.\n    prices (list): Jerin lambobi masu wakiltar farashin kowanne abu na tunawa.\n    \n    Returns:\n    int: Mafi ƙarancin adadin rukunin da ake buƙata don rarraba duk abubuwan tunawa.\n\n    Misalai:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "hi": "एक पायथन फ़ंक्शन 'def min_groups(w, n, prices):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    समूह के कुल मूल्य पर प्रतिबंध के साथ उपहारों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करें।\n    \n    उपहारों को जोड़ों में इस प्रकार समूहित किया जाता है कि प्रत्येक समूह का कुल मूल्य सीमा `w` से अधिक नहीं होता है।\n    फ़ंक्शन इस प्रतिबंध के तहत बनाए गए समूहों की संख्या को न्यूनतम करने का लक्ष्य रखता है।\n    \n    तर्क:\n    w (int): किसी भी उपहार समूह के लिए अनुमत मूल्य का अधिकतम योग।\n    n (int): उपहारों की कुल संख्या।\n    prices (list): प्रत्येक उपहार के मूल्य का प्रतिनिधित्व करने वाली पूर्णांकों की सूची।\n    \n    लौटाता है:\n    int: सभी उपहारों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या।\n\n    उदाहरण:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "hu": "Írj egy Python függvényt 'def min_groups(w, n, prices):' a következő probléma megoldására:\n\n    Meghatározza a szükséges minimális csoportszámot az ajándéktárgyak elosztásához, a csoportok összárának korlátozásával.\n    \n    Az ajándéktárgyakat párokba csoportosítják úgy, hogy minden csoport összára ne haladja meg a `w` korlátot. \n    A függvény célja a létrehozott csoportok számának minimalizálása ezen korlátozás mellett.\n    \n    Argumentumok:\n    w (int): Az ajándéktárgyak bármely csoportjának megengedett maximális ártartománya.\n    n (int): Az ajándéktárgyak teljes száma.\n    prices (list): Egész számok listája, amelyek az egyes ajándéktárgyak árát képviselik.\n    \n    Visszatér:\n    int: Az összes ajándéktárgy elosztásához szükséges minimális csoportszám.\n\n    Példák:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "es": "Escribe una función en Python 'def min_groups(w, n, prices):' para resolver el siguiente problema:\n\n    Determina el número mínimo de grupos necesarios para distribuir los souvenirs con una restricción en el precio total del grupo.\n    \n    Los souvenirs se agrupan en pares de manera que el precio total de cada grupo no exceda el límite `w`. \n    La función tiene como objetivo minimizar el número de grupos creados bajo esta restricción.\n    \n    Argumentos:\n    w (int): La suma máxima permitida de precios para cualquier grupo de souvenirs.\n    n (int): El número total de souvenirs.\n    prices (list): Una lista de enteros que representa el precio de cada souvenir.\n    \n    Devuelve:\n    int: El número mínimo de grupos necesarios para distribuir todos los souvenirs.\n\n    Ejemplos:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "arb": "اكتب دالة بايثون 'def min_groups(w, n, prices):' لحل المشكلة التالية:\n\n    تحديد الحد الأدنى لعدد المجموعات اللازمة لتوزيع الهدايا التذكارية مع وجود قيد على السعر الإجمالي للمجموعة.\n    \n    يتم تجميع الهدايا التذكارية في أزواج بحيث لا يتجاوز السعر الإجمالي لكل مجموعة الحد `w`.\n    تهدف الدالة إلى تقليل عدد المجموعات التي يتم إنشاؤها تحت هذا القيد.\n    \n    يعيدالحجج:\n    w (int): الحد الأقصى المسموح به لمجموع أسعار أي مجموعة من الهدايا التذكارية.\n    n (int): العدد الإجمالي للهدايا التذكارية.\n    prices (list): قائمة من الأعداد الصحيحة تمثل سعر كل هدية تذكارية.\n    \n    يعيد:\n    int: الحد الأدنى لعدد المجموعات المطلوبة لتوزيع جميع الهدايا التذكارية.\n\n    أمثلة:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "sw": "Andika kazi ya python 'def min_groups(w, n, prices):' kutatua tatizo lifuatalo:\n\n    Inabainisha idadi ndogo zaidi ya vikundi vinavyohitajika kugawa zawadi zikiwa na kizuizi kwenye jumla ya bei ya kikundi.\n    \n    Zawadi zimepangwa katika jozi ili jumla ya bei ya kila kikundi isizidi kikomo `w`. \n    Kazi inalenga kupunguza idadi ya vikundi vilivyoundwa chini ya kizuizi hiki.\n    \n    Hoja:\n    w (int): Jumla ya juu inayoruhusiwa ya bei kwa kikundi chochote cha zawadi.\n    n (int): Jumla ya zawadi.\n    prices (list): Orodha ya namba nzima inayowakilisha bei ya kila zawadi.\n    \n    Inarejesha:\n    int: Idadi ndogo zaidi ya vikundi vinavyohitajika kugawa zawadi zote.\n\n    Mifano:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "tr": "Bir python fonksiyonu 'def min_groups(w, n, prices):' yazarak aşağıdaki problemi çözün:\n\n    Hediyelik eşyaların grup toplam fiyatı üzerinde bir kısıtlama ile dağıtılması için gereken minimum grup sayısını belirler.\n    \n    Hediyelik eşyalar, her grubun toplam fiyatı `w` limitini aşmayacak şekilde çiftler halinde gruplanır.\n    Fonksiyon, bu kısıtlama altında oluşturulan grup sayısını en aza indirmeyi amaçlar.\n    \n    Argümanlar:\n    w (int): Herhangi bir hediyelik eşya grubunun izin verilen maksimum fiyat toplamı.\n    n (int): Toplam hediyelik eşya sayısı.\n    prices (list): Her bir hediyelik eşyanın fiyatını temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    int: Tüm hediyelik eşyaları dağıtmak için gereken minimum grup sayısı.\n\n    Örnekler:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "vi": "Viết một hàm python 'def min_groups(w, n, prices):' để giải quyết vấn đề sau:\n\n    Xác định số nhóm tối thiểu cần thiết để phân phối quà lưu niệm với một ràng buộc về tổng giá của nhóm.\n\n    Các món quà lưu niệm được nhóm thành từng cặp sao cho tổng giá của mỗi nhóm không vượt quá giới hạn `w`.\n    Hàm này nhằm mục đích giảm thiểu số lượng nhóm được tạo ra dưới ràng buộc này.\n\n    Tham số:\n    w (int): Tổng giá tối đa được phép cho bất kỳ nhóm quà lưu niệm nào.\n    n (int): Tổng số quà lưu niệm.\n    prices (list): Một danh sách các số nguyên đại diện cho giá của từng món quà lưu niệm.\n\n    Trả về:\n    int: Số nhóm tối thiểu cần thiết để phân phối tất cả các món quà lưu niệm.\n\n    Ví dụ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "id": "Tulis fungsi python 'def min_groups(w, n, prices):' untuk menyelesaikan masalah berikut:\n\nMenentukan jumlah minimum kelompok yang diperlukan untuk mendistribusikan suvenir dengan batasan pada total harga kelompok.\n\nSuvenir dikelompokkan dalam pasangan sedemikian rupa sehingga total harga setiap kelompok tidak melebihi batas `w`. Fungsi ini bertujuan untuk meminimalkan jumlah kelompok yang dibuat di bawah batasan ini.\n\nArgs:\nw (int): Jumlah maksimum yang diizinkan untuk total harga dari setiap kelompok suvenir.\nn (int): Jumlah total suvenir.\nprices (list): Daftar bilangan bulat yang mewakili harga masing-masing suvenir.\n\nReturns:\nint: Jumlah minimum kelompok yang diperlukan untuk mendistribusikan semua suvenir.\n\nContoh:\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "ja": "Python関数を書いてください。 'def min_groups(w, n, prices):' 次の問題を解決するために:\n\n    お土産のグループの合計価格に制約がある場合に、配布するために必要な最小のグループ数を決定します。\n    \n    お土産はペアでグループ化され、各グループの合計価格が制限 `w` を超えないようにします。\n    この制約の下で作成されるグループの数を最小化することを目的としています。\n    \n    引数:\n    w (int): お土産のグループの合計価格として許可される最大値。\n    n (int): お土産の総数。\n    prices (list): 各お土産の価格を表す整数のリスト。\n    \n    戻り値:\n    int: すべてのお土産を配布するために必要な最小のグループ数。\n\n    例:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "ko": "파이썬 함수를 작성하세요 'def min_groups(w, n, prices):' 다음 문제를 해결하기 위해:\n\n    기념품의 총 가격에 대한 제약 조건을 가지고 기념품을 배포하는 데 필요한 최소 그룹 수를 결정합니다.\n    \n    기념품은 각 그룹의 총 가격이 `w`를 초과하지 않도록 쌍으로 그룹화됩니다. \n    이 함수는 이 제약 조건 하에서 생성되는 그룹의 수를 최소화하는 것을 목표로 합니다.\n    \n    인수:\n    w (int): 기념품 그룹의 가격 합계에 허용되는 최대 값.\n    n (int): 기념품의 총 수.\n    prices (list): 각 기념품의 가격을 나타내는 정수 목록.\n    \n    반환:\n    int: 모든 기념품을 배포하는 데 필요한 최소 그룹 수.\n\n    예:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "ml": "Python ഫംഗ്ഷൻ 'def min_groups(w, n, prices):' എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    സവിനീറുകൾ ഒരു ഗ്രൂപ്പിന്റെ മൊത്തം വിലയുടെ പരിധിയിൽ ഒരു നിയന്ത്രണത്തോടെ വിതരണം ചെയ്യുന്നതിനാവശ്യമായ കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം നിർണയിക്കുന്നു.\n    \n    സവിനീറുകൾ ഓരോ ഗ്രൂപ്പിന്റെയും മൊത്തം വില `w` എന്ന പരിധി കവിയാത്ത വിധത്തിൽ ജോഡികളായി ഗ്രൂപ്പുകളാക്കുന്നു. \n    ഈ നിയന്ത്രണത്തിന്റെ കീഴിൽ സൃഷ്ടിക്കുന്ന ഗ്രൂപ്പുകളുടെ എണ്ണം കുറയ്ക്കുകയാണ് ഫംഗ്ഷന്റെ ലക്ഷ്യം.\n    \n    Args:\n    w (int): സവിനീറുകളുടെ ഏതെങ്കിലും ഗ്രൂപ്പിനായുള്ള പരമാവധി അനുവദനീയമായ വിലയുടെ മൊത്തം.\n    n (int): മൊത്തം സവിനീറുകളുടെ എണ്ണം.\n    prices (list): ഓരോ സവിനീറിന്റെയും വിലയെ പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n    \n    Returns:\n    int: എല്ലാ സവിനീറുകളും വിതരണം ചെയ്യുന്നതിനാവശ്യമായ കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം.\n\n    ഉദാഹരണങ്ങൾ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "fa": "یک تابع پایتون بنویسید 'def min_groups(w, n, prices):' برای حل مسئله زیر:\n\npython\n    تعیین حداقل تعداد گروه‌های مورد نیاز برای توزیع سوغاتی‌ها با محدودیت در قیمت کل گروه.\n    \n    سوغاتی‌ها به صورت جفت‌هایی گروه‌بندی می‌شوند به‌طوری که قیمت کل هر گروه از حد `w` تجاوز نکند. \n    تابع هدف دارد تا تعداد گروه‌های ایجاد شده تحت این محدودیت را به حداقل برساند.\n    \n    آرگومان‌ها:\n    w (int): حداکثر مجموع قیمت‌های مجاز برای هر گروه از سوغاتی‌ها.\n    n (int): تعداد کل سوغاتی‌ها.\n    prices (list): لیستی از اعداد صحیح که قیمت هر سوغاتی را نشان می‌دهد.\n    \n    بازگشت:\n    int: حداقل تعداد گروه‌های مورد نیاز برای توزیع تمام سوغاتی‌ها.\n\n    مثال‌ها:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n"}, "level": "easy", "test": "def test_min_groups():\n    # Test case 1\n    w1 = 100\n    n1 = 9\n    prices1 = [90, 20, 20, 30, 50, 60, 70, 80, 90]\n    expected_output1 = 6\n    assert min_groups(w1, n1, prices1) == expected_output1, \"Test case 1 failed\"\n\n    # Test case 2\n    w2 = 200\n    n2 = 5\n    prices2 = [80, 120, 60, 40, 100]\n    expected_output2 = 3\n    assert min_groups(w2, n2, prices2) == expected_output2, \"Test case 2 failed\"\n\n    # Test case 3\n    w3 = 80\n    n3 = 4\n    prices3 = [30, 30, 20, 10]\n    expected_output3 = 2\n    assert min_groups(w3, n3, prices3) == expected_output3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_min_groups()", "entry_point": "min_groups", "signature": "def min_groups(w, n, prices):", "docstring": {"en": "\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ", "sq": "\n    Përcakton numrin minimal të grupeve të nevojshme për të shpërndarë suveniret me një kufizim në çmimin total të grupit.\n    \n    Suveniret grupohen në çifte të tilla që çmimi total i secilit grup të mos e kalojë kufirin `w`. \n    Funksioni synon të minimizojë numrin e grupeve të krijuara nën këtë kufizim.\n    \n    Argumentet:\n    w (int): Shuma maksimale e lejuar e çmimeve për çdo grup suveniresh.\n    n (int): Numri total i suvenireve.\n    prices (list): Një listë e numrave të plotë që përfaqësojnë çmimin e secilit suvenir.\n    \n    Kthen:\n    int: Numri minimal i grupeve të nevojshme për të shpërndarë të gjitha suveniret.\n\n    Shembuj:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "hy": "\n    Որոշում է անհրաժեշտ խմբերի նվազագույն քանակը՝ հուշանվերները բաշխելու համար՝ խմբի ընդհանուր գնի սահմանափակմամբ:\n    \n    Հուշանվերները խմբավորվում են զույգերով այնպես, որ յուրաքանչյուր խմբի ընդհանուր գինը չգերազանցի `w` սահմանը:\n    Ֆունկցիան նպատակ ունի նվազագույնի հասցնել ստեղծված խմբերի քանակը այս սահմանափակման ներքո:\n    \n    Արգումենտներ:\n    w (int): Հուշանվերների ցանկացած խմբի համար թույլատրված գների գումարի առավելագույն չափը:\n    n (int): Հուշանվերների ընդհանուր քանակը:\n    prices (list): Ցուցակ, որը ներկայացնում է յուրաքանչյուր հուշանվերի գինը որպես ամբողջ թիվ:\n    \n    Վերադարձնում է:\n    int: Հուշանվերները բաշխելու համար անհրաժեշտ խմբերի նվազագույն քանակը:\n\n    Օրինակներ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "bn": "\n    স্মারক বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ নির্ধারণ করে একটি সীমাবদ্ধতার সাথে যা গ্রুপের মোট মূল্যকে সীমাবদ্ধ করে।\n    \n    স্মারকগুলো জোড়ায় জোড়ায় গ্রুপ করা হয় যাতে প্রতিটি গ্রুপের মোট মূল্য সীমা `w` অতিক্রম না করে।\n    এই সীমাবদ্ধতার অধীনে তৈরি গ্রুপের সংখ্যা সর্বনিম্ন করার লক্ষ্য রাখে ফাংশনটি।\n    \n    আর্গুমেন্ট:\n    w (int): স্মারকের যেকোনো গ্রুপের জন্য অনুমোদিত সর্বাধিক মূল্যের যোগফল।\n    n (int): স্মারকের মোট সংখ্যা।\n    prices (list): প্রতিটি স্মারকের মূল্যকে উপস্থাপনকারী পূর্ণসংখ্যার তালিকা।\n    \n    রিটার্ন:\n    int: সমস্ত স্মারক বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ।\n\n    উদাহরণ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "bg": "\n    Определя минималния брой групи, необходими за разпределяне на сувенири с ограничение върху общата цена на групата.\n    \n    Сувенирите се групират по двойки така, че общата цена на всяка група да не надвишава лимита `w`. \n    Функцията има за цел да минимизира броя на създадените групи при това ограничение.\n    \n    Аргументи:\n    w (int): Максимално допустимата сума на цените за която и да е група сувенири.\n    n (int): Общият брой на сувенирите.\n    prices (list): Списък от цели числа, представляващи цената на всеки сувенир.\n    \n    Връща:\n    int: Минималният брой групи, необходими за разпределяне на всички сувенири.\n\n    Примери:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "zh": "\n    确定分配纪念品所需的最小组数，并对组的总价格施加限制。\n    \n    纪念品以对的形式分组，使得每组的总价格不超过限制 `w`。\n    该函数旨在在此限制下最小化创建的组数。\n    \n    参数:\n    w (int): 任何纪念品组允许的最大价格总和。\n    n (int): 纪念品的总数量。\n    prices (list): 一个整数列表，表示每个纪念品的价格。\n    \n    返回:\n    int: 分配所有纪念品所需的最小组数。\n\n    示例:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "fr": "\n    Détermine le nombre minimum de groupes nécessaires pour distribuer des souvenirs avec une contrainte sur le prix total du groupe.\n    \n    Les souvenirs sont regroupés par paires de sorte que le prix total de chaque groupe ne dépasse pas la limite `w`. \n    La fonction vise à minimiser le nombre de groupes créés sous cette contrainte.\n    \n    Args:\n    w (int): La somme maximale autorisée des prix pour tout groupe de souvenirs.\n    n (int): Le nombre total de souvenirs.\n    prices (list): Une liste d'entiers représentant le prix de chaque souvenir.\n    \n    Returns:\n    int: Le nombre minimum de groupes requis pour distribuer tous les souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "de": "\n    Bestimmt die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs mit einer Einschränkung des Gesamtpreises der Gruppe zu verteilen.\n    \n    Die Souvenirs werden paarweise gruppiert, sodass der Gesamtpreis jeder Gruppe das Limit `w` nicht überschreitet.\n    Die Funktion zielt darauf ab, die Anzahl der unter dieser Einschränkung erstellten Gruppen zu minimieren.\n    \n    Args:\n    w (int): Die maximal erlaubte Summe der Preise für jede Gruppe von Souvenirs.\n    n (int): Die Gesamtanzahl der Souvenirs.\n    prices (list): Eine Liste von ganzen Zahlen, die den Preis jedes Souvenirs darstellen.\n    \n    Returns:\n    int: Die minimale Anzahl von Gruppen, die benötigt werden, um alle Souvenirs zu verteilen.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ", "ha": "\n    Yana tantance mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kyaututtuka tare da ƙuntatawa kan jimillar farashin ƙungiyar.\n    \n    Ana haɗa kyaututtukan a cikin ma'aurata ta yadda jimillar farashin kowace ƙungiya ba ta wuce iyaka `w`. \n    Aikin wannan aikin shi ne rage yawan ƙungiyoyin da aka ƙirƙira ƙarƙashin wannan ƙuntatawa.\n    \n    Args:\n    w (int): Mafi girman adadin da aka yarda na jimillar farashin kowace ƙungiyar kyaututtuka.\n    n (int): Jimillar adadin kyaututtuka.\n    prices (list): Jerin lambobi da ke wakiltar farashin kowanne kyaututtuka.\n    \n    Returns:\n    int: Mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba duk kyaututtukan.\n\n    Misalai:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "hi": "\n    स्मृति चिन्ह वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करता है जिसमें समूह की कुल कीमत पर एक बाधा होती है।\n    \n    स्मृति चिन्हों को जोड़ों में इस प्रकार समूहित किया जाता है कि प्रत्येक समूह की कुल कीमत सीमा `w` से अधिक न हो। \n    यह फ़ंक्शन इस बाधा के तहत बनाए गए समूहों की संख्या को न्यूनतम करने का प्रयास करता है।\n    \n    Args:\n    w (int): किसी भी स्मृति चिन्ह समूह के लिए अनुमत कीमतों का अधिकतम योग।\n    n (int): स्मृति चिन्हों की कुल संख्या।\n    prices (list): प्रत्येक स्मृति चिन्ह की कीमत का प्रतिनिधित्व करने वाले पूर्णांकों की सूची।\n    \n    Returns:\n    int: सभी स्मृति चिन्ह वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या।\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "hu": "\n    Meghatározza a minimális csoportok számát, amelyek szükségesek az ajándéktárgyak elosztásához, figyelembe véve a csoportok összárára vonatkozó korlátozást.\n    \n    Az ajándéktárgyakat párokba csoportosítják úgy, hogy minden csoport összára ne haladja meg a `w` határt. \n    A függvény célja a létrehozott csoportok számának minimalizálása ezen korlátozás alatt.\n    \n    Paraméterek:\n    w (int): Az ajándéktárgyak bármely csoportjának megengedett maximális árösszege.\n    n (int): Az ajándéktárgyak teljes száma.\n    prices (list): Egész számokat tartalmazó lista, amely az egyes ajándéktárgyak árát jelöli.\n    \n    Visszatérési érték:\n    int: Az összes ajándéktárgy elosztásához szükséges minimális csoportok száma.\n\n    Példák:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "es": "Determina el número mínimo de grupos necesarios para distribuir recuerdos con una restricción en el precio total del grupo.\n\nLos recuerdos se agrupan en pares de manera que el precio total de cada grupo no exceda el límite `w`. La función tiene como objetivo minimizar el número de grupos creados bajo esta restricción.\n\nArgumentos:\nw (int): La suma máxima permitida de precios para cualquier grupo de recuerdos.\nn (int): El número total de recuerdos.\nprices (list): Una lista de enteros que representa el precio de cada recuerdo.\n\nDevuelve:\nint: El número mínimo de grupos necesarios para distribuir todos los recuerdos.\n\nEjemplos:\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "arb": "    يحدد الحد الأدنى لعدد المجموعات اللازمة لتوزيع الهدايا التذكارية مع وجود قيد على السعر الإجمالي للمجموعة.\n    \n    يتم تجميع الهدايا التذكارية في أزواج بحيث لا يتجاوز السعر الإجمالي لكل مجموعة الحد `w`. \n    تهدف الدالة إلى تقليل عدد المجموعات التي يتم إنشاؤها تحت هذا القيد.\n    \n    يعيدالحجج:\n    w (int): الحد الأقصى المسموح به لمجموع أسعار أي مجموعة من الهدايا التذكارية.\n    n (int): العدد الإجمالي للهدايا التذكارية.\n    prices (list): قائمة من الأعداد الصحيحة تمثل سعر كل هدية تذكارية.\n    \n    يعيد:\n    int: الحد الأدنى لعدد المجموعات المطلوبة لتوزيع جميع الهدايا التذكارية.\n\n    امثله:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "sw": "    Huamua idadi ndogo ya vikundi vinavyohitajika kugawa zawadi kwa kizuizi kwenye jumla ya bei ya kikundi.\n    \n    Zawadi zimepangwa katika jozi ili jumla ya bei ya kila kikundi isizidi kikomo `w`. \n    Kazi inalenga kupunguza idadi ya vikundi vilivyoundwa chini ya kizuizi hiki.\n    \n    Hoja:\n    w (int): Jumla ya juu inayoruhusiwa ya bei kwa kikundi chochote cha zawadi.\n    n (int): Jumla ya idadi ya zawadi.\n    prices (list): Orodha ya namba nzima inayoonyesha bei ya kila zawadi.\n    \n    Inarejesha:\n    int: Idadi ndogo ya vikundi vinavyohitajika kugawa zawadi zote.\n\n    Mifano:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ", "tr": "    Hatıraların toplam fiyatı üzerinde bir sınırlama ile dağıtılması için gereken minimum grup sayısını belirler.\n    \n    Hatıralar, her grubun toplam fiyatı `w` sınırını aşmayacak şekilde çiftler halinde gruplanır.\n    Fonksiyon, bu kısıtlama altında oluşturulan grup sayısını en aza indirmeyi amaçlar.\n    \n    Argümanlar:\n    w (int): Herhangi bir hatıra grubunun izin verilen maksimum fiyat toplamı.\n    n (int): Toplam hatıra sayısı.\n    prices (list): Her hatıranın fiyatını temsil eden tamsayıların listesi.\n    \n    Döndürür:\n    int: Tüm hatıraları dağıtmak için gereken minimum grup sayısı.\n\n    Örnekler:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ", "vi": "Xác định số lượng nhóm tối thiểu cần thiết để phân phối quà lưu niệm với một giới hạn về tổng giá của nhóm.\n\nCác quà lưu niệm được nhóm thành các cặp sao cho tổng giá của mỗi nhóm không vượt quá giới hạn `w`. Hàm này nhằm mục đích giảm thiểu số lượng nhóm được tạo ra dưới giới hạn này.\n\nTham số:\nw (int): Tổng giá tối đa được phép cho bất kỳ nhóm quà lưu niệm nào.\nn (int): Tổng số quà lưu niệm.\nprices (list): Một danh sách các số nguyên đại diện cho giá của mỗi quà lưu niệm.\n\nTrả về:\nint: Số lượng nhóm tối thiểu cần thiết để phân phối tất cả quà lưu niệm.\n\nVí dụ:\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "id": "Menentukan jumlah minimum kelompok yang dibutuhkan untuk mendistribusikan suvenir dengan batasan pada total harga kelompok.\n\nSuvenir dikelompokkan dalam pasangan sedemikian rupa sehingga total harga setiap kelompok tidak melebihi batas `w`. Fungsi ini bertujuan untuk meminimalkan jumlah kelompok yang dibuat di bawah batasan ini.\n\nArgs:\nw (int): Jumlah maksimum yang diizinkan dari harga untuk setiap kelompok suvenir.\nn (int): Jumlah total suvenir.\nprices (list): Daftar bilangan bulat yang mewakili harga masing-masing suvenir.\n\nReturns:\nint: Jumlah minimum kelompok yang diperlukan untuk mendistribusikan semua suvenir.\n\nExamples:\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "ja": "    お土産を配布するために必要な最小のグループ数を、グループの合計価格に制約を設けて決定します。\n    \n    お土産はペアでグループ化され、各グループの合計価格が制限 `w` を超えないようにします。\n    この関数は、この制約の下で作成されるグループの数を最小化することを目的としています。\n    \n    引数:\n    w (int): お土産のグループの合計価格として許可される最大値。\n    n (int): お土産の総数。\n    prices (list): 各お土産の価格を表す整数のリスト。\n    \n    戻り値:\n    int: すべてのお土産を配布するために必要な最小のグループ数。\n\n    例:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "ko": "    기념품의 총 가격에 대한 제약 조건을 가지고 기념품을 배포하는 데 필요한 최소 그룹 수를 결정합니다.\n    \n    기념품은 각 그룹의 총 가격이 `w`를 초과하지 않도록 쌍으로 그룹화됩니다. \n    이 함수는 이 제약 조건 하에서 생성되는 그룹의 수를 최소화하는 것을 목표로 합니다.\n    \n    Args:\n    w (int): 기념품 그룹의 가격 합계에 허용되는 최대 값.\n    n (int): 기념품의 총 수.\n    prices (list): 각 기념품의 가격을 나타내는 정수 목록.\n    \n    Returns:\n    int: 모든 기념품을 배포하는 데 필요한 최소 그룹 수.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "ml": "    സ്മരണികകൾ ഒരു ഗ്രൂപ്പിന്റെ മൊത്തം വിലയിൽ ഒരു നിയന്ത്രണത്തോടെ വിതരണം ചെയ്യാൻ ആവശ്യമായ കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം നിർണ്ണയിക്കുന്നു.\n    \n    സ്മരണികകൾ ഓരോ ഗ്രൂപ്പിന്റെയും മൊത്തം വില `w` എന്ന പരിധി കവിയാത്ത വിധത്തിൽ ജോഡികളായി ഗ്രൂപ്പുചെയ്യുന്നു. ഈ നിയന്ത്രണത്തിൽ കുറഞ്ഞ ഗ്രൂപ്പുകൾ സൃഷ്ടിക്കുന്നതിന് ഫങ്ഷൻ ലക്ഷ്യമിടുന്നു.\n    \n    Args:\n    w (int): ഏതെങ്കിലും സ്മരണികാ ഗ്രൂപ്പിന്റെ വിലയുടെ പരമാവധി അനുവദനീയമായ മൊത്തം.\n    n (int): മൊത്തം സ്മരണികകളുടെ എണ്ണം.\n    prices (list): ഓരോ സ്മരണികയുടെ വില പ്രതിനിധീകരിക്കുന്ന പൂർണ്ണസംഖ്യകളുടെ പട്ടിക.\n    \n    Returns:\n    int: എല്ലാ സ്മരണികകളും വിതരണം ചെയ്യാൻ ആവശ്യമായ കുറഞ്ഞ ഗ്രൂപ്പുകളുടെ എണ്ണം.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2", "fa": "تعیین حداقل تعداد گروه‌های مورد نیاز برای توزیع سوغاتی‌ها با محدودیتی بر قیمت کل گروه.\n\nسوغاتی‌ها به صورت جفت‌هایی گروه‌بندی می‌شوند به طوری که قیمت کل هر گروه از حد `w` تجاوز نکند. هدف این تابع به حداقل رساندن تعداد گروه‌های ایجاد شده تحت این محدودیت است.\n\nArgs:\nw (int): حداکثر مجموع قیمت‌های مجاز برای هر گروه از سوغاتی‌ها.\nn (int): تعداد کل سوغاتی‌ها.\nprices (list): لیستی از اعداد صحیح که قیمت هر سوغاتی را نشان می‌دهد.\n\nReturns:\nint: حداقل تعداد گروه‌های مورد نیاز برای توزیع تمام سوغاتی‌ها.\n\nExamples:\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2"}}
{"task_id": "Python/49", "prompt": {"en": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2.\n    - For n=2, the function should return 6.\n    - For n=3, the function should return 14.\n    \"\"\"", "sq": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Llogarit numrin minimal të lëvizjeve të nevojshme për të zgjidhur problemin e Kullave të Hanoi me dy disqe për n çifte disqesh.\n    \n    Kjo funksion implementon një algoritëm iterativ për të përcaktuar numrin minimal të lëvizjeve të nevojshme për të transferuar\n    2n disqe nga shtylla A në shtyllën C në një konfigurim të Kullave të Hanoi me dy disqe, duke ndjekur rregullat që vetëm një disk \n    mund të zhvendoset në një kohë dhe asnjë disk nuk mund të vendoset mbi një disk më të vogël. Funksioni përdor një lidhje të njohur rekursive \n    dhe llogarit në mënyrë iterative numrin total të lëvizjeve për n çifte disqesh.\n    \n    Args:\n    n (int): Numri i çifteve të disqeve (secili prej dy disqeve identikë) në shtyllën A.\n\n    Returns:\n    int: Numri minimal i lëvizjeve të nevojshme për të transferuar të gjithë disqet nga shtylla A në shtyllën C.\n\n    Raste:\n    - Për n=1, funksioni duhet të kthejë 2.\n    - Për n=2, funksioni duhet të kthejë 6.\n    - Për n=3, funksioni duhet të kthejë 14.\n    \"\"\"", "hy": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Հաշվել նվազագույն քայլերի քանակը, որը պահանջվում է կրկնակի սկավառակների Հանոյի աշտարակների խնդիրը լուծելու համար n զույգ սկավառակների համար։\n    \n    Այս ֆունկցիան իրականացնում է իտերատիվ ալգորիթմ՝ որոշելու նվազագույն քայլերի քանակը, որը անհրաժեշտ է 2n սկավառակները A ձողից C ձող տեղափոխելու համար կրկնակի սկավառակների Հանոյի աշտարակների պայմաններում՝ հետևելով այն կանոններին, որ միայն մեկ սկավառակ կարող է տեղափոխվել միաժամանակ և ոչ մի սկավառակ չի կարող տեղադրվել ավելի փոքր սկավառակի վրա։ Ֆունկցիան օգտագործում է հայտնի ռեկուրսիվ հարաբերություն և իտերատիվ կերպով հաշվում է ընդհանուր քայլերի քանակը n զույգ սկավառակների համար։\n    \n    Արգումենտներ:\n    n (int): Սկավառակների զույգերի քանակը (յուրաքանչյուրը երկու նույնական սկավառակ) A ձողի վրա։\n\n    Վերադարձնում է:\n    int: Նվազագույն քայլերի քանակը, որը պահանջվում է բոլոր սկավառակները A ձողից C ձող տեղափոխելու համար։\n\n    Դեպքեր:\n    - n=1-ի համար ֆունկցիան պետք է վերադարձնի 2։\n    - n=2-ի համար ֆունկցիան պետք է վերադարձնի 6։\n    - n=3-ի համար ֆունկցիան պետք է վերադարձնի 14։\n    \"\"\"", "bn": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    n জোড়া ডিস্কের জন্য ডাবল-ডিস্ক হ্যানয় টাওয়ার সমস্যার সমাধান করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা গণনা করুন।\n    \n    এই ফাংশনটি একটি পুনরাবৃত্তিমূলক অ্যালগরিদম প্রয়োগ করে যা 2n ডিস্ককে ডাবল-ডিস্ক হ্যানয় টাওয়ার সেটআপে A পোল থেকে C পোল পর্যন্ত স্থানান্তর করার জন্য প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা নির্ধারণ করে, \n    নিয়ম অনুসরণ করে যে একবারে শুধুমাত্র একটি ডিস্ক সরানো যেতে পারে এবং কোনো ডিস্ককে ছোট ডিস্কের উপরে রাখা যাবে না। \n    ফাংশনটি একটি পরিচিত পুনরাবৃত্ত সম্পর্ক ব্যবহার করে এবং n জোড়া ডিস্কের জন্য মোট পদক্ষেপের সংখ্যা পুনরাবৃত্তিমূলকভাবে গণনা করে।\n    \n    Args:\n    n (int): A পোলের উপর থাকা ডিস্কের জোড়ার সংখ্যা (প্রতিটি দুটি অভিন্ন ডিস্কের)।\n\n    Returns:\n    int: A পোল থেকে C পোল পর্যন্ত সমস্ত ডিস্ক স্থানান্তর করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা।\n\n    কেসসমূহ:\n    - n=1 এর জন্য, ফাংশনটি 2 ফেরত দেবে।\n    - n=2 এর জন্য, ফাংশনটি 6 ফেরত দেবে।\n    - n=3 এর জন্য, ফাংশনটি 14 ফেরত দেবে।\n    \"\"\"", "bg": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Изчислява минималния брой ходове, необходими за решаване на проблема с двойните дискове на Ханойските кули за n двойки дискове.\n    \n    Тази функция реализира итеративен алгоритъм за определяне на минималния брой ходове, необходими за преместване\n    на 2n диска от кола A към кола C в конфигурация на Ханойски кули с двойни дискове, следвайки правилата, че само един диск \n    може да бъде преместен наведнъж и никой диск не може да бъде поставен върху по-малък диск. Функцията използва известна рекурсивна връзка \n    и итеративно изчислява общия брой ходове за n двойки дискове.\n    \n    Аргументи:\n    n (int): Броят на двойките дискове (всяка от два идентични диска) на кола A.\n\n    Връща:\n    int: Минималният брой ходове, необходими за преместване на всички дискове от кола A към кола C.\n\n    Случаи:\n    - За n=1, функцията трябва да върне 2.\n    - За n=2, функцията трябва да върне 6.\n    - За n=3, функцията трябва да върне 14.\n    \"\"\"", "zh": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    计算解决双盘汉诺塔问题所需的最小移动次数，对于 n 对圆盘。\n    \n    此函数实现了一个迭代算法，以确定在双盘汉诺塔设置中，将 2n 个圆盘从 A 柱移动到 C 柱所需的最小移动次数，\n    遵循的规则是每次只能移动一个圆盘，且不能将圆盘放在比它小的圆盘上。该函数使用已知的递归关系，并迭代计算\n    n 对圆盘的总移动次数。\n    \n    参数:\n    n (int): A 柱上的圆盘对数（每对有两个相同的圆盘）。\n\n    返回:\n    int: 将所有圆盘从 A 柱移动到 C 柱所需的最小移动次数。\n\n    情况:\n    - 对于 n=1，函数应返回 2。\n    - 对于 n=2，函数应返回 6。\n    - 对于 n=3，函数应返回 14。\n    \"\"\"", "fr": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculer le nombre minimum de mouvements nécessaires pour résoudre le problème des Tours de Hanoï à double disque pour n paires de disques.\n    \n    Cette fonction implémente un algorithme itératif pour déterminer le nombre minimum de mouvements nécessaires pour transférer\n    2n disques du poteau A au poteau C dans une configuration de Tours de Hanoï à double disque, en suivant les règles selon lesquelles un seul disque \n    peut être déplacé à la fois et aucun disque ne peut être placé sur un disque plus petit. La fonction utilise une relation récursive connue \n    et calcule de manière itérative le nombre total de mouvements pour n paires de disques.\n    \n    Args:\n    n (int): Le nombre de paires de disques (chacune de deux disques identiques) sur le poteau A.\n\n    Returns:\n    int: Le nombre minimum de mouvements nécessaires pour transférer tous les disques du poteau A au poteau C.\n\n    Cas:\n    - Pour n=1, la fonction doit retourner 2.\n    - Pour n=2, la fonction doit retourner 6.\n    - Pour n=3, la fonction doit retourner 14.\n    \"\"\"", "de": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Berechne die minimale Anzahl von Zügen, die erforderlich sind, um das Doppelscheiben-Hanoi-Turm-Problem für n Scheibenpaare zu lösen.\n    \n    Diese Funktion implementiert einen iterativen Algorithmus, um die minimale Anzahl von Zügen zu bestimmen, die notwendig sind, um\n    2n Scheiben vom A-Pfosten zum C-Pfosten in einem Doppelscheiben-Hanoi-Turm-Setup zu übertragen, wobei die Regeln befolgt werden, dass \n    nur eine Scheibe gleichzeitig bewegt werden kann und keine Scheibe auf eine kleinere Scheibe gelegt werden darf. Die Funktion verwendet \n    eine bekannte rekursive Beziehung und berechnet iterativ die Gesamtanzahl der Züge für n Scheibenpaare.\n    \n    Argumente:\n    n (int): Die Anzahl der Scheibenpaare (jeweils zwei identische Scheiben) auf dem A-Pfosten.\n\n    Rückgabe:\n    int: Die minimale Anzahl von Zügen, die erforderlich sind, um alle Scheiben vom A-Pfosten zum C-Pfosten zu übertragen.\n\n    Fälle:\n    - Für n=1 sollte die Funktion 2 zurückgeben.\n    - Für n=2 sollte die Funktion 6 zurückgeben.\n    - Für n=3 sollte die Funktion 14 zurückgeben.\n    \"\"\"", "ha": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Lissafa mafi ƙarancin adadin motsi da ake buƙata don warware matsalar hasumiyar Hanoi mai faifan diski biyu don n nau'i-nau'i na faifai.\n    \n    Wannan aikin yana aiwatar da wani tsari na maimaitawa don tantance mafi ƙarancin adadin motsi da ake buƙata don canja wurin\n    faifai 2n daga sandar A zuwa sandar C a cikin saitin hasumiyar Hanoi mai faifan diski biyu, bisa ga dokokin cewa ana iya motsa faifan guda ɗaya kawai a lokaci guda kuma babu faifan da za a iya sanya a saman ƙaramin faifan. Aikin yana amfani da sanannen dangantakar maimaitawa \n    kuma yana maimaita lissafin jimillar adadin motsi don nau'i-nau'i na faifai n.\n    \n    Args:\n    n (int): Adadin nau'i-nau'i na faifai (kowanne na faifai iri biyu) a kan sandar A.\n\n    Returns:\n    int: Mafi ƙarancin adadin motsi da ake buƙata don canja duk faifan daga sandar A zuwa sandar C.\n\n    Cases:\n    - Don n=1, aikin ya kamata ya dawo da 2.\n    - Don n=2, aikin ya kamata ya dawo da 6.\n    - Don n=3, aikin ya kamata ya dawo da 14.\n    \"\"\"", "hi": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    डबल-डिस्क हनोई टावर्स समस्या को हल करने के लिए आवश्यक न्यूनतम चालों की संख्या की गणना करें, जब n जोड़े डिस्क होते हैं।\n    \n    यह फ़ंक्शन एक पुनरावृत्त एल्गोरिदम को लागू करता है ताकि न्यूनतम चालों की संख्या निर्धारित की जा सके, \n    जो 2n डिस्क को A पोल से C पोल तक डबल-डिस्क हनोई टावर्स सेटअप में स्थानांतरित करने के लिए आवश्यक है, \n    इन नियमों का पालन करते हुए कि एक समय में केवल एक डिस्क को स्थानांतरित किया जा सकता है और कोई भी डिस्क \n    एक छोटी डिस्क के ऊपर नहीं रखी जा सकती। यह फ़ंक्शन एक ज्ञात पुनरावृत्त संबंध का उपयोग करता है और n जोड़े डिस्क के लिए \n    कुल चालों की संख्या को पुनरावृत्त रूप से गणना करता है।\n    \n    Args:\n    n (int): A पोल पर डिस्क के जोड़े (प्रत्येक दो समान डिस्क) की संख्या।\n\n    Returns:\n    int: सभी डिस्क को A पोल से C पोल तक स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या।\n\n    Cases:\n    - जब n=1 हो, तो फ़ंक्शन को 2 लौटाना चाहिए।\n    - जब n=2 हो, तो फ़ंक्शन को 6 लौटाना चाहिए।\n    - जब n=3 हो, तो फ़ंक्शन को 14 लौटाना चाहिए।\n    \"\"\"", "hu": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Számítsa ki a minimális lépésszámot a dupla korongos Hanoi tornyok problémájának megoldásához n korongpár esetén.\n    \n    Ez a függvény egy iteratív algoritmust valósít meg annak meghatározására, hogy hány minimális lépés szükséges\n    2n korong áthelyezéséhez az A oszlopról a C oszlopra egy dupla korongos Hanoi tornyok felállásban, azzal a szabállyal,\n    hogy egyszerre csak egy korong mozgatható, és egy korong sem helyezhető kisebb korong tetejére. A függvény egy ismert\n    rekurzív összefüggést használ, és iteratívan számítja ki az összes lépést n korongpár esetén.\n    \n    Paraméterek:\n    n (int): Az A oszlopon lévő korongpárok száma (mindegyik két azonos korongból áll).\n\n    Visszatérési érték:\n    int: A minimális lépésszám, amely szükséges az összes korong áthelyezéséhez az A oszlopról a C oszlopra.\n\n    Esetek:\n    - Ha n=1, a függvénynek 2-t kell visszaadnia.\n    - Ha n=2, a függvénynek 6-ot kell visszaadnia.\n    - Ha n=3, a függvénynek 14-et kell visszaadnia.\n    \"\"\"", "es": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calcular el número mínimo de movimientos requeridos para resolver el problema de las Torres de Hanoi de doble disco para n pares de discos.\n    \n    Esta función implementa un algoritmo iterativo para determinar el número mínimo de movimientos necesarios para transferir\n    2n discos del poste A al poste C en una configuración de Torres de Hanoi de doble disco, siguiendo las reglas de que solo un disco \n    puede moverse a la vez y ningún disco puede colocarse sobre un disco más pequeño. La función utiliza una relación recursiva conocida \n    y calcula iterativamente el número total de movimientos para n pares de discos.\n    \n    Argumentos:\n    n (int): El número de pares de discos (cada uno de dos discos idénticos) en el poste A.\n\n    Devuelve:\n    int: El número mínimo de movimientos requeridos para transferir todos los discos del poste A al poste C.\n\n    Casos:\n    - Para n=1, la función debe devolver 2.\n    - Para n=2, la función debe devolver 6.\n    - Para n=3, la función debe devolver 14.\n    \"\"\"", "arb": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    حساب الحد الأدنى لعدد الحركات المطلوبة لحل مشكلة أبراج هانوي ذات الأقراص المزدوجة لعدد n من أزواج الأقراص.\n    \n    تقوم هذه الدالة بتنفيذ خوارزمية تكرارية لتحديد الحد الأدنى لعدد الحركات اللازمة لنقل 2n قرصًا من العمود A إلى العمود C \n    في إعداد أبراج هانوي ذات الأقراص المزدوجة، مع اتباع القواعد التي تنص على أنه يمكن نقل قرص واحد فقط في كل مرة \n    ولا يجوز وضع أي قرص فوق قرص أصغر. تستخدم الدالة علاقة تكرارية معروفة وتحسب بشكل تكراري العدد الإجمالي للحركات \n    لعدد n من أزواج الأقراص.\n    \n    يعيدالحجج:\n    n (int): عدد أزواج الأقراص (كل زوج من قرصين متطابقين) على العمود A.\n\n    يعيد:\n    int: الحد الأدنى لعدد الحركات المطلوبة لنقل جميع الأقراص من العمود A إلى العمود C.\n\n    حالات:\n    - لـ n=1، يجب أن تعيد الدالة 2.\n    - لـ n=2، يجب أن تعيد الدالة 6.\n    - لـ n=3، يجب أن تعيد الدالة 14.\n    \"\"\"", "sw": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Hesabu idadi ndogo ya hatua zinazohitajika kutatua tatizo la minara ya Hanoi ya diski mbili kwa jozi n za diski.\n    \n    Kazi hii inatekeleza algoriti ya kurudia ili kubaini idadi ndogo ya hatua zinazohitajika kuhamisha\n    diski 2n kutoka nguzo A hadi nguzo C katika mpangilio wa minara ya Hanoi ya diski mbili, kufuata sheria kwamba diski moja tu \n    inaweza kuhamishwa kwa wakati mmoja na hakuna diski inayoweza kuwekwa juu ya diski ndogo. Kazi hii inatumia uhusiano wa kurudia unaojulikana \n    na inahesabu kwa kurudia jumla ya idadi ya hatua kwa jozi n za diski.\n    \n    Hoja:\n    n (int): Idadi ya jozi za diski (kila moja ikiwa na diski mbili zinazofanana) kwenye nguzo A.\n\n    Inarejesha:\n    int: Idadi ndogo ya hatua zinazohitajika kuhamisha diski zote kutoka nguzo A hadi nguzo C.\n\n    Cases:\n    - Kwa n=1, kazi inapaswa kurudisha 2.\n    - Kwa n=2, kazi inapaswa kurudisha 6.\n    - Kwa n=3, kazi inapaswa kurudisha 14.\n    \"\"\"", "tr": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Çift diskli Hanoi Kuleleri problemini n çift disk için çözmek üzere gereken minimum hamle sayısını hesaplar.\n    \n    Bu fonksiyon, çift diskli Hanoi Kuleleri düzeninde 2n diski A direğinden C direğine aktarmak için gereken minimum \n    hamle sayısını belirlemek üzere iteratif bir algoritma uygular. Kurallara göre, aynı anda yalnızca bir disk \n    taşınabilir ve hiçbir disk daha küçük bir diskin üzerine yerleştirilemez. Fonksiyon, bilinen bir özyinelemeli \n    ilişkiyi kullanır ve n çift disk için toplam hamle sayısını iteratif olarak hesaplar.\n    \n    Argümanlar:\n    n (int): A direğinde bulunan disk çiftlerinin sayısı (her biri iki özdeş diskten oluşur).\n\n    Döndürür:\n    int: Tüm diskleri A direğinden C direğine aktarmak için gereken minimum hamle sayısı.\n\n    Durumlar:\n    - n=1 için, fonksiyon 2 döndürmelidir.\n    - n=2 için, fonksiyon 6 döndürmelidir.\n    - n=3 için, fonksiyon 14 döndürmelidir.\n    \"\"\"", "vi": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Tính toán số lần di chuyển tối thiểu cần thiết để giải quyết vấn đề Tháp Hà Nội hai đĩa cho n cặp đĩa.\n    \n    Hàm này triển khai một thuật toán lặp để xác định số lần di chuyển tối thiểu cần thiết để chuyển\n    2n đĩa từ cột A sang cột C trong cấu hình Tháp Hà Nội hai đĩa, tuân theo các quy tắc chỉ có thể di chuyển một đĩa \n    tại một thời điểm và không đĩa nào có thể được đặt lên trên một đĩa nhỏ hơn. Hàm sử dụng một quan hệ đệ quy đã biết \n    và tính toán lặp đi lặp lại tổng số lần di chuyển cho n cặp đĩa.\n    \n    Tham số:\n    n (int): Số cặp đĩa (mỗi cặp gồm hai đĩa giống nhau) trên cột A.\n\n    Trả về:\n    int: Số lần di chuyển tối thiểu cần thiết để chuyển tất cả các đĩa từ cột A sang cột C.\n\n    Trường hợp:\n    - Với n=1, hàm sẽ trả về 2.\n    - Với n=2, hàm sẽ trả về 6.\n    - Với n=3, hàm sẽ trả về 14.\n    \"\"\"", "id": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Hitung jumlah minimum gerakan yang diperlukan untuk menyelesaikan masalah Menara Hanoi dengan cakram ganda untuk n pasang cakram.\n    \n    Fungsi ini mengimplementasikan algoritma iteratif untuk menentukan jumlah minimum gerakan yang diperlukan untuk memindahkan\n    2n cakram dari tiang A ke tiang C dalam pengaturan Menara Hanoi dengan cakram ganda, mengikuti aturan bahwa hanya satu cakram \n    yang dapat dipindahkan pada satu waktu dan tidak ada cakram yang boleh ditempatkan di atas cakram yang lebih kecil. Fungsi ini menggunakan hubungan rekursif yang dikenal \n    dan secara iteratif menghitung jumlah total gerakan untuk n pasang cakram.\n    \n    Args:\n    n (int): Jumlah pasangan cakram (masing-masing terdiri dari dua cakram identik) pada tiang A.\n\n    Returns:\n    int: Jumlah minimum gerakan yang diperlukan untuk memindahkan semua cakram dari tiang A ke tiang C.\n\n    Kasus:\n    - Untuk n=1, fungsi harus mengembalikan 2.\n    - Untuk n=2, fungsi harus mengembalikan 6.\n    - Untuk n=3, fungsi harus mengembalikan 14.\n    \"\"\"", "ja": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    n組のディスクに対する二重ディスクハノイの塔問題を解くために必要な最小の移動回数を計算します。\n    \n    この関数は、二重ディスクハノイの塔のセットアップで、AポールからCポールに2n枚のディスクを移動するために\n    必要な最小の移動回数を決定するための反復アルゴリズムを実装しています。ルールとして、一度に1枚のディスク\n    しか移動できず、小さいディスクの上に他のディスクを置いてはいけません。この関数は既知の再帰的関係を使用し、\n    n組のディスクに対する移動の総数を反復的に計算します。\n    \n    引数:\n    n (int): Aポール上のディスクペア（同一のディスクが2枚で1組）の数。\n\n    戻り値:\n    int: すべてのディスクをAポールからCポールに移動するために必要な最小の移動回数。\n\n    ケース:\n    - n=1の場合、関数は2を返すべきです。\n    - n=2の場合、関数は6を返すべきです。\n    - n=3の場合、関数は14を返すべきです。\n    \"\"\"", "ko": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    n 쌍의 디스크에 대해 이중 디스크 하노이 탑 문제를 해결하는 데 필요한 최소 이동 횟수를 계산합니다.\n    \n    이 함수는 반복 알고리즘을 구현하여 이중 디스크 하노이 탑 설정에서 A 기둥에서 C 기둥으로 2n개의 디스크를 \n    이동하는 데 필요한 최소 이동 횟수를 결정합니다. 이때 한 번에 하나의 디스크만 이동할 수 있으며, \n    작은 디스크 위에 더 큰 디스크를 놓을 수 없습니다. 이 함수는 알려진 재귀 관계를 사용하여 \n    n 쌍의 디스크에 대한 총 이동 횟수를 반복적으로 계산합니다.\n    \n    매개변수:\n    n (int): A 기둥에 있는 디스크 쌍(각각 두 개의 동일한 디스크)의 수.\n\n    반환값:\n    int: A 기둥에서 C 기둥으로 모든 디스크를 이동하는 데 필요한 최소 이동 횟수.\n\n    사례:\n    - n=1일 때, 함수는 2를 반환해야 합니다.\n    - n=2일 때, 함수는 6을 반환해야 합니다.\n    - n=3일 때, 함수는 14를 반환해야 합니다.\n    \"\"\"", "ml": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    n ജോഡികൾ ഡിസ്കുകളുടെ ഡബിൾ-ഡിസ്‌ക് ഹാനോയ് ടവേഴ്സ് പ്രശ്നം പരിഹരിക്കാൻ ആവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n    \n    ഈ ഫംഗ്ഷൻ ആവർത്തനാത്മക ആൽഗോരിതം നടപ്പിലാക്കുന്നു, 2n ഡിസ്കുകൾ A പോളിൽ നിന്ന് C പോളിലേക്ക് \n    ഒരു ഡബിൾ-ഡിസ്‌ക് ഹാനോയ് ടവേഴ്സ് ക്രമീകരണത്തിൽ മാറ്റുന്നതിനുള്ള ആവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം \n    നിർണ്ണയിക്കാൻ, ഓരോ സമയത്തും ഒരു ഡിസ്ക് മാത്രം നീക്കാൻ കഴിയും, ഒരു ചെറിയ ഡിസ്കിന് മുകളിൽ \n    മറ്റൊരു ഡിസ്ക് വയ്ക്കാൻ പാടില്ല എന്ന നിയമങ്ങൾ പാലിച്ച്. ഫംഗ്ഷൻ ഒരു അറിയപ്പെടുന്ന പുനരാവർത്തന ബന്ധം \n    ഉപയോഗിക്കുന്നു, n ജോഡികൾ ഡിസ്കുകൾക്കുള്ള മൊത്തം നീക്കങ്ങളുടെ എണ്ണം ആവർത്തിച്ച് കണക്കാക്കുന്നു.\n    \n    Args:\n    n (int): A പോളിൽ രണ്ട് സമാന ഡിസ്കുകളുള്ള ജോഡികളുടെ എണ്ണം.\n\n    Returns:\n    int: A പോളിൽ നിന്ന് C പോളിലേക്ക് എല്ലാ ഡിസ്കുകളും മാറ്റുന്നതിനുള്ള ആവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം.\n\n    കേസുകൾ:\n    - n=1 ആണെങ്കിൽ, ഫംഗ്ഷൻ 2 മടക്കം വേണം.\n    - n=2 ആണെങ്കിൽ, ഫംഗ്ഷൻ 6 മടക്കം വേണം.\n    - n=3 ആണെങ്കിൽ, ഫംഗ്ഷൻ 14 മടക്കം വേണം.\n    \"\"\"", "fa": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    حداقل تعداد حرکت‌های لازم برای حل مسئله برج‌های هانوی با دیسک‌های دوتایی برای n جفت دیسک را محاسبه کنید.\n    \n    این تابع یک الگوریتم تکراری را برای تعیین حداقل تعداد حرکت‌های لازم برای انتقال 2n دیسک از میله A به میله C \n    در یک تنظیم برج‌های هانوی با دیسک‌های دوتایی پیاده‌سازی می‌کند، با رعایت قوانینی که تنها یک دیسک می‌تواند \n    در هر زمان حرکت کند و هیچ دیسکی نباید روی دیسک کوچکتر قرار گیرد. تابع از یک رابطه بازگشتی شناخته شده \n    استفاده می‌کند و به صورت تکراری تعداد کل حرکت‌ها را برای n جفت دیسک محاسبه می‌کند.\n    \n    آرگومان‌ها:\n    n (int): تعداد جفت دیسک‌ها (هر کدام شامل دو دیسک یکسان) بر روی میله A.\n\n    بازگشت:\n    int: حداقل تعداد حرکت‌های لازم برای انتقال تمام دیسک‌ها از میله A به میله C.\n\n    موارد:\n    - برای n=1، تابع باید 2 را برگرداند.\n    - برای n=2، تابع باید 6 را برگرداند.\n    - برای n=3، تابع باید 14 را برگرداند.\n    \"\"\""}, "canonical_solution": "    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "instruction": {"en": "Write a python function 'def hanoi_double_iterative(n: int) -> int:' to solve the following problem:\n\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2.\n    - For n=2, the function should return 6.\n    - For n=3, the function should return 14.\n    ", "sq": "Shkruani një funksion python 'def hanoi_double_iterative(n: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin minimal të lëvizjeve të nevojshme për të zgjidhur problemin e Kullave të Hanoit me dy disqe për n çifte diskesh.\n    \n    Ky funksion zbaton një algoritëm iterativ për të përcaktuar numrin minimal të lëvizjeve të nevojshme për të transferuar\n    2n disqe nga poli A në polin C në një konfigurim të Kullave të Hanoit me dy disqe, duke ndjekur rregullat që vetëm një disk \n    mund të zhvendoset në një kohë dhe asnjë disk nuk mund të vendoset mbi një disk më të vogël. Funksioni përdor një marrëdhënie të njohur rekursive \n    dhe llogarit në mënyrë iterative numrin total të lëvizjeve për n çifte diskesh.\n    \n    Args:\n    n (int): Numri i çifteve të disqeve (secili prej dy disqeve identike) në polin A.\n\n    Kthen:\n    int: Numri minimal i lëvizjeve të nevojshme për të transferuar të gjitha disqet nga poli A në polin C.\n\n    Raste:\n    - Për n=1, funksioni duhet të kthejë 2.\n    - Për n=2, funksioni duhet të kthejë 6.\n    - Për n=3, funksioni duhet të kthejë 14.", "hy": "Պայթոն ֆունկցիա 'def hanoi_double_iterative(n: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել նվազագույն քայլերի քանակը, որը պահանջվում է կրկնակի սկավառակներով Հանոյի աշտարակների խնդիրը լուծելու համար n զույգ սկավառակների համար:\n    \n    Այս ֆունկցիան իրականացնում է իտերատիվ ալգորիթմ՝ որոշելու համար նվազագույն քայլերի քանակը, որը անհրաժեշտ է 2n սկավառակները A սյունից տեղափոխելու համար C սյունին կրկնակի սկավառակներով Հանոյի աշտարակների կառուցվածքում՝ հետևելով այն կանոններին, որ մեկ անգամում միայն մեկ սկավառակ կարող է տեղափոխվել և ոչ մի սկավառակ չի կարող տեղադրվել ավելի փոքր սկավառակի վրա: Ֆունկցիան օգտագործում է հայտնի ռեկուրսիվ հարաբերություն և իտերատիվ կերպով հաշվարկում է ընդհանուր քայլերի քանակը n զույգ սկավառակների համար:\n    \n    Արգումենտներ:\n    n (int): A սյունում գտնվող սկավառակների զույգերի քանակը (յուրաքանչյուր զույգ բաղկացած է երկու նույնական սկավառակներից):\n\n    Վերադարձնում է:\n    int: Նվազագույն քայլերի քանակը, որը պահանջվում է բոլոր սկավառակները A սյունից C սյուն տեղափոխելու համար:\n\n    Դեպքեր:\n    - Եթե n=1, ֆունկցիան պետք է վերադարձնի 2:\n    - Եթե n=2, ֆունկցիան պետք է վերադարձնի 6:\n    - Եթե n=3, ֆունկցիան պետք է վերադարձնի 14:", "bn": "একটি পাইথন ফাংশন 'def hanoi_double_iterative(n: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    n জোড়া ডিস্কের জন্য ডাবল-ডিস্ক হ্যানয় টাওয়ার সমস্যার সমাধান করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা গণনা করুন।\n    \n    এই ফাংশনটি একটি পুনরাবৃত্তিমূলক অ্যালগরিদম বাস্তবায়ন করে যা ডাবল-ডিস্ক হ্যানয় টাওয়ার সেটআপে A পোল থেকে C পোল পর্যন্ত \n    2n ডিস্ক স্থানান্তরের জন্য প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা নির্ধারণ করে, নিম্নলিখিত নিয়মগুলি অনুসরণ করে যে একবারে \n    শুধুমাত্র একটি ডিস্ক সরানো যেতে পারে এবং কোনো ডিস্ক একটি ছোট ডিস্কের উপরে রাখা যাবে না। ফাংশনটি একটি পরিচিত পুনরাবৃত্ত সম্পর্ক ব্যবহার করে \n    এবং n জোড়া ডিস্কের জন্য মোট পদক্ষেপের সংখ্যা পুনরাবৃত্তিমূলকভাবে গণনা করে।\n    \n    Args:\n    n (int): A পোলের উপর ডিস্ক জোড়ার সংখ্যা (প্রত্যেকটি দুটি অভিন্ন ডিস্কের)।\n\n    Returns:\n    int: A পোল থেকে C পোল পর্যন্ত সমস্ত ডিস্ক স্থানান্তরের জন্য প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা।\n\n    কেস:\n    - n=1 এর জন্য, ফাংশনটি 2 ফেরত দেবে।\n    - n=2 এর জন্য, ফাংশনটি 6 ফেরত দেবে।\n    - n=3 এর জন্য, ফাংশনটি 14 ফেরত দেবে।", "bg": "Напишете Python функция 'def hanoi_double_iterative(n: int) -> int:', за да решите следния проблем:\n\n    Изчислете минималния брой ходове, необходими за решаване на проблема с двойните дискове на Ханойските кули за n двойки дискове.\n    \n    Тази функция реализира итеративен алгоритъм за определяне на минималния брой ходове, необходими за прехвърляне\n    на 2n диска от полюс A към полюс C в настройка на Ханойските кули с двойни дискове, следвайки правилата, че само един диск \n    може да бъде преместен наведнъж и никой диск не може да бъде поставен върху по-малък диск. Функцията използва известна рекурсивна връзка \n    и итеративно изчислява общия брой ходове за n двойки дискове.\n    \n    Аргументи:\n    n (int): Броят на двойките дискове (всяка от две идентични диска) на полюс A.\n\n    Връща:\n    int: Минималният брой ходове, необходими за прехвърляне на всички дискове от полюс A към полюс C.\n\n    Случаи:\n    - За n=1, функцията трябва да върне 2.\n    - За n=2, функцията трябва да върне 6.\n    - За n=3, функцията трябва да върне 14.", "zh": "编写一个 Python 函数 'def hanoi_double_iterative(n: int) -> int:' 来解决以下问题：\n\n    计算解决 n 对圆盘的双圆盘汉诺塔问题所需的最小移动次数。\n    \n    此函数实现了一种迭代算法，以确定在双圆盘汉诺塔设置中，将 2n 个圆盘从 A 杆转移到 C 杆所需的最小移动次数，遵循一次只能移动一个圆盘且不能将圆盘放在比它小的圆盘上的规则。该函数使用已知的递归关系，并迭代计算 n 对圆盘的总移动次数。\n    \n    参数：\n    n (int): A 杆上的圆盘对数（每对由两个相同的圆盘组成）。\n\n    返回：\n    int: 将所有圆盘从 A 杆转移到 C 杆所需的最小移动次数。\n\n    情况：\n    - 对于 n=1，函数应返回 2。\n    - 对于 n=2，函数应返回 6。\n    - 对于 n=3，函数应返回 14。", "fr": "Écrire une fonction python 'def hanoi_double_iterative(n: int) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nombre minimum de mouvements nécessaires pour résoudre le problème des Tours de Hanoï à double disque pour n paires de disques.\n    \n    Cette fonction implémente un algorithme itératif pour déterminer le nombre minimum de mouvements nécessaires pour transférer\n    2n disques du poteau A au poteau C dans une configuration de Tours de Hanoï à double disque, en suivant les règles selon lesquelles un seul disque \n    peut être déplacé à la fois et aucun disque ne peut être placé sur un disque plus petit. La fonction utilise une relation récursive connue \n    et calcule de manière itérative le nombre total de mouvements pour n paires de disques.\n    \n    Args:\n    n (int): Le nombre de paires de disques (chacune de deux disques identiques) sur le poteau A.\n\n    Returns:\n    int: Le nombre minimum de mouvements nécessaires pour transférer tous les disques du poteau A au poteau C.\n\n    Cas:\n    - Pour n=1, la fonction doit retourner 2.\n    - Pour n=2, la fonction doit retourner 6.\n    - Pour n=3, la fonction doit retourner 14.", "de": "Schreiben Sie eine Python-Funktion 'def hanoi_double_iterative(n: int) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die minimale Anzahl von Zügen, die erforderlich sind, um das Doppel-Scheiben-Hanoi-Türme-Problem für n Scheibenpaare zu lösen.\n    \n    Diese Funktion implementiert einen iterativen Algorithmus, um die minimale Anzahl von Zügen zu bestimmen, die notwendig sind, um\n    2n Scheiben vom A-Pfosten zum C-Pfosten in einem Doppel-Scheiben-Hanoi-Türme-Setup zu übertragen, wobei die Regeln befolgt werden, dass jeweils nur eine Scheibe \n    bewegt werden kann und keine Scheibe auf eine kleinere Scheibe gelegt werden darf. Die Funktion verwendet eine bekannte rekursive Relation \n    und berechnet iterativ die Gesamtanzahl der Züge für n Scheibenpaare.\n    \n    Argumente:\n    n (int): Die Anzahl der Scheibenpaare (jeweils zwei identische Scheiben) auf dem A-Pfosten.\n\n    Rückgabewert:\n    int: Die minimale Anzahl von Zügen, die erforderlich sind, um alle Scheiben vom A-Pfosten zum C-Pfosten zu übertragen.\n\n    Fälle:\n    - Für n=1 sollte die Funktion 2 zurückgeben.\n    - Für n=2 sollte die Funktion 6 zurückgeben.\n    - Für n=3 sollte die Funktion 14 zurückgeben.", "ha": "Rubuta wani aikin python 'def hanoi_double_iterative(n: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa mafi ƙarancin adadin motsi da ake buƙata don warware matsalar hasumiyar Hanoi mai faifan diski biyu don n nau'i biyu na diski.\n\n    Wannan aikin yana aiwatar da wani algorithm mai maimaitawa don tantance mafi ƙarancin adadin motsi da ake buƙata don canja wurin\n    2n diski daga sandar A zuwa sandar C a cikin saitin hasumiyar Hanoi mai faifan diski biyu, bisa ga dokokin cewa ana iya motsa faifan diski ɗaya kawai a lokaci guda kuma babu faifan diski da za a iya sanya shi a saman wani ƙarami. Aikin yana amfani da sanannen dangantakar maimaitawa \n    kuma yana lissafin jimillar adadin motsi don n nau'i biyu na diski.\n\n    Args:\n    n (int): Adadin nau'i biyu na diski (kowanne daga cikin diski biyu masu kama) akan sandar A.\n\n    Returns:\n    int: Mafi ƙarancin adadin motsi da ake buƙata don canja dukkan diski daga sandar A zuwa sandar C.\n\n    Cases:\n    - Don n=1, aikin ya kamata ya dawo da 2.\n    - Don n=2, aikin ya kamata ya dawo da 6.\n    - Don n=3, aikin ya kamata ya dawo da 14.", "hi": "एक पायथन फ़ंक्शन 'def hanoi_double_iterative(n: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    n जोड़े डिस्क के लिए डबल-डिस्क हनोई टावर्स समस्या को हल करने के लिए आवश्यक न्यूनतम चालों की संख्या की गणना करें।\n    \n    यह फ़ंक्शन एक पुनरावृत्त एल्गोरिदम को लागू करता है ताकि डबल-डिस्क हनोई टावर्स सेटअप में A पोल से C पोल तक \n    2n डिस्क को स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या निर्धारित की जा सके, इस नियम का पालन करते हुए \n    कि एक समय में केवल एक डिस्क को स्थानांतरित किया जा सकता है और कोई भी डिस्क एक छोटी डिस्क के ऊपर नहीं रखी जा सकती। \n    फ़ंक्शन एक ज्ञात पुनरावृत्त संबंध का उपयोग करता है और n जोड़े डिस्क के लिए कुल चालों की संख्या को पुनरावृत्त रूप से \n    गणना करता है।\n    \n    तर्क:\n    n (int): A पोल पर डिस्क जोड़ों की संख्या (प्रत्येक दो समान डिस्क का)।\n\n    लौटाता है:\n    int: सभी डिस्क को A पोल से C पोल तक स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या।\n\n    मामले:\n    - n=1 के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\n    - n=2 के लिए, फ़ंक्शन को 6 लौटाना चाहिए।\n    - n=3 के लिए, फ़ंक्शन को 14 लौटाना चाहिए।", "hu": "Írj egy python függvényt 'def hanoi_double_iterative(n: int) -> int:' a következő probléma megoldására:\n\n    Számítsd ki a minimális lépések számát, amely szükséges az n pár korongból álló dupla korongos Hanoi tornyok problémájának megoldásához.\n    \n    Ez a függvény egy iteratív algoritmust valósít meg annak meghatározására, hogy hány minimális lépés szükséges ahhoz, hogy 2n korongot áthelyezzünk az A pólusról a C pólusra egy dupla korongos Hanoi tornyok elrendezésben, azokat a szabályokat követve, hogy egyszerre csak egy korong mozgatható, és egy korong sem helyezhető kisebb korong tetejére. A függvény egy ismert rekurzív összefüggést használ, és iteratívan kiszámítja az összes lépés számát n korongpár esetén.\n    \n    Args:\n    n (int): A korongpárok száma (mindegyik két azonos korongból áll) az A póluson.\n\n    Returns:\n    int: A minimális lépések száma, amely szükséges az összes korong áthelyezéséhez az A pólusról a C pólusra.\n\n    Esetek:\n    - Ha n=1, a függvénynek 2-t kell visszaadnia.\n    - Ha n=2, a függvénynek 6-ot kell visszaadnia.\n    - Ha n=3, a függvénynek 14-et kell visszaadnia.", "es": "Escribe una función en Python 'def hanoi_double_iterative(n: int) -> int:' para resolver el siguiente problema:\n\n    Calcular el número mínimo de movimientos necesarios para resolver el problema de las Torres de Hanoi de doble disco para n pares de discos.\n    \n    Esta función implementa un algoritmo iterativo para determinar el número mínimo de movimientos necesarios para transferir\n    2n discos del poste A al poste C en una configuración de Torres de Hanoi de doble disco, siguiendo las reglas de que solo se puede mover un disco \n    a la vez y ningún disco puede colocarse sobre uno más pequeño. La función utiliza una relación recursiva conocida \n    y calcula iterativamente el número total de movimientos para n pares de discos.\n    \n    Argumentos:\n    n (int): El número de pares de discos (cada uno de dos discos idénticos) en el poste A.\n\n    Döndürür:\n    int: El número mínimo de movimientos necesarios para transferir todos los discos del poste A al poste C.\n\n    Casos:\n    - Para n=1, la función debería devolver 2.\n    - Para n=2, la función debería devolver 6.\n    - Para n=3, la función debería devolver 14.", "arb": "اكتب دالة بايثون 'def hanoi_double_iterative(n: int) -> int:' لحل المشكلة التالية:\n\nاحسب الحد الأدنى لعدد الحركات المطلوبة لحل مشكلة أبراج هانوي ذات الأقراص المزدوجة لعدد n من أزواج الأقراص.\n\nتقوم هذه الدالة بتنفيذ خوارزمية تكرارية لتحديد الحد الأدنى لعدد الحركات اللازمة لنقل 2n من الأقراص من العمود A إلى العمود C في إعداد أبراج هانوي ذات الأقراص المزدوجة، مع اتباع القواعد التي تنص على أنه يمكن نقل قرص واحد فقط في كل مرة ولا يجوز وضع قرص فوق قرص أصغر. تستخدم الدالة علاقة تكرارية معروفة وتحسب بشكل تكراري العدد الإجمالي للحركات لعدد n من أزواج الأقراص.\n\nالمعاملات:\nn (int): عدد أزواج الأقراص (كل زوج مكون من قرصين متطابقين) على العمود A.\n\nالقيم المعادة:\nint: الحد الأدنى لعدد الحركات المطلوبة لنقل جميع الأقراص من العمود A إلى العمود C.\n\nالحالات:\n- بالنسبة لـ n=1، يجب أن تعيد الدالة 2.\n- بالنسبة لـ n=2، يجب أن تعيد الدالة 6.\n- بالنسبة لـ n=3، يجب أن تعيد الدالة 14.", "sw": "Andika kazi ya python 'def hanoi_double_iterative(n: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ndogo zaidi ya hatua zinazohitajika kutatua tatizo la Hanoi Towers lenye diski mbili kwa jozi n za diski.\n    \n    Kazi hii inatekeleza algoriti ya kurudia ili kubaini idadi ndogo zaidi ya hatua zinazohitajika kuhamisha\n    diski 2n kutoka nguzo ya A hadi nguzo ya C katika mpangilio wa Hanoi Towers wenye diski mbili, ikifuata sheria kwamba diski moja tu \n    inaweza kuhamishwa kwa wakati mmoja na hakuna diski inayoweza kuwekwa juu ya diski ndogo. Kazi hii inatumia uhusiano wa kurudia unaojulikana \n    na kwa kurudia huhesabu jumla ya idadi ya hatua kwa jozi n za diski.\n    \n    Hoja:\n    n (int): Idadi ya jozi za diski (kila moja ikiwa na diski mbili zinazofanana) kwenye nguzo ya A.\n\n    Inarejesha:\n    int: Idadi ndogo zaidi ya hatua zinazohitajika kuhamisha diski zote kutoka nguzo ya A hadi nguzo ya C.\n\n    Matukio:\n    - Kwa n=1, kazi inapaswa kurudisha 2.\n    - Kwa n=2, kazi inapaswa kurudisha 6.\n    - Kwa n=3, kazi inapaswa kurudisha 14.", "tr": "Bir python fonksiyonu 'def hanoi_double_iterative(n: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    n çift disk için çift diskli Hanoi Kuleleri problemini çözmek için gereken minimum hamle sayısını hesaplayın.\n    \n    Bu fonksiyon, çift diskli Hanoi Kuleleri düzeninde 2n diski A direğinden C direğine aktarmak için gerekli\n    minimum hamle sayısını belirlemek üzere bir iteratif algoritma uygular. Kurallar, aynı anda yalnızca bir diskin \n    hareket ettirilebileceğini ve hiçbir diskin daha küçük bir diskin üzerine yerleştirilemeyeceğini belirtir. Fonksiyon,\n    bilinen bir özyinelemeli ilişkiyi kullanır ve n çift disk için toplam hamle sayısını iteratif olarak hesaplar.\n    \n    Argümanlar:\n    n (int): A direğinde bulunan disk çiftlerinin (her biri iki özdeş diskten oluşan) sayısı.\n\n    Döndürür:\n    int: Tüm diskleri A direğinden C direğine aktarmak için gereken minimum hamle sayısı.\n\n    Durumlar:\n    - n=1 için, fonksiyon 2 döndürmelidir.\n    - n=2 için, fonksiyon 6 döndürmelidir.\n    - n=3 için, fonksiyon 14 döndürmelidir.", "vi": "Viết một hàm python 'def hanoi_double_iterative(n: int) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán số lần di chuyển tối thiểu cần thiết để giải quyết vấn đề Tháp Hà Nội đĩa đôi cho n cặp đĩa.\n    \n    Hàm này triển khai một thuật toán lặp để xác định số lần di chuyển tối thiểu cần thiết để chuyển\n    2n đĩa từ cọc A sang cọc C trong thiết lập Tháp Hà Nội đĩa đôi, tuân theo các quy tắc rằng chỉ có thể di chuyển một đĩa \n    tại một thời điểm và không đĩa nào có thể được đặt lên trên một đĩa nhỏ hơn. Hàm này sử dụng một quan hệ đệ quy đã biết \n    và tính toán lặp đi lặp lại tổng số lần di chuyển cho n cặp đĩa.\n    \n    Tham số:\n    n (int): Số cặp đĩa (mỗi cặp gồm hai đĩa giống hệt nhau) trên cọc A.\n\n    Trả về:\n    int: Số lần di chuyển tối thiểu cần thiết để chuyển tất cả các đĩa từ cọc A sang cọc C.\n\n    Các trường hợp:\n    - Với n=1, hàm nên trả về 2.\n    - Với n=2, hàm nên trả về 6.\n    - Với n=3, hàm nên trả về 14.", "id": "Tulis fungsi python 'def hanoi_double_iterative(n: int) -> int:' untuk menyelesaikan masalah berikut:\n\n    Hitung jumlah minimum gerakan yang diperlukan untuk menyelesaikan masalah Menara Hanoi dengan cakram ganda untuk n pasang cakram.\n    \n    Fungsi ini mengimplementasikan algoritma iteratif untuk menentukan jumlah minimum gerakan yang diperlukan untuk memindahkan\n    2n cakram dari tiang A ke tiang C dalam pengaturan Menara Hanoi cakram ganda, mengikuti aturan bahwa hanya satu cakram \n    yang dapat dipindahkan pada satu waktu dan tidak ada cakram yang boleh ditempatkan di atas cakram yang lebih kecil. Fungsi ini menggunakan hubungan rekursif yang dikenal \n    dan secara iteratif menghitung total jumlah gerakan untuk n pasang cakram.\n    \n    Argumen:\n    n (int): Jumlah pasangan cakram (masing-masing dua cakram identik) pada tiang A.\n\n    Mengembalikan:\n    int: Jumlah minimum gerakan yang diperlukan untuk memindahkan semua cakram dari tiang A ke tiang C.\n\n    Kasus:\n    - Untuk n=1, fungsi harus mengembalikan 2.\n    - Untuk n=2, fungsi harus mengembalikan 6.\n    - Untuk n=3, fungsi harus mengembalikan 14.", "ja": "Python関数を書いてください。 'def hanoi_double_iterative(n: int) -> int:' を作成して、次の問題を解決してください:\n\n    n 組のディスクに対する二重ディスクのハノイの塔問題を解くために必要な最小の移動回数を計算します。\n    \n    この関数は、二重ディスクのハノイの塔の設定で、2n 枚のディスクを A ポールから C ポールに移動するために必要な最小の移動回数を決定する反復アルゴリズムを実装しています。ルールとして、一度に一枚のディスクしか移動できず、どのディスクも小さいディスクの上に置くことはできません。この関数は既知の再帰関係を使用し、n 組のディスクに対する総移動回数を反復的に計算します。\n    \n    引数:\n    n (int): A ポール上のディスクのペア数（各ペアは同一の2枚のディスク）。\n\n    戻り値:\n    int: すべてのディスクを A ポールから C ポールに移動するために必要な最小の移動回数。\n\n    ケース:\n    - n=1 の場合、関数は 2 を返すべきです。\n    - n=2 の場合、関数は 6 を返すべきです。\n    - n=3 の場合、関数は 14 を返すべきです。", "ko": "파이썬 함수 'def hanoi_double_iterative(n: int) -> int:'를 작성하여 다음 문제를 해결하십시오:\n\n    n 쌍의 디스크에 대한 이중 디스크 하노이 탑 문제를 해결하는 데 필요한 최소 이동 횟수를 계산합니다.\n    \n    이 함수는 이중 디스크 하노이 탑 설정에서 2n개의 디스크를 A 기둥에서 C 기둥으로 옮기는 데 필요한 최소 이동 횟수를 \n    결정하기 위해 반복 알고리즘을 구현합니다. 이때 한 번에 하나의 디스크만 이동할 수 있으며 작은 디스크 위에 \n    큰 디스크를 놓을 수 없습니다. 이 함수는 알려진 재귀 관계를 사용하여 n 쌍의 디스크에 대한 총 이동 횟수를 반복적으로 계산합니다.\n    \n    매개변수:\n    n (int): A 기둥에 있는 디스크 쌍(각각 두 개의 동일한 디스크)의 수.\n\n    반환값:\n    int: 모든 디스크를 A 기둥에서 C 기둥으로 옮기는 데 필요한 최소 이동 횟수.\n\n    사례:\n    - n=1일 때, 함수는 2를 반환해야 합니다.\n    - n=2일 때, 함수는 6을 반환해야 합니다.\n    - n=3일 때, 함수는 14를 반환해야 합니다.", "ml": "'def hanoi_double_iterative(n: int) -> int:' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    n ജോഡികളായ ഡിസ്കുകൾക്കായി ഡബിൾ-ഡിസ്‌ക് ഹനോയ് ടവറുകൾ പ്രശ്നം പരിഹരിക്കാൻ ആവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n    \n    ഈ ഫംഗ്ഷൻ ആവർത്തനാത്മകമായ ഒരു ആൽഗോരിതം നടപ്പിലാക്കുന്നു, 2n ഡിസ്കുകൾ A പോളിൽ നിന്ന് C പോളിലേക്ക് \n    ഡബിൾ-ഡിസ്‌ക് ഹനോയ് ടവറുകൾ ക്രമീകരണത്തിൽ മാറ്റുന്നതിനായി ആവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം \n    നിർണ്ണയിക്കാൻ, ഓരോ തവണയും ഒരു ഡിസ്‌ക് മാത്രമേ നീക്കാൻ കഴിയൂ, കൂടാതെ ചെറിയ ഡിസ്‌കിന് മുകളിൽ \n    മറ്റേതെങ്കിലും ഡിസ്‌ക് വയ്ക്കാൻ പാടില്ല എന്ന നിയമങ്ങൾ പാലിച്ച്. ഫംഗ്ഷൻ ഒരു അറിയപ്പെടുന്ന പുനരാവർത്തന \n    ബന്ധം ഉപയോഗിക്കുന്നു, n ജോഡികളായ ഡിസ്കുകൾക്കായുള്ള മൊത്തം നീക്കങ്ങളുടെ എണ്ണം ആവർത്തനാത്മകമായി \n    കണക്കാക്കുന്നു.\n    \n    Args:\n    n (int): A പോളിൽ ഉള്ള ഡിസ്‌ക് ജോഡികളുടെ എണ്ണം (ഓരോന്നും രണ്ട് ഒരേപോലുള്ള ഡിസ്കുകൾ).\n\n    Returns:\n    int: A പോളിൽ നിന്ന് C പോളിലേക്ക് എല്ലാ ഡിസ്കുകളും മാറ്റുന്നതിനായി ആവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം.\n\n    കേസുകൾ:\n    - n=1 ആണെങ്കിൽ, ഫംഗ്ഷൻ 2 മടക്കം വേണം.\n    - n=2 ആണെങ്കിൽ, ഫംഗ്ഷൻ 6 മടക്കം വേണം.\n    - n=3 ആണെങ്കിൽ, ഫംഗ്ഷൻ 14 മടക്കം വേണം.", "fa": "یک تابع پایتون بنویسید 'def hanoi_double_iterative(n: int) -> int:' برای حل مسئله زیر:\n\n    حداقل تعداد حرکات لازم برای حل مسئله برج‌های هانوی با دیسک‌های دوتایی برای n جفت دیسک را محاسبه کنید.\n    \n    این تابع یک الگوریتم تکراری را پیاده‌سازی می‌کند تا حداقل تعداد حرکات لازم برای انتقال\n    2n دیسک از قطب A به قطب C در یک تنظیم برج‌های هانوی با دیسک‌های دوتایی را تعیین کند، با رعایت قوانینی که تنها یک دیسک \n    می‌تواند در هر زمان جابجا شود و هیچ دیسکی نباید بر روی دیسکی کوچکتر قرار گیرد. تابع از یک رابطه بازگشتی شناخته‌شده \n    استفاده می‌کند و به صورت تکراری تعداد کل حرکات برای n جفت دیسک را محاسبه می‌کند.\n    \n    آرگومان‌ها:\n    n (int): تعداد جفت دیسک‌ها (هر کدام شامل دو دیسک یکسان) بر روی قطب A.\n\n    بازگشت:\n    int: حداقل تعداد حرکات لازم برای انتقال تمام دیسک‌ها از قطب A به قطب C.\n\n    موارد:\n    - برای n=1، تابع باید 2 را برگرداند.\n    - برای n=2، تابع باید 6 را برگرداند.\n    - برای n=3، تابع باید 14 را برگرداند."}, "level": "easy", "test": "def test_hanoi_double_iterative():\n    # Test case 1: n = 1\n    assert hanoi_double_iterative(1) == 2, \"Test case 1 failed\"\n\n    # Test case 2: n = 2\n    assert hanoi_double_iterative(2) == 6, \"Test case 2 failed\"\n\n    # Test case 3: n = 3\n    assert hanoi_double_iterative(3) == 14, \"Test case 3 failed\"\n\n    # Additional test cases can be added based on computed or known results\n    # Test case 4: n = 4 (computed using the formula)\n    assert hanoi_double_iterative(4) == 30, \"Test case 4 failed\"\n\n    # Test case 5: n = 5 (computed using the formula)\n    assert hanoi_double_iterative(5) == 62, \"Test case 5 failed\"\n\n    # Test case 6: Large n, n = 10 (computed using the formula or a trusted source)\n    assert hanoi_double_iterative(10) == 2046, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_hanoi_double_iterative()", "entry_point": "hanoi_double_iterative", "signature": "def hanoi_double_iterative(n: int) -> int:", "docstring": {"en": "\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2.\n    - For n=2, the function should return 6.\n    - For n=3, the function should return 14.\n    ", "sq": "\n    Llogarit numrin minimal të lëvizjeve të nevojshme për të zgjidhur problemin e Kullave të Hanoi-t me dy disqe për n çifte diskesh.\n    \n    Kjo funksion implementon një algoritëm iterativ për të përcaktuar numrin minimal të lëvizjeve të nevojshme për të transferuar\n    2n disqe nga shtylla A në shtyllën C në një konfigurim të Kullave të Hanoi-t me dy disqe, duke ndjekur rregullat që vetëm një disk \n    mund të zhvendoset në një kohë dhe asnjë disk nuk mund të vendoset mbi një disk më të vogël. Funksioni përdor një marrëdhënie të njohur rekursive \n    dhe llogarit në mënyrë iterative numrin total të lëvizjeve për n çifte diskesh.\n    \n    Args:\n    n (int): Numri i çifteve të disqeve (secili prej dy disqeve identikë) në shtyllën A.\n\n    Returns:\n    int: Numri minimal i lëvizjeve të nevojshme për të transferuar të gjitha disqet nga shtylla A në shtyllën C.\n\n    Raste:\n    - Për n=1, funksioni duhet të kthejë 2.\n    - Për n=2, funksioni duhet të kthejë 6.\n    - Për n=3, funksioni duhet të kthejë 14.", "hy": "\n    Հաշվեք նվազագույն քայլերի քանակը, որը պահանջվում է լուծելու համար կրկնակի սկավառակների Հանոյյան աշտարակների խնդիրը n զույգ սկավառակների համար։\n    \n    Այս ֆունկցիան իրականացնում է իտերատիվ ալգորիթմ՝ որոշելու համար նվազագույն քայլերի քանակը, որը անհրաժեշտ է 2n սկավառակները A սյունակից C սյունակ տեղափոխելու համար կրկնակի սկավառակների Հանոյյան աշտարակների կարգավորումով՝ հետևելով այն կանոններին, որ մեկ անգամում միայն մեկ սկավառակ կարող է տեղափոխվել, և ոչ մի սկավառակ չի կարող տեղադրվել ավելի փոքր սկավառակի վրա։ Ֆունկցիան օգտագործում է հայտնի ռեկուրսիվ հարաբերություն և իտերատիվ կերպով հաշվում է ընդհանուր քայլերի քանակը n զույգ սկավառակների համար։\n    \n    Արգումենտներ:\n    n (int): A սյունակում գտնվող սկավառակների զույգերի քանակը (յուրաքանչյուր զույգը բաղկացած է երկու նույնական սկավառակներից)։\n\n    Վերադարձնում է:\n    int: Նվազագույն քայլերի քանակը, որը պահանջվում է բոլոր սկավառակները A սյունակից C սյունակ տեղափոխելու համար։\n\n    Դեպքեր:\n    - Երբ n=1, ֆունկցիան պետք է վերադարձնի 2։\n    - Երբ n=2, ֆունկցիան պետք է վերադարձնի 6։\n    - Երբ n=3, ֆունկցիան պետք է վերադարձնի 14։", "bn": "\n    n জোড়া ডিস্কের জন্য ডাবল-ডিস্ক হ্যানয় টাওয়ার সমস্যার সমাধান করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা গণনা করুন।\n    \n    এই ফাংশনটি একটি পুনরাবৃত্তিমূলক অ্যালগরিদম প্রয়োগ করে যা ডাবল-ডিস্ক হ্যানয় টাওয়ার সেটআপে 2n ডিস্ককে A পোল থেকে C পোল পর্যন্ত স্থানান্তর করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা নির্ধারণ করে, এই নিয়মগুলি অনুসরণ করে যে একবারে শুধুমাত্র একটি ডিস্ক সরানো যেতে পারে এবং কোনও ডিস্ক ছোট ডিস্কের উপরে রাখা যাবে না। ফাংশনটি একটি পরিচিত পুনরাবৃত্ত সম্পর্ক ব্যবহার করে এবং n জোড়া ডিস্কের জন্য মোট পদক্ষেপের সংখ্যা পুনরাবৃত্তিমূলকভাবে গণনা করে।\n    \n    Args:\n    n (int): A পোলের উপর ডিস্কের জোড়ার সংখ্যা (প্রতিটি দুটি অভিন্ন ডিস্কের)।\n\n    Returns:\n    int: সমস্ত ডিস্ককে A পোল থেকে C পোল পর্যন্ত স্থানান্তর করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা।\n\n    উদাহরণসমূহ:\n    - n=1 এর জন্য, ফাংশনটি 2 ফেরত দেওয়া উচিত।\n    - n=2 এর জন্য, ফাংশনটি 6 ফেরত দেওয়া উচিত।\n    - n=3 এর জন্য, ফাংশনটি 14 ফেরত দেওয়া উচিত।", "bg": "\n    Изчислете минималния брой ходове, необходими за решаване на проблема с двойните дискове на Ханойските кули за n двойки дискове.\n    \n    Тази функция реализира итеративен алгоритъм за определяне на минималния брой ходове, необходими за преместване\n    на 2n диска от стълб A към стълб C в настройка на Ханойските кули с двойни дискове, следвайки правилата, че само един диск \n    може да бъде преместен наведнъж и никой диск не може да бъде поставен върху по-малък диск. Функцията използва известна рекурсивна връзка \n    и итеративно изчислява общия брой ходове за n двойки дискове.\n    \n    Аргументи:\n    n (int): Броят на двойките дискове (всяка от два идентични диска) на стълб A.\n\n    Връща:\n    int: Минималният брой ходове, необходими за преместване на всички дискове от стълб A към стълб C.\n\n    Случаи:\n    - За n=1, функцията трябва да върне 2.\n    - За n=2, функцията трябва да върне 6.\n    - За n=3, функцията трябва да върне 14.", "zh": "\n    计算解决双盘汉诺塔问题所需的最小移动次数，对于 n 对圆盘。\n    \n    此函数实现了一个迭代算法，以确定在双盘汉诺塔设置中，将 2n 个圆盘从 A 柱移动到 C 柱所需的最小移动次数，\n    遵循的规则是一次只能移动一个圆盘，并且不能将圆盘放在比它小的圆盘上。\n    该函数使用已知的递归关系，并迭代计算 n 对圆盘的总移动次数。\n    \n    参数:\n    n (int): A 柱上的圆盘对数（每对由两个相同的圆盘组成）。\n\n    返回:\n    int: 将所有圆盘从 A 柱移动到 C 柱所需的最小移动次数。\n\n    情况:\n    - 对于 n=1，函数应返回 2。\n    - 对于 n=2，函数应返回 6。\n    - 对于 n=3，函数应返回 14。", "fr": "\n    Calculer le nombre minimum de mouvements nécessaires pour résoudre le problème des Tours de Hanoï à double disque pour n paires de disques.\n    \n    Cette fonction implémente un algorithme itératif pour déterminer le nombre minimum de mouvements nécessaires pour transférer\n    2n disques du poteau A au poteau C dans une configuration de Tours de Hanoï à double disque, en suivant les règles selon lesquelles un seul disque \n    peut être déplacé à la fois et aucun disque ne peut être placé sur un disque plus petit. La fonction utilise une relation récursive connue \n    et calcule itérativement le nombre total de mouvements pour n paires de disques.\n    \n    Args:\n    n (int): Le nombre de paires de disques (chacune de deux disques identiques) sur le poteau A.\n\n    Returns:\n    int: Le nombre minimum de mouvements nécessaires pour transférer tous les disques du poteau A au poteau C.\n\n    Cas:\n    - Pour n=1, la fonction doit retourner 2.\n    - Pour n=2, la fonction doit retourner 6.\n    - Pour n=3, la fonction doit retourner 14.", "de": "\n    Berechne die minimale Anzahl von Zügen, die erforderlich sind, um das Doppelscheiben-Hanoi-Türme-Problem für n Scheibenpaare zu lösen.\n    \n    Diese Funktion implementiert einen iterativen Algorithmus, um die minimale Anzahl von Zügen zu bestimmen, die notwendig sind, um\n    2n Scheiben vom A-Pfosten zum C-Pfosten in einem Doppelscheiben-Hanoi-Türme-Aufbau zu übertragen, wobei die Regeln befolgt werden, dass nur eine Scheibe \n    gleichzeitig bewegt werden darf und keine Scheibe auf eine kleinere Scheibe gelegt werden darf. Die Funktion verwendet eine bekannte rekursive Beziehung \n    und berechnet iterativ die Gesamtanzahl der Züge für n Scheibenpaare.\n    \n    Args:\n    n (int): Die Anzahl der Scheibenpaare (jeweils zwei identische Scheiben) auf dem A-Pfosten.\n\n    Returns:\n    int: Die minimale Anzahl von Zügen, die erforderlich ist, um alle Scheiben vom A-Pfosten zum C-Pfosten zu übertragen.\n\n    Fälle:\n    - Für n=1 sollte die Funktion 2 zurückgeben.\n    - Für n=2 sollte die Funktion 6 zurückgeben.\n    - Für n=3 sollte die Funktion 14 zurückgeben.", "ha": "\n    Lissafa mafi ƙarancin yawan motsi da ake buƙata don warware matsalar hasumiyar Hanoi mai faifan diski biyu don nau'i-nau'i na diski n.\n    \n    Wannan aikin yana aiwatar da wani tsari mai maimaitawa don ƙayyade mafi ƙarancin yawan motsi da ake buƙata don canja wurin\n    diski 2n daga sandar A zuwa sandar C a cikin saitin hasumiyar Hanoi mai faifan diski biyu, bisa ga dokokin da ke cewa ana iya motsa faifan diski ɗaya kawai a lokaci guda kuma ba za a iya sanya faifan diski a kan wani ƙaramin faifan diski ba. Aikin yana amfani da wata sananniyar dangantaka mai maimaitawa \n    kuma yana lissafin jimillar yawan motsi don nau'i-nau'i na diski n.\n    \n    Args:\n    n (int): Yawan nau'i-nau'i na diski (kowanne na diski guda biyu iri ɗaya) akan sandar A.\n\n    Returns:\n    int: Mafi ƙarancin yawan motsi da ake buƙata don canja wurin dukkan diski daga sandar A zuwa sandar C.\n\n    Cases:\n    - Don n=1, aikin ya kamata ya dawo da 2.\n    - Don n=2, aikin ya kamata ya dawo da 6.\n    - Don n=3, aikin ya kamata ya dawo da 14.", "hi": "\n    दोहरे-डिस्क हनोई टावर्स समस्या को हल करने के लिए आवश्यक न्यूनतम चालों की गणना करें, जिसमें n जोड़े डिस्क होते हैं।\n    \n    यह फ़ंक्शन एक पुनरावृत्त एल्गोरिदम को लागू करता है ताकि दोहरे-डिस्क हनोई टावर्स सेटअप में A पोल से C पोल तक 2n डिस्क को स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या निर्धारित की जा सके, इस नियम का पालन करते हुए कि एक समय में केवल एक डिस्क को ही स्थानांतरित किया जा सकता है और कोई भी डिस्क छोटी डिस्क के ऊपर नहीं रखी जा सकती। यह फ़ंक्शन एक ज्ञात पुनरावर्ती संबंध का उपयोग करता है और n जोड़े डिस्क के लिए कुल चालों की संख्या को पुनरावृत्त रूप से गणना करता है।\n    \n    Args:\n    n (int): A पोल पर डिस्क के जोड़ों की संख्या (प्रत्येक दो समान डिस्क का एक जोड़ा)।\n\n    Returns:\n    int: सभी डिस्क को A पोल से C पोल तक स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या।\n\n    Cases:\n    - n=1 के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\n    - n=2 के लिए, फ़ंक्शन को 6 लौटाना चाहिए।\n    - n=3 के लिए, फ़ंक्शन को 14 लौटाना चाहिए।", "hu": "\n    Számítsa ki a minimális lépésszámot, amely szükséges a dupla korongos Hanoi tornyok problémájának megoldásához n korongpár esetén.\n    \n    Ez a függvény egy iteratív algoritmust valósít meg annak meghatározására, hogy hány minimális lépés szükséges 2n korong áthelyezéséhez az A rúdról a C rúdra egy dupla korongos Hanoi tornyok elrendezésben, azzal a szabállyal, hogy egyszerre csak egy korong mozgatható, és egy korong sem helyezhető kisebb korong tetejére. A függvény egy ismert rekurzív összefüggést használ, és iteratívan számítja ki a teljes lépésszámot n korongpár esetén.\n    \n    Args:\n    n (int): A korongpárok száma (mindegyik két azonos korong) az A rúdon.\n\n    Returns:\n    int: A minimális lépésszám, amely szükséges az összes korong áthelyezéséhez az A rúdról a C rúdra.\n\n    Esetek:\n    - Ha n=1, a függvénynek 2-t kell visszaadnia.\n    - Ha n=2, a függvénynek 6-ot kell visszaadnia.\n    - Ha n=3, a függvénynek 14-et kell visszaadnia.", "es": "\n    Calcular el número mínimo de movimientos necesarios para resolver el problema de las Torres de Hanoi de doble disco para n pares de discos.\n\nEsta función implementa un algoritmo iterativo para determinar el número mínimo de movimientos necesarios para transferir 2n discos del poste A al poste C en una configuración de Torres de Hanoi de doble disco, siguiendo las reglas de que solo se puede mover un disco a la vez y ningún disco puede ser colocado sobre un disco más pequeño. La función utiliza una relación recursiva conocida y calcula iterativamente el número total de movimientos para n pares de discos.\n\nArgumentos:\nn (int): El número de pares de discos (cada uno de dos discos idénticos) en el poste A.\n\nDevuelve:\nint: El número mínimo de movimientos necesarios para transferir todos los discos del poste A al poste C.\n\nCases:\n- Para n=1, la función debería devolver 2.\n- Para n=2, la función debería devolver 6.\n- Para n=3, la función debería devolver 14.", "arb": "\n    د n من أزواج الأقراص.\n    \n    تقوم هذه الدالة بتنفيذ خوارزمية تكرارية لتحديد الحد الأدنى لعدد الحركات اللازمة لنقل 2n من الأقراص من العمود A إلى العمود C في إعداد أبراج هانوي ذات القرص المزدوج، مع اتباع القواعد التي تنص على أنه يمكن نقل قرص واحد فقط في كل مرة ولا يجوز وضع أي قرص فوق قرص أصغر. تستخدم الدالة علاقة تكرارية معروفة وتحسب تكرارياً العدد الإجمالي للحركات لعدد n من أزواج الأقراص.\n    \n    يعيدالحجج:\n    n (int): عدد أزواج الأقراص (كل زوج يتكون من قرصين متطابقين) على العمود A.\n\n    يعيد:\n    int: الحد الأدنى لعدد الحركات المطلوبة لنقل جميع الأقراص من العمود A إلى العمود C.\n\n    Cases:\n    - بالنسبة لـ n=1، يجب أن تعيد الدالة 2.\n    - بالنسبة لـ n=2، يجب أن تعيد الدالة 6.\n    - بالنسبة لـ n=3، يجب أن تعيد الدالة 14.", "sw": "\n    Hesabu idadi ndogo ya hatua zinazohitajika kutatua tatizo la Hanoi Towers lenye diski mbili kwa jozi n za diski.\n    \n    Kazi hii inatekeleza algoriti ya kurudia ili kubaini idadi ndogo ya hatua zinazohitajika kuhamisha\n    diski 2n kutoka nguzo A hadi nguzo C katika mpangilio wa Hanoi Towers wenye diski mbili, kufuatia sheria kwamba diski moja tu \n    inaweza kuhamishwa kwa wakati mmoja na hakuna diski inayoweza kuwekwa juu ya diski ndogo. Kazi hii inatumia uhusiano wa kurudia unaojulikana \n    na inahesabu kwa kurudia jumla ya idadi ya hatua kwa jozi n za diski.\n    \n    Hoja:\n    n (int): Idadi ya jozi za diski (kila moja ikiwa na diski mbili zinazofanana) kwenye nguzo A.\n\n    Inarejesha:\n    int: Idadi ndogo ya hatua zinazohitajika kuhamisha diski zote kutoka nguzo A hadi nguzo C.\n\n    Matukio:\n    - Kwa n=1, kazi inapaswa kurejesha 2.\n    - Kwa n=2, kazi inapaswa kurejesha 6.\n    - Kwa n=3, kazi inapaswa kurejesha 14.", "tr": "\n    Çift diskli Hanoi Kuleleri problemini n çift disk için çözmek üzere gereken minimum hamle sayısını hesaplayın.\n    \n    Bu fonksiyon, çift diskli Hanoi Kuleleri düzeninde 2n diski A direğinden C direğine aktarmak için gereken minimum \n    hamle sayısını belirlemek üzere iteratif bir algoritma uygular. Kurallar, yalnızca bir diskin bir seferde \n    taşınabileceğini ve hiçbir diskin daha küçük bir diskin üzerine yerleştirilemeyeceğini belirtir. Fonksiyon, bilinen \n    bir özyinelemeli ilişkiyi kullanır ve n çift disk için toplam hamle sayısını iteratif olarak hesaplar.\n    \n    Argümanlar:\n    n (int): A direğinde bulunan disk çiftlerinin (her biri iki özdeş diskten oluşan) sayısı.\n\n    Döndürür:\n    int: Tüm diskleri A direğinden C direğine aktarmak için gereken minimum hamle sayısı.\n\n    Durumlar:\n    - n=1 için, fonksiyon 2 döndürmelidir.\n    - n=2 için, fonksiyon 6 döndürmelidir.\n    - n=3 için, fonksiyon 14 döndürmelidir.", "vi": "\n    Tính toán số lần di chuyển tối thiểu cần thiết để giải quyết vấn đề Tháp Hà Nội hai đĩa cho n cặp đĩa.\n    \n    Hàm này triển khai một thuật toán lặp để xác định số lần di chuyển tối thiểu cần thiết để chuyển\n    2n đĩa từ cột A sang cột C trong thiết lập Tháp Hà Nội hai đĩa, tuân theo các quy tắc chỉ có thể di chuyển một đĩa \n    tại một thời điểm và không đĩa nào có thể được đặt lên trên một đĩa nhỏ hơn. Hàm này sử dụng một quan hệ đệ quy đã biết \n    và tính toán lặp đi lặp lại tổng số lần di chuyển cho n cặp đĩa.\n\n    Tham số:\n    n (int): Số cặp đĩa (mỗi cặp gồm hai đĩa giống hệt nhau) trên cột A.\n\n    Trả về:\n    int: Số lần di chuyển tối thiểu cần thiết để chuyển tất cả các đĩa từ cột A sang cột C.\n\n    Trường hợp:\n    - Với n=1, hàm nên trả về 2.\n    - Với n=2, hàm nên trả về 6.\n    - Với n=3, hàm nên trả về 14.", "id": "Menghitung jumlah minimum gerakan yang diperlukan untuk menyelesaikan masalah Menara Hanoi dengan dua cakram untuk n pasang cakram.\n\nFungsi ini mengimplementasikan algoritma iteratif untuk menentukan jumlah minimum gerakan yang diperlukan untuk memindahkan 2n cakram dari tiang A ke tiang C dalam pengaturan Menara Hanoi dengan dua cakram, mengikuti aturan bahwa hanya satu cakram yang dapat dipindahkan pada satu waktu dan tidak ada cakram yang boleh ditempatkan di atas cakram yang lebih kecil. Fungsi ini menggunakan hubungan rekursif yang dikenal dan secara iteratif menghitung jumlah total gerakan untuk n pasang cakram.\n\nArgs:\nn (int): Jumlah pasangan cakram (masing-masing terdiri dari dua cakram identik) pada tiang A.\n\nReturns:\nint: Jumlah minimum gerakan yang diperlukan untuk memindahkan semua cakram dari tiang A ke tiang C.\n\nKasus:\n- Untuk n=1, fungsi harus mengembalikan 2.\n- Untuk n=2, fungsi harus mengembalikan 6.\n- Untuk n=3, fungsi harus mengembalikan 14.", "ja": "    ダブルディスクハノイの塔問題をn組のディスクで解くために必要な最小の移動回数を計算します。\n\n    この関数は、ダブルディスクハノイの塔の設定で、2n枚のディスクをAポールからCポールに移動するために必要な最小の移動回数を決定するための反復アルゴリズムを実装しています。ルールとして、一度に1枚のディスクしか移動できず、小さなディスクの上にディスクを置くことはできません。この関数は既知の再帰関係を使用し、n組のディスクに対する総移動回数を反復的に計算します。\n\n    引数:\n    n (int): Aポール上のディスクペアの数（それぞれ2枚の同一ディスク）。\n\n    戻り値:\n    int: すべてのディスクをAポールからCポールに移動するために必要な最小の移動回数。\n\n    ケース:\n    - n=1の場合、関数は2を返すべきです。\n    - n=2の場合、関数は6を返すべきです。\n    - n=3の場合、関数は14を返すべきです。", "ko": "    n 쌍의 디스크에 대한 이중 디스크 하노이 탑 문제를 해결하는 데 필요한 최소 이동 횟수를 계산합니다.\n    \n    이 함수는 이중 디스크 하노이 탑 설정에서 2n개의 디스크를 A 기둥에서 C 기둥으로 옮기는 데 필요한 최소 이동 횟수를 결정하기 위해 반복 알고리즘을 구현합니다. \n    한 번에 하나의 디스크만 이동할 수 있으며 작은 디스크 위에 다른 디스크를 놓을 수 없다는 규칙을 따릅니다. \n    함수는 알려진 재귀 관계를 사용하여 n 쌍의 디스크에 대한 총 이동 횟수를 반복적으로 계산합니다.\n    \n    Args:\n    n (int): A 기둥에 있는 디스크 쌍(각각 두 개의 동일한 디스크)의 수.\n\n    Returns:\n    int: 모든 디스크를 A 기둥에서 C 기둥으로 옮기는 데 필요한 최소 이동 횟수.\n\n    Cases:\n    - n=1인 경우, 함수는 2를 반환해야 합니다.\n    - n=2인 경우, 함수는 6을 반환해야 합니다.\n    - n=3인 경우, 함수는 14를 반환해야 합니다.", "ml": "    ഡബിൾ-ഡിസ്‌ക് ഹനോയ് ടവേഴ്സ് പ്രശ്നം n ജോഡികൾ ഉള്ള ഡിസ്‌കുകൾക്കായി പരിഹരിക്കാൻ ആവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം കണക്കാക്കുക.\n    \n    ഡബിൾ-ഡിസ്‌ക് ഹനോയ് ടവേഴ്സ് ക്രമീകരണത്തിൽ 2n ഡിസ്‌കുകൾ A പോളിൽ നിന്ന് C പോളിലേക്ക് മാറ്റാൻ ആവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം നിർണയിക്കാൻ പുനരാവർത്തന ആൽഗോരിതം നടപ്പിലാക്കുന്നു, ഒരു സമയത്ത് ഒരു ഡിസ്‌ക് മാത്രമേ നീക്കാൻ പാടുള്ളൂ, കൂടാതെ ചെറിയ ഡിസ്‌കിന്റെ മുകളിൽ ഒരു ഡിസ്‌കും വയ്ക്കാൻ പാടില്ല എന്ന നിയമങ്ങൾ പാലിക്കുന്നു. ഈ ഫങ്ഷൻ അറിയപ്പെടുന്ന പുനരാവർത്തന ബന്ധം ഉപയോഗിക്കുന്നു, n ജോഡികൾ ഉള്ള ഡിസ്‌കുകൾക്കായി മൊത്തം നീക്കങ്ങളുടെ എണ്ണം പുനരാവർത്തിച്ച് കണക്കാക്കുന്നു.\n    \n    Args:\n    n (int): A പോളിൽ രണ്ട് സമാനമായ ഡിസ്‌കുകൾ അടങ്ങിയ ഓരോ ജോഡികളുടെയും എണ്ണം.\n\n    Returns:\n    int: എല്ലാ ഡിസ്‌കുകളും A പോളിൽ നിന്ന് C പോളിലേക്ക് മാറ്റാൻ ആവശ്യമായ കുറഞ്ഞ നീക്കങ്ങളുടെ എണ്ണം.\n\n    Cases:\n    - n=1 ആണെങ്കിൽ, ഫങ്ഷൻ 2 മടക്കണം.\n    - n=2 ആണെങ്കിൽ, ഫങ്ഷൻ 6 മടക്കണം.\n    - n=3 ആണെങ്കിൽ, ഫങ്ഷൻ 14 മടക്കണം.", "fa": "محاسبه حداقل تعداد حرکت‌های لازم برای حل مسئله برج‌های هانوی با دیسک‌های دوتایی برای n جفت دیسک.\n\nاین تابع یک الگوریتم تکراری را پیاده‌سازی می‌کند تا حداقل تعداد حرکت‌های لازم برای انتقال 2n دیسک از میله A به میله C در یک تنظیم برج‌های هانوی با دیسک‌های دوتایی را تعیین کند، با رعایت قوانینی که تنها یک دیسک می‌تواند در هر زمان حرکت کند و هیچ دیسکی نباید بر روی دیسک کوچکتر قرار گیرد. این تابع از یک رابطه بازگشتی شناخته‌شده استفاده می‌کند و به صورت تکراری تعداد کل حرکت‌ها را برای n جفت دیسک محاسبه می‌کند.\n\nArgs:\nn (int): تعداد جفت دیسک‌ها (هر کدام شامل دو دیسک یکسان) روی میله A.\n\nReturns:\nint: حداقل تعداد حرکت‌های لازم برای انتقال تمام دیسک‌ها از میله A به میله C.\n\nCases:\n- برای n=1، تابع باید 2 را برگرداند.\n- برای n=2، تابع باید 6 را برگرداند.\n- برای n=3، تابع باید 14 را برگرداند."}}
{"task_id": "Python/50", "prompt": {"en": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "sq": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Llogarit numrin total të cigareve që Peter mund të pijë.\n    Peter fillon me n cigare dhe mund të shkëmbejë k bishta për një cigare të re.\n    Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve,\n    dhe k është numri i bishtave të cigareve të nevojshme për të shkëmbyer për një cigare të re.\n    Funksioni kthen numrin total të cigareve që Peter mund të pijë.\n    Shembull:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "hy": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Հաշվում է ընդհանուր ծխախոտների քանակը, որը կարող է ծխել Փիթերը:\n    Փիթերը սկսում է n ծխախոտներով և կարող է փոխանակել k մնացորդներ մեկ նոր ծխախոտի համար:\n    Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ը ծխախոտների սկզբնական քանակն է,\n    իսկ k-ն այն մնացորդների քանակն է, որոնք անհրաժեշտ են մեկ նոր ծխախոտի փոխանակման համար:\n    Ֆունկցիան վերադարձնում է ընդհանուր ծխախոտների քանակը, որը կարող է ծխել Փիթերը:\n    Օրինակ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "bn": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    পিটার মোট কতগুলি সিগারেট খেতে পারবে তা গণনা করে।\n    পিটার n সিগারেট দিয়ে শুরু করে এবং k টুকরো অবশিষ্টাংশের বিনিময়ে একটি নতুন সিগারেট পেতে পারে।\n    ফাংশনটি দুটি আর্গুমেন্ট নেয়, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা,\n    এবং k হল একটি নতুন সিগারেটের বিনিময়ে প্রয়োজনীয় সিগারেট অবশিষ্টাংশের সংখ্যা।\n    ফাংশনটি পিটার মোট কতগুলি সিগারেট খেতে পারবে তা ফেরত দেয়।\n    উদাহরণ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "bg": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Изчислява общия брой цигари, които Петър може да изпуши.\n    Петър започва с n цигари и може да размени k фасове за една нова цигара.\n    Функцията приема два аргумента, n и k, където n е началният брой цигари,\n    а k е броят на фасовете, необходими за размяна за една нова цигара.\n    Функцията връща общия брой цигари, които Петър може да изпуши.\n    Пример:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "zh": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    计算Peter可以抽的香烟总数。\n    Peter开始时有n支香烟，可以用k个烟蒂换一支新香烟。\n    该函数接受两个参数，n和k，其中n是初始香烟数量，\n    k是换取一支新香烟所需的烟蒂数量。\n    该函数返回Peter可以抽的香烟总数。\n    示例:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "fr": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calcule le nombre total de cigarettes que Peter peut fumer.\n    Peter commence avec n cigarettes et peut échanger k mégots contre une nouvelle cigarette.\n    La fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes,\n    et k est le nombre de mégots de cigarette nécessaires pour échanger contre une nouvelle cigarette.\n    La fonction renvoie le nombre total de cigarettes que Peter peut fumer.\n    Exemple:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "de": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n    Peter beginnt mit n Zigaretten und kann k Kippen gegen eine neue Zigarette eintauschen.\n    Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist\n    und k die Anzahl der Zigarettenkippen ist, die für eine neue Zigarette eingetauscht werden müssen.\n    Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n    Beispiel:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "ha": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Lissafa jimillar adadin sigari da Peter zai iya sha.\n    Peter yana farawa da sigari n kuma zai iya musanya k bututun sigari don sabon sigari daya.\n    Aikin yana daukar hujjoji biyu, n da k, inda n shine adadin sigari na farko,\n    kuma k shine adadin bututun sigari da ake bukata don musanya sabon sigari daya.\n    Aikin yana mayar da jimillar adadin sigari da Peter zai iya sha.\n    Misali:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "hi": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है।\n    पीटर n सिगरेट से शुरू करता है और k बट्स को एक नई सिगरेट के लिए बदल सकता है।\n    यह फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेट की संख्या है,\n    और k वह संख्या है जो एक नई सिगरेट के लिए बट्स के आदान-प्रदान के लिए आवश्यक है।\n    फ़ंक्शन वह कुल संख्या लौटाता है जो पीटर पी सकता है।\n    उदाहरण:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "hu": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Kiszámítja a teljes cigarettaszámot, amit Péter elszívhat.\n    Péter n cigarettával kezd, és k csikket cserélhet egy új cigarettára.\n    A függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigarettaszám,\n    és k a cigarettacsikkek száma, amely szükséges egy új cigaretta cseréjéhez.\n    A függvény visszaadja a teljes cigarettaszámot, amit Péter elszívhat.\n    Példa:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "es": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calcula el número total de cigarrillos que Peter puede fumar.\n    Peter comienza con n cigarrillos y puede intercambiar k colillas por un cigarrillo nuevo.\n    La función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos,\n    y k es el número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\n    La función devuelve el número total de cigarrillos que Peter puede fumar.\n    Ejemplo:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "arb": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    يبدأ بيتر بـ n سجائر ويمكنه تبادل k أعقاب للحصول على سيجارة جديدة.\n    تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر،\n    و k هو عدد أعقاب السجائر اللازمة للتبادل للحصول على سيجارة جديدة.\n    تعيد الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "sw": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n    Peter anaanza na sigara n na anaweza kubadilisha vipande k vya sigara kwa sigara mpya moja.\n    Kazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara,\n    na k ni idadi ya vipande vya sigara vinavyohitajika kubadilisha kwa sigara mpya moja.\n    Kazi inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.\n    Mfano:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "tr": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Peter'ın içebileceği toplam sigara sayısını hesaplar.\n    Peter n sigara ile başlar ve k izmariti bir yeni sigara ile değiştirebilir.\n    Fonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır,\n    ve k bir yeni sigara ile değiştirmek için gereken sigara izmariti sayısıdır.\n    Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n    Örnek:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "vi": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Tính tổng số điếu thuốc mà Peter có thể hút.\n    Peter bắt đầu với n điếu thuốc và có thể đổi k tàn thuốc để lấy một điếu thuốc mới.\n    Hàm nhận hai tham số, n và k, trong đó n là số điếu thuốc ban đầu,\n    và k là số tàn thuốc cần để đổi lấy một điếu thuốc mới.\n    Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n    Ví dụ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "id": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Menghitung jumlah total rokok yang dapat dihisap Peter.\n    Peter mulai dengan n rokok dan dapat menukar k puntung untuk satu rokok baru.\n    Fungsi ini menerima dua argumen, n dan k, di mana n adalah jumlah awal rokok,\n    dan k adalah jumlah puntung rokok yang dibutuhkan untuk ditukar dengan satu rokok baru.\n    Fungsi ini mengembalikan jumlah total rokok yang dapat dihisap Peter.\n    Contoh:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "ja": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Peterが吸うことができるタバコの総数を計算します。\n    Peterはn本のタバコを持って始め、k個の吸い殻を1本の新しいタバコと交換できます。\n    関数は2つの引数、nとkを取ります。ここで、nは初期のタバコの本数、\n    kは1本の新しいタバコと交換するために必要な吸い殻の数です。\n    関数はPeterが吸うことができるタバコの総数を返します。\n    例:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "ko": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Peter가 피울 수 있는 총 담배 개수를 계산합니다.\n    Peter는 n개의 담배로 시작하며, k개의 꽁초를 새 담배 한 개로 교환할 수 있습니다.\n    이 함수는 두 개의 인수 n과 k를 받으며, n은 초기 담배 개수이고,\n    k는 새 담배 한 개로 교환하기 위해 필요한 꽁초의 개수입니다.\n    이 함수는 Peter가 피울 수 있는 총 담배 개수를 반환합니다.\n    예시:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "ml": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    പീറ്റർ എത്ര സിഗരറ്റ് വലിക്കാമെന്ന് കണക്കാക്കുന്നു.\n    പീറ്റർ n സിഗരറ്റുകളുമായി ആരംഭിക്കുന്നു, k ബട്ടുകൾ ഒരു പുതിയ സിഗരറ്റിന് മാറ്റാൻ കഴിയും.\n    ഫംഗ്ഷൻ രണ്ട് ആർഗുമെന്റുകൾ എടുക്കുന്നു, n, k, n പ്രാരംഭ സിഗരറ്റുകളുടെ എണ്ണം,\n    k ഒരു പുതിയ സിഗരറ്റിന് മാറ്റാൻ ആവശ്യമായ സിഗരറ്റ് ബട്ടുകളുടെ എണ്ണം.\n    ഫംഗ്ഷൻ പീറ്റർ എത്ര സിഗരറ്റ് വലിക്കാമെന്ന് തിരിച്ചുനൽകുന്നു.\n    ഉദാഹരണം:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "fa": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    محاسبه می‌کند که پیتر می‌تواند چند سیگار بکشد.\n    پیتر با n سیگار شروع می‌کند و می‌تواند k ته‌سیگار را با یک سیگار جدید تعویض کند.\n    این تابع دو آرگومان می‌گیرد، n و k، که n تعداد اولیه سیگارها است،\n    و k تعداد ته‌سیگارهایی است که برای تعویض با یک سیگار جدید نیاز است.\n    تابع تعداد کل سیگارهایی که پیتر می‌تواند بکشد را برمی‌گرداند.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\""}, "canonical_solution": "    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total", "instruction": {"en": "Write a python function 'def total_smoked_cigarettes(n, k):' to solve the following problem:\n\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ", "sq": "Shkruani një funksion python 'def total_smoked_cigarettes(n, k):' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit numrin total të cigareve që Peter mund të pijë.\n    Peter fillon me n cigare dhe mund të shkëmbejë k bishta për një cigare të re.\n    Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve,\n    dhe k është numri i bishtave të cigareve të nevojshme për të shkëmbyer për një cigare të re.\n    Funksioni kthen numrin total të cigareve që Peter mund të pijë.\n    Shembull:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "hy": "Պայթոն ֆունկցիա 'def total_smoked_cigarettes(n, k):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվում է ընդհանուր ծխախոտների քանակը, որը Պետերը կարող է ծխել։\n    Պետերը սկսում է n ծխախոտներով և կարող է փոխանակել k ծխախոտի մնացորդները մեկ նոր ծխախոտի համար։\n    Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ն սկզբնական ծխախոտների քանակն է,\n    իսկ k-ն այն ծխախոտի մնացորդների քանակն է, որը անհրաժեշտ է մեկ նոր ծխախոտի փոխանակման համար։\n    Ֆունկցիան վերադարձնում է ընդհանուր ծխախոտների քանակը, որը Պետերը կարող է ծխել։\n    Օրինակ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "bn": "একটি পাইথন ফাংশন 'def total_smoked_cigarettes(n, k):' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    পিটার কতগুলি সিগারেট খেতে পারে তার মোট সংখ্যা গণনা করে।\n    পিটার n সিগারেট দিয়ে শুরু করে এবং k বাট দিয়ে একটি নতুন সিগারেটের জন্য বিনিময় করতে পারে।\n    ফাংশনটি দুটি আর্গুমেন্ট নেয়, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা,\n    এবং k হল একটি নতুন সিগারেটের জন্য বিনিময় করতে প্রয়োজনীয় সিগারেট বাটের সংখ্যা।\n    ফাংশনটি পিটার কতগুলি সিগারেট খেতে পারে তার মোট সংখ্যা ফেরত দেয়।\n    উদাহরণ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "bg": "Напишете Python функция 'def total_smoked_cigarettes(n, k):', за да решите следния проблем:\n\n    Изчислява общия брой цигари, които Петър може да изпуши.\n    Петър започва с n цигари и може да размени k фасове за една нова цигара.\n    Функцията приема два аргумента, n и k, където n е началният брой цигари,\n    а k е броят на фасовете, необходими за размяна за една нова цигара.\n    Функцията връща общия брой цигари, които Петър може да изпуши.\n    Пример:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "zh": "编写一个 Python 函数 'def total_smoked_cigarettes(n, k):' 来解决以下问题：\n\n    计算 Peter 可以抽的香烟总数。\n    Peter 从 n 支香烟开始，可以用 k 个烟蒂换一支新香烟。\n    该函数接受两个参数，n 和 k，其中 n 是初始香烟数量，\n    k 是换取一支新香烟所需的烟蒂数量。\n    该函数返回 Peter 可以抽的香烟总数。\n    示例：\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "fr": "Écrivez une fonction python 'def total_smoked_cigarettes(n, k):' pour résoudre le problème suivant :\n\n    Calcule le nombre total de cigarettes que Peter peut fumer.\n    Peter commence avec n cigarettes et peut échanger k mégots contre une nouvelle cigarette.\n    La fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes,\n    et k est le nombre de mégots de cigarette nécessaires pour échanger contre une nouvelle cigarette.\n    La fonction retourne le nombre total de cigarettes que Peter peut fumer.\n    Exemple :\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "de": "Schreiben Sie eine Python-Funktion 'def total_smoked_cigarettes(n, k):', um das folgende Problem zu lösen:\n\n    Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n    Peter beginnt mit n Zigaretten und kann k Kippen gegen eine neue Zigarette eintauschen.\n    Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist\n    und k die Anzahl der Zigarettenkippen ist, die für eine neue Zigarette eingetauscht werden müssen.\n    Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n    Beispiel:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "ha": "Rubuta wani aikin python 'def total_smoked_cigarettes(n, k):' don warware matsalar mai zuwa:\n\n    Lissafa jimillar adadin sigari da Peter zai iya sha.\n    Peter yana farawa da n sigari kuma zai iya musanya k butts don sabon sigari daya.\n    Aikin yana daukar hujjoji biyu, n da k, inda n shine adadin sigari na farko,\n    kuma k shine adadin bututun sigari da ake bukata don musanya don sabon sigari daya.\n    Aikin yana mayar da jimillar adadin sigari da Peter zai iya sha.\n    Misali:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "hi": "एक पायथन फ़ंक्शन 'def total_smoked_cigarettes(n, k):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    यह गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है।\n    पीटर n सिगरेट से शुरू करता है और k बट्स के बदले एक नई सिगरेट प्राप्त कर सकता है।\n    फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेट की संख्या है,\n    और k वह संख्या है जो एक नई सिगरेट के बदले में सिगरेट बट्स की आवश्यकता होती है।\n    फ़ंक्शन वह कुल संख्या लौटाता है जो पीटर पी सकता है।\n    उदाहरण:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "hu": "Írj egy python függvényt 'def total_smoked_cigarettes(n, k):' a következő probléma megoldására:\n\n    Kiszámítja a teljes cigarettaszámot, amit Péter elszívhat.\n    Péter n cigarettával kezd, és k csikket cserélhet be egy új cigarettára.\n    A függvény két argumentumot vesz, n és k, ahol n a kezdeti cigarettaszám,\n    és k az a csikkszám, amely szükséges egy új cigaretta cseréjéhez.\n    A függvény visszaadja a teljes cigarettaszámot, amit Péter elszívhat.\n    Példa:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "es": "Escribe una función de Python 'def total_smoked_cigarettes(n, k):' para resolver el siguiente problema:\n\n    Calcula el número total de cigarrillos que Peter puede fumar.\n    Peter comienza con n cigarrillos y puede intercambiar k colillas por un cigarrillo nuevo.\n    La función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos,\n    y k es el número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\n    La función devuelve el número total de cigarrillos que Peter puede fumar.\n    Ejemplo:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "arb": "اكتب دالة بايثون 'def total_smoked_cigarettes(n, k):' لحل المشكلة التالية:\n\n    تحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n    يبدأ بيتر بـ n سجائر ويمكنه تبادل k أعقاب للحصول على سيجارة جديدة واحدة.\n    تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر،\n    و k هو عدد أعقاب السجائر اللازمة لتبادلها بسيجارة جديدة واحدة.\n    تعيد الدالة العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "sw": "Andika kazi ya python 'def total_smoked_cigarettes(n, k):' kutatua tatizo lifuatalo:\n\n    Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n    Peter anaanza na sigara n na anaweza kubadilisha vishungi k kwa sigara mpya moja.\n    Kazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara,\n    na k ni idadi ya vishungi vya sigara vinavyohitajika kubadilisha kwa sigara mpya moja.\n    Kazi inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.\n    Mfano:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ", "tr": "Bir python fonksiyonu 'def total_smoked_cigarettes(n, k):' yazın ve aşağıdaki problemi çözün:\n\n    Peter'ın içebileceği toplam sigara sayısını hesaplar.\n    Peter, n sigara ile başlar ve k izmariti bir yeni sigara ile değiştirebilir.\n    Fonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır,\n    ve k bir yeni sigara ile değiştirmek için gereken izmarit sayısıdır.\n    Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n    Örnek:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "vi": "Viết một hàm python 'def total_smoked_cigarettes(n, k):' để giải quyết vấn đề sau:\n\n    Tính tổng số điếu thuốc mà Peter có thể hút.\n    Peter bắt đầu với n điếu thuốc và có thể đổi k đầu lọc lấy một điếu thuốc mới.\n    Hàm nhận hai tham số, n và k, trong đó n là số điếu thuốc ban đầu,\n    và k là số đầu lọc cần để đổi lấy một điếu thuốc mới.\n    Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n    Ví dụ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ", "id": "Tulis sebuah fungsi python 'def total_smoked_cigarettes(n, k):' untuk menyelesaikan masalah berikut:\n\n    Menghitung total jumlah rokok yang bisa dihisap Peter.\n    Peter mulai dengan n rokok dan dapat menukar k puntung rokok untuk satu rokok baru.\n    Fungsi ini menerima dua argumen, n dan k, di mana n adalah jumlah awal rokok,\n    dan k adalah jumlah puntung rokok yang dibutuhkan untuk ditukar dengan satu rokok baru.\n    Fungsi ini mengembalikan total jumlah rokok yang bisa dihisap Peter.\n    Contoh:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "ja": "Python関数 'def total_smoked_cigarettes(n, k):' を作成して、次の問題を解決してください:\n\n    Peterが吸うことができるタバコの総数を計算します。\n    Peterはn本のタバコを持っていて、k個の吸い殻を新しいタバコ1本と交換できます。\n    関数は2つの引数、nとkを取り、nは初期のタバコの本数、\n    kは新しいタバコ1本と交換するために必要な吸い殻の数です。\n    関数はPeterが吸うことができるタバコの総数を返します。\n    例:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "ko": "파이썬 함수를 작성하세요 'def total_smoked_cigarettes(n, k):' 다음 문제를 해결하기 위해:\n\n    피터가 피울 수 있는 총 담배 수를 계산합니다.\n    피터는 n개의 담배로 시작하며, k개의 꽁초를 새 담배 한 개로 교환할 수 있습니다.\n    이 함수는 두 개의 인수, n과 k를 받습니다. 여기서 n은 초기 담배 수이고,\n    k는 새 담배 한 개로 교환하기 위해 필요한 꽁초의 수입니다.\n    이 함수는 피터가 피울 수 있는 총 담배 수를 반환합니다.\n    예시:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "ml": "'def total_smoked_cigarettes(n, k):' എന്ന പൈത്തൺ ഫംഗ്ഷൻ എഴുതുക താഴെ പറയുന്ന പ്രശ്നം പരിഹരിക്കാൻ:\n\n    പീറ്റർ പുകവലിക്കാവുന്ന മൊത്തം സിഗരറ്റുകളുടെ എണ്ണം കണക്കാക്കുന്നു.\n    പീറ്റർ n സിഗരറ്റുകളുമായി തുടങ്ങുന്നു, k ബട്ടുകൾ ഒരു പുതിയ സിഗരറ്റ് ലഭിക്കാൻ മാറ്റാം.\n    ഫംഗ്ഷൻ രണ്ട് ആർഗ്യുമെന്റുകൾ സ്വീകരിക്കുന്നു, n, k, n ആരംഭ സിഗരറ്റുകളുടെ എണ്ണം,\n    k ഒരു പുതിയ സിഗരറ്റ് ലഭിക്കാൻ ആവശ്യമായ സിഗരറ്റ് ബട്ടുകളുടെ എണ്ണം.\n    പീറ്റർ പുകവലിക്കാവുന്ന മൊത്തം സിഗരറ്റുകളുടെ എണ്ണം ഫംഗ്ഷൻ തിരിച്ചുനൽകുന്നു.\n    ഉദാഹരണം:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "fa": "یک تابع پایتون بنویسید 'def total_smoked_cigarettes(n, k):' برای حل مسئله زیر:\n\n    محاسبه تعداد کل سیگارهایی که پیتر می‌تواند بکشد.\n    پیتر با n سیگار شروع می‌کند و می‌تواند k ته‌سیگار را با یک سیگار جدید تعویض کند.\n    تابع دو آرگومان می‌گیرد، n و k، که در آن n تعداد اولیه سیگارها است،\n    و k تعداد ته‌سیگارهایی است که برای تعویض با یک سیگار جدید نیاز است.\n    تابع تعداد کل سیگارهایی که پیتر می‌تواند بکشد را برمی‌گرداند.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14"}, "level": "easy", "test": "assert total_smoked_cigarettes(4, 3) == 5\nassert total_smoked_cigarettes(10, 3) == 14\nassert total_smoked_cigarettes(1, 2) == 1  # Peter cannot exchange butts as he starts with less than k\nassert total_smoked_cigarettes(20, 4) == 26\nassert total_smoked_cigarettes(0, 5) == 0  # Peter starts with no cigarettes", "entry_point": "total_smoked_cigarettes", "signature": "def total_smoked_cigarettes(n, k):", "docstring": {"en": "\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ", "sq": "\n    Llogarit numrin total të cigareve që Pjetri mund të pijë.\n    Pjetri fillon me n cigare dhe mund të shkëmbejë k bishta për një cigare të re.\n    Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve,\n    dhe k është numri i bishtave të cigareve që duhen për të shkëmbyer për një cigare të re.\n    Funksioni kthen numrin total të cigareve që Pjetri mund të pijë.\n    Shembull:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "hy": "\n    Հաշվում է, թե քանի հատ ծխախոտ կարող է ծխել Պետերը:\n    Պետերը սկսում է n ծխախոտով և կարող է փոխանակել k ծխախոտի մնացորդները մեկ նոր ծխախոտի համար:\n    Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ն սկզբնական ծխախոտների քանակն է,\n    իսկ k-ն այն ծխախոտի մնացորդների քանակն է, որոնք անհրաժեշտ են մեկ նոր ծխախոտի փոխանակման համար:\n    Ֆունկցիան վերադարձնում է, թե ընդհանուր քանի հատ ծխախոտ կարող է ծխել Պետերը:\n    Օրինակ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "bn": "\n    পিটার কতগুলি সিগারেট খেতে পারে তার মোট সংখ্যা গণনা করে।\n    পিটার n সিগারেট দিয়ে শুরু করে এবং k টুকরো সিগারেটের অবশিষ্টাংশের বিনিময়ে একটি নতুন সিগারেট পেতে পারে।\n    ফাংশনটি দুটি আর্গুমেন্ট নেয়, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা,\n    এবং k হল একটি নতুন সিগারেটের বিনিময়ে প্রয়োজনীয় সিগারেটের অবশিষ্টাংশের সংখ্যা।\n    ফাংশনটি পিটার কতগুলি সিগারেট খেতে পারে তার মোট সংখ্যা প্রদান করে।\n    উদাহরণ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "bg": "\n    Изчислява общия брой цигари, които Петър може да изпуши.\n    Петър започва с n цигари и може да размени k фасове за една нова цигара.\n    Функцията приема два аргумента, n и k, където n е началният брой цигари,\n    а k е броят на фасовете, необходими за размяна за една нова цигара.\n    Функцията връща общия брой цигари, които Петър може да изпуши.\n    Пример:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "zh": "\n    计算彼得可以抽的香烟总数。\n    彼得从 n 支香烟开始，可以用 k 个烟蒂换一支新香烟。\n    该函数接受两个参数，n 和 k，其中 n 是初始香烟数量，\n    k 是换取一支新香烟所需的烟蒂数量。\n    该函数返回彼得可以抽的香烟总数。\n    示例:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "fr": "\n    Calcule le nombre total de cigarettes que Peter peut fumer.\n    Peter commence avec n cigarettes et peut échanger k mégots contre une nouvelle cigarette.\n    La fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes,\n    et k est le nombre de mégots de cigarette nécessaires pour échanger contre une nouvelle cigarette.\n    La fonction retourne le nombre total de cigarettes que Peter peut fumer.\n    Exemple:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "de": "\n    Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n    Peter beginnt mit n Zigaretten und kann k Kippen gegen eine neue Zigarette eintauschen.\n    Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist,\n    und k die Anzahl der benötigten Zigarettenkippen, um eine neue Zigarette einzutauschen.\n    Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n    Beispiel:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "ha": "\n    Lissafa jimillar adadin sigari da Peter zai iya sha.\n    Peter yana farawa da n sigari kuma zai iya musanya k butts don sabon sigari daya.\n    Aikin yana daukar hujjoji guda biyu, n da k, inda n shine adadin sigari na farko,\n    kuma k shine adadin bututun sigari da ake bukata don musanya da sabon sigari daya.\n    Aikin yana dawowa da jimillar adadin sigari da Peter zai iya sha.\n    Misali:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "hi": "\n    पीटर कितनी कुल सिगरेट पी सकता है, इसकी गणना करता है।\n    पीटर n सिगरेट से शुरू करता है और k बट्स को एक नई सिगरेट के लिए बदल सकता है।\n    फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेट की संख्या है,\n    और k वह संख्या है जितने सिगरेट बट्स को एक नई सिगरेट के लिए बदलने की आवश्यकता होती है।\n    फ़ंक्शन कुल सिगरेट की संख्या लौटाता है जो पीटर पी सकता है।\n    उदाहरण:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "hu": "\n    Kiszámítja, hogy Péter összesen hány cigarettát tud elszívni.\n    Péter n cigarettával kezd, és k csikket tud beváltani egy új cigarettára.\n    A függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigaretták száma,\n    és k a csikkek száma, amelyeket be kell váltani egy új cigarettára.\n    A függvény visszaadja, hogy Péter összesen hány cigarettát tud elszívni.\n    Példa:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "es": "\n    Calcula el número total de cigarrillos que Peter puede fumar.\nPeter comienza con n cigarrillos y puede intercambiar k colillas por un cigarrillo nuevo.\nLa función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos,\ny k es el número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\nLa función devuelve el número total de cigarrillos que Peter puede fumar.\nEjemplo:\n>>> total_smoked_cigarettes(4, 3)\n    5\n>>> total_smoked_cigarettes(10, 3)\n    14", "arb": "\n    يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    يبدأ بيتر بـ n سجائر ويمكنه تبادل k أعقاب للحصول على سيجارة جديدة واحدة.\n    تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر،\n    و k هو عدد أعقاب السجائر اللازمة لتبادلها بسيجارة جديدة واحدة.\n    تعيد الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "sw": "\n    Hesabu jumla ya sigara ambazo Peter anaweza kuvuta.\nPeter anaanza na sigara n na anaweza kubadilisha vipande k vya sigara kwa sigara mpya moja.\nKazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara,\nna k ni idadi ya vipande vya sigara vinavyohitajika kubadilisha kwa sigara mpya moja.\nKazi inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.\nMfano:\n>>> total_smoked_cigarettes(4, 3)\n    5\n>>> total_smoked_cigarettes(10, 3)\n    14", "tr": "\n    Peter'ın içebileceği toplam sigara sayısını hesaplar.\n    Peter, n sigara ile başlar ve k izmariti bir yeni sigara ile değiştirebilir.\n    Fonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır,\n    ve k bir yeni sigara ile değiştirmek için gereken izmarit sayısıdır.\n    Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n    Örnek:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ", "vi": "\n    Tính tổng số điếu thuốc mà Peter có thể hút.\n    Peter bắt đầu với n điếu thuốc và có thể đổi k đầu mẩu thuốc lấy một điếu thuốc mới.\n    Hàm nhận hai tham số, n và k, trong đó n là số điếu thuốc ban đầu,\n    và k là số đầu mẩu thuốc cần để đổi lấy một điếu thuốc mới.\n    Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n    Ví dụ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ", "id": "Menghitung jumlah total rokok yang bisa dihisap Peter.  \nPeter mulai dengan n rokok dan dapat menukar k puntung untuk satu rokok baru.  \nFungsi ini menerima dua argumen, n dan k, di mana n adalah jumlah awal rokok,  \ndan k adalah jumlah puntung rokok yang dibutuhkan untuk ditukar dengan satu rokok baru.  \nFungsi ini mengembalikan jumlah total rokok yang bisa dihisap Peter.  \nContoh:  \n>>> total_smoked_cigarettes(4, 3)  \n    5  \n>>> total_smoked_cigarettes(10, 3)  \n    14  ", "ja": "    ピーターが吸えるタバコの総数を計算します。\n    ピーターは n 本のタバコを持っていて、k 個の吸い殻を交換して新しいタバコ1本にできます。\n    関数は2つの引数、n と k を取り、n は最初のタバコの本数、\n    k は新しいタバコ1本を交換するのに必要な吸い殻の数です。\n    関数はピーターが吸えるタバコの総数を返します。\n    例:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "ko": "    Peter가 피울 수 있는 총 담배 수를 계산합니다.\n    Peter는 n개의 담배로 시작하며, k개의 꽁초를 새 담배 한 개로 교환할 수 있습니다.\n    이 함수는 두 개의 인수 n과 k를 받으며, 여기서 n은 초기 담배 수이고,\n    k는 새 담배 한 개로 교환하기 위해 필요한 담배 꽁초의 수입니다.\n    이 함수는 Peter가 피울 수 있는 총 담배 수를 반환합니다.\n    예:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ", "ml": "    പീറ്റർ പുകവലിക്കാനാകുന്ന മൊത്തം സിഗരറ്റുകളുടെ എണ്ണം കണക്കാക്കുന്നു.\n    പീറ്റർ n സിഗരറ്റുകളുമായി ആരംഭിക്കുന്നു, കൂടാതെ ഒരു പുതിയ സിഗരറ്റ് ലഭിക്കുന്നതിന് k ബട്ടുകൾ കൈമാറാം.\n    ഫങ്ഷൻ രണ്ട് ആർഗുമെന്റുകൾ സ്വീകരിക്കുന്നു, n, k, ഇവയിൽ n പ്രാരംഭ സിഗരറ്റുകളുടെ എണ്ണം ആണ്,\n    k ഒരു പുതിയ സിഗരറ്റ് കൈമാറുന്നതിനായി ആവശ്യമായ സിഗരറ്റ് ബട്ടുകളുടെ എണ്ണം ആണ്.\n    ഫങ്ഷൻ പീറ്റർ പുകവലിക്കാനാകുന്ന മൊത്തം സിഗരറ്റുകളുടെ എണ്ണം തിരികെ നൽകുന്നു.\n    ഉദാഹരണം:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "fa": "محاسبه تعداد کل سیگارهایی که پیتر می‌تواند بکشد.\nپیتر با n سیگار شروع می‌کند و می‌تواند k ته سیگار را با یک سیگار جدید مبادله کند.\nاین تابع دو آرگومان می‌گیرد، n و k، که در آن n تعداد اولیه سیگارها است\nو k تعداد ته سیگارهایی است که برای مبادله با یک سیگار جدید لازم است.\nاین تابع تعداد کل سیگارهایی که پیتر می‌تواند بکشد را برمی‌گرداند.\nمثال:\n>>> total_smoked_cigarettes(4, 3)\n    5\n>>> total_smoked_cigarettes(10, 3)\n    14"}}
