[
  {
    "task_id": "Go/1",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalcular el área de un triángulo dados sus tres lados.\nParámetros:\n- a (float64): Longitud del lado 'a'.\n- b (float64): Longitud del lado 'b'.\n- c (float64): Longitud del lado 'c'.\n\nDevuelve:\n- float64: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve -1.\n\nEjemplos:\n\tcalculateTriangleArea(3, 5, 4)  // Devuelve 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "arb": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب مساحة المثلث المعطى أطوال أضلاعه الثلاثة.\nالمعطيات:\n- a (float64): طول الضلع 'a'.\n- b (float64): طول الضلع 'b'.\n- c (float64): طول الضلع 'c'.\n\nالقيم المعادة:\n- float64: إذا كانت الأضلاع المعطاة تشكل مثلثًا، أعد المساحة المحسوبة بدقتين عشريتين.\nوإلا، أعد -1.\n\nأمثلة:\n\tcalculateTriangleArea(3, 5, 4)  // يعيد 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "sw": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\nVigezo:\n- a (float64): Urefu wa upande 'a'.\n- b (float64): Urefu wa upande 'b'.\n- c (float64): Urefu wa upande 'c'.\n\nRudisha:\n- float64: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali.\nVinginevyo, rudisha -1.\n\nMifano:\n\tcalculateTriangleArea(3, 5, 4)  // Inarudisha 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "tr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\nParametreler:\n- a (float64): 'a' kenarının uzunluğu.\n- b (float64): 'b' kenarının uzunluğu.\n- c (float64): 'c' kenarının uzunluğu.\n\nDöndürür:\n- float64: Sağlanan kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, -1 döndürün.\n\nÖrnekler:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 döndürür\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "vi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTính diện tích của một tam giác khi biết ba cạnh của nó.\nTham số:\n- a (float64): Độ dài cạnh 'a'.\n- b (float64): Độ dài cạnh 'b'.\n- c (float64): Độ dài cạnh 'c'.\n\nTrả về:\n- float64: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNếu không, trả về -1.\n\nVí dụ:\n\tcalculateTriangleArea(3, 5, 4)  // Trả về 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {"
    },
    "prompt_bertscore": {
      "es": "0.9844051315241888",
      "arb": "0.9677547412035583",
      "sw": "0.9964047901032685",
      "tr": "0.9992789717168433",
      "vi": "0.9934825399374833"
    },
    "canonical_solution": "if a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}",
    "instruction": {
      "es": "Escribe una función en Go `func calculateTriangleArea(a, b, c float64) float64` para resolver el siguiente problema:\nCalcular el área de un triángulo dados sus tres lados.\nParámetros:\n- a (float64): Longitud del lado 'a'.\n- b (float64): Longitud del lado 'b'.\n- c (float64): Longitud del lado 'c'.\n\nDevuelve:\n- float64: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve -1.\n\nEjemplos:\n\tcalculateTriangleArea(3, 5, 4)  // Devuelve 6.00",
      "arb": "اكتب دالة Go `func calculateTriangleArea(a, b, c float64) float64` لحل المشكلة التالية:\nاحسب مساحة مثلث معطى أطوال أضلاعه الثلاثة.\nالمعطيات:\n- a (float64): طول الضلع 'a'.\n- b (float64): طول الضلع 'b'.\n- c (float64): طول الضلع 'c'.\n\nالقيم المعادة:\n- float64: إذا كانت الأضلاع المعطاة تشكل مثلثًا، أعد المساحة المحسوبة بدقتين عشريتين.\nوإلا، أعد -1.\n\nأمثلة:\n\tcalculateTriangleArea(3, 5, 4)  // يعيد 6.00",
      "sw": "Andika kazi ya Go `func calculateTriangleArea(a, b, c float64) float64` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\nVigezo:\n- a (float64): Urefu wa upande 'a'.\n- b (float64): Urefu wa upande 'b'.\n- c (float64): Urefu wa upande 'c'.\n\nRudisha:\n- float64: Kama pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa kwa nafasi 2 za desimali.\nVinginevyo, rudisha -1.\n\nMifano:\n\tcalculateTriangleArea(3, 5, 4)  // Inarudisha 6.00",
      "tr": "Bir Go fonksiyonu `func calculateTriangleArea(a, b, c float64) float64` yazın ve aşağıdaki problemi çözün:\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\nParametreler:\n- a (float64): 'a' kenarının uzunluğu.\n- b (float64): 'b' kenarının uzunluğu.\n- c (float64): 'c' kenarının uzunluğu.\n\nDöndürülenler:\n- float64: Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, -1 döndürün.\n\nÖrnekler:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 döndürür",
      "vi": "Viết một hàm Go `func calculateTriangleArea(a, b, c float64) float64` để giải quyết vấn đề sau:\nTính diện tích của một tam giác khi biết ba cạnh của nó.\nTham số:\n- a (float64): Độ dài của cạnh 'a'.\n- b (float64): Độ dài của cạnh 'b'.\n- c (float64): Độ dài của cạnh 'c'.\n\nTrả về:\n- float64: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNếu không, trả về -1.\n\nVí dụ:\n\tcalculateTriangleArea(3, 5, 4)  // Trả về 6.00"
    },
    "instruction_bertscore": {
      "es": "0.9825821018870506",
      "arb": "0.9659134375713649",
      "sw": "0.9921249012831098",
      "tr": "0.9936207866826835",
      "vi": "0.9947285483177151"
    },
    "level": "easy",
    "test": "func TestCalculateTriangleArea(t *testing.T) {\n\t// Using a small delta for floating point comparison\n\tconst delta = 1e-6\n\n\tassert := assert.New(t)\n\n\t// Triangle with sides 3, 5, 4 should return area 6.00\n\tassert.InDelta(6.00, calculateTriangleArea(3, 5, 4), delta)\n\n\t// Not a triangle with sides 1, 1, 4 should return -1\n\tassert.Equal(-1.0, calculateTriangleArea(1, 1, 4))\n\n\t// Triangle with sides 7, 24, 25 should return area 84.00\n\tassert.InDelta(84.00, calculateTriangleArea(7, 24, 25), delta)\n\n\t// Triangle with sides 10.5, 6.2, 7.3 should return close to calculated area\n\tassert.InDelta(22.15, calculateTriangleArea(10.5, 6.2, 7.3), 1e-2) // Looser delta for specific precision\n}",
    "entry_point": "calculateTriangleArea",
    "signature": "func calculateTriangleArea(a, b, c float64) float64",
    "docstring": {
      "es": "Calcular el área de un triángulo dado sus tres lados.\nParámetros:\n- a (float64): Longitud del lado 'a'.\n- b (float64): Longitud del lado 'b'.\n- c (float64): Longitud del lado 'c'.\n\nDevuelve:\n- float64: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve -1.\n\nEjemplos:\n\tcalculateTriangleArea(3, 5, 4)  // Devuelve 6.00",
      "arb": "احسب مساحة المثلث بناءً على أطوال أضلاعه الثلاثة.  \nالمعلمات:  \n- a (float64): طول الضلع 'a'.  \n- b (float64): طول الضلع 'b'.  \n- c (float64): طول الضلع 'c'.  \n\nالقيم المعادة:  \n- float64: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة بدقة منزلتين عشريتين.  \nوإلا، يتم إرجاع -1.  \n\nأمثلة:  \n    calculateTriangleArea(3, 5, 4)  // يعيد 6.00  ",
      "sw": "Hesabu eneo la pembetatu ukitumia pande zake tatu.  \nVigezo:  \n- a (float64): Urefu wa upande 'a'.  \n- b (float64): Urefu wa upande 'b'.  \n- c (float64): Urefu wa upande 'c'.  \n\nRudisha:  \n- float64: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali.  \nVinginevyo, rudisha -1.  \n\nMifano:  \n\tcalculateTriangleArea(3, 5, 4)  // Inarudisha 6.00  ",
      "tr": "Üç kenarı verilen bir üçgenin alanını hesaplayın.\nParametreler:\n- a (float64): 'a' kenarının uzunluğu.\n- b (float64): 'b' kenarının uzunluğu.\n- c (float64): 'c' kenarının uzunluğu.\n\nDöndürür:\n- float64: Verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, -1 döndürün.\n\nÖrnekler:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 döndürür",
      "vi": "Tính diện tích của một tam giác khi biết ba cạnh của nó.  \nTham số:  \n- a (float64): Chiều dài của cạnh 'a'.  \n- b (float64): Chiều dài của cạnh 'b'.  \n- c (float64): Chiều dài của cạnh 'c'.  \n\nTrả về:  \n- float64: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.  \nNgược lại, trả về -1.  \n\nVí dụ:  \n\tcalculateTriangleArea(3, 5, 4)  // Trả về 6.00  "
    },
    "docstring_bertscore": {
      "es": "0.9774661777931161",
      "arb": "0.9525112498717979",
      "sw": "0.9914283045368204",
      "tr": "0.9958367072135087",
      "vi": "0.9984510802886899"
    }
  },
  {
    "task_id": "Go/2",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalcular el valor de la función para una entrada dada.\nParámetros:\n- x (int): Valor de entrada para la función.\nDevuelve:\n- string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n\nDefiniciones de Función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "arb": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب قيمة الدالة لمدخل معين.\nالمعلمات:\n- x (int): قيمة المدخل للدالة.\nيعيد:\n- string: إذا لم يكن x في النطاق المحدد، يعيد \"غير معرف\".\nوإلا، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\nتعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "sw": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu thamani ya kazi kwa pembejeo iliyotolewa.\nVigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\nInarudisha:\n- string: Ikiwa x haiko katika kikoa kilichobainishwa, inarudisha \"Not define\".\nVinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyozungushwa hadi sehemu tano za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "tr": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBelirtilen bir giriş için fonksiyonun değerini hesaplayın.\nParametreler:\n- x (int): Fonksiyon için giriş değeri.\nDöndürür:\n- string: Eğer x tanımlı alanda değilse, \"Not define\" döner.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döner.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "vi": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTính giá trị của hàm cho một đầu vào cho trước.\nTham số:\n- x (int): Giá trị đầu vào cho hàm.\nTrả về:\n- string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {"
    },
    "prompt_bertscore": {
      "es": "0.9793052964911181",
      "arb": "0.9835105002880077",
      "sw": "0.9927422445073663",
      "tr": "0.9876978273506042",
      "vi": "0.9927712445429974"
    },
    "canonical_solution": "if 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}",
    "instruction": {
      "es": "Escribe una función de Go `func calculateFunctionValue(x int) string` para resolver el siguiente problema:\nCalcular el valor de la función para un input dado.\nParámetros:\n- x (int): Valor de entrada para la función.\nDevuelve:\n- string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n\nDefiniciones de función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "arb": "اكتب دالة Go `func calculateFunctionValue(x int) string` لحل المشكلة التالية:\nاحسب قيمة الدالة للمدخل المعطى.\nالمعطيات:\n- x (int): قيمة المدخل للدالة.\nالإرجاع:\n- string: إذا لم يكن x في النطاق المحدد، يرجع \"Not define\".\nبخلاف ذلك، يرجع قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\nتعريفات الدالة:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "sw": "Andika kazi ya Go `func calculateFunctionValue(x int) string` kutatua tatizo lifuatalo:\nHesabu thamani ya kazi kwa pembejeo iliyotolewa.\nVigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\nInarudisha:\n- string: Ikiwa x haipo katika kikoa kilichobainishwa, inarudisha \"Not define\".\nVinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyozungushwa hadi sehemu 5 za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "tr": "Bir Go fonksiyonu `func calculateFunctionValue(x int) string` yazın ve aşağıdaki problemi çözün:\nVerilen bir girdi için fonksiyonun değerini hesaplayın.\nParametreler:\n- x (int): Fonksiyon için giriş değeri.\nDöndürür:\n- string: Eğer x tanımlı bir aralıkta değilse, \"Not define\" döndürür.\nAksi halde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "vi": "Viết một hàm Go `func calculateFunctionValue(x int) string` để giải quyết vấn đề sau:  \nTính giá trị của hàm cho một đầu vào cho trước.  \nTham số:  \n- x (int): Giá trị đầu vào cho hàm.  \nTrả về:  \n- string: Nếu x không nằm trong miền xác định, trả về \"Not define\".  \nNếu không, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân.  \n\nĐịnh nghĩa hàm:  \n- Với 0 <= x < 10: y = cos(x + 3.0)  \n- Với 10 <= x < 20: y = (cos(x + 7.5))^2  \n- Với 20 <= x < 30: y = (cos(x + 4.0))^4  \n\t>>> calculateFunctionValue(40)  \n\t\"Not define\""
    },
    "instruction_bertscore": {
      "es": "0.9795321323862599",
      "arb": "0.9727425487017254",
      "sw": "0.9805896405348897",
      "tr": "0.9859409416303506",
      "vi": "0.9943575067659419"
    },
    "level": "middle",
    "test": "func TestCalculateFunctionValue(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Not define\", calculateFunctionValue(40)) // the provided test case\n\n\t// Additional test cases based on provided function definitions\n\tassert.Equal(\"Not define\", calculateFunctionValue(40))\n\tassert.Equal(\"-0.14550\", calculateFunctionValue(5))\n\tassert.Equal(\"0.76266\", calculateFunctionValue(15))\n\tassert.Equal(\"0.31314\", calculateFunctionValue(25))\n\tassert.Equal(\"Not define\", calculateFunctionValue(-1))\n}",
    "entry_point": "calculateFunctionValue",
    "signature": "func calculateFunctionValue(x int) string",
    "docstring": {
      "es": "Calcular el valor de la función para una entrada dada.\nParámetros:\n- x (int): Valor de entrada para la función.\nDevuelve:\n- string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n\nDefiniciones de Función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "arb": "حساب قيمة الدالة لمدخل معين.\nالمعلمات:\n- x (int): قيمة المدخل للدالة.\nالقيم المعادة:\n- string: إذا لم يكن x في النطاق المحدد، يعيد \"غير معرف\".\nوإلا، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\nتعريفات الدالة:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\nVigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\nRudisha:\n- string: Ikiwa x haipo katika kikoa kilichobainishwa, inarudisha \"Not define\".\nVinginevyo, inarudisha thamani ya kazi iliyohesabiwa na kuzungushwa hadi sehemu 5 za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "tr": "Fonksiyonun değerini verilen bir giriş için hesaplayın.\nParametreler:\n- x (int): Fonksiyon için giriş değeri.\nDöndürülenler:\n- string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "vi": "Tính giá trị của hàm cho một đầu vào nhất định.  \nTham số:  \n- x (int): Giá trị đầu vào cho hàm.  \nTrả về:  \n- string: Nếu x không nằm trong miền xác định, trả về \"Not define\".  \nNgược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân.  \n\nĐịnh nghĩa hàm:  \n- Đối với 0 <= x < 10: y = cos(x + 3.0)  \n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2  \n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4  \n\t>>> calculateFunctionValue(40)  \n\t\"Not define\"  "
    },
    "docstring_bertscore": {
      "es": "0.9774916024818885",
      "arb": "0.9646586894543675",
      "sw": "0.9717221844343492",
      "tr": "0.9923723947378793",
      "vi": "0.9926242580610315"
    }
  },
  {
    "task_id": "Go/3",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEncuentra el máximo y el mínimo de tres enteros distintos.\n\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nLa función devuelve dos valores: el entero máximo y mínimo.\n\nEjemplo de uso:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nابحث عن القيمة القصوى والدنيا لثلاثة أعداد صحيحة متميزة.\n\nالمعطيات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nتعيد الدالة قيمتين: العدد الصحيح الأكبر والأصغر.\n\nمثال على الاستخدام:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPata kubwa na ndogo ya nambari tatu tofauti.\n\nVigezo:\na (int): Nambari ya kwanza.\nb (int): Nambari ya pili.\nc (int): Nambari ya tatu.\n\nInarudisha:\nKazi inarudisha maadili mawili: nambari kubwa na ndogo.\n\nMfano wa matumizi:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÜç farklı tam sayının maksimum ve minimumunu bulun.\n\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürür:\nFonksiyon iki değer döndürür: maksimum ve minimum tam sayı.\n\nÖrnek kullanım:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nHàm trả về hai giá trị: số nguyên lớn nhất và nhỏ nhất.\n\nVí dụ sử dụng:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {"
    },
    "prompt_bertscore": {
      "es": "0.993771944402651",
      "arb": "0.963067262841516",
      "sw": "0.9602923964184586",
      "tr": "0.9798809273353573",
      "vi": "0.9721164657407034"
    },
    "canonical_solution": "var max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}",
    "instruction": {
      "es": "Escribe una función en Go `func FindMaxMin(a, b, c int) (int, int)` para resolver el siguiente problema:\nEncuentra el máximo y mínimo de tres enteros distintos.\n\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nLa función devuelve dos valores: el entero máximo y mínimo.\n\nEjemplo de uso:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "arb": "اكتب دالة بلغة Go `func FindMaxMin(a, b, c int) (int, int)` لحل المشكلة التالية:\nالعثور على القيمة القصوى والدنيا لثلاثة أعداد صحيحة مميزة.\n\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nتعيد الدالة قيمتين: العدد الأقصى والعدد الأدنى.\n\nمثال على الاستخدام:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "sw": "Andika kazi ya Go `func FindMaxMin(a, b, c int) (int, int)` kutatua tatizo lifuatalo:\nPata kubwa na ndogo kati ya namba tatu tofauti za mzima.\n\nVigezo:\na (int): Namba ya kwanza ya mzima.\nb (int): Namba ya pili ya mzima.\nc (int): Namba ya tatu ya mzima.\n\nInarejesha:\nKazi inarejesha thamani mbili: namba kubwa na ndogo.\n\nMfano wa matumizi:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "tr": "Bir Go fonksiyonu `func FindMaxMin(a, b, c int) (int, int)` yazın ve aşağıdaki problemi çözün:\nÜç farklı tam sayının maksimum ve minimumunu bulun.\n\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürülenler:\nFonksiyon iki değer döndürür: maksimum ve minimum tam sayı.\n\nÖrnek kullanım:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "vi": "Viết một hàm Go `func FindMaxMin(a, b, c int) (int, int)` để giải quyết vấn đề sau:\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nHàm trả về hai giá trị: số nguyên lớn nhất và nhỏ nhất.\n\nVí dụ sử dụng:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)"
    },
    "instruction_bertscore": {
      "es": "0.9875240257671987",
      "arb": "0.9731854944514332",
      "sw": "0.9701972989991443",
      "tr": "0.9758679977473094",
      "vi": "0.9684137968078321"
    },
    "level": "middle",
    "test": "func TestFindMaxMin(t *testing.T) {\n\tassert := assert.New(t)\n\tvar max, min int\n\n\tmax, min = FindMaxMin(1, 2, 3)\n\tassert.Equal(3, max)\n\tassert.Equal(1, min)\n\n\t// Additional tests\n\tmax, min = FindMaxMin(5, 3, 4)\n\tassert.Equal(5, max)\n\tassert.Equal(3, min)\n\n\tmax, min = FindMaxMin(10, -2, 7)\n\tassert.Equal(10, max)\n\tassert.Equal(-2, min)\n\n\tmax, min = FindMaxMin(-1, -3, -2)\n\tassert.Equal(-1, max)\n\tassert.Equal(-3, min)\n}",
    "entry_point": "FindMaxMin",
    "signature": "func FindMaxMin(a, b, c int) (int, int)",
    "docstring": {
      "es": "Encontrar el máximo y el mínimo de tres enteros distintos.\n\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nLa función devuelve dos valores: el entero máximo y mínimo.\n\nEjemplo de uso:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة مميزة.\n\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nتعيد الدالة قيمتين: العدد الصحيح الأكبر والأصغر.\n\nمثال للاستخدام:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "sw": "Pata kubwa na ndogo kati ya nambari tatu tofauti za mzima.\n\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nKazi inarejesha thamani mbili: nambari kubwa na ndogo ya mzima.\n\nMfano wa matumizi:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "tr": "Üç farklı tam sayının maksimum ve minimumunu bulun.\n\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürülenler:\nFonksiyon iki değer döndürür: maksimum ve minimum tam sayı.\n\nÖrnek kullanım:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nHàm trả về hai giá trị: số nguyên lớn nhất và nhỏ nhất.\n\nVí dụ sử dụng:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)"
    },
    "docstring_bertscore": {
      "es": "0.9909841670048264",
      "arb": "0.9706493817463797",
      "sw": "0.9632716535036009",
      "tr": "0.972478370294949",
      "vi": "0.9707232722481247"
    }
  },
  {
    "task_id": "Go/4",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (float64): coordenada x del punto A.\n- ya (float64): coordenada y del punto A.\n- xb (float64): coordenada x del punto B.\n- yb (float64): coordenada y del punto B.\n\nDevuelve:\nfloat64: La distancia entre los puntos A y B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "arb": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعلمات:\n- xa (float64): الإحداثي السيني للنقطة A.\n- ya (float64): الإحداثي الصادي للنقطة A.\n- xb (float64): الإحداثي السيني للنقطة B.\n- yb (float64): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\nfloat64: المسافة بين النقطتين A و B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "sw": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (float64): x-kiwianishi cha pointi A.\n- ya (float64): y-kiwianishi cha pointi A.\n- xb (float64): x-kiwianishi cha pointi B.\n- yb (float64): y-kiwianishi cha pointi B.\n\nInarejesha:\nfloat64: Umbali kati ya pointi A na B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "tr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (float64): A noktasının x-koordinatı.\n- ya (float64): A noktasının y-koordinatı.\n- xb (float64): B noktasının x-koordinatı.\n- yb (float64): B noktasının y-koordinatı.\n\nDöndürür:\nfloat64: A ve B noktaları arasındaki mesafe.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "vi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (float64): tọa độ x của điểm A.\n- ya (float64): tọa độ y của điểm A.\n- xb (float64): tọa độ x của điểm B.\n- yb (float64): tọa độ y của điểm B.\n\nTrả về:\nfloat64: Khoảng cách giữa điểm A và B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9802376674996959",
      "sw": "0.9973365652207031",
      "tr": "0.9973365652207031",
      "vi": "0.999134567429831"
    },
    "canonical_solution": "return math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}",
    "instruction": {
      "es": "Escribe una función de Go `func calculateDistance(xa, ya, xb, yb float64) float64` para resolver el siguiente problema:\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (float64): coordenada x del punto A.\n- ya (float64): coordenada y del punto A.\n- xb (float64): coordenada x del punto B.\n- yb (float64): coordenada y del punto B.\n\nDevuelve:\nfloat64: La distancia entre los puntos A y B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "arb": "اكتب دالة Go `func calculateDistance(xa, ya, xb, yb float64) float64` لحل المشكلة التالية:\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعطيات:\n- xa (float64): الإحداثي السيني للنقطة A.\n- ya (float64): الإحداثي الصادي للنقطة A.\n- xb (float64): الإحداثي السيني للنقطة B.\n- yb (float64): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\nfloat64: المسافة بين النقطتين A و B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "sw": "Andika kazi ya Go `func calculateDistance(xa, ya, xb, yb float64) float64` kutatua tatizo lifuatalo:\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (float64): x-kiwianishi cha pointi A.\n- ya (float64): y-kiwianishi cha pointi A.\n- xb (float64): x-kiwianishi cha pointi B.\n- yb (float64): y-kiwianishi cha pointi B.\n\nInarejesha:\nfloat64: Umbali kati ya pointi A na B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "tr": "Bir Go fonksiyonu `func calculateDistance(xa, ya, xb, yb float64) float64` yazın ve aşağıdaki problemi çözün:\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (float64): A noktasının x-koordinatı.\n- ya (float64): A noktasının y-koordinatı.\n- xb (float64): B noktasının x-koordinatı.\n- yb (float64): B noktasının y-koordinatı.\n\nDöndürülen:\nfloat64: A ve B noktaları arasındaki mesafe.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "vi": "Viết một hàm Go `func calculateDistance(xa, ya, xb, yb float64) float64` để giải quyết vấn đề sau:\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (float64): tọa độ x của điểm A.\n- ya (float64): tọa độ y của điểm A.\n- xb (float64): tọa độ x của điểm B.\n- yb (float64): tọa độ y của điểm B.\n\nTrả về:\nfloat64: Khoảng cách giữa điểm A và B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9718596366580253",
      "sw": "1",
      "tr": "0.9944969452934285",
      "vi": "0.9990461769102704"
    },
    "level": "easy",
    "test": "func TestCalculateDistance(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.InDelta(5, calculateDistance(0, 0, 3, 4), 1e-6)\n\tassert.InDelta(0, calculateDistance(0, 0, 0, 0), 1e-6)\n\tassert.InDelta(4.242640687, calculateDistance(-1, -1, 2, 2), 1e-6)\n\tassert.InDelta(5.68243, calculateDistance(1.5, 3.9, 4.2, -1.1), 1e-6)\n}",
    "entry_point": "calculateDistance",
    "signature": "func calculateDistance(xa, ya, xb, yb float64) float64",
    "docstring": {
      "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (float64): coordenada x del punto A.\n- ya (float64): coordenada y del punto A.\n- xb (float64): coordenada x del punto B.\n- yb (float64): coordenada y del punto B.\n\nDevuelve:\nfloat64: La distancia entre los puntos A y B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعلمات:\n- xa (float64): الإحداثي السيني للنقطة A.\n- ya (float64): الإحداثي الصادي للنقطة A.\n- xb (float64): الإحداثي السيني للنقطة B.\n- yb (float64): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\nfloat64: المسافة بين النقطتين A و B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "sw": "Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (float64): x-kiwianishi cha pointi A.\n- ya (float64): y-kiwianishi cha pointi A.\n- xb (float64): x-kiwianishi cha pointi B.\n- yb (float64): y-kiwianishi cha pointi B.\n\nRudisha:\nfloat64: Umbali kati ya pointi A na B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "tr": "İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (float64): A noktasının x-koordinatı.\n- ya (float64): A noktasının y-koordinatı.\n- xb (float64): B noktasının x-koordinatı.\n- yb (float64): B noktasının y-koordinatı.\n\nDöndürür:\nfloat64: A ve B noktaları arasındaki mesafe.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (float64): tọa độ x của điểm A.\n- ya (float64): tọa độ y của điểm A.\n- xb (float64): tọa độ x của điểm B.\n- yb (float64): tọa độ y của điểm B.\n\nTrả về:\nfloat64: Khoảng cách giữa điểm A và B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9773676571241228",
      "sw": "1",
      "tr": "0.9971246266041389",
      "vi": "0.9988034505846458"
    }
  },
  {
    "task_id": "Go/5",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEncuentra el factorial de N y toma el módulo 10007 del resultado.\n\nParámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n\nDevuelve:\nint: El resultado después de tomar el módulo 10007 de la salida.\n\nEjemplos:\n    ExtraNumber(1)    // devuelve 1\n*/\nfunc processRequest(n int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاعثر على مضروب N وخذ باقي القسمة 10007 من النتيجة.\n\nالمعطيات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n\nالإرجاع:\nint: النتيجة بعد أخذ باقي القسمة 10007 من المخرجات.\n\nأمثلة:\n    ExtraNumber(1)    // يعيد 1\n*/\nfunc processRequest(n int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTafuta faktoria ya N na chukua modulo 10007 ya matokeo.\n\nVigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarejesha:\nint: Matokeo baada ya kuchukua modulo 10007 ya matokeo.\n\nMifano:\n    ExtraNumber(1)    // inarejesha 1\n*/\nfunc processRequest(n int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nN faktöriyelini bulun ve sonucun 10007 modunu alın.\n\nParametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n\nDöndürür:\nint: Çıktının 10007 modunu aldıktan sonraki sonucu.\n\nÖrnekler:\n    ExtraNumber(1)    // 1 döndürür\n*/\nfunc processRequest(n int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTìm giai thừa của N và lấy modulo 10007 của kết quả.\n\nTham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:\nint: Kết quả sau khi lấy modulo 10007 của đầu ra.\n\nVí dụ:\n    ExtraNumber(1)    // trả về 1\n*/\nfunc processRequest(n int) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9323997251616344",
      "sw": "0.9824863620433918",
      "tr": "0.9730043435439294",
      "vi": "0.9876167861551419"
    },
    "canonical_solution": "if n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}",
    "instruction": {
      "es": "Escribe una función en Go `func processRequest(n int) int` para resolver el siguiente problema:\nEncuentra el factorial de N y toma el módulo 10007 del resultado.\n\nParámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n\nDevuelve:\nint: El resultado después de tomar el módulo 10007 de la salida.\n\nEjemplos:\n    ExtraNumber(1)    // devuelve 1",
      "arb": "اكتب دالة Go `func processRequest(n int) int` لحل المشكلة التالية:\nابحث عن مضروب N وخذ باقي القسمة 10007 من النتيجة.\n\nالمعطيات:\n- N (int): عدد صحيح يمثل قيمة المدخلات (N <= 10000).\n\nالإرجاع:\nint: النتيجة بعد أخذ باقي القسمة 10007 من الناتج.\n\nأمثلة:\n    ExtraNumber(1)    // يعيد 1",
      "sw": "Andika kazi ya Go `func processRequest(n int) int` kutatua tatizo lifuatalo: Tafuta faktoria ya N na chukua modulo 10007 ya matokeo.\n\nVigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya pembejeo (N <= 10000).\n\nInarejesha:\nint: Matokeo baada ya kuchukua modulo 10007 ya matokeo.\n\nMifano:\n    ExtraNumber(1)    // inarejesha 1",
      "tr": "Bir Go fonksiyonu `func processRequest(n int) int` yazın ve aşağıdaki problemi çözün:\nN faktöriyelini bulun ve sonucun 10007 modunu alın.\n\nParametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n\nDöndürür:\nint: Çıktının 10007 modunu aldıktan sonraki sonuç.\n\nÖrnekler:\n    ExtraNumber(1)    // 1 döndürür",
      "vi": "Viết một hàm Go `func processRequest(n int) int` để giải quyết vấn đề sau:  \nTìm giai thừa của N và lấy modulo 10007 của kết quả.\n\nThông số:  \n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:  \nint: Kết quả sau khi lấy modulo 10007 của đầu ra.\n\nVí dụ:  \n    ExtraNumber(1)    // trả về 1"
    },
    "instruction_bertscore": {
      "es": "0.9946006303523286",
      "arb": "0.9277730276961887",
      "sw": "0.9892411854112453",
      "tr": "0.9651125598750322",
      "vi": "0.9860120513067611"
    },
    "level": "easy",
    "test": "func TestProcessRequest(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, processRequest(0), \"Factorial of 0 should be 1\")\n\tassert.Equal(1, processRequest(1), \"Factorial of 1 should be 1\")\n\tassert.Equal(2, processRequest(2), \"Factorial of 2 should be 2\")\n\tassert.Equal(6, processRequest(3), \"Factorial of 3 should be 6\")\n\tassert.Equal(24, processRequest(4), \"Factorial of 4 should be 24\")\n\tassert.Equal(6266, processRequest(10), \"Factorial of 10 modulus 10007 should be 6266\")\n\tassert.Equal(6991, processRequest(10000), \"Boundary condition for Factorial of 10000 modulus 10007 should be 6991\")\n}",
    "entry_point": "processRequest",
    "signature": "func processRequest(n int) int",
    "docstring": {
      "es": "Encuentra el factorial de N y toma el módulo 10007 del resultado.\n\nParámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n\nDevuelve:\nint: El resultado después de tomar el módulo 10007 de la salida.\n\nEjemplos:\n    ExtraNumber(1)    // devuelve 1",
      "arb": "ابحث عن مضروب N وخذ باقي القسمة 10007 من النتيجة.\n\nالمعطيات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n\nالقيم المعادة:\nint: النتيجة بعد أخذ باقي القسمة 10007 من الناتج.\n\nأمثلة:\n    ExtraNumber(1)    // يعيد 1",
      "sw": "Find the factorial of N and take the modulo 10007 of the result.\n\nVigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarejesha:\nint: Matokeo baada ya kuchukua modulo 10007 ya pato.\n\nMifano:\n    ExtraNumber(1)    // inarejesha 1",
      "tr": "Find the factorial of N and take the modulo 10007 of the result.\n\nParametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n\nDöndürür:\nint: Çıktının 10007 ile modunun alınmasından sonraki sonuç.\n\nÖrnekler:\n    ExtraNumber(1)    // 1 döndürür",
      "vi": "Tìm giai thừa của N và lấy phần dư 10007 của kết quả.\n\nTham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:\nint: Kết quả sau khi lấy phần dư 10007 của đầu ra.\n\nVí dụ:\n    ExtraNumber(1)    // trả về 1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.8991386705965804",
      "sw": "0.9752941545764996",
      "tr": "0.9756945934246659",
      "vi": "0.9504290075874091"
    }
  },
  {
    "task_id": "Go/6",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 calcula el área de un triángulo dado su base y altura.\n​\nParámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n​\nDevuelve:\n​float64: El área calculada del triángulo, redondeada a una precisión de float64.\n​\nEjemplos:\n\tcalculateTriangleArea2(1, 2) // devuelve 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nتحسب CalculateTriangleArea2 مساحة المثلث المعطى قاعدته وارتفاعه.\n\nالمعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n\nالقيم المعادة:\n​float64: المساحة المحسوبة للمثلث، مقربة إلى دقة float64.\n\nأمثلة:\n\tcalculateTriangleArea2(1, 2) // يعيد 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 huhesabu eneo la pembetatu ikipewa msingi wake na urefu.\n​\nVigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​\nInarejesha:\n​float64: Eneo lililohesabiwa la pembetatu, limezungushwa hadi usahihi wa float64.\n​\nMifano:\n\tcalculateTriangleArea2(1, 2) // inarejesha 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2, bir üçgenin taban ve yüksekliği verildiğinde alanını hesaplar.\n\nParametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n\nDöndürür:\n​float64: Hesaplanan üçgen alanı, float64 hassasiyetine yuvarlanmış olarak.\n\nÖrnekler:\n\tcalculateTriangleArea2(1, 2) // 1.0 döndürür\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n\nTham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n\nTrả về:\n​float64: Diện tích đã tính của tam giác, làm tròn đến độ chính xác float64.\n\nVí dụ:\n\tcalculateTriangleArea2(1, 2) // trả về 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {"
    },
    "prompt_bertscore": {
      "es": "0.9858513593285039",
      "arb": "0.9796135708424842",
      "sw": "0.9717811776575166",
      "tr": "0.9796135708424842",
      "vi": "0.9773483899771623"
    },
    "canonical_solution": "// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}",
    "instruction": {
      "es": "Escribe una función en Go `func calculateTriangleArea2(base, height int) float64` para resolver el siguiente problema:\nCalculateTriangleArea2 calcula el área de un triángulo dado su base y altura.\n\nParámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n\nDevuelve:\nfloat64: El área calculada del triángulo, redondeada a una precisión de float64.\n\nEjemplos:\n\tcalculateTriangleArea2(1, 2) // devuelve 1.0",
      "arb": "اكتب دالة Go `func calculateTriangleArea2(base, height int) float64` لحل المشكلة التالية:\nCalculateTriangleArea2 تحسب مساحة المثلث المعطى قاعدته وارتفاعه.\n\nالمعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n\nالقيم المعادة:\nfloat64: المساحة المحسوبة للمثلث، مقربة إلى دقة float64.\n\nأمثلة:\n\tcalculateTriangleArea2(1, 2) // يعيد 1.0",
      "sw": "Andika kazi ya Go `func calculateTriangleArea2(base, height int) float64` kutatua tatizo lifuatalo:\nCalculateTriangleArea2 huhesabu eneo la pembetatu ikizingatiwa msingi wake na urefu.\n\nVigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n\nInarejesha:\nfloat64: Eneo lililohesabiwa la pembetatu, lililozungushwa hadi usahihi wa float64.\n\nMifano:\n\tcalculateTriangleArea2(1, 2) // inarejesha 1.0",
      "tr": "Bir Go fonksiyonu `func calculateTriangleArea2(base, height int) float64` yazın ve aşağıdaki problemi çözün:\nCalculateTriangleArea2, bir üçgenin taban ve yüksekliği verildiğinde alanını hesaplar.\n\nParametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n\nDöndürür:\nfloat64: Hesaplanan üçgen alanı, float64 hassasiyetine yuvarlanmış olarak.\n\nÖrnekler:\n\tcalculateTriangleArea2(1, 2) // 1.0 döndürür",
      "vi": "Viết một hàm Go `func calculateTriangleArea2(base, height int) float64` để giải quyết vấn đề sau:\nCalculateTriangleArea2 tính diện tích của một tam giác dựa trên độ dài đáy và chiều cao của nó.\n\nTham số:\n- base (int): Độ dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n\nTrả về:\nfloat64: Diện tích được tính của tam giác, làm tròn đến độ chính xác float64.\n\nVí dụ:\n\tcalculateTriangleArea2(1, 2) // trả về 1.0"
    },
    "instruction_bertscore": {
      "es": "0.9779641441583705",
      "arb": "0.9849477897251762",
      "sw": "0.9894124047996974",
      "tr": "0.9921533054275978",
      "vi": "0.9839202747640827"
    },
    "level": "easy",
    "test": "func TestCalculateTriangleArea2(t *testing.T) {\n\t// Using testify for assert comparison with delta for approximation\n\tassert := assert.New(t)\n\n\t// Adding more comprehensive test cases and correcting the expected values\n\tassert.InDelta(1.0, calculateTriangleArea2(1, 2), 1e-6)    // Should assert true with close approximate comparison\n\tassert.InDelta(6.0, calculateTriangleArea2(3, 4), 1e-6)    // Should assert true with close approximate comparison\n\tassert.InDelta(20.0, calculateTriangleArea2(5, 8), 1e-6)   // Additional test case\n\tassert.InDelta(10.5, calculateTriangleArea2(7, 3), 1e-6)   // Additional test case\n\tassert.InDelta(50.0, calculateTriangleArea2(10, 10), 1e-6) // Additional test case\n}",
    "entry_point": "calculateTriangleArea2",
    "signature": "func calculateTriangleArea2(base, height int) float64",
    "docstring": {
      "es": "CalcularÁreaTriángulo2 calcula el área de un triángulo dada su base y altura.\n\nParámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n\nDevuelve:\nfloat64: El área calculada del triángulo, redondeada a una precisión de float64.\n\nEjemplos:\n\tcalculateTriangleArea2(1, 2) // devuelve 1.0",
      "arb": "احسب مساحة المثلث 2 يحسب مساحة المثلث بناءً على قاعدته وارتفاعه.\n\nالمعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n\nالقيم المعادة:\nfloat64: المساحة المحسوبة للمثلث، مقربة إلى دقة float64.\n\nأمثلة:\n\tcalculateTriangleArea2(1, 2) // يعيد 1.0",
      "sw": "CalculateTriangleArea2 huhesabu eneo la pembetatu ikizingatia msingi wake na urefu.\n\nVigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n\nInarejesha:\nfloat64: Eneo lililohesabiwa la pembetatu, limezungushwa hadi usahihi wa float64.\n\nMifano:\n\tcalculateTriangleArea2(1, 2) // inarejesha 1.0",
      "tr": "CalculateTriangleArea2, bir üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplar.\n\nParametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n\nDöndürülenler:\nfloat64: Hesaplanan üçgen alanı, float64 hassasiyetine yuvarlanmış olarak.\n\nÖrnekler:\n\tcalculateTriangleArea2(1, 2) // 1.0 döndürür",
      "vi": "CalculateTriangleArea2 tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n\nTham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n\nTrả về:\nfloat64: Diện tích đã tính của tam giác, được làm tròn đến độ chính xác float64.\n\nVí dụ:\n\tcalculateTriangleArea2(1, 2) // trả về 1.0"
    },
    "docstring_bertscore": {
      "es": "0.985897441576904",
      "arb": "0.9424873676928722",
      "sw": "0.985897441576904",
      "tr": "0.9840350831243209",
      "vi": "0.9760602719561511"
    }
  },
  {
    "task_id": "Go/7",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalcular la distancia de Hamming entre dos enteros.\n\nLa distancia de Hamming mide el número de bits diferentes entre\ndos valores enteros cuando se representan en forma binaria.\n\nParámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n\nDevuelve:\n- int: El número de bits que necesitan ser cambiados para convertir x en y.\n\nEjemplos:\n    hammingDistance(1, 2) // devuelve 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب مسافة هامنج بين عددين صحيحين.\n\nتقيس مسافة هامنج عدد البتات المختلفة بين قيمتين صحيحتين عند تمثيلهما في شكل ثنائي.\n\nالمعلمات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n\nالإرجاع:\n- int: عدد البتات التي تحتاج إلى قلب لتحويل x إلى y.\n\nأمثلة:\n    hammingDistance(1, 2) // يعيد 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu umbali wa Hamming kati ya nambari mbili.\n\nUmbali wa Hamming unapima idadi ya biti zinazotofautiana kati ya\nmaadili mawili ya nambari wakati yanawakilishwa katika mfumo wa binary.\n\nVigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n\nInarudisha:\n- int: Idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y.\n\nMifano:\n    hammingDistance(1, 2) // inarudisha 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nİki tamsayı arasındaki Hamming mesafesini hesaplayın.\n\nHamming mesafesi, iki tamsayı değeri ikili biçimde temsil edildiğinde\nfarklı olan bitlerin sayısını ölçer.\n\nParametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n\nDöndürülen:\n- int: x'i y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\nÖrnekler:\n    hammingDistance(1, 2) // 2 döndürür\n*/\nfunc hammingDistance(x int, y int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTính khoảng cách Hamming giữa hai số nguyên.\n\nKhoảng cách Hamming đo lường số lượng bit khác nhau giữa\nhai giá trị số nguyên khi được biểu diễn dưới dạng nhị phân.\n\nTham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n\nTrả về:\n- int: Số lượng bit cần thay đổi để chuyển đổi x thành y.\n\nVí dụ:\n    hammingDistance(1, 2) // trả về 2\n*/\nfunc hammingDistance(x int, y int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9938216019979098",
      "arb": "0.999413444484804",
      "sw": "0.9755559494187036",
      "tr": "0.9865149834315414",
      "vi": "0.9926075731090246"
    },
    "canonical_solution": "distance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}",
    "instruction": {
      "es": "Escribe una función en Go `func hammingDistance(x int, y int) int` para resolver el siguiente problema:\nCalcular la distancia de Hamming entre dos enteros.\n\nLa distancia de Hamming mide el número de bits diferentes entre\ndos valores enteros cuando se representan en forma binaria.\n\nParámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n\nDevuelve:\n- int: El número de bits que necesitan ser cambiados para convertir x en y.\n\nEjemplos:\n    hammingDistance(1, 2) // devuelve 2",
      "arb": "اكتب دالة Go `func hammingDistance(x int, y int) int` لحل المشكلة التالية:\nاحسب مسافة هامنج بين عددين صحيحين.\n\nتقيس مسافة هامنج عدد البتات المختلفة بين\nقيمتين صحيحتين عند تمثيلهما في شكل ثنائي.\n\nالمعطيات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n\nالمخرجات:\n- int: عدد البتات التي تحتاج إلى قلب لتحويل x إلى y.\n\nأمثلة:\n    hammingDistance(1, 2) // يعيد 2",
      "sw": "Andika kazi ya Go `func hammingDistance(x int, y int) int` kutatua tatizo lifuatalo:\nHesabu umbali wa Hamming kati ya nambari mbili.\n\nUmbali wa Hamming hupima idadi ya biti zinazotofautiana kati ya\nmaadili mawili ya nambari wakati yanawakilishwa katika mfumo wa binary.\n\nVigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n\nInarejesha:\n- int: Idadi ya biti zinazohitaji kubadilishwa ili kubadilisha x kuwa y.\n\nMifano:\n    hammingDistance(1, 2) // inarejesha 2",
      "tr": "Bir Go fonksiyonu `func hammingDistance(x int, y int) int` yazın ve aşağıdaki problemi çözün:\nİki tamsayı arasındaki Hamming mesafesini hesaplayın.\n\nHamming mesafesi, iki tamsayı değeri ikili biçimde temsil edildiğinde, farklı olan bitlerin sayısını ölçer.\n\nParametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n\nDöndürür:\n- int: x'i y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\nÖrnekler:\n    hammingDistance(1, 2) // 2 döndürür",
      "vi": "Viết một hàm Go `func hammingDistance(x int, y int) int` để giải quyết vấn đề sau:  \nTính khoảng cách Hamming giữa hai số nguyên.\n\nKhoảng cách Hamming đo lường số lượng bit khác nhau giữa hai giá trị số nguyên khi được biểu diễn dưới dạng nhị phân.\n\nTham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n\nTrả về:\n- int: Số bit cần phải thay đổi để chuyển đổi x thành y.\n\nVí dụ:\n    hammingDistance(1, 2) // trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9868725181174043",
      "arb": "0.9860678664438319",
      "sw": "0.97244400723903",
      "tr": "0.9785123640100268",
      "vi": "0.9921403944528305"
    },
    "level": "middle",
    "test": "func TestHammingDistance(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, hammingDistance(1, 2), \"1 and 2 should have a Hamming distance of 2\")\n\tassert.Equal(2, hammingDistance(4, 7), \"4 and 7 should have a Hamming distance of 2\")\n\tassert.Equal(3, hammingDistance(25, 30), \"25 and 30 should have a Hamming distance of 3\")\n\tassert.Equal(0, hammingDistance(0, 0), \"0 and 0 should have a Hamming distance of 0\")\n\tassert.Equal(28, hammingDistance(0xFFFFFFF, 0), \"0xFFFFFFF and 0 should have a Hamming distance of 28\")\n}",
    "entry_point": "hammingDistance",
    "signature": "func hammingDistance(x int, y int) int",
    "docstring": {
      "es": "Calcular la distancia de Hamming entre dos enteros.\n\nLa distancia de Hamming mide el número de bits diferentes entre\ndos valores enteros cuando se representan en forma binaria.\n\nParámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n\nDevuelve:\n- int: El número de bits que deben ser cambiados para convertir x en y.\n\nEjemplos:\n    hammingDistance(1, 2) // devuelve 2",
      "arb": "احسب مسافة هامنج بين عددين صحيحين.\n\nتقيس مسافة هامنج عدد البتات المختلفة بين قيمتين صحيحتين عند تمثيلهما في شكل ثنائي.\n\nالمعلمات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n\nالقيم المعادة:\n- int: عدد البتات التي تحتاج إلى قلب لتحويل x إلى y.\n\nأمثلة:\n    hammingDistance(1, 2) // يعيد 2",
      "sw": "Hesabu umbali wa Hamming kati ya nambari mbili za mzima.\n\nUmbali wa Hamming hupima idadi ya biti zinazotofautiana kati ya\nthamani mbili za mzima zinapowakilishwa katika mfumo wa binary.\n\nVigezo:\n- x (int): Nambari ya kwanza ya mzima chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili ya mzima chanya (y <= 1,000,000,000).\n\nInarejesha:\n- int: Idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y.\n\nMifano:\n    hammingDistance(1, 2) // inarejesha 2",
      "tr": "İki tamsayı arasındaki Hamming mesafesini hesaplayın.\n\nHamming mesafesi, iki tamsayı değeri ikili biçimde temsil edildiğinde farklı olan bitlerin sayısını ölçer.\n\nParametreler:\n- x (int): Birinci pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n\nDöndürür:\n- int: x'i y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\nÖrnekler:\n    hammingDistance(1, 2) // 2 döndürür",
      "vi": "Tính khoảng cách Hamming giữa hai số nguyên.\n\nKhoảng cách Hamming đo lường số lượng bit khác nhau giữa\nhai giá trị số nguyên khi được biểu diễn dưới dạng nhị phân.\n\nTham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n\nTrả về:\n- int: Số bit cần phải lật để chuyển đổi x thành y.\n\nVí dụ:\n    hammingDistance(1, 2) // trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9916215718975674",
      "arb": "0.9990221426341652",
      "sw": "0.9850997419666678",
      "tr": "0.9801818523626251",
      "vi": "0.9985909160769385"
    }
  },
  {
    "task_id": "Go/8",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCuenta la cantidad de enteros impares en una lista dada de números.\n\nParámetros:\n- count (int): La cantidad de números a evaluar.\n- nums ([]int): Un slice de enteros.\n\nDevuelve:\nint: La cantidad de números impares en la lista de entrada.\n\nEjemplos:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // devuelve 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n\nالمعلمات:\n- count (int): عدد الأرقام لتقييمها.\n- nums ([]int): شريحة من الأعداد الصحيحة.\n\nالإرجاع:\nint: عدد الأعداد الفردية في قائمة الإدخال.\n\nأمثلة:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // يعيد 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu idadi ya nambari zisizo za kawaida katika orodha ya nambari zilizotolewa.\n\nVigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- nums ([]int): Sehemu ya nambari za mzima.\n\nRudisha:\nint: Idadi ya nambari zisizo za kawaida katika orodha ya pembejeo.\n\nMifano:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // inarudisha 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen bir sayı listesinde tek sayıların sayısını hesaplayın.\n\nParametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- nums ([]int): Bir tamsayı dilimi.\n\nDöndürür:\nint: Girdi listesindeki tek sayıların sayısı.\n\nÖrnekler:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 döndürür\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nĐếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n\nTham số:\n- count (int): Số lượng số cần đánh giá.\n- nums ([]int): Một slice của các số nguyên.\n\nTrả về:\nint: Số lượng số lẻ trong danh sách đầu vào.\n\nVí dụ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // trả về 3\n*/\nfunc countOddNumbers(count int, nums []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9879973619652048",
      "arb": "0.9813333126814843",
      "sw": "0.9727328158130547",
      "tr": "0.976674437094311",
      "vi": "0.9921135793513908"
    },
    "canonical_solution": "ans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "Escribe una función en Go `func countOddNumbers(count int, nums []int) int` para resolver el siguiente problema:\nCuenta el número de enteros impares en una lista dada de números.\n\nParámetros:\n- count (int): La cantidad de números a evaluar.\n- nums ([]int): Un slice de enteros.\n\nDevuelve:\nint: La cantidad de números impares en la lista de entrada.\n\nEjemplos:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // devuelve 3",
      "arb": "اكتب دالة بلغة Go `func countOddNumbers(count int, nums []int) int` لحل المشكلة التالية:\nعد عدد الأعداد الفردية في قائمة الأرقام المعطاة.\n\nالمعطيات:\n- count (int): عدد الأرقام لتقييمها.\n- nums ([]int): شريحة من الأعداد الصحيحة.\n\nالقيم المعادة:\nint: عدد الأعداد الفردية في قائمة الإدخال.\n\nأمثلة:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // يعيد 3",
      "sw": "Andika kazi ya Go `func countOddNumbers(count int, nums []int) int` kutatua tatizo lifuatalo:\nHesabu idadi ya namba zisizo za jozi katika orodha iliyotolewa ya namba.\n\nVigezo:\n- count (int): Idadi ya namba za kutathmini.\n- nums ([]int): Sehemu ya namba za mzima.\n\nInarejesha:\nint: Idadi ya namba zisizo za jozi katika orodha ya pembejeo.\n\nMifano:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // inarejesha 3",
      "tr": "Bir Go fonksiyonu `func countOddNumbers(count int, nums []int) int` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n\nParametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- nums ([]int): Bir tamsayı dilimi.\n\nDöndürür:\nint: Girdi listesindeki tek sayıların sayısı.\n\nÖrnekler:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 döndürür",
      "vi": "Viết một hàm Go `func countOddNumbers(count int, nums []int) int` để giải quyết vấn đề sau:  \nĐếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n\nTham số:\n- count (int): Số lượng số cần đánh giá.\n- nums ([]int): Một slice các số nguyên.\n\nTrả về:\nint: Số lượng số lẻ trong danh sách đầu vào.\n\nVí dụ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // trả về 3"
    },
    "instruction_bertscore": {
      "es": "0.9875784504916022",
      "arb": "0.9687848383596053",
      "sw": "0.9690549756778127",
      "tr": "0.9737362964980429",
      "vi": "0.9908197010493296"
    },
    "level": "easy",
    "test": "func TestCountOddNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, countOddNumbers(5, []int{1, 4, 3, 2, 5}))\n\tassert.Equal(0, countOddNumbers(4, []int{2, 2, 0, 0}))\n\tassert.Equal(4, countOddNumbers(6, []int{7, 7, 8, 1, 9, 10})) // Additional Test Sample\n}",
    "entry_point": "countOddNumbers",
    "signature": "func countOddNumbers(count int, nums []int) int",
    "docstring": {
      "es": "Cuenta el número de enteros impares en una lista dada de números.\n\nParámetros:\n- count (int): La cantidad de números a evaluar.\n- nums ([]int): Un segmento de enteros.\n\nDevuelve:\nint: La cantidad de números impares en la lista de entrada.\n\nEjemplos:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // devuelve 3",
      "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n\nالمعلمات:\n- count (int): عدد الأرقام لتقييمها.\n- nums ([]int): شريحة من الأعداد الصحيحة.\n\nيعيد:\nint: عدد الأعداد الفردية في قائمة الإدخال.\n\nأمثلة:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // يعيد 3",
      "sw": "Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n\nVigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- nums ([]int): Sehemu ya nambari za mzima.\n\nRudisha:\nint: Idadi ya nambari zisizo za kawaida katika orodha ya ingizo.\n\nMifano:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // inarudisha 3",
      "tr": "Tek bir sayı listesindeki tek sayıların sayısını hesaplayın.\n\nParametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- nums ([]int): Bir tamsayı dilimi.\n\nDöndürür:\nint: Girdi listesindeki tek sayıların sayısı.\n\nÖrnekler:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 döndürür",
      "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n\nTham số:\n- count (int): Số lượng số cần đánh giá.\n- nums ([]int): Một mảng số nguyên.\n\nTrả về:\nint: Số lượng số lẻ trong danh sách đầu vào.\n\nVí dụ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.9747141538638777",
      "arb": "0.9732281999833557",
      "sw": "0.9557195277862734",
      "tr": "0.9678620016093171",
      "vi": "0.9715990335981075"
    }
  },
  {
    "task_id": "Go/9",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalcular la suma de números pares en una lista dada.\nParámetros:\n- numbers ([]int): Una porción de enteros.\n- size (int): La longitud de la porción.\nDevuelve:\nint: La suma de los números pares en la porción de entrada.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب مجموع الأرقام الزوجية في قائمة معينة.\nالمعلمات:\n- numbers ([]int): شريحة من الأعداد الصحيحة.\n- size (int): طول الشريحة.\nالقيم المعادة:\nint: مجموع الأرقام الزوجية في الشريحة المدخلة.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu jumla ya namba za jozi katika orodha iliyotolewa.\nVigezo:\n- numbers ([]int): Sehemu ya nambari za mzima.\n- size (int): Urefu wa sehemu hiyo.\nInarudisha:\nint: Jumla ya namba za jozi katika sehemu ya ingizo.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen bir listedeki çift sayıların toplamını hesaplayın.\nParametreler:\n- numbers ([]int): Bir tamsayı dilimi.\n- size (int): Dilimin uzunluğu.\nDöndürür:\nint: Girdi dilimindeki çift sayıların toplamı.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTính tổng các số chẵn trong một danh sách cho trước.\nTham số:\n- numbers ([]int): Một mảng số nguyên.\n- size (int): Độ dài của mảng.\nTrả về:\nint: Tổng các số chẵn trong mảng đầu vào.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9971651472018701",
      "arb": "0.999999801369619",
      "sw": "0.997056893644206",
      "tr": "0.999999801369619",
      "vi": "0.9777645206254305"
    },
    "canonical_solution": "ans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "Escribe una función en Go `func calculateEvenSum(numbers []int) int` para resolver el siguiente problema:\nCalcular la suma de los números pares en una lista dada.\nParámetros:\n- numbers ([]int): Un slice de enteros.\nDevuelve:\nint: La suma de los números pares en el slice de entrada.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n",
      "arb": "اكتب دالة Go `func calculateEvenSum(numbers []int) int` لحل المشكلة التالية:\nاحسب مجموع الأعداد الزوجية في قائمة معطاة.\nالمعلمات:\n- numbers ([]int): شريحة من الأعداد الصحيحة.\nالقيم المعادة:\nint: مجموع الأعداد الزوجية في الشريحة المدخلة.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "sw": "Andika kazi ya Go `func calculateEvenSum(numbers []int) int` kutatua tatizo lifuatalo:\nHesabu jumla ya namba shufwa katika orodha iliyotolewa.\nVigezo:\n- numbers ([]int): Sehemu ya namba za mzima.\nInarudisha:\nint: Jumla ya namba shufwa katika sehemu ya ingizo.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "tr": "Bir Go fonksiyonu `func calculateEvenSum(numbers []int) int` yazın ve aşağıdaki problemi çözün:\nVerilen bir listedeki çift sayıların toplamını hesaplayın.\nParametreler:\n- numbers ([]int): Bir tamsayı dilimi.\nDöndürür:\nint: Girdi dilimindeki çift sayıların toplamı.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "vi": "Viết một hàm Go `func calculateEvenSum(numbers []int) int` để giải quyết vấn đề sau:  \nTính tổng các số chẵn trong một danh sách cho trước.  \nTham số:  \n- numbers ([]int): Một slice của các số nguyên.  \nTrả về:  \nint: Tổng các số chẵn trong slice đầu vào.  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6"
    },
    "instruction_bertscore": {
      "es": "0.9857250304061657",
      "arb": "0.9932122039888948",
      "sw": "0.994494958989618",
      "tr": "0.9960816184733248",
      "vi": "1"
    },
    "level": "easy",
    "test": "func TestCalculateEvenSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, calculateEvenSum([]int{1, 4, 3, 2, 5}))\n\tassert.Equal(4, calculateEvenSum([]int{2, 2, 0, 0}))\n\tassert.Equal(0, calculateEvenSum([]int{7, 11, 19})) // Should return 0 because there are no even numbers\n\tassert.Equal(12+14+16+18+20, calculateEvenSum([]int{12, 14, 16, 18, 20}))\n}",
    "entry_point": "calculateEvenSum",
    "signature": "func calculateEvenSum(numbers []int) int",
    "docstring": {
      "es": "Calcular la suma de números pares en una lista dada.\nParámetros:\n- numbers ([]int): Un segmento de enteros.\nDevuelve:\nint: La suma de los números pares en el segmento de entrada.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "arb": "حساب مجموع الأرقام الزوجية في قائمة معينة.  \nالمعلمات:  \n- numbers ([]int): شريحة من الأعداد الصحيحة.  \nالقيم المعادة:  \nint: مجموع الأرقام الزوجية في الشريحة المدخلة.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "sw": "Hesabu jumla ya namba shufwa katika orodha iliyotolewa.  \nVigezo:  \n- numbers ([]int): Sehemu ya nambari za mzima.  \nInarudisha:  \nint: Jumla ya namba shufwa katika sehemu ya ingizo.  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "tr": "Verilen bir listedeki çift sayıların toplamını hesaplayın.\nParametreler:\n- numbers ([]int): Bir tamsayı dilimi.\nDöndürür:\nint: Girdi dilimindeki çift sayıların toplamı.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "vi": "Tính tổng các số chẵn trong một danh sách cho trước.  \nTham số:  \n- numbers ([]int): Một mảng các số nguyên.  \nTrả về:  \nint: Tổng các số chẵn trong mảng đầu vào.  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6"
    },
    "docstring_bertscore": {
      "es": "0.9950598637932813",
      "arb": "0.9917216816096089",
      "sw": "0.9395245969293559",
      "tr": "0.9999996027392379",
      "vi": "0.9762797585271947"
    }
  },
  {
    "task_id": "Go/10",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDeterminar si dos intervalos cerrados se intersectan.\n\nArgumentos:\na, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\nc, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n\nRetorna:\nint: 1 si los intervalos se intersectan, 0 en caso contrario.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nتحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n\nالمعطيات:\na, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\nc, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\n\nالإرجاع:\nint: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTambua kama vipindi viwili vilivyofungwa vinakatana.\n\nHoja:\na, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\nc, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n\nRudisha:\nint: 1 ikiwa vipindi vinakatana, 0 vinginevyo.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\n\nArgümanlar:\na, b: İlk kapalı aralığı temsil eder [a, b] burada 0 <= a <= b <= 1000.\nc, d: İkinci kapalı aralığı temsil eder [c, d] burada 0 <= c <= d <= 1000.\n\nDöndürür:\nint: Aralıklar kesişiyorsa 1, aksi takdirde 0.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nXác định xem hai khoảng đóng có giao nhau hay không.\n\nTham số:\na, b: Đại diện cho khoảng đóng đầu tiên [a, b] với điều kiện 0 <= a <= b <= 1000.\nc, d: Đại diện cho khoảng đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\n\nTrả về:\nint: 1 nếu các khoảng giao nhau, 0 nếu không.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9696502709297743",
      "sw": "0.9885841161107819",
      "tr": "0.9854640300854859",
      "vi": "0.96266305001611"
    },
    "canonical_solution": "if (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}",
    "instruction": {
      "es": "Escribe una función en Go `func AreIntervalsIntersecting(a, b, c, d int) int` para resolver el siguiente problema:\nDeterminar si dos intervalos cerrados se intersectan.\n\nArgumentos:\na, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\nc, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n\nDevuelve:\nint: 1 si los intervalos se intersectan, 0 en caso contrario.",
      "arb": "اكتب دالة Go `func AreIntervalsIntersecting(a, b, c, d int) int` لحل المشكلة التالية:\nتحديد ما إذا كانت فترتان مغلقتان تتقاطعان.\n\nالمعطيات:\na, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\nc, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\n\nالإرجاع:\nint: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.",
      "sw": "Andika kazi ya Go `func AreIntervalsIntersecting(a, b, c, d int) int` kutatua tatizo lifuatalo:\nTambua kama vipindi viwili vilivyofungwa vinaingiliana.\n\nHoja:\na, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\nc, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n\nInarudisha:\nint: 1 ikiwa vipindi vinaingiliana, 0 vinginevyo.",
      "tr": "Bir Go fonksiyonu `func AreIntervalsIntersecting(a, b, c, d int) int` yazın. Aşağıdaki problemi çözmek için:\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\n\nArgümanlar:\na, b: İlk kapalı aralığı temsil eder [a, b] burada 0 <= a <= b <= 1000.\nc, d: İkinci kapalı aralığı temsil eder [c, d] burada 0 <= c <= d <= 1000.\n\nDöndürür:\nint: Aralıklar kesişiyorsa 1, aksi takdirde 0.",
      "vi": "Viết một hàm Go `func AreIntervalsIntersecting(a, b, c, d int) int` để giải quyết vấn đề sau:\nXác định xem hai đoạn đóng có giao nhau hay không.\n\nTham số:\na, b: Đại diện cho đoạn đóng đầu tiên [a, b] với điều kiện 0 <= a <= b <= 1000.\nc, d: Đại diện cho đoạn đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\n\nTrả về:\nint: 1 nếu các đoạn giao nhau, 0 nếu không."
    },
    "instruction_bertscore": {
      "es": "0.9949400896735172",
      "arb": "0.9803419484497392",
      "sw": "0.9880486086035118",
      "tr": "0.9805042294710447",
      "vi": "0.952944462732835"
    },
    "level": "easy",
    "test": "func TestAreIntervalsIntersecting(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, AreIntervalsIntersecting(1, 1, 1, 2))\n\tassert.Equal(1, AreIntervalsIntersecting(3, 5, 2, 6))\n\tassert.Equal(1, AreIntervalsIntersecting(3, 5, 4, 7))\n\tassert.Equal(0, AreIntervalsIntersecting(3, 5, 6, 7))\n\t// Additional test cases\n\tassert.Equal(1, AreIntervalsIntersecting(0, 0, 0, 0))\n\tassert.Equal(1, AreIntervalsIntersecting(1, 3, 2, 4))\n\tassert.Equal(0, AreIntervalsIntersecting(1, 3, 4, 6))\n\tassert.Equal(1, AreIntervalsIntersecting(10, 20, 20, 30))\n\tassert.Equal(0, AreIntervalsIntersecting(10, 20, 21, 30))\n}",
    "entry_point": "AreIntervalsIntersecting",
    "signature": "func AreIntervalsIntersecting(a, b, c, d int) int",
    "docstring": {
      "es": "Determinar si dos intervalos cerrados se intersectan.\n\nArgumentos:\na, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\nc, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n\nDevuelve:\nint: 1 si los intervalos se intersectan, 0 en caso contrario.",
      "arb": "تحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n\nالأوساط:\na, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\nc, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\n\nالقيم المعادة:\nint: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.",
      "sw": "Determine if two closed intervals intersect.\n\nHoja:\na, b: Inawakilisha kipengele cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\nc, d: Inawakilisha kipengele cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n\nRudisha:\nint: 1 ikiwa vipengele vinaingiliana, 0 vinginevyo.",
      "tr": "Determine if two closed intervals intersect.\n\nArgümanlar:\na, b: İlk kapalı aralığı temsil eden [a, b] burada 0 <= a <= b <= 1000.\nc, d: İkinci kapalı aralığı temsil eden [c, d] burada 0 <= c <= d <= 1000.\n\nDöndürülen:\nint: Aralıklar kesişiyorsa 1, aksi takdirde 0.",
      "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n\nĐối số:\na, b: Đại diện cho khoảng đóng đầu tiên [a, b] nơi 0 <= a <= b <= 1000.\nc, d: Đại diện cho khoảng đóng thứ hai [c, d] nơi 0 <= c <= d <= 1000.\n\nTrả về:\nint: 1 nếu các khoảng giao nhau, 0 nếu không."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9536239772663554",
      "sw": "0.9828331706886787",
      "tr": "0.9817206419245024",
      "vi": "0.9664914519801764"
    }
  },
  {
    "task_id": "Go/11",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndür\nfunc HelloMMCODEEVAL() string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {"
    },
    "prompt_bertscore": {
      "es": "0.9982075594415412",
      "arb": "1",
      "sw": "1",
      "tr": "1",
      "vi": "0.9982075594415412"
    },
    "canonical_solution": "return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}",
    "instruction": {
      "es": "Escribe una función en Go `func HelloMMCODEEVAL() string` para resolver el siguiente problema:  \nDevuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "arb": "اكتب دالة Go `func HelloMMCODEEVAL() string` لحل المشكلة التالية:  \nإرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sw": "Andika kazi ya Go `func HelloMMCODEEVAL() string` kutatua tatizo lifuatalo:  \nRudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "tr": "Aşağıdaki problemi çözmek için bir Go fonksiyonu `func HelloMMCODEEVAL() string` yazın:\n\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndürün.",
      "vi": "Viết một hàm Go `func HelloMMCODEEVAL() string` để giải quyết vấn đề sau:  \nTrả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "instruction_bertscore": {
      "es": "0.9887360683522736",
      "arb": "0.999999801369619",
      "sw": "0.999999801369619",
      "tr": "0.9632805918707474",
      "vi": "0.999999801369619"
    },
    "level": "easy",
    "test": "func TestHelloMMCODEEVAL(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\", HelloMMCODEEVAL())\n}",
    "entry_point": "HelloMMCODEEVAL",
    "signature": "func HelloMMCODEEVAL() string",
    "docstring": {
      "es": "Devuelve \"Hello, MMCODEEVAL: Evaluación de Código Masivamente Multilingüe\"",
      "arb": "إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sw": "Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "tr": "\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndür",
      "vi": "Trả về \"Hello, MMCODEEVAL: Đánh giá mã đa ngôn ngữ khổng lồ\""
    },
    "docstring_bertscore": {
      "es": "0.956679309787434",
      "arb": "0.956679309787434",
      "sw": "0.8942376645749255",
      "tr": "0.999999801369619",
      "vi": "0.9195046408248495"
    }
  },
  {
    "task_id": "Go/12",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore calcula el puntaje total para un estudiante basado en los puntajes individuales en diferentes materias.\n\nParámetros:\n- scores (variadic ints): Lista de puntajes para cada materia.\n\nDevuelve:\n- int: El puntaje total obtenido al sumar los puntajes individuales.\n\nEjemplos:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // devuelve 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore تحسب الدرجة الإجمالية لطالب بناءً على الدرجات الفردية في مواد مختلفة.\n\nالمعلمات:\n- scores (variadic ints): قائمة الدرجات لكل مادة.\n\nالإرجاع:\n- int: الدرجة الإجمالية المحصلة عن طريق جمع الدرجات الفردية.\n\nأمثلة:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // يعيد 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore huhesabu jumla ya alama kwa mwanafunzi kulingana na alama za kila somo tofauti.\n\nVigezo:\n- scores (variadic ints): Orodha ya alama kwa kila somo.\n\nInarudisha:\n- int: Jumla ya alama inayopatikana kwa kujumlisha alama za kila somo.\n\nMifano:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // inarudisha 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore, farklı derslerdeki bireysel puanlara dayanarak bir öğrenci için toplam puanı hesaplar.\n\nParametreler:\n- scores (değişken sayıda int): Her ders için puan listesi.\n\nDöndürülen:\n- int: Bireysel puanların toplanmasıyla elde edilen toplam puan.\n\nÖrnekler:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 500 döndürür\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore tính tổng điểm cho một học sinh dựa trên điểm số cá nhân trong các môn học khác nhau.\n\nTham số:\n- scores (variadic ints): Danh sách điểm số cho mỗi môn học.\n\nTrả về:\n- int: Tổng điểm đạt được bằng cách cộng các điểm số cá nhân lại.\n\nVí dụ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // trả về 500\n*/\nfunc CalculateTotalScore(scores ...int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9867988262460403",
      "arb": "0.9858080579054382",
      "sw": "0.9757140592020074",
      "tr": "0.9655561015158831",
      "vi": "0.9812657783519324"
    },
    "canonical_solution": "total := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}",
    "instruction": {
      "es": "Escribe una función en Go `func CalculateTotalScore(scores ...int) int` para resolver el siguiente problema:\nCalculateTotalScore calcula el puntaje total para un estudiante basado en las calificaciones individuales en diferentes materias.\n\nParámetros:\n- scores (variadic ints): Lista de calificaciones para cada materia.\n\nDevuelve:\n- int: El puntaje total obtenido al sumar las calificaciones individuales.\n\nEjemplos:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // devuelve 500",
      "arb": "اكتب دالة بلغة Go `func CalculateTotalScore(scores ...int) int` لحل المشكلة التالية:\nتحسب CalculateTotalScore المجموع الكلي للدرجات لطالب بناءً على الدرجات الفردية في مواد مختلفة.\n\nالمعلمات:\n- scores (variadic ints): قائمة الدرجات لكل مادة.\n\nالقيم المعادة:\n- int: المجموع الكلي للدرجات المحصل عليه من جمع الدرجات الفردية.\n\nأمثلة:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // يعيد 500",
      "sw": "Andika kazi ya Go `func CalculateTotalScore(scores ...int) int` kutatua tatizo lifuatalo:  \nCalculateTotalScore huhesabu jumla ya alama kwa mwanafunzi kulingana na alama za kila somo tofauti.\n\nVigezo:  \n- scores (variadic ints): Orodha ya alama kwa kila somo.\n\nInarejesha:  \n- int: Jumla ya alama inayopatikana kwa kujumlisha alama za kila moja.\n\nMifano:  \n\tcalculateTotalScore(100, 100, 100, 100, 100) // inarejesha 500",
      "tr": "Bir Go fonksiyonu `func CalculateTotalScore(scores ...int) int` yazın: \nCalculateTotalScore, bir öğrencinin farklı derslerdeki bireysel puanlarına dayanarak toplam puanı hesaplar.\n\nParametreler:\n- scores (değişken sayıda int): Her bir ders için puan listesi.\n\nDöndürür:\n- int: Bireysel puanların toplamının elde ettiği toplam puan.\n\nÖrnekler:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 500 döndürür",
      "vi": "Viết một hàm Go `func CalculateTotalScore(scores ...int) int` để giải quyết vấn đề sau:  \nCalculateTotalScore tính tổng điểm cho một học sinh dựa trên điểm số cá nhân trong các môn học khác nhau.\n\nTham số:\n- scores (biến đổi ints): Danh sách điểm số cho mỗi môn học.\n\nTrả về:\n- int: Tổng điểm đạt được bằng cách cộng các điểm số cá nhân.\n\nVí dụ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // trả về 500"
    },
    "instruction_bertscore": {
      "es": "0.9730255969947001",
      "arb": "0.9887175957268373",
      "sw": "0.9687558383239742",
      "tr": "0.9475452917155447",
      "vi": "0.982555286785611"
    },
    "level": "easy",
    "test": "func TestCalculateTotalScore(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(500, CalculateTotalScore(100, 100, 100, 100, 100), \"should return the correct total score\")\n\tassert.Equal(0, CalculateTotalScore(0, 0, 0, 0, 0), \"should handle zero scores correctly\")\n\tassert.Equal(150, CalculateTotalScore(20, 30, 40, 10, 50), \"should return the correct total score for varied inputs\")\n\tassert.Equal(236, CalculateTotalScore(23, 45, 67, 89, 12), \"should return the correct total score for varied inputs\")\n\tassert.Equal(25, CalculateTotalScore(5, 5, 5, 5, 5), \"should return the correct total score for uniform inputs\")\n}",
    "entry_point": "CalculateTotalScore",
    "signature": "func CalculateTotalScore(scores ...int) int",
    "docstring": {
      "es": "CalculateTotalScore calcula el puntaje total para un estudiante basado en los puntajes individuales en diferentes materias.\n\nParámetros:\n- scores (variadic ints): Lista de puntajes para cada materia.\n\nDevuelve:\n- int: El puntaje total obtenido al sumar los puntajes individuales.\n\nEjemplos:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // devuelve 500",
      "arb": "CalculateTotalScore يحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات الفردية في مواد مختلفة.\n\nالمعطيات:\n- scores (variadic ints): قائمة بالدرجات لكل مادة.\n\nالقيم المعادة:\n- int: المجموع الكلي الذي يتم الحصول عليه من جمع الدرجات الفردية.\n\nأمثلة:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // يعيد 500",
      "sw": "CalculateTotalScore huhesabu jumla ya alama kwa mwanafunzi kulingana na alama za kila somo tofauti.\n\nVigezo:\n- scores (variadic ints): Orodha ya alama kwa kila somo.\n\nInarejesha:\n- int: Jumla ya alama iliyopatikana kwa kujumlisha alama za kila somo.\n\nMifano:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // inarejesha 500",
      "tr": "CalculateTotalScore, bir öğrencinin farklı derslerdeki bireysel puanlarına dayanarak toplam puanı hesaplar.\n\nParametreler:\n- scores (değişken sayıda int): Her ders için puanların listesi.\n\nDöndürülen:\n- int: Bireysel puanların toplanmasıyla elde edilen toplam puan.\n\nÖrnekler:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 500 döndürür",
      "vi": "CalculateTotalScore tính tổng điểm cho một học sinh dựa trên điểm số cá nhân trong các môn học khác nhau.\n\nTham số:\n- scores (variadic ints): Danh sách điểm số cho mỗi môn học.\n\nTrả về:\n- int: Tổng điểm đạt được bằng cách cộng các điểm số cá nhân.\n\nVí dụ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // trả về 500"
    },
    "docstring_bertscore": {
      "es": "0.9871807924687704",
      "arb": "0.9728680831025395",
      "sw": "0.9622961797023386",
      "tr": "0.9514678444802216",
      "vi": "0.9762841283955774"
    }
  },
  {
    "task_id": "Go/13",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers decodifica una serie de números para revelar el patrón oculto que indica\nlos valores reales que representa cada dígito. El patrón se define de la siguiente manera:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- dataStr: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado correspondiente a cada cadena de datos según el patrón predefinido.\n\nEjemplo de uso:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers يقوم بفك ترميز سلسلة من الأرقام للكشف عن النمط المخفي الذي يشير إلى\nالقيم الفعلية التي يمثلها كل رقم. يتم تعريف النمط كما يلي:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعطيات:\n- dataStr: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: النتيجة المقابلة لكل سلسلة بيانات وفقًا للنمط المحدد مسبقًا.\n\nمثال على الاستخدام:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers inatafsiri mfululizo wa namba ili kufichua muundo uliofichwa ambao unaonyesha\nthamani halisi ambayo kila tarakimu inawakilisha. Muundo umefafanuliwa kama ifuatavyo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- dataStr: Kamba inayowakilisha mfululizo wa namba. Urefu hauzidi 100.\n\nInarudisha:\nint: Matokeo yanayolingana na kila kamba ya data kulingana na muundo uliowekwa awali.\n\nMfano wa matumizi:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers, her bir rakamın temsil ettiği gerçek değerleri gösteren gizli deseni ortaya çıkarmak için bir dizi sayıyı çözer. Desen aşağıdaki gibi tanımlanmıştır:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- dataStr: Bir dizi sayıyı temsil eden bir string. Uzunluğu 100'ü geçmez.\n\nDöndürür:\nint: Önceden tanımlanmış desene göre her bir veri dizesine karşılık gelen sonuç.\n\nÖrnek kullanım:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers giải mã một chuỗi số để tiết lộ mẫu ẩn chỉ ra\ngiá trị thực mà mỗi chữ số đại diện. Mẫu được định nghĩa như sau:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- dataStr: Một chuỗi đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả tương ứng với mỗi chuỗi dữ liệu theo mẫu được định nghĩa trước.\n\nVí dụ sử dụng:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {"
    },
    "prompt_bertscore": {
      "es": "0.9924810455563053",
      "arb": "0.9813631072386395",
      "sw": "0.9790643578389228",
      "tr": "0.9919032297778748",
      "vi": "0.9883580747371642"
    },
    "canonical_solution": "a := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "Escribe una función en Go `func DecodeNumbers(dataStr string) int` para resolver el siguiente problema:\nDecodeNumbers decodifica una serie de números para revelar el patrón oculto que indica los valores reales que representa cada dígito. El patrón se define de la siguiente manera:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- dataStr: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado correspondiente a cada cadena de datos según el patrón predefinido.\n\nEjemplo de uso:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "arb": "اكتب دالة Go `func DecodeNumbers(dataStr string) int` لحل المشكلة التالية:\nDecodeNumbers تقوم بفك تشفير سلسلة من الأرقام للكشف عن النمط المخفي الذي يشير إلى القيم الفعلية التي يمثلها كل رقم. يتم تعريف النمط كما يلي:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- dataStr: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: النتيجة المقابلة لكل سلسلة بيانات وفقًا للنمط المحدد مسبقًا.\n\nمثال على الاستخدام:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "sw": "Andika kazi ya Go `func DecodeNumbers(dataStr string) int` kutatua tatizo lifuatalo:\nDecodeNumbers inafasiri mfululizo wa nambari ili kufichua muundo uliofichwa ambao unaonyesha\nthamani halisi kila tarakimu inawakilisha. Muundo umefafanuliwa kama ifuatavyo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- dataStr: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarudisha:\nint: Matokeo yanayolingana na kila kamba ya data kulingana na muundo uliowekwa.\n\nMfano wa matumizi:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "tr": "Bir Go fonksiyonu `func DecodeNumbers(dataStr string) int` yazın ve aşağıdaki problemi çözün:\nDecodeNumbers, her bir rakamın temsil ettiği gerçek değerleri gösteren gizli deseni ortaya çıkarmak için bir dizi sayıyı çözer. Desen aşağıdaki gibi tanımlanmıştır:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- dataStr: Bir dizi sayıyı temsil eden bir string. Uzunluğu 100'ü geçmez.\n\nDöndürülen:\nint: Önceden tanımlanmış desene göre her bir veri dizisine karşılık gelen sonuç.\n\nÖrnek kullanım:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "vi": "Viết một hàm Go `func DecodeNumbers(dataStr string) int` để giải quyết vấn đề sau:\nDecodeNumbers giải mã một chuỗi các số để tiết lộ mẫu ẩn mà chỉ ra giá trị thực mà mỗi chữ số đại diện. Mẫu được định nghĩa như sau:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- dataStr: Một chuỗi đại diện cho một chuỗi các số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả tương ứng với mỗi chuỗi dữ liệu theo mẫu đã định trước.\n\nVí dụ sử dụng:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))"
    },
    "instruction_bertscore": {
      "es": "0.9853833861507857",
      "arb": "0.9896992270699118",
      "sw": "0.975689826295521",
      "tr": "0.9887372601345598",
      "vi": "0.9891688839525485"
    },
    "level": "easy",
    "test": "func TestDecodeNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, DecodeNumbers(\"0000\"))\n\tassert.Equal(8, DecodeNumbers(\"8888\"))\n\tassert.Equal(1, DecodeNumbers(\"1234\"))\n\tassert.Equal(3, DecodeNumbers(\"5678\"))\n\tassert.Equal(2, DecodeNumbers(\"9012\"))\n\tassert.Equal(0, DecodeNumbers(\"1357\"))\n\tassert.Equal(4, DecodeNumbers(\"2468\"))\n\n\t// Additional test samples\n\tassert.Equal(4, DecodeNumbers(\"9999\"))\n\tassert.Equal(0, DecodeNumbers(\"1111\"))\n\tassert.Equal(0, DecodeNumbers(\"2222\"))\n\tassert.Equal(0, DecodeNumbers(\"3333\"))\n\tassert.Equal(4, DecodeNumbers(\"4444\"))\n\tassert.Equal(0, DecodeNumbers(\"5555\"))\n\tassert.Equal(4, DecodeNumbers(\"6666\"))\n\tassert.Equal(0, DecodeNumbers(\"7777\"))\n\tassert.Equal(3, DecodeNumbers(\"0001\"))\n\tassert.Equal(1, DecodeNumbers(\"2301\"))\n}",
    "entry_point": "DecodeNumbers",
    "signature": "func DecodeNumbers(dataStr string) int",
    "docstring": {
      "es": "DecodeNumbers decodifica una serie de números para revelar el patrón oculto que indica los valores reales que representa cada dígito. El patrón se define de la siguiente manera:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- dataStr: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado correspondiente a cada cadena de datos según el patrón predefinido.\n\nEjemplo de uso:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "arb": "DecodeNumbers يقوم بفك تشفير سلسلة من الأرقام للكشف عن النمط المخفي الذي يشير إلى القيم الفعلية التي يمثلها كل رقم. يتم تعريف النمط كما يلي:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعطيات:\n- dataStr: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: النتيجة المقابلة لكل سلسلة بيانات وفقًا للنمط المحدد مسبقًا.\n\nمثال على الاستخدام:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "sw": "DecodeNumbers inafasiri mfululizo wa nambari ili kufichua muundo uliofichwa ambao unaonyesha\nthamani halisi ambayo kila tarakimu inawakilisha. Muundo umefafanuliwa kama ifuatavyo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- dataStr: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo yanayolingana na kila kamba ya data kulingana na muundo uliofafanuliwa awali.\n\nMfano wa matumizi:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "tr": "DecodeNumbers, her bir rakamın temsil ettiği gerçek değerleri gösteren gizli deseni ortaya çıkarmak için bir dizi sayıyı çözer. Desen şu şekilde tanımlanmıştır:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- dataStr: Bir dizi sayıyı temsil eden bir dize. Uzunluğu 100'ü geçmez.\n\nDöndürür:\nint: Önceden tanımlanmış desene göre her veri dizisine karşılık gelen sonuç.\n\nÖrnek kullanım:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "vi": "DecodeNumbers giải mã một chuỗi số để tiết lộ mẫu ẩn chỉ ra các giá trị thực mà mỗi chữ số đại diện. Mẫu được định nghĩa như sau: 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- dataStr: Một chuỗi đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả tương ứng với mỗi chuỗi dữ liệu theo mẫu đã định trước.\n\nVí dụ sử dụng:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))"
    },
    "docstring_bertscore": {
      "es": "0.9919566613503732",
      "arb": "0.964791970440042",
      "sw": "0.9741675230552697",
      "tr": "0.9782543431450625",
      "vi": "0.9820785738711272"
    }
  },
  {
    "task_id": "Go/14",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods cuenta el número de diferentes métodos de coloreado para n cuadrados\ncon m colores, considerando el requisito de que los cuadrados adyacentes y los\nprimeros/últimos cuadrados deben tener colores diferentes.\n\nArgumentos:\n    n int: El número de cuadrados.\n    m int: El número de colores.\n\nDevuelve:\n    int: El conteo de diferentes métodos de coloreado que satisfacen las condiciones especificadas.\n\nEjemplos:\n    CountColoringMethods(1,1) devuelve 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods يحسب عدد طرق التلوين المختلفة لمربعات n\nبألوان m، مع مراعاة الشرط الذي يتطلب أن تكون المربعات المتجاورة و\nالمربعات الأولى/الأخيرة بألوان مختلفة.\n\nيعيدالحجج:\n    n int: عدد المربعات.\n    m int: عدد الألوان.\n\nيعيد:\n    int: عدد طرق التلوين المختلفة التي تلبي الشروط المحددة.\n\nامثله:\n    CountColoringMethods(1,1) يعيد 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods huhesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n\nna rangi m, kwa kuzingatia hitaji kwamba miraba inayopakana na\nmiraba ya kwanza/ya mwisho lazima iwe na rangi tofauti.\n\nيعيدالحجج:\n    n int: Idadi ya miraba.\n    m int: Idadi ya rangi.\n\nHoja:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti maalum.\n\n Mifano:\n    CountColoringMethods(1,1) inarejesha 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods, n kare için m renk ile farklı boyama yöntemlerinin sayısını sayar,\nbitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını göz önünde bulundurarak.\n\nArgümanlar:\n    n int: Karelerin sayısı.\n    m int: Renklerin sayısı.\n\nDöndürür:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\n\nÖrnekler:\n    CountColoringMethods(1,1) 1 döndürür\n*/\nfunc CountColoringMethods(n, m int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods đếm số lượng phương pháp tô màu khác nhau cho n ô vuông\nvới m màu, xem xét yêu cầu rằng các ô vuông liền kề và các\nô vuông đầu/cuối phải có màu khác nhau.\n\nTham số:\n    n int: Số lượng ô vuông.\n    m int: Số lượng màu.\n\nTrả về:\n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định.\n\nVí dụ:\n    CountColoringMethods(1,1) trả về 1\n*/\nfunc CountColoringMethods(n, m int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9947984662118394",
      "arb": "0.9732248232668781",
      "sw": "0.9720018560108463",
      "tr": "0.9703456758937774",
      "vi": "0.9675328710679424"
    },
    "canonical_solution": "const mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}",
    "instruction": {
      "es": "Escribe una función de Go `func CountColoringMethods(n, m int) int` para resolver el siguiente problema:\nCountColoringMethods cuenta el número de diferentes métodos de coloreo para n cuadrados\ncon m colores, considerando el requisito de que los cuadrados adyacentes y los\nprimeros/últimos cuadrados deben tener colores diferentes.\n\nArgumentos:\n    n int: El número de cuadrados.\n    m int: El número de colores.\n\nDevuelve:\n    int: El conteo de diferentes métodos de coloreo que satisfacen las condiciones especificadas.\n\nEjemplos:\n    CountColoringMethods(1,1) devuelve 1",
      "arb": "اكتب دالة Go `func CountColoringMethods(n, m int) int` لحل المشكلة التالية:\nCountColoringMethods تحسب عدد طرق التلوين المختلفة لـ n مربعات\nبـ m ألوان، مع الأخذ في الاعتبار أن المربعات المتجاورة والمربعات\nالأولى/الأخيرة يجب أن تكون بألوان مختلفة.\n\nالمعاملات:\n    n int: عدد المربعات.\n    m int: عدد الألوان.\n\nالإرجاع:\n    int: عدد طرق التلوين المختلفة التي تفي بالشروط المحددة.\n\nأمثلة:\n    CountColoringMethods(1,1) يرجع 1",
      "sw": "Andika kazi ya Go `func CountColoringMethods(n, m int) int` kutatua tatizo lifuatalo:\nCountColoringMethods huhesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n\nkwa rangi m, kwa kuzingatia hitaji kwamba miraba iliyo karibu na\nmiraba ya kwanza/ya mwisho lazima iwe na rangi tofauti.\n\nHoja:\n    n int: Idadi ya miraba.\n    m int: Idadi ya rangi.\n\nInarudisha:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti maalum.\n\nMifano:\n    CountColoringMethods(1,1) inarudisha 1",
      "tr": "Bir Go fonksiyonu `func CountColoringMethods(n, m int) int` yazın ve aşağıdaki problemi çözün:\nCountColoringMethods, n kareyi m renk ile boyamak için farklı yöntemlerin sayısını sayar, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını göz önünde bulundurur.\n\nArgümanlar:\n    n int: Karelerin sayısı.\n    m int: Renklerin sayısı.\n\nDöndürür:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\n\nÖrnekler:\n    CountColoringMethods(1,1) 1 döndürür",
      "vi": "Viết một hàm Go `func CountColoringMethods(n, m int) int` để giải quyết vấn đề sau:  \nCountColoringMethods đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và các ô đầu/cuối phải có màu khác nhau.\n\nTham số:\n    n int: Số lượng ô vuông.\n    m int: Số lượng màu.\n\nTrả về:\n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định.\n\nVí dụ:\n    CountColoringMethods(1,1) trả về 1"
    },
    "instruction_bertscore": {
      "es": "0.9957439468255654",
      "arb": "0.9559501376586549",
      "sw": "0.9660763144838135",
      "tr": "0.9519497217846122",
      "vi": "0.9733585015133146"
    },
    "level": "hard",
    "test": "func TestCountColoringMethods(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, CountColoringMethods(1, 1))\n\tassert.Equal(2, CountColoringMethods(2, 2))\n\tassert.Equal(6, CountColoringMethods(3, 3))\n\tassert.Equal(2, CountColoringMethods(4, 2))\n\t// Add your tests here\n\tassert.Equal(6, CountColoringMethods(2, 3))\n\tassert.Equal(67911, CountColoringMethods(1000, 1000))\n\tassert.Equal(501817, CountColoringMethods(999, 66))\n\tassert.Equal(30, CountColoringMethods(5, 3))\n\n\t// Test with unknown expected result, assuming a placeholder value is \"expectedResult\".\n\t// Replace \"expectedResult\" with the actual expected value if known.\n\texpectedResult := 566585 // Placeholder for the expected result of CountColoringMethods(1000, 10)\n\tassert.Equal(expectedResult, CountColoringMethods(1000, 10))\n}",
    "entry_point": "CountColoringMethods",
    "signature": "func CountColoringMethods(n, m int) int",
    "docstring": {
      "es": "CountColoringMethods cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n\nArgumentos:\n    n int: El número de cuadrados.\n    m int: El número de colores.\n\nDevuelve:\n    int: El conteo de diferentes métodos de coloreado que satisfacen las condiciones especificadas.\n\nEjemplos:\n    CountColoringMethods(1,1) devuelve 1",
      "arb": "CountColoringMethods يحسب عدد طرق التلوين المختلفة لـ n مربعات باستخدام m ألوان، مع الأخذ في الاعتبار أن المربعات المتجاورة والمربعات الأولى/الأخيرة يجب أن تكون بألوان مختلفة.\n\nيعيدالحجج:\n    n int: عدد المربعات.\n    m int: عدد الألوان.\n\nيعيد:\n    int: عدد طرق التلوين المختلفة التي تفي بالشروط المحددة.\n\nامثله:\n    CountColoringMethods(1,1) يعيد 1",
      "sw": "CountColoringMethods huhesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n na rangi m, kwa kuzingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho lazima iwe na rangi tofauti.\n\nHoja:\n    n int: Idadi ya miraba.\n    m int: Idadi ya rangi.\n\nInarudisha:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti maalum.\n\nMifano:\n    CountColoringMethods(1,1) inarudisha 1",
      "tr": "CountColoringMethods, n kareyi m renkle boyamak için farklı boyama yöntemlerinin sayısını, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerekliliğini dikkate alarak sayar.\n\nArgümanlar:\n    n int: Karelerin sayısı.\n    m int: Renklerin sayısı.\n\nDöndürür:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\n\nÖrnekler:\n    CountColoringMethods(1,1)  1 döndürür ",
      "vi": "CountColoringMethods đếm số lượng các phương pháp tô màu khác nhau cho n ô vuông với m màu sắc, xem xét yêu cầu rằng các ô vuông liền kề và các ô vuông đầu/cuối phải có màu khác nhau.\n\nTham số  :\n    n int: Số lượng ô vuông.\n    m int: Số lượng màu sắc.\n\nTrả về:\n    int: Số lượng các phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định.\n\nVí dụ:\n    CountColoringMethods(1,1) trả về 1"
    },
    "docstring_bertscore": {
      "es": "0.9929988749596633",
      "arb": "0.9514740020220337",
      "sw": "0.948014258045168",
      "tr": "0.9630676601022781",
      "vi": "0.9828609789420236"
    }
  },
  {
    "task_id": "Go/15",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\nParámetros:\n- n (int): El número de lanzamientos de moneda.\nDevuelve:\n- uint64: El conteo de secuencias válidas.\nEjemplo:\n    countValidCoinTossSequences(1)\n    // Devuelve: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n من الرميات.\nالمعلمات:\n- n (int): عدد رميات العملة.\nيعيد:\n- uint64: عدد التسلسلات الصحيحة.\nمثال:\n    countValidCoinTossSequences(1)\n    // يعيد: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu idadi ya mfuatano sahihi wa kurusha sarafu bila vichwa vinavyofuatana katika kurusha mara n.\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\nInarudisha:\n- uint64: Idadi ya mfuatano sahihi.\nMfano:\n    countValidCoinTossSequences(1)\n    // Inarudisha: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nArdışık yazı gelmeyen geçerli para atışı dizilerinin sayısını n atışta sayın.\nParametreler:\n- n (int): Para atışlarının sayısı.\nDöndürür:\n- uint64: Geçerli dizilerin sayısı.\nÖrnek:\n    countValidCoinTossSequences(1)\n    // Döndürür: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nĐếm số lượng chuỗi tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\nTham số:\n- n (int): Số lần tung đồng xu.\nTrả về:\n- uint64: Số lượng chuỗi hợp lệ.\nVí dụ:\n    countValidCoinTossSequences(1)\n    // Trả về: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {"
    },
    "prompt_bertscore": {
      "es": "0.9863670037976704",
      "arb": "0.978917371356957",
      "sw": "0.9751360447931958",
      "tr": "0.9858517565892659",
      "vi": "0.9842084874469643"
    },
    "canonical_solution": "var a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}",
    "instruction": {
      "es": "Escribe una función en Go `func CountValidCoinTossSequences(n int) uint64` para resolver el siguiente problema:\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\nParámetros:\n- n (int): El número de lanzamientos de moneda.\nDevuelve:\n- uint64: El conteo de secuencias válidas.\nEjemplo:\n    countValidCoinTossSequences(1)\n    // Devuelve: 2",
      "arb": "اكتب دالة Go `func CountValidCoinTossSequences(n int) uint64` لحل المشكلة التالية:\nاحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\nالمعلمات:\n- n (int): عدد رميات العملة.\nيعيد:\n- uint64: عدد التسلسلات الصحيحة.\nمثال:\n    countValidCoinTossSequences(1)\n    // يعيد: 2",
      "sw": "Andika kazi ya Go `func CountValidCoinTossSequences(n int) uint64` kutatua tatizo lifuatalo:\nHesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa vinavyofuatana katika kurusha mara n.\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\nInarudisha:\n- uint64: Idadi ya mfuatano halali.\nMfano:\n    countValidCoinTossSequences(1)\n    // Inarudisha: 2",
      "tr": "Bir Go fonksiyonu `func CountValidCoinTossSequences(n int) uint64` yazın ve aşağıdaki problemi çözün:\nn atışında ardışık yazı olmayan geçerli madeni para atış dizilerinin sayısını sayın.\nParametreler:\n- n (int): Madeni para atışlarının sayısı.\nDöndürür:\n- uint64: Geçerli dizilerin sayısı.\nÖrnek:\n    countValidCoinTossSequences(1)\n    // Döndürür: 2",
      "vi": "Viết một hàm Go `func CountValidCoinTossSequences(n int) uint64` để giải quyết vấn đề sau:\nĐếm số lượng dãy tung đồng xu hợp lệ không có hai mặt ngửa liên tiếp trong n lần tung.\nTham số:\n- n (int): Số lần tung đồng xu.\nTrả về:\n- uint64: Số lượng dãy hợp lệ.\nVí dụ:\n    countValidCoinTossSequences(1)\n    // Trả về: 2"
    },
    "instruction_bertscore": {
      "es": "0.9920545861282234",
      "arb": "0.9758763402233128",
      "sw": "0.9844333370382958",
      "tr": "0.9922405041648721",
      "vi": "0.9771515472695568"
    },
    "level": "easy",
    "test": "func TestCountValidCoinTossSequences(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(uint64(2), CountValidCoinTossSequences(1))\n\tassert.Equal(uint64(3), CountValidCoinTossSequences(2))\n\tassert.Equal(uint64(5), CountValidCoinTossSequences(3))\n\tassert.Equal(uint64(8), CountValidCoinTossSequences(4))  // Additional test\n\tassert.Equal(uint64(13), CountValidCoinTossSequences(5)) // Additional test\n\t// Feel free to add more tests here\n\tassert.Equal(uint64(267914296), CountValidCoinTossSequences(40)) // Additional test\n\tassert.Equal(uint64(165580141), CountValidCoinTossSequences(39))\n\tassert.Equal(uint64(102334155), CountValidCoinTossSequences(38))\n\t// Use t.Log instead of fmt.Print or fmt.Println in tests\n\tt.Log(\"All tests passed!\")\n}",
    "entry_point": "CountValidCoinTossSequences",
    "signature": "func CountValidCoinTossSequences(n int) uint64",
    "docstring": {
      "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\nParámetros:\n- n (int): El número de lanzamientos de moneda.\nDevuelve:\n- uint64: El conteo de secuencias válidas.\nEjemplo:\n    countValidCoinTossSequences(1)\n    // Devuelve: 2",
      "arb": "احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\nالمعلمات:\n- n (int): عدد رميات العملة.\nالقيم المعادة:\n- uint64: عدد التسلسلات الصحيحة.\nمثال:\n    countValidCoinTossSequences(1)\n    // يعيد: 2",
      "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha n.  \nVigezo:  \n- n (int): Idadi ya kurusha sarafu.  \nInarejesha:  \n- uint64: Idadi ya mfuatano halali.  \nMfano:  \n    countValidCoinTossSequences(1)  \n    // Inarejesha: 2  ",
      "tr": "n atışında ardışık yazı olmayan geçerli para atış dizilerinin sayısını sayın.  \nParametreler:  \n- n (int): Para atışlarının sayısı.  \nDöndürülen:  \n- uint64: Geçerli dizilerin sayısı.  \nÖrnek:  \n    countValidCoinTossSequences(1)  \n    // Döndürülen: 2  ",
      "vi": "Đếm số lượng chuỗi tung đồng xu hợp lệ không có hai lần liên tiếp xuất hiện mặt ngửa trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n- uint64: Số lượng chuỗi hợp lệ.\n\nVí dụ:\n    countValidCoinTossSequences(1)\n    // Trả về: 2"
    },
    "docstring_bertscore": {
      "es": "0.9867082507922884",
      "arb": "0.9608382327055425",
      "sw": "0.9727622131094479",
      "tr": "0.9373799847053221",
      "vi": "0.9738906323041071"
    }
  },
  {
    "task_id": "Go/16",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n\nParámetros:\n- n (uint64): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\nint: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n\nEjemplos:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاعثر على طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعلمات:\n- n (uint64): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\nint: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n\nأمثلة:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n- n (uint64): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\nint: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBir negatif olmayan tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n- n (uint64): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürür:\nint: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (uint64): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\nint: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9958466387325605",
      "sw": "0.9732333643732626",
      "tr": "1",
      "vi": "0.9971738869386356"
    },
    "canonical_solution": "max := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}",
    "instruction": {
      "es": "Escribe una función en Go `func findLongestConsecutiveOnesLength(n uint64) int` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n\nParámetros:\n- n (uint64): Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\nint: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número entero dado.\n\nEjemplos:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "arb": "اكتب دالة Go `func findLongestConsecutiveOnesLength(n uint64) int` لحل المشكلة التالية:\nاعثر على طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعطيات:\n- n (uint64): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\nint: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n\nأمثلة:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "sw": "Andika kazi ya Go `func findLongestConsecutiveOnesLength(n uint64) int` kutatua tatizo lifuatalo:\nPata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n- n (uint64): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\nint: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyopewa.\n\nMifano:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "tr": "Bir Go fonksiyonu `func findLongestConsecutiveOnesLength(n uint64) int` yazın ve aşağıdaki problemi çözün:\nBir negatif olmayan bir tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n- n (uint64): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürür:\nint: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "vi": "Viết một hàm Go `func findLongestConsecutiveOnesLength(n uint64) int` để giải quyết vấn đề sau:  \nTìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:  \n- n (uint64): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:  \nint: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:  \n    >>> findLongestConsecutiveOnesLength(7)  \n    3  "
    },
    "instruction_bertscore": {
      "es": "0.9953514531926405",
      "arb": "0.9599761768518511",
      "sw": "0.9868327920411972",
      "tr": "0.9972225513819891",
      "vi": "0.9984004295415261"
    },
    "level": "easy",
    "test": "func TestFindLongestConsecutiveOnesLength(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, findLongestConsecutiveOnesLength(7))\n\tassert.Equal(2, findLongestConsecutiveOnesLength(13))\n\tassert.Equal(3, findLongestConsecutiveOnesLength(12345))         // New test sample\n\tassert.Equal(4, findLongestConsecutiveOnesLength(0b11011101111)) // New test sample using binary literal for clarity\n\tassert.Equal(32, findLongestConsecutiveOnesLength(0xFFFFFFFF))   // New test sample: all ones for a 32-bit number\n\tassert.Equal(0, findLongestConsecutiveOnesLength(0))             // New test sample: no ones in a zero\n}",
    "entry_point": "findLongestConsecutiveOnesLength",
    "signature": "func findLongestConsecutiveOnesLength(n uint64) int",
    "docstring": {
      "es": "Encontrar la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n\nParámetros:\n- n (uint64): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\nint: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n\nEjemplos:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n",
      "arb": "ابحث عن طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعلمات:\n- n (uint64): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\nint: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n\nأمثلة:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "sw": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nVigezo:\n- n (uint64): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\nint: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyopewa.\n\nMifano:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "tr": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParametreler:\n- n (uint64): Negatif olmayan bir tamsayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürür:\nint: Verilen tamsayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (uint64): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\nint: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.967957741452976",
      "tr": "0.999999801369619",
      "vi": "0.9975707504399434"
    }
  },
  {
    "task_id": "Go/17",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCrea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (string): La primera palabra que se usará en el ID.\n- word2 (string): La segunda palabra que se usará en el ID.\nDevuelve:\nstring: Un ID divino formado al invertir cada otro carácter de la segunda\n        palabra y combinándolo con la primera palabra.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (string): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (string): الكلمة الثانية التي سيتم استخدامها في المعرف.\nيعيد:\nstring: معرف سماوي يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHujaa ID kwa kuchanganya maneno mawili kwa njia maalum.\nVigezo:\n- word1 (string): Neno la kwanza litakalotumika katika ID.\n- word2 (string): Neno la pili litakalotumika katika ID.\nInarudisha:\nstring: ID ya kipekee inayoundwa kwa kubadilisha kila herufi nyingine ya\n        neno la pili na kuichanganya na neno la kwanza.\nmfano:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBelirli bir şekilde iki kelimeyi birleştirerek bir kimlik oluşturur.\nParametreler:\n- word1 (string): Kimlikte kullanılacak ilk kelime.\n- word2 (string): Kimlikte kullanılacak ikinci kelime.\nDöndürür:\nstring: İkinci kelimenin her iki karakterinin ters çevrilmesiyle ve ilk kelimeyle birleştirilmesiyle oluşan ilahi bir kimlik.\nörneğin:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.\nTham số:\n- word1 (string): Từ đầu tiên được sử dụng trong ID.\n- word2 (string): Từ thứ hai được sử dụng trong ID.\nTrả về:\nstring: Một ID thần thánh được tạo bằng cách đảo ngược mỗi ký tự khác của từ thứ hai\n        và kết hợp nó với từ đầu tiên.\nví dụ:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {"
    },
    "prompt_bertscore": {
      "es": "0.9947704593281135",
      "arb": "0.9641003394532784",
      "sw": "0.9587704904389693",
      "tr": "0.9693388184923115",
      "vi": "0.9656905742838438"
    },
    "canonical_solution": "length1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}",
    "instruction": {
      "es": "Escribe una función en Go `func CreateID(word1, word2 string) string` para resolver el siguiente problema:\nCrea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (string): La primera palabra que se usará en el ID.\n- word2 (string): La segunda palabra que se usará en el ID.\nDevuelve:\nstring: Un ID divino formado invirtiendo cada otro carácter de la segunda\n        palabra y combinándolo con la primera palabra.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "arb": "اكتب دالة Go `func CreateID(word1, word2 string) string` لحل المشكلة التالية:\nينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (string): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (string): الكلمة الثانية التي سيتم استخدامها في المعرف.\nيعيد:\nstring: معرف إلهي يتكون عن طريق عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nعلى سبيل المثال:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "sw": "Andika kazi ya Go `func CreateID(word1, word2 string) string` kutatua tatizo lifuatalo:\nInaunda kitambulisho kwa kuchanganya maneno mawili kwa namna maalum.\nVigezo:\n- word1 (string): Neno la kwanza litakalotumika katika kitambulisho.\n- word2 (string): Neno la pili litakalotumika katika kitambulisho.\nInarudisha:\nstring: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha mpangilio wa kila herufi nyingine ya neno la pili na kuichanganya na neno la kwanza.\nmfano:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "tr": "Bir Go fonksiyonu `func CreateID(word1, word2 string) string` yazın ve aşağıdaki problemi çözün:\nİki kelimeyi belirli bir şekilde birleştirerek bir ID oluşturur.\nParametreler:\n- word1 (string): ID'de kullanılacak ilk kelime.\n- word2 (string): ID'de kullanılacak ikinci kelime.\nDöndürür:\nstring: İkinci kelimenin her iki karakterini ters çevirerek ve bunu birinci kelimeyle birleştirerek oluşturulan ilahi bir ID.\nÖrn.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "vi": "Viết một hàm Go `func CreateID(word1, word2 string) string` để giải quyết vấn đề sau:\nTạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.\nTham số:\n- word1 (string): Từ đầu tiên được sử dụng trong ID.\n- word2 (string): Từ thứ hai được sử dụng trong ID.\nTrả về:\nstring: Một ID thần thánh được tạo bằng cách đảo ngược mỗi ký tự khác của từ thứ hai và kết hợp với từ đầu tiên.\nví dụ:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\""
    },
    "instruction_bertscore": {
      "es": "0.9901711728552506",
      "arb": "0.9872173404588808",
      "sw": "0.9459858445940398",
      "tr": "0.9767441563580542",
      "vi": "0.9627524336875757"
    },
    "level": "middle",
    "test": "func TestCreateID(t *testing.T) {\n\tassert.Equal(t, \"ftiasch\", CreateID(\"fish\", \"cat\"))\n\tassert.Equal(t, \"imccpac\", CreateID(\"icpc\", \"acm\"))\n\tassert.Equal(t, \"owo\", CreateID(\"oo\", \"w\"))\n\tassert.Equal(t, \"hdellrloow\", CreateID(\"hello\", \"world\"))\n\tassert.Equal(t, \"afbecd\", CreateID(\"abc\", \"def\"))\n\tassert.Equal(t, \"bauaauabnbbn\", CreateID(\"buaanb\", \"nbbuaa\"))\n\tassert.Equal(t, \"xuttuxiesvgooloid\", CreateID(\"xtuisgood\", \"ilovextu\"))\n}",
    "entry_point": "CreateID",
    "signature": "func CreateID(word1, word2 string) string",
    "docstring": {
      "es": "Crea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (string): La primera palabra a ser utilizada en el ID.\n- word2 (string): La segunda palabra a ser utilizada en el ID.\nDevuelve:\nstring: Un ID divino formado al invertir cada otro carácter de la segunda\n        palabra y combinándolo con la primera palabra.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "arb": "ينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (string): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (string): الكلمة الثانية التي سيتم استخدامها في المعرف.\nالقيم المعادة:\nstring: معرف إلهي يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "sw": "Inaunda kitambulisho kwa kuchanganya maneno mawili kwa njia maalum.\nVigezo:\n- word1 (string): Neno la kwanza litakalotumika katika kitambulisho.\n- word2 (string): Neno la pili litakalotumika katika kitambulisho.\nInarejesha:\nstring: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha kila herufi nyingine ya neno la pili\n       na kuchanganya na neno la kwanza.\nmfano:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "tr": "İki kelimeyi belirli bir şekilde birleştirerek bir ID oluşturur\nParametreler:\n- word1 (string): Kimlikte kullanılacak birinci kelime.\n- word2 (string): Kimlikte kullanılacak ikinci kelime.\nDöndürür:\nstring: İkinci kelimenin her iki karakterini ters çevirerek ve birinci kelimeyle birleştirerek oluşturulan ilahi bir kimlik.\nörn.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "vi": "Tạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.  \nTham số:  \n- word1 (string): Từ đầu tiên được sử dụng trong ID.  \n- word2 (string): Từ thứ hai được sử dụng trong ID.  \nTrả về:  \nstring: Một ID thần thánh được tạo ra bằng cách đảo ngược mỗi ký tự khác của từ thứ hai và kết hợp với từ đầu tiên.  \nví dụ:  \n    >>> CreateID(\"fish\",\"cat\")  \n    \"ftiasch\"  "
    },
    "docstring_bertscore": {
      "es": "0.9892465484315333",
      "arb": "0.9402249676528849",
      "sw": "1",
      "tr": "0.9853237970364752",
      "vi": "0.9519097970780243"
    }
  },
  {
    "task_id": "Go/18",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\ndonde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n\nDevuelve:\nint: El número total de diferentes esquemas de permutación.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية الطول n،\nحيث أن عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n\nالقيم المعادة:\nint: العدد الإجمالي لمخططات التبديل المختلفة.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu idadi ya mipango tofauti ya upangaji kwa kamba ya binary ya urefu n,\nambapo idadi ya '1' ni m na idadi ya '0' ni n - m.\n\nVigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1' katika kamba ya binary.\n\nInarudisha:\nint: Jumla ya idadi ya mipango tofauti ya upangaji.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn uzunluğundaki bir ikili dizge için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu\nfarklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n- n (int): İkili dizgenin uzunluğu.\n- m (int): İkili dizgedeki '1'lerin sayısı.\n\nDöndürür:\nint: Farklı permütasyon şemalarının toplam sayısı.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\ntrong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\nint: Tổng số lượng các sơ đồ hoán vị khác nhau.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {"
    },
    "prompt_bertscore": {
      "es": "0.993264841039869",
      "arb": "0.9883614514536417",
      "sw": "0.9783983501713128",
      "tr": "0.9814679840798259",
      "vi": "0.9951683159813264"
    },
    "canonical_solution": "factorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}",
    "instruction": {
      "es": "Escribe una función en Go `func countPermutationsOfBinaryString(n, m int) int` para resolver el siguiente problema:\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\ndonde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n\nDevuelve:\nint: El número total de diferentes esquemas de permutación.",
      "arb": "اكتب دالة Go `func countPermutationsOfBinaryString(n, m int) int` لحل المشكلة التالية:\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعطيات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n\nالقيم المعادة:\nint: العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Andika kazi ya Go `func countPermutationsOfBinaryString(n, m int) int` kutatua tatizo lifuatalo:\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n,\nambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n\nInarejesha:\nint: Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "Bir Go fonksiyonu `func countPermutationsOfBinaryString(n, m int) int` yazın ve aşağıdaki problemi çözün:\nUzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n- n (int): İkili dizginin uzunluğu.\n- m (int): İkili dizgideki '1'lerin sayısı.\n\nDöndürür:\nint: Farklı permütasyon şemalarının toplam sayısı.",
      "vi": "Viết một hàm Go `func countPermutationsOfBinaryString(n, m int) int` để giải quyết vấn đề sau:  \nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,  \ntrong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:  \n- n (int): Độ dài của chuỗi nhị phân.  \n- m (int): Số lượng '1' trong chuỗi nhị phân.  \n\nTrả về:  \nint: Tổng số các sơ đồ hoán vị khác nhau.  "
    },
    "instruction_bertscore": {
      "es": "0.9955671657864444",
      "arb": "0.9777696850153373",
      "sw": "0.9676284122812201",
      "tr": "0.967280213223266",
      "vi": "0.9974793804646672"
    },
    "level": "hard",
    "test": "func TestCountPermutationsOfBinaryString(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, countPermutationsOfBinaryString(2, 0))\n\tassert.Equal(0, countPermutationsOfBinaryString(2, 1))\n\tassert.Equal(0, countPermutationsOfBinaryString(3, 0))\n\tassert.Equal(3, countPermutationsOfBinaryString(3, 1))\n\tassert.Equal(0, countPermutationsOfBinaryString(3, 2))\n\tassert.Equal(145422675, countPermutationsOfBinaryString(30, 2))\n\tassert.Equal(4, countPermutationsOfBinaryString(4, 2))\n\tassert.Equal(1, countPermutationsOfBinaryString(5, 5))\n\tassert.Equal(13884156, countPermutationsOfBinaryString(33, 17))\n\tassert.Equal(1, countPermutationsOfBinaryString(1000000, 1000000))\n\t// Add more test cases if necessary\n}",
    "entry_point": "countPermutationsOfBinaryString",
    "signature": "func countPermutationsOfBinaryString(n, m int) int",
    "docstring": {
      "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n\nDevuelve:\nint: El número total de diferentes esquemas de permutación.",
      "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n\nالعائدات:\nint: العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu wa n, ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n\nInarejesha:\nint: Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "İkili bir dizinin uzunluğu n olan, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n- n (int): İkili dizinin uzunluğu.\n- m (int): İkili dizideki '1'lerin sayısı.\n\nDöndürür:\nint: Farklı permütasyon şemalarının toplam sayısı.",
      "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\nint: Tổng số lượng các sơ đồ hoán vị khác nhau."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9808319695997523",
      "sw": "0.9860321129752456",
      "tr": "0.9669238703196894",
      "vi": "0.9963775777410667"
    }
  },
  {
    "task_id": "Go/19",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nResponde a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\nPregunta 1:\n¿A qué tipo de datos pertenecen las constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de datos se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en las expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de función es el mismo que el tipo de valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver en función del tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de funciones.\nSe supone que debes devolver solo cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n*/\nfunc answerQuestions() string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nأجب عن سلسلة من الأسئلة بتقديم خيارات A، B، C، أو D لكل سؤال.\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء الإشارة للمؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء الإشارة للمؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل خيارات السؤال.\n*/\nfunc answerQuestions() string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nJibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\nSwali la 1:\nKonstant kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya hizi\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maonyesho si sahihi?\n    A. Maonyesho ya majina ya vigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maonyesho ya kufuta pointer ni thamani za kushoto.\n    D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\nSwali la 4:\nNi kauli gani kuhusu kazi si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinapewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.\nSwali la 5:\nNi kauli gani kuhusu pointers si sahihi?\n    A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointers za int.\n    D. Majina ya kazi yanaweza kupewa pointers za kazi.\nUnatakiwa kurudisha tu misururu inayofanana na \"AAAAA\", ambayo inasimama kwa chaguo za swali.\n*/\nfunc answerQuestions() string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHer soruya A, B, C veya D seçeneklerini sağlayarak bir dizi soruya cevap verin.\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n    C. Gösterici çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında alan tahsis edilir.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon kendi gövdesinden kendini çağırabilir.\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir dizi int göstericisidir.\n    D. Fonksiyon adları fonksiyon göstericilerine atanabilir.\nSoruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz gerekiyor.\n*/\nfunc answerQuestions() string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTrả lời một loạt câu hỏi bằng cách cung cấp các lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có cái nào ở trên\nCâu hỏi 3:\nCâu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Phép toán tăng yêu cầu toán hạng là giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức phép toán tăng trước là giá trị bên trái.\nCâu hỏi 4:\nCâu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu của hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể tự gọi từ bên trong thân của nó.\nCâu hỏi 5:\nCâu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\nBạn cần trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.\n*/\nfunc answerQuestions() string {"
    },
    "prompt_bertscore": {
      "es": "0.9548016567955112",
      "arb": "0.9548374102640975",
      "sw": "0.920651731275326",
      "tr": "0.9522172769078663",
      "vi": "0.9269709582175699"
    },
    "canonical_solution": "return \"DDDBA\"\n}",
    "instruction": {
      "es": "Escribe una función en Go `func answerQuestions() string` para resolver el siguiente problema:\nResponde una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\nPregunta 3:\n¿Cuál afirmación sobre los valores de la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores de la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor de la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores de la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores de la izquierda.\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo del valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver según el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de funciones.\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "اكتب دالة Go `func answerQuestions() string` لحل المشكلة التالية:\nالإجابة على سلسلة من الأسئلة عن طريق تقديم اختيارات A، B، C، أو D لكل سؤال.\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسارية.\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الشكلية للدالة هي متغيرات محلية.\n    B. المتغيرات المحلية يتم تخصيص مساحة لها في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة استدعاء نفسها من داخل جسمها.\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهم.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال لمؤشرات الدوال.\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.",
      "sw": "Andika kazi ya Go `func answerQuestions() string` kutatua tatizo lifuatalo:\nJibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\nSwali la 1:\nKonstanti kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya hizi\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maonyesho si sahihi?\n    A. Maonyesho ya jina la kigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maonyesho ya kufuta pointer ni thamani za kushoto.\n    D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\nSwali la 4:\nNi kauli gani kuhusu kazi si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.\nSwali la 5:\nNi kauli gani kuhusu pointers si sahihi?\n    A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointers za int.\n    D. Majina ya kazi yanaweza kupewa pointers za kazi.\nUnatakiwa kurudisha tu misururu kama \"AAAAA\", ambayo inawakilisha chaguo za swali.",
      "tr": "Bir Go fonksiyonu `func answerQuestions() string` yazın ve aşağıdaki problemi çözün:\nHer soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\nSoru 1:\n1e6 gibi sabitler hangi veri tipine aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. Gösterici çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinde kendisini çağırabilir.\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int gösterici dizisidir.\n    D. Fonksiyon isimleri, fonksiyon göstericilerine atanabilir.\nSadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz bekleniyor.",
      "vi": "Viết một hàm Go `func answerQuestions() string` để giải quyết vấn đề sau:  \nTrả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.  \nCâu hỏi 1:  \nHằng số như 1e6 thuộc kiểu dữ liệu nào?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nCâu hỏi 2:  \nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Không có lựa chọn nào ở trên  \nCâu hỏi 3:  \nCâu nào về giá trị trái trong biểu thức là không đúng?  \n    A. Biểu thức tên biến là giá trị trái.  \n    B. Phép toán tăng yêu cầu toán hạng phải là giá trị trái.  \n    C. Biểu thức giải tham chiếu con trỏ là giá trị trái.  \n    D. Biểu thức phép toán tăng tiền tố là giá trị trái.  \nCâu hỏi 4:  \nCâu nào về hàm là không đúng?  \n    A. Tham số hình thức của một hàm là biến cục bộ.  \n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.  \n    C. Kiểu của hàm giống với kiểu giá trị trả về.  \n    D. Một hàm có thể gọi chính nó từ bên trong thân hàm.  \nCâu hỏi 5:  \nCâu nào về con trỏ là không đúng?  \n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.  \n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.  \n    C. int *p[4], p là một mảng các con trỏ int.  \n    D. Tên hàm có thể được gán cho con trỏ hàm.  \nBạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "instruction_bertscore": {
      "es": "0.9504256308709316",
      "arb": "0.9586540930356828",
      "sw": "0.9305109488683737",
      "tr": "0.956064548758131",
      "vi": "0.9326519857455488"
    },
    "level": "easy",
    "test": "func TestAnswerQuestions(t *testing.T) {\n\texpectedAnswers := \"DDDBA\"\n\tactualAnswers := answerQuestions()\n\n\tassert.Equal(t, expectedAnswers, actualAnswers, \"they should be equal\")\n}",
    "entry_point": "answerQuestions",
    "signature": "func answerQuestions() string",
    "docstring": {
      "es": "Responde a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\nPregunta 1:\n¿A qué tipo de datos pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de datos se puede utilizar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo del valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver en función del tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de función.\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "الإجابة على سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسارية.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الشكلية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\nمن المفترض أن تعود فقط بسلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.",
      "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.  \nSwali la 1:  \nKonstanti kama 1e6 ni za aina gani ya data?  \nA. unsigned int  \nB. int  \nC. float  \nD. double  \nSwali la 2:  \nKwa kuzingatia 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?  \nA. int  \nB. long long  \nC. double  \nD. Hakuna kati ya hapo juu  \nSwali la 3:  \nNi tamko gani kuhusu thamani za kushoto katika maonyesho ambalo si sahihi?  \nA. Maonyesho ya majina ya mabadiliko ni thamani za kushoto.  \nB. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.  \nC. Maonyesho ya kufuta pointer ni thamani za kushoto.  \nD. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.  \nSwali la 4:  \nNi tamko gani kuhusu kazi ambalo si sahihi?  \nA. Vigezo rasmi vya kazi ni mabadiliko ya ndani.  \nB. Mabadiliko ya ndani yanatengewa nafasi kwenye stack.  \nC. Aina ya kazi ni sawa na aina ya thamani ya kurudi.  \nD. Kazi inaweza kujita kutoka ndani ya mwili wake.  \nSwali la 5:  \nNi tamko gani kuhusu pointer ambalo si sahihi?  \nA. Kuondoa pointer mbili ni sawa na tofauti katika thamani za anwani zao.  \nB. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.  \nC. int *p[4], p ni safu ya pointer za int.  \nD. Majina ya kazi yanaweza kupewa pointer za kazi.  \nUnatakiwa kurudisha tu misururu inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.",
      "tr": "Bir dizi soruya, her soru için A, B, C veya D seçeneklerini sağlayarak cevap verin.  \nSoru 1:  \n1e6 gibi sabitler hangi veri türüne aittir?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nSoru 2:  \n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Yukarıdakilerin hiçbiri  \nSoru 3:  \nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?  \n    A. Değişken adı ifadeleri sol değerlerdir.  \n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.  \n    C. Gösterici çözme ifadeleri sol değerlerdir.  \n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.  \nSoru 4:  \nFonksiyonlar hakkında hangi ifade yanlıştır?  \n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.  \n    B. Yerel değişkenler yığında yer kaplar.  \n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.  \n    D. Bir fonksiyon, gövdesi içinden kendini çağırabilir.  \nSoru 5:  \nGöstericiler hakkında hangi ifade yanlıştır?  \n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.  \n    B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.  \n    C. int *p[4], p bir dizi int göstericisidir.  \n    D. Fonksiyon adları, fonksiyon göstericilerine atanabilir.  \nSoruların seçeneklerini temsil eden \"AAAAA\" gibi dizeleri yalnızca döndürmeniz bekleniyor.",
      "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C hoặc D cho mỗi câu hỏi.  \nCâu hỏi 1:  \nHằng số như 1e6 thuộc kiểu dữ liệu nào?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nCâu hỏi 2:  \nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Không có cái nào ở trên  \nCâu hỏi 3:  \nPhát biểu nào về giá trị trái trong biểu thức là không đúng?  \n    A. Biểu thức tên biến là giá trị trái.  \n    B. Phép toán tăng yêu cầu toán hạng phải là giá trị trái.  \n    C. Biểu thức giải tham chiếu con trỏ là giá trị trái.  \n    D. Biểu thức phép toán tăng trước là giá trị trái.  \nCâu hỏi 4:  \nPhát biểu nào về hàm là không đúng?  \n    A. Tham số hình thức của một hàm là biến cục bộ.  \n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.  \n    C. Kiểu hàm giống với kiểu giá trị trả về.  \n    D. Một hàm có thể gọi chính nó từ trong thân của nó.  \nCâu hỏi 5:  \nPhát biểu nào về con trỏ là không đúng?  \n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.  \n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.  \n    C. int *p[4], p là một mảng các con trỏ int.  \n    D. Tên hàm có thể được gán cho con trỏ hàm.  \nBạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "docstring_bertscore": {
      "es": "0.9527652981291416",
      "arb": "0.9398306863465307",
      "sw": "0.9308039286804002",
      "tr": "0.9509996726721224",
      "vi": "0.9301840032611902"
    }
  },
  {
    "task_id": "Go/20",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square determina si es posible ensamblar los cuadrados de madera de n cubos,\ndonde cada cubo contiene un número específico de cuadrados con una longitud de lado de 1, en un solo cuadrado más grande.\nLa función toma la longitud de la lista y un arreglo de números como entradas.\n\nEjemplos de uso:\n    IsSquare(1, []int{9})             // Salida: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "arb": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء،\nحيث يحتوي كل دلو على عدد معين من المربعات بطول ضلع 1، في مربع أكبر واحد.\nتأخذ الدالة طول القائمة ومصفوفة من الأرقام كمدخلات.\n\nأمثلة الاستخدام:\n    IsSquare(1, []int{9})             // الناتج: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "sw": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square huamua kama inawezekana kukusanya miraba ya mbao kutoka kwenye n ndoo,\nambapo kila ndoo ina idadi maalum ya miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa.\nKazi hii inachukua urefu wa orodha na safu ya namba kama pembejeo.\n\nMfano wa matumizi:\n    IsSquare(1, []int{9})             // Matokeo: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "tr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square, n kovadan ahşap kareleri bir araya getirmenin mümkün olup olmadığını belirler,\nburada her kova, kenar uzunluğu 1 olan belirli sayıda kare içerir ve bunları tek bir büyük kareye dönüştürür.\nFonksiyon, listenin uzunluğunu ve bir dizi sayıyı girdi olarak alır.\n\nKullanım örnekleri:\n    IsSquare(1, []int{9})             // Çıktı: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "vi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng,\ntrong đó mỗi thùng chứa một số lượng hình vuông nhất định với chiều dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không.\nHàm nhận độ dài của danh sách và một mảng số làm đầu vào.\n\nVí dụ sử dụng:\n    IsSquare(1, []int{9})             // Ra: true\n*/\nfunc IsSquare(length int, squares []int) bool {"
    },
    "prompt_bertscore": {
      "es": "0.9875518340205436",
      "arb": "0.9870681690427237",
      "sw": "0.9646294907883554",
      "tr": "0.9728386858061463",
      "vi": "0.9702912511693739"
    },
    "canonical_solution": "sum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}",
    "instruction": {
      "es": "Escribe una función en Go `func IsSquare(length int, squares []int) bool` para resolver el siguiente problema:\nIs_Square determina si es posible ensamblar los cuadrados de madera de n cubos,\ndonde cada cubo contiene un número específico de cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\nLa función toma la longitud de la lista y un arreglo de números como entradas.\n\nEjemplos de uso:\n    IsSquare(1, []int{9})             // Salida: true",
      "arb": "اكتب دالة Go `func IsSquare(length int, squares []int) bool` لحل المشكلة التالية:\nIs_Square يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلوًا، حيث يحتوي كل دلو على عدد معين من المربعات بطول ضلع 1، في مربع أكبر واحد.\nتأخذ الدالة طول القائمة ومصفوفة من الأرقام كمدخلات.\n\nأمثلة الاستخدام:\n    IsSquare(1, []int{9})             // الناتج: true",
      "sw": "Andika kazi ya Go `func IsSquare(length int, squares []int) bool` kutatua tatizo lifuatalo:\nIs_Square huamua kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n,\nambapo kila ndoo ina idadi maalum ya miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa.\nKazi inachukua urefu wa orodha na safu ya namba kama pembejeo.\n\nMifano ya matumizi:\n    IsSquare(1, []int{9})             // Matokeo: true",
      "tr": "Bir Go fonksiyonu `func IsSquare(length int, squares []int) bool` yazın ve aşağıdaki problemi çözün:\nIs_Square, her bir kova 1 birim kenar uzunluğuna sahip belirli sayıda kare içerdiğinde, n kovadan ahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler.\nFonksiyon, listenin uzunluğunu ve bir dizi sayıyı girdi olarak alır.\n\nKullanım örnekleri:\n    IsSquare(1, []int{9})             // Çıktı: true",
      "vi": "Viết một hàm Go `func IsSquare(length int, squares []int) bool` để giải quyết vấn đề sau:  \nIs_Square xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng,  \ntrong đó mỗi thùng chứa một số lượng hình vuông cụ thể với độ dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không.  \nHàm nhận độ dài của danh sách và một mảng số làm đầu vào.  \n\nVí dụ sử dụng:  \n    IsSquare(1, []int{9})             // Ra: true  "
    },
    "instruction_bertscore": {
      "es": "0.968983071479878",
      "arb": "0.9792953649720664",
      "sw": "0.9741885778756594",
      "tr": "0.9560635556062258",
      "vi": "0.9769245127440339"
    },
    "level": "easy",
    "test": "func TestIsSquare(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.True(IsSquare(1, []int{9}))\n\tassert.True(IsSquare(2, []int{14, 2}))\n\tassert.False(IsSquare(2, []int{7, 7}))\n\tassert.False(IsSquare(7, []int{1, 2, 3, 4, 5, 6, 7}))\n\tassert.True(IsSquare(6, []int{1, 3, 5, 7, 9, 11}))\n\tassert.False(IsSquare(4, []int{2, 2, 2, 2}))\n\n\t// Additional test cases\n\tassert.False(IsSquare(3, []int{4, 5, 6}))\n\tassert.False(IsSquare(4, []int{16, 9, 4, 1}))\n\tassert.False(IsSquare(5, []int{1, 1, 1, 1, 1}))\n\tassert.False(IsSquare(2, []int{25, 25}))\n\tassert.True(IsSquare(3, []int{10, 10, 5}))\n}",
    "entry_point": "IsSquare",
    "signature": "func IsSquare(length int, squares []int) bool",
    "docstring": {
      "es": "Is_Square determina si es posible ensamblar los cuadrados de madera de n cubetas, donde cada cubeta contiene un número específico de cuadrados con una longitud de lado de 1, en un solo cuadrado más grande. La función toma la longitud de la lista y un arreglo de números como entradas.\n\nEjemplos de uso:\n    IsSquare(1, []int{9})             // Salida: true",
      "arb": "Is_Square يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء، حيث يحتوي كل دلو على عدد محدد من المربعات بطول جانب 1، في مربع أكبر واحد. تأخذ الدالة طول القائمة ومصفوفة من الأرقام كمدخلات.\n\nأمثلة الاستخدام:\n    IsSquare(1, []int{9})             // المخرج: true",
      "sw": "Is_Square huamua ikiwa inawezekana kuunganisha miraba ya mbao kutoka kwenye n ndoo, ambapo kila ndoo ina idadi maalum ya miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa zaidi. Kazi hii inachukua urefu wa orodha na safu ya namba kama pembejeo.\n\nMifano ya matumizi:\n    IsSquare(1, []int{9})             // Matokeo: true",
      "tr": "Is_Square, her bir kovada belirli sayıda kenar uzunluğu 1 olan kare bulunan n kovadan, tek bir büyük kare oluşturmanın mümkün olup olmadığını belirler. Fonksiyon, listenin uzunluğunu ve bir sayı dizisini girdi olarak alır.\n\nKullanım örnekleri:\n    IsSquare(1, []int{9})             // Çıktı: true",
      "vi": "Is_Square xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng, trong đó mỗi thùng chứa một số lượng hình vuông nhất định với chiều dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không. Hàm này nhận độ dài của danh sách và một mảng số làm đầu vào.\n\nVí dụ sử dụng:\n    IsSquare(1, []int{9})             // Ra: true"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.985965969058361",
      "sw": "0.9669719388718998",
      "tr": "0.928678980864089",
      "vi": "0.9607923490875234"
    }
  },
  {
    "task_id": "Go/21",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado los enteros c y d, donde a + b = c y a * b = d, encuentra\ny devuelve el valor posible de a donde a <= b. Si hay múltiples\ngrupos, muestra el grupo con el menor a. Si no existe un par válido,\ndevuelve -1.\n\nParámetros:\n- c (int): La suma de a y b.\n- d (int): El producto de a y b.\n\nDevuelve:\n- int: Un valor posible de a, o -1 si no existen pares válidos.\n\nEjemplos:\n    findIntegers(7,11) // devuelve -1\n*/\nfunc findIntegers(c int, d int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث\nوأعد القيمة الممكنة لـ a حيث a <= b. إذا كانت هناك\nمجموعات متعددة، أخرج المجموعة ذات a الأصغر. إذا لم يكن هناك\nزوج صالح موجود، أعد -1.\n\nالمعلمات:\n- c (int): مجموع a و b.\n- d (int): حاصل ضرب a و b.\n\nيُرجع:\n- int: قيمة ممكنة لـ a، أو -1 إذا لم تكن هناك أزواج صالحة.\n\nأمثلة:\n    findIntegers(7,11) // يعيد -1\n*/\nfunc findIntegers(c int, d int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKwa kupewa nambari za c na d, ambapo a + b = c na a * b = d, pata\nna rudisha thamani inayowezekana ya a ambapo a <= b. Ikiwa kuna\nvikundi vingi, toa kikundi chenye a ndogo zaidi. Ikiwa hakuna\njozi halali, rudisha -1.\n\nVigezo:\n- c (int): Jumla ya a na b.\n- d (int): Bidhaa ya a na b.\n\nInarudisha:\n- int: Thamani inayowezekana ya a, au -1 ikiwa hakuna jozi halali.\n\nMifano:\n    findIntegers(7,11) // inarudisha -1\n*/\nfunc findIntegers(c int, d int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen c ve d tamsayıları için, burada a + b = c ve a * b = d, a'nın\nmümkün olan değerini bulun ve a <= b olduğu durumu döndürün. Eğer birden\nfazla grup varsa, en küçük a'ya sahip olan grubu çıkartın. Eğer geçerli bir\nçift yoksa, -1 döndürün.\n\nParametreler:\n- c (int): a ve b'nin toplamı.\n- d (int): a ve b'nin çarpımı.\n\nDöndürür:\n- int: a'nın mümkün olan bir değeri veya geçerli bir çift yoksa -1.\n\nÖrnekler:\n    findIntegers(7,11) // -1 döndürür\n*/\nfunc findIntegers(c int, d int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm\nvà trả về giá trị có thể có của a sao cho a <= b. Nếu có nhiều\nnhóm, xuất nhóm với a nhỏ nhất. Nếu không tồn tại cặp hợp lệ,\ntrả về -1.\n\nTham số:\n- c (int): Tổng của a và b.\n- d (int): Tích của a và b.\n\nTrả về:\n- int: Một giá trị có thể có của a, hoặc -1 nếu không tồn tại cặp hợp lệ.\n\nVí dụ:\n    findIntegers(7,11) // trả về -1\n*/\nfunc findIntegers(c int, d int) int {"
    },
    "prompt_bertscore": {
      "es": "0.980198735945013",
      "arb": "0.975644339938264",
      "sw": "0.9718789038049856",
      "tr": "0.9648354704934886",
      "vi": "0.9860188047397163"
    },
    "canonical_solution": "for i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "es": "Escribe una función en Go `func findIntegers(c int, d int) int` para resolver el siguiente problema:\nDados los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a donde a <= b. Si hay múltiples grupos, muestra el grupo con el menor a. Si no existe un par válido, devuelve -1.\n\nParámetros:\n- c (int): La suma de a y b.\n- d (int): El producto de a y b.\n\nDevuelve:\n- int: Un valor posible de a, o -1 si no existen pares válidos.\n\nEjemplos:\n    findIntegers(7,11) // devuelve -1",
      "arb": "اكتب دالة بلغة Go `func findIntegers(c int, d int) int` لحل المشكلة التالية:\nمعطى عددين صحيحين c و d، حيث a + b = c و a * b = d، ابحث وأرجع القيمة الممكنة لـ a حيث a <= b. إذا كانت هناك مجموعات متعددة، أخرج المجموعة ذات a الأصغر. إذا لم يكن هناك زوج صالح، أرجع -1.\n\nالمعطيات:\n- c (int): مجموع a و b.\n- d (int): حاصل ضرب a و b.\n\nالقيم المرجعة:\n- int: قيمة ممكنة لـ a، أو -1 إذا لم توجد أزواج صالحة.\n\nأمثلة:\n    findIntegers(7,11) // يرجع -1",
      "sw": "Andika kazi ya Go `func findIntegers(c int, d int) int` kutatua tatizo lifuatalo:\nKwa kupewa nambari nzima c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a ambapo a <= b. Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi. Ikiwa hakuna jozi halali ipo, rudisha -1.\n\nVigezo:\n- c (int): Jumla ya a na b.\n- d (int): Bidhaa ya a na b.\n\nRudisha:\n- int: Thamani inayowezekana ya a, au -1 ikiwa hakuna jozi halali ipo.\n\nMifano:\n    findIntegers(7,11) // inarudisha -1",
      "tr": "Bir Go fonksiyonu `func findIntegers(c int, d int) int` yazın ve aşağıdaki problemi çözün:\nVerilen c ve d tamsayıları için, a + b = c ve a * b = d olduğunda, a'nın a <= b koşulunu sağlayan olası değerini bulun ve döndürün. Birden fazla grup varsa, en küçük a'ya sahip olan grubu çıktı olarak verin. Geçerli bir çift yoksa, -1 döndürün.\n\nParametreler:\n- c (int): a ve b'nin toplamı.\n- d (int): a ve b'nin çarpımı.\n\nDöndürülenler:\n- int: a'nın olası bir değeri veya geçerli çift yoksa -1.\n\nÖrnekler:\n    findIntegers(7,11) // -1 döndürür",
      "vi": "Viết một hàm Go `func findIntegers(c int, d int) int` để giải quyết vấn đề sau:\nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a sao cho a <= b. Nếu có nhiều nhóm, xuất nhóm với a nhỏ nhất. Nếu không tồn tại cặp hợp lệ, trả về -1.\n\nTham số:\n- c (int): Tổng của a và b.\n- d (int): Tích của a và b.\n\nTrả về:\n- int: Một giá trị có thể của a, hoặc -1 nếu không tồn tại cặp hợp lệ.\n\nVí dụ:\n    findIntegers(7,11) // trả về -1"
    },
    "instruction_bertscore": {
      "es": "0.9794276528058355",
      "arb": "0.9624874607592752",
      "sw": "0.9794457281705098",
      "tr": "0.9497725341780888",
      "vi": "0.9849269335351675"
    },
    "level": "easy",
    "test": "func TestFindIntegers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, findIntegers(5, 6))\n\tassert.Equal(3, findIntegers(6, 9))\n\tassert.Equal(3, findIntegers(7, 12))\n\tassert.Equal(-1, findIntegers(7, 11))\n\tassert.Equal(1, findIntegers(9, 8))\n\tassert.Equal(5, findIntegers(10, 25))\n\tassert.Equal(-1, findIntegers(10000, 8765))\n}",
    "entry_point": "findIntegers",
    "signature": "func findIntegers(c int, d int) int",
    "docstring": {
      "es": "Dado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a donde a <= b. Si hay múltiples grupos, muestra el grupo con el menor a. Si no existe un par válido, devuelve -1.\n\nParámetros:\n- c (int): La suma de a y b.\n- d (int): El producto de a y b.\n\nDevuelve:\n- int: Un valor posible de a, o -1 si no existen pares válidos.\n\nEjemplos:\n    findIntegers(7,11) // devuelve -1",
      "arb": "المعادلة الصحيحة هي a + b = c و a * b = d، حيث يجب إيجاد وإرجاع القيمة الممكنة لـ a حيث a <= b. إذا كانت هناك مجموعات متعددة، يجب إخراج المجموعة التي تحتوي على أصغر قيمة لـ a. إذا لم يكن هناك زوج صالح، يجب إرجاع -1.\n\nالمعلمات:\n- c (int): مجموع a و b.\n- d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n- int: قيمة ممكنة لـ a، أو -1 إذا لم تكن هناك أزواج صالحة.\n\nأمثلة:\n    findIntegers(7,11) // يعيد -1",
      "sw": "Kwa kupewa nambari nzima c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a ambapo a <= b. Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi. Ikiwa hakuna jozi halali ipo, rudisha -1.\n\nVigezo::\n- c (int): Jumla ya a na b.\n- d (int): Bidhaa ya a na b.\n\nInarejesha:\n- int: Thamani inayowezekana ya a, au -1 ikiwa hakuna jozi halali.\n\nMifano:\n    findIntegers(7,11) // inarudisha -1",
      "tr": "Verilen c ve d tam sayıları için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün, burada a <= b. Birden fazla grup varsa, en küçük a'ya sahip grubu çıktı olarak verin. Geçerli bir çift yoksa, -1 döndürün.\n\nParametreler:\n- c (int): a ve b'nin toplamı.\n- d (int): a ve b'nin çarpımı.\n\nDöndürülenler:\n- int: a'nın olası bir değeri veya geçerli çift yoksa -1.\n\nÖrnekler:\n    findIntegers(7,11) // -1 döndürür",
      "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a sao cho a <= b. Nếu có nhiều nhóm, xuất nhóm với a nhỏ nhất. Nếu không tồn tại cặp hợp lệ, trả về -1.\n\nTham số:\n- c (int): Tổng của a và b.\n- d (int): Tích của a và b.\n\nTrả về:\n- int: Một giá trị có thể của a, hoặc -1 nếu không tồn tại cặp hợp lệ.\n\nVí dụ:\n    findIntegers(7,11) // trả về -1"
    },
    "docstring_bertscore": {
      "es": "0.9845193439932839",
      "arb": "0.9172319120050483",
      "sw": "0.9639408392573074",
      "tr": "0.9585615312781206",
      "vi": "0.9905845226781842"
    }
  },
  {
    "task_id": "Go/22",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado tres dígitos a, b, c donde dos son idénticos y el tercero es diferente,\nencuentra el valor único.\n\nEjemplos:\n    extraNumber(0, 0, 1) debería devolver 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى ثلاثة أرقام a و b و c حيث أن اثنين منهما متطابقان والثالث مختلف،\nابحث عن القيمة الفريدة.\n\nأمثلة:\n    extraNumber(0, 0, 1) يجب أن تعيد 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKwa kupewa tarakimu tatu a, b, c ambapo mbili ni sawa na ya tatu ni tofauti,\ntafuta thamani ya kipekee.\n\nMifano:\n    extraNumber(0, 0, 1) inapaswa kurudisha 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÜç rakam a, b, c verildiğinde, bunlardan ikisi özdeş ve üçüncüsü farklıdır,\nbenzersiz değeri bulun.\n\nÖrnekler:\n    extraNumber(0, 0, 1) 1 döndürmelidir\n*/\nfunc extraNumber(a, b, c int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho ba chữ số a, b, c trong đó hai chữ số giống nhau và chữ số thứ ba khác biệt,\ntìm giá trị duy nhất.\n\nVí dụ:\n    extraNumber(0, 0, 1) sẽ trả về 1\n*/\nfunc extraNumber(a, b, c int) int {"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9792935772986371",
      "sw": "0.9914725991117912",
      "tr": "0.9806957091583623",
      "vi": "0.9680397758003434"
    },
    "canonical_solution": "if a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}",
    "instruction": {
      "es": "Escribe una función en Go `func extraNumber(a, b, c int) int` para resolver el siguiente problema:\nDado tres dígitos a, b, c donde dos son idénticos y el tercero es diferente,\nencuentra el valor único.\n\nEjemplos:\n    extraNumber(0, 0, 1) debería devolver 1",
      "arb": "اكتب دالة بلغة Go `func extraNumber(a, b, c int) int` لحل المشكلة التالية:\nمعطى ثلاثة أرقام a، b، c حيث أن اثنين منهما متطابقان والثالث مختلف،\nابحث عن القيمة الفريدة.\n\nأمثلة:\n    extraNumber(0, 0, 1) يجب أن تعيد 1",
      "sw": "Andika kazi ya Go `func extraNumber(a, b, c int) int` kutatua tatizo lifuatalo:\nUkipiwa tarakimu tatu a, b, c ambapo mbili ni sawa na ya tatu ni tofauti,\ntafuta thamani ya kipekee.\n\nMifano:\n    extraNumber(0, 0, 1) inapaswa kurudisha 1",
      "tr": "Bir Go fonksiyonu `func extraNumber(a, b, c int) int` yazın ve aşağıdaki problemi çözün:\nÜç basamaklı a, b, c verildiğinde, bunlardan ikisi özdeş ve üçüncüsü farklıdır,\nbenzersiz değeri bulun.\n\nÖrnekler:\n    extraNumber(0, 0, 1) 1 döndürmelidir.",
      "vi": "Viết một hàm Go `func extraNumber(a, b, c int) int` để giải quyết vấn đề sau:  \nCho ba chữ số a, b, c trong đó hai số giống nhau và số thứ ba khác biệt,  \ntìm giá trị duy nhất.\n\nVí dụ:  \n    extraNumber(0, 0, 1) sẽ trả về 1"
    },
    "instruction_bertscore": {
      "es": "0.9934825399374833",
      "arb": "0.9758566758155903",
      "sw": "0.9865427916848863",
      "tr": "0.9601875195772722",
      "vi": "0.9734319947542975"
    },
    "level": "easy",
    "test": "func TestExtraNumber(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(7, extraNumber(2, 7, 2), \"Extra number should be 7\")\n\tassert.Equal(3, extraNumber(3, 2, 2), \"Extra number should be 3\")\n\tassert.Equal(1, extraNumber(5, 5, 1), \"Extra number should be 1\")\n\tassert.Equal(3, extraNumber(500000000, 3, 500000000), \"Extra number should be 3\")\n\tassert.Equal(3, extraNumber(500000000, 500000000, 3), \"Extra number should be 3\")\n}",
    "entry_point": "extraNumber",
    "signature": "func extraNumber(a, b, c int) int",
    "docstring": {
      "es": "Dado tres dígitos a, b, c donde dos son idénticos y el tercero es diferente, encuentra el valor único.\n\nEjemplos:\n    extraNumber(0, 0, 1) debería devolver 1",
      "arb": "إعطاء ثلاثة أرقام a، b، c حيث يكون اثنان متطابقين والثالث مختلفًا، \nابحث عن القيمة الفريدة.\n\nأمثلة:\n    extraNumber(0, 0, 1) يجب أن تعيد 1",
      "sw": "Given three digits a, b, c ambapo mbili ni sawa na ya tatu ni tofauti, pata thamani ya kipekee.\n\nMifano:\n    extraNumber(0, 0, 1) inapaswa kurudisha 1",
      "tr": "Üç rakam a, b, c verildiğinde, bunlardan ikisi özdeş ve üçüncüsü farklıdır,\nbenzersiz değeri bulun.\n\nÖrnekler:\n    extraNumber(0, 0, 1) 1 döndürmelidir",
      "vi": "Được cho ba chữ số a, b, c trong đó hai chữ số giống nhau và chữ số thứ ba khác biệt, tìm giá trị duy nhất.\n\nVí dụ:\n    extraNumber(0, 0, 1) nên trả về 1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9845272892085253",
      "sw": "0.9925173949160347",
      "tr": "0.9682070225811747",
      "vi": "0.9557417743889494"
    }
  },
  {
    "task_id": "Go/23",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgumentos:\n- edges: Una porción de enteros que representa las longitudes de los lados.\n\nDevuelve:\nint: El conteo de triángulos acutángulos distintos que se pueden formar.\n\nEjemplos:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "arb": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب عدد المثلثات الحادة الزوايا التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nالمعطيات:\n- edges: قائمة من الأعداد الصحيحة تمثل أطوال الحواف.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزوايا المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "sw": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua kingo 3 zozote kutoka kwenye seti iliyotolewa ya kingo.\n\nHoja:\n- edges: Sehemu ya nambari za mzima inayowakilisha urefu wa kingo.\n\nInarudisha:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nMifano:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "tr": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dik açılı üçgenlerin sayısını sayın.\n\nArgümanlar:\n- edges: Kenarların uzunluklarını temsil eden bir tamsayı dilimi.\n\nDöndürür:\nint: Oluşturulabilecek farklı dik açılı üçgenlerin sayısı.\n\nÖrnekler:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "vi": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nTham số:\n- edges: Một slice các số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9664497396001591",
      "arb": "0.9666684316496785",
      "sw": "0.9668905004156755",
      "tr": "0.9664014724175676",
      "vi": "0.961684000867989"
    },
    "canonical_solution": "sort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}",
    "instruction": {
      "es": "Escribe una función en Go `func countAcuteTriangles(edges []int) int` para resolver el siguiente problema:\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgumentos:\n- edges: Un slice de enteros que representa las longitudes de los lados.\n\nDevuelve:\nint: El conteo de triángulos acutángulos distintos que se pueden formar.\n\nEjemplos:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "arb": "اكتب دالة Go `func countAcuteTriangles(edges []int) int` لحل المشكلة التالية:\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 أضلاع من مجموعة الأضلاع المعطاة.\n\nالمعطيات:\n- edges: شريحة من الأعداد الصحيحة تمثل أطوال الأضلاع.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزاوية المختلفة التي يمكن تشكيلها.\n\nأمثلة:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "sw": "Andika kazi ya Go `func countAcuteTriangles(edges []int) int` kutatua tatizo lifuatalo: \nHesabu idadi ya pembetatu zenye pembe kali zinazoweza kuundwa kwa kuchagua kingo 3 kutoka kwenye seti ya kingo zilizotolewa.\n\nHoja:\n- edges: Kipande cha namba nzima kinachowakilisha urefu wa kingo.\n\nInarudisha:\nint: Idadi ya pembetatu tofauti zenye pembe kali zinazoweza kuundwa.\n\nMifano:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "tr": "Bir Go fonksiyonu `func countAcuteTriangles(edges []int) int` yazın ve aşağıdaki problemi çözün:\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek keskin açılı üçgenlerin sayısını sayın.\n\nArgümanlar:\n- edges: Kenarların uzunluklarını temsil eden bir tamsayı dilimi.\n\nDöndürür:\nint: Oluşturulabilecek farklı keskin açılı üçgenlerin sayısı.\n\nÖrnekler:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "vi": "Viết một hàm Go `func countAcuteTriangles(edges []int) int` để giải quyết vấn đề sau:\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nTham số:\n- edges: Một slice các số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4"
    },
    "instruction_bertscore": {
      "es": "0.9641650929574959",
      "arb": "0.9388671303681304",
      "sw": "0.9678767002575137",
      "tr": "0.9778427809955582",
      "vi": "0.9619154052618947"
    },
    "level": "middle",
    "test": "func TestCountAcuteTriangles(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, countAcuteTriangles([]int{1, 1, 1, 1}))\n\tassert.Equal(0, countAcuteTriangles([]int{1, 2, 3}))\n\t// Additional tests to ensure correctness\n\tassert.Equal(0, countAcuteTriangles([]int{3, 4, 5, 7, 10}))\n\tassert.Equal(4, countAcuteTriangles([]int{6, 8, 10, 5, 5, 5}))\n}",
    "entry_point": "countAcuteTriangles",
    "signature": "func countAcuteTriangles(edges []int) int",
    "docstring": {
      "es": "Contar el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgumentos:\n- edges: Una porción de enteros que representa las longitudes de los lados.\n\nDevuelve:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nEjemplos:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "arb": "احسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nالحجج:\n- edges: مقطع من الأعداد الصحيحة يمثل أطوال الحواف.\n\nالإرجاع:\nint: عدد المثلثات الحادة الزاوية المختلفة التي يمكن تشكيلها.\n\nأمثلة:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "sw": "Hesabu idadi ya pembetatu kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti iliyotolewa ya pande.\n\nHoja:\n- edges: Sehemu ya nambari za mzima inayowakilisha urefu wa pande.\n\nInarudisha:\nint: Idadi ya pembetatu kali tofauti ambazo zinaweza kuundwa.\n\nMifano:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "tr": "Verilen bir dizi kenardan herhangi 3 kenar seçilerek oluşturulabilecek keskin açılı üçgenlerin sayısını sayın.\n\nArgümanlar:\n- edges: Kenarların uzunluklarını temsil eden bir tamsayı dilimi.\n\nDöndürür:\nint: Oluşturulabilecek farklı keskin açılı üçgenlerin sayısı.\n\nÖrnekler:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n\nTham số:\n- edges: Một mảng các số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4"
    },
    "docstring_bertscore": {
      "es": "0.9488596289468525",
      "arb": "0.9533564221431013",
      "sw": "0.9344613098863955",
      "tr": "0.9752417161559064",
      "vi": "0.9319144711407662"
    }
  },
  {
    "task_id": "Go/24",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar lee un entero y un carácter, luego los devuelve\ncomo una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (rune): El carácter de entrada.\nDevuelve:\n- string: Una cadena que contiene el entero y el carácter separados por una coma.\n\nEjemplos:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Salida: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "arb": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما\nكسلسلة نصية منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (rune): الحرف المدخل.\nيعيد:\n- string: سلسلة نصية تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n\nأمثلة:\n    fmt.Println(processIntegerAndChar(234, 'H')) // الناتج: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "sw": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar husoma nambari nzima na herufi, kisha kuzirudisha\nkama kamba iliyopangwa ikitenganishwa na koma.\nVigezo:\n- integer_value (int): Nambari nzima ya ingizo.\n- char_value (rune): Herufi ya ingizo.\nInarudisha:\n- string: Kamba inayojumuisha nambari nzima na herufi zikitenganishwa na koma.\n\nMifano:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Matokeo: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "tr": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar bir tam sayı ve bir karakter okur, ardından bunları\nvirgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (rune): Girdi karakteri.\nDöndürür:\n- string: Tam sayı ve karakterin virgülle ayrılmış bir dizesi.\n\nÖrnekler:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Çıktı: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "vi": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar đọc một số nguyên và một ký tự, sau đó trả về chúng\nnhư một chuỗi định dạng được phân tách bằng dấu phẩy.\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (rune): Ký tự đầu vào.\nTrả về:\n- string: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n\nVí dụ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Ra: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {"
    },
    "prompt_bertscore": {
      "es": "0.9958510086009432",
      "arb": "1",
      "sw": "0.9877073616088938",
      "tr": "0.9789457755014449",
      "vi": "0.988254985569407"
    },
    "canonical_solution": "return fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}",
    "instruction": {
      "es": "Escribe una función en Go `func processIntegerAndChar(integerValue int, charValue rune) string` para resolver el siguiente problema:\nprocessIntegerAndChar lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (rune): El carácter de entrada.\nDevuelve:\n- string: Una cadena que contiene el entero y el carácter separados por una coma.\n\nEjemplos:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Salida: \"234,H\"",
      "arb": "اكتب دالة Go `func processIntegerAndChar(integerValue int, charValue rune) string` لحل المشكلة التالية:\nprocessIntegerAndChar تقرأ عددًا صحيحًا وحرفًا، ثم تعيدهما\nكسلسلة نصية مهيكلة مفصولة بفاصلة.\nالمعطيات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (rune): الحرف المدخل.\nالقيم المعادة:\n- string: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n\nأمثلة:\n    fmt.Println(processIntegerAndChar(234, 'H')) // الناتج: \"234,H\"",
      "sw": "Andika kazi ya Go `func processIntegerAndChar(integerValue int, charValue rune) string` kutatua tatizo lifuatalo:\nprocessIntegerAndChar inasoma nambari nzima na herufi, kisha inazirejesha\nkama kamba iliyopangwa ikitenganishwa na koma.\nVigezo:\n- integer_value (int): Nambari nzima ya pembejeo.\n- char_value (rune): Herufi ya pembejeo.\nInarejesha:\n- string: Kamba inayojumuisha nambari nzima na herufi ikitenganishwa na koma.\n\nMifano:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Matokeo: \"234,H\"",
      "tr": "Bir Go fonksiyonu `func processIntegerAndChar(integerValue int, charValue rune) string` yazın ve aşağıdaki problemi çözün:\nprocessIntegerAndChar bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (rune): Girdi karakteri.\nDöndürülenler:\n- string: Virgülle ayrılmış tam sayı ve karakter içeren bir dize.\n\nÖrnekler:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Çıktı: \"234,H\"",
      "vi": "Viết một hàm Go `func processIntegerAndChar(integerValue int, charValue rune) string` để giải quyết vấn đề sau:\nprocessIntegerAndChar đọc một số nguyên và một ký tự, sau đó trả về chúng\nnhư một chuỗi định dạng được ngăn cách bởi dấu phẩy.\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (rune): Ký tự đầu vào.\nTrả về:\n- string: Một chuỗi chứa số nguyên và ký tự được ngăn cách bởi dấu phẩy.\n\nVí dụ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Ra: \"234,H\""
    },
    "instruction_bertscore": {
      "es": "0.99104435201028",
      "arb": "0.9820591080937858",
      "sw": "0.9886766778683441",
      "tr": "0.9883546980206865",
      "vi": "0.9900597412114901"
    },
    "level": "easy",
    "test": "func TestProcessIntegerAndChar(t *testing.T) {\n\tassert := assert.New(t)\n\n\t// Test 1\n\toutput1 := processIntegerAndChar(234, 'H')\n\tassert.Equal(\"234,H\", output1)\n\n\t// Additional tests can be added here with different input values\n\t// Test 2\n\toutput2 := processIntegerAndChar(123, 'A')\n\tassert.Equal(\"123,A\", output2)\n\n\t// Test 3\n\toutput3 := processIntegerAndChar(0, 'Z')\n\tassert.Equal(\"0,Z\", output3)\n}",
    "entry_point": "processIntegerAndChar",
    "signature": "func processIntegerAndChar(integerValue int, charValue rune) string",
    "docstring": {
      "es": "processIntegerAndChar lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.  \nParámetros:  \n- integer_value (int): El entero de entrada.  \n- char_value (rune): El carácter de entrada.  \nDevuelve:  \n- string: Una cadena que contiene el entero y el carácter separados por una coma.  \n\nEjemplos:  \n    fmt.Println(processIntegerAndChar(234, 'H')) // Salida: \"234,H\"  ",
      "arb": "processIntegerAndChar يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (rune): الحرف المدخل.\nالقيم المعادة:\n- string: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n\nأمثلة:\n    fmt.Println(processIntegerAndChar(234, 'H')) // الناتج: \"234,H\"",
      "sw": "processIntegerAndChar husoma nambari nzima na herufi, kisha inazirudisha kama kamba iliyopangwa ikitenganishwa na koma. \nVigezo:\n- integer_value (int): Nambari nzima ya ingizo.\n- char_value (rune): Herufi ya ingizo.\nInarejesha:\n- string: Kamba inayojumuisha nambari nzima na herufi zikitenganishwa na koma.\n\nMifano:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Matokeo: \"234,H\"",
      "tr": "processIntegerAndChar bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (rune): Girdi karakteri.\nDöndürülenler:\n- string: Tam sayı ve karakterin virgülle ayrılmış bir dizesi.\n\nÖrnekler:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Çıktı: \"234,H\"",
      "vi": "processIntegerAndChar đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy. \nTham số: \n- integer_value (int): Số nguyên đầu vào. \n- char_value (rune): Ký tự đầu vào. \nTrả về: \n- string: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n\nVí dụ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Ra: \"234,H\""
    },
    "docstring_bertscore": {
      "es": "0.9960565910453144",
      "arb": "0.9934763823956712",
      "sw": "0.9799035711987952",
      "tr": "0.9539960119700337",
      "vi": "0.9859685512533145"
    }
  },
  {
    "task_id": "Go/25",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDesplaza todos los caracteres 5 posiciones en orden alfabético.\nSolo se reemplazan las letras, y todas las letras están en mayúsculas.\n\nParámetros:\ntext (str): El texto de entrada a ser procesado.\n\nDevuelve:\nstr: El texto transformado con caracteres desplazados 5 posiciones.\n\nEjemplo:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tdevuelve \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nتحرك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي.\nيتم استبدال الحروف فقط، وجميع الحروف تكون بالأحرف الكبيرة.\n\nالمعلمات:\ntext (str): النص المدخل ليتم معالجته.\n\nالإرجاع:\nstr: النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n\nمثال:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tيعيد \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti.\nNi herufi pekee zinazobadilishwa, na herufi zote ziko katika herufi kubwa.\n\nVigezo:\ntext (str): Maandishi ya ingizo yanayopaswa kushughulikiwa.\n\nInarejesha:\nstr: Maandishi yaliyobadilishwa na herufi zilizogeuzwa kwa nafasi 5.\n\nMfano:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tinarejesha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTüm karakterleri alfabetik sırada 5 pozisyon kaydırır.\nSadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (str): İşlenecek giriş metni.\n\nDöndürür:\nstr: Karakterleri 5 pozisyon kaydırılmış dönüştürülmüş metin.\n\nÖrnek:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\t\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" döndürür\n*/\nfunc shiftCharacters(text string) string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái.\nChỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (str): Văn bản đầu vào cần được xử lý.\n\nTrả về:\nstr: Văn bản đã được biến đổi với các ký tự dịch chuyển 5 vị trí.\n\nVí dụ:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\ttrả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {"
    },
    "prompt_bertscore": {
      "es": "0.9899387753094399",
      "arb": "0.9933367452378037",
      "sw": "0.9889255617357808",
      "tr": "0.9669083771499687",
      "vi": "0.973856070617807"
    },
    "canonical_solution": "runes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}",
    "instruction": {
      "es": "Escribe una función en Go `func shiftCharacters(text string) string` para resolver el siguiente problema:\nDesplaza todos los caracteres 5 posiciones en orden alfabético.\nSolo se reemplazan las letras, y todas las letras están en mayúsculas.\n\nParámetros:\ntext (str): El texto de entrada a procesar.\n\nDevuelve:\nstr: El texto transformado con caracteres desplazados 5 posiciones.\n\nEjemplo:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tdevuelve \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "اكتب دالة Go `func shiftCharacters(text string) string` لحل المشكلة التالية:\nتحريك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي.\nيتم استبدال الأحرف فقط، وجميع الأحرف تكون بحروف كبيرة.\n\nالمعطيات:\ntext (str): النص المدخل الذي سيتم معالجته.\n\nالقيم المعادة:\nstr: النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n\nمثال:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tيعيد \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Andika kazi ya Go `func shiftCharacters(text string) string` kutatua tatizo lifuatalo:\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti.\nNi herufi pekee ndizo zinabadilishwa, na herufi zote ziko kwa herufi kubwa.\n\nVigezo:\ntext (str): Maandishi ya kuingiza yanayopaswa kushughulikiwa.\n\nInarejesha:\nstr: Maandishi yaliyobadilishwa na herufi kusogezwa kwa nafasi 5.\n\nMfano:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tinarejesha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Bir Go fonksiyonu `func shiftCharacters(text string) string` yazın:\nTüm karakterleri alfabetik sırada 5 pozisyon kaydırır.\nSadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (str): İşlenecek giriş metni.\n\nDöndürür:\nstr: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\nÖrnek:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\t\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" döndürür.",
      "vi": "Viết một hàm Go `func shiftCharacters(text string) string` để giải quyết vấn đề sau:\nDịch chuyển tất cả các ký tự theo thứ tự bảng chữ cái 5 vị trí.\nChỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (str): Văn bản đầu vào cần xử lý.\n\nTrả về:\nstr: Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\nVí dụ:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\ttrả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "instruction_bertscore": {
      "es": "0.9773239584402951",
      "arb": "0.9869809703054493",
      "sw": "0.9757629222757419",
      "tr": "0.952118954869254",
      "vi": "0.9918217913216506"
    },
    "level": "easy",
    "test": "func TestShiftCharacters(t *testing.T) {\n\tassert := assert.New(t)\n\n\ttest1 := \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\"\n\texpected1 := \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\tassert.Equal(expected1, shiftCharacters(test1), \"Test case 1 failed\")\n\n\ttest2 := \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\"\n\texpected2 := \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\"\n\tassert.Equal(expected2, shiftCharacters(test2), \"Test case 2 failed\")\n\n\ttest3 := \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\"\n\texpected3 := \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\"\n\tassert.Equal(expected3, shiftCharacters(test3), \"Test case 3 failed\")\n}",
    "entry_point": "shiftCharacters",
    "signature": "func shiftCharacters(text string) string",
    "docstring": {
      "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético.  \nSolo se reemplazan las letras, y todas las letras están en mayúsculas.\n\nParámetros:  \ntext (str): El texto de entrada a ser procesado.\n\nDevuelve:  \nstr: El texto transformado con caracteres desplazados 5 posiciones.\n\nEjemplo:  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\tdevuelve \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعلمات:\ntext (str): النص المدخل ليتم معالجته.\n\nالقيم المعادة:\nstr: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n\nمثال:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tيعيد \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Hubadilisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. \nNi herufi pekee zinazo badilishwa, na herufi zote ziko katika herufi kubwa.\n\nVigezo:\ntext (str): Maandishi ya pembejeo yanayopaswa kushughulikiwa.\n\nInarejesha:\nstr: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\nMfano:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tinarejesha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Alfabetik sırayla tüm karakterleri 5 pozisyon kaydırır. \nSadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (str): İşlenecek giriş metni.\n\nDöndürür:\nstr: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\nÖrnek:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\t\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" döndürür.",
      "vi": "Dịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái.  \nChỉ các chữ cái được thay thế, và tất cả các chữ cái đều là chữ hoa.\n\nTham số:  \ntext (str): Văn bản đầu vào cần xử lý.\n\nTrả về:  \nstr: Văn bản đã được biến đổi với các ký tự dịch chuyển 5 vị trí.\n\nVí dụ:  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\ttrả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "es": "0.9749715788376989",
      "arb": "0.9935125331250195",
      "sw": "0.9603102731527517",
      "tr": "0.9443119863730588",
      "vi": "0.9561006994874793"
    }
  },
  {
    "task_id": "Go/26",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nClasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (string): El entero a ser clasificado como una cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nEjemplos:\n    classifyInteger(\"24\") // devuelve 6\n*/\nfunc classifyInteger(x string) int {",
      "arb": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nصنّف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (string): العدد الصحيح المراد تصنيفه كسلسلة.\n\nالإرجاع:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nأمثلة:\n    classifyInteger(\"24\") // يعيد 6\n*/\nfunc classifyInteger(x string) int {",
      "sw": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusiana na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\n\nVigezo:\n- x (string): Nambari ya kutambulishwa kama string.\n\nInarudisha:\nint: Darasa ambalo nambari x inahusiana.\n\nMifano:\n    classifyInteger(\"24\") // inarudisha 6\n*/\nfunc classifyInteger(x string) int {",
      "tr": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAşağıdaki yönteme göre x tam sayısını sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tam sayı, string olarak.\n\nDöndürür:\nint: x tam sayısının ait olduğu sınıf.\n\nÖrnekler:\n    classifyInteger(\"24\") // 6 döndürür\n*/\nfunc classifyInteger(x string) int {",
      "vi": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi lớp được xác định.\n\nTham số:\n- x (string): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nVí dụ:\n    classifyInteger(\"24\") // trả về 6\n*/\nfunc classifyInteger(x string) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9768971017514512",
      "sw": "0.9562270284098175",
      "tr": "0.9861860515205476",
      "vi": "0.9820473889013047"
    },
    "canonical_solution": "var n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}",
    "instruction": {
      "es": "Escribe una función en Go `func classifyInteger(x string) int` para resolver el siguiente problema:\nClasifica el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (string): El entero a clasificar como una cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nEjemplos:\n    classifyInteger(\"24\") // devuelve 6",
      "arb": "اكتب دالة Go `func classifyInteger(x string) int` لحل المشكلة التالية:\nصنف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من خانة واحدة، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، احصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (string): العدد الصحيح الذي سيتم تصنيفه كسلسلة.\n\nالقيم المعادة:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nأمثلة:\n    classifyInteger(\"24\") // يعيد 6",
      "sw": "Andika kazi ya Go `func classifyInteger(x string) int` kutatua tatizo lifuatalo:\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusiana na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\n\nVigezo:\n- x (string): Nambari ya kutambulishwa kama kamba.\n\nInarejesha:\nint: Darasa ambalo nambari x inahusiana nalo.\n\nMifano:\n    classifyInteger(\"24\") // inarejesha 6",
      "tr": "Bir Go fonksiyonu `func classifyInteger(x string) int` yazın ve aşağıdaki problemi çözün:\nAşağıdaki yönteme göre tam sayı x'i sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tam sayı, string olarak.\n\nDöndürür:\nint: Tam sayı x'in ait olduğu sınıf.\n\nÖrnekler:\n    classifyInteger(\"24\") // 6 döndürür",
      "vi": "Viết một hàm Go `func classifyInteger(x string) int` để giải quyết vấn đề sau:\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, cộng các chữ số của x, lấy một x mới, và lặp lại cho đến khi xác định được lớp.\n\nTham số:\n- x (string): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nVí dụ:\n    classifyInteger(\"24\") // trả về 6"
    },
    "instruction_bertscore": {
      "es": "0.9899838644059348",
      "arb": "0.9748146608366813",
      "sw": "0.9560351514617379",
      "tr": "0.9841304257072176",
      "vi": "0.9751312776640509"
    },
    "level": "easy",
    "test": "func TestClassifyInteger(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, classifyInteger(\"24\"))\n\tassert.Equal(3, classifyInteger(\"39\"))\n\tassert.Equal(9, classifyInteger(\"123456789\"))\n\tassert.Equal(9, classifyInteger(\"123456789012345678901234567890\"))\n\tassert.Equal(6, classifyInteger(\"12345\"))\n\tassert.Equal(9, classifyInteger(\"999999999\"))\n}",
    "entry_point": "classifyInteger",
    "signature": "func classifyInteger(x string) int",
    "docstring": {
      "es": "Clasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (string): El entero a ser clasificado como una cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nEjemplos:\n    classifyInteger(\"24\") // devuelve 6",
      "arb": "تصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، احصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (string): العدد الصحيح الذي سيتم تصنيفه كسلسلة نصية.\n\nالإرجاع:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nأمثلة:\n    classifyInteger(\"24\") // يعيد 6",
      "sw": "Kama x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainika.\n\nVigezo::\n- x (string): Nambari ya mzima inayopaswa kuainishwa kama kamba.\n\nInarudisha:\nint: Darasa ambalo nambari x inahusishwa.\n\nMifano:\n    classifyInteger(\"24\") // inarejesha 6",
      "tr": "Aşağıdaki yönteme göre tam sayı x'i sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tam sayı, string olarak.\n\nDöndürür:\nint: Tam sayı x'in ait olduğu sınıf.\n\nÖrnekler:\n    classifyInteger(\"24\") // 6 döndürür",
      "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, cộng các chữ số của x, lấy một x mới, và lặp lại cho đến khi xác định được lớp.\n\nTham số:\n- x (string): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nVí dụ:\n    classifyInteger(\"24\") // trả về 6"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.970332169027867",
      "sw": "0.9689361947099538",
      "tr": "1",
      "vi": "0.9798640437529692"
    }
  },
  {
    "task_id": "Go/27",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase transforma el caso de una letra dada.\n\nParámetros:\n- letter (rune): La letra de entrada a ser transformada.\n\nDevuelve:\n- rune: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\n  y si la entrada es mayúscula, devuelve la versión en minúscula.\n\nEjemplos:\n\t- TransformLetterCase('b') devuelve 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase يحول حالة الحرف المعطى.\n\nالمعلمات:\n- letter (rune): الحرف المدخل الذي سيتم تحويله.\n\nالقيم المعادة:\n- rune: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\n  وإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n\nأمثلة:\n\t- TransformLetterCase('b') يعيد 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase hubadilisha herufi kubwa na ndogo ya herufi iliyotolewa.\n\nVigezo:\n- letter (rune): Herufi ya kuingiza ambayo itabadilishwa.\n\nInarejesha:\n- rune: Herufi ikiwa na herufi kubwa na ndogo zimebadilishwa. Ikiwa ingizo ni herufi ndogo, inarejesha toleo la herufi kubwa,\n  na ikiwa ingizo ni herufi kubwa, inarejesha toleo la herufi ndogo.\n\nMifano:\n\t- TransformLetterCase('b') inarejesha 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase verilen bir harfin büyük/küçük harf durumunu dönüştürür.\n\nParametreler:\n- letter (rune): Dönüştürülecek giriş harfi.\n\nDöndürür:\n- rune: Harfin büyük/küçük harfi ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\n  ve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n\nÖrnekler:\n\t- TransformLetterCase('b') 'B' döndürür\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase chuyển đổi kiểu chữ của một chữ cái cho trước.\n\nTham số:\n- letter (rune): Chữ cái đầu vào cần được chuyển đổi.\n\nTrả về:\n- rune: Chữ cái với kiểu chữ đã được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\n  và nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n\nVí dụ:\n\t- TransformLetterCase('b') trả về 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {"
    },
    "prompt_bertscore": {
      "es": "0.9976359012049227",
      "arb": "0.9854973999894997",
      "sw": "0.9689214960617573",
      "tr": "0.9976359012049227",
      "vi": "0.9799587904447229"
    },
    "canonical_solution": "if letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}",
    "instruction": {
      "es": "Escriba una función de Go `func TransformLetterCase(letter rune) rune` para resolver el siguiente problema:\nTransformLetterCase transforma el caso de una letra dada.\n\nParámetros:\n- letter (rune): La letra de entrada a transformar.\n\nDevuelve:\n- rune: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\n  y si la entrada es mayúscula, devuelve la versión en minúscula.\n\nEjemplos:\n\t- TransformLetterCase('b') devuelve 'B'",
      "arb": "اكتب دالة Go `func TransformLetterCase(letter rune) rune` لحل المشكلة التالية:\nTransformLetterCase تحول حالة الحرف المعطى.\n\nالمعلمات:\n- letter (rune): الحرف المدخل الذي سيتم تحويله.\n\nالقيم المعادة:\n- rune: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\n  وإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n\nأمثلة:\n\t- TransformLetterCase('b') يعيد 'B'",
      "sw": "Andika kazi ya Go `func TransformLetterCase(letter rune) rune` kutatua tatizo lifuatalo:\nTransformLetterCase hubadilisha herufi kubwa na ndogo ya herufi iliyotolewa.\n\nVigezo:\n- letter (rune): Herufi ya kuingiza itakayobadilishwa.\n\nInarejesha:\n- rune: Herufi iliyo na herufi kubwa na ndogo iliyobadilishwa. Ikiwa ingizo ni herufi ndogo, inarejesha toleo la herufi kubwa,\n  na ikiwa ingizo ni herufi kubwa, inarejesha toleo la herufi ndogo.\n\nMifano:\n\t- TransformLetterCase('b') inarejesha 'B'",
      "tr": "Bir Go fonksiyonu `func TransformLetterCase(letter rune) rune` yazın:  \nTransformLetterCase verilen bir harfin durumunu dönüştürür.\n\nParametreler:\n- letter (rune): Dönüştürülecek giriş harfi.\n\nDöndürür:\n- rune: Harfin durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\n  ve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n\nÖrnekler:\n\t- TransformLetterCase('b') 'B' döndürür.",
      "vi": "Viết một hàm Go `func TransformLetterCase(letter rune) rune` để giải quyết vấn đề sau:\nTransformLetterCase chuyển đổi chữ hoa/thường của một chữ cái đã cho.\n\nTham số:\n- letter (rune): Chữ cái đầu vào cần được chuyển đổi.\n\nTrả về:\n- rune: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\n  và nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n\nVí dụ:\n\t- TransformLetterCase('b') trả về 'B'"
    },
    "instruction_bertscore": {
      "es": "0.990464152667277",
      "arb": "0.9796739544783188",
      "sw": "0.9740672147128471",
      "tr": "0.9398686247493083",
      "vi": "0.9744761946673979"
    },
    "level": "easy",
    "test": "func TestTransformLetterCase(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(rune('B'), TransformLetterCase('b'), \"Lowercase 'b' should transform to uppercase 'B'\")\n\tassert.Equal(rune('b'), TransformLetterCase('B'), \"Uppercase 'B' should transform to lowercase 'b'\")\n\n\t// Additional test cases\n\tassert.Equal(rune('Z'), TransformLetterCase('z'), \"Lowercase 'z' should transform to uppercase 'Z'\")\n\tassert.Equal(rune('z'), TransformLetterCase('Z'), \"Uppercase 'Z' should transform to lowercase 'z'\")\n\tassert.Equal(rune('M'), TransformLetterCase('m'), \"Lowercase 'm' should transform to uppercase 'M'\")\n\tassert.Equal(rune('m'), TransformLetterCase('M'), \"Uppercase 'M' should transform to lowercase 'm'\")\n\tassert.Equal(rune('1'), TransformLetterCase('1'), \"Non-alphabetic '1' should remain unchanged\")\n\tassert.Equal(rune('!'), TransformLetterCase('!'), \"Non-alphabetic '!' should remain unchanged\")\n}",
    "entry_point": "TransformLetterCase",
    "signature": "func TransformLetterCase(letter rune) rune",
    "docstring": {
      "es": "TransformLetterCase transforma el caso de una letra dada.\n\nParámetros:\n- letter (rune): La letra de entrada a ser transformada.\n\nDevuelve:\n- rune: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión mayúscula,\n  y si la entrada es mayúscula, devuelve la versión minúscula.\n\nEjemplos:\n\t- TransformLetterCase('b') devuelve 'B'",
      "arb": "TransformLetterCase يقوم بتحويل حالة حرف معين.\n\nالمعلمات:\n- letter (rune): الحرف المدخل الذي سيتم تحويله.\n\nالقيم المعادة:\n- rune: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\n  وإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n\nأمثلة:\n\t- TransformLetterCase('b') يعيد 'B'",
      "sw": "TransformLetterCase hubadilisha herufi ndogo au kubwa ya herufi iliyotolewa.\n\nVigezo:\n- letter (rune): Herufi ya kuingiza itakayobadilishwa.\n\nInarudisha:\n- rune: Herufi yenye kubadilishwa herufi ndogo au kubwa. Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\n  na ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n\nMifano:\n\t- TransformLetterCase('b') inarudisha 'B'",
      "tr": "TransformLetterCase verilen bir harfin durumunu dönüştürür.\n\nParametreler:\n- letter (rune): Dönüştürülecek giriş harfi.\n\nDöndürülenler:\n- rune: Harfin durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\n  ve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n\nÖrnekler:\n\t- TransformLetterCase('b') 'B' döndürür.",
      "vi": "TransformLetterCase chuyển đổi kiểu chữ của một chữ cái được cung cấp.\n\nTham số:\n- letter (rune): Chữ cái đầu vào cần được chuyển đổi.\n\nTrả về:\n- rune: Chữ cái với kiểu chữ được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\n  và nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n\nVí dụ:\n\t- TransformLetterCase('b') trả về 'B'"
    },
    "docstring_bertscore": {
      "es": "0.9966681739885208",
      "arb": "0.9628366529691345",
      "sw": "0.9208449986360729",
      "tr": "0.9804364965111118",
      "vi": "0.974698859324538"
    }
  },
  {
    "task_id": "Go/28",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo devuelve el código ASCII para un carácter dado.\n\nParámetros:\n- character: El carácter de entrada para el cual se mostrará la información ASCII.\n\nDevuelve:\n- El código ASCII correspondiente.\n\nEjemplos:\n\tDisplayASCIIInfo('A') // devuelve 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo تُرجع رمز ASCII لحرف معين.\n\nالمعلمات:\n- character: الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\nالإرجاع:\n- رمز ASCII المقابل.\n\nأمثلة:\n\tDisplayASCIIInfo('A') // يعيد 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo inarudisha msimbo wa ASCII kwa herufi iliyotolewa.\n\nVigezo:\n- character: Herufi ya kuingiza ambayo taarifa ya ASCII inapaswa kuonyeshwa.\n\nInarudisha:\n- Msimbo wa ASCII unaolingana.\n\nMifano:\n\tDisplayASCIIInfo('A') // inarudisha 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo, verilen bir karakter için ASCII kodunu döndürür.\n\nParametreler:\n- character: ASCII bilgisinin gösterileceği giriş karakteri.\n\nDöndürür:\n- Karşılık gelen ASCII kodu.\n\nÖrnekler:\n\tDisplayASCIIInfo('A') // 65 döndürür\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo trả về mã ASCII cho một ký tự cho trước.\n\nTham số:\n- character: Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\nTrả về:\n- Mã ASCII tương ứng.\n\nVí dụ:\n\tDisplayASCIIInfo('A') // trả về 65\n*/\nfunc DisplayASCIIInfo(character rune) int {"
    },
    "prompt_bertscore": {
      "es": "0.9877746973080647",
      "arb": "0.9877746973080647",
      "sw": "0.9854531054145289",
      "tr": "0.9787511177280308",
      "vi": "0.9863687914710998"
    },
    "canonical_solution": "return int(character)\n}",
    "instruction": {
      "es": "Escribe una función en Go `func DisplayASCIIInfo(character rune) int` para resolver el siguiente problema:\nDisplayASCIIInfo devuelve el código ASCII para un carácter dado.\n\nParámetros:\n- character: El carácter de entrada para el cual se va a mostrar la información ASCII.\n\nDevuelve:\n- El código ASCII correspondiente.\n\nEjemplos:\n\tDisplayASCIIInfo('A') // devuelve 65",
      "arb": "اكتب دالة Go `func DisplayASCIIInfo(character rune) int` لحل المشكلة التالية:\nDisplayASCIIInfo تعيد رمز ASCII للحرف المعطى.\n\nالمعطيات:\n- character: الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\nالقيم المعادة:\n- رمز ASCII المقابل.\n\nأمثلة:\n\tDisplayASCIIInfo('A') // يعيد 65",
      "sw": "Andika kazi ya Go `func DisplayASCIIInfo(character rune) int` kutatua tatizo lifuatalo:\nDisplayASCIIInfo inarudisha msimbo wa ASCII kwa herufi iliyotolewa.\n\nVigezo:\n- character: Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n\nInarudisha:\n- Msimbo wa ASCII unaolingana.\n\nMifano:\n\tDisplayASCIIInfo('A') // inarudisha 65",
      "tr": "Bir Go fonksiyonu `func DisplayASCIIInfo(character rune) int` yazın:\nDisplayASCIIInfo verilen bir karakter için ASCII kodunu döndürür.\n\nParametreler:\n- character: ASCII bilgisinin gösterileceği giriş karakteri.\n\nDöndürür:\n- Karşılık gelen ASCII kodu.\n\nÖrnekler:\n\tDisplayASCIIInfo('A') // 65 döndürür",
      "vi": "Viết một hàm Go `func DisplayASCIIInfo(character rune) int` để giải quyết vấn đề sau:\nDisplayASCIIInfo trả về mã ASCII cho một ký tự đã cho.\n\nTham số:\n- character: Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\nTrả về:\n- Mã ASCII tương ứng.\n\nVí dụ:\n\tDisplayASCIIInfo('A') // trả về 65"
    },
    "instruction_bertscore": {
      "es": "0.9798249135679054",
      "arb": "0.9661831776288103",
      "sw": "0.984918591059164",
      "tr": "0.9576577630444119",
      "vi": "0.9801308043546991"
    },
    "level": "easy",
    "test": "func TestDisplayASCIIInfo(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(65, DisplayASCIIInfo('A'), \"ASCII value for 'A' should be 65\")\n\tassert.Equal(66, DisplayASCIIInfo('B'), \"ASCII value for 'B' should be 66\") // Additional test case\n\tassert.Equal(48, DisplayASCIIInfo('0'), \"ASCII value for '0' should be 48\") // Additional test case\n\tassert.Equal(32, DisplayASCIIInfo(' '), \"ASCII value for ' ' should be 32\") // Additional test case\n}",
    "entry_point": "DisplayASCIIInfo",
    "signature": "func DisplayASCIIInfo(character rune) int",
    "docstring": {
      "es": "DisplayASCIIInfo devuelve el código ASCII para un carácter dado.\n\nParámetros:\n- character: El carácter de entrada para el cual se mostrará la información ASCII.\n\nDevuelve:\n- El código ASCII correspondiente.\n\nEjemplos:\n\tDisplayASCIIInfo('A') // devuelve 65",
      "arb": "DisplayASCIIInfo يعيد رمز ASCII للحرف المعطى.\n\nالمعلمات:\n- character: الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\nيعيد:\n- رمز ASCII المقابل.\n\nأمثلة:\n\tDisplayASCIIInfo('A') // يعيد 65",
      "sw": "DisplayASCIIInfo inarejesha msimbo wa ASCII kwa herufi iliyotolewa.\n\nVigezo:\n- character: Herufi ya kuingiza ambayo taarifa ya ASCII inapaswa kuonyeshwa.\n\nInarejesha:\n- Msimbo wa ASCII unaolingana.\n\nMifano:\n\tDisplayASCIIInfo('A') // inarejesha 65",
      "tr": "DisplayASCIIInfo, verilen bir karakter için ASCII kodunu döndürür.\n\nParametreler:\n- character: ASCII bilgisinin görüntüleneceği giriş karakteri.\n\nDöndürülenler:\n- Karşılık gelen ASCII kodu.\n\nÖrnekler:\n\tDisplayASCIIInfo('A') // 65 döndürür",
      "vi": "DisplayASCIIInfo trả về mã ASCII cho một ký tự cho trước.\n\nTham số:\n- character: Ký tự đầu vào mà thông tin ASCII sẽ được hiển thị.\n\nTrả về:\n- Mã ASCII tương ứng.\n\nVí dụ:\n\tDisplayASCIIInfo('A') // trả về 65"
    },
    "docstring_bertscore": {
      "es": "0.972569541639844",
      "arb": "0.9708787998364751",
      "sw": "0.9790460838438676",
      "tr": "0.9451569600139812",
      "vi": "0.970343292329205"
    }
  },
  {
    "task_id": "Go/29",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvalúa la calificación para un entero de entrada.\nParámetros:\n- score (int): La puntuación entera a evaluar.\nDevuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n         De lo contrario, devuelve 'B'.\n\t Ejemplo:\n\t\tevaluateIntegerGrade(90) // Devuelve 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nتقييم الدرجة لعدد صحيح مُدخل.\nالمعلمات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\nالإرجاع:\n    char: الدرجة المقابلة للدرجة المدخلة.\n         إذا كانت الدرجة بين 90 و 100 (شاملة)، تُرجع 'A'.\n         خلاف ذلك، تُرجع 'B'.\n\t مثال:\n\t\tevaluateIntegerGrade(90) // يعيد 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTambua alama kwa namba kamili iliyoingizwa.\nVigezo:\n- score (int): Alama ya namba kamili inayopaswa kutambuliwa.\nInarudisha:\n    char: Alama inayolingana na alama iliyoingizwa.\n         Ikiwa alama iko kati ya 90 na 100 (ikiwemo), inarudisha 'A'.\n         Vinginevyo, inarudisha 'B'.\n\t Mfano:\n\t\tevaluateIntegerGrade(90) // Inarudisha 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBir tamsayı notunu değerlendir.\nParametreler:\n- score (int): Değerlendirilecek tamsayı notu.\nDöndürür:\n    char: Girdi notuna karşılık gelen harf notu.\n         Eğer not 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n         Aksi takdirde, 'B' döndürür.\n\t Örnek:\n\t\tevaluateIntegerGrade(90) // 'A' döndürür\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nĐánh giá điểm cho một số nguyên đầu vào.\nTham số:\n- score (int): Điểm số nguyên cần được đánh giá.\nTrả về:\n    char: Điểm tương ứng với điểm số đầu vào.\n         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n         Ngược lại, trả về 'B'.\n\t Ví dụ:\n\t\tevaluateIntegerGrade(90) // Trả về 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {"
    },
    "prompt_bertscore": {
      "es": "0.9925916826785418",
      "arb": "1",
      "sw": "0.9664630478356885",
      "tr": "0.9781369525898709",
      "vi": "0.9705490734039571"
    },
    "canonical_solution": "if 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}",
    "instruction": {
      "es": "Escribe una función en Go `func evaluateIntegerGrade(score int) rune` para resolver el siguiente problema:\nEvalúa la calificación para un entero de entrada.\nParámetros:\n- score (int): La puntuación entera a evaluar.\nDevuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n         De lo contrario, devuelve 'B'.\n     Ejemplo:\n        evaluateIntegerGrade(90) // Devuelve 'A'",
      "arb": "اكتب دالة بلغة Go `func evaluateIntegerGrade(score int) rune` لحل المشكلة التالية:\nتقييم الدرجة لعدد صحيح مُدخل.\nالمعلمات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\nيعيد:\n    char: الدرجة المقابلة للدرجة المُدخلة.\n         إذا كانت الدرجة بين 90 و100 (شاملة)، تعيد 'A'.\n         خلاف ذلك، تعيد 'B'.\n     مثال:\n        evaluateIntegerGrade(90) // يعيد 'A'",
      "sw": "Andika kazi ya Go `func evaluateIntegerGrade(score int) rune` kutatua tatizo lifuatalo:\nTathmini alama kwa nambari kamili ya ingizo.\nVigezo:\n- score (int): Alama ya nambari kamili itakayopimwa.\nInarudisha:\n    char: Alama inayolingana na alama ya ingizo.\n         Ikiwa alama iko kati ya 90 na 100 (ikijumuisha), inarudisha 'A'.\n         Vinginevyo, inarudisha 'B'.\n     Mfano:\n        evaluateIntegerGrade(90) // Inarudisha 'A'",
      "tr": "Bir Go fonksiyonu `func evaluateIntegerGrade(score int) rune` yazın:\nBir tamsayı notunu değerlendirin.\nParametreler:\n- score (int): Değerlendirilecek tamsayı notu.\nDöndürülen:\n    char: Girdi notuna karşılık gelen harf notu.\n         Eğer not 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n         Aksi takdirde, 'B' döndürür.\n     Örnek:\n        evaluateIntegerGrade(90) // 'A' döndürür.",
      "vi": "Viết một hàm Go `func evaluateIntegerGrade(score int) rune` để giải quyết vấn đề sau:\nĐánh giá điểm cho một số nguyên đầu vào.\nTham số:\n- score (int): Điểm số nguyên cần được đánh giá.\nTrả về:\n    char: Điểm tương ứng với điểm số đầu vào.\n         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n         Ngược lại, trả về 'B'.\n     Ví dụ:\n        evaluateIntegerGrade(90) // Trả về 'A'"
    },
    "instruction_bertscore": {
      "es": "0.9879508824560427",
      "arb": "0.990918817609466",
      "sw": "0.9751793462162615",
      "tr": "0.9478323126161401",
      "vi": "0.9753962505923515"
    },
    "level": "easy",
    "test": "func TestEvaluateIntegerGrade(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal('A', evaluateIntegerGrade(90))\n\tassert.Equal('B', evaluateIntegerGrade(89))\n\tassert.Equal('A', evaluateIntegerGrade(95))\n\tassert.Equal('A', evaluateIntegerGrade(100))\n\tassert.Equal('B', evaluateIntegerGrade(101))\n}",
    "entry_point": "evaluateIntegerGrade",
    "signature": "func evaluateIntegerGrade(score int) rune",
    "docstring": {
      "es": "Evaluar la calificación para un entero de entrada.\nParámetros:\n- score (int): La puntuación entera a evaluar.\nDevuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n         De lo contrario, devuelve 'B'.\n     Ejemplo:\n        evaluateIntegerGrade(90) // Devuelve 'A'",
      "arb": "تقييم الدرجة لعدد صحيح مدخل.\nالمعلمات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\nيعيد:\n    char: الدرجة المقابلة للدرجة المدخلة.\n         إذا كانت الدرجة بين 90 و 100 (شاملة)، تُرجع 'A'.\n         خلاف ذلك، تُرجع 'B'.\n     مثال:\n        evaluateIntegerGrade(90) // يعيد 'A'",
      "sw": "Tambua daraja kwa nambari kamili ya pembejeo.\n\nVigezo:\n- score (int): Alama ya nambari kamili itakayopimwa.\n\nInarejesha:\n    char: Daraja linalolingana na alama ya pembejeo.\n         Ikiwa alama iko kati ya 90 na 100 (ikijumuishwa), inarejesha 'A'.\n         Vinginevyo, inarejesha 'B'.\n\n     Mfano:\n        evaluateIntegerGrade(90) // Inarejesha 'A'",
      "tr": "Girdi tam sayısı için notu değerlendirir.\nParametreler:\n- score (int): Değerlendirilecek tam sayı puanı.\nDöndürür:\n    char: Girdi puanına karşılık gelen not.\n         Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n         Aksi takdirde, 'B' döndürür.\n     Örnek:\n        evaluateIntegerGrade(90) // 'A' döndürür",
      "vi": "Đánh giá điểm cho một số nguyên đầu vào.  \nTham số:  \n- score (int): Điểm số nguyên cần được đánh giá.  \nTrả về:  \n    char: Điểm tương ứng với điểm số đầu vào.  \n         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \n         Ngược lại, trả về 'B'.  \n     Ví dụ:  \n        evaluateIntegerGrade(90) // Trả về 'A'  "
    },
    "docstring_bertscore": {
      "es": "0.9941282873062277",
      "arb": "0.9906860228028931",
      "sw": "0.9735460085930115",
      "tr": "0.9816348335998952",
      "vi": "0.9726738225898873"
    }
  },
  {
    "task_id": "Go/30",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n//\n// Argumentos:\n//\n//\ts (string): La cadena de tres caracteres a verificar.\n//\n// Devuelve:\n//\n//\tstr: Devuelve \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\n//\tEjemplos:\n//\t    checkTwoEqualDigits(\"112\") // devuelve \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متشابهين بالضبط.\n//\n// يعيدالحجج:\n//\n//\ts (string): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n//\n// يعيد:\n//\n//\tstr: يعيد \"Yes\" إذا كان الإدخال يحتوي على حرفين متساويين بالضبط، وإلا \"No\".\n//\tامثله:\n//\t    checkTwoEqualDigits(\"112\") // يعيد \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits hukagua kama kuna herufi mbili sawa katika kamba ya herufi tatu.\n//\n// Hoja:\n//\n//\ts (string): Kamba ya herufi tatu inayopaswa kukaguliwa.\n//\n// Inarejesha:\n//\n//\tstr: Inarudisha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\n//\tMifano:\n//\t    checkTwoEqualDigits(\"112\") // inarudisha \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n//\n// Argümanlar:\n//\n//\ts (string): Kontrol edilecek üç karakterli dizge.\n//\n// Döndürür:\n//\n//\tstr: Girdi tam olarak iki eşit karaktere sahipse \"Yes\" döndürür, aksi takdirde \"No\".\n//\tÖrnekler:\n//\t    checkTwoEqualDigits(\"112\") // \"Yes\" döndürür\nfunc CheckTwoEqualDigits(s string) string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n//\n// Tham số:\n//\n//\ts (string): Chuỗi ba ký tự cần được kiểm tra.\n//\n// Trả về:\n//\n//\tstr: Trả về \"Yes\" nếu đầu vào có chính xác hai ký tự giống nhau, nếu không thì \"No\".\n//\tVí dụ:\n//\t    checkTwoEqualDigits(\"112\") // trả về \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {"
    },
    "prompt_bertscore": {
      "es": "0.9813992579679879",
      "arb": "0.9751483598768199",
      "sw": "0.9658053826440819",
      "tr": "0.9793458170888493",
      "vi": "0.9671234938526294"
    },
    "canonical_solution": "if (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}",
    "instruction": {
      "es": "Escribe una función en Go `func CheckTwoEqualDigits(s string) string` para resolver el siguiente problema:\nCheckTwoEqualDigits verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nArgumentos:\n\n\ts (string): La cadena de tres caracteres a verificar.\n\nDevuelve:\n\n\tstr: Devuelve \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\n\tEjemplos:\n\t    checkTwoEqualDigits(\"112\") // devuelve \"Yes\"",
      "arb": "اكتب دالة Go `func CheckTwoEqualDigits(s string) string` لحل المشكلة التالية:\nCheckTwoEqualDigits يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متساويين بالضبط.\n\nالمعطيات:\n\n\ts (string): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nالقيم المعادة:\n\n\tstr: يعيد \"Yes\" إذا كان الإدخال يحتوي على حرفين متساويين بالضبط، وإلا يعيد \"No\".\n\tأمثلة:\n\t    checkTwoEqualDigits(\"112\") // يعيد \"Yes\"",
      "sw": "Andika kazi ya Go `func CheckTwoEqualDigits(s string) string` kutatua tatizo lifuatalo:\nCheckTwoEqualDigits hukagua kama kamba yenye herufi tatu ina herufi mbili ambazo ni sawa.\n\nHoja:\n\n\ts (string): Kamba yenye herufi tatu itakayokaguliwa.\n\nRudisha:\n\n\tstr: Inarudisha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\n\tMifano:\n\t    checkTwoEqualDigits(\"112\") // inarudisha \"Yes\"",
      "tr": "Bir Go fonksiyonu `func CheckTwoEqualDigits(s string) string` yazın ve aşağıdaki problemi çözün:\nCheckTwoEqualDigits, üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgümanlar:\n\n\ts (string): Kontrol edilecek üç karakterli dizge.\n\nDöndürür:\n\n\tstr: Girdi tam olarak iki eşit karaktere sahipse \"Yes\" döner, aksi halde \"No\".\n\tÖrnekler:\n\t    checkTwoEqualDigits(\"112\") // \"Yes\" döner",
      "vi": "Viết một hàm Go `func CheckTwoEqualDigits(s string) string` để giải quyết vấn đề sau:  \nCheckTwoEqualDigits kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:\n\n\ts (string): Chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\n\n\tstr: Trả về \"Yes\" nếu đầu vào có chính xác hai ký tự giống nhau, ngược lại \"No\".\n\tVí dụ:\n\t    checkTwoEqualDigits(\"112\") // trả về \"Yes\""
    },
    "instruction_bertscore": {
      "es": "0.9853539888543925",
      "arb": "0.949738767013313",
      "sw": "0.9743901877124098",
      "tr": "0.9739029473877312",
      "vi": "0.9629923791878658"
    },
    "level": "easy",
    "test": "func TestCheckTwoEqualDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"112\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"123\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"232\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"444\")) // All three characters are equal, not two.\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"121\"))\n\n\t// Additional test cases to cover more scenarios\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"787\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"999\")) // All three characters are equal\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"890\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"556\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"353\")) // No two characters are equal\n}",
    "entry_point": "CheckTwoEqualDigits",
    "signature": "func CheckTwoEqualDigits(s string) string",
    "docstring": {
      "es": "CheckTwoEqualDigits verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nArgumentos:\n\n\ts (string): La cadena de tres caracteres a verificar.\n\ndevuelve:\n\n\tstr: Devuelve \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\n\tEjemplos:\n\t    checkTwoEqualDigits(\"112\") // devuelve \"Yes\"",
      "arb": "CheckTwoEqualDigits يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nيعيدالحجج:\n\n\ts (string): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nيعيد:\n\n\tstr: يعيد \"Yes\" إذا كان الإدخال يحتوي على حرفين متساويين بالضبط، وإلا يعيد \"No\".\n\tامثله:\n\t    checkTwoEqualDigits(\"112\") // يعيد \"Yes\"",
      "sw": "CheckTwoEqualDigits hukagua ikiwa mfuatano wa herufi tatu una herufi mbili ambazo ni sawa.\n\nHoja:\n\n\ts (string): Mfuatano wa herufi tatu utakaokaguliwa.\n\nInarejesha:\n\n\tstr: Inarejesha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\n\tMifano:\n\t    checkTwoEqualDigits(\"112\") // inarejesha \"Yes\"",
      "tr": "CheckTwoEqualDigits, üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgümanlar:\n\n\ts (string): Kontrol edilecek üç karakterli dizge.\n\nDöndürür:\n\n\tstr: Girdi tam olarak iki eşit karakter içeriyorsa \"Yes\" döner, aksi takdirde \"No\".\n\tÖrnekler:\n\t    checkTwoEqualDigits(\"112\") // \"Yes\" döner",
      "vi": "CheckTwoEqualDigits kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:\n\n\ts (string): Chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\n\n\tstr: Trả về \"Yes\" nếu đầu vào có chính xác hai ký tự giống nhau, ngược lại trả về \"No\".\n\tVí dụ:\n\t    checkTwoEqualDigits(\"112\") // trả về \"Yes\""
    },
    "docstring_bertscore": {
      "es": "0.9871078951189306",
      "arb": "0.9663210271132485",
      "sw": "0.9460122624347174",
      "tr": "0.9794151390918304",
      "vi": "0.9626054472056099"
    }
  },
  {
    "task_id": "Go/31",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDada una cadena compuesta de letras minúsculas en inglés,\nen cada ronda, puedes cambiar uno de los caracteres por otro carácter.\nLa pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer\nque la cadena esté compuesta por el mismo carácter?\n\nPor ejemplo:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة،\nفي كل جولة، يمكنك تغيير أحد الأحرف إلى حرف آخر.\nالسؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل\nالسلسلة مكونة من نفس الحرف؟\n\nعلى سبيل المثال:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKwa kupewa mfuatano wa herufi ndogo za Kiingereza,\nkatika kila raundi, unaweza kubadilisha moja ya herufi kuwa herufi nyingine.\nSwali ni: ni idadi gani ndogo ya raundi zinazohitajika kufanya\nmfuatano huo uwe na herufi sawa?\n\nKwa mfano:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKüçük İngiliz harflerinden oluşan bir dize verildiğinde,\nher turda karakterlerden birini başka bir karaktere değiştirebilirsiniz.\nSoru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için\ngerekli minimum tur sayısı nedir?\n\nÖrneğin:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một chuỗi bao gồm các chữ cái tiếng Anh viết thường,\ntrong mỗi vòng, bạn có thể thay đổi một trong các ký tự thành ký tự khác.\nCâu hỏi là: cần tối thiểu bao nhiêu vòng để làm cho\nchuỗi được tạo thành từ cùng một ký tự?\n\nVí dụ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {"
    },
    "prompt_bertscore": {
      "es": "0.9981874977730566",
      "arb": "0.9889255617357808",
      "sw": "0.9662002598415793",
      "tr": "0.990680063891462",
      "vi": "0.9934968413249178"
    },
    "canonical_solution": "var charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}",
    "instruction": {
      "es": "Escribe una función en Go `func minRoundsToSameChar(s string) int` para resolver el siguiente problema:\nDada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda, puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\n\nPor ejemplo:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "arb": "اكتب دالة Go `func minRoundsToSameChar(s string) int` لحل المشكلة التالية:\nبالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة، يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟\n\nعلى سبيل المثال:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "sw": "Andika kazi ya Go `func minRoundsToSameChar(s string) int` kutatua tatizo lifuatalo:\nUkipatiwa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi, unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo ya raundi zinazohitajika ili kufanya kamba iwe na herufi sawa?\n\nKwa mfano:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "tr": "Bir Go fonksiyonu `func minRoundsToSameChar(s string) int` yazın ve aşağıdaki problemi çözün:\nKüçük harflerden oluşan bir dize verildiğinde, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\n\nÖrneğin:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "vi": "Viết một hàm Go `func minRoundsToSameChar(s string) int` để giải quyết vấn đề sau:\nCho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng, bạn có thể thay đổi một trong các ký tự thành một ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu vòng để làm cho chuỗi được tạo thành từ cùng một ký tự?\n\nVí dụ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0"
    },
    "instruction_bertscore": {
      "es": "0.9836112058911924",
      "arb": "0.9886158969717475",
      "sw": "0.9829080543423289",
      "tr": "0.9840579256181399",
      "vi": "0.9930209229319582"
    },
    "level": "easy",
    "test": "func TestMinRoundsToSameChar(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, minRoundsToSameChar(\"aab\"), \"They should be equal\")\n\tassert.Equal(2, minRoundsToSameChar(\"abc\"), \"They should be equal\")\n\tassert.Equal(0, minRoundsToSameChar(\"aaa\"), \"They should be equal\")\n\tassert.Equal(1, minRoundsToSameChar(\"abab\"), \"They should be equal\")\n\tassert.Equal(0, minRoundsToSameChar(\"zzzzz\"), \"They should be equal\")\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "func minRoundsToSameChar(s string) int",
    "docstring": {
      "es": "Dada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda, puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\n\nPor ejemplo:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "arb": "بالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة، يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف؟\n\nعلى سبيل المثال:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "sw": "Kwa kupewa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi, unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo ya raundi zinazohitajika kufanya kamba iwe na herufi sawa?\n\nKwa mfano:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "tr": "Verilen bir küçük harflerden oluşan İngilizce harf dizisinde, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\n\nÖrneğin:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng, bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu vòng để làm cho chuỗi được tạo thành từ cùng một ký tự?\n\nVí dụ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0"
    },
    "docstring_bertscore": {
      "es": "0.9851058995084799",
      "arb": "0.9850401528523574",
      "sw": "0.9770744786817153",
      "tr": "0.9781087470757639",
      "vi": "0.9907011187118517"
    }
  },
  {
    "task_id": "Go/32",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años,\nel problema es encontrar el año Y_n cuando ocurre el enésimo evento, bajo la\ncondición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año\ninmediatamente siguiente a la ocurrencia del evento i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى تسلسل من n أحداث، كل منها يحدث بدورية a_i سنوات،\nالمشكلة هي إيجاد السنة Y_n عندما يحدث الحدث nth، تحت\nالشرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة\nالتي تلي مباشرة حدوث الحدث i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKwa kuzingatia mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i,\ntatizo ni kupata mwaka Y_n ambapo tukio la nth linatokea, chini ya\nsharti kwamba kuhesabu kwa tukio i+1 kunaweza kuanza tu katika mwaka\nunaofuata mara baada ya kutokea kwa tukio i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn olaydan oluşan bir dizi verildiğinde, her biri a_i yıllık bir periyodiklikle meydana gelir,\nsorun, n. olayın meydana geldiği Y_n yılını bulmaktır, \nşartı altında ki i+1. olayın geri sayımı yalnızca i. olayın meydana gelmesinin hemen ardından başlayabilir.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một chuỗi gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm,\nvấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng\nđếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi\nsự kiện i xảy ra.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.999231697686157",
      "arb": "0.9984475049418313",
      "sw": "0.9684165776331666",
      "tr": "0.9553379588243054",
      "vi": "0.9673991928215059"
    },
    "canonical_solution": "year := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}",
    "instruction": {
      "es": "Escribe una función en Go `func apocalypseYear(n int, signs []int) int` para resolver el siguiente problema:\nDada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el enésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente posterior a la ocurrencia del evento i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "arb": "اكتب دالة Go `func apocalypseYear(n int, signs []int) int` لحل المشكلة التالية:\nبالنظر إلى تسلسل من n أحداث، كل منها يحدث بشكل دوري كل a_i سنة، المشكلة هي إيجاد السنة Y_n عندما يحدث الحدث nth، تحت شرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "sw": "Andika kazi ya Go `func apocalypseYear(n int, signs []int) int` kutatua tatizo lifuatalo:  \nUkipatiwa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la nth linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza tu kuanza katika mwaka unaofuata mara baada ya tukio i kutokea.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "tr": "Bir Go fonksiyonu `func apocalypseYear(n int, signs []int) int` yazın ve aşağıdaki problemi çözün:\nn olayından oluşan bir dizi verildiğinde, her biri a_i yıllık bir periyodiklikle meydana gelmektedir, problem, n. olayın meydana geldiği Y_n yılını bulmaktır, bu koşul altında ki i+1. olayın geri sayımı yalnızca i. olayın meydana gelmesinden hemen sonraki yılda başlayabilir.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "vi": "Viết một hàm Go `func apocalypseYear(n int, signs []int) int` để giải quyết vấn đề sau:  \nCho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36"
    },
    "instruction_bertscore": {
      "es": "0.9932368341561431",
      "arb": "0.9000841512103064",
      "sw": "0.9670786033865155",
      "tr": "0.9523018934501871",
      "vi": "0.9680292483901486"
    },
    "level": "easy",
    "test": "func TestApocalypseYear(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(36, apocalypseYear(6, []int{3, 2, 4, 5, 9, 18}))\n\tassert.Equal(5, apocalypseYear(5, []int{1, 2, 3, 4, 5}))\n\tassert.Equal(5, apocalypseYear(5, []int{1, 1, 1, 1, 1}))\n\tassert.Equal(2012, apocalypseYear(6, []int{50, 30, 711, 200, 503, 1006}))\n\tassert.Equal(2, apocalypseYear(2, []int{1, 2}))\n\tassert.Equal(6, apocalypseYear(3, []int{3, 1, 2}))\n\tassert.Equal(4, apocalypseYear(3, []int{2, 3, 4}))\n\tassert.Equal(4, apocalypseYear(4, []int{1, 2, 3, 4}))\n\tassert.Equal(13, apocalypseYear(4, []int{5, 7, 11, 13}))\n\tassert.Equal(10, apocalypseYear(5, []int{2, 2, 2, 2, 2}))\n\tassert.Equal(15, apocalypseYear(3, []int{6, 10, 15}))\n\tassert.Equal(14, apocalypseYear(3, []int{4, 6, 14}))\n\tassert.Equal(800, apocalypseYear(4, []int{50, 30, 711, 200}))\n\tassert.Equal(6, apocalypseYear(6, []int{1, 1, 1, 1, 1, 1}))\n\tassert.Equal(1999998, apocalypseYear(2, []int{1000000, 999999}))\n}",
    "entry_point": "apocalypseYear",
    "signature": "func apocalypseYear(n int, signs []int) int",
    "docstring": {
      "es": "Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el enésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente posterior a la ocurrencia del evento i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "arb": "بالنظر إلى تسلسل من n أحداث، كل منها يحدث بتكرار دوري قدره a_i سنوات، تكمن المشكلة في إيجاد السنة Y_n عندما يحدث الحدث nth، تحت شرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "sw": "Kwa kuzingatia mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la nth linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza kuanza tu katika mwaka unaofuata mara baada ya kutokea kwa tukio i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "tr": "Verilen n olayından oluşan bir dizide, her biri a_i yıllık bir periyodiklikle meydana gelen, problem n'inci olayın gerçekleştiği Y_n yılını bulmaktır. Burada, i+1 olayının geri sayımı yalnızca i olayının gerçekleştiği yılı takip eden yılda başlayabilir.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "vi": "Cho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36"
    },
    "docstring_bertscore": {
      "es": "0.9988950191903029",
      "arb": "0.9824277660809866",
      "sw": "0.9577634344071224",
      "tr": "0.9308079012880208",
      "vi": "0.9610146164839014"
    }
  },
  {
    "task_id": "Go/33",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblema: Nueva Operación de Módulo \"⊕\".\nEn esta operación, para x ⊕ y:\n- Si x no es un múltiplo de y, el resultado es x % y.\n- Si x es un múltiplo de y, sigue dividiendo x por y (x = x / y) hasta que x ya no sea un múltiplo.\n  Sea el valor final x'. El resultado es x' % y.\n\nEjemplos:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nDado un número primo p y un entero n, calcula el valor de n! ⊕ p,\ndonde n! es el factorial de n (producto de todos los enteros positivos ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nالمشكلة: عملية باقي القسمة الجديدة \"⊕\".\nفي هذه العملية، لـ x ⊕ y:\n- إذا لم يكن x مضاعفًا لـ y، تكون النتيجة x % y.\n- إذا كان x مضاعفًا لـ y، استمر في قسمة x على y (x = x / y) حتى لا يعود x مضاعفًا.\n  دع القيمة النهائية تكون x'. النتيجة هي x' % y.\n\nأمثلة:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nبالنظر إلى عدد أولي p وعدد صحيح n، احسب قيمة n! ⊕ p،\nحيث n! هو مضروب n (حاصل ضرب جميع الأعداد الصحيحة الموجبة ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTatizo: Operesheni Mpya ya Modulo \"⊕\".\nKatika operesheni hii, kwa x ⊕ y:\n- Ikiwa x si kigezo cha y, matokeo ni x % y.\n- Ikiwa x ni kigezo cha y, endelea kugawanya x kwa y (x = x / y) hadi x isiwe tena kigezo.\n  Acha thamani ya mwisho iwe x'. Matokeo ni x' % y.\n\nMifano:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nUkipiwa nambari ya kwanza p na nambari nzima n, hesabu thamani ya n! ⊕ p,\nambapo n! ni faktoria ya n (bidhaa ya nambari zote chanya ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblem: Yeni Modulo İşlemi \"⊕\".\nBu işlemde, x ⊕ y için:\n- Eğer x, y'nin katı değilse, sonuç x % y'dir.\n- Eğer x, y'nin katıysa, x artık katı olmayana kadar x'i y'ye bölmeye devam edin (x = x / y).\n  Son değeri x' olarak adlandırın. Sonuç x' % y'dir.\n\nÖrnekler:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nVerilen bir asal sayı p ve bir tamsayı n için, n! ⊕ p değerini hesaplayın,\nburada n! n'nin faktöriyeli (n'ye kadar olan tüm pozitif tamsayıların çarpımı) anlamına gelir.\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVấn đề: Phép toán Modulo mới \"⊕\".\nTrong phép toán này, đối với x ⊕ y:\n- Nếu x không phải là bội số của y, kết quả là x % y.\n- Nếu x là bội số của y, tiếp tục chia x cho y (x = x / y) cho đến khi x không còn là bội số.\n  Để giá trị cuối cùng là x'. Kết quả là x' % y.\n\nVí dụ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nCho một số nguyên tố p và một số nguyên n, tính giá trị của n! ⊕ p,\ntrong đó n! là giai thừa của n (tích của tất cả các số nguyên dương ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {"
    },
    "prompt_bertscore": {
      "es": "0.9925086551792692",
      "arb": "0.9921437711693081",
      "sw": "0.9902508236380456",
      "tr": "0.9746088797619292",
      "vi": "0.9964522627643358"
    },
    "canonical_solution": "pj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "Escribe una función en Go `func newModuloFactorial(n, p uint64) uint64` para resolver el siguiente problema:\nProblema: Nueva Operación de Módulo \"⊕\".\nEn esta operación, para x ⊕ y:\n- Si x no es un múltiplo de y, el resultado es x % y.\n- Si x es un múltiplo de y, sigue dividiendo x por y (x = x / y) hasta que x ya no sea un múltiplo.\n  Sea el valor final x'. El resultado es x' % y.\n\nEjemplos:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nDado un número primo p y un entero n, calcula el valor de n! ⊕ p,\ndonde n! es el factorial de n (producto de todos los enteros positivos ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "arb": "اكتب دالة Go `func newModuloFactorial(n, p uint64) uint64` لحل المشكلة التالية:\nمشكلة: عملية باقي القسمة الجديدة \"⊕\".\nفي هذه العملية، لـ x ⊕ y:\n- إذا لم يكن x مضاعفًا لـ y، تكون النتيجة x % y.\n- إذا كان x مضاعفًا لـ y، استمر في قسمة x على y (x = x / y) حتى لا يعود x مضاعفًا.\n  دع القيمة النهائية تكون x'. النتيجة هي x' % y.\n\nأمثلة:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nبالنظر إلى عدد أولي p وعدد صحيح n، احسب قيمة n! ⊕ p،\nحيث n! هو مضروب n (حاصل ضرب جميع الأعداد الصحيحة الموجبة ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "sw": "Andika kazi ya Go `func newModuloFactorial(n, p uint64) uint64` kutatua tatizo lifuatalo:\nTatizo: Operesheni Mpya ya Modulo \"⊕\".\nKatika operesheni hii, kwa x ⊕ y:\n- Ikiwa x si kigezo cha y, matokeo ni x % y.\n- Ikiwa x ni kigezo cha y, endelea kugawanya x kwa y (x = x / y) hadi x isibaki kuwa kigezo.\n  Acha thamani ya mwisho iwe x'. Matokeo ni x' % y.\n\nMifano:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nUkipatiwa namba ya msingi p na nambari n, hesabu thamani ya n! ⊕ p,\nambapo n! ni faktoria ya n (bidhaa ya nambari zote chanya ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n",
      "tr": "Bir Go fonksiyonu `func newModuloFactorial(n, p uint64) uint64` yazın ve aşağıdaki problemi çözün:\nProblem: Yeni Modulo Operasyonu \"⊕\".\nBu operasyonda, x ⊕ y için:\n- Eğer x, y'nin katı değilse, sonuç x % y olur.\n- Eğer x, y'nin katı ise, x artık katı olmayana kadar x'i y'ye bölmeye devam edin (x = x / y).\n  Nihai değere x' diyelim. Sonuç x' % y olur.\n\nÖrnekler:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nVerilen bir asal sayı p ve bir tamsayı n için, n! ⊕ p değerini hesaplayın,\nburada n! n faktöriyelidir (n'ye kadar olan tüm pozitif tam sayıların çarpımı).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "vi": "Viết một hàm Go `func newModuloFactorial(n, p uint64) uint64` để giải quyết vấn đề sau:\nVấn đề: Phép toán Modulo mới \"⊕\".\nTrong phép toán này, đối với x ⊕ y:\n- Nếu x không phải là bội số của y, kết quả là x % y.\n- Nếu x là bội số của y, tiếp tục chia x cho y (x = x / y) cho đến khi x không còn là bội số.\n  Giá trị cuối cùng là x'. Kết quả là x' % y.\n\nVí dụ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nCho một số nguyên tố p và một số nguyên n, tính giá trị của n! ⊕ p,\ntrong đó n! là giai thừa của n (tích của tất cả các số nguyên dương ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "instruction_bertscore": {
      "es": "0.9961137965950524",
      "arb": "0.990651858377355",
      "sw": "0.9891976853577986",
      "tr": "0.9731833095172419",
      "vi": "0.9908187078974243"
    },
    "level": "middle",
    "test": "func TestNewModuloFactorial(t *testing.T) {\n\t// Test cases\n\tassert.Equal(t, uint64(6), newModuloFactorial(3, 7))\n\tassert.Equal(t, uint64(1), newModuloFactorial(10, 3))\n\tassert.Equal(t, uint64(4), newModuloFactorial(11, 7))\n\tassert.Equal(t, uint64(1), newModuloFactorial(45, 7))\n\tassert.Equal(t, uint64(2), newModuloFactorial(14, 7))\n\tassert.Equal(t, uint64(3152), newModuloFactorial(1919, 10007))\n\tassert.Equal(t, uint64(3679), newModuloFactorial(810, 10007))\n\tassert.Equal(t, uint64(1), newModuloFactorial(1, 2))\n\tassert.Equal(t, uint64(10), newModuloFactorial(5, 11))\n\tassert.Equal(t, uint64(5), newModuloFactorial(6, 13))\n\tassert.Equal(t, uint64(13), newModuloFactorial(8, 17))\n\tassert.Equal(t, uint64(16), newModuloFactorial(15, 19))\n\tassert.Equal(t, uint64(1), newModuloFactorial(21, 23))\n\tassert.Equal(t, uint64(28), newModuloFactorial(30, 29))\n\tassert.Equal(t, uint64(100), newModuloFactorial(100, 101))\n}",
    "entry_point": "newModuloFactorial",
    "signature": "func newModuloFactorial(n, p uint64) uint64",
    "docstring": {
      "es": "Problema: Nueva Operación de Módulo \"⊕\".\nEn esta operación, para x ⊕ y:\n- Si x no es un múltiplo de y, el resultado es x % y.\n- Si x es un múltiplo de y, sigue dividiendo x por y (x = x / y) hasta que x ya no sea un múltiplo.\n  Sea el valor final x'. El resultado es x' % y.\n\nEjemplos:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nDado un número primo p y un entero n, calcula el valor de n! ⊕ p,\ndonde n! es el factorial de n (producto de todos los enteros positivos ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "arb": "المشكلة: عملية باقي جديدة \"⊕\".  \nفي هذه العملية، لـ x ⊕ y:  \n- إذا لم يكن x مضاعفًا لـ y، فالنتيجة هي x % y.  \n- إذا كان x مضاعفًا لـ y، استمر في قسمة x على y (x = x / y) حتى لا يكون x مضاعفًا.  \n  دع القيمة النهائية تكون x'. النتيجة هي x' % y.  \n\nأمثلة:  \n- 4⊕5 = 4  \n- 20⊕5 = 4  \n- 100⊕5 = 4  \n\nمعطى عدد أولي p وعدد صحيح n، احسب قيمة n! ⊕ p،  \nحيث n! هو مضروب n (حاصل ضرب جميع الأعداد الصحيحة الموجبة ≤ n).  \n\n    >>> newModuloFactorial(3, 7)\n    6",
      "sw": "Tatizo: Operesheni Mpya ya Modulo \"⊕\".\nKatika operesheni hii, kwa x ⊕ y:\n- Ikiwa x sio kigezo cha y, matokeo ni x % y.\n- Ikiwa x ni kigezo cha y, endelea kugawanya x kwa y (x = x / y) mpaka x isiwe tena kigezo.\n  Acha thamani ya mwisho iwe x'. Matokeo ni x' % y.\n\nMifano:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nUkipewa nambari ya kwanza p na nambari nzima n, hesabu thamani ya n! ⊕ p,\nambapo n! ni faktoria ya n (bidhaa ya nambari zote chanya ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "tr": "Problem: Yeni Modulo İşlemi \"⊕\".\nBu işlemde, x ⊕ y için:\n- Eğer x, y'nin katı değilse, sonuç x % y'dir.\n- Eğer x, y'nin katıysa, x artık katı olmayana kadar x'i y'ye bölmeye devam edin (x = x / y).\n  Son değere x' deyin. Sonuç x' % y'dir.\n\nÖrnekler:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nVerilen bir asal sayı p ve bir tamsayı n için, n! ⊕ p değerini hesaplayın,\nburada n! n'nin faktöriyelidir (n'den küçük veya eşit tüm pozitif tamsayıların çarpımı).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "vi": "Vấn đề: Phép toán Modulo mới \"⊕\".\nTrong phép toán này, với x ⊕ y:\n- Nếu x không phải là bội số của y, kết quả là x % y.\n- Nếu x là bội số của y, tiếp tục chia x cho y (x = x / y) cho đến khi x không còn là bội số.\n  Để giá trị cuối cùng là x'. Kết quả là x' % y.\n\nVí dụ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nCho một số nguyên tố p và một số nguyên n, tính giá trị của n! ⊕ p,\ntrong đó n! là giai thừa của n (tích của tất cả các số nguyên dương ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "docstring_bertscore": {
      "es": "0.9898744190659845",
      "arb": "0.9794248719805011",
      "sw": "0.9954330902792459",
      "tr": "0.9650045049477493",
      "vi": "0.9948004525156497"
    }
  },
  {
    "task_id": "Go/34",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSe te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nأنت مُعطى مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).\nاعثر على الحد الأدنى من التكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUmepewa safu a ya n ya nambari kamili. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1).\nPata gharama ndogo zaidi ya kufanya vipengele vyote kwenye safu kuwa sawa.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSize n olan bir tamsayı dizisi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, bu işlemde i, j, x (1 <= i <= j <= n) üç tamsayısını seçip a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur.\nDizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9967911261943814",
      "sw": "0.9876831287024076",
      "tr": "0.954647320989447",
      "vi": "0.9821409438107722"
    },
    "canonical_solution": "p, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}",
    "instruction": {
      "es": "Escribe una función de Go `func makeEqualAgain(n int, a []int) int` para resolver el siguiente problema:\nSe te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "arb": "اكتب دالة Go `func makeEqualAgain(n int, a []int) int` لحل المشكلة التالية:\nأنت مُعطى مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).\nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "sw": "Andika kazi ya Go `func makeEqualAgain(n int, a []int) int` kutatua tatizo lifuatalo:\nUmepewa safu a ya n ya nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1).\nPata gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "tr": "Bir Go fonksiyonu `func makeEqualAgain(n int, a []int) int` yazın ve aşağıdaki problemi çözün:\nn tamsayısından oluşan bir dizi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, burada i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlem (j - i + 1) maliyetine sahiptir.\nDizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "vi": "Viết một hàm Go `func makeEqualAgain(n int, a []int) int` để giải quyết vấn đề sau:\nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.996646721907369",
      "sw": "0.9874306694881123",
      "tr": "0.9736254607454254",
      "vi": "0.9867076549011453"
    },
    "level": "middle",
    "test": "func TestMakeEqualAgain(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, makeEqualAgain(3, []int{1, 2, 1}))\n\tassert.Equal(1, makeEqualAgain(5, []int{5, 5, 1, 5, 5}))\n\tassert.Equal(0, makeEqualAgain(4, []int{1, 1, 1, 1}))\n\tassert.Equal(1, makeEqualAgain(6, []int{2, 2, 2, 3, 2, 2}))\n\tassert.Equal(0, makeEqualAgain(1, []int{1}))\n\tassert.Equal(1, makeEqualAgain(2, []int{1, 2}))\n\tassert.Equal(2, makeEqualAgain(4, []int{1, 2, 2, 1}))\n\tassert.Equal(2, makeEqualAgain(7, []int{4, 4, 4, 3, 3, 4, 4}))\n\tassert.Equal(3, makeEqualAgain(6, []int{5, 4, 4, 4, 5, 5}))\n\tassert.Equal(5, makeEqualAgain(7, []int{1, 2, 1, 2, 1, 2, 1}))\n\tassert.Equal(4, makeEqualAgain(6, []int{1, 2, 3, 4, 5, 1}))\n\tassert.Equal(0, makeEqualAgain(7, []int{1, 1, 1, 1, 1, 1, 1}))\n\tassert.Equal(2, makeEqualAgain(8, []int{8, 8, 8, 1, 2, 8, 8, 8}))\n\tassert.Equal(2, makeEqualAgain(3, []int{1, 2, 3}))\n\tassert.Equal(6, makeEqualAgain(7, []int{4, 3, 2, 7, 1, 1, 3}))\n\tassert.Equal(7, makeEqualAgain(9, []int{9, 9, 2, 9, 2, 5, 5, 5, 3}))\n}",
    "entry_point": "makeEqualAgain",
    "signature": "func makeEqualAgain(n int, a []int) int",
    "docstring": {
      "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "arb": "أنت مُعطى مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). \nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "sw": "Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). Pata gharama ya chini kabisa ya kufanya vipengele vyote kwenye safu kuwa sawa.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "tr": "Verilen bir n tamsayıdan oluşan a diziniz var. En fazla bir işlem gerçekleştirebilirsiniz, burada üç tamsayı i, j, x (1 <= i <= j <= n) seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, maliyeti (j - i + 1) olur. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9958865634391485",
      "sw": "0.9864575792514224",
      "tr": "0.9722139932577916",
      "vi": "0.9780386305512586"
    }
  },
  {
    "task_id": "Go/35",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras,\ndetermina el ganador de un juego jugado por Charlie y Dan. Charlie comienza primero, turnándose con Dan para mover\nun número positivo de piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El jugador\nobligado a mover piedras solo en la última pila pierde. Suponiendo un juego óptimo, determina el ganador.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، تحتوي كل منها على عدد موجب من الحجارة،\nحدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوب مع دان لتحريك عدد موجب من الحجارة\nمن الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. اللاعب الذي يُجبر على تحريك الحجارة\nفقط في الكومة الأخيرة يخسر. بافتراض اللعب الأمثل، اكتشف الفائز.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipewa mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe,\nbaini mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza, akibadilishana zamu na Dan kuhamisha\nidadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji anayelazimika\nkuhamisha mawe tu kwenye rundo la mwisho anapoteza. Kwa kudhani uchezaji bora, tafuta mshindi.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her biri pozitif sayıda taş içeren,\nCharlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk olarak, Dan ile sırayla\nsol en uçtaki boş olmayan yığından bitişik sağ yığına pozitif sayıda taş taşıyarak hamle yapar. Sadece\nson yığındaki taşları hareket ettirmek zorunda kalan oyuncu kaybeder. Optimal oyun varsayılarak, kazananı bulun.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương,\nxác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, lần lượt với Dan để di chuyển\nmột số lượng đá dương từ đống không rỗng bên trái nhất sang đống bên phải liền kề. Người chơi bị buộc phải\nchỉ di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi tối ưu, tìm ra người chiến thắng.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {"
    },
    "prompt_bertscore": {
      "es": "0.9887636779752375",
      "arb": "0.9758739566587404",
      "sw": "0.959531443428714",
      "tr": "0.9760729843005373",
      "vi": "0.9872912309606258"
    },
    "canonical_solution": "if n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}",
    "instruction": {
      "es": "Escriba una función en Go `func GameWinner(n int, piles []int) string` para resolver el siguiente problema:\nDada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras,\ndetermine el ganador de un juego jugado por Charlie y Dan. Charlie va primero, turnándose con Dan para mover\nun número positivo de piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El jugador obligado a\nmover piedras solo en la última pila pierde. Asumiendo un juego óptimo, determine el ganador.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "arb": "اكتب دالة Go `func GameWinner(n int, piles []int) string` لحل المشكلة التالية:\nبالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، يحتوي كل منها على عدد إيجابي من الحجارة،\nحدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوب مع دان لتحريك\nعدد إيجابي من الحجارة من الكومة غير الفارغة الأقصى إلى اليسار إلى الكومة المجاورة على اليمين. اللاعب الذي يُجبر على\nتحريك الحجارة فقط في الكومة الأخيرة يخسر. بافتراض اللعب الأمثل، اكتشف الفائز.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "sw": "Andika kazi ya Go `func GameWinner(n int, piles []int) string` kutatua tatizo lifuatalo:\nUkipatiwa mlolongo wa mirundo N ya mawe iliyoorodheshwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe,\nbaini mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza, akibadilishana zamu na Dan kuhamisha\nidadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji anayelazimishwa\nkuhamisha mawe tu kwenye rundo la mwisho anapoteza. Ukizingatia uchezaji bora, gundua mshindi.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "tr": "Bir Go fonksiyonu `func GameWinner(n int, piles []int) string` yazın ve aşağıdaki problemi çözün:\n1'den N'ye kadar numaralandırılmış N taş yığını verildiğinde, her biri pozitif sayıda taş içeren,\nCharlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk başlar ve Dan ile sırayla\nsol en uçtaki boş olmayan yığından bitişik sağ yığına pozitif sayıda taş taşır. Sadece son yığındaki taşları\nhareket ettirmek zorunda kalan oyuncu kaybeder. Optimal oyun varsayıldığında, kazananı bulun.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "vi": "Viết một hàm Go `func GameWinner(n int, piles []int) string` để giải quyết vấn đề sau:  \nCho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, lần lượt với Dan để di chuyển một số lượng đá dương từ đống không rỗng ngoài cùng bên trái sang đống liền kề bên phải. Người chơi buộc phải chỉ di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi tối ưu, tìm ra người chiến thắng.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\""
    },
    "instruction_bertscore": {
      "es": "0.9853512080290581",
      "arb": "0.9762014981570669",
      "sw": "0.9600433139206409",
      "tr": "0.9580905786446868",
      "vi": "0.9843437547364491"
    },
    "level": "middle",
    "test": "func TestGameWinner(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Dan\", GameWinner(3, []int{1, 2, 2}))\n\tassert.Equal(\"Charlie\", GameWinner(5, []int{5, 5, 5, 5, 5}))\n\tassert.Equal(\"Charlie\", GameWinner(3, []int{2, 1, 2}))\n\tassert.Equal(\"Charlie\", GameWinner(4, []int{3, 3, 3, 3}))\n\tassert.Equal(\"Charlie\", GameWinner(2, []int{1, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(2, []int{2, 1}))\n\tassert.Equal(\"Dan\", GameWinner(11, []int{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(10, []int{2, 2, 2, 2, 2, 2, 2, 2, 2, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(10, []int{10, 10, 10, 10, 10, 10, 10, 10, 10, 10}))\n\tassert.Equal(\"Dan\", GameWinner(10, []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\n}",
    "entry_point": "GameWinner",
    "signature": "func GameWinner(n int, piles []int) string",
    "docstring": {
      "es": "Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determine el ganador de un juego jugado por Charlie y Dan. Charlie comienza primero, turnándose con Dan para mover un número positivo de piedras de la pila más a la izquierda que no esté vacía a la pila adyacente a la derecha. El jugador obligado a mover piedras solo en la última pila pierde. Asumiendo un juego óptimo, determine el ganador.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "arb": "بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، يحتوي كل منها على عدد إيجابي من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوب مع دان لتحريك عدد إيجابي من الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. اللاعب الذي يُجبر على تحريك الحجارة فقط في الكومة الأخيرة يخسر. بافتراض اللعب الأمثل، اكتشف من هو الفائز.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "sw": "Kwa kuzingatia mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe, tambua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza, akichukua zamu na Dan kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji anayelazimishwa kuhamisha mawe tu kwenye rundo la mwisho anapoteza. Tukizingatia uchezaji bora, tafuta mshindi.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "tr": "Verilen 1'den N'ye kadar numaralandırılmış N taş yığını dizisinde, her biri pozitif sayıda taş içeren, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk olarak, Dan ile sırayla, soldaki en dolu olmayan yığından sağdaki bitişik yığına pozitif sayıda taş taşır. Sadece son yığındaki taşları taşımak zorunda kalan oyuncu kaybeder. Optimal oyun varsayıldığında, kazananı bulun.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, lần lượt với Dan để di chuyển một số lượng đá dương từ đống không rỗng bên trái nhất sang đống kế bên phải. Người chơi bị buộc phải chỉ di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi tối ưu, tìm ra người chiến thắng.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\""
    },
    "docstring_bertscore": {
      "es": "0.9676349670837943",
      "arb": "0.9632680781567423",
      "sw": "0.9500869660712671",
      "tr": "0.9656826290686024",
      "vi": "0.9766468274713471"
    }
  },
  {
    "task_id": "Go/36",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى من التكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkiwa na milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusogea hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBir çember şeklinde düzenlenmiş n kapı verildiğinde, oyuncu kapı 1'in önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i ödeyebilir. C_i >= C_{i+1} olduğu garanti edilir, 1 <= i < n için.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho n cánh cửa sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} với 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {"
    },
    "prompt_bertscore": {
      "es": "0.9936561428905077",
      "arb": "0.9936561428905077",
      "sw": "0.9965287354610343",
      "tr": "0.9936561428905077",
      "vi": "0.986352702410236"
    },
    "canonical_solution": "return int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}",
    "instruction": {
      "es": "Escribe una función en Go `func MinTotalCost(n int, C []int) int64` para resolver el siguiente problema:\nDadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "arb": "اكتب دالة Go `func MinTotalCost(n int, C []int) int64` لحل المشكلة التالية:\nمعطى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "sw": "Andika kazi ya Go `func MinTotalCost(n int, C []int) int64` kutatua tatizo lifuatalo:\nUkipiwa milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "tr": "Bir Go fonksiyonu `func MinTotalCost(n int, C []int) int64` yazın ve aşağıdaki problemi çözün:\nn kapıdan oluşan bir çember verildiğinde, oyuncu 1 numaralı kapının önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i ödeyebilir. C_i >= C_{i+1} olduğu garanti edilir, burada 1 <= i < n.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "vi": "Viết một hàm Go `func MinTotalCost(n int, C []int) int64` để giải quyết vấn đề sau:\nCho n cánh cửa được sắp xếp thành vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n"
    },
    "instruction_bertscore": {
      "es": "0.9877081561304181",
      "arb": "0.992001154555725",
      "sw": "0.9953683367750285",
      "tr": "0.9654091150339174",
      "vi": "0.9842664875182265"
    },
    "level": "easy",
    "test": "func TestMinTotalCost(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(15), MinTotalCost(5, []int{4, 3, 3, 3, 3})) // Note the 0-indexed array for slice in Golang\n\tassert.Equal(int64(3), MinTotalCost(3, []int{1, 1, 1}))\n\tassert.Equal(int64(11), MinTotalCost(4, []int{5, 4, 3, 2}))\n\tassert.Equal(int64(391), MinTotalCost(4, []int{100, 99, 98, 97}))\n\tassert.Equal(int64(35), MinTotalCost(6, []int{10, 9, 8, 7, 6, 5}))\n\tassert.Equal(int64(14), MinTotalCost(7, []int{2, 2, 2, 2, 2, 2, 2}))\n\tassert.Equal(int64(56), MinTotalCost(8, []int{9, 7, 7, 7, 7, 7, 7, 7}))\n\tassert.Equal(int64(18), MinTotalCost(9, []int{3, 2, 2, 2, 2, 2, 2, 2, 2}))\n\tassert.Equal(int64(50), MinTotalCost(10, []int{6, 5, 5, 5, 5, 5, 5, 5, 5, 5}))\n\tassert.Equal(int64(11), MinTotalCost(11, []int{8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}))\n}",
    "entry_point": "MinTotalCost",
    "signature": "func MinTotalCost(n int, C []int) int64",
    "docstring": {
      "es": "Dadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n. La tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "arb": "معطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n. المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "sw": "Kwa kuwa na milango n iliyopangwa katika mduara, mchezaji huanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n. \nKazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "tr": "Verilen n kapı bir daire şeklinde düzenlenmiştir, oyuncu kapı 1'in önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilmektedir, 1 <= i < n için.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "vi": "Cho n cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} với 1 <= i < n. Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9860934897629854",
      "arb": "0.9926687512663833",
      "sw": "0.9956591316528636",
      "tr": "0.9758350251040576",
      "vi": "0.9817484501778472"
    }
  },
  {
    "task_id": "Go/37",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDada una secuencia de IDs de estudiantes que ingresan a un aula, donde los IDs varían de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con cada estudiante que ya esté en el aula con un número de ID menor. La secuencia representa el orden en que los estudiantes ingresan al aula.\n\nEjemplos:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح كل طالب موجود بالفعل في الفصل بمعرف أصغر. يمثل التسلسل الترتيب الذي يدخل فيه الطلاب إلى الفصل.\n\nأمثلة:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipatiwa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vipo kati ya 0 hadi N-1, hesabu jumla ya mikono iliyoshikwa. Kila mwanafunzi atashikana mikono na kila mwanafunzi ambaye tayari yupo darasani mwenye kitambulisho kidogo zaidi. Mlolongo unaonyesha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBir sınıfa giren öğrenci kimlikleri dizisi verildiğinde, kimliklerin 0'dan N-1'e kadar sıralandığı varsayılırsa, gerçekleşen toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfa daha küçük bir kimlik numarasıyla zaten girmiş olan her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một dãy số ID của học sinh vào lớp học, trong đó các ID có phạm vi từ 0 đến N-1, tính tổng số cái bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với mọi học sinh đã có mặt trong lớp với số ID nhỏ hơn. Dãy số đại diện cho thứ tự mà học sinh vào lớp.\n\nVí dụ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {"
    },
    "prompt_bertscore": {
      "es": "0.9948971855112138",
      "arb": "0.991385400374517",
      "sw": "0.9795299474520686",
      "tr": "0.9534497784221877",
      "vi": "0.9857482701607467"
    },
    "canonical_solution": "var ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "Escribe una función en Go `func CountHandshakes(n int, order []int) int64` para resolver el siguiente problema:\nDada una secuencia de IDs de estudiantes que entran a un aula, donde los IDs van de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con cada estudiante que ya esté en el aula con un número de ID menor. La secuencia representa el orden en que los estudiantes entran al aula.\n\nEjemplos:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "arb": "اكتب دالة Go `func CountHandshakes(n int, order []int) int64` لحل المشكلة التالية:\nبالنظر إلى تسلسل معرفات الطلاب الذين يدخلون إلى الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح كل طالب موجود بالفعل في الفصل برقم معرف أصغر. يمثل التسلسل ترتيب دخول الطلاب إلى الفصل.\n\nأمثلة:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "sw": "Andika kazi ya Go `func CountHandshakes(n int, order []int) int64` kutatua tatizo lifuatalo:\nUkipatiwa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1, hesabu jumla ya mikono iliyoshikana. Kila mwanafunzi atashikana mikono na kila mwanafunzi ambaye tayari yuko darasani mwenye kitambulisho kidogo zaidi. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "tr": "Bir Go fonksiyonu `func CountHandshakes(n int, order []int) int64` yazın ve aşağıdaki problemi çözün:\nBir sınıfa giren öğrenci kimlik numaralarının bir dizisi verildiğinde, kimlik numaraları 0'dan N-1'e kadar olan, gerçekleşen toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfa daha önce girmiş ve daha küçük bir kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "vi": "Viết một hàm Go `func CountHandshakes(n int, order []int) int64` để giải quyết vấn đề sau:  \nCho một dãy số ID của học sinh khi vào lớp học, trong đó các ID nằm trong khoảng từ 0 đến N-1, tính tổng số lần bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với mọi học sinh đã có mặt trong lớp với ID nhỏ hơn. Dãy số này biểu thị thứ tự mà học sinh vào lớp.\n\nVí dụ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0"
    },
    "instruction_bertscore": {
      "es": "0.9898251587314878",
      "arb": "0.9800487700073317",
      "sw": "0.9773897050964176",
      "tr": "0.9469881334967418",
      "vi": "0.9751741818263545"
    },
    "level": "hard",
    "test": "func TestCountHandshakes(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(2), CountHandshakes(4, []int{2, 1, 3, 0}))\n\tassert.Equal(int64(15), CountHandshakes(6, []int{0, 1, 2, 3, 4, 5}))\n\tassert.Equal(int64(1), CountHandshakes(3, []int{1, 2, 0}))\n\tassert.Equal(int64(0), CountHandshakes(4, []int{3, 2, 1, 0}))\n\tassert.Equal(int64(6), CountHandshakes(4, []int{0, 1, 2, 3}))\n\tassert.Equal(int64(0), CountHandshakes(6, []int{5, 4, 3, 2, 1, 0}))\n\tassert.Equal(int64(5), CountHandshakes(4, []int{0, 2, 1, 3}))\n\tassert.Equal(int64(3), CountHandshakes(5, []int{3, 1, 4, 2, 0}))\n\tassert.Equal(int64(4), CountHandshakes(4, []int{1, 0, 3, 2}))\n\tassert.Equal(int64(1), CountHandshakes(3, []int{2, 0, 1}))\n\tassert.Equal(int64(7), CountHandshakes(5, []int{1, 3, 0, 2, 4}))\n\tassert.Equal(int64(0), CountHandshakes(5, []int{4, 3, 2, 1, 0}))\n}\n\n// To run tests in Go, you can use the following command:\n// go test -v",
    "entry_point": "CountHandshakes",
    "signature": "func CountHandshakes(n int, order []int) int64",
    "docstring": {
      "es": "Dada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones varían de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con cada estudiante que ya esté en el aula con un número de identificación menor. La secuencia representa el orden en que los estudiantes ingresan al aula.\n\nEjemplos:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "arb": "بالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سيصافح كل طالب موجود بالفعل في الفصل برقم معرف أصغر. يمثل التسلسل الترتيب الذي يدخل به الطلاب إلى الفصل.\n\nأمثلة:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "sw": "Mpeana mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1, hesabu jumla ya mikono inayoshikwa. Kila mwanafunzi atashikana mikono na kila mwanafunzi ambaye tayari yuko darasani na ana kitambulisho kidogo. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "tr": "Verilen bir sınıfa giren öğrenci kimlikleri dizisi için, kimliklerin 0'dan N-1'e kadar sıralandığı durumda, gerçekleşen toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfa daha önce girmiş ve daha küçük bir kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "vi": "Đưa ra một dãy số ID của học sinh khi vào lớp học, trong đó các ID nằm trong khoảng từ 0 đến N-1, tính tổng số cái bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với mọi học sinh đã có mặt trong lớp với số ID nhỏ hơn. Dãy số này biểu thị thứ tự mà các học sinh vào lớp.\n\nVí dụ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0"
    },
    "docstring_bertscore": {
      "es": "0.9927329088794575",
      "arb": "0.9887313012231287",
      "sw": "0.9720697876011603",
      "tr": "0.9178182688898633",
      "vi": "0.9600117316900563"
    }
  },
  {
    "task_id": "Go/38",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado n números enteros positivos que representan la cantidad de cada número de 1 a n,\nencuentra la suma máxima de la moda (elemento más frecuente) para todos los prefijos de\nuna secuencia construida a partir de estos números. La moda es el número más grande entre\nlos elementos más frecuentes en una secuencia.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tUna secuencia que alcanza su valor máximo es (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات\nلسلسلة تم إنشاؤها من هذه الأرقام. النمط هو أكبر عدد بين\nالعناصر الأكثر تكرارًا في سلسلة.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tسلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa n nambari chanya zinazoashiria idadi ya kila nambari kutoka 1 hadi n,\ntafuta jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi) kwa viambishi vyote vya\nmlolongo uliojengwa kutoka kwa nambari hizi. Modi ni nambari kubwa zaidi kati ya\nvipengele vinavyojitokeza mara nyingi katika mlolongo.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n1'den n'e kadar her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\nbu sayılardan oluşturulan bir dizinin tüm ön ekleri için modun (en sık rastlanan eleman)\nmaksimum toplamını bulun. Mod, bir dizideki en sık rastlanan elemanlar arasında en büyük sayıdır.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMaksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\nmột dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMột dãy đạt giá trị tối đa là (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9885864996753543",
      "sw": "0.960101512622284",
      "tr": "0.9627466734065256",
      "vi": "0.9712079303778498"
    },
    "canonical_solution": "ans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "Escribe una función en Go `func MaxModeSum(n int, counts []int) int64` para resolver el siguiente problema:\nDado n números enteros positivos que representan la cantidad de cada número del 1 al n,\nencuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de\nuna secuencia construida a partir de estos números. El modo es el número más grande entre\nlos elementos más frecuentes en una secuencia.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tUna secuencia que alcanza su valor máximo es (3,2,3,1,2,2).",
      "arb": "اكتب دالة Go `func MaxModeSum(n int, counts []int) int64` لحل المشكلة التالية:\nمعطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\nابحث عن الحد الأقصى لمجموع الوضع (العنصر الأكثر تكرارًا) لجميع البادئات\nلسلسلة مكونة من هذه الأرقام. الوضع هو أكبر رقم بين\nالعناصر الأكثر تكرارًا في سلسلة.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tتسلسل يصل إلى قيمته القصوى هو (3,2,3,1,2,2).",
      "sw": "Andika kazi ya Go `func MaxModeSum(n int, counts []int) int64` kutatua tatizo lifuatalo:\nUkipiwa n nambari chanya zinazoonyesha idadi ya kila nambari kutoka 1 hadi n,\ntafuta jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya\nmlolongo uliotengenezwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya\nvipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).",
      "tr": "Bir Go fonksiyonu `func MaxModeSum(n int, counts []int) int64` yazın ve aşağıdaki problemi çözün:\n1'den n'e kadar olan her sayının sayısını temsil eden n pozitif tam sayı verildiğinde,\nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun.\nMod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMaksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.",
      "vi": "Viết một hàm Go `func MaxModeSum(n int, counts []int) int64` để giải quyết vấn đề sau:\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\nmột dãy được tạo thành từ các số này. Mode là số lớn nhất trong số\ncác phần tử xuất hiện nhiều nhất trong một dãy.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMột dãy đạt giá trị tối đa là (3,2,3,1,2,2)."
    },
    "instruction_bertscore": {
      "es": "0.9889281439307342",
      "arb": "0.9843477273440697",
      "sw": "0.9476390452553931",
      "tr": "0.97280293233756",
      "vi": "0.9752357572444753"
    },
    "level": "middle",
    "test": "func TestMaxModeSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(17), MaxModeSum(3, []int{1, 3, 2}))\n\tassert.Equal(int64(37), MaxModeSum(4, []int{4, 1, 2, 3}))\n\tassert.Equal(int64(4), MaxModeSum(2, []int{1, 1}))\n\tassert.Equal(int64(75), MaxModeSum(5, []int{1, 2, 3, 4, 5}))\n\tassert.Equal(int64(100000), MaxModeSum(1, []int{100000}))\n\tassert.Equal(int64(62), MaxModeSum(5, []int{5, 3, 2, 4, 1}))\n\tassert.Equal(int64(900000), MaxModeSum(3, []int{100000, 100000, 100000}))\n\tassert.Equal(int64(27), MaxModeSum(3, []int{2, 2, 5}))\n\tassert.Equal(int64(64), MaxModeSum(4, []int{4, 4, 4, 4}))\n\tassert.Equal(int64(126), MaxModeSum(6, []int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(int64(16), MaxModeSum(3, []int{3, 1, 2}))\n}",
    "entry_point": "MaxModeSum",
    "signature": "func MaxModeSum(n int, counts []int) int64",
    "docstring": {
      "es": "Dado n enteros positivos que representan el conteo de cada número del 1 al n, encuentra la suma máxima de la moda (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. La moda es el número más grande entre los elementos más frecuentes en una secuencia.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tUna secuencia que alcanza su valor máximo es (3,2,3,1,2,2).",
      "arb": "معطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، \nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات \nلسلسلة تم إنشاؤها من هذه الأرقام. النمط هو أكبر رقم بين \nالعناصر الأكثر تكرارًا في سلسلة.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tسلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).",
      "sw": "Kutolewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, tafuta jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya mlolongo ulioundwa kutoka kwa nambari hizi. Modi ni nambari kubwa zaidi kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).",
      "tr": "Verilen n pozitif tamsayı, 1'den n'e kadar olan her sayının sayısını temsil eder,\nbu sayılardan oluşturulan bir dizinin tüm ön ekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMaksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.",
      "vi": "Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\nmột dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMột dãy đạt giá trị lớn nhất là (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9714643621997658",
      "sw": "0.9452679943969796",
      "tr": "0.9280258841712462",
      "vi": "0.9647798539867988"
    }
  },
  {
    "task_id": "Go/39",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) devuelve 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع عملية XOR لجميع المصفوفات الفرعية.\nيتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR لمصفوفة فرعية هو نتيجة عملية XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الفرعية الممكنة.\n\nأمثلة على الحالات:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) يعيد 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote.\nSehemu ndogo inafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) inarudisha 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\nBir alt dizi, 1 <= L <= R <= n olan bir (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nNihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 döndürür\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, với n là kích thước của mảng.\nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) trả về 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {"
    },
    "prompt_bertscore": {
      "es": "0.9926310114939867",
      "arb": "0.9742279066911043",
      "sw": "0.9848605909879019",
      "tr": "0.9741508381032628",
      "vi": "1"
    },
    "canonical_solution": "n := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}",
    "instruction": {
      "es": "Escribe una función en Go `func sumOfXorSubarrays(A []int) int64` para resolver el siguiente problema:\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) devuelve 39",
      "arb": "اكتب دالة Go `func sumOfXorSubarrays(A []int) int64` لحل المشكلة التالية:\nبالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الفرعية.\nيتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث يكون 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR لمصفوفة فرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الفرعية الممكنة.\n\nحالات المثال:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) يعيد 39",
      "sw": "Andika kazi ya Go `func sumOfXorSubarrays(A []int) int64` kutatua tatizo lifuatalo:\nUkipewa safu A ya namba nzima, kazi ni kuhesabu jumla ya XOR ya vipande vyote vya safu.\nKipande cha safu kinafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya kipande cha safu ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa vipande vyote vinavyowezekana.\n\nMifano ya kesi:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) inarudisha 39",
      "tr": "Bir Go fonksiyonu `func sumOfXorSubarrays(A []int) int64` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, 1 <= L <= R <= n olacak şekilde (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nSonuç, tüm olası alt dizilerin XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 döndürür.",
      "vi": "Viết một hàm Go `func sumOfXorSubarrays(A []int) int64` để giải quyết vấn đề sau:\nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) trả về 39"
    },
    "instruction_bertscore": {
      "es": "0.9868480865805369",
      "arb": "0.9769272935693685",
      "sw": "0.9800060644754092",
      "tr": "0.9662950065333329",
      "vi": "1"
    },
    "level": "middle",
    "test": "func TestSumOfXorSubarrays(t *testing.T) {\n\tassert.Equal(t, int64(39), sumOfXorSubarrays([]int{1, 2, 3, 4, 5}))\n\tassert.Equal(t, int64(4), sumOfXorSubarrays([]int{1, 1, 1}))\n\tassert.Equal(t, int64(9), sumOfXorSubarrays([]int{2, 3, 1}))\n\tassert.Equal(t, int64(74), sumOfXorSubarrays([]int{4, 5, 7, 9}))\n\tassert.Equal(t, int64(0), sumOfXorSubarrays([]int{0, 0, 0, 0}))\n\tassert.Equal(t, int64(72), sumOfXorSubarrays([]int{8, 8, 8, 8, 8}))\n\tassert.Equal(t, int64(125), sumOfXorSubarrays([]int{3, 6, 9, 12, 15}))\n\tassert.Equal(t, int64(390), sumOfXorSubarrays([]int{10, 20, 30, 40, 50}))\n\tassert.Equal(t, int64(192), sumOfXorSubarrays([]int{16, 16, 16, 16, 16, 16}))\n\tassert.Equal(t, int64(192), sumOfXorSubarrays([]int{1, 3, 5, 7, 9, 11, 13}))\n\tassert.Equal(t, int64(218), sumOfXorSubarrays([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}))\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "func sumOfXorSubarrays(A []int) int64",
    "docstring": {
      "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays. Un subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array. La suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R. El resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) devuelve 39",
      "arb": "المطلوب هو حساب مجموع عملية XOR لجميع المصفوفات الفرعية.\n\nالمصفوفة الفرعية تُعرّف بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\n\nمجموع XOR للمصفوفة الفرعية هو نتيجة عملية XOR لجميع العناصر من L إلى R.\n\nالنتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الفرعية الممكنة.\n\nأمثلة على الحالات:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) تُعيد 39",
      "sw": "Kwa kupewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu zote ndogo za safu.\nSehemu ndogo ya safu inafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ya safu ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa sehemu zote ndogo zinazowezekana.\n\nMifano ya kesi:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) inarudisha 39",
      "tr": "Verilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, (L, R) indeks çiftleriyle tanımlanır ve 1 <= L <= R <= n, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nNihai sonuç, tüm olası alt dizilerin XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 döndürür",
      "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con. \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng. \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R. \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể có.\n\nCác trường hợp ví dụ:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) trả về 39"
    },
    "docstring_bertscore": {
      "es": "0.991328989346303",
      "arb": "0.9381520609964048",
      "sw": "0.9654265945074484",
      "tr": "0.9638592021707021",
      "vi": "0.9948606375211033"
    }
  },
  {
    "task_id": "Go/40",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n,\nque pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "arb": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n،\nالتي يمكن التعبير عنها كـ x = a^b مع كون a و b أعداد صحيحة موجبة و b >= k.\nيتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "sw": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa nambari mbili nzima chanya n na k, pata idadi ya nambari chanya x, ambapo 1 <= x <= n,\nambazo zinaweza kuonyeshwa kama x = a^b na a na b wakiwa nambari nzima chanya na b >= k.\nMwakilishi tofauti halali wa nambari sawa huhesabiwa mara moja tu.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "tr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nİki pozitif tam sayı n ve k verildiğinde, 1 <= x <= n aralığında,\nx = a^b olarak ifade edilebilen pozitif tam sayı x'lerin sayısını bulun,\nburada a ve b pozitif tam sayılar ve b >= k.\nAynı sayının farklı yasal temsilleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "vi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n,\nmà có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k.\nCác biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.9940146707282758",
      "tr": "0.9766394781472488",
      "vi": "0.982202519228893"
    },
    "canonical_solution": "count := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}",
    "instruction": {
      "es": "Escribe una función en Go `func countPowerNumbers(n int, k int) int` para resolver el siguiente problema:\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n,\nque pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99",
      "arb": "اكتب دالة Go `func countPowerNumbers(n int, k int) int` لحل المشكلة التالية:\nمعطى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n،\nالتي يمكن التعبير عنها كـ x = a^b حيث a و b هما عددان صحيحان موجبان و b >= k.\nيتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> countPowerNumbers(99, 1)\n    99",
      "sw": "Andika kazi ya Go `func countPowerNumbers(n int, k int) int` kutatua tatizo lifuatalo:  \nUkipiwa nambari mbili chanya n na k, tafuta idadi ya nambari chanya x, ambapo 1 <= x <= n,  \nambazo zinaweza kuonyeshwa kama x = a^b na a na b wakiwa ni nambari chanya na b >= k.  \nUwakilishi tofauti halali wa nambari sawa unahesabiwa mara moja tu.  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "tr": "Bir Go fonksiyonu `func countPowerNumbers(n int, k int) int` yazın ve aşağıdaki problemi çözün:\nVerilen iki pozitif tam sayı n ve k için, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tam sayı x'lerin sayısını bulun. Burada a ve b pozitif tam sayılar ve b >= k olmalıdır.\nAynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99",
      "vi": "Viết một hàm Go `func countPowerNumbers(n int, k int) int` để giải quyết vấn đề sau:  \nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n,  \nmà có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k.  \nCác biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.  \n    >>> countPowerNumbers(99, 1)  \n    99  "
    },
    "instruction_bertscore": {
      "es": "0.9947472195735324",
      "arb": "0.9655672248172211",
      "sw": "0.9782215691321917",
      "tr": "0.9328351229568629",
      "vi": "0.9771263212111654"
    },
    "level": "hard",
    "test": "func TestCountPowerNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(99, countPowerNumbers(99, 1))\n\tassert.Equal(7, countPowerNumbers(99, 3))\n\tassert.Equal(12, countPowerNumbers(99, 2))\n\tassert.Equal(10, countPowerNumbers(10, 1))\n\tassert.Equal(4, countPowerNumbers(10, 2))\n\tassert.Equal(500, countPowerNumbers(500, 1))\n\tassert.Equal(30, countPowerNumbers(500, 2))\n\tassert.Equal(13, countPowerNumbers(500, 3))\n\tassert.Equal(1000, countPowerNumbers(1000, 1))\n\tassert.Equal(41, countPowerNumbers(1000, 2))\n\tassert.Equal(17, countPowerNumbers(1000, 3))\n\tassert.Equal(1, countPowerNumbers(1000, 93))\n\tassert.Equal(10, countPowerNumbers(50, 2))\n\tassert.Equal(5, countPowerNumbers(50, 3))\n\tassert.Equal(1, countPowerNumbers(2, 3))\n}",
    "entry_point": "countPowerNumbers",
    "signature": "func countPowerNumbers(n int, k int) int",
    "docstring": {
      "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99",
      "arb": "بالنظر إلى عددين صحيحين موجبَين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b عددين صحيحين موجبَين و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس العدد مرة واحدة فقط.\n    >>> countPowerNumbers(99, 1)\n    99",
      "sw": "Kwa kupewa nambari mbili nzima chanya n na k, pata idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari nzima chanya na b >= k. Uwakilishi tofauti halali wa nambari ile ile unahesabiwa mara moja tu.\n    >>> countPowerNumbers(99, 1)\n    99",
      "tr": "İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tamsayıların sayısını bulun, burada a ve b pozitif tamsayılar ve b >= k'dir. Aynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99",
      "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của cùng một số chỉ được tính một lần.  \n    >>> countPowerNumbers(99, 1)  \n    99  "
    },
    "docstring_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9902891593015853",
      "sw": "0.9768172523382751",
      "tr": "0.9447906855913528",
      "vi": "0.9728297474389997"
    }
  },
  {
    "task_id": "Go/41",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\ntal que la subsecuencia balanceada más larga es de longitud 2 * k. El resultado debe ser calculado\nmódulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')',\nبحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة\nباقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa nambari tatu n, m, na k, pata idadi ya mfuatano inayojumuisha n '(' na m ')',\nhivyo kwamba mfuatano mrefu zaidi ulio sawa ni wa urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa\nkwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÜç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun,\nöyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç, 1,000,000,007 (10^9 + 7) ile\nmod alınarak hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho ba số nguyên n, m, và k, tìm số lượng dãy gồm n '(' và m ')',\nsao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính\ntheo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {"
    },
    "prompt_bertscore": {
      "es": "0.9977016478610453",
      "arb": "0.9945603083849786",
      "sw": "0.9891589524334968",
      "tr": "0.9769431839998513",
      "vi": "0.9918559557471885"
    },
    "canonical_solution": "const P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}",
    "instruction": {
      "es": "Escribe una función en Go `func countBalancedSubsequences(n, m, k int64) int64` para resolver el siguiente problema:\nDado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\ntal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado\nmódulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "arb": "اكتب دالة Go `func countBalancedSubsequences(n, m, k int64) int64` لحل المشكلة التالية:\nبالنظر إلى ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التسلسلات المكونة من n '(' و m ')',\nبحيث يكون أطول تسلسل متوازن بطول 2 * k. يجب حساب النتيجة\nباقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "sw": "Andika kazi ya Go `func countBalancedSubsequences(n, m, k int64) int64` kutatua tatizo lifuatalo:\nUkipiwa nambari tatu n, m, na k, pata idadi ya mlolongo unaojumuisha n '(' na m ')',\nambapo mlolongo mrefu zaidi ulio sawa ni wa urefu 2 * k. Matokeo yanapaswa kuhesabiwa\nmodulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "tr": "Bir Go fonksiyonu `func countBalancedSubsequences(n, m, k int64) int64` yazın ve aşağıdaki problemi çözün:\nVerilen üç tamsayı n, m ve k ile, n adet '(' ve m adet ')' içeren dizilerin sayısını bulun,\nöyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) ile\nmod alınarak hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "vi": "Viết một hàm Go `func countBalancedSubsequences(n, m, k int64) int64` để giải quyết vấn đề sau:\nCho ba số nguyên n, m và k, tìm số lượng dãy gồm n '(' và m ')',\nsao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính\ntheo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9858197770979193",
      "arb": "0.9928520871080785",
      "sw": "0.9814262716998087",
      "tr": "0.9528526954967969",
      "vi": "0.9902808168255819"
    },
    "level": "hard",
    "test": "func TestCountBalancedSubsequences(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(2), countBalancedSubsequences(2, 2, 2))\n\tassert.Equal(int64(0), countBalancedSubsequences(3, 2, 3))\n\tassert.Equal(int64(4), countBalancedSubsequences(3, 2, 1))\n\tassert.Equal(int64(14), countBalancedSubsequences(4, 3, 2))\n\tassert.Equal(int64(35), countBalancedSubsequences(5, 5, 2))\n\tassert.Equal(int64(6), countBalancedSubsequences(6, 1, 1))\n\tassert.Equal(int64(6), countBalancedSubsequences(1, 6, 1))\n\tassert.Equal(int64(27), countBalancedSubsequences(7, 2, 2))\n\tassert.Equal(int64(110), countBalancedSubsequences(8, 3, 3))\n\tassert.Equal(int64(10659), countBalancedSubsequences(10, 10, 5))\n\tassert.Equal(int64(574221648), countBalancedSubsequences(20, 20, 10))\n\tassert.Equal(int64(854104531), countBalancedSubsequences(2000, 2000, 1000))\n\tassert.Equal(int64(334874485), countBalancedSubsequences(2000, 1999, 1000))\n\tassert.Equal(int64(259428024), countBalancedSubsequences(2000, 2000, 1999))\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "func countBalancedSubsequences(n, m, k int64) int64",
    "docstring": {
      "es": "Dado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')', \ntal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado \nmódulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "arb": "معطى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التسلسلات المكونة من n '(' و m ')',\nبحيث يكون أطول تسلسل متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق الموديلو 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "sw": "Kwa kuzingatia nambari tatu za mzima n, m, na k, tafuta idadi ya misururu inayojumuisha n '(' na m ')',\nkiasi kwamba mlolongo mrefu zaidi ulio sawa ni wa urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa\nmodulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "tr": "Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun,\nöyle ki en uzun dengeli alt dizi uzunluğu 2 * k olur. Sonuç, 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "vi": "Cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả cần được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9874193475563933",
      "arb": "0.9866081410802469",
      "sw": "1",
      "tr": "0.9685623723328461",
      "vi": "0.9798666259479227"
    }
  },
  {
    "task_id": "Go/42",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود الزاوية السفلية اليسرى\nعند (0,0) والزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط بشكل عشوائي يكون موازياً للمحاور، ويمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلمس الحافة) الورقة. ثم يتم التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\nيجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkit given karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege\nikiwa na kona yake ya chini-kushoto kwenye (0,0) na kona ya juu-kulia kwenye (n,m), unahitaji kuhesabu idadi ya\ntarajio ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari\nunachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kupitia pointi zenye kuratibu za nambari kamili,\nna unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha\nhutupwa. Jibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn x m boyutunda bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir Kartezyen koordinat sistemine yerleştirilmiştir. \nKağıdı, kalan alanın k'dan küçük olacak şekilde kesmek için beklenen işlem sayısını hesaplamanız gerekiyor. Her işlemde, eksenlere paralel, \ntam sayı koordinatlarına sahip noktalar üzerinden geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. \nBu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 ile mod alınmış olmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái\ntại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng thao tác dự kiến để\ncắt giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên\nsong song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh)\ntờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ.\nKết quả phải được tính theo modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {"
    },
    "prompt_bertscore": {
      "es": "0.9824363071873711",
      "arb": "0.9682270842496593",
      "sw": "0.9658860265787821",
      "tr": "0.9710363137286357",
      "vi": "0.958398654365672"
    },
    "canonical_solution": "const MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}",
    "instruction": {
      "es": "Escribe una función en Go `func expectedCuts(n int, m int, k int64) int64` para resolver el siguiente problema:\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea es entonces descartada.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "arb": "اكتب دالة Go `func expectedCuts(n int, m int, k int64) int64` لحل المشكلة التالية:\nبالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوٍ مع وجود زاويتها السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائيًا يكون موازيًا للمحاور، ويمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\nيجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "sw": "Andika kazi ya Go `func expectedCuts(n int, m int, k int64) int64` kutatua tatizo lifuatalo:\nUkipatiwa karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za nambari kamili, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa.\nJibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "tr": "Bir Go fonksiyonu `func expectedCuts(n int, m int, k int64) int64` yazarak aşağıdaki problemi çözün:\nDüzlem Kartezyen koordinat sistemine yerleştirilmiş, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan n x m boyutlarında bir dikdörtgen kağıt verildiğinde, kalan alanın k'dan küçük olması için kağıdı kesme işlemlerinin beklenen sayısını hesaplamanız gerekir. Her işlemde, eksenlere paralel, tamsayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı daha sonra atılır.\nCevap 10^9+7 ile mod alınmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "vi": "Viết một hàm Go `func expectedCuts(n int, m int, k int64) int64` để giải quyết vấn đề sau:\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính toán số lượng thao tác kỳ vọng để cắt giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần giấy phía dưới hoặc bên phải của đường này sau đó bị loại bỏ.\nCâu trả lời phải được lấy modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9779756647204706",
      "arb": "0.9691803114482457",
      "sw": "0.9759480457908665",
      "tr": "0.9538502172703541",
      "vi": "0.9538118816068143"
    },
    "level": "hard",
    "test": "func TestExpectedCuts(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(int64(0), expectedCuts(2, 4, 10))\n\tassert.Equal(int64(1), expectedCuts(2, 4, 8))\n\tassert.Equal(int64(833333342), expectedCuts(2, 4, 2))\n\tassert.Equal(int64(250000003), expectedCuts(2, 4, 6))\n\tassert.Equal(int64(666666673), expectedCuts(3, 3, 4))\n\tassert.Equal(int64(666666673), expectedCuts(5, 5, 12))\n\tassert.Equal(int64(722222229), expectedCuts(6, 7, 20))\n\tassert.Equal(int64(72727275), expectedCuts(8, 8, 30))\n\tassert.Equal(int64(714285721), expectedCuts(10, 10, 50))\n\tassert.Equal(int64(945634929), expectedCuts(1, 10, 5))\n\tassert.Equal(int64(945634929), expectedCuts(10, 1, 5))\n}",
    "entry_point": "expectedCuts",
    "signature": "func expectedCuts(n int, m int, k int64) int64",
    "docstring": {
      "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "arb": "معطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازي للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلمس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة بتقليص 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "sw": "Ukipewa karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa bahati nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za nambari kamili, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa.\n\nJibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "tr": "Verilen bir dikdörtgen kağıt, (0,0) noktasında alt-sol köşesi ve (n,m) noktasında üst-sağ köşesi olacak şekilde bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. Kağıdın kalan alanının k'dan küçük olması için gereken beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 modunda olmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Descartes với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt mong đợi để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Kết quả phải được lấy theo modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9757535866478333",
      "arb": "0.9452254874954382",
      "sw": "0.9595272721907122",
      "tr": "0.9395736586334715",
      "vi": "0.9321577933575339"
    }
  },
  {
    "task_id": "Go/43",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento. Esto implica elegir k-1 puntos de ruptura con 1 ≤ x1 < x2 < ... < x(k-1) < n, y dividir p en segmentos [1, x1], (x1, x2], ..., (x(k-1), n]. El resultado debe ser módulo 998244353.\nEjemplo:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى ترتيب q من n عنصرًا وعدد صحيح k، ابحث عن عدد التباديل p من n عنصرًا بحيث f(p) = q، حيث f(p) هو الترتيب الأصغر لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع. يتضمن ذلك اختيار k-1 نقاط تقسيم مع 1 ≤ x1 < x2 < ... < x(k-1) < n، وتقسيم p إلى مقاطع [1, x1]، (x1, x2]، ...، (x(k-1), n]. يجب أن تكون النتيجة موديولو 998244353.\nمثال:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa permutation q ya vipengele n na integer k, pata idadi ya permutations p ya vipengele n kama f(p) = q, ambapo f(p) ni permutation ndogo zaidi kwa mpangilio wa alfabeti ambayo inaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu. Hii inahusisha kuchagua sehemu k-1 na 1 ≤ x1 < x2 < ... < x(k-1) < n, na kugawanya p katika sehemu [1, x1], (x1, x2], ..., (x(k-1), n]. Matokeo yanapaswa kuwa modulo 998244353.\nMfano:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, n elemanlı p permütasyonlarının sayısını bulun, öyle ki f(p) = q, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur. Bu, 1 ≤ x1 < x2 < ... < x(k-1) < n ile k-1 kırılma noktası seçmeyi ve p'yi [1, x1], (x1, x2], ..., (x(k-1), n] segmentlerine bölmeyi içerir. Sonuç 998244353 ile mod alınmalıdır.\nÖrnek:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành đúng k đoạn liên tiếp không rỗng và sắp xếp từng đoạn. Điều này bao gồm việc chọn k-1 điểm ngắt với 1 ≤ x1 < x2 < ... < x(k-1) < n, và chia p thành các đoạn [1, x1], (x1, x2], ..., (x(k-1), n]. Kết quả nên được lấy modulo 998244353.\nVí dụ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9945613015368837",
      "arb": "0.9869120455632302",
      "sw": "0.9713471702749553",
      "tr": "0.9914471744230188",
      "vi": "0.9795734475055152"
    },
    "canonical_solution": "const N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "Escribe una función en Go `func CountPermutations(n int, k int, qq []int) int` para resolver el siguiente problema:\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento. Esto implica elegir k-1 puntos de ruptura con 1 ≤ x1 < x2 < ... < x(k-1) < n, y dividir p en segmentos [1, x1], (x1, x2], ..., (x(k-1), n]. El resultado debe ser módulo 998244353.\nEjemplo:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "arb": "اكتب دالة Go `func CountPermutations(n int, k int, qq []int) int` لحل المشكلة التالية:\nبالنظر إلى ترتيب q من n عنصر وعدد صحيح k، ابحث عن عدد الترتيبات p من n عنصر بحيث يكون f(p) = q، حيث أن f(p) هو الترتيب الأصغر لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع. يتضمن ذلك اختيار k-1 نقاط تقاطع مع 1 ≤ x1 < x2 < ... < x(k-1) < n، وتقسيم p إلى مقاطع [1, x1]، (x1, x2]، ...، (x(k-1), n]. يجب أن تكون النتيجة موديولو 998244353.\nمثال:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "sw": "Andika kazi ya Go `func CountPermutations(n int, k int, qq []int) int` kutatua tatizo lifuatalo:  \nUkipiwa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu zinazoendelea na kupanga kila sehemu. Hii inahusisha kuchagua sehemu k-1 na 1 ≤ x1 < x2 < ... < x(k-1) < n, na kugawanya p katika sehemu [1, x1], (x1, x2], ..., (x(k-1), n]. Matokeo yanapaswa kuwa moduli 998244353.  \nMfano:  \n\t>>> CountPermutations(2, 1, []int{1, 2})  \n\t2  ",
      "tr": "Bir Go fonksiyonu `func CountPermutations(n int, k int, qq []int) int` yazın ve aşağıdaki problemi çözün:\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölüp her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur. Bu, 1 ≤ x1 < x2 < ... < x(k-1) < n olacak şekilde k-1 kırılma noktası seçmeyi ve p'yi [1, x1], (x1, x2], ..., (x(k-1), n] segmentlerine bölmeyi içerir. Sonuç 998244353 ile mod alınmalıdır.\nÖrnek:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "vi": "Viết một hàm Go `func CountPermutations(n int, k int, qq []int) int` để giải quyết vấn đề sau:\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành đúng k đoạn liên tiếp không rỗng và sắp xếp từng đoạn. Điều này bao gồm việc chọn k-1 điểm ngắt với 1 ≤ x1 < x2 < ... < x(k-1) < n, và chia p thành các đoạn [1, x1], (x1, x2], ..., (x(k-1), n]. Kết quả nên được lấy modulo 998244353.\nVí dụ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2"
    },
    "instruction_bertscore": {
      "es": "0.9934265261700315",
      "arb": "0.9925291141085157",
      "sw": "0.9735082688206149",
      "tr": "0.9576661055204153",
      "vi": "0.9908697559053503"
    },
    "level": "hard",
    "test": "func TestCountPermutations(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, CountPermutations(2, 1, []int{1, 2}))\n\tassert.Equal(1, CountPermutations(3, 3, []int{3, 1, 2}))\n\tassert.Equal(13, CountPermutations(6, 3, []int{1, 2, 3, 6, 5, 4}))\n\tassert.Equal(720, CountPermutations(6, 1, []int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(0, CountPermutations(6, 3, []int{1, 2, 5, 3, 4, 5}))\n\tassert.Equal(1, CountPermutations(9, 9, []int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\n\tassert.Equal(29093, CountPermutations(9, 2, []int{1, 2, 3, 4, 5, 6, 7, 9, 8}))\n}",
    "entry_point": "CountPermutations",
    "signature": "func CountPermutations(n int, k int, qq []int) int",
    "docstring": {
      "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento. Esto implica elegir k-1 puntos de ruptura con 1 ≤ x1 < x2 < ... < x(k-1) < n, y dividir p en segmentos [1, x1], (x1, x2], ..., (x(k-1), n]. El resultado debe ser módulo 998244353.\nEjemplo:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "arb": "معطى ترتيب q من n عنصر وعدد صحيح k، ابحث عن عدد الترتيبات p من n عنصر بحيث f(p) = q، حيث f(p) هو الترتيب المعجمي الأصغر الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع. يتضمن ذلك اختيار k-1 نقاط تقاطع مع 1 ≤ x1 < x2 < ... < x(k-1) < n، وتقسيم p إلى مقاطع [1, x1]، (x1, x2]، ...، (x(k-1), n]. يجب أن تكون النتيجة موديولو 998244353.\nمثال:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "sw": "Kwa kuzingatia mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu zinazofuatana na kupanga kila sehemu. Hii inahusisha kuchagua sehemu k-1 na 1 ≤ x1 < x2 < ... < x(k-1) < n, na kugawanya p katika sehemu [1, x1], (x1, x2], ..., (x(k-1), n]. Matokeo yanapaswa kuwa modulo 998244353.\nMfano:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, f(p) = q olacak şekilde n elemanlı p permütasyonlarının sayısını bulun. Burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur. Bu, 1 ≤ x1 < x2 < ... < x(k-1) < n olacak şekilde k-1 kırılma noktası seçmeyi ve p'yi [1, x1], (x1, x2], ..., (x(k-1), n] segmentlerine bölmeyi içerir. Sonuç 998244353 ile mod alınmalıdır.\nÖrnek:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "vi": "Đưa ra một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn. Điều này bao gồm việc chọn k-1 điểm ngắt với 1 ≤ x1 < x2 < ... < x(k-1) < n, và chia p thành các đoạn [1, x1], (x1, x2], ..., (x(k-1), n]. Kết quả nên được lấy modulo 998244353.\nVí dụ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2"
    },
    "docstring_bertscore": {
      "es": "0.9966165300894517",
      "arb": "0.9936440264372646",
      "sw": "0.9328919312458389",
      "tr": "0.9672647200535452",
      "vi": "0.9916813596422589"
    }
  },
  {
    "task_id": "Go/44",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado un array de n enteros distintos que representan las alturas de los amigos de Kira,\nencuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (MCD)\nde los valores máximo y mínimo del triplete sea 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى مصفوفة تحتوي على n عدد صحيح مميز تمثل أطوال أصدقاء كيرا،\nابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD)\nللقيمتين العظمى والصغرى في الثلاثية هو 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa safu ya n ya nambari tofauti inayowakilisha urefu wa marafiki wa Kira,\ntafuta idadi ya njia za kuchagua tatu (a, b, c) ili kisahihishi kikuu cha mgawanyiko (GCD)\ncha thamani za juu na za chini za tatu hiyo ni 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tam sayıdan oluşan bir dizi verildiğinde,\nbir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun, öyle ki üçlünün maksimum ve minimum değerlerinin\nen büyük ortak böleni (GCD) 1 olsun.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira,\ntìm số cách để chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD)\ncủa giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9903439812867509",
      "sw": "0.9718433489667805",
      "tr": "0.9969283797876765",
      "vi": "1"
    },
    "canonical_solution": "count := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}",
    "instruction": {
      "es": "Escribe una función en Go `func countTriplets(heights []int, n int) int` para resolver el siguiente problema:\nDado un arreglo de n enteros distintos que representan las alturas de los amigos de Kira,\nencuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD)\nde los valores máximo y mínimo del triplete sea 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n",
      "arb": "اكتب دالة Go `func countTriplets(heights []int, n int) int` لحل المشكلة التالية:\nبالنظر إلى مصفوفة من n عدد صحيح مميز تمثل أطوال أصدقاء كيرا،\nابحث عن عدد الطرق لاختيار ثلاثي (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD)\nللقيمتين العظمى والصغرى للثلاثي هو 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "sw": "Andika kazi ya Go `func countTriplets(heights []int, n int) int` kutatua tatizo lifuatalo:  \nUkipiwa safu ya n ya nambari tofauti zinazoashiria urefu wa marafiki wa Kira,  \ntafuta idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkuu zaidi (GCD)  \nwa thamani ya juu na ya chini ya tatu hiyo ni 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "tr": "Bir Go fonksiyonu `func countTriplets(heights []int, n int) int` yazın. Aşağıdaki problemi çözmek için:\nKira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tam sayıdan oluşan bir dizi verildiğinde,\nmaksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n",
      "vi": "Viết một hàm Go `func countTriplets(heights []int, n int) int` để giải quyết vấn đề sau:\nCho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira,\ntìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD)\ncủa giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1"
    },
    "instruction_bertscore": {
      "es": "0.9941638421444329",
      "arb": "1",
      "sw": "0.9648938678255128",
      "tr": "0.9806623392543484",
      "vi": "1"
    },
    "level": "hard",
    "test": "func TestCountTriplets(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, countTriplets([]int{1, 5, 7}, 3))\n\tassert.Equal(3, countTriplets([]int{1, 6, 2, 3}, 4))\n\tassert.Equal(0, countTriplets([]int{16, 4, 8, 2}, 4))\n\tassert.Equal(77, countTriplets([]int{10, 1, 6, 7, 9, 8, 4, 3, 5, 2}, 10))\n\tassert.Equal(7, countTriplets([]int{4, 5, 9, 11, 14}, 5))\n\tassert.Equal(104, countTriplets([]int{15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}, 11))\n\tassert.Equal(4, countTriplets([]int{3, 7, 11, 13}, 4))\n\tassert.Equal(10, countTriplets([]int{5, 12, 13, 17, 19}, 5))\n\tassert.Equal(87, countTriplets([]int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, 11))\n\tassert.Equal(122, countTriplets([]int{1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}, 11))\n}",
    "entry_point": "countTriplets",
    "signature": "func countTriplets(heights []int, n int) int",
    "docstring": {
      "es": "Dado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (MCD) de los valores máximo y mínimo del triplete sea 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "arb": "نظرًا لمصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل أطوال أصدقاء كيرا، \nابحث عن عدد الطرق لاختيار ثلاثي (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD) \nللقيمتين العظمى والصغرى للثلاثي هو 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "sw": "Ukipiwa safu ya nambari tofauti za n zinazoashiria urefu wa marafiki wa Kira, pata idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkubwa wa kawaida (GCD) wa thamani za juu na za chini za tatu hiyo ni 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "tr": "Kira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tamsayıdan oluşan bir dizi verildiğinde, maksimum ve minimum değerlerinin en büyük ortak böleni (EBOB) 1 olan bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "vi": "Cho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn Kira, tìm số cách để chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.993600327753437",
      "sw": "0.9542820397187239",
      "tr": "0.9611643837912017",
      "vi": "0.9746793935471966"
    }
  },
  {
    "task_id": "Go/45",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSe te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero.\nPuedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo\ncolor al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color.\nEncuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nلديك صورة بكسل 1 في n، حيث يتم تمثيل كل بكسل بلون يمثل برقم صحيح.\nيمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس\nاللون إلى اللون المختار. يعتبر البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون.\nاعثر على الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUmepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari.\nUnaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa\nza rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa.\nPata idadi ndogo ya operesheni zinazohitajika ili kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n1'e n pikselden oluşan bir görüntü verilir, burada her piksel bir tamsayı ile temsil edilen bir renge sahiptir.\nBir renk seçip aynı renge sahip tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem yapabilirsiniz.\nİki piksel, bitişik ve aynı renge sahiplerse bağlıdır.\nTüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên.\nBạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng\nmàu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu.\nTìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9987821971338751",
      "arb": "0.9741156805258195",
      "sw": "0.9738957966940139",
      "tr": "0.9697360792543813",
      "vi": "0.9899816794717433"
    },
    "canonical_solution": "n := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}",
    "instruction": {
      "es": "Escribe una función de Go `func minOperations(pixels []int) int` para resolver el siguiente problema:\nSe te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un número entero.\nPuedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo\ncolor al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color.\nEncuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "arb": "اكتب دالة Go `func minOperations(pixels []int) int` لحل المشكلة التالية:\nأنت مُعطى صورة مكونة من 1 في n بكسل، حيث أن كل بكسل له لون ممثل برقم صحيح.\nيمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون.\nاعثر على الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "sw": "Andika kazi ya Go `func minOperations(pixels []int) int` kutatua tatizo lifuatalo:\nUmepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari nzima.\nUnaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa\nkuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa.\nPata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "tr": "Bir Go fonksiyonu `func minOperations(pixels []int) int` yazarak aşağıdaki problemi çözün:\nSize her pikseli bir tamsayı ile temsil edilen bir 1'e n piksel görüntüsü verilmektedir.\nBir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz.\nİki piksel, bitişik ve aynı renkte olduklarında bağlı kabul edilir.\nTüm pikselleri aynı renkte yapmak için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel bulunmaktadır.\n\nÖrnekler:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "vi": "Viết một hàm Go `func minOperations(pixels []int) int` để giải quyết vấn đề sau:\nBạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên.\nBạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu\nthành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu.\nTìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có nhiều nhất 20 pixel của màu đó.\n\nVí dụ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2"
    },
    "instruction_bertscore": {
      "es": "0.9986687791863041",
      "arb": "0.9835726715972717",
      "sw": "0.9715388485926539",
      "tr": "0.9652414709923239",
      "vi": "0.9926131347596936"
    },
    "level": "hard",
    "test": "func TestMinOperations(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, minOperations([]int{1, 2, 3, 2, 1}))\n\tassert.Equal(1, minOperations([]int{1, 1, 2, 2}))\n\tassert.Equal(3, minOperations([]int{1, 2, 1, 4, 2}))\n\tassert.Equal(0, minOperations([]int{5, 5, 5, 5, 5}))\n\tassert.Equal(1, minOperations([]int{1, 1, 1, 2, 2, 2}))\n\tassert.Equal(2, minOperations([]int{1, 3, 3, 3, 2, 2, 2}))\n\tassert.Equal(1, minOperations([]int{4, 4, 4, 4, 3, 3, 3, 3}))\n\tassert.Equal(8, minOperations([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\n\tassert.Equal(5, minOperations([]int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2}))\n\tassert.Equal(0, minOperations([]int{3, 3, 3}))\n\tassert.Equal(1, minOperations([]int{2, 1, 1, 2}))\n}",
    "entry_point": "minOperations",
    "signature": "func minOperations(pixels []int) int",
    "docstring": {
      "es": "Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "arb": "أنت مُعطى صورة مكونة من 1 في n بكسل، حيث أن كل بكسل له لون يُمثل بعدد صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يُعتبر البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "sw": "Unapewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari kamili. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Pata idadi ndogo ya operesheni zinazohitajika ili kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "tr": "1'e n piksel boyutunda bir görüntü verilir ve her piksel bir tamsayı ile temsil edilen bir renge sahiptir. \nBir renk seçip aynı renkteki tüm bağlantılı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. \nİki piksel, bitişik ve aynı renkte ise bağlantılıdır. \nTüm pikselleri aynı renkte yapmak için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "vi": "Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2"
    },
    "docstring_bertscore": {
      "es": "0.9983875185667588",
      "arb": "0.9727042130381857",
      "sw": "0.9720731643176378",
      "tr": "0.952694387083112",
      "vi": "0.9874322585311606"
    }
  },
  {
    "task_id": "Go/46",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n\nque son múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5,\ndebe contarse solo una vez.\n\nPor ejemplo:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n\nالتي هي مضاعفات إما لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5،\nيجب أن يتم احتسابه مرة واحدة فقط.\n\nعلى سبيل المثال:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n\nambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5,\ninapaswa kuhesabiwa mara moja tu.\n\nKwa mfano:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen bir tamsayı n için, 1'den n'e kadar olan sayılardan 3 veya 5'in katı olanların\ntoplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa,\nyalnızca bir kez sayılmalıdır.\n\nÖrneğin:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n\nmà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5,\nnó chỉ nên được tính một lần.\n\nVí dụ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9939993761889361",
      "arb": "0.9978188397858558",
      "sw": "0.9939993761889361",
      "tr": "0.961717768032765",
      "vi": "0.9907853379934105"
    },
    "canonical_solution": "sum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}",
    "instruction": {
      "es": "Escribe una función en Go `func sumOfMultiples(n int) int` para resolver el siguiente problema:\nDado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n\nque sean múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5,\ndebe contarse solo una vez.\n\nPor ejemplo:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "arb": "اكتب دالة بلغة Go `func sumOfMultiples(n int) int` لحل المشكلة التالية:\nبالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأعداد من 1 إلى n\nالتي هي مضاعفات إما لـ 3 أو 5. إذا كان العدد مضاعفًا لكل من 3 و 5،\nيجب أن يُحسب مرة واحدة فقط.\n\nعلى سبيل المثال:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "sw": "Andika kazi ya Go `func sumOfMultiples(n int) int` kutatua tatizo lifuatalo:\nUkipiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n\nambazo ni marudio ya ama 3 au 5. Ikiwa nambari ni marudio ya zote 3 na 5,\ninapaswa kuhesabiwa mara moja tu.\n\nKwa mfano:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "tr": "Bir Go fonksiyonu `func sumOfMultiples(n int) int` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı n için, 1'den n'ye kadar olan tüm sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\n\nÖrneğin:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "vi": "Viết một hàm Go `func sumOfMultiples(n int) int` để giải quyết vấn đề sau:\nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n\nmà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5,\nnó chỉ nên được tính một lần.\n\nVí dụ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)"
    },
    "instruction_bertscore": {
      "es": "0.9870898197542564",
      "arb": "0.990081987814166",
      "sw": "0.9948461375032878",
      "tr": "0.9645333536839346",
      "vi": "0.9872475322767981"
    },
    "level": "easy",
    "test": "func TestSumOfMultiples(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(33, sumOfMultiples(10))\n\tassert.Equal(60, sumOfMultiples(15))\n\tassert.Equal(98, sumOfMultiples(20))\n\tassert.Equal(8, sumOfMultiples(5))\n\tassert.Equal(3, sumOfMultiples(3))\n\tassert.Equal(14, sumOfMultiples(6))\n\tassert.Equal(23, sumOfMultiples(9))\n\tassert.Equal(45, sumOfMultiples(12))\n\tassert.Equal(60, sumOfMultiples(17))\n\tassert.Equal(119, sumOfMultiples(21))\n\tassert.Equal(168, sumOfMultiples(25))\n}",
    "entry_point": "sumOfMultiples",
    "signature": "func sumOfMultiples(n int) int",
    "docstring": {
      "es": "Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, debe contarse solo una vez.\n\nPor ejemplo:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "arb": "بالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع كل الأرقام من 1 إلى n\nالتي هي مضاعفات إما لـ 3 أو 5. إذا كان الرقم مضاعفًا لكلا 3 و5،\nفيجب احتسابه مرة واحدة فقط.\n\nعلى سبيل المثال:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "sw": "Kwa kupewa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni nyingi za 3 au 5. Ikiwa nambari ni nyingi ya 3 na 5, inapaswa kuhesabiwa mara moja tu.\n\nKwa mfano:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "tr": "Verilen bir tamsayı n için, 1'den n'e kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\n\nÖrneğin:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "vi": "Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.\n\nVí dụ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)"
    },
    "docstring_bertscore": {
      "es": "0.9900521932570108",
      "arb": "0.9944242465739697",
      "sw": "0.9900521932570108",
      "tr": "0.9820630807014065",
      "vi": "0.9860144348713336"
    }
  },
  {
    "task_id": "Go/47",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDeterminar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee\nigual de adelante hacia atrás (ignorando espacios, puntuación y capitalización).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "arb": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nتحديد ما إذا كانت سلسلة معينة هي جملة قابلة للانعكاس. الجملة القابلة للانعكاس هي كلمة، عبارة، رقم، أو تسلسل آخر من الأحرف التي تقرأ\nنفس الشيء من الأمام والخلف (مع تجاهل المسافات، وعلامات الترقيم، والحروف الكبيرة).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "sw": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTambua kama string iliyotolewa ni palindrome. Palindrome ni neno, kifungu, namba, au mlolongo mwingine wa herufi ambao unasomwa\nvilevile mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "tr": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "vi": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nXác định xem một chuỗi cho trước có phải là palindrome hay không. Palindrome là một từ, cụm từ, số, hoặc một chuỗi ký tự khác mà khi đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và viết hoa).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.962184549428197",
      "sw": "0.997807915114899",
      "tr": "0.9869938812802166",
      "vi": "0.9963378516648598"
    },
    "canonical_solution": "str = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}",
    "instruction": {
      "es": "Escribe una función en Go `func IsPalindrome(str string) bool` para resolver el siguiente problema:\nDetermina si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "arb": "اكتب دالة بلغة Go `func IsPalindrome(str string) bool` لحل المشكلة التالية:\nتحديد ما إذا كانت السلسلة المعطاة هي كلمة متطابقة عند قراءتها من الأمام والخلف. الكلمة المتطابقة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف التي تقرأ بنفس الطريقة من الأمام والخلف (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "sw": "Andika kazi ya Go `func IsPalindrome(str string) bool` kutatua tatizo lifuatalo:\nTambua kama kamba iliyotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (ukipuuza nafasi, alama za uakifishaji, na herufi kubwa).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "tr": "Bir Go fonksiyonu `func IsPalindrome(str string) bool` yazın:\nVerilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan kelime, ifade, sayı veya diğer karakter dizisidir (boşluklar, noktalama işaretleri ve büyük/küçük harfler göz ardı edilir).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "vi": "Viết một hàm Go `func IsPalindrome(str string) bool` để giải quyết vấn đề sau:\nXác định xem một chuỗi đã cho có phải là một palindrome hay không. Một palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue"
    },
    "instruction_bertscore": {
      "es": "0.9911665096946165",
      "arb": "0.9625524128938736",
      "sw": "0.9954761930719305",
      "tr": "0.9726499869441632",
      "vi": "0.988231547184445"
    },
    "level": "hard",
    "test": "func TestIsPalindrome(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.True(IsPalindrome(\"A man a plan a canal Panama\"))\n\tassert.True(IsPalindrome(\"No lemon, no melon\"))\n\tassert.True(IsPalindrome(\"Was it a car or a cat I saw\"))\n\tassert.True(IsPalindrome(\"Madam, in Eden, I'm Adam\"))\n\tassert.True(IsPalindrome(\"Never odd or even\"))\n\tassert.True(IsPalindrome(\"Eva, can I see bees in a cave\"))\n\tassert.False(IsPalindrome(\"hello\"))\n\tassert.False(IsPalindrome(\"GitHub\"))\n\tassert.False(IsPalindrome(\"programming\"))\n}",
    "entry_point": "IsPalindrome",
    "signature": "func IsPalindrome(str string) bool",
    "docstring": {
      "es": "Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual hacia adelante y hacia atrás (ignorando espacios, puntuación y mayúsculas).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "arb": "تحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة. الكلمة المتطابقة هي كلمة أو عبارة أو رقم أو أي تسلسل آخر من الأحرف التي تُقرأ بنفس الطريقة للأمام والخلف (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة والصغيرة).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "sw": "Amua kama string iliyotolewa ni palindrome. Palindrome ni neno, kifungu, namba, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "tr": "Verilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "vi": "Xác định xem một chuỗi cho trước có phải là một chuỗi palindrome hay không. Một chuỗi palindrome là một từ, cụm từ, số, hoặc một dãy ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9836674182890253",
      "sw": "0.9940649242146775",
      "tr": "0.9836280894735804",
      "vi": "0.9980683195444358"
    }
  },
  {
    "task_id": "Go/48",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    addDigits(38) // devuelve 2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.\n*/\nfunc addDigits(num int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى عدد صحيح غير سالب num، اجمع جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    addDigits(38) // يعيد 2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو النتيجة.\n*/\nfunc addDigits(num int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKwa kupewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.\nKwa mfano:\n    addDigits(38) // inarudisha 2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.\n*/\nfunc addDigits(num int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen negatif olmayan bir tamsayı num için, sonucu tek bir basamak olana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    addDigits(38) // 2 döndürür\n    Çünkü 3 + 8 = 11, ve 1 + 1 = 2. 2 yalnızca bir basamak olduğundan, sonuç 2'dir.\n*/\nfunc addDigits(num int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.\nVí dụ:\n    addDigits(38) // trả về 2\n    Vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.\n*/\nfunc addDigits(num int) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.985117221440199",
      "sw": "0.9933234370022743",
      "tr": "0.9730396997517536",
      "vi": "0.9848866115678174"
    },
    "canonical_solution": "for num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}",
    "instruction": {
      "es": "Escribe una función en Go `func addDigits(num int) int` para resolver el siguiente problema:\nDado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    addDigits(38) // devuelve 2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.",
      "arb": "اكتب دالة Go `func addDigits(num int) int` لحل المشكلة التالية:\nمعطى عدد صحيح غير سالب num، قم بجمع جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    addDigits(38) // يعيد 2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.",
      "sw": "Andika kazi ya Go `func addDigits(num int) int` kutatua tatizo lifuatalo:\nKwa kuzingatia nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja pekee.\nKwa mfano:\n    addDigits(38) // inarudisha 2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja pekee, 2 ndiyo matokeo.",
      "tr": "Bir Go fonksiyonu `func addDigits(num int) int` yazın ve aşağıdaki problemi çözün:\nVerilen bir negatif olmayan tamsayı num için, sonucu tek bir basamak olana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    addDigits(38) // 2 döndürür\n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 tek bir basamak olduğundan, sonuç 2'dir.",
      "vi": "Viết một hàm Go `func addDigits(num int) int` để giải quyết vấn đề sau:\nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.\nVí dụ:\n    addDigits(38) // trả về 2\n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả."
    },
    "instruction_bertscore": {
      "es": "0.9939330336416704",
      "arb": "0.9847014880526929",
      "sw": "0.9919238873375025",
      "tr": "0.9550517324452341",
      "vi": "0.9697611066823917"
    },
    "level": "easy",
    "test": "func TestAddDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, addDigits(38))\n\tassert.Equal(0, addDigits(0))\n\tassert.Equal(9, addDigits(9))\n\tassert.Equal(6, addDigits(123))\n\tassert.Equal(6, addDigits(456))\n\tassert.Equal(9, addDigits(9999))\n\tassert.Equal(1, addDigits(100))\n\tassert.Equal(2, addDigits(1010))\n\tassert.Equal(1, addDigits(1234))\n\tassert.Equal(3, addDigits(9876))\n\tassert.Equal(1, addDigits(199))\n}",
    "entry_point": "addDigits",
    "signature": "func addDigits(num int) int",
    "docstring": {
      "es": "Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    addDigits(38) // devuelve 2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.",
      "arb": "بالنظر إلى عدد صحيح غير سالب num، قم بإضافة جميع أرقامه بشكل متكرر حتى يكون الناتج عبارة عن رقم واحد فقط.\nعلى سبيل المثال:\n    addDigits(38) // يعيد 2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.",
      "sw": "Kwa kupewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.\nKwa mfano:\n    addDigits(38) // inarudisha 2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.",
      "tr": "Verilen bir negatif olmayan tam sayı num için, sonucu yalnızca bir basamak olana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    addDigits(38) // 2 döndürür\n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamak olduğundan, sonuç 2'dir.",
      "vi": "Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n    addDigits(38) // trả về 2  \n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả."
    },
    "docstring_bertscore": {
      "es": "0.9901229056726591",
      "arb": "0.9735799743881685",
      "sw": "0.9910379958380868",
      "tr": "0.940698303850891",
      "vi": "0.9587142780411364"
    }
  },
  {
    "task_id": "Go/49",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras,\ny tú y tu oponente se turnan para remover de 1 a 3 piedras de la pila.\nEl que remueve la última piedra gana el juego.\nDado el número de piedras n, determina si puedes ganar el juego si tanto tú\ncomo tu oponente juegan de manera óptima. Nota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من الحجارة عددها n،\nوأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة.\nالشخص الذي يزيل الحجر الأخير يفوز باللعبة.\nبالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت\nوخصمك تلعبان بشكل مثالي. ملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUnacheza mchezo uitwao Nim. Katika mchezo huu, unaanza na rundo la mawe n,\nna wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo.\nYule anayeondoa jiwe la mwisho anashinda mchezo.\nUkipata idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe\nna mpinzani wako mna cheza kwa ustadi. Kumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNim adında bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlıyorsunuz\nve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarıyorsunuz.\nSon taşı çıkaran oyunu kazanır.\nTaş sayısı n verildiğinde, hem siz hem de rakibiniz optimal oynarsa oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống đá n,\nvà bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống.\nNgười lấy viên đá cuối cùng sẽ thắng trò chơi.\nCho số lượng đá n, xác định liệu bạn có thể thắng trò chơi nếu cả bạn\nvà đối thủ đều chơi tối ưu. Lưu ý: Bạn luôn là người đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9825676018692351",
      "sw": "0.991135721985556",
      "tr": "0.9839260350451328",
      "vi": "0.9813178195117636"
    },
    "canonical_solution": "return n%4 != 0\n}",
    "instruction": {
      "es": "Escribe una función de Go `func canWinNim(n int) bool` para resolver el siguiente problema:\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras,\ny tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila.\nEl que quite la última piedra gana el juego.\nDado el número de piedras n, determina si puedes ganar el juego si tanto tú\ncomo tu oponente juegan de manera óptima. Nota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true\n",
      "arb": "اكتب دالة Go `func canWinNim(n int) bool` لحل المشكلة التالية:\nأنت تلعب لعبة تسمى Nim. في هذه اللعبة، تبدأ بكومة من n من الحجارة،\nوأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة.\nالشخص الذي يزيل الحجر الأخير يفوز باللعبة.\nبالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت\nوخصمك تلعبان بشكل مثالي. ملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true",
      "sw": "Andika kazi ya Go `func canWinNim(n int) bool` kutatua tatizo lifuatalo:\nUnacheza mchezo uitwao Nim. Katika mchezo huu, unaanza na rundo la mawe n,\nna wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo.\nYule anayeondoa jiwe la mwisho anashinda mchezo.\nUkipatiwa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe\nna mpinzani wako mna cheza kwa umahiri. Kumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true",
      "tr": "Bir Go fonksiyonu `func canWinNim(n int) bool` yazın ve aşağıdaki problemi çözün:\nNim adında bir oyun oynuyorsunuz. Bu oyunda, n taşla başlıyorsunuz ve siz ve rakibiniz sırayla yığından 1 ila 3 taş alıyorsunuz. Son taşı alan oyunu kazanır. Taş sayısı n verildiğinde, hem sizin hem de rakibinizin en iyi şekilde oynadığı varsayıldığında oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true",
      "vi": "Viết một hàm Go `func canWinNim(n int) bool` để giải quyết vấn đề sau:\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá,\nvà bạn cùng đối thủ của mình lần lượt loại bỏ từ 1 đến 3 viên đá khỏi đống.\nNgười loại bỏ viên đá cuối cùng sẽ thắng trò chơi.\nCho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn\nvà đối thủ của bạn chơi tối ưu. Lưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true"
    },
    "instruction_bertscore": {
      "es": "0.9971001950672717",
      "arb": "0.9911057287980197",
      "sw": "0.9926814636107696",
      "tr": "0.9642677848644908",
      "vi": "0.9870469155919529"
    },
    "level": "easy",
    "test": "func TestCanWinNim(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, canWinNim(1))\n\tassert.Equal(true, canWinNim(2))\n\tassert.Equal(true, canWinNim(3))\n\tassert.Equal(false, canWinNim(4))\n\tassert.Equal(true, canWinNim(5))\n\tassert.Equal(true, canWinNim(6))\n\tassert.Equal(true, canWinNim(7))\n\tassert.Equal(false, canWinNim(8))\n\tassert.Equal(true, canWinNim(9))\n\tassert.Equal(true, canWinNim(10))\n\tassert.Equal(true, canWinNim(11))\n\tassert.Equal(false, canWinNim(12))\n\tassert.Equal(true, canWinNim(13))\n\tassert.Equal(true, canWinNim(14))\n\tassert.Equal(true, canWinNim(15))\n\tassert.Equal(false, canWinNim(16))\n\tassert.Equal(true, canWinNim(17))\n\tassert.Equal(true, canWinNim(18))\n\tassert.Equal(true, canWinNim(19))\n\tassert.Equal(false, canWinNim(20))\n}",
    "entry_point": "canWinNim",
    "signature": "func canWinNim(n int) bool",
    "docstring": {
      "es": "Estás jugando un juego llamado Nim. En este juego, comienzas con un montón de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras del montón. El que quita la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima. Nota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true",
      "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من الحجارة عددها n، وأنت وخصمك تتناوبان على إزالة من 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت وخصمك تلعبان بشكل مثالي. ملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true",
      "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho ndiye anayeshinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mnaocheza kwa ustadi. Kumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya matukio:\n    >>> canWinNim(1)\n    true",
      "tr": "Nim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem sizin hem de rakibinizin en iyi şekilde oynadığını varsayarak oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true",
      "vi": "Bạn đang chơi một trò chơi có tên là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ của mình lần lượt lấy từ 1 đến 3 viên đá ra khỏi đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn và đối thủ đều chơi tối ưu hay không. Lưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "es": "0.9948346169411877",
      "arb": "0.9782660623375435",
      "sw": "0.9815899431337813",
      "tr": "0.9728494118467221",
      "vi": "0.9769598689518582"
    }
  },
  {
    "task_id": "Go/50",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct calcula la suma de dos enteros si la suma es par,\no el producto de los dos enteros si la suma es impar.\n\nEjemplos:\n\tEvenSumOrOddProduct(2, 3) // devuelve 6\n\tEvenSumOrOddProduct(5, 5) // devuelve 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct يحسب مجموع عددين صحيحين إذا كان المجموع زوجيًا،\nأو حاصل ضرب العددين إذا كان المجموع فرديًا.\n\nأمثلة:\n\tEvenSumOrOddProduct(2, 3) // يعيد 6\n\tEvenSumOrOddProduct(5, 5) // يعيد 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct huhesabu jumla ya namba mbili ikiwa jumla ni shufwa,\nau bidhaa ya namba mbili ikiwa jumla ni witiri.\n\nMifano:\n\tEvenSumOrOddProduct(2, 3) // inarudisha 6\n\tEvenSumOrOddProduct(5, 5) // inarudisha 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct iki tam sayının toplamı çift ise toplamı,\ntoplam tek ise iki tam sayının çarpımını hesaplar.\n\nÖrnekler:\n\tEvenSumOrOddProduct(2, 3) // 6 döndürür\n\tEvenSumOrOddProduct(5, 5) // 10 döndürür\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct tính tổng của hai số nguyên nếu tổng là số chẵn,\nhoặc tích của hai số nguyên nếu tổng là số lẻ.\n\nVí dụ:\n\tEvenSumOrOddProduct(2, 3) // trả về 6\n\tEvenSumOrOddProduct(5, 5) // trả về 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {"
    },
    "prompt_bertscore": {
      "es": "0.994613938587858",
      "arb": "0.9898805766077966",
      "sw": "0.984234905287642",
      "tr": "0.9848359608206535",
      "vi": "0.9873857790219984"
    },
    "canonical_solution": "sum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}",
    "instruction": {
      "es": "Escribe una función en Go `func EvenSumOrOddProduct(a, b int) int` para resolver el siguiente problema:\nEvenSumOrOddProduct calcula la suma de dos enteros si la suma es par,\no el producto de los dos enteros si la suma es impar.\n\nEjemplos:\n\tEvenSumOrOddProduct(2, 3) // devuelve 6\n\tEvenSumOrOddProduct(5, 5) // devuelve 10",
      "arb": "اكتب دالة بلغة Go `func EvenSumOrOddProduct(a, b int) int` لحل المشكلة التالية:\nEvenSumOrOddProduct تحسب مجموع عددين صحيحين إذا كان المجموع زوجيًا،\nأو حاصل ضرب العددين إذا كان المجموع فرديًا.\n\nأمثلة:\n\tEvenSumOrOddProduct(2, 3) // يعيد 6\n\tEvenSumOrOddProduct(5, 5) // يعيد 10",
      "sw": "Andika kazi ya Go `func EvenSumOrOddProduct(a, b int) int` kutatua tatizo lifuatalo:\nEvenSumOrOddProduct huhesabu jumla ya nambari mbili ikiwa jumla ni shufwa,\nau bidhaa ya nambari hizo mbili ikiwa jumla ni witiri.\n\nMifano:\n\tEvenSumOrOddProduct(2, 3) // inarudisha 6\n\tEvenSumOrOddProduct(5, 5) // inarudisha 10",
      "tr": "Bir Go fonksiyonu `func EvenSumOrOddProduct(a, b int) int` yazın:\nEvenSumOrOddProduct, iki tam sayının toplamı çift ise toplamı,\ntoplam tek ise iki tam sayının çarpımını hesaplar.\n\nÖrnekler:\n\tEvenSumOrOddProduct(2, 3) // 6 döndürür\n\tEvenSumOrOddProduct(5, 5) // 10 döndürür",
      "vi": "Viết một hàm Go `func EvenSumOrOddProduct(a, b int) int` để giải quyết vấn đề sau:\nEvenSumOrOddProduct tính tổng của hai số nguyên nếu tổng là số chẵn,\nhoặc tích của hai số nguyên nếu tổng là số lẻ.\n\nVí dụ:\n\tEvenSumOrOddProduct(2, 3) // trả về 6\n\tEvenSumOrOddProduct(5, 5) // trả về 10"
    },
    "instruction_bertscore": {
      "es": "0.9910471328356145",
      "arb": "0.985038166548547",
      "sw": "0.9821476972437273",
      "tr": "0.9573717352957216",
      "vi": "0.9922466617066842"
    },
    "level": "easy",
    "test": "func TestEvenSumOrOddProduct(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, EvenSumOrOddProduct(2, 3))\n\tassert.Equal(10, EvenSumOrOddProduct(5, 5))\n\tassert.Equal(2, EvenSumOrOddProduct(1, 1))\n\tassert.Equal(0, EvenSumOrOddProduct(0, 0))\n\tassert.Equal(-2, EvenSumOrOddProduct(-1, -1))\n\tassert.Equal(300, EvenSumOrOddProduct(100, 200))\n\tassert.Equal(12, EvenSumOrOddProduct(3, 4))\n\tassert.Equal(0, EvenSumOrOddProduct(-5, 5))\n\tassert.Equal(56, EvenSumOrOddProduct(7, 8))\n\tassert.Equal(90, EvenSumOrOddProduct(9, 10))\n\tassert.Equal(154, EvenSumOrOddProduct(11, 14))\n}",
    "entry_point": "EvenSumOrOddProduct",
    "signature": "func EvenSumOrOddProduct(a, b int) int",
    "docstring": {
      "es": "EvenSumOrOddProduct calcula la suma de dos enteros si la suma es par, o el producto de los dos enteros si la suma es impar.\n\nEjemplos:\n\tEvenSumOrOddProduct(2, 3) // devuelve 6\n\tEvenSumOrOddProduct(5, 5) // devuelve 10",
      "arb": "EvenSumOrOddProduct يحسب مجموع عددين صحيحين إذا كان المجموع زوجيًا، أو حاصل ضرب العددين إذا كان المجموع فرديًا.\n\nأمثلة:\n\tEvenSumOrOddProduct(2, 3) // يعيد 6\n\tEvenSumOrOddProduct(5, 5) // يعيد 10",
      "sw": "EvenSumOrOddProduct huhesabu jumla ya namba mbili ikiwa jumla ni shufwa, au bidhaa ya namba mbili ikiwa jumla ni witiri.\n\nMifano:\n\tEvenSumOrOddProduct(2, 3) // inarejesha 6\n\tEvenSumOrOddProduct(5, 5) // inarejesha 10",
      "tr": "EvenSumOrOddProduct, iki tam sayının toplamı çiftse bu toplamı, toplam tekse iki tam sayının çarpımını hesaplar.\n\nÖrnekler:\n\tEvenSumOrOddProduct(2, 3) // 6 döndürür\n\tEvenSumOrOddProduct(5, 5) // 10 döndürür",
      "vi": "EvenSumOrOddProduct tính tổng của hai số nguyên nếu tổng là số chẵn, hoặc tích của hai số nguyên nếu tổng là số lẻ.\n\nVí dụ:\n\tEvenSumOrOddProduct(2, 3) // trả về 6\n\tEvenSumOrOddProduct(5, 5) // trả về 10"
    },
    "docstring_bertscore": {
      "es": "0.9921119903083425",
      "arb": "0.9838982267917878",
      "sw": "0.975615737163395",
      "tr": "0.9882821979316089",
      "vi": "0.981479107381164"
    }
  }
]