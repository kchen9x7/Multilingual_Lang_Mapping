[
  {
    "task_id": "CPP/1",
    "prompt": {
      "es": "#include <bits/stdc++.h>\nusing namespace std;\n// Devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "arb": "#include <bits/stdc++.h>\nusing namespace std;\n// إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "sw": "#include <bits/stdc++.h>\nusing namespace std;\n// Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "tr": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndür\nstring hello_mmcodeeval()\n```",
      "vi": "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n// Trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()\n```"
    },
    "prompt_bertscore": {
      "es": "0.9980401140303288",
      "arb": "1",
      "sw": "1",
      "tr": "0.9369284978492299",
      "vi": "0.9343600083920678"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "es": "Escribe una función CPP `string hello_mmcodeeval()` para resolver el siguiente problema:\nDevuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "arb": "اكتب دالة CPP `string hello_mmcodeeval()` لحل المشكلة التالية:\nإرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sw": "Andika kazi ya CPP `string hello_mmcodeeval()` kutatua tatizo lifuatalo: Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "tr": "Bir CPP fonksiyonu `string hello_mmcodeeval()` yazın ve aşağıdaki problemi çözün:\n\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndürün.",
      "vi": "Viết một hàm CPP `string hello_mmcodeeval()` để giải quyết vấn đề sau:  \nTrả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "instruction_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9999996027392379",
      "sw": "0.9999996027392379",
      "tr": "0.9848107347622621",
      "vi": "0.9999996027392379"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(hello_mmcodeeval() ==  \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\");\n    return 0;\n}",
    "entry_point": "hello_mmcodeeval",
    "signature": "string hello_mmcodeeval()",
    "docstring": {
      "es": "Return \"Hola, MMCODEEVAL: Evaluación de Código Masivamente Multilingüe\"",
      "arb": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sw": "Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "tr": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "vi": "Return \"Hello, MMCODEEVAL: Đánh Giá Mã Đa Ngôn Ngữ Quy Mô Lớn\""
    },
    "docstring_bertscore": {
      "es": "0.956679309787434",
      "arb": "0.956679309787434",
      "sw": "0.956679309787434",
      "tr": "0.999999801369619",
      "vi": "0.913028694511969"
    }
  },
  {
    "task_id": "CPP/2",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcular el área de un triángulo dados sus tres lados.\n *\n * @param a (double): Longitud del lado 'a'.\n * @param b (double): Longitud del lado 'b'.\n * @param c (double): Longitud del lado 'c'.\n *\n * @return (double): Si los lados proporcionados forman un triángulo, devuelve el\n *                   área calculada redondeada a 2 decimales.\n *                   De lo contrario, devuelve -1 como indicador.\n *\n * Ejemplo de uso:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // El área debería ser aproximadamente 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * حساب مساحة المثلث المعطى أضلاعه الثلاثة.\n *\n * @param a (double): طول الضلع 'a'.\n * @param b (double): طول الضلع 'b'.\n * @param c (double): طول الضلع 'c'.\n *\n * @return (double): إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع\n *                   المساحة المحسوبة مقربة إلى منزلتين عشريتين.\n *                   خلاف ذلك، يتم إرجاع -1 كمؤشر.\n *\n * مثال على الاستخدام:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // يجب أن تكون المساحة تقريبًا 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Kuhesabu eneo la pembetatu ukizingatia pande zake tatu.\n *\n * @param a (double): Urefu wa upande 'a'.\n * @param b (double): Urefu wa upande 'b'.\n * @param c (double): Urefu wa upande 'c'.\n *\n * @return (double): Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha\n *                   eneo lililohesabiwa likiwa limezungushwa hadi sehemu 2 za desimali.\n *                   Vinginevyo, rudisha -1 kama kiashiria.\n *\n * Mfano wa matumizi:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Eneo linapaswa kuwa takriban 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Üç kenarı verilen bir üçgenin alanını hesaplayın.\n *\n * @param a (double): 'a' kenarının uzunluğu.\n * @param b (double): 'b' kenarının uzunluğu.\n * @param c (double): 'c' kenarının uzunluğu.\n *\n * @return (double): Verilen kenarlar bir üçgen oluşturuyorsa,\n *                   hesaplanan alanı 2 ondalık basamağa yuvarlanmış\n *                   olarak döndürün. Aksi takdirde, bir gösterge olarak\n *                   -1 döndürün.\n *\n * Örnek kullanım:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Alan yaklaşık olarak 6 olmalıdır\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính diện tích của một tam giác khi biết ba cạnh của nó.\n *\n * @param a (double): Độ dài của cạnh 'a'.\n * @param b (double): Độ dài của cạnh 'b'.\n * @param c (double): Độ dài của cạnh 'c'.\n *\n * @return (double): Nếu các cạnh được cung cấp tạo thành một tam giác, trả về\n *                   diện tích đã tính toán làm tròn đến 2 chữ số thập phân.\n *                   Nếu không, trả về -1 như một chỉ báo.\n *\n * Ví dụ sử dụng:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Diện tích nên xấp xỉ 6\n */\ndouble calculate_triangle_area(double a, double b, double c)"
    },
    "prompt_bertscore": {
      "es": "0.9920432641965045",
      "arb": "0.9870153333613684",
      "sw": "0.9938444444917288",
      "tr": "0.9932090259027982",
      "vi": "0.9990986153308636"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}",
    "instruction": {
      "es": "Escribe una función CPP `double calculate_triangle_area(double a, double b, double c)` para resolver el siguiente problema:\nCalcular el área de un triángulo dados sus tres lados.\n\n@param a (double): Longitud del lado 'a'.\n@param b (double): Longitud del lado 'b'.\n@param c (double): Longitud del lado 'c'.\n\n@return (double): Si los lados proporcionados forman un triángulo, devuelve el área calculada redondeada a 2 decimales. De lo contrario, devuelve -1 como indicador.\n\nEjemplo de uso:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // El área debería ser aproximadamente 6",
      "arb": "اكتب دالة CPP `double calculate_triangle_area(double a, double b, double c)` لحل المشكلة التالية:\nاحسب مساحة مثلث معطى أضلاعه الثلاثة.\n\n@param a (double): طول الضلع 'a'.\n@param b (double): طول الضلع 'b'.\n@param c (double): طول الضلع 'c'.\n\n@return (double): إذا كانت الأضلاع المعطاة تشكل مثلثًا، أعد المساحة المحسوبة مقربة إلى منزلتين عشريتين. خلاف ذلك، أعد -1 كمؤشر.\n\nمثال على الاستخدام:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // يجب أن تكون المساحة تقريبًا 6",
      "sw": "Andika kazi ya CPP `double calculate_triangle_area(double a, double b, double c)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\n\n@param a (double): Urefu wa upande 'a'.\n@param b (double): Urefu wa upande 'b'.\n@param c (double): Urefu wa upande 'c'.\n\n@return (double): Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa lililokaribia hadi sehemu 2 za desimali. Vinginevyo, rudisha -1 kama kiashiria.\n\nMfano wa matumizi:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Eneo linapaswa kuwa takriban 6",
      "tr": "Bir CPP fonksiyonu `double calculate_triangle_area(double a, double b, double c)` yazın ve aşağıdaki problemi çözün:\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\n\n@param a (double): 'a' kenarının uzunluğu.\n@param b (double): 'b' kenarının uzunluğu.\n@param c (double): 'c' kenarının uzunluğu.\n\n@return (double): Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamağa yuvarlanmış olarak döndürün. Aksi takdirde, bir gösterge olarak -1 döndürün.\n\nÖrnek kullanım:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Alan yaklaşık olarak 6 olmalıdır.",
      "vi": "Viết một hàm CPP `double calculate_triangle_area(double a, double b, double c)` để giải quyết vấn đề sau:\nTính diện tích của một tam giác khi biết ba cạnh của nó.\n\n@param a (double): Độ dài của cạnh 'a'.\n@param b (double): Độ dài của cạnh 'b'.\n@param c (double): Độ dài của cạnh 'c'.\n\n@return (double): Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính được làm tròn đến 2 chữ số thập phân. Nếu không, trả về -1 để chỉ thị.\n\nVí dụ sử dụng:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Diện tích nên xấp xỉ 6"
    },
    "instruction_bertscore": {
      "es": "0.9930153612812892",
      "arb": "0.9925608949694814",
      "sw": "0.9936186017484921",
      "tr": "0.9922559973345928",
      "vi": "0.9893093156319402"
    },
    "level": "easy",
    "test": "int main() {\n    // Test cases for the calculate_triangle_area function\n    assert(fabs(calculate_triangle_area(3, 5, 4) - 6.00) < 1e-6); // Expected area is 6\n    assert(calculate_triangle_area(1, 1, 4) == -1);  // Not a triangle, should return -1\n    assert(fabs(calculate_triangle_area(7, 24, 25) - 84.00) < 1e-6); // Expected area is 84\n    assert(fabs(calculate_triangle_area(10.5, 6.2, 7.3) - 22.15) < 1e-2); // Expected area is approx 22.15\n\n    // All tests passed\n    \n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "double calculate_triangle_area(double a, double b, double c)",
    "docstring": {
      "es": "Calcular el área de un triángulo dados sus tres lados.\n\n@param a (double): Longitud del lado 'a'.\n@param b (double): Longitud del lado 'b'.\n@param c (double): Longitud del lado 'c'.\n\n@return (double): Si los lados proporcionados forman un triángulo, devuelve el área calculada redondeada a 2 decimales. De lo contrario, devuelve -1 como indicador.\n\nEjemplo de uso:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // El área debería ser aproximadamente 6",
      "arb": "حساب مساحة مثلث معطى أضلاعه الثلاثة.\n\n@param a (double): طول الضلع 'a'.\n@param b (double): طول الضلع 'b'.\n@param c (double): طول الضلع 'c'.\n\n@return (double): إذا كانت الأضلاع المعطاة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة مقربة إلى منزلتين عشريتين. خلاف ذلك، يتم إرجاع -1 كمؤشر.\n\nمثال على الاستخدام:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // يجب أن تكون المساحة تقريبًا 6",
      "sw": "Hesabu eneo la pembetatu ukizingatia pande zake tatu.\n\n@param a (double): Urefu wa upande 'a'.\n@param b (double): Urefu wa upande 'b'.\n@param c (double): Urefu wa upande 'c'.\n\n@return (double): Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa likiwa limezungushwa hadi sehemu 2 za desimali. Vinginevyo, rudisha -1 kama kiashiria.\n\nMfano wa matumizi:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Eneo linapaswa kuwa takriban 6",
      "tr": "Üç kenarı verilen bir üçgenin alanını hesaplayın.\n\n@param a (double): 'a' kenarının uzunluğu.\n@param b (double): 'b' kenarının uzunluğu.\n@param c (double): 'c' kenarının uzunluğu.\n\n@return (double): Verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamağa yuvarlanmış olarak döndürün. Aksi takdirde, bir gösterge olarak -1 döndürün.\n\nÖrnek kullanım:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Alan yaklaşık olarak 6 olmalıdır.",
      "vi": "Tính diện tích của một tam giác khi biết độ dài ba cạnh của nó.\n\n@param a (double): Độ dài của cạnh 'a'.\n@param b (double): Độ dài của cạnh 'b'.\n@param c (double): Độ dài của cạnh 'c'.\n\n@return (double): Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính toán được làm tròn đến 2 chữ số thập phân. Nếu không, trả về -1 để chỉ báo.\n\nVí dụ sử dụng:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Diện tích nên xấp xỉ 6"
    },
    "docstring_bertscore": {
      "es": "0.9798558999073468",
      "arb": "0.9801089550127853",
      "sw": "0.9913351468881151",
      "tr": "0.9934271220611746",
      "vi": "0.97074154624318"
    }
  },
  {
    "task_id": "CPP/3",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calcula el valor de la función para una entrada dada.\n * Parámetros:\n * - x (int): Valor de entrada para la función.\n * Retorna:\n * - std::string: Si x no está en el dominio definido, retorna \"Not define\".\n *   De lo contrario, retorna el valor calculado de la función redondeado a 5 decimales.\n *\n * Definiciones de la función:\n * - Para 0 <= x < 10: y = cos(x + 3.0)\n * - Para 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Para 20 <= x < 30: y = (cos(x + 4.0))^4\n * Ejemplo:\n *   calculate_function_value(40) returns \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "arb": "```cpp\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * حساب قيمة الدالة لمدخل معين.\n * المعاملات:\n * - x (int): قيمة المدخل للدالة.\n * يعيد:\n * - std::string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\n *   خلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n *\n * تعريفات الدالة:\n * - لـ 0 <= x < 10: y = cos(x + 3.0)\n * - لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n * - لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n * مثال:\n *   calculate_function_value(40) returns \"Not define\"\n */\nstd::string calculate_function_value(int x)\n```",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Hesabu thamani ya kazi kwa ingizo lililopewa.\n * Vigezo:\n * - x (int): Thamani ya ingizo kwa kazi.\n * Inarudisha:\n * - std::string: Ikiwa x haiko katika kikoa kilichobainishwa, inarudisha \"Not define\".\n *   Vinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyopinduliwa hadi sehemu 5 za desimali.\n *\n * Ufafanuzi wa Kazi:\n * - Kwa 0 <= x < 10: y = cos(x + 3.0)\n * - Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n * Mfano:\n *   calculate_function_value(40) inarudisha \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Belirli bir giriş için fonksiyonun değerini hesapla.\n * Parametreler:\n * - x (int): Fonksiyon için giriş değeri.\n * Döndürür:\n * - std::string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\n *   Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n *\n * Fonksiyon Tanımları:\n * - 0 <= x < 10 için: y = cos(x + 3.0)\n * - 10 <= x < 20 için: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 için: y = (cos(x + 4.0))^4\n * Örnek:\n *   calculate_function_value(40) \"Not define\" döndürür\n */\nstd::string calculate_function_value(int x)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Tính giá trị của hàm cho một đầu vào cho trước.\n * Tham số:\n * - x (int): Giá trị đầu vào cho hàm.\n * Trả về:\n * - std::string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\n *   Ngược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân.\n *\n * Định nghĩa hàm:\n * - Với 0 <= x < 10: y = cos(x + 3.0)\n * - Với 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Với 20 <= x < 30: y = (cos(x + 4.0))^4\n * Ví dụ:\n *   calculate_function_value(40) trả về \"Not define\"\n */\nstd::string calculate_function_value(int x)"
    },
    "prompt_bertscore": {
      "es": "0.9820452039671134",
      "arb": "0.9637646541093294",
      "sw": "0.9921493328199771",
      "tr": "0.9878767933239166",
      "vi": "0.9946586304235908"
    },
    "canonical_solution": "{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}",
    "instruction": {
      "es": "Escribe una función CPP `std::string calculate_function_value(int x)` para resolver el siguiente problema:\nCalcular el valor de la función para una entrada dada. Parámetros: - x (int): Valor de entrada para la función. Retorna: - std::string: Si x no está en el dominio definido, retorna \"Not define\". De lo contrario, retorna el valor calculado de la función redondeado a 5 decimales. Definiciones de la función: - Para 0 <= x < 10: y = cos(x + 3.0) - Para 10 <= x < 20: y = (cos(x + 7.5))^2 - Para 20 <= x < 30: y = (cos(x + 4.0))^4 Ejemplo: calculate_function_value(40) retorna \"Not define\"",
      "arb": "اكتب دالة CPP `std::string calculate_function_value(int x)` لحل المشكلة التالية:\nاحسب قيمة الدالة لمدخل معين. المعطيات: - x (int): قيمة المدخل للدالة. يعيد: - std::string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\". خلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية. تعريفات الدالة: - لـ 0 <= x < 10: y = cos(x + 3.0) - لـ 10 <= x < 20: y = (cos(x + 7.5))^2 - لـ 20 <= x < 30: y = (cos(x + 4.0))^4 مثال: calculate_function_value(40) يعيد \"Not define\"",
      "sw": "Andika kazi ya CPP `std::string calculate_function_value(int x)` kutatua tatizo lifuatalo:\nHesabu thamani ya kazi kwa ingizo lililopewa. Vigezo: - x (int): Thamani ya ingizo kwa kazi. Inarudisha: - std::string: Ikiwa x haipo kwenye uwanja uliofafanuliwa, inarudisha \"Not define\". Vinginevyo, inarudisha thamani ya kazi iliyohesabiwa ikizungushwa hadi sehemu tano za desimali. Ufafanuzi wa Kazi: - Kwa 0 <= x < 10: y = cos(x + 3.0) - Kwa 10 <= x < 20: y = (cos(x + 7.5))^2 - Kwa 20 <= x < 30: y = (cos(x + 4.0))^4 Mfano: calculate_function_value(40) inarudisha \"Not define\"",
      "tr": "Bir CPP fonksiyonu `std::string calculate_function_value(int x)` yazın. Aşağıdaki problemi çözmek için:\nVerilen bir girdi için fonksiyonun değerini hesaplayın. Parametreler: - x (int): Fonksiyon için giriş değeri. Döndürür: - std::string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür. Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür. Fonksiyon Tanımları: - 0 <= x < 10 için: y = cos(x + 3.0) - 10 <= x < 20 için: y = (cos(x + 7.5))^2 - 20 <= x < 30 için: y = (cos(x + 4.0))^4 Örnek: calculate_function_value(40) \"Not define\" döndürür.",
      "vi": "Viết một hàm CPP `std::string calculate_function_value(int x)` để giải quyết vấn đề sau:\nTính giá trị của hàm cho một đầu vào nhất định. Tham số: - x (int): Giá trị đầu vào cho hàm. Trả về: - std::string: Nếu x không nằm trong miền xác định, trả về \"Not define\". Ngược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân. Định nghĩa hàm: - Đối với 0 <= x < 10: y = cos(x + 3.0) - Đối với 10 <= x < 20: y = (cos(x + 7.5))^2 - Đối với 20 <= x < 30: y = (cos(x + 4.0))^4 Ví dụ: calculate_function_value(40) trả về \"Not define\""
    },
    "instruction_bertscore": {
      "es": "0.976600745222947",
      "arb": "0.9785596380407131",
      "sw": "0.9767576632239646",
      "tr": "0.9793412485900854",
      "vi": "0.9935578208518955"
    },
    "level": "easy",
    "test": "int main() {\n    assert(calculate_function_value(40) == \"Not define\");\n\n    // Additional test cases based on provided function definitions\n    assert(calculate_function_value(5) == \"-0.14550\");\n    assert(calculate_function_value(15) == \"0.76266\");\n    assert(calculate_function_value(25) == \"0.31314\");\n    assert(calculate_function_value(-1) == \"Not define\");\n\n    // std::cout << \"All tests passed successfully.\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "calculate_function_value",
    "signature": "std::string calculate_function_value(int x)",
    "docstring": {
      "es": "Calcular el valor de la función para una entrada dada. Parámetros: - x (int): Valor de entrada para la función. Devuelve: - std::string: Si x no está en el dominio definido, devuelve \"Not define\". De lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales. Definiciones de Función: - Para 0 <= x < 10: y = cos(x + 3.0) - Para 10 <= x < 20: y = (cos(x + 7.5))^2 - Para 20 <= x < 30: y = (cos(x + 4.0))^4 Ejemplo: calculate_function_value(40) devuelve \"Not define\"",
      "arb": "احسب قيمة الدالة لقيمة مدخلة معينة.  \nالمعلمات:  \n- x (int): قيمة المدخل للدالة.  \n\nالقيم المعادة:  \n- std::string: إذا لم يكن x في النطاق المحدد، يعيد \"غير معرف\". خلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.  \n\nتعريفات الدالة:  \n- لـ 0 <= x < 10: y = cos(x + 3.0)  \n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2  \n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4  \n\nمثال:  \ncalculate_function_value(40) يعيد \"غير معرف\"",
      "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n\nVigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n\nInarejesha:\n- std::string: Ikiwa x haipo kwenye kikoa kilichofafanuliwa, inarejesha \"Not define\". Vinginevyo, inarejesha thamani ya kazi iliyohesabiwa ikizunguushwa hadi sehemu 5 za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMfano:\ncalculate_function_value(40) inarejesha \"Not define\"",
      "tr": "Calculate the value of the function for a given input.\n\nParametreler:\n- x (int): Fonksiyon için giriş değeri.\n\nDöndürülenler:\n- std::string: Eğer x tanımlı alanda değilse, \"Not define\" döner. Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döner.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\nÖrnek:\ncalculate_function_value(40) returns \"Not define\"",
      "vi": "Tính giá trị của hàm cho một đầu vào đã cho.\n\nTham số:\n- x (int): Giá trị đầu vào cho hàm.\n\nTrả về:\n- std::string: Nếu x không nằm trong miền xác định, trả về \"Not define\". Ngược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Với 0 <= x < 10: y = cos(x + 3.0)\n- Với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Với 20 <= x < 30: y = (cos(x + 4.0))^4\n\nVí dụ:\ncalculate_function_value(40) trả về \"Not define\""
    },
    "docstring_bertscore": {
      "es": "0.9765655876455039",
      "arb": "0.9541145943075116",
      "sw": "0.98582950998659",
      "tr": "0.9834894454676181",
      "vi": "0.9894866925622045"
    }
  },
  {
    "task_id": "CPP/4",
    "prompt": {
      "es": "#include <cassert>\n#include <cstdio>\n/*\nEncuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Ejemplo de llamada: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "arb": "#include <cassert>\n#include <cstdio>\n/*\nالعثور على القيمة القصوى والدنيا لثلاثة أعداد صحيحة متميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالإرجاع:\nTuple[int, int]: الزوج ليس مفهومًا في C؛ بدلاً من ذلك، سنعيد بالقيمة المرجعية.\n\n>>> مثال على الاستدعاء: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "sw": "#include <cassert>\n#include <cstdio>\n/*\nPata kubwa na ndogo kati ya nambari tatu tofauti za mzima.\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nRudisha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarudisha kwa marejeleo.\n\n>>> Mfano wa kupiga simu: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "tr": "#include <cassert>\n#include <cstdio>\n/*\nÜç farklı tamsayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tamsayı.\nb (int): İkinci tamsayı.\nc (int): Üçüncü tamsayı.\n\nDöndürür:\nTuple[int, int]: C'de bir tuple kavramı yoktur; bunun yerine referansla döndüreceğiz.\n\n>>> Örnek çağrı: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "vi": "#include <cassert>\n#include <cstdio>\n/*\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)"
    },
    "prompt_bertscore": {
      "es": "0.9962530364921579",
      "arb": "0.9895764734944321",
      "sw": "0.9808389216630885",
      "tr": "0.9717291364976854",
      "vi": "0.9851833653570835"
    },
    "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}",
    "instruction": {
      "es": "Escribe una función CPP `void find_max_min(int a, int b, int c, int *max, int *min)` para resolver el siguiente problema:\nEncuentra el máximo y mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "arb": "اكتب دالة CPP `void find_max_min(int a, int b, int c, int *max, int *min)` لحل المشكلة التالية:\nإيجاد القيمة العظمى والصغرى لثلاثة أعداد صحيحة مميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالإرجاع:\nTuple[int, int]: الكائن Tuple ليس مفهومًا في C؛ بدلاً من ذلك، سنقوم بالإرجاع عن طريق المرجع.\n\n>>> مثال على الاستدعاء:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "sw": "Andika kazi ya CPP `void find_max_min(int a, int b, int c, int *max, int *min)` kutatua tatizo lifuatalo:\nPata kubwa na ndogo kati ya namba tatu tofauti za mzima.\nVigezo:\na (int): Namba ya kwanza ya mzima.\nb (int): Namba ya pili ya mzima.\nc (int): Namba ya tatu ya mzima.\n\nRudisha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarudisha kwa marejeleo.\n\n>>> Mfano wa kuita:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "tr": "Bir CPP fonksiyonu `void find_max_min(int a, int b, int c, int *max, int *min)` yazın ve aşağıdaki problemi çözün:\nÜç farklı tam sayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürülenler:\nTuple[int, int]: C'de bir tuple kavramı yoktur; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "vi": "Viết một hàm CPP `void find_max_min(int a, int b, int c, int *max, int *min)` để giải quyết vấn đề sau:\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Tuple không phải là một khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9762628749448067",
      "sw": "0.9806271816769053",
      "tr": "0.978559240779951",
      "vi": "0.9792568306781456"
    },
    "level": "easy",
    "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}",
    "entry_point": "find_max_min",
    "signature": "void find_max_min(int a, int b, int c, int *max, int *min)",
    "docstring": {
      "es": "Encuentra el máximo y el mínimo de tres enteros distintos.  \nParámetros:  \na (int): El primer entero.  \nb (int): El segundo entero.  \nc (int): El tercer entero.  \n\nDevuelve:  \nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.  \n\n>>> Llamada de ejemplo:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة مميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: الزوج ليس مفهومًا في C؛ بدلاً من ذلك، سنعيد بالقيمة المرجعية.\n\n>>> مثال على الاستدعاء:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "sw": "Pata kubwa na ndogo kati ya nambari tatu tofauti za mzima.\n\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nTuple[int, int]: Tuple sio dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kupiga:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "tr": "Üç farklı tam sayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürür:\nTuple[int, int]: C'de bir kavram olarak tuple yoktur; bunun yerine referansla döndüreceğiz.\n\n>>> Örnek çağrı:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9629840367118624",
      "sw": "0.9675094326829803",
      "tr": "0.9693525239886029",
      "vi": "0.9794741323149978"
    }
  },
  {
    "task_id": "CPP/5",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n * \n * Parámetros:\n * - xa (double): coordenada x del punto A.\n * - ya (double): coordenada y del punto A.\n * - xb (double): coordenada x del punto B.\n * - yb (double): coordenada y del punto B.\n * \n * Devuelve:\n * double: La distancia entre los puntos A y B.\n * \n * Ejemplos:\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * حساب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n * \n * المعاملات:\n * - xa (double): الإحداثي السيني للنقطة A.\n * - ya (double): الإحداثي الصادي للنقطة A.\n * - xb (double): الإحداثي السيني للنقطة B.\n * - yb (double): الإحداثي الصادي للنقطة B.\n * \n * يعيد:\n * double: المسافة بين النقطتين A و B.\n * \n * أمثلة:\n * calculate_distance(0, 0, 3, 4) يعيد 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n * \n * Vigezo:\n * - xa (double): x-kiwango cha pointi A.\n * - ya (double): y-kiwango cha pointi A.\n * - xb (double): x-kiwango cha pointi B.\n * - yb (double): y-kiwango cha pointi B.\n * \n * Inarudisha:\n * double: Umbali kati ya pointi A na B.\n * \n * Mifano:\n * calculate_distance(0, 0, 3, 4) inarudisha 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesapla.\n * \n * Parametreler:\n * - xa (double): A noktasının x-koordinatı.\n * - ya (double): A noktasının y-koordinatı.\n * - xb (double): B noktasının x-koordinatı.\n * - yb (double): B noktasının y-koordinatı.\n * \n * Döndürülen:\n * double: A ve B noktaları arasındaki mesafe.\n * \n * Örnekler:\n * calculate_distance(0, 0, 3, 4) 5 döndürür\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n * \n * Tham số:\n * - xa (double): tọa độ x của điểm A.\n * - ya (double): tọa độ y của điểm A.\n * - xb (double): tọa độ x của điểm B.\n * - yb (double): tọa độ y của điểm B.\n * \n * Trả về:\n * double: Khoảng cách giữa điểm A và B.\n * \n * Ví dụ:\n * calculate_distance(0, 0, 3, 4) trả về 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9780849114300397",
      "sw": "1",
      "tr": "0.9974046954413982",
      "vi": "0.9950151719575484"
    },
    "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}",
    "instruction": {
      "es": "Escribe una función CPP `double calculate_distance(double xa, double ya, double xb, double yb)` para resolver el siguiente problema:\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n\nDevuelve:\ndouble: La distancia entre los puntos A y B.\n\nEjemplos:\ncalculate_distance(0, 0, 3, 4) returns 5",
      "arb": "اكتب دالة CPP `double calculate_distance(double xa, double ya, double xb, double yb)` لحل المشكلة التالية:\nحساب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعطيات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\ndouble: المسافة بين النقطتين A و B.\n\nأمثلة:\ncalculate_distance(0, 0, 3, 4) returns 5",
      "sw": "Andika kazi ya CPP `double calculate_distance(double xa, double ya, double xb, double yb)` kutatua tatizo lifuatalo:\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (double): x-kiwianishi cha pointi A.\n- ya (double): y-kiwianishi cha pointi A.\n- xb (double): x-kiwianishi cha pointi B.\n- yb (double): y-kiwianishi cha pointi B.\n\nInarudisha:\ndouble: Umbali kati ya pointi A na B.\n\nMifano:\ncalculate_distance(0, 0, 3, 4) inarudisha 5",
      "tr": "Bir CPP fonksiyonu `double calculate_distance(double xa, double ya, double xb, double yb)` yazın ve aşağıdaki problemi çözün:\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n\nDöndürülen:\ndouble: A ve B noktaları arasındaki mesafe.\n\nÖrnekler:\ncalculate_distance(0, 0, 3, 4) 5 döndürür.",
      "vi": "Viết một hàm CPP `double calculate_distance(double xa, double ya, double xb, double yb)` để giải quyết vấn đề sau:\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n\nTrả về:\ndouble: Khoảng cách giữa điểm A và B.\n\nVí dụ:\ncalculate_distance(0, 0, 3, 4) trả về 5"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9703498471317792",
      "sw": "0.9973200788990773",
      "tr": "0.9956428439616187",
      "vi": "0.9975195038016363"
    },
    "level": "easy",
    "test": "int main() \n{\n    assert(fabs(calculate_distance(0, 0, 3, 4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0, 0, 0, 0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    //std::cout << \"All test cases passed!\\n\"; // printf can be replaced with std::cout\n    return 0;\n}",
    "entry_point": "calculate_distance",
    "signature": "double calculate_distance(double xa, double ya, double xb, double yb)",
    "docstring": {
      "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n\nDevuelve:\ndouble: La distancia entre los puntos A y B.\n\nEjemplos:\ncalculate_distance(0, 0, 3, 4) devuelve 5",
      "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعلمات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\ndouble: المسافة بين النقطتين A و B.\n\nأمثلة:\ncalculate_distance(0, 0, 3, 4) يعيد 5",
      "sw": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nVigezo:\n- xa (double): x-kiwiko cha nukta A.\n- ya (double): y-kiwiko cha nukta A.\n- xb (double): x-kiwiko cha nukta B.\n- yb (double): y-kiwiko cha nukta B.\n\nRudisha:\ndouble: Umbali kati ya nukta A na B.\n\nMifano:\ncalculate_distance(0, 0, 3, 4) inarudisha 5",
      "tr": "İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n\nDöndürülenler:\ndouble: A ve B noktaları arasındaki mesafe.\n\nÖrnekler:\ncalculate_distance(0, 0, 3, 4) 5 döndürür.",
      "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n\nTrả về:\ndouble: Khoảng cách giữa điểm A và B.\n\nVí dụ:\ncalculate_distance(0, 0, 3, 4) trả về 5"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9665283972310489",
      "sw": "0.9958079058082587",
      "tr": "0.9985168269448125",
      "vi": "0.9965003313165463"
    }
  },
  {
    "task_id": "CPP/6",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcula el factorial de N módulo 10007.\n * \n * Parámetros:\n * - N (int): Un entero que representa el valor de entrada (N <= 10000).\n * \n * Retorna:\n * int: El resultado después de calcular el factorial de N y\n * tomar el módulo 10007.\n * \n * Ejemplos:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * يحسب مضروب N موديولو 10007.\n * \n * المعلمات:\n * - N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n * \n * يعيد:\n * int: النتيجة بعد حساب مضروب N وأخذ الموديولو 10007.\n * \n * أمثلة:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Inahesabu factorial ya N modulo 10007.\n * \n * Vigezo:\n * - N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n * \n * Inarudisha:\n * int: Matokeo baada ya kuhesabu factorial ya N na\n * kuchukua modulo 10007.\n * \n * Mifano:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N faktöriyelinin 10007 ile modülünü hesaplar.\n * \n * Parametreler:\n * - N (int): Girdi değeri olarak bir tam sayı (N <= 10000).\n * \n * Döndürür:\n * int: N faktöriyelini hesapladıktan sonra 10007 ile modülünü\n * aldıktan sonraki sonuç.\n * \n * Örnekler:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính giai thừa của N theo modulo 10007.\n * \n * Tham số:\n * - N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n * \n * Trả về:\n * int: Kết quả sau khi tính giai thừa của N và\n * lấy modulo 10007.\n * \n * Ví dụ:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9919081955374007",
      "sw": "0.9945021096833353",
      "tr": "0.9635213318925617",
      "vi": "0.9904663376014685"
    },
    "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}",
    "instruction": {
      "es": "Escribe una función CPP `int process_request(int n)` para resolver el siguiente problema:\nCalcula el factorial de N módulo 10007.\n\nParámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n\nDevuelve:\nint: El resultado después de calcular el factorial de N y\ntomar el módulo 10007.\n\nEjemplos:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "arb": "اكتب دالة CPP `int process_request(int n)` لحل المشكلة التالية:\nتحسب المضروب لـ N موديولو 10007.\n\nالمعطيات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n\nالقيم المعادة:\nint: النتيجة بعد حساب المضروب لـ N وأخذ الموديولو 10007.\n\nأمثلة:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "sw": "Andika kazi ya CPP `int process_request(int n)` kutatua tatizo lifuatalo:\nInahesabu faktoria ya N modulo 10007.\n\nVigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya pembejeo (N <= 10000).\n\nInarudisha:\nint: Matokeo baada ya kuhesabu faktoria ya N na\nkuchukua modulo 10007.\n\nMifano:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "tr": "Bir CPP fonksiyonu `int process_request(int n)` yazın ve aşağıdaki problemi çözün:\nN faktöriyelini 10007 ile mod alarak hesaplar.\n\nParametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n\nDöndürür:\nint: N faktöriyelini hesapladıktan sonra 10007 ile mod alındıktan sonraki sonuç.\n\nÖrnekler:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "vi": "Viết một hàm CPP `int process_request(int n)` để giải quyết vấn đề sau:  \nTính giai thừa của N modulo 10007.\n\nTham số:  \n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:  \nint: Kết quả sau khi tính giai thừa của N và lấy modulo 10007.\n\nVí dụ:  \n>>> process_request(1)  \n1  \n>>> process_request(10)  \n6266  "
    },
    "instruction_bertscore": {
      "es": "0.9972906816026841",
      "arb": "0.9806025515096569",
      "sw": "0.9886502600276665",
      "tr": "0.9487646836247179",
      "vi": "0.9920891478145235"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "process_request",
    "signature": "int process_request(int n)",
    "docstring": {
      "es": "Calcula el factorial de N módulo 10007.\n\nParámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n\nDevuelve:\nint: El resultado después de calcular el factorial de N y\ntomar el módulo 10007.\n\nEjemplos:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "arb": "يحسب مضروب N بتطبيق باقي القسمة 10007.\n\nالمعطيات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n\nالقيم المعادة:\nint: النتيجة بعد حساب مضروب N وأخذ باقي القسمة 10007.\n\nأمثلة:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "sw": "Hesabu faktoria ya N modulo 10007.\n\nVigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarejesha:\nint: Matokeo baada ya kuhesabu faktoria ya N na\nkuchukua modulo 10007.\n\nMifano:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "tr": "N'in faktöriyelini 10007 ile mod alarak hesaplar.\n\nParametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n\nDöndürür:\nint: N'in faktöriyelini hesapladıktan sonra 10007 ile mod alarak elde edilen sonuç.\n\nÖrnekler:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "vi": "Tính giai thừa của N theo modulo 10007.\n\nTham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:\nint: Kết quả sau khi tính giai thừa của N và\nlấy modulo 10007.\n\nVí dụ:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266"
    },
    "docstring_bertscore": {
      "es": "0.9971651472018701",
      "arb": "0.9117711655696371",
      "sw": "0.9910791123269611",
      "tr": "0.9671681856883623",
      "vi": "0.9890262673389655"
    }
  },
  {
    "task_id": "CPP/7",
    "prompt": {
      "es": "#include <bits/stdc++.h>\n/*\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Retorna:\n    float: El área calculada del triángulo, redondeada a un decimal.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "arb": "#include <bits/stdc++.h>\n/*\nاحسب مساحة المثلث المعطى قاعدته وارتفاعه.\n    المعطيات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى مكان عشري واحد.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "sw": "#include <bits/stdc++.h>\n/*\nHesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n​    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​    Inarudisha:\n​    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "tr": "#include <bits/stdc++.h>\n/*\nBir üçgenin alanını, tabanı ve yüksekliği verildiğinde hesaplayın.\n​    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "vi": "#include <bits/stdc++.h>\n/*\nTính diện tích của một tam giác khi biết đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)"
    },
    "prompt_bertscore": {
      "es": "0.9733239398270145",
      "arb": "0.9655880810072298",
      "sw": "0.9726291307541545",
      "tr": "0.9757798058581298",
      "vi": "0.9667601988857166"
    },
    "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}",
    "instruction": {
      "es": "Escribe una función CPP `float calculate_triangle_area(int base, int height)` para resolver el siguiente problema:\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n​    Devuelve:\n​    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "arb": "اكتب دالة CPP `float calculate_triangle_area(int base, int height)` لحل المشكلة التالية:  \nاحسب مساحة المثلث المعطى قاعدته وارتفاعه.  \n    المعطيات:  \n- base (int): طول قاعدة المثلث.  \n- height (int): ارتفاع المثلث.  \n    المخرجات:  \n    float: المساحة المحسوبة للمثلث، مقربة إلى مكان عشري واحد.  \n    >>> calculate_triangle_area(1,2)  \n    1.0  ",
      "sw": "Andika kazi ya CPP `float calculate_triangle_area(int base, int height)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​    Inarudisha:\n​    float: Eneo lililohesabiwa la pembetatu, lililozungushwa hadi sehemu moja ya desimali.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "tr": "Bir CPP fonksiyonu `float calculate_triangle_area(int base, int height)` yazın ve aşağıdaki problemi çözün:\nÜçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Hesaplanan üçgen alanı, bir ondalık basamağa yuvarlanmış.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "vi": "Viết một hàm CPP `float calculate_triangle_area(int base, int height)` để giải quyết vấn đề sau:\nTính diện tích của một tam giác cho trước độ dài đáy và chiều cao của nó.\n    Tham số:\n- base (int): Độ dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "instruction_bertscore": {
      "es": "0.9809517437195163",
      "arb": "0.9644151686072188",
      "sw": "0.9844259877141975",
      "tr": "0.9839315966958017",
      "vi": "0.9845179535806167"
    },
    "level": "easy",
    "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(calculate_triangle_area(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "float calculate_triangle_area(int base, int height)",
    "docstring": {
      "es": "Calcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n​    Devuelve:\n​    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "arb": "احسب مساحة المثلث المعطى قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "sw": "Hesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n    Parameters:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​    Returns:\n​    float: Eneo lililohesabiwa la pembetatu, lililokadiriwa hadi sehemu moja ya desimali.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "tr": "Üçgenin taban uzunluğu ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n    Dönüş:\n    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış olarak.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "vi": "Tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích được tính của tam giác, làm tròn đến một chữ số thập phân.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "docstring_bertscore": {
      "es": "0.9752236407912321",
      "arb": "0.9800811467594404",
      "sw": "0.9618788572717842",
      "tr": "0.9749797226833213",
      "vi": "0.970035613868982"
    }
  },
  {
    "task_id": "CPP/8",
    "prompt": {
      "es": "#include <bits/stdc++.h>\n/*\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Retorna:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser cambiados\n         para transformar x en y en binario.\n    >>> hamming_distance(1,2)\n    2\n*/\nint hamming_distance(int x, int y)",
      "arb": "#include <bits/stdc++.h>\n/*\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعطيات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي يجب قلبها\n         لتحويل x إلى y في النظام الثنائي.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "sw": "#include <bits/stdc++.h>\n/*\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n​    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n​    Inarudisha:\n​    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitaji kubadilishwa\n​         ili kubadilisha x kuwa y katika binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "tr": "#include <bits/stdc++.h>\n/*\nİki tam sayının ikili gösteriminde Hamming mesafesini hesaplayın.\n​    Parametreler:\n- x (int): İlk pozitif tam sayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tam sayı (y <= 1,000,000,000).\n​    Döndürür:\n​    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "vi": "#include <bits/stdc++.h>\n/*\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n​    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n​    Trả về:\n​    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật\n​         để biến đổi x thành y trong nhị phân.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)"
    },
    "prompt_bertscore": {
      "es": "0.9682680021081524",
      "arb": "0.9600190810141546",
      "sw": "0.952255413941025",
      "tr": "0.9627587898597688",
      "vi": "0.9703486553494929"
    },
    "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int hamming_distance(int x, int y)` para resolver el siguiente problema:\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que deben ser cambiados para transformar x en y en binario.\n    >>> hamming_distance(1,2)\n    2",
      "arb": "اكتب دالة CPP `int hamming_distance(int x, int y)` لحل المشكلة التالية:\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى التغيير لتحويل x إلى y في النظام الثنائي.\n    >>> hamming_distance(1,2)\n    2",
      "sw": "Andika kazi ya CPP `int hamming_distance(int x, int y)` kutatua tatizo lifuatalo:\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> hamming_distance(1,2)\n    2",
      "tr": "Bir CPP fonksiyonu `int hamming_distance(int x, int y)` yazın: Aşağıdaki problemi çözmek için:\nİki tam sayının ikili gösterimdeki Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tam sayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tam sayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n    >>> hamming_distance(1,2)\n    2",
      "vi": "Viết một hàm CPP `int hamming_distance(int x, int y)` để giải quyết vấn đề sau:\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y trong nhị phân.\n    >>> hamming_distance(1,2)\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9878315055970407",
      "arb": "0.9840889119575813",
      "sw": "0.9777486301949477",
      "tr": "0.9808740792405316",
      "vi": "0.9901302549967574"
    },
    "level": "middle",
    "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}",
    "entry_point": "hamming_distance",
    "signature": "int hamming_distance(int x, int y)",
    "docstring": {
      "es": "Calcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser cambiados para transformar x en y en binario.\n    >>> hamming_distance(1,2)\n    2",
      "arb": "احسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلب لتحويل x إلى y في النظام الثنائي.\n    >>> hamming_distance(1,2)\n    2",
      "sw": "Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> hamming_distance(1,2)\n    2",
      "tr": "İkili gösterimde iki tamsayı arasındaki Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için değiştirilmesi gereken bit sayısı.\n    >>> hamming_distance(1,2)\n    2",
      "vi": "Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y trong nhị phân.\n    >>> hamming_distance(1,2)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9877568205737716",
      "arb": "0.9888826575734773",
      "sw": "0.9742779615471251",
      "tr": "0.9841302270768366",
      "vi": "0.9900289535024297"
    }
  },
  {
    "task_id": "CPP/9",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Cuenta el número de enteros impares en una lista dada de números.\n * Parámetros:\n * - count (int): El número de enteros a evaluar.\n * - ... (int): Una secuencia de enteros.\n * Retorna:\n *   int: La cantidad de números impares en la lista de entrada.\n * Uso:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) debería retornar 3\n */\nint count_odd_numbers(int count, ...)",
      "arb": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * عد عدد الأعداد الفردية في قائمة معينة من الأرقام.\n * المعلمات:\n * - count (int): عدد الأعداد لتقييمها.\n * - ... (int): سلسلة من الأعداد الصحيحة.\n * يعيد:\n *   int: عدد الأعداد الفردية في قائمة الإدخال.\n * الاستخدام:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) يجب أن تعيد 3\n */\nint count_odd_numbers(int count, ...)",
      "sw": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n * Vigezo:\n * - count (int): Idadi ya nambari za kutathmini.\n * - ... (int): Mlolongo wa nambari.\n * Inarudi:\n *   int: Idadi ya nambari zisizo za kawaida katika orodha ya pembejeo.\n * Matumizi:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) inapaswa kurudi 3\n */\nint count_odd_numbers(int count, ...)",
      "tr": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Verilen bir sayı listesindeki tek sayıların sayısını sayar.\n * Parametreler:\n * - count (int): Değerlendirilecek tamsayıların sayısı.\n * - ... (int): Bir dizi tamsayı.\n * Döndürür:\n *   int: Girdi listesindeki tek sayıların sayısı.\n * Kullanım:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) 3 döndürmelidir\n */\nint count_odd_numbers(int count, ...)",
      "vi": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n * Tham số:\n * - count (int): Số lượng số nguyên cần đánh giá.\n * - ... (int): Một dãy số nguyên.\n * Trả về:\n *   int: Số lượng số lẻ trong danh sách đầu vào.\n * Sử dụng:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) sẽ trả về 3\n */\nint count_odd_numbers(int count, ...)"
    },
    "prompt_bertscore": {
      "es": "0.9924609838878208",
      "arb": "0.9882224101869174",
      "sw": "0.9788816178883707",
      "tr": "0.9807380174295227",
      "vi": "0.994090150273069"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int count_odd_numbers(int count, ...)` para resolver el siguiente problema:\nCuenta la cantidad de enteros impares en una lista dada de números.\nParámetros:\n- count (int): El número de enteros a evaluar.\n- ... (int): Una secuencia de enteros.\nDevuelve:\n  int: La cantidad de números impares en la lista de entrada.\nUso:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) debería devolver 3",
      "arb": "اكتب دالة CPP `int count_odd_numbers(int count, ...)` لحل المشكلة التالية:\nعد عدد الأعداد الفردية في قائمة معينة من الأرقام.\nالمعلمات:\n- count (int): عدد الأعداد للتقييم.\n- ... (int): تسلسل من الأعداد الصحيحة.\nالقيم المعادة:\n  int: عدد الأعداد الفردية في قائمة الإدخال.\nالاستخدام:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) يجب أن تعيد 3",
      "sw": "Andika kazi ya CPP `int count_odd_numbers(int count, ...)` kutatua tatizo lifuatalo:\nHesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\nVigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- ... (int): Mlolongo wa nambari.\nInarudisha:\n  int: Idadi ya nambari zisizo za kawaida katika orodha ya pembejeo.\nMatumizi:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) inapaswa kurudisha 3",
      "tr": "Bir CPP fonksiyonu `int count_odd_numbers(int count, ...)` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\nParametreler:\n- count (int): Değerlendirilecek tamsayıların sayısı.\n- ... (int): Bir dizi tamsayı.\nDöndürülen:\n  int: Girdi listesindeki tek sayıların sayısı.\nKullanım:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) 3 döndürmelidir.",
      "vi": "Viết một hàm CPP `int count_odd_numbers(int count, ...)` để giải quyết vấn đề sau:\nĐếm số lượng số nguyên lẻ trong một danh sách các số cho trước.\nTham số:\n- count (int): Số lượng số nguyên cần đánh giá.\n- ... (int): Một dãy các số nguyên.\nTrả về:\n  int: Số lượng số lẻ trong danh sách đầu vào.\nSử dụng:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) nên trả về 3"
    },
    "instruction_bertscore": {
      "es": "0.9963028927177976",
      "arb": "0.9900730494470193",
      "sw": "0.9778811166590979",
      "tr": "0.9742477697292078",
      "vi": "0.9963028927177976"
    },
    "level": "easy",
    "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_odd_numbers",
    "signature": "int count_odd_numbers(int count, ...)",
    "docstring": {
      "es": "Cuenta el número de enteros impares en una lista dada de números.\nParámetros:\n- count (int): El número de enteros a evaluar.\n- ... (int): Una secuencia de enteros.\nDevuelve:\n  int: La cuenta de números impares en la lista de entrada.\nUso:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) debería devolver 3",
      "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\nالمعلمات:\n- count (int): عدد الأعداد لتقييمها.\n- ... (int): سلسلة من الأعداد الصحيحة.\nالقيم المعادة:\n  int: عدد الأعداد الفردية في قائمة الإدخال.\nالاستخدام:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) يجب أن تعيد 3",
      "sw": "Hesabu idadi ya nambari zisizo za jozi katika orodha iliyotolewa ya nambari.\n\nVigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- ... (int): Mfululizo wa nambari.\n\nInarejesha:\n  int: Idadi ya nambari zisizo za jozi katika orodha ya pembejeo.\n\nMatumizi:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) inapaswa kurejesha 3",
      "tr": "Verilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\nParametreler:\n- count (int): Değerlendirilecek tamsayıların sayısı.\n- ... (int): Bir dizi tamsayı.\nDöndürülen:\n  int: Girdi listesindeki tek sayıların sayısı.\nKullanım:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) 3 döndürmelidir.",
      "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.  \nTham số:  \n- count (int): Số lượng số nguyên cần đánh giá.  \n- ... (int): Một dãy số nguyên.  \nTrả về:  \n  int: Số lượng số lẻ trong danh sách đầu vào.  \nSử dụng:  \n  count_odd_numbers(5, 1, 4, 3, 2, 5) sẽ trả về 3  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.96878960548875",
      "sw": "0.976133566566753",
      "tr": "0.9682572760675766",
      "vi": "0.9915540375680155"
    }
  },
  {
    "task_id": "CPP/10",
    "prompt": {
      "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calcular la suma de números pares en un arreglo dado.\n * \n * Parámetros:\n * - numbers (vector<int>): Un vector de enteros.\n * - size (int): El tamaño del arreglo.\n * \n * Devuelve:\n * int: La suma de los números pares en el arreglo de entrada.\n * \n * Ejemplos:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "arb": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * حساب مجموع الأعداد الزوجية في مصفوفة معينة.\n * \n * المعاملات:\n * - numbers (vector<int>): متجه من الأعداد الصحيحة.\n * - size (int): حجم المصفوفة.\n * \n * يعيد:\n * int: مجموع الأعداد الزوجية في المصفوفة المدخلة.\n * \n * أمثلة:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Hesabu jumla ya namba shufwa katika safu iliyotolewa.\n * \n * Vigezo:\n * - numbers (vector<int>): Vekta ya namba nzima.\n * - size (int): Ukubwa wa safu.\n * \n * Inarudisha:\n * int: Jumla ya namba shufwa katika safu ya ingizo.\n * \n * Mifano:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Verilen bir dizideki çift sayıların toplamını hesapla.\n * \n * Parametreler:\n * - numbers (vector<int>): Bir tamsayılar vektörü.\n * - size (int): Dizinin boyutu.\n * \n * Döndürür:\n * int: Girdi dizisindeki çift sayıların toplamı.\n * \n * Örnekler:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "vi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Tính tổng các số chẵn trong một mảng cho trước.\n * \n * Tham số:\n * - numbers (vector<int>): Một vector các số nguyên.\n * - size (int): Kích thước của mảng.\n * \n * Trả về:\n * int: Tổng các số chẵn trong mảng đầu vào.\n * \n * Ví dụ:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)"
    },
    "prompt_bertscore": {
      "es": "0.9964635846960549",
      "arb": "1",
      "sw": "0.9820738067419824",
      "tr": "1",
      "vi": "0.9984723337394606"
    },
    "canonical_solution": "{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int calculate_even_sum(const std::vector<int>& numbers)` para resolver el siguiente problema:\nCalcular la suma de los números pares en un arreglo dado.\n\nParámetros:\n- numbers (vector<int>): Un vector de enteros.\n\nDevuelve:\nint: La suma de los números pares en el arreglo de entrada.\n\nEjemplos:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "arb": "اكتب دالة CPP `int calculate_even_sum(const std::vector<int>& numbers)` لحل المشكلة التالية:\nاحسب مجموع الأرقام الزوجية في مصفوفة معينة.\n\nالمعطيات:\n- numbers (vector<int>): متجه من الأعداد الصحيحة.\n\nالقيم المعادة:\nint: مجموع الأرقام الزوجية في المصفوفة المدخلة.\n\nأمثلة:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "sw": "Andika kazi ya CPP `int calculate_even_sum(const std::vector<int>& numbers)` kutatua tatizo lifuatalo:\nHesabu jumla ya namba shufwa katika safu iliyotolewa.\n\nVigezo:\n- numbers (vector<int>): Vekta ya namba nzima.\n\nInarejesha:\nint: Jumla ya namba shufwa katika safu ya pembejeo.\n\nMifano:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "tr": "Bir CPP fonksiyonu `int calculate_even_sum(const std::vector<int>& numbers)` yazın:\nVerilen bir dizideki çift sayıların toplamını hesaplayın.\n\nParametreler:\n- numbers (vector<int>): Bir tamsayı vektörü.\n\nDöndürür:\nint: Girdi dizisindeki çift sayıların toplamı.\n\nÖrnekler:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "vi": "Viết một hàm CPP `int calculate_even_sum(const std::vector<int>& numbers)` để giải quyết vấn đề sau:  \nTính tổng các số chẵn trong một mảng cho trước.\n\nTham số:  \n- numbers (vector<int>): Một vector các số nguyên.\n\nTrả về:  \nint: Tổng các số chẵn trong mảng đầu vào.\n\nVí dụ:  \n>>> calculate_even_sum({1,4,3,2,5}, 5)  \n6  "
    },
    "instruction_bertscore": {
      "es": "0.9915776745833587",
      "arb": "0.9841093708868279",
      "sw": "0.9969551948891162",
      "tr": "0.9663101024422915",
      "vi": "0.9983025047636759"
    },
    "level": "easy",
    "test": "int main() {\n    std::vector<int> sample1 = {1, 4, 3, 2, 5};\n    std::vector<int> sample2 = {2, 2, 0, 0};\n    std::vector<int> sample3 = {7, 11, 19}; // Additional test with no even numbers\n    std::vector<int> sample4 = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(calculate_even_sum(sample1) == 6);\n    assert(calculate_even_sum(sample2) == 4);\n    assert(calculate_even_sum(sample3) == 0); // Should return 0 because there are no even numbers\n    assert(calculate_even_sum(sample4) == 12 + 14 + 16 + 18 + 20);\n\n    // std::cout << \"All tests passed successfully.\\n\";\n\n    return 0;\n}",
    "entry_point": "calculate_even_sum",
    "signature": "int calculate_even_sum(const std::vector<int>& numbers)",
    "docstring": {
      "es": "Calcular la suma de números pares en un arreglo dado.\n\nParámetros:\n- numbers (vector<int>): Un vector de enteros.\n\nDevuelve:\nint: La suma de los números pares en el arreglo de entrada.\n\nEjemplos:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "arb": "حساب مجموع الأعداد الزوجية في مصفوفة معينة.\n\nالمعلمات:\n- numbers (vector<int>): متجه من الأعداد الصحيحة.\n\nالقيم المعادة:\nint: مجموع الأعداد الزوجية في المصفوفة المدخلة.\n\nأمثلة:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "sw": "Hesabu jumla ya namba shufwa katika safu iliyotolewa.\n\nVigezo:\n- numbers (vector<int>): Kipeo cha namba nzima.\n\nInarejesha:\nint: Jumla ya namba shufwa katika safu iliyoingizwa.\n\nMifano:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "tr": "Verilen bir dizideki çift sayıların toplamını hesaplayın.\n\nParametreler:\n- numbers (vector<int>): Bir tamsayı vektörü.\n\nDöndürür:\nint: Girdi dizisindeki çift sayıların toplamı.\n\nÖrnekler:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "vi": "Tính tổng các số chẵn trong một mảng cho trước.\n\nTham số:\n- numbers (vector<int>): Một vector chứa các số nguyên.\n\nTrả về:\nint: Tổng các số chẵn trong mảng đầu vào.\n\nVí dụ:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6"
    },
    "docstring_bertscore": {
      "es": "0.9955381657508133",
      "arb": "0.9925126277868899",
      "sw": "0.9816235116681763",
      "tr": "0.9914340648178704",
      "vi": "0.9936041017306766"
    }
  },
  {
    "task_id": "CPP/11",
    "prompt": {
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Determina si dos intervalos cerrados se intersectan.\n *\n * @param a El límite inferior del primer intervalo cerrado [a,b].\n * @param b El límite superior del primer intervalo cerrado [a,b].\n * @param c El límite inferior del segundo intervalo cerrado [c,d].\n * @param d El límite superior del segundo intervalo cerrado [c,d].\n *\n * @return 1 si los intervalos se intersectan, 0 en caso contrario.\n *\n * Ejemplos:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * يحدد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n *\n * @param a الحد الأدنى للفترة المغلقة الأولى [a,b].\n * @param b الحد الأقصى للفترة المغلقة الأولى [a,b].\n * @param c الحد الأدنى للفترة المغلقة الثانية [c,d].\n * @param d الحد الأقصى للفترة المغلقة الثانية [c,d].\n *\n * @return 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n *\n * أمثلة:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Huamua ikiwa vipindi viwili vilivyofungwa vinaingiliana.\n *\n * @param a Kikomo cha chini cha kipindi cha kwanza kilichofungwa [a,b].\n * @param b Kikomo cha juu cha kipindi cha kwanza kilichofungwa [a,b].\n * @param c Kikomo cha chini cha kipindi cha pili kilichofungwa [c,d].\n * @param d Kikomo cha juu cha kipindi cha pili kilichofungwa [c,d].\n *\n * @return 1 ikiwa vipindi vinaingiliana, 0 vinginevyo.\n *\n * Mifano:\n * are_intervals_intersecting(1, 1, 1, 2) inarejesha 1\n * are_intervals_intersecting(3, 5, 2, 6) inarejesha 1\n * are_intervals_intersecting(3, 5, 4, 7) inarejesha 1\n * are_intervals_intersecting(3, 5, 6, 7) inarejesha 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * İki kapalı aralığın kesişip kesişmediğini belirler.\n *\n * @param a İlk kapalı aralığın alt sınırı [a,b].\n * @param b İlk kapalı aralığın üst sınırı [a,b].\n * @param c İkinci kapalı aralığın alt sınırı [c,d].\n * @param d İkinci kapalı aralığın üst sınırı [c,d].\n *\n * @return Aralıklar kesişiyorsa 1, aksi takdirde 0.\n *\n * Örnekler:\n * are_intervals_intersecting(1, 1, 1, 2) 1 döndürür\n * are_intervals_intersecting(3, 5, 2, 6) 1 döndürür\n * are_intervals_intersecting(3, 5, 4, 7) 1 döndürür\n * are_intervals_intersecting(3, 5, 6, 7) 0 döndürür\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Xác định xem hai khoảng đóng có giao nhau hay không.\n *\n * @param a Giới hạn dưới của khoảng đóng thứ nhất [a,b].\n * @param b Giới hạn trên của khoảng đóng thứ nhất [a,b].\n * @param c Giới hạn dưới của khoảng đóng thứ hai [c,d].\n * @param d Giới hạn trên của khoảng đóng thứ hai [c,d].\n *\n * @return 1 nếu các khoảng giao nhau, 0 nếu không.\n *\n * Ví dụ:\n * are_intervals_intersecting(1, 1, 1, 2) trả về 1\n * are_intervals_intersecting(3, 5, 2, 6) trả về 1\n * are_intervals_intersecting(3, 5, 4, 7) trả về 1\n * are_intervals_intersecting(3, 5, 6, 7) trả về 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9748571677382228",
      "sw": "0.9753777779669153",
      "tr": "0.9730520148353777",
      "vi": "0.969421250100441"
    },
    "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}",
    "instruction": {
      "es": "Escribe una función CPP `int are_intervals_intersecting(int a, int b, int c, int d)` para resolver el siguiente problema:\nDetermina si dos intervalos cerrados se intersectan.\n\n@param a El límite inferior del primer intervalo cerrado [a,b].\n@param b El límite superior del primer intervalo cerrado [a,b].\n@param c El límite inferior del segundo intervalo cerrado [c,d].\n@param d El límite superior del segundo intervalo cerrado [c,d].\n\n@return 1 si los intervalos se intersectan, 0 en caso contrario.\n\nEjemplos:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "arb": "اكتب دالة CPP `int are_intervals_intersecting(int a, int b, int c, int d)` لحل المشكلة التالية:\nتحديد ما إذا كانت فترتان مغلقتان تتقاطعان.\n\n@param a الحد الأدنى للفترة المغلقة الأولى [a,b].\n@param b الحد الأقصى للفترة المغلقة الأولى [a,b].\n@param c الحد الأدنى للفترة المغلقة الثانية [c,d].\n@param d الحد الأقصى للفترة المغلقة الثانية [c,d].\n\n@return 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n\nأمثلة:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "sw": "Andika kazi ya CPP `int are_intervals_intersecting(int a, int b, int c, int d)` kutatua tatizo lifuatalo:\nInabainisha kama vipindi viwili vilivyofungwa vinaingiliana.\n\n@param a Kikomo cha chini cha kipindi cha kwanza kilichofungwa [a,b].\n@param b Kikomo cha juu cha kipindi cha kwanza kilichofungwa [a,b].\n@param c Kikomo cha chini cha kipindi cha pili kilichofungwa [c,d].\n@param d Kikomo cha juu cha kipindi cha pili kilichofungwa [c,d].\n\n@return 1 ikiwa vipindi vinaingiliana, 0 vinginevyo.\n\nMifano:\nare_intervals_intersecting(1, 1, 1, 2) inarejesha 1\nare_intervals_intersecting(3, 5, 2, 6) inarejesha 1\nare_intervals_intersecting(3, 5, 4, 7) inarejesha 1\nare_intervals_intersecting(3, 5, 6, 7) inarejesha 0",
      "tr": "Bir CPP fonksiyonu `int are_intervals_intersecting(int a, int b, int c, int d)` yazarak aşağıdaki problemi çözün:\nİki kapalı aralığın kesişip kesişmediğini belirler.\n\n@param a İlk kapalı aralığın [a,b] alt sınırı.\n@param b İlk kapalı aralığın [a,b] üst sınırı.\n@param c İkinci kapalı aralığın [c,d] alt sınırı.\n@param d İkinci kapalı aralığın [c,d] üst sınırı.\n\n@return Aralıklar kesişiyorsa 1, aksi takdirde 0.\n\nÖrnekler:\nare_intervals_intersecting(1, 1, 1, 2) 1 döndürür\nare_intervals_intersecting(3, 5, 2, 6) 1 döndürür\nare_intervals_intersecting(3, 5, 4, 7) 1 döndürür\nare_intervals_intersecting(3, 5, 6, 7) 0 döndürür",
      "vi": "Viết một hàm CPP `int are_intervals_intersecting(int a, int b, int c, int d)` để giải quyết vấn đề sau:\nXác định xem hai đoạn đóng có giao nhau hay không.\n\n@param a Giới hạn dưới của đoạn đóng thứ nhất [a,b].\n@param b Giới hạn trên của đoạn đóng thứ nhất [a,b].\n@param c Giới hạn dưới của đoạn đóng thứ hai [c,d].\n@param d Giới hạn trên của đoạn đóng thứ hai [c,d].\n\n@return 1 nếu các đoạn giao nhau, 0 nếu không.\n\nVí dụ:\nare_intervals_intersecting(1, 1, 1, 2) trả về 1\nare_intervals_intersecting(3, 5, 2, 6) trả về 1\nare_intervals_intersecting(3, 5, 4, 7) trả về 1\nare_intervals_intersecting(3, 5, 6, 7) trả về 0"
    },
    "instruction_bertscore": {
      "es": "0.9931295737503842",
      "arb": "0.9639748050524644",
      "sw": "0.9740030570997728",
      "tr": "0.9715348759850333",
      "vi": "0.966984253955524"
    },
    "level": "easy",
    "test": "int main() {\n    assert(are_intervals_intersecting(1, 1, 1, 2) == 1);\n    assert(are_intervals_intersecting(3, 5, 2, 6) == 1);\n    assert(are_intervals_intersecting(3, 5, 4, 7) == 1);\n    assert(are_intervals_intersecting(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == 1);\n    assert(are_intervals_intersecting(1, 3, 2, 4) == 1);\n    assert(are_intervals_intersecting(1, 3, 4, 6) == 0);\n    assert(are_intervals_intersecting(10, 20, 20, 30) == 1);\n    assert(are_intervals_intersecting(10, 20, 21, 30) == 0);\n    \n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "are_intervals_intersecting",
    "signature": "int are_intervals_intersecting(int a, int b, int c, int d)",
    "docstring": {
      "es": "Determina si dos intervalos cerrados se intersectan.\n\n@param a El límite inferior del primer intervalo cerrado [a,b].\n@param b El límite superior del primer intervalo cerrado [a,b].\n@param c El límite inferior del segundo intervalo cerrado [c,d].\n@param d El límite superior del segundo intervalo cerrado [c,d].\n\n@return 1 si los intervalos se intersectan, 0 en caso contrario.\n\nEjemplos:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "arb": "تحديد ما إذا كانت فترتان مغلقتان تتقاطعان.\n\n@param a الحد الأدنى للفترة المغلقة الأولى [a,b].\n@param b الحد الأقصى للفترة المغلقة الأولى [a,b].\n@param c الحد الأدنى للفترة المغلقة الثانية [c,d].\n@param d الحد الأقصى للفترة المغلقة الثانية [c,d].\n\n@return 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n\nأمثلة:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "sw": "Inabainisha kama vipindi viwili vilivyofungwa vinaingiliana.\n\n@param a Chini ya mpaka wa kipengele cha kwanza kilichofungwa [a,b].\n@param b Juu ya mpaka wa kipengele cha kwanza kilichofungwa [a,b].\n@param c Chini ya mpaka wa kipengele cha pili kilichofungwa [c,d].\n@param d Juu ya mpaka wa kipengele cha pili kilichofungwa [c,d].\n\n@return 1 ikiwa vipengele vinaingiliana, 0 vinginevyo.\n\nExamples:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "tr": "İki kapalı aralığın kesişip kesişmediğini belirler.\n\n@param a İlk kapalı aralığın [a,b] alt sınırı.\n@param b İlk kapalı aralığın [a,b] üst sınırı.\n@param c İkinci kapalı aralığın [c,d] alt sınırı.\n@param d İkinci kapalı aralığın [c,d] üst sınırı.\n\n@return Aralıklar kesişiyorsa 1, aksi takdirde 0.\n\nÖrnekler:\nare_intervals_intersecting(1, 1, 1, 2) 1 döndürür\nare_intervals_intersecting(3, 5, 2, 6) 1 döndürür\nare_intervals_intersecting(3, 5, 4, 7) 1 döndürür\nare_intervals_intersecting(3, 5, 6, 7) 0 döndürür",
      "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n\n@param a Giới hạn dưới của khoảng đóng thứ nhất [a,b].\n@param b Giới hạn trên của khoảng đóng thứ nhất [a,b].\n@param c Giới hạn dưới của khoảng đóng thứ hai [c,d].\n@param d Giới hạn trên của khoảng đóng thứ hai [c,d].\n\n@return 1 nếu các khoảng giao nhau, 0 nếu không.\n\nVí dụ:\nare_intervals_intersecting(1, 1, 1, 2) trả về 1\nare_intervals_intersecting(3, 5, 2, 6) trả về 1\nare_intervals_intersecting(3, 5, 4, 7) trả về 1\nare_intervals_intersecting(3, 5, 6, 7) trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9652150531516462",
      "sw": "0.9709505054040286",
      "tr": "0.9674480558952404",
      "vi": "0.9623045221783421"
    }
  },
  {
    "task_id": "CPP/12",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Se te dan tres enteros a, b, c, donde dos de ellos son iguales, y el\n * tercero es diferente de los otros dos. Tu tarea es encontrar el valor que\n * ocurre exactamente una vez.\n *\n * Ejemplos:\n *   extraNumber(0, 0, 1) returns 1\n *   extraNumber(4, 3, 4) returns 3\n */\nint extraNumber(int a, int b, int c)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * لديك ثلاثة أعداد صحيحة a، b، c، حيث يكون اثنان منها متساويين،\n * والثالث مختلف عن الاثنين الآخرين. مهمتك هي العثور على القيمة التي\n * تظهر مرة واحدة فقط.\n *\n * أمثلة:\n *   extraNumber(0, 0, 1) returns 1\n *   extraNumber(4, 3, 4) returns 3\n */\nint extraNumber(int a, int b, int c)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Umepewa nambari tatu a, b, c, ambapo mbili kati ya hizo ni sawa, na\n * ya tatu ni tofauti na hizo mbili nyingine. Kazi yako ni kupata thamani\n * inayotokea mara moja tu.\n *\n * Mifano:\n *   extraNumber(0, 0, 1) inarudisha 1\n *   extraNumber(4, 3, 4) inarudisha 3\n */\nint extraNumber(int a, int b, int c)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Üç tamsayı a, b, c verilir, bunlardan ikisi eşittir ve\n * üçüncüsü diğer ikisinden farklıdır. Göreviniz tam olarak bir kez\n * geçen değeri bulmaktır.\n *\n * Örnekler:\n *   extraNumber(0, 0, 1) 1 döndürür\n *   extraNumber(4, 3, 4) 3 döndürür\n */\nint extraNumber(int a, int b, int c)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Bạn được cung cấp ba số nguyên a, b, c, trong đó hai số bằng nhau và\n * số thứ ba khác với hai số còn lại. Nhiệm vụ của bạn là tìm giá trị xuất hiện\n * chính xác một lần.\n *\n * Ví dụ:\n *   extraNumber(0, 0, 1) trả về 1\n *   extraNumber(4, 3, 4) trả về 3\n */\nint extraNumber(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9831460135388087",
      "sw": "0.9790685290769245",
      "tr": "0.9816529089645695",
      "vi": "0.980243825041508"
    },
    "canonical_solution": "{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}",
    "instruction": {
      "es": "Escribe una función CPP `int extraNumber(int a, int b, int c)` para resolver el siguiente problema:\nSe te dan tres enteros a, b, c, donde dos de ellos son iguales, y el tercero es diferente de los otros dos. Tu tarea es encontrar el valor que ocurre exactamente una vez.\n\nEjemplos:\n  extraNumber(0, 0, 1) devuelve 1\n  extraNumber(4, 3, 4) devuelve 3",
      "arb": "اكتب دالة CPP `int extraNumber(int a, int b, int c)` لحل المشكلة التالية:\nأنت لديك ثلاثة أعداد صحيحة a، b، c، حيث يكون اثنان منهما متساويين، والثالث مختلف عن الآخرين. مهمتك هي إيجاد القيمة التي تظهر مرة واحدة فقط.\n\nأمثلة:\n  extraNumber(0, 0, 1) returns 1\n  extraNumber(4, 3, 4) returns 3",
      "sw": "Andika kazi ya CPP `int extraNumber(int a, int b, int c)` kutatua tatizo lifuatalo:  \nUmepewa nambari tatu za mzima a, b, c, ambapo mbili kati ya hizo ni sawa, na ya tatu ni tofauti na zile mbili nyingine. Kazi yako ni kupata thamani inayotokea mara moja tu.\n\nMifano:  \n  extraNumber(0, 0, 1) inarudisha 1  \n  extraNumber(4, 3, 4) inarudisha 3  ",
      "tr": "Bir CPP fonksiyonu `int extraNumber(int a, int b, int c)` yazarak aşağıdaki problemi çözün:\nÜç tamsayı a, b, c verilir, bunlardan ikisi eşittir ve üçüncüsü diğer ikisinden farklıdır. Göreviniz, yalnızca bir kez meydana gelen değeri bulmaktır.\n\nÖrnekler:\n  extraNumber(0, 0, 1) 1 döndürür\n  extraNumber(4, 3, 4) 3 döndürür",
      "vi": "Viết một hàm CPP `int extraNumber(int a, int b, int c)` để giải quyết vấn đề sau:  \nBạn được cho ba số nguyên a, b, c, trong đó hai trong số chúng bằng nhau, và số thứ ba khác với hai số còn lại. Nhiệm vụ của bạn là tìm giá trị xuất hiện chính xác một lần.\n\nVí dụ:  \n  extraNumber(0, 0, 1) trả về 1  \n  extraNumber(4, 3, 4) trả về 3  "
    },
    "instruction_bertscore": {
      "es": "0.992980600964608",
      "arb": "0.977038725213129",
      "sw": "0.9817365323549851",
      "tr": "0.97567234682199",
      "vi": "0.9915478800262034"
    },
    "level": "easy",
    "test": "int main() {\n    assert(extraNumber(2, 7, 2) == 7);\n    assert(extraNumber(3, 2, 2) == 3);\n    assert(extraNumber(5, 5, 1) == 1);\n    assert(extraNumber(500000000, 3, 500000000) == 3);\n    assert(extraNumber(500000000, 500000000, 3) == 3);\n\n    \n    return 0;\n}",
    "entry_point": "extraNumber",
    "signature": "int extraNumber(int a, int b, int c)",
    "docstring": {
      "es": "Se te dan tres enteros a, b, c, donde dos de ellos son iguales, y el tercero es diferente de los otros dos. Tu tarea es encontrar el valor que ocurre exactamente una vez.\n\nEjemplos:\n  extraNumber(0, 0, 1) returns 1\n  extraNumber(4, 3, 4) returns 3",
      "arb": "أنت مُعطى ثلاثة أعداد صحيحة a، b، c، حيث أن اثنين منهما متساويان، والثالث مختلف عن الاثنين الآخرين. مهمتك هي إيجاد القيمة التي تظهر مرة واحدة فقط.\n\nأمثلة:\n  extraNumber(0, 0, 1) يعيد 1\n  extraNumber(4, 3, 4) يعيد 3",
      "sw": "Unapewa nambari tatu za mzima a, b, c, ambapo mbili kati yao ni sawa, na ya tatu ni tofauti na zile nyingine mbili. Kazi yako ni kupata thamani inayotokea mara moja tu.\n\nMifano:\n  extraNumber(0, 0, 1) inarudisha 1\n  extraNumber(4, 3, 4) inarudisha 3",
      "tr": "Üç tamsayı a, b, c verilir ve bunlardan ikisi eşittir, üçüncüsü ise diğer ikisinden farklıdır. Göreviniz, tam olarak bir kez geçen değeri bulmaktır.\n\nÖrnekler:\n  extraNumber(0, 0, 1) 1 döndürür\n  extraNumber(4, 3, 4) 3 döndürür",
      "vi": "Bạn được cung cấp ba số nguyên a, b, c, trong đó có hai số bằng nhau, và số thứ ba khác với hai số còn lại. Nhiệm vụ của bạn là tìm giá trị xuất hiện chính xác một lần.\n\nVí dụ:\n  extraNumber(0, 0, 1) trả về 1\n  extraNumber(4, 3, 4) trả về 3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9861943939965512",
      "sw": "0.9643422712573789",
      "tr": "0.9784803845186802",
      "vi": "0.9739518104614658"
    }
  },
  {
    "task_id": "CPP/13",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcular la puntuación total para un estudiante basada en las puntuaciones en diferentes materias.\n *\n * Parámetros:\n * - subject_scores (list): Una lista que contiene las puntuaciones para cada materia.\n *\n * Retorna:\n *   int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n *\n * Ejemplos:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * حساب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n *\n * المعلمات:\n * - subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n *\n * العوائد:\n *   int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n *\n * أمثلة:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n *\n * Vigezo:\n * - subject_scores (list): Orodha inayojumuisha alama za kila somo.\n *\n * Inarejesha:\n *   int: Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n *\n * Mifano:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Farklı derslerdeki puanlara göre bir öğrencinin toplam puanını hesaplayın.\n *\n * Parametreler:\n * - subject_scores (list): Her ders için puanları içeren bir liste.\n *\n * Döndürür:\n *   int: Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n *\n * Örnekler:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n *\n * Tham số:\n * - subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n *\n * Trả về:\n *   int: Tổng điểm đạt được bằng cách cộng điểm số trong tất cả các môn học.\n *\n * Ví dụ:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)"
    },
    "prompt_bertscore": {
      "es": "0.9927460184846059",
      "arb": "0.9927460184846059",
      "sw": "0.9893657266601542",
      "tr": "0.9865564971811778",
      "vi": "0.9876872999404094"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` para resolver el siguiente problema:\nCalcular la puntuación total de un estudiante basada en las puntuaciones en diferentes materias.\n\nParámetros:\n- score1 (int): La puntuación para la primera materia.\n- score2 (int): La puntuación para la segunda materia.\n- score3 (int): La puntuación para la tercera materia.\n- score4 (int): La puntuación para la cuarta materia.\n- score5 (int): La puntuación para la quinta materia.\n\nDevuelve:\n  int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n\nEjemplos:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "arb": "اكتب دالة CPP `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` لحل المشكلة التالية:\nاحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n\nالمعلمات:\n- score1 (int): الدرجة للموضوع الأول.\n- score2 (int): الدرجة للموضوع الثاني.\n- score3 (int): الدرجة للموضوع الثالث.\n- score4 (int): الدرجة للموضوع الرابع.\n- score5 (int): الدرجة للموضوع الخامس.\n\nالإرجاع:\n  int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n\nأمثلة:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "sw": "Andika kazi ya CPP `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` kutatua tatizo lifuatalo:\nHesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n\nVigezo:\n- score1 (int): Alama kwa somo la kwanza.\n- score2 (int): Alama kwa somo la pili.\n- score3 (int): Alama kwa somo la tatu.\n- score4 (int): Alama kwa somo la nne.\n- score5 (int): Alama kwa somo la tano.\n\nInarejesha:\n  int: Jumla ya alama inayopatikana kwa kujumlisha alama katika masomo yote.\n\nMifano:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "tr": "Bir CPP fonksiyonu `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` yazarak aşağıdaki problemi çözün:\nFarklı derslerdeki puanlara dayalı olarak bir öğrencinin toplam puanını hesaplayın.\n\nParametreler:\n- score1 (int): Birinci dersin puanı.\n- score2 (int): İkinci dersin puanı.\n- score3 (int): Üçüncü dersin puanı.\n- score4 (int): Dördüncü dersin puanı.\n- score5 (int): Beşinci dersin puanı.\n\nDöndürür:\n  int: Tüm derslerdeki puanların toplamını alarak elde edilen toplam puan.\n\nÖrnekler:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "vi": "Viết một hàm CPP `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` để giải quyết vấn đề sau:\nTính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n\nTham số:\n- score1 (int): Điểm số cho môn học thứ nhất.\n- score2 (int): Điểm số cho môn học thứ hai.\n- score3 (int): Điểm số cho môn học thứ ba.\n- score4 (int): Điểm số cho môn học thứ tư.\n- score5 (int): Điểm số cho môn học thứ năm.\n\nTrả về:\n  int: Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n\nVí dụ:\n  >>> calculate_total_score(100,100,100,100,100)\n  500"
    },
    "instruction_bertscore": {
      "es": "0.9924357578294294",
      "arb": "0.9775813834141163",
      "sw": "0.977801664506684",
      "tr": "0.969398606237003",
      "vi": "0.9768144715129407"
    },
    "level": "easy",
    "test": "int main() {\n    assert(calculate_total_score(100,100,100,100,100) == 500);\n    assert(calculate_total_score(0,0,0,0,0) == 0);\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150);\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236);\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25);\n    return 0;\n}",
    "entry_point": "calculate_total_score",
    "signature": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
    "docstring": {
      "es": "Calcular la puntuación total para un estudiante basado en las puntuaciones en diferentes materias.\n\nParámetros:\n- score1 (int): La puntuación para la primera materia.\n- score2 (int): La puntuación para la segunda materia.\n- score3 (int): La puntuación para la tercera materia.\n- score4 (int): La puntuación para la cuarta materia.\n- score5 (int): La puntuación para la quinta materia.\n\nDevuelve:\n  int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n\nEjemplos:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "arb": "احسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n\nالمعلمات:\n- score1 (int): الدرجة للموضوع الأول.\n- score2 (int): الدرجة للموضوع الثاني.\n- score3 (int): الدرجة للموضوع الثالث.\n- score4 (int): الدرجة للموضوع الرابع.\n- score5 (int): الدرجة للموضوع الخامس.\n\nالقيم المعادة:\n  int: المجموع الكلي للدرجات الناتج عن جمع الدرجات في جميع المواد.\n\nأمثلة:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "sw": "Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n\nVigezo:\n- score1 (int): Alama ya somo la kwanza.\n- score2 (int): Alama ya somo la pili.\n- score3 (int): Alama ya somo la tatu.\n- score4 (int): Alama ya somo la nne.\n- score5 (int): Alama ya somo la tano.\n\nInarejesha:\n  int: Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n\nMifano:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "tr": "Bir öğrencinin farklı derslerdeki puanlarına göre toplam puanını hesaplayın.\n\nParametreler:\n- score1 (int): Birinci dersin puanı.\n- score2 (int): İkinci dersin puanı.\n- score3 (int): Üçüncü dersin puanı.\n- score4 (int): Dördüncü dersin puanı.\n- score5 (int): Beşinci dersin puanı.\n\nDöndürür:\n  int: Tüm derslerdeki puanların toplamıyla elde edilen toplam puan.\n\nÖrnekler:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "vi": "Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n\nTham số:\n- score1 (int): Điểm số cho môn học thứ nhất.\n- score2 (int): Điểm số cho môn học thứ hai.\n- score3 (int): Điểm số cho môn học thứ ba.\n- score4 (int): Điểm số cho môn học thứ tư.\n- score5 (int): Điểm số cho môn học thứ năm.\n\nTrả về:\n  int: Tổng điểm đạt được bằng cách cộng điểm số trong tất cả các môn học.\n\nVí dụ:\n  >>> calculate_total_score(100,100,100,100,100)\n  500"
    },
    "docstring_bertscore": {
      "es": "0.9978694905330198",
      "arb": "0.9682727692372973",
      "sw": "0.9663194380702003",
      "tr": "0.9527003459945431",
      "vi": "0.9730631381367157"
    }
  },
  {
    "task_id": "CPP/14",
    "prompt": {
      "es": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDecodificar una serie de números para revelar el patrón y entender los valores reales \nque representa cada dígito.\n\nEcuaciones proporcionadas como referencia:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una matriz de caracteres constante (cadena de estilo C) que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "arb": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nفك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n\nالمعادلات المقدمة للمرجعية:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: مصفوفة حروف ثابتة (سلسلة نمط C) تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "sw": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nFasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi \nambayo kila tarakimu inawakilisha.\n\nMlinganyo uliotolewa kwa kumbukumbu:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Safu ya tabia ya mara kwa mara (kamba ya mtindo wa C) inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "tr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nBir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n\nReferans için sağlanan denklemler:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden sabit karakter dizisi (C tarzı string). Uzunluk 100'ü geçmez.\n\nDöndürülen:\nint: Her bir veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "vi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nGiải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực tế mà mỗi chữ số đại diện.\n\nCác phương trình được cung cấp để tham khảo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một mảng ký tự hằng số (chuỗi kiểu C) đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)"
    },
    "prompt_bertscore": {
      "es": "0.9855687082962913",
      "arb": "0.9747888388871468",
      "sw": "0.9749056335511953",
      "tr": "0.9688501877549657",
      "vi": "0.9767519029429146"
    },
    "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}",
    "instruction": {
      "es": "Escriba una función CPP `int decode_numbers(const char* data_str)` para resolver el siguiente problema:\nDecodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n\nEcuaciones proporcionadas como referencia:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Un arreglo de caracteres constante (cadena estilo C) que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);",
      "arb": "اكتب دالة CPP `int decode_numbers(const char* data_str)` لحل المشكلة التالية:\nفك شفرة سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n\nالمعادلات المقدمة للمرجعية:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعطيات:\n- data_str: مصفوفة حروف ثابتة (سلسلة نمط C) تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);",
      "sw": "Andika kazi ya CPP `int decode_numbers(const char* data_str)` kutatua tatizo lifuatalo:\nFasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n\nMlinganyo uliotolewa kwa marejeleo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Mfululizo wa herufi za tabia (C-style string) unaowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila mfululizo wa data yanayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);",
      "tr": "Bir CPP fonksiyonu `int decode_numbers(const char* data_str)` yazın ve aşağıdaki problemi çözün:\nBir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n\nReferans için verilen denklemler:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden sabit karakter dizisi (C tarzı string). Uzunluğu 100'ü geçmez.\n\nDöndürülen:\nint: Denklemin sağ tarafına karşılık gelen her bir veri dizisinin sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);",
      "vi": "Viết một hàm CPP `int decode_numbers(const char* data_str)` để giải quyết vấn đề sau:\nGiải mã một chuỗi các số để khám phá mẫu và hiểu giá trị thực mà mỗi chữ số đại diện.\n\nCác phương trình được cung cấp để tham khảo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một mảng ký tự hằng (chuỗi kiểu C) đại diện cho một chuỗi các số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "instruction_bertscore": {
      "es": "0.9849120362565899",
      "arb": "0.9664533149470177",
      "sw": "0.9650088748161321",
      "tr": "0.9574644956836649",
      "vi": "0.9654518205658398"
    },
    "level": "easy",
    "test": "int main() {\n    // Assert basic provided test cases\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "decode_numbers",
    "signature": "int decode_numbers(const char* data_str)",
    "docstring": {
      "es": "Decodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n\nEcuaciones proporcionadas como referencia:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Un arreglo de caracteres constante (cadena estilo C) que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);",
      "arb": "فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n\nالمعادلات المقدمة للمرجعية:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: مصفوفة حرفية ثابتة (سلسلة نمط C) تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);",
      "sw": "Fasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n\nMlinganyo uliotolewa kwa kumbukumbu:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Safu ya tabia isiyobadilika (mfuatano wa herufi wa mtindo wa C) inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila mfuatano wa data yanayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);",
      "tr": "Bir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n\nReferans için sağlanan denklemler:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden sabit karakter dizisi (C tarzı string). Uzunluk 100'ü geçmez.\n\nDöndürülenler:\nint: Her veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);",
      "vi": "Giải mã một chuỗi số để lộ ra mô hình và hiểu các giá trị thực mà mỗi chữ số đại diện.\n\nCác phương trình được cung cấp để tham khảo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một mảng ký tự hằng số (chuỗi kiểu C) đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "docstring_bertscore": {
      "es": "0.9826945266827164",
      "arb": "0.9644187439540773",
      "sw": "0.9624036387384785",
      "tr": "0.9458615019755119",
      "vi": "0.9762219570863135"
    }
  },
  {
    "task_id": "CPP/15",
    "prompt": {
      "es": "#include <cassert>\n#include <iostream>\n/**\n * Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores,\n * considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\n * deben tener colores diferentes.\n * \n * @param n El número de cuadrados.\n * @param m El número de colores.\n * @return La cuenta de diferentes métodos de coloreado que satisfacen las condiciones especificadas.\n *         El resultado es módulo 1000003.\n *\n * Ejemplos:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2\n */\nint count_coloring_methods(int n, int m)",
      "arb": "#include <cassert>\n#include <iostream>\n/**\n * يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان،\n * مع مراعاة الشرط الذي ينص على أن المربعات المتجاورة والمربعات الأولى/الأخيرة\n * يجب أن تكون بألوان مختلفة.\n * \n * @param n عدد المربعات.\n * @param m عدد الألوان.\n * @return عدد طرق التلوين المختلفة التي تلبي الشروط المحددة.\n *         النتيجة تكون موديولو 1000003.\n *\n * أمثلة:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2\n */\nint count_coloring_methods(int n, int m)",
      "sw": "#include <cassert>\n#include <iostream>\n/**\n * Inahesabu idadi ya mbinu tofauti za kupaka rangi miraba n kwa rangi m,\n * kwa kuzingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/mwisho\n * lazima iwe na rangi tofauti.\n * \n * @param n Idadi ya miraba.\n * @param m Idadi ya rangi.\n * @return Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa.\n *         Matokeo ni modulo 1000003.\n *\n * Mifano:\n * count_coloring_methods(1,1) inarudisha 1\n * count_coloring_methods(2,2) inarudisha 2\n */\nint count_coloring_methods(int n, int m)",
      "tr": "#include <cassert>\n#include <iostream>\n/**\n * n kare için m renk ile farklı boyama yöntemlerinin sayısını,\n * bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması\n * gerekliliğini göz önünde bulundurarak sayar.\n * \n * @param n Kare sayısı.\n * @param m Renk sayısı.\n * @return Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\n *         Sonuç 1000003 ile mod alınmıştır.\n *\n * Örnekler:\n * count_coloring_methods(1,1) 1 döndürür\n * count_coloring_methods(2,2) 2 döndürür\n */\nint count_coloring_methods(int n, int m)",
      "vi": "#include <cassert>\n#include <iostream>\n/**\n * Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\n * xem xét yêu cầu rằng các ô vuông liền kề và ô đầu/cuối\n * phải có màu khác nhau.\n * \n * @param n Số lượng ô vuông.\n * @param m Số lượng màu.\n * @return Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định.\n *         Kết quả được lấy modulo 1000003.\n *\n * Ví dụ:\n * count_coloring_methods(1,1) trả về 1\n * count_coloring_methods(2,2) trả về 2\n */\nint count_coloring_methods(int n, int m)"
    },
    "prompt_bertscore": {
      "es": "0.9952443914172627",
      "arb": "0.9710577658097875",
      "sw": "0.9673987955607438",
      "tr": "0.9811853330476134",
      "vi": "0.976566183536647"
    },
    "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}",
    "instruction": {
      "es": "Escribe una función CPP `int count_coloring_methods(int n, int m)` para resolver el siguiente problema:\nCuenta el número de diferentes métodos de coloreo para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n\n@param n El número de cuadrados.\n@param m El número de colores.\n@return La cuenta de diferentes métodos de coloreo que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n\nEjemplos:\ncount_coloring_methods(1,1) devuelve 1\ncount_coloring_methods(2,2) devuelve 2",
      "arb": "اكتب دالة CPP `int count_coloring_methods(int n, int m)` لحل المشكلة التالية:\nتحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان، مع مراعاة الشرط بأن المربعات المتجاورة والمربعين الأول والأخير يجب أن تكون بألوان مختلفة.\n\n@param n عدد المربعات.\n@param m عدد الألوان.\n@return عدد طرق التلوين المختلفة التي تلبي الشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n\nأمثلة:\ncount_coloring_methods(1,1) يعيد 1\ncount_coloring_methods(2,2) يعيد 2",
      "sw": "Andika kazi ya CPP `int count_coloring_methods(int n, int m)` kutatua tatizo lifuatalo:\nInahesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n na rangi m, kwa kuzingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho lazima iwe na rangi tofauti.\n\n@param n Idadi ya miraba.\n@param m Idadi ya rangi.\n@return Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa. Matokeo ni modulo 1000003.\n\nMifano:\ncount_coloring_methods(1,1) inarudisha 1\ncount_coloring_methods(2,2) inarudisha 2",
      "tr": "Bir CPP fonksiyonu `int count_coloring_methods(int n, int m)` yazın ve aşağıdaki problemi çözün:\nn kareyi m renkle boyamak için farklı boyama yöntemlerinin sayısını hesaplar, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını göz önünde bulundurarak.\n\n@param n Karelerin sayısı.\n@param m Renklerin sayısı.\n@return Belirtilen koşulları sağlayan farklı boyama yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n\nÖrnekler:\ncount_coloring_methods(1,1) 1 döndürür\ncount_coloring_methods(2,2) 2 döndürür",
      "vi": "Viết một hàm CPP `int count_coloring_methods(int n, int m)` để giải quyết vấn đề sau:\nĐếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, với yêu cầu rằng các ô vuông liền kề và các ô đầu/cuối phải có màu khác nhau.\n\n@param n Số lượng ô vuông.\n@param m Số lượng màu sắc.\n@return Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả được lấy modulo 1000003.\n\nVí dụ:\ncount_coloring_methods(1,1) trả về 1\ncount_coloring_methods(2,2) trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9945334932835388",
      "arb": "0.9436954376703265",
      "sw": "0.9616847953895131",
      "tr": "0.9620677547641484",
      "vi": "0.97161869800583"
    },
    "level": "hard",
    "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999, 66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}",
    "entry_point": "count_coloring_methods",
    "signature": "int count_coloring_methods(int n, int m)",
    "docstring": {
      "es": "Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n\n@param n El número de cuadrados.\n@param m El número de colores.\n@return El conteo de diferentes métodos de coloreado que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n\nEjemplos:\ncount_coloring_methods(1,1) returns 1\ncount_coloring_methods(2,2) returns 2",
      "arb": "يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان، مع مراعاة الشرط الذي ينص على أن المربعات المتجاورة والمربعات الأولى/الأخيرة يجب أن تكون بألوان مختلفة.\n\n@param n عدد المربعات.\n@param m عدد الألوان.\n@return عدد طرق التلوين المختلفة التي تفي بالشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n\nأمثلة:\ncount_coloring_methods(1,1) returns 1\ncount_coloring_methods(2,2) returns 2",
      "sw": "Hesabu idadi ya mbinu tofauti za kupaka rangi mraba n kwa rangi m, kwa kuzingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/mwisho lazima iwe na rangi tofauti.\n\n@param n Idadi ya miraba.\n@param m Idadi ya rangi.\n@return Hesabu ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyowekwa. Matokeo ni modulo 1000003.\n\nMifano:\ncount_coloring_methods(1,1) inarudisha 1\ncount_coloring_methods(2,2) inarudisha 2",
      "tr": "Farklı renklendirme yöntemlerinin sayısını, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerekliliğini dikkate alarak, n kare için m renk ile sayar.\n\n@param n Karelerin sayısı.\n@param m Renklerin sayısı.\n@return Belirtilen koşulları karşılayan farklı renklendirme yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n\nÖrnekler:\ncount_coloring_methods(1,1) returns 1\ncount_coloring_methods(2,2) returns 2",
      "vi": "Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và ô vuông đầu tiên/cuối cùng phải có màu khác nhau.\n\n@param n Số lượng ô vuông.\n@param m Số lượng màu sắc.\n@return Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả được lấy modulo 1000003.\n\nVí dụ:\ncount_coloring_methods(1,1) trả về 1\ncount_coloring_methods(2,2) trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9913724893997496",
      "arb": "0.9303141061607682",
      "sw": "0.9522846126070371",
      "tr": "0.9728378912846222",
      "vi": "0.9655443823234021"
    }
  },
  {
    "task_id": "CPP/16",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n *\n * Parámetros:\n * - n (int): El número de lanzamientos de moneda.\n *\n * Devuelve:\n * - unsigned long long: El conteo de secuencias válidas.\n *\n * Ejemplos:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n *\n * المعلمات:\n * - n (int): عدد رميات العملة.\n *\n * يعيد:\n * - unsigned long long: عدد التسلسلات الصحيحة.\n *\n * أمثلة:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha n.\n *\n * Vigezo:\n * - n (int): Idadi ya kurusha sarafu.\n *\n * Inarudisha:\n * - unsigned long long: Hesabu ya mfuatano halali.\n *\n * Mifano:\n *   count_valid_coin_toss_sequences(1) inarudisha 2\n *   count_valid_coin_toss_sequences(2) inarudisha 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ardışık yazı gelmeyen geçerli para atışı dizilerinin sayısını n atışta sayar.\n *\n * Parametreler:\n * - n (int): Para atışlarının sayısı.\n *\n * Döndürür:\n * - unsigned long long: Geçerli dizilerin sayısı.\n *\n * Örnekler:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Đếm số lượng dãy tung đồng xu hợp lệ không có hai mặt ngửa liên tiếp trong n lần tung.\n *\n * Tham số:\n * - n (int): Số lần tung đồng xu.\n *\n * Trả về:\n * - unsigned long long: Số lượng dãy hợp lệ.\n *\n * Ví dụ:\n *   count_valid_coin_toss_sequences(1) trả về 2\n *   count_valid_coin_toss_sequences(2) trả về 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9958746456162864",
      "arb": "0.9832020273062605",
      "sw": "0.957909030476421",
      "tr": "0.9940643283235344",
      "vi": "0.9885471708599094"
    },
    "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}",
    "instruction": {
      "es": "Escribe una función CPP `unsigned long long count_valid_coin_toss_sequences(int n)` para resolver el siguiente problema:\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n\nParámetros:\n- n (int): El número de lanzamientos de moneda.\n\nDevuelve:\n- unsigned long long: La cuenta de secuencias válidas.\n\nEjemplos:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "arb": "اكتب دالة CPP `unsigned long long count_valid_coin_toss_sequences(int n)` لحل المشكلة التالية:\nاحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n\nالمعطيات:\n- n (int): عدد رميات العملة.\n\nالقيم المعادة:\n- unsigned long long: عدد التسلسلات الصحيحة.\n\nأمثلة:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "sw": "Andika kazi ya CPP `unsigned long long count_valid_coin_toss_sequences(int n)` kutatua tatizo lifuatalo:\nHesabu idadi ya mfuatano sahihi wa kurusha sarafu bila vichwa mfululizo katika kurusha n.\n\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\n\nInarudisha:\n- unsigned long long: Idadi ya mfuatano sahihi.\n\nMifano:\n  count_valid_coin_toss_sequences(1) inarudisha 2\n  count_valid_coin_toss_sequences(2) inarudisha 3",
      "tr": "Bir CPP fonksiyonu `unsigned long long count_valid_coin_toss_sequences(int n)` yazın ve aşağıdaki problemi çözün:\nn atışında ardışık yazı gelmeyen geçerli para atışı dizilerinin sayısını sayın.\n\nParametreler:\n- n (int): Para atışlarının sayısı.\n\nDöndürür:\n- unsigned long long: Geçerli dizilerin sayısı.\n\nÖrnekler:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "vi": "Viết một hàm CPP `unsigned long long count_valid_coin_toss_sequences(int n)` để giải quyết vấn đề sau:\nĐếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n- unsigned long long: Số lượng dãy hợp lệ.\n\nVí dụ:\n  count_valid_coin_toss_sequences(1) trả về 2\n  count_valid_coin_toss_sequences(2) trả về 3"
    },
    "instruction_bertscore": {
      "es": "0.9962450912769165",
      "arb": "0.9711715810181205",
      "sw": "0.9863507161064256",
      "tr": "0.9931667176316378",
      "vi": "0.9885600818346767"
    },
    "level": "easy",
    "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296ULL); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141ULL);\n    assert(count_valid_coin_toss_sequences(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_valid_coin_toss_sequences",
    "signature": "unsigned long long count_valid_coin_toss_sequences(int n)",
    "docstring": {
      "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n\nParámetros:\n- n (int): El número de lanzamientos de moneda.\n\nDevuelve:\n- unsigned long long: El conteo de secuencias válidas.\n\nEjemplos:\n  count_valid_coin_toss_sequences(1) devuelve 2\n  count_valid_coin_toss_sequences(2) devuelve 3",
      "arb": "احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n\nالمعطيات:\n- n (int): عدد رميات العملة.\n\nالقيم المعادة:\n- unsigned long long: عدد التسلسلات الصحيحة.\n\nأمثلة:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha sarafu n.\n\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\n\nInarejesha:\n- unsigned long long: Hesabu ya mfuatano halali.\n\nMifano:\n  count_valid_coin_toss_sequences(1) inarejesha 2\n  count_valid_coin_toss_sequences(2) inarejesha 3",
      "tr": "n atışında ardışık yazı gelmeyen geçerli madeni para atış dizilerinin sayısını sayın.\n\nParametreler:\n- n (int): Madeni para atışlarının sayısı.\n\nDöndürür:\n- unsigned long long: Geçerli dizilerin sayısı.\n\nÖrnekler:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "vi": "Đếm số lượng dãy tung đồng xu hợp lệ mà không có mặt sấp liên tiếp trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n- unsigned long long: Số lượng dãy hợp lệ.\n\nVí dụ:\n  count_valid_coin_toss_sequences(1) trả về 2\n  count_valid_coin_toss_sequences(2) trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.9895401241347028",
      "arb": "0.9619034874390325",
      "sw": "0.9789751727978381",
      "tr": "0.9559622541118981",
      "vi": "0.974886763664997"
    }
  },
  {
    "task_id": "CPP/17",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Encuentra la longitud de la secuencia consecutiva más larga de 1s en la \n * representación binaria de un entero no negativo.\n *\n * Parámetros:\n * - n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n *\n * Devuelve:\n * - int: La longitud de la secuencia consecutiva más larga de 1s en la \n *        representación binaria del entero dado.\n *\n * Ejemplos:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * إيجاد طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n *\n * المعاملات:\n * - n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n *\n * يعيد:\n * - int: طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n *\n * أمثلة:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tafuta urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa \n * binary wa nambari isiyo hasi.\n *\n * Vigezo:\n * - n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n *\n * Inarejesha:\n * - int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa \n *        binary wa nambari iliyotolewa.\n *\n * Mifano:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Bir pozitif olmayan tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin \n * uzunluğunu bulun.\n *\n * Parametreler:\n * - n (unsigned long long): Pozitif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n *\n * Döndürür:\n * - int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin \n *        uzunluğu.\n *\n * Örnekler:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tìm độ dài của dãy số 1 liên tiếp dài nhất trong biểu diễn nhị phân \n * của một số nguyên không âm.\n *\n * Tham số:\n * - n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n *\n * Trả về:\n * - int: Độ dài của dãy số 1 liên tiếp dài nhất trong biểu diễn nhị phân \n *        của số nguyên đã cho.\n *\n * Ví dụ:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)"
    },
    "prompt_bertscore": {
      "es": "0.9915371539856276",
      "arb": "0.9866862028199935",
      "sw": "0.9791807552422093",
      "tr": "0.9914360511216808",
      "vi": "0.9984842515623228"
    },
    "canonical_solution": "{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int find_longest_consecutive_ones_length(unsigned long long n)` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n\nParámetros:\n- n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n- int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n\nEjemplos:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "arb": "اكتب دالة CPP `int find_longest_consecutive_ones_length(unsigned long long n)` لحل المشكلة التالية:\nابحث عن طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعاملات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\n- int: طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n\nأمثلة:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "sw": "Andika kazi ya CPP `int find_longest_consecutive_ones_length(unsigned long long n)` kutatua tatizo lifuatalo:\nPata urefu wa mlolongo mrefu zaidi wa mfululizo wa 1 katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\n- int: Urefu wa mlolongo mrefu zaidi wa mfululizo wa 1 katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "tr": "Bir CPP fonksiyonu `int find_longest_consecutive_ones_length(unsigned long long n)` yazın ve aşağıdaki problemi çözün:\nBir negatif olmayan bir tam sayının ikili gösteriminde en uzun ardışık 1'ler dizisinin uzunluğunu bulun.\n\nParametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürür:\n- int: Verilen tam sayının ikili gösteriminde en uzun ardışık 1'ler dizisinin uzunluğu.\n\nÖrnekler:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "vi": "Viết một hàm CPP `int find_longest_consecutive_ones_length(unsigned long long n)` để giải quyết vấn đề sau:\nTìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n- int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\n  >>> find_longest_consecutive_ones_length(7)\n  3"
    },
    "instruction_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9952082406879144",
      "sw": "0.9751269077956682",
      "tr": "0.9968244960983953",
      "vi": "0.9983021075029138"
    },
    "level": "hard",
    "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}",
    "entry_point": "find_longest_consecutive_ones_length",
    "signature": "int find_longest_consecutive_ones_length(unsigned long long n)",
    "docstring": {
      "es": "Encontrar la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n\nParámetros:\n- n (unsigned long long): Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n- int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número entero dado.\n\nEjemplos:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "arb": "إيجاد طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعلمات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\n- int: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n\nأمثلة:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "sw": "Pata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nRudisha:\n- int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "tr": "İkili gösterimdeki bir pozitif olmayan tam sayının ardışık en uzun 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n- n (unsigned long long): Pozitif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürür:\n- int: Verilen tam sayının ikili gösterimindeki ardışık en uzun 1 dizisinin uzunluğu.\n\nÖrnekler:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n- int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\n  >>> find_longest_consecutive_ones_length(7)\n  3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9933335671517071",
      "sw": "0.96572056747138",
      "tr": "1",
      "vi": "0.9978675042292094"
    }
  },
  {
    "task_id": "CPP/18",
    "prompt": {
      "es": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Genera un identificador único entrelazando dos palabras en un patrón especificado.\n * @param word1 La primera palabra que se utilizará en el proceso de creación del ID.\n * @param word2 La segunda palabra que se utilizará en el proceso de creación del ID.\n * @return Un identificador único formado alternando caracteres de la segunda palabra,\n *         invertida, con caracteres de la primera palabra.\n * Ejemplo de uso:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "arb": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * يولد معرفًا فريدًا عن طريق دمج كلمتين في نمط محدد.\n * @param word1 الكلمة الأولى التي ستستخدم في عملية إنشاء المعرف.\n * @param word2 الكلمة الثانية التي ستستخدم في عملية إنشاء المعرف.\n * @return معرف فريد يتكون من تبديل الأحرف من الكلمة الثانية،\n *         معكوسة، مع الأحرف من الكلمة الأولى.\n * مثال على الاستخدام:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "sw": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Hutoa kitambulisho cha kipekee kwa kuchanganya maneno mawili kwa mtindo maalum.\n * @param word1 Neno la kwanza litakalotumika katika mchakato wa kuunda kitambulisho.\n * @param word2 Neno la pili litakalotumika katika mchakato wa kuunda kitambulisho.\n * @return Kitambulisho cha kipekee kinachoundwa kwa kubadilisha herufi kutoka neno la pili,\n *         lililogeuzwa, na herufi kutoka neno la kwanza.\n * Mfano wa Matumizi:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "tr": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * İki kelimeyi belirli bir desende iç içe geçirerek benzersiz bir kimlik oluşturur.\n * @param word1 Kimlik oluşturma sürecinde kullanılacak birinci kelime.\n * @param word2 Kimlik oluşturma sürecinde kullanılacak ikinci kelime.\n * @return İkinci kelimenin ters çevrilmiş karakterleri ile birinci kelimenin karakterlerinin\n *         dönüşümlü olarak kullanılmasıyla oluşturulan benzersiz bir kimlik.\n * Örnek Kullanım:\n * \n * create_id(\"fish\", \"cat\") \"ftiasch\" döndürür\n * create_id(\"icpc\", \"acm\") \"imccpac\" döndürür\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "vi": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Tạo một định danh duy nhất bằng cách xen kẽ hai từ theo một mẫu được chỉ định.\n * @param word1 Từ đầu tiên được sử dụng trong quá trình tạo ID.\n * @param word2 Từ thứ hai được sử dụng trong quá trình tạo ID.\n * @return Một định danh duy nhất được tạo ra bằng cách xen kẽ các ký tự từ từ thứ hai,\n *         đảo ngược, với các ký tự từ từ đầu tiên.\n * Ví dụ sử dụng:\n * \n * create_id(\"fish\", \"cat\") trả về \"ftiasch\"\n * create_id(\"icpc\", \"acm\") trả về \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)"
    },
    "prompt_bertscore": {
      "es": "0.9909784067237765",
      "arb": "0.9725079662217232",
      "sw": "0.9611925893053087",
      "tr": "0.9629083585366881",
      "vi": "0.9657469853120577"
    },
    "canonical_solution": "{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}",
    "instruction": {
      "es": "Escribe una función CPP `std::string create_id(const std::string& word1, const std::string& word2)` para resolver el siguiente problema:\nGenera un identificador único entrelazando dos palabras en un patrón especificado.\n@param word1 La primera palabra a utilizar en el proceso de creación del ID.\n@param word2 La segunda palabra a utilizar en el proceso de creación del ID.\n@return Un identificador único formado alternando caracteres de la segunda palabra, invertida, con caracteres de la primera palabra.\nEjemplo de uso:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "arb": "اكتب دالة CPP `std::string create_id(const std::string& word1, const std::string& word2)` لحل المشكلة التالية:\nتوليد معرف فريد عن طريق تشابك كلمتين بنمط محدد.\n@param word1 الكلمة الأولى التي ستستخدم في عملية إنشاء المعرف.\n@param word2 الكلمة الثانية التي ستستخدم في عملية إنشاء المعرف.\n@return معرف فريد يتكون من تناوب الأحرف من الكلمة الثانية، معكوسة، مع الأحرف من الكلمة الأولى.\nمثال على الاستخدام:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "sw": "Andika kazi ya CPP `std::string create_id(const std::string& word1, const std::string& word2)` kutatua tatizo lifuatalo:\nHutengeneza kitambulisho cha kipekee kwa kuchanganya maneno mawili katika mpangilio maalum.\n@param word1 Neno la kwanza litakalotumika katika mchakato wa utengenezaji wa kitambulisho.\n@param word2 Neno la pili litakalotumika katika mchakato wa utengenezaji wa kitambulisho.\n@return Kitambulisho cha kipekee kinachoundwa kwa kubadilisha herufi kutoka neno la pili, lililogeuzwa, na herufi kutoka neno la kwanza.\nMfano wa Matumizi:\n\ncreate_id(\"fish\", \"cat\") inarudisha \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") inarudisha \"imccpac\"",
      "tr": "Bir CPP fonksiyonu `std::string create_id(const std::string& word1, const std::string& word2)` yazın ve aşağıdaki problemi çözün:\nBelirli bir desende iki kelimeyi iç içe geçirerek benzersiz bir tanımlayıcı oluşturur.\n@param word1 ID oluşturma sürecinde kullanılacak ilk kelime.\n@param word2 ID oluşturma sürecinde kullanılacak ikinci kelime.\n@return İkinci kelimenin ters çevrilmiş karakterleriyle birinci kelimenin karakterlerinin dönüşümlü olarak birleştirilmesiyle oluşturulan benzersiz bir tanımlayıcı.\nÖrnek Kullanım:\n\ncreate_id(\"fish\", \"cat\") \"ftiasch\" döndürür\ncreate_id(\"icpc\", \"acm\") \"imccpac\" döndürür",
      "vi": "Viết một hàm CPP `std::string create_id(const std::string& word1, const std::string& word2)` để giải quyết vấn đề sau:\nTạo một định danh duy nhất bằng cách xen kẽ hai từ theo một mẫu được chỉ định.\n@param word1 Từ đầu tiên được sử dụng trong quá trình tạo ID.\n@param word2 Từ thứ hai được sử dụng trong quá trình tạo ID.\n@return Một định danh duy nhất được tạo thành bằng cách xen kẽ các ký tự từ từ thứ hai, đảo ngược, với các ký tự từ từ đầu tiên.\nVí dụ Sử Dụng:\n\ncreate_id(\"fish\", \"cat\") trả về \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") trả về \"imccpac\""
    },
    "instruction_bertscore": {
      "es": "0.984161014785897",
      "arb": "0.9785068023593578",
      "sw": "0.9549792323561563",
      "tr": "0.9612499934854278",
      "vi": "0.9600931701462806"
    },
    "level": "hard",
    "test": "int main() {\n    std::string id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = create_id(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = create_id(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "create_id",
    "signature": "std::string create_id(const std::string& word1, const std::string& word2)",
    "docstring": {
      "es": "Genera un identificador único entrelazando dos palabras en un patrón especificado.\n@param word1 La primera palabra que se utilizará en el proceso de creación del ID.\n@param word2 La segunda palabra que se utilizará en el proceso de creación del ID.\n@return Un identificador único formado alternando caracteres de la segunda palabra, invertida, con caracteres de la primera palabra.\nEjemplo de uso:\n\ncreate_id(\"fish\", \"cat\") devuelve \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") devuelve \"imccpac\"",
      "arb": "ينشئ معرفًا فريدًا عن طريق تشابك كلمتين بنمط محدد.\n@param word1 الكلمة الأولى التي سيتم استخدامها في عملية إنشاء المعرف.\n@param word2 الكلمة الثانية التي سيتم استخدامها في عملية إنشاء المعرف.\n@return معرف فريد يتكون من تبديل الأحرف من الكلمة الثانية، معكوسة، مع الأحرف من الكلمة الأولى.\nمثال على الاستخدام:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "sw": "Hutengeneza kitambulisho cha kipekee kwa kuchanganya maneno mawili kwa mpangilio maalum.\n@param word1 Neno la kwanza litakalotumika katika mchakato wa kuunda kitambulisho.\n@param word2 Neno la pili litakalotumika katika mchakato wa kuunda kitambulisho.\n@return Kitambulisho cha kipekee kinachoundwa kwa kubadilishana herufi kutoka neno la pili, lililogeuzwa, na herufi kutoka neno la kwanza.\nMfano wa Matumizi:\n\ncreate_id(\"fish\", \"cat\") inarudisha \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") inarudisha \"imccpac\"",
      "tr": "İki kelimeyi belirtilen bir desende iç içe geçirerek benzersiz bir tanımlayıcı oluşturur.\n@param word1 Kimlik oluşturma sürecinde kullanılacak ilk kelime.\n@param word2 Kimlik oluşturma sürecinde kullanılacak ikinci kelime.\n@return İkinci kelimenin karakterlerinin ters çevrilmiş hali ile birinci kelimenin karakterlerinin dönüşümlü olarak kullanılmasıyla oluşturulan benzersiz bir tanımlayıcı.\nÖrnek Kullanım:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "vi": "Tạo một định danh duy nhất bằng cách xen kẽ hai từ theo một mẫu được chỉ định.\n@param word1 Từ đầu tiên được sử dụng trong quá trình tạo ID.\n@param word2 Từ thứ hai được sử dụng trong quá trình tạo ID.\n@return Một định danh duy nhất được tạo bằng cách xen kẽ các ký tự từ từ thứ hai, đảo ngược, với các ký tự từ từ đầu tiên.\nVí dụ Sử dụng:\n\ncreate_id(\"fish\", \"cat\") trả về \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") trả về \"imccpac\""
    },
    "docstring_bertscore": {
      "es": "0.9903102141219751",
      "arb": "0.9684471667118459",
      "sw": "0.929163241733052",
      "tr": "0.9460996598023728",
      "vi": "0.9403479198587454"
    }
  },
  {
    "task_id": "CPP/19",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\n * donde el número de '1's es m y el número de '0's es n - m.\n * \n * Parámetros:\n * - n (int): Longitud de la cadena binaria.\n * - m (int): Número de '1's en la cadena binaria.\n * \n * Devuelve:\n * - int: El número total de diferentes esquemas de permutación.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\n * حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n * \n * المعلمات:\n * - n (int): طول السلسلة الثنائية.\n * - m (int): عدد '1's في السلسلة الثنائية.\n * \n * يعيد:\n * - int: العدد الإجمالي لمخططات التبديل المختلفة.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu idadi ya mipango tofauti ya upangaji kwa kamba ya binary ya urefu n,\n * ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n * \n * Vigezo:\n * - n (int): Urefu wa kamba ya binary.\n * - m (int): Idadi ya '1's katika kamba ya binary.\n * \n * Inarudisha:\n * - int: Jumla ya idadi ya mipango tofauti ya upangaji.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Uzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu\n * farklı permütasyon düzenlerinin sayısını sayar.\n * \n * Parametreler:\n * - n (int): İkili dizginin uzunluğu.\n * - m (int): İkili dizgideki '1'lerin sayısı.\n * \n * Döndürür:\n * - int: Farklı permütasyon düzenlerinin toplam sayısı.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\n * trong đó số lượng '1' là m và số lượng '0' là n - m.\n * \n * Tham số:\n * - n (int): Độ dài của chuỗi nhị phân.\n * - m (int): Số lượng '1' trong chuỗi nhị phân.\n * \n * Trả về:\n * - int: Tổng số lượng các sơ đồ hoán vị khác nhau.\n */\nint count_permutations_of_binary_string(int n, int m)"
    },
    "prompt_bertscore": {
      "es": "0.9965648861903826",
      "arb": "0.991681955533402",
      "sw": "0.9831275409133725",
      "tr": "0.9516327076964806",
      "vi": "0.9975139421509673"
    },
    "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}",
    "instruction": {
      "es": "Escribe una función CPP `int count_permutations_of_binary_string(int n, int m)` para resolver el siguiente problema:\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n\nDevuelve:\n- int: El número total de diferentes esquemas de permutación.",
      "arb": "اكتب دالة CPP `int count_permutations_of_binary_string(int n, int m)` لحل المشكلة التالية:\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n\nيعيد:\n- int: العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Andika kazi ya CPP `int count_permutations_of_binary_string(int n, int m)` kutatua tatizo lifuatalo:\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n\nRudisha:\n- int: Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "Bir CPP fonksiyonu `int count_permutations_of_binary_string(int n, int m)` yazın ve aşağıdaki problemi çözün:\nUzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n- n (int): İkili dizginin uzunluğu.\n- m (int): İkili dizgideki '1'lerin sayısı.\n\nDöndürür:\n- int: Farklı permütasyon şemalarının toplam sayısı.",
      "vi": "Viết một hàm CPP `int count_permutations_of_binary_string(int n, int m)` để giải quyết vấn đề sau:\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\n- int: Tổng số các sơ đồ hoán vị khác nhau."
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9890749317823191",
      "sw": "0.9883644309093573",
      "tr": "0.9824229989518417",
      "vi": "0.9975334079283088"
    },
    "level": "hard",
    "test": "int main() {\n    assert(count_permutations_of_binary_string(2, 0) == 2);\n    assert(count_permutations_of_binary_string(2, 1) == 0);\n    assert(count_permutations_of_binary_string(3, 0) == 0);\n    assert(count_permutations_of_binary_string(3, 1) == 3);\n    assert(count_permutations_of_binary_string(3, 2) == 0);\n    assert(count_permutations_of_binary_string(30, 2) == 145422675);\n    assert(count_permutations_of_binary_string(4, 2) == 4);\n    assert(count_permutations_of_binary_string(5, 5) == 1);\n    assert(count_permutations_of_binary_string(33, 17) == 13884156);\n    assert(count_permutations_of_binary_string(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}",
    "entry_point": "count_permutations_of_binary_string",
    "signature": "int count_permutations_of_binary_string(int n, int m)",
    "docstring": {
      "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n\nDevuelve:\n- int: El número total de diferentes esquemas de permutación.",
      "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n\nالقيم المعادة:\n- int: العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n\nRudisha:\n- int: Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "İkili bir dizgenin uzunluğu n, '1'lerin sayısı m ve '0'ların sayısı n - m olduğunda, farklı permütasyon şemalarının sayısını hesaplayın.\n\nParametreler:\n- n (int): İkili dizgenin uzunluğu.\n- m (int): İkili dizgedeki '1'lerin sayısı.\n\nDöndürür:\n- int: Farklı permütasyon şemalarının toplam sayısı.",
      "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\n- int: Tổng số lượng các sơ đồ hoán vị khác nhau."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9806355241529088",
      "sw": "0.9843423643237819",
      "tr": "0.9472394009287509",
      "vi": "0.9963597010067736"
    }
  },
  {
    "task_id": "CPP/20",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n *  \n *  Pregunta 1:\n *  ¿Constantes como 1e6 pertenecen a qué tipo de dato?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Pregunta 2:\n *  Dado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Ninguna de las anteriores\n *  \n *  Pregunta 3:\n *  ¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n *      A. Las expresiones de nombres de variables son valores a la izquierda.\n *      B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n *      C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n *      D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n *  \n *  Pregunta 4:\n *  ¿Cuál afirmación sobre las funciones es incorrecta?\n *      A. Los parámetros formales de una función son variables locales.\n *      B. Las variables locales se asignan espacio en la pila.\n *      C. El tipo de la función es el mismo que el tipo del valor de retorno.\n *      D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n *  \n *  Pregunta 5:\n *  ¿Cuál afirmación sobre los punteros es incorrecta?\n *      A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n *      B. La desreferencia de punteros implica resolver según el tipo del puntero.\n *      C. int *p[4], p es un arreglo de punteros a int.\n *      D. Los nombres de funciones pueden asignarse a punteros de funciones.\n *  \n *  Se supone que debes devolver solo cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n */\nconst char* answer_questions()",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  أجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\n *  \n *  السؤال 1:\n *  الثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  السؤال 2:\n *  بالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n *      A. int\n *      B. long long\n *      C. double\n *      D. لا شيء مما سبق\n *  \n *  السؤال 3:\n *  أي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n *      A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n *      B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n *      C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n *      D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\n *  \n *  السؤال 4:\n *  أي عبارة عن الدوال غير صحيحة؟\n *      A. المعاملات الشكلية للدالة هي متغيرات محلية.\n *      B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n *      C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n *      D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n *  \n *  السؤال 5:\n *  أي عبارة عن المؤشرات غير صحيحة؟\n *      A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n *      B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n *      C. int *p[4], p هو مصفوفة من مؤشرات int.\n *      D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n *  \n *  من المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل خيارات السؤال.\n */\nconst char* answer_questions()",
      "sw": "```c\n#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Jibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n *  \n *  Swali la 1:\n *  Vigezo kama 1e6 vinahusiana na aina gani ya data?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Swali la 2:\n *  Ukipewa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Hakuna kati ya hizi\n *  \n *  Swali la 3:\n *  Ni kauli gani kuhusu thamani za kushoto katika maelezo sio sahihi?\n *      A. Maelezo ya majina ya vigezo ni thamani za kushoto.\n *      B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n *      C. Maelezo ya kufuta pointer ni thamani za kushoto.\n *      D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n *  \n *  Swali la 4:\n *  Ni kauli gani kuhusu kazi sio sahihi?\n *      A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n *      B. Vigezo vya ndani vinapewa nafasi kwenye stack.\n *      C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n *      D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n *  \n *  Swali la 5:\n *  Ni kauli gani kuhusu pointers sio sahihi?\n *      A. Kutoa mbili pointers ni sawa na tofauti katika thamani za anwani zao.\n *      B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n *      C. int *p[4], p ni safu ya pointers za int.\n *      D. Majina ya kazi yanaweza kupewa pointers za kazi.\n *  \n *  Unatakiwa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.\n */\nconst char* answer_questions()\n```",
      "tr": "```c\n#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Her bir soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\n *  \n *  Soru 1:\n *  1e6 gibi sabitler hangi veri türüne aittir?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Soru 2:\n *  21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Yukarıdakilerin hiçbiri\n *  \n *  Soru 3:\n *  İfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n *      A. Değişken adı ifadeleri sol değerlerdir.\n *      B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n *      C. Pointer çözme ifadeleri sol değerlerdir.\n *      D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n *  \n *  Soru 4:\n *  Fonksiyonlar hakkında hangi ifade yanlıştır?\n *      A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n *      B. Yerel değişkenler yığında yer kaplar.\n *      C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n *      D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\n *  \n *  Soru 5:\n *  Pointerlar hakkında hangi ifade yanlıştır?\n *      A. İki pointerın çıkarılması, adres değerlerindeki farkı eşittir.\n *      B. Pointer çözme, pointer türüne göre çözümlemeyi içerir.\n *      C. int *p[4], p bir int pointerları dizisidir.\n *      D. Fonksiyon isimleri, fonksiyon pointerlarına atanabilir.\n *  \n *  Soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz bekleniyor.\n */\nconst char* answer_questions()\n```",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n *  \n *  Câu hỏi 1:\n *  Hằng số như 1e6 thuộc kiểu dữ liệu nào?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Câu hỏi 2:\n *  Cho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Không có lựa chọn nào ở trên\n *  \n *  Câu hỏi 3:\n *  Câu nào về giá trị bên trái trong biểu thức là không đúng?\n *      A. Biểu thức tên biến là giá trị bên trái.\n *      B. Phép toán tăng yêu cầu toán hạng phải là giá trị bên trái.\n *      C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n *      D. Biểu thức phép toán tăng trước là giá trị bên trái.\n *  \n *  Câu hỏi 4:\n *  Câu nào về hàm là không đúng?\n *      A. Tham số hình thức của hàm là biến cục bộ.\n *      B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n *      C. Kiểu của hàm giống với kiểu giá trị trả về.\n *      D. Một hàm có thể gọi chính nó từ trong thân hàm.\n *  \n *  Câu hỏi 5:\n *  Câu nào về con trỏ là không đúng?\n *      A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n *      B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n *      C. int *p[4], p là một mảng các con trỏ int.\n *      D. Tên hàm có thể được gán cho con trỏ hàm.\n *  \n *  Bạn được yêu cầu chỉ trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.\n */\nconst char* answer_questions()"
    },
    "prompt_bertscore": {
      "es": "0.9634677016896823",
      "arb": "0.9583708461123271",
      "sw": "0.9144206962222615",
      "tr": "0.9492785404204551",
      "vi": "0.9372570324994616"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "es": "Escribe una función CPP `const char* answer_questions()` para resolver el siguiente problema:\nResponde una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguno de los anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo de valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de función.\n\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "اكتب دالة CPP `const char* answer_questions()` لحل المشكلة التالية:\nالإجابة على سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الشكلية للدالة هي متغيرات محلية.\n    B. المتغيرات المحلية يتم تخصيص مساحة لها في المكدس.\n    C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.",
      "sw": "Andika kazi ya CPP `const char* answer_questions()` kutatua tatizo lifuatalo:\nJibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstanti kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\n\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maonyesho si sahihi?\n    A. Maonyesho ya majina ya vigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maonyesho ya kufuta pointer ni thamani za kushoto.\n    D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi kauli gani kuhusu kazi si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinapewa nafasi katika stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi kauli gani kuhusu pointers si sahihi?\n    A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointers za int.\n    D. Majina ya kazi yanaweza kupewa pointers za kazi.\n\nUnatakiwa kurudisha tu misururu inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.",
      "tr": "Bir CPP fonksiyonu `const char* answer_questions()` yazın ve aşağıdaki problemi çözün:\nHer soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\n\nSoru 1:\n1e6 gibi sabitler hangi veri tipine aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. Gösterici çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında alan tahsis edilir.\n    C. Fonksiyon tipi, dönüş değeri tipi ile aynıdır.\n    D. Bir fonksiyon, kendi gövdesinden kendisini çağırabilir.\n\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. Gösterici çözme, göstericinin türüne göre çözülmeyi içerir.\n    C. int *p[4], p bir int gösterici dizisidir.\n    D. Fonksiyon isimleri, fonksiyon göstericilerine atanabilir.\n\nSoruların seçenekleri gibi \"AAAAA\" şeklinde dizeler döndürmeniz bekleniyor.",
      "vi": "Viết một hàm CPP `const char* answer_questions()` để giải quyết vấn đề sau:  \nTrả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:  \nHằng số như 1e6 thuộc kiểu dữ liệu nào?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \n\nCâu hỏi 2:  \nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Không có cái nào ở trên  \n\nCâu hỏi 3:  \nPhát biểu nào về giá trị trái trong biểu thức là không đúng?  \n    A. Biểu thức tên biến là giá trị trái.  \n    B. Toán tử tăng yêu cầu toán hạng phải là giá trị trái.  \n    C. Biểu thức giải tham chiếu con trỏ là giá trị trái.  \n    D. Biểu thức toán tử tăng tiền tố là giá trị trái.  \n\nCâu hỏi 4:  \nPhát biểu nào về hàm là không đúng?  \n    A. Tham số hình thức của một hàm là biến cục bộ.  \n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.  \n    C. Kiểu hàm giống như kiểu giá trị trả về.  \n    D. Một hàm có thể tự gọi chính nó từ trong thân của nó.  \n\nCâu hỏi 5:  \nPhát biểu nào về con trỏ là không đúng?  \n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.  \n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.  \n    C. int *p[4], p là một mảng con trỏ int.  \n    D. Tên hàm có thể được gán cho con trỏ hàm.  \n\nBạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "instruction_bertscore": {
      "es": "0.9569424950423052",
      "arb": "0.9503124115537417",
      "sw": "0.9276818563512937",
      "tr": "0.9508477204306307",
      "vi": "0.9295924819864684"
    },
    "level": "easy",
    "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(answer_questions(), expected_answers) == 0);\n    \n    return 0;\n}",
    "entry_point": "answer_questions",
    "signature": "const char* answer_questions()",
    "docstring": {
      "es": "Responde una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en las expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo del valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver según el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de funciones.\n\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "ترجمة سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسارية.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الشكلية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n    D. يمكن للدالة استدعاء نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل خيارات السؤال.",
      "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstant kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\n\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maelezo ni isiyo sahihi?\n    A. Maelezo ya jina la kigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maelezo ya kufuta pointer ni thamani za kushoto.\n    D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi kauli gani kuhusu kazi ni isiyo sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujipigia yenyewe kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi kauli gani kuhusu pointers ni isiyo sahihi?\n    A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointers za int.\n    D. Majina ya kazi yanaweza kupewa pointers za kazi.\n\nUnapaswa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inasimama kwa chaguo za swali.",
      "tr": "Bir dizi soruya, her soru için A, B, C veya D seçeneklerini sağlayarak cevap verin.\n\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. Gösterici dereference ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinden kendini çağırabilir.\n\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. Gösterici dereference, göstericinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int gösterici dizisidir.\n    D. Fonksiyon isimleri, fonksiyon göstericilerine atanabilir.\n\nSadece soruların seçenekleri olan \"AAAAA\" gibi dizeleri döndürmeniz gerekiyor.",
      "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có cái nào ở trên\n\nCâu hỏi 3:\nCâu nào về giá trị trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị trái.\n    B. Phép toán tăng yêu cầu toán hạng là giá trị trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị trái.\n    D. Biểu thức phép toán tăng trước là giá trị trái.\n\nCâu hỏi 4:\nCâu nào về hàm là không đúng?\n    A. Tham số hình thức của hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu của hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể gọi chính nó từ bên trong thân hàm.\n\nCâu hỏi 5:\nCâu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\nBạn được yêu cầu chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "docstring_bertscore": {
      "es": "0.9437911775139852",
      "arb": "0.9415230171929478",
      "sw": "0.8807776754344774",
      "tr": "0.9455121111352716",
      "vi": "0.9238455091719859"
    }
  },
  {
    "task_id": "CPP/21",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Determina si es posible ensamblar los cuadrados de madera de n cubos\n * en un solo cuadrado más grande, donde cada cubo contiene cuadrados con un lado de longitud 1.\n * \n * Entrada: vector de números\n * Ejemplo:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector que contiene la cantidad de cuadrados en cada cubo.\n * @return True si es posible formar un cuadrado más grande, False en caso contrario.\n */\nbool Is_Square(std::vector<int> squares)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء\n * في مربع أكبر واحد، حيث يحتوي كل دلو على مربعات بطول جانب 1.\n * \n * المدخل: متجه من الأرقام\n * مثال:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares متجه يحتوي على عدد المربعات في كل دلو.\n * @return صحيح إذا كان من الممكن تشكيل مربع أكبر، خطأ خلاف ذلك.\n */\nbool Is_Square(std::vector<int> squares)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Huamua ikiwa inawezekana kuunganisha miraba ya mbao kutoka kwenye n ndoo\n * kuwa mraba mmoja mkubwa zaidi, ambapo kila ndoo ina miraba yenye urefu wa upande wa 1.\n * \n * Ingizo: vector ya namba\n * Mfano:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector inayoshikilia idadi ya miraba katika kila ndoo.\n * @return True ikiwa inawezekana kuunda mraba mkubwa zaidi, False vinginevyo.\n */\nbool Is_Square(std::vector<int> squares)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Her bir kovada kenar uzunluğu 1 olan kareler bulunan n kovadan\n * tek bir büyük kare oluşturmanın mümkün olup olmadığını belirler.\n * \n * Girdi: sayıların vektörü\n * Örnek:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Her kovadaki karelerin sayısını içeren vektör.\n * @return Daha büyük bir kare oluşturmak mümkünse True, aksi takdirde False döner.\n */\nbool Is_Square(std::vector<int> squares)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng\n * thành một hình vuông lớn hơn duy nhất hay không, trong đó mỗi thùng chứa các hình vuông có cạnh dài 1.\n * \n * Đầu vào: vector các số\n * Ví dụ:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector chứa số lượng hình vuông trong mỗi thùng.\n * @return True nếu có thể tạo thành một hình vuông lớn hơn, False nếu không.\n */\nbool Is_Square(std::vector<int> squares)"
    },
    "prompt_bertscore": {
      "es": "0.9719851710588394",
      "arb": "0.9721389109737604",
      "sw": "0.9788816178883707",
      "tr": "0.9452548847918314",
      "vi": "0.9555336097496248"
    },
    "canonical_solution": "{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}",
    "instruction": {
      "es": "Escribe una función CPP `bool Is_Square(std::vector<int> squares)` para resolver el siguiente problema:\nDetermina si es posible ensamblar los cuadrados de madera de n cubetas\nen un solo cuadrado más grande, donde cada cubeta contiene cuadrados con un lado de longitud 1.\n\nEntrada: vector de números\nEjemplo:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector que contiene la cantidad de cuadrados en cada cubeta.\n@return True si es posible formar un cuadrado más grande, False en caso contrario.",
      "arb": "اكتب دالة CPP `bool Is_Square(std::vector<int> squares)` لحل المشكلة التالية:\nتحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء\nفي مربع أكبر واحد، حيث يحتوي كل دلو على مربعات بطول ضلع 1.\n\nمدخل: متجه من الأرقام\nمثال:\n   >>> Is_Square({9})\n   true\n\n@param squares متجه يحتوي على عدد المربعات في كل دلو.\n@return True إذا كان من الممكن تشكيل مربع أكبر، False خلاف ذلك.",
      "sw": "Andika kazi ya CPP `bool Is_Square(std::vector<int> squares)` kutatua tatizo lifuatalo:\nInabainisha kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n\nkuwa mraba mmoja mkubwa zaidi, ambapo kila ndoo ina miraba yenye urefu wa upande wa 1.\n\nIngizo: vector ya namba\nMfano:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector inayojumuisha idadi ya miraba katika kila ndoo.\n@return True ikiwa inawezekana kuunda mraba mkubwa zaidi, False vinginevyo.",
      "tr": "Bir CPP fonksiyonu `bool Is_Square(std::vector<int> squares)` yazın ve aşağıdaki problemi çözün:\nAhşap kareleri n kovasından tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler,\nburada her kova 1 birim kenar uzunluğuna sahip kareler içerir.\n\nGirdi: sayıların vektörü\nÖrnek:\n   >>> Is_Square({9})\n   true\n\n@param squares Her kovadaki karelerin sayısını içeren vektör.\n@return Daha büyük bir kare oluşturmak mümkünse True, aksi takdirde False.",
      "vi": "Viết một hàm CPP `bool Is_Square(std::vector<int> squares)` để giải quyết vấn đề sau:  \nXác định xem có thể lắp ráp các hình vuông gỗ từ n xô thành một hình vuông lớn hơn, trong đó mỗi xô chứa các hình vuông có độ dài cạnh là 1.\n\nĐầu vào: vector của các số  \nVí dụ:  \n   >>> Is_Square({9})  \n   true\n\n@param squares Vector chứa số lượng hình vuông trong mỗi xô.  \n@return True nếu có thể tạo thành một hình vuông lớn hơn, False nếu không."
    },
    "instruction_bertscore": {
      "es": "0.9819732997691787",
      "arb": "0.9697487915987676",
      "sw": "0.9784609187413388",
      "tr": "0.9684793448335736",
      "vi": "0.9714903827796815"
    },
    "level": "easy",
    "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}",
    "entry_point": "Is_Square",
    "signature": "bool Is_Square(std::vector<int> squares)",
    "docstring": {
      "es": "Determina si es posible ensamblar los cuadrados de madera de n cubetas en un solo cuadrado más grande, donde cada cubeta contiene cuadrados con un lado de longitud 1.\n\nEntrada: vector de números\nEjemplo:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector que contiene la cantidad de cuadrados en cada cubeta.\n@return True si es posible formar un cuadrado más grande, False en caso contrario.",
      "arb": "يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء في مربع أكبر واحد، حيث يحتوي كل دلو على مربعات بطول جانب 1.\n\nالمدخلات: متجه من الأرقام\nمثال:\n   >>> Is_Square({9})\n   true\n\n@param squares متجه يحتوي على عدد المربعات في كل دلو.\n@return صحيح إذا كان من الممكن تشكيل مربع أكبر، خطأ خلاف ذلك.",
      "sw": "Inabainisha ikiwa inawezekana kuunganisha mraba wa mbao kutoka kwa n ndoo kuwa mraba mmoja mkubwa zaidi, ambapo kila ndoo ina miraba yenye urefu wa upande wa 1.\n\nIngizo: vekta ya namba\nMfano:\n   >>> Is_Square({9})\n   true\n\n@param squares Vekta inayojumuisha idadi ya miraba katika kila ndoo.\n@return Kweli ikiwa inawezekana kuunda mraba mkubwa zaidi, Si kweli vinginevyo.",
      "tr": "Bir büyük kare oluşturmak için n kovasından ahşap karelerin bir araya getirilip getirilemeyeceğini belirler, burada her kova kenar uzunluğu 1 olan kareler içerir.\n\nGirdi: sayıların vektörü\nÖrnek:\n   >>> Is_Square({9})\n   true\n\n@param squares Her kovadaki karelerin sayısını içeren vektör.\n@return Daha büyük bir kare oluşturmak mümkünse True, aksi takdirde False.",
      "vi": "Xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng thành một hình vuông lớn hơn hay không, trong đó mỗi thùng chứa các hình vuông có độ dài cạnh là 1.\n\nĐầu vào: vector các số\nVí dụ:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector chứa số lượng hình vuông trong mỗi thùng.\n@return True nếu có thể tạo thành một hình vuông lớn hơn, False nếu không."
    },
    "docstring_bertscore": {
      "es": "0.9834374043077869",
      "arb": "0.9692369211068407",
      "sw": "0.9726730280683632",
      "tr": "0.934139925929881",
      "vi": "0.9382237665639583"
    }
  },
  {
    "task_id": "CPP/22",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Dados los enteros c y d, donde a + b = c y a * b = d, esta función\n * encuentra el valor posible de a con la condición a <= b. Cuando múltiples \n * pares (a, b) son posibles, devuelve el par con el menor a.\n * Si no existe un par válido, devuelve -1.\n *\n * Parámetros:\n *  - c (int): La suma de a y b.\n *  - d (int): El producto de a y b.\n *\n * Devuelve:\n *  - int: Un valor posible de a o -1 si no existen valores válidos.\n *\n * Ejemplos:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * بالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، هذه الدالة\n * تجد القيمة الممكنة لـ a بشرط أن a <= b. عندما تكون هناك عدة أزواج (a, b) ممكنة،\n * تُرجع الزوج الذي يحتوي على أصغر قيمة لـ a.\n * إذا لم يوجد زوج صالح، تُرجع -1.\n *\n * المعاملات:\n *  - c (int): مجموع a و b.\n *  - d (int): حاصل ضرب a و b.\n *\n * تُرجع:\n *  - int: قيمة ممكنة لـ a أو -1 إذا لم توجد قيم صالحة.\n *\n * أمثلة:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ukipewa nambari kamili c na d, ambapo a + b = c na a * b = d, kazi hii\n * inapata thamani inayowezekana ya a kwa sharti a <= b. Wakati jozi nyingi \n * (a, b) zinawezekana, inarudisha jozi yenye a ndogo zaidi.\n * Ikiwa hakuna jozi halali ipo, inarudisha -1.\n *\n * Vigezo:\n *  - c (int): Jumla ya a na b.\n *  - d (int): Bidhaa ya a na b.\n *\n * Inarudisha:\n *  - int: Thamani inayowezekana ya a au -1 ikiwa hakuna thamani halali ipo.\n *\n * Mifano:\n *  find_integers(7, 11) inarudisha -1\n *  find_integers(5, 6) inarudisha 2\n */\nint find_integers(int c, int d)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * a + b = c ve a * b = d olan tamsayılar c ve d verildiğinde, bu fonksiyon\n * a <= b koşuluyla a'nın olası değerini bulur. Birden fazla (a, b) çifti mümkün olduğunda,\n * en küçük a'ya sahip çifti döndürür. Geçerli bir çift yoksa, -1 döndürür.\n *\n * Parametreler:\n *  - c (int): a ve b'nin toplamı.\n *  - d (int): a ve b'nin çarpımı.\n *\n * Döndürür:\n *  - int: a'nın olası bir değeri veya geçerli değer yoksa -1.\n *\n * Örnekler:\n *  find_integers(7, 11) -1 döndürür\n *  find_integers(5, 6) 2 döndürür\n */\nint find_integers(int c, int d)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cho các số nguyên c và d, trong đó a + b = c và a * b = d, hàm này\n * tìm giá trị có thể của a với điều kiện a <= b. Khi có nhiều cặp \n * (a, b) có thể, nó trả về cặp với a nhỏ nhất.\n * Nếu không tồn tại cặp hợp lệ, nó trả về -1.\n *\n * Tham số:\n *  - c (int): Tổng của a và b.\n *  - d (int): Tích của a và b.\n *\n * Trả về:\n *  - int: Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n *\n * Ví dụ:\n *  find_integers(7, 11) trả về -1\n *  find_integers(5, 6) trả về 2\n */\nint find_integers(int c, int d)"
    },
    "prompt_bertscore": {
      "es": "0.9969408935016817",
      "arb": "0.9726299252756786",
      "sw": "0.974995215853042",
      "tr": "0.9693729829178496",
      "vi": "0.9912684070800873"
    },
    "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "es": "Escribe una función CPP `int find_integers(int c, int d)` para resolver el siguiente problema:\nDado los enteros c y d, donde a + b = c y a * b = d, esta función\nencuentra el valor posible de a con la condición a <= b. Cuando múltiples\npares (a, b) son posibles, devuelve el par con el menor a.\nSi no existe un par válido, devuelve -1.\n\nParámetros:\n- c (int): La suma de a y b.\n- d (int): El producto de a y b.\n\nDevuelve:\n- int: Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\nfind_integers(7, 11) devuelve -1\nfind_integers(5, 6) devuelve 2",
      "arb": "اكتب دالة CPP `int find_integers(int c, int d)` لحل المشكلة التالية:\nبالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، تقوم هذه الدالة\nبإيجاد القيمة الممكنة لـ a مع الشرط a <= b. عندما تكون هناك أزواج متعددة (a, b) ممكنة، فإنها تعيد الزوج مع أصغر قيمة لـ a.\nإذا لم يكن هناك زوج صالح، فإنها تعيد -1.\n\nالمعلمات:\n- c (int): مجموع a و b.\n- d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n- int: قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صالحة.\n\nأمثلة:\nfind_integers(7, 11) يعيد -1\nfind_integers(5, 6) يعيد 2",
      "sw": "Andika kazi ya CPP `int find_integers(int c, int d)` kutatua tatizo lifuatalo:\nUkipatiwa namba nzima c na d, ambapo a + b = c na a * b = d, kazi hii\ninapata thamani inayowezekana ya a kwa sharti a <= b. Wakati jozi nyingi (a, b) zinawezekana, inarudisha jozi yenye a ndogo zaidi.\nIkiwa hakuna jozi halali ipo, inarudisha -1.\n\nVigezo:\n- c (int): Jumla ya a na b.\n- d (int): Bidhaa ya a na b.\n\nInarudisha:\n- int: Thamani inayowezekana ya a au -1 ikiwa hakuna thamani halali ipo.\n\nMifano:\nfind_integers(7, 11) inarudisha -1\nfind_integers(5, 6) inarudisha 2",
      "tr": "Bir CPP fonksiyonu `int find_integers(int c, int d)` yazın ve aşağıdaki problemi çözün:\nVerilen c ve d tamsayıları için, burada a + b = c ve a * b = d, bu fonksiyon\na'nın olası değerini a <= b koşuluyla bulur. Birden fazla\n(a, b) çifti mümkün olduğunda, en küçük a'ya sahip çifti döndürür.\nEğer geçerli bir çift yoksa, -1 döndürür.\n\nParametreler:\n- c (int): a ve b'nin toplamı.\n- d (int): a ve b'nin çarpımı.\n\nDöndürür:\n- int: a'nın olası bir değeri veya geçerli bir değer yoksa -1.\n\nÖrnekler:\nfind_integers(7, 11) -1 döndürür\nfind_integers(5, 6) 2 döndürür",
      "vi": "Viết một hàm CPP `int find_integers(int c, int d)` để giải quyết vấn đề sau:\nCho các số nguyên c và d, nơi a + b = c và a * b = d, hàm này\ntìm giá trị có thể của a với điều kiện a <= b. Khi có nhiều\ncặp (a, b) có thể, nó trả về cặp với a nhỏ nhất.\nNếu không tồn tại cặp hợp lệ, nó trả về -1.\n\nTham số:\n- c (int): Tổng của a và b.\n- d (int): Tích của a và b.\n\nTrả về:\n- int: Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n\nVí dụ:\nfind_integers(7, 11) trả về -1\nfind_integers(5, 6) trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9922031616532375",
      "arb": "0.9770977184362963",
      "sw": "0.9946616098793063",
      "tr": "0.9738971871066812",
      "vi": "0.9922472575978273"
    },
    "level": "easy",
    "test": "int main() {\n    assert(find_integers(5, 6) == 2);\n    assert(find_integers(6, 9) == 3);\n    assert(find_integers(7, 12) == 3);\n    assert(find_integers(7, 11) == -1);\n    assert(find_integers(9, 8) == 1);\n    assert(find_integers(10, 25) == 5);\n    assert(find_integers(10000, 8765) == -1);\n\n    return 0;\n}",
    "entry_point": "find_integers",
    "signature": "int find_integers(int c, int d)",
    "docstring": {
      "es": "Dado los enteros c y d, donde a + b = c y a * b = d, esta función\nencuentra el valor posible de a con la condición a <= b. Cuando múltiples\npares (a, b) son posibles, devuelve el par con el menor a.\nSi no existe un par válido, devuelve -1.\n\nParámetros:\n- c (int): La suma de a y b.\n- d (int): El producto de a y b.\n\nDevuelve:\n- int: Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\nfind_integers(7, 11) devuelve -1\nfind_integers(5, 6) devuelve 2",
      "arb": "المعطاة الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، هذه الدالة\nتجد القيمة الممكنة لـ a بشرط أن a <= b. عندما تكون هناك أزواج متعددة (a, b) ممكنة، فإنها تعيد الزوج الذي يحتوي على أصغر قيمة لـ a.\nإذا لم يكن هناك زوج صالح، فإنها تعيد -1.\n\nالمعطيات:\n- c (int): مجموع a و b.\n- d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n- int: قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صالحة.\n\nأمثلة:\nfind_integers(7, 11) يعيد -1\nfind_integers(5, 6) يعيد 2",
      "sw": "Kwa kupewa namba kamili c na d, ambapo a + b = c na a * b = d, kazi hii\ninapata thamani inayowezekana ya a kwa sharti a <= b. Wakati jozi nyingi (a, b) zinawezekana, inarudisha jozi yenye a ndogo zaidi.\nIkiwa hakuna jozi halali inayopatikana, inarudisha -1.\n\nVigezo:\n- c (int): Jumla ya a na b.\n- d (int): Bidhaa ya a na b.\n\nInarudisha:\n- int: Thamani inayowezekana ya a au -1 ikiwa hakuna thamani halali inayopatikana.\n\nMifano:\nfind_integers(7, 11) inarudisha -1\nfind_integers(5, 6) inarudisha 2",
      "tr": "Verilen c ve d tamsayıları için, burada a + b = c ve a * b = d, bu fonksiyon\na <= b koşuluyla a'nın olası değerini bulur. Birden fazla (a, b) çifti mümkün olduğunda, en küçük a'ya sahip çifti döndürür.\nEğer geçerli bir çift yoksa, -1 döner.\n\nParametreler:\n- c (int): a ve b'nin toplamı.\n- d (int): a ve b'nin çarpımı.\n\nDöndürür:\n- int: a'nın olası bir değeri veya geçerli bir değer yoksa -1.\n\nÖrnekler:\nfind_integers(7, 11) -1 döndürür\nfind_integers(5, 6) 2 döndürür",
      "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, hàm này tìm giá trị có thể của a với điều kiện a <= b. Khi có nhiều cặp (a, b) có thể, nó trả về cặp với a nhỏ nhất. Nếu không tồn tại cặp hợp lệ nào, nó trả về -1.\n\nTham số:\n- c (int): Tổng của a và b.\n- d (int): Tích của a và b.\n\nTrả về:\n- int: Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ nào.\n\nVí dụ:\nfind_integers(7, 11) trả về -1\nfind_integers(5, 6) trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9958770291808589",
      "arb": "0.9677607001149894",
      "sw": "0.9785804942307218",
      "tr": "0.9805475308941103",
      "vi": "0.9912135850949217"
    }
  },
  {
    "task_id": "CPP/23",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n  \nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n  \nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n  \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة معينة من الحواف.\n\nالمعطيات:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من المعطيات الصحيحة التي تمثل أطوال الحواف.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka\nkatika seti iliyotolewa ya pande.\n  \nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya kawaida ya hoja za nambari za mzima zinazowakilisha urefu wa pande.\n  \nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n  \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dik açılı üçgenlerin sayısını sayar.\n  \nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden keyfi sayıda tamsayı argümanı.\n  \nReturns:\nint: Oluşturulabilecek farklı dik açılı üçgenlerin sayısı.\n  \nÖrnekler:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ\nmột tập hợp các cạnh cho trước.\n  \nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các tham số nguyên đại diện cho độ dài của các cạnh.\n  \nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n  \nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)"
    },
    "prompt_bertscore": {
      "es": "0.9673054392816574",
      "arb": "0.9735563373728253",
      "sw": "0.95808541425478",
      "tr": "0.9775863491736422",
      "vi": "0.9482480460036461"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int count_acute_triangles(int edges_count, ...)` para resolver el siguiente problema:\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 aristas de un conjunto dado de aristas.\n\nArgs:\n- edges_count: El número de aristas pasadas.\n- Un número arbitrario de argumentos enteros que representan las longitudes de las aristas.\n\nReturns:\nint: La cuenta de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "arb": "اكتب دالة CPP `int count_acute_triangles(int edges_count, ...)` لحل المشكلة التالية:\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nArgs:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من الوسيطات الصحيحة التي تمثل أطوال الحواف.\n\nReturns:\nint: عدد المثلثات الحادة الزاوية المختلفة التي يمكن تشكيلها.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "sw": "Andika kazi ya CPP `int count_acute_triangles(int edges_count, ...)` kutatua tatizo lifuatalo:\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 kutoka kwenye seti ya pande zilizotolewa.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo na kikomo ya hoja za nambari za mzima zinazoashiria urefu wa pande.\n\nInarudisha:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nMifano:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "tr": "Bir CPP fonksiyonu `int count_acute_triangles(int edges_count, ...)` yazın ve aşağıdaki problemi çözün:\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n\nArgümanlar:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n\nDöndürür:\nint: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n\nÖrnekler:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "vi": "Viết một hàm CPP `int count_acute_triangles(int edges_count, ...)` để giải quyết vấn đề sau:\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các tham số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "instruction_bertscore": {
      "es": "0.9791352688849523",
      "arb": "0.9796199270146774",
      "sw": "0.9456511524019959",
      "tr": "0.959287128060041",
      "vi": "0.9518839751284898"
    },
    "level": "middle",
    "test": "int main() {\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}",
    "entry_point": "count_acute_triangles",
    "signature": "int count_acute_triangles(int edges_count, ...)",
    "docstring": {
      "es": "Contar el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n\nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "arb": "احسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nArgs:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من الوسائط الصحيحة التي تمثل أطوال الحواف.\n\nReturns:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "sw": "Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti iliyotolewa ya pande.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya lazima ya hoja za nambari nzima zinazowakilisha urefu wa pande.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "tr": "Verilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n\nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tam sayı argümanı.\n\nReturns:\nint: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n",
      "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n\nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các đối số kiểu số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác biệt có thể được tạo thành.\n\nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "docstring_bertscore": {
      "es": "0.9504182815468333",
      "arb": "0.977585356021737",
      "sw": "0.9393424528699469",
      "tr": "0.9797553929345432",
      "vi": "0.9385807053586781"
    }
  },
  {
    "task_id": "CPP/24",
    "prompt": {
      "es": "#include <bits/stdc++.h>\n/**\n * Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n * \n * Parámetros:\n * - integer_value (int): El entero de entrada.\n * - char_value (char): El carácter de entrada.\n * \n * Devuelve:\n * - char*: Una cadena que contiene el entero y el carácter separados por una coma.\n * \n * Ejemplo:\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "arb": "#include <bits/stdc++.h>\n/**\n * يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة نصية منسقة مفصولة بفاصلة.\n * \n * المعاملات:\n * - integer_value (int): العدد الصحيح المدخل.\n * - char_value (char): الحرف المدخل.\n * \n * يعيد:\n * - char*: سلسلة نصية تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n * \n * مثال:\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "sw": "#include <bits/stdc++.h>\n/**\n * Husoma nambari kamili na herufi, kisha kuzirudisha kama mfuatano wa maandishi uliopangwa kwa koma.\n * \n * Vigezo:\n * - integer_value (int): Nambari kamili ya ingizo.\n * - char_value (char): Herufi ya ingizo.\n * \n * Inarudisha:\n * - char*: Mfuatano wa maandishi unaojumuisha nambari kamili na herufi zilizotenganishwa na koma.\n * \n * Mfano:\n * process_integer_and_char(234, 'H') inarudisha \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "tr": "#include <bits/stdc++.h>\n/**\n * Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n * \n * Parametreler:\n * - integer_value (int): Girdi tam sayısı.\n * - char_value (char): Girdi karakteri.\n * \n * Döndürür:\n * - char*: Tam sayı ve karakteri virgülle ayrılmış bir dize olarak içeren bir dize.\n * \n * Örnek:\n * process_integer_and_char(234, 'H') \"234,H\" döndürür\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "vi": "#include <bits/stdc++.h>\n/**\n * Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được ngăn cách bằng dấu phẩy.\n * \n * Tham số:\n * - integer_value (int): Số nguyên đầu vào.\n * - char_value (char): Ký tự đầu vào.\n * \n * Trả về:\n * - char*: Một chuỗi chứa số nguyên và ký tự được ngăn cách bằng dấu phẩy.\n * \n * Ví dụ:\n * process_integer_and_char(234, 'H') trả về \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)"
    },
    "prompt_bertscore": {
      "es": "0.9969416880232058",
      "arb": "1",
      "sw": "0.9736387689809548",
      "tr": "0.9686314957054463",
      "vi": "0.9836644388333098"
    },
    "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}",
    "instruction": {
      "es": "Escribe una función en CPP `char* process_integer_and_char(int integer_value, char char_value)` para resolver el siguiente problema:\nLee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\n\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n\nEjemplo:\nprocess_integer_and_char(234, 'H') returns \"234,H\"",
      "arb": "اكتب دالة CPP `char* process_integer_and_char(int integer_value, char char_value)` لحل المشكلة التالية:\nيقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\n\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\n\nيعيد:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n\nمثال:\nprocess_integer_and_char(234, 'H') returns \"234,H\"",
      "sw": "Andika kazi ya CPP `char* process_integer_and_char(int integer_value, char char_value)` kutatua tatizo lifuatalo:\nHusoma nambari nzima na herufi, kisha huzirudisha kama kamba iliyopangwa ikitenganishwa na koma.\n\nVigezo:\n- integer_value (int): Nambari nzima ya ingizo.\n- char_value (char): Herufi ya ingizo.\n\nInarejesha:\n- char*: Kamba inayojumuisha nambari nzima na herufi ikitenganishwa na koma.\n\nMfano:\nprocess_integer_and_char(234, 'H') inarejesha \"234,H\"",
      "tr": "Bir CPP fonksiyonu `char* process_integer_and_char(int integer_value, char char_value)` yazın ve aşağıdaki problemi çözün:\nBir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\n\nDöndürülenler:\n- char*: Virgülle ayrılmış tam sayı ve karakter içeren bir dize.\n\nÖrnek:\nprocess_integer_and_char(234, 'H') \"234,H\" döndürür.",
      "vi": "Viết một hàm CPP `char* process_integer_and_char(int integer_value, char char_value)` để giải quyết vấn đề sau:\nĐọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\n\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\n\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n\nVí dụ:\nprocess_integer_and_char(234, 'H') trả về \"234,H\""
    },
    "instruction_bertscore": {
      "es": "0.9883384103294417",
      "arb": "1",
      "sw": "0.9878142247538907",
      "tr": "0.9853325367732407",
      "vi": "0.9841687613707574"
    },
    "level": "middle",
    "test": "int main() {\n    // Test 1\n    char* output1 = process_integer_and_char(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = process_integer_and_char(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = process_integer_and_char(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}",
    "entry_point": "process_integer_and_char",
    "signature": "char* process_integer_and_char(int integer_value, char char_value)",
    "docstring": {
      "es": "Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\n\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n\nEjemplo:\nprocess_integer_and_char(234, 'H') devuelve \"234,H\"",
      "arb": "يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\n\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\n\nالقيم المعادة:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n\nمثال:\nprocess_integer_and_char(234, 'H') يعيد \"234,H\"",
      "sw": "Husoma nambari kamili na herufi, kisha inazirudisha kama kamba iliyopangwa kwa mtindo wa kutenganishwa na koma.\n\nVigezo:\n- integer_value (int): Nambari kamili ya ingizo.\n- char_value (char): Herufi ya ingizo.\n\nInarudisha:\n- char*: Kamba inayojumuisha nambari kamili na herufi iliyotenganishwa na koma.\n\nMfano:\nprocess_integer_and_char(234, 'H') inarudisha \"234,H\"",
      "tr": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\n\nDöndürür:\n- char*: Tam sayı ve karakteri virgülle ayrılmış bir dize olarak içeren bir dize.\n\nÖrnek:\nprocess_integer_and_char(234, 'H') \"234,H\" döndürür.",
      "vi": "Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được ngăn cách bởi dấu phẩy.\n\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\n\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được ngăn cách bởi dấu phẩy.\n\nVí dụ:\nprocess_integer_and_char(234, 'H') trả về \"234,H\""
    },
    "docstring_bertscore": {
      "es": "0.9893629458348197",
      "arb": "0.9871740390358152",
      "sw": "0.9597324573743212",
      "tr": "0.9845131864514718",
      "vi": "0.9784303296626594"
    }
  },
  {
    "task_id": "CPP/25",
    "prompt": {
      "es": "#include <bits/stdc++.h>\n/*\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras,\ny todas las letras están en mayúsculas.\n\nParámetros:\ntext (std::string&): El texto de entrada a procesar, modificado en su lugar.\n\nDevuelve:\nstd::string&: El texto transformado con caracteres desplazados 5 posiciones.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "arb": "#include <bits/stdc++.h>\n/*\nينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الأحرف فقط،\nوجميع الأحرف تكون بحروف كبيرة.\n\nالمعلمات:\ntext (std::string&): النص المدخل ليتم معالجته، يتم تعديله في مكانه.\n\nيُرجع:\nstd::string&: النص المحول مع الأحرف التي تم نقلها بمقدار 5 مواقع.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "sw": "#include <bits/stdc++.h>\n/*\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee zinazobadilishwa,\nna herufi zote ziko katika herufi kubwa.\n\nVigezo:\ntext (std::string&): Maandishi ya ingizo yanayopaswa kushughulikiwa, yanabadilishwa papo hapo.\n\nInarejesha:\nstd::string&: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "tr": "```cpp\n#include <bits/stdc++.h>\n/*\nTüm karakterleri alfabetik sırada 5 pozisyon kaydırır. Sadece harfler değiştirilir\nve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (std::string&): İşlenecek giriş metni, yerinde değiştirilir.\n\nDöndürür:\nstd::string&: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)\n```",
      "vi": "#include <bits/stdc++.h>\n/*\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế,\nvà tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (std::string&): Văn bản đầu vào cần được xử lý, được sửa đổi tại chỗ.\n\nTrả về:\nstd::string&: Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)"
    },
    "prompt_bertscore": {
      "es": "0.9813515866765395",
      "arb": "0.9954245491728614",
      "sw": "0.9849815568899521",
      "tr": "0.9537207102619193",
      "vi": "0.9839792679872501"
    },
    "canonical_solution": "{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}",
    "instruction": {
      "es": "Escriba una función CPP `std::string& shift_characters(std::string& text)` para resolver el siguiente problema:\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan letras, y todas las letras están en mayúsculas.\n\nParámetros:\ntext (std::string&): El texto de entrada a ser procesado, modificado en su lugar.\n\nDevuelve:\nstd::string&: El texto transformado con caracteres desplazados 5 posiciones.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "اكتب دالة CPP `std::string& shift_characters(std::string& text)` لحل المشكلة التالية:\nتحريك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعلمات:\ntext (std::string&): النص المدخل ليتم معالجته، يتم تعديله في مكانه.\n\nالقيم المعادة:\nstd::string&: النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Andika kazi ya CPP `std::string& shift_characters(std::string& text)` kutatua tatizo lifuatalo:\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo zinazobadilishwa, na herufi zote ni kubwa.\n\nVigezo:\ntext (std::string&): Maandishi ya kuingiza yatakayoshughulikiwa, kubadilishwa mahali pale pale.\n\nInarejesha:\nstd::string&: Maandishi yaliyobadilishwa na herufi kusogezwa kwa nafasi 5.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Bir CPP fonksiyonu `std::string& shift_characters(std::string& text)` yazın ve aşağıdaki problemi çözün:\nTüm karakterleri alfabetik sırada 5 pozisyon kaydırır. Sadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (std::string&): İşlenecek olan giriş metni, yerinde değiştirilir.\n\nDöndürülenler:\nstd::string&: Karakterleri 5 pozisyon kaydırılmış olan dönüştürülmüş metin.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "vi": "Viết một hàm CPP `std::string& shift_characters(std::string& text)` để giải quyết vấn đề sau:\nDịch chuyển tất cả các ký tự theo thứ tự bảng chữ cái thêm 5 vị trí. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (std::string&): Văn bản đầu vào cần được xử lý, được sửa đổi tại chỗ.\n\nTrả về:\nstd::string&: Văn bản đã được biến đổi với các ký tự dịch chuyển thêm 5 vị trí.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "instruction_bertscore": {
      "es": "0.98308483538145",
      "arb": "0.9909273587158505",
      "sw": "0.9842170285533488",
      "tr": "0.9822384713278604",
      "vi": "0.9923427988111051"
    },
    "level": "easy",
    "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}",
    "entry_point": "shift_characters",
    "signature": "std::string& shift_characters(std::string& text)",
    "docstring": {
      "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n\nParámetros:\ntext (std::string&): El texto de entrada a procesar, modificado en el lugar.\n\nDevuelve:\nstd::string&: El texto transformado con caracteres desplazados 5 posiciones.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعلمات:\ntext (std::string&): النص المدخل ليتم معالجته، يتم تعديله في المكان.\n\nالإرجاع:\nstd::string&: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Hubadilisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo hubadilishwa, na herufi zote ni za herufi kubwa.\n\nVigezo:\ntext (std::string&): Maandishi ya pembejeo yatakayoshughulikiwa, yamebadilishwa papo hapo.\n\nInarejesha:\nstd::string&: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Sadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (std::string&): İşlenecek giriş metni, yerinde değiştirilir.\n\nDöndürür:\nstd::string&: Karakterleri 5 pozisyon kaydırılmış dönüştürülmüş metin.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "vi": "Dịch chuyển tất cả các ký tự theo 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (std::string&): Văn bản đầu vào cần được xử lý, được sửa đổi tại chỗ.\n\nTrả về:\nstd::string&: Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "es": "0.9703814293623637",
      "arb": "0.9943416163354591",
      "sw": "0.9646912648368572",
      "tr": "0.9639934763082817",
      "vi": "0.9926874225222005"
    }
  },
  {
    "task_id": "CPP/26",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Clasificar el entero x basado en el siguiente método:\n * Si x es un número de un solo dígito, x pertenece a su propia clase.\n * De lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta \n * que se determine la clase.\n *\n * Parámetros:\n * - x (const char*): El entero a clasificar en forma de cadena.\n *\n * Retorna:\n * int: La clase a la que pertenece el entero x.\n *\n * Uso:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * صنف العدد الصحيح x بناءً على الطريقة التالية:\n * إذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\n * خلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n *\n * المعلمات:\n * - x (const char*): العدد الصحيح الذي سيتم تصنيفه في شكل سلسلة.\n *\n * يعيد:\n * int: الفئة التي ينتمي إليها العدد الصحيح x.\n *\n * الاستخدام:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tambua nambari x kulingana na njia ifuatayo:\n * Ikiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.\n * Vinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi \n * darasa litakapobainishwa.\n *\n * Vigezo:\n * - x (const char*): Nambari ya kutambuliwa katika umbo la kamba.\n *\n * Inarudisha:\n * int: Darasa ambalo nambari x inamiliki.\n *\n * Matumizi:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "tr": "```cpp\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * x tamsayısını aşağıdaki yönteme göre sınıflandırın:\n * Eğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\n * Aksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve\n * sınıf belirlenene kadar yineleyin.\n *\n * Parametreler:\n * - x (const char*): Sınıflandırılacak tamsayı, string formunda.\n *\n * Döndürür:\n * int: x tamsayısının ait olduğu sınıf.\n *\n * Kullanım:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)\n```",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Phân loại số nguyên x dựa trên phương pháp sau:\n * Nếu x là số có một chữ số, x thuộc về lớp của chính nó.\n * Ngược lại, tính tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi \n * lớp được xác định.\n *\n * Tham số:\n * - x (const char*): Số nguyên cần phân loại dưới dạng chuỗi.\n *\n * Trả về:\n * int: Lớp mà số nguyên x thuộc về.\n *\n * Sử dụng:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)"
    },
    "prompt_bertscore": {
      "es": "0.9935544441354178",
      "arb": "0.9772115336446293",
      "sw": "0.9663373148044934",
      "tr": "0.9658754991685873",
      "vi": "0.974254721792544"
    },
    "canonical_solution": "{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int classify_integer(const char *x)` para resolver el siguiente problema:\nClasifica el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (const char*): El entero a ser clasificado en forma de cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nUso:\n>>> classify_integer(\"24\")\n6",
      "arb": "اكتب دالة CPP `int classify_integer(const char *x)` لحل المشكلة التالية:\nتصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (const char*): العدد الصحيح الذي سيتم تصنيفه في شكل سلسلة.\n\nالإرجاع:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nالاستخدام:\n>>> classify_integer(\"24\")\n6",
      "sw": "Andika kazi ya CPP `int classify_integer(const char *x)` kutatua tatizo lifuatalo:\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake yenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\n\nVigezo:\n- x (const char*): Nambari inayotakiwa kutambuliwa katika mfumo wa kamba.\n\nInarudisha:\nint: Darasa ambalo nambari x ni ya.\n\nMatumizi:\n>>> classify_integer(\"24\")\n6",
      "tr": "Bir CPP fonksiyonu `int classify_integer(const char *x)` yazın ve aşağıdaki problemi çözün:\nAşağıdaki yönteme göre tamsayı x'i sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (const char*): Sınıflandırılacak tamsayı, string formunda.\n\nDöndürülen:\nint: Tamsayı x'in ait olduğu sınıf.\n\nKullanım:\n>>> classify_integer(\"24\")\n6",
      "vi": "Viết một hàm CPP `int classify_integer(const char *x)` để giải quyết vấn đề sau:\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, cộng các chữ số của x, lấy một x mới, và lặp lại cho đến khi xác định được lớp.\n\nTham số:\n- x (const char*): Số nguyên cần phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nSử dụng:\n>>> classify_integer(\"24\")\n6"
    },
    "instruction_bertscore": {
      "es": "0.9986457380621041",
      "arb": "0.975461599987712",
      "sw": "0.9601783825797445",
      "tr": "0.9858169962725848",
      "vi": "0.9794721460111874"
    },
    "level": "easy",
    "test": "int main() {\n    assert(classify_integer(\"24\") == 6);\n    assert(classify_integer(\"39\") == 3);\n    assert(classify_integer(\"123456789\") == 9);\n    assert(classify_integer(\"123456789012345678901234567890\") == 9);\n    assert(classify_integer(\"12345\") == 6);\n    assert(classify_integer(\"999999999\") == 9);\n    // std::printf(\"All tests passed successfully!\\n\");\n    return 0;\n}",
    "entry_point": "classify_integer",
    "signature": "int classify_integer(const char *x)",
    "docstring": {
      "es": "Clasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (const char*): El entero a ser clasificado en forma de cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nUso:\n>>> classify_integer(\"24\")\n6",
      "arb": "صنف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (const char*): العدد الصحيح الذي سيتم تصنيفه في شكل سلسلة.\n\nالقيم المعادة:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nالاستخدام:\n>>> classify_integer(\"24\")\n6",
      "sw": "Tambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusiana na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\n\nVigezo:\n- x (const char*): Nambari ya kuhesabu inayopaswa kuainishwa katika umbo la kamba.\n\nInarejesha:\nint: Darasa ambalo nambari x inahusiana.\n\nMatumizi:\n>>> classify_integer(\"24\")\n6",
      "tr": "Tam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayıysa, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (const char*): Sınıflandırılacak tam sayının string formu.\n\nDöndürür:\nint: Tam sayı x'in ait olduğu sınıf.\n\nKullanım:\n>>> classify_integer(\"24\")\n6",
      "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, cộng các chữ số của x lại, nhận được một x mới, và lặp lại cho đến khi xác định được lớp.\n\nTham số:\n- x (const char*): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nSử dụng:\n>>> classify_integer(\"24\")\n6"
    },
    "docstring_bertscore": {
      "es": "0.9983632856602725",
      "arb": "0.9700060179422078",
      "sw": "0.9534668606349568",
      "tr": "0.9713483620572415",
      "vi": "0.9796606462427895"
    }
  },
  {
    "task_id": "CPP/27",
    "prompt": {
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Transforma el caso de una letra dada.\n * \n * Si la entrada es una letra minúscula, devuelve la versión en mayúscula,\n * y si la entrada es una letra mayúscula, devuelve la versión en minúscula.\n * Los caracteres no alfabéticos se devuelven sin cambios.\n *\n * Uso:\n *   char result = transform_letter_case('b'); // result será 'B'\n *   char result = transform_letter_case('B'); // result será 'b'\n *\n * @param letter La letra de entrada a transformar.\n * @return La letra con su caso invertido si es alfabética, de lo contrario la letra original.\n */\nchar transform_letter_case(char letter)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * يحول حالة حرف معين.\n * \n * إذا كان الإدخال حرفًا صغيرًا، فإنه يعيد النسخة الكبيرة،\n * وإذا كان الإدخال حرفًا كبيرًا، فإنه يعيد النسخة الصغيرة.\n * الأحرف غير الأبجدية تُعاد دون تغيير.\n *\n * الاستخدام:\n *   char result = transform_letter_case('b'); // النتيجة ستكون 'B'\n *   char result = transform_letter_case('B'); // النتيجة ستكون 'b'\n *\n * @param letter الحرف المدخل ليتم تحويله.\n * @return الحرف مع عكس حالته إذا كان أبجديًا، وإلا الحرف الأصلي.\n */\nchar transform_letter_case(char letter)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Hubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n * \n * Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\n * na ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n * Herufi zisizo za alfabeti zinarudishwa bila kubadilishwa.\n *\n * Matumizi:\n *   char result = transform_letter_case('b'); // result itakuwa 'B'\n *   char result = transform_letter_case('B'); // result itakuwa 'b'\n *\n * @param letter Herufi ya ingizo inayopaswa kubadilishwa.\n * @return Herufi ikiwa imebadilishwa herufi kubwa au ndogo ikiwa ni ya alfabeti, vinginevyo herufi asili.\n */\nchar transform_letter_case(char letter)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Belirtilen bir harfin büyük/küçük harf durumunu değiştirir.\n * \n * Eğer giriş küçük harf ise, büyük harf versiyonunu döndürür,\n * ve eğer giriş büyük harf ise, küçük harf versiyonunu döndürür.\n * Alfabetik olmayan karakterler değişmeden döndürülür.\n *\n * Kullanım:\n *   char result = transform_letter_case('b'); // result 'B' olacaktır\n *   char result = transform_letter_case('B'); // result 'b' olacaktır\n *\n * @param letter Dönüştürülecek giriş harfi.\n * @return Eğer alfabetikse harfin büyük/küçük harfi değiştirilmiş hali, aksi takdirde orijinal harf.\n */\nchar transform_letter_case(char letter)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Chuyển đổi kiểu chữ của một chữ cái cho trước.\n * \n * Nếu đầu vào là một chữ cái viết thường, nó sẽ trả về phiên bản viết hoa,\n * và nếu đầu vào là một chữ cái viết hoa, nó sẽ trả về phiên bản viết thường.\n * Các ký tự không phải chữ cái được trả về không thay đổi.\n *\n * Sử dụng:\n *   char result = transform_letter_case('b'); // result sẽ là 'B'\n *   char result = transform_letter_case('B'); // result sẽ là 'b'\n *\n * @param letter Chữ cái đầu vào cần được chuyển đổi.\n * @return Chữ cái với kiểu chữ được đảo ngược nếu nó là chữ cái, nếu không thì trả về chữ cái gốc.\n */\nchar transform_letter_case(char letter)"
    },
    "prompt_bertscore": {
      "es": "0.993002847567284",
      "arb": "0.9765713479265539",
      "sw": "0.9868051824182335",
      "tr": "0.9692643320994234",
      "vi": "0.9672821995270763"
    },
    "canonical_solution": "{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "es": "Escribe una función CPP `char transform_letter_case(char letter)` para resolver el siguiente problema:\nTransforma el caso de una letra dada.\n\nSi la entrada es una letra minúscula, devuelve la versión en mayúscula,\ny si la entrada es una letra mayúscula, devuelve la versión en minúscula.\nLos caracteres no alfabéticos se devuelven sin cambios.\n\nUso:\n  char result = transform_letter_case('b'); // result será 'B'\n  char result = transform_letter_case('B'); // result será 'b'\n\n@param letter La letra de entrada a transformar.\n@return La letra con su caso invertido si es alfabética, de lo contrario, la letra original.",
      "arb": "اكتب دالة CPP `char transform_letter_case(char letter)` لحل المشكلة التالية:\nتحول حالة الحرف المعطى.\n\nإذا كان الإدخال حرفًا صغيرًا، فإنه يعيد النسخة الكبيرة،\nوإذا كان الإدخال حرفًا كبيرًا، فإنه يعيد النسخة الصغيرة.\nالحروف غير الأبجدية تعاد دون تغيير.\n\nالاستخدام:\n  char result = transform_letter_case('b'); // النتيجة ستكون 'B'\n  char result = transform_letter_case('B'); // النتيجة ستكون 'b'\n\n@param letter الحرف المدخل الذي سيتم تحويله.\n@return الحرف مع عكس حالته إذا كان أبجديًا، وإلا يعاد الحرف الأصلي.",
      "sw": "Andika kazi ya CPP `char transform_letter_case(char letter)` kutatua tatizo lifuatalo:\nHubadilisha herufi kuwa katika hali tofauti.\n\nIkiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\nHerufi zisizo za alfabeti zinarudishwa bila kubadilishwa.\n\nMatumizi:\n  char result = transform_letter_case('b'); // result itakuwa 'B'\n  char result = transform_letter_case('B'); // result itakuwa 'b'\n\n@param letter Herufi ya ingizo inayopaswa kubadilishwa.\n@return Herufi ikiwa na hali yake imebadilishwa ikiwa ni ya alfabeti, vinginevyo herufi asilia.",
      "tr": "Bir CPP fonksiyonu `char transform_letter_case(char letter)` yazın: Aşağıdaki problemi çözmek için:\n\nVerilen bir harfin büyük/küçük harf durumunu dönüştürür.\n\nEğer giriş küçük harf ise, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harf ise, küçük harf versiyonunu döndürür.\nAlfabetik olmayan karakterler değişmeden geri döndürülür.\n\nKullanım:\n  char result = transform_letter_case('b'); // result 'B' olacaktır\n  char result = transform_letter_case('B'); // result 'b' olacaktır\n\n@param letter Dönüştürülecek giriş harfi.\n@return Eğer alfabetikse harfin büyük/küçük harf durumu tersine çevrilmiş hali, aksi takdirde orijinal harf.",
      "vi": "Viết một hàm CPP `char transform_letter_case(char letter)` để giải quyết vấn đề sau:\nChuyển đổi chữ hoa thành chữ thường của một chữ cái đã cho.\n\nNếu đầu vào là một chữ cái thường, nó sẽ trả về phiên bản chữ hoa,\nvà nếu đầu vào là một chữ cái hoa, nó sẽ trả về phiên bản chữ thường.\nCác ký tự không phải chữ cái được trả về không thay đổi.\n\nSử dụng:\n  char result = transform_letter_case('b'); // result sẽ là 'B'\n  char result = transform_letter_case('B'); // result sẽ là 'b'\n\n@param letter Chữ cái đầu vào cần được chuyển đổi.\n@return Chữ cái với trường hợp của nó bị đảo ngược nếu nó là chữ cái, nếu không thì trả về chữ cái gốc."
    },
    "instruction_bertscore": {
      "es": "0.9777420753923736",
      "arb": "0.9724819456418077",
      "sw": "0.9845521180061547",
      "tr": "0.9802430305199838",
      "vi": "0.9431055054386528"
    },
    "level": "easy",
    "test": "int main() {\n    assert(transform_letter_case('b') == 'B');\n    assert(transform_letter_case('B') == 'b');\n    // Additional test cases\n    assert(transform_letter_case('z') == 'Z');\n    assert(transform_letter_case('Z') == 'z');\n    assert(transform_letter_case('m') == 'M');\n    assert(transform_letter_case('M') == 'm');\n    assert(transform_letter_case('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!'); // Non-alphabetic, should be unchanged\n\n    // Uncomment the following line to print a success message (optional)\n    \n    return 0;\n}",
    "entry_point": "transform_letter_case",
    "signature": "char transform_letter_case(char letter)",
    "docstring": {
      "es": "Transforma el caso de una letra dada.\n\nSi la entrada es una letra minúscula, devuelve la versión en mayúscula,\ny si la entrada es una letra mayúscula, devuelve la versión en minúscula.\nLos caracteres no alfabéticos se devuelven sin cambios.\n\nUso:\n  char result = transform_letter_case('b'); // result será 'B'\n  char result = transform_letter_case('B'); // result será 'b'\n\n@param letter La letra de entrada a transformar.\n@return La letra con su caso invertido si es alfabética, de lo contrario, la letra original.",
      "arb": "يحوّل حالة حرف معين.\n\nإذا كان الإدخال حرفًا صغيرًا، فإنه يعيد النسخة الكبيرة،\nوإذا كان الإدخال حرفًا كبيرًا، فإنه يعيد النسخة الصغيرة.\nيتم إرجاع الأحرف غير الأبجدية دون تغيير.\n\nالاستخدام:\n  char result = transform_letter_case('b'); // النتيجة ستكون 'B'\n  char result = transform_letter_case('B'); // النتيجة ستكون 'b'\n\n@param letter الحرف المدخل المراد تحويله.\n@return الحرف مع عكس حالته إذا كان أبجديًا، وإلا الحرف الأصلي.",
      "sw": "Hubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n\nIkiwa ingizo ni herufi ndogo, itarudisha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, itarudisha toleo la herufi ndogo.\nHerufi zisizo za alfabeti zitarudishwa bila kubadilishwa.\n\nMatumizi:\n  char result = transform_letter_case('b'); // result itakuwa 'B'\n  char result = transform_letter_case('B'); // result itakuwa 'b'\n\n@param letter Herufi ya ingizo inayopaswa kubadilishwa.\n@return Herufi ikiwa imebadilishwa herufi kubwa au ndogo ikiwa ni ya alfabeti, vinginevyo herufi asili.",
      "tr": "Verilen bir harfin büyük/küçük harf durumunu değiştirir.\n\nEğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\nAlfabetik olmayan karakterler değişmeden döndürülür.\n\nKullanım:\n  char result = transform_letter_case('b'); // result 'B' olacaktır\n  char result = transform_letter_case('B'); // result 'b' olacaktır\n\n@param letter Dönüştürülecek giriş harfi.\n@return Eğer alfabetikse harfin büyük/küçük harf durumu değiştirilmiş hali, aksi takdirde orijinal harf.",
      "vi": "Biến đổi chữ hoa/thường của một chữ cái cho trước.\n\nNếu đầu vào là một chữ cái viết thường, nó trả về phiên bản viết hoa,\nvà nếu đầu vào là một chữ cái viết hoa, nó trả về phiên bản viết thường.\nCác ký tự không phải chữ cái được trả về không thay đổi.\n\nSử dụng:\n  char result = transform_letter_case('b'); // result sẽ là 'B'\n  char result = transform_letter_case('B'); // result sẽ là 'b'\n\n@param letter Chữ cái đầu vào cần được biến đổi.\n@return Chữ cái với chữ hoa/thường đảo ngược nếu nó là chữ cái, ngược lại trả về chữ cái gốc."
    },
    "docstring_bertscore": {
      "es": "0.9691956059875854",
      "arb": "0.9749842911820852",
      "sw": "0.9756284495077813",
      "tr": "0.9621001315162572",
      "vi": "0.9582913939599131"
    }
  },
  {
    "task_id": "CPP/28",
    "prompt": {
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Muestra la información ASCII para un carácter dado.\n * \n * @param character El carácter de entrada para el cual se mostrará la información ASCII.\n * @return El código ASCII correspondiente.\n * \n * Ejemplo:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "arb": "```cpp\n#include <cassert>\n#include <cstdio>\n/**\n * يعرض معلومات ASCII لحرف معين.\n * \n * @param character الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n * @return رمز ASCII المقابل.\n * \n * مثال:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)\n```",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Inaonyesha taarifa za ASCII kwa herufi iliyotolewa.\n * \n * @param character Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n * @return Nambari ya ASCII inayolingana.\n * \n * Mfano:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Belirtilen bir karakter için ASCII bilgisini görüntüler.\n * \n * @param character ASCII bilgisinin görüntüleneceği giriş karakteri.\n * @return Karşılık gelen ASCII kodu.\n * \n * Örnek:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Çıktı: 65\n * ```\n */\nint display_ascii_info(char character)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Hiển thị thông tin ASCII cho một ký tự nhất định.\n * \n * @param character Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n * @return Mã ASCII tương ứng.\n * \n * Ví dụ:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)"
    },
    "prompt_bertscore": {
      "es": "0.9939854720622636",
      "arb": "0.9615664116824164",
      "sw": "0.963471277036541",
      "tr": "0.9725053840267698",
      "vi": "0.9647234429585849"
    },
    "canonical_solution": "{\n    return character;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int display_ascii_info(char character)` para resolver el siguiente problema:\nMuestra la información ASCII para un carácter dado.\n\n@param character El carácter de entrada para el cual se mostrará la información ASCII.\n@return El código ASCII correspondiente.\n\nExample:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "arb": "اكتب دالة CPP `int display_ascii_info(char character)` لحل المشكلة التالية:\nيعرض معلومات ASCII للحرف المعطى.\n\n@param character الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n@return رمز ASCII المقابل.\n\nمثال:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "sw": "Andika kazi ya CPP `int display_ascii_info(char character)` kutatua tatizo lifuatalo: \nOnyesha taarifa za ASCII kwa herufi iliyotolewa.\n\n@param character Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n@return Msimbo wa ASCII unaolingana.\n\nMfano:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "tr": "Bir CPP fonksiyonu `int display_ascii_info(char character)` yazın: \nVerilen bir karakter için ASCII bilgisini görüntüler.\n\n@param character ASCII bilgisinin görüntüleneceği giriş karakteri.\n@return Karşılık gelen ASCII kodu.\n\nÖrnek:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Çıktı: 65\n```",
      "vi": "Viết một hàm CPP `int display_ascii_info(char character)` để giải quyết vấn đề sau:  \nHiển thị thông tin ASCII cho một ký tự đã cho.\n\n@param character Ký tự đầu vào mà thông tin ASCII cần được hiển thị.  \n@return Mã ASCII tương ứng.\n\nVí dụ:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```"
    },
    "instruction_bertscore": {
      "es": "0.9929514022985959",
      "arb": "0.9856082357421172",
      "sw": "0.9586334354760552",
      "tr": "0.9473291818609787",
      "vi": "0.9847861045950138"
    },
    "level": "easy",
    "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    \n    // Uncomment the line below to print a success message if compiled outside a test framework\n    // std::printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
    "entry_point": "display_ascii_info",
    "signature": "int display_ascii_info(char character)",
    "docstring": {
      "es": "Muestra la información ASCII para un carácter dado.\n\n@param character El carácter de entrada para el cual se mostrará la información ASCII.\n@return El código ASCII correspondiente.\n\nEjemplo:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "arb": "يعرض معلومات ASCII للحرف المعطى.\n\n@param character الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n@return كود ASCII المقابل.\n\nمثال:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "sw": "Inaonyesha habari za ASCII kwa herufi iliyotolewa.\n\n@param character Herufi ya ingizo ambayo habari za ASCII zinaonyeshwa.\n@return Nambari ya ASCII inayolingana.\n\nMfano:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "tr": "Belirtilen karakter için ASCII bilgisini görüntüler.\n\n@param character ASCII bilgisinin görüntüleneceği giriş karakteri.\n@return Karşılık gelen ASCII kodu.\n\nÖrnek:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Çıktı: 65\n```",
      "vi": "Hiển thị thông tin ASCII cho một ký tự được cung cấp.\n\n@param character Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n@return Mã ASCII tương ứng.\n\nVí dụ:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```"
    },
    "docstring_bertscore": {
      "es": "0.9905988240656187",
      "arb": "0.9707629983243317",
      "sw": "0.9439008214843165",
      "tr": "0.9803308251484012",
      "vi": "0.9659237663511787"
    }
  },
  {
    "task_id": "CPP/29",
    "prompt": {
      "es": "#include <cassert> // Usado para hacer afirmaciones en casos de prueba\n/**\n * @brief Evalúa la calificación para un número entero de entrada.\n * \n * @param score La puntuación entera que se va a evaluar.\n * @return char La calificación correspondiente a la puntuación de entrada.\n *              Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n *              De lo contrario, devuelve 'B'.\n * \n * Ejemplos:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "arb": "#include <cassert> // مستخدم لإجراء التأكيدات في حالات الاختبار\n/**\n * @brief تقييم الدرجة لعدد صحيح مدخل.\n * \n * @param score الدرجة الصحيحة التي سيتم تقييمها.\n * @return char الدرجة المقابلة للدرجة المدخلة.\n *              إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n *              خلاف ذلك، تعيد 'B'.\n * \n * أمثلة:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "sw": "#include <cassert> // Inatumika kwa kufanya uthibitisho katika kesi za majaribio\n/**\n * @brief Tambua daraja kwa namba kamili iliyoingizwa.\n * \n * @param score Alama ya namba kamili inayotakiwa kutathminiwa.\n * @return char Daraja linalolingana na alama iliyoingizwa.\n *              Ikiwa alama iko kati ya 90 na 100 (pamoja), inarudisha 'A'.\n *              Vinginevyo, inarudisha 'B'.\n * \n * Mifano:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "tr": "#include <cassert> // Test durumlarında doğrulama yapmak için kullanılır\n/**\n * @brief Bir tam sayı için notu değerlendirir.\n * \n * @param score Değerlendirilecek tam sayı puanı.\n * @return char Girdi puanına karşılık gelen not.\n *              Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döner.\n *              Aksi takdirde, 'B' döner.\n * \n * Örnekler:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "vi": "#include <cassert> // Được sử dụng để thực hiện các khẳng định trong các trường hợp kiểm tra\n/**\n * @brief Đánh giá điểm cho một số nguyên đầu vào.\n * \n * @param score Điểm số nguyên cần được đánh giá.\n * @return char Điểm tương ứng với điểm số đầu vào.\n *              Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n *              Ngược lại, trả về 'B'.\n * \n * Ví dụ:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)"
    },
    "prompt_bertscore": {
      "es": "0.9974871270495276",
      "arb": "0.996891633167185",
      "sw": "0.9728613296695843",
      "tr": "0.9862194214245615",
      "vi": "0.972359192066328"
    },
    "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}",
    "instruction": {
      "es": "Escribe una función CPP `char evaluate_integer_grade(int score)` para resolver el siguiente problema:\nEvalúa la calificación para un entero de entrada.\n\n@param score El puntaje entero a ser evaluado.\n@return char La calificación correspondiente al puntaje de entrada.\n             Si el puntaje está entre 90 y 100 (inclusive), devuelve 'A'.\n             De lo contrario, devuelve 'B'.\n\nEjemplos:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "arb": "اكتب دالة CPP `char evaluate_integer_grade(int score)` لحل المشكلة التالية:\nتقييم الدرجة لعدد صحيح مدخل.\n\n@param score العدد الصحيح الذي سيتم تقييمه.\n@return char الدرجة المقابلة للعدد المدخل.\n             إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n             خلاف ذلك، تعيد 'B'.\n\nأمثلة:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "sw": "Andika kazi ya CPP `char evaluate_integer_grade(int score)` kutatua tatizo lifuatalo:\nTambua alama kwa namba kamili iliyoingizwa.\n\n@param score Namba kamili ya alama itakayopimwa.\n@return char Alama inayolingana na alama iliyoingizwa.\n             Ikiwa alama iko kati ya 90 na 100 (pamoja), inarudisha 'A'.\n             Vinginevyo, inarudisha 'B'.\n\nMifano:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "tr": "Bir CPP fonksiyonu `char evaluate_integer_grade(int score)` yazın: Aşağıdaki problemi çözmek için:\nBir tamsayı notunu değerlendirin.\n\n@param score Değerlendirilecek tamsayı notu.\n@return char Girdi notuna karşılık gelen harf notu.\n             Eğer not 90 ile 100 arasında (dahil) ise, 'A' döner.\n             Aksi takdirde, 'B' döner.\n\nÖrnekler:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "vi": "Viết một hàm CPP `char evaluate_integer_grade(int score)` để giải quyết vấn đề sau:  \nĐánh giá điểm cho một số nguyên đầu vào.\n\n@param score Số nguyên điểm cần được đánh giá.  \n@return char Điểm tương ứng với điểm đầu vào.  \n             Nếu điểm nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \n             Ngược lại, trả về 'B'.\n\nVí dụ:  \n    evaluate_integer_grade(90) -> 'A'  \n    evaluate_integer_grade(89) -> 'B'  "
    },
    "instruction_bertscore": {
      "es": "0.9958704743782847",
      "arb": "0.9875407107192056",
      "sw": "0.9701108947833942",
      "tr": "0.9713926566322123",
      "vi": "0.9747848662795261"
    },
    "level": "easy",
    "test": "int main() {\n    assert(evaluate_integer_grade(90) == 'A'); // Test for lower bound of 'A' grade\n    assert(evaluate_integer_grade(89) == 'B'); // Test for score just below 'A' grade\n    assert(evaluate_integer_grade(95) == 'A'); // Test for a score well within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A'); // Test for upper boundary of 'A' grade\n    assert(evaluate_integer_grade(101) == 'B'); // Test for score above 'A' grade range\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // std::cout << \"All tests passed\\n\";\n\n    return 0;\n}",
    "entry_point": "evaluate_integer_grade",
    "signature": "char evaluate_integer_grade(int score)",
    "docstring": {
      "es": "Evaluar la calificación para un entero de entrada.\n\n@param score El puntaje entero a evaluar.\n@return char La calificación correspondiente al puntaje de entrada.\n             Si el puntaje está entre 90 y 100 (inclusive), devuelve 'A'.\n             De lo contrario, devuelve 'B'.\n\nEjemplos:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "arb": "تقييم الدرجة لعدد صحيح مدخل.\n\n@param score الدرجة الصحيحة التي سيتم تقييمها.\n@return char الدرجة المقابلة للدرجة المدخلة.\n             إذا كانت الدرجة بين 90 و100 (شاملة)، تُرجع 'A'.\n             خلاف ذلك، تُرجع 'B'.\n\nأمثلة:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "sw": "Tambua alama kwa namba kamili iliyoingizwa.\n\n@param score Namba kamili ya alama itakayopimwa.\n@return char Daraja linalolingana na alama iliyoingizwa.\n             Ikiwa alama iko kati ya 90 na 100 (pamoja), inarudisha 'A'.\n             Vinginevyo, inarudisha 'B'.\n\nMifano:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "tr": "Girdi tamsayısı için notu değerlendirir.\n\n@param score Değerlendirilecek tamsayı puanı.\n@return char Girdi puanına karşılık gelen not.\n             Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n             Aksi takdirde, 'B' döndürür.\n\nÖrnekler:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "vi": "Đánh giá điểm cho một số nguyên đầu vào.\n\n@param score Số nguyên điểm cần được đánh giá.\n@return char Điểm tương ứng với điểm đầu vào.\n             Nếu điểm nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n             Ngược lại, trả về 'B'.\n\nVí dụ:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'"
    },
    "docstring_bertscore": {
      "es": "0.9885209516496127",
      "arb": "0.986540408120314",
      "sw": "0.9414002636174683",
      "tr": "0.9940251981384706",
      "vi": "0.9563642820031126"
    }
  },
  {
    "task_id": "CPP/30",
    "prompt": {
      "es": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Verifica si una cadena de tres caracteres tiene exactamente dos caracteres iguales.\n * \n * @param s Una cadena de tres caracteres a verificar.\n * \n * @return Devuelve \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\n * Ejemplos:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "arb": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n * \n * @param s سلسلة مكونة من ثلاثة أحرف للتحقق منها.\n * \n * @return يعيد \"Yes\" إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد \"No\".\n * أمثلة:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "sw": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Hukagua kama mfuatano wa herufi tatu una herufi mbili sawa.\n * \n * @param s Mfuatano wa herufi tatu unaopaswa kukaguliwa.\n * \n * @return Inarudisha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\n * Mifano:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "tr": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n * \n * @param s Kontrol edilecek üç karakterli bir dizge.\n * \n * @return Girdi tam olarak iki eşit karaktere sahipse \"Yes\" döndürür, aksi takdirde \"No\".\n * Örnekler:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "vi": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n * \n * @param s Một chuỗi ba ký tự cần được kiểm tra.\n * \n * @return Trả về \"Yes\" nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại \"No\".\n * Ví dụ:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])"
    },
    "prompt_bertscore": {
      "es": "0.9673626448313954",
      "arb": "0.9761744844252462",
      "sw": "0.9587244081905693",
      "tr": "0.9887980410311564",
      "vi": "0.974385817844027"
    },
    "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "es": "Escribe una función CPP `const char* check_two_equal_digits(const char s[4])` para resolver el siguiente problema:\nVerifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n \nParámetros:\n@param s Una cadena de tres caracteres a ser verificada.\n \nRetorna:\nRetorna \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\nEjemplos:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "arb": "اكتب دالة CPP `const char* check_two_equal_digits(const char s[4])` لحل المشكلة التالية:\nالتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متشابهين بالضبط.\n\nالمعلمات:\n@param s سلسلة مكونة من ثلاثة أحرف ليتم التحقق منها.\n\nالقيم المعادة:\nتعيد \"Yes\" إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا تعيد \"No\".\nأمثلة:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "sw": "Andika kazi ya CPP `const char* check_two_equal_digits(const char s[4])` kutatua tatizo lifuatalo:\nHukagua kama kamba ya herufi tatu ina herufi mbili tu ambazo ni sawa.\n\nVigezo:\n@param s Kamba ya herufi tatu inayopaswa kukaguliwa.\n\nInarejesha:\nInarejesha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\nMifano:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "tr": "Bir CPP fonksiyonu `const char* check_two_equal_digits(const char s[4])` yazın ve aşağıdaki problemi çözün:\nÜç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nParametreler:\n@param s Kontrol edilecek üç karakterli bir dizge.\n\nDöndürülen Değer:\nGirdi tam olarak iki eşit karaktere sahipse \"Yes\", aksi takdirde \"No\" döndürür.\nÖrnekler:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "vi": "Viết một hàm CPP `const char* check_two_equal_digits(const char s[4])` để giải quyết vấn đề sau:  \nKiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:  \n@param s Một chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:  \nTrả về \"Yes\" nếu đầu vào có chính xác hai ký tự giống nhau, ngược lại trả về \"No\".  \nVí dụ:  \n  >>> check_two_equal_digits(\"112\")  \n  \"Yes\"  \n  >>> check_two_equal_digits(\"123\")  \n  \"No\"  "
    },
    "instruction_bertscore": {
      "es": "0.9821999370339395",
      "arb": "0.9633401809850579",
      "sw": "0.9814942032901226",
      "tr": "0.9767191289300439",
      "vi": "0.9764732245183226"
    },
    "level": "easy",
    "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(check_two_equal_digits(\"112\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"123\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"232\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(check_two_equal_digits(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(check_two_equal_digits(\"787\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(check_two_equal_digits(\"890\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"556\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}",
    "entry_point": "check_two_equal_digits",
    "signature": "const char* check_two_equal_digits(const char s[4])",
    "docstring": {
      "es": "Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nParámetros:\n@param s Una cadena de tres caracteres a verificar.\n\nDevuelve:\nDevuelve \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\nEjemplos:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "arb": "يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nالمعلمات:\n@param s سلسلة مكونة من ثلاثة أحرف ليتم التحقق منها.\n\nالإرجاع:\nيعيد \"Yes\" إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد \"No\".\n\nأمثلة:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "sw": "Hukagua kama mfuatano wa herufi tatu una herufi mbili sawa.\n\nVigezo:\n@param s Mfuatano wa herufi tatu unaopaswa kukaguliwa.\n\nInarejesha:\nInarejesha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\nMifano:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "tr": "Üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nParametreler:\n@param s Kontrol edilecek üç karakterli bir dizge.\n\nDöndürülenler:\nGirdi tam olarak iki eşit karakter içeriyorsa \"Evet\", aksi takdirde \"Hayır\" döndürür.\nÖrnekler:\n  >>> check_two_equal_digits(\"112\")\n  \"Evet\"\n  >>> check_two_equal_digits(\"123\")\n  \"Hayır\"",
      "vi": "Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:\n@param s Một chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\nTrả về \"Yes\" nếu đầu vào có chính xác hai ký tự bằng nhau, nếu không thì \"No\".\nVí dụ:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\""
    },
    "docstring_bertscore": {
      "es": "0.9797782354283622",
      "arb": "0.9739804132363348",
      "sw": "0.9386220204779333",
      "tr": "0.9735255496637649",
      "vi": "0.9741909614402318"
    }
  },
  {
    "task_id": "CPP/31",
    "prompt": {
      "es": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Dada una cadena compuesta de letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar\n * uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo\n * de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\n * \n * Ejemplos:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "arb": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * بالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير\n * أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى\n * لعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف؟\n * \n * أمثلة:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "sw": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Ukipewa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha\n * moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ya chini ya raundi zinazohitajika\n * kufanya kamba iwe na herufi sawa?\n * \n * Mifano:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "tr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Küçük İngiliz harflerinden oluşan bir dize verildiğinde, her turda karakterlerden birini\n * başka bir karaktere değiştirebilirsiniz. Soru şu: diziyi aynı karakterden oluşacak şekilde\n * yapmak için gereken minimum tur sayısı nedir?\n * \n * Örnekler:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "vi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Cho một chuỗi gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi\n * một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu\n * vòng để làm cho chuỗi được tạo thành từ cùng một ký tự?\n * \n * Ví dụ:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)"
    },
    "prompt_bertscore": {
      "es": "0.9841769052163798",
      "arb": "0.9910590506584765",
      "sw": "0.9805582569346862",
      "tr": "0.9906192829948653",
      "vi": "0.9952211516626817"
    },
    "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n",
    "instruction": {
      "es": "Escribe una función CPP `int minRoundsToSameChar(const char* s)` para resolver el siguiente problema:\nDada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\n\nEjemplos:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "arb": "اكتب دالة CPP `int minRoundsToSameChar(const char* s)` لحل المشكلة التالية:\nبالنظر إلى سلسلة تتكون من حروف إنجليزية صغيرة، في كل جولة يمكنك تغيير\nأحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى\nلعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف؟\n\nأمثلة:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "sw": "Andika kazi ya CPP `int minRoundsToSameChar(const char* s)` kutatua tatizo lifuatalo:  \nUkipiwa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo ya raundi inayohitajika ili kufanya kamba iwe na herufi sawa?\n\nMifano:  \n>>> minRoundsToSameChar(\"aab\")  \n1  \n>>> minRoundsToSameChar(\"abc\")  \n2  \n>>> minRoundsToSameChar(\"aaa\")  \n0",
      "tr": "Bir CPP fonksiyonu `int minRoundsToSameChar(const char* s)` yazın ve aşağıdaki problemi çözün:\nKüçük İngiliz harflerinden oluşan bir dizi verildiğinde, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\n\nÖrnekler:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "vi": "Viết một hàm CPP `int minRoundsToSameChar(const char* s)` để giải quyết vấn đề sau:  \nCho một chuỗi gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu vòng để làm cho chuỗi được tạo thành từ cùng một ký tự?\n\nVí dụ:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0"
    },
    "instruction_bertscore": {
      "es": "0.9884657324036851",
      "arb": "0.9955528643990099",
      "sw": "0.9815690869437728",
      "tr": "0.9911490302210854",
      "vi": "0.9946665756388322"
    },
    "level": "middle",
    "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "int minRoundsToSameChar(const char* s)",
    "docstring": {
      "es": "Dada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para que la cadena esté compuesta por el mismo carácter?\n\nEjemplos:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "arb": "بالنظر إلى سلسلة تتكون من حروف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف؟\n\nأمثلة:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "sw": "Kwa kuzingatia kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo zaidi ya raundi zinazohitajika ili kufanya kamba iwe na herufi sawa?\n\nMifano:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "tr": "Verilen küçük İngilizce harflerden oluşan bir dize için, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\n\nÖrnekler:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: số vòng tối thiểu cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự là bao nhiêu?\n\nVí dụ:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0"
    },
    "docstring_bertscore": {
      "es": "0.9741035640725765",
      "arb": "0.977773061731815",
      "sw": "0.9767814988696888",
      "tr": "0.9818455804341732",
      "vi": "0.9915151060133327"
    }
  },
  {
    "task_id": "CPP/32",
    "prompt": {
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, la tarea es encontrar\n * el año Y_n cuando ocurre el n-ésimo evento. La cuenta regresiva para el evento i+1 solo comienza en el año\n * inmediatamente después de la ocurrencia del evento i.\n * Ejemplo de uso:\n *     apocalypseYear(6, {3,2,4,5,9,18}) devuelve 36\n */\nint apocalypseYear(int n, int signs[])",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى تسلسل من n أحداث، كل منها يحدث بدورية a_i سنوات، المهمة هي إيجاد\n * السنة Y_n عندما يحدث الحدث n. يبدأ العد التنازلي للحدث i+1 فقط في السنة\n * التي تلي مباشرة حدوث الحدث i.\n * مثال على الاستخدام:\n *     apocalypseYear(6, {3,2,4,5,9,18}) returns 36\n */\nint apocalypseYear(int n, int signs[])",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, kazi ni kupata\n * mwaka Y_n ambapo tukio la n linatokea. Hesabu ya tukio i+1 inaanza tu katika mwaka\n * unaofuata mara baada ya tukio i kutokea.\n * Mfano wa matumizi:\n *     apocalypseYear(6, {3,2,4,5,9,18}) inarudisha 36\n */\nint apocalypseYear(int n, int signs[])",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * n olayından oluşan bir dizi verildiğinde, her biri a_i yıl periyoduyla gerçekleşen, \n * n'inci olayın gerçekleştiği Y_n yılını bulma görevi. i+1'inci olayın geri sayımı, \n * yalnızca i'inci olayın gerçekleştiği yılın hemen ardından başlar.\n * Örnek kullanım:\n *     apocalypseYear(6, {3,2,4,5,9,18}) 36 döndürür\n */\nint apocalypseYear(int n, int signs[])",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho một chuỗi n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, nhiệm vụ là tìm\n * năm Y_n khi sự kiện thứ n xảy ra. Đếm ngược cho sự kiện i+1 chỉ bắt đầu vào năm\n * ngay sau khi sự kiện i xảy ra.\n * Ví dụ sử dụng:\n *     apocalypseYear(6, {3,2,4,5,9,18}) trả về 36\n */\nint apocalypseYear(int n, int signs[])"
    },
    "prompt_bertscore": {
      "es": "0.9930834915019842",
      "arb": "0.9603287457781879",
      "sw": "0.9685939545634307",
      "tr": "0.9600033892140528",
      "vi": "0.9682970021437836"
    },
    "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}",
    "instruction": {
      "es": "Escribe una función en CPP `int apocalypseYear(int n, int signs[])` para resolver el siguiente problema:\nDada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, la tarea es encontrar el año Y_n cuando ocurre el n-ésimo evento. La cuenta regresiva para el evento i+1 solo comienza en el año inmediatamente posterior a la ocurrencia del evento i.\nEjemplo de uso:\napocalypseYear(6, {3,2,4,5,9,18}) devuelve 36",
      "arb": "اكتب دالة CPP `int apocalypseYear(int n, int signs[])` لحل المشكلة التالية:\nبالنظر إلى تسلسل من n أحداث، كل منها يحدث بشكل دوري كل a_i سنوات، المهمة هي إيجاد\nالسنة Y_n عندما يحدث الحدث n. يبدأ العد التنازلي للحدث i+1 فقط في السنة\nالتي تلي مباشرة حدوث الحدث i.\nمثال على الاستخدام:\napocalypseYear(6, {3,2,4,5,9,18}) يعيد 36",
      "sw": "Andika kazi ya CPP `int apocalypseYear(int n, int signs[])` kutatua tatizo lifuatalo:\nUkipewa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, kazi ni kupata\nmwaka Y_n ambapo tukio la n linatokea. Muda wa kuhesabu kwa tukio i+1 unaanza tu katika mwaka\nunaofuata mara tu baada ya tukio i kutokea.\nMfano wa matumizi:\napocalypseYear(6, {3,2,4,5,9,18}) inarudisha 36",
      "tr": "Bir CPP fonksiyonu `int apocalypseYear(int n, int signs[])` yazın ve aşağıdaki problemi çözün:\nn olayından oluşan bir dizisi verildiğinde, her biri a_i yıllık bir periyodiklikle meydana gelen, görev\nn'inci olayın gerçekleştiği Y_n yılını bulmaktır. i+1 olayının geri sayımı yalnızca i olayının meydana geldiği yılın hemen ardından başlar.\nÖrnek kullanım:\napocalypseYear(6, {3,2,4,5,9,18}) 36 döndürür",
      "vi": "Viết một hàm CPP `int apocalypseYear(int n, int signs[])` để giải quyết vấn đề sau:\nCho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, nhiệm vụ là tìm\nnăm Y_n khi sự kiện thứ n xảy ra. Đếm ngược cho sự kiện i+1 chỉ bắt đầu vào năm\nngay sau khi sự kiện i xảy ra.\nVí dụ sử dụng:\napocalypseYear(6, {3,2,4,5,9,18}) trả về 36"
    },
    "instruction_bertscore": {
      "es": "0.9883922391627021",
      "arb": "0.9618486654538669",
      "sw": "0.9727862473855531",
      "tr": "0.9576996740548102",
      "vi": "0.964155161438444"
    },
    "level": "easy",
    "test": "int main() {\n    int arr1[] = {3,2,4,5,9,18};\n    assert(apocalypseYear(6, arr1) == 36);\n    int arr2[] = {1, 2,3,4,5};\n    assert(apocalypseYear(5, arr2) == 5);\n    int arr3[] = {1,1,1,1,1};\n    assert(apocalypseYear(5, arr3) == 5);\n    int arr4[] = {50,30,711,200,503,1006};\n    assert(apocalypseYear(6, arr4) == 2012);\n    int arr5[] = {1, 2};\n    assert(apocalypseYear(2, arr5) == 2);\n    int arr6[] = {3, 1, 2};\n    assert(apocalypseYear(3, arr6) == 6);\n    int arr7[] = {2, 3, 4};\n    assert(apocalypseYear(3, arr7) == 4);\n    int arr8[] = {1, 2, 3, 4};\n    assert(apocalypseYear(4, arr8) == 4);\n    int arr9[] = {5, 7, 11, 13};\n    assert(apocalypseYear(4, arr9) == 13);\n    int arr10[] = {2, 2, 2, 2, 2};\n    assert(apocalypseYear(5, arr10) == 10);\n    int arr11[] = {6, 10, 15};\n    assert(apocalypseYear(3, arr11) == 15);\n    int arr12[] = {4, 6, 14};\n    assert(apocalypseYear(3, arr12) == 14);\n    int arr13[] = {50, 30, 711, 200};\n    assert(apocalypseYear(4, arr13) == 800);\n    int arr14[] = {1, 1, 1, 1, 1, 1};\n    assert(apocalypseYear(6, arr14) == 6);\n    int arr15[] = {1000000, 999999};\n    assert(apocalypseYear(2, arr15) == 1999998);\n    return 0;\n}",
    "entry_point": "apocalypseYear",
    "signature": "int apocalypseYear(int n, int signs[])",
    "docstring": {
      "es": "Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, la tarea es encontrar el año Y_n cuando ocurre el n-ésimo evento. La cuenta regresiva para el evento i+1 solo comienza en el año inmediatamente posterior a la ocurrencia del evento i.\n\nEjemplo de uso:\napocalypseYear(6, {3,2,4,5,9,18}) devuelve 36",
      "arb": "بالنظر إلى تسلسل من n من الأحداث، كل منها يحدث بتكرار دوري قدره a_i سنوات، فإن المهمة هي إيجاد السنة Y_n عندما يحدث الحدث n. يبدأ العد التنازلي للحدث i+1 فقط في السنة التي تلي مباشرة حدوث الحدث i.\n\nاستخدام المثال:\napocalypseYear(6, {3,2,4,5,9,18}) يعيد 36",
      "sw": "Kwa kuzingatia mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, kazi ni kupata mwaka Y_n ambapo tukio la n linatokea. Hesabu ya tukio i+1 inaanza tu katika mwaka unaofuata mara baada ya tukio i kutokea.\n\nMfano wa matumizi:\napocalypseYear(6, {3,2,4,5,9,18}) inarudisha 36",
      "tr": "Verilen n adet olaydan oluşan bir dizide, her biri a_i yıllık bir periyodiklikle meydana gelen olaylar için, n'inci olayın gerçekleştiği yıl Y_n bulunmalıdır. i+1'inci olayın geri sayımı, yalnızca i'inci olayın gerçekleştiği yılın hemen ardından başlar.\nÖrnek kullanım:\napocalypseYear(6, {3,2,4,5,9,18}) 36 döndürür",
      "vi": "Cho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, nhiệm vụ là tìm năm Y_n khi sự kiện thứ n xảy ra. Đếm ngược cho sự kiện i+1 chỉ bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\nVí dụ sử dụng:\n\napocalypseYear(6, {3,2,4,5,9,18}) trả về 36"
    },
    "docstring_bertscore": {
      "es": "0.9914902772157034",
      "arb": "0.9568781387988499",
      "sw": "0.9487758069260558",
      "tr": "0.9145212031950651",
      "vi": "1"
    }
  },
  {
    "task_id": "CPP/33",
    "prompt": {
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Este problema introduce una operación de módulo personalizada, denotada por \"⊕\".\n * Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es x % y.\n * Si x es un múltiplo de y, divide x por y repetidamente hasta que x ya no sea un\n * múltiplo de y, denotando este valor final como x'. Entonces el resultado es x' % y.\n * Por ejemplo:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Dado un número primo p, necesitas manejar varias consultas donde se te da\n * un entero n y debes calcular n! ⊕ p. Aquí, n! es el factorial de n.\n * Ejemplo:\n *    newModuloFactorial(3, 7) devuelve 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "arb": "```cpp\n#include <cassert>\n#include <cstdio>\n/**\n * هذه المسألة تقدم عملية باقي مخصصة، يرمز لها بـ \"⊕\".\n * عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي x % y.\n * إذا كان x مضاعفًا لـ y، قم بتقسيم x على y بشكل متكرر حتى لا يكون x\n * مضاعفًا لـ y، مشيرًا إلى هذه القيمة النهائية بـ x'. ثم تكون النتيجة x' % y.\n * على سبيل المثال:\n * - 4⊕5=4،\n * - 20⊕5=4،\n * - 100⊕5=4.\n * بالنظر إلى عدد أولي p، تحتاج إلى معالجة عدة استفسارات حيث يُعطى لك\n * عدد صحيح n ويجب عليك حساب n! ⊕ p. هنا، n! هو العامل المضاعف لـ n.\n * مثال:\n *    newModuloFactorial(3, 7) يعيد 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n```",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Shida hii inatambulisha operesheni maalum ya modulo, inayojulikana kama \"⊕\".\n * Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni x % y.\n * Ikiwa x ni kigezo cha y, gawanya x kwa y mara kwa mara hadi x isiwe tena\n * kigezo cha y, ukitaja thamani hii ya mwisho kama x'. Kisha matokeo ni x' % y.\n * Kwa mfano:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Ukipewa nambari ya kwanza p, unahitaji kushughulikia maswali kadhaa ambapo unapewa\n * nambari nzima n na lazima uhisabu n! ⊕ p. Hapa, n! ni factorial ya n.\n * Mfano:\n *    newModuloFactorial(3, 7) inarudisha 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Bu problem, \"⊕\" ile gösterilen özel bir modül işlemi tanıtır.\n * x ⊕ y hesaplanırken, x y'nin katı değilse, sonuç x % y olur.\n * Eğer x y'nin katıysa, x y'nin katı olmayana kadar x'i y'ye bölün,\n * bu son değeri x' olarak belirtin. Sonuç x' % y olur.\n * Örneğin:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Verilen bir asal sayı p ile, birkaç sorguyu ele almanız gerekiyor\n * burada size bir tamsayı n verilir ve n! ⊕ p hesaplamanız gerekir.\n * Burada n!, n'nin faktöriyelidir.\n * Örnek:\n *    newModuloFactorial(3, 7) 6 döndürür\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "vi": "```cpp\n#include <cassert>\n#include <cstdio>\n/**\n * Vấn đề này giới thiệu một phép toán modulo tùy chỉnh, ký hiệu là \"⊕\".\n * Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là x % y.\n * Nếu x là bội số của y, chia x cho y lặp đi lặp lại cho đến khi x không còn\n * là bội số của y, ký hiệu giá trị cuối cùng này là x'. Sau đó kết quả là x' % y.\n * Ví dụ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Cho một số nguyên tố p, bạn cần xử lý một số truy vấn trong đó bạn được cho\n * một số nguyên n và bạn phải tính n! ⊕ p. Ở đây, n! là giai thừa của n.\n * Ví dụ:\n *    newModuloFactorial(3, 7) trả về 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n```"
    },
    "prompt_bertscore": {
      "es": "0.9982476827785102",
      "arb": "0.9834401851331214",
      "sw": "0.9827640473160786",
      "tr": "0.968817612372476",
      "vi": "0.9756359974622606"
    },
    "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función CPP `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` para resolver el siguiente problema:\nEste problema introduce una operación de módulo personalizada, denotada por \"⊕\".\nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es x % y.\nSi x es un múltiplo de y, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando este valor final como x'. Entonces el resultado es x' % y.\nPor ejemplo:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nDado un número primo p, necesitas manejar varias consultas donde se te da un entero n y debes calcular n! ⊕ p. Aquí, n! es el factorial de n.\nEjemplo:\n   newModuloFactorial(3, 7) devuelve 6",
      "arb": "اكتب دالة CPP `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` لحل المشكلة التالية:\nتقدم هذه المشكلة عملية باقي مخصصة، يرمز لها بـ \"⊕\".\nعند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي x % y.\nإذا كان x مضاعفًا لـ y، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مشيرًا إلى هذه القيمة النهائية بـ x'. ثم تكون النتيجة x' % y.\nعلى سبيل المثال:\n- 4⊕5=4،\n- 20⊕5=4،\n- 100⊕5=4.\nبالنظر إلى عدد أولي p، تحتاج إلى معالجة عدة استفسارات حيث يُعطى لك عدد صحيح n ويجب عليك حساب n! ⊕ p. هنا، n! هو مضروب n.\nمثال:\n   newModuloFactorial(3, 7) returns 6",
      "sw": "Andika kazi ya CPP `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` kutatua tatizo lifuatalo:\nTatizo hili linaanzisha operesheni ya modulo maalum, inayojulikana kama \"⊕\".\nWakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni x % y.\nIkiwa x ni kigezo cha y, gawanya x kwa y mara kwa mara hadi x isiwe tena\nkigezo cha y, ukionyesha thamani hii ya mwisho kama x'. Kisha matokeo ni x' % y.\nKwa mfano:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nUkipiwa nambari ya msingi p, unahitaji kushughulikia maswali kadhaa ambapo unapewa\nnambari nzima n na lazima uhakiki n! ⊕ p. Hapa, n! ni factorial ya n.\nMfano:\n   newModuloFactorial(3, 7) inarudisha 6",
      "tr": "Bir CPP fonksiyonu `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` yazın ve aşağıdaki problemi çözün:\nBu problem, \"⊕\" ile gösterilen özel bir modül işlemi tanıtır.\nx ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x % y'dir.\nEğer x, y'nin katı ise, x artık y'nin katı olmayana kadar x'i tekrar tekrar y'ye bölün, bu son değeri x' olarak belirtin. Sonuç x' % y'dir.\nÖrneğin:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nVerilen bir asal sayı p ile, size bir tamsayı n verildiğinde n! ⊕ p hesaplamanız gereken birkaç sorguyu ele almanız gerekir. Burada, n! n'nin faktöriyelidir.\nÖrnek:\n   newModuloFactorial(3, 7) 6 döndürür.",
      "vi": "Viết một hàm CPP `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` để giải quyết vấn đề sau:\nVấn đề này giới thiệu một phép toán modulo tùy chỉnh, được ký hiệu là \"⊕\".\nKhi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là x % y.\nNếu x là bội số của y, chia x cho y liên tục cho đến khi x không còn là\nbội số của y, ký hiệu giá trị cuối cùng này là x'. Sau đó kết quả là x' % y.\nVí dụ:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nCho trước một số nguyên tố p, bạn cần xử lý nhiều truy vấn trong đó bạn được cho\nmột số nguyên n và bạn phải tính n! ⊕ p. Ở đây, n! là giai thừa của n.\nVí dụ:\n   newModuloFactorial(3, 7) trả về 6"
    },
    "instruction_bertscore": {
      "es": "0.9957793030333897",
      "arb": "0.993389978179921",
      "sw": "0.9789406111115381",
      "tr": "0.976082518558827",
      "vi": "0.985533153458086"
    },
    "level": "easy",
    "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}",
    "entry_point": "newModuloFactorial",
    "signature": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
    "docstring": {
      "es": "Este problema introduce una operación de módulo personalizada, denotada por \"⊕\".\nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es x % y.\nSi x es un múltiplo de y, divide x por y repetidamente hasta que x ya no sea un\nmúltiplo de y, denotando este valor final como x'. Entonces el resultado es x' % y.\nPor ejemplo:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nDado un número primo p, necesitas manejar varias consultas donde se te da\nun número entero n y debes calcular n! ⊕ p. Aquí, n! es el factorial de n.\nEjemplo:\n   newModuloFactorial(3, 7) devuelve 6",
      "arb": "هذه المشكلة تقدم عملية باقي مخصصة، يرمز لها بـ \"⊕\".  \nعند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي x % y.  \nإذا كان x مضاعفًا لـ y، قسم x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مشيرًا إلى هذه القيمة النهائية بـ x'. ثم تكون النتيجة هي x' % y.  \nعلى سبيل المثال:  \n- 4⊕5=4،  \n- 20⊕5=4،  \n- 100⊕5=4.  \nمعطى عدد أولي p، تحتاج إلى معالجة عدة استفسارات حيث يُعطى لك عدد صحيح n ويجب عليك حساب n! ⊕ p. هنا، n! هو مضروب n.  \nمثال:  \n   newModuloFactorial(3, 7) returns 6  ",
      "sw": "Tatizo hili linaanzisha operesheni maalum ya modulo, inayojulikana kama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni x % y. Ikiwa x ni kigezo cha y, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani hii ya mwisho kama x'. Kisha matokeo ni x' % y. Kwa mfano:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nUkipiwa nambari ya kwanza p, unahitaji kushughulikia maswali kadhaa ambapo unapewa nambari n na lazima uhakiki n! ⊕ p. Hapa, n! ni factorial ya n.\nMfano:\n   newModuloFactorial(3, 7) inarudisha 6",
      "tr": "Bu problem, \"⊕\" ile gösterilen özel bir modül işlemi tanıtmaktadır. \nx ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x % y'dir. \nEğer x, y'nin katı ise, x artık y'nin katı olmayana kadar x'i y ile tekrar tekrar bölün, bu son değeri x' olarak belirtin. Sonuç, x' % y'dir. \nÖrneğin:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nVerilen bir asal sayı p için, size bir tamsayı n verilen birkaç sorguyu ele almanız gerekmektedir ve n! ⊕ p hesaplamalısınız. Burada, n! n faktöriyelidir.\nÖrnek:\n   newModuloFactorial(3, 7) 6 döndürür.",
      "vi": "Vấn đề này giới thiệu một phép toán modulo tùy chỉnh, được ký hiệu bằng \"⊕\".  \nKhi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là x % y.  \nNếu x là bội số của y, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng này là x'. Sau đó kết quả là x' % y.  \nVí dụ:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nCho một số nguyên tố p, bạn cần xử lý một số truy vấn mà bạn được cho một số nguyên n và bạn phải tính n! ⊕ p. Ở đây, n! là giai thừa của n.  \nVí dụ:  \n   newModuloFactorial(3, 7) trả về 6  "
    },
    "docstring_bertscore": {
      "es": "0.9955582274192978",
      "arb": "0.9776626232399596",
      "sw": "0.9829223557297634",
      "tr": "0.9654025602313432",
      "vi": "0.9869035044568457"
    }
  },
  {
    "task_id": "CPP/34",
    "prompt": {
      "es": "#include <cstdio>\n#include <cassert>\n/**\n * Se te da un array a de n enteros. Puedes realizar como máximo una operación donde\n * seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x,\n * a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n *\n * Ejemplos:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "arb": "#include <cstdio>\n#include <cassert>\n/**\n * لديك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). ابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n *\n * أمثلة:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "sw": "#include <cstdio>\n#include <cassert>\n/**\n * Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo\n * unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x,\n * kwa gharama ya (j - i + 1). Tafuta gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n *\n * Mifano:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "tr": "#include <cstdio>\n#include <cassert>\n/**\n * Size n olan bir tamsayı dizisi verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, bu işlemde\n * i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz,\n * maliyet (j - i + 1) olur. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n *\n * Örnekler:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "vi": "#include <cstdio>\n#include <cassert>\n/**\n * Bạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác trong đó bạn\n * chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x,\n * với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n *\n * Ví dụ:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])"
    },
    "prompt_bertscore": {
      "es": "0.9990074439859686",
      "arb": "0.9796129749513411",
      "sw": "0.987542697023016",
      "tr": "0.9641801888664545",
      "vi": "0.9847052620299326"
    },
    "canonical_solution": "{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int makeEqualAgain(int n, int a[])` para resolver el siguiente problema:\nSe te da un arreglo a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el arreglo sean iguales.\n\nEjemplos:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "arb": "اكتب دالة CPP `int makeEqualAgain(int n, int a[])` لحل المشكلة التالية:\nأنت مُعطى مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). جد التكلفة الدنيا لجعل جميع العناصر في المصفوفة متساوية.\n\nأمثلة:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "sw": "Andika kazi ya CPP `int makeEqualAgain(int n, int a[])` kutatua tatizo lifuatalo:\nUmepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). Tafuta gharama ya chini ya kufanya vipengele vyote katika safu kuwa sawa.\n\nMifano:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "tr": "Bir CPP fonksiyonu `int makeEqualAgain(int n, int a[])` yazın ve aşağıdaki problemi çözün:\nn tamsayısından oluşan bir dizi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n\nÖrnekler:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "vi": "Viết một hàm CPP `int makeEqualAgain(int n, int a[])` để giải quyết vấn đề sau:  \nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n\nVí dụ:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9968650166961264",
      "sw": "0.9872042308537325",
      "tr": "0.9615950144572855",
      "vi": "0.9861735378065425"
    },
    "level": "middle",
    "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(makeEqualAgain(3, a7) == 1);\n    assert(makeEqualAgain(5, a8) == 1);\n    assert(makeEqualAgain(4, a9) == 0);\n    assert(makeEqualAgain(6, a10) == 1);\n    assert(makeEqualAgain(1, a11) == 0);\n    assert(makeEqualAgain(2, a12) == 1);\n    assert(makeEqualAgain(4, a13) == 2);\n    assert(makeEqualAgain(7, a14) == 2);\n    assert(makeEqualAgain(6, a15) == 3);\n    assert(makeEqualAgain(7, a16) == 5);\n    \n    return 0;\n}",
    "entry_point": "makeEqualAgain",
    "signature": "int makeEqualAgain(int n, int a[])",
    "docstring": {
      "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n\nEjemplos:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "arb": "أنت مُعطى مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). ابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n\nأمثلة:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "sw": "Unapewa safu a ya n ya nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). Tafuta gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n\nMifano:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "tr": "Bir n tam sayısından oluşan bir dizi verilir. En fazla bir işlem gerçekleştirebilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tam sayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlem (j - i + 1) maliyetine sahiptir. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n\nÖrnekler:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n\nVí dụ:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.996202187114613",
      "sw": "0.9868776825073111",
      "tr": "0.9652514025113756",
      "vi": "0.9775527806392473"
    }
  },
  {
    "task_id": "CPP/35",
    "prompt": {
      "es": "#include <cassert>\n#include <iostream>\n/**\n * Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determina el ganador\n * de un juego jugado por Charlie y Dan. Charlie comienza, turnándose con Dan moviendo piedras de la pila más a la izquierda no vacía\n * a la pila adyacente a la derecha. El que solo pueda mover piedras en la última pila pierde. Asumiendo un juego perfecto, encuentra al ganador.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "arb": "#include <cassert>\n#include <iostream>\n/**\n * بالنظر إلى تسلسل من N كومة من الحجارة مرقمة من 1 إلى N، كل منها يحتوي على عدد موجب من الحجارة، حدد الفائز\n * في لعبة يلعبها تشارلي ودان. يبدأ تشارلي، ويتناوب مع دان في نقل الحجارة من الكومة غير الفارغة الأكثر يسارًا\n * إلى الكومة المجاورة على اليمين. الشخص الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض اللعب المثالي، حدد الفائز.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "sw": "#include <cassert>\n#include <iostream>\n/**\n * Ukipewa mlolongo wa mirundo N ya mawe iliyohesabiwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe, tambua mshindi\n * wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, wakibadilishana zamu na Dan kuhamisha mawe kutoka kwenye rundo la kwanza lisilo tupu\n * kwenda kwenye rundo la kulia lililo karibu. Yule ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Ukizingatia uchezaji mkamilifu, pata mshindi.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "tr": "```cpp\n#include <cassert>\n#include <iostream>\n/**\n * 1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her biri pozitif sayıda taş içeren, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin.\n * Charlie başlar, Dan ile sırayla taşları en soldaki boş olmayan yığından bitişik sağ yığına taşır.\n * Sadece son yığındaki taşları hareket ettirebilen kişi kaybeder. Mükemmel oyun varsayılarak, kazananı bulun.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])\n```",
      "vi": "```cpp\n#include <cassert>\n#include <iostream>\n/**\n * Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng\n * của một trò chơi được chơi bởi Charlie và Dan. Charlie bắt đầu, lần lượt với Dan di chuyển đá từ đống không trống bên trái nhất\n * sang đống bên phải liền kề. Người chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi hoàn hảo, tìm người chiến thắng.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])\n```"
    },
    "prompt_bertscore": {
      "es": "0.9788059397131964",
      "arb": "0.9707552517394713",
      "sw": "0.9724346716111213",
      "tr": "0.9525132361756082",
      "vi": "0.960562335106285"
    },
    "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}",
    "instruction": {
      "es": "Escribe una función CPP `const char* gameWinner(int n, const int piles[])` para resolver el siguiente problema:\nDada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie empieza, turnándose con Dan moviendo piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El que solo pueda mover piedras en la última pila pierde. Asumiendo un juego perfecto, encuentra al ganador.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "arb": "اكتب دالة CPP `const char* gameWinner(int n, const int piles[])` لحل المشكلة التالية:\nبالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، كل منها يحتوي على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي، بالتناوب مع دان في نقل الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. الشخص الذي يمكنه فقط نقل الحجارة في الكومة الأخيرة يخسر. بافتراض اللعب المثالي، حدد الفائز.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "sw": "Andika kazi ya CPP `const char* gameWinner(int n, const int piles[])` kutatua tatizo lifuatalo:\nUkipatiwa mlolongo wa mirundo N ya mawe iliyo na namba kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe, bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, wakibadilishana zamu na Dan kuhamisha mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Yule ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Kwa kudhani uchezaji mkamilifu, tafuta mshindi.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "tr": "Bir CPP fonksiyonu `const char* gameWinner(int n, const int piles[])` yazın ve aşağıdaki problemi çözün:\n1'den N'ye kadar numaralandırılmış, her biri pozitif sayıda taş içeren N taş yığını dizisi verildiğinde, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie başlar ve Dan ile sırayla taşları en soldaki boş olmayan yığından bitişik sağdaki yığına taşır. Sadece son yığındaki taşları hareket ettirebilen kişi kaybeder. Mükemmel oyun varsayıldığında, kazananı bulun.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "vi": "Viết một hàm CPP `const char* gameWinner(int n, const int piles[])` để giải quyết vấn đề sau:  \nCho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie bắt đầu, lần lượt với Dan di chuyển đá từ đống không trống bên trái nhất sang đống liền kề bên phải. Người chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi hoàn hảo, tìm người chiến thắng.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\""
    },
    "instruction_bertscore": {
      "es": "0.9945160138100078",
      "arb": "0.9806492296492002",
      "sw": "0.9764108545786777",
      "tr": "0.9666481713508129",
      "vi": "0.9791801593510662"
    },
    "level": "middle",
    "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(std::string(gameWinner(3, test1)) == \"Dan\");\n    assert(std::string(gameWinner(5, test2)) == \"Charlie\");\n    assert(std::string(gameWinner(3, test3)) == \"Charlie\");\n    assert(std::string(gameWinner(4, test4)) == \"Charlie\");\n    assert(std::string(gameWinner(2, test5)) == \"Charlie\");\n    assert(std::string(gameWinner(2, test6)) == \"Charlie\");\n    assert(std::string(gameWinner(11, test7)) == \"Dan\");\n    assert(std::string(gameWinner(10, test8)) == \"Charlie\");\n    assert(std::string(gameWinner(10, test9)) == \"Charlie\");\n    assert(std::string(gameWinner(10, test10)) == \"Dan\");\n\n    return 0;\n}",
    "entry_point": "gameWinner",
    "signature": "const char* gameWinner(int n, const int piles[])",
    "docstring": {
      "es": "Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie comienza, turnándose con Dan moviendo piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El que solo pueda mover piedras en la última pila pierde. Suponiendo un juego perfecto, encuentra al ganador.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "arb": "بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، كل منها يحتوي على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي، بالتناوب مع دان في نقل الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. الشخص الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض اللعب المثالي، حدد الفائز.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "sw": "Kwa kupewa mlolongo wa marundo N ya mawe yaliyoorodheshwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe, amua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, wakibadilishana zamu na Dan kuhamisha mawe kutoka kwenye rundo la kwanza lenye mawe kwenda kwenye rundo la kulia lililo karibu. Yule ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukichukulia uchezaji mkamilifu, tafuta mshindi.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "tr": "Taşlardan oluşan N yığınından oluşan bir diziliş verildiğinde, her biri pozitif sayıda taş içeren ve 1'den N'e kadar numaralandırılmış olan, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie başlar, Dan ile sırayla taşları en soldaki boş olmayan yığından bitişik sağ yığına taşır. Sadece son yığındaki taşları hareket ettirebilen kişi kaybeder. Mükemmel oyun varsayıldığında, kazananı bulun.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie bắt đầu, lần lượt với Dan di chuyển đá từ đống không rỗng bên trái nhất sang đống liền kề bên phải. Người chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi hoàn hảo, tìm người chiến thắng.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\""
    },
    "docstring_bertscore": {
      "es": "0.976805533145794",
      "arb": "0.9727425487017254",
      "sw": "0.9524669552968271",
      "tr": "0.9582155171543578",
      "vi": "0.9718457325313529"
    }
  },
  {
    "task_id": "CPP/36",
    "prompt": {
      "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\n * En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha\n * y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\n * La tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n *\n * Ejemplo:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "arb": "```cpp\n#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * بالنظر إلى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\n * في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين\n * ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.\n * المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n *\n * مثال:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)\n```",
      "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Ukipewa milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1.\n * Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia\n * na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\n * Kazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n *\n * Mfano:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Bir çember şeklinde düzenlenmiş n kapı verildiğinde, oyuncu kapı 1'in önünde başlar.\n * Her turda, oyuncu bir sayı i seçebilir ve i adım sağa gitmek için bir maliyet C_i ödeyebilir\n * ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir, 1 <= i < n için.\n * Görev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n *\n * Örnek:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "vi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Cho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.\n * Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải\n * và sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng C_i >= C_{i+1} với 1 <= i < n.\n * Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n *\n * Ví dụ:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)"
    },
    "prompt_bertscore": {
      "es": "0.9903267004436009",
      "arb": "0.9681843787177368",
      "sw": "0.9966207013274534",
      "tr": "0.9865912574978588",
      "vi": "0.987264018598424"
    },
    "canonical_solution": "{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}",
    "instruction": {
      "es": "Escribe una función CPP `long long minTotalCost(int n, const std::vector<int>& C)` para resolver el siguiente problema:\nDadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\nCada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha\ny luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "arb": "اكتب دالة CPP `long long minTotalCost(int n, const std::vector<int>& C)` لحل المشكلة التالية:\nمعطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\nفي كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين\nثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى من التكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "sw": "Andika kazi ya CPP `long long minTotalCost(int n, const std::vector<int>& C)` kutatua tatizo lifuatalo:\nUkipewa milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1.\nKila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia\nna kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "tr": "Bir CPP fonksiyonu `long long minTotalCost(int n, const std::vector<int>& C)` yazın ve aşağıdaki problemi çözün:\nBir çember şeklinde düzenlenmiş n kapı verildiğinde, oyuncu 1 numaralı kapının önünde başlar.\nHer turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir\nve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir, burada 1 <= i < n.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "vi": "Viết một hàm CPP `long long minTotalCost(int n, const std::vector<int>& C)` để giải quyết vấn đề sau:\nCho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.\nMỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải\nvà sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "instruction_bertscore": {
      "es": "0.9979652303766786",
      "arb": "0.9947094798011358",
      "sw": "0.991681756903021",
      "tr": "0.9797391052432983",
      "vi": "0.9872795117681448"
    },
    "level": "easy",
    "test": "int main() {\n    std::vector<int> costs1 = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(minTotalCost(5, costs1) == 15);\n\n    std::vector<int> costs2 = {1, 1, 1};\n    assert(minTotalCost(3, costs2) == 3);\n\n    std::vector<int> costs3 = {5, 4, 3, 2};\n    assert(minTotalCost(4, costs3) == 11);\n\n    std::vector<int> costs4 = {100, 99, 98, 97};\n    assert(minTotalCost(4, costs4) == 391);\n\n    std::vector<int> costs5 = {10, 9, 8, 7, 6, 5};\n    assert(minTotalCost(6, costs5) == 35);\n\n    std::vector<int> costs6 = {2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(7, costs6) == 14);\n\n    std::vector<int> costs7 = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(minTotalCost(8, costs7) == 56);\n\n    std::vector<int> costs8 = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(9, costs8) == 18);\n\n    std::vector<int> costs9 = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(minTotalCost(10, costs9) == 50);\n\n    std::vector<int> costs10 = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(minTotalCost(11, costs10) == 11);\n\n\n    return 0;\n}",
    "entry_point": "minTotalCost",
    "signature": "long long minTotalCost(int n, const std::vector<int>& C)",
    "docstring": {
      "es": "Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.  \nEn cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.  \nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "arb": "معطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.  \nفي كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين  \nثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.  \nالمهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.  \n\nمثال:  \n    >>> minTotalCost(3, (1, 1, 1))  \n    3  ",
      "sw": "Kwa kuzingatia milango n iliyopangwa kwa mduara, mchezaji huanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n. Kazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "tr": "Verilen n kapı bir daire şeklinde düzenlenmiştir, oyuncu 1 numaralı kapının önünde başlar.\nHer turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir\nve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilmiştir, 1 <= i < n için.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "vi": "Cho n cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.  \nMỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải  \nvà sau đó mở cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.  \nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9928054089685353",
      "arb": "0.9928054089685353",
      "sw": "0.9955576315281547",
      "tr": "0.9637815376917175",
      "vi": "0.9847779607493914"
    }
  },
  {
    "task_id": "CPP/37",
    "prompt": {
      "es": "#include <cassert>\n#include <vector>\n/**\n * Calcula el número total de apretones de manos en un escenario de aula dado\n * la secuencia de IDs de estudiantes a medida que ingresan al aula. Se asume\n * que los estudiantes tienen IDs que van de 0 a N-1 y que cada estudiante\n * solo estrechará la mano con estudiantes que ya estén en el aula con un\n * ID menor.\n *\n * Ejemplos:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "arb": "#include <cassert>\n#include <vector>\n/**\n * يحسب العدد الإجمالي للمصافحات في سيناريو الفصل الدراسي المعطى\n * تسلسل معرفات الطلاب عند دخولهم الفصل. يفترض\n * أن الطلاب لديهم معرفات تتراوح من 0 إلى N-1 وأن كل طالب\n * سوف يصافح فقط الطلاب الموجودين بالفعل في الفصل مع\n * معرف أصغر.\n *\n * أمثلة:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "sw": "#include <cassert>\n#include <vector>\n/**\n * Inahesabu jumla ya mikono iliyoshikana katika hali ya darasani ikizingatiwa\n * mlolongo wa vitambulisho vya wanafunzi wanapoingia darasani. Inadhaniwa\n * kwamba wanafunzi wana vitambulisho vinavyoanzia 0 hadi N-1 na kwamba kila mwanafunzi\n * atashikana mikono tu na wanafunzi ambao tayari wapo darasani wenye kitambulisho\n * kidogo zaidi.\n *\n * Mifano:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "tr": "#include <cassert>\n#include <vector>\n/**\n * Bir sınıf senaryosunda, öğrencilerin sınıfa giriş sırasına göre toplam\n * tokalaşma sayısını hesaplar. Öğrencilerin kimliklerinin 0'dan N-1'e\n * kadar olduğu ve her öğrencinin sadece sınıfta zaten bulunan ve daha\n * küçük kimliğe sahip öğrencilerle tokalaşacağı varsayılır.\n *\n * Örnekler:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "vi": "#include <cassert>\n#include <vector>\n/**\n * Tính tổng số lần bắt tay trong một kịch bản lớp học cho trước\n * dãy số ID của học sinh khi họ vào lớp. Giả sử rằng\n * học sinh có ID từ 0 đến N-1 và mỗi học sinh\n * sẽ chỉ bắt tay với những học sinh đã có mặt trong lớp với\n * ID nhỏ hơn.\n *\n * Ví dụ:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)"
    },
    "prompt_bertscore": {
      "es": "0.9886321846629923",
      "arb": "0.9819198681966803",
      "sw": "0.9478819702113987",
      "tr": "0.9417307845715104",
      "vi": "0.9602709443373069"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función CPP `long long countHandshakes(int n, const std::vector<int>& order)` para resolver el siguiente problema:\nCalcula el número total de apretones de manos en un escenario de aula dado la secuencia de identificaciones de estudiantes a medida que entran al aula. Se asume que los estudiantes tienen identificaciones que van de 0 a N-1 y que cada estudiante solo estrechará la mano con estudiantes que ya están en el aula con una identificación menor.\n\nEjemplos:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "arb": "اكتب دالة CPP `long long countHandshakes(int n, const std::vector<int>& order)` لحل المشكلة التالية:\nتحسب العدد الإجمالي للمصافحات في سيناريو الفصل الدراسي بالنظر إلى تسلسل معرفات الطلاب أثناء دخولهم إلى الفصل. يفترض أن الطلاب لديهم معرفات تتراوح من 0 إلى N-1 وأن كل طالب سيصافح فقط الطلاب الموجودين بالفعل في الفصل بمعرف أصغر.\n\nأمثلة:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "sw": "Andika kazi ya CPP `long long countHandshakes(int n, const std::vector<int>& order)` kutatua tatizo lifuatalo:\nInahesabu jumla ya mikono iliyoshikwa katika hali ya darasani ikizingatia mlolongo wa nambari za wanafunzi wanapoingia darasani. Inadhani kwamba wanafunzi wana nambari za utambulisho kuanzia 0 hadi N-1 na kwamba kila mwanafunzi atashikana mikono tu na wanafunzi ambao tayari wako darasani wenye nambari ndogo.\n\nMifano:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "tr": "Bir CPP fonksiyonu `long long countHandshakes(int n, const std::vector<int>& order)` yazın:\nBir sınıf senaryosunda, öğrencilerin sınıfa giriş sırasına göre toplam tokalaşma sayısını hesaplar. Öğrencilerin kimliklerinin 0'dan N-1'e kadar olduğunu ve her öğrencinin yalnızca sınıfta kendisinden daha küçük kimliğe sahip olan öğrencilerle tokalaşacağını varsayar.\n\nÖrnekler:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "vi": "Viết một hàm CPP `long long countHandshakes(int n, const std::vector<int>& order)` để giải quyết vấn đề sau:\nTính tổng số cái bắt tay trong một tình huống lớp học cho trước dãy số ID của học sinh khi họ vào lớp. Giả sử rằng học sinh có ID từ 0 đến N-1 và mỗi học sinh chỉ bắt tay với những học sinh đã có mặt trong lớp với ID nhỏ hơn.\n\nVí dụ:\n>>> countHandshakes(3, {2, 1, 0})\n0"
    },
    "instruction_bertscore": {
      "es": "0.9798032628563725",
      "arb": "0.9879606153447134",
      "sw": "0.9594033268329465",
      "tr": "0.9188372427445722",
      "vi": "0.9574019271136389"
    },
    "level": "middle",
    "test": "int main() {\n    assert(countHandshakes(4, {2, 1, 3, 0}) == 2);\n    assert(countHandshakes(6, {0, 1, 2, 3, 4, 5}) == 15);\n    assert(countHandshakes(3, {1, 2, 0}) == 1);\n    assert(countHandshakes(4, {3, 2, 1, 0}) == 0);\n    assert(countHandshakes(4, {0, 1, 2, 3}) == 6);\n    assert(countHandshakes(6, {5, 4, 3, 2, 1, 0}) == 0);\n    assert(countHandshakes(4, {0, 2, 1, 3}) == 5);\n    assert(countHandshakes(5, {3, 1, 4, 2, 0}) == 3);\n    assert(countHandshakes(4, {1, 0, 3, 2}) == 4);\n    assert(countHandshakes(3, {2, 0, 1}) == 1);\n    assert(countHandshakes(5, {1, 3, 0, 2, 4}) == 7);\n    assert(countHandshakes(5, {4, 3, 2, 1, 0}) == 0);\n\n    return 0;\n}",
    "entry_point": "countHandshakes",
    "signature": "long long countHandshakes(int n, const std::vector<int>& order)",
    "docstring": {
      "es": "Calcula el número total de apretones de manos en un escenario de aula dado la secuencia de identificaciones de estudiantes a medida que ingresan al aula. Se asume que los estudiantes tienen identificaciones que van de 0 a N-1 y que cada estudiante solo estrechará la mano con estudiantes que ya están en el aula con una identificación menor.\n\nEjemplos:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "arb": "يحسب العدد الإجمالي للمصافحات في سيناريو الفصل الدراسي بالنظر إلى تسلسل معرفات الطلاب عند دخولهم إلى الفصل. يفترض أن الطلاب لديهم معرفات تتراوح من 0 إلى N-1 وأن كل طالب سيصافح فقط الطلاب الموجودين بالفعل في الفصل والذين لديهم معرف أصغر.\n\nأمثلة:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "sw": "Hesabu jumla ya mikono iliyoshikwa katika hali ya darasani kutokana na mlolongo wa vitambulisho vya wanafunzi wanapoingia darasani. Inadhani kwamba wanafunzi wana vitambulisho kuanzia 0 hadi N-1 na kwamba kila mwanafunzi atashikana mikono tu na wanafunzi ambao tayari wapo darasani wenye kitambulisho kidogo zaidi.\n\nMifano:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "tr": "Sınıfa giren öğrenci kimlik numaralarının sırasına göre bir sınıf senaryosunda toplam el sıkışma sayısını hesaplar. Öğrencilerin kimlik numaralarının 0'dan N-1'e kadar olduğu ve her öğrencinin yalnızca sınıfta kendisinden daha küçük kimlik numarasına sahip öğrencilerle el sıkışacağı varsayılır.\n\nÖrnekler:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "vi": "Tính tổng số lần bắt tay trong một tình huống lớp học với dãy số ID của học sinh khi họ vào lớp. Giả sử rằng học sinh có ID từ 0 đến N-1 và mỗi học sinh chỉ bắt tay với những học sinh đã có mặt trong lớp với ID nhỏ hơn.\n\nVí dụ:\n>>> countHandshakes(3, {2, 1, 0})\n0"
    },
    "docstring_bertscore": {
      "es": "0.9657003071725144",
      "arb": "0.9750951269347026",
      "sw": "0.940180474447533",
      "tr": "0.8966412908158287",
      "vi": "0.9301432840330781"
    }
  },
  {
    "task_id": "CPP/38",
    "prompt": {
      "es": "```c\n#include <cassert>\n#include <cstdio>\n/**\n * Dados n enteros positivos que representan el conteo de cada número de 1 a n,\n * encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de\n * una secuencia construida a partir de estos números. El modo es el número más grande entre\n * los elementos más frecuentes en una secuencia.\n * \n * Ejemplo:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)\n```",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\n * ابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات\n * لتسلسل مُنشأ من هذه الأرقام. النمط هو أكبر رقم بين\n * العناصر الأكثر تكرارًا في تسلسل.\n * \n * مثال:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * تسلسل يصل إلى قيمته القصوى هو (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\n * pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya\n * mlolongo ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya\n * vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n * \n * Mfano:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * 1'den n'e kadar her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\n * bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun.\n * Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n * \n * Örnek:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.\n */\nlong long maxModeSum(int n, const int* counts)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\n * tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\n * một dãy được tạo ra từ các số này. Mode là số lớn nhất trong số\n * các phần tử xuất hiện nhiều nhất trong một dãy.\n * \n * Ví dụ:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Một dãy đạt giá trị tối đa là (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)"
    },
    "prompt_bertscore": {
      "es": "0.9727073911242822",
      "arb": "0.9847384333035654",
      "sw": "0.9543831425826707",
      "tr": "0.9576768315609911",
      "vi": "0.9680820840715039"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función CPP `long long maxModeSum(int n, const int* counts)` para resolver el siguiente problema:\nDado n enteros positivos que representan la cantidad de cada número de 1 a n,\nencuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de\nuna secuencia construida a partir de estos números. El modo es el número más grande entre\nlos elementos más frecuentes en una secuencia.\n\nEjemplo:\n>>> maxModeSum(3, {1, 2, 3})\n17\nUna secuencia que alcanza su valor máximo es (3,2,3,1,2,2).",
      "arb": "اكتب دالة CPP `long long maxModeSum(int n, const int* counts)` لحل المشكلة التالية:\nمعطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البوادئ\nلسلسلة مكونة من هذه الأرقام. النمط هو أكبر رقم بين العناصر الأكثر تكرارًا في سلسلة.\n\nمثال:\n>>> maxModeSum(3, {1, 2, 3})\n17\nسلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).",
      "sw": "Andika kazi ya CPP `long long maxModeSum(int n, const int* counts)` kutatua tatizo lifuatalo:\nUkipewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\ntafuta jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya\nmfuatano ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya\nvipengele vinavyojitokeza mara nyingi zaidi katika mfuatano.\n\nMfano:\n>>> maxModeSum(3, {1, 2, 3})\n17\nMfuatano unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).",
      "tr": "Bir CPP fonksiyonu `long long maxModeSum(int n, const int* counts)` yazın ve aşağıdaki problemi çözün:\n1'den n'ye kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n\nÖrnek:\n>>> maxModeSum(3, {1, 2, 3})\n17\nMaksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.",
      "vi": "Viết một hàm CPP `long long maxModeSum(int n, const int* counts)` để giải quyết vấn đề sau:\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\nmột dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n\nVí dụ:\n>>> maxModeSum(3, {1, 2, 3})\n17\nMột dãy đạt giá trị tối đa là (3,2,3,1,2,2)."
    },
    "instruction_bertscore": {
      "es": "0.9939755405432118",
      "arb": "0.9822859439889277",
      "sw": "0.9551486640711792",
      "tr": "0.9549301706520408",
      "vi": "0.9743885986693616"
    },
    "level": "middle",
    "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(maxModeSum(3, a1) == 17);\n    assert(maxModeSum(4, a2) == 37);\n    assert(maxModeSum(2, a3) == 4);\n    assert(maxModeSum(5, a4) == 75);\n    assert(maxModeSum(1, a5) == 100000);\n    assert(maxModeSum(5, a6) == 62);\n    assert(maxModeSum(3, a7) == 900000);\n    assert(maxModeSum(3, a8) == 27);\n    assert(maxModeSum(4, a9) == 64);\n    assert(maxModeSum(6, a10) == 126);\n    assert(maxModeSum(3, a11) == 16);\n    return 0;\n}",
    "entry_point": "maxModeSum",
    "signature": "long long maxModeSum(int n, const int* counts)",
    "docstring": {
      "es": "Dado n enteros positivos que representan el conteo de cada número del 1 al n, encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. El modo es el número más grande entre los elementos más frecuentes en una secuencia.\n\nEjemplo:\n>>> maxModeSum(3, {1, 2, 3})\n17\nUna secuencia que alcanza su valor máximo es (3,2,3,1,2,2).",
      "arb": "إعطاء n أعداد صحيحة موجبة تمثل عدد كل رقم من 1 إلى n، \nابحث عن أكبر مجموع للوضع (العنصر الأكثر تكرارًا) لجميع البادئات في تسلسل مُنشأ من هذه الأرقام. الوضع هو أكبر رقم بين العناصر الأكثر تكرارًا في تسلسل.\n\nمثال:\n>>> maxModeSum(3, {1, 2, 3})\n17\nالتسلسل الذي يصل إلى قيمته القصوى هو (3,2,3,1,2,2).",
      "sw": "Kutolewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, pata jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya mlolongo ulioundwa kutoka kwa nambari hizi. Modi ni nambari kubwa zaidi kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n\nMfano:\n>>> maxModeSum(3, {1, 2, 3})\n17\nMlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).",
      "tr": "Verilen n pozitif tam sayı, 1'den n'e kadar olan her sayının sayısını temsil eder,\nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n\nÖrnek:\n>>> maxModeSum(3, {1, 2, 3})\n17\nMaksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.",
      "vi": "Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo thành từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n\nVí dụ:\n>>> maxModeSum(3, {1, 2, 3})\n17\nMột dãy đạt giá trị lớn nhất là (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9763145188438758",
      "sw": "0.9463825094649664",
      "tr": "0.9330706985887702",
      "vi": "0.960670588663949"
    }
  },
  {
    "task_id": "CPP/39",
    "prompt": {
      "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\n * Un subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\n * La suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\n * El resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n *\n * Casos de ejemplo:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "arb": "```cpp\n#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * بالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الجزئية.\n * يتم تعريف المصفوفة الجزئية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\n * مجموع XOR لمصفوفة جزئية هو نتيجة XOR لجميع العناصر من L إلى R.\n * النتيجة النهائية هي مجموع مجموعات XOR لجميع المصفوفات الجزئية الممكنة.\n *\n * أمثلة الحالات:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)\n```",
      "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Ukipewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\n * Kipengele kidogo kinatajwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\n * Jumla ya XOR ya kipengele kidogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\n * Matokeo ya mwisho ni jumla ya XOR za vipengele vidogo vyote vinavyowezekana.\n *\n * Mifano ya kesi:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Bir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\n * Bir alt dizi, 1 <= L <= R <= n olacak şekilde (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\n * Bir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR işlemine tabi tutulmasının sonucudur.\n * Nihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n *\n * Örnek durumlar:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "vi": "```cpp\n#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\n * Một mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\n * Tổng XOR của một mảng con là kết quả của việc thực hiện XOR tất cả các phần tử từ L đến R.\n * Kết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n *\n * Các trường hợp ví dụ:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)\n```"
    },
    "prompt_bertscore": {
      "es": "0.991835695448323",
      "arb": "0.9698826684755851",
      "sw": "0.9803834621993754",
      "tr": "0.9818878887053337",
      "vi": "0.9693972158243358"
    },
    "canonical_solution": "{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función CPP `long long sumOfXorSubarrays(const std::vector<int>& A)` para resolver el siguiente problema:\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "arb": "اكتب دالة CPP `long long sumOfXorSubarrays(const std::vector<int>& A)` لحل المشكلة التالية:\nمعطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع القطع الفرعية.\nيتم تعريف القطعة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR للقطعة الفرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع القطع الفرعية الممكنة.\n\nحالات المثال:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "sw": "Andika kazi ya CPP `long long sumOfXorSubarrays(const std::vector<int>& A)` kutatua tatizo lifuatalo:\nUkipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\nKipengele kidogo kinafafanuliwa na jozi ya faharasa (L, R) kama 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya kipengele kidogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya XOR kwa vipengele vidogo vyote vinavyowezekana.\n\nMifano ya kesi:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "tr": "Bir CPP fonksiyonu `long long sumOfXorSubarrays(const std::vector<int>& A)` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, 1 <= L <= R <= n olacak şekilde (L, R) indeks çiftleriyle tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nSonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "vi": "Viết một hàm CPP `long long sumOfXorSubarrays(const std::vector<int>& A)` để giải quyết vấn đề sau:\nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"
    },
    "instruction_bertscore": {
      "es": "0.9908695572749693",
      "arb": "0.9791813511333524",
      "sw": "0.9952094324702006",
      "tr": "0.9699414630683714",
      "vi": "0.9969496332384472"
    },
    "level": "middle",
    "test": "int main() {\n    assert(sumOfXorSubarrays({1, 2, 3, 4, 5}) == 39);\n    assert(sumOfXorSubarrays({1, 1, 1}) == 4);\n    assert(sumOfXorSubarrays({2, 3, 1}) == 9);\n    assert(sumOfXorSubarrays({4, 5, 7, 9}) == 74);\n    assert(sumOfXorSubarrays({0, 0, 0, 0}) == 0);\n    assert(sumOfXorSubarrays({8, 8, 8, 8, 8}) == 72);\n    assert(sumOfXorSubarrays({3, 6, 9, 12, 15}) == 125);\n    assert(sumOfXorSubarrays({10, 20, 30, 40, 50}) == 390);\n    assert(sumOfXorSubarrays({16, 16, 16, 16, 16, 16}) == 192);\n    assert(sumOfXorSubarrays({1, 3, 5, 7, 9, 11, 13}) == 192);\n    assert(sumOfXorSubarrays({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) == 218);\n\n\n    return 0;\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "long long sumOfXorSubarrays(const std::vector<int>& A)",
    "docstring": {
      "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.  \nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.  \nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "arb": "معطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع الـ XOR لجميع القطع الفرعية.\nيتم تعريف القطعة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع الـ XOR لقطعة فرعية هو نتيجة تطبيق عملية XOR على جميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع قيم الـ XOR لجميع القطع الفرعية الممكنة.\n\nحالات المثال:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "sw": "Kwa kupewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\nKipengele kidogo kinafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya kipengele kidogo ni matokeo ya kufanya XOR kwa vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa vipengele vidogo vyote vinavyowezekana.\n\nMifano ya kesi:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "tr": "Verilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, 1 <= L <= R <= n olacak şekilde bir (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nNihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.  \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.  \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.  \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể có.  \n\nCác trường hợp ví dụ:  \n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)  \n    39  "
    },
    "docstring_bertscore": {
      "es": "0.9911249959449802",
      "arb": "0.9688704480538313",
      "sw": "0.975337058738803",
      "tr": "0.980499859602662",
      "vi": "0.9931945258849827"
    }
  },
  {
    "task_id": "CPP/40",
    "prompt": {
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Dados dos enteros positivos n y k, encuentra el número de enteros positivos x,\n * donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo\n * enteros positivos y b >= k. Diferentes representaciones legales de x se cuentan\n * solo una vez. Por ejemplo:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * بالنظر إلى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x،\n * حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b\n * أعداد صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لـ x مرة واحدة فقط. على سبيل المثال:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Ukipewa nambari mbili kamili chanya n na k, tafuta idadi ya nambari kamili chanya x,\n * ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa\n * nambari kamili chanya na b >= k. Uwakilishi tofauti halali wa x unahesabiwa\n * mara moja tu. Kwa mfano:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında x = a^b\n * şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun, burada a ve b\n * pozitif tamsayılardır ve b >= k. x'in farklı yasal temsilleri yalnızca bir kez sayılır. Örneğin:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x,\n * với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là\n * các số nguyên dương và b >= k. Các cách biểu diễn hợp lệ khác nhau của x chỉ được đếm\n * một lần. Ví dụ:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9939485268113911",
      "sw": "0.9946373769728201",
      "tr": "0.952295934538756",
      "vi": "0.9791179880418022"
    },
    "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}",
    "instruction": {
      "es": "Escribe una función en CPP `int countPowerNumbers(int n, int k)` para resolver el siguiente problema:\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales de x se cuentan solo una vez. Por ejemplo:\n    >>> countPowerNumbers(99, 1)\n    99",
      "arb": "اكتب دالة CPP `int countPowerNumbers(int n, int k)` لحل المشكلة التالية:  \nمعطى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b أعداد صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لـ x مرة واحدة فقط. على سبيل المثال:  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "sw": "Andika kazi ya CPP `int countPowerNumbers(int n, int k)` kutatua tatizo lifuatalo:\nUkipiwa nambari mbili nzima chanya n na k, tafuta idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b zikiwa nambari nzima chanya na b >= k. Uwiano tofauti halali wa x unahesabiwa mara moja tu. Kwa mfano:\n    >>> countPowerNumbers(99, 1)\n    99",
      "tr": "Bir CPP fonksiyonu `int countPowerNumbers(int n, int k)` yazın ve aşağıdaki problemi çözün:\nVerilen iki pozitif tamsayı n ve k için, 1 <= x <= n aralığında olan ve x = a^b şeklinde ifade edilebilen pozitif tamsayı x'lerin sayısını bulun, burada a ve b pozitif tamsayılar ve b >= k. x'in farklı yasal temsilleri yalnızca bir kez sayılır. Örneğin:\n    >>> countPowerNumbers(99, 1)\n    99",
      "vi": "Viết một hàm CPP `int countPowerNumbers(int n, int k)` để giải quyết vấn đề sau:  \nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, trong đó 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của x chỉ được đếm một lần. Ví dụ:  \n    >>> countPowerNumbers(99, 1)  \n    99  "
    },
    "instruction_bertscore": {
      "es": "0.9932457725232897",
      "arb": "0.9928397720244544",
      "sw": "0.9895234391826958",
      "tr": "0.9022009551809952",
      "vi": "0.9844897480665097"
    },
    "level": "hard",
    "test": "int main() {\n    assert(countPowerNumbers(99, 1) == 99);\n    assert(countPowerNumbers(99, 3) == 7);\n    assert(countPowerNumbers(99, 2) == 12);\n    assert(countPowerNumbers(10, 1) == 10);\n    assert(countPowerNumbers(10, 2) == 4);\n    assert(countPowerNumbers(500, 1) == 500);\n    assert(countPowerNumbers(500, 2) == 30);\n    assert(countPowerNumbers(500, 3) == 13);\n    assert(countPowerNumbers(1000, 1) == 1000);\n    assert(countPowerNumbers(1000, 2) == 41);\n    assert(countPowerNumbers(1000, 3) == 17);\n    assert(countPowerNumbers(1000, 93) == 1);\n    assert(countPowerNumbers(50, 2) == 10);\n    assert(countPowerNumbers(50, 3) == 5);\n    assert(countPowerNumbers(2, 3) == 1);\n    return 0;\n}",
    "entry_point": "countPowerNumbers",
    "signature": "int countPowerNumbers(int n, int k)",
    "docstring": {
      "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales de x se cuentan solo una vez. Por ejemplo:\n    >>> countPowerNumbers(99, 1)\n    99",
      "arb": "بالنظر إلى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b حيث a و b هما عددان صحيحان موجبان و b >= k. يتم احتساب التمثيلات القانونية المختلفة لـ x مرة واحدة فقط. على سبيل المثال:\n    >>> countPowerNumbers(99, 1)\n    99",
      "sw": "Ukipiwa nambari mbili chanya n na k, pata idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari chanya na b >= k. Uwakilishi tofauti halali wa x unahesabiwa mara moja tu. Kwa mfano:\n    >>> countPowerNumbers(99, 1)\n    99",
      "tr": "Verilen iki pozitif tamsayı n ve k için, 1 <= x <= n aralığında olan ve x = a^b şeklinde ifade edilebilen pozitif tamsayı x'in sayısını bulun, burada a ve b pozitif tamsayılardır ve b >= k'dir. x'in farklı yasal gösterimleri yalnızca bir kez sayılır. Örneğin:\n    >>> countPowerNumbers(99, 1)\n    99",
      "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của x chỉ được đếm một lần. Ví dụ:\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9854475437638599",
      "sw": "0.9589246276146524",
      "tr": "0.9472322502350337",
      "vi": "0.9676123232203563"
    }
  },
  {
    "task_id": "CPP/41",
    "prompt": {
      "es": "#include <cassert>\n/* Dados tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\ntal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "arb": "#include <cassert>\n/* بالنظر إلى ثلاثة أعداد صحيحة n و m و k، جد عدد التتابعات المكونة من n '(' و m ')',\nبحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتقسيمها على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "sw": "#include <cassert>\n/* Ukipewa nambari tatu n, m, na k, pata idadi ya mfuatano unaojumuisha n '(' na m ')',\nambapo mfuatano mrefu zaidi ulio na usawa ni wa urefu 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "tr": "#include <cassert>\n/* Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun,\nöyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "vi": "#include <cassert>\n/* Cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n '(' và m ')',\nsao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả cần được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)"
    },
    "prompt_bertscore": {
      "es": "0.9895502542841356",
      "arb": "0.9880428483224618",
      "sw": "0.9859455101291145",
      "tr": "0.9747411675956984",
      "vi": "0.9834872605334266"
    },
    "canonical_solution": "{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "es": "Escribe una función CPP `long long countBalancedSubsequences(long long n, long long m, long long k)` para resolver el siguiente problema:\nDado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\ntal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "arb": "اكتب دالة CPP `long long countBalancedSubsequences(long long n, long long m, long long k)` لحل المشكلة التالية:\nمعطى ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')',\nبحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتقسيمها على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "sw": "Andika kazi ya CPP `long long countBalancedSubsequences(long long n, long long m, long long k)` kutatua tatizo lifuatalo:\nUkipiwa nambari tatu n, m, na k, tafuta idadi ya misururu inayojumuisha n '(' na m ')',\nhivyo kwamba msururu mrefu zaidi ulio sawa ni wa urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "tr": "Bir CPP fonksiyonu `long long countBalancedSubsequences(long long n, long long m, long long k)` yazın ve aşağıdaki problemi çözün:\nÜç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun,\nöyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "vi": "Viết một hàm CPP `long long countBalancedSubsequences(long long n, long long m, long long k)` để giải quyết vấn đề sau:\nCho ba số nguyên n, m và k, tìm số lượng dãy gồm n '(' và m ')',\nsao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả cần được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9906512624862119",
      "arb": "0.9930282722560565",
      "sw": "0.9860128458282852",
      "tr": "0.9736790909483048",
      "vi": "0.9850318103763539"
    },
    "level": "hard",
    "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "long long countBalancedSubsequences(long long n, long long m, long long k)",
    "docstring": {
      "es": "Dado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\ntal que la subsecuencia balanceada más larga sea de longitud 2 * k. El resultado debe calcularse módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "arb": "معطى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التتابعات التي تتكون من n '(' و m ')',\nبحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق المودولو 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "sw": "Kwa kupewa nambari tatu za mzima n, m, na k, tafuta idadi ya mfuatano unaojumuisha n '(' na m ')',\nambapo mfuatano mrefu zaidi wenye usawa una urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "tr": "Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "vi": "Cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n dấu '(' và m dấu ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9964649751087221",
      "arb": "0.9866081410802469",
      "sw": "0.9840732201574796",
      "tr": "0.9725582197081251",
      "vi": "0.9838467815230998"
    }
  },
  {
    "task_id": "CPP/42",
    "prompt": {
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas \n * cartesianas en un plano, con su esquina inferior izquierda en (0,0) y la esquina \n * superior derecha en (n,m), necesitas calcular el número esperado de operaciones \n * para cortar el papel de tal manera que el área restante sea menor que k. En cada \n * operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por \n * puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte \n * inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta \n * debe ser módulo 10^9+7.\n *\n * Por ejemplo:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "arb": "```cpp\n#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي \n * مع وجود الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، \n * تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. \n * في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، \n * ويقطع (وليس فقط يلمس الحافة) الورقة. ثم يتم التخلص من الجزء السفلي أو الأيمن من الورقة \n * على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n *\n * على سبيل المثال:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)\n```",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukiwa na karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian \n * kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), \n * unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. \n * Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kupitia \n * pointi zenye kuratibu za nambari kamili, na unakata (sio tu kugusa ukingo) karatasi. Sehemu ya chini au ya kulia \n * ya karatasi kando ya mstari huu kisha inatupwa. Jibu linapaswa kuwa modulo 10^9+7.\n *\n * Kwa mfano:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * n x m boyutunda bir dikdörtgen kağıt, düzlem Kartezyen koordinat \n * sisteminde alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olacak şekilde yerleştirilmiştir. \n * Kağıdın kalan alanının k'dan küçük olacak şekilde kesilmesi için gereken \n * beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel, \n * tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) \n * bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. \n * Cevap 10^9+7 ile mod alınmalıdır.\n *\n * Örneğin:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ \n * phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), \n * bạn cần tính số lượng thao tác kỳ vọng để cắt giấy sao cho \n * diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên \n * song song với các trục, đi qua các điểm có tọa độ nguyên, \n * và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải \n * của tờ giấy dọc theo đường này sau đó bị loại bỏ. Kết quả nên được lấy theo modulo 10^9+7.\n *\n * Ví dụ:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)"
    },
    "prompt_bertscore": {
      "es": "0.9657902867351232",
      "arb": "0.9410049891592089",
      "sw": "0.9446824320336888",
      "tr": "0.945360953415304",
      "vi": "0.9542115259334566"
    },
    "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función CPP `long long expectedCuts(int n, int m, long long k)` para resolver el siguiente problema:\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea es entonces descartada. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "arb": "اكتب دالة CPP `long long expectedCuts(int n, int m, long long k)` لحل المشكلة التالية:\nمعطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. الجزء السفلي أو الأيمن من الورقة على طول هذا الخط يتم التخلص منه. يجب أن تكون الإجابة مودولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "sw": "Andika kazi ya CPP `long long expectedCuts(int n, int m, long long k)` kutatua tatizo lifuatalo:\nUkipatiwa karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian \nna kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), \nunahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi hiyo ili \neneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu \nambao ni sambamba na mhimili, unapita kupitia pointi zenye kuratibu za namba kamili, \nna unakata (si kugusa tu kingo) karatasi hiyo. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu \nkisha inatupwa. Jibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "tr": "`long long expectedCuts(int n, int m, long long k)` fonksiyonunu aşağıdaki problemi çözmek için yazın:\nn x m boyutlarında bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir Kartezyen koordinat sistemine yerleştirilmiştir. \nKağıdı kesmek için gereken beklenen işlem sayısını hesaplamanız gerekiyor, böylece kalan alan k'dan küçük olur. Her işlemde, eksenlere paralel, \ntam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. \nBu çizgi boyunca kağıdın alt veya sağ kısmı daha sonra atılır. Cevap 10^9+7 modunda olmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "vi": "Viết một hàm CPP `long long expectedCuts(int n, int m, long long k)` để giải quyết vấn đề sau:\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng thao tác mong đợi để cắt giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời nên được tính theo modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9819027859839113",
      "arb": "0.9585768258174603",
      "sw": "0.9601940743798464",
      "tr": "0.9539117926884749",
      "vi": "0.9571345706207659"
    },
    "level": "hard",
    "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}",
    "entry_point": "expectedCuts",
    "signature": "long long expectedCuts(int n, int m, long long k)",
    "docstring": {
      "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas \ncartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), \nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que \nel área restante sea menor que k. En cada operación, se elige aleatoriamente una línea \nque es paralela a los ejes, pasa por puntos con coordenadas enteras, \ny corta (no solo toca el borde) el papel. La parte inferior o derecha \ndel papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "arb": "معطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوٍ مع وجود الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة بتقسيم 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "sw": "Kwa kuzingatia karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za namba kamili, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa moduli 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "tr": "Verilen bir dikdörtgen kağıt, (0,0) noktasında sol alt köşesi ve (n,m) noktasında sağ üst köşesi olan bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. Kağıdın kalan alanı k'dan küçük olacak şekilde kesilmesi için beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) rastgele bir çizgi seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 ile mod alınmış olarak verilmelidir.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Descartes với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt dự kiến để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên, song song với các trục tọa độ, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Kết quả cần được lấy modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9782660623375435",
      "arb": "0.9465670370889478",
      "sw": "0.958034167616473",
      "tr": "0.9202969774147977",
      "vi": "0.9308879493315779"
    }
  },
  {
    "task_id": "CPP/43",
    "prompt": {
      "es": "#include <bits/stdc++.h>\n/*\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de ruptura 1 <= x_1 < x_2 < ... < x_{k-1} < n, y divídelo en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). El resultado debe ser módulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "arb": "#include <bits/stdc++.h>\n/*\nبالنظر إلى ترتيب q مكون من n عنصرًا وعدد صحيح k، جد عدد التباديل p المكونة من n عنصرًا بحيث f(p) = q، حيث أن f(p) هو الترتيب الأصغر لغوياً الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختر k-1 نقاط تقاطع 1 <= x_1 < x_2 < ... < x_{k-1} < n، وقسمها إلى [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). يجب أن يكون الناتج موديولو 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "sw": "#include <bits/stdc++.h>\n/*\nUkipewa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu za mfululizo na kupanga kila sehemu (yaani, chagua sehemu za kugawanya k-1 1 <= x_1 < x_2 < ... < x_{k-1} < n, na igawanye katika [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "tr": "#include <bits/stdc++.h>\n/*\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık parçaya bölerek ve her parçayı sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, 1 <= x_1 < x_2 < ... < x_{k-1} < n olacak şekilde k-1 kırılma noktası seçin ve [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "vi": "#include <bits/stdc++.h>\n/*\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x_1 < x_2 < ... < x_{k-1} < n, và chia nó thành [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Kết quả nên được lấy modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])"
    },
    "prompt_bertscore": {
      "es": "0.9977298533751523",
      "arb": "0.9827209445233941",
      "sw": "0.9659843486173944",
      "tr": "0.946430975277939",
      "vi": "0.9929100871793407"
    },
    "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int countPermutations(int n, int k, int qq[])` para resolver el siguiente problema:\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de ruptura 1 <= x_1 < x_2 < ... < x_{k-1} < n, y divídelo en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). El resultado debe ser módulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "arb": "اكتب دالة CPP `int countPermutations(int n, int k, int qq[])` لحل المشكلة التالية:\nمعطى ترتيب q من n عنصرًا وعدد صحيح k، جد عدد التباديل p من n عنصرًا بحيث f(p) = q، حيث أن f(p) هو الترتيب الأصغر لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختيار k-1 نقاط فاصلة 1 <= x_1 < x_2 < ... < x_{k-1} < n، وتقسيمها إلى [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n]). يجب أن تكون النتيجة موديولو 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "sw": "Andika kazi ya CPP `int countPermutations(int n, int k, int qq[])` kutatua tatizo lifuatalo:\nUkipewa permutation q ya vipengele n na nambari k, pata idadi ya permutations p ya vipengele n kama f(p) = q, ambapo f(p) ni permutation ndogo zaidi ki-lexicographically inayoweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu (yaani, chagua sehemu k-1 za kuvunja 1 <= x_1 < x_2 < ... < x_{k-1} < n, na igawanye katika [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "tr": "Bir CPP fonksiyonu `int countPermutations(int n, int k, int qq[])` yazın ve aşağıdaki problemi çözün:\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k tane boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x_1 < x_2 < ... < x_{k-1} < n ve [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "vi": "Viết một hàm CPP `int countPermutations(int n, int k, int qq[])` để giải quyết vấn đề sau:\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x_1 < x_2 < ... < x_{k-1} < n, và chia nó thành [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Kết quả nên được lấy modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9975719422222296",
      "arb": "0.9946133426967149",
      "sw": "0.9756727440827521",
      "tr": "0.9584411612672135",
      "vi": "0.990844927107721"
    },
    "level": "hard",
    "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}",
    "entry_point": "countPermutations",
    "signature": "int countPermutations(int n, int k, int qq[])",
    "docstring": {
      "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de ruptura 1 <= x_1 < x_2 < ... < x_{k-1} < n, y divídelo en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). El resultado debe ser módulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "arb": "معطى ترتيب q لعناصر n وعدد صحيح k، ابحث عن عدد التباديل p لعناصر n بحيث f(p) = q، حيث أن f(p) هو الترتيب الأصغر لغوياً الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختيار k-1 نقاط فاصلة 1 <= x_1 < x_2 < ... < x_{k-1} < n، وتقسيمها إلى [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n]). يجب أن تكون النتيجة موديولو 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "sw": "Mojawapo ya mpangilio q wa vipengele n na nambari k, pata idadi ya mpangilio p wa vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu zinazofuatana na kupanga kila sehemu (yaani, chagua sehemu za kuvunja k-1 1 <= x_1 < x_2 < ... < x_{k-1} < n, na igawanye katika [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k tane boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x_1 < x_2 < ... < x_{k-1} < n ve [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "vi": "Được cho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x_1 < x_2 < ... < x_{k-1} < n, và chia nó thành [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Kết quả nên được lấy theo modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9943724040445195",
      "arb": "0.997335572068798",
      "sw": "0.9568827072976137",
      "tr": "0.9711318549419135",
      "vi": "0.9915552293503017"
    }
  },
  {
    "task_id": "CPP/44",
    "prompt": {
      "es": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Dado un array de n enteros distintos que representan las alturas de los amigos de Kira,\n * encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD)\n * de los valores máximo y mínimo del triplete sea 1.\n * \n * Ejemplo de uso:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "arb": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * بالنظر إلى مصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل ارتفاعات أصدقاء كيرا،\n * ابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD)\n * للقيمتين العظمى والصغرى في الثلاثية هو 1.\n * \n * مثال على الاستخدام:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "sw": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Ukipewa safu ya n ya nambari tofauti zinazowakilisha urefu wa marafiki wa Kira, \n * pata idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkubwa zaidi wa kawaida (GCD) \n * wa thamani za juu na za chini za tatu hiyo ni 1.\n * \n * Mfano wa matumizi:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "tr": "```cpp\n#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Kira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tamsayıdan oluşan bir dizi verildiğinde,\n * maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin\n * kaç farklı yolu olduğunu bulun.\n * \n * Örnek kullanım:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)\n```",
      "vi": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Cho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira,\n * tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD)\n * của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n * \n * Ví dụ sử dụng:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)"
    },
    "prompt_bertscore": {
      "es": "0.9979578810525803",
      "arb": "0.9908653860369676",
      "sw": "0.9495466914348522",
      "tr": "0.9486604026746746",
      "vi": "0.999999801369619"
    },
    "canonical_solution": "{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int countTriplets(const std::vector<int>& heights)` para resolver el siguiente problema:\nDado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD) de los valores máximo y mínimo del triplete sea 1.\n\nEjemplo de uso:\n>>> countTriplets({1, 5, 7})\n1",
      "arb": "اكتب دالة CPP `int countTriplets(const std::vector<int>& heights)` لحل المشكلة التالية:\nبالنظر إلى مصفوفة تحتوي على n عدد صحيح مميز تمثل ارتفاعات أصدقاء كيرا، أوجد عدد الطرق لاختيار ثلاثية (a، b، c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى في الثلاثية هو 1.\n\nمثال على الاستخدام:\n>>> countTriplets({1, 5, 7})\n1",
      "sw": "Andika kazi ya CPP `int countTriplets(const std::vector<int>& heights)` kutatua tatizo lifuatalo:  \nUkipiwa safu ya n ya nambari tofauti zinazoashiria urefu wa marafiki wa Kira, pata idadi ya njia za kuchagua tatu (a, b, c) kama vile mgawanyiko mkubwa zaidi (GCD) wa thamani ya juu na ya chini ya tatu ni 1.\n\nMfano wa matumizi:  \n>>> countTriplets({1, 5, 7})  \n1",
      "tr": "Bir CPP fonksiyonu `int countTriplets(const std::vector<int>& heights)` yazın ve aşağıdaki problemi çözün:\nKira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tam sayıdan oluşan bir dizi verildiğinde, maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun.\n\nÖrnek kullanım:\n>>> countTriplets({1, 5, 7})\n1",
      "vi": "Viết một hàm CPP `int countTriplets(const std::vector<int>& heights)` để giải quyết vấn đề sau:  \nCho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira, tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\nVí dụ sử dụng:  \n>>> countTriplets({1, 5, 7})  \n1"
    },
    "instruction_bertscore": {
      "es": "0.9928973748349544",
      "arb": "0.9898035080199551",
      "sw": "0.9464981123467288",
      "tr": "0.9834179385304455",
      "vi": "1"
    },
    "level": "hard",
    "test": "int main() {\n    assert(countTriplets({1, 5, 7}) == 1);\n    assert(countTriplets({1, 6, 2, 3}) == 3);\n    assert(countTriplets({16, 4, 8, 2}) == 0);\n    assert(countTriplets({10, 1, 6, 7, 9, 8, 4, 3, 5, 2}) == 77);\n    assert(countTriplets({4, 5, 9, 11, 14}) == 7);\n    assert(countTriplets({15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}) == 104);\n    assert(countTriplets({3, 7, 11, 13}) == 4);\n    assert(countTriplets({5, 12, 13, 17, 19}) == 10);\n    assert(countTriplets({2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}) == 87);\n    assert(countTriplets({1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}) == 122);\n\n    return 0;\n}",
    "entry_point": "countTriplets",
    "signature": "int countTriplets(const std::vector<int>& heights)",
    "docstring": {
      "es": "Dado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (MCD) de los valores máximo y mínimo del triplete sea 1.\n\nEjemplo de uso:\n>>> countTriplets({1, 5, 7})\n1",
      "arb": "نظرًا لمصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل أطوال أصدقاء كيرا، ابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى في الثلاثية هو 1.\n\nاستخدام المثال:\n>>> countTriplets({1, 5, 7})\n1",
      "sw": "Ukipewa safu ya n ya nambari tofauti zinazowakilisha urefu wa marafiki wa Kira, tafuta idadi ya njia za kuchagua triplet (a, b, c) ili kwamba mgawanyiko wa kawaida mkubwa (GCD) wa thamani za juu na chini za triplet ni 1.\n\nMfano wa matumizi:\n>>> countTriplets({1, 5, 7})\n1",
      "tr": "Verilen n farklı tam sayıdan oluşan bir dizi, Kira'nın arkadaşlarının boylarını temsil etmektedir. Maksimum ve minimum değerlerinin en büyük ortak böleni (EBOB) 1 olan bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun.\n\nÖrnek kullanım:\n>>> countTriplets({1, 5, 7})\n1",
      "vi": "Cho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira, tìm số cách để chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\nVí dụ sử dụng:\n>>> countTriplets({1, 5, 7})\n1"
    },
    "docstring_bertscore": {
      "es": "0.9931903546469809",
      "arb": "0.9797919409246536",
      "sw": "0.9871801965776272",
      "tr": "0.9488659851190456",
      "vi": "1"
    }
  },
  {
    "task_id": "CPP/45",
    "prompt": {
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color \n * representado por un entero. Puedes realizar una operación donde \n * eliges un color y cambias todos los píxeles conectados del mismo color \n * al color elegido. Dos píxeles están conectados si son adyacentes \n * y tienen el mismo color. Encuentra el número mínimo de operaciones \n * requeridas para hacer que todos los píxeles sean del mismo color.\n *\n * Nota: Para cada color, hay como máximo 20 píxeles de ese color.\n *\n * Ejemplos:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * لديك صورة مكونة من 1 بكسل في n، حيث يتم تمثيل كل بكسل بلون \n * ممثل برقم صحيح. يمكنك إجراء عملية حيث تختار لونًا وتغير جميع \n * البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر بكسلان \n * متصلان إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد \n * العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n *\n * ملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n *\n * أمثلة:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Umepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi \n * inayowakilishwa na nambari nzima. Unaweza kufanya operesheni ambapo \n * unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi \n * sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa \n * ziko karibu na zina rangi sawa. Pata idadi ndogo ya operesheni \n * zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n *\n * Kumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n *\n * Mifano:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * 1'e n piksel boyutunda bir görüntü verilir, burada her piksel bir \n * tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı \n * renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz \n * bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte \n * ise bağlıdır. Tüm pikselleri aynı renkte yapmak için gereken minimum \n * işlem sayısını bulun.\n *\n * Not: Her renk için en fazla 20 piksel vardır.\n *\n * Örnekler:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu \n * được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn \n * chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành \n * màu đã chọn. Hai pixel được kết nối nếu chúng liền kề \n * và có cùng màu. Tìm số lượng thao tác tối thiểu \n * cần thiết để làm cho tất cả các pixel có cùng màu.\n *\n * Lưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n *\n * Ví dụ:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)"
    },
    "prompt_bertscore": {
      "es": "0.9966451328643208",
      "arb": "0.9572172008592764",
      "sw": "0.97614449123771",
      "tr": "0.9643661069031031",
      "vi": "0.9943704177407092"
    },
    "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}",
    "instruction": {
      "es": "Escribe una función CPP `int minOperations(int n, int* pixels)` para resolver el siguiente problema:\nSe te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puedes realizar una operación en la que eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "arb": "اكتب دالة CPP `int minOperations(int n, int* pixels)` لحل المشكلة التالية:\nلديك صورة بكسل بحجم 1 في n، حيث أن كل بكسل له لون ممثل بعدد صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلين إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، يوجد على الأكثر 20 بكسل من ذلك اللون.\n\nأمثلة:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "sw": "Andika kazi ya CPP `int minOperations(int n, int* pixels)` kutatua tatizo lifuatalo:\nUmepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari nzima. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Tafuta idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "tr": "`int minOperations(int n, int* pixels)` fonksiyonunu aşağıdaki problemi çözmek için yazın:\n1'e n pikselden oluşan bir görüntü verilir, burada her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı renkteki tüm bağlantılı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte olduklarında bağlantılıdır. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "vi": "Viết một hàm CPP `int minOperations(int n, int* pixels)` để giải quyết vấn đề sau:\nBạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2"
    },
    "instruction_bertscore": {
      "es": "0.9985017310358538",
      "arb": "0.9801836400360544",
      "sw": "0.9831883218099692",
      "tr": "0.9476964494355122",
      "vi": "0.9938545746411616"
    },
    "level": "hard",
    "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(minOperations(5, a1) == 2);\n    assert(minOperations(4, a2) == 1);\n    assert(minOperations(5, a3) == 3);\n    assert(minOperations(5, a4) == 0);\n    assert(minOperations(6, a5) == 1);\n    assert(minOperations(7, a6) == 2);\n    assert(minOperations(8, a7) == 1);\n    assert(minOperations(9, a8) == 8);\n    assert(minOperations(10, a9) == 5);\n    assert(minOperations(3, a10) == 0);\n    assert(minOperations(4, a11) == 1);\n    return 0;\n}",
    "entry_point": "minOperations",
    "signature": "int minOperations(int n, int* pixels)",
    "docstring": {
      "es": "Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un número entero. Puedes realizar una operación en la que eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones necesarias para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "arb": "أنت لديك صورة بكسل بحجم 1 في n، حيث كل بكسل له لون ممثل برقم صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر بكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "sw": "Unapewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari nzima. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa na rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Pata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "tr": "1'e n piksel boyutunda bir görüntü verilir ve her piksel bir tam sayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte olduklarında bağlı kabul edilir. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "vi": "Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được coi là kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2"
    },
    "docstring_bertscore": {
      "es": "0.984838543015607",
      "arb": "0.9883123897495262",
      "sw": "0.998394669260476",
      "tr": "0.962554796458446",
      "vi": "0.9810216616136406"
    }
  },
  {
    "task_id": "CPP/46",
    "prompt": {
      "es": "#include <cassert>\n#include <iostream>\n/**\n * @brief Calcula la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5.\n *\n * Cuenta cada número solo una vez, incluso si es múltiplo de ambos 3 y 5.\n * Por ejemplo:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n El límite superior del rango para verificar múltiplos.\n * @return La suma de los múltiplos de 3 o 5 dentro del rango.\n */\nint sumOfMultiples(int n)",
      "arb": "#include <cassert>\n#include <iostream>\n/**\n * @brief يحسب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5.\n *\n * يحسب كل رقم مرة واحدة فقط حتى لو كان مضاعفًا لكل من 3 و 5.\n * على سبيل المثال:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n الحد الأعلى للنطاق للتحقق من المضاعفات.\n * @return مجموع المضاعفات لـ 3 أو 5 ضمن النطاق.\n */\nint sumOfMultiples(int n)",
      "sw": "#include <cassert>\n#include <iostream>\n/**\n * @brief Inahesabu jumla ya namba zote kutoka 1 hadi n ambazo ni marudufu ya 3 au 5.\n *\n * Inahesabu kila namba mara moja tu hata kama ni marudufu ya 3 na 5.\n * Kwa mfano:\n *     @code\n *     std::cout << sumOfMultiples(10); // Inatoa: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Kikomo cha juu cha safu ya kuangalia marudufu.\n * @return Jumla ya marudufu ya 3 au 5 ndani ya safu.\n */\nint sumOfMultiples(int n)",
      "tr": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1'den n'e kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplar.\n *\n * Her sayıyı yalnızca bir kez sayar, eğer hem 3 hem de 5'in katıysa bile.\n * Örneğin:\n *     @code\n *     std::cout << sumOfMultiples(10); // Çıktı: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Katları kontrol edilecek aralığın üst sınırı.\n * @return Aralık içindeki 3 veya 5'in katlarının toplamı.\n */\nint sumOfMultiples(int n)",
      "vi": "#include <cassert>\n#include <iostream>\n/**\n * @brief Tính tổng của tất cả các số từ 1 đến n là bội số của 3 hoặc 5.\n *\n * Đếm mỗi số chỉ một lần ngay cả khi nó là bội số của cả 3 và 5.\n * Ví dụ:\n *     @code\n *     std::cout << sumOfMultiples(10); // Xuất ra: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Giới hạn trên của phạm vi để kiểm tra bội số.\n * @return Tổng của các bội số của 3 hoặc 5 trong phạm vi.\n */\nint sumOfMultiples(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9858956539034747",
      "arb": "0.9799299890394728",
      "sw": "0.9832590342256176",
      "tr": "0.9755100658006844",
      "vi": "0.9648110389566212"
    },
    "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int sumOfMultiples(int n)` para resolver el siguiente problema:\nCalcula la suma de todos los números del 1 al n que son múltiplos de 3 o 5.\n\nCuenta cada número solo una vez, incluso si es múltiplo de ambos 3 y 5.\nPor ejemplo:\n    std::cout << sumOfMultiples(10); // Salidas: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n El límite superior del rango para verificar múltiplos.\n@return La suma de los múltiplos de 3 o 5 dentro del rango.",
      "arb": "اكتب دالة CPP `int sumOfMultiples(int n)` لحل المشكلة التالية:\nتحسب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5.\n\nتحسب كل رقم مرة واحدة فقط حتى لو كان مضاعفًا لكل من 3 و 5.\nعلى سبيل المثال:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n الحد الأعلى للنطاق للتحقق من المضاعفات.\n@return مجموع المضاعفات لـ 3 أو 5 ضمن النطاق.",
      "sw": "Andika kazi ya CPP `int sumOfMultiples(int n)` kutatua tatizo lifuatalo:\nHesabu jumla ya namba zote kutoka 1 hadi n ambazo ni marudio ya ama 3 au 5.\n\nHesabu kila namba mara moja tu hata kama ni marudio ya 3 na 5.\nKwa mfano:\n    std::cout << sumOfMultiples(10); // Inatoa: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kikomo cha juu cha safu ya kuangalia marudio.\n@return Jumla ya marudio ya ama 3 au 5 ndani ya safu.",
      "tr": "Bir CPP fonksiyonu `int sumOfMultiples(int n)` yazın ve aşağıdaki problemi çözün:\n1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplar.\n\nBir sayı hem 3 hem de 5'in katı olsa bile her sayıyı yalnızca bir kez sayar.\nÖrneğin:\n    std::cout << sumOfMultiples(10); // Çıktı: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Katları kontrol etmek için aralığın üst sınırı.\n@return Aralık içindeki 3 veya 5'in katlarının toplamı.",
      "vi": "Viết một hàm CPP `int sumOfMultiples(int n)` để giải quyết vấn đề sau:\nTính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5.\n\nĐếm mỗi số chỉ một lần ngay cả khi nó là bội số của cả 3 và 5.\nVí dụ:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Giới hạn trên của phạm vi để kiểm tra các bội số.\n@return Tổng của các bội số của 3 hoặc 5 trong phạm vi."
    },
    "instruction_bertscore": {
      "es": "0.975883292286649",
      "arb": "0.9724736031658041",
      "sw": "0.9668253496506961",
      "tr": "0.9338777338269151",
      "vi": "0.9674772545612526"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(sumOfMultiples(10) == 33);\n    assert(sumOfMultiples(15) == 60);\n    assert(sumOfMultiples(20) == 98);\n    assert(sumOfMultiples(5) == 8);\n    assert(sumOfMultiples(3) == 3);\n    assert(sumOfMultiples(6) == 14);\n    assert(sumOfMultiples(9) == 23);\n    assert(sumOfMultiples(12) == 45);\n    assert(sumOfMultiples(17) == 60);\n    assert(sumOfMultiples(21) == 119);\n    assert(sumOfMultiples(25) == 168);\n\n    return 0;\n}",
    "entry_point": "sumOfMultiples",
    "signature": "int sumOfMultiples(int n)",
    "docstring": {
      "es": "Calcula la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5.\n\nCuenta cada número solo una vez, incluso si es múltiplo de ambos 3 y 5.\nPor ejemplo:\n    std::cout << sumOfMultiples(10); // Salidas: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n El límite superior del rango para verificar múltiplos.\n@return La suma de los múltiplos de 3 o 5 dentro del rango.",
      "arb": "يحسب مجموع كل الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5.\n\nيحسب كل رقم مرة واحدة فقط حتى لو كان مضاعفًا لكل من 3 و 5.\nعلى سبيل المثال:\n    std::cout << sumOfMultiples(10); // المخرجات: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n الحد الأعلى للنطاق للتحقق من المضاعفات.\n@return مجموع المضاعفات لـ 3 أو 5 ضمن النطاق.",
      "sw": "Hesabu jumla ya namba zote kutoka 1 hadi n ambazo ni marudio ya aidha 3 au 5.\n\nHesabu kila namba mara moja tu hata kama ni marudio ya 3 na 5.\nKwa mfano:\n    std::cout << sumOfMultiples(10); // Inatoa: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kikomo cha juu cha safu ya kuangalia marudio.\n@return Jumla ya marudio ya aidha 3 au 5 ndani ya safu.",
      "tr": "1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplar.\n\nHer sayıyı yalnızca bir kez sayar, 3 ve 5'in her ikisinin de katı olsa bile.\nÖrneğin:\n    std::cout << sumOfMultiples(10); // Çıktı: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Katları kontrol edilecek aralığın üst sınırı.\n@return Aralık içindeki 3 veya 5'in katlarının toplamı.",
      "vi": "Tính tổng của tất cả các số từ 1 đến n là bội số của 3 hoặc 5.\n\nĐếm mỗi số chỉ một lần ngay cả khi nó là bội số của cả 3 và 5.\nVí dụ:\n    std::cout << sumOfMultiples(10); // Xuất ra: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Giới hạn trên của phạm vi để kiểm tra bội số.\n@return Tổng của các bội số của 3 hoặc 5 trong phạm vi."
    },
    "docstring_bertscore": {
      "es": "0.9703101210555721",
      "arb": "0.9649085664737094",
      "sw": "0.9763230599502603",
      "tr": "0.9650515803480545",
      "vi": "0.9452046313054295"
    }
  },
  {
    "task_id": "CPP/47",
    "prompt": {
      "es": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase,\n * número u otra secuencia de caracteres que se lee igual de adelante hacia atrás\n * y de atrás hacia adelante (ignorando espacios, puntuación y capitalización).\n * Ejemplos:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "arb": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * تحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة. الكلمة المتطابقة هي كلمة أو عبارة أو\n * رقم أو تسلسل آخر من الأحرف الذي يقرأ نفسه بنفس الطريقة من الأمام والخلف \n * (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n * أمثلة:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "sw": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Kuamua kama mfuatano uliotolewa ni palindrome. Palindrome ni neno, kifungu,\n * nambari, au mfuatano mwingine wa herufi ambao unasomwa sawa mbele na\n * nyuma (ukipuuza nafasi, alama za uakifishaji, na herufi kubwa).\n * Mifano:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "tr": "#include <cassert>\n#include <cctype> // isalnum ve tolower için\n#include <cstring> // strlen için\n/**\n * Belirtilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri\n * okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek)\n * bir kelime, ifade, sayı veya başka bir karakter dizisidir.\n * Örnekler:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "vi": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Xác định xem một chuỗi cho trước có phải là một chuỗi palindrome hay không. Một chuỗi palindrome là một từ, cụm từ,\n * số, hoặc một dãy ký tự khác mà đọc xuôi hay ngược đều như nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa).\n * Ví dụ:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)"
    },
    "prompt_bertscore": {
      "es": "0.9977093944459057",
      "arb": "0.997050736102394",
      "sw": "0.9942647463779987",
      "tr": "0.9893734732450146",
      "vi": "0.9950815145048141"
    },
    "canonical_solution": "{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}",
    "instruction": {
      "es": "Escribe una función en CPP `bool isPalindrome(const char* str)` para resolver el siguiente problema:\nDeterminar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\nEjemplos:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "arb": "اكتب دالة CPP `bool isPalindrome(const char* str)` لحل المشكلة التالية:\nتحديد ما إذا كانت السلسلة المعطاة هي كلمة متطابقة. الكلمة المتطابقة هي كلمة، عبارة، رقم، أو تسلسل آخر من الأحرف الذي يقرأ نفسه بنفس الطريقة من الأمام إلى الخلف (مع تجاهل المسافات، علامات الترقيم، والحروف الكبيرة والصغيرة).\nأمثلة:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "sw": "Andika kazi ya CPP `bool isPalindrome(const char* str)` kutatua tatizo lifuatalo:  \nTambua kama kamba iliyotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).  \nMifano:  \n  >>> isPalindrome(\"racecar\")  \n  true  \n  >>> isPalindrome(\"hello\")  \n  false",
      "tr": "Bir CPP fonksiyonu `bool isPalindrome(const char* str)` yazın ve aşağıdaki problemi çözün:\nVerilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan kelime, ifade, sayı veya diğer karakter dizileridir (boşluklar, noktalama işaretleri ve büyük/küçük harf dikkate alınmaz).\nÖrnekler:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "vi": "Viết một hàm CPP `bool isPalindrome(const char* str)` để giải quyết vấn đề sau:  \nXác định xem một chuỗi cho trước có phải là palindrome hay không. Một palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa/thường).  \nVí dụ:  \n  >>> isPalindrome(\"racecar\")  \n  true  \n  >>> isPalindrome(\"hello\")  \n  false  "
    },
    "instruction_bertscore": {
      "es": "0.9924778674702088",
      "arb": "0.9976627163063625",
      "sw": "0.9965889204664878",
      "tr": "0.9949927267244915",
      "vi": "0.9977127711623832"
    },
    "level": "middle",
    "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}",
    "entry_point": "isPalindrome",
    "signature": "bool isPalindrome(const char* str)",
    "docstring": {
      "es": "Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual hacia adelante y hacia atrás (ignorando espacios, puntuación y mayúsculas).\nEjemplos:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "arb": "تحديد ما إذا كانت سلسلة معينة هي جملة مقلوبة. الجملة المقلوبة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف يقرأ بنفس الطريقة من الأمام والخلف (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n\nأمثلة:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "sw": "Amua ikiwa string iliyopewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (ukipuuza nafasi, alama za uakifishaji, na matumizi ya herufi kubwa na ndogo).\n\nMifano:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "tr": "Verilen bir stringin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\nÖrnekler:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "vi": "Xác định xem một chuỗi cho trước có phải là palindrome hay không. Một palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n\nVí dụ:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9990139987885428",
      "sw": "0.9965489957598999",
      "tr": "0.9803663799866065",
      "vi": "0.9971899759994994"
    }
  },
  {
    "task_id": "CPP/48",
    "prompt": {
      "es": "#include <cassert>\n#include <cstdio>\n/*\nDado un número entero no negativo num, esta función lo reduce a un solo dígito sumando repetidamente todos sus dígitos.\nPor ejemplo:\n    >>> addDigits(38)\n    2\nEl cálculo es porque 3 + 8 = 11, y luego 1 + 1 = 2. Se devuelve 2 ya que es un número de un solo dígito.\n*/\nint addDigits(int num)",
      "arb": "#include <cassert>\n#include <cstdio>\n/*\nبالنظر إلى عدد صحيح غير سالب، تقوم هذه الدالة بتقليله إلى رقم واحد عن طريق جمع جميع أرقامه بشكل متكرر.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\nالحساب هو لأن 3 + 8 = 11، و 1 + 1 = 2. يتم إرجاع 2 لأنه رقم واحد.\n*/\nint addDigits(int num)",
      "sw": "#include <cassert>\n#include <cstdio>\n/*\nIkizingatiwa nambari isiyo hasi num, kazi hii inapunguza hadi tarakimu moja kwa kuongeza mara kwa mara tarakimu zake zote.\nKwa mfano:\n    >>> addDigits(38)\n    2\nHesabu ni kwa sababu 3 + 8 = 11, na zaidi 1 + 1 = 2. 2 inarudishwa kwa kuwa ni nambari ya tarakimu moja.\n*/\nint addDigits(int num)",
      "tr": "#include <cassert>\n#include <cstdio>\n/*\nVerilen negatif olmayan bir tam sayı num, bu fonksiyon onu tüm basamaklarını tekrar tekrar toplayarak tek bir rakama indirger.\nÖrneğin:\n    >>> addDigits(38)\n    2\nHesaplama 3 + 8 = 11 ve daha sonra 1 + 1 = 2 olduğu içindir. 2, tek basamaklı bir sayı olduğu için döndürülür.\n*/\nint addDigits(int num)",
      "vi": "#include <cassert>\n#include <cstdio>\n/*\nCho một số nguyên không âm num, hàm này giảm nó xuống còn một chữ số bằng cách liên tục cộng tất cả các chữ số của nó.\nVí dụ:\n    >>> addDigits(38)\n    2\nPhép tính là vì 3 + 8 = 11, và tiếp tục 1 + 1 = 2. 2 được trả về vì nó là một số có một chữ số.\n*/\nint addDigits(int num)"
    },
    "prompt_bertscore": {
      "es": "0.975051229620494",
      "arb": "0.9694254213384428",
      "sw": "0.9927762103025232",
      "tr": "0.9586538944053018",
      "vi": "0.9839667542732449"
    },
    "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "es": "Escribe una función CPP `int addDigits(int num)` para resolver el siguiente problema:\nDado un entero no negativo num, esta función lo reduce a un solo dígito sumando repetidamente todos sus dígitos.\nPor ejemplo:\n    >>> addDigits(38)\n    2\nEl cálculo es porque 3 + 8 = 11, y además 1 + 1 = 2. Se devuelve 2 ya que es un número de un solo dígito.",
      "arb": "اكتب دالة CPP `int addDigits(int num)` لحل المشكلة التالية:\nبالنظر إلى عدد صحيح غير سالب num، تقوم هذه الدالة بتقليله إلى رقم واحد عن طريق جمع جميع أرقامه بشكل متكرر.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\nالحساب هو لأن 3 + 8 = 11، ومزيد من 1 + 1 = 2. يتم إرجاع 2 لأنه رقم مكون من خانة واحدة.",
      "sw": "Andika kazi ya CPP `int addDigits(int num)` kutatua tatizo lifuatalo:\nUkipiwa nambari isiyo hasi num, kazi hii inapunguza hadi tarakimu moja kwa kuongeza tarakimu zake zote mara kwa mara.\nKwa mfano:\n    >>> addDigits(38)\n    2\nHesabu ni kwa sababu 3 + 8 = 11, na zaidi 1 + 1 = 2. 2 inarudishwa kwa kuwa ni nambari ya tarakimu moja.",
      "tr": "Bir CPP fonksiyonu `int addDigits(int num)` yazın:\nVerilen bir negatif olmayan tamsayı num, bu fonksiyon tüm basamaklarını tekrar tekrar toplayarak onu tek bir basamağa indirger.\nÖrneğin:\n    >>> addDigits(38)\n    2\nHesaplama, çünkü 3 + 8 = 11 ve daha sonra 1 + 1 = 2. 2 döndürülür çünkü bu tek basamaklı bir sayıdır.",
      "vi": "Viết một hàm CPP `int addDigits(int num)` để giải quyết vấn đề sau:  \nCho một số nguyên không âm num, hàm này giảm nó xuống một chữ số bằng cách liên tục cộng tất cả các chữ số của nó.  \nVí dụ:  \n    >>> addDigits(38)  \n    2  \nPhép tính là vì 3 + 8 = 11, và tiếp tục 1 + 1 = 2. 2 được trả về vì nó là một số có một chữ số.  "
    },
    "instruction_bertscore": {
      "es": "0.9754028053949256",
      "arb": "0.9866673329337952",
      "sw": "0.9919016407348266",
      "tr": "0.9413571608247837",
      "vi": "0.978376500829399"
    },
    "level": "easy",
    "test": "int main() {\n    assert(addDigits(38) == 2);\n    assert(addDigits(0) == 0);\n    assert(addDigits(9) == 9);\n    assert(addDigits(123) == 6);\n    assert(addDigits(456) == 6);\n    assert(addDigits(9999) == 9);\n    assert(addDigits(100) == 1);\n    assert(addDigits(1010) == 2);\n    assert(addDigits(1234) == 1);\n    assert(addDigits(9876) == 3);\n    assert(addDigits(199) == 1);\n    return 0;\n}",
    "entry_point": "addDigits",
    "signature": "int addDigits(int num)",
    "docstring": {
      "es": "Dado un número entero no negativo num, esta función lo reduce a un solo dígito sumando repetidamente todos sus dígitos.\nPor ejemplo:\n    >>> addDigits(38)\n    2\nEl cálculo es porque 3 + 8 = 11, y además 1 + 1 = 2. Se devuelve 2 ya que es un número de un solo dígito.",
      "arb": "بالنظر إلى عدد صحيح غير سالب num، تقوم هذه الدالة بتقليله إلى رقم واحد عن طريق جمع جميع أرقامه بشكل متكرر.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\nالحساب هو لأن 3 + 8 = 11، وبالإضافة إلى ذلك 1 + 1 = 2. يتم إرجاع 2 لأنه رقم مكون من خانة واحدة.",
      "sw": "Kwa kupewa nambari isiyo na alama hasi num, kazi hii inapunguza hadi tarakimu moja kwa kuongeza mara kwa mara tarakimu zake zote. \n\nKwa mfano:\n    >>> addDigits(38)\n    2\n\nHesabu ni kwa sababu 3 + 8 = 11, na zaidi 1 + 1 = 2. 2 inarejeshwa kwa kuwa ni nambari ya tarakimu moja.",
      "tr": "Verilen bir negatif olmayan tam sayı num için, bu fonksiyon tüm basamaklarını tekrar tekrar toplayarak onu tek bir rakama indirger.\nÖrneğin:\n    >>> addDigits(38)\n    2\nHesaplama, çünkü 3 + 8 = 11 ve daha sonra 1 + 1 = 2. 2 döndürülür çünkü bu tek basamaklı bir sayıdır.",
      "vi": "Cho một số nguyên không âm num, hàm này giảm nó xuống một chữ số bằng cách liên tục cộng tất cả các chữ số của nó.\nVí dụ:\n    >>> addDigits(38)\n    2\nPhép tính là vì 3 + 8 = 11, và tiếp tục 1 + 1 = 2. 2 được trả về vì nó là một số có một chữ số."
    },
    "docstring_bertscore": {
      "es": "0.9689445371859573",
      "arb": "0.9772331843561621",
      "sw": "0.9908463175203882",
      "tr": "0.9553037943987673",
      "vi": "0.9782458020386781"
    }
  },
  {
    "task_id": "CPP/49",
    "prompt": {
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Estás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y\n * tu oponente se turnan para quitar de 1 a 3 piedras de la pila. Quien quite la última piedra gana\n * el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu\n * oponente juegan óptimamente.\n * Nota: Siempre tomas el primer turno.\n *\n * Aquí hay algunos casos:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل آخر حجر يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت وخصمك تلعبان بشكل مثالي.\n * ملاحظة: أنت دائمًا تأخذ الدور الأول.\n *\n * إليك بعض الحالات:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na\n * mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho\n * anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wote wewe\n * na mpinzani wako mna cheza kwa ustadi.\n * Kumbuka: Daima unachukua zamu ya kwanza.\n *\n * Hapa kuna baadhi ya kesi:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Nim adında bir oyun oynuyorsunuz. Bu oyunda, n taşından oluşan bir yığınla başlarsınız ve siz ve\n * rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n\n * verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı\n * belirleyin.\n * Not: Her zaman ilk hamleyi siz yaparsınız.\n *\n * İşte bazı durumlar:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Bạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng\n * đối thủ của bạn lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn\n * và đối thủ của bạn chơi tối ưu.\n * Lưu ý: Bạn luôn là người đi trước.\n *\n * Dưới đây là một số trường hợp:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9860257568030525",
      "arb": "0.9748667019965125",
      "sw": "0.9919683805428543",
      "tr": "0.9756649974978917",
      "vi": "0.9778622467728997"
    },
    "canonical_solution": "{\n    return n % 4 != 0;\n}",
    "instruction": {
      "es": "Escribe una función CPP `bool canWinNim(int n)` para resolver el siguiente problema:\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila. Quien quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true",
      "arb": "اكتب دالة CPP `bool canWinNim(int n)` لحل المشكلة التالية:\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من الحجارة عددها n، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل آخر حجر يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت وخصمك تلعبان بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true",
      "sw": "Andika kazi ya CPP `bool canWinNim(int n)` kutatua tatizo lifuatalo:\nUnacheza mchezo uitwao Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ustadi.\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true",
      "tr": "Bir CPP fonksiyonu `bool canWinNim(int n)` yazın ve aşağıdaki problemi çözün:\nNim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsanız oyunu kazanıp kazanamayacağınızı belirleyin.\nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true",
      "vi": "Viết một hàm CPP `bool canWinNim(int n)` để giải quyết vấn đề sau:\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ của mình lần lượt lấy từ 1 đến 3 viên đá ra khỏi đống. Người lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu.\nLưu ý: Bạn luôn là người đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true"
    },
    "instruction_bertscore": {
      "es": "0.9893530143157679",
      "arb": "0.988396609031085",
      "sw": "0.9923815317354069",
      "tr": "0.981080853467189",
      "vi": "0.9799895781537833"
    },
    "level": "easy",
    "test": "int main() {\n    assert(canWinNim(1) == true);\n    assert(canWinNim(2) == true);\n    assert(canWinNim(3) == true);\n    assert(canWinNim(4) == false);\n    assert(canWinNim(5) == true);\n    assert(canWinNim(6) == true);\n    assert(canWinNim(7) == true);\n    assert(canWinNim(8) == false);\n    assert(canWinNim(9) == true);\n    assert(canWinNim(10) == true);\n    assert(canWinNim(11) == true);\n    assert(canWinNim(12) == false);\n    assert(canWinNim(13) == true);\n    assert(canWinNim(14) == true);\n    assert(canWinNim(15) == true);\n    assert(canWinNim(16) == false);\n    assert(canWinNim(17) == true);\n    assert(canWinNim(18) == true);\n    assert(canWinNim(19) == true);\n    assert(canWinNim(20) == false);\n    return 0;\n}",
    "entry_point": "canWinNim",
    "signature": "bool canWinNim(int n)",
    "docstring": {
      "es": "Estás jugando a un juego llamado Nim. En este juego, comienzas con un montón de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras del montón. El que quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true",
      "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة تحتوي على n من الحجارة، وتقوم أنت وخصمك بالتناوب لإزالة من 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت وخصمك تلعبان بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true",
      "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho ndiye anayeshinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wote wewe na mpinzani wako mna cheza kwa ustadi.\n\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true",
      "tr": "Bir oyun oynuyorsunuz, adı Nim. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı belirleyin. \nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nBazı durumlar:\n    >>> canWinNim(1)\n    true",
      "vi": "Bạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ của bạn lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn và đối thủ đều chơi tối ưu hay không. \nLưu ý: Bạn luôn là người đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "es": "0.9948346169411877",
      "arb": "0.9781947540307521",
      "sw": "0.9948346169411877",
      "tr": "0.9737827760072051",
      "vi": "0.9762334776484135"
    }
  },
  {
    "task_id": "CPP/50",
    "prompt": {
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dados dos enteros a y b, devuelve la suma si la suma es par, o el producto de a y b si la suma es impar.\n * Ejemplos:\n *    evenSumOrOddProduct(2, 3) returns 6\n *    evenSumOrOddProduct(5, 5) returns 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجيًا، أو حاصل ضرب a و b إذا كان المجموع فرديًا.\n * أمثلة:\n *    evenSumOrOddProduct(2, 3) returns 6\n *    evenSumOrOddProduct(5, 5) returns 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa nambari mbili a na b, rudisha jumla ikiwa jumla ni shufwa, au bidhaa ya a na b ikiwa jumla ni witiri.\n * Mifano:\n *    evenSumOrOddProduct(2, 3) inarudisha 6\n *    evenSumOrOddProduct(5, 5) inarudisha 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * İki tamsayı a ve b verildiğinde, toplam çift ise toplamı, toplam tek ise a ve b'nin çarpımını döndürün.\n * Örnekler:\n *    evenSumOrOddProduct(2, 3) 6 döndürür\n *    evenSumOrOddProduct(5, 5) 10 döndürür\n */\nint evenSumOrOddProduct(int a, int b)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc tích của a và b nếu tổng là số lẻ.\n * Ví dụ:\n *    evenSumOrOddProduct(2, 3) trả về 6\n *    evenSumOrOddProduct(5, 5) trả về 10\n */\nint evenSumOrOddProduct(int a, int b)"
    },
    "prompt_bertscore": {
      "es": "0.9969557907802593",
      "arb": "1",
      "sw": "0.9908320161329537",
      "tr": "1",
      "vi": "0.9972753870633444"
    },
    "canonical_solution": "{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}",
    "instruction": {
      "es": "Escribe una función en CPP `int evenSumOrOddProduct(int a, int b)` para resolver el siguiente problema:\nDado dos enteros a y b, devuelve la suma si la suma es par, o el producto de a y b si la suma es impar.\nEjemplos:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "arb": "اكتب دالة CPP `int evenSumOrOddProduct(int a, int b)` لحل المشكلة التالية:\nمعطى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجيًا، أو حاصل ضرب a و b إذا كان المجموع فرديًا.\nأمثلة:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "sw": "Andika kazi ya CPP `int evenSumOrOddProduct(int a, int b)` kutatua tatizo lifuatalo:  \nUkipata nambari mbili nzima a na b, rudisha jumla ikiwa jumla ni shufwa, au bidhaa ya a na b ikiwa jumla ni witiri.  \nMifano:  \nevenSumOrOddProduct(2, 3) inarudisha 6  \nevenSumOrOddProduct(5, 5) inarudisha 10  ",
      "tr": "Bir CPP fonksiyonu `int evenSumOrOddProduct(int a, int b)` yazın ve aşağıdaki problemi çözün:\nVerilen iki tam sayı a ve b için, toplam çift ise toplamı, toplam tek ise a ve b'nin çarpımını döndürün.\nÖrnekler:\nevenSumOrOddProduct(2, 3) 6 döndürür\nevenSumOrOddProduct(5, 5) 10 döndürür",
      "vi": "Viết một hàm CPP `int evenSumOrOddProduct(int a, int b)` để giải quyết vấn đề sau:  \nCho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc tích của a và b nếu tổng là số lẻ.  \nVí dụ:  \nevenSumOrOddProduct(2, 3) trả về 6  \nevenSumOrOddProduct(5, 5) trả về 10  "
    },
    "instruction_bertscore": {
      "es": "0.9932487519790052",
      "arb": "1",
      "sw": "1",
      "tr": "0.9795430570572169",
      "vi": "0.9980081345389822"
    },
    "level": "easy",
    "test": "int main() {\n    assert(evenSumOrOddProduct(2, 3) == 6);\n    assert(evenSumOrOddProduct(5, 5) == 10);\n    assert(evenSumOrOddProduct(1, 1) == 2);\n    assert(evenSumOrOddProduct(0, 0) == 0);\n    assert(evenSumOrOddProduct(-1, -1) == -2);\n    assert(evenSumOrOddProduct(100, 200) == 300);\n    assert(evenSumOrOddProduct(3, 4) == 12);\n    assert(evenSumOrOddProduct(-5, 5) == 0);\n    assert(evenSumOrOddProduct(7, 8) == 56);\n    assert(evenSumOrOddProduct(9, 10) == 90);\n    assert(evenSumOrOddProduct(11, 14) == 154);\n    return 0;\n}",
    "entry_point": "evenSumOrOddProduct",
    "signature": "int evenSumOrOddProduct(int a, int b)",
    "docstring": {
      "es": "Dado dos enteros a y b, devuelve la suma si la suma es par, o el producto de a y b si la suma es impar.\nEjemplos:\nevenSumOrOddProduct(2, 3) devuelve 6\nevenSumOrOddProduct(5, 5) devuelve 10",
      "arb": "إعطاء عددين صحيحين a و b، قم بإرجاع المجموع إذا كان المجموع زوجيًا، أو حاصل ضرب a و b إذا كان المجموع فرديًا.\nأمثلة:\nevenSumOrOddProduct(2, 3) يعيد 6\nevenSumOrOddProduct(5, 5) يعيد 10",
      "sw": "Ukipewa nambari mbili a na b, rudisha jumla ikiwa jumla ni shufwa, au bidhaa ya a na b ikiwa jumla ni witiri.\n\nMifano:\nevenSumOrOddProduct(2, 3) inarudisha 6\nevenSumOrOddProduct(5, 5) inarudisha 10",
      "tr": "İki tamsayı a ve b verildiğinde, toplam çift ise toplamı, toplam tek ise a ve b'nin çarpımını döndürün.\nÖrnekler:\nevenSumOrOddProduct(2, 3) 6 döndürür\nevenSumOrOddProduct(5, 5) 10 döndürür",
      "vi": "Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc tích của a và b nếu tổng là số lẻ.\nVí dụ:\nevenSumOrOddProduct(2, 3) trả về 6\nevenSumOrOddProduct(5, 5) trả về 10"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "1",
      "vi": "0.9969617496916904"
    }
  }
]