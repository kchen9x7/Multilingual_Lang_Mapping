[
  {
    "task_id": "Ruby/1",
    "prompt": {
      "en": "# Check if in given list of numbers, any two numbers are closer to each other than\n# given threshold.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "es": "# Verificar si en la lista dada de números, hay dos números más cercanos entre sí que el\n# umbral dado.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "arb": "# تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما من\n# العتبة المعطاة.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "sw": "# Angalia kama katika orodha iliyotolewa ya namba, kuna namba mbili zozote zilizo karibu zaidi na kila moja kuliko kizingiti kilichotolewa.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "tr": "# Verilen sayı listesindeki herhangi iki sayının\n# verilen eşikten daha yakın olup olmadığını kontrol et.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "vi": "# Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn\n# ngưỡng đã cho hay không.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)"
    },
    "prompt_bertscore": {
      "es": "0.9809646546942835",
      "arb": "0.9873295666241655",
      "sw": "0.9799856055461625",
      "tr": "0.972660712984739",
      "vi": "0.9808573942885247"
    },
    "canonical_solution": "numbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end",
    "instruction": {
      "en": "Write a ruby function `def has_close_elements(numbers, threshold)` to solve the following problem:\nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "es": "Escribe una función en ruby `def has_close_elements(numbers, threshold)` para resolver el siguiente problema:\nVerifica si en la lista dada de números, hay dos números que estén más cerca uno del otro que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "arb": "اكتب دالة روبي `def has_close_elements(numbers, threshold)` لحل المشكلة التالية:\nتحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sw": "Andika kazi ya ruby `def has_close_elements(numbers, threshold)` kutatua tatizo lifuatalo:\nAngalia kama katika orodha iliyotolewa ya nambari, nambari zozote mbili ziko karibu zaidi kwa kila mmoja kuliko kizingiti kilichopewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "tr": "Bir ruby fonksiyonu `def has_close_elements(numbers, threshold)` yazın: \nVerilen sayı listesinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "vi": "Viết một hàm ruby `def has_close_elements(numbers, threshold)` để giải quyết vấn đề sau:\nKiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "instruction_bertscore": {
      "es": "0.9729332338675188",
      "arb": "0.9824653072230022",
      "sw": "0.8009195225216867",
      "tr": "0.960140841437729",
      "vi": "0.9813841620590292"
    },
    "level": "easy",
    "test": "  # Test cases\n  def check(has_close_elements)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3)\n    raise 'Test failed' if has_close_elements.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95)\n    raise 'Test failed' if has_close_elements.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\n    raise 'Test failed' unless has_close_elements.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0)\n    raise 'Test failed' if has_close_elements.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5)\n  \n    puts 'All tests passed!'\n  end\n  \n  check(method(:has_close_elements))",
    "entry_point": "has_close_elements",
    "signature": "def has_close_elements(numbers, threshold)",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "es": "Verifica si en la lista dada de números, hay dos números que estén más cerca uno del otro que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "arb": "التحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المحددة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sw": "Angalia ikiwa katika orodha iliyotolewa ya nambari, nambari yoyote mbili ziko karibu zaidi na kila mmoja kuliko kizingiti kilichotolewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "vi": "Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "docstring_bertscore": {
      "es": "0.969819901275178",
      "arb": "0.9825139716663557",
      "sw": "0.9859016128149057",
      "tr": "0.9638012020994399",
      "vi": "0.9763492791605569"
    }
  },
  {
    "task_id": "Ruby/2",
    "prompt": {
      "en": "# Counts the number of times the digit '1' appears in all numbers from 1 to n.\n# The function takes a single argument, n, which is a positive integer, and \n# returns the total count of the digit '1' appearing in all numbers from 1 to n.\n#\n# Example:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "es": "# Cuenta el número de veces que el dígito '1' aparece en todos los números del 1 al n.\n# La función toma un solo argumento, n, que es un entero positivo, y\n# devuelve el conteo total del dígito '1' apareciendo en todos los números del 1 al n.\n#\n# Ejemplo:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "arb": "# يحسب عدد المرات التي يظهر فيها الرقم '1' في جميع الأرقام من 1 إلى n.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب،\n# وتعيد العدد الإجمالي لظهور الرقم '1' في جميع الأرقام من 1 إلى n.\n#\n# مثال:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "sw": "# Inahesabu idadi ya mara ambazo tarakimu '1' inaonekana katika namba zote kutoka 1 hadi n.\n# Kazi inachukua hoja moja, n, ambayo ni nambari nzima chanya, na \n# inarudisha jumla ya idadi ya tarakimu '1' inayoonekana katika namba zote kutoka 1 hadi n.\n#\n# Mfano:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "tr": "# 1'den n'e kadar olan tüm sayılarda '1' rakamının kaç kez göründüğünü sayar.\n# Fonksiyon, pozitif bir tamsayı olan n'i tek bir argüman olarak alır ve \n# 1'den n'e kadar olan tüm sayılarda '1' rakamının toplam sayısını döndürür.\n#\n# Örnek:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "vi": "# Đếm số lần chữ số '1' xuất hiện trong tất cả các số từ 1 đến n.\n# Hàm nhận một tham số duy nhất, n, là một số nguyên dương, và\n# trả về tổng số lần chữ số '1' xuất hiện trong tất cả các số từ 1 đến n.\n#\n# Ví dụ:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)"
    },
    "prompt_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9724747949480904",
      "sw": "0.9924574085409622",
      "tr": "0.9671604391035019",
      "vi": "0.9823663892932467"
    },
    "canonical_solution": "  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n",
    "instruction": {
      "en": "Write a ruby function `def count_ones_in_range(n)` to solve the following problem:\nCounts the number of times the digit '1' appears in all numbers from 1 to n.\nThe function takes a single argument, n, which is a positive integer, and\nreturns the total count of the digit '1' appearing in all numbers from 1 to n.\n\nExample:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "es": "Escribe una función en ruby `def count_ones_in_range(n)` para resolver el siguiente problema:\nCuenta el número de veces que aparece el dígito '1' en todos los números del 1 al n.\nLa función toma un solo argumento, n, que es un entero positivo, y\ndevuelve el conteo total del dígito '1' que aparece en todos los números del 1 al n.\n\nEjemplo:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "arb": "اكتب دالة روبي `def count_ones_in_range(n)` لحل المشكلة التالية:\nتحسب عدد المرات التي يظهر فيها الرقم '1' في جميع الأرقام من 1 إلى n.\nتأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد العدد الإجمالي لظهور الرقم '1' في جميع الأرقام من 1 إلى n.\n\nمثال:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "sw": "Andika kazi ya ruby `def count_ones_in_range(n)` kutatua tatizo lifuatalo:\nInahesabu idadi ya mara ambazo tarakimu '1' inaonekana katika namba zote kutoka 1 hadi n.\nKazi inachukua hoja moja, n, ambayo ni nambari nzima chanya, na\ninarudisha jumla ya idadi ya tarakimu '1' inayoonekana katika namba zote kutoka 1 hadi n.\n\nMfano:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "tr": "Bir ruby fonksiyonu `def count_ones_in_range(n)` yazın: \n1'den n'e kadar olan tüm sayılarda '1' rakamının kaç kez göründüğünü sayar.\nFonksiyon, pozitif bir tamsayı olan n adlı tek bir argüman alır ve\n1'den n'e kadar olan tüm sayılarda '1' rakamının toplam sayısını döndürür.\n\nÖrnek:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "vi": "Viết một hàm ruby `def count_ones_in_range(n)` để giải quyết vấn đề sau:\nĐếm số lần chữ số '1' xuất hiện trong tất cả các số từ 1 đến n.\nHàm nhận một đối số duy nhất, n, là một số nguyên dương, và\ntrả về tổng số lần chữ số '1' xuất hiện trong tất cả các số từ 1 đến n.\n\nVí dụ:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12"
    },
    "instruction_bertscore": {
      "es": "0.9891108838812864",
      "arb": "0.9838543294775791",
      "sw": "0.9826780403610905",
      "tr": "0.9591472922717925",
      "vi": "0.9860970651098441"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_ones_in_range(15) == 8\nraise 'Test failed' unless count_ones_in_range(20) == 12\nraise 'Test failed' unless count_ones_in_range(100) == 21\nraise 'Test failed' unless count_ones_in_range(5) == 1\nraise 'Test failed' unless count_ones_in_range(55) == 16\nraise 'Test failed' unless count_ones_in_range(0) == 0\n\nputs 'All tests passed!'",
    "entry_point": "count_ones_in_range",
    "signature": "def count_ones_in_range(n)",
    "docstring": {
      "en": "Counts the number of times the digit '1' appears in all numbers from 1 to n.\nThe function takes a single argument, n, which is a positive integer, and\nreturns the total count of the digit '1' appearing in all numbers from 1 to n.\n\nExample:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "es": "Cuenta el número de veces que aparece el dígito '1' en todos los números del 1 al n.  \nLa función toma un solo argumento, n, que es un número entero positivo, y  \ndevuelve el conteo total del dígito '1' que aparece en todos los números del 1 al n.\n\nEjemplo:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "arb": "يحسب عدد المرات التي يظهر فيها الرقم '1' في جميع الأرقام من 1 إلى n. تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد العدد الإجمالي لظهور الرقم '1' في جميع الأرقام من 1 إلى n.\n\nمثال:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "sw": "Hesabu idadi ya mara ambazo tarakimu '1' inaonekana katika namba zote kutoka 1 hadi n. \nKazi hii inachukua hoja moja, n, ambayo ni nambari kamili chanya, na \ninarudisha jumla ya hesabu ya tarakimu '1' inayoonekana katika namba zote kutoka 1 hadi n.\n\nMfano:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "tr": "1'den n'e kadar olan tüm sayılarda '1' rakamının kaç kez göründüğünü sayar. \nFonksiyon, pozitif bir tamsayı olan n adlı tek bir argüman alır ve \n1'den n'e kadar olan tüm sayılarda '1' rakamının toplam sayısını döndürür.\n\nÖrnek:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "vi": "Đếm số lần chữ số '1' xuất hiện trong tất cả các số từ 1 đến n. Hàm nhận một đối số duy nhất, n, là một số nguyên dương, và trả về tổng số lần chữ số '1' xuất hiện trong tất cả các số từ 1 đến n.\n\nVí dụ:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12"
    },
    "docstring_bertscore": {
      "es": "0.9841745216518073",
      "arb": "0.9831241641968949",
      "sw": "0.983870617168824",
      "tr": "0.9804658938075049",
      "vi": "0.9809455861777042"
    }
  },
  {
    "task_id": "Ruby/3",
    "prompt": {
      "en": "# Calculates the total count of the digit '1' in the binary representation of all numbers in a given range [l, r].\n# The function takes two arguments, l and r, where l <= r and both are non-negative integers. It returns the sum \n# of all '1's in the binary representation of each number in the range [l, r].\n#\n# Examples:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "es": "# Calcula el conteo total del dígito '1' en la representación binaria de todos los números en un rango dado [l, r].\n# La función toma dos argumentos, l y r, donde l <= r y ambos son enteros no negativos. Devuelve la suma\n# de todos los '1's en la representación binaria de cada número en el rango [l, r].\n#\n# Ejemplos:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "arb": "# يحسب العدد الإجمالي للرقم '1' في التمثيل الثنائي لجميع الأرقام في النطاق المعطى [l, r].\n# تأخذ الدالة وسيطين، l و r، حيث l <= r وكلاهما أعداد صحيحة غير سالبة. تُرجع مجموع \n# جميع '1's في التمثيل الثنائي لكل رقم في النطاق [l, r].\n#\n# أمثلة:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "sw": "# Inahesabu jumla ya idadi ya tarakimu '1' katika uwakilishi wa binary wa namba zote katika safu iliyotolewa [l, r].\n# Kazi inachukua hoja mbili, l na r, ambapo l <= r na zote ni namba zisizo na alama hasi. Inarudisha jumla \n# ya '1' zote katika uwakilishi wa binary wa kila namba katika safu [l, r].\n#\n# Mifano:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "tr": "# Belirtilen [l, r] aralığındaki tüm sayıların ikili (binary) gösterimlerinde '1' rakamının toplam sayısını hesaplar.\n# Fonksiyon iki argüman alır, l ve r, burada l <= r ve her ikisi de negatif olmayan tam sayılardır. \n# Bu aralıktaki her sayının ikili gösterimindeki tüm '1'lerin toplamını döndürür.\n#\n# Örnekler:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "vi": "# Tính tổng số lượng chữ số '1' trong biểu diễn nhị phân của tất cả các số trong một phạm vi cho trước [l, r].\n# Hàm nhận hai đối số, l và r, trong đó l <= r và cả hai đều là số nguyên không âm. Nó trả về tổng\n# của tất cả các chữ số '1' trong biểu diễn nhị phân của mỗi số trong phạm vi [l, r].\n#\n# Ví dụ:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)"
    },
    "prompt_bertscore": {
      "es": "0.9992134236911019",
      "arb": "0.9745556468198119",
      "sw": "0.9683979063773492",
      "tr": "0.9438507666282957",
      "vi": "0.9774639928589247"
    },
    "canonical_solution": "  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend",
    "instruction": {
      "en": "Write a ruby function `def sum_of_binary_ones(l, r)` to solve the following problem:\nCalculates the total count of the digit '1' in the binary representation of all numbers in a given range [l, r].\nThe function takes two arguments, l and r, where l <= r and both are non-negative integers. It returns the sum\nof all '1's in the binary representation of each number in the range [l, r].\n\nExamples:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "es": "Escribe una función en ruby `def sum_of_binary_ones(l, r)` para resolver el siguiente problema:\nCalcula el conteo total del dígito '1' en la representación binaria de todos los números en un rango dado [l, r].\nLa función toma dos argumentos, l y r, donde l <= r y ambos son enteros no negativos. Devuelve la suma\nde todos los '1's en la representación binaria de cada número en el rango [l, r].\n\nEjemplos:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "arb": "اكتب دالة روبي `def sum_of_binary_ones(l, r)` لحل المشكلة التالية:\nتحسب العدد الإجمالي للرقم '1' في التمثيل الثنائي لجميع الأرقام في نطاق معين [l, r].\nتأخذ الدالة وسيطين، l و r، حيث l <= r وكلاهما عددان صحيحان غير سالبين. تُرجع مجموع\nجميع '1's في التمثيل الثنائي لكل رقم في النطاق [l, r].\n\nأمثلة:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "sw": "Andika kazi ya ruby `def sum_of_binary_ones(l, r)` kutatua tatizo lifuatalo:\nInahesabu jumla ya idadi ya tarakimu '1' katika uwakilishi wa nambari ya binary ya nambari zote katika safu iliyotolewa [l, r].\nKazi inachukua hoja mbili, l na r, ambapo l <= r na zote ni nambari zisizo na alama hasi. Inarudisha jumla\nya '1' zote katika uwakilishi wa binary wa kila nambari katika safu [l, r].\n\nMifano:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "tr": "Bir ruby fonksiyonu `def sum_of_binary_ones(l, r)` yazın:\nVerilen [l, r] aralığındaki tüm sayıların ikili gösteriminde '1' rakamının toplam sayısını hesaplar.\nFonksiyon, l ve r olmak üzere iki argüman alır, burada l <= r ve her ikisi de negatif olmayan tam sayılardır. Bu aralıktaki her sayının ikili gösterimindeki tüm '1'lerin toplamını döndürür.\n\nÖrnekler:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "vi": "Viết một hàm ruby `def sum_of_binary_ones(l, r)` để giải quyết vấn đề sau:\nTính tổng số lượng chữ số '1' trong biểu diễn nhị phân của tất cả các số trong một phạm vi cho trước [l, r].\nHàm nhận hai đối số, l và r, trong đó l <= r và cả hai đều là số nguyên không âm. Nó trả về tổng\ncủa tất cả các chữ số '1' trong biểu diễn nhị phân của mỗi số trong phạm vi [l, r].\n\nVí dụ:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5"
    },
    "instruction_bertscore": {
      "es": "0.9952136037082023",
      "arb": "0.9765177177236745",
      "sw": "0.979464200795946",
      "tr": "0.9518827833462035",
      "vi": "0.9774073832003297"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless sum_of_binary_ones(2, 3) == 3\nraise 'Test failed' unless sum_of_binary_ones(5, 5) == 2\nraise 'Test failed' unless sum_of_binary_ones(0, 4) == 5\nraise 'Test failed' unless sum_of_binary_ones(10, 15) == 17\nraise 'Test failed' unless sum_of_binary_ones(0, 0) == 0\n\n\n\nputs 'All tests passed!'",
    "entry_point": "sum_of_binary_ones",
    "signature": "def sum_of_binary_ones(l, r)",
    "docstring": {
      "en": "Calculates the total count of the digit '1' in the binary representation of all numbers in a given range [l, r].\nThe function takes two arguments, l and r, where l <= r and both are non-negative integers. It returns the sum\nof all '1's in the binary representation of each number in the range [l, r].\n\nExamples:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "es": "Calcula el conteo total del dígito '1' en la representación binaria de todos los números en un rango dado [l, r]. La función toma dos argumentos, l y r, donde l <= r y ambos son enteros no negativos. Devuelve la suma de todos los '1's en la representación binaria de cada número en el rango [l, r].\n\nEjemplos:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "arb": "يحسب العدد الإجمالي للرقم '1' في التمثيل الثنائي لجميع الأرقام في نطاق معين [l, r]. تأخذ الدالة وسيطين، l و r، حيث l <= r وكلاهما عددان صحيحان غير سالبين. تُرجع مجموع جميع '1's في التمثيل الثنائي لكل رقم في النطاق [l, r].\n\nأمثلة:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "sw": "Hesabu jumla ya idadi ya tarakimu '1' katika uwakilishi wa binary wa nambari zote katika safu iliyotolewa [l, r]. \nKazi inachukua hoja mbili, l na r, ambapo l <= r na zote ni nambari zisizo hasi. Inarudisha jumla \nya '1' zote katika uwakilishi wa binary wa kila nambari katika safu [l, r].\n\nMifano:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "tr": "Belirtilen aralıktaki [l, r] tüm sayıların ikili gösteriminde '1' rakamının toplam sayısını hesaplar.\nFonksiyon iki argüman alır, l ve r, burada l <= r ve her ikisi de negatif olmayan tam sayılardır. Aralık [l, r] içindeki her sayının ikili gösterimindeki tüm '1'lerin toplamını döndürür.\n\nÖrnekler:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "vi": "Tính tổng số chữ số '1' trong biểu diễn nhị phân của tất cả các số trong một phạm vi cho trước [l, r]. Hàm nhận hai đối số, l và r, trong đó l <= r và cả hai đều là số nguyên không âm. Nó trả về tổng của tất cả các chữ số '1' trong biểu diễn nhị phân của mỗi số trong phạm vi [l, r].\n\nVí dụ:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5"
    },
    "docstring_bertscore": {
      "es": "0.9984014226934312",
      "arb": "0.9747624210464692",
      "sw": "0.9641368874433889",
      "tr": "0.9673735695023524",
      "vi": "0.9725139251331543"
    }
  },
  {
    "task_id": "Ruby/4",
    "prompt": {
      "en": "# Converts a positive integer into a unique binary power representation.\n# The function takes a single argument, n, which is a positive integer, and\n# returns a string representing n as a sum of powers of 2, with the powers \n# themselves also represented as sums of powers of 2 when applicable.\n#\n# The representation is formatted as '2(b)' where 'b' is the power. If 'b' itself \n# is a power of 2, it's represented in a similar nested format. Spaces are not \n# used in the representation.\n#\n# Example:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "es": "# Convierte un entero positivo en una representación única de potencias de dos.\n# La función toma un solo argumento, n, que es un entero positivo, y\n# devuelve una cadena que representa n como una suma de potencias de 2, con las potencias\n# también representadas como sumas de potencias de 2 cuando sea aplicable.\n#\n# La representación se formatea como '2(b)' donde 'b' es la potencia. Si 'b' en sí mismo\n# es una potencia de 2, se representa en un formato anidado similar. No se utilizan\n# espacios en la representación.\n#\n# Ejemplo:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "arb": "# يحول عددًا صحيحًا موجبًا إلى تمثيل فريد لقوة ثنائية.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد\n# سلسلة تمثل n كمجموع لقوى 2، مع تمثيل القوى\n# نفسها أيضًا كمجموع لقوى 2 عند الاقتضاء.\n#\n# يتم تنسيق التمثيل كـ '2(b)' حيث 'b' هو القوة. إذا كانت 'b' نفسها\n# قوة لـ 2، يتم تمثيلها بتنسيق متداخل مماثل. لا تُستخدم\n# المسافات في التمثيل.\n#\n# مثال:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\" \n\ndef binary_power_representation(n)",
      "sw": "# Hubadilisha nambari nzima chanya kuwa uwakilishi wa kipekee wa nguvu za binary.\n# Kazi inachukua hoja moja, n, ambayo ni nambari nzima chanya, na\n# inarudisha kamba inayowakilisha n kama jumla ya nguvu za 2, na nguvu \n# zenyewe pia zinawakilishwa kama jumla ya nguvu za 2 inapowezekana.\n#\n# Uwakilishi umeundwa kama '2(b)' ambapo 'b' ni nguvu. Ikiwa 'b' yenyewe \n# ni nguvu ya 2, inawakilishwa kwa muundo sawa wa ndani. Nafasi hazitumiwi \n# katika uwakilishi.\n#\n# Mfano:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\" \n\ndef binary_power_representation(n)",
      "tr": "# Pozitif bir tam sayıyı benzersiz bir ikili kuvvet temsil biçimine dönüştürür.\n# Fonksiyon, pozitif bir tam sayı olan n adlı tek bir argüman alır ve\n# n'yi 2'nin kuvvetlerinin toplamı olarak temsil eden bir dize döndürür, \n# kuvvetler de uygulanabilir olduğunda 2'nin kuvvetlerinin toplamı olarak temsil edilir.\n#\n# Temsil biçimi '2(b)' şeklinde biçimlendirilmiştir, burada 'b' kuvvettir. Eğer 'b' \n# kendisi 2'nin bir kuvveti ise, benzer bir iç içe biçimde temsil edilir. Temsil biçiminde \n# boşluk kullanılmaz.\n#\n# Örnek:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "vi": "# Chuyển đổi một số nguyên dương thành một biểu diễn duy nhất dưới dạng lũy thừa nhị phân.\n# Hàm nhận một đối số duy nhất, n, là một số nguyên dương, và\n# trả về một chuỗi biểu diễn n dưới dạng tổng của các lũy thừa của 2, với các lũy thừa \n# cũng được biểu diễn dưới dạng tổng của các lũy thừa của 2 khi có thể.\n#\n# Biểu diễn được định dạng là '2(b)' trong đó 'b' là lũy thừa. Nếu 'b' tự nó \n# là một lũy thừa của 2, nó được biểu diễn theo định dạng lồng nhau tương tự. Không sử dụng \n# khoảng trắng trong biểu diễn.\n#\n# Ví dụ:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)"
    },
    "prompt_bertscore": {
      "es": "0.9819212586093475",
      "arb": "0.9895295967245079",
      "sw": "0.9762797585271947",
      "tr": "0.9621797822990521",
      "vi": "0.9688307219776243"
    },
    "canonical_solution": "    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end",
    "instruction": {
      "en": "Write a ruby function `def binary_power_representation(n)` to solve the following problem:\nConverts a positive integer into a unique binary power representation.\nThe function takes a single argument, n, which is a positive integer, and\nreturns a string representing n as a sum of powers of 2, with the powers\nthemselves also represented as sums of powers of 2 when applicable.\n\nThe representation is formatted as '2(b)' where 'b' is the power. If 'b' itself\nis a power of 2, it's represented in a similar nested format. Spaces are not\nused in the representation.\n\nExample:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "es": "Escribe una función en Ruby `def binary_power_representation(n)` para resolver el siguiente problema:\nConvierte un entero positivo en una representación única de potencias binarias.\nLa función toma un solo argumento, n, que es un entero positivo, y\ndevuelve una cadena que representa n como una suma de potencias de 2, con las potencias\ntambién representadas como sumas de potencias de 2 cuando sea aplicable.\n\nLa representación está formateada como '2(b)' donde 'b' es la potencia. Si 'b' en sí mismo\nes una potencia de 2, se representa en un formato anidado similar. No se utilizan\nespacios en la representación.\n\nEjemplo:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "arb": "اكتب دالة روبي `def binary_power_representation(n)` لحل المشكلة التالية:\nتحول عددًا صحيحًا موجبًا إلى تمثيل فريد لقوة ثنائية.\nتأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد سلسلة تمثل n كمجموع لقوى 2، مع تمثيل القوى نفسها أيضًا كمجموع لقوى 2 عند الاقتضاء.\n\nيتم تنسيق التمثيل كـ '2(b)' حيث 'b' هو القوة. إذا كانت 'b' نفسها قوة لـ 2، يتم تمثيلها بتنسيق متداخل مشابه. لا تُستخدم المسافات في التمثيل.\n\nمثال:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "sw": "Andika kazi ya ruby `def binary_power_representation(n)` kutatua tatizo lifuatalo:\nInabadilisha namba nzima chanya kuwa uwakilishi wa kipekee wa nguvu za binary.\nKazi inachukua hoja moja, n, ambayo ni namba nzima chanya, na\ninarudisha kamba inayoonyesha n kama jumla ya nguvu za 2, na nguvu zenyewe\npia zinawakilishwa kama jumla ya nguvu za 2 inapowezekana.\n\nUwakilishi umeundwa kama '2(b)' ambapo 'b' ni nguvu. Ikiwa 'b' yenyewe\nni nguvu ya 2, inawakilishwa kwa muundo sawa wa ndani. Nafasi hazitumiki\nkatika uwakilishi.\n\nMfano:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "tr": "Bir ruby fonksiyonu `def binary_power_representation(n)` yazın ve aşağıdaki problemi çözün:\nPozitif bir tam sayıyı benzersiz bir ikili güç temsil biçimine dönüştürür.\nFonksiyon, pozitif bir tam sayı olan n adlı tek bir argüman alır ve\nn'yi 2'nin kuvvetlerinin toplamı olarak temsil eden bir dize döndürür, burada\nkuvvetler de uygulanabilir olduğunda 2'nin kuvvetlerinin toplamı olarak temsil edilir.\n\nTemsil biçimi '2(b)' şeklinde formatlanır, burada 'b' kuvvettir. Eğer 'b' kendisi\n2'nin bir kuvveti ise, benzer bir iç içe formatta temsil edilir. Temsilde boşluklar\nkullanılmaz.\n\nÖrnek:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "vi": "Viết một hàm ruby `def binary_power_representation(n)` để giải quyết vấn đề sau:\nChuyển đổi một số nguyên dương thành một biểu diễn lũy thừa nhị phân duy nhất.\nHàm nhận một đối số duy nhất, n, là một số nguyên dương, và\ntrả về một chuỗi đại diện cho n dưới dạng tổng của các lũy thừa của 2, với các lũy thừa\ncũng được biểu diễn dưới dạng tổng của các lũy thừa của 2 khi có thể.\n\nBiểu diễn được định dạng dưới dạng '2(b)' trong đó 'b' là lũy thừa. Nếu 'b' tự nó\nlà một lũy thừa của 2, nó được biểu diễn theo định dạng lồng nhau tương tự. Không sử dụng\nkhoảng trắng trong biểu diễn.\n\nVí dụ:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\""
    },
    "instruction_bertscore": {
      "es": "0.9885348557762852",
      "arb": "0.992325517967955",
      "sw": "0.9766291493674351",
      "tr": "0.9819347654752579",
      "vi": "0.9845562892441564"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless binary_power_representation(137) == \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\nraise 'Test failed' unless binary_power_representation(1315) == \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\nraise 'Test failed' unless binary_power_representation(1) == \"2(0)\"\nraise 'Test failed' unless binary_power_representation(3) == \"2+2(0)\"\nraise 'Test failed' unless binary_power_representation(10) == \"2(2+2(0))+2\"\n\n\nputs 'All tests passed!'",
    "entry_point": "binary_power_representation",
    "signature": "def binary_power_representation(n)",
    "docstring": {
      "en": "Converts a positive integer into a unique binary power representation.\nThe function takes a single argument, n, which is a positive integer, and\nreturns a string representing n as a sum of powers of 2, with the powers\nthemselves also represented as sums of powers of 2 when applicable.\n\nThe representation is formatted as '2(b)' where 'b' is the power. If 'b' itself\nis a power of 2, it's represented in a similar nested format. Spaces are not\nused in the representation.\n\nExample:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "es": "Convierte un entero positivo en una representación única de potencias binarias.\nLa función toma un solo argumento, n, que es un entero positivo, y\ndevuelve una cadena que representa n como una suma de potencias de 2, con las potencias\ntambién representadas como sumas de potencias de 2 cuando sea aplicable.\n\nLa representación está formateada como '2(b)' donde 'b' es la potencia. Si 'b' en sí mismo\nes una potencia de 2, se representa en un formato anidado similar. No se utilizan\nespacios en la representación.\n\nEjemplo:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "arb": "يحوّل عددًا صحيحًا موجبًا إلى تمثيل فريد لقوة ثنائية.  \nتأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد سلسلة تمثل n كمجموع لقوى العدد 2، مع تمثيل القوى نفسها أيضًا كمجموع لقوى العدد 2 عند الاقتضاء.\n\nيتم تنسيق التمثيل كـ '2(b)' حيث 'b' هو القوة. إذا كانت 'b' نفسها قوة للعدد 2، يتم تمثيلها بتنسيق متداخل مشابه. لا تُستخدم المسافات في التمثيل.\n\nمثال:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "sw": "Inabadilisha nambari kamili chanya kuwa uwakilishi wa kipekee wa nguvu za binary.\nKazi hii inachukua hoja moja, n, ambayo ni nambari kamili chanya, na\ninarudisha kamba inayowakilisha n kama jumla ya nguvu za 2, na nguvu\nwenyewe pia zinaonyeshwa kama jumla ya nguvu za 2 inapohitajika.\n\nUwakilishi umeundwa kama '2(b)' ambapo 'b' ni nguvu. Ikiwa 'b' yenyewe\nni nguvu ya 2, inaonyeshwa kwa muundo sawa wa ndani. Nafasi hazitumiki\nkatika uwakilishi.\n\nMfano:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "tr": "Pozitif bir tam sayıyı benzersiz bir ikili güç temsiline dönüştürür.\nFonksiyon, n olarak adlandırılan pozitif bir tam sayı olan tek bir argüman alır ve\nn'yi 2'nin kuvvetlerinin toplamı olarak temsil eden bir dize döndürür, burada kuvvetler\nuygulanabilir olduğunda yine 2'nin kuvvetlerinin toplamı olarak temsil edilir.\n\nTemsil, 'b' kuvveti olan '2(b)' biçiminde formatlanır. Eğer 'b' kendisi\n2'nin bir kuvveti ise, benzer şekilde iç içe geçmiş bir formatta temsil edilir. Temsilde boşluk kullanılmaz.\n\nÖrnek:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "vi": "Chuyển đổi một số nguyên dương thành một biểu diễn lũy thừa nhị phân duy nhất.  \nHàm nhận một đối số duy nhất, n, là một số nguyên dương, và  \ntrả về một chuỗi đại diện cho n dưới dạng tổng của các lũy thừa của 2, với các lũy thừa  \ncũng được biểu diễn dưới dạng tổng của các lũy thừa của 2 khi có thể.\n\nBiểu diễn được định dạng là '2(b)' trong đó 'b' là lũy thừa. Nếu 'b' tự nó  \nlà một lũy thừa của 2, nó được biểu diễn theo định dạng lồng nhau tương tự. Không sử dụng khoảng trắng  \ntrong biểu diễn.\n\nVí dụ:  \n>>> binary_power_representation(137)  \n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"  \n>>> binary_power_representation(1315)  \n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"  "
    },
    "docstring_bertscore": {
      "es": "0.9894126034300784",
      "arb": "0.9677390494034566",
      "sw": "0.9690253797510385",
      "tr": "0.9813323195295791",
      "vi": "0.9825924306668644"
    }
  },
  {
    "task_id": "Ruby/5",
    "prompt": {
      "en": "# Finds the maximum possible Least Common Multiple (LCM) of any three numbers chosen between 1 and n.\n# The function takes a single argument, n, which is a positive integer, and returns the highest LCM\n# attainable by any combination of three distinct numbers from 1 to n.\n#\n# Example:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "es": "# Encuentra el Máximo Común Múltiplo (MCM) más alto posible de cualquier tres números elegidos entre 1 y n.\n# La función toma un solo argumento, n, que es un entero positivo, y devuelve el MCM más alto\n# alcanzable por cualquier combinación de tres números distintos del 1 al n.\n#\n# Ejemplo:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "arb": "# يجد أكبر مضاعف مشترك أصغر (LCM) ممكن لأي ثلاثة أرقام مختارة بين 1 و n.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد أعلى LCM\n# يمكن تحقيقه بواسطة أي مجموعة من ثلاثة أرقام مميزة من 1 إلى n.\n#\n# مثال:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "sw": "# Inapata Kiwango cha Juu cha Kawaida (LCM) kinachowezekana cha nambari tatu zozote zilizochaguliwa kati ya 1 na n.\n# Kazi inachukua hoja moja, n, ambayo ni nambari nzima chanya, na inarejesha LCM ya juu zaidi\n# inayoweza kupatikana kwa mchanganyiko wowote wa nambari tatu tofauti kutoka 1 hadi n.\n#\n# Mfano:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "tr": "# 1 ve n arasında seçilen herhangi üç sayının mümkün olan en büyük Asal Ortak Çarpanını (LCM) bulur.\n# Fonksiyon, pozitif bir tamsayı olan n adlı tek bir argüman alır ve 1 ile n arasından seçilen\n# üç farklı sayının herhangi bir kombinasyonu ile elde edilebilecek en yüksek LCM'yi döndürür.\n#\n# Örnek:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "vi": "# Tìm Bội số chung nhỏ nhất (LCM) lớn nhất có thể của bất kỳ ba số nào được chọn từ 1 đến n.\n# Hàm nhận một đối số duy nhất, n, là một số nguyên dương, và trả về LCM cao nhất\n# có thể đạt được bởi bất kỳ tổ hợp nào của ba số khác nhau từ 1 đến n.\n#\n# Ví dụ:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)"
    },
    "prompt_bertscore": {
      "es": "0.9875689162333126",
      "arb": "0.9654146766845864",
      "sw": "0.974289084848463",
      "tr": "0.96535012181075",
      "vi": "0.9771634650924189"
    },
    "canonical_solution": "    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end",
    "instruction": {
      "en": "Write a ruby function `def max_lcm_of_three(n)` to solve the following problem:\nFinds the maximum possible Least Common Multiple (LCM) of any three numbers chosen between 1 and n.\nThe function takes a single argument, n, which is a positive integer, and returns the highest LCM\nattainable by any combination of three distinct numbers from 1 to n.\n\nExample:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "es": "Escribe una función en ruby `def max_lcm_of_three(n)` para resolver el siguiente problema:\nEncuentra el Máximo Común Múltiplo (LCM) posible más alto de cualquier tres números elegidos entre 1 y n.\nLa función toma un solo argumento, n, que es un número entero positivo, y devuelve el LCM más alto\nobtenible por cualquier combinación de tres números distintos del 1 al n.\n\nEjemplo:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "arb": "اكتب دالة روبي `def max_lcm_of_three(n)` لحل المشكلة التالية:\nتجد أكبر مضاعف مشترك أصغر (LCM) ممكن لأي ثلاثة أرقام مختارة بين 1 و n.\nتأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد أعلى LCM يمكن تحقيقه بواسطة أي مجموعة من ثلاثة أرقام مميزة من 1 إلى n.\n\nمثال:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "sw": "Andika kazi ya ruby `def max_lcm_of_three(n)` kutatua tatizo lifuatalo:\nInapata Kiwango cha Juu cha Kawaida (LCM) kinachowezekana cha nambari tatu zozote zilizochaguliwa kati ya 1 na n.\nKazi inachukua hoja moja, n, ambayo ni nambari nzima chanya, na inarejesha LCM ya juu inayoweza kupatikana kwa mchanganyiko wowote wa nambari tatu tofauti kutoka 1 hadi n.\n\nMfano:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "tr": "Bir ruby fonksiyonu `def max_lcm_of_three(n)` yazın ve aşağıdaki problemi çözün:\n1 ile n arasında seçilen herhangi üç sayının mümkün olan en yüksek Ortak Katını (LCM) bulur.\nFonksiyon, pozitif bir tamsayı olan n adlı tek bir argüman alır ve 1 ile n arasındaki üç farklı sayının herhangi bir kombinasyonu ile elde edilebilecek en yüksek LCM'yi döndürür.\n\nÖrnek:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "vi": "Viết một hàm ruby `def max_lcm_of_three(n)` để giải quyết vấn đề sau:  \nTìm Bội số Chung Nhỏ nhất (LCM) lớn nhất có thể của bất kỳ ba số nào được chọn từ 1 đến n.  \nHàm nhận một tham số duy nhất, n, là một số nguyên dương, và trả về LCM cao nhất có thể đạt được bởi bất kỳ tổ hợp nào của ba số khác nhau từ 1 đến n.  \n\nVí dụ:  \n>>> max_lcm_of_three(9)  \n504  \n>>> max_lcm_of_three(10)  \n630  "
    },
    "instruction_bertscore": {
      "es": "0.9894749733697233",
      "arb": "0.961131808408712",
      "sw": "0.9770514375575152",
      "tr": "0.9693499417936495",
      "vi": "0.9761683268834341"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless max_lcm_of_three(9) == 504\nraise 'Test failed' unless max_lcm_of_three(10) == 630\nraise 'Test failed' unless max_lcm_of_three(3) == 6\nraise 'Test failed' unless max_lcm_of_three(5) == 60\nraise 'Test failed' unless max_lcm_of_three(1) == 1\n  \n\nputs 'All tests passed!'",
    "entry_point": "max_lcm_of_three",
    "signature": "def max_lcm_of_three(n)",
    "docstring": {
      "en": "Finds the maximum possible Least Common Multiple (LCM) of any three numbers chosen between 1 and n.\nThe function takes a single argument, n, which is a positive integer, and returns the highest LCM\nattainable by any combination of three distinct numbers from 1 to n.\n\nExample:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "es": "Encuentra el Máximo Común Múltiplo (MCM) más alto posible de cualquier tres números elegidos entre 1 y n.  \nLa función toma un solo argumento, n, que es un entero positivo, y devuelve el MCM más alto alcanzable por cualquier combinación de tres números distintos del 1 al n.\n\nEjemplo:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "arb": "يجد أكبر مضاعف مشترك أصغر (LCM) ممكن لأي ثلاثة أرقام مختارة بين 1 و n. تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد أعلى LCM يمكن تحقيقه بواسطة أي مجموعة من ثلاثة أرقام مميزة من 1 إلى n.\n\nمثال:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "sw": "Inapata Kiwango cha Juu cha Kawaida (LCM) kinachowezekana cha nambari tatu zozote zilizochaguliwa kati ya 1 na n. \nKazi hii inachukua hoja moja, n, ambayo ni nambari nzima chanya, na inarejesha LCM ya juu zaidi inayoweza kupatikana kwa mchanganyiko wowote wa nambari tatu tofauti kutoka 1 hadi n.\n\nMfano:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "tr": "1 ile n arasında seçilen herhangi üç sayının maksimum mümkün olan En Küçük Ortak Katı'nı (EKOK) bulur. \nFonksiyon, pozitif bir tam sayı olan n'yi tek bir argüman olarak alır ve 1 ile n arasındaki üç farklı sayının herhangi bir kombinasyonu ile elde edilebilecek en yüksek EKOK'u döndürür.\n\nÖrnek:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "vi": "Tìm Bội Số Chung Nhỏ Nhất (LCM) lớn nhất có thể của bất kỳ ba số nào được chọn trong khoảng từ 1 đến n. Hàm nhận một đối số duy nhất, n, là một số nguyên dương, và trả về LCM cao nhất có thể đạt được bởi bất kỳ tổ hợp nào của ba số khác nhau từ 1 đến n.\n\nVí dụ:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630"
    },
    "docstring_bertscore": {
      "es": "0.9777158561820769",
      "arb": "0.9684314749117442",
      "sw": "0.9789708029294554",
      "tr": "0.9662423694823586",
      "vi": "0.9560268089857343"
    }
  },
  {
    "task_id": "Ruby/6",
    "prompt": {
      "en": "# Swaps the case of each letter in a given string.\n# The function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters. \n# It returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.\n#\n# Example:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "es": "# Intercambia el caso de cada letra en una cadena dada.\n# La función toma un solo argumento, input_string, que es una cadena que contiene solo alfabetos en inglés sin espacios ni otros tipos de caracteres.\n# Devuelve una nueva cadena donde cada letra minúscula se convierte en mayúscula y cada letra mayúscula se convierte en minúscula.\n#\n# Ejemplo:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "arb": "# يبدل حالة كل حرف في سلسلة نصية معطاة.\n# تأخذ الدالة وسيطًا واحدًا، input_string، وهو سلسلة نصية تحتوي فقط على الحروف الإنجليزية بدون أي مسافات أو أنواع أخرى من الأحرف.\n# تُرجع سلسلة نصية جديدة حيث يتم تحويل كل حرف صغير إلى كبير وكل حرف كبير إلى صغير.\n#\n# مثال:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "sw": "# Hubadilisha herufi kubwa na ndogo za kila herufi katika kamba iliyotolewa.\n# Kazi inachukua hoja moja, input_string, ambayo ni kamba inayo na alfabeti za Kiingereza pekee bila nafasi au aina nyingine za herufi.\n# Inarudisha kamba mpya ambapo kila herufi ndogo inabadilishwa kuwa herufi kubwa na kila herufi kubwa inabadilishwa kuwa herufi ndogo.\n#\n# Mfano:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "tr": "# Verilen bir stringdeki her harfin büyük/küçük harf durumunu değiştirir.\n# Fonksiyon, yalnızca İngiliz alfabesi harflerinden oluşan, boşluk veya başka türde karakter içermeyen bir string olan input_string adlı tek bir argüman alır.\n# Her küçük harfin büyük harfe ve her büyük harfin küçük harfe dönüştürüldüğü yeni bir string döndürür.\n#\n# Örnek:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "vi": "# Đổi chữ hoa thành chữ thường và ngược lại cho mỗi chữ cái trong một chuỗi đã cho.\n# Hàm nhận một đối số duy nhất, input_string, là một chuỗi chỉ chứa các chữ cái tiếng Anh mà không có khoảng trắng hoặc các loại ký tự khác.\n# Nó trả về một chuỗi mới trong đó mọi chữ cái thường được chuyển thành chữ hoa và mọi chữ hoa được chuyển thành chữ thường.\n#\n# Ví dụ:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)"
    },
    "prompt_bertscore": {
      "es": "0.9836948292816081",
      "arb": "0.9669238703196894",
      "sw": "0.970052894712132",
      "tr": "0.9600111357989132",
      "vi": "0.9505497748590783"
    },
    "canonical_solution": "    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end",
    "instruction": {
      "en": "Write a ruby function `def swap_case(input_string)` to solve the following problem:\nSwaps the case of each letter in a given string.\nThe function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters.\nIt returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.\n\nExample:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "es": "Escribe una función en Ruby `def swap_case(input_string)` para resolver el siguiente problema:\nIntercambia el caso de cada letra en una cadena dada.\nLa función toma un solo argumento, input_string, que es una cadena que contiene solo alfabetos ingleses sin espacios ni otros tipos de caracteres.\nDevuelve una nueva cadena donde cada letra minúscula se convierte en mayúscula y cada letra mayúscula se convierte en minúscula.\n\nEjemplo:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "arb": "اكتب دالة روبي `def swap_case(input_string)` لحل المشكلة التالية:\nتبديل حالة كل حرف في سلسلة معينة.\nتأخذ الدالة وسيطًا واحدًا، input_string، وهو سلسلة تحتوي فقط على الحروف الإنجليزية بدون أي مسافات أو أنواع أخرى من الأحرف.\nتعيد سلسلة جديدة حيث يتم تحويل كل حرف صغير إلى كبير وكل حرف كبير إلى صغير.\n\nمثال:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "sw": "Andika kazi ya ruby `def swap_case(input_string)` kutatua tatizo lifuatalo:\nHubadilisha herufi kubwa na ndogo za kila herufi katika kamba iliyotolewa.\nKazi inachukua hoja moja, input_string, ambayo ni kamba inayo na alfabeti za Kiingereza pekee bila nafasi au aina nyingine za herufi.\nInarudisha kamba mpya ambapo kila herufi ndogo inabadilishwa kuwa herufi kubwa na kila herufi kubwa inabadilishwa kuwa herufi ndogo.\n\nMfano:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "tr": "Bir ruby fonksiyonu `def swap_case(input_string)` yazın:\nVerilen bir stringdeki her harfin büyük/küçük harf durumunu değiştirir.\nFonksiyon, yalnızca İngiliz alfabesi harfleri içeren, boşluk veya başka türde karakter içermeyen bir string olan input_string adlı tek bir argüman alır.\nHer küçük harfin büyük harfe ve her büyük harfin küçük harfe dönüştürüldüğü yeni bir string döndürür.\n\nÖrnek:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "vi": "Viết một hàm ruby `def swap_case(input_string)` để giải quyết vấn đề sau:\nĐổi trường hợp của mỗi chữ cái trong một chuỗi cho trước.\nHàm nhận một tham số duy nhất, input_string, là một chuỗi chỉ chứa các chữ cái tiếng Anh mà không có khoảng trắng hoặc các loại ký tự khác.\nNó trả về một chuỗi mới trong đó mọi chữ cái thường được chuyển thành chữ hoa và mọi chữ cái hoa được chuyển thành chữ thường.\n\nVí dụ:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\""
    },
    "instruction_bertscore": {
      "es": "0.9827896706352321",
      "arb": "0.9675747820783407",
      "sw": "0.961951357360862",
      "tr": "0.9460053103713811",
      "vi": "0.9674810285384923"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless swap_case(\"HelloWorld\") == \"hELLOwORLD\"\nraise 'Test failed' unless swap_case(\"Ruby\") == \"rUBY\"\nraise 'Test failed' unless swap_case(\"AeDb\") == \"aEdB\"\nraise 'Test failed' unless swap_case(\"JAVA\") == \"java\"\nraise 'Test failed' unless swap_case(\"python\") == \"PYTHON\"\n  \n\nputs 'All tests passed!'",
    "entry_point": "swap_case",
    "signature": "def swap_case(input_string)",
    "docstring": {
      "en": "Swaps the case of each letter in a given string.\nThe function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters.\nIt returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.\n\nExample:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "es": "Intercambia la mayúscula y minúscula de cada letra en una cadena dada.\nLa función toma un solo argumento, input_string, que es una cadena que contiene solo alfabetos en inglés sin espacios ni otros tipos de caracteres.\nDevuelve una nueva cadena donde cada letra minúscula se convierte en mayúscula y cada letra mayúscula se convierte en minúscula.\n\nEjemplo:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "arb": "يقوم بتبديل حالة كل حرف في سلسلة معينة.\nتأخذ الدالة وسيطًا واحدًا، input_string، وهو سلسلة تحتوي فقط على الحروف الإنجليزية بدون أي مسافات أو أنواع أخرى من الأحرف.\nتُرجع سلسلة جديدة حيث يتم تحويل كل حرف صغير إلى كبير وكل حرف كبير إلى صغير.\n\nمثال:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "sw": "Badilisha herufi kubwa na ndogo za kila herufi katika kamba iliyotolewa.\n\nKazi hii inachukua hoja moja, input_string, ambayo ni kamba inayojumuisha alfabeti za Kiingereza pekee bila nafasi au aina nyingine za herufi.\n\nInarudisha kamba mpya ambapo kila herufi ndogo inabadilishwa kuwa herufi kubwa na kila herufi kubwa inabadilishwa kuwa herufi ndogo.\n\nMfano:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "tr": "Her harfin büyük/küçük harf durumunu değiştiren bir dizge döndürür.\nFonksiyon, yalnızca İngiliz alfabesi harflerini içeren ve boşluk veya diğer türde karakterler içermeyen bir dizge olan input_string adlı tek bir argüman alır.\nHer küçük harfin büyük harfe ve her büyük harfin küçük harfe dönüştürüldüğü yeni bir dizge döndürür.\n\nÖrnek:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "vi": "Hoán đổi chữ hoa và chữ thường của mỗi chữ cái trong một chuỗi cho trước. Hàm nhận một tham số duy nhất, input_string, là một chuỗi chỉ chứa các chữ cái tiếng Anh mà không có khoảng trắng hoặc các loại ký tự khác. Nó trả về một chuỗi mới trong đó mọi chữ cái thường được chuyển thành chữ hoa và mọi chữ cái hoa được chuyển thành chữ thường.\n\nVí dụ:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\""
    },
    "docstring_bertscore": {
      "es": "0.9600528481789306",
      "arb": "0.958899600186642",
      "sw": "0.9542659506578601",
      "tr": "0.9380181841195873",
      "vi": "0.9608694176753649"
    }
  },
  {
    "task_id": "Ruby/7",
    "prompt": {
      "en": "# Finds the maximum value in an array and returns its value along with its index.\n# The function takes a single argument, arr, which is an array of integers. The array size should be between 1 and 100.\n# It returns an array containing the maximum value and its index in the format [max_value, index].\n#\n# Example:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "es": "# Encuentra el valor máximo en un arreglo y devuelve su valor junto con su índice.\n# La función toma un solo argumento, arr, que es un arreglo de enteros. El tamaño del arreglo debe estar entre 1 y 100.\n# Devuelve un arreglo que contiene el valor máximo y su índice en el formato [max_value, index].\n#\n# Ejemplo:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "arb": "# يجد القيمة القصوى في مصفوفة ويعيد قيمتها مع مؤشرها.\n# تأخذ الدالة وسيطًا واحدًا، arr، وهو مصفوفة من الأعداد الصحيحة. يجب أن يكون حجم المصفوفة بين 1 و 100.\n# تعيد مصفوفة تحتوي على القيمة القصوى ومؤشرها في الشكل [max_value, index].\n#\n# مثال:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "sw": "# Inapata thamani ya juu zaidi katika safu na kurudisha thamani yake pamoja na nafasi yake.\n# Kazi inachukua hoja moja, arr, ambayo ni safu ya nambari za mzima. Ukubwa wa safu unapaswa kuwa kati ya 1 na 100.\n# Inarudisha safu inayojumuisha thamani ya juu zaidi na nafasi yake katika muundo [max_value, index].\n#\n# Mfano:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "tr": "# Bir dizideki maksimum değeri bulur ve bu değeri dizinle birlikte döndürür.\n# Fonksiyon, bir tamsayı dizisi olan arr adlı tek bir argüman alır. Dizi boyutu 1 ile 100 arasında olmalıdır.\n# Maksimum değeri ve dizindeki yerini [max_value, index] formatında içeren bir dizi döndürür.\n#\n# Örnek:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "vi": "# Tìm giá trị lớn nhất trong một mảng và trả về giá trị đó cùng với chỉ số của nó.\n# Hàm nhận một đối số duy nhất, arr, là một mảng các số nguyên. Kích thước mảng nên nằm trong khoảng từ 1 đến 100.\n# Nó trả về một mảng chứa giá trị lớn nhất và chỉ số của nó theo định dạng [max_value, index].\n#\n# Ví dụ:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)"
    },
    "prompt_bertscore": {
      "es": "0.9885320749509507",
      "arb": "0.980466291068267",
      "sw": "0.9709592451407941",
      "tr": "0.9825600539147558",
      "vi": "0.9824788140889125"
    },
    "canonical_solution": "    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end",
    "instruction": {
      "en": "Write a ruby function `def find_max_with_index(arr)` to solve the following problem:\nFinds the maximum value in an array and returns its value along with its index.\nThe function takes a single argument, arr, which is an array of integers. The array size should be between 1 and 100.\nIt returns an array containing the maximum value and its index in the format [max_value, index].\n\nExample:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "es": "Escribe una función en ruby `def find_max_with_index(arr)` para resolver el siguiente problema:\nEncuentra el valor máximo en un array y devuelve su valor junto con su índice.\nLa función toma un solo argumento, arr, que es un array de enteros. El tamaño del array debe estar entre 1 y 100.\nDevuelve un array que contiene el valor máximo y su índice en el formato [max_value, index].\n\nEjemplo:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "arb": "اكتب دالة روبي `def find_max_with_index(arr)` لحل المشكلة التالية:\nتجد القيمة القصوى في مصفوفة وتعيد قيمتها مع مؤشرها.\nتأخذ الدالة وسيطًا واحدًا، arr، وهو مصفوفة من الأعداد الصحيحة. يجب أن يكون حجم المصفوفة بين 1 و 100.\nتُعيد مصفوفة تحتوي على القيمة القصوى ومؤشرها في الشكل [max_value, index].\n\nمثال:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "sw": "Andika kazi ya ruby `def find_max_with_index(arr)` kutatua tatizo lifuatalo:\nInapata thamani ya juu zaidi katika safu na kurudisha thamani yake pamoja na faharasa yake.\nKazi inachukua hoja moja, arr, ambayo ni safu ya nambari za mzima. Ukubwa wa safu unapaswa kuwa kati ya 1 na 100.\nInarudisha safu iliyo na thamani ya juu zaidi na faharasa yake katika muundo [max_value, index].\n\nMfano:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "tr": "Bir ruby fonksiyonu `def find_max_with_index(arr)` yazın:\nBir dizideki maksimum değeri bulur ve bu değeri indeksle birlikte döndürür.\nFonksiyon, tek bir argüman alır, arr, bu bir tamsayı dizisidir. Dizi boyutu 1 ile 100 arasında olmalıdır.\nMaksimum değeri ve indeksini [max_value, index] formatında içeren bir dizi döndürür.\n\nÖrnek:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "vi": "Viết một hàm ruby `def find_max_with_index(arr)` để giải quyết vấn đề sau:\nTìm giá trị lớn nhất trong một mảng và trả về giá trị đó cùng với chỉ số của nó.\nHàm nhận một đối số duy nhất, arr, là một mảng các số nguyên. Kích thước mảng nên nằm trong khoảng từ 1 đến 100.\nNó trả về một mảng chứa giá trị lớn nhất và chỉ số của nó theo định dạng [max_value, index].\n\nVí dụ:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]"
    },
    "instruction_bertscore": {
      "es": "0.9844577685751631",
      "arb": "0.9763979436039104",
      "sw": "0.9777720685799098",
      "tr": "0.9707665736711903",
      "vi": "0.9923763673454999"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless find_max_with_index([3, 2, 1]) == [3, 0]\nraise 'Test failed' unless find_max_with_index([10, 20, 30, 40]) == [40, 3]\nraise 'Test failed' unless find_max_with_index([5]) == [5, 0]\nraise 'Test failed' unless find_max_with_index([-3, -2, -1, -4]) == [-1, 2]\nraise 'Test failed' unless find_max_with_index([100, 200, 100, 50]) == [200, 1]\n  \nputs 'All tests passed!'",
    "entry_point": "find_max_with_index",
    "signature": "def find_max_with_index(arr)",
    "docstring": {
      "en": "Finds the maximum value in an array and returns its value along with its index.\nThe function takes a single argument, arr, which is an array of integers. The array size should be between 1 and 100.\nIt returns an array containing the maximum value and its index in the format [max_value, index].\n\nExample:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "es": "Encuentra el valor máximo en un arreglo y devuelve su valor junto con su índice.\nLa función toma un único argumento, arr, que es un arreglo de enteros. El tamaño del arreglo debe estar entre 1 y 100.\nDevuelve un arreglo que contiene el valor máximo y su índice en el formato [max_value, index].\n\nEjemplo:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "arb": "يعثر على القيمة القصوى في مصفوفة ويعيد قيمتها مع مؤشرها.\nتأخذ الدالة وسيطًا واحدًا، arr، وهو مصفوفة من الأعداد الصحيحة. يجب أن يكون حجم المصفوفة بين 1 و 100.\nتعيد مصفوفة تحتوي على القيمة القصوى ومؤشرها في الشكل [max_value, index].\n\nمثال:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "sw": "Inapata thamani ya juu zaidi katika safu na kurudisha thamani yake pamoja na faharasa yake. \nKazi inachukua hoja moja, arr, ambayo ni safu ya nambari za mzima. Ukubwa wa safu unapaswa kuwa kati ya 1 na 100. \nInarudisha safu inayojumuisha thamani ya juu zaidi na faharasa yake katika muundo [max_value, index].\n\nMfano:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "tr": "Bir dizideki maksimum değeri bulur ve bu değeri dizinle birlikte döndürür.\nFonksiyon, bir tamsayı dizisi olan tek bir argüman, arr, alır. Dizi boyutu 1 ile 100 arasında olmalıdır.\n[max_value, index] formatında maksimum değeri ve dizinini içeren bir dizi döndürür.\n\nÖrnek:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "vi": "Tìm giá trị lớn nhất trong một mảng và trả về giá trị của nó cùng với chỉ số của nó. Hàm nhận một đối số duy nhất, arr, là một mảng các số nguyên. Kích thước mảng nên nằm trong khoảng từ 1 đến 100. Nó trả về một mảng chứa giá trị lớn nhất và chỉ số của nó theo định dạng [max_value, index].\n\nVí dụ:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]"
    },
    "docstring_bertscore": {
      "es": "0.9822565466925345",
      "arb": "0.9745135371790324",
      "sw": "0.9717799858752303",
      "tr": "0.9911452562438458",
      "vi": "0.9754222711722671"
    }
  },
  {
    "task_id": "Ruby/8",
    "prompt": {
      "en": "# Calculates the minimum time required for a character to reach the top of a building with varying floor heights.\n# The character can move up one or two floors at a time, but cannot use the two-floor jump consecutively. \n# Moving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n#\n# Args:\n# - floor_heights (Array): An array of integers representing the height of each floor.\n#\n# Returns:\n# - Integer: The minimum time required to reach the top of the building.\n#\n# Example:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "es": "# Calcula el tiempo mínimo requerido para que un personaje llegue a la cima de un edificio con alturas de piso variables.\n# El personaje puede subir uno o dos pisos a la vez, pero no puede usar el salto de dos pisos consecutivamente.\n# Subir un piso toma una unidad de tiempo, mientras que saltar dos pisos es instantáneo.\n#\n# Argumentos:\n# - floor_heights (Array): Un arreglo de enteros que representa la altura de cada piso.\n#\n# Retorna:\n# - Entero: El tiempo mínimo requerido para llegar a la cima del edificio.\n#\n# Ejemplo:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "arb": "# يحسب الحد الأدنى من الوقت المطلوب لشخصية للوصول إلى قمة مبنى بارتفاعات طوابق متغيرة.\n# يمكن للشخصية التحرك لأعلى طابق واحد أو طابقين في المرة الواحدة، ولكن لا يمكنها استخدام القفزة ذات الطابقين بشكل متتالي.\n# التحرك لأعلى طابق واحد يستغرق وحدة واحدة من الوقت، بينما القفز لأعلى طابقين يكون فورياً.\n#\n# الوسائط:\n# - floor_heights (مصفوفة): مصفوفة من الأعداد الصحيحة تمثل ارتفاع كل طابق.\n#\n# يعيد:\n# - عدد صحيح: الحد الأدنى من الوقت المطلوب للوصول إلى قمة المبنى.\n#\n# مثال:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "sw": "# Inahesabu muda wa chini kabisa unaohitajika kwa mhusika kufika juu ya jengo lenye urefu tofauti wa sakafu.\n# Mhusika anaweza kupanda sakafu moja au mbili kwa wakati mmoja, lakini hawezi kutumia kuruka sakafu mbili mfululizo.\n# Kupanda sakafu moja kunachukua muda wa kitengo kimoja, wakati kuruka sakafu mbili ni papo hapo.\n#\n# Vipengele:\n# - floor_heights (Array): Mfululizo wa namba za mzima zinazoashiria urefu wa kila sakafu.\n#\n# Inarejesha:\n# - Namba: Muda wa chini kabisa unaohitajika kufika juu ya jengo.\n#\n# Mfano:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "tr": "# Bir karakterin farklı kat yüksekliklerine sahip bir binanın tepesine ulaşması için gereken minimum zamanı hesaplar.\n# Karakter bir seferde bir veya iki kat yukarı çıkabilir, ancak iki kat zıplamayı ardışık olarak kullanamaz.\n# Bir kat yukarı çıkmak bir zaman birimi alırken, iki kat yukarı zıplamak anlıktır.\n#\n# Argümanlar:\n# - floor_heights (Dizi): Her katın yüksekliğini temsil eden bir tamsayı dizisi.\n#\n# Döndürür:\n# - Tamsayı: Binanın tepesine ulaşmak için gereken minimum zaman.\n#\n# Örnek:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "vi": "# Tính toán thời gian tối thiểu cần thiết để một nhân vật đạt đến đỉnh của một tòa nhà với các tầng có độ cao khác nhau.\n# Nhân vật có thể di chuyển lên một hoặc hai tầng mỗi lần, nhưng không thể sử dụng bước nhảy hai tầng liên tiếp.\n# Di chuyển lên một tầng mất một đơn vị thời gian, trong khi nhảy lên hai tầng là tức thời.\n#\n# Tham số:\n# - floor_heights (Mảng): Một mảng các số nguyên đại diện cho độ cao của mỗi tầng.\n#\n# Trả về:\n# - Số nguyên: Thời gian tối thiểu cần thiết để đạt đến đỉnh của tòa nhà.\n#\n# Ví dụ:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)"
    },
    "prompt_bertscore": {
      "es": "0.9735170085573804",
      "arb": "0.9865747711762329",
      "sw": "0.9514040841279094",
      "tr": "0.9761496556276168",
      "vi": "0.9813513880461585"
    },
    "canonical_solution": "    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end",
    "instruction": {
      "en": "Write a ruby function `def minimum_time_to_top(heights)` to solve the following problem:\nCalculates the minimum time required for a character to reach the top of a building with varying floor heights.\nThe character can move up one or two floors at a time, but cannot use the two-floor jump consecutively.\nMoving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n\nArgs:\n- floor_heights (Array): An array of integers representing the height of each floor.\n\nReturns:\n- Integer: The minimum time required to reach the top of the building.\n\nExample:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "es": "Escribe una función en Ruby `def minimum_time_to_top(heights)` para resolver el siguiente problema:\nCalcula el tiempo mínimo requerido para que un personaje llegue a la cima de un edificio con alturas de piso variables. \nEl personaje puede subir uno o dos pisos a la vez, pero no puede usar el salto de dos pisos consecutivamente. \nSubir un piso toma una unidad de tiempo, mientras que saltar dos pisos es instantáneo.\n\nArgumentos:\n- floor_heights (Array): Un arreglo de enteros que representa la altura de cada piso.\n\nDevuelve:\n- Integer: El tiempo mínimo requerido para llegar a la cima del edificio.\n\nEjemplo:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "arb": "اكتب دالة روبي `def minimum_time_to_top(heights)` لحل المشكلة التالية:\nتحسب الحد الأدنى من الوقت اللازم لشخصية للوصول إلى قمة مبنى بارتفاعات طوابق متغيرة.\nيمكن للشخصية التحرك لأعلى طابق واحد أو طابقين في كل مرة، ولكن لا يمكنها استخدام القفز بطابقين بشكل متتالي.\nالتحرك لأعلى طابق واحد يستغرق وحدة زمنية واحدة، بينما القفز لأعلى طابقين يكون فورياً.\n\nالمعاملات:\n- floor_heights (Array): مصفوفة من الأعداد الصحيحة تمثل ارتفاع كل طابق.\n\nالإرجاع:\n- Integer: الحد الأدنى من الوقت المطلوب للوصول إلى قمة المبنى.\n\nمثال:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "sw": "Andika kazi ya ruby `def minimum_time_to_top(heights)` kutatua tatizo lifuatalo:\nInakokotoa muda wa chini unaohitajika kwa mhusika kufika juu ya jengo lenye urefu tofauti wa sakafu.\nMhusika anaweza kupanda sakafu moja au mbili kwa wakati mmoja, lakini hawezi kutumia kuruka sakafu mbili mfululizo.\nKupanda sakafu moja kunachukua kitengo kimoja cha muda, wakati kuruka sakafu mbili ni papo hapo.\n\nHoja:\n- floor_heights (Array): Orodha ya namba nzima inayoonyesha urefu wa kila sakafu.\n\nInarudisha:\n- Integer: Muda wa chini unaohitajika kufika juu ya jengo.\n\nMfano:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "tr": "Bir ruby fonksiyonu `def minimum_time_to_top(heights)` yazın ve aşağıdaki problemi çözün:\nBir karakterin farklı kat yüksekliklerine sahip bir binanın tepesine ulaşması için gereken minimum zamanı hesaplar.\nKarakter bir seferde bir veya iki kat yukarı çıkabilir, ancak iki kat atlamayı ardışık olarak kullanamaz.\nBir kat yukarı çıkmak bir zaman birimi alırken, iki kat yukarı atlamak anlıktır.\n\nArgümanlar:\n- floor_heights (Array): Her katın yüksekliğini temsil eden bir tamsayı dizisi.\n\nArgümanlar:\n- Integer: Binanın tepesine ulaşmak için gereken minimum zaman.\n\nÖrnek:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "vi": "Viết một hàm ruby `def minimum_time_to_top(heights)` để giải quyết vấn đề sau:\nTính toán thời gian tối thiểu cần thiết để một nhân vật đạt đến đỉnh của một tòa nhà với các tầng có độ cao khác nhau.\nNhân vật có thể di chuyển lên một hoặc hai tầng mỗi lần, nhưng không thể sử dụng bước nhảy hai tầng liên tiếp.\nDi chuyển lên một tầng mất một đơn vị thời gian, trong khi nhảy lên hai tầng là tức thời.\n\nTham số:\n- floor_heights (Array): Một mảng các số nguyên đại diện cho độ cao của mỗi tầng.\n\nTrả về:\n- Integer: Thời gian tối thiểu cần thiết để đạt đến đỉnh của tòa nhà.\n\nVí dụ:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1"
    },
    "instruction_bertscore": {
      "es": "0.977112814345255",
      "arb": "0.9799057561329866",
      "sw": "0.9600468892674995",
      "tr": "0.9858597018045073",
      "vi": "0.9789350494608691"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless minimum_time_to_top([3, 5, 1, 8, 4]) == 1\nraise 'Test failed' unless minimum_time_to_top([2, 2, 2, 2, 2]) == 2\nraise 'Test failed' unless minimum_time_to_top([1, 1, 1, 1, 1]) == 1\nraise 'Test failed' unless minimum_time_to_top([10]) == 0\n\n\n\nputs 'All tests passed!'",
    "entry_point": "minimum_time_to_top",
    "signature": "def minimum_time_to_top(heights)",
    "docstring": {
      "en": "Calculates the minimum time required for a character to reach the top of a building with varying floor heights.\nThe character can move up one or two floors at a time, but cannot use the two-floor jump consecutively.\nMoving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n\nArgs:\n- floor_heights (Array): An array of integers representing the height of each floor.\n\nReturns:\n- Integer: The minimum time required to reach the top of the building.\n\nExample:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "es": "Calcula el tiempo mínimo requerido para que un personaje alcance la cima de un edificio con alturas de pisos variables. El personaje puede subir uno o dos pisos a la vez, pero no puede usar el salto de dos pisos consecutivamente. Subir un piso toma una unidad de tiempo, mientras que saltar dos pisos es instantáneo.\n\nArgumentos:\n- floor_heights (Array): Un arreglo de enteros que representa la altura de cada piso.\n\nDevuelve:\n- Integer: El tiempo mínimo requerido para alcanzar la cima del edificio.\n\nEjemplo:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "arb": "يحسب الحد الأدنى من الوقت المطلوب لشخصية للوصول إلى قمة مبنى بارتفاعات طوابق متغيرة.\nيمكن للشخصية التحرك لأعلى طابق واحد أو طابقين في كل مرة، ولكن لا يمكنها استخدام القفزة ذات الطابقين بشكل متتالي.\nالتحرك لأعلى طابق واحد يستغرق وحدة واحدة من الوقت، بينما القفز لأعلى طابقين يكون فورياً.\n\nالمعطيات:\n- floor_heights (Array): مصفوفة من الأعداد الصحيحة تمثل ارتفاع كل طابق.\n\nالقيم المعادة:\n- Integer: الحد الأدنى من الوقت المطلوب للوصول إلى قمة المبنى.\n\nمثال:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "sw": "Hesabu muda wa chini kabisa unaohitajika kwa mhusika kufika juu ya jengo lenye urefu tofauti wa sakafu. Mhusika anaweza kupanda sakafu moja au mbili kwa wakati mmoja, lakini hawezi kutumia kuruka sakafu mbili mfululizo. Kupanda sakafu moja kunachukua kitengo kimoja cha muda, wakati kuruka sakafu mbili ni papo hapo.\n\nHoja:\n- floor_heights (Array): Mfululizo wa namba za mzima zinazoonyesha urefu wa kila sakafu.\n\nInarejesha:\n- Integer: Muda wa chini kabisa unaohitajika kufika juu ya jengo.\n\nMfano:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "tr": "Bina katlarının değişen yükseklikleriyle bir karakterin tepeye ulaşması için gereken minimum zamanı hesaplar.\nKarakter bir seferde bir veya iki kat yukarı çıkabilir, ancak iki kat sıçramayı ardışık olarak kullanamaz.\nBir kat yukarı çıkmak bir zaman birimi alırken, iki kat yukarı sıçramak anlıktır.\n\nArgümanlar:\n- floor_heights (Dizi): Her katın yüksekliğini temsil eden tamsayıların dizisi.\n\nDöndürür:\n- Tamsayı: Binanın tepesine ulaşmak için gereken minimum zaman.\n\nÖrnek:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "vi": "Tính toán thời gian tối thiểu cần thiết để một nhân vật đạt đến đỉnh của một tòa nhà với độ cao các tầng khác nhau. Nhân vật có thể di chuyển lên một hoặc hai tầng mỗi lần, nhưng không thể sử dụng bước nhảy hai tầng liên tiếp. Di chuyển lên một tầng mất một đơn vị thời gian, trong khi nhảy lên hai tầng là ngay lập tức.\n\nTham số:\n- floor_heights (Array): Một mảng các số nguyên đại diện cho độ cao của mỗi tầng.\n\nTrả về:\n- Integer: Thời gian tối thiểu cần thiết để đạt đến đỉnh của tòa nhà.\n\nVí dụ:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1"
    },
    "docstring_bertscore": {
      "es": "0.9817649364994732",
      "arb": "0.9771551226164155",
      "sw": "0.955996219907055",
      "tr": "0.9848566183802812",
      "vi": "0.9862396817234271"
    }
  },
  {
    "task_id": "Ruby/9",
    "prompt": {
      "en": "# Transposes a given n x m matrix.\n# The function takes a single argument, matrix, which is an array of arrays representing the n x m matrix.\n# The matrix has n rows and m columns, where 1 ≤ n ≤ 20 and 1 ≤ m ≤ 20. Each element in the matrix is an integer.\n# The function returns a new matrix which is the transpose of the input matrix.\n#\n# Example:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "es": "# Transpone una matriz n x m dada.\n# La función toma un solo argumento, matrix, que es un array de arrays que representa la matriz n x m.\n# La matriz tiene n filas y m columnas, donde 1 ≤ n ≤ 20 y 1 ≤ m ≤ 20. Cada elemento en la matriz es un entero.\n# La función devuelve una nueva matriz que es la transpuesta de la matriz de entrada.\n#\n# Ejemplo:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "arb": "```python\n# يقوم بعملية نقل لمصفوفة معطاة بحجم n x m.\n# تأخذ الدالة وسيطًا واحدًا، matrix، وهو عبارة عن مصفوفة من المصفوفات تمثل المصفوفة بحجم n x m.\n# تحتوي المصفوفة على n صفوف وm أعمدة، حيث 1 ≤ n ≤ 20 و1 ≤ m ≤ 20. كل عنصر في المصفوفة هو عدد صحيح.\n# تعيد الدالة مصفوفة جديدة وهي عبارة عن النقل للمصفوفة المدخلة.\n#\n# مثال:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)\n```",
      "sw": "# Inabadilisha nafasi ya matini ya n x m iliyotolewa.\n# Kazi inachukua hoja moja, matrix, ambayo ni safu ya safu zinazowakilisha matini ya n x m.\n# Matini ina safu n na safu m, ambapo 1 ≤ n ≤ 20 na 1 ≤ m ≤ 20. Kila kipengele katika matini ni nambari kamili.\n# Kazi inarudisha matini mpya ambayo ni nafasi ya matini ya pembejeo.\n#\n# Mfano:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "tr": "# Verilen n x m matrisini transpoze eder.\n# Fonksiyon, n x m matrisini temsil eden dizilerin bir dizisi olan matrix adlı tek bir argüman alır.\n# Matris n satır ve m sütuna sahiptir, burada 1 ≤ n ≤ 20 ve 1 ≤ m ≤ 20. Matrisin her bir elemanı bir tam sayıdır.\n# Fonksiyon, giriş matrisinin transpozu olan yeni bir matris döndürür.\n#\n# Örnek:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "vi": "# Chuyển vị một ma trận n x m cho trước.\n# Hàm nhận một đối số duy nhất, matrix, là một mảng các mảng đại diện cho ma trận n x m.\n# Ma trận có n hàng và m cột, với 1 ≤ n ≤ 20 và 1 ≤ m ≤ 20. Mỗi phần tử trong ma trận là một số nguyên.\n# Hàm trả về một ma trận mới là ma trận chuyển vị của ma trận đầu vào.\n#\n# Ví dụ:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)"
    },
    "prompt_bertscore": {
      "es": "0.9976615245240763",
      "arb": "0.9493979172794571",
      "sw": "0.9918027228050712",
      "tr": "0.9916124349000398",
      "vi": "0.995497049261939"
    },
    "canonical_solution": "    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end",
    "instruction": {
      "en": "Write a ruby function `def transpose_matrix(matrix)` to solve the following problem:\nTransposes a given n x m matrix.\nThe function takes a single argument, matrix, which is an array of arrays representing the n x m matrix.\nThe matrix has n rows and m columns, where 1 ≤ n ≤ 20 and 1 ≤ m ≤ 20. Each element in the matrix is an integer.\nThe function returns a new matrix which is the transpose of the input matrix.\n\nExample:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "es": "Escribe una función en ruby `def transpose_matrix(matrix)` para resolver el siguiente problema:\nTranspone una matriz dada de n x m.\nLa función toma un solo argumento, matrix, que es un array de arrays que representa la matriz de n x m.\nLa matriz tiene n filas y m columnas, donde 1 ≤ n ≤ 20 y 1 ≤ m ≤ 20. Cada elemento en la matriz es un entero.\nLa función devuelve una nueva matriz que es la transpuesta de la matriz de entrada.\n\nEjemplo:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "arb": "اكتب دالة روبي `def transpose_matrix(matrix)` لحل المشكلة التالية:\nتحويل مصفوفة n x m المعطاة.\nتأخذ الدالة وسيطًا واحدًا، matrix، وهو عبارة عن مصفوفة من المصفوفات تمثل المصفوفة n x m.\nتحتوي المصفوفة على n صفوف وm أعمدة، حيث 1 ≤ n ≤ 20 و1 ≤ m ≤ 20. كل عنصر في المصفوفة هو عدد صحيح.\nتعيد الدالة مصفوفة جديدة وهي التحويل للمصفوفة المدخلة.\n\nمثال:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "sw": "Andika kazi ya ruby `def transpose_matrix(matrix)` kutatua tatizo lifuatalo:  \nKubadilisha nafasi ya matriki ya n x m iliyotolewa.  \nKazi inachukua hoja moja, matrix, ambayo ni safu ya safu zinazowakilisha matriki ya n x m.  \nMatriki ina safu n na safu m, ambapo 1 ≤ n ≤ 20 na 1 ≤ m ≤ 20. Kila kipengele katika matriki ni nambari kamili.  \nKazi inarudisha matriki mpya ambayo ni badiliko la matriki ya ingizo.  \n\nMfano:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "tr": "Bir ruby fonksiyonu `def transpose_matrix(matrix)` yazın:\nVerilen bir n x m matrisini transpoze eder.\nFonksiyon, n x m matrisini temsil eden dizi dizisi olan tek bir argüman, matrix, alır.\nMatris n satır ve m sütuna sahiptir, burada 1 ≤ n ≤ 20 ve 1 ≤ m ≤ 20. Matrisin her bir elemanı bir tam sayıdır.\nFonksiyon, giriş matrisinin transpoze edilmiş hali olan yeni bir matris döndürür.\n\nÖrnek:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "vi": "Viết một hàm ruby `def transpose_matrix(matrix)` để giải quyết vấn đề sau:\nChuyển vị một ma trận n x m cho trước.\nHàm nhận một đối số duy nhất, matrix, là một mảng các mảng đại diện cho ma trận n x m.\nMa trận có n hàng và m cột, với 1 ≤ n ≤ 20 và 1 ≤ m ≤ 20. Mỗi phần tử trong ma trận là một số nguyên.\nHàm trả về một ma trận mới là chuyển vị của ma trận đầu vào.\n\nVí dụ:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]"
    },
    "instruction_bertscore": {
      "es": "0.9928898268804751",
      "arb": "0.9894435897695198",
      "sw": "0.9901064193510333",
      "tr": "0.9595832859581641",
      "vi": "0.995131966621597"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]]) == [[34, -4], [76, 5], [-54, 23], [7, 9]]\nraise 'Test failed' unless transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]]\nraise 'Test failed' unless transpose_matrix([[10]]) == [[10]]\nraise 'Test failed' unless transpose_matrix([]) == []\nraise 'Test failed' unless transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]]\n\n\nputs 'All tests passed!'",
    "entry_point": "transpose_matrix",
    "signature": "def transpose_matrix(matrix)",
    "docstring": {
      "en": "Transposes a given n x m matrix.\nThe function takes a single argument, matrix, which is an array of arrays representing the n x m matrix.\nThe matrix has n rows and m columns, where 1 ≤ n ≤ 20 and 1 ≤ m ≤ 20. Each element in the matrix is an integer.\nThe function returns a new matrix which is the transpose of the input matrix.\n\nExample:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "es": "Transpone una matriz dada de n x m.  \nLa función toma un solo argumento, matrix, que es un array de arrays que representa la matriz n x m.  \nLa matriz tiene n filas y m columnas, donde 1 ≤ n ≤ 20 y 1 ≤ m ≤ 20. Cada elemento en la matriz es un entero.  \nLa función devuelve una nueva matriz que es la transpuesta de la matriz de entrada.\n\nEjemplo:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "arb": "يقوم بتحويل مصفوفة n x m معطاة.\nتأخذ الدالة وسيطًا واحدًا، وهو matrix، الذي يمثل مصفوفة n x m كمصفوفة من المصفوفات.\nتحتوي المصفوفة على n صفوف وm أعمدة، حيث 1 ≤ n ≤ 20 و1 ≤ m ≤ 20. كل عنصر في المصفوفة هو عدد صحيح.\nتُرجع الدالة مصفوفة جديدة وهي تحويل للمصفوفة المدخلة.\n\nمثال:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "sw": "Inabadilisha nafasi ya jedwali lililopewa la n x m.  \nKazi hii inachukua hoja moja, matrix, ambayo ni safu ya safu zinazowakilisha jedwali la n x m.  \nJedwali lina safu n na safu m, ambapo 1 ≤ n ≤ 20 na 1 ≤ m ≤ 20. Kila kipengele katika jedwali ni nambari kamili.  \nKazi hii inarudisha jedwali jipya ambalo ni mabadiliko ya nafasi ya jedwali la ingizo.  \n\nMfano:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "tr": "Verilen n x m matrisini transpoze eder.  \nFonksiyon, n x m matrisini temsil eden dizi dizisi olan tek bir argüman, matrix, alır.  \nMatrisin n satırı ve m sütunu vardır, burada 1 ≤ n ≤ 20 ve 1 ≤ m ≤ 20. Matristeki her bir eleman bir tam sayıdır.  \nFonksiyon, giriş matrisinin transpozu olan yeni bir matris döndürür.  \n\nÖrnek:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "vi": "Chuyển vị một ma trận n x m cho trước.  \nHàm nhận một đối số duy nhất, matrix, là một mảng các mảng đại diện cho ma trận n x m.  \nMa trận có n hàng và m cột, với 1 ≤ n ≤ 20 và 1 ≤ m ≤ 20. Mỗi phần tử trong ma trận là một số nguyên.  \nHàm trả về một ma trận mới là chuyển vị của ma trận đầu vào.  \n\nVí dụ:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]"
    },
    "docstring_bertscore": {
      "es": "0.9967285576243554",
      "arb": "0.9739152624713554",
      "sw": "0.9412548661785508",
      "tr": "0.9771169855832568",
      "vi": "0.9940772392983017"
    }
  },
  {
    "task_id": "Ruby/10",
    "prompt": {
      "en": "# Sorts a list of students by their scores in descending order. If two students have the same score,\n# they are sorted alphabetically by their names. The function takes an array of arrays as an argument,\n# where each sub-array contains a student's name and their score. The function returns an array of \n# student names sorted as per the mentioned criteria.\n#\n# Example:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "es": "# Ordena una lista de estudiantes por sus puntajes en orden descendente. Si dos estudiantes tienen el mismo puntaje,\n# se ordenan alfabéticamente por sus nombres. La función toma un arreglo de arreglos como argumento,\n# donde cada sub-arreglo contiene el nombre de un estudiante y su puntaje. La función devuelve un arreglo de\n# nombres de estudiantes ordenados según los criterios mencionados.\n#\n# Ejemplo:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "arb": "# يقوم بترتيب قائمة الطلاب حسب درجاتهم بترتيب تنازلي. إذا كان لدى طالبين نفس الدرجة،\n# يتم ترتيبهم أبجدياً حسب أسمائهم. تأخذ الدالة مصفوفة من المصفوفات كمعامل،\n# حيث تحتوي كل مصفوفة فرعية على اسم الطالب ودرجته. تُرجع الدالة مصفوفة من\n# أسماء الطلاب مرتبة وفقاً للمعايير المذكورة.\n#\n# مثال:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "sw": "# Hupanga orodha ya wanafunzi kwa alama zao kwa mpangilio wa kushuka. Ikiwa wanafunzi wawili wana alama sawa,\n# wanapangwa kwa mpangilio wa alfabeti kwa majina yao. Kazi inachukua safu ya safu kama hoja,\n# ambapo kila safu-ndogo ina jina la mwanafunzi na alama zao. Kazi inarejesha safu ya\n# majina ya wanafunzi yaliyopangwa kulingana na vigezo vilivyotajwa.\n#\n# Mfano:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "tr": "# Öğrencileri puanlarına göre azalan sırayla sıralar. Eğer iki öğrenci aynı puana sahipse,\n# isimlerine göre alfabetik olarak sıralanırlar. Fonksiyon, bir dizi diziyi argüman olarak alır,\n# burada her alt dizi bir öğrencinin ismini ve puanını içerir. Fonksiyon, belirtilen kriterlere göre\n# sıralanmış öğrenci isimlerinin bir dizisini döndürür.\n#\n# Örnek:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "vi": "# Sắp xếp danh sách sinh viên theo điểm số của họ theo thứ tự giảm dần. Nếu hai sinh viên có cùng điểm số,\n# họ sẽ được sắp xếp theo thứ tự bảng chữ cái theo tên của họ. Hàm nhận một mảng các mảng làm đối số,\n# trong đó mỗi mảng con chứa tên sinh viên và điểm số của họ. Hàm trả về một mảng các\n# tên sinh viên được sắp xếp theo tiêu chí đã đề cập.\n#\n# Ví dụ:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)"
    },
    "prompt_bertscore": {
      "es": "0.9943026847807763",
      "arb": "0.9943092395833505",
      "sw": "0.9897898025236637",
      "tr": "0.9750979077600371",
      "vi": "0.992570031967009"
    },
    "canonical_solution": "    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end",
    "instruction": {
      "en": "Write a ruby function `def sort_students_by_score(student_scores)` to solve the following problem:\nSorts a list of students by their scores in descending order. If two students have the same score,\nthey are sorted alphabetically by their names. The function takes an array of arrays as an argument,\nwhere each sub-array contains a student's name and their score. The function returns an array of\nstudent names sorted as per the mentioned criteria.\n\nExample:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "es": "Escribe una función en Ruby `def sort_students_by_score(student_scores)` para resolver el siguiente problema:\nOrdena una lista de estudiantes por sus puntuaciones en orden descendente. Si dos estudiantes tienen la misma puntuación, se ordenan alfabéticamente por sus nombres. La función toma un array de arrays como argumento, donde cada sub-array contiene el nombre de un estudiante y su puntuación. La función devuelve un array de nombres de estudiantes ordenados según los criterios mencionados.\n\nEjemplo:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "arb": "اكتب دالة روبي `def sort_students_by_score(student_scores)` لحل المشكلة التالية:\nترتيب قائمة الطلاب حسب درجاتهم بترتيب تنازلي. إذا كان لدى طالبين نفس الدرجة، يتم ترتيبهم أبجدياً حسب أسمائهم. تأخذ الدالة مصفوفة من المصفوفات كمعامل، حيث تحتوي كل مصفوفة فرعية على اسم الطالب ودرجته. تعيد الدالة مصفوفة من أسماء الطلاب مرتبة حسب المعايير المذكورة.\n\nمثال:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "sw": "Andika kazi ya ruby `def sort_students_by_score(student_scores)` kutatua tatizo lifuatalo:\nPanga orodha ya wanafunzi kwa alama zao kwa mpangilio wa kushuka. Ikiwa wanafunzi wawili wana alama sawa, wanapangwa kwa alfabeti kwa majina yao. Kazi inachukua safu ya safu kama hoja, ambapo kila safu ndogo ina jina la mwanafunzi na alama zao. Kazi inarejesha safu ya majina ya wanafunzi yaliyopangwa kulingana na vigezo vilivyotajwa.\n\nMfano:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "tr": "Bir ruby fonksiyonu `def sort_students_by_score(student_scores)` yazın: \nÖğrencileri puanlarına göre azalan sırayla sıralar. Eğer iki öğrenci aynı puana sahipse, isimlerine göre alfabetik olarak sıralanırlar. Fonksiyon, her alt dizinin bir öğrencinin adını ve puanını içerdiği bir dizi dizisini argüman olarak alır. Fonksiyon, belirtilen kriterlere göre sıralanmış öğrenci isimlerinin bir dizisini döndürür.\n\nÖrnek:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "vi": "Viết một hàm ruby `def sort_students_by_score(student_scores)` để giải quyết vấn đề sau:\nSắp xếp danh sách học sinh theo điểm số của họ theo thứ tự giảm dần. Nếu hai học sinh có cùng điểm số, họ sẽ được sắp xếp theo thứ tự bảng chữ cái theo tên của họ. Hàm nhận một mảng các mảng làm đối số, trong đó mỗi mảng con chứa tên của một học sinh và điểm số của họ. Hàm trả về một mảng tên học sinh được sắp xếp theo tiêu chí đã đề cập.\n\nVí dụ:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]"
    },
    "instruction_bertscore": {
      "es": "0.9931045463223739",
      "arb": "0.988470698163211",
      "sw": "0.9888105547451617",
      "tr": "0.9721178561533707",
      "vi": "0.9934559234664245"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]]) == [\"bbb\", \"ccc\", \"aaa\"]\nraise 'Test failed' unless sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]]) == [\"charlie\", \"alice\", \"bob\"]\nraise 'Test failed' unless sort_students_by_score([[\"zoe\", 95], [\"adam\", 95], [\"mia\", 88]]) == [\"adam\", \"zoe\", \"mia\"]\nraise 'Test failed' unless sort_students_by_score([[\"lara\", 70], [\"max\", 70], [\"sam\", 70]]) == [\"lara\", \"max\", \"sam\"]\nraise 'Test failed' unless sort_students_by_score([[\"john\", 100]]) == [\"john\"]\n\n\nputs 'All tests passed!'",
    "entry_point": "sort_students_by_score",
    "signature": "def sort_students_by_score(student_scores)",
    "docstring": {
      "en": "Sorts a list of students by their scores in descending order. If two students have the same score,\nthey are sorted alphabetically by their names. The function takes an array of arrays as an argument,\nwhere each sub-array contains a student's name and their score. The function returns an array of\nstudent names sorted as per the mentioned criteria.\n\nExample:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "es": "Ordena una lista de estudiantes por sus puntuaciones en orden descendente. Si dos estudiantes tienen la misma puntuación, se ordenan alfabéticamente por sus nombres. La función toma un arreglo de arreglos como argumento, donde cada sub-arreglo contiene el nombre de un estudiante y su puntuación. La función devuelve un arreglo de nombres de estudiantes ordenados según los criterios mencionados.\n\nEjemplo:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "arb": "يقوم بفرز قائمة الطلاب حسب درجاتهم بترتيب تنازلي. إذا كان لدى طالبين نفس الدرجة، يتم فرزهم أبجدياً حسب أسمائهم. تأخذ الدالة مصفوفة من المصفوفات كمعامل، حيث يحتوي كل صف فرعي على اسم الطالب ودرجته. تُرجع الدالة مصفوفة من أسماء الطلاب مرتبة وفقاً للمعايير المذكورة.\n\nمثال:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "sw": "Hupanga orodha ya wanafunzi kwa alama zao kwa mpangilio wa kushuka. Ikiwa wanafunzi wawili wana alama sawa, wanapangwa kwa mpangilio wa alfabeti kwa majina yao. Kazi inachukua safu ya safu kama hoja, ambapo kila safu-ndogo ina jina la mwanafunzi na alama zao. Kazi inarejesha safu ya majina ya wanafunzi yaliyopangwa kulingana na vigezo vilivyotajwa.\n\nMfano:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "tr": "Öğrencilerin bir listesini puanlarına göre azalan sırayla sıralar. Eğer iki öğrenci aynı puana sahipse, isimlerine göre alfabetik olarak sıralanırlar. Fonksiyon, bir öğrencinin ismi ve puanını içeren her alt dizinin bulunduğu bir dizi alır. Fonksiyon, belirtilen kriterlere göre sıralanmış öğrenci isimlerinin bir dizisini döndürür.\n\nÖrnek:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "vi": "Sắp xếp danh sách sinh viên theo điểm số của họ theo thứ tự giảm dần. Nếu hai sinh viên có cùng điểm số, họ sẽ được sắp xếp theo thứ tự bảng chữ cái theo tên của họ. Hàm nhận một mảng các mảng làm đối số, trong đó mỗi mảng con chứa tên sinh viên và điểm số của họ. Hàm trả về một mảng tên sinh viên được sắp xếp theo tiêu chí đã đề cập.\n\nVí dụ:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]"
    },
    "docstring_bertscore": {
      "es": "0.9905231458904444",
      "arb": "0.9935856291052404",
      "sw": "0.9857297975353105",
      "tr": "0.9702888676048014",
      "vi": "0.9881095881304895"
    }
  },
  {
    "task_id": "Ruby/11",
    "prompt": {
      "en": "# Calculates the total number of drinks a customer can enjoy under a promotional offer.\n# Under this offer, for every 3 bottle caps, the customer can get 1 additional drink.\n# The promotion continues as long as the customer has enough caps for exchange.\n#\n# The function takes a single integer argument, n, which represents the initial number\n# of drinks purchased. It returns an integer representing the total number of drinks\n# the customer can enjoy, including those received through the promotion.\n#\n# Examples:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "es": "# Calcula el número total de bebidas que un cliente puede disfrutar bajo una oferta promocional.\n# Bajo esta oferta, por cada 3 tapas de botella, el cliente puede obtener 1 bebida adicional.\n# La promoción continúa mientras el cliente tenga suficientes tapas para el intercambio.\n#\n# La función toma un solo argumento entero, n, que representa el número inicial\n# de bebidas compradas. Devuelve un entero que representa el número total de bebidas\n# que el cliente puede disfrutar, incluidas las recibidas a través de la promoción.\n#\n# Ejemplos:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "arb": "# يحسب العدد الإجمالي للمشروبات التي يمكن للعميل الاستمتاع بها تحت عرض ترويجي.\n# بموجب هذا العرض، مقابل كل 3 أغطية زجاجات، يمكن للعميل الحصول على مشروب إضافي واحد.\n# يستمر العرض طالما أن العميل لديه أغطية كافية للتبادل.\n#\n# تأخذ الدالة وسيطًا واحدًا من نوع عدد صحيح، n، والذي يمثل العدد الأولي\n# للمشروبات المشتراة. تُرجع عددًا صحيحًا يمثل العدد الإجمالي للمشروبات\n# التي يمكن للعميل الاستمتاع بها، بما في ذلك تلك التي تم الحصول عليها من خلال العرض الترويجي.\n#\n# أمثلة:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "sw": "# Inahesabu jumla ya vinywaji ambavyo mteja anaweza kufurahia chini ya ofa ya matangazo.\n# Chini ya ofa hii, kwa kila kofia 3 za chupa, mteja anaweza kupata kinywaji 1 cha ziada.\n# Ofa inaendelea mradi mteja ana kofia za kutosha kwa kubadilishana.\n#\n# Kazi inachukua hoja moja ya nambari nzima, n, ambayo inawakilisha idadi ya awali\n# ya vinywaji vilivyonunuliwa. Inarudisha nambari nzima inayoonyesha jumla ya vinywaji\n# ambavyo mteja anaweza kufurahia, ikiwa ni pamoja na vile vilivyopatikana kupitia ofa.\n#\n# Mifano:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "tr": "# Bir müşterinin promosyon teklifi kapsamında tadını çıkarabileceği toplam içecek sayısını hesaplar.\n# Bu teklif kapsamında, her 3 şişe kapağı için müşteri 1 ek içecek alabilir.\n# Müşterinin değişim için yeterli kapağı olduğu sürece promosyon devam eder.\n#\n# Fonksiyon, n adlı tek bir tamsayı argümanı alır ve bu, satın alınan başlangıç içecek sayısını temsil eder.\n# Müşterinin promosyon yoluyla aldığı içecekler de dahil olmak üzere tadını çıkarabileceği toplam içecek sayısını\n# temsil eden bir tamsayı döndürür.\n#\n# Örnekler:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "vi": "# Tính tổng số đồ uống mà một khách hàng có thể thưởng thức theo một chương trình khuyến mãi.\n# Theo chương trình này, cứ mỗi 3 nắp chai, khách hàng có thể nhận thêm 1 đồ uống.\n# Chương trình khuyến mãi tiếp tục miễn là khách hàng có đủ nắp chai để đổi.\n#\n# Hàm nhận một đối số nguyên, n, đại diện cho số lượng đồ uống ban đầu đã mua.\n# Nó trả về một số nguyên đại diện cho tổng số đồ uống mà khách hàng có thể thưởng thức, bao gồm cả những đồ uống nhận được thông qua chương trình khuyến mãi.\n#\n# Ví dụ:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)"
    },
    "prompt_bertscore": {
      "es": "0.9956009329512203",
      "arb": "0.9903251114005527",
      "sw": "0.9887303080712235",
      "tr": "0.9896477818012237",
      "vi": "0.9565410630422337"
    },
    "canonical_solution": "    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end",
    "instruction": {
      "en": "Write a ruby function `def total_drinks_with_promo(n)` to solve the following problem:\nCalculates the total number of drinks a customer can enjoy under a promotional offer.\nUnder this offer, for every 3 bottle caps, the customer can get 1 additional drink.\nThe promotion continues as long as the customer has enough caps for exchange.\n\nThe function takes a single integer argument, n, which represents the initial number\nof drinks purchased. It returns an integer representing the total number of drinks\nthe customer can enjoy, including those received through the promotion.\n\nExamples:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "es": "Escribe una función en Ruby `def total_drinks_with_promo(n)` para resolver el siguiente problema:\nCalcula el número total de bebidas que un cliente puede disfrutar bajo una oferta promocional.\nBajo esta oferta, por cada 3 tapas de botella, el cliente puede obtener 1 bebida adicional.\nLa promoción continúa mientras el cliente tenga suficientes tapas para el intercambio.\n\nLa función toma un solo argumento entero, n, que representa el número inicial\nde bebidas compradas. Devuelve un entero que representa el número total de bebidas\nque el cliente puede disfrutar, incluidas las recibidas a través de la promoción.\n\nEjemplos:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "arb": "اكتب دالة روبي `def total_drinks_with_promo(n)` لحل المشكلة التالية:\nتحسب العدد الإجمالي للمشروبات التي يمكن للعميل الاستمتاع بها تحت عرض ترويجي.\nتحت هذا العرض، لكل 3 أغطية زجاجات، يمكن للعميل الحصول على مشروب إضافي واحد.\nيستمر العرض طالما أن العميل لديه أغطية كافية للتبادل.\n\nتأخذ الدالة وسيطًا واحدًا وهو عدد صحيح، n، والذي يمثل العدد الأولي\nللمشروبات المشتراة. تُرجع عددًا صحيحًا يمثل العدد الإجمالي للمشروبات\nالتي يمكن للعميل الاستمتاع بها، بما في ذلك تلك التي تم الحصول عليها من خلال العرض.\n\nأمثلة:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "sw": "Andika kazi ya ruby `def total_drinks_with_promo(n)` kutatua tatizo lifuatalo:\nHesabu jumla ya vinywaji ambavyo mteja anaweza kufurahia chini ya ofa ya matangazo.\nChini ya ofa hii, kwa kila kofia 3 za chupa, mteja anaweza kupata kinywaji 1 cha ziada.\nMatangazo yanaendelea mradi mteja ana kofia za kutosha kwa kubadilishana.\n\nKazi inachukua hoja moja ya nambari nzima, n, ambayo inawakilisha idadi ya awali\nya vinywaji vilivyonunuliwa. Inarudisha nambari nzima inayowakilisha jumla ya vinywaji\nambavyo mteja anaweza kufurahia, ikiwa ni pamoja na vile vilivyopatikana kupitia matangazo.\n\nMifano:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "tr": "Bir ruby fonksiyonu `def total_drinks_with_promo(n)` yazın ve aşağıdaki problemi çözün:\nBir müşterinin bir promosyon teklifi kapsamında tadını çıkarabileceği toplam içecek sayısını hesaplar.\nBu teklif kapsamında, her 3 şişe kapağı için müşteri 1 ek içecek alabilir.\nMüşterinin değişim için yeterli kapağı olduğu sürece promosyon devam eder.\n\nFonksiyon, satın alınan başlangıç içecek sayısını temsil eden tek bir tamsayı argümanı n alır. Müşterinin, promosyonla alınanlar da dahil olmak üzere tadını çıkarabileceği toplam içecek sayısını temsil eden bir tamsayı döndürür.\n\nÖrnekler:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "vi": "Viết một hàm ruby `def total_drinks_with_promo(n)` để giải quyết vấn đề sau:\nTính tổng số đồ uống mà khách hàng có thể thưởng thức theo một chương trình khuyến mãi.\nTheo chương trình này, cứ mỗi 3 nắp chai, khách hàng có thể nhận thêm 1 đồ uống.\nKhuyến mãi tiếp tục miễn là khách hàng có đủ nắp chai để đổi.\n\nHàm nhận một tham số nguyên, n, đại diện cho số lượng đồ uống ban đầu được mua. Nó trả về một số nguyên đại diện cho tổng số đồ uống mà khách hàng có thể thưởng thức, bao gồm cả những đồ uống nhận được thông qua khuyến mãi.\n\nVí dụ:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4"
    },
    "instruction_bertscore": {
      "es": "0.9858599004348884",
      "arb": "0.9788383164653051",
      "sw": "0.986603175320721",
      "tr": "0.9880791976821912",
      "vi": "0.9609683356051203"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless total_drinks_with_promo(100) == 149\nraise 'Test failed' unless total_drinks_with_promo(3) == 4\nraise 'Test failed' unless total_drinks_with_promo(9) == 13\nraise 'Test failed' unless total_drinks_with_promo(10) == 14\nraise 'Test failed' unless total_drinks_with_promo(1) == 1\n  \nputs 'All tests passed!'",
    "entry_point": "total_drinks_with_promo",
    "signature": "def total_drinks_with_promo(n)",
    "docstring": {
      "en": "Calculates the total number of drinks a customer can enjoy under a promotional offer.\nUnder this offer, for every 3 bottle caps, the customer can get 1 additional drink.\nThe promotion continues as long as the customer has enough caps for exchange.\n\nThe function takes a single integer argument, n, which represents the initial number\nof drinks purchased. It returns an integer representing the total number of drinks\nthe customer can enjoy, including those received through the promotion.\n\nExamples:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "es": "Calcula el número total de bebidas que un cliente puede disfrutar bajo una oferta promocional.  \nBajo esta oferta, por cada 3 tapas de botella, el cliente puede obtener 1 bebida adicional.  \nLa promoción continúa mientras el cliente tenga suficientes tapas para el intercambio.\n\nLa función toma un único argumento entero, n, que representa el número inicial  \nde bebidas compradas. Devuelve un entero que representa el número total de bebidas  \nque el cliente puede disfrutar, incluidas las recibidas a través de la promoción.\n\nEjemplos:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "arb": "يحسب العدد الإجمالي للمشروبات التي يمكن للعميل الاستمتاع بها تحت عرض ترويجي.  \nتحت هذا العرض، لكل 3 أغطية زجاجات، يمكن للعميل الحصول على مشروب إضافي واحد.  \nيستمر العرض طالما أن العميل لديه أغطية كافية للتبادل.\n\nيعيدالحجج:  \n    n: عدد صحيح يمثل العدد الأولي للمشروبات المشتراة.\n\nيعيد:  \n    عدد صحيح يمثل العدد الإجمالي للمشروبات التي يمكن للعميل الاستمتاع بها، بما في ذلك تلك التي تم الحصول عليها من خلال العرض الترويجي.\n\nأمثلة:  \n>>> total_drinks_with_promo(100)  \n149  \n>>> total_drinks_with_promo(3)  \n4",
      "sw": "Hesabu jumla ya vinywaji ambavyo mteja anaweza kufurahia chini ya ofa ya matangazo. Chini ya ofa hii, kwa kila kofia 3 za chupa, mteja anaweza kupata kinywaji 1 cha ziada. Ofa inaendelea mradi mteja ana kofia za kutosha kwa kubadilishana.\n\nKazi inachukua hoja moja ya nambari nzima, n, ambayo inawakilisha idadi ya awali ya vinywaji vilivyonunuliwa. Inarejesha nambari nzima inayowakilisha jumla ya vinywaji ambavyo mteja anaweza kufurahia, ikiwa ni pamoja na vile vilivyopatikana kupitia ofa.\n\nMifano:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "tr": "İndirimli bir teklif kapsamında bir müşterinin toplam kaç içecek alabileceğini hesaplar.\nBu teklif kapsamında, her 3 şişe kapağı için müşteri 1 ek içecek alabilir.\nMüşterinin değişim için yeterli kapağı olduğu sürece promosyon devam eder.\n\nFonksiyon, başlangıçta satın alınan içecek sayısını temsil eden tek bir tamsayı argümanı n alır. Müşterinin, promosyon aracılığıyla alınanlar da dahil olmak üzere, keyfini çıkarabileceği toplam içecek sayısını temsil eden bir tamsayı döndürür.\n\nÖrnekler:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "vi": "Tính tổng số đồ uống mà khách hàng có thể thưởng thức theo một chương trình khuyến mãi. Theo chương trình này, cứ mỗi 3 nắp chai, khách hàng có thể nhận thêm 1 đồ uống. Chương trình khuyến mãi tiếp tục miễn là khách hàng có đủ nắp chai để đổi.\n\nHàm nhận một đối số nguyên, n, đại diện cho số lượng đồ uống ban đầu đã mua. Nó trả về một số nguyên đại diện cho tổng số đồ uống mà khách hàng có thể thưởng thức, bao gồm cả những đồ uống nhận được thông qua chương trình khuyến mãi.\n\nVí dụ:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4"
    },
    "docstring_bertscore": {
      "es": "0.9933456836049502",
      "arb": "0.9379045675416353",
      "sw": "0.9851851530305129",
      "tr": "0.9852834750691252",
      "vi": "0.9644312576680826"
    }
  },
  {
    "task_id": "Ruby/12",
    "prompt": {
      "en": "# Determines the maximum length of a string that can be accepted by a simplified regular expression.\n# The function takes a single argument, regex, which is a string representing a regular expression \n# composed only of 'x', '(', ')', and '|'. The function returns the length of the longest string \n# that can be accepted by this regular expression.\n#\n# Example:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "es": "# Determina la longitud máxima de una cadena que puede ser aceptada por una expresión regular simplificada.\n# La función toma un único argumento, regex, que es una cadena que representa una expresión regular\n# compuesta solo de 'x', '(', ')', y '|'. La función devuelve la longitud de la cadena más larga\n# que puede ser aceptada por esta expresión regular.\n#\n# Ejemplo:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "arb": "# يحدد الحد الأقصى لطول سلسلة يمكن قبولها بواسطة تعبير منتظم مبسط.\n# تأخذ الدالة وسيطًا واحدًا، regex، وهو سلسلة تمثل تعبيرًا منتظمًا \n# يتكون فقط من 'x'، '('، ')'، و '|'. تُرجع الدالة طول أطول سلسلة \n# يمكن قبولها بواسطة هذا التعبير المنتظم.\n#\n# مثال:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "sw": "# Huamua urefu wa juu wa kamba ambayo inaweza kukubaliwa na usemi wa kawaida uliorahisishwa.\n# Kazi inachukua hoja moja, regex, ambayo ni kamba inayowakilisha usemi wa kawaida \n# unaojumuisha tu 'x', '(', ')', na '|'. Kazi inarudisha urefu wa kamba ndefu zaidi \n# ambayo inaweza kukubaliwa na usemi huu wa kawaida.\n#\n# Mfano:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "tr": "# Basitleştirilmiş bir düzenli ifade tarafından kabul edilebilecek bir dizgenin maksimum uzunluğunu belirler.\n# Fonksiyon, yalnızca 'x', '(', ')', ve '|' karakterlerinden oluşan bir düzenli ifadeyi temsil eden \n# bir dize olan regex adlı tek bir argüman alır. Fonksiyon, bu düzenli ifade tarafından kabul edilebilecek \n# en uzun dizgenin uzunluğunu döndürür.\n#\n# Örnek:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "vi": "# Xác định độ dài tối đa của một chuỗi có thể được chấp nhận bởi một biểu thức chính quy đơn giản.\n# Hàm nhận một đối số duy nhất, regex, là một chuỗi đại diện cho một biểu thức chính quy\n# chỉ bao gồm 'x', '(', ')', và '|'. Hàm trả về độ dài của chuỗi dài nhất\n# có thể được chấp nhận bởi biểu thức chính quy này.\n#\n# Ví dụ:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)"
    },
    "prompt_bertscore": {
      "es": "0.9940828009489707",
      "arb": "0.9938617253348788",
      "sw": "0.9938617253348788",
      "tr": "0.984941036292221",
      "vi": "0.9888395547807928"
    },
    "canonical_solution": "    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end",
    "instruction": {
      "en": "Write a ruby function `def max_regex_string_length(regex)` to solve the following problem:\nDetermines the maximum length of a string that can be accepted by a simplified regular expression.\nThe function takes a single argument, regex, which is a string representing a regular expression\ncomposed only of 'x', '(', ')', and '|'. The function returns the length of the longest string\nthat can be accepted by this regular expression.\n\nExample:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "es": "Escribe una función en Ruby `def max_regex_string_length(regex)` para resolver el siguiente problema:\nDetermina la longitud máxima de una cadena que puede ser aceptada por una expresión regular simplificada.\nLa función toma un solo argumento, regex, que es una cadena que representa una expresión regular\ncompuesta solo de 'x', '(', ')', y '|'. La función devuelve la longitud de la cadena más larga\nque puede ser aceptada por esta expresión regular.\n\nEjemplo:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "arb": "اكتب دالة روبي `def max_regex_string_length(regex)` لحل المشكلة التالية:\nتحديد الطول الأقصى لسلسلة يمكن قبولها بواسطة تعبير منتظم مبسط.\nتأخذ الدالة وسيطًا واحدًا، regex، وهو سلسلة تمثل تعبيرًا منتظمًا\nيتكون فقط من 'x'، '('، ')'، و '|'. تُرجع الدالة طول أطول سلسلة\nيمكن قبولها بواسطة هذا التعبير المنتظم.\n\nمثال:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "sw": "Andika kazi ya ruby `def max_regex_string_length(regex)` kutatua tatizo lifuatalo:\nInabainisha urefu wa juu zaidi wa kamba ambayo inaweza kukubaliwa na usemi wa kawaida uliorahisishwa.\nKazi inachukua hoja moja, regex, ambayo ni kamba inayowakilisha usemi wa kawaida\nulioundwa tu na 'x', '(', ')', na '|'. Kazi inarejesha urefu wa kamba ndefu zaidi\nambayo inaweza kukubaliwa na usemi huu wa kawaida.\n\nMfano:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "tr": "Bir ruby fonksiyonu `def max_regex_string_length(regex)` yazın ve aşağıdaki problemi çözün:\nBasitleştirilmiş bir düzenli ifade tarafından kabul edilebilecek bir dizgenin maksimum uzunluğunu belirler.\nFonksiyon, yalnızca 'x', '(', ')', ve '|' karakterlerinden oluşan bir düzenli ifadeyi temsil eden bir dize olan regex adlı tek bir argüman alır. Fonksiyon, bu düzenli ifade tarafından kabul edilebilecek en uzun dizgenin uzunluğunu döndürür.\n\nÖrnek:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "vi": "Viết một hàm ruby `def max_regex_string_length(regex)` để giải quyết vấn đề sau:\nXác định độ dài tối đa của một chuỗi có thể được chấp nhận bởi một biểu thức chính quy đơn giản.\nHàm nhận một đối số duy nhất, regex, là một chuỗi đại diện cho một biểu thức chính quy\nchỉ bao gồm 'x', '(', ')', và '|'. Hàm trả về độ dài của chuỗi dài nhất\ncó thể được chấp nhận bởi biểu thức chính quy này.\n\nVí dụ:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4"
    },
    "instruction_bertscore": {
      "es": "0.9907279338132914",
      "arb": "0.9840181995419329",
      "sw": "0.9852936052185579",
      "tr": "0.9829553283730152",
      "vi": "0.9863693873622429"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\") == 6\nraise 'Test failed' unless max_regex_string_length(\"x(xx|x)x\") == 4\nraise 'Test failed' unless max_regex_string_length(\"xx|x\") == 2\nraise 'Test failed' unless max_regex_string_length(\"(xx|x)(x|xx)\") == 4\nraise 'Test failed' unless max_regex_string_length(\"x\") == 1\n  \n\nputs 'All tests passed!'",
    "entry_point": "max_regex_string_length",
    "signature": "def max_regex_string_length(regex)",
    "docstring": {
      "en": "Determines the maximum length of a string that can be accepted by a simplified regular expression.\nThe function takes a single argument, regex, which is a string representing a regular expression\ncomposed only of 'x', '(', ')', and '|'. The function returns the length of the longest string\nthat can be accepted by this regular expression.\n\nExample:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "es": "Determina la longitud máxima de una cadena que puede ser aceptada por una expresión regular simplificada. La función toma un solo argumento, regex, que es una cadena que representa una expresión regular compuesta solo de 'x', '(', ')', y '|'. La función devuelve la longitud de la cadena más larga que puede ser aceptada por esta expresión regular.\n\nEjemplo:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "arb": "يحدد الحد الأقصى لطول سلسلة يمكن قبولها بواسطة تعبير منتظم مبسط. تأخذ الدالة وسيطًا واحدًا، regex، وهو سلسلة تمثل تعبيرًا منتظمًا يتكون فقط من 'x'، '('، ')'، و '|'. تعيد الدالة طول أطول سلسلة يمكن قبولها بواسطة هذا التعبير المنتظم.\n\nمثال:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "sw": "Inabainisha urefu wa juu wa kamba inayoweza kukubalika na usemi wa kawaida uliorahisishwa.\nKazi inachukua hoja moja, regex, ambayo ni kamba inayowakilisha usemi wa kawaida\nuliotungwa tu na 'x', '(', ')', na '|'. Kazi inarejesha urefu wa kamba ndefu zaidi\nambayo inaweza kukubalika na usemi huu wa kawaida.\n\nMfano:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "tr": "Belirtilen basitleştirilmiş bir düzenli ifade tarafından kabul edilebilecek bir dizenin maksimum uzunluğunu belirler.\nFonksiyon, yalnızca 'x', '(', ')', ve '|' karakterlerinden oluşan bir düzenli ifadeyi temsil eden bir dize olan regex adlı tek bir argüman alır. Fonksiyon, bu düzenli ifade tarafından kabul edilebilecek en uzun dizenin uzunluğunu döndürür.\n\nÖrnek:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "vi": "Xác định độ dài tối đa của một chuỗi có thể được chấp nhận bởi một biểu thức chính quy đơn giản. Hàm nhận một đối số duy nhất, regex, là một chuỗi đại diện cho một biểu thức chính quy chỉ bao gồm 'x', '(', ')', và '|'. Hàm trả về độ dài của chuỗi dài nhất có thể được chấp nhận bởi biểu thức chính quy này.\n\nVí dụ:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4"
    },
    "docstring_bertscore": {
      "es": "0.9909938998934972",
      "arb": "0.992410531771038",
      "sw": "0.9593898199670361",
      "tr": "0.9763816559126656",
      "vi": "0.9846760633639204"
    }
  },
  {
    "task_id": "Ruby/13",
    "prompt": {
      "en": "# Finds the maximum sum of any three numbers from a given array that is divisible by a specified number k.\n# This function takes an array of numbers and an integer k as arguments. It returns the maximum sum \n# of any three numbers from the array such that this sum is divisible by k. It's guaranteed that there \n# are at least three numbers in the array and that a solution exists.\n#\n# Example:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "es": "# Encuentra la suma máxima de cualquier tres números de un arreglo dado que sea divisible por un número especificado k.\n# Esta función toma un arreglo de números y un entero k como argumentos. Devuelve la suma máxima\n# de cualquier tres números del arreglo tal que esta suma sea divisible por k. Se garantiza que hay al menos\n# tres números en el arreglo y que existe una solución.\n#\n# Ejemplo:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "arb": "# يجد أكبر مجموع لأي ثلاثة أرقام من مصفوفة معينة يكون قابلاً للقسمة على عدد محدد k.\n# تأخذ هذه الدالة مصفوفة من الأرقام وعدد صحيح k كوسائط. تقوم بإرجاع أكبر مجموع \n# لأي ثلاثة أرقام من المصفوفة بحيث يكون هذا المجموع قابلاً للقسمة على k. من المضمون \n# أن هناك على الأقل ثلاثة أرقام في المصفوفة وأن هناك حلاً موجودًا.\n#\n# مثال:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "sw": "# Inapata jumla ya juu zaidi ya nambari yoyote tatu kutoka kwenye safu iliyotolewa ambayo inagawanyika na nambari maalum k.\n# Kazi hii inachukua safu ya nambari na nambari nzima k kama hoja. Inarudisha jumla ya juu zaidi \n# ya nambari yoyote tatu kutoka kwenye safu hiyo ambapo jumla hii inagawanyika na k. Inahakikishwa kuwa kuna \n# angalau nambari tatu kwenye safu na kwamba suluhisho lipo.\n#\n# Mfano:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "tr": "# Belirtilen bir sayı k ile bölünebilen, verilen bir dizideki herhangi üç sayının maksimum toplamını bulur.\n# Bu fonksiyon bir sayı dizisi ve bir tamsayı k'yi argüman olarak alır. Dizideki herhangi üç sayının \n# toplamının k ile bölünebildiği maksimum toplamı döndürür. Dizide en az üç sayı olduğu ve bir çözüm \n# bulunduğu garanti edilmektedir.\n#\n# Örnek:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "vi": "# Tìm tổng lớn nhất của bất kỳ ba số nào từ một mảng cho trước mà chia hết cho một số k được chỉ định.\n# Hàm này nhận một mảng số và một số nguyên k làm đối số. Nó trả về tổng lớn nhất \n# của bất kỳ ba số nào từ mảng sao cho tổng này chia hết cho k. Đảm bảo rằng có ít nhất \n# ba số trong mảng và rằng có tồn tại một lời giải.\n#\n# Ví dụ:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)"
    },
    "prompt_bertscore": {
      "es": "0.9934636700512849",
      "arb": "0.9899435424385846",
      "sw": "0.9789602755192605",
      "tr": "0.9688762083348813",
      "vi": "0.9735193921219528"
    },
    "canonical_solution": "    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end",
    "instruction": {
      "en": "Write a ruby function `def max_sum_divisible_by_k(numbers, k)` to solve the following problem:\nFinds the maximum sum of any three numbers from a given array that is divisible by a specified number k.\nThis function takes an array of numbers and an integer k as arguments. It returns the maximum sum\nof any three numbers from the array such that this sum is divisible by k. It's guaranteed that there\nare at least three numbers in the array and that a solution exists.\n\nExample:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "es": "Escribe una función de Ruby `def max_sum_divisible_by_k(numbers, k)` para resolver el siguiente problema:\nEncuentra la suma máxima de cualquier tres números de un array dado que sea divisible por un número especificado k.\nEsta función toma un array de números y un entero k como argumentos. Devuelve la suma máxima\nde cualquier tres números del array tal que esta suma sea divisible por k. Se garantiza que hay al menos tres números en el array y que existe una solución.\n\nEjemplo:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "arb": "اكتب دالة روبي `def max_sum_divisible_by_k(numbers, k)` لحل المشكلة التالية:\nإيجاد أكبر مجموع لأي ثلاثة أرقام من مصفوفة معطاة يكون قابلاً للقسمة على رقم محدد k.\nتأخذ هذه الدالة مصفوفة من الأرقام وعدد صحيح k كوسيطات. تُرجع أكبر مجموع لأي ثلاثة أرقام من المصفوفة بحيث يكون هذا المجموع قابلاً للقسمة على k. من المضمون أن هناك على الأقل ثلاثة أرقام في المصفوفة وأن هناك حلاً موجودًا.\n\nمثال:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "sw": "Andika kazi ya ruby `def max_sum_divisible_by_k(numbers, k)` kutatua tatizo lifuatalo:\nInapata jumla kubwa zaidi ya namba tatu zozote kutoka kwenye safu iliyotolewa ambayo inagawanyika kwa namba maalum k.\nKazi hii inachukua safu ya namba na namba nzima k kama hoja. Inarudisha jumla kubwa zaidi\nya namba tatu zozote kutoka kwenye safu hiyo ili kwamba jumla hii igawanyike kwa k. Inahakikishwa kwamba kuna\nangalau namba tatu kwenye safu na kwamba suluhisho lipo.\n\nMfano:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "tr": "Bir ruby fonksiyonu `def max_sum_divisible_by_k(numbers, k)` yazın ve aşağıdaki problemi çözün:\nBelirtilen bir k sayısına bölünebilen, verilen bir dizideki herhangi üç sayının maksimum toplamını bulun.\nBu fonksiyon, bir sayı dizisi ve bir tamsayı k'yi argüman olarak alır. Diziden herhangi üç sayının toplamının k'ye bölünebildiği maksimum toplamı döndürür. Dizide en az üç sayı olduğu ve bir çözümün mevcut olduğu garanti edilir.\n\nÖrnek:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "vi": "Viết một hàm ruby `def max_sum_divisible_by_k(numbers, k)` để giải quyết vấn đề sau:\nTìm tổng lớn nhất của bất kỳ ba số nào từ một mảng cho trước mà chia hết cho một số k được chỉ định.\nHàm này nhận một mảng số và một số nguyên k làm đối số. Nó trả về tổng lớn nhất\ncủa bất kỳ ba số nào từ mảng sao cho tổng này chia hết cho k. Đảm bảo rằng có ít nhất ba số trong mảng và rằng có tồn tại một giải pháp.\n\nVí dụ:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35"
    },
    "instruction_bertscore": {
      "es": "0.9948000552548877",
      "arb": "0.9871470253039945",
      "sw": "0.9830061777505601",
      "tr": "0.9748881540776643",
      "vi": "0.977425657195385"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless max_sum_divisible_by_k([1, 2, 3, 4], 3) == 9\nraise 'Test failed' unless max_sum_divisible_by_k([4, 5, 10, 20], 5) == 35\nraise 'Test failed' unless max_sum_divisible_by_k([6, 12, 17, 23, 29], 7) == 35\nraise 'Test failed' unless max_sum_divisible_by_k([7, 14, 21, 28], 7) == 63\nraise 'Test failed' unless max_sum_divisible_by_k([10, 15, 25, 30, 40], 10) == 80\n\n\nputs 'All tests passed!'",
    "entry_point": "max_sum_divisible_by_k",
    "signature": "def max_sum_divisible_by_k(numbers, k)",
    "docstring": {
      "en": "Finds the maximum sum of any three numbers from a given array that is divisible by a specified number k.\nThis function takes an array of numbers and an integer k as arguments. It returns the maximum sum\nof any three numbers from the array such that this sum is divisible by k. It's guaranteed that there\nare at least three numbers in the array and that a solution exists.\n\nExample:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "es": "Encuentra la suma máxima de cualquier tres números de un arreglo dado que sea divisible por un número especificado k.  \nEsta función toma un arreglo de números y un entero k como argumentos. Devuelve la suma máxima de cualquier tres números del arreglo tal que esta suma sea divisible por k. Se garantiza que hay al menos tres números en el arreglo y que existe una solución.\n\nEjemplo:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "arb": "يعثر على أكبر مجموع لأي ثلاثة أرقام من مصفوفة معينة يمكن قسمته على عدد محدد k.\nتأخذ هذه الدالة مصفوفة من الأرقام وعدد صحيح k كوسائط. تُرجع أكبر مجموع لأي ثلاثة أرقام من المصفوفة بحيث يمكن قسمته على k. من المضمون أن هناك على الأقل ثلاثة أرقام في المصفوفة وأن هناك حلاً موجودًا.\n\nمثال:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "sw": "Inapata jumla ya juu zaidi ya nambari yoyote tatu kutoka kwenye safu iliyotolewa ambayo inagawanyika kwa nambari maalum k. \nKazi hii inachukua safu ya nambari na nambari nzima k kama hoja. Inarudisha jumla ya juu zaidi ya nambari yoyote tatu kutoka kwenye safu hiyo ili jumla hii igawanyike kwa k. Inahakikishwa kuwa kuna angalau nambari tatu kwenye safu na kwamba suluhisho lipo.\n\nMfano:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "tr": "Verilen bir diziden herhangi üç sayının toplamının belirtilen bir k sayısına bölünebilir olan en büyük toplamını bulur.\nBu fonksiyon, bir sayı dizisi ve bir tamsayı k'yi argüman olarak alır. Diziden herhangi üç sayının toplamının k'ye bölünebilir olan en büyük toplamını döndürür. Dizide en az üç sayı olduğu ve bir çözümün var olduğu garanti edilmektedir.\n\nÖrnek:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "vi": "Tìm tổng lớn nhất của bất kỳ ba số nào từ một mảng cho trước mà chia hết cho một số k được chỉ định. Hàm này nhận một mảng số và một số nguyên k làm đối số. Nó trả về tổng lớn nhất của bất kỳ ba số nào từ mảng sao cho tổng này chia hết cho k. Đảm bảo rằng có ít nhất ba số trong mảng và rằng có tồn tại một giải pháp.\n\nVí dụ:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35"
    },
    "docstring_bertscore": {
      "es": "0.9919932093404836",
      "arb": "0.9676645630105685",
      "sw": "0.9833794042365247",
      "tr": "0.9690353112700902",
      "vi": "0.9691113867060266"
    }
  },
  {
    "task_id": "Ruby/14",
    "prompt": {
      "en": "# Calculates the difference in the number of victories between the most and least successful teams.\n# This function takes a string, team_sequence, representing the sequence of winning teams, where each team\n# is identified by a lowercase letter. It returns an integer representing the difference in the number\n# of victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n#\n# Example:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "es": "# Calcula la diferencia en el número de victorias entre los equipos más y menos exitosos.\n# Esta función toma una cadena, team_sequence, que representa la secuencia de equipos ganadores, donde cada equipo\n# está identificado por una letra minúscula. Devuelve un entero que representa la diferencia en el número\n# de victorias entre el equipo que ganó más y el equipo que ganó menos (excluyendo equipos con cero victorias).\n#\n# Ejemplo:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "arb": "# يحسب الفرق في عدد الانتصارات بين الفرق الأكثر والأقل نجاحًا.\n# تأخذ هذه الدالة سلسلة نصية، team_sequence، تمثل تسلسل الفرق الفائزة، حيث يتم تحديد كل فريق بحرف صغير.\n# تُرجع عددًا صحيحًا يمثل الفرق في عدد الانتصارات بين الفريق الذي فاز بأكبر عدد والفريق الذي فاز بأقل عدد (باستثناء الفرق التي لم تحقق أي انتصارات).\n#\n# مثال:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "sw": "# Inahesabu tofauti ya idadi ya ushindi kati ya timu zilizofanikiwa zaidi na zile zilizofanikiwa kidogo.\n# Kazi hii inachukua kamba, team_sequence, inayowakilisha mlolongo wa timu zilizoshinda, ambapo kila timu\n# inatambulishwa na herufi ndogo. Inarudisha nambari kamili inayowakilisha tofauti ya idadi\n# ya ushindi kati ya timu iliyoshinda zaidi na timu iliyoshinda kidogo (ikiondoa timu zisizo na ushindi).\n#\n# Mfano:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "tr": "# En başarılı ve en az başarılı takımlar arasındaki zafer sayısı farkını hesaplar.\n# Bu fonksiyon, kazanan takımların dizisini temsil eden bir string olan team_sequence alır, \n# burada her takım küçük bir harfle tanımlanır. En çok kazanan takım ile en az kazanan takım arasındaki \n# zafer sayısı farkını temsil eden bir tamsayı döndürür (zaferi olmayan takımlar hariç).\n#\n# Örnek:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "vi": "# Tính sự khác biệt về số chiến thắng giữa các đội thành công nhất và ít thành công nhất.\n# Hàm này nhận một chuỗi, team_sequence, đại diện cho chuỗi các đội chiến thắng, trong đó mỗi đội\n# được xác định bằng một chữ cái thường. Nó trả về một số nguyên đại diện cho sự khác biệt về số\n# chiến thắng giữa đội thắng nhiều nhất và đội thắng ít nhất (không bao gồm các đội không có chiến thắng nào).\n#\n# Ví dụ:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)"
    },
    "prompt_bertscore": {
      "es": "0.987338306360931",
      "arb": "0.9725876170045182",
      "sw": "0.9679907140962277",
      "tr": "0.9676063643089252",
      "vi": "0.9830371640900016"
    },
    "canonical_solution": "    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end",
    "instruction": {
      "en": "Write a ruby function `def victory_gap_in_teams(team_sequence)` to solve the following problem:\nCalculates the difference in the number of victories between the most and least successful teams.\nThis function takes a string, team_sequence, representing the sequence of winning teams, where each team\nis identified by a lowercase letter. It returns an integer representing the difference in the number\nof victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n\nExample:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "es": "Escribe una función en ruby `def victory_gap_in_teams(team_sequence)` para resolver el siguiente problema:  \nCalcula la diferencia en el número de victorias entre los equipos más y menos exitosos.  \nEsta función toma una cadena, team_sequence, que representa la secuencia de equipos ganadores, donde cada equipo  \nes identificado por una letra minúscula. Devuelve un entero que representa la diferencia en el número  \nde victorias entre el equipo que ganó más y el equipo que ganó menos (excluyendo equipos con cero victorias).\n\nEjemplo:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "arb": "اكتب دالة روبي `def victory_gap_in_teams(team_sequence)` لحل المشكلة التالية:\nتحسب الفرق في عدد الانتصارات بين الفرق الأكثر والأقل نجاحًا.\nتأخذ هذه الدالة سلسلة نصية، team_sequence، تمثل تسلسل الفرق الفائزة، حيث يتم تحديد كل فريق بحرف صغير. تعيد عددًا صحيحًا يمثل الفرق في عدد الانتصارات بين الفريق الذي فاز بأكبر عدد والفريق الذي فاز بأقل عدد (باستثناء الفرق التي لم تحقق أي انتصارات).\n\nمثال:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "sw": "Andika kazi ya ruby `def victory_gap_in_teams(team_sequence)` kutatua tatizo lifuatalo:\nHesabu tofauti ya idadi ya ushindi kati ya timu iliyofanikiwa zaidi na ile iliyofanikiwa kidogo zaidi.\nKazi hii inachukua kamba, team_sequence, inayowakilisha mlolongo wa timu zilizoshinda, ambapo kila timu\ninatambulishwa na herufi ndogo. Inarudisha nambari kamili inayowakilisha tofauti ya idadi\nya ushindi kati ya timu iliyoshinda zaidi na timu iliyoshinda kidogo zaidi (ikiondoa timu ambazo hazijashinda kabisa).\n\nMfano:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "tr": "Bir ruby fonksiyonu `def victory_gap_in_teams(team_sequence)` yazın:\nEn başarılı ve en az başarılı takımlar arasındaki galibiyet farkını hesaplar.\nBu fonksiyon, kazanan takımların dizisini temsil eden bir dize olan team_sequence alır, burada her takım\nküçük harflerle tanımlanır. En çok kazanan takım ile en az kazanan takım arasındaki galibiyet farkını\ntemsil eden bir tamsayı döndürür (galibiyeti olmayan takımlar hariç).\n\nÖrnek:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "vi": "Viết một hàm ruby `def victory_gap_in_teams(team_sequence)` để giải quyết vấn đề sau:\nTính toán sự khác biệt về số lượng chiến thắng giữa các đội thành công nhất và ít thành công nhất.\nHàm này nhận một chuỗi, team_sequence, đại diện cho chuỗi các đội chiến thắng, trong đó mỗi đội\nđược xác định bằng một chữ cái thường. Nó trả về một số nguyên đại diện cho sự khác biệt về số lượng\nchiến thắng giữa đội thắng nhiều nhất và đội thắng ít nhất (không bao gồm các đội không có chiến thắng nào).\n\nVí dụ:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0"
    },
    "instruction_bertscore": {
      "es": "0.9911247973145991",
      "arb": "0.9864605587071379",
      "sw": "0.9650958749230253",
      "tr": "0.9478486003073849",
      "vi": "0.9828013898277131"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless victory_gap_in_teams(\"abaabcaa\") == 4\nraise 'Test failed' unless victory_gap_in_teams(\"abcd\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"a\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"aaabbbccc\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"abcdaaa\") == 3\n\nputs 'All tests passed!'",
    "entry_point": "victory_gap_in_teams",
    "signature": "def victory_gap_in_teams(team_sequence)",
    "docstring": {
      "en": "Calculates the difference in the number of victories between the most and least successful teams.\nThis function takes a string, team_sequence, representing the sequence of winning teams, where each team\nis identified by a lowercase letter. It returns an integer representing the difference in the number\nof victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n\nExample:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "es": "Calcula la diferencia en el número de victorias entre los equipos más y menos exitosos.  \nEsta función toma una cadena, team_sequence, que representa la secuencia de equipos ganadores, donde cada equipo  \nestá identificado por una letra minúscula. Devuelve un entero que representa la diferencia en el número  \nde victorias entre el equipo que ganó más y el equipo que ganó menos (excluyendo equipos con cero victorias).\n\nEjemplo:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "arb": "يحسب الفرق في عدد الانتصارات بين الفرق الأكثر والأقل نجاحًا.  \nتأخذ هذه الدالة سلسلة نصية، team_sequence، تمثل تسلسل الفرق الفائزة، حيث يتم تحديد كل فريق بحرف صغير. تُرجع عددًا صحيحًا يمثل الفرق في عدد الانتصارات بين الفريق الذي فاز بأكبر عدد والفريق الذي فاز بأقل عدد (باستثناء الفرق التي لم تحقق أي انتصار).\n\nمثال:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "sw": "Hesabu tofauti ya idadi ya ushindi kati ya timu zilizofanikiwa zaidi na zile zilizofanikiwa kidogo.\n\nKazi hii inachukua kamba, team_sequence, inayowakilisha mlolongo wa timu zilizoshinda, ambapo kila timu inatambulishwa na herufi ndogo. Inarudisha nambari ya mzima inayowakilisha tofauti ya idadi ya ushindi kati ya timu iliyoshinda zaidi na timu iliyoshinda kidogo (ikiondoa timu zilizo na ushindi sifuri).\n\nMfano:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "tr": "Zafer sayısındaki farkı en başarılı ve en az başarılı takımlar arasında hesaplar.\nBu fonksiyon, her bir takımın küçük harfle tanımlandığı kazanan takımların dizisini temsil eden bir string, team_sequence, alır. En çok kazanan takım ile en az kazanan takım arasındaki zafer sayısındaki farkı temsil eden bir tamsayı döndürür (zaferi olmayan takımlar hariç).\n\nÖrnek:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "vi": "Tính toán sự khác biệt về số lượng chiến thắng giữa các đội thành công nhất và ít thành công nhất. Hàm này nhận một chuỗi, team_sequence, đại diện cho chuỗi các đội chiến thắng, trong đó mỗi đội được xác định bằng một chữ cái viết thường. Nó trả về một số nguyên đại diện cho sự khác biệt về số lượng chiến thắng giữa đội thắng nhiều nhất và đội thắng ít nhất (không tính các đội không có chiến thắng nào).\n\nVí dụ:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0"
    },
    "docstring_bertscore": {
      "es": "0.9898307203821568",
      "arb": "0.9827175678069164",
      "sw": "0.9577658179716948",
      "tr": "0.9405113926623372",
      "vi": "0.9780882881465174"
    }
  },
  {
    "task_id": "Ruby/15",
    "prompt": {
      "en": "# Determines the maximum number of drop tests needed to find the drop tolerance height of a device from a building with a given height.\n# The function takes a single argument, n, which is the height of the building (number of floors).\n# It returns the maximum number of tests needed to find the exact floor from which if the device is dropped, it will break.\n#\n# The problem assumes the worst-case scenario, where the outcome of each test is the least favorable, thus requiring the maximum number of tests.\n#\n# Example:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "es": "# Determina el número máximo de pruebas de caída necesarias para encontrar la altura de tolerancia de caída de un dispositivo desde un edificio con una altura dada.\n# La función toma un solo argumento, n, que es la altura del edificio (número de pisos).\n# Devuelve el número máximo de pruebas necesarias para encontrar el piso exacto desde el cual, si el dispositivo se deja caer, se romperá.\n#\n# El problema asume el peor de los casos, donde el resultado de cada prueba es el menos favorable, requiriendo así el número máximo de pruebas.\n#\n# Ejemplo:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "arb": "```python\n# يحدد الحد الأقصى لعدد اختبارات الإسقاط اللازمة لإيجاد ارتفاع تحمل الإسقاط لجهاز من مبنى بارتفاع معين.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو ارتفاع المبنى (عدد الطوابق).\n# تعيد الدالة الحد الأقصى لعدد الاختبارات اللازمة لإيجاد الطابق الدقيق الذي إذا تم إسقاط الجهاز منه، سوف ينكسر.\n#\n# يفترض المشكلة أسوأ سيناريو، حيث تكون نتيجة كل اختبار هي الأقل تفضيلاً، مما يتطلب الحد الأقصى لعدد الاختبارات.\n#\n# مثال:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)\n```",
      "sw": "# Inabainisha idadi ya juu ya majaribio ya kuacha yanayohitajika ili kupata urefu wa uvumilivu wa kuacha kifaa kutoka kwa jengo lenye urefu uliotolewa.\n# Kazi inachukua hoja moja, n, ambayo ni urefu wa jengo (idadi ya sakafu).\n# Inarudisha idadi ya juu ya majaribio yanayohitajika ili kupata sakafu halisi ambayo kifaa kitavunjika ikiwa kitaangushwa.\n#\n# Tatizo linadhani hali mbaya zaidi, ambapo matokeo ya kila jaribio ni yasiyo na faida zaidi, hivyo kuhitaji idadi ya juu ya majaribio.\n#\n# Mfano:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "tr": "# Bir cihazın bir binadan bırakılma tolerans yüksekliğini bulmak için gereken maksimum düşme testi sayısını belirler.\n# Fonksiyon, bina yüksekliği (kat sayısı) olan n adlı tek bir argüman alır.\n# Cihazın bırakıldığında kırılacağı kesin katı bulmak için gereken maksimum test sayısını döndürür.\n#\n# Problem, her testin sonucunun en az elverişli olduğu en kötü senaryoyu varsayar, bu nedenle maksimum test sayısını gerektirir.\n#\n# Örnek:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "vi": "# Xác định số lần thử nghiệm thả tối đa cần thiết để tìm độ cao chịu đựng khi thả của một thiết bị từ một tòa nhà với chiều cao cho trước.\n# Hàm nhận một đối số duy nhất, n, là chiều cao của tòa nhà (số tầng).\n# Nó trả về số lần thử nghiệm tối đa cần thiết để tìm chính xác tầng từ đó nếu thiết bị được thả, nó sẽ bị vỡ.\n#\n# Vấn đề giả định kịch bản xấu nhất, nơi kết quả của mỗi thử nghiệm là ít thuận lợi nhất, do đó yêu cầu số lần thử nghiệm tối đa.\n#\n# Ví dụ:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)"
    },
    "prompt_bertscore": {
      "es": "0.9840638845295709",
      "arb": "0.9627472692976687",
      "sw": "0.9595395872743364",
      "tr": "0.9529551887734109",
      "vi": "0.9900712617735901"
    },
    "canonical_solution": "    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end",
    "instruction": {
      "en": "Write a ruby function `def max_drop_test_height(n)` to solve the following problem:\nDetermines the maximum number of drop tests needed to find the drop tolerance height of a device from a building with a given height.\nThe function takes a single argument, n, which is the height of the building (number of floors).\nIt returns the maximum number of tests needed to find the exact floor from which if the device is dropped, it will break.\n\nThe problem assumes the worst-case scenario, where the outcome of each test is the least favorable, thus requiring the maximum number of tests.\n\nExample:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "es": "Escribe una función en ruby `def max_drop_test_height(n)` para resolver el siguiente problema:\nDetermina el número máximo de pruebas de caída necesarias para encontrar la altura de tolerancia de caída de un dispositivo desde un edificio con una altura dada.\nLa función toma un solo argumento, n, que es la altura del edificio (número de pisos).\nDevuelve el número máximo de pruebas necesarias para encontrar el piso exacto desde el cual, si se deja caer el dispositivo, se romperá.\n\nEl problema asume el peor de los casos, donde el resultado de cada prueba es el menos favorable, requiriendo así el número máximo de pruebas.\n\nEjemplo:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "arb": "اكتب دالة روبي `def max_drop_test_height(n)` لحل المشكلة التالية:\nتحدد الحد الأقصى لعدد اختبارات الإسقاط اللازمة للعثور على ارتفاع تحمل الإسقاط لجهاز من مبنى بارتفاع معين.\nتأخذ الدالة وسيطًا واحدًا، n، وهو ارتفاع المبنى (عدد الطوابق).\nتعيد الدالة الحد الأقصى لعدد الاختبارات اللازمة للعثور على الطابق الدقيق الذي إذا أسقط منه الجهاز، سيتحطم.\n\nتفترض المشكلة أسوأ سيناريو، حيث تكون نتيجة كل اختبار هي الأقل ملاءمة، مما يتطلب الحد الأقصى لعدد الاختبارات.\n\nمثال:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "sw": "Andika kazi ya ruby `def max_drop_test_height(n)` kutatua tatizo lifuatalo:\nInabainisha idadi ya juu zaidi ya majaribio ya kuachia yanayohitajika ili kupata urefu wa uvumilivu wa kuachia wa kifaa kutoka kwenye jengo lenye urefu uliotolewa.\nKazi inachukua hoja moja, n, ambayo ni urefu wa jengo (idadi ya sakafu).\nInarejesha idadi ya juu zaidi ya majaribio yanayohitajika ili kupata sakafu halisi ambayo kifaa kikidondoshwa, kitavunjika.\n\nTatizo linachukulia hali mbaya zaidi, ambapo matokeo ya kila jaribio ni yasiyofaa zaidi, hivyo yanahitaji idadi ya juu zaidi ya majaribio.\n\nMfano:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "tr": "Bir ruby fonksiyonu `def max_drop_test_height(n)` yazın: Aşağıdaki problemi çözmek için:\nBir cihazın bir binadan düşme toleransı yüksekliğini bulmak için gereken maksimum düşme testi sayısını belirler.\nFonksiyon, binanın yüksekliği (kat sayısı) olan tek bir argüman, n, alır.\nCihazın bırakıldığında kırılacağı kesin katı bulmak için gereken maksimum test sayısını döndürür.\n\nProblem, her testin sonucunun en az elverişli olduğu en kötü durum senaryosunu varsayar, bu nedenle maksimum test sayısı gereklidir.\n\nÖrnek:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "vi": "Viết một hàm ruby `def max_drop_test_height(n)` để giải quyết vấn đề sau:\nXác định số lượng thử nghiệm thả tối đa cần thiết để tìm ra độ cao chịu đựng của một thiết bị khi thả từ một tòa nhà có chiều cao cho trước.\nHàm nhận một đối số duy nhất, n, là chiều cao của tòa nhà (số tầng).\nNó trả về số lượng thử nghiệm tối đa cần thiết để tìm ra chính xác tầng mà nếu thiết bị bị thả, nó sẽ bị vỡ.\n\nVấn đề giả định kịch bản xấu nhất, nơi kết quả của mỗi thử nghiệm là ít thuận lợi nhất, do đó yêu cầu số lượng thử nghiệm tối đa.\n\nVí dụ:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4"
    },
    "instruction_bertscore": {
      "es": "0.9834634248877024",
      "arb": "0.9813569496968275",
      "sw": "0.9741417011057352",
      "tr": "0.9568352346365464",
      "vi": "0.9633574618282079"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless max_drop_test_height(3) == 2\nraise 'Test failed' unless max_drop_test_height(10) == 4\nraise 'Test failed' unless max_drop_test_height(15) == 5\nraise 'Test failed' unless max_drop_test_height(6) == 3\nraise 'Test failed' unless max_drop_test_height(100) == 9\n\n\nputs 'All tests passed!'",
    "entry_point": "max_drop_test_height",
    "signature": "def max_drop_test_height(n)",
    "docstring": {
      "en": "Determines the maximum number of drop tests needed to find the drop tolerance height of a device from a building with a given height.\nThe function takes a single argument, n, which is the height of the building (number of floors).\nIt returns the maximum number of tests needed to find the exact floor from which if the device is dropped, it will break.\n\nThe problem assumes the worst-case scenario, where the outcome of each test is the least favorable, thus requiring the maximum number of tests.\n\nExample:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "es": "Determina el número máximo de pruebas de caída necesarias para encontrar la altura de tolerancia de caída de un dispositivo desde un edificio con una altura dada.  \nLa función toma un solo argumento, n, que es la altura del edificio (número de pisos).  \nDevuelve el número máximo de pruebas necesarias para encontrar el piso exacto desde el cual, si el dispositivo se deja caer, se romperá.\n\nEl problema asume el peor de los casos, donde el resultado de cada prueba es el menos favorable, requiriendo así el número máximo de pruebas.\n\nEjemplo:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "arb": "يحدد الحد الأقصى لعدد اختبارات الإسقاط اللازمة للعثور على ارتفاع تحمل الإسقاط لجهاز من مبنى بارتفاع معين.\nتأخذ الدالة وسيطًا واحدًا، n، وهو ارتفاع المبنى (عدد الطوابق).\nتعيد الدالة الحد الأقصى لعدد الاختبارات اللازمة للعثور على الطابق الدقيق الذي إذا أسقط منه الجهاز، سينكسر.\n\nتفترض المشكلة أسوأ سيناريو، حيث تكون نتيجة كل اختبار هي الأقل تفضيلاً، مما يتطلب الحد الأقصى من الاختبارات.\n\nمثال:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "sw": "Inabainisha idadi kubwa zaidi ya majaribio ya kuangusha yanayohitajika ili kupata urefu wa uvumilivu wa kuangusha kifaa kutoka kwenye jengo lenye urefu uliotolewa.\nKazi inachukua hoja moja, n, ambayo ni urefu wa jengo (idadi ya sakafu).\nInarejesha idadi kubwa zaidi ya majaribio yanayohitajika ili kupata sakafu halisi ambayo kifaa kikiangushwa, kitavunjika.\n\nTatizo linadhani hali mbaya zaidi, ambapo matokeo ya kila jaribio ni yasiyopendeza zaidi, hivyo kuhitaji idadi kubwa zaidi ya majaribio.\n\nMfano:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "tr": "Bir cihazın bir binadan düşme toleransı yüksekliğini bulmak için gereken maksimum düşme testi sayısını belirler.\nFonksiyon, bina yüksekliği (kat sayısı) olan n adlı tek bir argüman alır.\nCihazın bırakıldığında kırılacağı kesin katı bulmak için gereken maksimum test sayısını döndürür.\n\nProblem, her testin sonucunun en az elverişli olduğu en kötü senaryoyu varsayar, bu nedenle maksimum test sayısını gerektirir.\n\nÖrnek:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "vi": "Xác định số lần thử nghiệm thả tối đa cần thiết để tìm chiều cao chịu đựng khi thả của một thiết bị từ một tòa nhà với chiều cao đã cho. \nHàm nhận một tham số duy nhất, n, là chiều cao của tòa nhà (số tầng). \nNó trả về số lần thử nghiệm tối đa cần thiết để tìm chính xác tầng mà nếu thiết bị được thả, nó sẽ vỡ.\n\nVấn đề giả định kịch bản xấu nhất, nơi kết quả của mỗi thử nghiệm là ít thuận lợi nhất, do đó yêu cầu số lần thử nghiệm tối đa.\n\nVí dụ:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4"
    },
    "docstring_bertscore": {
      "es": "0.9835162605690577",
      "arb": "0.9736411525455272",
      "sw": "0.9815865664173038",
      "tr": "0.9626715911224945",
      "vi": "0.973326720652349"
    }
  },
  {
    "task_id": "Ruby/16",
    "prompt": {
      "en": "# Computes the repeated sum of digits of a given number string until it reduces to a single digit.\n# The function takes a single argument, `input_string`, which is a string representing a non-negative number.\n# It repeatedly sums the digits of the number until the sum is a single digit, then returns this single digit.\n#\n# Example:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "es": "# Calcula la suma repetida de los dígitos de una cadena de número dada hasta que se reduce a un solo dígito.\n# La función toma un único argumento, `input_string`, que es una cadena que representa un número no negativo.\n# Repetidamente suma los dígitos del número hasta que la suma es un solo dígito, luego devuelve este único dígito.\n#\n# Ejemplo:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "arb": "# يحسب مجموع الأرقام المتكرر لسلسلة رقمية معطاة حتى يتم تقليصها إلى رقم واحد.\n# تأخذ الدالة وسيطًا واحدًا، `input_string`، وهو سلسلة تمثل رقمًا غير سالب.\n# تقوم بجمع أرقام الرقم بشكل متكرر حتى يصبح المجموع رقمًا واحدًا، ثم تعيد هذا الرقم الواحد.\n#\n# مثال:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "sw": "# Inahesabu jumla ya kurudiwa ya tarakimu za namba iliyotolewa kama kamba hadi inapopunguzwa kuwa tarakimu moja.\n# Kazi inachukua hoja moja, `input_string`, ambayo ni kamba inayowakilisha namba isiyo hasi.\n# Inarudia kujumlisha tarakimu za namba hadi jumla itakapokuwa tarakimu moja, kisha inarudisha tarakimu hii moja.\n#\n# Mfano:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "tr": "# Verilen bir sayı dizisinin rakamlarının tekrar eden toplamını tek bir rakama indirgenene kadar hesaplar.\n# Fonksiyon, `input_string` adlı tek bir argüman alır, bu argüman negatif olmayan bir sayıyı temsil eden bir dizgidir.\n# Sayının rakamlarını tekrar tekrar toplar, toplam tek bir rakam olana kadar devam eder ve bu tek rakamı döndürür.\n#\n# Örnek:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "vi": "# Tính tổng lặp lại của các chữ số của một chuỗi số cho trước cho đến khi nó giảm xuống còn một chữ số.\n# Hàm nhận một đối số duy nhất, `input_string`, là một chuỗi đại diện cho một số không âm.\n# Nó lặp lại việc tính tổng các chữ số của số cho đến khi tổng là một chữ số, sau đó trả về chữ số này.\n#\n# Ví dụ:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)"
    },
    "prompt_bertscore": {
      "es": "0.9776260752498491",
      "arb": "0.9814534840620104",
      "sw": "0.9541829231585875",
      "tr": "0.9682260910977541",
      "vi": "0.9777013561642613"
    },
    "canonical_solution": "    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end",
    "instruction": {
      "en": "Write a ruby function `def digit_sum_to_single(input_string)` to solve the following problem:\nComputes the repeated sum of digits of a given number string until it reduces to a single digit.\nThe function takes a single argument, `input_string`, which is a string representing a non-negative number.\nIt repeatedly sums the digits of the number until the sum is a single digit, then returns this single digit.\n\nExample:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "es": "Escribe una función en ruby `def digit_sum_to_single(input_string)` para resolver el siguiente problema:\nCalcula la suma repetida de los dígitos de una cadena de números dada hasta que se reduzca a un solo dígito.\nLa función toma un solo argumento, `input_string`, que es una cadena que representa un número no negativo.\nRepetidamente suma los dígitos del número hasta que la suma sea un solo dígito, luego devuelve este único dígito.\n\nEjemplo:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "arb": "اكتب دالة روبي `def digit_sum_to_single(input_string)` لحل المشكلة التالية:\nتحسب مجموع الأرقام المتكرر لسلسلة رقمية معطاة حتى يتم تقليصها إلى رقم واحد.\nتأخذ الدالة وسيطًا واحدًا، `input_string`، وهو سلسلة تمثل رقمًا غير سالب.\nتقوم بجمع أرقام الرقم بشكل متكرر حتى يصبح المجموع رقمًا واحدًا، ثم تعيد هذا الرقم الواحد.\n\nمثال:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "sw": "Andika kazi ya ruby `def digit_sum_to_single(input_string)` kutatua tatizo lifuatalo:\nInahesabu jumla ya mara kwa mara ya tarakimu za namba iliyotolewa kama kamba hadi inapopunguzwa kuwa tarakimu moja.\nKazi inachukua hoja moja, `input_string`, ambayo ni kamba inayowakilisha namba isiyo hasi.\nInarudia kujumlisha tarakimu za namba hadi jumla iwe tarakimu moja, kisha inarudisha tarakimu hii moja.\n\nMfano:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "tr": "Bir ruby fonksiyonu `def digit_sum_to_single(input_string)` yazın:  \nVerilen bir sayı dizisinin rakamlarının tekrar eden toplamını tek bir rakama indirgenene kadar hesaplar.  \nFonksiyon, negatif olmayan bir sayıyı temsil eden bir dize olan `input_string` adlı tek bir argüman alır.  \nSayıların rakamlarını tekrar tekrar toplar, toplam tek bir rakam olana kadar devam eder ve bu tek rakamı döndürür.\n\nÖrnek:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "vi": "Viết một hàm ruby `def digit_sum_to_single(input_string)` để giải quyết vấn đề sau:\nTính tổng lặp lại của các chữ số của một chuỗi số cho đến khi nó giảm xuống còn một chữ số.\nHàm nhận một đối số duy nhất, `input_string`, là một chuỗi đại diện cho một số không âm.\nNó lặp lại việc tính tổng các chữ số của số cho đến khi tổng là một chữ số duy nhất, sau đó trả về chữ số này.\n\nVí dụ:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3"
    },
    "instruction_bertscore": {
      "es": "0.9671832815973209",
      "arb": "0.9799371397331901",
      "sw": "0.9710941151695168",
      "tr": "0.9538972926706594",
      "vi": "0.9841641928719935"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless digit_sum_to_single(\"35379\") == 9\nraise 'Test failed' unless digit_sum_to_single(\"24815\") == 2\nraise 'Test failed' unless digit_sum_to_single(\"9999\") == 9\nraise 'Test failed' unless digit_sum_to_single(\"12345\") == 6\nraise 'Test failed' unless digit_sum_to_single(\"0\") == 0\n  \n\nputs 'All tests passed!'",
    "entry_point": "digit_sum_to_single",
    "signature": "def digit_sum_to_single(input_string)",
    "docstring": {
      "en": "Computes the repeated sum of digits of a given number string until it reduces to a single digit.\nThe function takes a single argument, `input_string`, which is a string representing a non-negative number.\nIt repeatedly sums the digits of the number until the sum is a single digit, then returns this single digit.\n\nExample:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "es": "Calcula la suma repetida de los dígitos de una cadena de números dada hasta que se reduce a un solo dígito.  \nLa función toma un solo argumento, `input_string`, que es una cadena que representa un número no negativo.  \nSuma repetidamente los dígitos del número hasta que la suma sea un solo dígito, luego devuelve este único dígito.\n\nEjemplo:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "arb": "يحسب مجموع الأرقام المتكرر لسلسلة رقمية معينة حتى يتم تقليصها إلى رقم واحد.\nتأخذ الدالة وسيطًا واحدًا، `input_string`، وهو سلسلة تمثل رقمًا غير سالب.\nتقوم بجمع أرقام الرقم بشكل متكرر حتى يصبح المجموع رقمًا واحدًا، ثم تعيد هذا الرقم الواحد.\n\nمثال:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "sw": "Hesabu jumla ya kurudiwa ya tarakimu za namba iliyotolewa hadi inapopunguzwa kuwa tarakimu moja.\nKazi hii inachukua hoja moja, `input_string`, ambayo ni kamba inayowakilisha namba isiyo hasi.\nInajumlisha mara kwa mara tarakimu za namba hadi jumla inakuwa tarakimu moja, kisha inarudisha tarakimu hii moja.\n\nMfano:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "tr": "Verilen bir sayı dizisinin rakamlarının tekrar eden toplamını tek bir rakama indirgenene kadar hesaplar.\nFonksiyon, negatif olmayan bir sayıyı temsil eden bir dize olan `input_string` adlı tek bir argüman alır.\nSayının rakamlarını tekrar tekrar toplar, toplam tek bir rakam olana kadar devam eder ve ardından bu tek rakamı döndürür.\n\nÖrnek:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "vi": "Tính tổng lặp lại của các chữ số của một chuỗi số cho trước cho đến khi nó giảm xuống còn một chữ số. Hàm này nhận một đối số duy nhất, `input_string`, là một chuỗi biểu diễn một số không âm. Nó liên tục cộng các chữ số của số đó cho đến khi tổng chỉ còn một chữ số, sau đó trả về chữ số đơn này.\n\nVí dụ:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3"
    },
    "docstring_bertscore": {
      "es": "0.9585577573008809",
      "arb": "0.9694204555789169",
      "sw": "0.9449481994835135",
      "tr": "0.9587136821499933",
      "vi": "0.9579340579044314"
    }
  },
  {
    "task_id": "Ruby/17",
    "prompt": {
      "en": "# Calculates the minimum number of seat swaps required to group representatives of the same company together.\n# Given a string representing a sequence of seats occupied by representatives of three companies, A, B, and T,\n# the function returns the minimum number of swaps needed so that all representatives of each company are seated together.\n# The input string contains only the characters 'A', 'B', and 'T', and each character represents a seat taken by a representative from the respective companies.\n#\n# Examples:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "es": "# Calcula el número mínimo de intercambios de asientos necesarios para agrupar a los representantes de la misma empresa juntos.\n# Dada una cadena que representa una secuencia de asientos ocupados por representantes de tres empresas, A, B y T,\n# la función devuelve el número mínimo de intercambios necesarios para que todos los representantes de cada empresa estén sentados juntos.\n# La cadena de entrada contiene solo los caracteres 'A', 'B' y 'T', y cada carácter representa un asiento ocupado por un representante de las respectivas empresas.\n#\n# Ejemplos:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "arb": "# يحسب الحد الأدنى لعدد تبادلات المقاعد المطلوبة لتجميع ممثلي نفس الشركة معًا.\n# بالنظر إلى سلسلة تمثل تسلسل المقاعد التي يشغلها ممثلو ثلاث شركات، A، B، و T،\n# تعيد الدالة الحد الأدنى لعدد التبادلات اللازمة بحيث يجلس جميع ممثلي كل شركة معًا.\n# تحتوي سلسلة الإدخال فقط على الأحرف 'A'، 'B'، و 'T'، ويمثل كل حرف مقعدًا يشغله ممثل من الشركات المعنية.\n#\n# أمثلة:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "sw": "# Inakokotoa idadi ndogo ya kubadilisha viti inayohitajika ili kuwakusanya wawakilishi wa kampuni moja pamoja.\n# Ukipewa mfuatano wa viti vinavyowakilishwa na wawakilishi wa kampuni tatu, A, B, na T,\n# kazi inarudisha idadi ndogo ya mabadiliko yanayohitajika ili wawakilishi wote wa kila kampuni wakae pamoja.\n# Mfuatano wa ingizo unajumuisha tu herufi 'A', 'B', na 'T', na kila herufi inawakilisha kiti kilichochukuliwa na mwakilishi kutoka kampuni husika.\n#\n# Mifano:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "tr": "# Aynı şirketin temsilcilerini bir araya getirmek için gereken minimum koltuk değişim sayısını hesaplar.\n# Üç şirketin temsilcileri tarafından işgal edilen koltukların bir dizisini temsil eden bir dize verildiğinde, A, B ve T,\n# fonksiyon, her şirketin tüm temsilcileri bir araya oturacak şekilde gereken minimum değişim sayısını döndürür.\n# Girdi dizesi yalnızca 'A', 'B' ve 'T' karakterlerini içerir ve her karakter ilgili şirketlerden bir temsilci tarafından alınan bir koltuğu temsil eder.\n#\n# Örnekler:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "vi": "# Tính toán số lần hoán đổi chỗ ngồi tối thiểu cần thiết để nhóm các đại diện của cùng một công ty lại với nhau.\n# Cho một chuỗi đại diện cho một dãy ghế được chiếm bởi các đại diện của ba công ty, A, B và T,\n# hàm trả về số lần hoán đổi tối thiểu cần thiết để tất cả các đại diện của mỗi công ty được ngồi cùng nhau.\n# Chuỗi đầu vào chỉ chứa các ký tự 'A', 'B', và 'T', và mỗi ký tự đại diện cho một ghế được chiếm bởi một đại diện từ các công ty tương ứng.\n#\n# Ví dụ:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)"
    },
    "prompt_bertscore": {
      "es": "0.9764914985133779",
      "arb": "0.9643226068496565",
      "sw": "0.9433241974881722",
      "tr": "0.9703252169645308",
      "vi": "0.957504817651015"
    },
    "canonical_solution": "    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end",
    "instruction": {
      "en": "Write a ruby function `def minimum_swaps_to_group_companies(s)` to solve the following problem:\nCalculates the minimum number of seat swaps required to group representatives of the same company together.\nGiven a string representing a sequence of seats occupied by representatives of three companies, A, B, and T,\nthe function returns the minimum number of swaps needed so that all representatives of each company are seated together.\nThe input string contains only the characters 'A', 'B', and 'T', and each character represents a seat taken by a representative from the respective companies.\n\nExamples:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "es": "Escribe una función en ruby `def minimum_swaps_to_group_companies(s)` para resolver el siguiente problema:\nCalcula el número mínimo de intercambios de asientos necesarios para agrupar a los representantes de la misma empresa juntos.\nDada una cadena que representa una secuencia de asientos ocupados por representantes de tres empresas, A, B y T,\nla función devuelve el número mínimo de intercambios necesarios para que todos los representantes de cada empresa estén sentados juntos.\nLa cadena de entrada contiene solo los caracteres 'A', 'B' y 'T', y cada carácter representa un asiento ocupado por un representante de las respectivas empresas.\n\nEjemplos:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "arb": "اكتب دالة روبي `def minimum_swaps_to_group_companies(s)` لحل المشكلة التالية:\nتحسب الحد الأدنى لعدد تبديلات المقاعد المطلوبة لتجميع ممثلي نفس الشركة معًا.\nبالنظر إلى سلسلة تمثل تسلسل المقاعد التي يشغلها ممثلو ثلاث شركات، A، B، وT،\nتعيد الدالة الحد الأدنى لعدد التبديلات اللازمة بحيث يجلس جميع ممثلي كل شركة معًا.\nتحتوي سلسلة الإدخال فقط على الأحرف 'A'، 'B'، و'T'، وكل حرف يمثل مقعدًا يشغله ممثل من الشركات المعنية.\n\nأمثلة:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "sw": "Andika kazi ya ruby `def minimum_swaps_to_group_companies(s)` kutatua tatizo lifuatalo:\nHesabu idadi ndogo zaidi ya kubadilisha viti inayohitajika ili kuwakusanya wawakilishi wa kampuni moja pamoja.\nUkipiwa kamba inayowakilisha mlolongo wa viti vilivyokaliwa na wawakilishi wa kampuni tatu, A, B, na T,\nkazi inarudisha idadi ndogo zaidi ya kubadilisha viti inayohitajika ili wawakilishi wote wa kila kampuni wakae pamoja.\nKamba ya ingizo ina herufi 'A', 'B', na 'T' pekee, na kila herufi inawakilisha kiti kilichochukuliwa na mwakilishi kutoka kampuni husika.\n\nMifano:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "tr": "Bir ruby fonksiyonu `def minimum_swaps_to_group_companies(s)` yazın:\nAynı şirketin temsilcilerini bir araya getirmek için gereken minimum koltuk değişim sayısını hesaplar.\nÜç şirketin, A, B ve T, temsilcileri tarafından işgal edilen koltukların bir dizisini temsil eden bir dize verildiğinde,\nfonksiyon, her bir şirketin tüm temsilcilerinin bir arada oturması için gereken minimum değişim sayısını döndürür.\nGirdi dizesi yalnızca 'A', 'B' ve 'T' karakterlerini içerir ve her karakter, ilgili şirketlerden bir temsilci tarafından alınan bir koltuğu temsil eder.\n\nÖrnekler:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "vi": "Viết một hàm ruby `def minimum_swaps_to_group_companies(s)` để giải quyết vấn đề sau:\nTính toán số lần hoán đổi chỗ ngồi tối thiểu cần thiết để nhóm các đại diện của cùng một công ty lại với nhau.\nCho một chuỗi đại diện cho một dãy ghế được chiếm bởi các đại diện của ba công ty, A, B và T,\nhàm trả về số lần hoán đổi tối thiểu cần thiết để tất cả các đại diện của mỗi công ty ngồi cùng nhau.\nChuỗi đầu vào chỉ chứa các ký tự 'A', 'B', và 'T', và mỗi ký tự đại diện cho một ghế được chiếm bởi một đại diện từ các công ty tương ứng.\n\nVí dụ:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1"
    },
    "instruction_bertscore": {
      "es": "0.9700006549219198",
      "arb": "0.9677912891936687",
      "sw": "0.9654738685381347",
      "tr": "0.9572170022288954",
      "vi": "0.9640091681083834"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless minimum_swaps_to_group_companies(\"TABTABBTTTT\") == 3\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"BBTAAT\") == 1\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"AABBBTTT\") == 0\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"ATBT\") == 1\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"TTABAB\") == 1\n  \n\n\n\nputs 'All tests passed!'",
    "entry_point": "minimum_swaps_to_group_companies",
    "signature": "def minimum_swaps_to_group_companies(s)",
    "docstring": {
      "en": "Calculates the minimum number of seat swaps required to group representatives of the same company together.\nGiven a string representing a sequence of seats occupied by representatives of three companies, A, B, and T,\nthe function returns the minimum number of swaps needed so that all representatives of each company are seated together.\nThe input string contains only the characters 'A', 'B', and 'T', and each character represents a seat taken by a representative from the respective companies.\n\nExamples:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "es": "Calcula el número mínimo de intercambios de asientos necesarios para agrupar a los representantes de la misma empresa juntos.\nDada una cadena que representa una secuencia de asientos ocupados por representantes de tres empresas, A, B y T,\nla función devuelve el número mínimo de intercambios necesarios para que todos los representantes de cada empresa estén sentados juntos.\nLa cadena de entrada contiene solo los caracteres 'A', 'B' y 'T', y cada carácter representa un asiento ocupado por un representante de las respectivas empresas.\n\nEjemplos:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "arb": "يحسب الحد الأدنى لعدد تبديلات المقاعد المطلوبة لتجميع ممثلي نفس الشركة معًا.  \nبالنظر إلى سلسلة تمثل تسلسل المقاعد التي يشغلها ممثلو ثلاث شركات، A وB وT،  \nتعيد الدالة الحد الأدنى لعدد التبديلات اللازمة بحيث يجلس جميع ممثلي كل شركة معًا.  \nتحتوي سلسلة الإدخال على الأحرف 'A' و'B' و'T' فقط، ويمثل كل حرف مقعدًا يشغله ممثل من الشركات المعنية.\n\nأمثلة:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "sw": "Hesabu idadi ndogo ya ubadilishaji wa viti inayohitajika ili kuwakusanya wawakilishi wa kampuni moja pamoja. \nUkipatiwa kamba inayowakilisha mlolongo wa viti vilivyokaliwa na wawakilishi wa kampuni tatu, A, B, na T, \nkazi inarudisha idadi ndogo ya ubadilishaji unaohitajika ili wawakilishi wote wa kila kampuni wakae pamoja. \nKamba ya ingizo ina herufi 'A', 'B', na 'T' pekee, na kila herufi inawakilisha kiti kilichochukuliwa na mwakilishi kutoka kampuni husika.\n\nMifano:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "tr": "Aynı şirketin temsilcilerini bir araya getirmek için gereken minimum koltuk değişim sayısını hesaplar.\nÜç şirketin temsilcileri tarafından işgal edilen koltukların bir dizisini temsil eden bir dize verildiğinde, \nher şirketin tüm temsilcilerinin bir arada oturması için gereken minimum değişim sayısını döndürür.\nGirdi dizisi yalnızca 'A', 'B' ve 'T' karakterlerini içerir ve her karakter, ilgili şirketlerden bir temsilci tarafından alınan bir koltuğu temsil eder.\n\nÖrnekler:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "vi": "Tính toán số lần đổi chỗ tối thiểu cần thiết để nhóm các đại diện của cùng một công ty lại với nhau.  \nCho một chuỗi đại diện cho một dãy ghế được chiếm bởi các đại diện của ba công ty, A, B và T,  \nhàm trả về số lần đổi chỗ tối thiểu cần thiết để tất cả các đại diện của mỗi công ty ngồi cùng nhau.  \nChuỗi đầu vào chỉ chứa các ký tự 'A', 'B', và 'T', và mỗi ký tự đại diện cho một ghế được chiếm bởi một đại diện từ các công ty tương ứng.\n\nVí dụ:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")  \n3  \n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")  \n1  "
    },
    "docstring_bertscore": {
      "es": "0.9743490712235355",
      "arb": "0.9691233045288887",
      "sw": "0.9701297646695924",
      "tr": "0.9404065158211508",
      "vi": "0.9537667925103194"
    }
  },
  {
    "task_id": "Ruby/18",
    "prompt": {
      "en": "# Calculates the final minimum weight of fish in a simulated feeding game.\n# In this game, there are 'n' fish, each with an initial weight given in the 'weights' array.\n# The game proceeds for 'm' rounds. In each round, the lightest fish eats the second lightest,\n# and its weight becomes the sum of both. The function returns the weight of the lightest fish\n# after 'm' rounds.\n#\n# Arguments:\n# n (Integer) -- The number of fish.\n# m (Integer) -- The number of rounds the game will be played.\n# weights (Array of Integers) -- An array representing the weights of each fish.\n#\n# Example:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "es": "# Calcula el peso mínimo final de los peces en un juego de alimentación simulado.\n# En este juego, hay 'n' peces, cada uno con un peso inicial dado en el arreglo 'weights'.\n# El juego procede por 'm' rondas. En cada ronda, el pez más ligero se come al segundo más ligero,\n# y su peso se convierte en la suma de ambos. La función devuelve el peso del pez más ligero\n# después de 'm' rondas.\n#\n# Argumentos:\n# n (Entero) -- El número de peces.\n# m (Entero) -- El número de rondas que se jugará el juego.\n# weights (Arreglo de Enteros) -- Un arreglo que representa los pesos de cada pez.\n#\n# Ejemplo:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "arb": "# يحسب الوزن النهائي الأدنى للأسماك في لعبة تغذية محاكاة.\n# في هذه اللعبة، هناك 'n' سمكة، كل منها بوزن ابتدائي معطى في مصفوفة 'weights'.\n# تستمر اللعبة لعدد 'm' من الجولات. في كل جولة، تأكل السمكة الأخف وزناً السمكة الثانية الأخف،\n# ويصبح وزنها مجموع الاثنين. تُرجع الدالة وزن السمكة الأخف بعد 'm' جولات.\n#\n# الوسائط:\n# n (عدد صحيح) -- عدد الأسماك.\n# m (عدد صحيح) -- عدد الجولات التي ستُلعب في اللعبة.\n# weights (مصفوفة من الأعداد الصحيحة) -- مصفوفة تمثل أوزان كل سمكة.\n#\n# مثال:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "sw": "# Inakokotoa uzito wa mwisho wa chini wa samaki katika mchezo wa kulisha uliosimuliwa.\n# Katika mchezo huu, kuna 'n' samaki, kila mmoja akiwa na uzito wa awali uliopewa katika safu ya 'weights'.\n# Mchezo unaendelea kwa raundi 'm'. Katika kila raundi, samaki mwepesi zaidi anakula wa pili mwepesi zaidi,\n# na uzito wake unakuwa jumla ya wote wawili. Kazi inarejesha uzito wa samaki mwepesi zaidi\n# baada ya raundi 'm'.\n#\n# Hoja:\n# n (Integer) -- Idadi ya samaki.\n# m (Integer) -- Idadi ya raundi ambazo mchezo utachezwa.\n# weights (Array of Integers) -- Safu inayowakilisha uzito wa kila samaki.\n#\n# Mfano:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "tr": "# Simüle edilmiş bir besleme oyununda balıkların nihai minimum ağırlığını hesaplar.\n# Bu oyunda, her biri 'weights' dizisinde verilen başlangıç ağırlığına sahip 'n' balık vardır.\n# Oyun 'm' tur devam eder. Her turda, en hafif balık ikinci en hafif balığı yer\n# ve ağırlığı her ikisinin toplamı olur. Fonksiyon, 'm' turdan sonra en hafif balığın\n# ağırlığını döndürür.\n#\n# Argümanlar:\n# n (Integer) -- Balık sayısı.\n# m (Integer) -- Oyunun oynanacağı tur sayısı.\n# weights (Array of Integers) -- Her bir balığın ağırlığını temsil eden bir dizi.\n#\n# Örnek:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "vi": "# Tính trọng lượng tối thiểu cuối cùng của cá trong một trò chơi cho ăn mô phỏng.\n# Trong trò chơi này, có 'n' con cá, mỗi con có trọng lượng ban đầu được cho trong mảng 'weights'.\n# Trò chơi diễn ra trong 'm' vòng. Trong mỗi vòng, con cá nhẹ nhất ăn con cá nhẹ thứ hai,\n# và trọng lượng của nó trở thành tổng của cả hai. Hàm trả về trọng lượng của con cá nhẹ nhất\n# sau 'm' vòng.\n#\n# Tham số:\n# n (Integer) -- Số lượng cá.\n# m (Integer) -- Số vòng mà trò chơi sẽ diễn ra.\n# weights (Array of Integers) -- Một mảng đại diện cho trọng lượng của mỗi con cá.\n#\n# Ví dụ:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)"
    },
    "prompt_bertscore": {
      "es": "0.9958744469859053",
      "arb": "0.9737579472095758",
      "sw": "0.9893460622524317",
      "tr": "0.9867769769041265",
      "vi": "0.9767270741452853"
    },
    "canonical_solution": "  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend",
    "instruction": {
      "en": "Write a ruby function `def final_min_weight_fish(m, weights)` to solve the following problem:\nCalculates the final minimum weight of fish in a simulated feeding game.\nIn this game, there are 'n' fish, each with an initial weight given in the 'weights' array.\nThe game proceeds for 'm' rounds. In each round, the lightest fish eats the second lightest,\nand its weight becomes the sum of both. The function returns the weight of the lightest fish\nafter 'm' rounds.\n\nArguments:\nn (Integer) -- The number of fish.\nm (Integer) -- The number of rounds the game will be played.\nweights (Array of Integers) -- An array representing the weights of each fish.\n\nExample:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "es": "Escribe una función en ruby `def final_min_weight_fish(m, weights)` para resolver el siguiente problema:\nCalcula el peso mínimo final de los peces en un juego de alimentación simulado.\nEn este juego, hay 'n' peces, cada uno con un peso inicial dado en el array 'weights'.\nEl juego procede por 'm' rondas. En cada ronda, el pez más ligero se come al segundo más ligero,\ny su peso se convierte en la suma de ambos. La función devuelve el peso del pez más ligero\ndespués de 'm' rondas.\n\nArgumentos:\nn (Integer) -- El número de peces.\nm (Integer) -- El número de rondas que se jugará el juego.\nweights (Array of Integers) -- Un array que representa los pesos de cada pez.\n\nEjemplo:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "arb": "اكتب دالة روبي `def final_min_weight_fish(m, weights)` لحل المشكلة التالية:\nتحسب الوزن النهائي الأدنى للأسماك في لعبة تغذية محاكاة.\nفي هذه اللعبة، هناك 'n' سمكة، كل منها بوزن ابتدائي معطى في مصفوفة 'weights'.\nتستمر اللعبة لمدة 'm' جولة. في كل جولة، تأكل السمكة الأخف السمكة الثانية الأخف،\nويصبح وزنها مجموع الاثنين. تعيد الدالة وزن السمكة الأخف بعد 'm' جولة.\n\nالمعطيات:\nn (عدد صحيح) -- عدد الأسماك.\nm (عدد صحيح) -- عدد الجولات التي ستلعبها اللعبة.\nweights (مصفوفة من الأعداد الصحيحة) -- مصفوفة تمثل أوزان كل سمكة.\n\nمثال:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "sw": "Andika kazi ya ruby `def final_min_weight_fish(m, weights)` kutatua tatizo lifuatalo:\nHesabu uzito wa mwisho wa chini wa samaki katika mchezo wa kulisha uliosimuliwa.\nKatika mchezo huu, kuna 'n' samaki, kila mmoja akiwa na uzito wa awali uliotolewa katika safu ya 'weights'.\nMchezo unaendelea kwa raundi 'm'. Katika kila raundi, samaki mwepesi zaidi anakula wa pili mwepesi,\nna uzito wake unakuwa jumla ya wote wawili. Kazi inarudisha uzito wa samaki mwepesi zaidi\nbaada ya raundi 'm'.\n\nHoja:\nn (Integer) -- Idadi ya samaki.\nm (Integer) -- Idadi ya raundi ambazo mchezo utachezwa.\nweights (Array of Integers) -- Safu inayowakilisha uzito wa kila samaki.\n\nMfano:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "tr": "Bir ruby fonksiyonu `def final_min_weight_fish(m, weights)` yazın:\nSimüle edilmiş bir beslenme oyununda balıkların nihai minimum ağırlığını hesaplar.\nBu oyunda, her biri 'weights' dizisinde verilen başlangıç ağırlığına sahip 'n' balık vardır.\nOyun 'm' tur boyunca devam eder. Her turda, en hafif balık ikinci en hafif olanı yer\nve ağırlığı ikisinin toplamı olur. Fonksiyon, 'm' turdan sonra en hafif balığın ağırlığını döndürür.\n\nArgümanlar:\nn (Integer) -- Balık sayısı.\nm (Integer) -- Oyunun oynanacağı tur sayısı.\nweights (Array of Integers) -- Her bir balığın ağırlığını temsil eden bir dizi.\n\nÖrnek:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "vi": "Viết một hàm ruby `def final_min_weight_fish(m, weights)` để giải quyết vấn đề sau:\nTính toán trọng lượng tối thiểu cuối cùng của cá trong một trò chơi cho ăn mô phỏng.\nTrong trò chơi này, có 'n' con cá, mỗi con có trọng lượng ban đầu được cho trong mảng 'weights'.\nTrò chơi diễn ra trong 'm' vòng. Trong mỗi vòng, con cá nhẹ nhất ăn con cá nhẹ thứ hai,\nvà trọng lượng của nó trở thành tổng của cả hai. Hàm trả về trọng lượng của con cá nhẹ nhất\nsau 'm' vòng.\n\nTham số:\nn (Integer) -- Số lượng cá.\nm (Integer) -- Số vòng mà trò chơi sẽ diễn ra.\nweights (Array of Integers) -- Một mảng đại diện cho trọng lượng của mỗi con cá.\n\nVí dụ:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4"
    },
    "instruction_bertscore": {
      "es": "0.9879457180661357",
      "arb": "0.9672786241802177",
      "sw": "0.987856135764289",
      "tr": "0.9668756031370979",
      "vi": "0.9800030850196937"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless final_min_weight_fish(1, [1, 2, 3]) == 3\nraise 'Test failed' unless final_min_weight_fish(2, [4, 3, 2, 1]) == 4\nraise 'Test failed' unless final_min_weight_fish(2, [5, 4, 3, 2, 1]) == 4\nraise 'Test failed' unless final_min_weight_fish(2, [3, 2, 1]) == 6\nraise 'Test failed' unless final_min_weight_fish(3, [1, 2, 3, 4]) == 10\n  \nputs 'All tests passed!'",
    "entry_point": "final_min_weight_fish",
    "signature": "def final_min_weight_fish(m, weights)",
    "docstring": {
      "en": "Calculates the final minimum weight of fish in a simulated feeding game.\nIn this game, there are 'n' fish, each with an initial weight given in the 'weights' array.\nThe game proceeds for 'm' rounds. In each round, the lightest fish eats the second lightest,\nand its weight becomes the sum of both. The function returns the weight of the lightest fish\nafter 'm' rounds.\n\nArguments:\nn (Integer) -- The number of fish.\nm (Integer) -- The number of rounds the game will be played.\nweights (Array of Integers) -- An array representing the weights of each fish.\n\nExample:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "es": "Calcula el peso mínimo final de los peces en un juego de alimentación simulado. En este juego, hay 'n' peces, cada uno con un peso inicial dado en el arreglo 'weights'. El juego procede por 'm' rondas. En cada ronda, el pez más ligero se come al segundo más ligero, y su peso se convierte en la suma de ambos. La función devuelve el peso del pez más ligero después de 'm' rondas.\n\nArgumentos:\nn (Integer) -- El número de peces.\nm (Integer) -- El número de rondas que se jugará el juego.\nweights (Array de Enteros) -- Un arreglo que representa los pesos de cada pez.\n\nEjemplo:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "arb": "يحسب الوزن النهائي الأدنى للأسماك في لعبة تغذية محاكاة.\nفي هذه اللعبة، هناك 'n' من الأسماك، كل منها بوزن ابتدائي معطى في مصفوفة 'weights'.\nتستمر اللعبة لمدة 'm' جولات. في كل جولة، تأكل السمكة الأخف وزناً السمكة الثانية الأخف وزناً،\nويصبح وزنها مجموع الاثنين. تعيد الدالة وزن السمكة الأخف وزناً بعد 'm' جولات.\n\nالمعطيات:\nn (عدد صحيح) -- عدد الأسماك.\nm (عدد صحيح) -- عدد الجولات التي ستلعب فيها اللعبة.\nweights (مصفوفة من الأعداد الصحيحة) -- مصفوفة تمثل أوزان كل سمكة.\n\nمثال:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "sw": "Hesabu uzito wa mwisho wa chini wa samaki katika mchezo wa kulisha uliosimuliwa. Katika mchezo huu, kuna 'n' samaki, kila mmoja akiwa na uzito wa awali uliotolewa katika safu ya 'weights'. Mchezo unaendelea kwa raundi 'm'. Katika kila raundi, samaki mwepesi zaidi anakula samaki wa pili mwepesi, na uzito wake unakuwa jumla ya wote wawili. Kazi inarudisha uzito wa samaki mwepesi zaidi baada ya raundi 'm'.\n\nHoja:\nn (Integer) -- Idadi ya samaki.\nm (Integer) -- Idadi ya raundi ambazo mchezo utachezwa.\nweights (Array of Integers) -- Safu inayowakilisha uzito wa kila samaki.\n\nMfano:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "tr": "Balıkların simüle edilmiş bir beslenme oyunundaki nihai minimum ağırlığını hesaplar.\nBu oyunda, her biri 'weights' dizisinde verilen başlangıç ağırlığına sahip 'n' balık vardır.\nOyun 'm' tur devam eder. Her turda, en hafif balık ikinci en hafif olanı yer ve ağırlığı her ikisinin toplamı olur.\nFonksiyon, 'm' turdan sonra en hafif balığın ağırlığını döndürür.\n\nArgümanlar:\nn (Integer) -- Balık sayısı.\nm (Integer) -- Oyunun oynanacağı tur sayısı.\nweights (Array of Integers) -- Her bir balığın ağırlığını temsil eden bir dizi.\n\nÖrnek:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "vi": "Tính toán trọng lượng tối thiểu cuối cùng của cá trong một trò chơi cho ăn mô phỏng. Trong trò chơi này, có 'n' con cá, mỗi con có trọng lượng ban đầu được cho trong mảng 'weights'. Trò chơi diễn ra trong 'm' vòng. Trong mỗi vòng, con cá nhẹ nhất ăn con cá nhẹ thứ hai, và trọng lượng của nó trở thành tổng của cả hai. Hàm trả về trọng lượng của con cá nhẹ nhất sau 'm' vòng.\n\nTham số:\nn (Integer) -- Số lượng cá.\nm (Integer) -- Số vòng mà trò chơi sẽ được chơi.\nweights (Array of Integers) -- Một mảng đại diện cho trọng lượng của mỗi con cá.\n\nVí dụ:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4"
    },
    "docstring_bertscore": {
      "es": "0.9944518561969335",
      "arb": "0.9641098737115681",
      "sw": "0.9866248260322538",
      "tr": "0.9867563193444988",
      "vi": "0.9788792343237983"
    }
  },
  {
    "task_id": "Ruby/19",
    "prompt": {
      "en": "# Sorts a list of patient information based on their age and registration order.\n# The function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\n# The sorting criteria are as follows:\n# 1. Patients aged 60 and above are given priority over younger patients.\n# 2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n# 3. Younger patients (below 60) are sorted based on their registration order.\n#\n# Example:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "es": "# Ordena una lista de información de pacientes basada en su edad y orden de registro.\n# La función toma un arreglo de arreglos, donde cada sub-arreglo contiene el ID de un paciente (una cadena) y la edad (un entero).\n# Los criterios de ordenación son los siguientes:\n# 1. Los pacientes de 60 años o más tienen prioridad sobre los pacientes más jóvenes.\n# 2. Los pacientes ancianos (de 60 años o más) se ordenan en orden descendente de edad. Si las edades son iguales, se ordenan por su orden de registro.\n# 3. Los pacientes más jóvenes (menores de 60 años) se ordenan según su orden de registro.\n#\n# Ejemplo:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "arb": "# يقوم بفرز قائمة بمعلومات المرضى بناءً على أعمارهم وترتيب تسجيلهم.\n# تأخذ الدالة مصفوفة من المصفوفات، حيث تحتوي كل مصفوفة فرعية على معرف المريض (سلسلة نصية) والعمر (عدد صحيح).\n# معايير الفرز كالتالي:\n# 1. يتم إعطاء المرضى الذين تبلغ أعمارهم 60 عامًا فأكثر أولوية على المرضى الأصغر سنًا.\n# 2. يتم فرز المرضى المسنين (الذين تبلغ أعمارهم 60 عامًا فأكثر) بترتيب تنازلي للعمر. إذا كانت الأعمار متساوية، يتم فرزهم حسب ترتيب تسجيلهم.\n# 3. يتم فرز المرضى الأصغر سنًا (أقل من 60 عامًا) بناءً على ترتيب تسجيلهم.\n#\n# مثال:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "sw": "# Hupanga orodha ya taarifa za wagonjwa kulingana na umri wao na mpangilio wa usajili.\n# Kazi inachukua safu ya safu, ambapo kila safu ndogo ina kitambulisho cha mgonjwa (kamba) na umri (nambari kamili).\n# Vigezo vya upangaji ni kama ifuatavyo:\n# 1. Wagonjwa wenye umri wa miaka 60 na zaidi wanapewa kipaumbele juu ya wagonjwa wadogo.\n# 2. Wagonjwa wazee (wenye umri wa miaka 60+) wanapangwa kwa mpangilio wa kushuka kwa umri. Ikiwa umri ni sawa, wanapangwa kwa mpangilio wa usajili wao.\n# 3. Wagonjwa wadogo (chini ya miaka 60) wanapangwa kulingana na mpangilio wa usajili wao.\n#\n# Mfano:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "tr": "# Hasta bilgilerini yaşlarına ve kayıt sıralarına göre sıralar.\n# Fonksiyon, her alt dizinin bir hastanın kimlik numarasını (bir string) ve yaşını (bir tamsayı) içerdiği bir dizi dizisi alır.\n# Sıralama kriterleri aşağıdaki gibidir:\n# 1. 60 yaş ve üzeri hastalar, daha genç hastalara göre öncelik alır.\n# 2. Yaşlı hastalar (60+ yaş) yaşlarına göre azalan sırada sıralanır. Eğer yaşlar eşitse, kayıt sıralarına göre sıralanırlar.\n# 3. Daha genç hastalar (60 yaş altı) kayıt sıralarına göre sıralanır.\n#\n# Örnek:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "vi": "# Sắp xếp danh sách thông tin bệnh nhân dựa trên tuổi và thứ tự đăng ký của họ.\n# Hàm nhận một mảng các mảng, trong đó mỗi mảng con chứa ID của bệnh nhân (một chuỗi) và tuổi (một số nguyên).\n# Tiêu chí sắp xếp như sau:\n# 1. Bệnh nhân từ 60 tuổi trở lên được ưu tiên hơn so với bệnh nhân trẻ hơn.\n# 2. Bệnh nhân cao tuổi (từ 60 tuổi trở lên) được sắp xếp theo thứ tự giảm dần của tuổi. Nếu tuổi bằng nhau, họ được sắp xếp theo thứ tự đăng ký.\n# 3. Bệnh nhân trẻ hơn (dưới 60 tuổi) được sắp xếp dựa trên thứ tự đăng ký của họ.\n#\n# Ví dụ:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)"
    },
    "prompt_bertscore": {
      "es": "0.9775273559504748",
      "arb": "0.9801027974709732",
      "sw": "0.9719813970815997",
      "tr": "0.963061899821228",
      "vi": "0.9840291242128898"
    },
    "canonical_solution": "    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end",
    "instruction": {
      "en": "Write a ruby function `def sort_patients(patient_info)` to solve the following problem:\nSorts a list of patient information based on their age and registration order.\nThe function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\nThe sorting criteria are as follows:\n1. Patients aged 60 and above are given priority over younger patients.\n2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n3. Younger patients (below 60) are sorted based on their registration order.\n\nExample:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "es": "Escribe una función en ruby `def sort_patients(patient_info)` para resolver el siguiente problema:\nOrdena una lista de información de pacientes basada en su edad y orden de registro.\nLa función toma un array de arrays, donde cada sub-array contiene el ID de un paciente (una cadena) y la edad (un entero).\nLos criterios de ordenación son los siguientes:\n1. Los pacientes de 60 años o más tienen prioridad sobre los pacientes más jóvenes.\n2. Los pacientes ancianos (de 60 años o más) se ordenan en orden descendente de edad. Si las edades son iguales, se ordenan por su orden de registro.\n3. Los pacientes más jóvenes (menores de 60 años) se ordenan según su orden de registro.\n\nEjemplo:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "arb": "اكتب دالة روبي `def sort_patients(patient_info)` لحل المشكلة التالية:\nترتيب قائمة معلومات المرضى بناءً على أعمارهم وترتيب تسجيلهم.\nتأخذ الدالة مصفوفة من المصفوفات، حيث تحتوي كل مصفوفة فرعية على معرف المريض (سلسلة نصية) والعمر (عدد صحيح).\nمعايير الترتيب كالتالي:\n1. يُعطى المرضى الذين تبلغ أعمارهم 60 عامًا فما فوق الأولوية على المرضى الأصغر سنًا.\n2. يتم ترتيب المرضى المسنين (الذين تبلغ أعمارهم 60 عامًا فما فوق) بترتيب تنازلي حسب العمر. إذا كانت الأعمار متساوية، يتم ترتيبهم حسب ترتيب تسجيلهم.\n3. يتم ترتيب المرضى الأصغر سنًا (أقل من 60 عامًا) بناءً على ترتيب تسجيلهم.\n\nمثال:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "sw": "Andika kazi ya ruby `def sort_patients(patient_info)` kutatua tatizo lifuatalo:\nPanga orodha ya taarifa za wagonjwa kulingana na umri wao na mpangilio wa usajili.\nKazi inachukua safu ya safu, ambapo kila safu ndogo ina kitambulisho cha mgonjwa (kamba) na umri (nambari kamili).\nVigezo vya upangaji ni kama ifuatavyo:\n1. Wagonjwa wenye umri wa miaka 60 na zaidi wanapewa kipaumbele kuliko wagonjwa vijana.\n2. Wagonjwa wazee (wenye umri wa miaka 60+) wanapangwa kwa mpangilio wa kushuka kwa umri. Ikiwa umri ni sawa, wanapangwa kwa mpangilio wa usajili.\n3. Wagonjwa vijana (chini ya miaka 60) wanapangwa kulingana na mpangilio wa usajili wao.\n\nMfano:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "tr": "Bir ruby fonksiyonu `def sort_patients(patient_info)` yazın ve aşağıdaki problemi çözün:\nHasta bilgilerini yaşlarına ve kayıt sıralarına göre sıralar.\nFonksiyon, her alt dizinin bir hastanın kimliğini (bir string) ve yaşını (bir tamsayı) içerdiği dizilerden oluşan bir dizi alır.\nSıralama kriterleri aşağıdaki gibidir:\n1. 60 yaş ve üzeri hastalar, daha genç hastalara göre önceliklidir.\n2. Yaşlı hastalar (60+ yaş) yaşlarına göre azalan sırayla sıralanır. Yaşlar eşitse, kayıt sıralarına göre sıralanırlar.\n3. Daha genç hastalar (60 yaş altı), kayıt sıralarına göre sıralanır.\n\nÖrnek:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "vi": "Viết một hàm ruby `def sort_patients(patient_info)` để giải quyết vấn đề sau:\nSắp xếp danh sách thông tin bệnh nhân dựa trên tuổi và thứ tự đăng ký của họ.\nHàm nhận một mảng các mảng, trong đó mỗi mảng con chứa ID của bệnh nhân (một chuỗi) và tuổi (một số nguyên).\nTiêu chí sắp xếp như sau:\n1. Bệnh nhân từ 60 tuổi trở lên được ưu tiên hơn bệnh nhân trẻ hơn.\n2. Bệnh nhân cao tuổi (từ 60 tuổi trở lên) được sắp xếp theo thứ tự giảm dần của tuổi. Nếu tuổi bằng nhau, họ được sắp xếp theo thứ tự đăng ký.\n3. Bệnh nhân trẻ hơn (dưới 60 tuổi) được sắp xếp dựa trên thứ tự đăng ký của họ.\n\nVí dụ:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]"
    },
    "instruction_bertscore": {
      "es": "0.9781178840732916",
      "arb": "0.9811497782094081",
      "sw": "0.9674486517863835",
      "tr": "0.9604463349637606",
      "vi": "0.9807249078243745"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]]) == [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\nraise 'Test failed' unless sort_patients([[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]) == [[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]\nraise 'Test failed' unless sort_patients([[\"987654\", 45], [\"123456\", 65], [\"543210\", 55]]) == [[\"123456\", 65], [\"987654\", 45], [\"543210\", 55]]\n\n\n\nputs 'All tests passed!'",
    "entry_point": "sort_patients",
    "signature": "def sort_patients(patient_info)",
    "docstring": {
      "en": "Sorts a list of patient information based on their age and registration order.\nThe function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\nThe sorting criteria are as follows:\n1. Patients aged 60 and above are given priority over younger patients.\n2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n3. Younger patients (below 60) are sorted based on their registration order.\n\nExample:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "es": "Ordena una lista de información de pacientes basada en su edad y orden de registro.  \nLa función toma un array de arrays, donde cada sub-array contiene el ID de un paciente (una cadena) y la edad (un entero).  \nLos criterios de ordenación son los siguientes:  \n1. Se da prioridad a los pacientes de 60 años o más sobre los pacientes más jóvenes.  \n2. Los pacientes ancianos (de 60 años o más) se ordenan en orden descendente de edad. Si las edades son iguales, se ordenan por su orden de registro.  \n3. Los pacientes más jóvenes (menores de 60 años) se ordenan según su orden de registro.  \n\nEjemplo:  \n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])  \n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]  ",
      "arb": "يقوم بترتيب قائمة بمعلومات المرضى بناءً على أعمارهم وترتيب تسجيلهم.\nتأخذ الدالة مصفوفة من المصفوفات، حيث تحتوي كل مصفوفة فرعية على معرف المريض (سلسلة نصية) والعمر (عدد صحيح).\nمعايير الترتيب كالتالي:\n1. المرضى الذين تبلغ أعمارهم 60 عامًا فأكثر يُعطون أولوية على المرضى الأصغر سنًا.\n2. يتم ترتيب المرضى المسنين (الذين تبلغ أعمارهم 60 عامًا فأكثر) بترتيب تنازلي حسب العمر. إذا كانت الأعمار متساوية، يتم ترتيبهم حسب ترتيب تسجيلهم.\n3. يتم ترتيب المرضى الأصغر سنًا (أقل من 60 عامًا) بناءً على ترتيب تسجيلهم.\n\nمثال:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "sw": "Hupanga orodha ya taarifa za wagonjwa kulingana na umri wao na mpangilio wa usajili.\nKazi inachukua safu ya safu, ambapo kila safu ndogo ina kitambulisho cha mgonjwa (kamba) na umri (nambari kamili).\nVigezo vya upangaji ni kama ifuatavyo:\n1. Wagonjwa wenye umri wa miaka 60 na zaidi wanapewa kipaumbele kuliko wagonjwa wadogo.\n2. Wagonjwa wazee (wenye umri wa miaka 60+) wanapangwa kwa mpangilio wa kushuka kwa umri. Ikiwa umri ni sawa, wanapangwa kwa mpangilio wa usajili wao.\n3. Wagonjwa wadogo (chini ya miaka 60) wanapangwa kulingana na mpangilio wa usajili wao.\n\nMfano:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "tr": "Yaşlarına ve kayıt sıralarına göre hasta bilgilerini sıralar.\nFonksiyon, her alt dizinin bir hastanın kimliğini (bir dize) ve yaşını (bir tamsayı) içerdiği bir dizi dizisi alır.\nSıralama kriterleri aşağıdaki gibidir:\n1. 60 yaş ve üzeri hastalar, daha genç hastalara göre önceliklidir.\n2. Yaşlı hastalar (60+ yaş) yaşlarına göre azalan sırada sıralanır. Eğer yaşlar eşitse, kayıt sıralarına göre sıralanırlar.\n3. Daha genç hastalar (60 yaş altı) kayıt sıralarına göre sıralanır.\n\nÖrnek:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "vi": "Sắp xếp danh sách thông tin bệnh nhân dựa trên tuổi và thứ tự đăng ký của họ. Hàm nhận một mảng các mảng, trong đó mỗi mảng con chứa ID của bệnh nhân (một chuỗi) và tuổi (một số nguyên). Tiêu chí sắp xếp như sau:\n1. Bệnh nhân từ 60 tuổi trở lên được ưu tiên hơn so với bệnh nhân trẻ hơn.\n2. Bệnh nhân cao tuổi (từ 60 tuổi trở lên) được sắp xếp theo thứ tự giảm dần của tuổi. Nếu tuổi bằng nhau, họ được sắp xếp theo thứ tự đăng ký.\n3. Bệnh nhân trẻ hơn (dưới 60 tuổi) được sắp xếp dựa trên thứ tự đăng ký của họ.\n\nVí dụ:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]"
    },
    "docstring_bertscore": {
      "es": "0.9753730108377704",
      "arb": "0.9754896068714379",
      "sw": "0.9676399328433202",
      "tr": "0.9627621665762464",
      "vi": "0.9817816214514801"
    }
  },
  {
    "task_id": "Ruby/20",
    "prompt": {
      "en": "# Finds the intersection point of two linear functions.\n# This function takes four arguments: slope1, intercept1, slope2, intercept2.\n# slope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.\n# The function calculates and returns the coordinates of the intersection point of these two lines, if it exists.\n# The coordinates are returned as a two-element array [x, y], rounded to two decimal places.\n#\n# Example:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Parallel lines with no intersection\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "es": "# Encuentra el punto de intersección de dos funciones lineales.\n# Esta función toma cuatro argumentos: slope1, intercept1, slope2, intercept2.\n# slope1 y slope2 son las pendientes de las dos líneas, mientras que intercept1 e intercept2 son sus intersecciones con el eje y.\n# La función calcula y devuelve las coordenadas del punto de intersección de estas dos líneas, si existe.\n# Las coordenadas se devuelven como un arreglo de dos elementos [x, y], redondeado a dos decimales.\n#\n# Ejemplo:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Líneas paralelas sin intersección\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "arb": "# يجد نقطة التقاطع بين دالتين خطيتين.\n# تأخذ هذه الدالة أربعة معطيات: slope1, intercept1, slope2, intercept2.\n# slope1 و slope2 هما ميل الخطين، بينما intercept1 و intercept2 هما تقاطعهم مع المحور y.\n# تقوم الدالة بحساب وإرجاع إحداثيات نقطة التقاطع بين هذين الخطين، إذا كانت موجودة.\n# يتم إرجاع الإحداثيات كمصفوفة تحتوي على عنصرين [x, y]، مقربة إلى منزلتين عشريتين.\n#\n# مثال:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # خطوط متوازية بدون تقاطع\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "sw": "# Inapata sehemu ya kukutana ya mistari miwili ya mstari.\n# Kazi hii inachukua hoja nne: slope1, intercept1, slope2, intercept2.\n# slope1 na slope2 ni miteremko ya mistari miwili, wakati intercept1 na intercept2 ni sehemu zao za kukatiza y.\n# Kazi hii inahesabu na kurudisha kuratibu za sehemu ya kukutana ya mistari hii miwili, ikiwa ipo.\n# Kuratibu zinarudishwa kama safu ya vipengele viwili [x, y], iliyozungushwa hadi sehemu mbili za desimali.\n#\n# Mfano:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Mistari inayolingana bila sehemu ya kukutana\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "tr": "# İki doğrusal fonksiyonun kesişim noktasını bulur.\n# Bu fonksiyon dört argüman alır: slope1, intercept1, slope2, intercept2.\n# slope1 ve slope2, iki doğrunun eğimleri iken, intercept1 ve intercept2 onların y-kesim noktalarıdır.\n# Fonksiyon, bu iki doğrunun kesişim noktasının koordinatlarını hesaplar ve döndürür, eğer varsa.\n# Koordinatlar, iki elemanlı bir dizi [x, y] olarak döndürülür ve iki ondalık basamağa yuvarlanır.\n#\n# Örnek:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Kesişim noktası olmayan paralel doğrular\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "vi": "# Tìm điểm giao của hai hàm số tuyến tính.\n# Hàm này nhận bốn tham số: slope1, intercept1, slope2, intercept2.\n# slope1 và slope2 là độ dốc của hai đường thẳng, trong khi intercept1 và intercept2 là các giao điểm y của chúng.\n# Hàm tính toán và trả về tọa độ của điểm giao của hai đường thẳng này, nếu nó tồn tại.\n# Tọa độ được trả về dưới dạng một mảng hai phần tử [x, y], làm tròn đến hai chữ số thập phân.\n#\n# Ví dụ:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Các đường thẳng song song không có điểm giao\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)"
    },
    "prompt_bertscore": {
      "es": "0.9954424259071545",
      "arb": "0.9836040551974752",
      "sw": "0.9838273157457583",
      "tr": "0.9860251609119094",
      "vi": "0.9808585860708109"
    },
    "canonical_solution": "    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end",
    "instruction": {
      "en": "Write a ruby function `def find_intersection(slope1, intercept1, slope2, intercept2)` to solve the following problem:\nFinds the intersection point of two linear functions.\nThis function takes four arguments: slope1, intercept1, slope2, intercept2.\nslope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.\nThe function calculates and returns the coordinates of the intersection point of these two lines, if it exists.\nThe coordinates are returned as a two-element array [x, y], rounded to two decimal places.\n\nExample:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Parallel lines with no intersection",
      "es": "Escribe una función en Ruby `def find_intersection(slope1, intercept1, slope2, intercept2)` para resolver el siguiente problema:\nEncuentra el punto de intersección de dos funciones lineales.\nEsta función toma cuatro argumentos: slope1, intercept1, slope2, intercept2.\nslope1 y slope2 son las pendientes de las dos líneas, mientras que intercept1 e intercept2 son sus intersecciones con el eje y.\nLa función calcula y devuelve las coordenadas del punto de intersección de estas dos líneas, si existe.\nLas coordenadas se devuelven como un arreglo de dos elementos [x, y], redondeadas a dos decimales.\n\nEjemplo:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Líneas paralelas sin intersección",
      "arb": "اكتب دالة روبي `def find_intersection(slope1, intercept1, slope2, intercept2)` لحل المشكلة التالية:\nتجد نقطة التقاطع بين دالتين خطيتين.\nتأخذ هذه الدالة أربعة معطيات: slope1, intercept1, slope2, intercept2.\nslope1 و slope2 هما ميل الخطين، بينما intercept1 و intercept2 هما تقاطعهما مع المحور y.\nتحسب الدالة وتعيد إحداثيات نقطة التقاطع بين هذين الخطين، إذا كانت موجودة.\nتُعاد الإحداثيات كمصفوفة تحتوي على عنصرين [x, y]، مقربة إلى منزلتين عشريتين.\n\nمثال:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  خطوط متوازية بدون تقاطع",
      "sw": "Andika kazi ya ruby `def find_intersection(slope1, intercept1, slope2, intercept2)` kutatua tatizo lifuatalo:\nInapata nukta ya makutano ya kazi mbili za mstari.\nKazi hii inachukua hoja nne: slope1, intercept1, slope2, intercept2.\nslope1 na slope2 ni miteremko ya mistari miwili, wakati intercept1 na intercept2 ni sehemu zao za kukatiza y.\nKazi hii inahesabu na kurudisha kuratibu za nukta ya makutano ya mistari hii miwili, ikiwa ipo.\nKuratibu zinarudishwa kama safu ya vipengele viwili [x, y], vilivyokaribishwa hadi sehemu mbili za desimali.\n\nMfano:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Mistari sambamba bila makutano",
      "tr": "Bir ruby fonksiyonu `def find_intersection(slope1, intercept1, slope2, intercept2)` yazarak aşağıdaki problemi çözün:\nİki doğrusal fonksiyonun kesişim noktasını bulur.\nBu fonksiyon dört argüman alır: slope1, intercept1, slope2, intercept2.\nslope1 ve slope2, iki doğrunun eğimleri iken, intercept1 ve intercept2 onların y-kesim noktalarıdır.\nFonksiyon, bu iki doğrunun kesişim noktasının koordinatlarını hesaplar ve döndürür, eğer varsa.\nKoordinatlar, iki elemanlı bir dizi [x, y] olarak, iki ondalık basamağa yuvarlanmış şekilde döndürülür.\n\nÖrnek:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Paralel doğrular, kesişim yok",
      "vi": "Viết một hàm ruby `def find_intersection(slope1, intercept1, slope2, intercept2)` để giải quyết vấn đề sau:\nTìm điểm giao nhau của hai hàm số tuyến tính.\nHàm này nhận bốn tham số: slope1, intercept1, slope2, intercept2.\nslope1 và slope2 là độ dốc của hai đường thẳng, trong khi intercept1 và intercept2 là các giao điểm y của chúng.\nHàm tính toán và trả về tọa độ của điểm giao nhau của hai đường thẳng này, nếu nó tồn tại.\nTọa độ được trả về dưới dạng một mảng hai phần tử [x, y], làm tròn đến hai chữ số thập phân.\n\nVí dụ:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Các đường thẳng song song không có giao điểm"
    },
    "instruction_bertscore": {
      "es": "0.9930799161551255",
      "arb": "0.9780930552756621",
      "sw": "0.9938253759751494",
      "tr": "0.986182476173689",
      "vi": "0.9824138619543141"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless find_intersection(1.0, 0.0, -1.0, 2.0) == [1.00, 1.00]\nraise 'Test failed' unless find_intersection(2.0, 3.0, 2.0, -1.0).nil?\nraise 'Test failed' unless find_intersection(0.5, 1.0, -0.5, -1.0) == [-2.00, 0.00]\nraise 'Test failed' unless find_intersection(3.0, 2.0, -1.0, 4.0) == [0.50, 3.50]\nraise 'Test failed' unless find_intersection(2.0, 0.0, 0.0, 2.0) == [1.0, 2.0]\n  \n\nputs 'All tests passed!'",
    "entry_point": "find_intersection",
    "signature": "def find_intersection(slope1, intercept1, slope2, intercept2)",
    "docstring": {
      "en": "Finds the intersection point of two linear functions.\nThis function takes four arguments: slope1, intercept1, slope2, intercept2.\nslope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.\nThe function calculates and returns the coordinates of the intersection point of these two lines, if it exists.\nThe coordinates are returned as a two-element array [x, y], rounded to two decimal places.\n\nExample:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Parallel lines with no intersection",
      "es": "Encuentra el punto de intersección de dos funciones lineales.  \nEsta función toma cuatro argumentos: slope1, intercept1, slope2, intercept2.  \nslope1 y slope2 son las pendientes de las dos líneas, mientras que intercept1 e intercept2 son sus intersecciones con el eje y.  \nLa función calcula y devuelve las coordenadas del punto de intersección de estas dos líneas, si existe.  \nLas coordenadas se devuelven como un arreglo de dos elementos [x, y], redondeado a dos decimales.  \n\nEjemplo:  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Líneas paralelas sin intersección",
      "arb": "يجد نقطة التقاطع بين دالتين خطيتين.  \nتأخذ هذه الدالة أربعة معطيات: slope1، intercept1، slope2، intercept2.  \nslope1 و slope2 هما ميل الخطين، بينما intercept1 و intercept2 هما تقاطعهما مع المحور y.  \nتحسب الدالة وتعيد إحداثيات نقطة التقاطع لهذين الخطين، إذا كانت موجودة.  \nتُعاد الإحداثيات كمصفوفة تحتوي على عنصرين [x, y]، مقربة إلى منزلتين عشريتين.\n\nمثال:  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  خطوط متوازية بدون تقاطع  ",
      "sw": "Inapata sehemu ya kukutana ya mistari miwili ya laini.\nKazi hii inachukua hoja nne: slope1, intercept1, slope2, intercept2.\nslope1 na slope2 ni miteremko ya mistari miwili, wakati intercept1 na intercept2 ni sehemu zao za kukatiza kwenye mhimili wa y.\nKazi hii inahesabu na kurudisha kuratibu za sehemu ya kukutana ya mistari hii miwili, ikiwa ipo.\nKuratibu zinarudishwa kama safu yenye vipengele viwili [x, y], vilivyopunguzwa hadi sehemu mbili za desimali.\n\nMfano:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Mistari inayofanana bila sehemu ya kukutana",
      "tr": "İki doğrusal fonksiyonun kesişim noktasını bulur.  \nBu fonksiyon dört argüman alır: slope1, intercept1, slope2, intercept2.  \nslope1 ve slope2 iki doğrunun eğimleri, intercept1 ve intercept2 ise bunların y-kesim noktalarıdır.  \nFonksiyon, bu iki doğrunun kesişim noktasının koordinatlarını hesaplar ve döndürür, eğer varsa.  \nKoordinatlar, iki elemanlı bir dizi [x, y] olarak döndürülür ve iki ondalık basamağa yuvarlanır.  \n\nÖrnek:  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Kesişim olmayan paralel doğrular  ",
      "vi": "Tìm điểm giao nhau của hai hàm tuyến tính.  \nHàm này nhận bốn đối số: slope1, intercept1, slope2, intercept2.  \nslope1 và slope2 là độ dốc của hai đường thẳng, trong khi intercept1 và intercept2 là các giao điểm y của chúng.  \nHàm tính toán và trả về tọa độ của điểm giao nhau của hai đường thẳng này, nếu nó tồn tại.  \nTọa độ được trả về dưới dạng một mảng hai phần tử [x, y], làm tròn đến hai chữ số thập phân.  \n\nVí dụ:  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Các đường thẳng song song không có điểm giao nhau  "
    },
    "docstring_bertscore": {
      "es": "0.991192331644151",
      "arb": "0.9875981148993247",
      "sw": "0.97314457659294",
      "tr": "0.9835106989183887",
      "vi": "0.9780298908144931"
    }
  },
  {
    "task_id": "Ruby/21",
    "prompt": {
      "en": "# This method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\n# The function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n#\n# Examples:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "es": "# Este método calcula el número mínimo de pasos necesarios para transformar un número dado en un palíndromo invirtiendo repetidamente sus dígitos y sumando el resultado al número original. El proceso se detiene cuando se obtiene un palíndromo. Si el palíndromo no se obtiene dentro de 8 pasos, el método devuelve 0.\n# La función toma un solo argumento, m, que es un número entero positivo entre 12 y 100, y devuelve el número de pasos necesarios para alcanzar un palíndromo. El número de entrada m no es un palíndromo.\n#\n# Ejemplos:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "arb": "# تقوم هذه الطريقة بحساب الحد الأدنى لعدد الخطوات المطلوبة لتحويل رقم معين إلى عدد متناظر عن طريق عكس أرقامه بشكل متكرر وإضافة النتيجة إلى الرقم الأصلي. يتم إيقاف العملية عندما يتم الحصول على عدد متناظر. إذا لم يتم الحصول على عدد متناظر في غضون 8 خطوات، فإن الطريقة تعيد 0.\n# تأخذ الدالة وسيطًا واحدًا، m، وهو عدد صحيح موجب بين 12 و100، وتعيد عدد الخطوات التي تم اتخاذها للوصول إلى عدد متناظر. الرقم المدخل m نفسه ليس عددًا متناظرًا.\n#\n# أمثلة:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "sw": "# Njia hii huhesabu idadi ndogo ya hatua zinazohitajika kubadilisha nambari iliyotolewa kuwa palindromu kwa kurudia kugeuza tarakimu zake na kuongeza matokeo kwenye nambari ya awali. Mchakato unakoma palindromu inapopatikana. Ikiwa palindromu haipatikani ndani ya hatua 8, njia inarejesha 0.\n# Kazi inachukua hoja moja, m, ambayo ni nambari kamili chanya kati ya 12 na 100, na inarejesha idadi ya hatua zilizochukuliwa kufikia palindromu. Nambari ya ingizo m yenyewe si palindromu.\n#\n# Mifano:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "tr": "# Bu yöntem, bir sayıyı ters çevirip elde edilen sonucu orijinal sayıya ekleyerek bir palindrom oluşturmak için gereken minimum adım sayısını hesaplar. İşlem, bir palindrom elde edildiğinde durdurulur. Eğer palindrom 8 adım içinde elde edilmezse, yöntem 0 döndürür.\n# Fonksiyon, 12 ile 100 arasında pozitif bir tamsayı olan m adlı tek bir argüman alır ve bir palindroma ulaşmak için alınan adım sayısını döndürür. Girdi sayısı m, kendisi bir palindrom değildir.\n#\n# Örnekler:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "vi": "# Phương thức này tính toán số bước tối thiểu cần thiết để biến đổi một số đã cho thành một số palindrome bằng cách liên tục đảo ngược các chữ số của nó và cộng kết quả vào số ban đầu. Quá trình dừng lại khi đạt được một số palindrome. Nếu không đạt được số palindrome trong vòng 8 bước, phương thức trả về 0.\n# Hàm nhận một đối số duy nhất, m, là một số nguyên dương nằm trong khoảng từ 12 đến 100, và trả về số bước đã thực hiện để đạt được một số palindrome. Bản thân số đầu vào m không phải là một số palindrome.\n#\n# Ví dụ:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)"
    },
    "prompt_bertscore": {
      "es": "0.9886468833111889",
      "arb": "0.9901119810017023",
      "sw": "0.9901119810017023",
      "tr": "0.9637173800786432",
      "vi": "0.9733644604247457"
    },
    "canonical_solution": "  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend",
    "instruction": {
      "en": "Write a ruby function `def palindrome_sum_steps(m)` to solve the following problem:\nThis method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\nThe function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n\nExamples:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "es": "Escribe una función de Ruby `def palindrome_sum_steps(m)` para resolver el siguiente problema:\nEste método calcula el número mínimo de pasos necesarios para transformar un número dado en un palíndromo invirtiendo repetidamente sus dígitos y sumando el resultado al número original. El proceso se detiene cuando se obtiene un palíndromo. Si el palíndromo no se obtiene en 8 pasos, el método devuelve 0.\nLa función toma un solo argumento, m, que es un entero positivo entre 12 y 100, y devuelve el número de pasos necesarios para alcanzar un palíndromo. El número de entrada m en sí mismo no es un palíndromo.\n\nEjemplos:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "arb": "اكتب دالة روبي `def palindrome_sum_steps(m)` لحل المشكلة التالية:\nتحسب هذه الطريقة الحد الأدنى من الخطوات المطلوبة لتحويل رقم معين إلى عدد متناظر عن طريق عكس أرقامه بشكل متكرر وإضافة النتيجة إلى الرقم الأصلي. يتم إيقاف العملية عند الحصول على عدد متناظر. إذا لم يتم الحصول على عدد متناظر في غضون 8 خطوات، تعيد الطريقة 0.\nتأخذ الدالة وسيطًا واحدًا، m، وهو عدد صحيح موجب بين 12 و 100، وتعيد عدد الخطوات المتخذة للوصول إلى عدد متناظر. الرقم المدخل m نفسه ليس عددًا متناظرًا.\n\nأمثلة:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "sw": "Andika kazi ya ruby `def palindrome_sum_steps(m)` kutatua tatizo lifuatalo:\nNjia hii inahesabu idadi ndogo ya hatua zinazohitajika kubadilisha nambari iliyotolewa kuwa palindrome kwa kurudia kurudisha nambari zake na kuongeza matokeo kwenye nambari ya awali. Mchakato unakomeshwa wakati palindrome inapatikana. Ikiwa palindrome haipatikani ndani ya hatua 8, njia inarudisha 0.\nKazi inachukua hoja moja, m, ambayo ni nambari nzima chanya kati ya 12 na 100, na inarudisha idadi ya hatua zilizochukuliwa kufikia palindrome. Nambari ya ingizo m yenyewe si palindrome.\n\nMifano:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "tr": "Bir ruby fonksiyonu `def palindrome_sum_steps(m)` yazın ve aşağıdaki problemi çözün:\nBu yöntem, bir sayıyı ters çevirip elde edilen sonucu orijinal sayıya ekleyerek bir palindrom haline getirmek için gereken minimum adım sayısını hesaplar. İşlem, bir palindrom elde edildiğinde durdurulur. Eğer palindrom 8 adım içinde elde edilmezse, yöntem 0 döndürür.\nFonksiyon, 12 ile 100 arasında pozitif bir tam sayı olan m adlı tek bir argüman alır ve bir palindroma ulaşmak için alınan adım sayısını döndürür. Girdi sayısı m, kendisi bir palindrom değildir.\n\nÖrnekler:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "vi": "Viết một hàm ruby `def palindrome_sum_steps(m)` để giải quyết vấn đề sau:  \nPhương thức này tính toán số bước tối thiểu cần thiết để biến đổi một số cho trước thành một số palindrome bằng cách liên tục đảo ngược các chữ số của nó và cộng kết quả vào số gốc. Quá trình dừng lại khi đạt được một số palindrome. Nếu không đạt được số palindrome trong vòng 8 bước, phương thức trả về 0.  \nHàm nhận một đối số duy nhất, m, là một số nguyên dương nằm trong khoảng từ 12 đến 100, và trả về số bước cần thiết để đạt được một số palindrome. Bản thân số đầu vào m không phải là một số palindrome.\n\nVí dụ:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0"
    },
    "instruction_bertscore": {
      "es": "0.98921139085409",
      "arb": "0.9895107268383097",
      "sw": "0.9917848460707781",
      "tr": "0.9665462739653421",
      "vi": "0.964792566331185"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless palindrome_sum_steps(12) == 1\nraise 'Test failed' unless palindrome_sum_steps(87) == 4\nraise 'Test failed' unless palindrome_sum_steps(89) == 0\nraise 'Test failed' unless palindrome_sum_steps(56) == 1\nraise 'Test failed' unless palindrome_sum_steps(95) == 3\n\nputs 'All tests passed!'",
    "entry_point": "palindrome_sum_steps",
    "signature": "def palindrome_sum_steps(m)",
    "docstring": {
      "en": "This method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\nThe function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n\nExamples:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "es": "Este método calcula el número mínimo de pasos necesarios para transformar un número dado en un palíndromo invirtiendo repetidamente sus dígitos y sumando el resultado al número original. El proceso se detiene cuando se obtiene un palíndromo. Si el palíndromo no se obtiene dentro de 8 pasos, el método devuelve 0. \n\nLa función toma un único argumento, m, que es un número entero positivo entre 12 y 100, y devuelve el número de pasos necesarios para alcanzar un palíndromo. El número de entrada m en sí mismo no es un palíndromo.\n\nEjemplos:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "arb": "هذه الطريقة تحسب الحد الأدنى لعدد الخطوات المطلوبة لتحويل رقم معين إلى عدد متناظر عن طريق عكس أرقامه بشكل متكرر وإضافة النتيجة إلى الرقم الأصلي. تتوقف العملية عندما يتم الحصول على عدد متناظر. إذا لم يتم الحصول على عدد متناظر في غضون 8 خطوات، فإن الطريقة تُرجع 0. \n\nيعيدالحجج:\n    m: عدد صحيح موجب بين 12 و 100.\n\nيعيد:\n    عدد الخطوات المتخذة للوصول إلى عدد متناظر. الرقم المدخل m نفسه ليس عددًا متناظرًا.\n\nأمثلة:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "sw": "Njia hii inahesabu idadi ndogo ya hatua zinazohitajika kubadilisha nambari iliyotolewa kuwa palindromu kwa kurudia kugeuza tarakimu zake na kuongeza matokeo kwenye nambari ya awali. Mchakato unakomeshwa palindromu inapatikana. Ikiwa palindromu haipatikani ndani ya hatua 8, njia inarudisha 0.\n\nHoja:\n    m: Nambari nzima chanya kati ya 12 na 100.\n\nInarejesha:\n    Idadi ya hatua zilizochukuliwa kufikia palindromu.\n\nMifano:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "tr": "Bu yöntem, bir sayının rakamlarını ters çevirip sonucu orijinal sayıya ekleyerek sayıyı bir palindroma dönüştürmek için gereken minimum adım sayısını hesaplar. İşlem, bir palindrom elde edildiğinde durdurulur. Eğer palindrom 8 adım içinde elde edilmezse, yöntem 0 döndürür.\nFonksiyon, 12 ile 100 arasında pozitif bir tamsayı olan m adlı tek bir argüman alır ve bir palindroma ulaşmak için alınan adım sayısını döndürür. Girdi sayısı m kendisi bir palindrom değildir.\n\nÖrnekler:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "vi": "Phương thức này tính toán số bước tối thiểu cần thiết để biến một số cho trước thành một số palindrome bằng cách liên tục đảo ngược các chữ số của nó và cộng kết quả vào số ban đầu. Quá trình dừng lại khi đạt được một số palindrome. Nếu không đạt được số palindrome trong vòng 8 bước, phương thức trả về 0. \n\nHàm nhận một đối số duy nhất, m, là một số nguyên dương nằm trong khoảng từ 12 đến 100, và trả về số bước thực hiện để đạt được một số palindrome. Bản thân số đầu vào m không phải là một số palindrome.\n\nVí dụ:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0"
    },
    "docstring_bertscore": {
      "es": "0.9921070245488166",
      "arb": "0.9513975293253353",
      "sw": "0.9238502763011308",
      "tr": "0.9808103188882195",
      "vi": "0.9670517882850759"
    }
  },
  {
    "task_id": "Ruby/22",
    "prompt": {
      "en": "# This function calculates the number of different prime pairs whose sum equals a given even number.\n# The function accepts a single argument, even_number, which is an even number greater than 6 and less than 32767.\n# It returns the count of distinct prime pairs whose sum equals the given even number.\n# A prime pair is considered distinct if the primes in the pair are different, regardless of their order.\n#\n# Example:\n# >>> count_prime_pairs(10)\n# 2 (since 10 can be expressed as 3+7 and 5+5)\n# >>> count_prime_pairs(14)\n# 2 (since 14 can be expressed as 3+11 and 7+7)\n \ndef count_prime_pairs(even_number)",
      "es": "# Esta función calcula el número de diferentes pares de primos cuya suma es igual a un número par dado.\n# La función acepta un solo argumento, even_number, que es un número par mayor que 6 y menor que 32767.\n# Devuelve el conteo de pares de primos distintos cuya suma es igual al número par dado.\n# Se considera que un par de primos es distinto si los primos en el par son diferentes, independientemente de su orden.\n#\n# Ejemplo:\n# >>> count_prime_pairs(10)\n# 2 (ya que 10 puede expresarse como 3+7 y 5+5)\n# >>> count_prime_pairs(14)\n# 2 (ya que 14 puede expresarse como 3+11 y 7+7)\n\ndef count_prime_pairs(even_number)",
      "arb": "# تقوم هذه الدالة بحساب عدد أزواج الأعداد الأولية المختلفة التي يكون مجموعها مساوياً لعدد زوجي معين.\n# تقبل الدالة وسيطاً واحداً، even_number، وهو عدد زوجي أكبر من 6 وأقل من 32767.\n# تُرجع عدد أزواج الأعداد الأولية المميزة التي يكون مجموعها مساوياً للعدد الزوجي المعطى.\n# يُعتبر زوج الأعداد الأولية مميزاً إذا كانت الأعداد الأولية في الزوج مختلفة، بغض النظر عن ترتيبها.\n#\n# مثال:\n# >>> count_prime_pairs(10)\n# 2 (لأن 10 يمكن التعبير عنه كـ 3+7 و 5+5)\n# >>> count_prime_pairs(14)\n# 2 (لأن 14 يمكن التعبير عنه كـ 3+11 و 7+7)\n\ndef count_prime_pairs(even_number)",
      "sw": "# Kazi ya hii kazi ni kuhesabu idadi ya jozi tofauti za nambari za msingi ambazo jumla yao ni sawa na nambari fulani ya jozi.\n# Kazi hii inakubali hoja moja, even_number, ambayo ni nambari ya jozi kubwa kuliko 6 na ndogo kuliko 32767.\n# Inarudisha hesabu ya jozi tofauti za nambari za msingi ambazo jumla yao ni sawa na nambari ya jozi iliyotolewa.\n# Jozi ya msingi inachukuliwa kuwa tofauti ikiwa nambari za msingi katika jozi ni tofauti, bila kujali mpangilio wao.\n#\n# Mfano:\n# >>> count_prime_pairs(10)\n# 2 (kwa kuwa 10 inaweza kuonyeshwa kama 3+7 na 5+5)\n# >>> count_prime_pairs(14)\n# 2 (kwa kuwa 14 inaweza kuonyeshwa kama 3+11 na 7+7)\n\ndef count_prime_pairs(even_number)",
      "tr": "# Bu fonksiyon, toplamı verilen bir çift sayıya eşit olan farklı asal çiftlerin sayısını hesaplar.\n# Fonksiyon, 6'dan büyük ve 32767'den küçük bir çift sayı olan even_number adlı tek bir argüman alır.\n# Verilen çift sayıya eşit toplamı olan farklı asal çiftlerin sayısını döndürür.\n# Bir asal çift, çiftteki asal sayılar farklı olduğu sürece, sıralarından bağımsız olarak farklı kabul edilir.\n#\n# Örnek:\n# >>> count_prime_pairs(10)\n# 2 (çünkü 10, 3+7 ve 5+5 olarak ifade edilebilir)\n# >>> count_prime_pairs(14)\n# 2 (çünkü 14, 3+11 ve 7+7 olarak ifade edilebilir)",
      "vi": "# Hàm này tính số lượng cặp số nguyên tố khác nhau có tổng bằng một số chẵn đã cho.\n# Hàm chấp nhận một đối số duy nhất, even_number, là một số chẵn lớn hơn 6 và nhỏ hơn 32767.\n# Nó trả về số lượng cặp số nguyên tố khác nhau có tổng bằng số chẵn đã cho.\n# Một cặp số nguyên tố được coi là khác nhau nếu các số nguyên tố trong cặp là khác nhau, không phân biệt thứ tự.\n#\n# Ví dụ:\n# >>> count_prime_pairs(10)\n# 2 (vì 10 có thể được biểu diễn dưới dạng 3+7 và 5+5)\n# >>> count_prime_pairs(14)\n# 2 (vì 14 có thể được biểu diễn dưới dạng 3+11 và 7+7)\n\ndef count_prime_pairs(even_number)"
    },
    "prompt_bertscore": {
      "es": "0.9776467328094768",
      "arb": "0.9796380023793515",
      "sw": "0.9507120558803839",
      "tr": "0.9558446649263254",
      "vi": "0.985089214556473"
    },
    "canonical_solution": "    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n",
    "instruction": {
      "en": "Write a ruby function `def count_prime_pairs(even_number)` to solve the following problem:\nThis function calculates the number of different prime pairs whose sum equals a given even number.\nThe function accepts a single argument, even_number, which is an even number greater than 6 and less than 32767.\nIt returns the count of distinct prime pairs whose sum equals the given even number.\nA prime pair is considered distinct if the primes in the pair are different, regardless of their order.\n\nExample:\n>>> count_prime_pairs(10)\n2 (since 10 can be expressed as 3+7 and 5+5)\n>>> count_prime_pairs(14)\n2 (since 14 can be expressed as 3+11 and 7+7)",
      "es": "Escribe una función en Ruby `def count_prime_pairs(even_number)` para resolver el siguiente problema:\nEsta función calcula el número de diferentes pares de números primos cuya suma es igual a un número par dado.\nLa función acepta un solo argumento, even_number, que es un número par mayor que 6 y menor que 32767.\nDevuelve la cantidad de pares de números primos distintos cuya suma es igual al número par dado.\nUn par de números primos se considera distinto si los primos en el par son diferentes, independientemente de su orden.\n\nEjemplo:\n>>> count_prime_pairs(10)\n2 (ya que 10 se puede expresar como 3+7 y 5+5)\n>>> count_prime_pairs(14)\n2 (ya que 14 se puede expresar como 3+11 y 7+7)",
      "arb": "اكتب دالة روبي `def count_prime_pairs(even_number)` لحل المشكلة التالية:\nتحسب هذه الدالة عدد الأزواج الأولية المختلفة التي يساوي مجموعها عددًا زوجيًا معينًا.\nتقبل الدالة وسيطًا واحدًا، even_number، وهو عدد زوجي أكبر من 6 وأقل من 32767.\nتعيد عدد الأزواج الأولية المميزة التي يساوي مجموعها العدد الزوجي المعطى.\nيعتبر الزوج الأولي مميزًا إذا كانت الأعداد الأولية في الزوج مختلفة، بغض النظر عن ترتيبها.\n\nمثال:\n>>> count_prime_pairs(10)\n2 (لأن 10 يمكن التعبير عنه كـ 3+7 و 5+5)\n>>> count_prime_pairs(14)\n2 (لأن 14 يمكن التعبير عنه كـ 3+11 و 7+7)",
      "sw": "Andika kazi ya ruby `def count_prime_pairs(even_number)` kutatua tatizo lifuatalo:\nKazi hii inahesabu idadi ya jozi tofauti za nambari za kwanza ambazo jumla yake ni sawa na nambari fulani ya jozi.\nKazi inakubali hoja moja, even_number, ambayo ni nambari ya jozi kubwa kuliko 6 na ndogo kuliko 32767.\nInarudisha idadi ya jozi tofauti za nambari za kwanza ambazo jumla yake ni sawa na nambari ya jozi iliyotolewa.\nJozi ya nambari za kwanza inachukuliwa kuwa tofauti ikiwa nambari za kwanza katika jozi ni tofauti, bila kujali mpangilio wao.\n\nMfano:\n>>> count_prime_pairs(10)\n2 (kwa kuwa 10 inaweza kuonyeshwa kama 3+7 na 5+5)\n>>> count_prime_pairs(14)\n2 (kwa kuwa 14 inaweza kuonyeshwa kama 3+11 na 7+7)",
      "tr": "Bir ruby fonksiyonu `def count_prime_pairs(even_number)` yazın:\nBu fonksiyon, toplamı verilen bir çift sayıya eşit olan farklı asal çiftlerin sayısını hesaplar.\nFonksiyon, 6'dan büyük ve 32767'den küçük bir çift sayı olan even_number adlı tek bir argüman alır.\nVerilen çift sayıya eşit toplamı olan farklı asal çiftlerin sayısını döndürür.\nBir asal çift, çifti oluşturan asal sayılar farklıysa, sıralarına bakılmaksızın farklı kabul edilir.\n\nÖrnek:\n>>> count_prime_pairs(10)\n2 (çünkü 10, 3+7 ve 5+5 olarak ifade edilebilir)\n>>> count_prime_pairs(14)\n2 (çünkü 14, 3+11 ve 7+7 olarak ifade edilebilir)",
      "vi": "Viết một hàm ruby `def count_prime_pairs(even_number)` để giải quyết vấn đề sau:\nHàm này tính toán số lượng cặp số nguyên tố khác nhau có tổng bằng một số chẵn đã cho.\nHàm chấp nhận một đối số, even_number, là một số chẵn lớn hơn 6 và nhỏ hơn 32767.\nNó trả về số lượng cặp số nguyên tố khác nhau có tổng bằng số chẵn đã cho.\nMột cặp số nguyên tố được coi là khác nhau nếu các số nguyên tố trong cặp là khác nhau, không phân biệt thứ tự.\n\nVí dụ:\n>>> count_prime_pairs(10)\n2 (vì 10 có thể được biểu diễn dưới dạng 3+7 và 5+5)\n>>> count_prime_pairs(14)\n2 (vì 14 có thể được biểu diễn dưới dạng 3+11 và 7+7)"
    },
    "instruction_bertscore": {
      "es": "0.9681444540111488",
      "arb": "0.9822088754010861",
      "sw": "0.9618871997477877",
      "tr": "0.9582719281825717",
      "vi": "0.9770423005599876"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless count_prime_pairs(10) == 2\nraise 'Test failed' unless count_prime_pairs(14) == 2\nraise 'Test failed' unless count_prime_pairs(20) == 2\nraise 'Test failed' unless count_prime_pairs(26) == 3\nraise 'Test failed' unless count_prime_pairs(100) == 6\nraise 'Test failed' unless count_prime_pairs(1234) == 25\n\n\nputs 'All tests passed!'",
    "entry_point": "count_prime_pairs",
    "signature": "def count_prime_pairs(even_number)",
    "docstring": {
      "en": "This function calculates the number of different prime pairs whose sum equals a given even number.\nThe function accepts a single argument, even_number, which is an even number greater than 6 and less than 32767.\nIt returns the count of distinct prime pairs whose sum equals the given even number.\nA prime pair is considered distinct if the primes in the pair are different, regardless of their order.\n\nExample:\n>>> count_prime_pairs(10)\n2 (since 10 can be expressed as 3+7 and 5+5)\n>>> count_prime_pairs(14)\n2 (since 14 can be expressed as 3+11 and 7+7)",
      "es": "Esta función calcula el número de diferentes pares de primos cuya suma es igual a un número par dado.  \nLa función acepta un solo argumento, even_number, que es un número par mayor que 6 y menor que 32767.  \nDevuelve el conteo de pares de primos distintos cuya suma es igual al número par dado.  \nUn par de primos se considera distinto si los primos en el par son diferentes, independientemente de su orden.  \n\nEjemplo:  \n>>> count_prime_pairs(10)  \n2 (ya que 10 se puede expresar como 3+7 y 5+5)  \n>>> count_prime_pairs(14)  \n2 (ya que 14 se puede expresar como 3+11 y 7+7)",
      "arb": "هذه الدالة تحسب عدد أزواج الأعداد الأولية المختلفة التي يكون مجموعها مساوياً لعدد زوجي معين.\nتقبل الدالة وسيطاً واحداً، even_number، وهو عدد زوجي أكبر من 6 وأقل من 32767.\nتُرجع عدد أزواج الأعداد الأولية المميزة التي يكون مجموعها مساوياً للعدد الزوجي المعطى.\nيُعتبر زوج الأعداد الأولية مميزاً إذا كانت الأعداد الأولية في الزوج مختلفة، بغض النظر عن ترتيبها.\n\nمثال:\n>>> count_prime_pairs(10)\n2 (لأن 10 يمكن التعبير عنه كـ 3+7 و 5+5)\n>>> count_prime_pairs(14)\n2 (لأن 14 يمكن التعبير عنه كـ 3+11 و 7+7)",
      "sw": "Kazi ya hii kazi ni kuhesabu idadi ya jozi tofauti za nambari za msingi ambazo jumla yao ni sawa na nambari fulani ya jozi.\nKazi hii inakubali hoja moja, even_number, ambayo ni nambari ya jozi kubwa kuliko 6 na ndogo kuliko 32767.\nInarudisha hesabu ya jozi tofauti za nambari za msingi ambazo jumla yao ni sawa na nambari ya jozi iliyotolewa.\nJozi ya nambari za msingi inachukuliwa kuwa tofauti ikiwa nambari za msingi katika jozi ni tofauti, bila kujali mpangilio wao.\n\nMfano:\n>>> count_prime_pairs(10)\n2 (kwa kuwa 10 inaweza kuonyeshwa kama 3+7 na 5+5)\n>>> count_prime_pairs(14)\n2 (kwa kuwa 14 inaweza kuonyeshwa kama 3+11 na 7+7)",
      "tr": "Bu fonksiyon, toplamı verilen bir çift sayıya eşit olan farklı asal çiftlerin sayısını hesaplar.\nFonksiyon, 6'dan büyük ve 32767'den küçük bir çift sayı olan even_number adlı tek bir argüman kabul eder.\nVerilen çift sayının toplamına eşit olan farklı asal çiftlerin sayısını döndürür.\nBir asal çift, çiftteki asal sayılar farklı olduğu sürece, sıralarından bağımsız olarak farklı kabul edilir.\n\nÖrnek:\n>>> count_prime_pairs(10)\n2 (çünkü 10, 3+7 ve 5+5 olarak ifade edilebilir)\n>>> count_prime_pairs(14)\n2 (çünkü 14, 3+11 ve 7+7 olarak ifade edilebilir)",
      "vi": "Hàm này tính số cặp số nguyên tố khác nhau có tổng bằng một số chẵn đã cho.\nHàm nhận một đối số duy nhất, even_number, là một số chẵn lớn hơn 6 và nhỏ hơn 32767.\nNó trả về số lượng cặp số nguyên tố khác nhau có tổng bằng số chẵn đã cho.\nMột cặp số nguyên tố được coi là khác nhau nếu các số nguyên tố trong cặp khác nhau, không phân biệt thứ tự của chúng.\n\nVí dụ:\n>>> count_prime_pairs(10)\n2 (vì 10 có thể được biểu diễn dưới dạng 3+7 và 5+5)\n>>> count_prime_pairs(14)\n2 (vì 14 có thể được biểu diễn dưới dạng 3+11 và 7+7)"
    },
    "docstring_bertscore": {
      "es": "0.9759154704083767",
      "arb": "0.9630883176619057",
      "sw": "0.8603922394288668",
      "tr": "0.9594847652891707",
      "vi": "0.978837720574162"
    }
  },
  {
    "task_id": "Ruby/23",
    "prompt": {
      "en": "# Calculates the minimum number of character operations needed to transform one string into another.\n# The function takes two string arguments, str_a and str_b. The operations allowed are:\n# 1. Delete a character;\n# 2. Insert a character;\n# 3. Replace a character with another.\n# It returns an integer representing the minimum number of operations required to transform str_a into str_b.\n# Both strings should have a length less than 200.\n#\n# Example:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "es": "# Calcula el número mínimo de operaciones de caracteres necesarias para transformar una cadena en otra.\n# La función toma dos argumentos de cadena, str_a y str_b. Las operaciones permitidas son:\n# 1. Eliminar un carácter;\n# 2. Insertar un carácter;\n# 3. Reemplazar un carácter por otro.\n# Devuelve un entero que representa el número mínimo de operaciones requeridas para transformar str_a en str_b.\n# Ambas cadenas deben tener una longitud menor a 200.\n#\n# Ejemplo:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "arb": "# يحسب الحد الأدنى لعدد العمليات على الأحرف اللازمة لتحويل سلسلة نصية إلى أخرى.\n# تأخذ الدالة وسيطين نصيين، str_a و str_b. العمليات المسموح بها هي:\n# 1. حذف حرف؛\n# 2. إدراج حرف؛\n# 3. استبدال حرف بآخر.\n# تُرجع عددًا صحيحًا يمثل الحد الأدنى لعدد العمليات المطلوبة لتحويل str_a إلى str_b.\n# يجب أن يكون طول كلا السلسلتين أقل من 200.\n#\n# مثال:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "sw": "# Inahesabu idadi ndogo ya operesheni za herufi zinazohitajika kubadilisha kamba moja kuwa nyingine.\n# Kazi inachukua hoja mbili za kamba, str_a na str_b. Operesheni zinazokubalika ni:\n# 1. Futa herufi;\n# 2. Ingiza herufi;\n# 3. Badilisha herufi moja na nyingine.\n# Inarudisha nambari kamili inayowakilisha idadi ndogo ya operesheni zinazohitajika kubadilisha str_a kuwa str_b.\n# Kamba zote mbili zinapaswa kuwa na urefu chini ya 200.\n#\n# Mfano:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "tr": "# Bir dizeyi diğerine dönüştürmek için gereken minimum karakter işlemi sayısını hesaplar.\n# Fonksiyon iki dize argümanı alır, str_a ve str_b. İzin verilen işlemler şunlardır:\n# 1. Bir karakteri sil;\n# 2. Bir karakter ekle;\n# 3. Bir karakteri başka bir karakterle değiştir.\n# Bu, str_a'yı str_b'ye dönüştürmek için gereken minimum işlem sayısını temsil eden bir tamsayı döndürür.\n# Her iki dize de 200'den kısa bir uzunluğa sahip olmalıdır.\n#\n# Örnek:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "vi": "# Tính toán số lượng tối thiểu các thao tác ký tự cần thiết để biến đổi một chuỗi thành chuỗi khác.\n# Hàm nhận hai đối số chuỗi, str_a và str_b. Các thao tác được phép là:\n# 1. Xóa một ký tự;\n# 2. Chèn một ký tự;\n# 3. Thay thế một ký tự bằng ký tự khác.\n# Nó trả về một số nguyên đại diện cho số lượng tối thiểu các thao tác cần thiết để biến đổi str_a thành str_b.\n# Cả hai chuỗi nên có độ dài nhỏ hơn 200.\n#\n# Ví dụ:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)"
    },
    "prompt_bertscore": {
      "es": "0.990628618622774",
      "arb": "0.9869416414900044",
      "sw": "0.9883892597069867",
      "tr": "0.9885886846095456",
      "vi": "0.9917727296175349"
    },
    "canonical_solution": "    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end",
    "instruction": {
      "en": "Write a ruby function `def min_operations_to_transform(str_a, str_b)` to solve the following problem:\nCalculates the minimum number of character operations needed to transform one string into another.\nThe function takes two string arguments, str_a and str_b. The operations allowed are:\n1. Delete a character;\n2. Insert a character;\n3. Replace a character with another.\nIt returns an integer representing the minimum number of operations required to transform str_a into str_b.\nBoth strings should have a length less than 200.\n\nExample:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "es": "Escribe una función en Ruby `def min_operations_to_transform(str_a, str_b)` para resolver el siguiente problema:\nCalcula el número mínimo de operaciones de caracteres necesarias para transformar una cadena en otra.\nLa función toma dos argumentos de cadena, str_a y str_b. Las operaciones permitidas son:\n1. Eliminar un carácter;\n2. Insertar un carácter;\n3. Reemplazar un carácter por otro.\nDevuelve un entero que representa el número mínimo de operaciones necesarias para transformar str_a en str_b.\nAmbas cadenas deben tener una longitud menor a 200.\n\nEjemplo:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "arb": "اكتب دالة روبي `def min_operations_to_transform(str_a, str_b)` لحل المشكلة التالية:\nتحسب الحد الأدنى لعدد العمليات الحرفية اللازمة لتحويل سلسلة نصية إلى أخرى.\nتأخذ الدالة وسيطين نصيين، str_a و str_b. العمليات المسموح بها هي:\n1. حذف حرف;\n2. إدراج حرف;\n3. استبدال حرف بآخر.\nتعيد عددًا صحيحًا يمثل الحد الأدنى لعدد العمليات المطلوبة لتحويل str_a إلى str_b.\nيجب أن يكون طول كلا السلسلتين أقل من 200.\n\nمثال:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "sw": "Andika kazi ya ruby `def min_operations_to_transform(str_a, str_b)` kutatua tatizo lifuatalo:\nHesabu idadi ndogo ya operesheni za herufi zinazohitajika kubadilisha kamba moja kuwa nyingine.\nKazi inachukua hoja mbili za kamba, str_a na str_b. Operesheni zinazokubalika ni:\n1. Futa herufi;\n2. Ingiza herufi;\n3. Badilisha herufi moja na nyingine.\nInarudisha namba kamili inayowakilisha idadi ndogo ya operesheni zinazohitajika kubadilisha str_a kuwa str_b.\nKamba zote mbili zinapaswa kuwa na urefu chini ya 200.\n\nMfano:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "tr": "Bir ruby fonksiyonu `def min_operations_to_transform(str_a, str_b)` yazın:\nBir dizeyi başka bir dizeye dönüştürmek için gereken minimum karakter işlemi sayısını hesaplar.\nFonksiyon iki dize argümanı alır, str_a ve str_b. İzin verilen işlemler:\n1. Bir karakteri silmek;\n2. Bir karakter eklemek;\n3. Bir karakteri başka bir karakterle değiştirmek.\nFonksiyon, str_a'yı str_b'ye dönüştürmek için gereken minimum işlem sayısını temsil eden bir tamsayı döndürür.\nHer iki dize de 200'den küçük bir uzunluğa sahip olmalıdır.\n\nÖrnek:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "vi": "Viết một hàm ruby `def min_operations_to_transform(str_a, str_b)` để giải quyết vấn đề sau:\nTính toán số lượng tối thiểu các thao tác ký tự cần thiết để biến đổi một chuỗi thành chuỗi khác.\nHàm nhận hai đối số chuỗi, str_a và str_b. Các thao tác được phép là:\n1. Xóa một ký tự;\n2. Chèn một ký tự;\n3. Thay thế một ký tự bằng ký tự khác.\nHàm trả về một số nguyên đại diện cho số lượng tối thiểu các thao tác cần thiết để biến đổi str_a thành str_b.\nCả hai chuỗi nên có độ dài nhỏ hơn 200.\n\nVí dụ:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3"
    },
    "instruction_bertscore": {
      "es": "0.9870979635998789",
      "arb": "0.9835619455566957",
      "sw": "0.988830219152884",
      "tr": "0.9679269537439156",
      "vi": "0.9867475796077333"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless min_operations_to_transform(\"apple\", \"aple\") == 1\nraise 'Test failed' unless min_operations_to_transform(\"kitten\", \"sitting\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"sfdxbqw\", \"gfdgw\") == 4\nraise 'Test failed' unless min_operations_to_transform(\"horse\", \"ros\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"\", \"abc\") == 3\n\n\n\nputs 'All tests passed!'",
    "entry_point": "min_operations_to_transform",
    "signature": "def min_operations_to_transform(str_a, str_b)",
    "docstring": {
      "en": "Calculates the minimum number of character operations needed to transform one string into another.\nThe function takes two string arguments, str_a and str_b. The operations allowed are:\n1. Delete a character;\n2. Insert a character;\n3. Replace a character with another.\nIt returns an integer representing the minimum number of operations required to transform str_a into str_b.\nBoth strings should have a length less than 200.\n\nExample:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "es": "Calcula el número mínimo de operaciones de caracteres necesarias para transformar una cadena en otra.  \nLa función toma dos argumentos de cadena, str_a y str_b. Las operaciones permitidas son:  \n1. Eliminar un carácter;  \n2. Insertar un carácter;  \n3. Reemplazar un carácter por otro.  \nDevuelve un entero que representa el número mínimo de operaciones requeridas para transformar str_a en str_b.  \nAmbas cadenas deben tener una longitud menor a 200.  \n\nEjemplo:  \n>>> min_operations_to_transform(\"apple\", \"aple\")  \n1  \n>>> min_operations_to_transform(\"kitten\", \"sitting\")  \n3",
      "arb": "يحسب الحد الأدنى لعدد العمليات على الأحرف اللازمة لتحويل سلسلة نصية إلى أخرى.\nتأخذ الدالة وسيطين من السلاسل النصية، str_a و str_b. العمليات المسموح بها هي:\n1. حذف حرف؛\n2. إدراج حرف؛\n3. استبدال حرف بآخر.\nتعيد عددًا صحيحًا يمثل الحد الأدنى لعدد العمليات المطلوبة لتحويل str_a إلى str_b.\nيجب أن يكون طول كلا السلسلتين أقل من 200.\n\nمثال:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "sw": "Hesabu idadi ndogo ya operesheni za herufi zinazohitajika kubadilisha kamba moja kuwa nyingine. \nKazi inachukua hoja mbili za kamba, str_a na str_b. Operesheni zinazokubalika ni:\n1. Futa herufi;\n2. Ingiza herufi;\n3. Badilisha herufi moja na nyingine.\nInarudisha namba nzima inayowakilisha idadi ndogo ya operesheni zinazohitajika kubadilisha str_a kuwa str_b. \nKamba zote mbili zinapaswa kuwa na urefu chini ya 200.\n\nMfano:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "tr": "Bir dizeyi başka bir dizeye dönüştürmek için gereken minimum karakter işlemi sayısını hesaplar. \nFonksiyon iki dize argümanı alır, str_a ve str_b. İzin verilen işlemler şunlardır:\n1. Bir karakteri sil;\n2. Bir karakter ekle;\n3. Bir karakteri başka bir karakterle değiştir.\nFonksiyon, str_a'yı str_b'ye dönüştürmek için gereken minimum işlem sayısını temsil eden bir tam sayı döndürür. \nHer iki dizenin uzunluğu 200'den az olmalıdır.\n\nÖrnek:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "vi": "Tính toán số lượng tối thiểu các thao tác ký tự cần thiết để biến đổi một chuỗi thành chuỗi khác. Hàm này nhận hai đối số chuỗi, str_a và str_b. Các thao tác được phép là:\n1. Xóa một ký tự;\n2. Chèn một ký tự;\n3. Thay thế một ký tự bằng ký tự khác.\nHàm trả về một số nguyên đại diện cho số lượng tối thiểu các thao tác cần thiết để biến đổi str_a thành str_b. Cả hai chuỗi nên có độ dài nhỏ hơn 200.\n\nVí dụ:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3"
    },
    "docstring_bertscore": {
      "es": "0.9885356502978093",
      "arb": "0.9727185144256202",
      "sw": "0.9870264566627063",
      "tr": "0.9777857740762013",
      "vi": "0.9830137257050394"
    }
  },
  {
    "task_id": "Ruby/24",
    "prompt": {
      "en": "# Reverses the order of words in a given sentence and reverses each word itself.\n# The function takes a single argument, 'sentence', which is a string. It returns \n# a new string with each word in the sentence reversed and the order of words also reversed.\n# Punctuation (spaces, commas, periods, exclamation marks, question marks) is used to identify words \n# and is removed in the returned string.\n#\n# Example:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "es": "# Invierte el orden de las palabras en una oración dada y también invierte cada palabra en sí misma.\n# La función toma un solo argumento, 'sentence', que es una cadena de texto. Devuelve \n# una nueva cadena con cada palabra en la oración invertida y el orden de las palabras también invertido.\n# La puntuación (espacios, comas, puntos, signos de exclamación, signos de interrogación) se utiliza para identificar palabras \n# y se elimina en la cadena devuelta.\n#\n# Ejemplo:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "arb": "# يعكس ترتيب الكلمات في جملة معينة ويعكس كل كلمة بحد ذاتها.\n# تأخذ الدالة وسيطًا واحدًا، 'sentence'، وهو عبارة عن سلسلة نصية. تُرجع\n# سلسلة نصية جديدة مع كل كلمة في الجملة معكوسة وترتيب الكلمات أيضًا معكوس.\n# يتم استخدام علامات الترقيم (المسافات، الفواصل، النقاط، علامات التعجب، علامات الاستفهام) لتحديد الكلمات\n# ويتم إزالتها في السلسلة النصية المُرجعة.\n#\n# مثال:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "sw": "# Inarudisha mpangilio wa maneno katika sentensi iliyotolewa na kugeuza kila neno lenyewe.\n# Kazi inachukua hoja moja, 'sentence', ambayo ni kamba. Inarudisha \n# kamba mpya na kila neno katika sentensi limegeuzwa na mpangilio wa maneno pia umegeuzwa.\n# Alama za uakifishaji (nafasi, koma, nukta, alama za mshangao, alama za kuuliza) zinatumika kutambua maneno \n# na zinaondolewa katika kamba inayorejeshwa.\n#\n# Mfano:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "tr": "# Verilen bir cümledeki kelimelerin sırasını tersine çevirir ve her kelimenin kendisini de tersine çevirir.\n# Fonksiyon, 'sentence' adında tek bir argüman alır, bu bir stringdir. \n# Cümledeki her kelimenin tersine çevrilmiş haliyle ve kelimelerin sırası da tersine çevrilmiş olarak yeni bir string döndürür.\n# Noktalama işaretleri (boşluklar, virgüller, noktalar, ünlem işaretleri, soru işaretleri) kelimeleri tanımlamak için kullanılır \n# ve döndürülen stringde kaldırılır.\n#\n# Örnek:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "vi": "# Đảo ngược thứ tự của các từ trong một câu cho trước và đảo ngược từng từ.\n# Hàm nhận một đối số duy nhất, 'sentence', là một chuỗi. Nó trả về\n# một chuỗi mới với mỗi từ trong câu được đảo ngược và thứ tự của các từ cũng bị đảo ngược.\n# Dấu câu (khoảng trắng, dấu phẩy, dấu chấm, dấu chấm than, dấu chấm hỏi) được sử dụng để xác định từ\n# và bị loại bỏ trong chuỗi trả về.\n#\n# Ví dụ:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)"
    },
    "prompt_bertscore": {
      "es": "0.9891639181930227",
      "arb": "0.9905692281388445",
      "sw": "0.9790075495499468",
      "tr": "0.9819029846142924",
      "vi": "0.9760006828418407"
    },
    "canonical_solution": "    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end",
    "instruction": {
      "en": "Write a ruby function `def reverse_words_in_sentence(sentence)` to solve the following problem:\nReverses the order of words in a given sentence and reverses each word itself.\nThe function takes a single argument, 'sentence', which is a string. It returns\na new string with each word in the sentence reversed and the order of words also reversed.\nPunctuation (spaces, commas, periods, exclamation marks, question marks) is used to identify words\nand is removed in the returned string.\n\nExample:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "es": "Escribe una función en Ruby `def reverse_words_in_sentence(sentence)` para resolver el siguiente problema:\nInvierte el orden de las palabras en una oración dada e invierte cada palabra en sí misma.\nLa función toma un solo argumento, 'sentence', que es una cadena. Devuelve\nuna nueva cadena con cada palabra en la oración invertida y el orden de las palabras también invertido.\nLa puntuación (espacios, comas, puntos, signos de exclamación, signos de interrogación) se utiliza para identificar palabras\ny se elimina en la cadena devuelta.\n\nEjemplo:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "arb": "اكتب دالة روبي `def reverse_words_in_sentence(sentence)` لحل المشكلة التالية:\nتعكس ترتيب الكلمات في الجملة المعطاة وتعكس كل كلمة نفسها.\nتأخذ الدالة وسيطًا واحدًا، 'sentence'، وهو سلسلة نصية. تعيد\nسلسلة نصية جديدة مع كل كلمة في الجملة معكوسة وترتيب الكلمات أيضًا معكوس.\nيتم استخدام علامات الترقيم (المسافات، الفواصل، النقاط، علامات التعجب، علامات الاستفهام) لتحديد الكلمات\nوتتم إزالتها في السلسلة النصية المعادة.\n\nمثال:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "sw": "Andika kazi ya ruby `def reverse_words_in_sentence(sentence)` kutatua tatizo lifuatalo:\nInarudisha mpangilio wa maneno katika sentensi iliyotolewa na inarudisha kila neno lenyewe.\nKazi inachukua hoja moja, 'sentence', ambayo ni kamba. Inarudisha\nkamba mpya na kila neno katika sentensi likiwa limegeuzwa na mpangilio wa maneno pia umegeuzwa.\nAlama za uakifishaji (nafasi, koma, nukta, alama za mshangao, alama za kuuliza) zinatumika kutambua maneno\nna zinaondolewa katika kamba inayorudishwa.\n\nMfano:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "tr": "Bir ruby fonksiyonu `def reverse_words_in_sentence(sentence)` yazın:\nVerilen bir cümledeki kelimelerin sırasını tersine çevirir ve her kelimeyi de kendi içinde tersine çevirir.\nFonksiyon, 'sentence' adlı tek bir argüman alır, bu bir stringdir. Cümledeki her kelimenin tersine çevrildiği ve kelimelerin sırasının da tersine çevrildiği yeni bir string döndürür.\nNoktalama işaretleri (boşluklar, virgüller, noktalar, ünlem işaretleri, soru işaretleri) kelimeleri tanımlamak için kullanılır ve döndürülen stringde kaldırılır.\n\nÖrnek:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "vi": "Viết một hàm ruby `def reverse_words_in_sentence(sentence)` để giải quyết vấn đề sau:\nĐảo ngược thứ tự của các từ trong một câu cho trước và đảo ngược từng từ.\nHàm nhận một đối số duy nhất, 'sentence', là một chuỗi. Nó trả về\nmột chuỗi mới với mỗi từ trong câu được đảo ngược và thứ tự của các từ cũng được đảo ngược.\nDấu câu (khoảng trắng, dấu phẩy, dấu chấm, dấu chấm than, dấu chấm hỏi) được sử dụng để xác định từ\nvà bị loại bỏ trong chuỗi trả về.\n\nVí dụ:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\""
    },
    "instruction_bertscore": {
      "es": "0.9870306279007081",
      "arb": "0.9750198460202903",
      "sw": "0.9893474526650989",
      "tr": "0.9661216022106894",
      "vi": "0.9836848977625564"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless reverse_words_in_sentence(\"hello world!\") == \"dlrow olleh\"\nraise 'Test failed' unless reverse_words_in_sentence(\"This is, a test.\") == \"tset a si sihT\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Ruby, programming!\") == \"gnimmargorp ybuR\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Keep calm and code on.\") == \"no edoc dna mlac peeK\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Simple sentence.\") == \"ecnetnes elpmiS\"\n\n\n\nputs 'All tests passed!'",
    "entry_point": "reverse_words_in_sentence",
    "signature": "def reverse_words_in_sentence(sentence)",
    "docstring": {
      "en": "Reverses the order of words in a given sentence and reverses each word itself.\nThe function takes a single argument, 'sentence', which is a string. It returns\na new string with each word in the sentence reversed and the order of words also reversed.\nPunctuation (spaces, commas, periods, exclamation marks, question marks) is used to identify words\nand is removed in the returned string.\n\nExample:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "es": "Invierte el orden de las palabras en una oración dada y también invierte cada palabra en sí misma.  \nLa función toma un solo argumento, 'sentence', que es una cadena de texto. Devuelve una nueva cadena con cada palabra en la oración invertida y el orden de las palabras también invertido.  \nLa puntuación (espacios, comas, puntos, signos de exclamación, signos de interrogación) se utiliza para identificar palabras y se elimina en la cadena devuelta.  \n\nEjemplo:  \n>>> reverse_words_in_sentence(\"hello world!\")  \n\"dlrow olleh\"  \n>>> reverse_words_in_sentence(\"This is, a test.\")  \n\"tset a si sihT\"",
      "arb": "يعكس ترتيب الكلمات في جملة معينة ويعكس كل كلمة بحد ذاتها.  \nتأخذ الدالة وسيطًا واحدًا، 'sentence'، وهو سلسلة نصية. تُرجع سلسلة نصية جديدة مع كل كلمة في الجملة معكوسة وترتيب الكلمات أيضًا معكوس.  \nتُستخدم علامات الترقيم (المسافات، الفواصل، النقاط، علامات التعجب، علامات الاستفهام) لتحديد الكلمات ويتم إزالتها في السلسلة النصية المُرجعة.\n\nمثال:  \n>>> reverse_words_in_sentence(\"hello world!\")  \n\"dlrow olleh\"  \n>>> reverse_words_in_sentence(\"This is, a test.\")  \n\"tset a si sihT\"  ",
      "sw": "Rejelea mpangilio wa maneno katika sentensi iliyotolewa na urekebishe kila neno lenyewe.\nKazi hii inachukua hoja moja, 'sentence', ambayo ni kamba. Inarejesha\nkamba mpya na kila neno katika sentensi limegeuzwa na mpangilio wa maneno pia umegeuzwa.\nAlama za uakifishaji (nafasi, koma, nukta, alama za mshangao, alama za kuuliza) zinatumika kutambua maneno\nna huondolewa katika kamba inayorejeshwa.\n\nMfano:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "tr": "Verilen bir cümledeki kelimelerin sırasını tersine çevirir ve her kelimenin kendisini de tersine çevirir. \nFonksiyon, bir dize olan 'sentence' adlı tek bir argüman alır. \nCümledeki her kelimenin tersine çevrildiği ve kelimelerin sırasının da tersine çevrildiği yeni bir dize döndürür. \nNoktalama işaretleri (boşluklar, virgüller, noktalar, ünlem işaretleri, soru işaretleri) kelimeleri tanımlamak için kullanılır \nve döndürülen dizgede kaldırılır.\n\nÖrnek:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "vi": "Đảo ngược thứ tự của các từ trong một câu cho trước và đảo ngược từng từ.  \nHàm nhận một đối số duy nhất, 'sentence', là một chuỗi. Nó trả về  \nmột chuỗi mới với mỗi từ trong câu được đảo ngược và thứ tự của các từ cũng được đảo ngược.  \nDấu câu (dấu cách, dấu phẩy, dấu chấm, dấu chấm than, dấu chấm hỏi) được sử dụng để xác định từ  \nvà bị loại bỏ trong chuỗi trả về.  \n\nVí dụ:  \n>>> reverse_words_in_sentence(\"hello world!\")  \n\"dlrow olleh\"  \n>>> reverse_words_in_sentence(\"This is, a test.\")  \n\"tset a si sihT\"  "
    },
    "docstring_bertscore": {
      "es": "0.9859606060380731",
      "arb": "0.9869640867230614",
      "sw": "0.9615366171252612",
      "tr": "0.9679227825059138",
      "vi": "0.9739118857548777"
    }
  },
  {
    "task_id": "Ruby/25",
    "prompt": {
      "en": "# Calculates the number of unique permutations of a given string.\n# The function takes a single argument, str, which is a string consisting of\n# lowercase letters. It returns the total number of unique permutations that\n# can be formed with the characters in str.\n#\n# Example:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "es": "# Calcula el número de permutaciones únicas de una cadena dada.\n# La función toma un solo argumento, str, que es una cadena compuesta de\n# letras minúsculas. Devuelve el número total de permutaciones únicas que\n# se pueden formar con los caracteres en str.\n#\n# Ejemplo:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "arb": "# يحسب عدد التباديل الفريدة لسلسلة معينة.\n# تأخذ الدالة وسيطًا واحدًا، str، وهو سلسلة تتكون من\n# أحرف صغيرة. تُرجع العدد الإجمالي للتباديل الفريدة التي\n# يمكن تشكيلها باستخدام الأحرف في str.\n#\n# مثال:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "sw": "# Inahesabu idadi ya mpangilio wa kipekee wa herufi katika kamba fulani.\n# Kazi inachukua hoja moja, str, ambayo ni kamba inayojumuisha\n# herufi ndogo. Inarudisha jumla ya idadi ya mpangilio wa kipekee ambao\n# unaweza kuundwa na herufi katika str.\n#\n# Mfano:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "tr": "# Verilen bir stringin benzersiz permütasyonlarının sayısını hesaplar.\n# Fonksiyon, küçük harflerden oluşan bir string olan str adlı tek bir argüman alır.\n# Bu stringdeki karakterlerle oluşturulabilecek toplam benzersiz permütasyon\n# sayısını döndürür.\n#\n# Örnek:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "vi": "# Tính số lượng hoán vị duy nhất của một chuỗi cho trước.\n# Hàm nhận một đối số, str, là một chuỗi bao gồm các chữ cái thường.\n# Nó trả về tổng số lượng hoán vị duy nhất có thể được tạo thành với các ký tự trong str.\n#\n# Ví dụ:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)"
    },
    "prompt_bertscore": {
      "es": "0.9975969696502399",
      "arb": "0.9925324908249934",
      "sw": "0.9763588134188466",
      "tr": "0.9743663520666856",
      "vi": "0.9856708043121432"
    },
    "canonical_solution": "    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end",
    "instruction": {
      "en": "Write a ruby function `def unique_permutations_count(str)` to solve the following problem:\nCalculates the number of unique permutations of a given string.\nThe function takes a single argument, str, which is a string consisting of\nlowercase letters. It returns the total number of unique permutations that\ncan be formed with the characters in str.\n\nExample:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "es": "Escribe una función en ruby `def unique_permutations_count(str)` para resolver el siguiente problema:\nCalcula el número de permutaciones únicas de una cadena dada.\nLa función toma un solo argumento, str, que es una cadena que consiste en\nletras minúsculas. Devuelve el número total de permutaciones únicas que\nse pueden formar con los caracteres en str.\n\nEjemplo:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "arb": "اكتب دالة روبي `def unique_permutations_count(str)` لحل المشكلة التالية:\nتحسب عدد التباديل الفريدة لسلسلة معينة.\nتأخذ الدالة وسيطًا واحدًا، str، وهو سلسلة تتكون من\nحروف صغيرة. تعيد الدالة العدد الإجمالي للتباديل الفريدة التي\nيمكن تشكيلها باستخدام الأحرف في str.\n\nمثال:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "sw": "Andika kazi ya ruby `def unique_permutations_count(str)` kutatua tatizo lifuatalo:\nInahesabu idadi ya mchanganyiko wa kipekee wa herufi wa kamba iliyotolewa.\nKazi inachukua hoja moja, str, ambayo ni kamba inayojumuisha\nherufi ndogo. Inarudisha jumla ya idadi ya mchanganyiko wa kipekee ambao\nunaweza kuundwa na herufi katika str.\n\nMfano:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "tr": "Bir ruby fonksiyonu `def unique_permutations_count(str)` yazın:\nVerilen bir stringin benzersiz permütasyonlarının sayısını hesaplar.\nFonksiyon, küçük harflerden oluşan bir string olan str adlı tek bir argüman alır. str içindeki karakterlerle oluşturulabilecek toplam benzersiz permütasyon sayısını döndürür.\n\nÖrnek:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "vi": "Viết một hàm ruby `def unique_permutations_count(str)` để giải quyết vấn đề sau:\nTính toán số lượng hoán vị duy nhất của một chuỗi đã cho.\nHàm nhận một đối số duy nhất, str, là một chuỗi bao gồm các chữ cái thường. Nó trả về tổng số hoán vị duy nhất có thể được tạo thành từ các ký tự trong str.\n\nVí dụ:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6"
    },
    "instruction_bertscore": {
      "es": "0.9933756767924865",
      "arb": "0.991083879456106",
      "sw": "0.9731473574182745",
      "tr": "0.9714419169667089",
      "vi": "0.994841966265286"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless unique_permutations_count(\"aacc\") == 6\nraise 'Test failed' unless unique_permutations_count(\"abc\") == 6\nraise 'Test failed' unless unique_permutations_count(\"abcd\") == 24\nraise 'Test failed' unless unique_permutations_count(\"aaa\") == 1\nraise 'Test failed' unless unique_permutations_count(\"ab\") == 2\nraise 'Test failed' unless unique_permutations_count(\"aacdarwqea\") == 151200\n\n  \n\nputs 'All tests passed!'",
    "entry_point": "unique_permutations_count",
    "signature": "def unique_permutations_count(str)",
    "docstring": {
      "en": "Calculates the number of unique permutations of a given string.\nThe function takes a single argument, str, which is a string consisting of\nlowercase letters. It returns the total number of unique permutations that\ncan be formed with the characters in str.\n\nExample:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "es": "Calcula el número de permutaciones únicas de una cadena dada.\nLa función toma un solo argumento, str, que es una cadena que consiste en\nletras minúsculas. Devuelve el número total de permutaciones únicas que\nse pueden formar con los caracteres en str.\n\nEjemplo:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "arb": "يحسب عدد التباديل الفريدة لسلسلة معينة.\nتأخذ الدالة وسيطًا واحدًا، str، وهو سلسلة تتكون من أحرف صغيرة. تعيد الدالة العدد الإجمالي للتباديل الفريدة التي يمكن تشكيلها باستخدام الأحرف في str.\n\nمثال:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "sw": "Hesabu idadi ya mchanganyiko wa kipekee wa herufi uliyopewa.\n\nHoja:\n    str: Hii ni herufi inayojumuisha herufi ndogo.\n\nInarejesha:\n    Inarudisha jumla ya idadi ya mchanganyiko wa kipekee ambao unaweza kuundwa na herufi katika str.\n\nMfano:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "tr": "Verilen bir stringin benzersiz permütasyonlarının sayısını hesaplar. \nFonksiyon, küçük harflerden oluşan bir string olan tek bir argüman, str, alır. \nBu stringdeki karakterlerle oluşturulabilecek benzersiz permütasyonların toplam sayısını döndürür.\n\nÖrnek:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "vi": "Tính toán số lượng hoán vị duy nhất của một chuỗi đã cho. Hàm này nhận một đối số duy nhất, str, là một chuỗi bao gồm các chữ cái thường. Nó trả về tổng số lượng hoán vị duy nhất có thể được tạo thành với các ký tự trong str.\n\nVí dụ:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6"
    },
    "docstring_bertscore": {
      "es": "0.9969561880410214",
      "arb": "0.9849765911304262",
      "sw": "0.8779996309253234",
      "tr": "0.9794026253778252",
      "vi": "0.9947198085809495"
    }
  },
  {
    "task_id": "Ruby/26",
    "prompt": {
      "en": "# Finds the longest palindrome within a given string.\n# The function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\n# It returns the length of the longest palindrome that can be found within the string.\n# Palindromes are sequences that read the same backward as forward.\n# Note: The function is case-sensitive and considers each character.\n#\n# Example:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "es": "# Encuentra el palíndromo más largo dentro de una cadena dada.\n# La función toma un solo argumento, str, que es una cadena que puede incluir letras, números y símbolos.\n# Devuelve la longitud del palíndromo más largo que se puede encontrar dentro de la cadena.\n# Los palíndromos son secuencias que se leen igual hacia adelante que hacia atrás.\n# Nota: La función distingue entre mayúsculas y minúsculas y considera cada carácter.\n#\n# Ejemplo:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "arb": "# يعثر على أطول جملة متناظرة داخل سلسلة معينة.\n# تأخذ الدالة وسيطًا واحدًا، str، وهو سلسلة قد تحتوي على حروف، أرقام، ورموز.\n# تُرجع طول أطول جملة متناظرة يمكن العثور عليها داخل السلسلة.\n# الجمل المتناظرة هي تسلسلات تقرأ بنفس الطريقة من الأمام والخلف.\n# ملاحظة: الدالة حساسة لحالة الأحرف وتعتبر كل حرف.\n#\n# مثال:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "sw": "# Inapata palindrome ndefu zaidi ndani ya string iliyotolewa.\n# Kazi inachukua hoja moja, str, ambayo ni string inayoweza kujumuisha herufi, nambari, na alama.\n# Inarudisha urefu wa palindrome ndefu zaidi inayoweza kupatikana ndani ya string.\n# Palindrome ni mfuatano unaosomwa sawa mbele na nyuma.\n# Kumbuka: Kazi hii inazingatia ukubwa wa herufi na inachukulia kila herufi.\n#\n# Mfano:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "tr": "# Verilen bir string içindeki en uzun palindromu bulur.\n# Fonksiyon, harfler, sayılar ve semboller içerebilecek bir string olan tek bir argüman alır, str.\n# String içinde bulunabilecek en uzun palindromun uzunluğunu döndürür.\n# Palindromlar, tersten okunduğunda da aynı olan dizilerdir.\n# Not: Fonksiyon büyük/küçük harf duyarlıdır ve her karakteri dikkate alır.\n#\n# Örnek:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "vi": "# Tìm chuỗi palindrome dài nhất trong một chuỗi cho trước.\n# Hàm nhận một đối số, str, là một chuỗi có thể bao gồm chữ cái, số và ký hiệu.\n# Nó trả về độ dài của chuỗi palindrome dài nhất có thể tìm thấy trong chuỗi.\n# Palindrome là các chuỗi đọc giống nhau từ trái sang phải và từ phải sang trái.\n# Lưu ý: Hàm phân biệt chữ hoa chữ thường và xem xét từng ký tự.\n#\n# Ví dụ:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)"
    },
    "prompt_bertscore": {
      "es": "0.9867734015572678",
      "arb": "0.954698368997373",
      "sw": "0.983904582963981",
      "tr": "0.9936513757613629",
      "vi": "0.9517133516311808"
    },
    "canonical_solution": "    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end",
    "instruction": {
      "en": "Write a ruby function `def find_longest_palindrome(str)` to solve the following problem:\nFinds the longest palindrome within a given string.\nThe function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\nIt returns the length of the longest palindrome that can be found within the string.\nPalindromes are sequences that read the same backward as forward.\nNote: The function is case-sensitive and considers each character.\n\nExample:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "es": "Escribe una función en ruby `def find_longest_palindrome(str)` para resolver el siguiente problema:\nEncuentra el palíndromo más largo dentro de una cadena dada.\nLa función toma un solo argumento, str, que es una cadena que puede incluir letras, números y símbolos.\nDevuelve la longitud del palíndromo más largo que se puede encontrar dentro de la cadena.\nLos palíndromos son secuencias que se leen igual hacia adelante y hacia atrás.\nNota: La función distingue entre mayúsculas y minúsculas y considera cada carácter.\n\nEjemplo:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "arb": "اكتب دالة روبي `def find_longest_palindrome(str)` لحل المشكلة التالية:\nتجد أطول جملة مقلوبة داخل سلسلة معينة.\nتأخذ الدالة وسيطًا واحدًا، str، وهو سلسلة قد تحتوي على حروف وأرقام ورموز.\nتعيد طول أطول جملة مقلوبة يمكن العثور عليها داخل السلسلة.\nالجمل المقلوبة هي تسلسلات تقرأ بنفس الطريقة من الأمام والخلف.\nملاحظة: الدالة حساسة لحالة الأحرف وتعتبر كل حرف.\n\nمثال:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "sw": "Andika kazi ya ruby `def find_longest_palindrome(str)` kutatua tatizo lifuatalo:\nInapata palindrome ndefu zaidi ndani ya kamba iliyotolewa.\nKazi inachukua hoja moja, str, ambayo ni kamba inayoweza kujumuisha herufi, namba, na alama.\nInarudisha urefu wa palindrome ndefu zaidi inayoweza kupatikana ndani ya kamba.\nPalindromes ni mlolongo unaosomwa sawa mbele na nyuma.\nKumbuka: Kazi hii inazingatia ukubwa wa herufi na inachukulia kila herufi.\n\nMfano:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "tr": "Bir ruby fonksiyonu `def find_longest_palindrome(str)` yazın ve aşağıdaki problemi çözün:\nVerilen bir string içindeki en uzun palindromu bulur.\nFonksiyon, harfler, sayılar ve semboller içerebilen bir string olan str adlı tek bir argüman alır.\nString içinde bulunabilecek en uzun palindromun uzunluğunu döndürür.\nPalindromlar, tersten okunduğunda da aynı olan dizilerdir.\nNot: Fonksiyon büyük/küçük harfe duyarlıdır ve her karakteri dikkate alır.\n\nÖrnek:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "vi": "Viết một hàm ruby `def find_longest_palindrome(str)` để giải quyết vấn đề sau:\nTìm chuỗi palindrome dài nhất trong một chuỗi cho trước.\nHàm nhận một đối số duy nhất, str, là một chuỗi có thể bao gồm chữ cái, số và ký hiệu.\nNó trả về độ dài của chuỗi palindrome dài nhất có thể tìm thấy trong chuỗi.\nPalindromes là các chuỗi đọc giống nhau khi đọc ngược lại.\nLưu ý: Hàm phân biệt chữ hoa chữ thường và xem xét từng ký tự.\n\nVí dụ:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5"
    },
    "instruction_bertscore": {
      "es": "0.987092997840353",
      "arb": "0.9824708688736711",
      "sw": "0.9891009523622346",
      "tr": "0.9859834485318921",
      "vi": "0.9774490955803471"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless find_longest_palindrome(\"ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"12ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"A\") == 1\nraise 'Test failed' unless find_longest_palindrome(\"ABAKK\") == 3\nraise 'Test failed' unless find_longest_palindrome(\"51233214\") == 6\nraise 'Test failed' unless find_longest_palindrome(\"abaaab\") == 5\n\n\nputs 'All tests passed!'",
    "entry_point": "find_longest_palindrome",
    "signature": "def find_longest_palindrome(str)",
    "docstring": {
      "en": "Finds the longest palindrome within a given string.\nThe function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\nIt returns the length of the longest palindrome that can be found within the string.\nPalindromes are sequences that read the same backward as forward.\nNote: The function is case-sensitive and considers each character.\n\nExample:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "es": "Encuentra el palíndromo más largo dentro de una cadena dada.\nLa función toma un solo argumento, str, que es una cadena que puede incluir letras, números y símbolos.\nDevuelve la longitud del palíndromo más largo que se puede encontrar dentro de la cadena.\nLos palíndromos son secuencias que se leen igual hacia adelante y hacia atrás.\nNota: La función distingue entre mayúsculas y minúsculas y considera cada carácter.\n\nEjemplo:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "arb": "يعثر على أطول جملة متناظرة داخل سلسلة معينة.  \nتأخذ الدالة وسيطًا واحدًا، str، وهو سلسلة قد تشمل حروفًا وأرقامًا ورموزًا.  \nتُعيد طول أطول جملة متناظرة يمكن العثور عليها داخل السلسلة.  \nالجمل المتناظرة هي تسلسلات تُقرأ بنفس الطريقة من الأمام والخلف.  \nملاحظة: الدالة حساسة لحالة الأحرف وتعتبر كل حرف.\n\nمثال:  \n>>> find_longest_palindrome(\"ABBA\")  \n4  \n>>> find_longest_palindrome(\"12ABBA\")  \n4  \n>>> find_longest_palindrome(\"A\")  \n1  \n>>> find_longest_palindrome(\"ABAKK\")  \n3  \n>>> find_longest_palindrome(\"51233214\")  \n6  \n>>> find_longest_palindrome(\"abaaab\")  \n5  ",
      "sw": "Inapata palindrome ndefu zaidi ndani ya mfuatano uliotolewa.\nKazi hii inachukua hoja moja, str, ambayo ni mfuatano unaoweza kujumuisha herufi, namba, na alama.\nInarejesha urefu wa palindrome ndefu zaidi inayoweza kupatikana ndani ya mfuatano huo.\nPalindromes ni mfuatano inayosomwa sawa mbele na nyuma.\nKumbuka: Kazi hii inazingatia ukubwa wa herufi na inachukulia kila herufi tofauti.\n\nMfano:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "tr": "Verilen bir dizede en uzun palindromu bulur.\nFonksiyon, harfler, sayılar ve semboller içerebilen bir dize olan tek bir argüman, str, alır.\nDizede bulunabilecek en uzun palindromun uzunluğunu döndürür.\nPalindromlar, ileri ve geri aynı şekilde okunan dizilerdir.\nNot: Fonksiyon büyük/küçük harfe duyarlıdır ve her karakteri dikkate alır.\n\nÖrnek:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "vi": "Tìm chuỗi palindrome dài nhất trong một chuỗi cho trước.  \nHàm nhận một đối số duy nhất, str, là một chuỗi có thể bao gồm chữ cái, số và ký hiệu.  \nNó trả về độ dài của chuỗi palindrome dài nhất có thể tìm thấy trong chuỗi.  \nPalindromes là các chuỗi đọc giống nhau khi đọc ngược lại như khi đọc xuôi.  \nLưu ý: Hàm phân biệt chữ hoa chữ thường và xem xét từng ký tự.\n\nVí dụ:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5"
    },
    "docstring_bertscore": {
      "es": "0.9864047435700671",
      "arb": "0.9519544889137571",
      "sw": "0.9718280544274408",
      "tr": "0.9832199040405537",
      "vi": "0.9729848777665879"
    }
  },
  {
    "task_id": "Ruby/27",
    "prompt": {
      "en": "# Calculates the sum of two integers as perceived by Xiao Ming, a child who \n# simplifies numbers larger than 99 to their last two digits before addition, \n# and also keeps only the last two digits of the result if it exceeds 99.\n#\n# The function takes two arguments, a and b, which are non-negative integers, and \n# returns the final sum according to Xiao Ming's calculation method.\n#\n# Examples:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "es": "```python\n# Calcula la suma de dos enteros según lo percibe Xiao Ming, un niño que \n# simplifica los números mayores de 99 a sus dos últimos dígitos antes de la suma, \n# y también conserva solo los dos últimos dígitos del resultado si este excede 99.\n#\n# La función toma dos argumentos, a y b, que son enteros no negativos, y \n# devuelve la suma final según el método de cálculo de Xiao Ming.\n#\n# Ejemplos:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)\n```",
      "arb": "```python\n# يحسب مجموع عددين صحيحين كما يراه شياو مينغ، وهو طفل يقوم بتبسيط الأعداد \n# الأكبر من 99 إلى آخر رقمين قبل الجمع، ويحتفظ أيضًا بآخر رقمين من النتيجة \n# إذا تجاوزت 99.\n#\n# تأخذ الدالة وسيطين، a و b، وهما عددان صحيحان غير سالبين، وتعيد المجموع \n# النهائي وفقًا لطريقة حساب شياو مينغ.\n#\n# أمثلة:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b):\n```",
      "sw": "# Inahesabu jumla ya nambari mbili kama inavyoonekana na Xiao Ming, mtoto ambaye \n# hurahisisha nambari kubwa kuliko 99 kwa kuchukua tarakimu mbili za mwisho kabla ya kujumlisha, \n# na pia huhifadhi tarakimu mbili za mwisho za matokeo ikiwa yanazidi 99.\n#\n# Kazi inachukua hoja mbili, a na b, ambazo ni nambari zisizo hasi, na \n# inarudisha jumla ya mwisho kulingana na njia ya hesabu ya Xiao Ming.\n#\n# Mifano:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "tr": "# Xiao Ming tarafından algılandığı şekliyle iki tam sayının toplamını hesaplar, \n# 99'dan büyük sayıları toplama işleminden önce son iki basamağına indirger ve \n# ayrıca sonuç 99'u aşarsa sadece son iki basamağını tutar.\n#\n# Fonksiyon iki argüman alır, a ve b, bunlar negatif olmayan tam sayılardır ve \n# Xiao Ming'in hesaplama yöntemine göre nihai toplamı döndürür.\n#\n# Örnekler:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "vi": "# Tính tổng của hai số nguyên như cách mà Tiểu Minh, một đứa trẻ,\n# đơn giản hóa các số lớn hơn 99 thành hai chữ số cuối trước khi cộng,\n# và cũng chỉ giữ lại hai chữ số cuối của kết quả nếu nó vượt quá 99.\n#\n# Hàm nhận hai tham số, a và b, là các số nguyên không âm,\n# và trả về tổng cuối cùng theo phương pháp tính của Tiểu Minh.\n#\n# Ví dụ:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)"
    },
    "prompt_bertscore": {
      "es": "0.9628473790097104",
      "arb": "0.9523197701844802",
      "sw": "0.9678459125484533",
      "tr": "0.9616696994805545",
      "vi": "0.9536309293296915"
    },
    "canonical_solution": "    a %= 100\n    b %= 100\n    (a + b) % 100\n  end",
    "instruction": {
      "en": "Write a ruby function `def ming_sum(a, b)` to solve the following problem:\nCalculates the sum of two integers as perceived by Xiao Ming, a child who\nsimplifies numbers larger than 99 to their last two digits before addition,\nand also keeps only the last two digits of the result if it exceeds 99.\n\nThe function takes two arguments, a and b, which are non-negative integers, and\nreturns the final sum according to Xiao Ming's calculation method.\n\nExamples:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "es": "Escribe una función en ruby `def ming_sum(a, b)` para resolver el siguiente problema:\nCalcula la suma de dos enteros según lo percibe Xiao Ming, un niño que\nsimplifica los números mayores que 99 a sus últimos dos dígitos antes de la suma,\ny también mantiene solo los últimos dos dígitos del resultado si excede 99.\n\nLa función toma dos argumentos, a y b, que son enteros no negativos, y\ndevuelve la suma final según el método de cálculo de Xiao Ming.\n\nEjemplos:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "arb": "اكتب دالة روبي `def ming_sum(a, b)` لحل المشكلة التالية:\nتحسب مجموع عددين صحيحين كما يراه شياو مينغ، وهو طفل يبسط الأرقام الأكبر من 99 إلى آخر رقمين قبل الجمع،\nويحتفظ أيضًا بآخر رقمين فقط من النتيجة إذا تجاوزت 99.\n\nتأخذ الدالة وسيطين، a و b، وهما عددان صحيحان غير سالبين، وتعيد المجموع النهائي وفقًا لطريقة حساب شياو مينغ.\n\nأمثلة:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "sw": "Andika kazi ya ruby `def ming_sum(a, b)` kutatua tatizo lifuatalo:\nInahesabu jumla ya nambari mbili kama inavyoonekana na Xiao Ming, mtoto ambaye\nhurahisisha nambari kubwa kuliko 99 hadi tarakimu zao mbili za mwisho kabla ya kuongeza,\nna pia huhifadhi tu tarakimu mbili za mwisho za matokeo ikiwa yanazidi 99.\n\nKazi inachukua hoja mbili, a na b, ambazo ni nambari zisizo na hasi, na\ninarudisha jumla ya mwisho kulingana na njia ya hesabu ya Xiao Ming.\n\nMifano:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "tr": "Bir ruby fonksiyonu `def ming_sum(a, b)` yazın ve aşağıdaki problemi çözün:\nXiao Ming tarafından algılandığı gibi iki tam sayının toplamını hesaplar. Xiao Ming, 99'dan büyük sayıları toplama işleminden önce son iki basamağına indirger ve ayrıca sonuç 99'u aşarsa son iki basamağını tutar.\n\nFonksiyon, iki argüman alır, a ve b, bunlar negatif olmayan tam sayılardır ve Xiao Ming'in hesaplama yöntemine göre nihai toplamı döndürür.\n\nÖrnekler:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "vi": "Viết một hàm ruby `def ming_sum(a, b)` để giải quyết vấn đề sau:\nTính tổng của hai số nguyên như được hiểu bởi Tiểu Minh, một đứa trẻ mà\nđơn giản hóa các số lớn hơn 99 thành hai chữ số cuối trước khi cộng,\nvà cũng chỉ giữ lại hai chữ số cuối của kết quả nếu nó vượt quá 99.\n\nHàm nhận hai tham số, a và b, là các số nguyên không âm, và\ntrả về tổng cuối cùng theo phương pháp tính toán của Tiểu Minh.\n\nVí dụ:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67"
    },
    "instruction_bertscore": {
      "es": "0.9831406505185207",
      "arb": "0.9876004984638971",
      "sw": "0.9797279819419603",
      "tr": "0.9555816783018352",
      "vi": "0.9630221737450211"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless ming_sum(35, 80) == 15\nraise 'Test failed' unless ming_sum(15, 1152) == 67\nraise 'Test failed' unless ming_sum(1234, 5678) == 12\nraise 'Test failed' unless ming_sum(0, 99) == 99\nraise 'Test failed' unless ming_sum(50, 50) == 0\n\n\n\n\nputs 'All tests passed!'",
    "entry_point": "ming_sum",
    "signature": "def ming_sum(a, b)",
    "docstring": {
      "en": "Calculates the sum of two integers as perceived by Xiao Ming, a child who\nsimplifies numbers larger than 99 to their last two digits before addition,\nand also keeps only the last two digits of the result if it exceeds 99.\n\nThe function takes two arguments, a and b, which are non-negative integers, and\nreturns the final sum according to Xiao Ming's calculation method.\n\nExamples:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "es": "Calcula la suma de dos enteros según lo percibe Xiao Ming, un niño que simplifica los números mayores de 99 a sus dos últimos dígitos antes de sumarlos, y también conserva solo los dos últimos dígitos del resultado si excede 99.\n\nLa función toma dos argumentos, a y b, que son enteros no negativos, y devuelve la suma final según el método de cálculo de Xiao Ming.\n\nEjemplos:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "arb": "يحسب مجموع عددين صحيحين كما يراه شياو مينغ، وهو طفل يبسط الأرقام الأكبر من 99 إلى آخر رقمين قبل الجمع، ويحتفظ أيضًا بآخر رقمين من النتيجة إذا تجاوزت 99.\n\nتأخذ الدالة وسيطين، a و b، وهما عددان صحيحان غير سالبين، وتعيد المجموع النهائي وفقًا لطريقة حساب شياو مينغ.\n\nأمثلة:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "sw": "Hesabu jumla ya nambari mbili kama inavyoeleweka na Xiao Ming, mtoto ambaye\nhurahisisha nambari kubwa kuliko 99 kwa kuchukua tarakimu zao mbili za mwisho kabla ya kuongeza,\nna pia huhifadhi tu tarakimu mbili za mwisho za matokeo ikiwa yanazidi 99.\n\nKazi hii inachukua hoja mbili, a na b, ambazo ni nambari zisizo hasi, na\ninarudisha jumla ya mwisho kulingana na njia ya hesabu ya Xiao Ming.\n\nMifano:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "tr": "Xiao Ming tarafından algılandığı şekliyle iki tam sayının toplamını hesaplar. Xiao Ming, 99'dan büyük sayıları toplama işleminden önce son iki basamağına indirger ve sonuç 99'u aşarsa yalnızca son iki basamağını tutar.\n\nFonksiyon, a ve b olmak üzere iki argüman alır; bunlar negatif olmayan tam sayılardır ve Xiao Ming'in hesaplama yöntemine göre nihai toplamı döndürür.\n\nÖrnekler:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "vi": "Tính tổng của hai số nguyên theo cách của Tiểu Minh, một đứa trẻ đơn giản hóa các số lớn hơn 99 thành hai chữ số cuối của chúng trước khi cộng, và cũng chỉ giữ lại hai chữ số cuối của kết quả nếu nó vượt quá 99.\n\nHàm nhận hai đối số, a và b, là các số nguyên không âm, và trả về tổng cuối cùng theo phương pháp tính toán của Tiểu Minh.\n\nVí dụ:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67"
    },
    "docstring_bertscore": {
      "es": "0.9846939400982135",
      "arb": "0.9742330710810112",
      "sw": "0.959588847608833",
      "tr": "0.9382114514803342",
      "vi": "0.9491822046856532"
    }
  },
  {
    "task_id": "Ruby/28",
    "prompt": {
      "en": "# Finds the longest word in a given sentence.\n# The function takes a single argument, sentence, which is a string containing multiple words separated by spaces.\n# Each word is composed only of lowercase letters. The function returns the longest word found in the sentence.\n# If there are multiple words of the same longest length, it returns the first one encountered.\n#\n# Example:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "es": "# Encuentra la palabra más larga en una oración dada.\n# La función toma un solo argumento, sentence, que es una cadena que contiene múltiples palabras separadas por espacios.\n# Cada palabra está compuesta solo por letras minúsculas. La función devuelve la palabra más larga encontrada en la oración.\n# Si hay múltiples palabras de la misma longitud más larga, devuelve la primera que se encuentra.\n#\n# Ejemplo:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "arb": "# يجد أطول كلمة في جملة معينة.\n# تأخذ الدالة وسيطًا واحدًا، وهو الجملة، وهي سلسلة تحتوي على كلمات متعددة مفصولة بمسافات.\n# كل كلمة تتكون فقط من حروف صغيرة. تعيد الدالة أطول كلمة تم العثور عليها في الجملة.\n# إذا كانت هناك كلمات متعددة بنفس الطول الأطول، فإنها تعيد أول واحدة تم العثور عليها.\n#\n# مثال:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "sw": "# Inapata neno refu zaidi katika sentensi iliyotolewa.\n# Kazi inachukua hoja moja, sentence, ambayo ni kamba yenye maneno mengi yaliyotenganishwa na nafasi.\n# Kila neno linaundwa na herufi ndogo pekee. Kazi inarudisha neno refu zaidi lililopatikana katika sentensi.\n# Ikiwa kuna maneno mengi ya urefu sawa mrefu zaidi, inarudisha la kwanza lililokutana nalo.\n#\n# Mfano:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "tr": "# Verilen bir cümledeki en uzun kelimeyi bulur.\n# Fonksiyon, boşluklarla ayrılmış birden fazla kelime içeren bir string olan sentence adlı tek bir argüman alır.\n# Her kelime yalnızca küçük harflerden oluşur. Fonksiyon, cümlede bulunan en uzun kelimeyi döndürür.\n# Eğer aynı uzunlukta birden fazla kelime varsa, karşılaşılan ilkini döndürür.\n#\n# Örnek:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "vi": "# Tìm từ dài nhất trong một câu cho trước.\n# Hàm nhận một đối số duy nhất, sentence, là một chuỗi chứa nhiều từ được tách ra bởi dấu cách.\n# Mỗi từ chỉ bao gồm các chữ cái thường. Hàm trả về từ dài nhất tìm thấy trong câu.\n# Nếu có nhiều từ có cùng độ dài dài nhất, nó trả về từ đầu tiên gặp phải.\n#\n# Ví dụ:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)"
    },
    "prompt_bertscore": {
      "es": "0.9937763142710339",
      "arb": "0.9798876807683123",
      "sw": "0.9913665304883186",
      "tr": "0.9869527647913423",
      "vi": "0.989666651687422"
    },
    "canonical_solution": "  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend",
    "instruction": {
      "en": "Write a ruby function `def find_longest_word(sentence)` to solve the following problem:\nFinds the longest word in a given sentence.\nThe function takes a single argument, sentence, which is a string containing multiple words separated by spaces.\nEach word is composed only of lowercase letters. The function returns the longest word found in the sentence.\nIf there are multiple words of the same longest length, it returns the first one encountered.\n\nExample:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "es": "Escribe una función en ruby `def find_longest_word(sentence)` para resolver el siguiente problema:\nEncuentra la palabra más larga en una oración dada.\nLa función toma un solo argumento, sentence, que es una cadena que contiene múltiples palabras separadas por espacios.\nCada palabra está compuesta solo por letras minúsculas. La función devuelve la palabra más larga encontrada en la oración.\nSi hay múltiples palabras de la misma longitud más larga, devuelve la primera que se encuentra.\n\nEjemplo:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "arb": "اكتب دالة روبي `def find_longest_word(sentence)` لحل المشكلة التالية:\nتجد أطول كلمة في جملة معينة.\nتأخذ الدالة وسيطًا واحدًا، sentence، وهو سلسلة تحتوي على كلمات متعددة مفصولة بمسافات.\nكل كلمة تتكون فقط من حروف صغيرة. تعيد الدالة أطول كلمة موجودة في الجملة.\nإذا كانت هناك كلمات متعددة بنفس الطول الأطول، فإنها تعيد أول واحدة تم العثور عليها.\n\nمثال:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "sw": "Andika kazi ya ruby `def find_longest_word(sentence)` kutatua tatizo lifuatalo:\nInapata neno refu zaidi katika sentensi iliyotolewa.\nKazi inachukua hoja moja, sentence, ambayo ni kamba inayojumuisha maneno mengi yaliyotenganishwa na nafasi.\nKila neno linaundwa na herufi ndogo pekee. Kazi inarudisha neno refu zaidi lililopatikana katika sentensi.\nIkiwa kuna maneno mengi yenye urefu sawa, inarudisha la kwanza lililokutana nalo.\n\nMfano:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "tr": "Bir ruby fonksiyonu `def find_longest_word(sentence)` yazın:\nVerilen bir cümledeki en uzun kelimeyi bulur.\nFonksiyon, boşluklarla ayrılmış birden fazla kelime içeren bir string olan tek bir argüman, sentence, alır.\nHer kelime yalnızca küçük harflerden oluşur. Fonksiyon, cümlede bulunan en uzun kelimeyi döndürür.\nEğer aynı uzunlukta birden fazla kelime varsa, ilk karşılaşılanı döndürür.\n\nÖrnek:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "vi": "Viết một hàm ruby `def find_longest_word(sentence)` để giải quyết vấn đề sau:  \nTìm từ dài nhất trong một câu cho trước.  \nHàm nhận một đối số duy nhất, sentence, là một chuỗi chứa nhiều từ được phân tách bằng dấu cách.  \nMỗi từ chỉ bao gồm các chữ cái thường. Hàm trả về từ dài nhất tìm thấy trong câu.  \nNếu có nhiều từ có cùng độ dài dài nhất, nó trả về từ đầu tiên gặp phải.  \n\nVí dụ:  \n>>> find_longest_word(\"I am a student\")  \n\"student\"  \n>>> find_longest_word(\"The quick brown fox\")  \n\"quick\"  "
    },
    "instruction_bertscore": {
      "es": "0.987884738539158",
      "arb": "0.9801180920103129",
      "sw": "0.9853589546139184",
      "tr": "0.9662344242671173",
      "vi": "0.9894773569342957"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless find_longest_word(\"I am a student\") == \"student\"\nraise 'Test failed' unless find_longest_word(\"The quick brown fox jumps over the lazy dog\") == \"quick\"\nraise 'Test failed' unless find_longest_word(\"Hello world\") == \"Hello\"\nraise 'Test failed' unless find_longest_word(\"A B C D EFG HI\") == \"EFG\"\nraise 'Test failed' unless find_longest_word(\"Ruby Python Java\") == \"Python\"",
    "entry_point": "find_longest_word",
    "signature": "def find_longest_word(sentence)",
    "docstring": {
      "en": "Finds the longest word in a given sentence.\nThe function takes a single argument, sentence, which is a string containing multiple words separated by spaces.\nEach word is composed only of lowercase letters. The function returns the longest word found in the sentence.\nIf there are multiple words of the same longest length, it returns the first one encountered.\n\nExample:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "es": "Encuentra la palabra más larga en una oración dada.  \nLa función toma un solo argumento, sentence, que es una cadena que contiene múltiples palabras separadas por espacios.  \nCada palabra está compuesta solo por letras minúsculas. La función devuelve la palabra más larga encontrada en la oración.  \nSi hay múltiples palabras de la misma longitud más larga, devuelve la primera que encuentra.  \n\nEjemplo:  \n>>> find_longest_word(\"I am a student\")  \n\"student\"  \n>>> find_longest_word(\"The quick brown fox\")  \n\"quick\"  ",
      "arb": "يعثر على أطول كلمة في جملة معينة.\nتأخذ الدالة وسيطًا واحدًا، الجملة، وهي سلسلة تحتوي على كلمات متعددة مفصولة بمسافات.\nكل كلمة تتكون فقط من حروف صغيرة. تعيد الدالة أطول كلمة موجودة في الجملة.\nإذا كانت هناك عدة كلمات بنفس الطول الأطول، فإنها تعيد أول واحدة تم العثور عليها.\n\nمثال:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "sw": "Inapata neno refu zaidi katika sentensi iliyotolewa. \nKazi inachukua hoja moja, sentensi, ambayo ni kamba inayojumuisha maneno mengi yaliyotenganishwa na nafasi. \nKila neno linaundwa tu na herufi ndogo. Kazi inarudisha neno refu zaidi lililopatikana katika sentensi. \nKama kuna maneno mengi ya urefu sawa, inarudisha la kwanza lililokutana nalo.\n\nMfano:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "tr": "Verilen bir cümledeki en uzun kelimeyi bulur.\nFonksiyon, boşluklarla ayrılmış birden fazla kelime içeren bir dize olan sentence adlı tek bir argüman alır.\nHer kelime yalnızca küçük harflerden oluşur. Fonksiyon, cümlede bulunan en uzun kelimeyi döndürür.\nEğer aynı uzunlukta birden fazla kelime varsa, karşılaşılan ilkini döndürür.\n\nÖrnek:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "vi": "Tìm từ dài nhất trong một câu cho trước.  \nHàm này nhận một đối số duy nhất, sentence, là một chuỗi chứa nhiều từ được ngăn cách bởi khoảng trắng.  \nMỗi từ chỉ bao gồm các chữ cái thường. Hàm trả về từ dài nhất được tìm thấy trong câu.  \nNếu có nhiều từ có cùng độ dài dài nhất, nó trả về từ đầu tiên gặp phải.\n\nVí dụ:  \n>>> find_longest_word(\"I am a student\")  \n\"student\"  \n>>> find_longest_word(\"The quick brown fox\")  \n\"quick\"  "
    },
    "docstring_bertscore": {
      "es": "0.9867241412227712",
      "arb": "0.9790035769423261",
      "sw": "0.9854393999182375",
      "tr": "0.9846418989383825",
      "vi": "0.983551616776882"
    }
  },
  {
    "task_id": "Ruby/29",
    "prompt": {
      "en": "# Decrypts a message encrypted with Caesar's cipher.\n# The cipher shifts each letter in the message 5 positions to the right in the alphabet.\n# Non-letter characters are left unchanged. All letters are in uppercase.\n#\n# Example:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "es": "# Descifra un mensaje cifrado con el cifrado de César.\n# El cifrado desplaza cada letra del mensaje 5 posiciones a la derecha en el alfabeto.\n# Los caracteres que no son letras se dejan sin cambios. Todas las letras están en mayúsculas.\n#\n# Ejemplo:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "arb": "# يفك تشفير رسالة مشفرة بشيفرة قيصر.\n# الشيفرة تحرك كل حرف في الرسالة 5 مواقع إلى اليمين في الأبجدية.\n# تترك الأحرف غير الحروف دون تغيير. جميع الأحرف تكون بحروف كبيرة.\n#\n# مثال:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "sw": "# Inafungua ujumbe uliosimbwa kwa kutumia kanuni ya Caesar.\n# Kanuni inasogeza kila herufi katika ujumbe nafasi 5 kwenda kulia kwenye alfabeti.\n# Herufi zisizo za alfabeti hazibadilishwi. Herufi zote ni kubwa.\n#\n# Mfano:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "tr": "# Caesar şifrelemesiyle şifrelenmiş bir mesajı çözer.\n# Şifre, mesajdaki her harfi alfabede 5 pozisyon sağa kaydırır.\n# Harf olmayan karakterler değişmeden kalır. Tüm harfler büyük harfle yazılmıştır.\n#\n# Örnek:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "vi": "# Giải mã một thông điệp được mã hóa bằng mã Caesar.\n# Mã này dịch chuyển mỗi chữ cái trong thông điệp 5 vị trí sang phải trong bảng chữ cái.\n# Các ký tự không phải chữ cái được giữ nguyên. Tất cả các chữ cái đều viết hoa.\n#\n# Ví dụ:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)"
    },
    "prompt_bertscore": {
      "es": "0.98869316418997",
      "arb": "0.9780334661613517",
      "sw": "0.9777309520910356",
      "tr": "0.9836993977803719",
      "vi": "0.9834735550371352"
    },
    "canonical_solution": "    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end",
    "instruction": {
      "en": "Write a ruby function `def decrypt_caesar_cipher(message)` to solve the following problem:\nDecrypts a message encrypted with Caesar's cipher.\nThe cipher shifts each letter in the message 5 positions to the right in the alphabet.\nNon-letter characters are left unchanged. All letters are in uppercase.\n\nExample:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "es": "Escribe una función en ruby `def decrypt_caesar_cipher(message)` para resolver el siguiente problema:\nDescifra un mensaje encriptado con el cifrado de César.\nEl cifrado desplaza cada letra en el mensaje 5 posiciones a la derecha en el alfabeto.\nLos caracteres que no son letras se dejan sin cambios. Todas las letras están en mayúsculas.\n\nEjemplo:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "arb": "اكتب دالة روبي `def decrypt_caesar_cipher(message)` لحل المشكلة التالية:\nتفك تشفير رسالة مشفرة بشيفرة قيصر.\nتحرك الشيفرة كل حرف في الرسالة 5 مواقع إلى اليمين في الأبجدية.\nتترك الأحرف غير الحروف دون تغيير. جميع الأحرف في حالة الأحرف الكبيرة.\n\nمثال:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "sw": "Andika kazi ya ruby `def decrypt_caesar_cipher(message)` kutatua tatizo lifuatalo:\nFungua ujumbe uliosimbwa kwa njia ya siri ya Kaisari.\nNjia ya siri inasogeza kila herufi katika ujumbe nafasi 5 kwenda kulia katika alfabeti.\nHerufi zisizo za barua zinabaki bila kubadilishwa. Herufi zote ziko katika herufi kubwa.\n\nMfano:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "tr": "Bir ruby fonksiyonu `def decrypt_caesar_cipher(message)` yazın: \nAşağıdaki problemi çözmek için:\nCaesar şifresi ile şifrelenmiş bir mesajı çözmek. \nŞifre, mesajdaki her harfi alfabede 5 pozisyon sağa kaydırır. \nHarf olmayan karakterler değişmeden kalır. Tüm harfler büyük harfle yazılmıştır.\n\nÖrnek:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "vi": "Viết một hàm ruby `def decrypt_caesar_cipher(message)` để giải quyết vấn đề sau:\nGiải mã một thông điệp được mã hóa bằng mật mã Caesar.\nMật mã dịch chuyển mỗi chữ cái trong thông điệp 5 vị trí sang phải trong bảng chữ cái.\nCác ký tự không phải chữ cái được giữ nguyên. Tất cả các chữ cái đều ở dạng chữ hoa.\n\nVí dụ:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'"
    },
    "instruction_bertscore": {
      "es": "0.987280703550431",
      "arb": "0.9858426195917384",
      "sw": "0.9857051673680622",
      "tr": "0.989928645160007",
      "vi": "0.9908645915154434"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX') == 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\nraise 'Test failed' unless decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ') == 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\nraise 'Test failed' unless decrypt_caesar_cipher('IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ') == 'DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE'\nraise 'Test failed' unless decrypt_caesar_cipher('ABCDEF') == 'VWXYZA'\nraise 'Test failed' unless decrypt_caesar_cipher('XYZ') == 'STU'\n\n  \n\n\nputs 'All tests passed!'",
    "entry_point": "decrypt_caesar_cipher",
    "signature": "def decrypt_caesar_cipher(message)",
    "docstring": {
      "en": "Decrypts a message encrypted with Caesar's cipher.\nThe cipher shifts each letter in the message 5 positions to the right in the alphabet.\nNon-letter characters are left unchanged. All letters are in uppercase.\n\nExample:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "es": "Descifra un mensaje cifrado con el cifrado de César.  \nEl cifrado desplaza cada letra en el mensaje 5 posiciones a la derecha en el alfabeto.  \nLos caracteres que no son letras se dejan sin cambios. Todas las letras están en mayúsculas.\n\nEjemplo:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "arb": "يفك تشفير رسالة مشفرة بشيفرة قيصر. \nتقوم الشيفرة بتحريك كل حرف في الرسالة 5 مواقع إلى اليمين في الأبجدية. \nتُترك الأحرف غير الحرفية دون تغيير. جميع الأحرف تكون بأحرف كبيرة.\n\nمثال:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "sw": "Inafungua ujumbe uliosimbwa na cipher ya Caesar. \nCipher inasogeza kila herufi katika ujumbe nafasi 5 kwenda kulia katika alfabeti. \nHerufi zisizo za barua hazibadiliki. Herufi zote ziko katika herufi kubwa.\n\nMfano:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "tr": "Caesar şifrelemesiyle şifrelenmiş bir mesajı çözer.\nŞifre, mesajdaki her harfi alfabede 5 pozisyon sağa kaydırır.\nHarf olmayan karakterler değiştirilmeden bırakılır. Tüm harfler büyük harflerle yazılmıştır.\n\nÖrnek:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "vi": "Giải mã một thông điệp được mã hóa bằng mã Caesar.  \nMã này dịch chuyển mỗi chữ cái trong thông điệp 5 vị trí sang phải trong bảng chữ cái.  \nCác ký tự không phải chữ cái được giữ nguyên. Tất cả các chữ cái đều ở dạng chữ hoa.\n\nVí dụ:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'"
    },
    "docstring_bertscore": {
      "es": "0.9874566900680278",
      "arb": "0.9884007802690866",
      "sw": "0.9790182755905227",
      "tr": "0.9745641879261964",
      "vi": "0.9875834162511281"
    }
  },
  {
    "task_id": "Ruby/30",
    "prompt": {
      "en": "# Calculates the number of possible photo arrangements for a group of people.\n# In this arrangement, people are lined up in such a way that the age difference\n# between any two adjacent persons is no more than two years.\n# The function takes a single integer argument, n, representing the number of people\n# in the group, where each person has a distinct age from 1 to n years.\n#\n# Example:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "es": "# Calcula el número de posibles arreglos de fotos para un grupo de personas.\n# En este arreglo, las personas están alineadas de tal manera que la diferencia de edad\n# entre dos personas adyacentes no es mayor de dos años.\n# La función toma un solo argumento entero, n, que representa el número de personas\n# en el grupo, donde cada persona tiene una edad distinta de 1 a n años.\n#\n# Ejemplo:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "arb": "# يحسب عدد الترتيبات الممكنة للصور لمجموعة من الأشخاص.\n# في هذا الترتيب، يتم اصطفاف الأشخاص بطريقة لا يتجاوز فيها فرق العمر\n# بين أي شخصين متجاورين سنتين.\n# تأخذ الدالة وسيطًا واحدًا، n، يمثل عدد الأشخاص\n# في المجموعة، حيث لكل شخص عمر مميز من 1 إلى n سنة.\n#\n# مثال:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "sw": "# Inahesabu idadi ya mipangilio ya picha inayowezekana kwa kundi la watu.\n# Katika mpangilio huu, watu wamepangwa kwa namna ambayo tofauti ya umri\n# kati ya mtu yeyote aliye karibu ni miaka miwili au chini ya hapo.\n# Kazi hii inachukua hoja moja ya nambari nzima, n, inayowakilisha idadi ya watu\n# katika kundi, ambapo kila mtu ana umri tofauti kutoka mwaka 1 hadi n.\n#\n# Mfano:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "tr": "# Bir grup insan için olası fotoğraf düzenlemelerinin sayısını hesaplar.\n# Bu düzenlemede, insanlar yan yana dizilir ve herhangi iki bitişik kişi arasındaki\n# yaş farkı en fazla iki yıldır.\n# Fonksiyon, gruptaki kişi sayısını temsil eden tek bir tamsayı argümanı alır,\n# burada her kişinin yaşı 1'den n'e kadar farklıdır.\n#\n# Örnek:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "vi": "# Tính toán số lượng cách sắp xếp ảnh có thể có cho một nhóm người.\n# Trong cách sắp xếp này, mọi người được xếp hàng sao cho sự chênh lệch tuổi\n# giữa bất kỳ hai người liền kề nào không quá hai năm.\n# Hàm nhận một đối số kiểu số nguyên, n, đại diện cho số người\n# trong nhóm, trong đó mỗi người có một độ tuổi khác biệt từ 1 đến n năm.\n#\n# Ví dụ:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)"
    },
    "prompt_bertscore": {
      "es": "0.9922134904330513",
      "arb": "0.9743874068870753",
      "sw": "0.9621670699546658",
      "tr": "0.9477333946863847",
      "vi": "0.9831037052676482"
    },
    "canonical_solution": "    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end",
    "instruction": {
      "en": "Write a ruby function `def photo_arrangements_count(n)` to solve the following problem:\nCalculates the number of possible photo arrangements for a group of people.\nIn this arrangement, people are lined up in such a way that the age difference\nbetween any two adjacent persons is no more than two years.\nThe function takes a single integer argument, n, representing the number of people\nin the group, where each person has a distinct age from 1 to n years.\n\nExample:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "es": "Escribe una función en ruby `def photo_arrangements_count(n)` para resolver el siguiente problema:\nCalcula el número de posibles arreglos de fotos para un grupo de personas.\nEn este arreglo, las personas están alineadas de tal manera que la diferencia de edad\nentre dos personas adyacentes no es mayor de dos años.\nLa función toma un único argumento entero, n, que representa el número de personas\nen el grupo, donde cada persona tiene una edad distinta de 1 a n años.\n\nEjemplo:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "arb": "اكتب دالة روبي `def photo_arrangements_count(n)` لحل المشكلة التالية:\nتحسب عدد الترتيبات الممكنة للصور لمجموعة من الأشخاص.\nفي هذا الترتيب، يتم ترتيب الأشخاص بحيث لا يزيد فرق العمر\nبين أي شخصين متجاورين عن سنتين.\nتأخذ الدالة وسيطًا واحدًا من نوع عدد صحيح، n، يمثل عدد الأشخاص\nفي المجموعة، حيث يكون لكل شخص عمر مميز من 1 إلى n سنة.\n\nمثال:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "sw": "Andika kazi ya ruby `def photo_arrangements_count(n)` kutatua tatizo lifuatalo:\nHesabu idadi ya mipangilio ya picha inayowezekana kwa kundi la watu.\nKatika mpangilio huu, watu wamepangwa kwa njia ambayo tofauti ya umri\nkati ya mtu yeyote aliye karibu ni miaka miwili au chini ya hapo.\nKazi inachukua hoja moja ya nambari nzima, n, inayowakilisha idadi ya watu\nkatika kundi, ambapo kila mtu ana umri tofauti kutoka mwaka 1 hadi n.\n\nMfano:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "tr": "Bir ruby fonksiyonu `def photo_arrangements_count(n)` yazın ve aşağıdaki problemi çözün:\nBir grup insan için olası fotoğraf düzenlemelerinin sayısını hesaplar.\nBu düzenlemede, insanlar öyle bir sıraya dizilir ki, yan yana duran herhangi iki kişi arasındaki yaş farkı\niki yıldan fazla değildir.\nFonksiyon, gruptaki kişi sayısını temsil eden tek bir tamsayı argümanı alır, burada her kişinin yaşı 1'den n'ye kadar farklıdır.\n\nÖrnek:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "vi": "Viết một hàm ruby `def photo_arrangements_count(n)` để giải quyết vấn đề sau:\nTính toán số lượng cách sắp xếp ảnh có thể có cho một nhóm người.\nTrong cách sắp xếp này, mọi người được xếp hàng sao cho chênh lệch tuổi tác\ngiữa bất kỳ hai người liền kề nào không quá hai năm.\nHàm nhận một đối số số nguyên, n, đại diện cho số lượng người\ntrong nhóm, trong đó mỗi người có độ tuổi khác nhau từ 1 đến n năm.\n\nVí dụ:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6"
    },
    "instruction_bertscore": {
      "es": "0.9841828641278109",
      "arb": "0.9603853554367829",
      "sw": "0.9180429198508138",
      "tr": "0.9721867808955897",
      "vi": "0.9790049673549933"
    },
    "level": "middle",
    "test": "  \nraise 'Test failed' unless photo_arrangements_count(4) == 4\nraise 'Test failed' unless photo_arrangements_count(5) == 6\nraise 'Test failed' unless photo_arrangements_count(6) == 9\nraise 'Test failed' unless photo_arrangements_count(7) == 14\nraise 'Test failed' unless photo_arrangements_count(8) == 21\n  \n\nputs 'All tests passed!'",
    "entry_point": "photo_arrangements_count",
    "signature": "def photo_arrangements_count(n)",
    "docstring": {
      "en": "Calculates the number of possible photo arrangements for a group of people.\nIn this arrangement, people are lined up in such a way that the age difference\nbetween any two adjacent persons is no more than two years.\nThe function takes a single integer argument, n, representing the number of people\nin the group, where each person has a distinct age from 1 to n years.\n\nExample:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "es": "Calcula el número de posibles arreglos fotográficos para un grupo de personas. En este arreglo, las personas están alineadas de tal manera que la diferencia de edad entre dos personas adyacentes no sea mayor de dos años. La función toma un solo argumento entero, n, que representa el número de personas en el grupo, donde cada persona tiene una edad distinta de 1 a n años.\n\nEjemplo:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "arb": "يحسب عدد الترتيبات الممكنة للصور لمجموعة من الأشخاص. في هذا الترتيب، يتم ترتيب الأشخاص بحيث لا يزيد فرق العمر بين أي شخصين متجاورين عن سنتين. تأخذ الدالة وسيطًا واحدًا من النوع عدد صحيح، n، يمثل عدد الأشخاص في المجموعة، حيث يكون لكل شخص عمر مميز من 1 إلى n سنة.\n\nمثال:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "sw": "Hesabu idadi ya mipangilio ya picha inayowezekana kwa kundi la watu.\nKatika mpangilio huu, watu wamepangwa kwa namna ambayo tofauti ya umri\nkati ya watu wawili walio karibu haiwezi kuwa zaidi ya miaka miwili.\nKazi hii inachukua hoja moja ya nambari nzima, n, inayowakilisha idadi ya watu\nkatika kundi, ambapo kila mtu ana umri tofauti kutoka mwaka 1 hadi n.\n\nMfano:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "tr": "Bir grup insan için olası fotoğraf düzenlemelerinin sayısını hesaplar.\nBu düzenlemede, insanlar öyle bir sıraya dizilir ki, bitişik iki kişi arasındaki yaş farkı\niki yıldan fazla olmaz.\nFonksiyon, gruptaki kişi sayısını temsil eden tek bir tam sayı argümanı alır, burada her kişi 1'den n'ye kadar farklı bir yaşa sahiptir.\n\nÖrnek:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "vi": "Tính toán số lượng cách sắp xếp ảnh có thể có cho một nhóm người. Trong cách sắp xếp này, mọi người được xếp hàng sao cho sự chênh lệch tuổi tác giữa bất kỳ hai người liền kề nào không quá hai tuổi. Hàm này nhận một đối số nguyên duy nhất, n, đại diện cho số người trong nhóm, trong đó mỗi người có một độ tuổi khác nhau từ 1 đến n năm.\n\nVí dụ:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6"
    },
    "docstring_bertscore": {
      "es": "0.9801043865140214",
      "arb": "0.9586747505953105",
      "sw": "0.937692231664309",
      "tr": "0.969842346508235",
      "vi": "0.9783814665889249"
    }
  },
  {
    "task_id": "Ruby/31",
    "prompt": {
      "en": "# Converts a numerical score into a corresponding letter grade based on predefined ranges.\n# The function takes a single argument, score, which is an integer representing the score.\n# It returns a string representing the letter grade, or an error message for invalid scores.\n#\n# Grade Conversion:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Any other score: 'Score is error!'\n#\n# Examples:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "es": "# Convierte una puntuación numérica en una calificación de letra correspondiente basada en rangos predefinidos.\n# La función toma un solo argumento, score, que es un entero que representa la puntuación.\n# Devuelve una cadena que representa la calificación de letra, o un mensaje de error para puntuaciones no válidas.\n#\n# Conversión de Calificaciones:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Cualquier otra puntuación: 'Score is error!'\n#\n# Ejemplos:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "arb": "# يحول درجة رقمية إلى درجة حرفية مقابلة بناءً على نطاقات محددة مسبقًا.\n# تأخذ الدالة وسيطًا واحدًا، وهو score، وهو عدد صحيح يمثل الدرجة.\n# تُرجع سلسلة نصية تمثل الدرجة الحرفية، أو رسالة خطأ للدرجات غير الصالحة.\n#\n# تحويل الدرجات:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# أي درجة أخرى: 'Score is error!'\n#\n# أمثلة:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'",
      "sw": "# Inabadilisha alama ya nambari kuwa daraja la herufi linalolingana kulingana na viwango vilivyowekwa awali.\n# Kazi inachukua hoja moja, score, ambayo ni nambari inayowakilisha alama.\n# Inarudisha kamba inayowakilisha daraja la herufi, au ujumbe wa kosa kwa alama zisizo sahihi.\n#\n# Ubadilishaji wa Daraja:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Alama nyingine yoyote: 'Score is error!'\n#\n# Mifano:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "tr": "# Sayısal bir puanı, önceden tanımlanmış aralıklara göre karşılık gelen bir harf notuna dönüştürür.\n# Fonksiyon, puanı temsil eden bir tamsayı olan tek bir argüman, score, alır.\n# Bir harf notunu temsil eden bir string veya geçersiz puanlar için bir hata mesajı döndürür.\n#\n# Not Dönüşümü:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Diğer puanlar: 'Score is error!'\n#\n# Örnekler:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'",
      "vi": "# Chuyển đổi một điểm số thành một điểm chữ tương ứng dựa trên các khoảng giá trị được định trước.\n# Hàm nhận một đối số duy nhất, score, là một số nguyên đại diện cho điểm số.\n# Nó trả về một chuỗi đại diện cho điểm chữ, hoặc một thông báo lỗi cho các điểm không hợp lệ.\n#\n# Chuyển đổi điểm:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Bất kỳ điểm nào khác: 'Score is error!'\n#\n# Ví dụ:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)"
    },
    "prompt_bertscore": {
      "es": "0.996897393448235",
      "arb": "0.9728954940951222",
      "sw": "0.9871257718532237",
      "tr": "0.9707842517751024",
      "vi": "0.9866693192376056"
    },
    "canonical_solution": "    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end",
    "instruction": {
      "en": "Write a ruby function `def convert_score_to_grade(score)` to solve the following problem:\nConverts a numerical score into a corresponding letter grade based on predefined ranges.\nThe function takes a single argument, score, which is an integer representing the score.\nIt returns a string representing the letter grade, or an error message for invalid scores.\n\nGrade Conversion:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAny other score: 'Score is error!'\n\nExamples:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "es": "Escribe una función de ruby `def convert_score_to_grade(score)` para resolver el siguiente problema:\nConvierte una puntuación numérica en una calificación de letra correspondiente basada en rangos predefinidos.\nLa función toma un solo argumento, score, que es un entero que representa la puntuación.\nDevuelve una cadena que representa la calificación de letra, o un mensaje de error para puntuaciones no válidas.\n\nConversión de Calificaciones:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nCualquier otra puntuación: 'Score is error!'\n\nEjemplos:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "arb": "اكتب دالة روبي `def convert_score_to_grade(score)` لحل المشكلة التالية:\nتحول درجة رقمية إلى درجة حرفية مقابلة بناءً على نطاقات محددة مسبقًا.\nتأخذ الدالة وسيطًا واحدًا، score، وهو عدد صحيح يمثل الدرجة.\nتعيد سلسلة تمثل الدرجة الحرفية، أو رسالة خطأ للدرجات غير الصالحة.\n\nتحويل الدرجات:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nأي درجة أخرى: 'Score is error!'\n\nأمثلة:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "sw": "Andika kazi ya ruby `def convert_score_to_grade(score)` kutatua tatizo lifuatalo:\nInabadilisha alama ya nambari kuwa daraja la herufi linalolingana kulingana na viwango vilivyowekwa awali.\nKazi inachukua hoja moja, score, ambayo ni nambari nzima inayowakilisha alama.\nInarudisha kamba inayowakilisha daraja la herufi, au ujumbe wa kosa kwa alama zisizo sahihi.\n\nUbadilishaji wa Daraja:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAlama nyingine yoyote: 'Score is error!'\n\nMifano:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "tr": "Bir ruby fonksiyonu `def convert_score_to_grade(score)` yazın:\nÖnceden tanımlanmış aralıklara dayalı olarak sayısal bir puanı karşılık gelen bir harf notuna dönüştürür.\nFonksiyon, puanı temsil eden bir tamsayı olan tek bir argüman, score, alır.\nBir dize döndürür, harf notunu veya geçersiz puanlar için bir hata mesajını temsil eder.\n\nNot Dönüşümü:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nDiğer herhangi bir puan: 'Score is error!'\n\nÖrnekler:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "vi": "Viết một hàm ruby `def convert_score_to_grade(score)` để giải quyết vấn đề sau:\nChuyển đổi một điểm số thành một điểm chữ tương ứng dựa trên các khoảng giá trị được định trước.\nHàm nhận một đối số duy nhất, score, là một số nguyên đại diện cho điểm số.\nNó trả về một chuỗi đại diện cho điểm chữ, hoặc một thông báo lỗi cho các điểm số không hợp lệ.\n\nChuyển đổi điểm:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nBất kỳ điểm nào khác: 'Score is error!'\n\nVí dụ:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'"
    },
    "instruction_bertscore": {
      "es": "0.9923058535602326",
      "arb": "0.9830552394546758",
      "sw": "0.9883703898207883",
      "tr": "0.977226629553588",
      "vi": "0.9873033474138689"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless convert_score_to_grade(56) == 'E'\nraise 'Test failed' unless convert_score_to_grade(67) == 'D'\nraise 'Test failed' unless convert_score_to_grade(100) == 'A'\nraise 'Test failed' unless convert_score_to_grade(123) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(-5) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(85) == 'B'\n  \n\nputs 'All tests passed!'",
    "entry_point": "convert_score_to_grade",
    "signature": "def convert_score_to_grade(score)",
    "docstring": {
      "en": "Converts a numerical score into a corresponding letter grade based on predefined ranges.\nThe function takes a single argument, score, which is an integer representing the score.\nIt returns a string representing the letter grade, or an error message for invalid scores.\n\nGrade Conversion:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAny other score: 'Score is error!'\n\nExamples:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "es": "Convierte una puntuación numérica en una calificación de letra correspondiente basada en rangos predefinidos. La función toma un solo argumento, score, que es un entero que representa la puntuación. Devuelve una cadena que representa la calificación de letra, o un mensaje de error para puntuaciones no válidas.\n\nConversión de Calificaciones:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nCualquier otra puntuación: '¡La puntuación es un error!'\n\nEjemplos:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'¡La puntuación es un error!'",
      "arb": "يحوّل درجة رقمية إلى درجة حرفية مقابلة بناءً على نطاقات محددة مسبقًا.  \nتأخذ الدالة وسيطًا واحدًا، score، وهو عدد صحيح يمثل الدرجة.  \nتعيد سلسلة نصية تمثل الدرجة الحرفية، أو رسالة خطأ للدرجات غير الصالحة.\n\nتحويل الدرجات:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nأي درجة أخرى: 'Score is error!'\n\nأمثلة:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "sw": "Inabadilisha alama ya nambari kuwa daraja la herufi linalolingana kulingana na viwango vilivyowekwa awali.\nKazi inachukua hoja moja, score, ambayo ni nambari inayowakilisha alama.\nInarejesha kamba inayowakilisha daraja la herufi, au ujumbe wa kosa kwa alama batili.\n\nUbadilishaji wa Daraja:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAlama nyingine yoyote: 'Score is error!'\n\nMifano:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "tr": "Sayısal bir puanı, önceden tanımlanmış aralıklara göre karşılık gelen bir harf notuna dönüştürür.\nFonksiyon, puanı temsil eden bir tamsayı olan tek bir argüman, score, alır.\nBir harf notunu temsil eden bir dize veya geçersiz puanlar için bir hata mesajı döndürür.\n\nNot Dönüşümü:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nDiğer tüm puanlar: 'Puan hatalı!'\n\nÖrnekler:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Puan hatalı!'",
      "vi": "Chuyển đổi một điểm số thành một điểm chữ tương ứng dựa trên các khoảng giá trị được định trước. \nHàm nhận một đối số duy nhất, score, là một số nguyên đại diện cho điểm số. \nNó trả về một chuỗi đại diện cho điểm chữ, hoặc một thông báo lỗi cho các điểm số không hợp lệ.\n\nChuyển đổi Điểm:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nBất kỳ điểm nào khác: 'Score is error!'\n\nVí dụ:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'"
    },
    "docstring_bertscore": {
      "es": "0.9890808906937502",
      "arb": "0.9898219806453913",
      "sw": "0.9816942240838247",
      "tr": "0.9725677539664147",
      "vi": "0.9855335507188481"
    }
  },
  {
    "task_id": "Ruby/32",
    "prompt": {
      "en": "# Calculates the minimum time required to reverse the order of M people standing in a circle.\n# In each minute, only a pair of adjacent people can swap places. The function returns the \n# minimum number of minutes required to reverse the order of the people, such that each person's \n# left neighbor becomes their right neighbor and vice versa.\n#\n# Args:\n# - m: A positive integer representing the number of people in the circle.\n#\n# Returns:\n# - An integer representing the minimum number of minutes required to achieve the reversed order.\n#\n# Examples:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "es": "# Calcula el tiempo mínimo necesario para invertir el orden de M personas paradas en un círculo.\n# En cada minuto, solo un par de personas adyacentes puede intercambiar lugares. La función devuelve el\n# número mínimo de minutos necesarios para invertir el orden de las personas, de modo que el vecino \n# izquierdo de cada persona se convierta en su vecino derecho y viceversa.\n#\n# Argumentos:\n# - m: Un entero positivo que representa el número de personas en el círculo.\n#\n# Devuelve:\n# - Un entero que representa el número mínimo de minutos necesarios para lograr el orden invertido.\n#\n# Ejemplos:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "arb": "# يحسب الحد الأدنى من الوقت المطلوب لعكس ترتيب M شخصًا يقفون في دائرة.\n# في كل دقيقة، يمكن فقط لزوج من الأشخاص المتجاورين تبديل الأماكن. تعيد الدالة \n# الحد الأدنى لعدد الدقائق المطلوبة لعكس ترتيب الأشخاص، بحيث يصبح الجار الأيسر \n# لكل شخص هو الجار الأيمن والعكس صحيح.\n#\n# الوسائط:\n# - m: عدد صحيح موجب يمثل عدد الأشخاص في الدائرة.\n#\n# يعيد:\n# - عدد صحيح يمثل الحد الأدنى لعدد الدقائق المطلوبة لتحقيق الترتيب المعكوس.\n#\n# أمثلة:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "sw": "# Inahesabu muda wa chini unaohitajika kubadilisha mpangilio wa watu M waliokuwa wamesimama kwenye duara.\n# Kila dakika, ni jozi moja tu ya watu wa karibu wanaoweza kubadilishana nafasi. Kazi inarudisha \n# idadi ya chini ya dakika zinazohitajika kubadilisha mpangilio wa watu, ili jirani wa kushoto wa kila mtu \n# awe jirani wa kulia na kinyume chake.\n#\n# Vipengele:\n# - m: Nambari chanya inayowakilisha idadi ya watu kwenye duara.\n#\n# Inarudisha:\n# - Nambari inayowakilisha idadi ya chini ya dakika zinazohitajika kufanikisha mpangilio uliobadilishwa.\n#\n# Mifano:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "tr": "# Bir dairede duran M kişinin sırasını tersine çevirmek için gereken minimum zamanı hesaplar.\n# Her dakika, yalnızca bitişik iki kişi yer değiştirebilir. Fonksiyon, kişilerin sırasını tersine\n# çevirmek için gereken minimum dakika sayısını döndürür, böylece her kişinin sol komşusu sağ\n# komşusu olur ve tam tersi.\n#\n# Argümanlar:\n# - m: Dairedeki kişi sayısını temsil eden pozitif bir tamsayı.\n#\n# Döndürür:\n# - Ters sırayı elde etmek için gereken minimum dakika sayısını temsil eden bir tamsayı.\n#\n# Örnekler:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "vi": "# Tính thời gian tối thiểu cần thiết để đảo ngược thứ tự của M người đứng trong một vòng tròn.\n# Mỗi phút, chỉ một cặp người liền kề có thể đổi chỗ cho nhau. Hàm trả về số phút tối thiểu\n# cần thiết để đảo ngược thứ tự của mọi người, sao cho người hàng xóm bên trái của mỗi người \n# trở thành hàng xóm bên phải của họ và ngược lại.\n#\n# Tham số:\n# - m: Một số nguyên dương đại diện cho số người trong vòng tròn.\n#\n# Trả về:\n# - Một số nguyên đại diện cho số phút tối thiểu cần thiết để đạt được thứ tự đảo ngược.\n#\n# Ví dụ:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)"
    },
    "prompt_bertscore": {
      "es": "0.9854602561082462",
      "arb": "0.9816648267874315",
      "sw": "0.9469525786585365",
      "tr": "0.9695102365111447",
      "vi": "0.973509063342139"
    },
    "canonical_solution": "    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end",
    "instruction": {
      "en": "Write a ruby function `def min_time_to_reverse_order(m)` to solve the following problem:\nCalculates the minimum time required to reverse the order of M people standing in a circle.\nIn each minute, only a pair of adjacent people can swap places. The function returns the\nminimum number of minutes required to reverse the order of the people, such that each person's\nleft neighbor becomes their right neighbor and vice versa.\n\nArgs:\n- m: A positive integer representing the number of people in the circle.\n\nReturns:\n- An integer representing the minimum number of minutes required to achieve the reversed order.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "es": "Escribe una función de Ruby `def min_time_to_reverse_order(m)` para resolver el siguiente problema:\nCalcula el tiempo mínimo requerido para invertir el orden de M personas paradas en un círculo.\nEn cada minuto, solo un par de personas adyacentes pueden intercambiar lugares. La función devuelve el\nnúmero mínimo de minutos necesarios para invertir el orden de las personas, de modo que el vecino\nizquierdo de cada persona se convierta en su vecino derecho y viceversa.\n\nArgumentos:\n- m: Un entero positivo que representa el número de personas en el círculo.\n\nDevuelve:\n- Un entero que representa el número mínimo de minutos necesarios para lograr el orden invertido.\n\nEjemplos:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "arb": "اكتب دالة روبي `def min_time_to_reverse_order(m)` لحل المشكلة التالية:\nتحسب الحد الأدنى من الوقت المطلوب لعكس ترتيب M شخصًا يقفون في دائرة.\nفي كل دقيقة، يمكن فقط لزوج من الأشخاص المتجاورين تبديل الأماكن. تقوم الدالة بإرجاع\nالحد الأدنى لعدد الدقائق المطلوبة لعكس ترتيب الأشخاص، بحيث يصبح الجار الأيسر لكل شخص هو الجار الأيمن والعكس صحيح.\n\nالمعاملات:\n- m: عدد صحيح موجب يمثل عدد الأشخاص في الدائرة.\n\nالإرجاع:\n- عدد صحيح يمثل الحد الأدنى لعدد الدقائق المطلوبة لتحقيق الترتيب المعكوس.\n\nأمثلة:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "sw": "Andika kazi ya ruby `def min_time_to_reverse_order(m)` kutatua tatizo lifuatalo:\nHesabu muda wa chini unaohitajika kubadilisha mpangilio wa watu M wanaosimama kwenye mduara.\nKila dakika, ni jozi moja tu ya watu wa karibu wanaweza kubadilishana nafasi. Kazi inarudisha\nidadi ya chini ya dakika zinazohitajika kubadilisha mpangilio wa watu, ili jirani wa kushoto wa kila mtu awe jirani wa kulia na kinyume chake.\n\nVipengele:\n- m: Nambari chanya inayowakilisha idadi ya watu kwenye mduara.\n\nInarudisha:\n- Nambari inayowakilisha idadi ya chini ya dakika zinazohitajika kufikia mpangilio uliobadilishwa.\n\nMifano:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "tr": "Bir ruby fonksiyonu `def min_time_to_reverse_order(m)` yazın ve aşağıdaki problemi çözün:\nBir dairede duran M kişinin sırasını tersine çevirmek için gereken minimum zamanı hesaplar.\nHer dakikada, yalnızca bitişik bir çift kişi yer değiştirebilir. Fonksiyon, her kişinin\nsol komşusunun sağ komşusu ve tam tersi olacak şekilde kişilerin sırasını tersine çevirmek için\ngerekli minimum dakika sayısını döndürür.\n\nArgümanlar:\n- m: Dairedeki kişi sayısını temsil eden pozitif bir tamsayı.\n\nDöndürür:\n- Ters sırayı elde etmek için gereken minimum dakika sayısını temsil eden bir tamsayı.\n\nÖrnekler:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "vi": "Viết một hàm ruby `def min_time_to_reverse_order(m)` để giải quyết vấn đề sau:\nTính toán thời gian tối thiểu cần thiết để đảo ngược thứ tự của M người đứng trong một vòng tròn.\nTrong mỗi phút, chỉ một cặp người liền kề có thể hoán đổi vị trí. Hàm trả về\nsố phút tối thiểu cần thiết để đảo ngược thứ tự của những người, sao cho mỗi người hàng xóm bên trái trở thành hàng xóm bên phải của họ và ngược lại.\n\nTham số:\n- m: Một số nguyên dương đại diện cho số người trong vòng tròn.\n\nTrả về:\n- Một số nguyên đại diện cho số phút tối thiểu cần thiết để đạt được thứ tự đảo ngược.\n\nVí dụ:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6"
    },
    "instruction_bertscore": {
      "es": "0.9903465634817045",
      "arb": "0.9813988607072258",
      "sw": "0.9812000316958099",
      "tr": "0.9829233488816685",
      "vi": "0.986050982861444"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless min_time_to_reverse_order(4) == 2\nraise 'Test failed' unless min_time_to_reverse_order(5) == 4\nraise 'Test failed' unless min_time_to_reverse_order(6) == 6\nraise 'Test failed' unless min_time_to_reverse_order(7) == 9\nraise 'Test failed' unless min_time_to_reverse_order(10) == 20\n\n\n\nputs 'All tests passed!'",
    "entry_point": "min_time_to_reverse_order",
    "signature": "def min_time_to_reverse_order(m)",
    "docstring": {
      "en": "Calculates the minimum time required to reverse the order of M people standing in a circle.\nIn each minute, only a pair of adjacent people can swap places. The function returns the\nminimum number of minutes required to reverse the order of the people, such that each person's\nleft neighbor becomes their right neighbor and vice versa.\n\nArgs:\n- m: A positive integer representing the number of people in the circle.\n\nReturns:\n- An integer representing the minimum number of minutes required to achieve the reversed order.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "es": "Calcula el tiempo mínimo requerido para invertir el orden de M personas paradas en un círculo. En cada minuto, solo un par de personas adyacentes puede intercambiar lugares. La función devuelve el número mínimo de minutos necesarios para invertir el orden de las personas, de modo que el vecino de la izquierda de cada persona se convierta en su vecino de la derecha y viceversa.\n\nArgumentos:\n- m: Un entero positivo que representa el número de personas en el círculo.\n\nDevuelve:\n- Un entero que representa el número mínimo de minutos necesarios para lograr el orden invertido.\n\nEjemplos:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "arb": "يحسب الحد الأدنى من الوقت المطلوب لعكس ترتيب M شخصًا يقفون في دائرة. في كل دقيقة، يمكن فقط لزوج من الأشخاص المتجاورين تبديل الأماكن. تُرجع الدالة الحد الأدنى لعدد الدقائق المطلوبة لعكس ترتيب الأشخاص، بحيث يصبح الجار الأيسر لكل شخص هو الجار الأيمن والعكس صحيح.\n\nالمعطيات:\n- m: عدد صحيح موجب يمثل عدد الأشخاص في الدائرة.\n\nالقيم المعادة:\n- عدد صحيح يمثل الحد الأدنى لعدد الدقائق المطلوبة لتحقيق الترتيب المعكوس.\n\nأمثلة:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "sw": "Hesabu muda wa chini unaohitajika kubadilisha mpangilio wa watu M waliokuwa wamesimama kwenye mduara. Katika kila dakika, ni jozi moja tu ya watu wa karibu wanaweza kubadilishana nafasi. Kazi inarudisha idadi ya chini ya dakika zinazohitajika kubadilisha mpangilio wa watu, ili jirani wa kushoto wa kila mtu awe jirani wa kulia na kinyume chake.\n\nHoja:\n- m: Nambari chanya inayowakilisha idadi ya watu kwenye mduara.\n\nInarejesha:\n- Nambari inayowakilisha idadi ya chini ya dakika zinazohitajika kufanikisha mpangilio uliobadilishwa.\n\nHoja:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "tr": "M kişisinin bir dairedeki sırasını tersine çevirmek için gereken minimum zamanı hesaplar.\nHer dakikada, yalnızca bitişik iki kişi yer değiştirebilir. Fonksiyon, her kişinin sol komşusunun sağ komşusu ve sağ komşusunun sol komşusu olacak şekilde, kişilerin sırasını tersine çevirmek için gereken minimum dakika sayısını döndürür.\n\nArgümanlar:\n- m: Dairedeki kişi sayısını temsil eden pozitif bir tam sayı.\n\nDöndürür:\n- Ters sıra elde etmek için gereken minimum dakika sayısını temsil eden bir tam sayı.\n\nArgümanlar:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "vi": "Tính toán thời gian tối thiểu cần thiết để đảo ngược thứ tự của M người đứng trong một vòng tròn. Trong mỗi phút, chỉ có một cặp người liền kề có thể đổi chỗ cho nhau. Hàm trả về số phút tối thiểu cần thiết để đảo ngược thứ tự của những người, sao cho người hàng xóm bên trái của mỗi người trở thành hàng xóm bên phải của họ và ngược lại.\n\nTham số:\n- m: Một số nguyên dương đại diện cho số người trong vòng tròn.\n\nTrả về:\n- Một số nguyên đại diện cho số phút tối thiểu cần thiết để đạt được thứ tự đảo ngược.\n\nVí dụ:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6"
    },
    "docstring_bertscore": {
      "es": "0.9890276577516328",
      "arb": "0.9796511119844998",
      "sw": "0.9521503384694575",
      "tr": "0.9670253704443982",
      "vi": "0.9787886588700464"
    }
  },
  {
    "task_id": "Ruby/33",
    "prompt": {
      "en": "# Generates all unique four-digit permutations using the given four digits.\n# Each digit is used exactly once in each permutation. The function accepts\n# four integers as arguments and returns an array of strings, each representing\n# a unique permutation. The permutations are sorted in ascending order.\n#\n# Example:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "es": "# Genera todas las permutaciones únicas de cuatro dígitos utilizando los cuatro dígitos dados.\n# Cada dígito se usa exactamente una vez en cada permutación. La función acepta\n# cuatro enteros como argumentos y devuelve un arreglo de cadenas, cada una representando\n# una permutación única. Las permutaciones están ordenadas en orden ascendente.\n#\n# Ejemplo:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "arb": "# يولد جميع التباديل الفريدة المكونة من أربعة أرقام باستخدام الأرقام الأربعة المعطاة.\n# يتم استخدام كل رقم مرة واحدة بالضبط في كل تبادل. تقبل الدالة\n# أربعة أعداد صحيحة كوسائط وتعيد مصفوفة من السلاسل، كل منها تمثل\n# تبادلًا فريدًا. يتم ترتيب التباديل بترتيب تصاعدي.\n#\n# مثال:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "sw": "# Hutoa mchanganyiko wa kipekee wa tarakimu nne kwa kutumia tarakimu nne zilizotolewa.\n# Kila tarakimu inatumika mara moja tu katika kila mchanganyiko. Kazi inakubali\n# tarakimu nne kama hoja na inarudisha safu ya mistari, kila moja ikiwakilisha\n# mchanganyiko wa kipekee. Mchanganyiko umewekwa kwa mpangilio wa kupanda.\n#\n# Mfano:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "tr": "# Verilen dört basamağı kullanarak tüm benzersiz dört basamaklı permütasyonları oluşturur.\n# Her basamak her permütasyonda tam olarak bir kez kullanılır. Fonksiyon,\n# dört tamsayıyı argüman olarak kabul eder ve her biri benzersiz bir permütasyonu temsil eden\n# bir dizi string döndürür. Permütasyonlar artan sırayla sıralanır.\n#\n# Örnek:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "vi": "# Tạo tất cả các hoán vị bốn chữ số duy nhất sử dụng bốn chữ số đã cho.\n# Mỗi chữ số được sử dụng đúng một lần trong mỗi hoán vị. Hàm chấp nhận\n# bốn số nguyên làm đối số và trả về một mảng chuỗi, mỗi chuỗi đại diện cho\n# một hoán vị duy nhất. Các hoán vị được sắp xếp theo thứ tự tăng dần.\n#\n# Ví dụ:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)"
    },
    "prompt_bertscore": {
      "es": "0.9948465347640498",
      "arb": "0.9828699173091702",
      "sw": "0.950558514595844",
      "tr": "0.9913232290652529",
      "vi": "0.991021509516461"
    },
    "canonical_solution": "    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end",
    "instruction": {
      "en": "Write a ruby function `def generate_four_digit_permutations(*digits)` to solve the following problem:\nGenerates all unique four-digit permutations using the given four digits.\nEach digit is used exactly once in each permutation. The function accepts\nfour integers as arguments and returns an array of strings, each representing\na unique permutation. The permutations are sorted in ascending order.\n\nExample:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "es": "Escribe una función en Ruby `def generate_four_digit_permutations(*digits)` para resolver el siguiente problema:\nGenera todas las permutaciones únicas de cuatro dígitos utilizando los cuatro dígitos dados.\nCada dígito se utiliza exactamente una vez en cada permutación. La función acepta\ncuatro enteros como argumentos y devuelve un arreglo de cadenas, cada una representando\nuna permutación única. Las permutaciones están ordenadas en orden ascendente.\n\nEjemplo:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "arb": "اكتب دالة روبي `def generate_four_digit_permutations(*digits)` لحل المشكلة التالية:\nتوليد جميع التباديل الفريدة المكونة من أربعة أرقام باستخدام الأرقام الأربعة المعطاة.\nيتم استخدام كل رقم مرة واحدة فقط في كل تبديل. تقبل الدالة\nأربعة أعداد صحيحة كمعطيات وتعيد مصفوفة من السلاسل، كل منها تمثل\nتبديلًا فريدًا. يتم ترتيب التباديل بترتيب تصاعدي.\n\nمثال:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "sw": "Andika kazi ya ruby `def generate_four_digit_permutations(*digits)` kutatua tatizo lifuatalo:  \nInazalisha mchanganyiko wa kipekee wa tarakimu nne kwa kutumia tarakimu nne zilizotolewa.  \nKila tarakimu inatumika mara moja tu katika kila mchanganyiko. Kazi inakubali  \nnambari nne kama hoja na inarudisha safu ya mistari, kila moja ikiwakilisha  \nmchanganyiko wa kipekee. Mchanganyiko hupangwa kwa mpangilio wa kupanda.  \n\nMfano:  \n>>> generate_four_digit_permutations(1, 2, 3, 4)  \n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]  \n>>> generate_four_digit_permutations(1, 2, 3, 5)  \n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "tr": "Bir ruby fonksiyonu `def generate_four_digit_permutations(*digits)` yazın:\nVerilen dört rakamı kullanarak tüm benzersiz dört basamaklı permütasyonları oluşturur.\nHer permütasyonda her rakam tam olarak bir kez kullanılır. Fonksiyon,\nargüman olarak dört tam sayı alır ve her biri benzersiz bir permütasyonu temsil eden\nbir dizi string döndürür. Permütasyonlar artan sırayla sıralanır.\n\nÖrnek:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "vi": "Viết một hàm ruby `def generate_four_digit_permutations(*digits)` để giải quyết vấn đề sau:\nTạo ra tất cả các hoán vị bốn chữ số duy nhất sử dụng bốn chữ số đã cho.\nMỗi chữ số được sử dụng chính xác một lần trong mỗi hoán vị. Hàm chấp nhận\nbốn số nguyên làm tham số và trả về một mảng các chuỗi, mỗi chuỗi đại diện cho\nmột hoán vị duy nhất. Các hoán vị được sắp xếp theo thứ tự tăng dần.\n\nVí dụ:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]"
    },
    "instruction_bertscore": {
      "es": "0.9921652232504599",
      "arb": "0.9920208189634475",
      "sw": "0.9539020597998041",
      "tr": "0.96976845600649",
      "vi": "0.9973347775472738"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless generate_four_digit_permutations(1, 2, 3, 4) == [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", \"2134\", \"2143\", \"2314\", \"2341\", \"2413\", \"2431\", \"3124\", \"3142\", \"3214\", \"3241\", \"3412\", \"3421\", \"4123\", \"4132\", \"4213\", \"4231\", \"4312\", \"4321\"]\n\nraise 'Test failed' unless generate_four_digit_permutations(1, 2, 3, 5) == [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", \"2135\", \"2153\", \"2315\", \"2351\", \"2513\", \"2531\", \"3125\", \"3152\", \"3215\", \"3251\", \"3512\", \"3521\", \"5123\", \"5132\", \"5213\", \"5231\", \"5312\", \"5321\"]\n   \n\n\nputs 'All tests passed!'",
    "entry_point": "generate_four_digit_permutations",
    "signature": "def generate_four_digit_permutations(*digits)",
    "docstring": {
      "en": "Generates all unique four-digit permutations using the given four digits.\nEach digit is used exactly once in each permutation. The function accepts\nfour integers as arguments and returns an array of strings, each representing\na unique permutation. The permutations are sorted in ascending order.\n\nExample:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "es": "Genera todas las permutaciones únicas de cuatro dígitos utilizando los cuatro dígitos dados. Cada dígito se utiliza exactamente una vez en cada permutación. La función acepta cuatro enteros como argumentos y devuelve un arreglo de cadenas, cada una representando una permutación única. Las permutaciones están ordenadas en orden ascendente.\n\nEjemplo:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "arb": "ينشئ جميع التباديل الفريدة المكونة من أربعة أرقام باستخدام الأرقام الأربعة المعطاة. يتم استخدام كل رقم مرة واحدة فقط في كل تبديل. تقبل الدالة أربعة أعداد صحيحة كوسائط وتعيد مصفوفة من السلاسل، كل منها يمثل تبديلًا فريدًا. يتم ترتيب التباديل بترتيب تصاعدي.\n\nمثال:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "sw": "Hutengeneza mchanganyiko wa kipekee wa tarakimu nne kwa kutumia tarakimu nne zilizotolewa. Kila tarakimu inatumika mara moja tu katika kila mchanganyiko. Kazi hii inakubali nambari nne kama hoja na inarejesha safu ya mistari, kila moja ikiwakilisha mchanganyiko wa kipekee. Mchanganyiko umewekwa katika mpangilio wa kupanda.\n\nMfano:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "tr": "Verilen dört basamaklı rakamları kullanarak tüm benzersiz dört basamaklı permütasyonları oluşturur. Her permütasyonda her rakam tam olarak bir kez kullanılır. Fonksiyon dört tam sayı argüman olarak alır ve her biri benzersiz bir permütasyonu temsil eden bir dizi string döndürür. Permütasyonlar artan sırayla sıralanmıştır.\n\nÖrnek:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "vi": "Tạo tất cả các hoán vị bốn chữ số duy nhất sử dụng bốn chữ số đã cho. Mỗi chữ số được sử dụng chính xác một lần trong mỗi hoán vị. Hàm chấp nhận bốn số nguyên làm đối số và trả về một mảng các chuỗi, mỗi chuỗi đại diện cho một hoán vị duy nhất. Các hoán vị được sắp xếp theo thứ tự tăng dần.\n\nVí dụ:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]"
    },
    "docstring_bertscore": {
      "es": "0.9954932752846994",
      "arb": "0.9816916418888713",
      "sw": "0.9356163455521134",
      "tr": "0.9934213617801245",
      "vi": "0.9928473199789337"
    }
  },
  {
    "task_id": "Ruby/34",
    "prompt": {
      "en": "# Counts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\n# The function takes a single argument, n, which is a positive integer, and returns the count of numbers \n# that are related to 7 as per the criteria.\n#\n# Example:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "es": "# Cuenta la cantidad de números menores o iguales a n que son múltiplos de 7 o contienen el dígito '7'.\n# La función toma un solo argumento, n, que es un entero positivo, y devuelve la cuenta de números\n# que están relacionados con el 7 según los criterios.\n#\n# Ejemplo:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "arb": "# يحسب عدد الأرقام الأقل من أو تساوي n التي هي إما مضاعفات للعدد 7 أو تحتوي على الرقم '7'.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد عدد الأرقام \n# المتعلقة بالعدد 7 وفقًا للمعايير.\n#\n# مثال:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "sw": "# Inahesabu idadi ya namba zilizo chini au sawa na n ambazo ni ama vizidisho vya 7 au zina namba '7'.\n# Kazi inachukua hoja moja, n, ambayo ni nambari chanya, na inarejesha idadi ya namba \n# zinazohusiana na 7 kulingana na vigezo.\n#\n# Mfano:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "tr": "# n'den küçük veya n'ye eşit olan ve ya 7'nin katı olan ya da '7' rakamını içeren sayıların sayısını sayar.\n# Fonksiyon, pozitif bir tam sayı olan n isimli tek bir argüman alır ve belirtilen kriterlere göre 7 ile ilişkili sayıların sayısını döndürür.\n#\n# Örnek:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "vi": "# Đếm số lượng các số nhỏ hơn hoặc bằng n mà là bội số của 7 hoặc chứa chữ số '7'.\n# Hàm nhận một tham số duy nhất, n, là một số nguyên dương, và trả về số lượng các số \n# liên quan đến 7 theo tiêu chí đã cho.\n#\n# Ví dụ:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)"
    },
    "prompt_bertscore": {
      "es": "0.9884941365481731",
      "arb": "0.9656629646608799",
      "sw": "0.9764325052902105",
      "tr": "0.969119331921268",
      "vi": "0.9721843973310174"
    },
    "canonical_solution": "    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end",
    "instruction": {
      "en": "Write a ruby function `def count_seven_related_numbers(n)` to solve the following problem:\nCounts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\nThe function takes a single argument, n, which is a positive integer, and returns the count of numbers\nthat are related to 7 as per the criteria.\n\nExample:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "es": "Escribe una función en ruby `def count_seven_related_numbers(n)` para resolver el siguiente problema:\nCuenta la cantidad de números menores o iguales a n que son múltiplos de 7 o contienen el dígito '7'.\nLa función toma un solo argumento, n, que es un entero positivo, y devuelve la cantidad de números\nque están relacionados con 7 según los criterios.\n\nEjemplo:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "arb": "اكتب دالة روبي `def count_seven_related_numbers(n)` لحل المشكلة التالية:\nتحسب عدد الأرقام الأقل من أو تساوي n التي تكون إما مضاعفات للعدد 7 أو تحتوي على الرقم '7'.\nتأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد عدد الأرقام\nالتي ترتبط بالعدد 7 وفقًا للمعايير.\n\nمثال:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "sw": "Andika kazi ya ruby `def count_seven_related_numbers(n)` kutatua tatizo lifuatalo:\nInahesabu idadi ya namba zilizo chini au sawa na n ambazo ni nyingi za 7 au zina namba '7'.\nKazi inachukua hoja moja, n, ambayo ni nambari nzima chanya, na inarudisha hesabu ya namba\nambazo zinahusiana na 7 kulingana na vigezo.\n\nMfano:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "tr": "Bir ruby fonksiyonu `def count_seven_related_numbers(n)` yazın: Aşağıdaki problemi çözmek için:\n7'nin katı olan veya '7' rakamını içeren, n'ye eşit veya n'den küçük olan sayıların sayısını sayar.\nFonksiyon, pozitif bir tamsayı olan n adlı tek bir argüman alır ve belirtilen kriterlere göre 7 ile ilişkili sayıların sayısını döndürür.\n\nÖrnek:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "vi": "Viết một hàm ruby `def count_seven_related_numbers(n)` để giải quyết vấn đề sau:\nĐếm số lượng các số nhỏ hơn hoặc bằng n mà là bội số của 7 hoặc chứa chữ số '7'.\nHàm nhận một đối số duy nhất, n, là một số nguyên dương, và trả về số lượng các số\nliên quan đến 7 theo tiêu chí đã cho.\n\nVí dụ:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2"
    },
    "instruction_bertscore": {
      "es": "0.9824893414991074",
      "arb": "0.9708774094238078",
      "sw": "0.9829877051251239",
      "tr": "0.947273962615051",
      "vi": "0.9772917803185674"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_seven_related_numbers(20) == 3\nraise 'Test failed' unless count_seven_related_numbers(15) == 2\nraise 'Test failed' unless count_seven_related_numbers(50) == 11\nraise 'Test failed' unless count_seven_related_numbers(28) == 6\nraise 'Test failed' unless count_seven_related_numbers(100) == 30\n  \n\nputs 'All tests passed!'",
    "entry_point": "count_seven_related_numbers",
    "signature": "def count_seven_related_numbers(n)",
    "docstring": {
      "en": "Counts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\nThe function takes a single argument, n, which is a positive integer, and returns the count of numbers\nthat are related to 7 as per the criteria.\n\nExample:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "es": "Cuenta la cantidad de números menores o iguales a n que son múltiplos de 7 o contienen el dígito '7'.  \nLa función toma un solo argumento, n, que es un número entero positivo, y devuelve la cantidad de números  \nque están relacionados con el 7 según los criterios.\n\nEjemplo:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "arb": "يحسب عدد الأرقام الأقل من أو تساوي n والتي إما أن تكون من مضاعفات 7 أو تحتوي على الرقم '7'. تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد عدد الأرقام المرتبطة بـ 7 وفقًا للمعايير.\n\nمثال:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "sw": "Hesabu idadi ya nambari zilizo chini au sawa na n ambazo ni ama vizidisho vya 7 au zina nambari '7'. \nKazi inachukua hoja moja, n, ambayo ni nambari nzima chanya, na inarudisha hesabu ya nambari \nzinazohusiana na 7 kulingana na vigezo.\n\nMfano:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "tr": "7'nin katı olan veya '7' rakamını içeren n'den küçük veya n'ye eşit sayıların sayısını sayar. \nFonksiyon, pozitif bir tam sayı olan n adlı tek bir argüman alır ve kriterlere göre 7 ile ilgili sayıların sayısını döndürür.\n\nÖrnek:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "vi": "Đếm số lượng các số nhỏ hơn hoặc bằng n mà là bội số của 7 hoặc chứa chữ số '7'. Hàm nhận một đối số duy nhất, n, là một số nguyên dương, và trả về số lượng các số liên quan đến 7 theo tiêu chí.\n\nVí dụ:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2"
    },
    "docstring_bertscore": {
      "es": "0.9807135858926554",
      "arb": "0.9737416595183309",
      "sw": "0.9745399550197101",
      "tr": "0.9704535321906793",
      "vi": "0.9774270476080522"
    }
  },
  {
    "task_id": "Ruby/35",
    "prompt": {
      "en": "# Finds all possible last two digits of a number that, when added to the number 'a',\n# makes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is \n# a positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\n# The function returns an array of strings representing the possible two-digit suffixes.\n#\n# Example:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "es": "# Encuentra todos los posibles últimos dos dígitos de un número que, al sumarse al número 'a',\n# lo hace divisible por 'b'. La función toma dos argumentos, 'a' y 'b', donde 'a' es\n# un entero positivo menor que 10000, y 'b' es un entero positivo entre 10 y 100.\n# La función devuelve un arreglo de cadenas que representan los posibles sufijos de dos dígitos.\n#\n# Ejemplo:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "arb": "# يجد جميع الأرقام المحتملة لآخر رقمين لعدد، والتي عند إضافتها إلى العدد 'a',\n# تجعلها قابلة للقسمة على 'b'. تأخذ الدالة معاملين، 'a' و 'b'، حيث 'a' هو \n# عدد صحيح موجب أقل من 10000، و 'b' هو عدد صحيح موجب بين 10 و 100.\n# ترجع الدالة مصفوفة من السلاسل النصية التي تمثل الأرقام المحتملة لآخر رقمين.\n#\n# مثال:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "sw": "# Inapata tarakimu mbili za mwisho zinazowezekana za nambari ambayo, ikiongezwa kwenye nambari 'a',\n# inafanya iweze kugawanyika na 'b'. Kazi inachukua hoja mbili, 'a' na 'b', ambapo 'a' ni\n# nambari kamili chanya chini ya 10000, na 'b' ni nambari kamili chanya kati ya 10 na 100.\n# Kazi inarudisha safu ya mistari inayowakilisha viambatisho vya tarakimu mbili vinavyowezekana.\n#\n# Mfano:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "tr": "# 'a' sayısına eklendiğinde 'b' ile bölünebilir hale getiren bir sayının \n# son iki basamağını bulur. Fonksiyon, 'a' ve 'b' olmak üzere iki argüman alır; \n# burada 'a', 10000'den küçük pozitif bir tam sayı ve 'b', 10 ile 100 arasında \n# pozitif bir tam sayıdır. Fonksiyon, olası iki basamaklı son ekleri temsil eden \n# bir dizi döndürür.\n#\n# Örnek:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "vi": "# Tìm tất cả các chữ số cuối có thể có của một số mà khi cộng vào số 'a',\n# làm cho nó chia hết cho 'b'. Hàm nhận hai tham số, 'a' và 'b', trong đó 'a' là\n# một số nguyên dương nhỏ hơn 10000, và 'b' là một số nguyên dương trong khoảng từ 10 đến 100.\n# Hàm trả về một mảng các chuỗi đại diện cho các hậu tố hai chữ số có thể có.\n#\n# Ví dụ:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)"
    },
    "prompt_bertscore": {
      "es": "0.9940478420019085",
      "arb": "0.9668583222939479",
      "sw": "0.9949887541168708",
      "tr": "0.9665768630440215",
      "vi": "0.9824865606737728"
    },
    "canonical_solution": "    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end",
    "instruction": {
      "en": "Write a ruby function `def find_possible_last_digits(a, b)` to solve the following problem:\nFinds all possible last two digits of a number that, when added to the number 'a',\nmakes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is\na positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\nThe function returns an array of strings representing the possible two-digit suffixes.\n\nExample:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "es": "Escribe una función en Ruby `def find_possible_last_digits(a, b)` para resolver el siguiente problema:\nEncuentra todos los posibles últimos dos dígitos de un número que, cuando se suman al número 'a',\nlo hacen divisible por 'b'. La función toma dos argumentos, 'a' y 'b', donde 'a' es\nun entero positivo menor que 10000, y 'b' es un entero positivo entre 10 y 100.\nLa función devuelve un arreglo de cadenas que representan los posibles sufijos de dos dígitos.\n\nEjemplo:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "arb": "اكتب دالة روبي `def find_possible_last_digits(a, b)` لحل المشكلة التالية:\nتجد جميع الأرقام الممكنة لآخر رقمين لعدد، عندما يضاف إلى العدد 'a'، يجعله قابلاً للقسمة على 'b'. تأخذ الدالة وسيطين، 'a' و 'b'، حيث أن 'a' هو عدد صحيح موجب أقل من 10000، و 'b' هو عدد صحيح موجب بين 10 و 100. تعيد الدالة مصفوفة من السلاسل النصية التي تمثل الأرقام المحتملة لآخر رقمين.\n\nمثال:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "sw": "Andika kazi ya ruby `def find_possible_last_digits(a, b)` kutatua tatizo lifuatalo:\nInapata tarakimu mbili za mwisho zinazowezekana za nambari ambayo, inapoongezwa kwa nambari 'a',\ninaifanya igawike kwa 'b'. Kazi inachukua hoja mbili, 'a' na 'b', ambapo 'a' ni\nnambari kamili chanya chini ya 10000, na 'b' ni nambari kamili chanya kati ya 10 na 100.\nKazi inarudisha safu ya mistari inayoonyesha viambishi vya tarakimu mbili vinavyowezekana.\n\nMfano:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "tr": "Bir ruby fonksiyonu `def find_possible_last_digits(a, b)` yazın ve aşağıdaki problemi çözün:\nBir sayının son iki basamağının tüm olası değerlerini bulun. Bu sayılar, 'a' sayısına eklendiğinde, 'b' sayısına bölünebilir olmalıdır. Fonksiyon iki argüman alır, 'a' ve 'b', burada 'a' 10000'den küçük pozitif bir tam sayıdır ve 'b' 10 ile 100 arasında pozitif bir tam sayıdır. Fonksiyon, olası iki basamaklı son ekleri temsil eden bir dizi döndürür.\n\nÖrnek:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "vi": "Viết một hàm ruby `def find_possible_last_digits(a, b)` để giải quyết vấn đề sau:\nTìm tất cả các chữ số cuối cùng có thể có của một số mà khi cộng vào số 'a',\nlàm cho nó chia hết cho 'b'. Hàm nhận hai tham số, 'a' và 'b', trong đó 'a' là\nmột số nguyên dương nhỏ hơn 10000, và 'b' là một số nguyên dương từ 10 đến 100.\nHàm trả về một mảng các chuỗi đại diện cho các hậu tố hai chữ số có thể có.\n\nVí dụ:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]"
    },
    "instruction_bertscore": {
      "es": "0.993680773057756",
      "arb": "0.9732786521001385",
      "sw": "0.9897127339358222",
      "tr": "0.9677839398695705",
      "vi": "0.9849652691987072"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless find_possible_last_digits(200, 40) == [\"00\", \"40\", \"80\"]\nraise 'Test failed' unless find_possible_last_digits(1992, 95) == [\"15\"]\nraise 'Test failed' unless find_possible_last_digits(1500, 25) == [\"00\", \"25\", \"50\", \"75\"]\nraise 'Test failed' unless find_possible_last_digits(300, 30) == [\"00\", \"30\", \"60\", \"90\"]\n  \nputs 'All tests passed!'",
    "entry_point": "find_possible_last_digits",
    "signature": "def find_possible_last_digits(a, b)",
    "docstring": {
      "en": "Finds all possible last two digits of a number that, when added to the number 'a',\nmakes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is\na positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\nThe function returns an array of strings representing the possible two-digit suffixes.\n\nExample:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "es": "Encuentra todos los posibles últimos dos dígitos de un número que, al sumarse al número 'a', lo hace divisible por 'b'. La función toma dos argumentos, 'a' y 'b', donde 'a' es un entero positivo menor que 10000, y 'b' es un entero positivo entre 10 y 100. La función devuelve un arreglo de cadenas que representan los posibles sufijos de dos dígitos.\n\nEjemplo:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "arb": "يجد جميع الأرقام المحتملة لآخر رقمين لعدد، بحيث عند إضافتها إلى العدد 'a'، يصبح قابلاً للقسمة على 'b'. تأخذ الدالة وسيطين، 'a' و 'b'، حيث أن 'a' هو عدد صحيح موجب أقل من 10000، و 'b' هو عدد صحيح موجب بين 10 و 100. تعيد الدالة مصفوفة من السلاسل النصية التي تمثل الأرقام المحتملة لآخر رقمين.\n\nمثال:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "sw": "Inapata tarakimu mbili za mwisho zinazowezekana za nambari ambayo, inapoongezwa kwa nambari 'a', inafanya iweze kugawanyika kwa 'b'. Kazi inachukua hoja mbili, 'a' na 'b', ambapo 'a' ni nambari nzima chanya chini ya 10000, na 'b' ni nambari nzima chanya kati ya 10 na 100. Kazi inarudisha safu ya mistari ya maandishi inayowakilisha viambishi vya tarakimu mbili vinavyowezekana.\n\nMfano:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "tr": "Bir sayıya eklendiğinde, sayıyı 'b' ile bölünebilir yapan tüm olası son iki basamağı bulur. Fonksiyon, 'a' ve 'b' olmak üzere iki argüman alır; burada 'a', 10000'den küçük pozitif bir tamsayı ve 'b', 10 ile 100 arasında bir pozitif tamsayıdır. Fonksiyon, olası iki basamaklı son ekleri temsil eden bir dizi döndürür.\n\nÖrnek:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "vi": "Tìm tất cả các chữ số cuối có thể có của một số mà khi cộng vào số 'a', làm cho nó chia hết cho 'b'. Hàm nhận hai đối số, 'a' và 'b', trong đó 'a' là một số nguyên dương nhỏ hơn 10000, và 'b' là một số nguyên dương nằm trong khoảng từ 10 đến 100. Hàm trả về một mảng các chuỗi đại diện cho các hậu tố hai chữ số có thể có.\n\nVí dụ:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]"
    },
    "docstring_bertscore": {
      "es": "0.9935997318622938",
      "arb": "0.9565325219358493",
      "sw": "0.9890213015794397",
      "tr": "0.9644318535592257",
      "vi": "0.9860424417550594"
    }
  },
  {
    "task_id": "Ruby/36",
    "prompt": {
      "en": "# Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\n# The tiles used must be smaller than n x n and can be of varying sizes. \n# The function takes a single argument, n, which is a positive integer representing the size of the room, \n# and returns the minimum number of tiles required.\n#\n# Example:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "es": "# Calcula el número mínimo de baldosas cuadradas necesarias para cubrir completamente una habitación cuadrada de tamaño n x n.\n# Las baldosas utilizadas deben ser más pequeñas que n x n y pueden ser de tamaños variados.\n# La función toma un solo argumento, n, que es un número entero positivo que representa el tamaño de la habitación,\n# y devuelve el número mínimo de baldosas necesarias.\n#\n# Ejemplo:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "arb": "# يحسب الحد الأدنى لعدد البلاط المربع المطلوب لتغطية غرفة مربعة بحجم n x n بالكامل.\n# يجب أن يكون البلاط المستخدم أصغر من n x n ويمكن أن يكون بأحجام مختلفة.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب يمثل حجم الغرفة،\n# وتعيد الحد الأدنى لعدد البلاط المطلوب.\n#\n# مثال:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "sw": "# Inahesabu idadi ndogo ya vigae vya mraba vinavyohitajika kufunika kabisa chumba cha mraba cha ukubwa wa n x n.\n# Vigae vinavyotumika lazima viwe vidogo kuliko n x n na vinaweza kuwa vya ukubwa tofauti.\n# Kazi inachukua hoja moja, n, ambayo ni nambari kamili chanya inayowakilisha ukubwa wa chumba,\n# na inarudisha idadi ndogo ya vigae vinavyohitajika.\n#\n# Mfano:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "tr": "# n x n boyutundaki kare bir odayı tamamen kaplamak için gereken minimum kare karo sayısını hesaplar.\n# Kullanılan karolar n x n'den küçük olmalı ve farklı boyutlarda olabilir.\n# Fonksiyon, odanın boyutunu temsil eden pozitif bir tam sayı olan n adlı tek bir argüman alır\n# ve gereken minimum karo sayısını döndürür.\n#\n# Örnek:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "vi": "# Tính toán số lượng gạch vuông nhỏ nhất cần thiết để phủ kín hoàn toàn một căn phòng hình vuông kích thước n x n.\n# Các viên gạch sử dụng phải nhỏ hơn n x n và có thể có kích thước khác nhau.\n# Hàm nhận một đối số duy nhất, n, là một số nguyên dương đại diện cho kích thước của phòng,\n# và trả về số lượng gạch nhỏ nhất cần thiết.\n#\n# Ví dụ:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)"
    },
    "prompt_bertscore": {
      "es": "0.9950503295349916",
      "arb": "0.9925320935642313",
      "sw": "0.9915492704388706",
      "tr": "0.9902168578428886",
      "vi": "0.9878652727618166"
    },
    "canonical_solution": "    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end",
    "instruction": {
      "en": "Write a ruby function `def min_tiles_required(n)` to solve the following problem:\nCalculates the minimum number of square tiles required to completely cover a square room of size n x n.\nThe tiles used must be smaller than n x n and can be of varying sizes.\nThe function takes a single argument, n, which is a positive integer representing the size of the room,\nand returns the minimum number of tiles required.\n\nExample:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "es": "Escribe una función en ruby `def min_tiles_required(n)` para resolver el siguiente problema:\nCalcula el número mínimo de baldosas cuadradas necesarias para cubrir completamente una habitación cuadrada de tamaño n x n.\nLas baldosas utilizadas deben ser más pequeñas que n x n y pueden ser de tamaños variados.\nLa función toma un solo argumento, n, que es un entero positivo que representa el tamaño de la habitación,\ny devuelve el número mínimo de baldosas requeridas.\n\nEjemplo:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "arb": "اكتب دالة روبي `def min_tiles_required(n)` لحل المشكلة التالية:\nتحسب الحد الأدنى لعدد البلاط المربع المطلوب لتغطية غرفة مربعة بحجم n x n بالكامل.\nيجب أن يكون البلاط المستخدم أصغر من n x n ويمكن أن يكون بأحجام مختلفة.\nتأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب يمثل حجم الغرفة،\nوتعيد الحد الأدنى لعدد البلاط المطلوب.\n\nمثال:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "sw": "Andika kazi ya ruby `def min_tiles_required(n)` kutatua tatizo lifuatalo:  \nInahesabu idadi ndogo zaidi ya vigae vya mraba vinavyohitajika kufunika kabisa chumba cha mraba cha ukubwa wa n x n.  \nVigae vinavyotumika lazima viwe vidogo kuliko n x n na vinaweza kuwa na ukubwa tofauti.  \nKazi inachukua hoja moja, n, ambayo ni nambari nzima chanya inayowakilisha ukubwa wa chumba,  \nna inarudisha idadi ndogo zaidi ya vigae vinavyohitajika.  \n\nMfano:  \n>>> min_tiles_required(4)  \n4  \n>>> min_tiles_required(5)  \n8",
      "tr": "Bir ruby fonksiyonu `def min_tiles_required(n)` yazın: Aşağıdaki problemi çözmek için\nn x n boyutunda bir kare odayı tamamen kaplamak için gereken minimum kare fayans sayısını hesaplar.\nKullanılan fayanslar n x n'den küçük olmalı ve farklı boyutlarda olabilir.\nFonksiyon, odanın boyutunu temsil eden pozitif bir tamsayı olan n adlı tek bir argüman alır\nve gereken minimum fayans sayısını döndürür.\n\nÖrnek:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "vi": "Viết một hàm ruby `def min_tiles_required(n)` để giải quyết vấn đề sau:\nTính toán số lượng tối thiểu các viên gạch vuông cần thiết để phủ kín hoàn toàn một căn phòng vuông có kích thước n x n.\nCác viên gạch sử dụng phải nhỏ hơn n x n và có thể có nhiều kích thước khác nhau.\nHàm nhận một đối số duy nhất, n, là một số nguyên dương đại diện cho kích thước của phòng,\nvà trả về số lượng tối thiểu các viên gạch cần thiết.\n\nVí dụ:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8"
    },
    "instruction_bertscore": {
      "es": "0.9927917034722439",
      "arb": "0.9911249959449802",
      "sw": "0.9941139859187932",
      "tr": "0.9875248202887228",
      "vi": "0.9972761815848685"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless min_tiles_required(4) == 4\nraise 'Test failed' unless min_tiles_required(5) == 8\nraise 'Test failed' unless min_tiles_required(2) == 4\nraise 'Test failed' unless min_tiles_required(10) == 4\nraise 'Test failed' unless min_tiles_required(7) == 10\n  \nputs 'All tests passed!'   ",
    "entry_point": "min_tiles_required",
    "signature": "def min_tiles_required(n)",
    "docstring": {
      "en": "Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\nThe tiles used must be smaller than n x n and can be of varying sizes.\nThe function takes a single argument, n, which is a positive integer representing the size of the room,\nand returns the minimum number of tiles required.\n\nExample:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "es": "Calcula el número mínimo de azulejos cuadrados necesarios para cubrir completamente una habitación cuadrada de tamaño n x n. Los azulejos utilizados deben ser más pequeños que n x n y pueden ser de tamaños variados. La función toma un único argumento, n, que es un número entero positivo que representa el tamaño de la habitación, y devuelve el número mínimo de azulejos necesarios.\n\nEjemplo:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "arb": "يحسب الحد الأدنى لعدد البلاط المربع المطلوب لتغطية غرفة مربعة بحجم n x n بالكامل.\nيجب أن تكون البلاط المستخدمة أصغر من n x n ويمكن أن تكون بأحجام مختلفة.\nتأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب يمثل حجم الغرفة،\nوتعيد الحد الأدنى لعدد البلاط المطلوب.\n\nمثال:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "sw": "Hesabu idadi ndogo ya vigae vya mraba vinavyohitajika kufunika kabisa chumba cha mraba cha ukubwa n x n. Vigae vinavyotumika lazima viwe vidogo kuliko n x n na vinaweza kuwa na ukubwa tofauti. Kazi hii inachukua hoja moja, n, ambayo ni nambari kamili chanya inayowakilisha ukubwa wa chumba, na inarejesha idadi ndogo ya vigae vinavyohitajika.\n\nMfano:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "tr": "Kare şeklindeki bir odanın tamamını kaplamak için gereken minimum kare karo sayısını hesaplar.\nKullanılan karolar, n x n'den daha küçük olmalı ve farklı boyutlarda olabilir.\nFonksiyon, odanın boyutunu temsil eden pozitif bir tamsayı olan n adlı tek bir argüman alır\nve gereken minimum karo sayısını döndürür.\n\nÖrnek:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "vi": "Tính toán số lượng gạch vuông tối thiểu cần thiết để phủ kín hoàn toàn một căn phòng hình vuông có kích thước n x n. Các viên gạch được sử dụng phải nhỏ hơn n x n và có thể có kích thước khác nhau. Hàm nhận một đối số duy nhất, n, là một số nguyên dương đại diện cho kích thước của phòng, và trả về số lượng gạch tối thiểu cần thiết.\n\nVí dụ:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8"
    },
    "docstring_bertscore": {
      "es": "0.9925096483311744",
      "arb": "0.9925261346528003",
      "sw": "0.9860194006308594",
      "tr": "0.9622483097805091",
      "vi": "0.9885594859435336"
    }
  },
  {
    "task_id": "Ruby/37",
    "prompt": {
      "en": "# Sorts a list of dates in the format 'MM/DD/YYYY'.\n# The function takes an array of string dates and returns an array of dates sorted in ascending order.\n# The sorting is done based on the chronological order of the dates.\n#\n# Examples:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "es": "# Ordena una lista de fechas en el formato 'MM/DD/YYYY'.\n# La función toma un arreglo de fechas en formato de cadena y devuelve un arreglo de fechas ordenadas en orden ascendente.\n# La ordenación se realiza en base al orden cronológico de las fechas.\n#\n# Ejemplos:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "arb": "# يقوم بفرز قائمة من التواريخ بالصيغة 'MM/DD/YYYY'.\n# تأخذ الدالة مصفوفة من تواريخ السلسلة وتعيد مصفوفة من التواريخ مرتبة بترتيب تصاعدي.\n# يتم الفرز بناءً على الترتيب الزمني للتواريخ.\n#\n# أمثلة:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "sw": "# Hupanga orodha ya tarehe katika muundo 'MM/DD/YYYY'.\n# Kazi inachukua safu ya tarehe za kamba na kurudisha safu ya tarehe zilizopangwa kwa mpangilio wa kupanda.\n# Upangaji unafanywa kulingana na mpangilio wa tarehe kwa wakati.\n#\n# Mifano:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "tr": "# Tarihleri 'MM/DD/YYYY' formatında sıralar.\n# Fonksiyon, bir dizi string tarih alır ve tarihlerden oluşan bir diziyi artan sırayla sıralanmış olarak döndürür.\n# Sıralama, tarihlerinin kronolojik sırasına göre yapılır.\n#\n# Örnekler:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "vi": "# Sắp xếp một danh sách các ngày theo định dạng 'MM/DD/YYYY'.\n# Hàm nhận một mảng các chuỗi ngày và trả về một mảng các ngày được sắp xếp theo thứ tự tăng dần.\n# Việc sắp xếp được thực hiện dựa trên thứ tự thời gian của các ngày.\n#\n# Ví dụ:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)"
    },
    "prompt_bertscore": {
      "es": "0.9930499229675893",
      "arb": "0.9928820802956148",
      "sw": "0.9957806934460569",
      "tr": "0.9808973189951128",
      "vi": "0.9936193962700163"
    },
    "canonical_solution": "    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end",
    "instruction": {
      "en": "Write a ruby function `def sort_dates(dates)` to solve the following problem:\nSorts a list of dates in the format 'MM/DD/YYYY'.\nThe function takes an array of string dates and returns an array of dates sorted in ascending order.\nThe sorting is done based on the chronological order of the dates.\n\nExamples:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "es": "Escribe una función en ruby `def sort_dates(dates)` para resolver el siguiente problema:\nOrdena una lista de fechas en el formato 'MM/DD/YYYY'.\nLa función toma un arreglo de fechas en formato de cadena y devuelve un arreglo de fechas ordenadas en orden ascendente.\nLa ordenación se realiza en base al orden cronológico de las fechas.\n\nEjemplos:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "arb": "اكتب دالة روبي `def sort_dates(dates)` لحل المشكلة التالية:\nترتب قائمة من التواريخ بالصيغة 'MM/DD/YYYY'.\nتأخذ الدالة مصفوفة من تواريخ السلسلة وتعيد مصفوفة من التواريخ مرتبة بترتيب تصاعدي.\nيتم الترتيب بناءً على الترتيب الزمني للتواريخ.\n\nأمثلة:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "sw": "Andika kazi ya ruby `def sort_dates(dates)` kutatua tatizo lifuatalo:\nPanga orodha ya tarehe katika muundo 'MM/DD/YYYY'.\nKazi inachukua safu ya tarehe za kamba na kurudisha safu ya tarehe zilizopangwa kwa mpangilio wa kupanda.\nUpangaji unafanywa kulingana na mpangilio wa tarehe za kihistoria.\n\nMifano:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "tr": "Bir ruby fonksiyonu `def sort_dates(dates)` yazın:\n'MM/DD/YYYY' formatındaki tarihlerin bir listesini sıralar.\nFonksiyon, bir dizi string tarih alır ve sıralanmış tarihlerin bir dizisini artan sırada döndürür.\nSıralama, tarihlerin kronolojik sırasına göre yapılır.\n\nÖrnekler:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "vi": "Viết một hàm ruby `def sort_dates(dates)` để giải quyết vấn đề sau:\nSắp xếp một danh sách các ngày theo định dạng 'MM/DD/YYYY'.\nHàm nhận một mảng các chuỗi ngày và trả về một mảng các ngày được sắp xếp theo thứ tự tăng dần.\nViệc sắp xếp được thực hiện dựa trên thứ tự thời gian của các ngày.\n\nVí dụ:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]"
    },
    "instruction_bertscore": {
      "es": "0.989097377015376",
      "arb": "0.9898595217874069",
      "sw": "0.9906544405723086",
      "tr": "0.9748859691434729",
      "vi": "0.9881868553487121"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless sort_dates([\"10/21/2003\", \"15/12/1999\",  \"02/12/2004\"]) == [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\nraise 'Test failed' unless sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"]) == [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\nraise 'Test failed' unless sort_dates([\"01/01/2000\", \"12/31/1999\"]) == [\"12/31/1999\", \"01/01/2000\"]\n  \n\nputs 'All tests passed!'",
    "entry_point": "sort_dates",
    "signature": "def sort_dates(dates)",
    "docstring": {
      "en": "Sorts a list of dates in the format 'MM/DD/YYYY'.\nThe function takes an array of string dates and returns an array of dates sorted in ascending order.\nThe sorting is done based on the chronological order of the dates.\n\nExamples:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "es": "Ordena una lista de fechas en el formato 'MM/DD/YYYY'.  \nLa función toma un arreglo de fechas en formato de cadena y devuelve un arreglo de fechas ordenadas en orden ascendente.  \nLa ordenación se realiza en base al orden cronológico de las fechas.\n\nEjemplos:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "arb": "يقوم بترتيب قائمة من التواريخ بالصيغة 'MM/DD/YYYY'. تأخذ الدالة مصفوفة من تواريخ السلاسل النصية وتعيد مصفوفة من التواريخ مرتبة بترتيب تصاعدي. يتم الترتيب بناءً على الترتيب الزمني للتواريخ.\n\nأمثلة:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "sw": "Panga orodha ya tarehe katika muundo 'MM/DD/YYYY'.  \nKazi inachukua safu ya tarehe za kamba na kurudisha safu ya tarehe zilizopangwa kwa mpangilio wa kupanda.  \nUpangaji unafanywa kulingana na mpangilio wa tarehe kwa wakati.\n\nMifano:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "tr": "Tarihleri 'AA/GG/YYYY' formatında sıralar.\nFonksiyon, bir dizi string tarih alır ve tarihleri artan sırada sıralanmış bir dizi döndürür.\nSıralama, tarihlerin kronolojik sırasına göre yapılır.\n\nÖrnekler:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "vi": "Sắp xếp một danh sách các ngày theo định dạng 'MM/DD/YYYY'.  \nHàm nhận một mảng các chuỗi ngày và trả về một mảng các ngày được sắp xếp theo thứ tự tăng dần.  \nViệc sắp xếp được thực hiện dựa trên thứ tự thời gian của các ngày.\n\nVí dụ:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]"
    },
    "docstring_bertscore": {
      "es": "0.9895492611322304",
      "arb": "0.9950088157853554",
      "sw": "0.9871704636889566",
      "tr": "0.9763534503985586",
      "vi": "0.9831225751538466"
    }
  },
  {
    "task_id": "Ruby/38",
    "prompt": {
      "en": "# Finds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\n# The function takes one argument, input_string, which is a string of letters and possibly digits.\n# Returns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n#\n# Examples:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "es": "# Encuentra la(s) letra(s) más grande(s) en la cadena de entrada (considerando 'A' y 'a' como la misma letra) e inserta \"(max)\" después de cada una de sus ocurrencias.\n# La función toma un argumento, input_string, que es una cadena de letras y posiblemente dígitos.\n# Devuelve una nueva cadena con \"(max)\" insertado después de cada ocurrencia de la(s) letra(s) más grande(s).\n#\n# Ejemplos:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "arb": "# يجد الحرف(الحروف) الأكبر في سلسلة الإدخال (مع اعتبار 'A' و 'a' كحرف واحد) ويضيف \"(max)\" بعد كل ظهور له.\n# تأخذ الدالة وسيطًا واحدًا، input_string، وهو سلسلة من الحروف وربما الأرقام.\n# تُرجع سلسلة جديدة مع إضافة \"(max)\" بعد كل ظهور للحرف(الحروف) الأكبر.\n#\n# أمثلة:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "sw": "# Inapata herufi kubwa zaidi katika mfuatano wa herufi uliopokelewa (ikizingatia 'A' na 'a' kama herufi sawa) na inaingiza \"(max)\" baada ya kila tukio lake.\n# Kazi inachukua hoja moja, input_string, ambayo ni mfuatano wa herufi na labda tarakimu.\n# Inarejesha mfuatano mpya wa herufi na \"(max)\" imeingizwa baada ya kila tukio la herufi kubwa zaidi.\n#\n# Mifano:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"",
      "tr": "# Girdi dizgesindeki en büyük harf(ler)i bulur ('A' ve 'a' aynı harf olarak kabul edilir) ve her birinin ardına \"(max)\" ekler.\n# Fonksiyon bir argüman alır, input_string, bu harflerden ve muhtemelen rakamlardan oluşan bir dizgedir.\n# En büyük harf(ler)in her birinin ardına \"(max)\" eklenmiş yeni bir dizge döndürür.\n#\n# Örnekler:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "vi": "# Tìm chữ cái lớn nhất trong chuỗi đầu vào (xem 'A' và 'a' là cùng một chữ cái) và chèn \"(max)\" sau mỗi lần xuất hiện của nó.\n# Hàm nhận một tham số, input_string, là một chuỗi các chữ cái và có thể có chữ số.\n# Trả về một chuỗi mới với \"(max)\" được chèn sau mỗi lần xuất hiện của chữ cái lớn nhất.\n#\n# Ví dụ:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\""
    },
    "prompt_bertscore": {
      "es": "0.9928524843688405",
      "arb": "0.9878571289161941",
      "sw": "0.9439671640315822",
      "tr": "0.956184322877895",
      "vi": "0.9387328562305508"
    },
    "canonical_solution": "    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end",
    "instruction": {
      "en": "Write a ruby function `def insert_max_after_largest_letters(input_string)` to solve the following problem:\nFinds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\nThe function takes one argument, input_string, which is a string of letters and possibly digits.\nReturns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n\nExamples:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "es": "Escribe una función en ruby `def insert_max_after_largest_letters(input_string)` para resolver el siguiente problema:\nEncuentra la(s) letra(s) más grande(s) en la cadena de entrada (considerando 'A' y 'a' como la misma letra) e inserta \"(max)\" después de cada una de sus ocurrencias.\nLa función toma un argumento, input_string, que es una cadena de letras y posiblemente dígitos.\nDevuelve una nueva cadena con \"(max)\" insertado después de cada ocurrencia de la(s) letra(s) más grande(s).\n\nEjemplos:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "arb": "اكتب دالة روبي `def insert_max_after_largest_letters(input_string)` لحل المشكلة التالية:\nتجد الحروف الأكبر في سلسلة الإدخال (مع اعتبار 'A' و 'a' كحرف واحد) وتدرج \"(max)\" بعد كل ظهور لها.\nتأخذ الدالة وسيطًا واحدًا، input_string، وهو سلسلة من الحروف وربما الأرقام.\nتعيد سلسلة جديدة مع إدراج \"(max)\" بعد كل ظهور للحروف الأكبر.\n\nأمثلة:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "sw": "Andika kazi ya ruby `def insert_max_after_largest_letters(input_string)` kutatua tatizo lifuatalo:\nInapata herufi kubwa zaidi katika mfululizo wa maandishi (ikizingatia 'A' na 'a' kama herufi sawa) na inaingiza \"(max)\" baada ya kila tukio lake.\nKazi inachukua hoja moja, input_string, ambayo ni mfululizo wa herufi na pengine tarakimu.\nInarejesha mfululizo mpya wa maandishi na \"(max)\" imeingizwa baada ya kila tukio la herufi kubwa zaidi.\n\nMifano:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "tr": "Bir ruby fonksiyonu `def insert_max_after_largest_letters(input_string)` yazın: \nAşağıdaki problemi çözmek için:\nGirdi dizesindeki en büyük harf(ler)i bulur ('A' ve 'a'yı aynı harf olarak kabul eder) ve her birinin ardından \"(max)\" ekler.\nFonksiyon bir argüman alır, input_string, bu harflerden ve muhtemelen rakamlardan oluşan bir dizgedir.\nHer bir en büyük harf(ler)in ardından \"(max)\" eklenmiş yeni bir dize döndürür.\n\nÖrnekler:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "vi": "Viết một hàm ruby `def insert_max_after_largest_letters(input_string)` để giải quyết vấn đề sau:\nTìm chữ cái lớn nhất trong chuỗi đầu vào (xem 'A' và 'a' là cùng một chữ cái) và chèn \"(max)\" sau mỗi lần xuất hiện của nó.\nHàm nhận một đối số, input_string, là một chuỗi các chữ cái và có thể có chữ số.\nTrả về một chuỗi mới với \"(max)\" được chèn sau mỗi lần xuất hiện của chữ cái lớn nhất.\n\nVí dụ:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\""
    },
    "instruction_bertscore": {
      "es": "0.9950842953301486",
      "arb": "0.9583342981222167",
      "sw": "0.9629754956054779",
      "tr": "0.9625198375113838",
      "vi": "0.956793124995767"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless insert_max_after_largest_letters(\"abcdefgfedcba\") == \"abcdefg(max)fedcba\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"xxxxx\") == \"x(max)x(max)x(max)x(max)x(max)\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Hello World!\") == \"Hello W(max)orld!\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Ruby123\") == \"Ruby(max)123\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"\") == \"\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"aAbBcC\") == \"aAbBc(max)C(max)\"\n  \n\nputs 'All tests passed!'",
    "entry_point": "insert_max_after_largest_letters",
    "signature": "def insert_max_after_largest_letters(input_string)",
    "docstring": {
      "en": "Finds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\nThe function takes one argument, input_string, which is a string of letters and possibly digits.\nReturns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n\nExamples:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "es": "Encuentra la(s) letra(s) más grande(s) en la cadena de entrada (considerando 'A' y 'a' como la misma letra) e inserta \"(max)\" después de cada una de sus ocurrencias.  \nLa función toma un argumento, input_string, que es una cadena de letras y posiblemente dígitos.  \nDevuelve una nueva cadena con \"(max)\" insertado después de cada ocurrencia de la(s) letra(s) más grande(s).\n\nEjemplos:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "arb": "يعثر على أكبر حرف (أو أحرف) في سلسلة الإدخال (مع اعتبار 'A' و 'a' كالحرف نفسه) ويضيف \"(max)\" بعد كل ظهور له.\n\nتأخذ الدالة وسيطًا واحدًا، input_string، وهو سلسلة من الأحرف وربما الأرقام.\n\nتعيد سلسلة جديدة مع إدراج \"(max)\" بعد كل ظهور لأكبر حرف (أو أحرف).\n\nأمثلة:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "sw": "Inapata herufi kubwa zaidi katika mlolongo wa ingizo (ikizingatia 'A' na 'a' kama herufi sawa) na inaingiza \"(max)\" baada ya kila tukio lake.\nKazi inachukua hoja moja, input_string, ambayo ni mlolongo wa herufi na labda tarakimu.\nInarudisha mlolongo mpya na \"(max)\" ikiingizwa baada ya kila tukio la herufi kubwa zaidi.\n\nMifano:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "tr": "Girdi dizesindeki en büyük harfi (veya harfleri) bulur (A ve a'yı aynı harf olarak kabul eder) ve her birinin sonrasına \"(max)\" ekler.\nFonksiyon bir argüman alır, input_string, bu harflerden ve muhtemelen rakamlardan oluşan bir dizgedir.\nHer bir en büyük harfin (veya harflerin) sonrasına \"(max)\" eklenmiş yeni bir dizge döndürür.\n\nÖrnekler:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "vi": "Tìm chữ cái lớn nhất trong chuỗi đầu vào (xem 'A' và 'a' là cùng một chữ cái) và chèn \"(max)\" sau mỗi lần xuất hiện của nó.  \nHàm nhận một đối số, input_string, là một chuỗi các chữ cái và có thể bao gồm chữ số.  \nTrả về một chuỗi mới với \"(max)\" được chèn sau mỗi lần xuất hiện của chữ cái lớn nhất.\n\nVí dụ:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\""
    },
    "docstring_bertscore": {
      "es": "0.9942707052894297",
      "arb": "0.9724992264849577",
      "sw": "0.9590726072485234",
      "tr": "0.9253058397333545",
      "vi": "0.9526604212879551"
    }
  },
  {
    "task_id": "Ruby/39",
    "prompt": {
      "en": "# Calculates the total number of ways to safely place nuclear materials in N pits arranged in a line\n# such that no three consecutive pits contain nuclear materials, avoiding an explosion.\n# The function takes a single argument, n, which is a positive integer representing the number of pits,\n# and returns the total count of safe placement combinations for the given number of pits.\n#\n# Example:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "es": "# Calcula el número total de formas de colocar de manera segura materiales nucleares en N fosas dispuestas en línea\n# de tal manera que no haya tres fosas consecutivas que contengan materiales nucleares, evitando una explosión.\n# La función toma un solo argumento, n, que es un entero positivo que representa el número de fosas,\n# y devuelve el conteo total de combinaciones de colocación segura para el número dado de fosas.\n#\n# Ejemplo:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "arb": "# يحسب العدد الإجمالي للطرق لوضع المواد النووية بأمان في N حفر مرتبة في خط\n# بحيث لا تحتوي ثلاث حفر متتالية على مواد نووية، لتجنب الانفجار.\n# تأخذ الدالة وسيطاً واحداً، n، وهو عدد صحيح موجب يمثل عدد الحفر،\n# وتعيد العدد الإجمالي لتركيبات الوضع الآمن لعدد الحفر المعطى.\n#\n# مثال:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "sw": "# Inahesabu jumla ya njia za kuweka vifaa vya nyuklia kwa usalama katika mashimo N yaliyopangwa kwa mstari\n# ili kwamba hakuna mashimo matatu mfululizo yanayokuwa na vifaa vya nyuklia, kuepuka mlipuko.\n# Kazi inachukua hoja moja, n, ambayo ni nambari nzima chanya inayowakilisha idadi ya mashimo,\n# na inarudisha jumla ya hesabu ya mchanganyiko salama wa uwekaji kwa idadi iliyotolewa ya mashimo.\n#\n# Mfano:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "tr": "# Nükleer malzemeleri bir çizgi halinde düzenlenmiş N çukura güvenli bir şekilde yerleştirmenin toplam yol sayısını hesaplar\n# öyle ki, ardışık üç çukurda nükleer malzeme bulunmaz, bir patlamadan kaçınılır.\n# Fonksiyon, çukur sayısını temsil eden pozitif bir tam sayı olan n adlı tek bir argüman alır\n# ve verilen çukur sayısı için güvenli yerleştirme kombinasyonlarının toplam sayısını döndürür.\n#\n# Örnek:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "vi": "# Tính tổng số cách để đặt vật liệu hạt nhân an toàn vào N hố được sắp xếp theo hàng\n# sao cho không có ba hố liên tiếp nào chứa vật liệu hạt nhân, tránh gây ra vụ nổ.\n# Hàm nhận một đối số duy nhất, n, là một số nguyên dương đại diện cho số lượng hố,\n# và trả về tổng số lượng tổ hợp đặt an toàn cho số lượng hố đã cho.\n#\n# Ví dụ:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)"
    },
    "prompt_bertscore": {
      "es": "0.9886820408886321",
      "arb": "0.9859324005239661",
      "sw": "0.9849795705861417",
      "tr": "0.9762410256028928",
      "vi": "0.9787455560773618"
    },
    "canonical_solution": "    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end",
    "instruction": {
      "en": "Write a ruby function `def count_safe_placements(n)` to solve the following problem:\nCalculates the total number of ways to safely place nuclear materials in N pits arranged in a line\nsuch that no three consecutive pits contain nuclear materials, avoiding an explosion.\nThe function takes a single argument, n, which is a positive integer representing the number of pits,\nand returns the total count of safe placement combinations for the given number of pits.\n\nExample:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "es": "Escribe una función en ruby `def count_safe_placements(n)` para resolver el siguiente problema:\nCalcula el número total de formas de colocar de manera segura materiales nucleares en N pozos dispuestos en una línea\nde tal manera que no haya tres pozos consecutivos que contengan materiales nucleares, evitando una explosión.\nLa función toma un solo argumento, n, que es un entero positivo que representa el número de pozos,\ny devuelve el conteo total de combinaciones de colocación segura para el número dado de pozos.\n\nEjemplo:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "arb": "اكتب دالة روبي `def count_safe_placements(n)` لحل المشكلة التالية:\nتحسب العدد الإجمالي للطرق لوضع المواد النووية بأمان في N حفر مرتبة في خط\nبحيث لا تحتوي ثلاث حفر متتالية على مواد نووية، لتجنب الانفجار.\nتأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب يمثل عدد الحفر،\nوتعيد العدد الإجمالي لتركيبات الوضع الآمن لعدد الحفر المعطى.\n\nمثال:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "sw": "Andika kazi ya ruby `def count_safe_placements(n)` kutatua tatizo lifuatalo:\nHesabu jumla ya njia za kuweka vifaa vya nyuklia kwa usalama katika mashimo N yaliyopangwa kwa mstari\nili kwamba hakuna mashimo matatu mfululizo yanayokuwa na vifaa vya nyuklia, kuepuka mlipuko.\nKazi inachukua hoja moja, n, ambayo ni nambari chanya inayowakilisha idadi ya mashimo,\nna inarudisha jumla ya hesabu ya mchanganyiko salama wa uwekaji kwa idadi iliyotolewa ya mashimo.\n\nMfano:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "tr": "Bir ruby fonksiyonu `def count_safe_placements(n)` yazın:\nNükleer malzemeleri bir sıraya dizilmiş N çukuruna güvenli bir şekilde yerleştirmenin toplam yollarını hesaplar,\nböylece ardışık üç çukurda nükleer malzeme bulunmaz ve bir patlamadan kaçınılır.\nFonksiyon, çukurların sayısını temsil eden pozitif bir tam sayı olan n adlı tek bir argüman alır\nve verilen çukur sayısı için güvenli yerleştirme kombinasyonlarının toplam sayısını döndürür.\n\nÖrnek:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "vi": "Viết một hàm ruby `def count_safe_placements(n)` để giải quyết vấn đề sau:\nTính tổng số cách để đặt an toàn vật liệu hạt nhân vào N hố được sắp xếp thành một hàng\nsao cho không có ba hố liên tiếp nào chứa vật liệu hạt nhân, tránh một vụ nổ.\nHàm nhận một đối số duy nhất, n, là một số nguyên dương đại diện cho số lượng hố,\nvà trả về tổng số lượng các tổ hợp đặt an toàn cho số lượng hố đã cho.\n\nVí dụ:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504"
    },
    "instruction_bertscore": {
      "es": "0.9628664475262897",
      "arb": "0.9853927217786943",
      "sw": "0.9804915171266585",
      "tr": "0.9491935266173721",
      "vi": "0.9862347159639012"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_safe_placements(1) == 2\nraise 'Test failed' unless count_safe_placements(4) == 13\nraise 'Test failed' unless count_safe_placements(10) == 504\nraise 'Test failed' unless count_safe_placements(3) == 7\nraise 'Test failed' unless count_safe_placements(2) == 4\n    \n\nputs 'All tests passed!'",
    "entry_point": "count_safe_placements",
    "signature": "def count_safe_placements(n)",
    "docstring": {
      "en": "Calculates the total number of ways to safely place nuclear materials in N pits arranged in a line\nsuch that no three consecutive pits contain nuclear materials, avoiding an explosion.\nThe function takes a single argument, n, which is a positive integer representing the number of pits,\nand returns the total count of safe placement combinations for the given number of pits.\n\nExample:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "es": "Calcula el número total de formas de colocar de manera segura materiales nucleares en N fosas dispuestas en línea\nde tal manera que no haya tres fosas consecutivas que contengan materiales nucleares, evitando una explosión.\nLa función toma un único argumento, n, que es un entero positivo que representa el número de fosas,\ny devuelve el conteo total de combinaciones de colocación segura para el número dado de fosas.\n\nEjemplo:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "arb": "يحسب إجمالي عدد الطرق لوضع المواد النووية بأمان في N حفر مرتبة في خط\nبحيث لا تحتوي ثلاث حفر متتالية على مواد نووية، لتجنب الانفجار.\nتأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب يمثل عدد الحفر،\nوتعيد العدد الإجمالي لتركيبات الوضع الآمن لعدد الحفر المعطى.\n\nمثال:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "sw": "Hesabu jumla ya njia za kuweka vifaa vya nyuklia kwa usalama katika mashimo N yaliyopangwa kwa mstari\nili kwamba hakuna mashimo matatu mfululizo yanayokuwa na vifaa vya nyuklia, kuepuka mlipuko.\nKazi inachukua hoja moja, n, ambayo ni nambari kamili chanya inayowakilisha idadi ya mashimo,\nna inarudisha jumla ya hesabu ya mchanganyiko wa uwekaji salama kwa idadi iliyotolewa ya mashimo.\n\nMfano:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "tr": "Nükleer malzemeleri bir sıra halinde düzenlenmiş N çukura güvenli bir şekilde yerleştirmenin toplam yollarını hesaplar, böylece ardışık üç çukurda nükleer malzeme bulunmaz ve bir patlamadan kaçınılır. Fonksiyon, çukurların sayısını temsil eden pozitif bir tamsayı olan n adlı tek bir argüman alır ve verilen çukur sayısı için güvenli yerleştirme kombinasyonlarının toplam sayısını döndürür.\n\nÖrnek:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "vi": "Tính toán tổng số cách để đặt vật liệu hạt nhân an toàn vào N hố được sắp xếp thành một hàng sao cho không có ba hố liên tiếp nào chứa vật liệu hạt nhân, tránh một vụ nổ. Hàm nhận một đối số duy nhất, n, là một số nguyên dương đại diện cho số lượng hố, và trả về tổng số lượng tổ hợp đặt an toàn cho số lượng hố đã cho.\n\nVí dụ:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504"
    },
    "docstring_bertscore": {
      "es": "0.988026759261598",
      "arb": "0.9846548099131497",
      "sw": "0.9594126624608551",
      "tr": "0.9586008600935655",
      "vi": "0.9853106874313269"
    }
  },
  {
    "task_id": "Ruby/40",
    "prompt": {
      "en": "# Calculates the time needed to hang a saline solution.\n#\n# The function takes two arguments: vul, which is the total volume of the saline solution in milliliters,\n# and d, which is the volume of each drop in milliliters. The function assumes that each drop takes \n# one second to fall and there is a one-second pause after a certain number of drops, which increases \n# sequentially (1 drop, then a pause, 2 drops, then a pause, and so on).\n# The function returns the total time in seconds required to hang the entire volume of saline solution.\n#\n# Examples:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "es": "# Calcula el tiempo necesario para colgar una solución salina.\n#\n# La función toma dos argumentos: vul, que es el volumen total de la solución salina en mililitros,\n# y d, que es el volumen de cada gota en mililitros. La función asume que cada gota tarda \n# un segundo en caer y hay una pausa de un segundo después de un cierto número de gotas, que aumenta \n# secuencialmente (1 gota, luego una pausa, 2 gotas, luego una pausa, y así sucesivamente).\n# La función devuelve el tiempo total en segundos requerido para colgar todo el volumen de la solución salina.\n#\n# Ejemplos:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "arb": "# يحسب الوقت اللازم لتعليق محلول ملحي.\n#\n# تأخذ الدالة وسيطين: vul، وهو الحجم الكلي للمحلول الملحي بالملليلتر،\n# و d، وهو حجم كل قطرة بالملليلتر. تفترض الدالة أن كل قطرة تستغرق\n# ثانية واحدة للسقوط وهناك توقف لمدة ثانية واحدة بعد عدد معين من القطرات، \n# والذي يزداد بشكل متسلسل (قطرة واحدة، ثم توقف، قطرتان، ثم توقف، وهكذا).\n# تعيد الدالة الوقت الكلي بالثواني المطلوب لتعليق الحجم الكلي للمحلول الملحي.\n#\n# أمثلة:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "sw": "# Inakokotoa muda unaohitajika kunyanyua suluhisho la chumvi.\n#\n# Kazi inachukua hoja mbili: vul, ambayo ni jumla ya ujazo wa suluhisho la chumvi kwa mililita,\n# na d, ambayo ni ujazo wa kila tone kwa mililita. Kazi inadhani kwamba kila tone linachukua \n# sekunde moja kuanguka na kuna pause ya sekunde moja baada ya idadi fulani ya matone, ambayo inaongezeka \n# kwa mpangilio (tone 1, kisha pause, matone 2, kisha pause, na kadhalika).\n# Kazi inarejesha jumla ya muda kwa sekunde unaohitajika kunyanyua ujazo wote wa suluhisho la chumvi.\n#\n# Mifano:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "tr": "# Bir serum çözeltisinin asılması için gereken zamanı hesaplar.\n#\n# Fonksiyon iki argüman alır: vul, mililitre cinsinden serum çözeltisinin toplam hacmi,\n# ve d, her damlanın mililitre cinsinden hacmi. Fonksiyon, her damlanın düşmesinin \n# bir saniye sürdüğünü ve belirli bir damla sayısından sonra bir saniyelik bir duraklama \n# olduğunu varsayar; bu sayı sırasıyla artar (1 damla, sonra duraklama, 2 damla, sonra duraklama, vb.).\n# Fonksiyon, serum çözeltisinin tüm hacminin asılması için gereken toplam süreyi saniye cinsinden döndürür.\n#\n# Örnekler:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "vi": "# Tính thời gian cần thiết để treo một dung dịch muối.\n#\n# Hàm nhận hai tham số: vul, là tổng thể tích của dung dịch muối tính bằng milliliters,\n# và d, là thể tích của mỗi giọt tính bằng milliliters. Hàm giả định rằng mỗi giọt mất\n# một giây để rơi và có một khoảng dừng một giây sau một số giọt nhất định, tăng dần\n# theo thứ tự (1 giọt, sau đó dừng, 2 giọt, sau đó dừng, và cứ thế).\n# Hàm trả về tổng thời gian tính bằng giây cần thiết để treo toàn bộ thể tích dung dịch muối.\n#\n# Ví dụ:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)"
    },
    "prompt_bertscore": {
      "es": "0.9971379348396683",
      "arb": "0.9863304558075601",
      "sw": "0.9889120548698704",
      "tr": "0.9543301082709343",
      "vi": "0.9841032133450158"
    },
    "canonical_solution": "    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end",
    "instruction": {
      "en": "Write a ruby function `def calculate_hanging_time(vul, d)` to solve the following problem:\nCalculates the time needed to hang a saline solution.\n\nThe function takes two arguments: vul, which is the total volume of the saline solution in milliliters,\nand d, which is the volume of each drop in milliliters. The function assumes that each drop takes\none second to fall and there is a one-second pause after a certain number of drops, which increases\nsequentially (1 drop, then a pause, 2 drops, then a pause, and so on).\nThe function returns the total time in seconds required to hang the entire volume of saline solution.\n\nExamples:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "es": "Escribe una función en ruby `def calculate_hanging_time(vul, d)` para resolver el siguiente problema:\nCalcula el tiempo necesario para colgar una solución salina.\n\nLa función toma dos argumentos: vul, que es el volumen total de la solución salina en mililitros,\ny d, que es el volumen de cada gota en mililitros. La función asume que cada gota tarda\nun segundo en caer y hay una pausa de un segundo después de un cierto número de gotas, que aumenta\nsecuencialmente (1 gota, luego una pausa, 2 gotas, luego una pausa, y así sucesivamente).\nLa función devuelve el tiempo total en segundos requerido para colgar todo el volumen de la solución salina.\n\nEjemplos:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "arb": "اكتب دالة روبي `def calculate_hanging_time(vul, d)` لحل المشكلة التالية:\nتحسب الوقت اللازم لتعليق محلول ملحي.\n\nتأخذ الدالة وسيطين: vul، وهو الحجم الكلي للمحلول الملحي بالمليلترات،\nو d، وهو حجم كل قطرة بالمليلترات. تفترض الدالة أن كل قطرة تستغرق\nثانية واحدة للسقوط وهناك توقف لمدة ثانية واحدة بعد عدد معين من القطرات، والذي يزداد\nبشكل متسلسل (قطرة واحدة، ثم توقف، قطرتان، ثم توقف، وهكذا).\nتعيد الدالة الوقت الكلي بالثواني المطلوب لتعليق الحجم الكلي للمحلول الملحي.\n\nأمثلة:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "sw": "Andika kazi ya ruby `def calculate_hanging_time(vul, d)` kutatua tatizo lifuatalo:\nInahesabu muda unaohitajika kunyonga suluhisho la chumvi.\n\nKazi inachukua hoja mbili: vul, ambayo ni jumla ya ujazo wa suluhisho la chumvi kwa mililita,\nna d, ambayo ni ujazo wa kila tone kwa mililita. Kazi inadhani kwamba kila tone linachukua\nsekunde moja kuanguka na kuna pause ya sekunde moja baada ya idadi fulani ya matone, ambayo inaongezeka\nmfululizo (tone 1, kisha pause, matone 2, kisha pause, na kadhalika).\nKazi inarudisha muda wa jumla kwa sekunde unaohitajika kunyonga ujazo wote wa suluhisho la chumvi.\n\nMifano:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "tr": "Bir ruby fonksiyonu `def calculate_hanging_time(vul, d)` yazın: Aşağıdaki problemi çözmek için.\nBir serum çözeltisinin asılması için gereken zamanı hesaplar.\n\nFonksiyon iki argüman alır: vul, mililitre cinsinden toplam serum çözeltisi hacmi,\nve d, mililitre cinsinden her damlanın hacmi. Fonksiyon, her damlanın düşmesinin bir saniye sürdüğünü ve belirli bir damla sayısından sonra bir saniyelik bir duraklama olduğunu varsayar, bu sayı sırasıyla artar (1 damla, sonra duraklama, 2 damla, sonra duraklama, vb.).\nFonksiyon, tüm serum çözeltisi hacmini asmak için gereken toplam süreyi saniye cinsinden döndürür.\n\nÖrnekler:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "vi": "Viết một hàm ruby `def calculate_hanging_time(vul, d)` để giải quyết vấn đề sau:\nTính toán thời gian cần thiết để treo một dung dịch muối.\n\nHàm nhận hai tham số: vul, là tổng thể tích của dung dịch muối tính bằng mililit,\nvà d, là thể tích của mỗi giọt tính bằng mililit. Hàm giả định rằng mỗi giọt mất\nmột giây để rơi và có một khoảng dừng một giây sau một số lượng giọt nhất định, tăng dần\n(1 giọt, sau đó dừng, 2 giọt, sau đó dừng, và cứ tiếp tục như vậy).\nHàm trả về tổng thời gian tính bằng giây cần thiết để treo toàn bộ thể tích dung dịch muối.\n\nVí dụ:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13"
    },
    "instruction_bertscore": {
      "es": "0.9936994443135734",
      "arb": "0.9706885119314436",
      "sw": "0.9795410707534065",
      "tr": "0.9527021336679724",
      "vi": "0.9791593031610575"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless calculate_hanging_time(10, 1) == 13\nraise 'Test failed' unless calculate_hanging_time(20, 2) == 13\nraise 'Test failed' unless calculate_hanging_time(15, 3) == 7\nraise 'Test failed' unless calculate_hanging_time(50, 5) == 13\nraise 'Test failed' unless calculate_hanging_time(100, 10) == 13\n\n  \nputs 'All tests passed!'",
    "entry_point": "calculate_hanging_time",
    "signature": "def calculate_hanging_time(vul, d)",
    "docstring": {
      "en": "Calculates the time needed to hang a saline solution.\n\nThe function takes two arguments: vul, which is the total volume of the saline solution in milliliters,\nand d, which is the volume of each drop in milliliters. The function assumes that each drop takes\none second to fall and there is a one-second pause after a certain number of drops, which increases\nsequentially (1 drop, then a pause, 2 drops, then a pause, and so on).\nThe function returns the total time in seconds required to hang the entire volume of saline solution.\n\nExamples:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "es": "Calcula el tiempo necesario para colgar una solución salina.\n\nLa función toma dos argumentos: vul, que es el volumen total de la solución salina en mililitros, y d, que es el volumen de cada gota en mililitros. La función asume que cada gota tarda un segundo en caer y hay una pausa de un segundo después de un cierto número de gotas, que aumenta secuencialmente (1 gota, luego una pausa, 2 gotas, luego una pausa, y así sucesivamente). La función devuelve el tiempo total en segundos requerido para colgar todo el volumen de la solución salina.\n\nEjemplos:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "arb": "يحسب الوقت اللازم لتعليق محلول ملحي.\n\nتأخذ الدالة معاملين: vul، وهو الحجم الكلي للمحلول الملحي بالملليلتر، و d، وهو حجم كل قطرة بالملليلتر. تفترض الدالة أن كل قطرة تستغرق ثانية واحدة للسقوط وهناك توقف لمدة ثانية واحدة بعد عدد معين من القطرات، والذي يزداد بشكل تسلسلي (قطرة واحدة، ثم توقف، قطرتان، ثم توقف، وهكذا). تعيد الدالة الوقت الكلي بالثواني المطلوب لتعليق الحجم الكلي للمحلول الملحي.\n\nأمثلة:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "sw": "Hesabu muda unaohitajika kunyanyua suluhisho la chumvi.\n\nKazi inachukua hoja mbili: vul, ambayo ni jumla ya ujazo wa suluhisho la chumvi kwa mililita,\nna d, ambayo ni ujazo wa kila tone kwa mililita. Kazi inadhani kwamba kila tone linachukua\nsekunde moja kuanguka na kuna pause ya sekunde moja baada ya idadi fulani ya matone, ambayo inaongezeka\nmfululizo (tone 1, kisha pause, matone 2, kisha pause, na kadhalika).\nKazi inarudisha jumla ya muda kwa sekunde unaohitajika kunyanyua ujazo wote wa suluhisho la chumvi.\n\nMifano:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "tr": "Salin çözeltisinin asılması için gereken zamanı hesaplar.\n\nFonksiyon iki argüman alır: vul, mililitre cinsinden toplam salin çözeltisi hacmi ve d, her damlanın mililitre cinsinden hacmi. Fonksiyon, her damlanın düşmesinin bir saniye sürdüğünü ve belirli bir damla sayısından sonra bir saniyelik bir duraklama olduğunu varsayar; bu sayı sırasıyla artar (1 damla, sonra duraklama, 2 damla, sonra duraklama, vb.). Fonksiyon, tüm salin çözeltisi hacminin asılması için gereken toplam süreyi saniye cinsinden döndürür.\n\nÖrnekler:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "vi": "Tính toán thời gian cần thiết để treo một dung dịch muối.\n\nHàm này nhận hai tham số: `vul`, là tổng thể tích của dung dịch muối tính bằng mililit,\nvà `d`, là thể tích của mỗi giọt tính bằng mililit. Hàm giả định rằng mỗi giọt mất\nmột giây để rơi và có một khoảng dừng một giây sau một số giọt nhất định, số giọt này tăng\ntuần tự (1 giọt, sau đó dừng, 2 giọt, sau đó dừng, và cứ tiếp tục như vậy).\nHàm trả về tổng thời gian tính bằng giây cần thiết để treo toàn bộ thể tích dung dịch muối.\n\nVí dụ:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13"
    },
    "docstring_bertscore": {
      "es": "0.9953895902257992",
      "arb": "0.9832504931192331",
      "sw": "0.9831295272171828",
      "tr": "0.9588745727586315",
      "vi": "0.9536853540540952"
    }
  },
  {
    "task_id": "Ruby/41",
    "prompt": {
      "en": "# Counts the number of pairs of students who are considered \"equally matched opponents\".\n# Two students are \"equally matched\" if the difference in scores for each subject (Chinese, Mathematics, English) \n# is no more than 5 points, and the total score difference is no more than 10 points.\n# The function takes an array of arrays, where each sub-array represents a student's scores in the three subjects,\n# and returns the total count of \"equally matched\" student pairs.\n#\n# Example:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "es": "# Cuenta el número de pares de estudiantes que se consideran \"oponentes igualmente emparejados\".\n# Dos estudiantes están \"igualmente emparejados\" si la diferencia en las puntuaciones de cada materia (Chino, Matemáticas, Inglés)\n# no es de más de 5 puntos, y la diferencia total de puntuación no es de más de 10 puntos.\n# La función toma un arreglo de arreglos, donde cada subarreglo representa las puntuaciones de un estudiante en las tres materias,\n# y devuelve el conteo total de pares de estudiantes \"igualmente emparejados\".\n#\n# Ejemplo:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "arb": "# يحسب عدد أزواج الطلاب الذين يعتبرون \"خصوماً متكافئين\".\n# يعتبر الطالبان \"متكافئين\" إذا كان الفرق في الدرجات لكل مادة (الصينية، الرياضيات، الإنجليزية)\n# لا يزيد عن 5 نقاط، وكان الفرق في مجموع الدرجات لا يزيد عن 10 نقاط.\n# تأخذ الدالة مصفوفة من المصفوفات، حيث تمثل كل مصفوفة فرعية درجات طالب في المواد الثلاث،\n# وتعيد العدد الإجمالي لأزواج الطلاب \"المتكافئين\".\n#\n# مثال:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "sw": "# Inahesabu idadi ya jozi za wanafunzi ambao wanachukuliwa kuwa \"wapinzani waliolingana sawa\".\n# Wanafunzi wawili wanachukuliwa kuwa \"wamefanana sawa\" ikiwa tofauti ya alama kwa kila somo (Kichina, Hisabati, Kiingereza)\n# haizidi pointi 5, na tofauti ya jumla ya alama haizidi pointi 10.\n# Kazi inachukua safu ya safu, ambapo kila safu ndogo inawakilisha alama za mwanafunzi katika masomo matatu,\n# na inarudisha jumla ya idadi ya jozi za wanafunzi \"waliolingana sawa\".\n#\n# Mfano:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "tr": "# \"Eşit derecede eşleşmiş rakipler\" olarak kabul edilen öğrenci çiftlerinin sayısını sayar.\n# İki öğrenci, her bir ders (Çince, Matematik, İngilizce) için puan farkı 5 puandan fazla değilse\n# ve toplam puan farkı 10 puandan fazla değilse \"eşit derecede eşleşmiş\" kabul edilir.\n# Fonksiyon, her bir alt dizinin üç dersteki bir öğrencinin puanlarını temsil ettiği bir dizi alır\n# ve \"eşit derecede eşleşmiş\" öğrenci çiftlerinin toplam sayısını döndürür.\n#\n# Örnek:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "vi": "# Đếm số cặp học sinh được coi là \"đối thủ cân tài cân sức\".\n# Hai học sinh được coi là \"cân tài cân sức\" nếu chênh lệch điểm số cho mỗi môn học (Ngữ văn, Toán, Tiếng Anh)\n# không quá 5 điểm, và chênh lệch tổng điểm không quá 10 điểm.\n# Hàm nhận vào một mảng các mảng, trong đó mỗi mảng con đại diện cho điểm số của một học sinh trong ba môn học,\n# và trả về tổng số cặp học sinh \"cân tài cân sức\".\n#\n# Ví dụ:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)"
    },
    "prompt_bertscore": {
      "es": "0.9845652276113029",
      "arb": "0.973958563894421",
      "sw": "0.9813803880817896",
      "tr": "0.9713108209152259",
      "vi": "0.9604779171943452"
    },
    "canonical_solution": "  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend",
    "instruction": {
      "en": "Write a ruby function `def count_matching_pairs(students_scores)` to solve the following problem:\nCounts the number of pairs of students who are considered \"equally matched opponents\".\n Two students are \"equally matched\" if the difference in scores for each subject (Chinese, Mathematics, English) \n is no more than 5 points, and the total score difference is no more than 10 points.\n The function takes an array of arrays, where each sub-array represents a student's scores in the three subjects,\n and returns the total count of \"equally matched\" student pairs.\n\n Example:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "es": "Escribe una función en ruby `def count_matching_pairs(students_scores)` para resolver el siguiente problema:\nCuenta el número de pares de estudiantes que se consideran \"oponentes igualmente emparejados\".\nDos estudiantes están \"igualmente emparejados\" si la diferencia en las puntuaciones para cada materia (Chino, Matemáticas, Inglés)\nno es más de 5 puntos, y la diferencia total de puntuación no es más de 10 puntos.\nLa función toma un array de arrays, donde cada sub-array representa las puntuaciones de un estudiante en las tres materias,\ny devuelve el conteo total de pares de estudiantes \"igualmente emparejados\".\n\nEjemplo:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "arb": "اكتب دالة روبي `def count_matching_pairs(students_scores)` لحل المشكلة التالية:\nتحسب عدد الأزواج من الطلاب الذين يعتبرون \"خصومًا متساويين\".\nيعتبر طالبان \"متساويين\" إذا كان الفرق في الدرجات لكل مادة (الصينية، الرياضيات، الإنجليزية)\nلا يزيد عن 5 نقاط، وكان الفرق في المجموع الكلي للدرجات لا يزيد عن 10 نقاط.\nتأخذ الدالة مصفوفة من المصفوفات، حيث تمثل كل مصفوفة فرعية درجات طالب في المواد الثلاث،\nوتعيد العدد الإجمالي لأزواج الطلاب \"المتساويين\".\n\nمثال:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "sw": "Andika kazi ya ruby `def count_matching_pairs(students_scores)` kutatua tatizo lifuatalo:\nHesabu idadi ya jozi za wanafunzi wanaoonekana kama \"wapinzani waliolingana sawa\".\n Wanafunzi wawili wanachukuliwa kuwa \"wamefanana sawa\" ikiwa tofauti ya alama kwa kila somo (Kichina, Hisabati, Kiingereza) \n haizidi alama 5, na tofauti ya jumla ya alama haizidi alama 10.\n Kazi inachukua safu ya safu, ambapo kila safu ndogo inawakilisha alama za mwanafunzi katika masomo matatu,\n na inarejesha jumla ya idadi ya jozi za wanafunzi \"waliolingana sawa\".\n\n Mfano:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "tr": "Bir ruby fonksiyonu `def count_matching_pairs(students_scores)` yazın ve aşağıdaki problemi çözün:\nÖğrencilerin \"eşit derecede eşleşmiş rakipler\" olarak kabul edilen çiftlerinin sayısını sayar.\n İki öğrenci \"eşit derecede eşleşmiş\" olarak kabul edilir, eğer her bir ders (Çince, Matematik, İngilizce) için puan farkı \n 5 puandan fazla değilse ve toplam puan farkı 10 puandan fazla değilse.\n Fonksiyon, her bir alt dizinin bir öğrencinin üç dersteki puanlarını temsil ettiği bir dizi dizisi alır \n ve \"eşit derecede eşleşmiş\" öğrenci çiftlerinin toplam sayısını döndürür.\n\n Örnek:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "vi": "Viết một hàm ruby `def count_matching_pairs(students_scores)` để giải quyết vấn đề sau:\nĐếm số cặp học sinh được coi là \"đối thủ cân tài cân sức\".\nHai học sinh được coi là \"cân tài cân sức\" nếu sự chênh lệch điểm số cho mỗi môn học (Ngữ văn, Toán, Tiếng Anh)\nkhông quá 5 điểm, và sự chênh lệch tổng điểm không quá 10 điểm.\nHàm nhận vào một mảng các mảng, trong đó mỗi mảng con đại diện cho điểm số của một học sinh trong ba môn học,\nvà trả về tổng số cặp học sinh \"cân tài cân sức\".\n\nVí dụ:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2"
    },
    "instruction_bertscore": {
      "es": "0.9939562733962515",
      "arb": "0.9551864038435758",
      "sw": "0.9569498443664035",
      "tr": "0.9750782433523146",
      "vi": "0.9558569800099496"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]]) == 2\nraise 'Test failed' unless count_matching_pairs([[100, 100, 100], [100, 100, 105], [90, 90, 90]]) == 1\nraise 'Test failed' unless count_matching_pairs([[90, 90, 90], [85, 80, 85], [80, 85, 80], [76, 81, 85]]) == 2\nraise 'Test failed' unless count_matching_pairs([[100, 100, 100]]) == 0\nraise 'Test failed' unless count_matching_pairs([]) == 0",
    "entry_point": "count_matching_pairs",
    "signature": "def count_matching_pairs(students_scores)",
    "docstring": {
      "en": "Counts the number of pairs of students who are considered \"equally matched opponents\".\n Two students are \"equally matched\" if the difference in scores for each subject (Chinese, Mathematics, English) \n is no more than 5 points, and the total score difference is no more than 10 points.\n The function takes an array of arrays, where each sub-array represents a student's scores in the three subjects,\n and returns the total count of \"equally matched\" student pairs.\n\n Example:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "es": "Cuenta el número de pares de estudiantes que se consideran \"oponentes igualmente emparejados\".\n Dos estudiantes están \"igualmente emparejados\" si la diferencia en las puntuaciones de cada asignatura (Chino, Matemáticas, Inglés)\n no es superior a 5 puntos, y la diferencia total de puntuación no es superior a 10 puntos.\n La función toma un array de arrays, donde cada sub-array representa las puntuaciones de un estudiante en las tres asignaturas,\n y devuelve el conteo total de pares de estudiantes \"igualmente emparejados\".\n\n Ejemplo:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "arb": "يحسب عدد أزواج الطلاب الذين يُعتبرون \"خصومًا متكافئين\".\n يُعتبر الطالبان \"متكافئين\" إذا كان الفرق في الدرجات لكل مادة (الصينية، الرياضيات، الإنجليزية)\n لا يزيد عن 5 نقاط، وكان الفرق في المجموع الكلي للدرجات لا يزيد عن 10 نقاط.\n تأخذ الدالة مصفوفة من المصفوفات، حيث تمثل كل مصفوفة فرعية درجات طالب في المواد الثلاث،\n وتعيد العدد الإجمالي لأزواج الطلاب \"المتكافئين\".\n\n مثال:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "sw": "Hesabu idadi ya wanandoa wa wanafunzi wanaoonekana kuwa \"wapinzani waliolingana sawa\". Wanafunzi wawili ni \"waliofanana sawa\" ikiwa tofauti ya alama kwa kila somo (Kichina, Hisabati, Kiingereza) haizidi pointi 5, na tofauti ya jumla ya alama haizidi pointi 10. Kazi inachukua safu ya safu, ambapo kila safu-ndogo inawakilisha alama za mwanafunzi katika masomo matatu, na inarudisha jumla ya idadi ya wanandoa wa wanafunzi \"waliofanana sawa\".\n\nMfano:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "tr": "Öğrencilerin \"eşit derecede eşleşmiş rakipler\" olarak kabul edilen çiftlerinin sayısını sayar.\n İki öğrenci, her bir konu (Çince, Matematik, İngilizce) için puan farkı 5 puandan fazla değilse \n ve toplam puan farkı 10 puandan fazla değilse \"eşit derecede eşleşmiş\" olarak kabul edilir.\n Fonksiyon, her alt dizinin üç konudaki bir öğrencinin puanlarını temsil ettiği bir dizi dizisi alır \n ve \"eşit derecede eşleşmiş\" öğrenci çiftlerinin toplam sayısını döndürür.\n\n Örnek:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "vi": "Đếm số lượng cặp học sinh được coi là \"đối thủ cân sức\". Hai học sinh được coi là \"cân sức\" nếu sự chênh lệch điểm số cho mỗi môn học (Ngữ văn, Toán, Tiếng Anh) không quá 5 điểm, và sự chênh lệch tổng điểm không quá 10 điểm. Hàm nhận vào một mảng các mảng, trong đó mỗi mảng con đại diện cho điểm số của một học sinh trong ba môn học, và trả về tổng số cặp học sinh \"cân sức\".\n\nVí dụ:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2"
    },
    "docstring_bertscore": {
      "es": "0.9852508996866354",
      "arb": "0.9399512549878188",
      "sw": "0.9368089223598469",
      "tr": "0.9741325641082076",
      "vi": "0.9372085666864891"
    }
  },
  {
    "task_id": "Ruby/42",
    "prompt": {
      "en": "# Calculates the total number of cigarettes Peter can smoke given an initial\n# amount of cigarettes and a conversion rate of cigarette butts to new cigarettes.\n# Peter starts with n cigarettes and can turn every k butts into a new cigarette.\n#\n# The function takes two arguments, n and k, where n is the initial number of\n# cigarettes and k is the number of butts required for a new cigarette. It\n# returns the total number of cigarettes Peter can smoke.\n#\n# Examples:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "es": "# Calcula el número total de cigarrillos que Peter puede fumar dado un\n# cantidad inicial de cigarrillos y una tasa de conversión de colillas de cigarrillo a nuevos cigarrillos.\n# Peter comienza con n cigarrillos y puede convertir cada k colillas en un nuevo cigarrillo.\n#\n# La función toma dos argumentos, n y k, donde n es el número inicial de\n# cigarrillos y k es el número de colillas requeridas para un nuevo cigarrillo. \n# Devuelve el número total de cigarrillos que Peter puede fumar.\n#\n# Ejemplos:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "arb": "# يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بناءً على كمية\n# السجائر الأولية ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.\n# يبدأ بيتر بـ n سجائر ويمكنه تحويل كل k أعقاب إلى سيجارة جديدة.\n#\n# تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر و k هو عدد\n# الأعقاب المطلوبة لسيجارة جديدة. تُرجع الدالة العدد الإجمالي للسجائر\n# التي يمكن لبيتر تدخينها.\n#\n# أمثلة:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "sw": "# Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na idadi ya awali\n# ya sigara na kiwango cha ubadilishaji wa vipande vya sigara kuwa sigara mpya.\n# Peter anaanza na sigara n na anaweza kubadilisha kila vipande k kuwa sigara mpya.\n#\n# Kazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya\n# sigara na k ni idadi ya vipande vinavyohitajika kwa sigara mpya. Inarudisha\n# jumla ya sigara ambazo Peter anaweza kuvuta.\n#\n# Mifano:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "tr": "# Peter'ın başlangıçtaki sigara miktarı ve izmaritlerin yeni sigaralara dönüşüm oranı\n# verildiğinde toplam kaç sigara içebileceğini hesaplar.\n# Peter n sigara ile başlar ve her k izmariti yeni bir sigaraya dönüştürebilir.\n#\n# Fonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır\n# ve k yeni bir sigara için gereken izmarit sayısıdır. Bu, Peter'ın toplamda\n# kaç sigara içebileceğini döndürür.\n#\n# Örnekler:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "vi": "# Tính tổng số điếu thuốc mà Peter có thể hút được với số lượng\n# điếu thuốc ban đầu và tỷ lệ chuyển đổi từ đầu lọc thuốc lá thành điếu thuốc mới.\n# Peter bắt đầu với n điếu thuốc và có thể biến mỗi k đầu lọc thành một điếu thuốc mới.\n#\n# Hàm nhận hai tham số, n và k, trong đó n là số lượng điếu thuốc ban đầu\n# và k là số đầu lọc cần thiết để tạo ra một điếu thuốc mới. Hàm trả về tổng số\n# điếu thuốc mà Peter có thể hút.\n#\n# Ví dụ:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)"
    },
    "prompt_bertscore": {
      "es": "0.9877542383788182",
      "arb": "0.9772407323106415",
      "sw": "0.9733571111006474",
      "tr": "0.9731880766463866",
      "vi": "0.9517101735450842"
    },
    "canonical_solution": "    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end",
    "instruction": {
      "en": "Write a ruby function `def total_smoked_cigarettes(n, k)` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke given an initial\n amount of cigarettes and a conversion rate of cigarette butts to new cigarettes.\n Peter starts with n cigarettes and can turn every k butts into a new cigarette.\n\n The function takes two arguments, n and k, where n is the initial number of\n cigarettes and k is the number of butts required for a new cigarette. It\n returns the total number of cigarettes Peter can smoke.\n\n Examples:\n >>> total_smoked_cigarettes(4, 3)\n 5\n >>> total_smoked_cigarettes(10, 3)\n 14",
      "es": "Escribe una función en Ruby `def total_smoked_cigarettes(n, k)` para resolver el siguiente problema:\nCalcula el número total de cigarrillos que Peter puede fumar dado un monto inicial de cigarrillos y una tasa de conversión de colillas a nuevos cigarrillos. Peter comienza con n cigarrillos y puede convertir cada k colillas en un nuevo cigarrillo.\n\nLa función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos y k es el número de colillas requeridas para un nuevo cigarrillo. Devuelve el número total de cigarrillos que Peter puede fumar.\n\nEjemplos:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "arb": "اكتب دالة روبي `def total_smoked_cigarettes(n, k)` لحل المشكلة التالية:\nتحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بالنظر إلى كمية\n السجائر الأولية ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.\n يبدأ بيتر بـ n سجائر ويمكنه تحويل كل k أعقاب إلى سيجارة جديدة.\n\n تأخذ الدالة معاملين، n و k، حيث n هو عدد السجائر الأولي و k هو عدد\n الأعقاب المطلوبة لسيجارة جديدة. تعيد الدالة العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n\n أمثلة:\n >>> total_smoked_cigarettes(4, 3)\n 5\n >>> total_smoked_cigarettes(10, 3)\n 14",
      "sw": "Andika kazi ya ruby `def total_smoked_cigarettes(n, k)` kutatua tatizo lifuatalo:\nInakokotoa jumla ya sigara ambazo Peter anaweza kuvuta kutokana na kiasi cha awali\ncha sigara na kiwango cha ubadilishaji wa vishungi vya sigara kuwa sigara mpya.\nPeter anaanza na n sigara na anaweza kubadilisha kila k vishungi kuwa sigara mpya.\n\nKazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya\nsigara na k ni idadi ya vishungi vinavyohitajika kwa sigara mpya. Inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.\n\nMifano:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "tr": "Bir ruby fonksiyonu `def total_smoked_cigarettes(n, k)` yazın ve aşağıdaki problemi çözün:\nPeter'ın başlangıçtaki sigara miktarı ve izmaritlerin yeni sigaralara dönüştürülme oranı verildiğinde, Peter'ın içebileceği toplam sigara sayısını hesaplar.\nPeter n sigara ile başlar ve her k izmariti yeni bir sigaraya dönüştürebilir.\n\nFonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır ve k yeni bir sigara için gereken izmarit sayısıdır. Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n\nÖrnekler:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "vi": "Viết một hàm ruby `def total_smoked_cigarettes(n, k)` để giải quyết vấn đề sau:\nTính tổng số điếu thuốc mà Peter có thể hút được với một số lượng thuốc lá ban đầu và tỷ lệ chuyển đổi từ đầu lọc thuốc lá thành điếu thuốc mới. Peter bắt đầu với n điếu thuốc và có thể biến mỗi k đầu lọc thành một điếu thuốc mới.\n\nHàm nhận hai tham số, n và k, trong đó n là số lượng điếu thuốc ban đầu và k là số đầu lọc cần thiết để có một điếu thuốc mới. Nó trả về tổng số điếu thuốc mà Peter có thể hút.\n\nVí dụ:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14"
    },
    "instruction_bertscore": {
      "es": "0.986159435049489",
      "arb": "0.9797869751651277",
      "sw": "0.9722584864631434",
      "tr": "0.9870270525538494",
      "vi": "0.9726362814478717"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless total_smoked_cigarettes(4, 3) == 5\nraise 'Test failed' unless total_smoked_cigarettes(10, 3) == 14\nraise 'Test failed' unless total_smoked_cigarettes(20, 4) == 26\nraise 'Test failed' unless total_smoked_cigarettes(1, 2) == 1\nraise 'Test failed' unless total_smoked_cigarettes(100, 5) == 124\n  ",
    "entry_point": "total_smoked_cigarettes",
    "signature": "def total_smoked_cigarettes(n, k)",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke given an initial\n amount of cigarettes and a conversion rate of cigarette butts to new cigarettes.\n Peter starts with n cigarettes and can turn every k butts into a new cigarette.\n\n The function takes two arguments, n and k, where n is the initial number of\n cigarettes and k is the number of butts required for a new cigarette. It\n returns the total number of cigarettes Peter can smoke.\n\n Examples:\n >>> total_smoked_cigarettes(4, 3)\n 5\n >>> total_smoked_cigarettes(10, 3)\n 14",
      "es": "Calcula el número total de cigarrillos que Peter puede fumar dado un monto inicial de cigarrillos y una tasa de conversión de colillas de cigarrillos a nuevos cigarrillos. Peter comienza con n cigarrillos y puede convertir cada k colillas en un nuevo cigarrillo.\n\nLa función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos y k es el número de colillas requeridas para un nuevo cigarrillo. Devuelve el número total de cigarrillos que Peter puede fumar.\n\nEjemplos:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "arb": "يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر بالنظر إلى كمية أولية من السجائر ومعدل تحويل أعقاب السجائر إلى سجائر جديدة. يبدأ بيتر بـ n سيجارة ويمكنه تحويل كل k عقب إلى سيجارة جديدة.\n\nتأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر و k هو عدد الأعقاب المطلوبة لسيجارة جديدة. تُرجع الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n\nأمثلة:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na idadi ya awali ya sigara na kiwango cha ubadilishaji wa vipande vya sigara kuwa sigara mpya. Peter anaanza na sigara n na anaweza kubadilisha kila vipande k kuwa sigara mpya.\n\nKazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara na k ni idadi ya vipande vinavyohitajika kwa sigara mpya. Inarudisha jumla ya sigara ambazo Peter anaweza kuvuta.\n\nMifano:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "tr": "Peter'ın başlangıçtaki sigara miktarı ve izmaritlerin yeni sigaralara dönüşüm oranı verildiğinde, toplam kaç sigara içebileceğini hesaplar. Peter, n sigara ile başlar ve her k izmariti yeni bir sigaraya dönüştürebilir.\n\nFonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır ve k yeni bir sigara için gereken izmarit sayısıdır. Peter'ın içebileceği toplam sigara sayısını döndürür.\n\nÖrnekler:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "vi": "Tính tổng số điếu thuốc mà Peter có thể hút được với một lượng thuốc ban đầu và tỷ lệ chuyển đổi từ tàn thuốc thành điếu thuốc mới. Peter bắt đầu với n điếu thuốc và có thể biến mỗi k tàn thuốc thành một điếu thuốc mới.\n\nHàm nhận hai tham số, n và k, trong đó n là số lượng điếu thuốc ban đầu và k là số tàn thuốc cần thiết để có một điếu thuốc mới. Nó trả về tổng số điếu thuốc mà Peter có thể hút.\n\nVí dụ:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14"
    },
    "docstring_bertscore": {
      "es": "0.9900096863554693",
      "arb": "0.9853976875382202",
      "sw": "0.9707794846459576",
      "tr": "0.9511281865286519",
      "vi": "0.9657408277702456"
    }
  },
  {
    "task_id": "Ruby/43",
    "prompt": {
      "en": "# Finds the length of the longest consecutive sequence in an array of integers.\n# The function takes an array of integers as an argument and returns the length\n# of the longest consecutive sequence of numbers present in the array.\n#\n# Example:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Because the longest consecutive sequence is 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "es": "# Encuentra la longitud de la secuencia consecutiva más larga en un arreglo de enteros.\n# La función toma un arreglo de enteros como argumento y devuelve la longitud\n# de la secuencia consecutiva más larga de números presente en el arreglo.\n#\n# Ejemplo:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Porque la secuencia consecutiva más larga es 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Porque la secuencia consecutiva más larga es 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "arb": "# يجد طول أطول تسلسل متتابع في مصفوفة من الأعداد الصحيحة.\n# تأخذ الدالة مصفوفة من الأعداد الصحيحة كمعامل وتعيد طول\n# أطول تسلسل متتابع من الأرقام الموجودة في المصفوفة.\n#\n# مثال:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # لأن أطول تسلسل متتابع هو 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # لأن أطول تسلسل متتابع هو 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "sw": "# Inapata urefu wa mlolongo mrefu zaidi wa namba mfululizo katika safu ya namba za mzima.\n# Kazi inachukua safu ya namba za mzima kama hoja na inarudisha urefu\n# wa mlolongo mrefu zaidi wa namba mfululizo uliopo kwenye safu.\n#\n# Mfano:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Kwa sababu mlolongo mrefu zaidi wa namba mfululizo ni 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Kwa sababu mlolongo mrefu zaidi wa namba mfululizo ni 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "tr": "# Bir tamsayı dizisindeki en uzun ardışık dizinin uzunluğunu bulur.\n# Fonksiyon, bir tamsayı dizisini argüman olarak alır ve dizide bulunan\n# en uzun ardışık sayı dizisinin uzunluğunu döndürür.\n#\n# Örnek:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Çünkü en uzun ardışık dizi 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Çünkü en uzun ardışık dizi 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "vi": "# Tìm độ dài của dãy số liên tiếp dài nhất trong một mảng số nguyên.\n# Hàm nhận một mảng số nguyên làm đối số và trả về độ dài\n# của dãy số liên tiếp dài nhất có trong mảng.\n#\n# Ví dụ:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Vì dãy số liên tiếp dài nhất là 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Vì dãy số liên tiếp dài nhất là 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)"
    },
    "prompt_bertscore": {
      "es": "0.995621789141229",
      "arb": "1",
      "sw": "0.9729638229461982",
      "tr": "0.9748986814878591",
      "vi": "0.9809014902331145"
    },
    "canonical_solution": "    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end",
    "instruction": {
      "en": "Write a ruby function `def longest_consecutive_sequence(arr)` to solve the following problem:\nFinds the length of the longest consecutive sequence in an array of integers.\n The function takes an array of integers as an argument and returns the length\n of the longest consecutive sequence of numbers present in the array.\n\n Example:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Because the longest consecutive sequence is 1, 2, 3, 4",
      "es": "Escribe una función ruby `def longest_consecutive_sequence(arr)` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia consecutiva más larga en un arreglo de enteros.\nLa función toma un arreglo de enteros como argumento y devuelve la longitud\nde la secuencia consecutiva más larga de números presente en el arreglo.\n\nEjemplo:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Porque la secuencia consecutiva más larga es 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Porque la secuencia consecutiva más larga es 1, 2, 3, 4",
      "arb": "اكتب دالة روبي `def longest_consecutive_sequence(arr)` لحل المشكلة التالية:\nتجد طول أطول تسلسل متتابع في مصفوفة من الأعداد الصحيحة.\nتأخذ الدالة مصفوفة من الأعداد الصحيحة كمعامل وتعيد طول\nأطول تسلسل متتابع من الأرقام الموجودة في المصفوفة.\n\nمثال:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   لأن أطول تسلسل متتابع هو 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   لأن أطول تسلسل متتابع هو 1, 2, 3, 4",
      "sw": "Andika kazi ya ruby `def longest_consecutive_sequence(arr)` kutatua tatizo lifuatalo:\nInapata urefu wa mlolongo mrefu zaidi wa namba mfululizo katika safu ya namba nzima.\n Kazi inachukua safu ya namba nzima kama hoja na inarejesha urefu\n wa mlolongo mrefu zaidi wa namba mfululizo uliopo kwenye safu.\n\n Mfano:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Kwa sababu mlolongo mrefu zaidi wa namba mfululizo ni 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Kwa sababu mlolongo mrefu zaidi wa namba mfululizo ni 1, 2, 3, 4",
      "tr": "Ruby fonksiyonu `def longest_consecutive_sequence(arr)` yazın ve aşağıdaki problemi çözün:\nBir tamsayı dizisindeki en uzun ardışık dizinin uzunluğunu bulur.\nFonksiyon, bir tamsayı dizisini argüman olarak alır ve dizide bulunan en uzun ardışık sayı dizisinin uzunluğunu döndürür.\n\nÖrnek:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Çünkü en uzun ardışık dizi 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Çünkü en uzun ardışık dizi 1, 2, 3, 4",
      "vi": "Viết một hàm ruby `def longest_consecutive_sequence(arr)` để giải quyết vấn đề sau:\nTìm độ dài của dãy số liên tiếp dài nhất trong một mảng số nguyên.\nHàm nhận một mảng số nguyên làm tham số và trả về độ dài của dãy số liên tiếp dài nhất có trong mảng.\n\nVí dụ:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Vì dãy số liên tiếp dài nhất là 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Vì dãy số liên tiếp dài nhất là 1, 2, 3, 4"
    },
    "instruction_bertscore": {
      "es": "0.9949490280406639",
      "arb": "0.9878438206806649",
      "sw": "0.9736338032214289",
      "tr": "0.9536944910516227",
      "vi": "0.9775915135635491"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9]) ==6\nraise 'Test failed' unless longest_consecutive_sequence([10, 4, 20, 1, 3, 2]) == 4\nraise 'Test failed' unless longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4\nraise 'Test failed' unless longest_consecutive_sequence([1, 2, 0, 1]) == 3\nraise 'Test failed' unless longest_consecutive_sequence([]) == 0\nraise 'Test failed' unless longest_consecutive_sequence([1]) == 1",
    "entry_point": "longest_consecutive_sequence",
    "signature": "def longest_consecutive_sequence(arr)",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in an array of integers.\n The function takes an array of integers as an argument and returns the length\n of the longest consecutive sequence of numbers present in the array.\n\n Example:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Because the longest consecutive sequence is 1, 2, 3, 4",
      "es": "Encuentra la longitud de la secuencia consecutiva más larga en un arreglo de enteros.\n La función toma un arreglo de enteros como argumento y devuelve la longitud\n de la secuencia consecutiva más larga de números presente en el arreglo.\n\n Ejemplo:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Porque la secuencia consecutiva más larga es 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Porque la secuencia consecutiva más larga es 1, 2, 3, 4",
      "arb": "يجد طول أطول تسلسل متتابع في مصفوفة من الأعداد الصحيحة.\nتأخذ الدالة مصفوفة من الأعداد الصحيحة كمعامل وتعيد طول\nأطول تسلسل متتابع من الأرقام الموجودة في المصفوفة.\n\nمثال:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   لأن أطول تسلسل متتابع هو 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   لأن أطول تسلسل متتابع هو 1, 2, 3, 4",
      "sw": "Inapata urefu wa mlolongo mrefu zaidi wa mfululizo katika safu ya nambari za mzima. \nKazi inachukua safu ya nambari za mzima kama hoja na inarudisha urefu wa mlolongo mrefu zaidi wa nambari za mfululizo zilizopo kwenye safu.\n\nMfano:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Kwa sababu mlolongo mrefu zaidi wa mfululizo ni 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Kwa sababu mlolongo mrefu zaidi wa mfululizo ni 1, 2, 3, 4",
      "tr": "Dizideki en uzun ardışık dizinin uzunluğunu bulur. Fonksiyon, bir tamsayı dizisini argüman olarak alır ve dizide bulunan en uzun ardışık sayı dizisinin uzunluğunu döndürür.\n\nÖrnek:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Çünkü en uzun ardışık dizi 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Çünkü en uzun ardışık dizi 1, 2, 3, 4",
      "vi": "Tìm độ dài của dãy số liên tiếp dài nhất trong một mảng số nguyên. Hàm này nhận một mảng số nguyên làm đối số và trả về độ dài của dãy số liên tiếp dài nhất có trong mảng.\n\nVí dụ:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Bởi vì dãy số liên tiếp dài nhất là 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Bởi vì dãy số liên tiếp dài nhất là 1, 2, 3, 4"
    },
    "docstring_bertscore": {
      "es": "0.9930380051447272",
      "arb": "0.9945473974102113",
      "sw": "1",
      "tr": "0.9609973356407514",
      "vi": "0.9747554689831329"
    }
  },
  {
    "task_id": "Ruby/44",
    "prompt": {
      "en": "# Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n# The function takes three arguments, a, b, and c, which are positive integers representing the side length of the square and the sides of the rectangle, respectively.\n# It returns a string indicating whose shape has the greater area: \"Alice\" if the square's area is larger, and \"Bob\" if the rectangle's area is larger.\n#\n# Examples:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "es": "# Compara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con lados 'b' y 'c'.\n# La función toma tres argumentos, a, b y c, que son enteros positivos que representan la longitud del lado del cuadrado y los lados del rectángulo, respectivamente.\n# Devuelve una cadena que indica cuál forma tiene el área mayor: \"Alice\" si el área del cuadrado es mayor, y \"Bob\" si el área del rectángulo es mayor.\n#\n# Ejemplos:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "arb": "# يقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأضلاع 'b' و 'c'.\n# تأخذ الدالة ثلاثة مدخلات، a و b و c، وهي أعداد صحيحة موجبة تمثل طول ضلع المربع وأضلاع المستطيل، على التوالي.\n# تعيد سلسلة نصية تشير إلى الشكل الذي له المساحة الأكبر: \"Alice\" إذا كانت مساحة المربع أكبر، و \"Bob\" إذا كانت مساحة المستطيل أكبر.\n#\n# أمثلة:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "sw": "# Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye pande 'b' na 'c'.\n# Kazi inachukua hoja tatu, a, b, na c, ambazo ni nambari nzima chanya zinazowakilisha urefu wa upande wa mraba na pande za mstatili, mtawalia.\n# Inarudisha kamba inayoonyesha umbo gani lina eneo kubwa zaidi: \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, na \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi.\n#\n# Mifano:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "tr": "# 'a' kenar uzunluğuna sahip bir karenin alanını, 'b' ve 'c' kenarlarına sahip bir dikdörtgenin alanıyla karşılaştırır.\n# Fonksiyon, sırasıyla karenin kenar uzunluğunu ve dikdörtgenin kenarlarını temsil eden pozitif tamsayılar olan üç argüman alır: a, b ve c.\n# Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" şeklinde hangi şeklin daha büyük alana sahip olduğunu belirten bir dize döndürür.\n#\n# Örnekler:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "vi": "# So sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật với các cạnh 'b' và 'c'.\n# Hàm nhận ba tham số, a, b, và c, là các số nguyên dương đại diện cho độ dài cạnh của hình vuông và các cạnh của hình chữ nhật, tương ứng.\n# Nó trả về một chuỗi chỉ ra hình nào có diện tích lớn hơn: \"Alice\" nếu diện tích của hình vuông lớn hơn, và \"Bob\" nếu diện tích của hình chữ nhật lớn hơn.\n#\n# Ví dụ:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)"
    },
    "prompt_bertscore": {
      "es": "0.9813380798106291",
      "arb": "0.9843574602327405",
      "sw": "0.9832085821088347",
      "tr": "0.9852908243932235",
      "vi": "0.979794324489226"
    },
    "canonical_solution": "    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end",
    "instruction": {
      "en": "Write a ruby function `def compare_area(a, b, c)` to solve the following problem:\nCompares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n The function takes three arguments, a, b, and c, which are positive integers representing the side length of the square and the sides of the rectangle, respectively.\n It returns a string indicating whose shape has the greater area: \"Alice\" if the square's area is larger, and \"Bob\" if the rectangle's area is larger.\n\n Examples:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "es": "Escribe una función en ruby `def compare_area(a, b, c)` para resolver el siguiente problema:\nCompara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con lados 'b' y 'c'.\n La función toma tres argumentos, a, b y c, que son enteros positivos que representan la longitud del lado del cuadrado y los lados del rectángulo, respectivamente.\n Devuelve una cadena que indica cuál forma tiene el área mayor: \"Alice\" si el área del cuadrado es mayor, y \"Bob\" si el área del rectángulo es mayor.\n\n Ejemplos:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "arb": "اكتب دالة روبي `def compare_area(a, b, c)` لحل المشكلة التالية:\nيقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأضلاع 'b' و 'c'.\nتأخذ الدالة ثلاثة معاملات، a، b، و c، وهي أعداد صحيحة موجبة تمثل طول ضلع المربع وأضلاع المستطيل، على التوالي.\nتعيد سلسلة نصية تشير إلى الشكل الذي له مساحة أكبر: \"Alice\" إذا كانت مساحة المربع أكبر، و \"Bob\" إذا كانت مساحة المستطيل أكبر.\n\nأمثلة:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "sw": "Andika kazi ya ruby `def compare_area(a, b, c)` kutatua tatizo lifuatalo:\nInalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye pande 'b' na 'c'.\n Kazi inachukua hoja tatu, a, b, na c, ambazo ni nambari kamili chanya zinazowakilisha urefu wa upande wa mraba na pande za mstatili, mtawalia.\n Inarudisha kamba inayoonyesha umbo gani lina eneo kubwa zaidi: \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, na \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi.\n\n Mifano:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "tr": "Bir ruby fonksiyonu `def compare_area(a, b, c)` yazın ve aşağıdaki problemi çözün:\nKenar uzunluğu 'a' olan bir karenin alanını, kenarları 'b' ve 'c' olan bir dikdörtgenin alanı ile karşılaştırır.\n Fonksiyon, sırasıyla karenin kenar uzunluğunu ve dikdörtgenin kenarlarını temsil eden pozitif tamsayılar olan üç argüman alır: a, b ve c.\n Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" döndüren bir string döndürür.\n\n Örnekler:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "vi": "Viết một hàm ruby `def compare_area(a, b, c)` để giải quyết vấn đề sau:\nSo sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật với các cạnh 'b' và 'c'.\nHàm nhận ba đối số, a, b, và c, là các số nguyên dương đại diện cho độ dài cạnh của hình vuông và các cạnh của hình chữ nhật, tương ứng.\nNó trả về một chuỗi chỉ ra hình nào có diện tích lớn hơn: \"Alice\" nếu diện tích của hình vuông lớn hơn, và \"Bob\" nếu diện tích của hình chữ nhật lớn hơn.\n\nVí dụ:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\""
    },
    "instruction_bertscore": {
      "es": "0.9776050204294595",
      "arb": "0.9894453774429491",
      "sw": "0.983329945271647",
      "tr": "0.9543819508003845",
      "vi": "0.9799617699004384"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless compare_area(5, 4, 6) == \"Alice\"\nraise 'Test failed' unless compare_area(7, 5, 10) == \"Bob\"\nraise 'Test failed' unless compare_area(6, 3, 12) == \"Bob\"\nraise 'Test failed' unless compare_area(10, 10, 1) == \"Alice\"\nraise 'Test failed' unless compare_area(8, 8, 8) == \"Bob\" # Case where areas are equal, but based on the problem statement, Bob wins in a tie.",
    "entry_point": "compare_area",
    "signature": "def compare_area(a, b, c)",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n The function takes three arguments, a, b, and c, which are positive integers representing the side length of the square and the sides of the rectangle, respectively.\n It returns a string indicating whose shape has the greater area: \"Alice\" if the square's area is larger, and \"Bob\" if the rectangle's area is larger.\n\n Examples:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "es": "Compara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con lados 'b' y 'c'. La función toma tres argumentos, a, b y c, que son enteros positivos que representan la longitud del lado del cuadrado y los lados del rectángulo, respectivamente. Devuelve una cadena que indica cuál forma tiene el área mayor: \"Alice\" si el área del cuadrado es mayor, y \"Bob\" si el área del rectángulo es mayor.\n\nEjemplos:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "arb": "يقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأضلاع 'b' و 'c'.\n تأخذ الدالة ثلاثة معاملات، a و b و c، وهي أعداد صحيحة موجبة تمثل طول ضلع المربع وأضلاع المستطيل، على التوالي.\n تُرجع سلسلة نصية تشير إلى الشكل الذي لديه مساحة أكبر: \"Alice\" إذا كانت مساحة المربع أكبر، و \"Bob\" إذا كانت مساحة المستطيل أكبر.\n\n أمثلة:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "sw": "Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye pande 'b' na 'c'.\n Kazi hii inachukua hoja tatu, a, b, na c, ambazo ni nambari nzima chanya zinazowakilisha urefu wa upande wa mraba na pande za mstatili, mtawalia.\n Inarudisha kamba inayoonyesha umbo gani lina eneo kubwa zaidi: \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, na \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi.\n\n Mifano:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "tr": "Bir kenar uzunluğu 'a' olan bir karenin alanını, kenarları 'b' ve 'c' olan bir dikdörtgenin alanıyla karşılaştırır.\n Fonksiyon, sırasıyla karenin kenar uzunluğunu ve dikdörtgenin kenarlarını temsil eden pozitif tamsayılar olan üç argüman alır: a, b ve c.\n Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" şeklinde hangi şeklin daha büyük alana sahip olduğunu belirten bir dize döndürür.\n\n Örnekler:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "vi": "So sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật với các cạnh 'b' và 'c'. \nHàm nhận ba đối số, a, b, và c, là các số nguyên dương đại diện cho độ dài cạnh của hình vuông và các cạnh của hình chữ nhật, tương ứng.\nNó trả về một chuỗi chỉ ra hình nào có diện tích lớn hơn: \"Alice\" nếu diện tích của hình vuông lớn hơn, và \"Bob\" nếu diện tích của hình chữ nhật lớn hơn.\n\nVí dụ:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\""
    },
    "docstring_bertscore": {
      "es": "0.9780714045641293",
      "arb": "0.9939816980850239",
      "sw": "0.9784062953865542",
      "tr": "0.9867293056126781",
      "vi": "0.9778262946739323"
    }
  },
  {
    "task_id": "Ruby/45",
    "prompt": {
      "en": "# Finds M positive integers whose sum is N, such that their product is maximized.\n# The function returns an array of these integers in lexicographically smallest order.\n#\n# Args:\n#   n: A positive integer representing the sum of the integers to find.\n#   m: A positive integer representing the number of integers to find.\n#\n# Returns:\n#   An array of integers that are the lexicographically smallest set of integers\n#   whose sum is N and whose product is maximized.\n#\n# Examples:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "es": "# Encuentra M enteros positivos cuya suma es N, de manera que su producto sea maximizado.\n# La función devuelve un arreglo de estos enteros en el orden lexicográficamente más pequeño.\n#\n# Argumentos:\n#   n: Un entero positivo que representa la suma de los enteros a encontrar.\n#   m: Un entero positivo que representa el número de enteros a encontrar.\n#\n# Devuelve:\n#   Un arreglo de enteros que son el conjunto de enteros lexicográficamente más pequeño\n#   cuya suma es N y cuyo producto es maximizado.\n#\n# Ejemplos:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "arb": "# يجد M عددًا صحيحًا موجبًا يكون مجموعها N، بحيث يتم تعظيم حاصل ضربها.\n# تُرجع الدالة مصفوفة من هذه الأعداد بترتيب معجمي أصغر.\n#\n# الوسائط:\n#   n: عدد صحيح موجب يمثل مجموع الأعداد التي يجب إيجادها.\n#   m: عدد صحيح موجب يمثل عدد الأعداد التي يجب إيجادها.\n#\n# الإرجاع:\n#   مصفوفة من الأعداد الصحيحة التي تمثل المجموعة الأصغر معجميًا من الأعداد\n#   التي يكون مجموعها N ويكون حاصل ضربها معظّمًا.\n#\n# أمثلة:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "sw": "# Inapata nambari M chanya ambazo jumla yake ni N, ili kwamba bidhaa yao iwe kubwa zaidi.\n# Kazi inarudisha safu ya nambari hizi katika mpangilio mdogo wa lexicographically.\n#\n# Vipengele:\n#   n: Nambari chanya inayowakilisha jumla ya nambari za kupata.\n#   m: Nambari chanya inayowakilisha idadi ya nambari za kupata.\n#\n# Inarudisha:\n#   Safu ya nambari ambazo ni seti ndogo ya lexicographically ya nambari\n#   ambazo jumla yake ni N na bidhaa yao imeongezwa.\n#\n# Mifano:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "tr": "# Toplamı N olan ve çarpımları maksimum olan M pozitif tam sayı bulur.\n# Fonksiyon, bu tam sayıların sözlükbilimsel olarak en küçük sıralı bir dizisini döndürür.\n#\n# Argümanlar:\n#   n: Bulunacak tam sayıların toplamını temsil eden pozitif bir tam sayı.\n#   m: Bulunacak tam sayıların sayısını temsil eden pozitif bir tam sayı.\n#\n# Döndürür:\n#   Toplamı N olan ve çarpımları maksimize edilmiş sözlükbilimsel olarak en küçük\n#   tam sayı kümesi olan bir tam sayı dizisi.\n#\n# Örnekler:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "vi": "# Tìm M số nguyên dương có tổng là N, sao cho tích của chúng được tối đa hóa.\n# Hàm trả về một mảng các số nguyên này theo thứ tự từ điển nhỏ nhất.\n#\n# Tham số:\n#   n: Một số nguyên dương đại diện cho tổng của các số nguyên cần tìm.\n#   m: Một số nguyên dương đại diện cho số lượng số nguyên cần tìm.\n#\n# Trả về:\n#   Một mảng các số nguyên là tập hợp các số nguyên có thứ tự từ điển nhỏ nhất\n#   có tổng là N và tích của chúng được tối đa hóa.\n#\n# Ví dụ:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)"
    },
    "prompt_bertscore": {
      "es": "0.987326785798831",
      "arb": "0.949033033269496",
      "sw": "0.949033033269496",
      "tr": "0.9594045186152327",
      "vi": "0.9474072436007254"
    },
    "canonical_solution": "    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end",
    "instruction": {
      "en": "Write a ruby function `def max_product_partition(n, m)` to solve the following problem:\nFinds M positive integers whose sum is N, such that their product is maximized.\n The function returns an array of these integers in lexicographically smallest order.\n\n Args:\n   n: A positive integer representing the sum of the integers to find.\n   m: A positive integer representing the number of integers to find.\n\n Returns:\n   An array of integers that are the lexicographically smallest set of integers\n   whose sum is N and whose product is maximized.\n\n Examples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "es": "Escribe una función de Ruby `def max_product_partition(n, m)` para resolver el siguiente problema:\nEncuentra M enteros positivos cuya suma sea N, de tal manera que su producto sea maximizado.\n La función devuelve un arreglo de estos enteros en el orden lexicográficamente más pequeño.\n\n Argumentos:\n   n: Un entero positivo que representa la suma de los enteros a encontrar.\n   m: Un entero positivo que representa el número de enteros a encontrar.\n\n Devuelve:\n   Un arreglo de enteros que son el conjunto de enteros lexicográficamente más pequeño\n   cuya suma es N y cuyo producto es maximizado.\n\n Ejemplos:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "arb": "اكتب دالة روبي `def max_product_partition(n, m)` لحل المشكلة التالية:\nتجد M عددًا صحيحًا موجبًا يكون مجموعها N، بحيث يتم تعظيم حاصل ضربها.\nتعيد الدالة مصفوفة من هذه الأعداد بترتيب معجمي أصغر.\n\nالمعطيات:\n   n: عدد صحيح موجب يمثل مجموع الأعداد المطلوب إيجادها.\n   m: عدد صحيح موجب يمثل عدد الأعداد المطلوب إيجادها.\n\nالقيم المعادة:\n   مصفوفة من الأعداد الصحيحة التي تمثل أصغر مجموعة من الأعداد بترتيب معجمي\n   يكون مجموعها N ويكون حاصل ضربها معظماً.\n\nأمثلة:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "sw": "Andika kazi ya ruby `def max_product_partition(n, m)` kutatua tatizo lifuatalo:\nInapata nambari M ambazo ni chanya na jumla yao ni N, ili kwamba zao lao liwe kubwa zaidi.\n Kazi inarudisha safu ya nambari hizi katika mpangilio mdogo zaidi wa lexicographically.\n\n Hoja:\n   n: Nambari chanya inayowakilisha jumla ya nambari za kupata.\n   m: Nambari chanya inayowakilisha idadi ya nambari za kupata.\n\n Inarudisha:\n   Safu ya nambari ambazo ni seti ndogo zaidi ya lexicographically ya nambari\n   ambazo jumla yao ni N na zao lao limewezeshwa kuwa kubwa zaidi.\n\n Mifano:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "tr": "Bir ruby fonksiyonu `def max_product_partition(n, m)` yazın ve aşağıdaki problemi çözün:\nToplamı N olan ve çarpımları maksimum olan M pozitif tam sayı bulun.\nFonksiyon, bu tam sayıların sözlük sırasına göre en küçük olanını bir dizi olarak döndürür.\n\nArgümanlar:\n   n: Bulunacak tam sayıların toplamını temsil eden pozitif bir tam sayı.\n   m: Bulunacak tam sayıların sayısını temsil eden pozitif bir tam sayı.\n\nDöndürür:\n   Toplamı N olan ve çarpımları maksimum olan tam sayıların sözlük sırasına göre en küçük kümesi olan bir tam sayı dizisi.\n\nÖrnekler:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "vi": "Viết một hàm ruby `def max_product_partition(n, m)` để giải quyết vấn đề sau:  \nTìm M số nguyên dương có tổng là N, sao cho tích của chúng là lớn nhất.  \nHàm trả về một mảng các số nguyên này theo thứ tự từ điển nhỏ nhất.\n\nTham số:  \n  n: Một số nguyên dương đại diện cho tổng của các số nguyên cần tìm.  \n  m: Một số nguyên dương đại diện cho số lượng số nguyên cần tìm.\n\nTrả về:  \n  Một mảng các số nguyên là tập hợp các số nguyên nhỏ nhất theo thứ tự từ điển  \n  có tổng là N và tích của chúng là lớn nhất.\n\nVí dụ:  \n  >>> max_product_partition(6, 3)  \n  [2, 2, 2]  \n  >>> max_product_partition(8, 3)  \n  [2, 3, 3]"
    },
    "instruction_bertscore": {
      "es": "0.9945378631519216",
      "arb": "0.9472207296729337",
      "sw": "0.945247138206971",
      "tr": "0.9384446435476692",
      "vi": "0.9411781948514714"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless max_product_partition(6, 3) == [2, 2, 2]\nraise 'Test failed' unless max_product_partition(8, 3) == [2, 3, 3]\nraise 'Test failed' unless max_product_partition(10, 2) == [5, 5]\nraise 'Test failed' unless max_product_partition(7, 3) == [2, 2, 3]\nraise 'Test failed' unless max_product_partition(20, 5) == [4, 4, 4, 4, 4]",
    "entry_point": "max_product_partition",
    "signature": "def max_product_partition(n, m)",
    "docstring": {
      "en": "Finds M positive integers whose sum is N, such that their product is maximized.\n The function returns an array of these integers in lexicographically smallest order.\n\n Args:\n   n: A positive integer representing the sum of the integers to find.\n   m: A positive integer representing the number of integers to find.\n\n Returns:\n   An array of integers that are the lexicographically smallest set of integers\n   whose sum is N and whose product is maximized.\n\n Examples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "es": "Encuentra M enteros positivos cuya suma es N, de manera que su producto sea maximizado. La función devuelve un arreglo de estos enteros en el orden lexicográficamente más pequeño.\n\nArgumentos:\n  n: Un entero positivo que representa la suma de los enteros a encontrar.\n  m: Un entero positivo que representa el número de enteros a encontrar.\n\nDevuelve:\n  Un arreglo de enteros que es el conjunto de enteros lexicográficamente más pequeño\n  cuya suma es N y cuyo producto es maximizado.\n\nEjemplos:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "arb": "يجد M عددًا صحيحًا موجبًا يكون مجموعها N، بحيث يتم تعظيم حاصل ضربها. تُرجع الدالة مصفوفة من هذه الأعداد بترتيب معجمي أصغر.\n\nيعيدالحجج:\n   n: عدد صحيح موجب يمثل مجموع الأعداد التي يجب إيجادها.\n   m: عدد صحيح موجب يمثل عدد الأعداد التي يجب إيجادها.\n\nيعيد:\n   مصفوفة من الأعداد الصحيحة التي تمثل أصغر مجموعة معجمية من الأعداد\n   التي يكون مجموعها N وحاصل ضربها مُعظم.\n\nامثله:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "sw": "Inapata nambari kamili M ambazo jumla yake ni N, ili kwamba bidhaa yao iwe kubwa zaidi.  \nKazi inarejesha safu ya nambari hizi kwa mpangilio mdogo wa kamusi.\n Kazi inarudisha safu ya nambari hizi katika mpangilio mdogo zaidi wa lexicographically.\n\nHoja:  \n   n: Nambari kamili chanya inayowakilisha jumla ya nambari za kupata.  \n   m: Nambari kamili chanya inayowakilisha idadi ya nambari za kupata.\n\nInarudisha: \n   Safu ya nambari ambazo ni seti ndogo zaidi ya nambari kwa mpangilio wa kamusi  \n   ambazo jumla yake ni N na bidhaa yao imewezeshwa.\n\nMifano:  \n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "tr": "M pozitif tam sayının toplamı N olacak şekilde bulunur, bu sayede çarpımları maksimize edilir. Fonksiyon, bu tam sayıların leksikografik olarak en küçük sırasını içeren bir dizi döndürür.\n\nArgümanlar:\n   n: Bulunacak tam sayıların toplamını temsil eden pozitif bir tam sayı.\n   m: Bulunacak tam sayıların sayısını temsil eden pozitif bir tam sayı.\n\nDöndürür:\n   Toplamı N olan ve çarpımı maksimize edilen tam sayıların leksikografik olarak en küçük kümesini içeren bir tam sayı dizisi.\n\nÖrnekler:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "vi": "Tìm M số nguyên dương có tổng là N, sao cho tích của chúng được tối đa hóa. Hàm trả về một mảng các số nguyên này theo thứ tự từ điển nhỏ nhất.\n\nTham số:\n  n: Một số nguyên dương đại diện cho tổng của các số nguyên cần tìm.\n  m: Một số nguyên dương đại diện cho số lượng số nguyên cần tìm.\n\nTrả về:\n  Một mảng các số nguyên là tập hợp các số nguyên nhỏ nhất theo thứ tự từ điển có tổng là N và tích của chúng được tối đa hóa.\n\nVí dụ:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]"
    },
    "docstring_bertscore": {
      "es": "0.9900414672164348",
      "arb": "0.9571192760814262",
      "sw": "0.999999801369619",
      "tr": "0.9422136550278062",
      "vi": "0.9515240568780545"
    }
  },
  {
    "task_id": "Ruby/46",
    "prompt": {
      "en": "# Counts the number of characters in a given title, excluding spaces and newline characters.\n# The function takes a single argument, title, which is a string representing the title of an essay.\n# It returns the count of characters in the title, excluding any spaces and newline characters.\n#\n# Examples:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "es": "# Cuenta el número de caracteres en un título dado, excluyendo espacios y caracteres de nueva línea.\n# La función toma un solo argumento, title, que es una cadena que representa el título de un ensayo.\n# Devuelve el conteo de caracteres en el título, excluyendo cualquier espacio y caracteres de nueva línea.\n#\n# Ejemplos:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "arb": "# يحسب عدد الأحرف في العنوان المعطى، باستثناء المسافات وأحرف السطر الجديد.\n# تأخذ الدالة وسيطًا واحدًا، وهو title، الذي يمثل سلسلة نصية لعنوان مقال.\n# تُرجع عدد الأحرف في العنوان، باستثناء أي مسافات وأحرف السطر الجديد.\n#\n# أمثلة:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "sw": "# Inahesabu idadi ya herufi katika kichwa kilichopewa, bila kujumuisha nafasi na herufi mpya.\n# Kazi inachukua hoja moja, title, ambayo ni kamba inayowakilisha kichwa cha insha.\n# Inarudisha hesabu ya herufi katika kichwa, bila kujumuisha nafasi zozote na herufi mpya.\n#\n# Mifano:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "tr": "# Verilen bir başlıktaki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç tutarak sayar.\n# Fonksiyon, bir makalenin başlığını temsil eden bir string olan title adlı tek bir argüman alır.\n# Başlıktaki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç tutarak döndürür.\n#\n# Örnekler:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "vi": "# Đếm số ký tự trong một tiêu đề cho trước, không bao gồm khoảng trắng và ký tự xuống dòng.\n# Hàm nhận một đối số, title, là một chuỗi đại diện cho tiêu đề của một bài luận.\n# Nó trả về số lượng ký tự trong tiêu đề, không bao gồm bất kỳ khoảng trắng và ký tự xuống dòng nào.\n#\n# Ví dụ:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)"
    },
    "prompt_bertscore": {
      "es": "0.9894880829748717",
      "arb": "0.9645983058185329",
      "sw": "0.9750655310079284",
      "tr": "0.9795680844852273",
      "vi": "0.9863312503290842"
    },
    "canonical_solution": "    title.count(\"^ \\n\")\n  end",
    "instruction": {
      "en": "Write a ruby function `def count_chars_in_title(title)` to solve the following problem:\nCounts the number of characters in a given title, excluding spaces and newline characters.\n The function takes a single argument, title, which is a string representing the title of an essay.\n It returns the count of characters in the title, excluding any spaces and newline characters.\n\n Examples:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "es": "Escribe una función en ruby `def count_chars_in_title(title)` para resolver el siguiente problema:\nCuenta el número de caracteres en un título dado, excluyendo espacios y caracteres de nueva línea.\n La función toma un solo argumento, title, que es una cadena que representa el título de un ensayo.\n Devuelve el conteo de caracteres en el título, excluyendo cualquier espacio y caracteres de nueva línea.\n\n Ejemplos:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "arb": "اكتب دالة روبي `def count_chars_in_title(title)` لحل المشكلة التالية:\nتحسب عدد الأحرف في عنوان معين، باستثناء المسافات وأحرف السطر الجديد.\nتأخذ الدالة وسيطًا واحدًا، title، وهو سلسلة تمثل عنوان المقال.\nتعيد عدد الأحرف في العنوان، باستثناء أي مسافات وأحرف السطر الجديد.\n\nأمثلة:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "sw": "Andika kazi ya ruby `def count_chars_in_title(title)` kutatua tatizo lifuatalo:\nInahesabu idadi ya herufi katika kichwa kilichopewa, bila kujumuisha nafasi na herufi za kurudi mstari mpya.\n Kazi inachukua hoja moja, title, ambayo ni kamba inayowakilisha kichwa cha insha.\n Inarudisha hesabu ya herufi katika kichwa, bila kujumuisha nafasi na herufi za kurudi mstari mpya.\n\n Mifano:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "tr": "Bir ruby fonksiyonu `def count_chars_in_title(title)` yazın:\nVerilen bir başlıktaki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç tutarak sayar.\n Fonksiyon, bir makalenin başlığını temsil eden bir string olan tek bir argüman, title, alır.\n Boşluklar ve yeni satır karakterleri hariç olmak üzere başlıktaki karakterlerin sayısını döndürür.\n\n Örnekler:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "vi": "Viết một hàm ruby `def count_chars_in_title(title)` để giải quyết vấn đề sau:\nĐếm số ký tự trong một tiêu đề đã cho, không bao gồm khoảng trắng và ký tự xuống dòng.\nHàm nhận một đối số duy nhất, title, là một chuỗi đại diện cho tiêu đề của một bài luận.\nNó trả về số lượng ký tự trong tiêu đề, không bao gồm bất kỳ khoảng trắng và ký tự xuống dòng nào.\n\nVí dụ:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10"
    },
    "instruction_bertscore": {
      "es": "0.9944123287511075",
      "arb": "0.9725796717892768",
      "sw": "0.9838549253687222",
      "tr": "0.9609965411192273",
      "vi": "0.9923698125429258"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_chars_in_title(\"234\") == 3\nraise 'Test failed' unless count_chars_in_title(\"Ca 45\") == 4\nraise 'Test failed' unless count_chars_in_title(\"Hello World\\n\") == 10\nraise 'Test failed' unless count_chars_in_title(\"Ruby Programming 101 \") == 18\nraise 'Test failed' unless count_chars_in_title(\"\\nNew Line\\n\") == 7",
    "entry_point": "count_chars_in_title",
    "signature": "def count_chars_in_title(title)",
    "docstring": {
      "en": "Counts the number of characters in a given title, excluding spaces and newline characters.\n The function takes a single argument, title, which is a string representing the title of an essay.\n It returns the count of characters in the title, excluding any spaces and newline characters.\n\n Examples:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "es": "Cuenta el número de caracteres en un título dado, excluyendo espacios y caracteres de nueva línea. \nLa función toma un único argumento, title, que es una cadena que representa el título de un ensayo. \nDevuelve el conteo de caracteres en el título, excluyendo cualquier espacio y caracteres de nueva línea.\n\nEjemplos:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "arb": "يحسب عدد الأحرف في عنوان معين، باستثناء المسافات وأحرف السطر الجديد.\nتأخذ الدالة وسيطًا واحدًا، title، وهو سلسلة تمثل عنوان المقال.\nتعيد الدالة عدد الأحرف في العنوان، باستثناء أي مسافات وأحرف السطر الجديد.\n\nأمثلة:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "sw": "Hesabu idadi ya herufi katika kichwa kilichopewa, ukiondoa nafasi na herufi za kurudi mstari mpya.\n Kazi hii inachukua hoja moja, title, ambayo ni kamba inayowakilisha kichwa cha insha.\n Inarudisha hesabu ya herufi katika kichwa, ukiondoa nafasi zozote na herufi za kurudi mstari mpya.\n\n Mifano:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "tr": "Karakter sayısını, boşluklar ve yeni satır karakterleri hariç olmak üzere, verilen bir başlıkta sayar.\n Fonksiyon, bir makalenin başlığını temsil eden bir string olan tek bir argüman, title, alır.\n Boşluklar ve yeni satır karakterleri hariç olmak üzere, başlıktaki karakterlerin sayısını döndürür.\n\n Örnekler:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "vi": "Đếm số ký tự trong một tiêu đề cho trước, không bao gồm các ký tự khoảng trắng và ký tự xuống dòng. \nHàm nhận một đối số duy nhất, title, là một chuỗi đại diện cho tiêu đề của một bài luận. \nNó trả về số lượng ký tự trong tiêu đề, không bao gồm bất kỳ ký tự khoảng trắng và ký tự xuống dòng nào.\n\nVí dụ:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10"
    },
    "docstring_bertscore": {
      "es": "0.9826893622928095",
      "arb": "0.9641956820361752",
      "sw": "0.9738518993798052",
      "tr": "0.9860823664616475",
      "vi": "0.9810121273553509"
    }
  },
  {
    "task_id": "Ruby/47",
    "prompt": {
      "en": "# Counts the number of students who have enrolled in both courses A and B.\n# This function takes four arguments: n and m are the number of students enrolled in courses A and B, respectively.\n# a_n is an array of student IDs enrolled in course A, and b_m is an array of student IDs enrolled in course B.\n# The function returns the count of students who have enrolled in both courses.\n#\n# Example:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "es": "# Cuenta el número de estudiantes que se han inscrito en ambos cursos A y B.\n# Esta función toma cuatro argumentos: n y m son el número de estudiantes inscritos en los cursos A y B, respectivamente.\n# a_n es un arreglo de IDs de estudiantes inscritos en el curso A, y b_m es un arreglo de IDs de estudiantes inscritos en el curso B.\n# La función devuelve el conteo de estudiantes que se han inscrito en ambos cursos.\n#\n# Ejemplo:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "arb": "# يحسب عدد الطلاب الذين سجلوا في كلا الدورتين A و B.\n# تأخذ هذه الدالة أربعة معطيات: n و m هما عدد الطلاب المسجلين في الدورتين A و B على التوالي.\n# a_n هو مصفوفة تحتوي على معرفات الطلاب المسجلين في الدورة A، و b_m هو مصفوفة تحتوي على معرفات الطلاب المسجلين في الدورة B.\n# تعيد الدالة عدد الطلاب الذين سجلوا في كلا الدورتين.\n#\n# مثال:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "sw": "# Inahesabu idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili A na B.\n# Kazi hii inachukua hoja nne: n na m ni idadi ya wanafunzi waliojiandikisha katika kozi A na B, mtawalia.\n# a_n ni safu ya vitambulisho vya wanafunzi waliojiandikisha katika kozi A, na b_m ni safu ya vitambulisho vya wanafunzi waliojiandikisha katika kozi B.\n# Kazi inarudisha idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili.\n#\n# Mfano:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "tr": "# Hem A hem de B kurslarına kayıt olmuş öğrencilerin sayısını sayar.\n# Bu fonksiyon dört argüman alır: n ve m sırasıyla A ve B kurslarına kayıtlı öğrenci sayılarıdır.\n# a_n, A kursuna kayıtlı öğrenci kimliklerinin bir dizisidir ve b_m, B kursuna kayıtlı öğrenci kimliklerinin bir dizisidir.\n# Fonksiyon, her iki kursa da kayıt olmuş öğrencilerin sayısını döndürür.\n#\n# Örnek:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "vi": "# Đếm số lượng sinh viên đã đăng ký cả hai khóa học A và B.\n# Hàm này nhận bốn đối số: n và m là số lượng sinh viên đăng ký các khóa học A và B, tương ứng.\n# a_n là một mảng chứa mã sinh viên đã đăng ký khóa học A, và b_m là một mảng chứa mã sinh viên đã đăng ký khóa học B.\n# Hàm trả về số lượng sinh viên đã đăng ký cả hai khóa học.\n#\n# Ví dụ:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9766496082966817",
      "sw": "0.9929678886202219",
      "tr": "0.973326720652349",
      "vi": "0.9650339022441424"
    },
    "canonical_solution": "    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end",
    "instruction": {
      "en": "Write a ruby function `def count_common_students(n, m, a_n, b_m)` to solve the following problem:\nCounts the number of students who have enrolled in both courses A and B.\n This function takes four arguments: n and m are the number of students enrolled in courses A and B, respectively.\n a_n is an array of student IDs enrolled in course A, and b_m is an array of student IDs enrolled in course B.\n The function returns the count of students who have enrolled in both courses.\n\n Example:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "es": "Escribe una función en Ruby `def count_common_students(n, m, a_n, b_m)` para resolver el siguiente problema:\nCuenta el número de estudiantes que se han inscrito en ambos cursos A y B.\n Esta función toma cuatro argumentos: n y m son el número de estudiantes inscritos en los cursos A y B, respectivamente.\n a_n es un array de IDs de estudiantes inscritos en el curso A, y b_m es un array de IDs de estudiantes inscritos en el curso B.\n La función devuelve la cantidad de estudiantes que se han inscrito en ambos cursos.\n\n Ejemplo:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "arb": "اكتب دالة روبي `def count_common_students(n, m, a_n, b_m)` لحل المشكلة التالية:\nتحسب عدد الطلاب الذين سجلوا في كلا الدورتين A و B.\nتأخذ هذه الدالة أربعة معطيات: n و m هما عدد الطلاب المسجلين في الدورتين A و B على التوالي.\na_n هو مصفوفة تحتوي على معرفات الطلاب المسجلين في الدورة A، و b_m هو مصفوفة تحتوي على معرفات الطلاب المسجلين في الدورة B.\nتعيد الدالة عدد الطلاب الذين سجلوا في كلا الدورتين.\n\nمثال:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "sw": "Andika kazi ya ruby `def count_common_students(n, m, a_n, b_m)` kutatua tatizo lifuatalo:\nInahesabu idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili A na B.\n Kazi hii inachukua hoja nne: n na m ni idadi ya wanafunzi waliojiandikisha katika kozi A na B, mtawalia.\n a_n ni safu ya vitambulisho vya wanafunzi waliojiandikisha katika kozi A, na b_m ni safu ya vitambulisho vya wanafunzi waliojiandikisha katika kozi B.\n Kazi inarudisha hesabu ya wanafunzi ambao wamejiandikisha katika kozi zote mbili.\n\n Mfano:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "tr": "Bir ruby fonksiyonu `def count_common_students(n, m, a_n, b_m)` yazın:\nHer iki ders olan A ve B'ye kayıtlı öğrencilerin sayısını sayar.\n Bu fonksiyon dört argüman alır: n ve m sırasıyla A ve B derslerine kayıtlı öğrenci sayılarıdır.\n a_n, ders A'ya kayıtlı öğrenci kimliklerinin bir dizisidir ve b_m, ders B'ye kayıtlı öğrenci kimliklerinin bir dizisidir.\n Fonksiyon, her iki derse de kayıtlı olan öğrencilerin sayısını döndürür.\n\n Örnek:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "vi": "Viết một hàm ruby `def count_common_students(n, m, a_n, b_m)` để giải quyết vấn đề sau:\nĐếm số lượng sinh viên đã đăng ký cả hai khóa học A và B.\nHàm này nhận bốn tham số: n và m là số lượng sinh viên đăng ký các khóa học A và B, tương ứng.\na_n là một mảng chứa mã số sinh viên đăng ký khóa học A, và b_m là một mảng chứa mã số sinh viên đăng ký khóa học B.\nHàm trả về số lượng sinh viên đã đăng ký cả hai khóa học.\n\nVí dụ:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1"
    },
    "instruction_bertscore": {
      "es": "0.9930163544331944",
      "arb": "0.9742982218459907",
      "sw": "0.9944903904908543",
      "tr": "0.9427159912614435",
      "vi": "0.9640888188911785"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6]) == 4\nraise 'Test failed' unless count_common_students(3, 2, [1, 2, 3], [2, 4]) == 1\nraise 'Test failed' unless count_common_students(4, 4, [7, 8, 9, 10], [10, 11, 12, 13]) == 1\nraise 'Test failed' unless count_common_students(2, 3, [14, 15], [15, 16, 17]) == 1\nraise 'Test failed' unless count_common_students(6, 5, [18, 19, 20, 21, 22, 23], [20, 21, 24, 25, 26]) == 2",
    "entry_point": "count_common_students",
    "signature": "def count_common_students(n, m, a_n, b_m)",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both courses A and B.\n This function takes four arguments: n and m are the number of students enrolled in courses A and B, respectively.\n a_n is an array of student IDs enrolled in course A, and b_m is an array of student IDs enrolled in course B.\n The function returns the count of students who have enrolled in both courses.\n\n Example:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "es": "Cuenta el número de estudiantes que se han inscrito en ambos cursos A y B.\n Esta función toma cuatro argumentos: n y m son el número de estudiantes inscritos en los cursos A y B, respectivamente.\n a_n es un array de IDs de estudiantes inscritos en el curso A, y b_m es un array de IDs de estudiantes inscritos en el curso B.\n La función devuelve el conteo de estudiantes que se han inscrito en ambos cursos.\n\n Ejemplo:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "arb": "يحسب عدد الطلاب الذين سجلوا في كلا الدورتين A و B. \nتأخذ هذه الدالة أربعة معطيات: n و m هما عدد الطلاب المسجلين في الدورتين A و B على التوالي.\na_n هو مصفوفة تحتوي على معرفات الطلاب المسجلين في الدورة A، و b_m هو مصفوفة تحتوي على معرفات الطلاب المسجلين في الدورة B.\nتعيد الدالة عدد الطلاب الذين سجلوا في كلا الدورتين.\n\nمثال:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "sw": "Hesabu idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili A na B. \nKazi hii inachukua hoja nne: n na m ni idadi ya wanafunzi waliojiandikisha katika kozi A na B, mtawalia. \na_n ni safu ya vitambulisho vya wanafunzi waliojiandikisha katika kozi A, na b_m ni safu ya vitambulisho vya wanafunzi waliojiandikisha katika kozi B. \nKazi hii inarudisha idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili.\n\nMfano:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "tr": "Her iki ders A ve B'ye de kayıtlı olan öğrencilerin sayısını sayar.\n Bu fonksiyon dört argüman alır: n ve m sırasıyla A ve B derslerine kayıtlı öğrenci sayılarıdır.\n a_n, A dersine kayıtlı öğrenci kimliklerinin bir dizisidir ve b_m, B dersine kayıtlı öğrenci kimliklerinin bir dizisidir.\n Fonksiyon, her iki derse de kayıtlı olan öğrencilerin sayısını döndürür.\n\n Örnek:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "vi": "Đếm số lượng sinh viên đã đăng ký cả hai khóa học A và B. \nHàm này nhận bốn đối số: n và m là số lượng sinh viên đã đăng ký trong các khóa học A và B, tương ứng. \na_n là một mảng chứa mã số sinh viên đã đăng ký khóa học A, và b_m là một mảng chứa mã số sinh viên đã đăng ký khóa học B. \nHàm trả về số lượng sinh viên đã đăng ký cả hai khóa học.\n\nVí dụ:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1"
    },
    "docstring_bertscore": {
      "es": "0.9946506852083494",
      "arb": "0.9697609080520107",
      "sw": "0.9834856714903784",
      "tr": "0.9760896692525443",
      "vi": "0.9581450033690905"
    }
  },
  {
    "task_id": "Ruby/48",
    "prompt": {
      "en": "# Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered\n# and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money,\n# and for each failed delivery, it loses 10 units. If the number of successful deliveries is\n# greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n#\n# Arguments:\n# - delivered: Integer representing the number of successfully delivered packages (0 <= delivered <= 100).\n# - failed: Integer representing the number of failed deliveries (0 <= failed <= 100).\n#\n# Returns:\n# - Integer: The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n#\n# Examples:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "es": "# Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas\n# y entregas fallidas. Por cada entrega exitosa, Deliv-e-droid gana 50 unidades de dinero,\n# y por cada entrega fallida, pierde 10 unidades. Si el número de entregas exitosas es\n# mayor que el número de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n#\n# Argumentos:\n# - delivered: Entero que representa el número de paquetes entregados exitosamente (0 <= delivered <= 100).\n# - failed: Entero que representa el número de entregas fallidas (0 <= failed <= 100).\n#\n# Retorna:\n# - Entero: Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n#\n# Ejemplos:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "arb": "# يحسب الأرباح الإجمالية لـ Deliv-e-droid بناءً على عدد التسليمات الناجحة\n# والتسليمات الفاشلة. لكل تسليم ناجح، يكسب Deliv-e-droid 50 وحدة من المال،\n# ولكل تسليم فاشل، يخسر 10 وحدات. إذا كان عدد التسليمات الناجحة\n# أكبر من عدد التسليمات الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n#\n# الوسائط:\n# - delivered: عدد صحيح يمثل عدد الطرود التي تم تسليمها بنجاح (0 <= delivered <= 100).\n# - failed: عدد صحيح يمثل عدد التسليمات الفاشلة (0 <= failed <= 100).\n#\n# يعيد:\n# - عدد صحيح: الأرباح الإجمالية لـ Deliv-e-droid، والتي يمكن أن تكون سلبية إذا فاقت الخسائر المكاسب.\n#\n# أمثلة:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "sw": "# Inahesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya mafanikio ya kufikisha\n# na kufikisha kushindwa. Kwa kila kufikisha kwa mafanikio, Deliv-e-droid hupata vitengo 50 vya pesa,\n# na kwa kila kufikisha kushindwa, inapoteza vitengo 10. Ikiwa idadi ya kufikisha kwa mafanikio ni\n# kubwa kuliko idadi ya kushindwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n#\n# Hoja:\n# - delivered: Nambari inayowakilisha idadi ya vifurushi vilivyofikishwa kwa mafanikio (0 <= delivered <= 100).\n# - failed: Nambari inayowakilisha idadi ya kufikisha kushindwa (0 <= failed <= 100).\n#\n# Inarudisha:\n# - Nambari: Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara inazidi faida.\n#\n# Mifano:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "tr": "# Deliv-e-droid'un başarılı teslimatlar ve başarısız teslimatlar sayısına göre toplam kazancını hesaplar.\n# Her başarılı teslimat için Deliv-e-droid 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder.\n# Eğer başarılı teslimatların sayısı başarısız olanlardan fazlaysa, Deliv-e-droid 500 birim bonus alır.\n#\n# Argümanlar:\n# - delivered: Başarıyla teslim edilen paketlerin sayısını temsil eden tamsayı (0 <= delivered <= 100).\n# - failed: Başarısız teslimatların sayısını temsil eden tamsayı (0 <= failed <= 100).\n#\n# Döndürür:\n# - Tamsayı: Deliv-e-droid'un toplam kazancı, kayıplar kazançlardan fazla ise negatif olabilir.\n#\n# Örnekler:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "vi": "# Tính tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công\n# và giao hàng thất bại. Với mỗi lần giao hàng thành công, Deliv-e-droid kiếm được 50 đơn vị tiền,\n# và với mỗi lần giao hàng thất bại, nó mất 10 đơn vị. Nếu số lượng giao hàng thành công\n# lớn hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n#\n# Tham số:\n# - delivered: Số nguyên đại diện cho số lượng gói hàng được giao thành công (0 <= delivered <= 100).\n# - failed: Số nguyên đại diện cho số lượng giao hàng thất bại (0 <= failed <= 100).\n#\n# Trả về:\n# - Số nguyên: Tổng thu nhập của Deliv-e-droid, có thể là số âm nếu tổn thất lớn hơn lợi nhuận.\n#\n# Ví dụ:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)"
    },
    "prompt_bertscore": {
      "es": "0.9892449593884849",
      "arb": "0.9755378740540294",
      "sw": "0.9702382168576376",
      "tr": "0.9600014029102425",
      "vi": "0.9783763021990179"
    },
    "canonical_solution": "    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end",
    "instruction": {
      "en": "Write a ruby function `def calculate_droid_earnings(delivered, failed)` to solve the following problem:\nCalculates the total earnings of Deliv-e-droid based on the number of successfully delivered\n and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money,\n and for each failed delivery, it loses 10 units. If the number of successful deliveries is\n greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n Arguments:\n - delivered: Integer representing the number of successfully delivered packages (0 <= delivered <= 100).\n - failed: Integer representing the number of failed deliveries (0 <= failed <= 100).\n\n Returns:\n - Integer: The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n Examples:\n >>> calculate_droid_earnings(5, 2)\n 730\n >>> calculate_droid_earnings(0, 10)\n -100",
      "es": "Escribe una función de Ruby `def calculate_droid_earnings(delivered, failed)` para resolver el siguiente problema:\nCalcula las ganancias totales de Deliv-e-droid basándose en el número de entregas exitosas y entregas fallidas. Por cada entrega exitosa, Deliv-e-droid gana 50 unidades de dinero, y por cada entrega fallida, pierde 10 unidades. Si el número de entregas exitosas es mayor que el número de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n\nArgumentos:\n- delivered: Entero que representa el número de paquetes entregados exitosamente (0 <= delivered <= 100).\n- failed: Entero que representa el número de entregas fallidas (0 <= failed <= 100).\n\nDevuelve:\n- Entero: Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n\nEjemplos:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "arb": "اكتب دالة روبي `def calculate_droid_earnings(delivered, failed)` لحل المشكلة التالية:\nتحسب الأرباح الإجمالية لـ Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة. لكل عملية تسليم ناجحة، يكسب Deliv-e-droid 50 وحدة من المال، ولكل عملية تسليم فاشلة، يخسر 10 وحدات. إذا كان عدد عمليات التسليم الناجحة أكبر من عدد العمليات الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n\nالمعطيات:\n- delivered: عدد صحيح يمثل عدد الطرود التي تم تسليمها بنجاح (0 <= delivered <= 100).\n- failed: عدد صحيح يمثل عدد عمليات التسليم الفاشلة (0 <= failed <= 100).\n\nالمخرجات:\n- عدد صحيح: الأرباح الإجمالية لـ Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق المكاسب.\n\nأمثلة:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "sw": "Andika kazi ya ruby `def calculate_droid_earnings(delivered, failed)` kutatua tatizo lifuatalo:\nInakokotoa mapato ya jumla ya Deliv-e-droid kulingana na idadi ya mafanikio ya kufikisha\n na kushindwa kufikisha. Kwa kila kufikisha kwa mafanikio, Deliv-e-droid inapata vitengo 50 vya pesa,\n na kwa kila kushindwa kufikisha, inapoteza vitengo 10. Ikiwa idadi ya mafanikio ya kufikisha ni\n kubwa kuliko idadi ya kushindwa, Deliv-e-droid inapokea bonasi ya vitengo 500.\n\n Hoja:\n - delivered: Integer inayowakilisha idadi ya vifurushi vilivyofikishwa kwa mafanikio (0 <= delivered <= 100).\n - failed: Integer inayowakilisha idadi ya kushindwa kufikisha (0 <= failed <= 100).\n\n Inarejesha:\n - Integer: Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara zinazidi mapato.\n\n Mifano:\n >>> calculate_droid_earnings(5, 2)\n 730\n >>> calculate_droid_earnings(0, 10)\n -100",
      "tr": "Bir ruby fonksiyonu `def calculate_droid_earnings(delivered, failed)` yazın ve aşağıdaki problemi çözün:\nBaşarıyla teslim edilen ve başarısız teslimatlar sayısına göre Deliv-e-droid'in toplam kazancını hesaplar. Her başarılı teslimat için Deliv-e-droid 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder. Başarılı teslimatların sayısı başarısız olanlardan fazlaysa, Deliv-e-droid 500 birim bonus alır.\n\nArgümanlar:\n- delivered: Başarıyla teslim edilen paketlerin sayısını temsil eden tamsayı (0 <= delivered <= 100).\n- failed: Başarısız teslimatların sayısını temsil eden tamsayı (0 <= failed <= 100).\n\nDöndürür:\n- Tamsayı: Deliv-e-droid'in toplam kazancı, kayıplar kazançlardan fazla ise negatif olabilir.\n\nÖrnekler:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "vi": "Viết một hàm ruby `def calculate_droid_earnings(delivered, failed)` để giải quyết vấn đề sau:\nTính tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại. \nĐối với mỗi lần giao hàng thành công, Deliv-e-droid kiếm được 50 đơn vị tiền, \nvà đối với mỗi lần giao hàng thất bại, nó mất 10 đơn vị. Nếu số lượng giao hàng thành công \nnhiều hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n\nTham số:\n- delivered: Số nguyên biểu thị số lượng gói hàng được giao thành công (0 <= delivered <= 100).\n- failed: Số nguyên biểu thị số lượng giao hàng thất bại (0 <= failed <= 100).\n\nTrả về:\n- Số nguyên: Tổng thu nhập của Deliv-e-droid, có thể là số âm nếu tổn thất lớn hơn lợi nhuận.\n\nVí dụ:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100"
    },
    "instruction_bertscore": {
      "es": "0.9918432434028023",
      "arb": "0.9690668935006748",
      "sw": "0.9838473774142429",
      "tr": "0.9680955909374142",
      "vi": "0.9773680543848848"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless calculate_droid_earnings(5, 2) == 730\nraise 'Test failed' unless calculate_droid_earnings(0, 10) == -100\nraise 'Test failed' unless calculate_droid_earnings(10, 0) == 1000\nraise 'Test failed' unless calculate_droid_earnings(3, 5) == 100\nraise 'Test failed' unless calculate_droid_earnings(20, 20) == 800",
    "entry_point": "calculate_droid_earnings",
    "signature": "def calculate_droid_earnings(delivered, failed)",
    "docstring": {
      "en": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered\n and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money,\n and for each failed delivery, it loses 10 units. If the number of successful deliveries is\n greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n Arguments:\n - delivered: Integer representing the number of successfully delivered packages (0 <= delivered <= 100).\n - failed: Integer representing the number of failed deliveries (0 <= failed <= 100).\n\n Returns:\n - Integer: The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n Examples:\n >>> calculate_droid_earnings(5, 2)\n 730\n >>> calculate_droid_earnings(0, 10)\n -100",
      "es": "Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas. Por cada entrega exitosa, Deliv-e-droid gana 50 unidades de dinero, y por cada entrega fallida, pierde 10 unidades. Si el número de entregas exitosas es mayor que el de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n\nArgumentos:\n- delivered: Entero que representa el número de paquetes entregados exitosamente (0 <= delivered <= 100).\n- failed: Entero que representa el número de entregas fallidas (0 <= failed <= 100).\n\nDevuelve:\n- Entero: Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n\nEjemplos:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "arb": "يحسب إجمالي أرباح Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة. لكل عملية تسليم ناجحة، يكسب Deliv-e-droid 50 وحدة من المال، ولكل عملية تسليم فاشلة، يخسر 10 وحدات. إذا كان عدد عمليات التسليم الناجحة أكبر من عدد العمليات الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n\nالمعطيات:\n- delivered: عدد صحيح يمثل عدد الطرود التي تم تسليمها بنجاح (0 <= delivered <= 100).\n- failed: عدد صحيح يمثل عدد عمليات التسليم الفاشلة (0 <= failed <= 100).\n\nالقيم المعادة:\n- عدد صحيح: إجمالي أرباح Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق الأرباح.\n\nأمثلة:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "sw": "Hesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya uwasilishaji uliofanikiwa na usiofanikiwa. Kwa kila uwasilishaji uliofanikiwa, Deliv-e-droid hupata vitengo 50 vya pesa, na kwa kila uwasilishaji usiofanikiwa, hupoteza vitengo 10. Ikiwa idadi ya uwasilishaji uliofanikiwa ni kubwa kuliko ile ya usiofanikiwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n\nHoja:\n- delivered: Nambari inayoashiria idadi ya vifurushi vilivyowasilishwa kwa mafanikio (0 <= delivered <= 100).\n- failed: Nambari inayoashiria idadi ya uwasilishaji usiofanikiwa (0 <= failed <= 100).\n\nRudisha:\n- Nambari: Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara inazidi faida.\n\nMifano:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "tr": "Deliv-e-droid'un toplam kazancını, başarılı ve başarısız teslimat sayısına göre hesaplar. Her başarılı teslimat için Deliv-e-droid 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder. Başarılı teslimat sayısı, başarısız olanlardan fazla ise, Deliv-e-droid 500 birim bonus alır.\n\nArgümanlar:\n- delivered: Başarıyla teslim edilen paket sayısını temsil eden tamsayı (0 <= delivered <= 100).\n- failed: Başarısız teslimat sayısını temsil eden tamsayı (0 <= failed <= 100).\n\nDöndürür:\n- Tamsayı: Deliv-e-droid'un toplam kazancı, kayıplar kazançlardan fazla ise negatif olabilir.\n\nÖrnekler:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "vi": "Tính tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại. Đối với mỗi lần giao hàng thành công, Deliv-e-droid kiếm được 50 đơn vị tiền, và đối với mỗi lần giao hàng thất bại, nó mất 10 đơn vị. Nếu số lượng giao hàng thành công lớn hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n\nCác đối số:\n- delivered: Số nguyên đại diện cho số lượng gói hàng được giao thành công (0 <= delivered <= 100).\n- failed: Số nguyên đại diện cho số lượng giao hàng thất bại (0 <= failed <= 100).\n\nTrả về:\n- Số nguyên: Tổng thu nhập của Deliv-e-droid, có thể âm nếu tổn thất lớn hơn lợi nhuận.\n\nVí dụ:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100"
    },
    "docstring_bertscore": {
      "es": "0.983705952582946",
      "arb": "0.9746801880687207",
      "sw": "0.9601871223165102",
      "tr": "0.9613898292736763",
      "vi": "0.9793827623397217"
    }
  },
  {
    "task_id": "Ruby/49",
    "prompt": {
      "en": "# Finds the missing (broken) and duplicate ID in a sequence of ticket IDs.\n# The function takes a nested array (array of arrays) where each sub-array\n# contains ticket IDs for a particular batch. It returns an array with two elements:\n# the first is the missing ID, and the second is the duplicate ID.\n#\n# Example:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "es": "# Encuentra el ID faltante (roto) y el ID duplicado en una secuencia de IDs de boletos.\n# La función toma un arreglo anidado (arreglo de arreglos) donde cada sub-arreglo\n# contiene IDs de boletos para un lote particular. Devuelve un arreglo con dos elementos:\n# el primero es el ID faltante, y el segundo es el ID duplicado.\n#\n# Ejemplo:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "arb": "# يعثر على المعرف المفقود (المعطل) والمكرر في تسلسل معرفات التذاكر.\n# تأخذ الدالة مصفوفة متداخلة (مصفوفة من المصفوفات) حيث يحتوي كل مصفوف فرعي\n# على معرفات التذاكر لدفعة معينة. تُرجع مصفوفة تحتوي على عنصرين:\n# الأول هو المعرف المفقود، والثاني هو المعرف المكرر.\n#\n# مثال:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "sw": "# Inapata kitambulisho kilichokosekana (kilichovunjika) na kitambulisho kilichorudiwa katika mlolongo wa vitambulisho vya tiketi.\n# Kazi inachukua safu iliyopachikwa (safu ya safu) ambapo kila safu ndogo\n# ina vitambulisho vya tiketi kwa kundi fulani. Inarejesha safu yenye vipengele viwili:\n# cha kwanza ni kitambulisho kilichokosekana, na cha pili ni kitambulisho kilichorudiwa.\n#\n# Mfano:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "tr": "# Bir bilet ID dizisindeki eksik (bozuk) ve yinelenen ID'yi bulur.\n# Fonksiyon, her alt dizinin belirli bir parti için bilet ID'leri içerdiği\n# iç içe bir dizi (dizilerin dizisi) alır. İki elemanlı bir dizi döndürür:\n# birincisi eksik ID, ikincisi ise yinelenen ID'dir.\n#\n# Örnek:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "vi": "# Tìm ID bị thiếu (bị hỏng) và ID trùng lặp trong một dãy ID vé.\n# Hàm nhận một mảng lồng nhau (mảng của các mảng) mà mỗi mảng con\n# chứa các ID vé cho một lô cụ thể. Nó trả về một mảng với hai phần tử:\n# phần tử đầu tiên là ID bị thiếu, và phần tử thứ hai là ID trùng lặp.\n#\n# Ví dụ:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)"
    },
    "prompt_bertscore": {
      "es": "0.9917300240856124",
      "arb": "0.9917363802578055",
      "sw": "0.9885884859791646",
      "tr": "0.9761303884806565",
      "vi": "0.9693378253404064"
    },
    "canonical_solution": "    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end",
    "instruction": {
      "en": "Write a ruby function `def find_missing_and_duplicate_ids(ids)` to solve the following problem:\nFinds the missing (broken) and duplicate ID in a sequence of ticket IDs.\n The function takes a nested array (array of arrays) where each sub-array\n contains ticket IDs for a particular batch. It returns an array with two elements:\n the first is the missing ID, and the second is the duplicate ID.\n\n Example:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "es": "Escribe una función en ruby `def find_missing_and_duplicate_ids(ids)` para resolver el siguiente problema:\nEncuentra el ID faltante (roto) y el ID duplicado en una secuencia de IDs de boletos.\nLa función toma un array anidado (array de arrays) donde cada sub-array\ncontiene IDs de boletos para un lote particular. Devuelve un array con dos elementos:\nel primero es el ID faltante, y el segundo es el ID duplicado.\n\nEjemplo:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "arb": "اكتب دالة روبي `def find_missing_and_duplicate_ids(ids)` لحل المشكلة التالية:\nتجد المعرف المفقود (المعطل) والمكرر في تسلسل معرفات التذاكر.\n تأخذ الدالة مصفوفة متداخلة (مصفوفة من المصفوفات) حيث يحتوي كل صفيف فرعي\n على معرفات التذاكر لدفعة معينة. تُرجع مصفوفة تحتوي على عنصرين:\n الأول هو المعرف المفقود، والثاني هو المعرف المكرر.\n\n مثال:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "sw": "Andika kazi ya ruby `def find_missing_and_duplicate_ids(ids)` kutatua tatizo lifuatalo:\nInapata kitambulisho kilichopotea (kilichovunjika) na kitambulisho kilichojirudia katika mlolongo wa vitambulisho vya tiketi.\n Kazi hii inachukua safu iliyopachikwa (safu ya safu) ambapo kila safu ndogo\n ina vitambulisho vya tiketi kwa kundi fulani. Inarejesha safu yenye vipengele viwili:\n cha kwanza ni kitambulisho kilichopotea, na cha pili ni kitambulisho kilichojirudia.\n\n Mfano:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "tr": "Bir ruby fonksiyonu `def find_missing_and_duplicate_ids(ids)` yazın ve aşağıdaki problemi çözün:\nBilet ID'lerinin bir dizisinde eksik (bozuk) ve yinelenen ID'yi bulun.\nFonksiyon, her alt dizinin belirli bir parti için bilet ID'lerini içerdiği iç içe bir dizi (dizilerin dizisi) alır. İki elemanlı bir dizi döndürür:\nbirincisi eksik ID, ikincisi ise yinelenen ID'dir.\n\nÖrnek:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "vi": "Viết một hàm ruby `def find_missing_and_duplicate_ids(ids)` để giải quyết vấn đề sau:\nTìm ID bị thiếu (bị hỏng) và ID trùng lặp trong một dãy các ID vé.\nHàm nhận một mảng lồng nhau (mảng của các mảng) trong đó mỗi mảng con chứa các ID vé cho một lô cụ thể. Nó trả về một mảng với hai phần tử: phần tử đầu tiên là ID bị thiếu, và phần tử thứ hai là ID trùng lặp.\n\nVí dụ:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]"
    },
    "instruction_bertscore": {
      "es": "0.9874092174069605",
      "arb": "0.9873466488369346",
      "sw": "0.9834264796368299",
      "tr": "0.9793775979498148",
      "vi": "0.977801664506684"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]]) == [7, 9]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5, 7]]) == [6, 5]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[20, 21, 23], [22, 24, 24, 26]]) == [25, 24]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[100, 102, 106], [101, 103, 103, 105]]) == [104, 103]",
    "entry_point": "find_missing_and_duplicate_ids",
    "signature": "def find_missing_and_duplicate_ids(ids)",
    "docstring": {
      "en": "Finds the missing (broken) and duplicate ID in a sequence of ticket IDs.\n The function takes a nested array (array of arrays) where each sub-array\n contains ticket IDs for a particular batch. It returns an array with two elements:\n the first is the missing ID, and the second is the duplicate ID.\n\n Example:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "es": "Encuentra el ID faltante (roto) y el ID duplicado en una secuencia de IDs de boletos. \nLa función toma un arreglo anidado (arreglo de arreglos) donde cada sub-arreglo \ncontiene IDs de boletos para un lote particular. Devuelve un arreglo con dos elementos: \nel primero es el ID faltante, y el segundo es el ID duplicado.\n\nEjemplo:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "arb": "يعثر على المعرف المفقود (المعطل) والمكرر في تسلسل معرفات التذاكر. تأخذ الدالة مصفوفة متداخلة (مصفوفة من المصفوفات) حيث تحتوي كل مصفوفة فرعية على معرفات التذاكر لدفعة معينة. تُرجع مصفوفة تحتوي على عنصرين: الأول هو المعرف المفقود، والثاني هو المعرف المكرر.\n\nمثال:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "sw": "Inapata kitambulisho kilichopotea (kilichovunjika) na kitambulisho kilichorudiwa katika mlolongo wa vitambulisho vya tiketi. \nKazi hii inachukua safu iliyopachikwa (safu ya safu) ambapo kila safu ndogo \nina vitambulisho vya tiketi kwa kundi fulani. Inarudisha safu yenye vipengele viwili: \ncha kwanza ni kitambulisho kilichopotea, na cha pili ni kitambulisho kilichorudiwa.\n\nMfano:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "tr": "Eksik (bozuk) ve yinelenen kimliği bir bilet kimlikleri dizisinde bulur. \nFonksiyon, her alt dizinin belirli bir parti için bilet kimliklerini içerdiği, iç içe geçmiş bir dizi (diziler dizisi) alır. İki elemandan oluşan bir dizi döndürür: ilki eksik kimlik, ikincisi ise yinelenen kimliktir.\n\nÖrnek:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "vi": "Tìm ID bị thiếu (bị hỏng) và ID trùng lặp trong một dãy các ID vé. Hàm này nhận một mảng lồng nhau (mảng của các mảng) mà mỗi mảng con chứa các ID vé cho một lô cụ thể. Nó trả về một mảng với hai phần tử: phần tử đầu tiên là ID bị thiếu, và phần tử thứ hai là ID trùng lặp.\n\nVí dụ:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]"
    },
    "docstring_bertscore": {
      "es": "0.9889432398396929",
      "arb": "0.988311595228002",
      "sw": "0.9867130179214332",
      "tr": "0.9920893464449045",
      "vi": "0.9611055891984155"
    }
  },
  {
    "task_id": "Ruby/50",
    "prompt": {
      "en": "# Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n# The function takes a single argument, s, which is a string of length 8,\n# and returns an array with three integers representing the count of digits,\n# lowercase letters, and uppercase letters in the string, respectively.\n#\n# Examples:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "es": "# Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena dada.\n# La función toma un solo argumento, s, que es una cadena de longitud 8,\n# y devuelve un arreglo con tres enteros que representan el conteo de dígitos,\n# letras minúsculas y letras mayúsculas en la cadena, respectivamente.\n#\n# Ejemplos:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "arb": "# يحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة.\n# تأخذ الدالة وسيطًا واحدًا، s، وهو سلسلة بطول 8،\n# وتعيد مصفوفة تحتوي على ثلاثة أعداد صحيحة تمثل عدد الأرقام،\n# الأحرف الصغيرة، والأحرف الكبيرة في السلسلة، على التوالي.\n#\n# أمثلة:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "sw": "# Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba iliyotolewa.\n# Kazi inachukua hoja moja, s, ambayo ni kamba ya urefu wa 8,\n# na inarudisha safu yenye nambari tatu zinazowakilisha hesabu ya tarakimu,\n# herufi ndogo, na herufi kubwa katika kamba, mtawalia.\n#\n# Mifano:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "tr": "# Verilen bir stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n# Fonksiyon, uzunluğu 8 olan bir string olan s adlı tek bir argüman alır\n# ve sırasıyla stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını temsil eden üç tamsayı içeren bir dizi döndürür.\n#\n# Örnekler:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "vi": "# Đếm số chữ số, chữ cái thường và chữ cái hoa trong một chuỗi cho trước.\n# Hàm nhận một đối số, s, là một chuỗi có độ dài 8,\n# và trả về một mảng với ba số nguyên đại diện cho số lượng chữ số,\n# chữ cái thường và chữ cái hoa trong chuỗi, tương ứng.\n#\n# Ví dụ:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9876503546895369",
      "sw": "0.9844426726662044",
      "tr": "0.9859872225091317",
      "vi": "0.987144443109041"
    },
    "canonical_solution": "    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end",
    "instruction": {
      "en": "Write a ruby function `def count_chars_types(s)` to solve the following problem:\nCounts the number of digits, lowercase letters, and uppercase letters in a given string.\n The function takes a single argument, s, which is a string of length 8,\n and returns an array with three integers representing the count of digits,\n lowercase letters, and uppercase letters in the string, respectively.\n\n Examples:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "es": "Escribe una función en ruby `def count_chars_types(s)` para resolver el siguiente problema:\nCuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena dada.\nLa función toma un solo argumento, s, que es una cadena de longitud 8,\ny devuelve un arreglo con tres enteros que representan el conteo de dígitos,\nletras minúsculas y letras mayúsculas en la cadena, respectivamente.\n\nEjemplos:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "arb": "اكتب دالة روبي `def count_chars_types(s)` لحل المشكلة التالية:\nتحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة.\nتأخذ الدالة وسيطًا واحدًا، s، وهو سلسلة بطول 8،\nوتعيد مصفوفة تحتوي على ثلاثة أعداد صحيحة تمثل عدد الأرقام،\nالأحرف الصغيرة، والأحرف الكبيرة في السلسلة، على التوالي.\n\nأمثلة:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "sw": "Andika kazi ya ruby `def count_chars_types(s)` kutatua tatizo lifuatalo: \nHesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba iliyotolewa. \nKazi inachukua hoja moja, s, ambayo ni kamba ya urefu wa 8, \nna inarejesha safu iliyo na nambari tatu zinazoashiria hesabu ya tarakimu, \nherufi ndogo, na herufi kubwa katika kamba, mtawalia.\n\nMifano:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "tr": "Bir ruby fonksiyonu `def count_chars_types(s)` yazın: \nAşağıdaki problemi çözmek için: \nVerilen bir stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını sayar. \nFonksiyon, uzunluğu 8 olan bir string olan s adlı tek bir argüman alır \nve sırasıyla stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını temsil eden üç tam sayı içeren bir dizi döndürür.\n\nÖrnekler:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "vi": "Viết một hàm ruby `def count_chars_types(s)` để giải quyết vấn đề sau:\nĐếm số lượng chữ số, chữ cái thường, và chữ cái hoa trong một chuỗi cho trước.\nHàm nhận một đối số duy nhất, s, là một chuỗi có độ dài 8,\nvà trả về một mảng với ba số nguyên đại diện cho số lượng chữ số,\nchữ cái thường, và chữ cái hoa trong chuỗi, tương ứng.\n\nVí dụ:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]"
    },
    "instruction_bertscore": {
      "es": "0.9956196042070377",
      "arb": "0.9852175297826216",
      "sw": "0.9810147095503043",
      "tr": "0.9898742204356035",
      "vi": "0.9932608684322484"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_chars_types(\"yLOI2022\") == [4, 1, 3]\nraise 'Test failed' unless count_chars_types(\"IAKIOIOI\") == [0, 0, 8]\nraise 'Test failed' unless count_chars_types(\"1n2s0e1s\") == [4, 4, 0]\nraise 'Test failed' unless count_chars_types(\"12345678\") == [8, 0, 0]\nraise 'Test failed' unless count_chars_types(\"abcdefgh\") == [0, 8, 0]",
    "entry_point": "count_chars_types",
    "signature": "def count_chars_types(s)",
    "docstring": {
      "en": "Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n The function takes a single argument, s, which is a string of length 8,\n and returns an array with three integers representing the count of digits,\n lowercase letters, and uppercase letters in the string, respectively.\n\n Examples:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "es": "Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena dada. La función toma un solo argumento, s, que es una cadena de longitud 8, y devuelve un array con tres enteros que representan el conteo de dígitos, letras minúsculas y letras mayúsculas en la cadena, respectivamente.\n\nEjemplos:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "arb": "يحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة نصية معينة. تأخذ الدالة وسيطًا واحدًا، s، وهو سلسلة نصية بطول 8، وتعيد مصفوفة تحتوي على ثلاثة أعداد صحيحة تمثل عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في السلسلة النصية، على التوالي.\n\nأمثلة:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "sw": "Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba iliyotolewa. \nKazi hii inachukua hoja moja, s, ambayo ni kamba ya urefu wa 8, \nna inarejesha safu yenye namba tatu zinazowakilisha hesabu ya tarakimu, \nherufi ndogo, na herufi kubwa katika kamba, mtawalia.\n\nMifano:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "tr": "Rakamların, küçük harflerin ve büyük harflerin sayısını verilen bir dizede sayar.\nFonksiyon, s adlı tek bir argüman alır ve bu argüman 8 uzunluğunda bir dizedir. \nFonksiyon, sırasıyla dizedeki rakamların, küçük harflerin ve büyük harflerin sayısını temsil eden üç tam sayı içeren bir dizi döndürür.\n\nÖrnekler:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "vi": "Đếm số chữ số, chữ cái viết thường và chữ cái viết hoa trong một chuỗi cho trước. Hàm nhận một đối số duy nhất, s, là một chuỗi có độ dài 8, và trả về một mảng với ba số nguyên đại diện cho số lượng chữ số, chữ cái viết thường, và chữ cái viết hoa trong chuỗi, tương ứng.\n\nVí dụ:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]"
    },
    "docstring_bertscore": {
      "es": "0.9944621849767473",
      "arb": "0.9813206003370981",
      "sw": "0.9870165251436546",
      "tr": "0.9720254930261895",
      "vi": "0.9907402488969156"
    }
  }
]