[
  {
    "task_id": "PHP/1",
    "prompt": {
      "en": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n*/\nfunction has_close_elements($numbers, $threshold) ",
      "es": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * Verificar si en la lista dada de números, hay dos números que están más cerca uno del otro que\n    * el umbral dado.\n*/\nfunction has_close_elements($numbers, $threshold) ",
      "arb": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * التحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من\n    * العتبة المعطاة.\n*/\nfunction has_close_elements($numbers, $threshold) ",
      "sw": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * Angalia kama katika orodha iliyotolewa ya nambari, nambari zozote mbili ziko karibu zaidi kuliko\n    * kizingiti kilichotolewa.\n*/\nfunction has_close_elements($numbers, $threshold) ",
      "tr": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * Verilen sayı listesindeki herhangi iki sayının\n    * verilen eşikten daha yakın olup olmadığını kontrol edin.\n*/\nfunction has_close_elements($numbers, $threshold) ",
      "vi": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * Kiểm tra xem trong danh sách các số đã cho, có hai số nào gần nhau hơn\n    * ngưỡng đã cho hay không.\n*/\nfunction has_close_elements($numbers, $threshold) "
    },
    "prompt_bertscore": {
      "es": "0.9791446045128609",
      "arb": "0.9924593948447725",
      "sw": "0.976400724429245",
      "tr": "0.9644364220579895",
      "vi": "0.9671056171183363"
    },
    "canonical_solution": "{\n    $count = count($numbers);\n    for ($i = 0; $i < $count; $i++) {\n        for ($j = 0; $j < $count; $j++) {\n            if ($i != $j) {\n                $distance = abs($numbers[$i] - $numbers[$j]);\n                if ($distance < $threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
    "instruction": {
      "en": "Write a PHP function `function has_close_elements($numbers, $threshold)` to solve the following problem:\nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.",
      "es": "Escribe una función PHP `function has_close_elements($numbers, $threshold)` para resolver el siguiente problema:\nVerifica si en la lista de números dada, hay dos números que estén más cerca uno del otro que el umbral dado.",
      "arb": "اكتب دالة PHP `function has_close_elements($numbers, $threshold)` لحل المشكلة التالية:\nتحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.",
      "sw": "Andika kazi ya PHP `function has_close_elements($numbers, $threshold)` kutatua tatizo lifuatalo:\nAngalia kama katika orodha iliyotolewa ya namba, namba zozote mbili ziko karibu zaidi na kila mmoja kuliko kizingiti kilichotolewa.",
      "tr": "Bir PHP fonksiyonu `function has_close_elements($numbers, $threshold)` yazın ve aşağıdaki problemi çözün:\nVerilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.",
      "vi": "Viết một hàm PHP `function has_close_elements($numbers, $threshold)` để giải quyết vấn đề sau:\nKiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không."
    },
    "instruction_bertscore": {
      "es": "0.9752049695354149",
      "arb": "0.9893043498724143",
      "sw": "0.9893043498724143",
      "tr": "0.9499771234705547",
      "vi": "0.9588614631534833"
    },
    "level": "easy",
    "test": "// Test cases\nfunction test_has_close_elements() {\n    if (has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) != true){\n        exit(1);\n    }\n\n    if (has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) != false){\n        exit(1);\n    }\n    if (has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) != true){\n        exit(1);\n    }\n    if (has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) != false){\n        exit(1);\n    }\n    if (has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) != true){\n        exit(1);\n    }\n    if (has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) != true){\n        exit(1);\n    }\n    if (has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) != false){\n        exit(1);\n    }\n}\n\ntest_has_close_elements();\n\n?>",
    "entry_point": "has_close_elements",
    "signature": "function has_close_elements($numbers, $threshold)",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.",
      "es": "Verifica si en la lista dada de números, hay dos números que están más cerca uno del otro que el umbral dado.",
      "arb": "تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المحددة.",
      "sw": "Angalia kama katika orodha iliyotolewa ya nambari, nambari zozote mbili ziko karibu zaidi kuliko kizingiti kilichotolewa.",
      "tr": "Verilen sayı listesinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol edin.",
      "vi": "Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không."
    },
    "docstring_bertscore": {
      "es": "0.9391279320584291",
      "arb": "0.9626747692085911",
      "sw": "0.902125674266583",
      "tr": "0.9409857220122485",
      "vi": "0.8676734333064626"
    }
  },
  {
    "task_id": "PHP/2",
    "prompt": {
      "en": "<?php\n\n\n/**\n    * Determines the outcome of a \"Rock, Paper, Scissors\" game.\n    * In this game, each player selects either rock (0), paper (1), or scissors (2).\n    * The rules are as follows:\n    * - Paper beats rock\n    * - Rock beats scissors\n    * - Scissors beats paper\n    * If both players choose the same item, it's a draw.\n    * Input: Two integers representing the choices of two players.\n    * Output: Returns 1 if the first player wins, -1 if the second player wins, and 0 for a draw.\n*/\n\nfunction determineGameOutcome($player1, $player2) ",
      "es": "<?php\n\n\n/**\n    * Determina el resultado de un juego de \"Piedra, Papel, Tijeras\".\n    * En este juego, cada jugador selecciona piedra (0), papel (1) o tijeras (2).\n    * Las reglas son las siguientes:\n    * - El papel vence a la piedra\n    * - La piedra vence a las tijeras\n    * - Las tijeras vencen al papel\n    * Si ambos jugadores eligen el mismo elemento, es un empate.\n    * Entrada: Dos enteros que representan las elecciones de dos jugadores.\n    * Salida: Devuelve 1 si el primer jugador gana, -1 si el segundo jugador gana, y 0 para un empate.\n*/\n\nfunction determineGameOutcome($player1, $player2) ",
      "arb": "<?php\n\n\n/**\n    * يحدد نتيجة لعبة \"حجر، ورقة، مقص\".\n    * في هذه اللعبة، يختار كل لاعب إما حجر (0)، ورقة (1)، أو مقص (2).\n    * القواعد هي كما يلي:\n    * - الورقة تهزم الحجر\n    * - الحجر يهزم المقص\n    * - المقص يهزم الورقة\n    * إذا اختار كلا اللاعبين نفس العنصر، تكون النتيجة تعادل.\n    * المدخل: عددان صحيحان يمثلان اختيارات اللاعبين.\n    * المخرج: يعيد 1 إذا فاز اللاعب الأول، -1 إذا فاز اللاعب الثاني، و0 للتعادل.\n*/\n\nfunction determineGameOutcome($player1, $player2) ",
      "sw": "<?php\n\n\n/**\n    * Huamua matokeo ya mchezo wa \"Jiwe, Karatasi, Mkasi\".\n    * Katika mchezo huu, kila mchezaji huchagua ama jiwe (0), karatasi (1), au mkasi (2).\n    * Sheria ni kama ifuatavyo:\n    * - Karatasi inashinda jiwe\n    * - Jiwe linashinda mkasi\n    * - Mkasi unashinda karatasi\n    * Ikiwa wachezaji wote wawili watachagua kipengee sawa, ni sare.\n    * Ingizo: Nambari mbili za mzima zinazoashiria chaguo za wachezaji wawili.\n    * Tokeo: Inarudisha 1 ikiwa mchezaji wa kwanza anashinda, -1 ikiwa mchezaji wa pili anashinda, na 0 kwa sare.\n*/\n\nfunction determineGameOutcome($player1, $player2) ",
      "tr": "<?php\n\n\n/**\n    * \"Taş, Kağıt, Makas\" oyununun sonucunu belirler.\n    * Bu oyunda, her oyuncu taş (0), kağıt (1) veya makas (2) seçeneklerinden birini seçer.\n    * Kurallar aşağıdaki gibidir:\n    * - Kağıt taşı yener\n    * - Taş makası yener\n    * - Makas kağıdı yener\n    * Her iki oyuncu da aynı öğeyi seçerse, oyun berabere biter.\n    * Girdi: İki oyuncunun seçimlerini temsil eden iki tamsayı.\n    * Çıktı: İlk oyuncu kazanırsa 1, ikinci oyuncu kazanırsa -1 ve beraberlik durumunda 0 döner.\n*/\n\nfunction determineGameOutcome($player1, $player2) ",
      "vi": "<?php\n\n\n/**\n    * Xác định kết quả của trò chơi \"Kéo, Búa, Bao\".\n    * Trong trò chơi này, mỗi người chơi chọn kéo (0), búa (1), hoặc bao (2).\n    * Các quy tắc như sau:\n    * - Bao thắng búa\n    * - Búa thắng kéo\n    * - Kéo thắng bao\n    * Nếu cả hai người chơi chọn cùng một vật, đó là hòa.\n    * Đầu vào: Hai số nguyên đại diện cho lựa chọn của hai người chơi.\n    * Đầu ra: Trả về 1 nếu người chơi thứ nhất thắng, -1 nếu người chơi thứ hai thắng, và 0 cho hòa.\n*/\n\nfunction determineGameOutcome($player1, $player2) "
    },
    "prompt_bertscore": {
      "es": "0.9836654319852149",
      "arb": "0.9735730223248322",
      "sw": "0.9869877237384045",
      "tr": "0.9675499532807114",
      "vi": "0.9835698907719371"
    },
    "canonical_solution": "{\n    if ($player1 === $player2) {\n        return 0; // Draw\n    } elseif (($player1 === 0 && $player2 === 1) || // Paper beats Rock\n              ($player1 === 1 && $player2 === 2) || // Scissors beats Paper\n              ($player1 === 2 && $player2 === 0)) { // Rock beats Scissors\n        return -1; // Player 2 wins\n    } else {\n        return 1; // Player 1 wins\n    }\n}",
    "instruction": {
      "en": "Write a PHP function `function determineGameOutcome($player1, $player2)` to solve the following problem:\nDetermines the outcome of a \"Rock, Paper, Scissors\" game.\nIn this game, each player selects either rock (0), paper (1), or scissors (2).\nThe rules are as follows:\n- Paper beats rock\n- Rock beats scissors\n- Scissors beats paper\nIf both players choose the same item, it's a draw.\nInput: Two integers representing the choices of two players.\nOutput: Returns 1 if the first player wins, -1 if the second player wins, and 0 for a draw.",
      "es": "Escribe una función PHP `function determineGameOutcome($player1, $player2)` para resolver el siguiente problema:\nDetermina el resultado de un juego de \"Piedra, Papel, Tijeras\".\nEn este juego, cada jugador selecciona piedra (0), papel (1) o tijeras (2).\nLas reglas son las siguientes:\n- El papel vence a la piedra\n- La piedra vence a las tijeras\n- Las tijeras vencen al papel\nSi ambos jugadores eligen el mismo elemento, es un empate.\nEntrada: Dos enteros que representan las elecciones de dos jugadores.\nSalida: Devuelve 1 si el primer jugador gana, -1 si el segundo jugador gana, y 0 para un empate.",
      "arb": "اكتب دالة PHP `function determineGameOutcome($player1, $player2)` لحل المشكلة التالية:\nتحدد نتيجة لعبة \"حجر، ورقة، مقص\".\nفي هذه اللعبة، يختار كل لاعب إما الحجر (0)، الورقة (1)، أو المقص (2).\nالقواعد كالتالي:\n- الورقة تهزم الحجر\n- الحجر يهزم المقص\n- المقص يهزم الورقة\nإذا اختار كلا اللاعبين نفس العنصر، تكون النتيجة تعادل.\nالمدخلات: عددان صحيحان يمثلان اختيارات اللاعبين.\nالمخرجات: تعيد 1 إذا فاز اللاعب الأول، -1 إذا فاز اللاعب الثاني، و0 للتعادل.",
      "sw": "Andika kazi ya PHP `function determineGameOutcome($player1, $player2)` kutatua tatizo lifuatalo:\nInabainisha matokeo ya mchezo wa \"Jiwe, Karatasi, Mikasi\".\nKatika mchezo huu, kila mchezaji huchagua ama jiwe (0), karatasi (1), au mikasi (2).\nSheria ni kama ifuatavyo:\n- Karatasi inashinda jiwe\n- Jiwe linashinda mikasi\n- Mikasi inashinda karatasi\nIkiwa wachezaji wote watachagua kitu sawa, ni sare.\nIngizo: Nambari mbili za mzima zinazowakilisha chaguo za wachezaji wawili.\nPato: Inarudisha 1 ikiwa mchezaji wa kwanza anashinda, -1 ikiwa mchezaji wa pili anashinda, na 0 kwa sare.",
      "tr": "Bir PHP fonksiyonu `function determineGameOutcome($player1, $player2)` yazın ve aşağıdaki problemi çözün:\n\"Taş, Kağıt, Makas\" oyununun sonucunu belirler.\nBu oyunda, her oyuncu ya taş (0), kağıt (1) ya da makas (2) seçer.\nKurallar aşağıdaki gibidir:\n- Kağıt taşı yener\n- Taş makası yener\n- Makas kağıdı yener\nEğer her iki oyuncu da aynı öğeyi seçerse, sonuç beraberedir.\nGirdi: İki oyuncunun seçimlerini temsil eden iki tamsayı.\nÇıktı: İlk oyuncu kazanırsa 1, ikinci oyuncu kazanırsa -1 ve beraberlik için 0 döner.",
      "vi": "Viết một hàm PHP `function determineGameOutcome($player1, $player2)` để giải quyết vấn đề sau:\nXác định kết quả của trò chơi \"Kéo, Búa, Bao\".\nTrong trò chơi này, mỗi người chơi chọn kéo (0), búa (1), hoặc bao (2).\nCác quy tắc như sau:\n- Bao thắng búa\n- Búa thắng kéo\n- Kéo thắng bao\nNếu cả hai người chơi chọn cùng một vật phẩm, đó là hòa.\nĐầu vào: Hai số nguyên đại diện cho lựa chọn của hai người chơi.\nĐầu ra: Trả về 1 nếu người chơi thứ nhất thắng, -1 nếu người chơi thứ hai thắng, và 0 cho hòa."
    },
    "instruction_bertscore": {
      "es": "0.9751803393681666",
      "arb": "0.9701537989456978",
      "sw": "0.9824504099444246",
      "tr": "0.9787147683683014",
      "vi": "0.97704468412456"
    },
    "level": "easy",
    "test": "function main(){\n    \n    assert(determineGameOutcome(0, 1) === -1);\n    assert(determineGameOutcome(1, 2) === -1);\n    assert(determineGameOutcome(2, 0) === -1);\n    assert(determineGameOutcome(0, 2) === 1);\n    assert(determineGameOutcome(1, 0) === 1);\n    assert(determineGameOutcome(2, 1) === 1);\n    assert(determineGameOutcome(0, 0) === 0);\n    assert(determineGameOutcome(1, 1) === 0);\n    assert(determineGameOutcome(2, 2) === 0);\n}\nmain();\n// echo \"All test passed!\\n\";\n?>",
    "entry_point": "determineGameOutcome",
    "signature": "function determineGameOutcome($player1, $player2)",
    "docstring": {
      "en": "Determines the outcome of a \"Rock, Paper, Scissors\" game.\nIn this game, each player selects either rock (0), paper (1), or scissors (2).\nThe rules are as follows:\n- Paper beats rock\n- Rock beats scissors\n- Scissors beats paper\nIf both players choose the same item, it's a draw.\nInput: Two integers representing the choices of two players.\nOutput: Returns 1 if the first player wins, -1 if the second player wins, and 0 for a draw.",
      "es": "Determina el resultado de un juego de \"Piedra, Papel, Tijeras\".\nEn este juego, cada jugador selecciona piedra (0), papel (1) o tijeras (2).\nLas reglas son las siguientes:\n- Papel vence a piedra\n- Piedra vence a tijeras\n- Tijeras vence a papel\nSi ambos jugadores eligen el mismo elemento, es un empate.\nEntrada: Dos enteros que representan las elecciones de dos jugadores.\nSalida: Devuelve 1 si el primer jugador gana, -1 si el segundo jugador gana, y 0 para un empate.",
      "arb": "يحدد نتيجة لعبة \"حجر، ورقة، مقص\".  \nفي هذه اللعبة، يختار كل لاعب إما الحجر (0)، أو الورقة (1)، أو المقص (2).  \nالقواعد هي كما يلي:  \n- الورقة تهزم الحجر  \n- الحجر يهزم المقص  \n- المقص يهزم الورقة  \nإذا اختار كلا اللاعبين نفس العنصر، تكون النتيجة تعادلًا.  \nالمدخلات: عددان صحيحان يمثلان اختيارات اللاعبين الاثنين.  \nالمخرجات: يعيد 1 إذا فاز اللاعب الأول، -1 إذا فاز اللاعب الثاني، و 0 للتعادل.  ",
      "sw": "Inabainisha matokeo ya mchezo wa \"Jiwe, Karatasi, Mikasi.  \nKatika mchezo huu, kila mchezaji huchagua aidha jiwe (0), karatasi (1), au mkasi (2).  \nSheria ni kama ifuatavyo:  \n- Karatasi inashinda jiwe  \n- Jiwe linashinda mkasi  \n- Mkasi unashinda karatasi  \nIkiwa wachezaji wote wawili watachagua kitu sawa, ni sare.  \nIngizo: Nambari mbili zinazoashiria chaguo za wachezaji wawili.  \nMatokeo: Inarejesha 1 ikiwa mchezaji wa kwanza atashinda, -1 ikiwa mchezaji wa pili atashinda, na 0 kwa sare.",
      "tr": "\"Taş, Kağıt, Makas\" oyununun sonucunu belirler.  \nBu oyunda, her oyuncu taş (0), kağıt (1) veya makas (2) seçer.  \nKurallar aşağıdaki gibidir:  \n- Kağıt taşı yener  \n- Taş makası yener  \n- Makas kağıdı yener  \nHer iki oyuncu da aynı öğeyi seçerse, oyun berabere biter.  \nGirdi: İki oyuncunun seçimlerini temsil eden iki tamsayı.  \nÇıktı: İlk oyuncu kazanırsa 1, ikinci oyuncu kazanırsa -1 ve beraberlik için 0 döndürür.",
      "vi": "Xác định kết quả của trò chơi \"Kéo, Búa, Bao\".  \nTrong trò chơi này, mỗi người chơi chọn kéo (0), búa (1), hoặc bao (2).  \nCác quy tắc như sau:  \n- Bao thắng búa  \n- Búa thắng kéo  \n- Kéo thắng bao  \nNếu cả hai người chơi chọn cùng một vật phẩm, đó là hòa.  \nĐầu vào: Hai số nguyên đại diện cho lựa chọn của hai người chơi.  \nĐầu ra: Trả về 1 nếu người chơi thứ nhất thắng, -1 nếu người chơi thứ hai thắng, và 0 nếu hòa.  "
    },
    "docstring_bertscore": {
      "es": "0.9811781823538961",
      "arb": "0.9797555915649242",
      "sw": "0.9783510761406266",
      "tr": "0.9693606678342254",
      "vi": "0.9611437262315742"
    }
  },
  {
    "task_id": "PHP/3",
    "prompt": {
      "en": "<?php\n\n/**\n    * Removes all asterisks (*) from a string except those at the beginning.\n    * This function takes a string that may contain alphabetic characters and asterisks.\n    * It will preserve any asterisks that appear at the start of the string but remove all others.\n    * For example, a string like \"***Hello*World**\" would be transformed to \"***HelloWorld\".\n    * Input: A single string.\n    * Output: The modified string with only the leading asterisks retained.\n*/\nfunction removeInnerAsterisks($string) ",
      "es": "<?php\n\n/**\n    * Elimina todos los asteriscos (*) de una cadena excepto los que están al principio.\n    * Esta función toma una cadena que puede contener caracteres alfabéticos y asteriscos.\n    * Preservará cualquier asterisco que aparezca al inicio de la cadena pero eliminará todos los demás.\n    * Por ejemplo, una cadena como \"***Hello*World**\" se transformaría en \"***HelloWorld\".\n    * Entrada: Una sola cadena.\n    * Salida: La cadena modificada con solo los asteriscos iniciales retenidos.\n*/\nfunction removeInnerAsterisks($string) ",
      "arb": "<?php\n\n/**\n    * يزيل جميع النجوم (*) من سلسلة نصية باستثناء تلك الموجودة في البداية.\n    * تأخذ هذه الدالة سلسلة نصية قد تحتوي على أحرف أبجدية ونجوم.\n    * ستحتفظ بأي نجوم تظهر في بداية السلسلة ولكنها ستزيل جميع النجوم الأخرى.\n    * على سبيل المثال، سيتم تحويل سلسلة مثل \"***Hello*World**\" إلى \"***HelloWorld\".\n    * المدخل: سلسلة نصية واحدة.\n    * المخرج: السلسلة المعدلة مع الاحتفاظ بالنجوم الموجودة في البداية فقط.\n*/\nfunction removeInnerAsterisks($string) ",
      "sw": "<?php\n\n/**\n    * Huondoa nyota zote (*) kutoka kwenye kamba isipokuwa zile zilizo mwanzoni.\n    * Kazi hii inachukua kamba ambayo inaweza kuwa na herufi za alfabeti na nyota.\n    * Itahifadhi nyota zozote ambazo zinaonekana mwanzoni mwa kamba lakini itaondoa zote zingine.\n    * Kwa mfano, kamba kama \"***Hello*World**\" itabadilishwa kuwa \"***HelloWorld\".\n    * Ingizo: Kamba moja.\n    * Tokeo: Kamba iliyobadilishwa na nyota za mwanzo pekee zilizohifadhiwa.\n*/\nfunction removeInnerAsterisks($string) ",
      "tr": "<?php\n\n/**\n    * Bir dizgeden başlangıçtakiler hariç tüm yıldız işaretlerini (*) kaldırır.\n    * Bu fonksiyon, alfabetik karakterler ve yıldız işaretleri içerebilecek bir dizge alır.\n    * Dizgenin başlangıcında görünen yıldız işaretlerini koruyacak, ancak diğerlerini kaldıracaktır.\n    * Örneğin, \"***Hello*World**\" gibi bir dizge \"***HelloWorld\" olarak dönüştürülecektir.\n    * Girdi: Tek bir dizge.\n    * Çıktı: Sadece baştaki yıldız işaretlerinin korunduğu değiştirilmiş dizge.\n*/\nfunction removeInnerAsterisks($string) ",
      "vi": "<?php\n\n/**\n    * Loại bỏ tất cả dấu hoa thị (*) khỏi một chuỗi ngoại trừ những dấu ở đầu.\n    * Hàm này nhận một chuỗi có thể chứa các ký tự chữ cái và dấu hoa thị.\n    * Nó sẽ giữ lại bất kỳ dấu hoa thị nào xuất hiện ở đầu chuỗi nhưng sẽ loại bỏ tất cả các dấu khác.\n    * Ví dụ, một chuỗi như \"***Hello*World**\" sẽ được chuyển thành \"***HelloWorld\".\n    * Đầu vào: Một chuỗi đơn.\n    * Đầu ra: Chuỗi đã được chỉnh sửa chỉ giữ lại các dấu hoa thị ở đầu.\n*/\nfunction removeInnerAsterisks($string) "
    },
    "prompt_bertscore": {
      "es": "0.9905169883486323",
      "arb": "0.9726517746175924",
      "sw": "0.9832518835319003",
      "tr": "0.9650875324470218",
      "vi": "0.9781617813875002"
    },
    "canonical_solution": "{\n    $result = '';\n    $leadingAsterisk = true;\n    for ($i = 0; $i < strlen($string); $i++) {\n        if ($string[$i] != '*' || $leadingAsterisk) {\n            $result .= $string[$i];\n        }\n        if ($string[$i] != '*' && $leadingAsterisk) {\n            $leadingAsterisk = false;\n        }\n    }\n    return $result;\n}",
    "instruction": {
      "en": "Write a PHP function `function removeInnerAsterisks($string)` to solve the following problem:\nRemoves all asterisks (*) from a string except those at the beginning.\nThis function takes a string that may contain alphabetic characters and asterisks.\nIt will preserve any asterisks that appear at the start of the string but remove all others.\nFor example, a string like \"***Hello*World**\" would be transformed to \"***HelloWorld\".\nInput: A single string.\nOutput: The modified string with only the leading asterisks retained.",
      "es": "Escribe una función PHP `function removeInnerAsterisks($string)` para resolver el siguiente problema:\nElimina todos los asteriscos (*) de una cadena excepto aquellos al principio.\nEsta función toma una cadena que puede contener caracteres alfabéticos y asteriscos.\nPreservará cualquier asterisco que aparezca al inicio de la cadena, pero eliminará todos los demás.\nPor ejemplo, una cadena como \"***Hello*World**\" se transformaría en \"***HelloWorld\".\nEntrada: Una sola cadena.\nSalida: La cadena modificada con solo los asteriscos iniciales retenidos.",
      "arb": "اكتب دالة PHP `function removeInnerAsterisks($string)` لحل المشكلة التالية:\nإزالة جميع النجوم (*) من سلسلة نصية باستثناء تلك الموجودة في البداية.\nتأخذ هذه الدالة سلسلة نصية قد تحتوي على أحرف أبجدية ونجوم.\nستحافظ على أي نجوم تظهر في بداية السلسلة ولكن ستزيل جميع النجوم الأخرى.\nعلى سبيل المثال، سلسلة مثل \"***Hello*World**\" ستتحول إلى \"***HelloWorld\".\nالمدخل: سلسلة نصية واحدة.\nالمخرج: السلسلة المعدلة مع الاحتفاظ فقط بالنجوم الرائدة.",
      "sw": "Andika kazi ya PHP `function removeInnerAsterisks($string)` kutatua tatizo lifuatalo:\nHuondoa nyota zote (*) kutoka kwenye kamba isipokuwa zile zilizo mwanzoni.\nKazi hii inachukua kamba ambayo inaweza kuwa na herufi za alfabeti na nyota.\nItahifadhi nyota zozote zinazotokea mwanzoni mwa kamba lakini itaondoa zote nyingine.\nKwa mfano, kamba kama \"***Hello*World**\" itabadilishwa kuwa \"***HelloWorld\".\nIngizo: Kamba moja.\nMatokeo: Kamba iliyorekebishwa na nyota za mwanzo pekee zilizohifadhiwa.",
      "tr": "Bir PHP fonksiyonu `function removeInnerAsterisks($string)` yazın: \nBaşlangıçtakiler hariç, bir dizedeki tüm yıldız işaretlerini (*) kaldırır.\nBu fonksiyon, alfabetik karakterler ve yıldız işaretleri içerebilen bir dize alır.\nDizenin başlangıcında görünen yıldız işaretlerini koruyacak, ancak diğerlerini kaldıracaktır.\nÖrneğin, \"***Hello*World**\" gibi bir dize \"***HelloWorld\" olarak dönüştürülecektir.\nGirdi: Tek bir dize.\nÇıktı: Yalnızca baştaki yıldız işaretlerinin korunduğu değiştirilmiş dize.",
      "vi": "Viết một hàm PHP `function removeInnerAsterisks($string)` để giải quyết vấn đề sau:\nLoại bỏ tất cả các dấu hoa thị (*) khỏi một chuỗi ngoại trừ những dấu ở đầu.\nHàm này nhận một chuỗi có thể chứa các ký tự chữ cái và dấu hoa thị.\nNó sẽ giữ lại bất kỳ dấu hoa thị nào xuất hiện ở đầu chuỗi nhưng loại bỏ tất cả các dấu khác.\nVí dụ, một chuỗi như \"***Hello*World**\" sẽ được chuyển thành \"***HelloWorld\".\nĐầu vào: Một chuỗi đơn.\nĐầu ra: Chuỗi đã được chỉnh sửa chỉ giữ lại các dấu hoa thị ở đầu."
    },
    "instruction_bertscore": {
      "es": "0.9848401320586553",
      "arb": "0.9804555650276912",
      "sw": "0.9823363961057106",
      "tr": "0.964649751087221",
      "vi": "0.979908139697559"
    },
    "level": "easy",
    "test": "function main(){\n    assert(removeInnerAsterisks(\"***Hello*World**\") === \"***HelloWorld\");\n    assert(removeInnerAsterisks(\"****\") === \"****\");\n    assert(removeInnerAsterisks(\"abc*def**ghi\") === \"abcdefghi\");\n    assert(removeInnerAsterisks(\"*a*b*c*\") === \"*abc\");\n    assert(removeInnerAsterisks(\"\") === \"\");\n    \n}\n\nmain();\n?>",
    "entry_point": "removeInnerAsterisks",
    "signature": "function removeInnerAsterisks($string)",
    "docstring": {
      "en": "Removes all asterisks (*) from a string except those at the beginning.\nThis function takes a string that may contain alphabetic characters and asterisks.\nIt will preserve any asterisks that appear at the start of the string but remove all others.\nFor example, a string like \"***Hello*World**\" would be transformed to \"***HelloWorld\".\nInput: A single string.\nOutput: The modified string with only the leading asterisks retained.",
      "es": "Elimina todos los asteriscos (*) de una cadena excepto los que están al principio.  \nEsta función toma una cadena que puede contener caracteres alfabéticos y asteriscos.  \nPreservará cualquier asterisco que aparezca al inicio de la cadena, pero eliminará todos los demás.  \nPor ejemplo, una cadena como \"***Hello*World**\" se transformaría en \"***HelloWorld\".  \nEntrada: Una sola cadena.  \nSalida: La cadena modificada con solo los asteriscos iniciales retenidos.",
      "arb": "يزيل جميع النجوم (*) من سلسلة نصية باستثناء تلك الموجودة في البداية.\nتأخذ هذه الدالة سلسلة نصية قد تحتوي على أحرف أبجدية ونجوم.\nستحافظ على أي نجوم تظهر في بداية السلسلة النصية ولكن ستزيل جميع النجوم الأخرى.\nعلى سبيل المثال، سيتم تحويل سلسلة نصية مثل \"***Hello*World**\" إلى \"***HelloWorld\".\nالمدخلات: سلسلة نصية واحدة.\nالمخرجات: السلسلة النصية المعدلة مع الاحتفاظ بالنجوم الموجودة في البداية فقط.",
      "sw": "Huondoa nyota zote (*) kutoka kwenye kamba isipokuwa zile zilizo mwanzoni. \nKazi hii inachukua kamba ambayo inaweza kuwa na herufi za alfabeti na nyota. \nItahifadhi nyota zozote zinazotokea mwanzoni mwa kamba lakini itaondoa zingine zote. \nKwa mfano, kamba kama \"***Hello*World**\" itabadilishwa kuwa \"***HelloWorld\". \nIngizo: Kamba moja. \nPato: Kamba iliyobadilishwa na nyota za mwanzo pekee zilizohifadhiwa.",
      "tr": "Başlangıçtaki asteriksler (*) hariç, bir dizgedeki tüm asteriksleri kaldırır.\nBu fonksiyon, alfabetik karakterler ve asteriksler içerebilen bir dizge alır.\nDizgenin başlangıcında görünen asteriksleri koruyacak, ancak diğer tüm asteriksleri kaldıracaktır.\nÖrneğin, \"***Hello*World**\" gibi bir dizge \"***HelloWorld\" olarak dönüştürülecektir.\nGirdi: Tek bir dizge.\nÇıktı: Sadece baştaki asterikslerin korunduğu değiştirilmiş dizge.",
      "vi": "Loại bỏ tất cả dấu hoa thị (*) khỏi một chuỗi ngoại trừ những dấu ở đầu.\nHàm này nhận một chuỗi có thể chứa các ký tự chữ cái và dấu hoa thị.\nNó sẽ giữ lại bất kỳ dấu hoa thị nào xuất hiện ở đầu chuỗi nhưng loại bỏ tất cả các dấu khác.\nVí dụ, một chuỗi như \"***Hello*World**\" sẽ được chuyển thành \"***HelloWorld\".\nĐầu vào: Một chuỗi đơn.\nĐầu ra: Chuỗi đã được chỉnh sửa chỉ giữ lại các dấu hoa thị ở đầu."
    },
    "docstring_bertscore": {
      "es": "0.9844810083297442",
      "arb": "0.9371533474405613",
      "sw": "0.9267925881354006",
      "tr": "0.9493510405095328",
      "vi": "0.9694172774928204"
    }
  },
  {
    "task_id": "PHP/4",
    "prompt": {
      "en": "<?php\n\n/**\n * Converts a numerical score to its corresponding letter grade.\n * The grading system is as follows:\n * - A score between 90 and 100 (inclusive) is graded as 'A'.\n * - A score between 80 and 89 (inclusive) is graded as 'B'.\n * - A score between 70 and 79 (inclusive) is graded as 'C'.\n * - A score between 60 and 69 (inclusive) is graded as 'D'.\n * - A score below 60 is graded as 'E'.\n * If the score is outside the range of 0 to 100, an error message is returned.\n * Input: A numeric score.\n * Output: Returns the corresponding letter grade or an error message if the score is out of range.\n */\n \nfunction convertScoreToGrade($score) ",
      "es": "<?php\n\n/**\n * Convierte una puntuación numérica en su calificación de letra correspondiente.\n * El sistema de calificación es el siguiente:\n * - Una puntuación entre 90 y 100 (inclusive) se califica como 'A'.\n * - Una puntuación entre 80 y 89 (inclusive) se califica como 'B'.\n * - Una puntuación entre 70 y 79 (inclusive) se califica como 'C'.\n * - Una puntuación entre 60 y 69 (inclusive) se califica como 'D'.\n * - Una puntuación por debajo de 60 se califica como 'E'.\n * Si la puntuación está fuera del rango de 0 a 100, se devuelve un mensaje de error.\n * Entrada: Una puntuación numérica.\n * Salida: Devuelve la calificación de letra correspondiente o un mensaje de error si la puntuación está fuera de rango.\n */\n \nfunction convertScoreToGrade($score) ",
      "arb": "<?php\n\n/**\n * يحول الدرجة الرقمية إلى الدرجة الحرفية المقابلة لها.\n * نظام التقييم هو كما يلي:\n * - الدرجة بين 90 و 100 (شاملة) تُقيّم كـ 'A'.\n * - الدرجة بين 80 و 89 (شاملة) تُقيّم كـ 'B'.\n * - الدرجة بين 70 و 79 (شاملة) تُقيّم كـ 'C'.\n * - الدرجة بين 60 و 69 (شاملة) تُقيّم كـ 'D'.\n * - الدرجة أقل من 60 تُقيّم كـ 'E'.\n * إذا كانت الدرجة خارج نطاق 0 إلى 100، يتم إرجاع رسالة خطأ.\n * المدخل: درجة رقمية.\n * المخرج: يعيد الدرجة الحرفية المقابلة أو رسالة خطأ إذا كانت الدرجة خارج النطاق.\n */\n \nfunction convertScoreToGrade($score) ",
      "sw": "<?php\n\n/**\n * Hubadilisha alama ya nambari kuwa alama ya herufi inayolingana.\n * Mfumo wa upangaji ni kama ifuatavyo:\n * - Alama kati ya 90 na 100 (pamoja) inapewa alama 'A'.\n * - Alama kati ya 80 na 89 (pamoja) inapewa alama 'B'.\n * - Alama kati ya 70 na 79 (pamoja) inapewa alama 'C'.\n * - Alama kati ya 60 na 69 (pamoja) inapewa alama 'D'.\n * - Alama chini ya 60 inapewa alama 'E'.\n * Ikiwa alama iko nje ya kiwango cha 0 hadi 100, ujumbe wa kosa unarejeshwa.\n * Ingizo: Alama ya nambari.\n * Tokeo: Inarejesha alama ya herufi inayolingana au ujumbe wa kosa ikiwa alama iko nje ya kiwango.\n */\n \nfunction convertScoreToGrade($score) ",
      "tr": "<?php\n\n/**\n * Sayısal bir puanı karşılık gelen harf notuna dönüştürür.\n * Not sistemi aşağıdaki gibidir:\n * - 90 ile 100 (dahil) arasındaki bir puan 'A' olarak derecelendirilir.\n * - 80 ile 89 (dahil) arasındaki bir puan 'B' olarak derecelendirilir.\n * - 70 ile 79 (dahil) arasındaki bir puan 'C' olarak derecelendirilir.\n * - 60 ile 69 (dahil) arasındaki bir puan 'D' olarak derecelendirilir.\n * - 60'ın altındaki bir puan 'E' olarak derecelendirilir.\n * Puan 0 ile 100 aralığının dışındaysa, bir hata mesajı döndürülür.\n * Girdi: Sayısal bir puan.\n * Çıktı: Karşılık gelen harf notunu veya puan aralık dışındaysa bir hata mesajı döndürür.\n */\n \nfunction convertScoreToGrade($score) ",
      "vi": "<?php\n\n/**\n * Chuyển đổi điểm số thành điểm chữ tương ứng.\n * Hệ thống chấm điểm như sau:\n * - Điểm số từ 90 đến 100 (bao gồm) được chấm là 'A'.\n * - Điểm số từ 80 đến 89 (bao gồm) được chấm là 'B'.\n * - Điểm số từ 70 đến 79 (bao gồm) được chấm là 'C'.\n * - Điểm số từ 60 đến 69 (bao gồm) được chấm là 'D'.\n * - Điểm số dưới 60 được chấm là 'E'.\n * Nếu điểm số nằm ngoài phạm vi từ 0 đến 100, một thông báo lỗi sẽ được trả về.\n * Đầu vào: Một điểm số dạng số.\n * Đầu ra: Trả về điểm chữ tương ứng hoặc một thông báo lỗi nếu điểm số nằm ngoài phạm vi.\n */\n \nfunction convertScoreToGrade($score) "
    },
    "prompt_bertscore": {
      "es": "0.9984904091041349",
      "arb": "0.9930151626509082",
      "sw": "0.9667071645739803",
      "tr": "0.9967736467208503",
      "vi": "0.9610666576437326"
    },
    "canonical_solution": "{\n    if ($score < 0 || $score > 100) {\n        return \"Score is error!\";\n    } elseif ($score >= 90) {\n        return 'A';\n    } elseif ($score >= 80) {\n        return 'B';\n    } elseif ($score >= 70) {\n        return 'C';\n    } elseif ($score >= 60) {\n        return 'D';\n    } else {\n        return 'E';\n    }\n}",
    "instruction": {
      "en": "Write a PHP function `function convertScoreToGrade($score)` to solve the following problem:\nConverts a numerical score to its corresponding letter grade.\nThe grading system is as follows:\n- A score between 90 and 100 (inclusive) is graded as 'A'.\n- A score between 80 and 89 (inclusive) is graded as 'B'.\n- A score between 70 and 79 (inclusive) is graded as 'C'.\n- A score between 60 and 69 (inclusive) is graded as 'D'.\n- A score below 60 is graded as 'E'.\nIf the score is outside the range of 0 to 100, an error message is returned.\nInput: A numeric score.\nOutput: Returns the corresponding letter grade or an error message if the score is out of range.",
      "es": "Escriba una función PHP `function convertScoreToGrade($score)` para resolver el siguiente problema:\nConvierte una puntuación numérica a su calificación de letra correspondiente.\nEl sistema de calificación es el siguiente:\n- Una puntuación entre 90 y 100 (inclusive) se califica como 'A'.\n- Una puntuación entre 80 y 89 (inclusive) se califica como 'B'.\n- Una puntuación entre 70 y 79 (inclusive) se califica como 'C'.\n- Una puntuación entre 60 y 69 (inclusive) se califica como 'D'.\n- Una puntuación por debajo de 60 se califica como 'E'.\nSi la puntuación está fuera del rango de 0 a 100, se devuelve un mensaje de error.\nEntrada: Una puntuación numérica.\nSalida: Devuelve la calificación de letra correspondiente o un mensaje de error si la puntuación está fuera de rango.",
      "arb": "اكتب دالة PHP `function convertScoreToGrade($score)` لحل المشكلة التالية:\nتحويل درجة رقمية إلى الدرجة الحرفية المقابلة لها.\nنظام التقييم كالتالي:\n- الدرجة بين 90 و 100 (شاملة) تُصنف كـ 'A'.\n- الدرجة بين 80 و 89 (شاملة) تُصنف كـ 'B'.\n- الدرجة بين 70 و 79 (شاملة) تُصنف كـ 'C'.\n- الدرجة بين 60 و 69 (شاملة) تُصنف كـ 'D'.\n- الدرجة أقل من 60 تُصنف كـ 'E'.\nإذا كانت الدرجة خارج النطاق من 0 إلى 100، يتم إرجاع رسالة خطأ.\nالمدخل: درجة رقمية.\nالمخرج: يعيد الدرجة الحرفية المقابلة أو رسالة خطأ إذا كانت الدرجة خارج النطاق.",
      "sw": "Andika kazi ya PHP `function convertScoreToGrade($score)` kutatua tatizo lifuatalo:\nInabadilisha alama ya nambari kuwa daraja lake la herufi linalolingana.\nMfumo wa upangaji ni kama ifuatavyo:\n- Alama kati ya 90 na 100 (ikijumuisha) inapewa daraja 'A'.\n- Alama kati ya 80 na 89 (ikijumuisha) inapewa daraja 'B'.\n- Alama kati ya 70 na 79 (ikijumuisha) inapewa daraja 'C'.\n- Alama kati ya 60 na 69 (ikijumuisha) inapewa daraja 'D'.\n- Alama chini ya 60 inapewa daraja 'E'.\nIkiwa alama iko nje ya kiwango cha 0 hadi 100, ujumbe wa kosa unarudishwa.\nIngizo: Alama ya nambari.\nPato: Inarudisha daraja la herufi linalolingana au ujumbe wa kosa ikiwa alama iko nje ya kiwango.",
      "tr": "Bir PHP fonksiyonu `function convertScoreToGrade($score)` yazın: Aşağıdaki problemi çözmek için:\nSayısal bir puanı karşılık gelen harf notuna dönüştürür.\nNot sistemi aşağıdaki gibidir:\n- 90 ile 100 arasında (dahil) bir puan 'A' olarak derecelendirilir.\n- 80 ile 89 arasında (dahil) bir puan 'B' olarak derecelendirilir.\n- 70 ile 79 arasında (dahil) bir puan 'C' olarak derecelendirilir.\n- 60 ile 69 arasında (dahil) bir puan 'D' olarak derecelendirilir.\n- 60'ın altındaki bir puan 'E' olarak derecelendirilir.\nEğer puan 0 ile 100 aralığının dışındaysa, bir hata mesajı döndürülür.\nGirdi: Sayısal bir puan.\nÇıktı: Karşılık gelen harf notunu veya puan aralık dışındaysa bir hata mesajı döndürür.",
      "vi": "Viết một hàm PHP `function convertScoreToGrade($score)` để giải quyết vấn đề sau:\nChuyển đổi một điểm số thành điểm chữ tương ứng.\nHệ thống chấm điểm như sau:\n- Điểm số từ 90 đến 100 (bao gồm) được chấm là 'A'.\n- Điểm số từ 80 đến 89 (bao gồm) được chấm là 'B'.\n- Điểm số từ 70 đến 79 (bao gồm) được chấm là 'C'.\n- Điểm số từ 60 đến 69 (bao gồm) được chấm là 'D'.\n- Điểm số dưới 60 được chấm là 'E'.\nNếu điểm số nằm ngoài khoảng từ 0 đến 100, một thông báo lỗi sẽ được trả về.\nĐầu vào: Một điểm số dạng số.\nĐầu ra: Trả về điểm chữ tương ứng hoặc một thông báo lỗi nếu điểm số nằm ngoài phạm vi."
    },
    "instruction_bertscore": {
      "es": "0.9944633767590335",
      "arb": "0.9747062086486363",
      "sw": "0.964269175277158",
      "tr": "0.9943694245888041",
      "vi": "0.9644719768961947"
    },
    "level": "easy",
    "test": "function main(){\n    assert(convertScoreToGrade(95) === 'A');\n    assert(convertScoreToGrade(85) === 'B');\n    assert(convertScoreToGrade(75) === 'C');\n    assert(convertScoreToGrade(65) === 'D');\n    assert(convertScoreToGrade(55) === 'E');\n    assert(convertScoreToGrade(-1) === 'Score is error!');\n    assert(convertScoreToGrade(101) === 'Score is error!');\n    \n}\n\nmain();\n?>",
    "entry_point": "convertScoreToGrade",
    "signature": "function convertScoreToGrade($score)",
    "docstring": {
      "en": "Converts a numerical score to its corresponding letter grade.\nThe grading system is as follows:\n- A score between 90 and 100 (inclusive) is graded as 'A'.\n- A score between 80 and 89 (inclusive) is graded as 'B'.\n- A score between 70 and 79 (inclusive) is graded as 'C'.\n- A score between 60 and 69 (inclusive) is graded as 'D'.\n- A score below 60 is graded as 'E'.\nIf the score is outside the range of 0 to 100, an error message is returned.\nInput: A numeric score.\nOutput: Returns the corresponding letter grade or an error message if the score is out of range.",
      "es": "Convierte una puntuación numérica en su correspondiente calificación con letra.  \nEl sistema de calificación es el siguiente:  \n- Una puntuación entre 90 y 100 (inclusive) se califica como 'A'.  \n- Una puntuación entre 80 y 89 (inclusive) se califica como 'B'.  \n- Una puntuación entre 70 y 79 (inclusive) se califica como 'C'.  \n- Una puntuación entre 60 y 69 (inclusive) se califica como 'D'.  \n- Una puntuación por debajo de 60 se califica como 'E'.  \nSi la puntuación está fuera del rango de 0 a 100, se devuelve un mensaje de error.  \nEntrada: Una puntuación numérica.  \nSalida: Devuelve la calificación con letra correspondiente o un mensaje de error si la puntuación está fuera de rango.",
      "arb": "يحوّل درجة رقمية إلى درجة حرفية مقابلة لها. نظام التقييم كالتالي:\n- الدرجة بين 90 و 100 (شاملة) تُصنف كـ 'A'.\n- الدرجة بين 80 و 89 (شاملة) تُصنف كـ 'B'.\n- الدرجة بين 70 و 79 (شاملة) تُصنف كـ 'C'.\n- الدرجة بين 60 و 69 (شاملة) تُصنف كـ 'D'.\n- الدرجة الأقل من 60 تُصنف كـ 'E'.\nإذا كانت الدرجة خارج النطاق من 0 إلى 100، يتم إرجاع رسالة خطأ.\nالمدخل: درجة رقمية.\nالمخرج: يعيد الدرجة الحرفية المقابلة أو رسالة خطأ إذا كانت الدرجة خارج النطاق.",
      "sw": "Inabadilisha alama ya nambari kuwa daraja lake la herufi linalolingana.\n\nMfumo wa upangaji alama ni kama ifuatavyo:\n- Alama kati ya 90 na 100 (pamoja) inapewa daraja 'A'.\n- Alama kati ya 80 na 89 (pamoja) inapewa daraja 'B'.\n- Alama kati ya 70 na 79 (pamoja) inapewa daraja 'C'.\n- Alama kati ya 60 na 69 (pamoja) inapewa daraja 'D'.\n- Alama chini ya 60 inapewa daraja 'E'.\n\nIkiwa alama iko nje ya kiwango cha 0 hadi 100, ujumbe wa kosa utarejeshwa.\n\nIngizo: Alama ya nambari.\n\nMatokeo: Inarejesha daraja la herufi linalolingana au ujumbe wa kosa ikiwa alama iko nje ya kiwango.",
      "tr": "Sayısal bir puanı, karşılık gelen harf notuna dönüştürür. Not sistemi aşağıdaki gibidir:\n- 90 ile 100 (dahil) arasındaki bir puan 'A' olarak değerlendirilir.\n- 80 ile 89 (dahil) arasındaki bir puan 'B' olarak değerlendirilir.\n- 70 ile 79 (dahil) arasındaki bir puan 'C' olarak değerlendirilir.\n- 60 ile 69 (dahil) arasındaki bir puan 'D' olarak değerlendirilir.\n- 60'ın altındaki bir puan 'E' olarak değerlendirilir.\nEğer puan 0 ile 100 aralığında değilse, bir hata mesajı döndürülür.\nGirdi: Sayısal bir puan.\nÇıktı: Karşılık gelen harf notunu veya puan aralık dışındaysa bir hata mesajı döndürür.",
      "vi": "Chuyển đổi một điểm số thành điểm chữ tương ứng. \nHệ thống chấm điểm như sau: \n- Một điểm số từ 90 đến 100 (bao gồm cả hai) được chấm là 'A'. \n- Một điểm số từ 80 đến 89 (bao gồm cả hai) được chấm là 'B'. \n- Một điểm số từ 70 đến 79 (bao gồm cả hai) được chấm là 'C'. \n- Một điểm số từ 60 đến 69 (bao gồm cả hai) được chấm là 'D'. \n- Một điểm số dưới 60 được chấm là 'E'. \nNếu điểm số nằm ngoài phạm vi từ 0 đến 100, một thông báo lỗi sẽ được trả về. \nĐầu vào: Một điểm số dạng số. \nĐầu ra: Trả về điểm chữ tương ứng hoặc một thông báo lỗi nếu điểm số nằm ngoài phạm vi."
    },
    "docstring_bertscore": {
      "es": "0.9983303130170207",
      "arb": "0.9700608399273734",
      "sw": "0.9642930109228823",
      "tr": "0.9683377213718957",
      "vi": "0.9743943589504115"
    }
  },
  {
    "task_id": "PHP/5",
    "prompt": {
      "en": "<?php\n/**\n * Calculates the day number of the year for a given date.\n * This function takes a date in the format 'YYYY/MM/DD' and returns the day number\n * in the year for that date. For example, '2024/01/01' would return 1, as it is the first day of the year,\n * while '2024/12/31' would return 366 for a leap year or 365 otherwise.\n * Input: A string representing the date in 'YYYY/MM/DD' format.\n * Output: An integer representing the day number in the year.\n */\n\nfunction getDayOfYear($date): int ",
      "es": "<?php\n/**\n * Calcula el número de día del año para una fecha dada.\n * Esta función toma una fecha en el formato 'YYYY/MM/DD' y devuelve el número de día\n * en el año para esa fecha. Por ejemplo, '2024/01/01' devolvería 1, ya que es el primer día del año,\n * mientras que '2024/12/31' devolvería 366 para un año bisiesto o 365 de lo contrario.\n * Entrada: Una cadena que representa la fecha en formato 'YYYY/MM/DD'.\n * Salida: Un entero que representa el número de día en el año.\n */\n\nfunction getDayOfYear($date): int ",
      "arb": "<?php\n/**\n * يحسب رقم اليوم في السنة لتاريخ معين.\n * تأخذ هذه الدالة تاريخًا بصيغة 'YYYY/MM/DD' وتعيد رقم اليوم\n * في السنة لذلك التاريخ. على سبيل المثال، '2024/01/01' ستعيد 1، لأنه اليوم الأول من السنة،\n * بينما '2024/12/31' ستعيد 366 في سنة كبيسة أو 365 في غير ذلك.\n * المدخل: سلسلة تمثل التاريخ بصيغة 'YYYY/MM/DD'.\n * المخرج: عدد صحيح يمثل رقم اليوم في السنة.\n */\n\nfunction getDayOfYear($date): int ",
      "sw": "<?php\n/**\n * Inahesabu nambari ya siku ya mwaka kwa tarehe iliyotolewa.\n * Kazi hii inachukua tarehe katika muundo wa 'YYYY/MM/DD' na inarejesha nambari ya siku\n * katika mwaka kwa tarehe hiyo. Kwa mfano, '2024/01/01' itarejesha 1, kwani ni siku ya kwanza ya mwaka,\n * wakati '2024/12/31' itarejesha 366 kwa mwaka wa kuruka au 365 vinginevyo.\n * Ingizo: Kamba inayowakilisha tarehe katika muundo wa 'YYYY/MM/DD'.\n * Matokeo: Nambari ya mzima inayowakilisha nambari ya siku katika mwaka.\n */\n\nfunction getDayOfYear($date): int ",
      "tr": "<?php\n/**\n * Belirli bir tarih için yılın gün numarasını hesaplar.\n * Bu fonksiyon 'YYYY/MM/DD' formatında bir tarih alır ve o tarihin yıl içindeki gün numarasını döndürür.\n * Örneğin, '2024/01/01' yılı ilk gün olduğu için 1 döndürecektir,\n * '2024/12/31' ise artık yıl için 366 veya aksi takdirde 365 döndürecektir.\n * Girdi: 'YYYY/MM/DD' formatında tarihi temsil eden bir dize.\n * Çıktı: Yıl içindeki gün numarasını temsil eden bir tamsayı.\n */\n\nfunction getDayOfYear($date): int ",
      "vi": "<?php\n/**\n * Tính toán số thứ tự của ngày trong năm cho một ngày cụ thể.\n * Hàm này nhận một ngày theo định dạng 'YYYY/MM/DD' và trả về số thứ tự của ngày\n * trong năm cho ngày đó. Ví dụ, '2024/01/01' sẽ trả về 1, vì đó là ngày đầu tiên của năm,\n * trong khi '2024/12/31' sẽ trả về 366 cho một năm nhuận hoặc 365 nếu không phải.\n * Đầu vào: Một chuỗi đại diện cho ngày theo định dạng 'YYYY/MM/DD'.\n * Đầu ra: Một số nguyên đại diện cho số thứ tự của ngày trong năm.\n */\n\nfunction getDayOfYear($date): int "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.981547634862621",
      "sw": "0.9858223592928728",
      "tr": "0.9675128093994578",
      "vi": "0.9460140501081467"
    },
    "canonical_solution": "{\n    $dateParts = explode('/', $date);\n    $year = (int) $dateParts[0];\n    $month = (int) $dateParts[1];\n    $day = (int) $dateParts[2];\n\n    $isLeapYear = ($year % 4 == 0 && $year % 100 != 0) || $year % 400 == 0;\n    $monthDays = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    $dayOfYear = 0;\n    for ($i = 0; $i < $month - 1; $i++) {\n        $dayOfYear += $monthDays[$i];\n    }\n    $dayOfYear += $day;\n\n    return $dayOfYear;\n}",
    "instruction": {
      "en": "Write a PHP function `function getDayOfYear($date): int` to solve the following problem:\nCalculates the day number of the year for a given date.\nThis function takes a date in the format 'YYYY/MM/DD' and returns the day number\nin the year for that date. For example, '2024/01/01' would return 1, as it is the first day of the year,\nwhile '2024/12/31' would return 366 for a leap year or 365 otherwise.\nInput: A string representing the date in 'YYYY/MM/DD' format.\nOutput: An integer representing the day number in the year.",
      "es": "Escribe una función PHP `function getDayOfYear($date): int` para resolver el siguiente problema:\nCalcula el número de día del año para una fecha dada.\nEsta función toma una fecha en el formato 'YYYY/MM/DD' y devuelve el número de día\nen el año para esa fecha. Por ejemplo, '2024/01/01' devolvería 1, ya que es el primer día del año,\nmientras que '2024/12/31' devolvería 366 para un año bisiesto o 365 de lo contrario.\nEntrada: Una cadena que representa la fecha en formato 'YYYY/MM/DD'.\nSalida: Un entero que representa el número de día en el año.",
      "arb": "اكتب دالة PHP `function getDayOfYear($date): int` لحل المشكلة التالية:\nتحسب رقم اليوم في السنة لتاريخ معين.\nتأخذ هذه الدالة تاريخًا بالتنسيق 'YYYY/MM/DD' وتعيد رقم اليوم\nفي السنة لذلك التاريخ. على سبيل المثال، '2024/01/01' ستعيد 1، لأنه اليوم الأول من السنة،\nبينما '2024/12/31' ستعيد 366 في سنة كبيسة أو 365 في غير ذلك.\nالمدخل: سلسلة تمثل التاريخ بالتنسيق 'YYYY/MM/DD'.\nالمخرج: عدد صحيح يمثل رقم اليوم في السنة.",
      "sw": "Andika kazi ya PHP `function getDayOfYear($date): int` kutatua tatizo lifuatalo:\nHesabu namba ya siku ya mwaka kwa tarehe iliyotolewa.\nKazi hii inachukua tarehe katika muundo wa 'YYYY/MM/DD' na inarudisha namba ya siku\nkatika mwaka kwa tarehe hiyo. Kwa mfano, '2024/01/01' ingerejesha 1, kwani ni siku ya kwanza ya mwaka,\nwakati '2024/12/31' ingerejesha 366 kwa mwaka wa kuruka au 365 vinginevyo.\nIngizo: Kamba inayoonyesha tarehe katika muundo wa 'YYYY/MM/DD'.\nMatokeo: Nambari ya mzima inayowakilisha namba ya siku katika mwaka.",
      "tr": "Bir PHP fonksiyonu `function getDayOfYear($date): int` yazın ve aşağıdaki problemi çözün:\nVerilen bir tarih için yılın gün numarasını hesaplar.\nBu fonksiyon, 'YYYY/MM/DD' formatında bir tarih alır ve o tarihin yıl içindeki gün numarasını döndürür. Örneğin, '2024/01/01' yılı ilk gün olduğu için 1 döndürecektir, '2024/12/31' ise artık yıl için 366 veya aksi takdirde 365 döndürecektir.\nGirdi: 'YYYY/MM/DD' formatında tarihi temsil eden bir dize.\nÇıktı: Yıl içindeki gün numarasını temsil eden bir tamsayı.",
      "vi": "Viết một hàm PHP `function getDayOfYear($date): int` để giải quyết vấn đề sau:\nTính toán số thứ tự của ngày trong năm cho một ngày đã cho.\nHàm này nhận một ngày ở định dạng 'YYYY/MM/DD' và trả về số thứ tự của ngày\ntrong năm cho ngày đó. Ví dụ, '2024/01/01' sẽ trả về 1, vì đó là ngày đầu tiên của năm,\ntrong khi '2024/12/31' sẽ trả về 366 cho một năm nhuận hoặc 365 nếu không phải.\nĐầu vào: Một chuỗi đại diện cho ngày ở định dạng 'YYYY/MM/DD'.\nĐầu ra: Một số nguyên đại diện cho số thứ tự của ngày trong năm."
    },
    "instruction_bertscore": {
      "es": "0.9982449019531757",
      "arb": "0.9820326902531081",
      "sw": "0.9649171075800939",
      "tr": "0.9704904774415518",
      "vi": "0.9496388559316524"
    },
    "level": "easy",
    "test": "function main(){\n    assert(getDayOfYear('2024/01/01') === 1);\n    assert(getDayOfYear('2024/03/01') === 61); // Non-leap year\n    assert(getDayOfYear('2024/12/31') === 366); // Leap year\n    assert(getDayOfYear('2023/12/31') === 365); // Non-leap year\n    \n}\n\nmain();\n?>",
    "entry_point": "getDayOfYear",
    "signature": "function getDayOfYear($date): int",
    "docstring": {
      "en": "Calculates the day number of the year for a given date.\nThis function takes a date in the format 'YYYY/MM/DD' and returns the day number\nin the year for that date. For example, '2024/01/01' would return 1, as it is the first day of the year,\nwhile '2024/12/31' would return 366 for a leap year or 365 otherwise.\nInput: A string representing the date in 'YYYY/MM/DD' format.\nOutput: An integer representing the day number in the year.",
      "es": "Calcula el número de día del año para una fecha dada.\nEsta función toma una fecha en el formato 'YYYY/MM/DD' y devuelve el número de día\nen el año para esa fecha. Por ejemplo, '2024/01/01' devolvería 1, ya que es el primer día del año,\nmientras que '2024/12/31' devolvería 366 para un año bisiesto o 365 de lo contrario.\nEntrada: Una cadena que representa la fecha en formato 'YYYY/MM/DD'.\nSalida: Un entero que representa el número de día en el año.",
      "arb": "يحسب رقم اليوم في السنة لتاريخ معين.\nتأخذ هذه الدالة تاريخًا بتنسيق 'YYYY/MM/DD' وتعيد رقم اليوم\nفي السنة لذلك التاريخ. على سبيل المثال، '2024/01/01' ستعيد 1، لأنه اليوم الأول من السنة،\nبينما '2024/12/31' ستعيد 366 في سنة كبيسة أو 365 في غير ذلك.\nالمدخلات: سلسلة تمثل التاريخ بتنسيق 'YYYY/MM/DD'.\nالمخرجات: عدد صحيح يمثل رقم اليوم في السنة.",
      "sw": "Hesabu nambari ya siku ya mwaka kwa tarehe iliyotolewa.\nKazi hii inachukua tarehe katika muundo 'YYYY/MM/DD' na inarudisha nambari ya siku\nkatika mwaka kwa tarehe hiyo. Kwa mfano, '2024/01/01' itarudisha 1, kwani ni siku ya kwanza ya mwaka,\nwakati '2024/12/31' itarudisha 366 kwa mwaka wa kuruka au 365 vinginevyo.\nIngizo: Kamba inayowakilisha tarehe katika muundo wa 'YYYY/MM/DD'.\nPato: Nambari kamili inayowakilisha nambari ya siku katika mwaka.",
      "tr": "Yılın gün numarasını verilen bir tarih için hesaplar.\nBu fonksiyon, 'YYYY/MM/DD' formatında bir tarih alır ve o tarih için yılın gün numarasını döndürür. Örneğin, '2024/01/01' yılı ilk gün olduğu için 1 döndürürken, '2024/12/31' artık yıl için 366 veya aksi takdirde 365 döndürecektir.\nGirdi: 'YYYY/MM/DD' formatında tarihi temsil eden bir dize.\nÇıktı: Yıl içindeki gün numarasını temsil eden bir tamsayı.",
      "vi": "Tính toán số ngày trong năm cho một ngày cụ thể.  \nHàm này nhận một ngày theo định dạng 'YYYY/MM/DD' và trả về số ngày trong năm cho ngày đó. Ví dụ, '2024/01/01' sẽ trả về 1, vì đó là ngày đầu tiên của năm, trong khi '2024/12/31' sẽ trả về 366 cho một năm nhuận hoặc 365 nếu không phải.  \nĐầu vào: Một chuỗi đại diện cho ngày theo định dạng 'YYYY/MM/DD'.  \nĐầu ra: Một số nguyên đại diện cho số ngày trong năm.  "
    },
    "docstring_bertscore": {
      "es": "0.9926759019601006",
      "arb": "0.9717402597990233",
      "sw": "0.9864134833068327",
      "tr": "0.9575103793016839",
      "vi": "0.9423884497631169"
    }
  },
  {
    "task_id": "PHP/6",
    "prompt": {
      "en": "<?php\n/**\n    * Calculates the sum of all positive integers less than or equal to a given number N that are not 'related' to the number 2.\n    * A number is 'related' to 2 if it is divisible by 2 or if any of its digits is 2.\n    * For example, for N = 8, the numbers not related to 2 are 1, 3, 5, and 7, and their sum is 16.\n    * Input: An integer N.\n    * Output: Returns the sum of all integers less than or equal to N that are not related to 2.\n*/\n\nfunction sumOfUnrelatedToTwo($N) ",
      "es": "<?php\n/**\n    * Calcula la suma de todos los enteros positivos menores o iguales a un número dado N que no están 'relacionados' con el número 2.\n    * Un número está 'relacionado' con 2 si es divisible por 2 o si alguno de sus dígitos es 2.\n    * Por ejemplo, para N = 8, los números no relacionados con 2 son 1, 3, 5 y 7, y su suma es 16.\n    * Entrada: Un entero N.\n    * Salida: Devuelve la suma de todos los enteros menores o iguales a N que no están relacionados con 2.\n*/\n\nfunction sumOfUnrelatedToTwo($N) ",
      "arb": "<?php\n/**\n    * يحسب مجموع جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي عدد معين N والتي ليست 'مرتبطة' بالعدد 2.\n    * يكون العدد 'مرتبطًا' بالعدد 2 إذا كان قابلاً للقسمة على 2 أو إذا كان يحتوي على الرقم 2 في أي من أرقامه.\n    * على سبيل المثال، بالنسبة لـ N = 8، الأعداد غير المرتبطة بالعدد 2 هي 1، 3، 5، و7، ومجموعها هو 16.\n    * المدخل: عدد صحيح N.\n    * المخرج: يعيد مجموع جميع الأعداد الصحيحة الأقل من أو تساوي N والتي ليست مرتبطة بالعدد 2.\n*/\n\nfunction sumOfUnrelatedToTwo($N) ",
      "sw": "<?php\n/**\n    * Inahesabu jumla ya nambari zote nzima chanya zilizo chini au sawa na nambari fulani N ambazo hazihusiani na nambari 2.\n    * Nambari inahusiana na 2 ikiwa inagawanyika kwa 2 au ikiwa yoyote ya tarakimu zake ni 2.\n    * Kwa mfano, kwa N = 8, nambari ambazo hazihusiani na 2 ni 1, 3, 5, na 7, na jumla yao ni 16.\n    * Ingizo: Nambari nzima N.\n    * Matokeo: Inarudisha jumla ya nambari zote zilizo chini au sawa na N ambazo hazihusiani na 2.\n*/\n\nfunction sumOfUnrelatedToTwo($N) ",
      "tr": "<?php\n/**\n    * 2 ile 'ilişkili' olmayan, verilen bir sayı N'den küçük veya eşit olan tüm pozitif tam sayıların toplamını hesaplar.\n    * Bir sayı, 2'ye bölünebiliyorsa veya herhangi bir basamağı 2 ise 2 ile 'ilişkili' kabul edilir.\n    * Örneğin, N = 8 için, 2 ile ilişkili olmayan sayılar 1, 3, 5 ve 7'dir ve bunların toplamı 16'dır.\n    * Girdi: Bir tam sayı N.\n    * Çıktı: 2 ile ilişkili olmayan, N'den küçük veya eşit olan tüm tam sayıların toplamını döndürür.\n*/\n\nfunction sumOfUnrelatedToTwo($N) ",
      "vi": "<?php\n/**\n    * Tính tổng của tất cả các số nguyên dương nhỏ hơn hoặc bằng một số cho trước N mà không 'liên quan' đến số 2.\n    * Một số được coi là 'liên quan' đến 2 nếu nó chia hết cho 2 hoặc nếu bất kỳ chữ số nào của nó là 2.\n    * Ví dụ, với N = 8, các số không liên quan đến 2 là 1, 3, 5, và 7, và tổng của chúng là 16.\n    * Đầu vào: Một số nguyên N.\n    * Đầu ra: Trả về tổng của tất cả các số nguyên nhỏ hơn hoặc bằng N mà không liên quan đến 2.\n*/\n\nfunction sumOfUnrelatedToTwo($N) "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9698296341638487",
      "sw": "0.9736709471026824",
      "tr": "0.9925249428705141",
      "vi": "0.99306541613731"
    },
    "canonical_solution": "{\n    $sum = 0;\n    for ($i = 1; $i <= $N; $i++) {\n        if ($i % 2 != 0 && strpos((string)$i, '2') === false) {\n            $sum += $i;\n        }\n    }\n    return $sum;\n}",
    "instruction": {
      "en": "Write a PHP function `function sumOfUnrelatedToTwo($N)` to solve the following problem:\nCalculates the sum of all positive integers less than or equal to a given number N that are not 'related' to the number 2.\nA number is 'related' to 2 if it is divisible by 2 or if any of its digits is 2.\nFor example, for N = 8, the numbers not related to 2 are 1, 3, 5, and 7, and their sum is 16.\nInput: An integer N.\nOutput: Returns the sum of all integers less than or equal to N that are not related to 2.",
      "es": "Escribe una función PHP `function sumOfUnrelatedToTwo($N)` para resolver el siguiente problema:\nCalcula la suma de todos los enteros positivos menores o iguales a un número dado N que no están 'relacionados' con el número 2.\nUn número está 'relacionado' con 2 si es divisible por 2 o si alguno de sus dígitos es 2.\nPor ejemplo, para N = 8, los números no relacionados con 2 son 1, 3, 5 y 7, y su suma es 16.\nEntrada: Un entero N.\nSalida: Devuelve la suma de todos los enteros menores o iguales a N que no están relacionados con 2.",
      "arb": "اكتب دالة PHP `function sumOfUnrelatedToTwo($N)` لحل المشكلة التالية:\nتحسب مجموع جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي عدد معين N والتي ليست 'مرتبطة' بالرقم 2.\nيعتبر العدد 'مرتبطًا' بالرقم 2 إذا كان قابلاً للقسمة على 2 أو إذا كان يحتوي على الرقم 2 في أي من أرقامه.\nعلى سبيل المثال، بالنسبة لـ N = 8، الأعداد التي ليست مرتبطة بالرقم 2 هي 1، 3، 5، و7، ومجموعها هو 16.\nالمدخلات: عدد صحيح N.\nالمخرجات: تعيد مجموع جميع الأعداد الصحيحة الأقل من أو تساوي N والتي ليست مرتبطة بالرقم 2.",
      "sw": "Andika kazi ya PHP `function sumOfUnrelatedToTwo($N)` kutatua tatizo lifuatalo:\nHesabu jumla ya namba zote chanya zilizo chini au sawa na namba fulani N ambazo hazihusiani na namba 2.\nNamba inahusiana na 2 ikiwa inagawanyika kwa 2 au ikiwa yoyote ya tarakimu zake ni 2.\nKwa mfano, kwa N = 8, namba ambazo hazihusiani na 2 ni 1, 3, 5, na 7, na jumla yao ni 16.\nIngizo: Namba kamili N.\nMatokeo: Inarudisha jumla ya namba zote zilizo chini au sawa na N ambazo hazihusiani na 2.",
      "tr": "Bir PHP fonksiyonu `function sumOfUnrelatedToTwo($N)` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı N'den küçük veya ona eşit olan ve 2 ile 'ilişkili' olmayan tüm pozitif tam sayıların toplamını hesaplar.\nBir sayı, 2'ye bölünebiliyorsa veya herhangi bir basamağı 2 ise 2 ile 'ilişkilidir'.\nÖrneğin, N = 8 için, 2 ile ilişkili olmayan sayılar 1, 3, 5 ve 7'dir ve bunların toplamı 16'dır.\nGirdi: Bir tam sayı N.\nÇıktı: 2 ile ilişkili olmayan ve N'den küçük veya ona eşit olan tüm tam sayıların toplamını döndürür.",
      "vi": "Viết một hàm PHP `function sumOfUnrelatedToTwo($N)` để giải quyết vấn đề sau:\nTính tổng của tất cả các số nguyên dương nhỏ hơn hoặc bằng một số cho trước N mà không 'liên quan' đến số 2.\nMột số được coi là 'liên quan' đến 2 nếu nó chia hết cho 2 hoặc nếu bất kỳ chữ số nào của nó là 2.\nVí dụ, với N = 8, các số không liên quan đến 2 là 1, 3, 5 và 7, và tổng của chúng là 16.\nĐầu vào: Một số nguyên N.\nĐầu ra: Trả về tổng của tất cả các số nguyên nhỏ hơn hoặc bằng N mà không liên quan đến 2."
    },
    "instruction_bertscore": {
      "es": "0.998673347685068",
      "arb": "0.9675392272401354",
      "sw": "0.9600993276880927",
      "tr": "0.9806611474720622",
      "vi": "0.9918561543775696"
    },
    "level": "easy",
    "test": "function main(){\n    assert(sumOfUnrelatedToTwo(8) === 16);  // 1 + 3 + 5 + 7\n    assert(sumOfUnrelatedToTwo(10) === 25); // 1 + 3 + 5 + 7 + 9\n    assert(sumOfUnrelatedToTwo(2) === 1);   // 1\n    assert(sumOfUnrelatedToTwo(22) === 100); // Sum of numbers not containing 2 and not even, up to 22\n    assert(sumOfUnrelatedToTwo(0) === 0);   // No numbers to sum\n    \n}\n\n\nmain();\n?>",
    "entry_point": "sumOfUnrelatedToTwo",
    "signature": "function sumOfUnrelatedToTwo($N)",
    "docstring": {
      "en": "Calculates the sum of all positive integers less than or equal to a given number N that are not 'related' to the number 2.\nA number is 'related' to 2 if it is divisible by 2 or if any of its digits is 2.\nFor example, for N = 8, the numbers not related to 2 are 1, 3, 5, and 7, and their sum is 16.\nInput: An integer N.\nOutput: Returns the sum of all integers less than or equal to N that are not related to 2.",
      "es": "Calcula la suma de todos los enteros positivos menores o iguales a un número dado N que no están 'relacionados' con el número 2.  \nUn número está 'relacionado' con 2 si es divisible por 2 o si alguno de sus dígitos es 2.  \nPor ejemplo, para N = 8, los números no relacionados con 2 son 1, 3, 5 y 7, y su suma es 16.  \nEntrada: Un entero N.  \nSalida: Devuelve la suma de todos los enteros menores o iguales a N que no están relacionados con 2.",
      "arb": "يحسب مجموع جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي العدد المعطى N والتي ليست \"مرتبطة\" بالعدد 2.  \nيكون العدد \"مرتبطًا\" بالعدد 2 إذا كان قابلاً للقسمة على 2 أو إذا كان يحتوي على الرقم 2 في أي من أرقامه.  \nعلى سبيل المثال، بالنسبة لـ N = 8، الأعداد غير المرتبطة بالعدد 2 هي 1، 3، 5، و7، ومجموعها هو 16.  \n\nمدخل: عدد صحيح N.  \nمخرج: يعيد مجموع جميع الأعداد الصحيحة الأقل من أو تساوي N والتي ليست مرتبطة بالعدد 2.",
      "sw": "Hesabu jumla ya namba zote za mzima chanya ambazo ni ndogo au sawa na namba fulani N ambazo hazihusiani na namba 2. \nNamba inahusiana na 2 ikiwa inagawanyika kwa 2 au ikiwa mojawapo ya tarakimu zake ni 2. \nKwa mfano, kwa N = 8, namba ambazo hazihusiani na 2 ni 1, 3, 5, na 7, na jumla yao ni 16. \nIngizo: Namba ya mzima N. \nPato: Rejesha jumla ya namba zote ambazo ni ndogo au sawa na N ambazo hazihusiani na 2.",
      "tr": "Verilen bir sayı N'den küçük veya ona eşit olan ve 2 ile 'ilişkili' olmayan tüm pozitif tam sayıların toplamını hesaplar.\nBir sayı, 2'ye bölünebiliyorsa veya herhangi bir basamağı 2 ise 'ilişkili' kabul edilir.\nÖrneğin, N = 8 için, 2 ile ilişkili olmayan sayılar 1, 3, 5 ve 7'dir ve bunların toplamı 16'dır.\nGirdi: Bir tam sayı N.\nÇıktı: 2 ile ilişkili olmayan ve N'den küçük veya ona eşit olan tüm tam sayıların toplamını döndürür.",
      "vi": "Tính tổng của tất cả các số nguyên dương nhỏ hơn hoặc bằng một số cho trước N mà không 'liên quan' đến số 2.  \nMột số được coi là 'liên quan' đến 2 nếu nó chia hết cho 2 hoặc nếu bất kỳ chữ số nào của nó là 2.  \nVí dụ, với N = 8, các số không liên quan đến 2 là 1, 3, 5 và 7, và tổng của chúng là 16.  \nĐầu vào: Một số nguyên N.  \nĐầu ra: Trả về tổng của tất cả các số nguyên nhỏ hơn hoặc bằng N mà không liên quan đến 2."
    },
    "docstring_bertscore": {
      "es": "0.9979471550120045",
      "arb": "0.9438662597980164",
      "sw": "0.9486399437454279",
      "tr": "0.9727234801851461",
      "vi": "0.9912386125229321"
    }
  },
  {
    "task_id": "PHP/7",
    "prompt": {
      "en": "<?php\n\n/**\n    * Calculates the number of different ways to exchange a paper bill into coins.\n    * Given a paper bill of value N (1 <= N <= 10), there are two types of coins available: 1 and 2 units.\n    * The function determines how many distinct combinations of these coins can sum up to the value of the bill.\n    * Example: For a bill of value 4, there are 5 ways:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * Input: An integer representing the bill value.\n    * Output: Returns the number of different ways to exchange the bill into coins.\n*/\nfunction countCoinExchangeWays($billValue) ",
      "es": "<?php\n\n/**\n    * Calcula el número de diferentes maneras de cambiar un billete de papel en monedas.\n    * Dado un billete de valor N (1 <= N <= 10), hay dos tipos de monedas disponibles: 1 y 2 unidades.\n    * La función determina cuántas combinaciones distintas de estas monedas pueden sumar el valor del billete.\n    * Ejemplo: Para un billete de valor 4, hay 5 maneras:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * Entrada: Un entero que representa el valor del billete.\n    * Salida: Devuelve el número de diferentes maneras de cambiar el billete en monedas.\n*/\nfunction countCoinExchangeWays($billValue) ",
      "arb": "<?php\n\n/**\n    * يحسب عدد الطرق المختلفة لتحويل ورقة نقدية إلى عملات معدنية.\n    * بالنظر إلى ورقة نقدية بقيمة N (1 <= N <= 10)، هناك نوعان من العملات المتاحة: 1 و 2 وحدة.\n    * تحدد الدالة عدد التركيبات المميزة لهذه العملات التي يمكن أن تصل إلى قيمة الورقة النقدية.\n    * مثال: بالنسبة لورقة نقدية بقيمة 4، هناك 5 طرق:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * المدخل: عدد صحيح يمثل قيمة الورقة النقدية.\n    * المخرج: يعيد عدد الطرق المختلفة لتحويل الورقة النقدية إلى عملات معدنية.\n*/\nfunction countCoinExchangeWays($billValue) ",
      "sw": "<?php\n\n/**\n    * Inahesabu idadi ya njia tofauti za kubadilisha noti ya karatasi kuwa sarafu.\n    * Ukipewa noti ya karatasi yenye thamani ya N (1 <= N <= 10), kuna aina mbili za sarafu zinazopatikana: 1 na 2.\n    * Kazi hii inaamua ni mchanganyiko gani tofauti wa sarafu hizi unaweza kufikia thamani ya noti.\n    * Mfano: Kwa noti yenye thamani ya 4, kuna njia 5:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * Ingizo: Nambari nzima inayowakilisha thamani ya noti.\n    * Matokeo: Inarudisha idadi ya njia tofauti za kubadilisha noti kuwa sarafu.\n*/\nfunction countCoinExchangeWays($billValue) ",
      "tr": "<?php\n\n/**\n    * Bir kağıt parayı bozuk paralara çevirmenin farklı yollarının sayısını hesaplar.\n    * Değeri N olan bir kağıt para verildiğinde (1 <= N <= 10), iki tür bozuk para mevcuttur: 1 ve 2 birim.\n    * Fonksiyon, bu bozuk paraların kağıt paranın değerine eşit olacak şekilde kaç farklı kombinasyon oluşturabileceğini belirler.\n    * Örnek: Değeri 4 olan bir kağıt para için 5 yol vardır:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * Girdi: Kağıt para değerini temsil eden bir tamsayı.\n    * Çıktı: Kağıt parayı bozuk paralara çevirmenin farklı yollarının sayısını döndürür.\n*/\nfunction countCoinExchangeWays($billValue) ",
      "vi": "<?php\n\n/**\n    * Tính toán số cách khác nhau để đổi một tờ tiền giấy thành tiền xu.\n    * Cho một tờ tiền giấy có giá trị N (1 <= N <= 10), có hai loại tiền xu có sẵn: 1 và 2 đơn vị.\n    * Hàm xác định có bao nhiêu tổ hợp khác nhau của các đồng xu này có thể cộng lại thành giá trị của tờ tiền.\n    * Ví dụ: Đối với một tờ tiền có giá trị 4, có 5 cách:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * Đầu vào: Một số nguyên đại diện cho giá trị của tờ tiền.\n    * Đầu ra: Trả về số cách khác nhau để đổi tờ tiền thành tiền xu.\n*/\nfunction countCoinExchangeWays($billValue) "
    },
    "prompt_bertscore": {
      "es": "0.994454438391887",
      "arb": "0.9230005355310635",
      "sw": "0.9700638193830889",
      "tr": "0.9582216746961699",
      "vi": "0.9407829203932119"
    },
    "canonical_solution": "{\n    // Base case: When bill value is 0\n    if ($billValue == 1) {\n        return 1;\n    }\n\n    // When bill value becomes negative, no valid combination\n    if ($billValue == 2) {\n        return 2;\n    }\n\n    // Count combinations by subtracting 1 and 2 from the current bill value\n    return countCoinExchangeWays($billValue - 1) + countCoinExchangeWays($billValue - 2);\n}",
    "instruction": {
      "en": "Write a PHP function `function countCoinExchangeWays($billValue)` to solve the following problem:\nCalculates the number of different ways to exchange a paper bill into coins.\nGiven a paper bill of value N (1 <= N <= 10), there are two types of coins available: 1 and 2 units.\nThe function determines how many distinct combinations of these coins can sum up to the value of the bill.\nExample: For a bill of value 4, there are 5 ways:\n4 = 1 + 1 + 1 + 1\n4 = 2 + 1 + 1\n4 = 1 + 2 + 1\n4 = 1 + 1 + 2\n4 = 2 + 2\nInput: An integer representing the bill value.\nOutput: Returns the number of different ways to exchange the bill into coins.",
      "es": "Escribe una función PHP `function countCoinExchangeWays($billValue)` para resolver el siguiente problema:\nCalcula el número de diferentes maneras de cambiar un billete de papel en monedas.\nDado un billete de papel de valor N (1 <= N <= 10), hay dos tipos de monedas disponibles: 1 y 2 unidades.\nLa función determina cuántas combinaciones distintas de estas monedas pueden sumar el valor del billete.\nEjemplo: Para un billete de valor 4, hay 5 maneras:\n4 = 1 + 1 + 1 + 1\n4 = 2 + 1 + 1\n4 = 1 + 2 + 1\n4 = 1 + 1 + 2\n4 = 2 + 2\nEntrada: Un entero que representa el valor del billete.\nSalida: Devuelve el número de diferentes maneras de cambiar el billete en monedas.",
      "arb": "اكتب دالة PHP `function countCoinExchangeWays($billValue)` لحل المشكلة التالية:\nتحسب عدد الطرق المختلفة لتبادل ورقة نقدية إلى عملات معدنية.\nبالنظر إلى ورقة نقدية بقيمة N (1 <= N <= 10)، هناك نوعان من العملات المتاحة: 1 و 2 وحدة.\nتحدد الدالة عدد التركيبات المختلفة لهذه العملات التي يمكن أن تجمع لتصل إلى قيمة الورقة النقدية.\nمثال: بالنسبة لورقة نقدية بقيمة 4، هناك 5 طرق:\n4 = 1 + 1 + 1 + 1\n4 = 2 + 1 + 1\n4 = 1 + 2 + 1\n4 = 1 + 1 + 2\n4 = 2 + 2\nالمدخل: عدد صحيح يمثل قيمة الورقة النقدية.\nالمخرج: يعيد عدد الطرق المختلفة لتبادل الورقة النقدية إلى عملات معدنية.",
      "sw": "Andika kazi ya PHP `function countCoinExchangeWays($billValue)` kutatua tatizo lifuatalo:\nHesabu idadi ya njia tofauti za kubadilisha noti kuwa sarafu.\nUkipata noti ya thamani N (1 <= N <= 10), kuna aina mbili za sarafu zinazopatikana: 1 na 2.\nKazi hii inaamua ni mchanganyiko mingapi tofauti ya sarafu hizi inaweza kufikia thamani ya noti.\nMfano: Kwa noti ya thamani 4, kuna njia 5:\n4 = 1 + 1 + 1 + 1\n4 = 2 + 1 + 1\n4 = 1 + 2 + 1\n4 = 1 + 1 + 2\n4 = 2 + 2\nIngizo: Nambari kamili inayowakilisha thamani ya noti.\nMatokeo: Inarudisha idadi ya njia tofauti za kubadilisha noti kuwa sarafu.",
      "tr": "Bir PHP fonksiyonu `function countCoinExchangeWays($billValue)` yazın ve aşağıdaki problemi çözün:\nBir kağıt parayı bozuk paralara çevirmenin farklı yollarının sayısını hesaplar.\nDeğeri N olan bir kağıt para verildiğinde (1 <= N <= 10), iki tür bozuk para mevcuttur: 1 ve 2 birim.\nFonksiyon, bu bozuk paraların kağıt paranın değerine eşit olacak şekilde kaç farklı kombinasyon oluşturabileceğini belirler.\nÖrnek: Değeri 4 olan bir kağıt para için 5 yol vardır:\n4 = 1 + 1 + 1 + 1\n4 = 2 + 1 + 1\n4 = 1 + 2 + 1\n4 = 1 + 1 + 2\n4 = 2 + 2\nGirdi: Kağıt para değerini temsil eden bir tamsayı.\nÇıktı: Kağıt parayı bozuk paralara çevirmenin farklı yollarının sayısını döndürür.",
      "vi": "Viết một hàm PHP `function countCoinExchangeWays($billValue)` để giải quyết vấn đề sau:\nTính toán số lượng cách khác nhau để đổi một tờ tiền giấy thành tiền xu.\nCho một tờ tiền giấy có giá trị N (1 <= N <= 10), có hai loại tiền xu có sẵn: 1 và 2 đơn vị.\nHàm xác định có bao nhiêu tổ hợp khác biệt của các đồng xu này có thể cộng lại thành giá trị của tờ tiền giấy.\nVí dụ: Đối với một tờ tiền có giá trị 4, có 5 cách:\n4 = 1 + 1 + 1 + 1\n4 = 2 + 1 + 1\n4 = 1 + 2 + 1\n4 = 1 + 1 + 2\n4 = 2 + 2\nĐầu vào: Một số nguyên đại diện cho giá trị của tờ tiền giấy.\nĐầu ra: Trả về số lượng cách khác nhau để đổi tờ tiền giấy thành tiền xu."
    },
    "instruction_bertscore": {
      "es": "0.9956138439259876",
      "arb": "0.9674315695736145",
      "sw": "0.9579521332691056",
      "tr": "0.9603742321354449",
      "vi": "0.9740151735530159"
    },
    "level": "easy",
    "test": "function main(){\n    assert(countCoinExchangeWays(4) === 5);\n    assert(countCoinExchangeWays(3) === 3);\n    assert(countCoinExchangeWays(2) === 2);\n    assert(countCoinExchangeWays(1) === 1);\n}\n\nmain();\n?>",
    "entry_point": "countCoinExchangeWays",
    "signature": "function countCoinExchangeWays($billValue)",
    "docstring": {
      "en": "Calculates the number of different ways to exchange a paper bill into coins.\nGiven a paper bill of value N (1 <= N <= 10), there are two types of coins available: 1 and 2 units.\nThe function determines how many distinct combinations of these coins can sum up to the value of the bill.\nExample: For a bill of value 4, there are 5 ways:\n4 = 1 + 1 + 1 + 1\n4 = 2 + 1 + 1\n4 = 1 + 2 + 1\n4 = 1 + 1 + 2\n4 = 2 + 2\nInput: An integer representing the bill value.\nOutput: Returns the number of different ways to exchange the bill into coins.",
      "es": "Calcula el número de diferentes maneras de cambiar un billete de papel en monedas.  \nDado un billete de valor N (1 <= N <= 10), hay dos tipos de monedas disponibles: 1 y 2 unidades.  \nLa función determina cuántas combinaciones distintas de estas monedas pueden sumar el valor del billete.  \nEjemplo: Para un billete de valor 4, hay 5 maneras:  \n4 = 1 + 1 + 1 + 1  \n4 = 2 + 1 + 1  \n4 = 1 + 2 + 1  \n4 = 1 + 1 + 2  \n4 = 2 + 2  \nEntrada: Un entero que representa el valor del billete.  \nSalida: Devuelve el número de diferentes maneras de cambiar el billete en monedas.",
      "arb": "يحسب عدد الطرق المختلفة لتحويل ورقة نقدية إلى عملات معدنية.  \nبالنظر إلى ورقة نقدية بقيمة N (1 <= N <= 10)، هناك نوعان من العملات المتاحة: 1 و 2 وحدة.  \nتحدد الدالة عدد التركيبات المميزة لهذه العملات التي يمكن أن تصل إلى قيمة الورقة النقدية.  \nمثال: بالنسبة لورقة نقدية بقيمة 4، هناك 5 طرق:  \n4 = 1 + 1 + 1 + 1  \n4 = 2 + 1 + 1  \n4 = 1 + 2 + 1  \n4 = 1 + 1 + 2  \n4 = 2 + 2  \nالمدخل: عدد صحيح يمثل قيمة الورقة النقدية.  \nالمخرج: يعيد عدد الطرق المختلفة لتحويل الورقة النقدية إلى عملات معدنية.  ",
      "sw": "Hesabu idadi ya njia tofauti za kubadilisha noti ya karatasi kuwa sarafu. \nKwa kuzingatia noti ya karatasi yenye thamani N (1 <= N <= 10), kuna aina mbili za sarafu zinazopatikana: 1 na 2. \nKazi hii inaamua ni mchanganyiko gani tofauti wa sarafu hizi unaweza kufikia thamani ya noti hiyo. \nMfano: Kwa noti yenye thamani ya 4, kuna njia 5: \n4 = 1 + 1 + 1 + 1 \n4 = 2 + 1 + 1 \n4 = 1 + 2 + 1 \n4 = 1 + 1 + 2 \n4 = 2 + 2 \nIngizo: Nambari ya mzima inayowakilisha thamani ya noti. \nMatokeo: Inarudisha idadi ya njia tofauti za kubadilisha noti kuwa sarafu.",
      "tr": "Kağıt parayı bozuk paralara çevirmenin farklı yollarının sayısını hesaplar.\nDeğeri N olan bir kağıt para verildiğinde (1 <= N <= 10), iki tür bozuk para mevcuttur: 1 ve 2 birim.\nFonksiyon, bu bozuk paraların kağıt paranın değerine eşit olacak şekilde kaç farklı kombinasyon oluşturabileceğini belirler.\nÖrnek: Değeri 4 olan bir kağıt para için 5 yol vardır:\n4 = 1 + 1 + 1 + 1\n4 = 2 + 1 + 1\n4 = 1 + 2 + 1\n4 = 1 + 1 + 2\n4 = 2 + 2\nGirdi: Kağıt para değerini temsil eden bir tamsayı.\nÇıktı: Parayı bozuk paralara çevirmenin farklı yollarının sayısını döndürür.",
      "vi": "Tính toán số cách khác nhau để đổi một tờ tiền giấy thành tiền xu.  \nCho một tờ tiền giấy có giá trị N (1 <= N <= 10), có hai loại tiền xu có sẵn: 1 và 2 đơn vị.  \nHàm xác định có bao nhiêu tổ hợp khác nhau của các đồng xu này có thể cộng lại thành giá trị của tờ tiền giấy.  \nVí dụ: Đối với một tờ tiền có giá trị 4, có 5 cách:  \n4 = 1 + 1 + 1 + 1  \n4 = 2 + 1 + 1  \n4 = 1 + 2 + 1  \n4 = 1 + 1 + 2  \n4 = 2 + 2  \n\nĐầu vào: Một số nguyên đại diện cho giá trị của tờ tiền giấy.  \nĐầu ra: Trả về số cách khác nhau để đổi tờ tiền giấy thành tiền xu.  "
    },
    "docstring_bertscore": {
      "es": "0.9823427522779036",
      "arb": "0.909584046444062",
      "sw": "0.9111138976387927",
      "tr": "0.916251273813879",
      "vi": "0.9233650222802625"
    }
  },
  {
    "task_id": "PHP/8",
    "prompt": {
      "en": "<?php\n\n/**\n * Compares two playing cards to determine which one is higher based on a given trump suit.\n * In this game, each card is represented by its suit and rank (e.g., '8D', 'QS').\n * The trump suit is one of the four suits: Spades (S), Hearts (H), Diamonds (D), or Clubs (C).\n * The rules for comparison are as follows:\n * - If neither card is of the trump suit, the card with the higher rank wins.\n * - If both cards are of the trump suit, the card with the higher rank wins.\n * - If one card is of the trump suit and the other is not, the trump suit card wins regardless of rank.\n * - If both cards have the same rank, the result is a draw.\n * Input: The trump suit and two card strings.\n * Output: Returns 1 if the first card wins, -1 if the second card wins, and 0 for a draw.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) ",
      "es": "<?php\n\n/**\n * Compara dos cartas para determinar cuál es más alta basándose en un palo de triunfo dado.\n * En este juego, cada carta está representada por su palo y rango (por ejemplo, '8D', 'QS').\n * El palo de triunfo es uno de los cuatro palos: Espadas (S), Corazones (H), Diamantes (D) o Tréboles (C).\n * Las reglas para la comparación son las siguientes:\n * - Si ninguna de las cartas es del palo de triunfo, la carta con el rango más alto gana.\n * - Si ambas cartas son del palo de triunfo, la carta con el rango más alto gana.\n * - Si una carta es del palo de triunfo y la otra no, la carta del palo de triunfo gana independientemente del rango.\n * - Si ambas cartas tienen el mismo rango, el resultado es un empate.\n * Entrada: El palo de triunfo y dos cadenas de cartas.\n * Salida: Devuelve 1 si la primera carta gana, -1 si la segunda carta gana, y 0 para un empate.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) ",
      "arb": "<?php\n\n/**\n * يقارن بين ورقتين لعب لتحديد أيهما أعلى بناءً على نوع الورقة الرابحة المعطى.\n * في هذه اللعبة، يتم تمثيل كل ورقة بنوعها ورتبتها (مثل '8D', 'QS').\n * نوع الورقة الرابحة هو واحد من الأنواع الأربعة: البستوني (S)، القلوب (H)، الألماس (D)، أو النوادي (C).\n * القواعد للمقارنة هي كما يلي:\n * - إذا لم تكن أي من الورقتين من نوع الورقة الرابحة، تفوز الورقة ذات الرتبة الأعلى.\n * - إذا كانت كلتا الورقتين من نوع الورقة الرابحة، تفوز الورقة ذات الرتبة الأعلى.\n * - إذا كانت إحدى الورقتين من نوع الورقة الرابحة والأخرى ليست كذلك، تفوز الورقة من نوع الورقة الرابحة بغض النظر عن الرتبة.\n * - إذا كانت كلتا الورقتين لهما نفس الرتبة، تكون النتيجة تعادل.\n * المدخلات: نوع الورقة الرابحة وسلسلتان تمثلان الورقتين.\n * المخرجات: يعيد 1 إذا فازت الورقة الأولى، -1 إذا فازت الورقة الثانية، و0 في حالة التعادل.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) ",
      "sw": "<?php\n\n/**\n * Inalinganisha kadi mbili za kucheza ili kubaini ipi ni ya juu zaidi kulingana na suti ya trump iliyotolewa.\n * Katika mchezo huu, kila kadi inawakilishwa na suti na cheo chake (mfano, '8D', 'QS').\n * Suti ya trump ni moja ya suti nne: Spades (S), Hearts (H), Diamonds (D), au Clubs (C).\n * Sheria za kulinganisha ni kama ifuatavyo:\n * - Ikiwa hakuna kadi iliyo na suti ya trump, kadi iliyo na cheo cha juu inashinda.\n * - Ikiwa kadi zote mbili zina suti ya trump, kadi iliyo na cheo cha juu inashinda.\n * - Ikiwa kadi moja ina suti ya trump na nyingine haina, kadi yenye suti ya trump inashinda bila kujali cheo.\n * - Ikiwa kadi zote mbili zina cheo sawa, matokeo ni sare.\n * Ingizo: Suti ya trump na kamba mbili za kadi.\n * Tokeo: Inarejesha 1 ikiwa kadi ya kwanza inashinda, -1 ikiwa kadi ya pili inashinda, na 0 kwa sare.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) ",
      "tr": "<?php\n\n/**\n * İki oyun kartını, verilen koz rengini temel alarak hangisinin daha yüksek olduğunu belirlemek için karşılaştırır.\n * Bu oyunda, her kart rengi ve rütbesi ile temsil edilir (örneğin, '8D', 'QS').\n * Koz rengi dört renkten biridir: Maça (S), Kupa (H), Karo (D) veya Sinek (C).\n * Karşılaştırma kuralları aşağıdaki gibidir:\n * - Eğer hiçbir kart koz renginde değilse, daha yüksek rütbeye sahip kart kazanır.\n * - Eğer her iki kart da koz rengindeyse, daha yüksek rütbeye sahip kart kazanır.\n * - Eğer bir kart koz rengindeyse ve diğeri değilse, rütbesi ne olursa olsun koz rengindeki kart kazanır.\n * - Eğer her iki kartın da rütbesi aynıysa, sonuç beraberedir.\n * Girdi: Koz rengi ve iki kart dizgesi.\n * Çıktı: İlk kart kazanırsa 1, ikinci kart kazanırsa -1 ve beraberlik için 0 döner.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) ",
      "vi": "<?php\n\n/**\n * So sánh hai lá bài để xác định lá nào cao hơn dựa trên chất chủ bài đã cho.\n * Trong trò chơi này, mỗi lá bài được biểu diễn bằng chất và hạng của nó (ví dụ, '8D', 'QS').\n * Chất chủ bài là một trong bốn chất: Bích (S), Cơ (H), Rô (D), hoặc Chuồn (C).\n * Các quy tắc so sánh như sau:\n * - Nếu không có lá bài nào thuộc chất chủ bài, lá bài có hạng cao hơn sẽ thắng.\n * - Nếu cả hai lá bài đều thuộc chất chủ bài, lá bài có hạng cao hơn sẽ thắng.\n * - Nếu một lá bài thuộc chất chủ bài và lá kia không, lá bài thuộc chất chủ bài sẽ thắng bất kể hạng.\n * - Nếu cả hai lá bài có cùng hạng, kết quả là hòa.\n * Đầu vào: Chất chủ bài và hai chuỗi lá bài.\n * Đầu ra: Trả về 1 nếu lá bài thứ nhất thắng, -1 nếu lá bài thứ hai thắng, và 0 cho hòa.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) "
    },
    "prompt_bertscore": {
      "es": "0.987275141899762",
      "arb": "0.979862653340302",
      "sw": "0.9765061971615745",
      "tr": "0.981570675986821",
      "vi": "0.9670766170827052"
    },
    "canonical_solution": "{\n    // Function to convert card rank to numerical value\n    $getNumericRank = function($card) {\n        $rank = substr($card, 0, -1);\n        switch ($rank) {\n            case 'A': return 14;\n            case 'K': return 13;\n            case 'Q': return 12;\n            case 'J': return 11;\n            default: return intval($rank);\n        }\n    };\n\n    $rank1 = $getNumericRank($card1);\n    $rank2 = $getNumericRank($card2);\n    $suit1 = substr($card1, -1);\n    $suit2 = substr($card2, -1);\n\n    $isTrump1 = $suit1 === $trumpSuit;\n    $isTrump2 = $suit2 === $trumpSuit;\n\n    if ($isTrump1 && !$isTrump2) {\n        return 1;\n    } elseif (!$isTrump1 && $isTrump2) {\n        return -1;\n    } elseif ($rank1 === $rank2) {\n        return 0;\n    } elseif ($rank1 > $rank2) {\n        return 1;\n    } else {\n        return -1;\n    }\n}",
    "instruction": {
      "en": "Write a PHP function `function compareCards($trumpSuit, $card1, $card2)` to solve the following problem:\nCompares two playing cards to determine which one is higher based on a given trump suit.\nIn this game, each card is represented by its suit and rank (e.g., '8D', 'QS').\nThe trump suit is one of the four suits: Spades (S), Hearts (H), Diamonds (D), or Clubs (C).\nThe rules for comparison are as follows:\n- If neither card is of the trump suit, the card with the higher rank wins.\n- If both cards are of the trump suit, the card with the higher rank wins.\n- If one card is of the trump suit and the other is not, the trump suit card wins regardless of rank.\n- If both cards have the same rank, the result is a draw.\nInput: The trump suit and two card strings.\nOutput: Returns 1 if the first card wins, -1 if the second card wins, and 0 for a draw.",
      "es": "Escribe una función PHP `function compareCards($trumpSuit, $card1, $card2)` para resolver el siguiente problema:\nCompara dos cartas de juego para determinar cuál es más alta basándose en un palo de triunfo dado.\nEn este juego, cada carta está representada por su palo y rango (por ejemplo, '8D', 'QS').\nEl palo de triunfo es uno de los cuatro palos: Picas (S), Corazones (H), Diamantes (D) o Tréboles (C).\nLas reglas para la comparación son las siguientes:\n- Si ninguna de las cartas es del palo de triunfo, la carta con el rango más alto gana.\n- Si ambas cartas son del palo de triunfo, la carta con el rango más alto gana.\n- Si una carta es del palo de triunfo y la otra no, la carta del palo de triunfo gana independientemente del rango.\n- Si ambas cartas tienen el mismo rango, el resultado es un empate.\nEntrada: El palo de triunfo y dos cadenas de cartas.\nSalida: Devuelve 1 si la primera carta gana, -1 si la segunda carta gana, y 0 para un empate.",
      "arb": "اكتب دالة PHP `function compareCards($trumpSuit, $card1, $card2)` لحل المشكلة التالية:\nيقارن بين ورقتين لعب لتحديد أيهما أعلى بناءً على رمز الطرومب المحدد.\nفي هذه اللعبة، يتم تمثيل كل ورقة لعب برمزها ورتبتها (مثل، '8D', 'QS').\nرمز الطرومب هو واحد من الأربعة رموز: البستوني (S)، القلوب (H)، الألماس (D)، أو النوادي (C).\nالقواعد للمقارنة هي كما يلي:\n- إذا لم تكن أي من الورقتين من رمز الطرومب، الورقة ذات الرتبة الأعلى تفوز.\n- إذا كانت كلتا الورقتين من رمز الطرومب، الورقة ذات الرتبة الأعلى تفوز.\n- إذا كانت إحدى الورقتين من رمز الطرومب والأخرى ليست كذلك، الورقة من رمز الطرومب تفوز بغض النظر عن الرتبة.\n- إذا كانت كلتا الورقتين لهما نفس الرتبة، النتيجة تعادل.\nالمدخلات: رمز الطرومب وسلسلتين تمثلان الورقتين.\nالمخرجات: تعيد 1 إذا فازت الورقة الأولى، -1 إذا فازت الورقة الثانية، و0 في حالة التعادل.",
      "sw": "Andika kazi ya PHP `function compareCards($trumpSuit, $card1, $card2)` kutatua tatizo lifuatalo:\nInalinganisha kadi mbili za kucheza ili kubaini ipi ni ya juu zaidi kulingana na suti ya trump iliyotolewa.\nKatika mchezo huu, kila kadi inawakilishwa na suti yake na cheo (mfano, '8D', 'QS').\nSuti ya trump ni moja ya suti nne: Spades (S), Hearts (H), Diamonds (D), au Clubs (C).\nSheria za kulinganisha ni kama ifuatavyo:\n- Ikiwa hakuna kadi yoyote ni ya suti ya trump, kadi yenye cheo cha juu inashinda.\n- Ikiwa kadi zote mbili ni za suti ya trump, kadi yenye cheo cha juu inashinda.\n- Ikiwa kadi moja ni ya suti ya trump na nyingine siyo, kadi ya suti ya trump inashinda bila kujali cheo.\n- Ikiwa kadi zote mbili zina cheo sawa, matokeo ni sare.\nIngizo: Suti ya trump na mistari miwili ya kadi.\nMatokeo: Inarudisha 1 ikiwa kadi ya kwanza inashinda, -1 ikiwa kadi ya pili inashinda, na 0 kwa sare.",
      "tr": "Bir PHP fonksiyonu `function compareCards($trumpSuit, $card1, $card2)` yazın ve aşağıdaki problemi çözün:\nBelirli bir koz rengini temel alarak hangi kartın daha yüksek olduğunu belirlemek için iki oyun kartını karşılaştırır.\nBu oyunda, her kart rengi ve rütbesi ile temsil edilir (örneğin, '8D', 'QS').\nKoz rengi dört renkten biridir: Maça (S), Kupa (H), Karo (D) veya Sinek (C).\nKarşılaştırma kuralları aşağıdaki gibidir:\n- Hiçbir kart koz renginde değilse, daha yüksek rütbeye sahip kart kazanır.\n- Her iki kart da koz rengindeyse, daha yüksek rütbeye sahip kart kazanır.\n- Bir kart koz rengindeyse ve diğeri değilse, rütbe ne olursa olsun koz rengi kart kazanır.\n- Her iki kartın da rütbesi aynıysa, sonuç beraberedir.\nGirdi: Koz rengi ve iki kart dizgesi.\nÇıktı: İlk kart kazanırsa 1, ikinci kart kazanırsa -1 ve beraberlik için 0 döndürür.",
      "vi": "Viết một hàm PHP `function compareCards($trumpSuit, $card1, $card2)` để giải quyết vấn đề sau:\nSo sánh hai lá bài để xác định lá nào cao hơn dựa trên chất chủ bài đã cho.\nTrong trò chơi này, mỗi lá bài được biểu diễn bằng chất và hạng của nó (ví dụ: '8D', 'QS').\nChất chủ bài là một trong bốn chất: Bích (S), Cơ (H), Rô (D), hoặc Chuồn (C).\nCác quy tắc so sánh như sau:\n- Nếu không có lá bài nào thuộc chất chủ bài, lá bài có hạng cao hơn sẽ thắng.\n- Nếu cả hai lá bài đều thuộc chất chủ bài, lá bài có hạng cao hơn sẽ thắng.\n- Nếu một lá bài thuộc chất chủ bài và lá kia không thuộc, lá bài thuộc chất chủ bài sẽ thắng bất kể hạng.\n- Nếu cả hai lá bài có cùng hạng, kết quả là hòa.\nĐầu vào: Chất chủ bài và hai chuỗi lá bài.\nĐầu ra: Trả về 1 nếu lá bài thứ nhất thắng, -1 nếu lá bài thứ hai thắng, và 0 cho hòa."
    },
    "instruction_bertscore": {
      "es": "0.9845985975153169",
      "arb": "0.9689886331305471",
      "sw": "0.989774507984324",
      "tr": "0.9839890008759208",
      "vi": "0.9787618437686066"
    },
    "level": "hard",
    "test": "function main(){\n    assert(compareCards('S', '8D', '3S') === -1); \n    assert(compareCards('S', '8D', '9S') === -1); // Non-trump vs trump\n    assert(compareCards('H', '8H', '7H') === 1);  // Both trump, first higher\n    assert(compareCards('D', '9C', '9S') === 0);  // Same rank, non-trump\n    assert(compareCards('C', 'QH', 'JS') === 1);  // Neither trump, first higher\n    assert(compareCards('D', 'KD', 'AD') === -1); // Both trump, second higher\n\n}\nmain();\n?>",
    "entry_point": "compareCards",
    "signature": "function compareCards($trumpSuit, $card1, $card2)",
    "docstring": {
      "en": "Compares two playing cards to determine which one is higher based on a given trump suit.\nIn this game, each card is represented by its suit and rank (e.g., '8D', 'QS').\nThe trump suit is one of the four suits: Spades (S), Hearts (H), Diamonds (D), or Clubs (C).\nThe rules for comparison are as follows:\n- If neither card is of the trump suit, the card with the higher rank wins.\n- If both cards are of the trump suit, the card with the higher rank wins.\n- If one card is of the trump suit and the other is not, the trump suit card wins regardless of rank.\n- If both cards have the same rank, the result is a draw.\nInput: The trump suit and two card strings.\nOutput: Returns 1 if the first card wins, -1 if the second card wins, and 0 for a draw.",
      "es": "Compara dos cartas de juego para determinar cuál es más alta basándose en un palo de triunfo dado.  \nEn este juego, cada carta está representada por su palo y rango (por ejemplo, '8D', 'QS').  \nEl palo de triunfo es uno de los cuatro palos: Picas (S), Corazones (H), Diamantes (D) o Tréboles (C).  \nLas reglas para la comparación son las siguientes:  \n- Si ninguna de las cartas es del palo de triunfo, la carta con el rango más alto gana.  \n- Si ambas cartas son del palo de triunfo, la carta con el rango más alto gana.  \n- Si una carta es del palo de triunfo y la otra no, la carta del palo de triunfo gana independientemente del rango.  \n- Si ambas cartas tienen el mismo rango, el resultado es un empate.  \nEntrada: El palo de triunfo y dos cadenas de cartas.  \nSalida: Devuelve 1 si la primera carta gana, -1 si la segunda carta gana, y 0 para un empate.",
      "arb": "يقارن بين ورقتين لعب لتحديد أيهما أعلى بناءً على نوع الورقة الرابحة المعطى.  \nفي هذه اللعبة، يتم تمثيل كل ورقة بنوعها ورتبتها (مثل '8D', 'QS').  \nنوع الورقة الرابحة هو واحد من الأنواع الأربعة: البستوني (S)، القلوب (H)، الألماس (D)، أو النوادي (C).  \nالقواعد للمقارنة هي كما يلي:  \n- إذا لم تكن أي من الورقتين من نوع الورقة الرابحة، تفوز الورقة ذات الرتبة الأعلى.  \n- إذا كانت كلتا الورقتين من نوع الورقة الرابحة، تفوز الورقة ذات الرتبة الأعلى.  \n- إذا كانت إحدى الورقتين من نوع الورقة الرابحة والأخرى ليست كذلك، تفوز الورقة من نوع الورقة الرابحة بغض النظر عن الرتبة.  \n- إذا كانت كلتا الورقتين لهما نفس الرتبة، تكون النتيجة تعادل.  \nالمدخلات: نوع الورقة الرابحة وسلسلتان نصيتان تمثلان الورقتين.  \nالمخرجات: يعيد 1 إذا فازت الورقة الأولى، -1 إذا فازت الورقة الثانية، و0 للتعادل.",
      "sw": "Inalinganisha kadi mbili za kucheza ili kubaini ipi ni ya juu zaidi kulingana na rangi ya trump iliyotolewa. Katika mchezo huu, kila kadi inawakilishwa na rangi na cheo chake (mfano, '8D', 'QS'). Rangi ya trump ni moja ya rangi nne: Spades (S), Hearts (H), Diamonds (D), au Clubs (C). Sheria za kulinganisha ni kama ifuatavyo: - Ikiwa hakuna kadi yoyote ni ya rangi ya trump, kadi yenye cheo cha juu inashinda. - Ikiwa kadi zote mbili ni za rangi ya trump, kadi yenye cheo cha juu inashinda. - Ikiwa kadi moja ni ya rangi ya trump na nyingine siyo, kadi ya rangi ya trump inashinda bila kujali cheo. - Ikiwa kadi zote mbili zina cheo sawa, matokeo ni sare. Ingizo: Rangi ya trump na kamba mbili za kadi. Tokeo: Inarudisha 1 ikiwa kadi ya kwanza inashinda, -1 ikiwa kadi ya pili inashinda, na 0 kwa sare.",
      "tr": "Belirtilen koz rengine göre hangi kartın daha yüksek olduğunu belirlemek için iki iskambil kartını karşılaştırır.\nBu oyunda, her kart kendi rengi ve değeri ile temsil edilir (örneğin, '8D', 'QS').\nKoz rengi dört renkten biridir: Maça (S), Kupa (H), Karo (D) veya Sinek (C).\nKarşılaştırma kuralları aşağıdaki gibidir:\n- Hiçbir kart koz renginde değilse, daha yüksek değere sahip kart kazanır.\n- Her iki kart da koz rengindeyse, daha yüksek değere sahip kart kazanır.\n- Bir kart koz renginde ve diğeri değilse, koz rengindeki kart değerine bakılmaksızın kazanır.\n- Her iki kartın da değeri aynıysa, sonuç beraberedir.\nGirdi: Koz rengi ve iki kart dizgesi.\nÇıktı: İlk kart kazanırsa 1, ikinci kart kazanırsa -1 ve beraberlik için 0 döner.",
      "vi": "So sánh hai lá bài để xác định lá nào cao hơn dựa trên chất chủ bài đã cho. Trong trò chơi này, mỗi lá bài được biểu diễn bằng chất và hạng của nó (ví dụ: '8D', 'QS'). Chất chủ bài là một trong bốn chất: Bích (S), Cơ (H), Rô (D), hoặc Chuồn (C). Các quy tắc so sánh như sau: \n- Nếu không lá bài nào thuộc chất chủ bài, lá bài có hạng cao hơn sẽ thắng. \n- Nếu cả hai lá bài đều thuộc chất chủ bài, lá bài có hạng cao hơn sẽ thắng. \n- Nếu một lá bài thuộc chất chủ bài và lá kia không thuộc, lá bài thuộc chất chủ bài sẽ thắng bất kể hạng. \n- Nếu cả hai lá bài có cùng hạng, kết quả là hòa. \nĐầu vào: Chất chủ bài và hai chuỗi ký tự biểu diễn lá bài. \nĐầu ra: Trả về 1 nếu lá bài thứ nhất thắng, -1 nếu lá bài thứ hai thắng, và 0 cho kết quả hòa."
    },
    "docstring_bertscore": {
      "es": "0.9814906279432639",
      "arb": "0.9802044962260631",
      "sw": "0.9919161407526421",
      "tr": "0.9536416553702675",
      "vi": "0.9581360650019438"
    }
  },
  {
    "task_id": "PHP/9",
    "prompt": {
      "en": "<?php\n\n/**\n    * This function calculates the minimum number of 6x6xh packages required to ship an order of products of various sizes.\n    * The sizes of the products range from 1x1 to 6x6, and each product requires a certain amount of space in the package.\n    * The goal is to efficiently pack these products to minimize the number of packages, reducing shipping costs.\n    *\n    * Input: Six integers ($a, $b, $c, $d, $e, $f), each representing the quantity of products from size 1x1 to 6x6.\n    * Output: An integer representing the minimum number of 6x6xh packages required to ship the order.\n    *\n    * Example:\n    * For an order with 1 product of size 1x1, 2 products of size 2x2, and 1 product of size 3x3,\n    * the function will calculate and return the minimum number of packages needed.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int ",
      "es": "<?php\n\n/**\n    * Esta función calcula el número mínimo de paquetes de 6x6xh necesarios para enviar un pedido de productos de varios tamaños.\n    * Los tamaños de los productos varían de 1x1 a 6x6, y cada producto requiere una cierta cantidad de espacio en el paquete.\n    * El objetivo es empaquetar estos productos de manera eficiente para minimizar el número de paquetes, reduciendo los costos de envío.\n    *\n    * Entrada: Seis enteros ($a, $b, $c, $d, $e, $f), cada uno representando la cantidad de productos de tamaño 1x1 a 6x6.\n    * Salida: Un entero que representa el número mínimo de paquetes de 6x6xh necesarios para enviar el pedido.\n    *\n    * Ejemplo:\n    * Para un pedido con 1 producto de tamaño 1x1, 2 productos de tamaño 2x2, y 1 producto de tamaño 3x3,\n    * la función calculará y devolverá el número mínimo de paquetes necesarios.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int ",
      "arb": "<?php\n\n/**\n    * تقوم هذه الدالة بحساب الحد الأدنى لعدد الطرود ذات الحجم 6x6xh المطلوبة لشحن طلب من المنتجات ذات الأحجام المختلفة.\n    * تتراوح أحجام المنتجات من 1x1 إلى 6x6، وكل منتج يحتاج إلى مساحة معينة في الطرد.\n    * الهدف هو تعبئة هذه المنتجات بكفاءة لتقليل عدد الطرود، مما يقلل من تكاليف الشحن.\n    *\n    * المدخلات: ستة أعداد صحيحة ($a, $b, $c, $d, $e, $f)، كل منها يمثل كمية المنتجات من الحجم 1x1 إلى 6x6.\n    * المخرجات: عدد صحيح يمثل الحد الأدنى لعدد الطرود ذات الحجم 6x6xh المطلوبة لشحن الطلب.\n    *\n    * مثال:\n    * لطلب يحتوي على 1 منتج بحجم 1x1، و2 منتجات بحجم 2x2، و1 منتج بحجم 3x3،\n    * ستقوم الدالة بحساب وإرجاع الحد الأدنى لعدد الطرود المطلوبة.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int ",
      "sw": "<?php\n\n/**\n    * Kazi ya hii kazi ni kuhesabu idadi ndogo ya vifurushi vya 6x6xh vinavyohitajika kusafirisha oda ya bidhaa za ukubwa mbalimbali.\n    * Ukubwa wa bidhaa ni kati ya 1x1 hadi 6x6, na kila bidhaa inahitaji kiasi fulani cha nafasi ndani ya kifurushi.\n    * Lengo ni kupakia bidhaa hizi kwa ufanisi ili kupunguza idadi ya vifurushi, na hivyo kupunguza gharama za usafirishaji.\n    *\n    * Ingizo: Nambari sita ($a, $b, $c, $d, $e, $f), kila moja ikiwakilisha idadi ya bidhaa kutoka ukubwa wa 1x1 hadi 6x6.\n    * Tokeo: Nambari inayoashiria idadi ndogo ya vifurushi vya 6x6xh vinavyohitajika kusafirisha oda.\n    *\n    * Mfano:\n    * Kwa oda yenye bidhaa 1 ya ukubwa 1x1, bidhaa 2 za ukubwa 2x2, na bidhaa 1 ya ukubwa 3x3,\n    * kazi hii itahesabu na kurudisha idadi ndogo ya vifurushi vinavyohitajika.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int ",
      "tr": "<?php\n\n/**\n    * Bu fonksiyon, çeşitli boyutlardaki ürünlerin bir siparişini göndermek için gereken minimum 6x6xh paket sayısını hesaplar.\n    * Ürünlerin boyutları 1x1'den 6x6'ya kadar değişir ve her ürün pakette belirli bir miktar alan gerektirir.\n    * Amaç, bu ürünleri verimli bir şekilde paketleyerek paket sayısını en aza indirmek ve nakliye maliyetlerini azaltmaktır.\n    *\n    * Girdi: 1x1'den 6x6'ya kadar boyutlardaki ürünlerin miktarını temsil eden altı tamsayı ($a, $b, $c, $d, $e, $f).\n    * Çıktı: Siparişi göndermek için gereken minimum 6x6xh paket sayısını temsil eden bir tamsayı.\n    *\n    * Örnek:\n    * 1 adet 1x1 boyutunda ürün, 2 adet 2x2 boyutunda ürün ve 1 adet 3x3 boyutunda ürün içeren bir sipariş için,\n    * fonksiyon gerekli minimum paket sayısını hesaplayıp döndürecektir.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int ",
      "vi": "<?php\n\n/**\n    * Hàm này tính toán số lượng tối thiểu các gói 6x6xh cần thiết để vận chuyển một đơn hàng gồm các sản phẩm có kích thước khác nhau.\n    * Kích thước của các sản phẩm dao động từ 1x1 đến 6x6, và mỗi sản phẩm yêu cầu một lượng không gian nhất định trong gói.\n    * Mục tiêu là đóng gói các sản phẩm này một cách hiệu quả để giảm thiểu số lượng gói, giảm chi phí vận chuyển.\n    *\n    * Đầu vào: Sáu số nguyên ($a, $b, $c, $d, $e, $f), mỗi số đại diện cho số lượng sản phẩm từ kích thước 1x1 đến 6x6.\n    * Đầu ra: Một số nguyên đại diện cho số lượng tối thiểu các gói 6x6xh cần thiết để vận chuyển đơn hàng.\n    *\n    * Ví dụ:\n    * Đối với một đơn hàng với 1 sản phẩm kích thước 1x1, 2 sản phẩm kích thước 2x2, và 1 sản phẩm kích thước 3x3,\n    * hàm sẽ tính toán và trả về số lượng gói tối thiểu cần thiết.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int "
    },
    "prompt_bertscore": {
      "es": "0.9953832340536061",
      "arb": "0.9663462531716399",
      "sw": "0.9620288232094656",
      "tr": "0.9880877387885757",
      "vi": "0.9922073328912393"
    },
    "canonical_solution": "{\n        $need2 = [0, 5, 3, 1];\n        $box = $f + $e + $d + intdiv($c + 3, 4);\n    \n        $need2num = $d * 5 + $need2[$c % 4];\n        if ($need2num < $b) {\n            $box += intdiv($b - $need2num + 8, 9);\n        }\n    \n        $need1num = $box * 36 - ($f * 36 + $e * 25 + $d * 16 + $c * 9 + $b * 4);\n        if ($need1num < $a) {\n            $box += intdiv($a - $need1num + 35, 36);\n        }\n        return $box;\n}",
    "instruction": {
      "en": "Write a PHP function `function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int` to solve the following problem:\nThis function calculates the minimum number of 6x6xh packages required to ship an order of products of various sizes.\nThe sizes of the products range from 1x1 to 6x6, and each product requires a certain amount of space in the package.\nThe goal is to efficiently pack these products to minimize the number of packages, reducing shipping costs.\n\nInput: Six integers ($a, $b, $c, $d, $e, $f), each representing the quantity of products from size 1x1 to 6x6.\nOutput: An integer representing the minimum number of 6x6xh packages required to ship the order.\n\nExample:\nFor an order with 1 product of size 1x1, 2 products of size 2x2, and 1 product of size 3x3,\nthe function will calculate and return the minimum number of packages needed.",
      "es": "Escribe una función PHP `function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int` para resolver el siguiente problema:\nEsta función calcula el número mínimo de paquetes de 6x6xh necesarios para enviar un pedido de productos de varios tamaños.\nLos tamaños de los productos varían de 1x1 a 6x6, y cada producto requiere una cierta cantidad de espacio en el paquete.\nEl objetivo es empacar estos productos de manera eficiente para minimizar el número de paquetes, reduciendo los costos de envío.\n\nEntrada: Seis enteros ($a, $b, $c, $d, $e, $f), cada uno representando la cantidad de productos de tamaño 1x1 a 6x6.\nSalida: Un entero que representa el número mínimo de paquetes de 6x6xh necesarios para enviar el pedido.\n\nEjemplo:\nPara un pedido con 1 producto de tamaño 1x1, 2 productos de tamaño 2x2, y 1 producto de tamaño 3x3,\nla función calculará y devolverá el número mínimo de paquetes necesarios.",
      "arb": "اكتب دالة PHP `function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int` لحل المشكلة التالية:\nتحسب هذه الدالة الحد الأدنى لعدد الحزم 6x6xh المطلوبة لشحن طلب من المنتجات ذات الأحجام المختلفة.\nتتراوح أحجام المنتجات من 1x1 إلى 6x6، وكل منتج يتطلب مقدارًا معينًا من المساحة في الحزمة.\nالهدف هو تعبئة هذه المنتجات بكفاءة لتقليل عدد الحزم، مما يقلل من تكاليف الشحن.\n\nالمدخلات: ستة أعداد صحيحة ($a, $b, $c, $d, $e, $f)، كل منها يمثل كمية المنتجات من الحجم 1x1 إلى 6x6.\nالمخرجات: عدد صحيح يمثل الحد الأدنى لعدد الحزم 6x6xh المطلوبة لشحن الطلب.\n\nمثال:\nلطلب يحتوي على منتج واحد بحجم 1x1، ومنتجين بحجم 2x2، ومنتج واحد بحجم 3x3،\nستقوم الدالة بحساب وإرجاع الحد الأدنى لعدد الحزم المطلوبة.",
      "sw": "Andika kazi ya PHP `function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int` kutatua tatizo lifuatalo:\nKazi hii inahesabu idadi ndogo ya vifurushi vya 6x6xh vinavyohitajika kusafirisha oda ya bidhaa za ukubwa mbalimbali.\nUkubwa wa bidhaa hutoka 1x1 hadi 6x6, na kila bidhaa inahitaji kiasi fulani cha nafasi katika kifurushi.\nLengo ni kupakia bidhaa hizi kwa ufanisi ili kupunguza idadi ya vifurushi, kupunguza gharama za usafirishaji.\n\nIngizo: Nambari sita ($a, $b, $c, $d, $e, $f), kila moja ikiwakilisha idadi ya bidhaa kutoka ukubwa wa 1x1 hadi 6x6.\nPato: Nambari kamili inayowakilisha idadi ndogo ya vifurushi vya 6x6xh vinavyohitajika kusafirisha oda.\n\nMfano:\nKwa oda yenye bidhaa 1 ya ukubwa 1x1, bidhaa 2 za ukubwa 2x2, na bidhaa 1 ya ukubwa 3x3,\nkazi itahesabu na kurudisha idadi ndogo ya vifurushi vinavyohitajika.",
      "tr": "Bir PHP fonksiyonu `function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int` yazın ve aşağıdaki problemi çözün:\nBu fonksiyon, çeşitli boyutlardaki ürün siparişini göndermek için gereken minimum 6x6xh paket sayısını hesaplar.\nÜrünlerin boyutları 1x1'den 6x6'ya kadar değişir ve her ürün pakette belirli bir miktarda alan gerektirir.\nAmaç, bu ürünleri verimli bir şekilde paketleyerek paket sayısını en aza indirmek ve nakliye maliyetlerini azaltmaktır.\n\nGirdi: 1x1'den 6x6'ya kadar olan ürünlerin miktarını temsil eden altı tamsayı ($a, $b, $c, $d, $e, $f).\nÇıktı: Siparişi göndermek için gereken minimum 6x6xh paket sayısını temsil eden bir tamsayı.\n\nÖrnek:\n1 adet 1x1 boyutunda ürün, 2 adet 2x2 boyutunda ürün ve 1 adet 3x3 boyutunda ürün içeren bir sipariş için,\nfonksiyon gerekli minimum paket sayısını hesaplayacak ve döndürecektir.",
      "vi": "Viết một hàm PHP `function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int` để giải quyết vấn đề sau:\nHàm này tính toán số lượng tối thiểu các gói 6x6xh cần thiết để vận chuyển một đơn hàng các sản phẩm có kích thước khác nhau.\nKích thước của các sản phẩm dao động từ 1x1 đến 6x6, và mỗi sản phẩm yêu cầu một lượng không gian nhất định trong gói hàng.\nMục tiêu là đóng gói các sản phẩm này một cách hiệu quả để giảm thiểu số lượng gói hàng, từ đó giảm chi phí vận chuyển.\n\nĐầu vào: Sáu số nguyên ($a, $b, $c, $d, $e, $f), mỗi số biểu thị số lượng sản phẩm từ kích thước 1x1 đến 6x6.\nĐầu ra: Một số nguyên biểu thị số lượng tối thiểu các gói 6x6xh cần thiết để vận chuyển đơn hàng.\n\nVí dụ:\nĐối với một đơn hàng có 1 sản phẩm kích thước 1x1, 2 sản phẩm kích thước 2x2, và 1 sản phẩm kích thước 3x3,\nhàm sẽ tính toán và trả về số lượng gói hàng tối thiểu cần thiết."
    },
    "instruction_bertscore": {
      "es": "0.9964713312809153",
      "arb": "0.9858114346219159",
      "sw": "0.9925233538274658",
      "tr": "0.9861524829861528",
      "vi": "0.9935888071913369"
    },
    "level": "easy",
    "test": "function main(){\n    assert(calculateMinimumPackages(0, 0, 4, 0, 0, 1) === 2);\n    assert(calculateMinimumPackages(7, 5, 1, 0, 0, 0) === 1);\n    assert(calculateMinimumPackages(0, 0, 0, 0, 0, 0) === 0);\n    assert(calculateMinimumPackages(0, 0, 4, 1, 1, 1) === 4);\n    assert(calculateMinimumPackages(1, 2, 1, 1, 1, 1) === 4);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "calculateMinimumPackages",
    "signature": "function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int",
    "docstring": {
      "en": "This function calculates the minimum number of 6x6xh packages required to ship an order of products of various sizes.\nThe sizes of the products range from 1x1 to 6x6, and each product requires a certain amount of space in the package.\nThe goal is to efficiently pack these products to minimize the number of packages, reducing shipping costs.\n\nInput: Six integers ($a, $b, $c, $d, $e, $f), each representing the quantity of products from size 1x1 to 6x6.\nOutput: An integer representing the minimum number of 6x6xh packages required to ship the order.\n\nExample:\nFor an order with 1 product of size 1x1, 2 products of size 2x2, and 1 product of size 3x3,\nthe function will calculate and return the minimum number of packages needed.",
      "es": "Esta función calcula el número mínimo de paquetes de 6x6xh necesarios para enviar un pedido de productos de varios tamaños.  \nLos tamaños de los productos varían de 1x1 a 6x6, y cada producto requiere una cierta cantidad de espacio en el paquete.  \nEl objetivo es empaquetar estos productos de manera eficiente para minimizar el número de paquetes, reduciendo los costos de envío.\n\nEntrada: Seis enteros ($a, $b, $c, $d, $e, $f), cada uno representando la cantidad de productos de tamaño 1x1 a 6x6.  \nSalida: Un entero que representa el número mínimo de paquetes de 6x6xh necesarios para enviar el pedido.\n\nEjemplo:  \nPara un pedido con 1 producto de tamaño 1x1, 2 productos de tamaño 2x2, y 1 producto de tamaño 3x3,  \nla función calculará y devolverá el número mínimo de paquetes necesarios.",
      "arb": "هذه الدالة تحسب الحد الأدنى لعدد الطرود بحجم 6x6xh المطلوبة لشحن طلب من المنتجات ذات الأحجام المختلفة. تتراوح أحجام المنتجات من 1x1 إلى 6x6، ويتطلب كل منتج كمية معينة من المساحة في الطرد. الهدف هو تعبئة هذه المنتجات بكفاءة لتقليل عدد الطرود، مما يقلل من تكاليف الشحن.\n\nالمدخلات: ستة أعداد صحيحة ($a, $b, $c, $d, $e, $f)، كل منها يمثل كمية المنتجات من الحجم 1x1 إلى 6x6. المخرجات: عدد صحيح يمثل الحد الأدنى لعدد الطرود بحجم 6x6xh المطلوبة لشحن الطلب.\n\nمثال: لطلب يحتوي على منتج واحد بحجم 1x1، و2 من المنتجات بحجم 2x2، ومنتج واحد بحجم 3x3، ستقوم الدالة بحساب وإرجاع الحد الأدنى لعدد الطرود المطلوبة.",
      "sw": "Kazi hii inahesabu idadi ndogo ya vifurushi vya 6x6xh vinavyohitajika kusafirisha oda ya bidhaa za ukubwa mbalimbali.\nUkubwa wa bidhaa hutoka 1x1 hadi 6x6, na kila bidhaa inahitaji kiasi fulani cha nafasi katika kifurushi.\nLengo ni kupakia bidhaa hizi kwa ufanisi ili kupunguza idadi ya vifurushi, kupunguza gharama za usafirishaji.\n\nIngizo: Nambari sita ($a, $b, $c, $d, $e, $f), kila moja ikiwakilisha idadi ya bidhaa kutoka ukubwa wa 1x1 hadi 6x6.\nTokeo: Nambari inayoashiria idadi ndogo ya vifurushi vya 6x6xh vinavyohitajika kusafirisha oda.\nMfano:\nKwa oda yenye bidhaa 1 ya ukubwa 1x1, bidhaa 2 za ukubwa 2x2, na bidhaa 1 ya ukubwa 3x3,\nkazi itahesabu na kurudisha idadi ndogo zaidi ya vifurushi vinavyohitajika.",
      "tr": "Bu fonksiyon, çeşitli boyutlardaki ürünlerin siparişini göndermek için gereken minimum 6x6xh paket sayısını hesaplar. Ürünlerin boyutları 1x1'den 6x6'ya kadar değişir ve her ürün pakette belirli bir miktarda alan gerektirir. Amaç, nakliye maliyetlerini azaltmak için bu ürünleri verimli bir şekilde paketlemektir.\n\nGirdi: 1x1'den 6x6'ya kadar olan ürün miktarlarını temsil eden altı tamsayı ($a, $b, $c, $d, $e, $f).\nÇıktı: Siparişi göndermek için gereken minimum 6x6xh paket sayısını temsil eden bir tamsayı.\n\nÖrnek:\n1 adet 1x1 boyutunda ürün, 2 adet 2x2 boyutunda ürün ve 1 adet 3x3 boyutunda ürün içeren bir sipariş için, fonksiyon gereken minimum paket sayısını hesaplayacak ve döndürecektir.",
      "vi": "Hàm này tính toán số lượng tối thiểu các gói hàng 6x6xh cần thiết để vận chuyển một đơn hàng gồm các sản phẩm có kích thước khác nhau.  \nKích thước của các sản phẩm dao động từ 1x1 đến 6x6, và mỗi sản phẩm yêu cầu một lượng không gian nhất định trong gói hàng.  \nMục tiêu là đóng gói các sản phẩm này một cách hiệu quả để giảm thiểu số lượng gói hàng, từ đó giảm chi phí vận chuyển.\n\nĐầu vào: Sáu số nguyên ($a, $b, $c, $d, $e, $f), mỗi số đại diện cho số lượng sản phẩm từ kích thước 1x1 đến 6x6.  \nĐầu ra: Một số nguyên đại diện cho số lượng tối thiểu các gói hàng 6x6xh cần thiết để vận chuyển đơn hàng.\n\nVí dụ:  \nĐối với một đơn hàng có 1 sản phẩm kích thước 1x1, 2 sản phẩm kích thước 2x2, và 1 sản phẩm kích thước 3x3,  \nhàm sẽ tính toán và trả về số lượng gói hàng tối thiểu cần thiết."
    },
    "docstring_bertscore": {
      "es": "0.9950195418259312",
      "arb": "0.9694726953691291",
      "sw": "0.9536206005498777",
      "tr": "0.9756256686824468",
      "vi": "0.9868874153959819"
    }
  },
  {
    "task_id": "PHP/10",
    "prompt": {
      "en": "<?php\n\n/**\n    * Calculates the number of chickens and rabbits in a farm.\n    * Given the total number of animals and the total number of legs, the function determines\n    * how many chickens and rabbits are there. \n    * Assumptions: \n    * - Each chicken has 2 legs.\n    * - Each rabbit has 4 legs.\n    * - The total number of animals and legs are non-negative integers.\n    * \n    * Input: Two integers, $totalAnimals (total number of animals) and $totalLegs (total number of legs).\n    * Output: Returns an array [number_of_chickens, number_of_rabbits] if a valid solution exists, \n    *         or \"No answer\" if no valid solution is found.\n    * \n    * Example:\n    * For 5 animals and 12 legs, the function will return [4, 1] (4 chickens and 1 rabbit).\n    * For 10 animals and 16 legs, the function will return \"No answer\" as no valid combination exists.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) ",
      "es": "<?php\n\n/**\n    * Calcula el número de gallinas y conejos en una granja.\n    * Dado el número total de animales y el número total de patas, la función determina\n    * cuántas gallinas y conejos hay.\n    * Suposiciones:\n    * - Cada gallina tiene 2 patas.\n    * - Cada conejo tiene 4 patas.\n    * - El número total de animales y patas son enteros no negativos.\n    * \n    * Entrada: Dos enteros, $totalAnimals (número total de animales) y $totalLegs (número total de patas).\n    * Salida: Devuelve un array [número_de_gallinas, número_de_conejos] si existe una solución válida,\n    *         o \"No answer\" si no se encuentra una solución válida.\n    * \n    * Ejemplo:\n    * Para 5 animales y 12 patas, la función devolverá [4, 1] (4 gallinas y 1 conejo).\n    * Para 10 animales y 16 patas, la función devolverá \"No answer\" ya que no existe una combinación válida.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) ",
      "arb": "<?php\n\n/**\n    * يحسب عدد الدجاج والأرانب في المزرعة.\n    * بالنظر إلى العدد الإجمالي للحيوانات والعدد الإجمالي للأرجل، تحدد الدالة\n    * كم عدد الدجاج والأرانب هناك.\n    * الافتراضات:\n    * - كل دجاجة لها 2 أرجل.\n    * - كل أرنب له 4 أرجل.\n    * - العدد الإجمالي للحيوانات والأرجل هي أعداد صحيحة غير سلبية.\n    * \n    * المدخل: عددان صحيحان، $totalAnimals (العدد الإجمالي للحيوانات) و $totalLegs (العدد الإجمالي للأرجل).\n    * المخرج: تعيد مصفوفة [عدد_الدجاج, عدد_الأرانب] إذا كانت هناك حل صالح،\n    *         أو \"لا يوجد جواب\" إذا لم يتم العثور على حل صالح.\n    * \n    * مثال:\n    * لعدد 5 حيوانات و12 أرجل، ستعيد الدالة [4, 1] (4 دجاجات و1 أرنب).\n    * لعدد 10 حيوانات و16 أرجل، ستعيد الدالة \"لا يوجد جواب\" حيث لا يوجد تركيبة صالحة.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) ",
      "sw": "<?php\n\n/**\n    * Inahesabu idadi ya kuku na sungura katika shamba.\n    * Ukipewa jumla ya idadi ya wanyama na jumla ya idadi ya miguu, kazi hii inaamua\n    * ni kuku wangapi na sungura wangapi wapo. \n    * Dhana:\n    * - Kila kuku ana miguu 2.\n    * - Kila sungura ana miguu 4.\n    * - Jumla ya idadi ya wanyama na miguu ni namba zisizo hasi.\n    * \n    * Ingizo: Namba mbili za mzima, $totalAnimals (jumla ya idadi ya wanyama) na $totalLegs (jumla ya idadi ya miguu).\n    * Tokeo: Inarudisha array [number_of_chickens, number_of_rabbits] ikiwa suluhisho halali lipo, \n    *         au \"No answer\" ikiwa hakuna suluhisho halali lililopatikana.\n    * \n    * Mfano:\n    * Kwa wanyama 5 na miguu 12, kazi hii itarudisha [4, 1] (kuku 4 na sungura 1).\n    * Kwa wanyama 10 na miguu 16, kazi hii itarudisha \"No answer\" kwani hakuna mchanganyiko halali unaopatikana.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) ",
      "tr": "<?php\n\n/**\n    * Bir çiftlikteki tavuk ve tavşan sayısını hesaplar.\n    * Toplam hayvan sayısı ve toplam bacak sayısı verildiğinde, fonksiyon\n    * kaç tavuk ve tavşan olduğunu belirler.\n    * Varsayımlar:\n    * - Her tavuk 2 bacağa sahiptir.\n    * - Her tavşan 4 bacağa sahiptir.\n    * - Toplam hayvan ve bacak sayıları negatif olmayan tam sayılardır.\n    * \n    * Girdi: İki tam sayı, $totalAnimals (toplam hayvan sayısı) ve $totalLegs (toplam bacak sayısı).\n    * Çıktı: Geçerli bir çözüm varsa [tavuk_sayısı, tavşan_sayısı] şeklinde bir dizi döndürür,\n    *         veya geçerli bir çözüm bulunamazsa \"No answer\" döndürür.\n    * \n    * Örnek:\n    * 5 hayvan ve 12 bacak için, fonksiyon [4, 1] (4 tavuk ve 1 tavşan) döndürecektir.\n    * 10 hayvan ve 16 bacak için, fonksiyon \"No answer\" döndürecektir çünkü geçerli bir kombinasyon yoktur.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) ",
      "vi": "<?php\n\n/**\n    * Tính toán số lượng gà và thỏ trong một trang trại.\n    * Cho tổng số lượng động vật và tổng số chân, hàm xác định\n    * có bao nhiêu con gà và thỏ.\n    * Giả định:\n    * - Mỗi con gà có 2 chân.\n    * - Mỗi con thỏ có 4 chân.\n    * - Tổng số lượng động vật và chân là các số nguyên không âm.\n    * \n    * Đầu vào: Hai số nguyên, $totalAnimals (tổng số động vật) và $totalLegs (tổng số chân).\n    * Đầu ra: Trả về một mảng [số_lượng_gà, số_lượng_thỏ] nếu tồn tại một giải pháp hợp lệ,\n    *         hoặc \"No answer\" nếu không tìm thấy giải pháp hợp lệ.\n    * \n    * Ví dụ:\n    * Với 5 động vật và 12 chân, hàm sẽ trả về [4, 1] (4 con gà và 1 con thỏ).\n    * Với 10 động vật và 16 chân, hàm sẽ trả về \"No answer\" vì không tồn tại kết hợp hợp lệ nào.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) "
    },
    "prompt_bertscore": {
      "es": "0.9925479839947141",
      "arb": "0.9896066653123494",
      "sw": "0.9703426964380619",
      "tr": "0.9812649838304083",
      "vi": "0.9944723151261801"
    },
    "canonical_solution": "{\n        // Check if the total number of legs is even\n        if ($totalLegs % 2 != 0) {\n            return \"No answer\";\n        }\n    \n        // Calculate the number of rabbits\n        $rabbits = ($totalLegs - 2 * $totalAnimals) / 2;\n    \n        // Calculate the number of chickens\n        $chickens = $totalAnimals - $rabbits;\n    \n        // Check if the number of rabbits and chickens are non-negative integers\n        if ($rabbits < 0 || $chickens < 0 || $rabbits != (int)$rabbits || $chickens != (int)$chickens) {\n            return \"No answer\";\n        }\n    \n        return [$chickens, $rabbits];\n    }",
    "instruction": {
      "en": "Write a PHP function `function calculateAnimals($totalAnimals, $totalLegs)` to solve the following problem:\nCalculates the number of chickens and rabbits in a farm.\nGiven the total number of animals and the total number of legs, the function determines\nhow many chickens and rabbits are there.\nAssumptions:\n- Each chicken has 2 legs.\n- Each rabbit has 4 legs.\n- The total number of animals and legs are non-negative integers.\n\nInput: Two integers, $totalAnimals (total number of animals) and $totalLegs (total number of legs).\nOutput: Returns an array [number_of_chickens, number_of_rabbits] if a valid solution exists,\nor \"No answer\" if no valid solution is found.\n\nExample:\nFor 5 animals and 12 legs, the function will return [4, 1] (4 chickens and 1 rabbit).\nFor 10 animals and 16 legs, the function will return \"No answer\" as no valid combination exists.",
      "es": "Escribe una función PHP `function calculateAnimals($totalAnimals, $totalLegs)` para resolver el siguiente problema:\nCalcula el número de gallinas y conejos en una granja.\nDado el número total de animales y el número total de patas, la función determina\ncuántas gallinas y conejos hay.\nSuposiciones:\n- Cada gallina tiene 2 patas.\n- Cada conejo tiene 4 patas.\n- El número total de animales y patas son enteros no negativos.\n\nEntrada: Dos enteros, $totalAnimals (número total de animales) y $totalLegs (número total de patas).\nSalida: Devuelve un arreglo [number_of_chickens, number_of_rabbits] si existe una solución válida,\no \"No answer\" si no se encuentra una solución válida.\n\nEjemplo:\nPara 5 animales y 12 patas, la función devolverá [4, 1] (4 gallinas y 1 conejo).\nPara 10 animales y 16 patas, la función devolverá \"No answer\" ya que no existe una combinación válida.",
      "arb": "اكتب دالة PHP `function calculateAnimals($totalAnimals, $totalLegs)` لحل المشكلة التالية:\nتحسب عدد الدجاج والأرانب في مزرعة.\nبالنظر إلى العدد الإجمالي للحيوانات والعدد الإجمالي للأرجل، تحدد الدالة\nكم عدد الدجاج والأرانب الموجودين.\nافتراضات:\n- كل دجاجة لها 2 رجل.\n- كل أرنب له 4 أرجل.\n- العدد الإجمالي للحيوانات والأرجل هي أعداد صحيحة غير سلبية.\n\nالمدخلات: عددان صحيحان، $totalAnimals (العدد الإجمالي للحيوانات) و $totalLegs (العدد الإجمالي للأرجل).\nالمخرجات: تعيد مصفوفة [number_of_chickens, number_of_rabbits] إذا كانت هناك حل صالح،\nأو \"No answer\" إذا لم يتم العثور على حل صالح.\n\nمثال:\nبالنسبة لـ 5 حيوانات و 12 رجل، ستعيد الدالة [4, 1] (4 دجاجات و 1 أرنب).\nبالنسبة لـ 10 حيوانات و 16 رجل، ستعيد الدالة \"No answer\" حيث لا يوجد تركيبة صالحة.",
      "sw": "Andika kazi ya PHP `function calculateAnimals($totalAnimals, $totalLegs)` kutatua tatizo lifuatalo:\nInakokotoa idadi ya kuku na sungura katika shamba.\nUkipatiwa jumla ya idadi ya wanyama na jumla ya idadi ya miguu, kazi hii itaamua\nkuna kuku na sungura wangapi.\nMadhumuni:\n- Kila kuku ana miguu 2.\n- Kila sungura ana miguu 4.\n- Jumla ya idadi ya wanyama na miguu ni namba zisizo hasi.\n\nIngizo: Namba mbili, $totalAnimals (jumla ya idadi ya wanyama) na $totalLegs (jumla ya idadi ya miguu).\nMatokeo: Inarudisha orodha [number_of_chickens, number_of_rabbits] ikiwa suluhisho halali lipo,\nau \"No answer\" ikiwa hakuna suluhisho halali lililopatikana.\n\nMfano:\nKwa wanyama 5 na miguu 12, kazi itarudisha [4, 1] (kuku 4 na sungura 1).\nKwa wanyama 10 na miguu 16, kazi itarudisha \"No answer\" kwani hakuna mchanganyiko halali uliopo.",
      "tr": "Bir PHP fonksiyonu `function calculateAnimals($totalAnimals, $totalLegs)` yazarak aşağıdaki problemi çözün:\nBir çiftlikteki tavuk ve tavşan sayısını hesaplar.\nToplam hayvan sayısı ve toplam bacak sayısı verildiğinde, fonksiyon\nkaç tavuk ve kaç tavşan olduğunu belirler.\nVarsayımlar:\n- Her tavuk 2 bacağa sahiptir.\n- Her tavşan 4 bacağa sahiptir.\n- Toplam hayvan ve bacak sayıları negatif olmayan tam sayılardır.\n\nGirdi: İki tam sayı, $totalAnimals (toplam hayvan sayısı) ve $totalLegs (toplam bacak sayısı).\nÇıktı: Geçerli bir çözüm varsa [number_of_chickens, number_of_rabbits] şeklinde bir dizi döndürür,\nveya geçerli bir çözüm bulunamazsa \"No answer\" döndürür.\n\nÖrnek:\n5 hayvan ve 12 bacak için, fonksiyon [4, 1] (4 tavuk ve 1 tavşan) döndürecektir.\n10 hayvan ve 16 bacak için, fonksiyon \"No answer\" döndürecektir çünkü geçerli bir kombinasyon yoktur.",
      "vi": "Viết một hàm PHP `function calculateAnimals($totalAnimals, $totalLegs)` để giải quyết vấn đề sau:\nTính toán số lượng gà và thỏ trong một trang trại.\nCho tổng số lượng động vật và tổng số chân, hàm xác định\ncó bao nhiêu gà và thỏ.\nGiả định:\n- Mỗi con gà có 2 chân.\n- Mỗi con thỏ có 4 chân.\n- Tổng số động vật và chân là các số nguyên không âm.\n\nĐầu vào: Hai số nguyên, $totalAnimals (tổng số động vật) và $totalLegs (tổng số chân).\nĐầu ra: Trả về một mảng [number_of_chickens, number_of_rabbits] nếu tồn tại một giải pháp hợp lệ,\nhoặc \"No answer\" nếu không tìm thấy giải pháp hợp lệ nào.\n\nVí dụ:\nVới 5 động vật và 12 chân, hàm sẽ trả về [4, 1] (4 con gà và 1 con thỏ).\nVới 10 động vật và 16 chân, hàm sẽ trả về \"No answer\" vì không tồn tại kết hợp hợp lệ nào."
    },
    "instruction_bertscore": {
      "es": "0.9959598580497504",
      "arb": "0.9866313808348279",
      "sw": "0.9748222087911607",
      "tr": "0.977363485886121",
      "vi": "0.987861697414958"
    },
    "level": "middle",
    "test": "function main(){\n    assert(calculateAnimals(14, 32) === [12, 2]);\n    assert(calculateAnimals(10, 16) === \"No answer\");\n    assert(calculateAnimals(5, 12) === [4, 1]);\n    assert(calculateAnimals(3, 10) === [1, 2]);\n    assert(calculateAnimals(0, 0) === [0, 0]);\n}\n\n\nmain();\n?>",
    "entry_point": "calculateAnimals",
    "signature": "function calculateAnimals($totalAnimals, $totalLegs)",
    "docstring": {
      "en": "Calculates the number of chickens and rabbits in a farm.\nGiven the total number of animals and the total number of legs, the function determines\nhow many chickens and rabbits are there.\nAssumptions:\n- Each chicken has 2 legs.\n- Each rabbit has 4 legs.\n- The total number of animals and legs are non-negative integers.\n\nInput: Two integers, $totalAnimals (total number of animals) and $totalLegs (total number of legs).\nOutput: Returns an array [number_of_chickens, number_of_rabbits] if a valid solution exists,\nor \"No answer\" if no valid solution is found.\n\nExample:\nFor 5 animals and 12 legs, the function will return [4, 1] (4 chickens and 1 rabbit).\nFor 10 animals and 16 legs, the function will return \"No answer\" as no valid combination exists.",
      "es": "Calcula el número de gallinas y conejos en una granja.  \nDado el número total de animales y el número total de patas, la función determina  \ncuántas gallinas y conejos hay.  \nSuposiciones:  \n- Cada gallina tiene 2 patas.  \n- Cada conejo tiene 4 patas.  \n- El número total de animales y patas son enteros no negativos.  \n\nEntrada: Dos enteros, $totalAnimals (número total de animales) y $totalLegs (número total de patas).  \nSalida: Devuelve un arreglo [number_of_chickens, number_of_rabbits] si existe una solución válida,  \no \"No answer\" si no se encuentra una solución válida.  \n\nEjemplo:  \nPara 5 animales y 12 patas, la función devolverá [4, 1] (4 gallinas y 1 conejo).  \nPara 10 animales y 16 patas, la función devolverá \"No answer\" ya que no existe una combinación válida.",
      "arb": "يحسب عدد الدجاج والأرانب في المزرعة.  \nبناءً على العدد الإجمالي للحيوانات والعدد الإجمالي للأرجل، تحدد الدالة  \nعدد الدجاج والأرانب الموجودين.  \nافتراضات:  \n- كل دجاجة لها 2 أرجل.  \n- كل أرنب له 4 أرجل.  \n- العدد الإجمالي للحيوانات والأرجل هما أعداد صحيحة غير سالبة.  \n\nالمدخلات: عددان صحيحان، $totalAnimals (العدد الإجمالي للحيوانات) و $totalLegs (العدد الإجمالي للأرجل).  \nالمخرجات: تعيد مصفوفة [عدد_الدجاج، عدد_الأرانب] إذا كانت هناك حل صالح،  \nأو \"لا يوجد جواب\" إذا لم يتم العثور على حل صالح.  \n\nمثال:  \nبالنسبة لـ 5 حيوانات و 12 رجلًا، ستعيد الدالة [4، 1] (4 دجاجات و 1 أرنب).  \nبالنسبة لـ 10 حيوانات و 16 رجلًا، ستعيد الدالة \"لا يوجد جواب\" حيث لا يوجد تركيبة صالحة.",
      "sw": "Hesabu idadi ya kuku na sungura kwenye shamba.  \nKwa kupewa jumla ya idadi ya wanyama na jumla ya idadi ya miguu, kazi hii inaamua ni kuku na sungura wangapi wapo.  \nMadhumuni:  \n- Kila kuku ana miguu 2.  \n- Kila sungura ana miguu 4.  \n- Jumla ya idadi ya wanyama na miguu ni namba zisizo hasi.  \n\nIngizo: Namba mbili za mzima, $totalAnimals (jumla ya idadi ya wanyama) na $totalLegs (jumla ya idadi ya miguu).  \nMatokeo: Inarudisha safu [number_of_chickens, number_of_rabbits] ikiwa suluhisho halali lipo,  \nau \"Hakuna jibu\" ikiwa hakuna suluhisho halali lililopatikana.  \n\nMfano:  \nKwa wanyama 5 na miguu 12, kazi itarudisha [4, 1] (kuku 4 na sungura 1).  \nKwa wanyama 10 na miguu 16, kazi itarudisha \"Hakuna jibu\" kwani hakuna mchanganyiko halali uliopo.",
      "tr": "Tavuk ve tavşan sayısını bir çiftlikte hesaplar.\nToplam hayvan sayısı ve toplam bacak sayısı verildiğinde, fonksiyon\nkaç tavuk ve kaç tavşan olduğunu belirler.\nVarsayımlar:\n- Her tavuk 2 bacağa sahiptir.\n- Her tavşan 4 bacağa sahiptir.\n- Toplam hayvan ve bacak sayıları negatif olmayan tam sayılardır.\n\nGirdi: İki tam sayı, $totalAnimals (toplam hayvan sayısı) ve $totalLegs (toplam bacak sayısı).\nÇıktı: Geçerli bir çözüm varsa bir dizi [number_of_chickens, number_of_rabbits] döndürür,\nveya geçerli bir çözüm bulunamazsa \"No answer\" döndürür.\n\nÖrnek:\n5 hayvan ve 12 bacak için, fonksiyon [4, 1] (4 tavuk ve 1 tavşan) döndürecektir.\n10 hayvan ve 16 bacak için, fonksiyon \"No answer\" döndürecektir çünkü geçerli bir kombinasyon yoktur.",
      "vi": "Tính toán số lượng gà và thỏ trong một trang trại.  \nDựa trên tổng số động vật và tổng số chân, hàm xác định có bao nhiêu gà và thỏ.  \nGiả định:  \n- Mỗi con gà có 2 chân.  \n- Mỗi con thỏ có 4 chân.  \n- Tổng số động vật và chân là các số nguyên không âm.  \n\nĐầu vào: Hai số nguyên, $totalAnimals (tổng số động vật) và $totalLegs (tổng số chân).  \nĐầu ra: Trả về một mảng [number_of_chickens, number_of_rabbits] nếu tồn tại một giải pháp hợp lệ,  \nhoặc \"No answer\" nếu không tìm thấy giải pháp hợp lệ nào.  \n\nVí dụ:  \nVới 5 động vật và 12 chân, hàm sẽ trả về [4, 1] (4 con gà và 1 con thỏ).  \nVới 10 động vật và 16 chân, hàm sẽ trả về \"No answer\" vì không tồn tại kết hợp hợp lệ nào.  "
    },
    "docstring_bertscore": {
      "es": "0.9952662407591766",
      "arb": "0.9752303942241873",
      "sw": "0.9564751177557301",
      "tr": "0.9791849264802109",
      "vi": "0.9873657173535139"
    }
  },
  {
    "task_id": "PHP/11",
    "prompt": {
      "en": "<?php\n\n/**\n * Identifies the most frequently occurring character in a given string.\n * The string is composed of lowercase letters from 'a' to 'z'.\n * If there are multiple characters with the same highest frequency,\n * the character with the smallest ASCII value is returned.\n * \n * Example:\n * Input: \"apple\"\n * Output: \"p 2\" (The character 'p' appears twice)\n * \n * Input: \"environment\"\n * Output: \"n 3\" (The character 'n' appears three times, the most frequent)\n */\n\nfunction findMostFrequentChar($string) ",
      "es": "<?php\n\n/**\n * Identifica el carácter que aparece con más frecuencia en una cadena dada.\n * La cadena está compuesta por letras minúsculas de 'a' a 'z'.\n * Si hay múltiples caracteres con la misma frecuencia más alta,\n * se devuelve el carácter con el valor ASCII más pequeño.\n * \n * Ejemplo:\n * Entrada: \"apple\"\n * Salida: \"p 2\" (El carácter 'p' aparece dos veces)\n * \n * Entrada: \"environment\"\n * Salida: \"n 3\" (El carácter 'n' aparece tres veces, el más frecuente)\n */\n\nfunction findMostFrequentChar($string) ",
      "arb": "<?php\n\n/**\n * يحدد الحرف الأكثر تكرارًا في سلسلة معينة.\n * السلسلة تتكون من حروف صغيرة من 'a' إلى 'z'.\n * إذا كان هناك عدة حروف بنفس التكرار الأعلى،\n * يتم إرجاع الحرف ذو القيمة الأصغر في ASCII.\n * \n * مثال:\n * المدخل: \"apple\"\n * المخرج: \"p 2\" (الحرف 'p' يظهر مرتين)\n * \n * المدخل: \"environment\"\n * المخرج: \"n 3\" (الحرف 'n' يظهر ثلاث مرات، الأكثر تكرارًا)\n */\n\nfunction findMostFrequentChar($string) ",
      "sw": "<?php\n\n/**\n * Inatambua herufi inayojitokeza mara nyingi zaidi katika kamba iliyotolewa.\n * Kamba hiyo inaundwa na herufi ndogo kutoka 'a' hadi 'z'.\n * Ikiwa kuna herufi nyingi zenye marudio sawa ya juu zaidi,\n * herufi iliyo na thamani ndogo zaidi ya ASCII inarejeshwa.\n * \n * Mfano:\n * Ingizo: \"apple\"\n * Tokeo: \"p 2\" (Herufi 'p' inatokea mara mbili)\n * \n * Ingizo: \"environment\"\n * Tokeo: \"n 3\" (Herufi 'n' inatokea mara tatu, mara nyingi zaidi)\n */\n\nfunction findMostFrequentChar($string) ",
      "tr": "<?php\n\n/**\n * Verilen bir stringde en sık görülen karakteri belirler.\n * String, 'a'dan 'z'ye kadar küçük harflerden oluşur.\n * Eğer en yüksek frekansa sahip birden fazla karakter varsa,\n * ASCII değeri en küçük olan karakter döndürülür.\n * \n * Örnek:\n * Girdi: \"apple\"\n * Çıktı: \"p 2\" (Karakter 'p' iki kez görünür)\n * \n * Girdi: \"environment\"\n * Çıktı: \"n 3\" (Karakter 'n' üç kez görünür, en sık)\n */\n\nfunction findMostFrequentChar($string) ",
      "vi": "<?php\n\n/**\n * Xác định ký tự xuất hiện thường xuyên nhất trong một chuỗi cho trước.\n * Chuỗi được tạo thành từ các chữ cái thường từ 'a' đến 'z'.\n * Nếu có nhiều ký tự có cùng tần suất cao nhất,\n * ký tự có giá trị ASCII nhỏ nhất sẽ được trả về.\n * \n * Ví dụ:\n * Đầu vào: \"apple\"\n * Đầu ra: \"p 2\" (Ký tự 'p' xuất hiện hai lần)\n * \n * Đầu vào: \"environment\"\n * Đầu ra: \"n 3\" (Ký tự 'n' xuất hiện ba lần, nhiều nhất)\n */\n\nfunction findMostFrequentChar($string) "
    },
    "prompt_bertscore": {
      "es": "0.9930517106410186",
      "arb": "0.9838271171153773",
      "sw": "0.9851760160329852",
      "tr": "0.9717174173052043",
      "vi": "0.985123776242773"
    },
    "canonical_solution": "{\n    $frequency = [];\n    $maxFreq = 0;\n    $resultChar = '';\n\n    for ($i = 0; $i < strlen($string); $i++) {\n        $char = $string[$i];\n        if (!isset($frequency[$char])) {\n            $frequency[$char] = 0;\n        }\n        $frequency[$char]++;\n\n        if ($frequency[$char] > $maxFreq || \n            ($frequency[$char] == $maxFreq && $char < $resultChar)) {\n            $maxFreq = $frequency[$char];\n            $resultChar = $char;\n        }\n    }\n\n    return $resultChar . \" \" . $maxFreq;\n}",
    "instruction": {
      "en": "Write a PHP function `function findMostFrequentChar($string)` to solve the following problem:\nIdentifies the most frequently occurring character in a given string.\nThe string is composed of lowercase letters from 'a' to 'z'.\nIf there are multiple characters with the same highest frequency,\nthe character with the smallest ASCII value is returned.\n\nExample:\nInput: \"apple\"\nOutput: \"p 2\" (The character 'p' appears twice)\n\nInput: \"environment\"\nOutput: \"n 3\" (The character 'n' appears three times, the most frequent)",
      "es": "Escribe una función PHP `function findMostFrequentChar($string)` para resolver el siguiente problema:\nIdentifica el carácter que ocurre con más frecuencia en una cadena dada.\nLa cadena está compuesta por letras minúsculas de 'a' a 'z'.\nSi hay múltiples caracteres con la misma frecuencia más alta,\nse devuelve el carácter con el valor ASCII más pequeño.\n\nEjemplo:\nEntrada: \"apple\"\nSalida: \"p 2\" (El carácter 'p' aparece dos veces)\n\nEntrada: \"environment\"\nSalida: \"n 3\" (El carácter 'n' aparece tres veces, el más frecuente)",
      "arb": "اكتب دالة PHP `function findMostFrequentChar($string)` لحل المشكلة التالية:\nتحديد الحرف الأكثر تكرارًا في سلسلة معينة.\nالسلسلة تتكون من أحرف صغيرة من 'a' إلى 'z'.\nإذا كان هناك عدة أحرف بنفس التكرار الأعلى،\nيتم إرجاع الحرف ذو القيمة الأصغر في ASCII.\n\nمثال:\nالمدخل: \"apple\"\nالمخرج: \"p 2\" (الحرف 'p' يظهر مرتين)\n\nالمدخل: \"environment\"\nالمخرج: \"n 3\" (الحرف 'n' يظهر ثلاث مرات، الأكثر تكرارًا)",
      "sw": "Andika kazi ya PHP `function findMostFrequentChar($string)` kutatua tatizo lifuatalo:\nInatambua herufi inayojitokeza mara nyingi zaidi katika kamba iliyotolewa.\nKamba inaundwa na herufi ndogo kutoka 'a' hadi 'z'.\nIkiwa kuna herufi nyingi zilizo na marudio sawa ya juu zaidi,\nherufi yenye thamani ndogo zaidi ya ASCII inarejeshwa.\n\nMfano:\nIngizo: \"apple\"\nPato: \"p 2\" (Herufi 'p' inaonekana mara mbili)\n\nIngizo: \"environment\"\nPato: \"n 3\" (Herufi 'n' inaonekana mara tatu, mara nyingi zaidi)",
      "tr": "Bir PHP fonksiyonu `function findMostFrequentChar($string)` yazın ve aşağıdaki problemi çözün:\nVerilen bir stringde en sık görülen karakteri belirler.\nString, 'a' ile 'z' arasında küçük harflerden oluşur.\nEğer aynı en yüksek sıklığa sahip birden fazla karakter varsa,\nen küçük ASCII değerine sahip karakter döndürülür.\n\nÖrnek:\nGirdi: \"apple\"\nÇıktı: \"p 2\" (Karakter 'p' iki kez görünür)\n\nGirdi: \"environment\"\nÇıktı: \"n 3\" (Karakter 'n' üç kez görünür, en sık)",
      "vi": "Viết một hàm PHP `function findMostFrequentChar($string)` để giải quyết vấn đề sau:\nXác định ký tự xuất hiện thường xuyên nhất trong một chuỗi cho trước.\nChuỗi được tạo thành từ các chữ cái thường từ 'a' đến 'z'.\nNếu có nhiều ký tự có cùng tần suất cao nhất,\nký tự có giá trị ASCII nhỏ nhất sẽ được trả về.\n\nVí dụ:\nĐầu vào: \"apple\"\nĐầu ra: \"p 2\" (Ký tự 'p' xuất hiện hai lần)\n\nĐầu vào: \"environment\"\nĐầu ra: \"n 3\" (Ký tự 'n' xuất hiện ba lần, nhiều nhất)"
    },
    "instruction_bertscore": {
      "es": "0.9903912553174373",
      "arb": "0.9821268410537187",
      "sw": "0.9777091027491217",
      "tr": "0.969864990371673",
      "vi": "0.9724994251153387"
    },
    "level": "middle",
    "test": "function main(){\n    assert(findMostFrequentChar(\"abbccc\") === \"c 3\");\n    assert(findMostFrequentChar(\"adfadffasdf\") === \"f 4\");\n    assert(findMostFrequentChar(\"environment\") === \"n 3\");\n    assert(findMostFrequentChar(\"apple\") === \"p 2\");\n    assert(findMostFrequentChar(\"banana\") === \"a 3\");\n    \n}\n\n\nmain();\n?>",
    "entry_point": "findMostFrequentChar",
    "signature": "function findMostFrequentChar($string)",
    "docstring": {
      "en": "Identifies the most frequently occurring character in a given string.\nThe string is composed of lowercase letters from 'a' to 'z'.\nIf there are multiple characters with the same highest frequency,\nthe character with the smallest ASCII value is returned.\n\nExample:\nInput: \"apple\"\nOutput: \"p 2\" (The character 'p' appears twice)\n\nInput: \"environment\"\nOutput: \"n 3\" (The character 'n' appears three times, the most frequent)",
      "es": "Identifica el carácter que ocurre con más frecuencia en una cadena dada.  \nLa cadena está compuesta por letras minúsculas de 'a' a 'z'.  \nSi hay múltiples caracteres con la misma frecuencia más alta,  \nse devuelve el carácter con el valor ASCII más pequeño.  \n\nEjemplo:  \nEntrada: \"apple\"  \nSalida: \"p 2\" (El carácter 'p' aparece dos veces)  \n\nEntrada: \"environment\"  \nSalida: \"n 3\" (El carácter 'n' aparece tres veces, el más frecuente)  ",
      "arb": "يحدد الحرف الأكثر تكرارًا في سلسلة معينة.\nالسلسلة تتكون من أحرف صغيرة من 'a' إلى 'z'.\nإذا كان هناك عدة أحرف بنفس التكرار الأعلى،\nيتم إرجاع الحرف ذو القيمة ASCII الأصغر.\n\nمثال:\nالمدخل: \"apple\"\nالمخرج: \"p 2\" (الحرف 'p' يظهر مرتين)\n\nالمدخل: \"environment\"\nالمخرج: \"n 3\" (الحرف 'n' يظهر ثلاث مرات، الأكثر تكرارًا)",
      "sw": "Inatambua herufi inayojitokeza mara nyingi zaidi katika kamba iliyotolewa.\nKamba hiyo inaundwa na herufi ndogo kutoka 'a' hadi 'z'.\nKama kuna herufi nyingi zenye mzunguko sawa wa juu zaidi,\nherufi yenye thamani ndogo zaidi ya ASCII inarejeshwa.\n\nMfano:\nIngizo: \"apple\"\nMatokeo: \"p 2\" (Herufi 'p' inajitokeza mara mbili)\n\nIngizo: \"environment\"\nMatokeo: \"n 3\" (Herufi 'n' inajitokeza mara tatu, mara nyingi zaidi)",
      "tr": "Verilen bir stringde en sık görülen karakteri belirler.  \nString, 'a'dan 'z'ye kadar küçük harflerden oluşur.  \nEğer en yüksek sıklığa sahip birden fazla karakter varsa,  \nen küçük ASCII değerine sahip karakter döndürülür.  \n\nÖrnek:  \nGirdi: \"apple\"  \nÇıktı: \"p 2\" (Karakter 'p' iki kez görünür)  \n\nGirdi: \"environment\"  \nÇıktı: \"n 3\" (Karakter 'n' üç kez görünür, en sık)  ",
      "vi": "Xác định ký tự xuất hiện thường xuyên nhất trong một chuỗi cho trước. Chuỗi được tạo thành từ các chữ cái thường từ 'a' đến 'z'. Nếu có nhiều ký tự có cùng tần suất cao nhất, ký tự có giá trị ASCII nhỏ nhất sẽ được trả về.\n\nVí dụ: \nĐầu vào: \"apple\" \nĐầu ra: \"p 2\" (Ký tự 'p' xuất hiện hai lần)\n\nĐầu vào: \"environment\" \nĐầu ra: \"n 3\" (Ký tự 'n' xuất hiện ba lần, thường xuyên nhất)"
    },
    "docstring_bertscore": {
      "es": "0.9835736647491768",
      "arb": "0.977494184676842",
      "sw": "0.9825803142136214",
      "tr": "0.9675700149491959",
      "vi": "0.9662304516594966"
    }
  },
  {
    "task_id": "PHP/12",
    "prompt": {
      "en": "<?php\n\n\n/**\n    * Finds the fractional element in a diagonally arranged sequence.\n    * In this sequence, fractions are arranged in a diagonal pattern. The first row contains fractions with the numerator 1 and increasing denominators. Each subsequent row increases the numerator and decreases the denominator until it reaches 1.\n    * For example, the sequence starts with 1/1, 1/2, 2/1, 3/1, 2/2, ...\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * The function takes an integer 'n' and returns the 'n'th element in this sequence as a string in the form 'numerator/denominator'.\n    * Input: An integer 'n' (n < 20000).\n    * Output: A string representing the 'n'th element in the sequence.\n    * Examples:\n    * - Input: 3, Output: \"2/1\"\n    * - Input: 14, Output: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) ",
      "es": "<?php\n\n\n/**\n    * Encuentra el elemento fraccional en una secuencia dispuesta diagonalmente.\n    * En esta secuencia, las fracciones están dispuestas en un patrón diagonal. La primera fila contiene fracciones con el numerador 1 y denominadores crecientes. Cada fila subsiguiente incrementa el numerador y disminuye el denominador hasta que llega a 1.\n    * Por ejemplo, la secuencia comienza con 1/1, 1/2, 2/1, 3/1, 2/2, ...\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * La función toma un entero 'n' y devuelve el elemento 'n' en esta secuencia como una cadena en la forma 'numerador/denominador'.\n    * Entrada: Un entero 'n' (n < 20000).\n    * Salida: Una cadena que representa el elemento 'n' en la secuencia.\n    * Ejemplos:\n    * - Entrada: 3, Salida: \"2/1\"\n    * - Entrada: 14, Salida: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) ",
      "arb": "<?php\n\n\n/**\n    * يجد العنصر الكسري في تسلسل مرتب بشكل قطري.\n    * في هذا التسلسل، يتم ترتيب الكسور في نمط قطري. يحتوي الصف الأول على كسور مع البسط 1 والمقامات المتزايدة. كل صف لاحق يزيد البسط ويقلل المقام حتى يصل إلى 1.\n    * على سبيل المثال، يبدأ التسلسل بـ 1/1، 1/2، 2/1، 3/1، 2/2، ...\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * تأخذ الدالة عددًا صحيحًا 'n' وتعيد العنصر 'n' في هذا التسلسل كسلسلة نصية في الشكل 'بسط/مقام'.\n    * المدخل: عدد صحيح 'n' (n < 20000).\n    * المخرج: سلسلة نصية تمثل العنصر 'n' في التسلسل.\n    * أمثلة:\n    * - المدخل: 3، المخرج: \"2/1\"\n    * - المدخل: 14، المخرج: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) ",
      "sw": "<?php\n\n\n/**\n    * Inapata kipengele cha sehemu katika mlolongo uliopangwa kwa diagonal.\n    * Katika mlolongo huu, sehemu zimepangwa katika muundo wa diagonal. Safu ya kwanza ina sehemu zenye numerator 1 na denominator zinazoongezeka. Kila safu inayofuata inaongeza numerator na kupunguza denominator hadi ifikie 1.\n    * Kwa mfano, mlolongo unaanza na 1/1, 1/2, 2/1, 3/1, 2/2, ...\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * Kazi inachukua nambari nzima 'n' na inarudisha kipengele cha 'n' katika mlolongo huu kama kamba katika umbo la 'numerator/denominator'.\n    * Ingizo: Nambari nzima 'n' (n < 20000).\n    * Tokeo: Kamba inayowakilisha kipengele cha 'n' katika mlolongo.\n    * Mifano:\n    * - Ingizo: 3, Tokeo: \"2/1\"\n    * - Ingizo: 14, Tokeo: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) ",
      "tr": "<?php\n\n\n/**\n    * Diyagonal olarak düzenlenmiş bir dizide kesirli elemanı bulur.\n    * Bu dizide, kesirler diyagonal bir desende düzenlenmiştir. İlk satırda payı 1 olan ve paydaları artan kesirler bulunur. Her sonraki satırda pay artar ve payda 1'e ulaşana kadar azalır.\n    * Örneğin, dizi 1/1, 1/2, 2/1, 3/1, 2/2, ... ile başlar.\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * Fonksiyon bir tamsayı 'n' alır ve bu dizideki 'n'inci elemanı 'pay/payda' şeklinde bir string olarak döndürür.\n    * Girdi: Bir tamsayı 'n' (n < 20000).\n    * Çıktı: Dizideki 'n'inci elemanı temsil eden bir string.\n    * Örnekler:\n    * - Girdi: 3, Çıktı: \"2/1\"\n    * - Girdi: 14, Çıktı: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) ",
      "vi": "<?php\n\n\n/**\n    * Tìm phần tử phân số trong một dãy sắp xếp theo đường chéo.\n    * Trong dãy này, các phân số được sắp xếp theo một mẫu đường chéo. Hàng đầu tiên chứa các phân số với tử số là 1 và mẫu số tăng dần. Mỗi hàng tiếp theo tăng tử số và giảm mẫu số cho đến khi nó đạt đến 1.\n    * Ví dụ, dãy bắt đầu với 1/1, 1/2, 2/1, 3/1, 2/2, ...\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * Hàm nhận một số nguyên 'n' và trả về phần tử thứ 'n' trong dãy này dưới dạng một chuỗi theo dạng 'tử số/mẫu số'.\n    * Đầu vào: Một số nguyên 'n' (n < 20000).\n    * Đầu ra: Một chuỗi đại diện cho phần tử thứ 'n' trong dãy.\n    * Ví dụ:\n    * - Đầu vào: 3, Đầu ra: \"2/1\"\n    * - Đầu vào: 14, Đầu ra: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) "
    },
    "prompt_bertscore": {
      "es": "0.9833541781781333",
      "arb": "0.9786676929679962",
      "sw": "0.960533533701035",
      "tr": "0.9653809095198104",
      "vi": "0.9624389949463027"
    },
    "canonical_solution": "{\n    // Find the diagonal this element is on\n    $d = 1;\n    while ($d * ($d + 1) / 2 < $n) {\n        $d++;\n    }\n\n    // Position within the diagonal\n    $p = $n - ($d * ($d - 1) / 2);\n\n    // Check if the diagonal is even or odd\n    if ($d % 2 == 0) {\n        // Even diagonal: numerator increases, denominator decreases\n        $numerator = $p;\n        $denominator = $d - $p + 1;\n    } else {\n        // Odd diagonal: numerator decreases, denominator increases\n        $numerator = $d - $p + 1;\n        $denominator = $p;\n    }\n\n    return \"$numerator/$denominator\";\n}",
    "instruction": {
      "en": "Write a PHP function `function findFractionalElement($n)` to solve the following problem:\nFinds the fractional element in a diagonally arranged sequence.\nIn this sequence, fractions are arranged in a diagonal pattern. The first row contains fractions with the numerator 1 and increasing denominators. Each subsequent row increases the numerator and decreases the denominator until it reaches 1.\nFor example, the sequence starts with 1/1, 1/2, 2/1, 3/1, 2/2, ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nThe function takes an integer 'n' and returns the 'n'th element in this sequence as a string in the form 'numerator/denominator'.\nInput: An integer 'n' (n < 20000).\nOutput: A string representing the 'n'th element in the sequence.\nExamples:\n- Input: 3, Output: \"2/1\"\n- Input: 14, Output: \"2/4\"",
      "es": "Escribe una función PHP `function findFractionalElement($n)` para resolver el siguiente problema:\nEncuentra el elemento fraccional en una secuencia dispuesta diagonalmente.\nEn esta secuencia, las fracciones están dispuestas en un patrón diagonal. La primera fila contiene fracciones con el numerador 1 y denominadores crecientes. Cada fila subsiguiente aumenta el numerador y disminuye el denominador hasta que llega a 1.\nPor ejemplo, la secuencia comienza con 1/1, 1/2, 2/1, 3/1, 2/2, ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nLa función toma un entero 'n' y devuelve el elemento 'n' en esta secuencia como una cadena en la forma 'numerador/denominador'.\nEntrada: Un entero 'n' (n < 20000).\nSalida: Una cadena que representa el elemento 'n' en la secuencia.\nEjemplos:\n- Entrada: 3, Salida: \"2/1\"\n- Entrada: 14, Salida: \"2/4\"",
      "arb": "اكتب دالة PHP `function findFractionalElement($n)` لحل المشكلة التالية:\nتجد العنصر الكسري في تسلسل مرتب بشكل قطري.\nفي هذا التسلسل، يتم ترتيب الكسور في نمط قطري. يحتوي الصف الأول على كسور مع البسط 1 والمقامات المتزايدة. كل صف لاحق يزيد البسط ويقلل المقام حتى يصل إلى 1.\nعلى سبيل المثال، يبدأ التسلسل بـ 1/1، 1/2، 2/1، 3/1، 2/2، ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nتأخذ الدالة عددًا صحيحًا 'n' وتعيد العنصر 'n' في هذا التسلسل كسلسلة نصية بالشكل 'بسط/مقام'.\nالمدخل: عدد صحيح 'n' (n < 20000).\nالمخرج: سلسلة نصية تمثل العنصر 'n' في التسلسل.\nأمثلة:\n- المدخل: 3، المخرج: \"2/1\"\n- المدخل: 14، المخرج: \"2/4\"",
      "sw": "Andika kazi ya PHP `function findFractionalElement($n)` kutatua tatizo lifuatalo:\nInapata kipengele cha sehemu katika mlolongo uliopangwa kwa diagonal.\nKatika mlolongo huu, sehemu zinawekwa katika muundo wa diagonal. Safu ya kwanza ina sehemu zenye numerator 1 na denominator zinazoongezeka. Kila safu inayofuata huongeza numerator na kupunguza denominator hadi ifikie 1.\nKwa mfano, mlolongo unaanza na 1/1, 1/2, 2/1, 3/1, 2/2, ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nKazi inachukua nambari nzima 'n' na inarudisha kipengele cha 'n' katika mlolongo huu kama kamba katika umbo la 'numerator/denominator'.\nIngizo: Nambari nzima 'n' (n < 20000).\nPato: Kamba inayowakilisha kipengele cha 'n' katika mlolongo.\nMifano:\n- Ingizo: 3, Pato: \"2/1\"\n- Ingizo: 14, Pato: \"2/4\"",
      "tr": "Bir PHP fonksiyonu `function findFractionalElement($n)` yazın ve aşağıdaki problemi çözün:\nÇapraz olarak düzenlenmiş bir dizide kesirli elemanı bulun.\nBu dizide, kesirler çapraz bir desende düzenlenmiştir. İlk satır, payı 1 olan ve paydaları artan kesirleri içerir. Her bir sonraki satır, payı artırır ve paydayı 1'e ulaşana kadar azaltır.\nÖrneğin, dizi 1/1, 1/2, 2/1, 3/1, 2/2, ... ile başlar.\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nFonksiyon bir tamsayı 'n' alır ve bu dizideki 'n'inci elemanı 'pay/payda' biçiminde bir string olarak döndürür.\nGirdi: Bir tamsayı 'n' (n < 20000).\nÇıktı: Dizideki 'n'inci elemanı temsil eden bir string.\nÖrnekler:\n- Girdi: 3, Çıktı: \"2/1\"\n- Girdi: 14, Çıktı: \"2/4\"",
      "vi": "Viết một hàm PHP `function findFractionalElement($n)` để giải quyết vấn đề sau:\nTìm phần tử phân số trong một dãy được sắp xếp theo đường chéo.\nTrong dãy này, các phân số được sắp xếp theo một mẫu đường chéo. Hàng đầu tiên chứa các phân số với tử số là 1 và mẫu số tăng dần. Mỗi hàng tiếp theo tăng tử số và giảm mẫu số cho đến khi đạt 1.\nVí dụ, dãy bắt đầu với 1/1, 1/2, 2/1, 3/1, 2/2, ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nHàm nhận một số nguyên 'n' và trả về phần tử thứ 'n' trong dãy này dưới dạng một chuỗi theo định dạng 'tử số/mẫu số'.\nĐầu vào: Một số nguyên 'n' (n < 20000).\nĐầu ra: Một chuỗi đại diện cho phần tử thứ 'n' trong dãy.\nVí dụ:\n- Đầu vào: 3, Đầu ra: \"2/1\"\n- Đầu vào: 14, Đầu ra: \"2/4\""
    },
    "instruction_bertscore": {
      "es": "0.9823433481690467",
      "arb": "0.9751036680410872",
      "sw": "0.9740129886188246",
      "tr": "0.9939395884442446",
      "vi": "0.9604604377208141"
    },
    "level": "middle",
    "test": "function main(){\n    assert(findFractionalElement(3) === \"2/1\");\n    assert(findFractionalElement(14) === \"2/4\");\n    assert(findFractionalElement(7) === \"1/4\");\n    assert(findFractionalElement(12345) === \"59/99\");\n    \n}\n\nmain();\n?>",
    "entry_point": "findFractionalElement",
    "signature": "function findFractionalElement($n)",
    "docstring": {
      "en": "Finds the fractional element in a diagonally arranged sequence.\nIn this sequence, fractions are arranged in a diagonal pattern. The first row contains fractions with the numerator 1 and increasing denominators. Each subsequent row increases the numerator and decreases the denominator until it reaches 1.\nFor example, the sequence starts with 1/1, 1/2, 2/1, 3/1, 2/2, ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nThe function takes an integer 'n' and returns the 'n'th element in this sequence as a string in the form 'numerator/denominator'.\nInput: An integer 'n' (n < 20000).\nOutput: A string representing the 'n'th element in the sequence.\nExamples:\n- Input: 3, Output: \"2/1\"\n- Input: 14, Output: \"2/4\"",
      "es": "Encuentra el elemento fraccionario en una secuencia dispuesta diagonalmente.\nEn esta secuencia, las fracciones están dispuestas en un patrón diagonal. La primera fila contiene fracciones con el numerador 1 y denominadores en aumento. Cada fila subsiguiente aumenta el numerador y disminuye el denominador hasta que llega a 1.\nPor ejemplo, la secuencia comienza con 1/1, 1/2, 2/1, 3/1, 2/2, ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nLa función toma un entero 'n' y devuelve el elemento 'n' en esta secuencia como una cadena en la forma 'numerador/denominador'.\nEntrada: Un entero 'n' (n < 20000).\nSalida: Una cadena que representa el elemento 'n' en la secuencia.\nEjemplos:\n- Entrada: 3, Salida: \"2/1\"\n- Entrada: 14, Salida: \"2/4\"",
      "arb": "يعثر على العنصر الكسري في تسلسل مرتب بشكل قطري.\nفي هذا التسلسل، يتم ترتيب الكسور في نمط قطري. يحتوي الصف الأول على كسور مع البسط 1 والمقامات المتزايدة. كل صف لاحق يزيد البسط ويقلل المقام حتى يصل إلى 1.\nعلى سبيل المثال، يبدأ التسلسل بـ 1/1، 1/2، 2/1، 3/1، 2/2، ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nتأخذ الدالة عددًا صحيحًا 'n' وتعيد العنصر 'n' في هذا التسلسل كسلسلة نصية في الشكل 'بسط/مقام'.\nالمدخل: عدد صحيح 'n' (n < 20000).\nالمخرج: سلسلة نصية تمثل العنصر 'n' في التسلسل.\nأمثلة:\n- المدخل: 3، المخرج: \"2/1\"\n- المدخل: 14، المخرج: \"2/4\"",
      "sw": "Inapata kipengele cha sehemu katika mlolongo uliopangwa kwa diagonal.\nKatika mlolongo huu, sehemu zimepangwa katika muundo wa diagonal. Safu ya kwanza ina sehemu zenye kizio 1 na viambato vinavyoongezeka. Kila safu inayofuata inaongeza kizio na kupunguza kiambato hadi inafikia 1.\nKwa mfano, mlolongo unaanza na 1/1, 1/2, 2/1, 3/1, 2/2, ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nKazi inachukua nambari nzima 'n' na inarudisha kipengele cha 'n' katika mlolongo huu kama kamba katika umbo la 'kizio/kiambato'.\nIngizo: Nambari nzima 'n' (n < 20000).\nPato: Kamba inayowakilisha kipengele cha 'n' katika mlolongo.\nMifano:\n- Ingizo: 3, Pato: \"2/1\"\n- Ingizo: 14, Pato: \"2/4\"",
      "tr": "Diyagonal olarak düzenlenmiş bir dizide kesirli elemanı bulur.\nBu dizide, kesirler diyagonal bir desende düzenlenmiştir. İlk satır, payı 1 olan ve paydaları artan kesirleri içerir. Her bir sonraki satır, payı artırır ve payda 1'e ulaşana kadar azaltır.\nÖrneğin, dizi 1/1, 1/2, 2/1, 3/1, 2/2, ... ile başlar.\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nFonksiyon bir tamsayı 'n' alır ve bu dizideki 'n'inci elemanı 'pay/payda' şeklinde bir string olarak döndürür.\nGirdi: Bir tamsayı 'n' (n < 20000).\nÇıktı: Dizideki 'n'inci elemanı temsil eden bir string.\nÖrnekler:\n- Girdi: 3, Çıktı: \"2/1\"\n- Girdi: 14, Çıktı: \"2/4\"",
      "vi": "Tìm phần tử phân số trong một dãy sắp xếp theo đường chéo.  \nTrong dãy này, các phân số được sắp xếp theo một mẫu đường chéo. Hàng đầu tiên chứa các phân số với tử số là 1 và mẫu số tăng dần. Mỗi hàng tiếp theo sẽ tăng tử số và giảm mẫu số cho đến khi đạt 1.  \nVí dụ, dãy bắt đầu với 1/1, 1/2, 2/1, 3/1, 2/2, ...  \n1/1   1/2   1/3   1/4   1/5  \n\n2/1   2/2   2/3   2/4  \n\n3/1   3/2   3/3  \n\n4/1   4/2  \n\n5/1  \n\nHàm nhận một số nguyên 'n' và trả về phần tử thứ 'n' trong dãy này dưới dạng chuỗi theo dạng 'tử số/mẫu số'.  \nĐầu vào: Một số nguyên 'n' (n < 20000).  \nĐầu ra: Một chuỗi đại diện cho phần tử thứ 'n' trong dãy.  \nVí dụ:  \n- Đầu vào: 3, Đầu ra: \"2/1\"  \n- Đầu vào: 14, Đầu ra: \"2/4\"  "
    },
    "docstring_bertscore": {
      "es": "0.9741270024575386",
      "arb": "0.9762722105727154",
      "sw": "0.9576243931403979",
      "tr": "0.9879270468103185",
      "vi": "0.9436775609360333"
    }
  },
  {
    "task_id": "PHP/13",
    "prompt": {
      "en": "<?php\n\n/**\n    * Calculates the monthly repayment amount for an equal principal repayment loan.\n    * In this repayment model, each month's repayment amount consists of two parts:\n    * - A constant principal payment, which is the total loan amount divided by the total number of months.\n    * - The interest payment, which is the outstanding loan amount multiplied by the monthly interest rate.\n    * Input: \n    * - $loanAmount (int): The total loan amount in ten-thousands.\n    * - $monthlyInterestRate (float): The monthly interest rate.\n    * - $totalMonths (int): The total number of months for loan repayment.\n    * Output: Returns the first month's repayment amount as an integer (in Yuan). Discard the decimal point and do not round\n    * Example: calculateMonthlyRepayment(500, 0.004, 360) should return 33889.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int ",
      "es": "<?php\n\n/**\n    * Calcula el monto de pago mensual para un préstamo con amortización de capital igual.\n    * En este modelo de amortización, el monto de pago de cada mes consta de dos partes:\n    * - Un pago de capital constante, que es el monto total del préstamo dividido por el número total de meses.\n    * - El pago de intereses, que es el monto del préstamo pendiente multiplicado por la tasa de interés mensual.\n    * Entrada: \n    * - $loanAmount (int): El monto total del préstamo en decenas de miles.\n    * - $monthlyInterestRate (float): La tasa de interés mensual.\n    * - $totalMonths (int): El número total de meses para la amortización del préstamo.\n    * Salida: Devuelve el monto del pago del primer mes como un entero (en Yuanes). Descartar el punto decimal y no redondear\n    * Ejemplo: calculateMonthlyRepayment(500, 0.004, 360) debería devolver 33889.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int ",
      "arb": "<?php\n\n/**\n    * يحسب مبلغ السداد الشهري لقرض بسداد رأس المال المتساوي.\n    * في هذا النموذج من السداد، يتكون مبلغ السداد الشهري من جزئين:\n    * - دفعة رأس المال الثابتة، وهي مبلغ القرض الإجمالي مقسوم على إجمالي عدد الأشهر.\n    * - دفعة الفائدة، وهي مبلغ القرض المتبقي مضروب في معدل الفائدة الشهري.\n    * المدخلات:\n    * - $loanAmount (int): إجمالي مبلغ القرض بالآلاف.\n    * - $monthlyInterestRate (float): معدل الفائدة الشهري.\n    * - $totalMonths (int): إجمالي عدد الأشهر لسداد القرض.\n    * المخرجات: يعيد مبلغ السداد للشهر الأول كعدد صحيح (باليوان). تجاهل الفاصلة العشرية ولا تقم بالتقريب\n    * مثال: calculateMonthlyRepayment(500, 0.004, 360) يجب أن يعيد 33889.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int ",
      "sw": "<?php\n\n/**\n    * Hukokotoa kiasi cha malipo ya kila mwezi kwa mkopo wa malipo ya mtaji sawa.\n    * Katika mfano huu wa malipo, kiasi cha malipo ya kila mwezi kinajumuisha sehemu mbili:\n    * - Malipo ya mtaji ya kudumu, ambayo ni jumla ya kiasi cha mkopo kilichogawanywa na jumla ya idadi ya miezi.\n    * - Malipo ya riba, ambayo ni kiasi cha mkopo kilichosalia kinachozidishwa na kiwango cha riba cha kila mwezi.\n    * Ingizo: \n    * - $loanAmount (int): Jumla ya kiasi cha mkopo kwa maelfu kumi.\n    * - $monthlyInterestRate (float): Kiwango cha riba cha kila mwezi.\n    * - $totalMonths (int): Jumla ya idadi ya miezi ya ulipaji wa mkopo.\n    * Tokeo: Inarudisha kiasi cha malipo ya mwezi wa kwanza kama namba nzima (katika Yuan). Puuza nukta ya desimali na usikadirie\n    * Mfano: calculateMonthlyRepayment(500, 0.004, 360) inapaswa kurudisha 33889.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int ",
      "tr": "<?php\n\n/**\n    * Eşit anapara ödemeli bir kredi için aylık geri ödeme tutarını hesaplar.\n    * Bu geri ödeme modelinde, her ayın geri ödeme tutarı iki bölümden oluşur:\n    * - Sabit bir anapara ödemesi, bu toplam kredi tutarının toplam ay sayısına bölünmesiyle elde edilir.\n    * - Faiz ödemesi, kalan kredi tutarının aylık faiz oranı ile çarpılmasıyla elde edilir.\n    * Girdi: \n    * - $loanAmount (int): On binler cinsinden toplam kredi tutarı.\n    * - $monthlyInterestRate (float): Aylık faiz oranı.\n    * - $totalMonths (int): Kredi geri ödemesi için toplam ay sayısı.\n    * Çıktı: İlk ayın geri ödeme tutarını bir tamsayı olarak (Yuan cinsinden) döndürür. Ondalık noktayı atın ve yuvarlamayın\n    * Örnek: calculateMonthlyRepayment(500, 0.004, 360) 33889 döndürmelidir.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int ",
      "vi": "<?php\n\n/**\n    * Tính toán số tiền trả hàng tháng cho khoản vay trả gốc đều.\n    * Trong mô hình trả nợ này, số tiền trả hàng tháng bao gồm hai phần:\n    * - Một khoản trả gốc cố định, là tổng số tiền vay chia cho tổng số tháng.\n    * - Khoản trả lãi, là số tiền vay còn lại nhân với lãi suất hàng tháng.\n    * Đầu vào: \n    * - $loanAmount (int): Tổng số tiền vay tính bằng mười nghìn.\n    * - $monthlyInterestRate (float): Lãi suất hàng tháng.\n    * - $totalMonths (int): Tổng số tháng để trả khoản vay.\n    * Đầu ra: Trả về số tiền trả tháng đầu tiên dưới dạng số nguyên (tính bằng Nhân dân tệ). Bỏ phần thập phân và không làm tròn\n    * Ví dụ: calculateMonthlyRepayment(500, 0.004, 360) sẽ trả về 33889.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int "
    },
    "prompt_bertscore": {
      "es": "0.947035010266666",
      "arb": "0.9585154490297205",
      "sw": "0.954965129599103",
      "tr": "0.956616542587027",
      "vi": "0.9550942393467756"
    },
    "canonical_solution": "{\n    $principalPayment = ($loanAmount * 10000) / $totalMonths;\n    $interestPayment = $loanAmount * 10000 * $monthlyInterestRate;\n    return (int) $principalPayment + $interestPayment;\n}",
    "instruction": {
      "en": "Write a PHP function `function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int` to solve the following problem:\nCalculates the monthly repayment amount for an equal principal repayment loan.\nIn this repayment model, each month's repayment amount consists of two parts:\n- A constant principal payment, which is the total loan amount divided by the total number of months.\n- The interest payment, which is the outstanding loan amount multiplied by the monthly interest rate.\nInput:\n- $loanAmount (int): The total loan amount in ten-thousands.\n- $monthlyInterestRate (float): The monthly interest rate.\n- $totalMonths (int): The total number of months for loan repayment.\nOutput: Returns the first month's repayment amount as an integer (in Yuan). Discard the decimal point and do not round\nExample: calculateMonthlyRepayment(500, 0.004, 360) should return 33889.",
      "es": "Escribe una función PHP `function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int` para resolver el siguiente problema:\nCalcula el monto de pago mensual para un préstamo de amortización de principal igual.\nEn este modelo de amortización, el monto de pago de cada mes consta de dos partes:\n- Un pago de principal constante, que es el monto total del préstamo dividido por el número total de meses.\n- El pago de intereses, que es el monto del préstamo pendiente multiplicado por la tasa de interés mensual.\nEntrada:\n- $loanAmount (int): El monto total del préstamo en decenas de miles.\n- $monthlyInterestRate (float): La tasa de interés mensual.\n- $totalMonths (int): El número total de meses para el pago del préstamo.\nSalida: Devuelve el monto del pago del primer mes como un entero (en Yuanes). Descarta el punto decimal y no redondees.\nEjemplo: calculateMonthlyRepayment(500, 0.004, 360) debería devolver 33889.",
      "arb": "اكتب دالة PHP `function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int` لحل المشكلة التالية:\nتحسب مبلغ السداد الشهري لقرض بسداد أصل القرض بالتساوي.\nفي هذا النموذج من السداد، يتكون مبلغ السداد الشهري من جزئين:\n- دفعة أصل ثابتة، وهي إجمالي مبلغ القرض مقسوم على إجمالي عدد الأشهر.\n- دفعة الفائدة، وهي مبلغ القرض المتبقي مضروبًا في معدل الفائدة الشهري.\nالمدخلات:\n- $loanAmount (int): إجمالي مبلغ القرض بعشرات الآلاف.\n- $monthlyInterestRate (float): معدل الفائدة الشهري.\n- $totalMonths (int): إجمالي عدد الأشهر لسداد القرض.\nالمخرجات: يعيد مبلغ السداد للشهر الأول كعدد صحيح (باليوان). تجاهل النقطة العشرية ولا تقم بالتقريب\nمثال: calculateMonthlyRepayment(500, 0.004, 360) يجب أن يعيد 33889.",
      "sw": "Andika kazi ya PHP `function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int` kutatua tatizo lifuatalo:\nInakokotoa kiasi cha malipo ya kila mwezi kwa mkopo wa ulipaji sawa wa mtaji.\nKatika mfano huu wa ulipaji, kiasi cha malipo ya kila mwezi kinajumuisha sehemu mbili:\n- Malipo ya mtaji ya kudumu, ambayo ni jumla ya kiasi cha mkopo kilichogawanywa na jumla ya idadi ya miezi.\n- Malipo ya riba, ambayo ni kiasi cha mkopo kilichosalia kinachozidishwa na kiwango cha riba cha kila mwezi.\nIngizo:\n- $loanAmount (int): Jumla ya kiasi cha mkopo katika maelfu kumi.\n- $monthlyInterestRate (float): Kiwango cha riba cha kila mwezi.\n- $totalMonths (int): Jumla ya idadi ya miezi kwa ulipaji wa mkopo.\nMatokeo: Inarudisha kiasi cha malipo ya mwezi wa kwanza kama namba nzima (katika Yuan). Puuza nukta ya desimali na usikokotoe\nMfano: calculateMonthlyRepayment(500, 0.004, 360) inapaswa kurudisha 33889.",
      "tr": "Bir PHP fonksiyonu `function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int` yazın ve aşağıdaki problemi çözün:\nEşit anapara ödemeli bir kredi için aylık geri ödeme tutarını hesaplar.\nBu geri ödeme modelinde, her ayın geri ödeme tutarı iki kısımdan oluşur:\n- Sabit bir anapara ödemesi, bu toplam kredi tutarının toplam ay sayısına bölünmesiyle elde edilir.\n- Faiz ödemesi, kalan kredi tutarının aylık faiz oranı ile çarpılmasıyla elde edilir.\nGirdi:\n- $loanAmount (int): Toplam kredi tutarı on binlerce.\n- $monthlyInterestRate (float): Aylık faiz oranı.\n- $totalMonths (int): Kredinin geri ödeneceği toplam ay sayısı.\nÇıktı: İlk ayın geri ödeme tutarını bir tam sayı olarak döndürür (Yuan cinsinden). Ondalık noktayı atın ve yuvarlamayın.\nÖrnek: calculateMonthlyRepayment(500, 0.004, 360) 33889 döndürmelidir.",
      "vi": "Viết một hàm PHP `function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int` để giải quyết vấn đề sau:\nTính toán số tiền trả hàng tháng cho khoản vay trả gốc đều.\nTrong mô hình trả nợ này, số tiền trả hàng tháng bao gồm hai phần:\n- Một khoản trả gốc cố định, là tổng số tiền vay chia cho tổng số tháng.\n- Khoản trả lãi, là số tiền vay còn lại nhân với lãi suất hàng tháng.\nĐầu vào:\n- $loanAmount (int): Tổng số tiền vay tính bằng mười nghìn.\n- $monthlyInterestRate (float): Lãi suất hàng tháng.\n- $totalMonths (int): Tổng số tháng để trả nợ vay.\nĐầu ra: Trả về số tiền trả của tháng đầu tiên dưới dạng số nguyên (tính bằng Nhân dân tệ). Bỏ phần thập phân và không làm tròn.\nVí dụ: calculateMonthlyRepayment(500, 0.004, 360) sẽ trả về 33889."
    },
    "instruction_bertscore": {
      "es": "0.9690468318321903",
      "arb": "0.9599426083174561",
      "sw": "0.9531705041064527",
      "tr": "0.9377685057306264",
      "vi": "0.9508171313519513"
    },
    "level": "easy",
    "test": "function main(){\n    assert(calculateMonthlyRepayment(500, 0.004, 360) === 33888);\n    assert(calculateMonthlyRepayment(300, 0.005, 180) === 31666); // Example test case\n\n}\n\nmain();\n?>",
    "entry_point": "calculateMonthlyRepayment",
    "signature": "function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int",
    "docstring": {
      "en": "Calculates the monthly repayment amount for an equal principal repayment loan.\nIn this repayment model, each month's repayment amount consists of two parts:\n- A constant principal payment, which is the total loan amount divided by the total number of months.\n- The interest payment, which is the outstanding loan amount multiplied by the monthly interest rate.\nInput:\n- $loanAmount (int): The total loan amount in ten-thousands.\n- $monthlyInterestRate (float): The monthly interest rate.\n- $totalMonths (int): The total number of months for loan repayment.\nOutput: Returns the first month's repayment amount as an integer (in Yuan). Discard the decimal point and do not round\nExample: calculateMonthlyRepayment(500, 0.004, 360) should return 33889.",
      "es": "Calcula el monto de reembolso mensual para un préstamo de amortización de capital igual. En este modelo de reembolso, el monto de reembolso de cada mes consta de dos partes: \n- Un pago de capital constante, que es el monto total del préstamo dividido por el número total de meses.\n- El pago de intereses, que es el monto del préstamo pendiente multiplicado por la tasa de interés mensual.\nEntrada:\n- $loanAmount (int): El monto total del préstamo en decenas de miles.\n- $monthlyInterestRate (float): La tasa de interés mensual.\n- $totalMonths (int): El número total de meses para el reembolso del préstamo.\nSalida: Devuelve el monto del reembolso del primer mes como un entero (en Yuan). Descartar el punto decimal y no redondear.\nEjemplo: calculateMonthlyRepayment(500, 0.004, 360) debería devolver 33889.",
      "arb": "يحسب مبلغ السداد الشهري لقرض سداد رأس المال المتساوي. في هذا النموذج من السداد، يتكون مبلغ السداد الشهري من جزئين:\n- دفعة رأس المال الثابتة، وهي إجمالي مبلغ القرض مقسوم على إجمالي عدد الأشهر.\n- دفعة الفائدة، وهي مبلغ القرض المستحق مضروبًا في معدل الفائدة الشهري.\nالمدخلات:\n- $loanAmount (int): إجمالي مبلغ القرض بعشرات الآلاف.\n- $monthlyInterestRate (float): معدل الفائدة الشهري.\n- $totalMonths (int): إجمالي عدد الأشهر لسداد القرض.\nالمخرجات: يعيد مبلغ السداد للشهر الأول كعدد صحيح (باليوان). تجاهل الفاصلة العشرية ولا تقم بالتقريب.\nمثال: calculateMonthlyRepayment(500, 0.004, 360) يجب أن يعيد 33889.",
      "sw": "Hesabu kiasi cha malipo ya kila mwezi kwa mkopo wa ulipaji wa mtaji sawa.\nKatika mfano huu wa ulipaji, kiasi cha malipo ya kila mwezi kinajumuisha sehemu mbili:\n- Malipo ya mtaji ya kudumu, ambayo ni jumla ya kiasi cha mkopo kilichogawanywa na jumla ya idadi ya miezi.\n- Malipo ya riba, ambayo ni kiasi cha mkopo kilichosalia kimezidishwa na kiwango cha riba cha kila mwezi.\nIngizo:\n- $loanAmount (int): Jumla ya kiasi cha mkopo katika makumi ya maelfu.\n- $monthlyInterestRate (float): Kiwango cha riba cha kila mwezi.\n- $totalMonths (int): Jumla ya idadi ya miezi kwa ulipaji wa mkopo.\nMatokeo: Inarejesha kiasi cha malipo ya mwezi wa kwanza kama nambari kamili (katika Yuan). Puuza nukta ya desimali na usikadirie\nMfano: calculateMonthlyRepayment(500, 0.004, 360) inapaswa kurejesha 33889.",
      "tr": "Aylık eşit anapara ödemeli bir kredi için aylık geri ödeme tutarını hesaplar.\nBu geri ödeme modelinde, her ayın geri ödeme tutarı iki bölümden oluşur:\n- Sabit bir anapara ödemesi, bu toplam kredi tutarının toplam ay sayısına bölünmesiyle elde edilir.\n- Faiz ödemesi, kalan kredi tutarının aylık faiz oranı ile çarpılmasıyla elde edilir.\nGirdi:\n- $loanAmount (int): Toplam kredi tutarı on binlerce.\n- $monthlyInterestRate (float): Aylık faiz oranı.\n- $totalMonths (int): Kredi geri ödemesi için toplam ay sayısı.\nÇıktı: İlk ayın geri ödeme tutarını bir tamsayı olarak döndürür (Yuan cinsinden). Ondalık noktayı atın ve yuvarlamayın\nÖrnek: calculateMonthlyRepayment(500, 0.004, 360) 33889 döndürmelidir.",
      "vi": "Tính toán số tiền trả hàng tháng cho khoản vay trả gốc đều.  \nTrong mô hình trả nợ này, số tiền trả hàng tháng bao gồm hai phần:  \n- Một khoản trả gốc cố định, là tổng số tiền vay chia cho tổng số tháng.  \n- Khoản trả lãi, là số tiền vay còn lại nhân với lãi suất hàng tháng.  \nĐầu vào:  \n- $loanAmount (int): Tổng số tiền vay tính bằng hàng chục nghìn.  \n- $monthlyInterestRate (float): Lãi suất hàng tháng.  \n- $totalMonths (int): Tổng số tháng để trả nợ vay.  \nĐầu ra: Trả về số tiền trả tháng đầu tiên dưới dạng số nguyên (tính bằng Nhân dân tệ). Bỏ phần thập phân và không làm tròn.  \nVí dụ: calculateMonthlyRepayment(500, 0.004, 360) sẽ trả về 33889."
    },
    "docstring_bertscore": {
      "es": "0.9739164542536416",
      "arb": "0.9544371700463121",
      "sw": "0.942969840888406",
      "tr": "0.9436104238672435",
      "vi": "0.9535860388635776"
    }
  },
  {
    "task_id": "PHP/14",
    "prompt": {
      "en": "<?php\n/**\n * Converts a decimal number into a sum of powers of 2.\n * This function is useful for understanding the binary representation of a decimal number.\n * It breaks down the number into a sum of powers of 2, which are easier to understand and work with,\n * especially in contexts where binary calculations are frequent.\n * \n * For example:\n * - Input: 7\n * - Output: \"7=4+2+1\"\n * - Input: 43\n * - Output: \"43=32+8+2+1\"\n * \n * Input: A single integer ($number), where 0 < $number < 1000000.\n * Output: A string representing the equation of the sum of powers of 2 that equals the input number.\n */\n\nfunction decimalToBinarySum($number) ",
      "es": "<?php\n/**\n * Convierte un número decimal en una suma de potencias de 2.\n * Esta función es útil para entender la representación binaria de un número decimal.\n * Descompone el número en una suma de potencias de 2, que son más fáciles de entender y trabajar,\n * especialmente en contextos donde los cálculos binarios son frecuentes.\n * \n * Por ejemplo:\n * - Entrada: 7\n * - Salida: \"7=4+2+1\"\n * - Entrada: 43\n * - Salida: \"43=32+8+2+1\"\n * \n * Entrada: Un solo entero ($number), donde 0 < $number < 1000000.\n * Salida: Una cadena que representa la ecuación de la suma de potencias de 2 que es igual al número de entrada.\n */\n\nfunction decimalToBinarySum($number) ",
      "arb": "<?php\n/**\n * يحول رقمًا عشريًا إلى مجموع قوى العدد 2.\n * هذه الدالة مفيدة لفهم التمثيل الثنائي لرقم عشري.\n * تقوم بتفكيك الرقم إلى مجموع قوى العدد 2، مما يسهل فهمه والتعامل معه،\n * خاصة في السياقات التي تكون فيها الحسابات الثنائية متكررة.\n * \n * على سبيل المثال:\n * - المدخل: 7\n * - المخرج: \"7=4+2+1\"\n * - المدخل: 43\n * - المخرج: \"43=32+8+2+1\"\n * \n * المدخل: عدد صحيح واحد ($number)، حيث 0 < $number < 1000000.\n * المخرج: سلسلة نصية تمثل معادلة مجموع قوى العدد 2 التي تساوي الرقم المدخل.\n */\n\nfunction decimalToBinarySum($number) ",
      "sw": "<?php\n/**\n * Hubadilisha nambari ya desimali kuwa jumla ya nguvu za 2.\n * Kazi hii ni muhimu kwa kuelewa uwakilishi wa binary wa nambari ya desimali.\n * Inavunja nambari kuwa jumla ya nguvu za 2, ambazo ni rahisi kuelewa na kufanya kazi nazo,\n * hasa katika muktadha ambapo mahesabu ya binary ni ya mara kwa mara.\n * \n * Kwa mfano:\n * - Ingizo: 7\n * - Matokeo: \"7=4+2+1\"\n * - Ingizo: 43\n * - Matokeo: \"43=32+8+2+1\"\n * \n * Ingizo: Nambari moja ($number), ambapo 0 < $number < 1000000.\n * Matokeo: Mstari wa maandishi unaowakilisha mlingano wa jumla ya nguvu za 2 ambazo ni sawa na nambari ya ingizo.\n */\n\nfunction decimalToBinarySum($number) ",
      "tr": "<?php\n/**\n * Ondalık bir sayıyı 2'nin kuvvetlerinin toplamına dönüştürür.\n * Bu fonksiyon, bir ondalık sayının ikili gösterimini anlamak için faydalıdır.\n * Sayıyı, özellikle ikili hesaplamaların sık olduğu bağlamlarda anlaması ve çalışması daha kolay olan 2'nin kuvvetlerinin toplamına ayırır.\n * \n * Örneğin:\n * - Girdi: 7\n * - Çıktı: \"7=4+2+1\"\n * - Girdi: 43\n * - Çıktı: \"43=32+8+2+1\"\n * \n * Girdi: 0 < $number < 1000000 olan tek bir tamsayı ($number).\n * Çıktı: Girdi sayısına eşit olan 2'nin kuvvetlerinin toplamının denklemini temsil eden bir dize.\n */\n\nfunction decimalToBinarySum($number) ",
      "vi": "<?php\n/**\n * Chuyển đổi một số thập phân thành tổng của các lũy thừa của 2.\n * Hàm này hữu ích để hiểu cách biểu diễn nhị phân của một số thập phân.\n * Nó phân tích số thành tổng của các lũy thừa của 2, dễ hiểu và làm việc hơn,\n * đặc biệt trong các ngữ cảnh nơi tính toán nhị phân thường xuyên xảy ra.\n * \n * Ví dụ:\n * - Đầu vào: 7\n * - Đầu ra: \"7=4+2+1\"\n * - Đầu vào: 43\n * - Đầu ra: \"43=32+8+2+1\"\n * \n * Đầu vào: Một số nguyên ($number), nơi 0 < $number < 1000000.\n * Đầu ra: Một chuỗi đại diện cho phương trình của tổng các lũy thừa của 2 bằng với số đầu vào.\n */\n\nfunction decimalToBinarySum($number) "
    },
    "prompt_bertscore": {
      "es": "0.9962176802843337",
      "arb": "0.9862295515739943",
      "sw": "0.9849686459151848",
      "tr": "0.9788401041387343",
      "vi": "0.9697007230465571"
    },
    "canonical_solution": "{\n    $result = $number . \"=\";\n    $power = 0;\n\n    while ((1 << $power) <= $number) {\n        $power++;\n    }\n\n    while ($number > 0) {\n        $power--;\n        $currentPowerOfTwo = 1 << $power;\n        if ($currentPowerOfTwo <= $number) {\n            $number -= $currentPowerOfTwo;\n            $result .= $currentPowerOfTwo . \"+\";\n        }\n    }\n\n    return rtrim($result, \"+\");\n}",
    "instruction": {
      "en": "Write a PHP function `function decimalToBinarySum($number)` to solve the following problem:\nConverts a decimal number into a sum of powers of 2.\nThis function is useful for understanding the binary representation of a decimal number.\nIt breaks down the number into a sum of powers of 2, which are easier to understand and work with,\nespecially in contexts where binary calculations are frequent.\n\nFor example:\n- Input: 7\n- Output: \"7=4+2+1\"\n- Input: 43\n- Output: \"43=32+8+2+1\"\n\nInput: A single integer ($number), where 0 < $number < 1000000.\nOutput: A string representing the equation of the sum of powers of 2 that equals the input number.",
      "es": "Escribe una función PHP `function decimalToBinarySum($number)` para resolver el siguiente problema:\nConvierte un número decimal en una suma de potencias de 2.\nEsta función es útil para entender la representación binaria de un número decimal.\nDescompone el número en una suma de potencias de 2, que son más fáciles de entender y trabajar,\nespecialmente en contextos donde los cálculos binarios son frecuentes.\n\nPor ejemplo:\n- Entrada: 7\n- Salida: \"7=4+2+1\"\n- Entrada: 43\n- Salida: \"43=32+8+2+1\"\n\nEntrada: Un solo entero ($number), donde 0 < $number < 1000000.\nSalida: Una cadena que representa la ecuación de la suma de potencias de 2 que es igual al número de entrada.",
      "arb": "اكتب دالة PHP `function decimalToBinarySum($number)` لحل المشكلة التالية:\nتحويل رقم عشري إلى مجموع قوى العدد 2.\nهذه الدالة مفيدة لفهم التمثيل الثنائي لرقم عشري.\nتقوم بتفكيك الرقم إلى مجموع قوى العدد 2، مما يسهل فهمه والتعامل معه،\nخاصة في السياقات التي تكون فيها الحسابات الثنائية متكررة.\n\nعلى سبيل المثال:\n- المدخل: 7\n- المخرج: \"7=4+2+1\"\n- المدخل: 43\n- المخرج: \"43=32+8+2+1\"\n\nالمدخل: عدد صحيح واحد ($number)، حيث 0 < $number < 1000000.\nالمخرج: سلسلة تمثل معادلة مجموع قوى العدد 2 التي تساوي الرقم المدخل.",
      "sw": "Andika kazi ya PHP `function decimalToBinarySum($number)` kutatua tatizo lifuatalo:\nInabadilisha nambari ya desimali kuwa jumla ya nguvu za 2.\nKazi hii ni muhimu kwa kuelewa uwakilishi wa nambari ya desimali katika mfumo wa binary.\nInavunja nambari kuwa jumla ya nguvu za 2, ambazo ni rahisi kuelewa na kufanya kazi nazo,\nhasa katika muktadha ambapo mahesabu ya binary ni ya mara kwa mara.\n\nKwa mfano:\n- Ingizo: 7\n- Matokeo: \"7=4+2+1\"\n- Ingizo: 43\n- Matokeo: \"43=32+8+2+1\"\n\nIngizo: Nambari moja ($number), ambapo 0 < $number < 1000000.\nMatokeo: Mstari wa maandishi unaowakilisha mlinganyo wa jumla ya nguvu za 2 inayolingana na nambari ya ingizo.",
      "tr": "Bir PHP fonksiyonu `function decimalToBinarySum($number)` yazın ve aşağıdaki problemi çözün:\nBir ondalık sayıyı 2'nin kuvvetlerinin toplamına dönüştürür.\nBu fonksiyon, bir ondalık sayının ikili gösterimini anlamak için faydalıdır.\nSayıyı, anlaması ve çalışması daha kolay olan 2'nin kuvvetlerinin toplamına ayırır,\nözellikle ikili hesaplamaların sık olduğu bağlamlarda.\n\nÖrneğin:\n- Girdi: 7\n- Çıktı: \"7=4+2+1\"\n- Girdi: 43\n- Çıktı: \"43=32+8+2+1\"\n\nGirdi: Tek bir tamsayı ($number), burada 0 < $number < 1000000.\nÇıktı: Girdi sayısına eşit olan 2'nin kuvvetlerinin toplamının denklemini temsil eden bir dize.",
      "vi": "Viết một hàm PHP `function decimalToBinarySum($number)` để giải quyết vấn đề sau:\nChuyển đổi một số thập phân thành tổng của các lũy thừa của 2.\nHàm này hữu ích để hiểu cách biểu diễn nhị phân của một số thập phân.\nNó phân tích số thành tổng của các lũy thừa của 2, dễ hiểu và làm việc hơn,\nđặc biệt trong các ngữ cảnh mà tính toán nhị phân thường xuyên xảy ra.\n\nVí dụ:\n- Đầu vào: 7\n- Đầu ra: \"7=4+2+1\"\n- Đầu vào: 43\n- Đầu ra: \"43=32+8+2+1\"\n\nĐầu vào: Một số nguyên ($number), nơi 0 < $number < 1000000.\nĐầu ra: Một chuỗi biểu diễn phương trình của tổng các lũy thừa của 2 bằng với số đầu vào."
    },
    "instruction_bertscore": {
      "es": "0.9889944864779999",
      "arb": "0.9811734152247512",
      "sw": "0.9701766414395168",
      "tr": "0.9909569546426247",
      "vi": "0.9698314218372781"
    },
    "level": "easy",
    "test": "function main(){\n    assert(decimalToBinarySum(7) === \"7=4+2+1\");\n    assert(decimalToBinarySum(43) === \"43=32+8+2+1\");\n    assert(decimalToBinarySum(15) === \"15=8+4+2+1\");\n    assert(decimalToBinarySum(1) === \"1=1\");\n    assert(decimalToBinarySum(32) === \"32=32\");\n    \n}\n\nmain();\n?>",
    "entry_point": "decimalToBinarySum",
    "signature": "function decimalToBinarySum($number)",
    "docstring": {
      "en": "Converts a decimal number into a sum of powers of 2.\nThis function is useful for understanding the binary representation of a decimal number.\nIt breaks down the number into a sum of powers of 2, which are easier to understand and work with,\nespecially in contexts where binary calculations are frequent.\n\nFor example:\n- Input: 7\n- Output: \"7=4+2+1\"\n- Input: 43\n- Output: \"43=32+8+2+1\"\n\nInput: A single integer ($number), where 0 < $number < 1000000.\nOutput: A string representing the equation of the sum of powers of 2 that equals the input number.",
      "es": "Convierte un número decimal en una suma de potencias de 2.  \nEsta función es útil para entender la representación binaria de un número decimal.  \nDescompone el número en una suma de potencias de 2, que son más fáciles de entender y trabajar,  \nespecialmente en contextos donde los cálculos binarios son frecuentes.  \n\nPor ejemplo:  \n- Entrada: 7  \n- Salida: \"7=4+2+1\"  \n- Entrada: 43  \n- Salida: \"43=32+8+2+1\"  \n\nEntrada: Un solo entero ($number), donde 0 < $number < 1000000.  \nSalida: Una cadena que representa la ecuación de la suma de potencias de 2 que es igual al número de entrada.  ",
      "arb": "تحول رقم عشري إلى مجموع قوى الرقم 2.  \nهذه الدالة مفيدة لفهم التمثيل الثنائي لرقم عشري.  \nتقوم بتفكيك الرقم إلى مجموع قوى الرقم 2، وهو ما يكون أسهل للفهم والعمل معه،  \nخاصة في السياقات التي تكون فيها الحسابات الثنائية متكررة.\n\nعلى سبيل المثال:  \n- المدخل: 7  \n- المخرج: \"7=4+2+1\"  \n- المدخل: 43  \n- المخرج: \"43=32+8+2+1\"\n\nالمدخل: عدد صحيح واحد ($number)، حيث 0 < $number < 1000000.  \nالمخرج: سلسلة نصية تمثل معادلة مجموع قوى الرقم 2 التي تساوي الرقم المدخل.",
      "sw": "Inabadilisha nambari ya desimali kuwa jumla ya nguvu za 2.  \nKazi hii ni muhimu kwa kuelewa uwakilishi wa binary wa nambari ya desimali.  \nInavunja nambari kuwa jumla ya nguvu za 2, ambazo ni rahisi kuelewa na kufanya kazi nazo,  \nhasa katika muktadha ambapo mahesabu ya binary ni ya mara kwa mara.  \n\nKwa mfano:  \n- Ingizo: 7  \n- Matokeo: \"7=4+2+1\"  \n- Ingizo: 43  \n- Matokeo: \"43=32+8+2+1\"  \n\nIngizo: Nambari moja ya mzima ($number), ambapo 0 < $number < 1000000.  \nMatokeo: Mstari wa maandishi unaowakilisha mlinganyo wa jumla ya nguvu za 2 inayolingana na nambari ya ingizo.",
      "tr": "Onluk bir sayıyı 2'nin kuvvetlerinin toplamına dönüştürür.\nBu fonksiyon, onluk bir sayının ikili gösterimini anlamak için kullanışlıdır.\nSayının, özellikle ikili hesaplamaların sık olduğu bağlamlarda anlaması ve çalışması daha kolay olan 2'nin kuvvetlerinin toplamına ayrılmasını sağlar.\n\nÖrneğin:\n- Girdi: 7\n- Çıktı: \"7=4+2+1\"\n- Girdi: 43\n- Çıktı: \"43=32+8+2+1\"\n\nGirdi: 0 < $number < 1000000 olan tek bir tamsayı ($number).\nÇıktı: Girdi sayısına eşit olan 2'nin kuvvetlerinin toplamının denklemini temsil eden bir dize.",
      "vi": "Chuyển đổi một số thập phân thành tổng của các lũy thừa của 2.  \nHàm này hữu ích để hiểu biểu diễn nhị phân của một số thập phân.  \nNó phân tích số thành tổng của các lũy thừa của 2, điều này dễ hiểu và làm việc hơn,  \nđặc biệt trong các ngữ cảnh mà các phép tính nhị phân thường xuyên xảy ra.  \n\nVí dụ:  \n- Đầu vào: 7  \n- Đầu ra: \"7=4+2+1\"  \n- Đầu vào: 43  \n- Đầu ra: \"43=32+8+2+1\"  \n\nĐầu vào: Một số nguyên ($number), với điều kiện 0 < $number < 1000000.  \nĐầu ra: Một chuỗi ký tự đại diện cho phương trình của tổng các lũy thừa của 2 bằng với số đầu vào.  "
    },
    "docstring_bertscore": {
      "es": "0.9951119049531124",
      "arb": "0.9892654183177315",
      "sw": "0.9824257797771762",
      "tr": "0.9716913967252888",
      "vi": "0.9652035325895462"
    }
  },
  {
    "task_id": "PHP/15",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Finds the rectangle with the largest area that includes a given point.\n * In this task, we are given a list of rectangles, each defined by two opposite corner points,\n * and a point referred to as the \"needle\". The rectangles' sides are parallel to the coordinate axes.\n * The goal is to find the rectangle with the maximum area that contains the needle (including its boundary).\n * Input: An array of rectangles (each rectangle is an array of two points [x1, y1, x2, y2]),\n *        and a needle point [x, y].\n * Output: Returns the index (1-based) of the rectangle with the largest area that contains the needle.\n * Example: For rectangles [[1,1,4,4], [2,2,6,6]] and needle point [3,3],\n *          the function should return 2, as the second rectangle is larger and contains the needle.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)",
      "es": "<?php\n\n\n/**\n * Encuentra el rectángulo con el área más grande que incluye un punto dado.\n * En esta tarea, se nos da una lista de rectángulos, cada uno definido por dos puntos de esquina opuestos,\n * y un punto referido como la \"aguja\". Los lados de los rectángulos son paralelos a los ejes de coordenadas.\n * El objetivo es encontrar el rectángulo con el área máxima que contiene la aguja (incluyendo su frontera).\n * Entrada: Un array de rectángulos (cada rectángulo es un array de dos puntos [x1, y1, x2, y2]),\n *          y un punto aguja [x, y].\n * Salida: Devuelve el índice (basado en 1) del rectángulo con el área más grande que contiene la aguja.\n * Ejemplo: Para los rectángulos [[1,1,4,4], [2,2,6,6]] y el punto aguja [3,3],\n *          la función debería devolver 2, ya que el segundo rectángulo es más grande y contiene la aguja.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)",
      "arb": "<?php\n\n\n/**\n * يجد المستطيل ذو المساحة الأكبر الذي يشمل نقطة معينة.\n * في هذه المهمة، لدينا قائمة من المستطيلات، كل منها معرف بنقطتين متقابلتين،\n * ونقطة يشار إليها باسم \"الإبرة\". جوانب المستطيلات موازية لمحاور الإحداثيات.\n * الهدف هو إيجاد المستطيل ذو المساحة القصوى الذي يحتوي على الإبرة (بما في ذلك حدوده).\n * المدخلات: مصفوفة من المستطيلات (كل مستطيل هو مصفوفة من نقطتين [x1, y1, x2, y2]),\n *          ونقطة الإبرة [x, y].\n * المخرجات: يعيد الفهرس (مبني على 1) للمستطيل ذو المساحة الأكبر الذي يحتوي على الإبرة.\n * مثال: للمستطيلات [[1,1,4,4], [2,2,6,6]] ونقطة الإبرة [3,3],\n *        يجب أن تعيد الدالة 2، حيث أن المستطيل الثاني أكبر ويحتوي على الإبرة.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)",
      "sw": "<?php\n\n\n/**\n * Inapata mstatili wenye eneo kubwa zaidi ambao unajumuisha nukta fulani.\n * Katika kazi hii, tunapewa orodha ya mistatili, kila moja ikifafanuliwa na pointi mbili za pembe kinyume,\n * na nukta inayorejelewa kama \"sindano\". Upande wa mistatili ni sambamba na mhimili wa kuratibu.\n * Lengo ni kupata mstatili wenye eneo kubwa zaidi ambao unajumuisha sindano (ikiwa ni pamoja na mpaka wake).\n * Ingizo: Safu ya mistatili (kila mstatili ni safu ya pointi mbili [x1, y1, x2, y2]),\n *        na nukta ya sindano [x, y].\n * Tokeo: Inarudisha faharasa (kwa msingi wa 1) ya mstatili wenye eneo kubwa zaidi ambao unajumuisha sindano.\n * Mfano: Kwa mistatili [[1,1,4,4], [2,2,6,6]] na nukta ya sindano [3,3],\n *          kazi inapaswa kurudisha 2, kwani mstatili wa pili ni mkubwa zaidi na unajumuisha sindano.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)",
      "tr": "<?php\n\n\n/**\n * Belirli bir noktayı içeren en büyük alanlı dikdörtgeni bulur.\n * Bu görevde, her biri iki zıt köşe noktası ile tanımlanan bir dikdörtgen listesi\n * ve \"iğne\" olarak adlandırılan bir nokta verilmektedir. Dikdörtgenlerin kenarları koordinat eksenlerine paraleldir.\n * Amaç, iğneyi (sınırları dahil) içeren en büyük alana sahip dikdörtgeni bulmaktır.\n * Girdi: Dikdörtgenlerin bir dizisi (her dikdörtgen iki noktanın [x1, y1, x2, y2] dizisidir),\n *        ve bir iğne noktası [x, y].\n * Çıktı: İğneyi içeren en büyük alanlı dikdörtgenin indeksini (1 tabanlı) döndürür.\n * Örnek: Dikdörtgenler [[1,1,4,4], [2,2,6,6]] ve iğne noktası [3,3] için,\n *          fonksiyon 2 döndürmelidir, çünkü ikinci dikdörtgen daha büyüktür ve iğneyi içerir.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)",
      "vi": "<?php\n\n\n/**\n * Tìm hình chữ nhật có diện tích lớn nhất bao gồm một điểm cho trước.\n * Trong nhiệm vụ này, chúng ta được cung cấp một danh sách các hình chữ nhật, mỗi hình được xác định bởi hai điểm góc đối diện,\n * và một điểm được gọi là \"kim\". Các cạnh của hình chữ nhật song song với các trục tọa độ.\n * Mục tiêu là tìm hình chữ nhật có diện tích lớn nhất chứa kim (bao gồm cả biên của nó).\n * Đầu vào: Một mảng các hình chữ nhật (mỗi hình chữ nhật là một mảng gồm hai điểm [x1, y1, x2, y2]),\n *          và một điểm kim [x, y].\n * Đầu ra: Trả về chỉ số (bắt đầu từ 1) của hình chữ nhật có diện tích lớn nhất chứa kim.\n * Ví dụ: Với các hình chữ nhật [[1,1,4,4], [2,2,6,6]] và điểm kim [3,3],\n *        hàm nên trả về 2, vì hình chữ nhật thứ hai lớn hơn và chứa kim.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)"
    },
    "prompt_bertscore": {
      "es": "0.9915707225200224",
      "arb": "0.9859387566961593",
      "sw": "0.9813432442005361",
      "tr": "0.9689616193987263",
      "vi": "0.9659132389409839"
    },
    "canonical_solution": "{\n    $maxArea = 0;\n    $maxRectIndex = -1;\n\n    for ($i = 0; $i < count($rectangles); $i++) {\n        $rect = $rectangles[$i];\n        if ($needle[0] >= min($rect[0], $rect[2]) && $needle[0] <= max($rect[0], $rect[2]) &&\n            $needle[1] >= min($rect[1], $rect[3]) && $needle[1] <= max($rect[1], $rect[3])) {\n            $area = abs($rect[2] - $rect[0]) * abs($rect[3] - $rect[1]);\n            if ($area > $maxArea) {\n                $maxArea = $area;\n                $maxRectIndex = $i + 1;\n            }\n        }\n    }\n    \n    return $maxRectIndex;\n}",
    "instruction": {
      "en": "Write a PHP function `function findMaxAreaRectangle($rectangles, $needle)` to solve the following problem:\nFinds the rectangle with the largest area that includes a given point.\nIn this task, we are given a list of rectangles, each defined by two opposite corner points,\nand a point referred to as the \"needle\". The rectangles' sides are parallel to the coordinate axes.\nThe goal is to find the rectangle with the maximum area that contains the needle (including its boundary).\nInput: An array of rectangles (each rectangle is an array of two points [x1, y1, x2, y2]),\nand a needle point [x, y].\nOutput: Returns the index (1-based) of the rectangle with the largest area that contains the needle.\nExample: For rectangles [[1,1,4,4], [2,2,6,6]] and needle point [3,3],\nthe function should return 2, as the second rectangle is larger and contains the needle.",
      "es": "Escribe una función PHP `function findMaxAreaRectangle($rectangles, $needle)` para resolver el siguiente problema:\nEncuentra el rectángulo con el área más grande que incluye un punto dado.\nEn esta tarea, se nos da una lista de rectángulos, cada uno definido por dos puntos de esquina opuestos,\ny un punto referido como la \"aguja\". Los lados de los rectángulos son paralelos a los ejes de coordenadas.\nEl objetivo es encontrar el rectángulo con el área máxima que contiene la aguja (incluyendo su borde).\nEntrada: Un array de rectángulos (cada rectángulo es un array de dos puntos [x1, y1, x2, y2]),\ny un punto de aguja [x, y].\nSalida: Devuelve el índice (basado en 1) del rectángulo con el área más grande que contiene la aguja.\nEjemplo: Para los rectángulos [[1,1,4,4], [2,2,6,6]] y el punto de aguja [3,3],\nla función debería devolver 2, ya que el segundo rectángulo es más grande y contiene la aguja.",
      "arb": "اكتب دالة PHP `function findMaxAreaRectangle($rectangles, $needle)` لحل المشكلة التالية:\nإيجاد المستطيل ذو المساحة الأكبر الذي يتضمن نقطة معينة.\nفي هذه المهمة، يُعطى لنا قائمة من المستطيلات، كل منها معرف بنقطتين متقابلتين،\nونقطة تُشار إليها باسم \"الإبرة\". تكون جوانب المستطيلات موازية لمحاور الإحداثيات.\nالهدف هو إيجاد المستطيل ذو المساحة القصوى الذي يحتوي على الإبرة (بما في ذلك حدوده).\nالمدخلات: مصفوفة من المستطيلات (كل مستطيل هو مصفوفة من نقطتين [x1, y1, x2, y2])،\nونقطة الإبرة [x, y].\nالمخرجات: تعيد فهرس (مبني على 1) المستطيل ذو المساحة الأكبر الذي يحتوي على الإبرة.\nمثال: للمستطيلات [[1,1,4,4], [2,2,6,6]] ونقطة الإبرة [3,3]،\nيجب أن تعيد الدالة 2، حيث أن المستطيل الثاني أكبر ويحتوي على الإبرة.",
      "sw": "Andika kazi ya PHP `function findMaxAreaRectangle($rectangles, $needle)` kutatua tatizo lifuatalo:\nInapata mstatili wenye eneo kubwa zaidi unaojumuisha nukta fulani.\nKatika kazi hii, tunapewa orodha ya mistatili, kila moja ikifafanuliwa na pointi mbili za pembe zinazopingana,\nna nukta inayojulikana kama \"needle\". Pande za mistatili ziko sambamba na mhimili wa kuratibu.\nLengo ni kupata mstatili wenye eneo kubwa zaidi unaojumuisha needle (ikiwa ni pamoja na mpaka wake).\nIngizo: Kundi la mistatili (kila mstatili ni kundi la pointi mbili [x1, y1, x2, y2]),\nna nukta ya needle [x, y].\nMatokeo: Inarudisha faharasa (inayoanza na 1) ya mstatili wenye eneo kubwa zaidi unaojumuisha needle.\nMfano: Kwa mistatili [[1,1,4,4], [2,2,6,6]] na nukta ya needle [3,3],\nkazi inapaswa kurudisha 2, kwani mstatili wa pili ni mkubwa zaidi na unajumuisha needle.",
      "tr": "Bir PHP fonksiyonu `function findMaxAreaRectangle($rectangles, $needle)` yazın. Aşağıdaki problemi çözmek için:\nBelirli bir noktayı içeren en büyük alana sahip dikdörtgeni bulur.\nBu görevde, her biri iki zıt köşe noktası ile tanımlanan bir dizi dikdörtgen ve \"iğne\" olarak adlandırılan bir nokta verilmektedir. Dikdörtgenlerin kenarları koordinat eksenlerine paraleldir. Amaç, iğneyi (sınırları dahil) içeren en büyük alana sahip dikdörtgeni bulmaktır.\nGirdi: Dikdörtgenlerin bir dizisi (her dikdörtgen iki nokta [x1, y1, x2, y2] içeren bir dizi) ve bir iğne noktası [x, y].\nÇıktı: İğneyi içeren en büyük alana sahip dikdörtgenin indeksini (1 tabanlı) döndürür.\nÖrnek: Dikdörtgenler [[1,1,4,4], [2,2,6,6]] ve iğne noktası [3,3] için, fonksiyon 2 döndürmelidir, çünkü ikinci dikdörtgen daha büyüktür ve iğneyi içerir.",
      "vi": "Viết một hàm PHP `function findMaxAreaRectangle($rectangles, $needle)` để giải quyết vấn đề sau:\nTìm hình chữ nhật có diện tích lớn nhất bao gồm một điểm cho trước.\nTrong nhiệm vụ này, chúng ta được cung cấp một danh sách các hình chữ nhật, mỗi hình được định nghĩa bởi hai điểm góc đối diện,\nvà một điểm được gọi là \"kim\". Các cạnh của hình chữ nhật song song với các trục tọa độ.\nMục tiêu là tìm hình chữ nhật có diện tích lớn nhất chứa kim (bao gồm cả biên).\nĐầu vào: Một mảng các hình chữ nhật (mỗi hình chữ nhật là một mảng gồm hai điểm [x1, y1, x2, y2]),\nvà một điểm kim [x, y].\nĐầu ra: Trả về chỉ số (bắt đầu từ 1) của hình chữ nhật có diện tích lớn nhất chứa kim.\nVí dụ: Với các hình chữ nhật [[1,1,4,4], [2,2,6,6]] và điểm kim [3,3],\nhàm nên trả về 2, vì hình chữ nhật thứ hai lớn hơn và chứa kim."
    },
    "instruction_bertscore": {
      "es": "0.9885650475942025",
      "arb": "0.9802356811958856",
      "sw": "0.9723554180890884",
      "tr": "0.9664191505214798",
      "vi": "0.9633667974561166"
    },
    "level": "middle",
    "test": "function main(){\n    assert(findMaxAreaRectangle([[2,3,6,8], [1,3,5,6], [8, 2, 1, 9]], [4,4]) === 3);\n    assert(findMaxAreaRectangle([[6,8,2,3], [1,3,5,6], [8, 2, 1, 9]], [4,4]) === 3);\n    assert(findMaxAreaRectangle([[1,1,4,4], [2,2,6,6]], [3,3]) === 2);\n    assert(findMaxAreaRectangle([[0,0,5,5], [1,1,3,3]], [2,2]) === 1);\n    assert(findMaxAreaRectangle([[1,1,2,2], [2,2,4,4]], [5,5]) === -1); // Needle is outside all rectangles\n    \n}\n\n\nmain();\n?>",
    "entry_point": "findMaxAreaRectangle",
    "signature": "function findMaxAreaRectangle($rectangles, $needle)",
    "docstring": {
      "en": "Finds the rectangle with the largest area that includes a given point.\nIn this task, we are given a list of rectangles, each defined by two opposite corner points,\nand a point referred to as the \"needle\". The rectangles' sides are parallel to the coordinate axes.\nThe goal is to find the rectangle with the maximum area that contains the needle (including its boundary).\nInput: An array of rectangles (each rectangle is an array of two points [x1, y1, x2, y2]),\nand a needle point [x, y].\nOutput: Returns the index (1-based) of the rectangle with the largest area that contains the needle.\nExample: For rectangles [[1,1,4,4], [2,2,6,6]] and needle point [3,3],\nthe function should return 2, as the second rectangle is larger and contains the needle.",
      "es": "Encuentra el rectángulo con el área más grande que incluye un punto dado.\nEn esta tarea, se nos da una lista de rectángulos, cada uno definido por dos puntos de esquina opuestos,\ny un punto referido como la \"aguja\". Los lados de los rectángulos son paralelos a los ejes de coordenadas.\nEl objetivo es encontrar el rectángulo con el área máxima que contiene la aguja (incluyendo su borde).\nEntrada: Un array de rectángulos (cada rectángulo es un array de dos puntos [x1, y1, x2, y2]),\ny un punto aguja [x, y].\nSalida: Devuelve el índice (basado en 1) del rectángulo con el área más grande que contiene la aguja.\nEjemplo: Para los rectángulos [[1,1,4,4], [2,2,6,6]] y el punto aguja [3,3],\nla función debería devolver 2, ya que el segundo rectángulo es más grande y contiene la aguja.",
      "arb": "يعثر على المستطيل ذو المساحة الأكبر الذي يتضمن نقطة معينة.\nفي هذه المهمة، يتم إعطاؤنا قائمة من المستطيلات، كل منها معرف بنقطتين متقابلتين،\nونقطة يشار إليها باسم \"الإبرة\". جوانب المستطيلات موازية لمحاور الإحداثيات.\nالهدف هو العثور على المستطيل ذو المساحة القصوى الذي يحتوي على الإبرة (بما في ذلك حدوده).\nالمدخلات: مصفوفة من المستطيلات (كل مستطيل هو مصفوفة من نقطتين [x1, y1, x2, y2])،\nونقطة الإبرة [x, y].\nالمخرجات: تعيد الفهرس (مبني على أساس 1) للمستطيل ذو المساحة الأكبر الذي يحتوي على الإبرة.\nمثال: للمستطيلات [[1,1,4,4], [2,2,6,6]] ونقطة الإبرة [3,3]،\nيجب أن تعيد الدالة 2، حيث أن المستطيل الثاني أكبر ويحتوي على الإبرة.",
      "sw": "Inapata mstatili wenye eneo kubwa zaidi ambalo linajumuisha nukta fulani.\nKatika kazi hii, tunapewa orodha ya mistatili, kila moja ikifafanuliwa na pointi mbili za pembe zinazopingana,\nna nukta inayojulikana kama \"sindano\". Pande za mistatili ziko sambamba na mhimili wa kuratibu.\nLengo ni kupata mstatili wenye eneo kubwa zaidi ambalo linajumuisha sindano (ikiwa ni pamoja na mpaka wake).\nIngizo: Safu ya mistatili (kila mstatili ni safu ya pointi mbili [x1, y1, x2, y2]),\nna nukta ya sindano [x, y].\nPato: Inarudisha faharasa (inayozingatia 1) ya mstatili wenye eneo kubwa zaidi ambalo linajumuisha sindano.\nMfano: Kwa mistatili [[1,1,4,4], [2,2,6,6]] na nukta ya sindano [3,3],\nkazi inapaswa kurudisha 2, kwani mstatili wa pili ni mkubwa zaidi na unajumuisha sindano.",
      "tr": "Verilen bir noktayı içeren en büyük alanlı dikdörtgeni bulur.\nBu görevde, her biri iki zıt köşe noktası ile tanımlanan bir dizi dikdörtgen ve \"iğne\" olarak adlandırılan bir nokta verilmektedir. Dikdörtgenlerin kenarları koordinat eksenlerine paraleldir. Amaç, iğneyi içeren (sınırları dahil) maksimum alana sahip dikdörtgeni bulmaktır.\nGirdi: Dikdörtgenlerin bir dizisi (her dikdörtgen iki noktadan oluşan bir dizi [x1, y1, x2, y2]) ve bir iğne noktası [x, y].\nÇıktı: İğneyi içeren en büyük alanlı dikdörtgenin dizinini (1 tabanlı) döndürür.\nÖrnek: Dikdörtgenler [[1,1,4,4], [2,2,6,6]] ve iğne noktası [3,3] için, fonksiyon 2 döndürmelidir, çünkü ikinci dikdörtgen daha büyüktür ve iğneyi içerir.",
      "vi": "Tìm hình chữ nhật có diện tích lớn nhất bao gồm một điểm cho trước.  \nTrong nhiệm vụ này, chúng ta được cung cấp một danh sách các hình chữ nhật, mỗi hình được xác định bởi hai điểm góc đối diện,  \nvà một điểm được gọi là \"kim\". Các cạnh của hình chữ nhật song song với các trục tọa độ.  \nMục tiêu là tìm hình chữ nhật có diện tích lớn nhất chứa kim (bao gồm cả biên của nó).  \nĐầu vào: Một mảng các hình chữ nhật (mỗi hình chữ nhật là một mảng gồm hai điểm [x1, y1, x2, y2]),  \nvà một điểm kim [x, y].  \nĐầu ra: Trả về chỉ số (dựa trên 1) của hình chữ nhật có diện tích lớn nhất chứa kim.  \nVí dụ: Đối với các hình chữ nhật [[1,1,4,4], [2,2,6,6]] và điểm kim [3,3],  \nhàm nên trả về 2, vì hình chữ nhật thứ hai lớn hơn và chứa kim.  "
    },
    "docstring_bertscore": {
      "es": "0.9885122119128472",
      "arb": "0.9865135930188742",
      "sw": "0.9683009747514043",
      "tr": "0.961712007751715",
      "vi": "0.951595166554465"
    }
  },
  {
    "task_id": "PHP/16",
    "prompt": {
      "en": "<?php\n\n/**\n * Calculates the maximum value of a segment from a given array of values.\n * Imagine a tailor has a ribbon with various segments, each having a different value, positive or negative.\n * The goal is to find the maximum total value that can be obtained by cutting a continuous segment of the ribbon.\n * This is akin to finding the most valuable portion of the ribbon to sell or use.\n *\n * Input: \n * An array $values of integers representing the value of each segment of the ribbon.\n *\n * Output:\n * Returns an integer representing the maximum value that can be obtained from any continuous segment of the ribbon.\n *\n * Example:\n * For a ribbon of length 4 with values [-1, 3, 2, -4], the function should return 5, \n * as the segment [3, 2] gives the maximum value.\n */\n\n function maxSegmentValue($values)",
      "es": "<?php\n\n/**\n * Calcula el valor máximo de un segmento de un arreglo dado de valores.\n * Imagina que un sastre tiene una cinta con varios segmentos, cada uno con un valor diferente, positivo o negativo.\n * El objetivo es encontrar el valor total máximo que se puede obtener cortando un segmento continuo de la cinta.\n * Esto es similar a encontrar la porción más valiosa de la cinta para vender o usar.\n *\n * Entrada: \n * Un arreglo $values de enteros que representa el valor de cada segmento de la cinta.\n *\n * Salida:\n * Devuelve un entero que representa el valor máximo que se puede obtener de cualquier segmento continuo de la cinta.\n *\n * Ejemplo:\n * Para una cinta de longitud 4 con valores [-1, 3, 2, -4], la función debería devolver 5, \n * ya que el segmento [3, 2] da el valor máximo.\n */\n\n function maxSegmentValue($values)",
      "arb": "<?php\n\n/**\n * يحسب القيمة القصوى لمقطع من مصفوفة معينة من القيم.\n * تخيل أن هناك خياط لديه شريط يحتوي على مقاطع مختلفة، كل منها له قيمة مختلفة، سواء كانت إيجابية أو سلبية.\n * الهدف هو العثور على القيمة الإجمالية القصوى التي يمكن الحصول عليها عن طريق قطع مقطع متواصل من الشريط.\n * هذا يشبه العثور على الجزء الأكثر قيمة من الشريط لبيعه أو استخدامه.\n *\n * المدخلات:\n * مصفوفة $values من الأعداد الصحيحة تمثل قيمة كل مقطع من الشريط.\n *\n * المخرجات:\n * يعيد عددًا صحيحًا يمثل القيمة القصوى التي يمكن الحصول عليها من أي مقطع متواصل من الشريط.\n *\n * مثال:\n * لشريط طوله 4 بقيم [-1, 3, 2, -4]، يجب أن تعيد الدالة 5،\n * حيث أن المقطع [3, 2] يعطي القيمة القصوى.\n */\n\n function maxSegmentValue($values)",
      "sw": "<?php\n\n/**\n * Inahesabu thamani ya juu zaidi ya kipande kutoka kwenye safu iliyotolewa ya thamani.\n * Fikiria fundi cherehani ana utepe wenye vipande mbalimbali, kila kimoja kikiwa na thamani tofauti, chanya au hasi.\n * Lengo ni kupata jumla ya thamani ya juu zaidi inayoweza kupatikana kwa kukata kipande cha mfululizo cha utepe.\n * Hii ni sawa na kutafuta sehemu ya thamani kubwa zaidi ya utepe kuuza au kutumia.\n *\n * Ingizo:\n * Safu $values ya nambari za mzima inayowakilisha thamani ya kila kipande cha utepe.\n *\n * Tokeo:\n * Inarudisha nambari ya mzima inayowakilisha thamani ya juu zaidi inayoweza kupatikana kutoka kipande chochote cha mfululizo cha utepe.\n *\n * Mfano:\n * Kwa utepe wa urefu 4 wenye thamani [-1, 3, 2, -4], kazi inapaswa kurudisha 5,\n * kwani kipande [3, 2] kinatoa thamani ya juu zaidi.\n */\n\n function maxSegmentValue($values)",
      "tr": "<?php\n\n/**\n * Belirtilen bir değerler dizisinden bir segmentin maksimum değerini hesaplar.\n * Bir terzinin, her biri farklı bir değere sahip çeşitli segmentlerden oluşan bir kurdeleye sahip olduğunu hayal edin, pozitif veya negatif.\n * Amaç, kurdelenin sürekli bir segmentini keserek elde edilebilecek maksimum toplam değeri bulmaktır.\n * Bu, satmak veya kullanmak için kurdelenin en değerli kısmını bulmaya benzer.\n *\n * Girdi: \n * Kurdelenin her segmentinin değerini temsil eden bir tamsayılar dizisi $values.\n *\n * Çıktı:\n * Kurdelenin herhangi bir sürekli segmentinden elde edilebilecek maksimum değeri temsil eden bir tamsayı döndürür.\n *\n * Örnek:\n * Değerleri [-1, 3, 2, -4] olan 4 uzunluğundaki bir kurdele için, fonksiyon 5 döndürmelidir,\n * çünkü [3, 2] segmenti maksimum değeri verir.\n */\n\n function maxSegmentValue($values)",
      "vi": "<?php\n\n/**\n * Tính giá trị lớn nhất của một đoạn từ một mảng giá trị cho trước.\n * Hãy tưởng tượng một thợ may có một dải ruy băng với các đoạn khác nhau, mỗi đoạn có giá trị khác nhau, có thể dương hoặc âm.\n * Mục tiêu là tìm tổng giá trị lớn nhất có thể đạt được bằng cách cắt một đoạn liên tục của dải ruy băng.\n * Điều này giống như việc tìm phần có giá trị nhất của dải ruy băng để bán hoặc sử dụng.\n *\n * Đầu vào: \n * Một mảng $values của các số nguyên đại diện cho giá trị của mỗi đoạn của dải ruy băng.\n *\n * Đầu ra:\n * Trả về một số nguyên đại diện cho giá trị lớn nhất có thể đạt được từ bất kỳ đoạn liên tục nào của dải ruy băng.\n *\n * Ví dụ:\n * Đối với một dải ruy băng có độ dài 4 với các giá trị [-1, 3, 2, -4], hàm nên trả về 5,\n * vì đoạn [3, 2] cho giá trị lớn nhất.\n */\n\n function maxSegmentValue($values)"
    },
    "prompt_bertscore": {
      "es": "0.9639515652978833",
      "arb": "0.9718594380276443",
      "sw": "0.9555129521899971",
      "tr": "0.9812242646022962",
      "vi": "0.979788762838557"
    },
    "canonical_solution": "  {\n    $maxSoFar = PHP_INT_MIN;\n    $maxEndingHere = 0;\n\n    foreach ($values as $value) {\n        $maxEndingHere += $value;\n        if ($maxSoFar < $maxEndingHere) {\n            $maxSoFar = $maxEndingHere;\n        }\n\n        if ($maxEndingHere < 0) {\n            $maxEndingHere = 0;\n        }\n    }\n\n    return $maxSoFar;\n}",
    "instruction": {
      "en": "Write a PHP function `function maxSegmentValue($values)` to solve the following problem:\nCalculates the maximum value of a segment from a given array of values.\nImagine a tailor has a ribbon with various segments, each having a different value, positive or negative.\nThe goal is to find the maximum total value that can be obtained by cutting a continuous segment of the ribbon.\nThis is akin to finding the most valuable portion of the ribbon to sell or use.\n\nInput:\nAn array $values of integers representing the value of each segment of the ribbon.\n\nOutput:\nReturns an integer representing the maximum value that can be obtained from any continuous segment of the ribbon.\n\nExample:\nFor a ribbon of length 4 with values [-1, 3, 2, -4], the function should return 5,\nas the segment [3, 2] gives the maximum value.",
      "es": "Escribe una función PHP `function maxSegmentValue($values)` para resolver el siguiente problema:\nCalcula el valor máximo de un segmento de un array dado de valores.\nImagina que un sastre tiene una cinta con varios segmentos, cada uno con un valor diferente, positivo o negativo.\nEl objetivo es encontrar el valor total máximo que se puede obtener cortando un segmento continuo de la cinta.\nEsto es similar a encontrar la porción más valiosa de la cinta para vender o usar.\n\nEntrada:\nUn array $values de enteros que representa el valor de cada segmento de la cinta.\n\nSalida:\nDevuelve un entero que representa el valor máximo que se puede obtener de cualquier segmento continuo de la cinta.\n\nEjemplo:\nPara una cinta de longitud 4 con valores [-1, 3, 2, -4], la función debería devolver 5,\nya que el segmento [3, 2] da el valor máximo.",
      "arb": "اكتب دالة PHP `function maxSegmentValue($values)` لحل المشكلة التالية:\nتحسب القيمة القصوى لجزء من مصفوفة معينة من القيم.\nتخيل أن هناك خياطًا لديه شريط يحتوي على أجزاء مختلفة، كل منها له قيمة مختلفة، سواء كانت إيجابية أو سلبية.\nالهدف هو العثور على القيمة الإجمالية القصوى التي يمكن الحصول عليها عن طريق قطع جزء مستمر من الشريط.\nهذا يشبه العثور على الجزء الأكثر قيمة من الشريط لبيعه أو استخدامه.\n\nالمدخلات:\nمصفوفة $values من الأعداد الصحيحة تمثل قيمة كل جزء من الشريط.\n\nالمخرجات:\nتعيد عددًا صحيحًا يمثل القيمة القصوى التي يمكن الحصول عليها من أي جزء مستمر من الشريط.\n\nمثال:\nبالنسبة لشريط بطول 4 بقيم [-1, 3, 2, -4]، يجب أن تعيد الدالة 5،\nحيث أن الجزء [3, 2] يعطي القيمة القصوى.",
      "sw": "Andika kazi ya PHP `function maxSegmentValue($values)` kutatua tatizo lifuatalo:\nHesabu thamani ya juu zaidi ya kipande kutoka kwenye safu iliyotolewa ya thamani.\nFikiria fundi cherehani ana utepe wenye vipande mbalimbali, kila kimoja kikiwa na thamani tofauti, chanya au hasi.\nLengo ni kupata jumla ya thamani ya juu zaidi inayoweza kupatikana kwa kukata kipande endelevu cha utepe.\nHii ni sawa na kutafuta sehemu yenye thamani kubwa zaidi ya utepe kuuza au kutumia.\n\nIngizo:\nSafu $values ya nambari za mzima inayoonyesha thamani ya kila kipande cha utepe.\n\nMatokeo:\nInarudisha nambari ya mzima inayowakilisha thamani ya juu zaidi inayoweza kupatikana kutoka kipande chochote endelevu cha utepe.\n\nMfano:\nKwa utepe wa urefu wa 4 wenye thamani [-1, 3, 2, -4], kazi inapaswa kurudisha 5,\nkwa kuwa kipande [3, 2] kinatoa thamani ya juu zaidi.",
      "tr": "Bir PHP fonksiyonu `function maxSegmentValue($values)` yazın ve aşağıdaki problemi çözün:\nVerilen bir değerler dizisinden bir segmentin maksimum değerini hesaplar.\nBir terzinin, her biri farklı bir değere sahip çeşitli segmentlerden oluşan bir kurdeleye sahip olduğunu hayal edin, bu değerler pozitif veya negatif olabilir.\nAmaç, kurdelenin sürekli bir segmentini keserek elde edilebilecek maksimum toplam değeri bulmaktır.\nBu, satmak veya kullanmak için kurdelenin en değerli kısmını bulmaya benzer.\n\nGirdi:\nKurdele segmentlerinin değerini temsil eden bir tamsayı dizisi $values.\n\nÇıktı:\nKurdeleden herhangi bir sürekli segmentten elde edilebilecek maksimum değeri temsil eden bir tamsayı döndürür.\n\nÖrnek:\nDeğerleri [-1, 3, 2, -4] olan uzunluğu 4 olan bir kurdele için, fonksiyon 5 döndürmelidir,\nçünkü [3, 2] segmenti maksimum değeri verir.",
      "vi": "Viết một hàm PHP `function maxSegmentValue($values)` để giải quyết vấn đề sau:\nTính giá trị lớn nhất của một đoạn từ một mảng giá trị cho trước.\nHãy tưởng tượng một thợ may có một dải ruy băng với nhiều đoạn khác nhau, mỗi đoạn có một giá trị khác nhau, có thể dương hoặc âm.\nMục tiêu là tìm giá trị tổng lớn nhất có thể thu được bằng cách cắt một đoạn liên tục của dải ruy băng.\nĐiều này giống như tìm phần có giá trị nhất của dải ruy băng để bán hoặc sử dụng.\n\nĐầu vào:\nMột mảng $values của các số nguyên đại diện cho giá trị của mỗi đoạn của dải ruy băng.\n\nĐầu ra:\nTrả về một số nguyên đại diện cho giá trị lớn nhất có thể thu được từ bất kỳ đoạn liên tục nào của dải ruy băng.\n\nVí dụ:\nĐối với một dải ruy băng có độ dài 4 với các giá trị [-1, 3, 2, -4], hàm nên trả về 5,\nvì đoạn [3, 2] cho giá trị lớn nhất."
    },
    "instruction_bertscore": {
      "es": "0.9569083306167672",
      "arb": "0.9770494512537049",
      "sw": "0.9492868828964586",
      "tr": "0.9701740592445632",
      "vi": "0.9733690289235094"
    },
    "level": "easy",
    "test": "function main(){\n    assert(maxSegmentValue([-1, 3, 2, -4]) === 5);\n    assert(maxSegmentValue([-2, -3, 4, -1, -2, 1, 5, -3]) === 7);\n    assert(maxSegmentValue([-1, -2, -3]) === -1);\n    assert(maxSegmentValue([10]) === 10);\n    assert(maxSegmentValue([1, -3]) === 1);\n    \n    \n}\n\n\nmain();\n?>",
    "entry_point": "maxSegmentValue",
    "signature": "function maxSegmentValue($values)",
    "docstring": {
      "en": "Calculates the maximum value of a segment from a given array of values.\nImagine a tailor has a ribbon with various segments, each having a different value, positive or negative.\nThe goal is to find the maximum total value that can be obtained by cutting a continuous segment of the ribbon.\nThis is akin to finding the most valuable portion of the ribbon to sell or use.\n\nInput:\nAn array $values of integers representing the value of each segment of the ribbon.\n\nOutput:\nReturns an integer representing the maximum value that can be obtained from any continuous segment of the ribbon.\n\nExample:\nFor a ribbon of length 4 with values [-1, 3, 2, -4], the function should return 5,\nas the segment [3, 2] gives the maximum value.",
      "es": "Calcula el valor máximo de un segmento de un arreglo dado de valores.  \nImagina que un sastre tiene una cinta con varios segmentos, cada uno con un valor diferente, positivo o negativo.  \nEl objetivo es encontrar el valor total máximo que se puede obtener cortando un segmento continuo de la cinta.  \nEsto es similar a encontrar la porción más valiosa de la cinta para vender o usar.\n\nEntrada:  \nUn arreglo $values de enteros que representa el valor de cada segmento de la cinta.\n\nSalida:  \nDevuelve un entero que representa el valor máximo que se puede obtener de cualquier segmento continuo de la cinta.\n\nEjemplo:  \nPara una cinta de longitud 4 con valores [-1, 3, 2, -4], la función debería devolver 5,  \nya que el segmento [3, 2] da el valor máximo.",
      "arb": "يحسب القيمة القصوى لمقطع من مصفوفة معينة من القيم.\nتخيل أن خياطًا لديه شريط يحتوي على مقاطع مختلفة، كل منها له قيمة مختلفة، سواء كانت إيجابية أو سلبية.\nالهدف هو العثور على القيمة الإجمالية القصوى التي يمكن الحصول عليها عن طريق قطع مقطع مستمر من الشريط.\nهذا يشبه العثور على الجزء الأكثر قيمة من الشريط لبيعه أو استخدامه.\n\nالمدخل:\nمصفوفة $values من الأعداد الصحيحة تمثل قيمة كل مقطع من الشريط.\n\nالمخرج:\nيعيد عددًا صحيحًا يمثل القيمة القصوى التي يمكن الحصول عليها من أي مقطع مستمر من الشريط.\n\nمثال:\nبالنسبة لشريط طوله 4 بقيم [-1, 3, 2, -4]، يجب أن تعيد الدالة 5،\nحيث أن المقطع [3, 2] يعطي القيمة القصوى.",
      "sw": "Hesabu thamani ya juu zaidi ya kipande kutoka kwenye safu iliyotolewa ya thamani.\nFikiria fundi cherehani ana utepe wenye vipande mbalimbali, kila kimoja kikiwa na thamani tofauti, chanya au hasi.\nLengo ni kupata jumla ya thamani ya juu zaidi inayoweza kupatikana kwa kukata kipande kinachoendelea cha utepe.\nHii ni sawa na kutafuta sehemu ya utepe yenye thamani kubwa zaidi kuuza au kutumia.\n\nIngizo:\nSafu $values ya nambari za mzima inayoonyesha thamani ya kila kipande cha utepe.\n\nMatokeo:\nRudisha nambari ya mzima inayoonyesha thamani ya juu zaidi inayoweza kupatikana kutoka kwenye kipande chochote kinachoendelea cha utepe.\n\nMfano:\nKwa utepe wa urefu wa 4 wenye thamani [-1, 3, 2, -4], kazi inapaswa kurudisha 5,\nkwa kuwa kipande [3, 2] kinatoa thamani ya juu zaidi.",
      "tr": "Bir dizi değerinden bir segmentin maksimum değerini hesaplar.\nBir terzinin, her biri farklı bir değere sahip, pozitif veya negatif, çeşitli segmentlere sahip bir kurdeleye sahip olduğunu hayal edin.\nAmaç, kurdelenin sürekli bir segmentini keserek elde edilebilecek maksimum toplam değeri bulmaktır.\nBu, satmak veya kullanmak için kurdelenin en değerli kısmını bulmaya benzer.\n\nGirdi:\nKurdele üzerindeki her segmentin değerini temsil eden bir tamsayı dizisi $values.\n\nÇıktı:\nKurdele üzerindeki herhangi bir sürekli segmentten elde edilebilecek maksimum değeri temsil eden bir tamsayı döndürür.\n\nÖrnek:\nDeğerleri [-1, 3, 2, -4] olan uzunluğu 4 olan bir kurdele için, fonksiyon 5 döndürmelidir,\nçünkü [3, 2] segmenti maksimum değeri verir.",
      "vi": "Tính giá trị lớn nhất của một đoạn từ một mảng giá trị cho trước.  \nHãy tưởng tượng một thợ may có một dải ruy băng với các đoạn khác nhau, mỗi đoạn có một giá trị khác nhau, có thể dương hoặc âm.  \nMục tiêu là tìm tổng giá trị lớn nhất có thể đạt được bằng cách cắt một đoạn liên tục của dải ruy băng.  \nĐiều này giống như việc tìm phần có giá trị nhất của dải ruy băng để bán hoặc sử dụng.\n\nĐầu vào:  \nMột mảng $values của các số nguyên đại diện cho giá trị của mỗi đoạn của dải ruy băng.\n\nĐầu ra:  \nTrả về một số nguyên đại diện cho giá trị lớn nhất có thể đạt được từ bất kỳ đoạn liên tục nào của dải ruy băng.\n\nVí dụ:  \nĐối với một dải ruy băng có độ dài 4 với các giá trị [-1, 3, 2, -4], hàm nên trả về 5,  \nvì đoạn [3, 2] cho giá trị lớn nhất."
    },
    "docstring_bertscore": {
      "es": "0.9858839347109936",
      "arb": "0.9914831265219861",
      "sw": "0.9513053648285351",
      "tr": "0.9702437785083065",
      "vi": "0.9666040754062232"
    }
  },
  {
    "task_id": "PHP/17",
    "prompt": {
      "en": "<?php\n\n/**\n * Determines the position of a new student in a choir formation.\n * The choir is arranged with the shortest members on the sides and the tallest in the center.\n * The new student may stand on the left or right side, or, if they are the tallest, to the right of the current tallest student.\n * If the new student is not the tallest, their position is based on the teacher's preference: left or right side.\n *\n * Input:\n * - $newStudentHeight (int): The height of the new student.\n * - $heights (array): An array of integers representing the heights of the current choir members from left to right.\n * - $teacherPreference (int): The teacher's preference for the new student's position (1 for left, 2 for right).\n *\n * Output:\n * - Returns an integer representing the position (1-indexed) where the new student will stand.\n *\n * Examples:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) should return 8.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) should return 3.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int ",
      "es": "<?php\n\n/**\n * Determina la posición de un nuevo estudiante en una formación de coro.\n * El coro está organizado con los miembros más bajos en los lados y los más altos en el centro.\n * El nuevo estudiante puede estar en el lado izquierdo o derecho, o, si es el más alto, a la derecha del estudiante más alto actual.\n * Si el nuevo estudiante no es el más alto, su posición se basa en la preferencia del maestro: lado izquierdo o derecho.\n *\n * Entrada:\n * - $newStudentHeight (int): La altura del nuevo estudiante.\n * - $heights (array): Un arreglo de enteros que representa las alturas de los miembros actuales del coro de izquierda a derecha.\n * - $teacherPreference (int): La preferencia del maestro para la posición del nuevo estudiante (1 para izquierda, 2 para derecha).\n *\n * Salida:\n * - Devuelve un entero que representa la posición (indexada en 1) donde el nuevo estudiante se ubicará.\n *\n * Ejemplos:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) debería devolver 8.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) debería devolver 3.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int ",
      "arb": "<?php\n\n/**\n * يحدد موضع الطالب الجديد في تشكيل الكورال.\n * يتم ترتيب الكورال بحيث يكون الأعضاء الأقصر على الجوانب والأطول في المركز.\n * يمكن للطالب الجديد أن يقف على الجانب الأيسر أو الأيمن، أو إذا كان الأطول، إلى يمين الطالب الأطول الحالي.\n * إذا لم يكن الطالب الجديد هو الأطول، فإن موضعه يعتمد على تفضيل المعلم: الجانب الأيسر أو الأيمن.\n *\n * المدخلات:\n * - $newStudentHeight (int): ارتفاع الطالب الجديد.\n * - $heights (array): مصفوفة من الأعداد الصحيحة تمثل ارتفاعات أعضاء الكورال الحاليين من اليسار إلى اليمين.\n * - $teacherPreference (int): تفضيل المعلم لموضع الطالب الجديد (1 للجانب الأيسر، 2 للجانب الأيمن).\n *\n * المخرجات:\n * - يعيد عددًا صحيحًا يمثل الموضع (مؤشر يبدأ من 1) حيث سيقف الطالب الجديد.\n *\n * أمثلة:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) يجب أن تعيد 8.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) يجب أن تعيد 3.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int ",
      "sw": "<?php\n\n/**\n * Huamua nafasi ya mwanafunzi mpya katika mpangilio wa kwaya.\n * Kwaya imepangwa na wanachama wafupi zaidi wakiwa pembeni na warefu zaidi katikati.\n * Mwanafunzi mpya anaweza kusimama upande wa kushoto au kulia, au, ikiwa yeye ndiye mrefu zaidi, upande wa kulia wa mwanafunzi mrefu zaidi wa sasa.\n * Ikiwa mwanafunzi mpya si mrefu zaidi, nafasi yake inategemea upendeleo wa mwalimu: upande wa kushoto au kulia.\n *\n * Ingizo:\n * - $newStudentHeight (int): Urefu wa mwanafunzi mpya.\n * - $heights (array): Mfululizo wa namba zinazoashiria urefu wa wanachama wa sasa wa kwaya kutoka kushoto kwenda kulia.\n * - $teacherPreference (int): Upendeleo wa mwalimu kwa nafasi ya mwanafunzi mpya (1 kwa kushoto, 2 kwa kulia).\n *\n * Tokeo:\n * - Inarudisha namba inayoashiria nafasi (1-indexed) ambapo mwanafunzi mpya atasimama.\n *\n * Mifano:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) inapaswa kurudisha 8.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) inapaswa kurudisha 3.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int",
      "tr": "<?php\n\n/**\n * Yeni bir öğrencinin koro oluşumundaki pozisyonunu belirler.\n * Koro, en kısa üyeler yanlarda ve en uzun üyeler ortada olacak şekilde düzenlenmiştir.\n * Yeni öğrenci, en uzun ise mevcut en uzun öğrencinin sağına, değilse sol veya sağ tarafa yerleştirilebilir.\n * Eğer yeni öğrenci en uzun değilse, pozisyonu öğretmenin tercihlerine göre belirlenir: sol veya sağ taraf.\n *\n * Girdi:\n * - $newStudentHeight (int): Yeni öğrencinin boyu.\n * - $heights (array): Mevcut koro üyelerinin boylarını soldan sağa doğru temsil eden bir tamsayı dizisi.\n * - $teacherPreference (int): Yeni öğrencinin pozisyonu için öğretmenin tercihi (1 sol, 2 sağ için).\n *\n * Çıktı:\n * - Yeni öğrencinin duracağı pozisyonu (1-indexli) temsil eden bir tamsayı döndürür.\n *\n * Örnekler:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) 8 döndürmelidir.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) 3 döndürmelidir.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int ",
      "vi": "<?php\n\n/**\n * Xác định vị trí của một học sinh mới trong đội hình dàn hợp xướng.\n * Dàn hợp xướng được sắp xếp với các thành viên thấp nhất ở hai bên và cao nhất ở trung tâm.\n * Học sinh mới có thể đứng ở bên trái hoặc bên phải, hoặc, nếu họ là người cao nhất, đứng bên phải của học sinh cao nhất hiện tại.\n * Nếu học sinh mới không phải là người cao nhất, vị trí của họ dựa trên sự ưu tiên của giáo viên: bên trái hoặc bên phải.\n *\n * Đầu vào:\n * - $newStudentHeight (int): Chiều cao của học sinh mới.\n * - $heights (array): Một mảng số nguyên đại diện cho chiều cao của các thành viên hiện tại của dàn hợp xướng từ trái sang phải.\n * - $teacherPreference (int): Sự ưu tiên của giáo viên cho vị trí của học sinh mới (1 cho bên trái, 2 cho bên phải).\n *\n * Đầu ra:\n * - Trả về một số nguyên đại diện cho vị trí (đánh số từ 1) nơi học sinh mới sẽ đứng.\n *\n * Ví dụ:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) sẽ trả về 8.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) sẽ trả về 3.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int "
    },
    "prompt_bertscore": {
      "es": "0.989467624045625",
      "arb": "0.9693797363508048",
      "sw": "0.9808836134988214",
      "tr": "0.9591939704113357",
      "vi": "0.9778225206966926"
    },
    "canonical_solution": "{\n    // Check if the new student is the tallest\n    if ($newStudentHeight > max($heights)) {\n        return count($heights) + 1; // Tallest student goes to the right of the current tallest\n    }\n\n    // If the new student is not the tallest, find their position based on teacher's preference\n    if ($teacherPreference == 1) { // Teacher prefers left side\n        for ($i = 0; $i < count($heights); $i++) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 1; // 1-indexed position\n            }\n        }\n    } else { // Teacher prefers right side\n        for ($i = count($heights) - 1; $i >= 0; $i--) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 2; // 1-indexed position\n            }\n        }\n    }\n    // If the new student is the shortest, they go to the left or right side based on teacher's preference\n    return $teacherPreference == 1 ? 1 : count($heights) + 1;\n}",
    "instruction": {
      "en": "Write a PHP function `function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int` to solve the following problem:\nDetermines the position of a new student in a choir formation.\nThe choir is arranged with the shortest members on the sides and the tallest in the center.\nThe new student may stand on the left or right side, or, if they are the tallest, to the right of the current tallest student.\nIf the new student is not the tallest, their position is based on the teacher's preference: left or right side.\n\nInput:\n- $newStudentHeight (int): The height of the new student.\n- $heights (array): An array of integers representing the heights of the current choir members from left to right.\n- $teacherPreference (int): The teacher's preference for the new student's position (1 for left, 2 for right).\n\nOutput:\n- Returns an integer representing the position (1-indexed) where the new student will stand.\n\nExamples:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) should return 8.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) should return 3.",
      "es": "Escriba una función PHP `function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int` para resolver el siguiente problema:\nDetermina la posición de un nuevo estudiante en una formación de coro.\nEl coro está organizado con los miembros más bajos en los lados y los más altos en el centro.\nEl nuevo estudiante puede estar en el lado izquierdo o derecho, o, si es el más alto, a la derecha del estudiante más alto actual.\nSi el nuevo estudiante no es el más alto, su posición se basa en la preferencia del maestro: lado izquierdo o derecho.\n\nEntrada:\n- $newStudentHeight (int): La altura del nuevo estudiante.\n- $heights (array): Un arreglo de enteros que representa las alturas de los miembros actuales del coro de izquierda a derecha.\n- $teacherPreference (int): La preferencia del maestro para la posición del nuevo estudiante (1 para izquierda, 2 para derecha).\n\nSalida:\n- Devuelve un entero que representa la posición (indexada en 1) donde el nuevo estudiante se ubicará.\n\nEjemplos:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) debería devolver 8.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) debería devolver 3.",
      "arb": "اكتب دالة PHP `function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int` لحل المشكلة التالية:\nتحدد موضع الطالب الجديد في تشكيل الكورال.\nيتم ترتيب الكورال بحيث يكون الأعضاء الأقصر على الجوانب والأطول في المركز.\nيمكن للطالب الجديد الوقوف على الجانب الأيسر أو الأيمن، أو إذا كان هو الأطول، إلى يمين أطول طالب حالي.\nإذا لم يكن الطالب الجديد هو الأطول، فإن موضعه يعتمد على تفضيل المعلم: الجانب الأيسر أو الأيمن.\n\nالمدخلات:\n- $newStudentHeight (int): ارتفاع الطالب الجديد.\n- $heights (array): مصفوفة من الأعداد الصحيحة تمثل ارتفاعات أعضاء الكورال الحاليين من اليسار إلى اليمين.\n- $teacherPreference (int): تفضيل المعلم لموضع الطالب الجديد (1 للجانب الأيسر، 2 للجانب الأيمن).\n\nالمخرجات:\n- تعيد عددًا صحيحًا يمثل الموضع (مؤشر يبدأ من 1) حيث سيقف الطالب الجديد.\n\nأمثلة:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) يجب أن تعيد 8.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) يجب أن تعيد 3.",
      "sw": "Andika kazi ya PHP `function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int` kutatua tatizo lifuatalo:\nInabainisha nafasi ya mwanafunzi mpya katika mpangilio wa kwaya.\nKwaya imepangwa na wanachama wafupi zaidi pembeni na warefu zaidi katikati.\nMwanafunzi mpya anaweza kusimama upande wa kushoto au kulia, au, ikiwa ndiye mrefu zaidi, upande wa kulia wa mwanafunzi mrefu wa sasa.\nIkiwa mwanafunzi mpya si mrefu zaidi, nafasi yao inategemea upendeleo wa mwalimu: upande wa kushoto au kulia.\n\nIngizo:\n- $newStudentHeight (int): Urefu wa mwanafunzi mpya.\n- $heights (array): Mfululizo wa namba za mzima zinazoonyesha urefu wa wanachama wa sasa wa kwaya kutoka kushoto kwenda kulia.\n- $teacherPreference (int): Upendeleo wa mwalimu kwa nafasi ya mwanafunzi mpya (1 kwa kushoto, 2 kwa kulia).\n\nMatokeo:\n- Inarudisha namba nzima inayowakilisha nafasi (1-indexed) ambapo mwanafunzi mpya atasimama.\n\nMifano:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) inapaswa kurudisha 8.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) inapaswa kurudisha 3.",
      "tr": "Bir PHP fonksiyonu `function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int` yazın ve aşağıdaki problemi çözün:\nYeni bir öğrencinin bir koro oluşumundaki konumunu belirler.\nKoro, en kısa üyeler kenarlarda ve en uzun üyeler ortada olacak şekilde düzenlenmiştir.\nYeni öğrenci sol veya sağ tarafa, ya da en uzun ise mevcut en uzun öğrencinin sağına durabilir.\nYeni öğrenci en uzun değilse, konumu öğretmenin tercihlerine göre belirlenir: sol veya sağ taraf.\n\nGirdi:\n- $newStudentHeight (int): Yeni öğrencinin boyu.\n- $heights (array): Mevcut koro üyelerinin soldan sağa doğru boylarını temsil eden bir tamsayı dizisi.\n- $teacherPreference (int): Yeni öğrencinin konumu için öğretmenin tercihi (1 sol, 2 sağ için).\n\nÇıktı:\n- Yeni öğrencinin duracağı konumu (1-indeksli) temsil eden bir tamsayı döndürür.\n\nÖrnekler:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) 8 döndürmelidir.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) 3 döndürmelidir.",
      "vi": "Viết một hàm PHP `function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int` để giải quyết vấn đề sau:\nXác định vị trí của một học sinh mới trong đội hình hợp xướng.\nĐội hợp xướng được sắp xếp với các thành viên thấp nhất ở hai bên và cao nhất ở trung tâm.\nHọc sinh mới có thể đứng ở bên trái hoặc bên phải, hoặc, nếu họ là người cao nhất, đứng bên phải của học sinh cao nhất hiện tại.\nNếu học sinh mới không phải là người cao nhất, vị trí của họ dựa trên sự ưu tiên của giáo viên: bên trái hoặc bên phải.\n\nĐầu vào:\n- $newStudentHeight (int): Chiều cao của học sinh mới.\n- $heights (array): Một mảng các số nguyên đại diện cho chiều cao của các thành viên hiện tại của đội hợp xướng từ trái sang phải.\n- $teacherPreference (int): Sự ưu tiên của giáo viên cho vị trí của học sinh mới (1 cho bên trái, 2 cho bên phải).\n\nĐầu ra:\n- Trả về một số nguyên đại diện cho vị trí (đánh số từ 1) nơi học sinh mới sẽ đứng.\n\nVí dụ:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) sẽ trả về 8.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) sẽ trả về 3."
    },
    "instruction_bertscore": {
      "es": "0.9880609236871359",
      "arb": "0.96233868660388",
      "sw": "0.9786774258566668",
      "tr": "0.976731245383287",
      "vi": "0.9751499489198683"
    },
    "level": "hard",
    "test": "function main(){\n    \n    assert(determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) === 8);\n    assert(determineChoirPosition(15, [5, 10, 20, 10, 5], 1) === 3);\n    assert(determineChoirPosition(12, [10, 15, 20, 15], 2) === 5);\n    assert(determineChoirPosition(18, [6, 9, 12, 15, 17, 21], 1) === 6);\n    assert(determineChoirPosition(18, [6, 9, 12, 15], 1) === 5);\n    assert(determineChoirPosition(10, [5, 8, 12], 2) === 4);   \n}\n\n\nmain();\n?>",
    "entry_point": "determineChoirPosition",
    "signature": "function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int",
    "docstring": {
      "en": "Determines the position of a new student in a choir formation.\nThe choir is arranged with the shortest members on the sides and the tallest in the center.\nThe new student may stand on the left or right side, or, if they are the tallest, to the right of the current tallest student.\nIf the new student is not the tallest, their position is based on the teacher's preference: left or right side.\n\nInput:\n- $newStudentHeight (int): The height of the new student.\n- $heights (array): An array of integers representing the heights of the current choir members from left to right.\n- $teacherPreference (int): The teacher's preference for the new student's position (1 for left, 2 for right).\n\nOutput:\n- Returns an integer representing the position (1-indexed) where the new student will stand.\n\nExamples:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) should return 8.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) should return 3.",
      "es": "Determina la posición de un nuevo estudiante en una formación de coro.  \nEl coro está organizado con los miembros más bajos en los lados y los más altos en el centro.  \nEl nuevo estudiante puede pararse en el lado izquierdo o derecho, o, si es el más alto, a la derecha del estudiante más alto actual.  \nSi el nuevo estudiante no es el más alto, su posición se basa en la preferencia del maestro: lado izquierdo o derecho.  \n\nEntrada:  \n- $newStudentHeight (int): La altura del nuevo estudiante.  \n- $heights (array): Un arreglo de enteros que representa las alturas de los miembros actuales del coro de izquierda a derecha.  \n- $teacherPreference (int): La preferencia del maestro para la posición del nuevo estudiante (1 para izquierda, 2 para derecha).  \n\nSalida:  \n- Devuelve un entero que representa la posición (indexada desde 1) donde el nuevo estudiante se ubicará.  \n\nEjemplos:  \n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) debería devolver 8.  \n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) debería devolver 3.  ",
      "arb": "يحدد موضع الطالب الجديد في تشكيل الكورال. يتم ترتيب الكورال بحيث يكون الأعضاء الأقصر على الجوانب والأطول في المركز. يمكن للطالب الجديد أن يقف على الجانب الأيسر أو الأيمن، أو إذا كان هو الأطول، إلى يمين الطالب الأطول الحالي. إذا لم يكن الطالب الجديد هو الأطول، فإن موضعه يعتمد على تفضيل المعلم: الجانب الأيسر أو الأيمن.\n\nالمدخلات:\n- $newStudentHeight (int): ارتفاع الطالب الجديد.\n- $heights (array): مصفوفة من الأعداد الصحيحة تمثل ارتفاعات أعضاء الكورال الحاليين من اليسار إلى اليمين.\n- $teacherPreference (int): تفضيل المعلم لموضع الطالب الجديد (1 للجانب الأيسر، 2 للجانب الأيمن).\n\nالمخرجات:\n- يعيد عددًا صحيحًا يمثل الموضع (مؤشر يبدأ من 1) حيث سيقف الطالب الجديد.\n\nأمثلة:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) يجب أن تعيد 8.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) يجب أن تعيد 3.",
      "sw": "Inabainisha nafasi ya mwanafunzi mpya katika mpangilio wa kwaya.\nKwaya imepangwa na wanachama wafupi zaidi pembeni na warefu zaidi katikati.\nMwanafunzi mpya anaweza kusimama upande wa kushoto au kulia, au, ikiwa yeye ndiye mrefu zaidi, upande wa kulia wa mwanafunzi mrefu zaidi wa sasa.\nIkiwa mwanafunzi mpya si mrefu zaidi, nafasi yake inategemea upendeleo wa mwalimu: upande wa kushoto au kulia.\n\nIngizo:\n- $newStudentHeight (int): Urefu wa mwanafunzi mpya.\n- $heights (array): Mfululizo wa nambari za mzima zinazowakilisha urefu wa wanachama wa sasa wa kwaya kutoka kushoto kwenda kulia.\n- $teacherPreference (int): Upendeleo wa mwalimu kwa nafasi ya mwanafunzi mpya (1 kwa kushoto, 2 kwa kulia).\n\nPato:\n- Inarudisha nambari nzima inayowakilisha nafasi (1-iliyowekwa) ambapo mwanafunzi mpya atasimama.\n\nMifano:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) inapaswa kurudisha 8.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) inapaswa kurudisha 3.",
      "tr": "Yeni bir öğrencinin bir koro oluşumundaki konumunu belirler.\nKoro, en kısa üyeler kenarlarda ve en uzun üyeler ortada olacak şekilde düzenlenmiştir.\nYeni öğrenci sol veya sağ tarafta durabilir veya en uzunsa, mevcut en uzun öğrencinin sağına geçebilir.\nYeni öğrenci en uzun değilse, konumu öğretmenin tercihlerine göre belirlenir: sol veya sağ taraf.\n\nGirdi:\n- $newStudentHeight (int): Yeni öğrencinin boyu.\n- $heights (array): Mevcut koro üyelerinin boylarını soldan sağa temsil eden bir tamsayı dizisi.\n- $teacherPreference (int): Yeni öğrencinin konumu için öğretmenin tercihi (1 sol için, 2 sağ için).\n\nÇıktı:\n- Yeni öğrencinin duracağı konumu (1-indexli) temsil eden bir tamsayı döndürür.\n\nÖrnekler:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) 8 döndürmelidir.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) 3 döndürmelidir.",
      "vi": "Xác định vị trí của một học sinh mới trong đội hình dàn hợp xướng.  \nDàn hợp xướng được sắp xếp với các thành viên thấp nhất ở hai bên và cao nhất ở trung tâm.  \nHọc sinh mới có thể đứng ở bên trái hoặc bên phải, hoặc, nếu họ là người cao nhất, ở bên phải của học sinh cao nhất hiện tại.  \nNếu học sinh mới không phải là người cao nhất, vị trí của họ dựa trên sự ưu tiên của giáo viên: bên trái hoặc bên phải.\n\nĐầu vào:  \n- $newStudentHeight (int): Chiều cao của học sinh mới.  \n- $heights (array): Một mảng các số nguyên đại diện cho chiều cao của các thành viên hiện tại của dàn hợp xướng từ trái sang phải.  \n- $teacherPreference (int): Sự ưu tiên của giáo viên cho vị trí của học sinh mới (1 cho bên trái, 2 cho bên phải).\n\nĐầu ra:  \n- Trả về một số nguyên đại diện cho vị trí (đánh số từ 1) nơi học sinh mới sẽ đứng.\n\nVí dụ:  \n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) sẽ trả về 8.  \n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) sẽ trả về 3."
    },
    "docstring_bertscore": {
      "es": "0.9791857210017351",
      "arb": "0.961940035429143",
      "sw": "0.9574301326277459",
      "tr": "0.9648058745667144",
      "vi": "0.9694574008297894"
    }
  },
  {
    "task_id": "PHP/18",
    "prompt": {
      "en": "<?php\n\n/**\n * Determines the exact price of an item within a specified range based on a series of hints.\n * The item's price is within the range [1, maxPrice].\n * Hints are given in a string where:\n * - 'u' indicates the actual price is higher than the current guess.\n * - 'd' indicates the actual price is lower than the current guess.\n * - 'y' indicates the current guess is correct.\n * The function uses a binary search approach to narrow down the possible price.\n * Input: The maximum price (maxPrice) and a string of hints.\n * Output: Returns the exact price of the item.\n * Example: For maxPrice = 1000000 and hints = \"uddy\", the function returns 562500.\n */\n\nfunction guessItemPrice(int $maxPrice, string $hints): int ",
      "es": "<?php\n\n/**\n * Determina el precio exacto de un artículo dentro de un rango especificado basado en una serie de pistas.\n * El precio del artículo está dentro del rango [1, maxPrice].\n * Las pistas se dan en una cadena donde:\n * - 'u' indica que el precio real es mayor que la conjetura actual.\n * - 'd' indica que el precio real es menor que la conjetura actual.\n * - 'y' indica que la conjetura actual es correcta.\n * La función utiliza un enfoque de búsqueda binaria para reducir el posible precio.\n * Entrada: El precio máximo (maxPrice) y una cadena de pistas.\n * Salida: Devuelve el precio exacto del artículo.\n * Ejemplo: Para maxPrice = 1000000 y pistas = \"uddy\", la función devuelve 562500.\n */\n\nfunction guessItemPrice(int $maxPrice, string $hints): int ",
      "arb": "<?php\n\n/**\n * يحدد السعر الدقيق لعنصر ما ضمن نطاق محدد بناءً على سلسلة من التلميحات.\n * سعر العنصر يقع ضمن النطاق [1, maxPrice].\n * التلميحات تُعطى في سلسلة حيث:\n * - 'u' تشير إلى أن السعر الفعلي أعلى من التخمين الحالي.\n * - 'd' تشير إلى أن السعر الفعلي أقل من التخمين الحالي.\n * - 'y' تشير إلى أن التخمين الحالي صحيح.\n * تستخدم الدالة نهج البحث الثنائي لتضييق النطاق المحتمل للسعر.\n * المدخلات: السعر الأقصى (maxPrice) وسلسلة من التلميحات.\n * المخرجات: تعيد السعر الدقيق للعنصر.\n * مثال: بالنسبة لـ maxPrice = 1000000 و hints = \"uddy\"، تعيد الدالة 562500.\n */\n\nfunction guessItemPrice(int $maxPrice, string $hints): int ",
      "sw": "<?php\n\n/**\n * Inabainisha bei halisi ya kipengee ndani ya safu iliyobainishwa kulingana na mfululizo wa vidokezo.\n * Bei ya kipengee iko ndani ya safu [1, maxPrice].\n * Vidokezo vinatolewa katika kamba ambapo:\n * - 'u' inaashiria bei halisi ni ya juu kuliko nadharia ya sasa.\n * - 'd' inaashiria bei halisi ni ya chini kuliko nadharia ya sasa.\n * - 'y' inaashiria nadharia ya sasa ni sahihi.\n * Kazi inatumia mbinu ya utafutaji wa nusu ili kupunguza bei inayowezekana.\n * Ingizo: Bei ya juu zaidi (maxPrice) na kamba ya vidokezo.\n * Matokeo: Inarudisha bei halisi ya kipengee.\n * Mfano: Kwa maxPrice = 1000000 na hints = \"uddy\", kazi inarudisha 562500.\n */\n\nfunction guessItemPrice(int $maxPrice, string $hints): int ",
      "tr": "<?php\n\n/**\n * Bir dizi ipucu temelinde belirtilen bir aralıktaki bir öğenin tam fiyatını belirler.\n * Öğenin fiyatı [1, maxPrice] aralığındadır.\n * İpuçları bir dizede verilir, burada:\n * - 'u' gerçek fiyatın mevcut tahminden daha yüksek olduğunu belirtir.\n * - 'd' gerçek fiyatın mevcut tahminden daha düşük olduğunu belirtir.\n * - 'y' mevcut tahminin doğru olduğunu belirtir.\n * Fonksiyon, olası fiyatı daraltmak için ikili arama yaklaşımını kullanır.\n * Girdi: Maksimum fiyat (maxPrice) ve bir ipucu dizisi.\n * Çıktı: Öğenin tam fiyatını döndürür.\n * Örnek: maxPrice = 1000000 ve hints = \"uddy\" için, fonksiyon 562500 döndürür.\n */\n\nfunction guessItemPrice(int $maxPrice, string $hints): int ",
      "vi": "<?php\n\n/**\n * Xác định giá chính xác của một mặt hàng trong một phạm vi được chỉ định dựa trên một loạt các gợi ý.\n * Giá của mặt hàng nằm trong phạm vi [1, maxPrice].\n * Gợi ý được đưa ra trong một chuỗi nơi:\n * - 'u' chỉ ra rằng giá thực tế cao hơn so với giá đoán hiện tại.\n * - 'd' chỉ ra rằng giá thực tế thấp hơn so với giá đoán hiện tại.\n * - 'y' chỉ ra rằng giá đoán hiện tại là chính xác.\n * Hàm sử dụng phương pháp tìm kiếm nhị phân để thu hẹp giá có thể có.\n * Đầu vào: Giá tối đa (maxPrice) và một chuỗi gợi ý.\n * Đầu ra: Trả về giá chính xác của mặt hàng.\n * Ví dụ: Với maxPrice = 1000000 và hints = \"uddy\", hàm trả về 562500.\n */ \n\nfunction guessItemPrice(int $maxPrice, string $hints): int "
    },
    "prompt_bertscore": {
      "es": "0.9833271644463125",
      "arb": "0.9776634177614837",
      "sw": "0.9862120721004632",
      "tr": "0.9913778524200376",
      "vi": "0.9690130646674143"
    },
    "canonical_solution": "{\n    $low = 1;\n    $high = $maxPrice;\n\n    foreach (str_split($hints) as $hint) {\n        $mid = intdiv($low + $high, 2);\n\n        if ($hint === 'u') {\n            $low = $mid + 1;\n        } elseif ($hint === 'd') {\n            $high = $mid - 1;\n        } elseif ($hint === 'y') {\n            return $mid;\n        }\n    }\n\n    // In case the hints do not determine the price correctly, return an error or a default value\n    return -1; // or any other appropriate error handling\n}",
    "instruction": {
      "en": "Write a PHP function `function guessItemPrice(int $maxPrice, string $hints): int` to solve the following problem:\nDetermines the exact price of an item within a specified range based on a series of hints.\nThe item's price is within the range [1, maxPrice].\nHints are given in a string where:\n- 'u' indicates the actual price is higher than the current guess.\n- 'd' indicates the actual price is lower than the current guess.\n- 'y' indicates the current guess is correct.\nThe function uses a binary search approach to narrow down the possible price.\nInput: The maximum price (maxPrice) and a string of hints.\nOutput: Returns the exact price of the item.\nExample: For maxPrice = 1000000 and hints = \"uddy\", the function returns 562500.",
      "es": "Escribe una función PHP `function guessItemPrice(int $maxPrice, string $hints): int` para resolver el siguiente problema:\nDetermina el precio exacto de un artículo dentro de un rango especificado basado en una serie de pistas.\nEl precio del artículo está dentro del rango [1, maxPrice].\nLas pistas se dan en una cadena donde:\n- 'u' indica que el precio real es mayor que la conjetura actual.\n- 'd' indica que el precio real es menor que la conjetura actual.\n- 'y' indica que la conjetura actual es correcta.\nLa función utiliza un enfoque de búsqueda binaria para reducir el posible precio.\nEntrada: El precio máximo (maxPrice) y una cadena de pistas.\nSalida: Devuelve el precio exacto del artículo.\nEjemplo: Para maxPrice = 1000000 y hints = \"uddy\", la función devuelve 562500.",
      "arb": "اكتب دالة PHP `function guessItemPrice(int $maxPrice, string $hints): int` لحل المشكلة التالية:\nتحديد السعر الدقيق لعنصر ما ضمن نطاق محدد بناءً على سلسلة من التلميحات.\nسعر العنصر يقع ضمن النطاق [1, maxPrice].\nيتم إعطاء التلميحات في سلسلة حيث:\n- 'u' تشير إلى أن السعر الفعلي أعلى من التخمين الحالي.\n- 'd' تشير إلى أن السعر الفعلي أقل من التخمين الحالي.\n- 'y' تشير إلى أن التخمين الحالي صحيح.\nتستخدم الدالة نهج البحث الثنائي لتضييق نطاق السعر المحتمل.\nالمدخلات: السعر الأقصى (maxPrice) وسلسلة من التلميحات.\nالمخرجات: تعيد السعر الدقيق للعنصر.\nمثال: بالنسبة لـ maxPrice = 1000000 و hints = \"uddy\"، تعيد الدالة 562500.",
      "sw": "Andika kazi ya PHP `function guessItemPrice(int $maxPrice, string $hints): int` kutatua tatizo lifuatalo:\nInabaini bei halisi ya kipengee ndani ya safu maalum kulingana na mfululizo wa vidokezo.\nBei ya kipengee iko ndani ya safu [1, maxPrice].\nVidokezo vinatolewa katika kamba ambapo:\n- 'u' inaonyesha kuwa bei halisi ni ya juu kuliko nadharia ya sasa.\n- 'd' inaonyesha kuwa bei halisi ni ya chini kuliko nadharia ya sasa.\n- 'y' inaonyesha kuwa nadharia ya sasa ni sahihi.\nKazi inatumia mbinu ya utafutaji wa binary kupunguza bei inayowezekana.\nIngizo: Bei ya juu zaidi (maxPrice) na kamba ya vidokezo.\nPato: Inarudisha bei halisi ya kipengee.\nMfano: Kwa maxPrice = 1000000 na hints = \"uddy\", kazi inarudisha 562500.",
      "tr": "Bir PHP fonksiyonu `function guessItemPrice(int $maxPrice, string $hints): int` yazın. Aşağıdaki problemi çözmek için:\nBelirtilen bir aralık içinde bir öğenin tam fiyatını, bir dizi ipucu temelinde belirler.\nÖğenin fiyatı [1, maxPrice] aralığındadır.\nİpuçları, bir dizgede verilir ve:\n- 'u' gerçek fiyatın mevcut tahminden daha yüksek olduğunu belirtir.\n- 'd' gerçek fiyatın mevcut tahminden daha düşük olduğunu belirtir.\n- 'y' mevcut tahminin doğru olduğunu belirtir.\nFonksiyon, olası fiyatı daraltmak için bir ikili arama yaklaşımı kullanır.\nGirdi: Maksimum fiyat (maxPrice) ve bir ipucu dizgesi.\nÇıktı: Öğenin tam fiyatını döndürür.\nÖrnek: maxPrice = 1000000 ve hints = \"uddy\" için, fonksiyon 562500 döndürür.",
      "vi": "Viết một hàm PHP `function guessItemPrice(int $maxPrice, string $hints): int` để giải quyết vấn đề sau:\nXác định giá chính xác của một mặt hàng trong một phạm vi xác định dựa trên một loạt các gợi ý.\nGiá của mặt hàng nằm trong phạm vi [1, maxPrice].\nCác gợi ý được đưa ra trong một chuỗi nơi:\n- 'u' chỉ ra rằng giá thực tế cao hơn so với dự đoán hiện tại.\n- 'd' chỉ ra rằng giá thực tế thấp hơn so với dự đoán hiện tại.\n- 'y' chỉ ra rằng dự đoán hiện tại là đúng.\nHàm sử dụng phương pháp tìm kiếm nhị phân để thu hẹp giá có thể có.\nĐầu vào: Giá tối đa (maxPrice) và một chuỗi các gợi ý.\nĐầu ra: Trả về giá chính xác của mặt hàng.\nVí dụ: Với maxPrice = 1000000 và hints = \"uddy\", hàm trả về 562500."
    },
    "instruction_bertscore": {
      "es": "0.9805834829930776",
      "arb": "0.9763884093456208",
      "sw": "0.9801550372611854",
      "tr": "0.985202831134425",
      "vi": "0.9765242725262486"
    },
    "level": "easy",
    "test": "function main(){\n    assert(guessItemPrice(1000000, \"uddy\") === 562500);\n    assert(guessItemPrice(500, \"ududy\") === 327);\n    assert(guessItemPrice(100, \"uuudy\") === 91);\n    assert(guessItemPrice(1000, \"ddduy\") === 93);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "guessItemPrice",
    "signature": "function guessItemPrice(int $maxPrice, string $hints): int",
    "docstring": {
      "en": "Determines the exact price of an item within a specified range based on a series of hints.\nThe item's price is within the range [1, maxPrice].\nHints are given in a string where:\n- 'u' indicates the actual price is higher than the current guess.\n- 'd' indicates the actual price is lower than the current guess.\n- 'y' indicates the current guess is correct.\nThe function uses a binary search approach to narrow down the possible price.\nInput: The maximum price (maxPrice) and a string of hints.\nOutput: Returns the exact price of the item.\nExample: For maxPrice = 1000000 and hints = \"uddy\", the function returns 562500.",
      "es": "Determina el precio exacto de un artículo dentro de un rango especificado basado en una serie de pistas.  \nEl precio del artículo está dentro del rango [1, maxPrice].  \nLas pistas se dan en una cadena donde:  \n- 'u' indica que el precio real es mayor que la suposición actual.  \n- 'd' indica que el precio real es menor que la suposición actual.  \n- 'y' indica que la suposición actual es correcta.  \nLa función utiliza un enfoque de búsqueda binaria para reducir el posible precio.  \nEntrada: El precio máximo (maxPrice) y una cadena de pistas.  \nSalida: Devuelve el precio exacto del artículo.  \nEjemplo: Para maxPrice = 1000000 y hints = \"uddy\", la función devuelve 562500.",
      "arb": "يحدد السعر الدقيق لعنصر ما ضمن نطاق محدد بناءً على سلسلة من التلميحات. سعر العنصر يقع ضمن النطاق [1، maxPrice]. يتم إعطاء التلميحات في سلسلة حيث: \n- 'u' تشير إلى أن السعر الفعلي أعلى من التخمين الحالي.\n- 'd' تشير إلى أن السعر الفعلي أقل من التخمين الحالي.\n- 'y' تشير إلى أن التخمين الحالي صحيح.\nتستخدم الدالة نهج البحث الثنائي لتضييق نطاق السعر المحتمل.\nالمدخلات: السعر الأقصى (maxPrice) وسلسلة من التلميحات.\nالمخرجات: تعيد السعر الدقيق للعنصر.\nمثال: بالنسبة لـ maxPrice = 1000000 و hints = \"uddy\"، تعيد الدالة 562500.",
      "sw": "Inabainisha bei halisi ya kipengee ndani ya safu maalum kulingana na mfululizo wa vidokezo.\nBei ya kipengee iko ndani ya safu [1, maxPrice].\nVidokezo vinatolewa katika kamba ambapo:\n- 'u' inaashiria kuwa bei halisi ni ya juu kuliko makisio ya sasa.\n- 'd' inaashiria kuwa bei halisi ni ya chini kuliko makisio ya sasa.\n- 'y' inaashiria kuwa makisio ya sasa ni sahihi.\nKazi inatumia mbinu ya utafutaji wa nusu ili kupunguza bei inayowezekana.\nIngizo: Bei ya juu zaidi (maxPrice) na kamba ya vidokezo.\nPato: Inarudisha bei halisi ya kipengee.\nMfano: Kwa maxPrice = 1000000 na hints = \"uddy\", kazi inarudisha 562500.",
      "tr": "Belirtilen bir aralık içinde bir öğenin tam fiyatını, bir dizi ipucu temelinde belirler.\nÖğenin fiyatı [1, maxPrice] aralığındadır.\nİpuçları, aşağıdaki anlamlara gelen bir string olarak verilir:\n- 'u', gerçek fiyatın mevcut tahminden daha yüksek olduğunu belirtir.\n- 'd', gerçek fiyatın mevcut tahminden daha düşük olduğunu belirtir.\n- 'y', mevcut tahminin doğru olduğunu belirtir.\nFonksiyon, olası fiyatı daraltmak için ikili arama yaklaşımını kullanır.\nGirdi: Maksimum fiyat (maxPrice) ve bir ipucu dizisi.\nÇıktı: Öğenin tam fiyatını döndürür.\nÖrnek: maxPrice = 1000000 ve hints = \"uddy\" için, fonksiyon 562500 değerini döndürür.",
      "vi": "Xác định giá chính xác của một mặt hàng trong một phạm vi xác định dựa trên một loạt các gợi ý.  \nGiá của mặt hàng nằm trong phạm vi [1, maxPrice].  \nCác gợi ý được đưa ra trong một chuỗi nơi:  \n- 'u' chỉ ra rằng giá thực tế cao hơn giá đoán hiện tại.  \n- 'd' chỉ ra rằng giá thực tế thấp hơn giá đoán hiện tại.  \n- 'y' chỉ ra rằng giá đoán hiện tại là chính xác.  \nHàm sử dụng phương pháp tìm kiếm nhị phân để thu hẹp giá có thể có.  \nĐầu vào: Giá tối đa (maxPrice) và một chuỗi các gợi ý.  \nĐầu ra: Trả về giá chính xác của mặt hàng.  \nVí dụ: Với maxPrice = 1000000 và hints = \"uddy\", hàm trả về 562500.  "
    },
    "docstring_bertscore": {
      "es": "0.9826770472091854",
      "arb": "0.9768730674753459",
      "sw": "0.9687284273313913",
      "tr": "0.9659740198375806",
      "vi": "0.9616122953004355"
    }
  },
  {
    "task_id": "PHP/19",
    "prompt": {
      "en": "<?php\n\n/**\n * Calculates the total effort required to sort a list of disordered elements.\n * In this scenario, imagine a series of numbered containers in a warehouse. Each container must be arranged in ascending order. \n * The effort to swap two containers is proportional to the distance between them, measured as double their positional difference.\n * Input: An array of integers representing the unsorted container numbers.\n * Output: Returns an integer representing the total effort required to sort the containers.\n * Example: For input [3, 1, 4, 2], the output is 8.\n */\n\nfunction calculateEffort($horseNumbers) ",
      "es": "<?php\n\n/**\n * Calcula el esfuerzo total requerido para ordenar una lista de elementos desordenados.\n * En este escenario, imagina una serie de contenedores numerados en un almacén. Cada contenedor debe ser ordenado en orden ascendente.\n * El esfuerzo para intercambiar dos contenedores es proporcional a la distancia entre ellos, medida como el doble de su diferencia posicional.\n * Entrada: Un array de enteros que representa los números de contenedores desordenados.\n * Salida: Devuelve un entero que representa el esfuerzo total requerido para ordenar los contenedores.\n * Ejemplo: Para la entrada [3, 1, 4, 2], la salida es 8.\n */\n\nfunction calculateEffort($horseNumbers) ",
      "arb": "<?php\n\n/**\n * يحسب الجهد الكلي المطلوب لترتيب قائمة من العناصر غير المرتبة.\n * في هذا السيناريو، تخيل سلسلة من الحاويات المرقمة في مستودع. يجب ترتيب كل حاوية بترتيب تصاعدي.\n * الجهد المطلوب لتبديل حاويتين يتناسب مع المسافة بينهما، ويقاس على أنه ضعف الفرق في موضعهما.\n * المدخل: مصفوفة من الأعداد الصحيحة تمثل أرقام الحاويات غير المرتبة.\n * المخرج: يعيد عددًا صحيحًا يمثل الجهد الكلي المطلوب لترتيب الحاويات.\n * مثال: للمدخل [3, 1, 4, 2]، يكون المخرج 8.\n */\n\nfunction calculateEffort($horseNumbers) ",
      "sw": "<?php\n\n/**\n * Inahesabu juhudi jumla zinazohitajika kupanga orodha ya vipengele visivyopangwa.\n * Katika hali hii, fikiria mfululizo wa makontena yenye namba katika ghala. Kila kontena lazima lipangwe kwa mpangilio wa kupanda.\n * Juhudi za kubadilisha nafasi ya makontena mawili ni sawa na umbali kati yao, kipimo kama mara mbili ya tofauti ya nafasi zao.\n * Ingizo: Mfululizo wa nambari za integer zinazowakilisha nambari za makontena yasiyopangwa.\n * Tokeo: Inarudisha nambari ya integer inayowakilisha juhudi jumla zinazohitajika kupanga makontena.\n * Mfano: Kwa ingizo [3, 1, 4, 2], tokeo ni 8.\n */\n\nfunction calculateEffort($horseNumbers) ",
      "tr": "<?php\n\n/**\n * Bir listeyi sıralamak için gereken toplam çabayı hesaplar.\n * Bu senaryoda, bir depoda numaralandırılmış bir dizi konteyner hayal edin. Her konteynerin artan sırayla düzenlenmesi gerekir.\n * İki konteyneri değiştirme çabası, aralarındaki mesafe ile orantılıdır ve bu mesafe, konumsal farklarının iki katı olarak ölçülür.\n * Girdi: Sırasız konteyner numaralarını temsil eden bir tamsayı dizisi.\n * Çıktı: Konteynerleri sıralamak için gereken toplam çabayı temsil eden bir tamsayı döndürür.\n * Örnek: Girdi [3, 1, 4, 2] için, çıktı 8'dir.\n */\n\nfunction calculateEffort($horseNumbers) ",
      "vi": "<?php\n\n/**\n * Tính toán tổng công sức cần thiết để sắp xếp một danh sách các phần tử không theo thứ tự.\n * Trong tình huống này, hãy tưởng tượng một loạt các thùng chứa được đánh số trong một nhà kho. Mỗi thùng chứa phải được sắp xếp theo thứ tự tăng dần.\n * Công sức để hoán đổi hai thùng chứa tỷ lệ thuận với khoảng cách giữa chúng, được đo bằng gấp đôi sự khác biệt vị trí của chúng.\n * Đầu vào: Một mảng số nguyên đại diện cho các số thùng chứa chưa được sắp xếp.\n * Đầu ra: Trả về một số nguyên đại diện cho tổng công sức cần thiết để sắp xếp các thùng chứa.\n * Ví dụ: Với đầu vào [3, 1, 4, 2], đầu ra là 8.\n */\n\nfunction calculateEffort($horseNumbers) "
    },
    "prompt_bertscore": {
      "es": "0.9783621994419645",
      "arb": "0.9632430507287318",
      "sw": "0.9411050988712505",
      "tr": "0.9575463314006513",
      "vi": "0.9729866654400173"
    },
    "canonical_solution": "{\n    $effort = 0;\n    $n = count($horseNumbers);\n    for ($i = 0; $i < $n - 1; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            if ($horseNumbers[$i] > $horseNumbers[$j]) {\n                // Swapping\n                $temp = $horseNumbers[$i];\n                $horseNumbers[$i] = $horseNumbers[$j];\n                $horseNumbers[$j] = $temp;\n                // Calculating effort\n                $effort += ($j - $i) * 2;\n            }\n        }\n    }\n    return $effort;\n}",
    "instruction": {
      "en": "Write a PHP function `function calculateEffort($horseNumbers)` to solve the following problem:\nCalculates the total effort required to sort a list of disordered elements.\nIn this scenario, imagine a series of numbered containers in a warehouse. Each container must be arranged in ascending order.\nThe effort to swap two containers is proportional to the distance between them, measured as double their positional difference.\nInput: An array of integers representing the unsorted container numbers.\nOutput: Returns an integer representing the total effort required to sort the containers.\nExample: For input [3, 1, 4, 2], the output is 8.",
      "es": "Escribe una función PHP `function calculateEffort($horseNumbers)` para resolver el siguiente problema:\nCalcula el esfuerzo total requerido para ordenar una lista de elementos desordenados.\nEn este escenario, imagina una serie de contenedores numerados en un almacén. Cada contenedor debe ser ordenado en orden ascendente.\nEl esfuerzo para intercambiar dos contenedores es proporcional a la distancia entre ellos, medida como el doble de su diferencia posicional.\nEntrada: Un array de enteros que representa los números de contenedores desordenados.\nSalida: Devuelve un entero que representa el esfuerzo total requerido para ordenar los contenedores.\nEjemplo: Para la entrada [3, 1, 4, 2], la salida es 8.",
      "arb": "اكتب دالة PHP `function calculateEffort($horseNumbers)` لحل المشكلة التالية:\nتحسب الجهد الكلي المطلوب لترتيب قائمة من العناصر غير المرتبة.\nفي هذا السيناريو، تخيل سلسلة من الحاويات المرقمة في مستودع. يجب ترتيب كل حاوية بترتيب تصاعدي.\nالجهد المطلوب لتبديل حاويتين يتناسب مع المسافة بينهما، ويقاس على أنه ضعف الفرق في موقعهما.\nالمدخلات: مصفوفة من الأعداد الصحيحة تمثل أرقام الحاويات غير المرتبة.\nالمخرجات: تُرجع عددًا صحيحًا يمثل الجهد الكلي المطلوب لترتيب الحاويات.\nمثال: بالنسبة للمدخل [3, 1, 4, 2]، يكون الناتج 8.",
      "sw": "Andika kazi ya PHP `function calculateEffort($horseNumbers)` kutatua tatizo lifuatalo:\nHesabu jumla ya juhudi zinazohitajika kupanga orodha ya vipengele visivyopangwa.\nKatika hali hii, fikiria mfululizo wa makontena yenye namba katika ghala. Kila kontena lazima lipangwe kwa mpangilio wa kupanda.\nJuhudi ya kubadilisha makontena mawili ni sawia na umbali kati yao, kipimo chake ni mara mbili ya tofauti ya nafasi zao.\nIngizo: Safu ya nambari za integers zinazowakilisha namba za kontena zisizopangwa.\nPato: Inarudisha integer inayowakilisha jumla ya juhudi zinazohitajika kupanga makontena.\nMfano: Kwa ingizo [3, 1, 4, 2], pato ni 8.",
      "tr": "Bir PHP fonksiyonu `function calculateEffort($horseNumbers)` yazın:\nDüzensiz elemanlardan oluşan bir listeyi sıralamak için gereken toplam çabayı hesaplar.\nBu senaryoda, bir depoda numaralandırılmış bir dizi konteyner hayal edin. Her konteynerin artan sırayla düzenlenmesi gerekmektedir.\nİki konteyneri değiştirme çabası, aralarındaki mesafeye orantılıdır ve bu mesafe, pozisyonel farklarının iki katı olarak ölçülür.\nGirdi: Sırasız konteyner numaralarını temsil eden bir tamsayı dizisi.\nÇıktı: Konteynerleri sıralamak için gereken toplam çabayı temsil eden bir tamsayı döndürür.\nÖrnek: [3, 1, 4, 2] girişi için çıktı 8'dir.",
      "vi": "Viết một hàm PHP `function calculateEffort($horseNumbers)` để giải quyết vấn đề sau:\nTính toán tổng nỗ lực cần thiết để sắp xếp một danh sách các phần tử không theo thứ tự.\nTrong tình huống này, hãy tưởng tượng một loạt các thùng được đánh số trong một kho hàng. Mỗi thùng phải được sắp xếp theo thứ tự tăng dần.\nNỗ lực để hoán đổi hai thùng tỷ lệ thuận với khoảng cách giữa chúng, được đo bằng cách nhân đôi sự khác biệt về vị trí của chúng.\nĐầu vào: Một mảng các số nguyên đại diện cho số thứ tự của các thùng chưa được sắp xếp.\nĐầu ra: Trả về một số nguyên đại diện cho tổng nỗ lực cần thiết để sắp xếp các thùng.\nVí dụ: Với đầu vào [3, 1, 4, 2], đầu ra là 8."
    },
    "instruction_bertscore": {
      "es": "0.9773146228123865",
      "arb": "0.968652749156217",
      "sw": "0.9576964959687136",
      "tr": "0.9518865573234432",
      "vi": "0.9528403804131728"
    },
    "level": "easy",
    "test": "function main(){\n    assert(calculateEffort([2, 3, 6, 5, 8, 4]) === 14);\n    assert(calculateEffort([3, 1, 4, 2]) === 8);\n    assert(calculateEffort([1, 2, 3, 4]) === 0); // Already sorted\n    assert(calculateEffort([4, 3, 2, 1]) === 20); // Reverse order\n    \n}\n\n\nmain();\n?>",
    "entry_point": "calculateEffort",
    "signature": "function calculateEffort($horseNumbers)",
    "docstring": {
      "en": "Calculates the total effort required to sort a list of disordered elements.\nIn this scenario, imagine a series of numbered containers in a warehouse. Each container must be arranged in ascending order.\nThe effort to swap two containers is proportional to the distance between them, measured as double their positional difference.\nInput: An array of integers representing the unsorted container numbers.\nOutput: Returns an integer representing the total effort required to sort the containers.\nExample: For input [3, 1, 4, 2], the output is 8.",
      "es": "Calcula el esfuerzo total requerido para ordenar una lista de elementos desordenados.  \nEn este escenario, imagina una serie de contenedores numerados en un almacén. Cada contenedor debe ser organizado en orden ascendente.  \nEl esfuerzo para intercambiar dos contenedores es proporcional a la distancia entre ellos, medida como el doble de su diferencia posicional.  \nEntrada: Un array de enteros que representa los números de contenedores desordenados.  \nSalida: Devuelve un entero que representa el esfuerzo total requerido para ordenar los contenedores.  \nEjemplo: Para la entrada [3, 1, 4, 2], la salida es 8.",
      "arb": "يحسب الجهد الكلي المطلوب لترتيب قائمة من العناصر غير المرتبة.\nفي هذا السيناريو، تخيل سلسلة من الحاويات المرقمة في مستودع. يجب ترتيب كل حاوية بترتيب تصاعدي.\nالجهد المطلوب لتبديل حاويتين يتناسب مع المسافة بينهما، ويقاس كضعف الفرق بين موقعيهما.\nالمدخلات: مصفوفة من الأعداد الصحيحة تمثل أرقام الحاويات غير المرتبة.\nالمخرجات: تُرجع عددًا صحيحًا يمثل الجهد الكلي المطلوب لترتيب الحاويات.\nالمثال: للمدخل [3, 1, 4, 2]، الناتج هو 8.",
      "sw": "Hesabu juhudi jumla zinazohitajika kupanga orodha ya vipengele visivyopangwa.\nKatika hali hii, fikiria mfululizo wa vyombo vilivyohesabiwa katika ghala. Kila chombo lazima kipangwe kwa mpangilio wa kupanda.\nJuhudi za kubadilisha vyombo viwili zinahusiana na umbali kati yao, kipimo chake ni mara mbili ya tofauti yao ya nafasi.\nIngizo: Safu ya nambari za integer zinazowakilisha nambari za vyombo visivyopangwa.\nPato: Inarudisha nambari ya integer inayowakilisha juhudi jumla zinazohitajika kupanga vyombo.\nMfano: Kwa ingizo [3, 1, 4, 2], pato ni 8.",
      "tr": "Hesaplanmamış elemanlardan oluşan bir listeyi sıralamak için gereken toplam çabayı hesaplar.\nBu senaryoda, bir depodaki numaralandırılmış konteynerler serisini hayal edin. Her konteynerin artan sırayla düzenlenmesi gerekir.\nİki konteyneri değiştirme çabası, aralarındaki mesafeye orantılıdır ve bu mesafe, konumsal farklarının iki katı olarak ölçülür.\nGirdi: Sırasız konteyner numaralarını temsil eden bir tamsayı dizisi.\nÇıktı: Konteynerleri sıralamak için gereken toplam çabayı temsil eden bir tamsayı döndürür.\nÖrnek: Girdi [3, 1, 4, 2] için çıktı 8'dir.",
      "vi": "Tính toán tổng công sức cần thiết để sắp xếp một danh sách các phần tử không theo thứ tự.  \nTrong tình huống này, hãy tưởng tượng một loạt các thùng được đánh số trong một nhà kho. Mỗi thùng phải được sắp xếp theo thứ tự tăng dần.  \nCông sức để hoán đổi hai thùng tỷ lệ thuận với khoảng cách giữa chúng, được đo bằng gấp đôi sự khác biệt vị trí của chúng.  \nĐầu vào: Một mảng các số nguyên đại diện cho các số thùng chưa được sắp xếp.  \nĐầu ra: Trả về một số nguyên đại diện cho tổng công sức cần thiết để sắp xếp các thùng.  \nVí dụ: Với đầu vào [3, 1, 4, 2], đầu ra là 8."
    },
    "docstring_bertscore": {
      "es": "0.9779192536922566",
      "arb": "0.9656319783214384",
      "sw": "0.9557260825888476",
      "tr": "0.9544502796514605",
      "vi": "0.9522770646525578"
    }
  },
  {
    "task_id": "PHP/20",
    "prompt": {
      "en": "<?php\n/**\n * Determines the ranking of a player at the time of their entry in a competition.\n * \n * In this competition, scores are announced one after another, updating the leaderboard each time.\n * This function calculates the rank of a specific player at the time they were added to the leaderboard.\n * \n * Input: \n * - $scores: An array of integers representing the scores of each player.\n * - $playerIndex: An integer representing the index of the player (1-based index).\n * \n * Output: \n * - Returns an integer, the rank of the player at the time of their entry.\n * \n * Example: \n * For scores [95, 92, 93, 100, 102, 99] and playerIndex 3, the function should return 2.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) ",
      "es": "<?php\n/**\n * Determina la clasificación de un jugador en el momento de su entrada en una competencia.\n * \n * En esta competencia, las puntuaciones se anuncian una tras otra, actualizando la tabla de clasificación cada vez.\n * Esta función calcula la clasificación de un jugador específico en el momento en que se agregó a la tabla de clasificación.\n * \n * Entrada: \n * - $scores: Un arreglo de enteros que representa las puntuaciones de cada jugador.\n * - $playerIndex: Un entero que representa el índice del jugador (índice basado en 1).\n * \n * Salida: \n * - Devuelve un entero, la clasificación del jugador en el momento de su entrada.\n * \n * Ejemplo: \n * Para puntuaciones [95, 92, 93, 100, 102, 99] y playerIndex 3, la función debería devolver 2.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) ",
      "arb": "<?php\n/**\n * يحدد ترتيب اللاعب في وقت دخوله في مسابقة.\n * \n * في هذه المسابقة، يتم الإعلان عن الدرجات واحدة تلو الأخرى، مما يحدث تحديثًا للوحة المتصدرين في كل مرة.\n * تقوم هذه الدالة بحساب ترتيب لاعب معين في وقت إضافته إلى لوحة المتصدرين.\n * \n * المدخلات:\n * - $scores: مصفوفة من الأعداد الصحيحة تمثل درجات كل لاعب.\n * - $playerIndex: عدد صحيح يمثل فهرس اللاعب (فهرس يبدأ من 1).\n * \n * المخرجات:\n * - تعيد عددًا صحيحًا، ترتيب اللاعب في وقت دخوله.\n * \n * مثال:\n * للدرجات [95, 92, 93, 100, 102, 99] و playerIndex 3، يجب أن تعيد الدالة 2.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) ",
      "sw": "<?php\n/**\n * Huamua kiwango cha mchezaji wakati wa kuingia kwake katika mashindano.\n * \n * Katika mashindano haya, alama hutangazwa moja baada ya nyingine, ikisasisha ubao wa viongozi kila wakati.\n * Kazi hii huhesabu kiwango cha mchezaji maalum wakati walipoongezwa kwenye ubao wa viongozi.\n * \n * Ingizo: \n * - $scores: Kundi la nambari za mzima linalowakilisha alama za kila mchezaji.\n * - $playerIndex: Nambari ya mzima inayowakilisha faharasa ya mchezaji (faharasa inayotokana na 1).\n * \n * Tokeo: \n * - Inarudisha nambari ya mzima, kiwango cha mchezaji wakati wa kuingia kwake.\n * \n * Mfano: \n * Kwa alama [95, 92, 93, 100, 102, 99] na playerIndex 3, kazi inapaswa kurudisha 2.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) ",
      "tr": "<?php\n/**\n * Bir oyuncunun bir yarışmaya katıldığı andaki sıralamasını belirler.\n * \n * Bu yarışmada, puanlar birbiri ardına açıklanır ve her seferinde liderlik tablosu güncellenir.\n * Bu fonksiyon, belirli bir oyuncunun liderlik tablosuna eklendiği andaki sıralamasını hesaplar.\n * \n * Girdi: \n * - $scores: Her oyuncunun puanlarını temsil eden bir tamsayı dizisi.\n * - $playerIndex: Oyuncunun indeksini temsil eden bir tamsayı (1 tabanlı indeks).\n * \n * Çıktı: \n * - Bir tamsayı döndürür, oyuncunun katılım anındaki sıralaması.\n * \n * Örnek: \n * Puanlar [95, 92, 93, 100, 102, 99] ve playerIndex 3 için, fonksiyon 2 döndürmelidir.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) ",
      "vi": "<?php\n/**\n * Xác định thứ hạng của một người chơi tại thời điểm họ tham gia vào cuộc thi.\n * \n * Trong cuộc thi này, điểm số được công bố lần lượt, cập nhật bảng xếp hạng mỗi lần.\n * Hàm này tính toán thứ hạng của một người chơi cụ thể tại thời điểm họ được thêm vào bảng xếp hạng.\n * \n * Đầu vào: \n * - $scores: Một mảng các số nguyên đại diện cho điểm số của mỗi người chơi.\n * - $playerIndex: Một số nguyên đại diện cho chỉ số của người chơi (chỉ số bắt đầu từ 1).\n * \n * Đầu ra: \n * - Trả về một số nguyên, thứ hạng của người chơi tại thời điểm họ tham gia.\n * \n * Ví dụ: \n * Với điểm số [95, 92, 93, 100, 102, 99] và playerIndex 3, hàm nên trả về 2.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) "
    },
    "prompt_bertscore": {
      "es": "0.9896398365859823",
      "arb": "0.970730820202604",
      "sw": "0.9690474277233334",
      "tr": "0.9660298349746513",
      "vi": "0.9516565433422047"
    },
    "canonical_solution": "{\n    $playerScore = $scores[$playerIndex - 1];\n    $rank = 1;\n\n    for ($i = 0; $i < $playerIndex - 1; $i++) {\n        if ($scores[$i] >= $playerScore) {\n            $rank++;\n        }\n    }\n\n    return $rank;\n}",
    "instruction": {
      "en": "Write a PHP function `function getPlayerRankingAtEntry($scores, $playerIndex)` to solve the following problem:\nDetermines the ranking of a player at the time of their entry in a competition.\n\nIn this competition, scores are announced one after another, updating the leaderboard each time.\nThis function calculates the rank of a specific player at the time they were added to the leaderboard.\n\nInput:\n- $scores: An array of integers representing the scores of each player.\n- $playerIndex: An integer representing the index of the player (1-based index).\n\nOutput:\n- Returns an integer, the rank of the player at the time of their entry.\n\nExample:\nFor scores [95, 92, 93, 100, 102, 99] and playerIndex 3, the function should return 2.",
      "es": "Escribe una función PHP `function getPlayerRankingAtEntry($scores, $playerIndex)` para resolver el siguiente problema:\nDetermina la clasificación de un jugador en el momento de su entrada en una competencia.\n\nEn esta competencia, las puntuaciones se anuncian una tras otra, actualizando la tabla de clasificación cada vez.\nEsta función calcula la clasificación de un jugador específico en el momento en que fueron añadidos a la tabla de clasificación.\n\nEntrada:\n- $scores: Un arreglo de enteros que representa las puntuaciones de cada jugador.\n- $playerIndex: Un entero que representa el índice del jugador (índice basado en 1).\n\nSalida:\n- Devuelve un entero, la clasificación del jugador en el momento de su entrada.\n\nEjemplo:\nPara puntuaciones [95, 92, 93, 100, 102, 99] y playerIndex 3, la función debería devolver 2.",
      "arb": "اكتب دالة PHP `function getPlayerRankingAtEntry($scores, $playerIndex)` لحل المشكلة التالية:\nتحديد ترتيب اللاعب في وقت دخوله في مسابقة.\n\nفي هذه المسابقة، يتم الإعلان عن الدرجات واحدة تلو الأخرى، مما يحدّث لوحة المتصدرين في كل مرة.\nتحسب هذه الدالة ترتيب لاعب معين في الوقت الذي تمت إضافته إلى لوحة المتصدرين.\n\nالمدخلات:\n- $scores: مصفوفة من الأعداد الصحيحة تمثل درجات كل لاعب.\n- $playerIndex: عدد صحيح يمثل مؤشر اللاعب (مؤشر يبدأ من 1).\n\nالمخرجات:\n- تُرجع عددًا صحيحًا، وهو ترتيب اللاعب في وقت دخوله.\n\nمثال:\nبالنسبة للدرجات [95, 92, 93, 100, 102, 99] و playerIndex 3، يجب أن تُرجع الدالة 2.",
      "sw": "Andika kazi ya PHP `function getPlayerRankingAtEntry($scores, $playerIndex)` kutatua tatizo lifuatalo:\nInabainisha nafasi ya mchezaji wakati wa kuingia kwake katika mashindano.\n\nKatika mashindano haya, alama zinatangazwa moja baada ya nyingine, zikisasisha ubao wa viongozi kila wakati.\nKazi hii inahesabu nafasi ya mchezaji maalum wakati walipoongezwa kwenye ubao wa viongozi.\n\nIngizo:\n- $scores: Ni safu ya namba za mzima zinazoashiria alama za kila mchezaji.\n- $playerIndex: Ni namba nzima inayowakilisha faharasa ya mchezaji (faharasa inayotokana na 1).\n\nMatokeo:\n- Inarejesha namba nzima, nafasi ya mchezaji wakati wa kuingia kwake.\n\nMfano:\nKwa alama [95, 92, 93, 100, 102, 99] na playerIndex 3, kazi inapaswa kurejesha 2.",
      "tr": "Bir PHP fonksiyonu `function getPlayerRankingAtEntry($scores, $playerIndex)` yazın:\nBir oyuncunun bir yarışmaya katıldığı zamandaki sıralamasını belirler.\n\nBu yarışmada, puanlar birbiri ardına açıklanır ve her seferinde liderlik tablosu güncellenir.\nBu fonksiyon, belirli bir oyuncunun liderlik tablosuna eklendiği zamandaki sıralamasını hesaplar.\n\nGirdi:\n- $scores: Her oyuncunun puanlarını temsil eden bir tamsayı dizisi.\n- $playerIndex: Oyuncunun indeksini temsil eden bir tamsayı (1 tabanlı indeks).\n\nÇıktı:\n- Oyuncunun girdiği zamandaki sıralamasını belirten bir tamsayı döndürür.\n\nÖrnek:\nPuanlar [95, 92, 93, 100, 102, 99] ve playerIndex 3 için, fonksiyon 2 döndürmelidir.",
      "vi": "Viết một hàm PHP `function getPlayerRankingAtEntry($scores, $playerIndex)` để giải quyết vấn đề sau:\nXác định thứ hạng của một người chơi tại thời điểm họ tham gia vào một cuộc thi.\n\nTrong cuộc thi này, điểm số được công bố lần lượt, cập nhật bảng xếp hạng mỗi lần.\nHàm này tính toán thứ hạng của một người chơi cụ thể tại thời điểm họ được thêm vào bảng xếp hạng.\n\nĐầu vào:\n- $scores: Một mảng các số nguyên đại diện cho điểm số của mỗi người chơi.\n- $playerIndex: Một số nguyên đại diện cho chỉ số của người chơi (chỉ số bắt đầu từ 1).\n\nĐầu ra:\n- Trả về một số nguyên, thứ hạng của người chơi tại thời điểm họ tham gia.\n\nVí dụ:\nVới điểm số [95, 92, 93, 100, 102, 99] và playerIndex 3, hàm nên trả về 2."
    },
    "instruction_bertscore": {
      "es": "0.9848321868434139",
      "arb": "0.9651612243183858",
      "sw": "0.9460581460527364",
      "tr": "0.9637082430811156",
      "vi": "0.9546439442729695"
    },
    "level": "easy",
    "test": "function main(){\n    assert(getPlayerRankingAtEntry([95, 92, 93, 100, 102, 99], 3) === 2);\n    assert(getPlayerRankingAtEntry([90, 85, 95, 88, 92], 5) === 2);\n    assert(getPlayerRankingAtEntry([100, 105, 95, 110, 90], 1) === 1);\n    assert(getPlayerRankingAtEntry([70, 80, 60, 90, 85], 4) === 1);\n    assert(getPlayerRankingAtEntry([95, 95, 95, 95, 95], 3) === 3);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "getPlayerRankingAtEntry",
    "signature": "function getPlayerRankingAtEntry($scores, $playerIndex)",
    "docstring": {
      "en": "Determines the ranking of a player at the time of their entry in a competition.\n\nIn this competition, scores are announced one after another, updating the leaderboard each time.\nThis function calculates the rank of a specific player at the time they were added to the leaderboard.\n\nInput:\n- $scores: An array of integers representing the scores of each player.\n- $playerIndex: An integer representing the index of the player (1-based index).\n\nOutput:\n- Returns an integer, the rank of the player at the time of their entry.\n\nExample:\nFor scores [95, 92, 93, 100, 102, 99] and playerIndex 3, the function should return 2.",
      "es": "Determina la clasificación de un jugador en el momento de su entrada en una competición.\n\nEn esta competición, las puntuaciones se anuncian una tras otra, actualizando la tabla de clasificación cada vez.\nEsta función calcula el rango de un jugador específico en el momento en que fueron añadidos a la tabla de clasificación.\n\nEntrada:\n- $scores: Un arreglo de enteros que representa las puntuaciones de cada jugador.\n- $playerIndex: Un entero que representa el índice del jugador (índice basado en 1).\n\nSalida:\n- Devuelve un entero, la clasificación del jugador en el momento de su entrada.\n\nEjemplo:\nPara scores [95, 92, 93, 100, 102, 99] y playerIndex 3, la función debería devolver 2.",
      "arb": "يحدد ترتيب اللاعب في وقت دخوله في مسابقة.\n\nفي هذه المسابقة، يتم الإعلان عن الدرجات واحدة تلو الأخرى، مع تحديث لوحة المتصدرين في كل مرة.\nتقوم هذه الدالة بحساب ترتيب لاعب معين في الوقت الذي تمت إضافته إلى لوحة المتصدرين.\n\nالمدخلات:\n- $scores: مصفوفة من الأعداد الصحيحة تمثل درجات كل لاعب.\n- $playerIndex: عدد صحيح يمثل مؤشر اللاعب (مؤشر يبدأ من 1).\n\nالمخرجات:\n- تُرجع عددًا صحيحًا، وهو ترتيب اللاعب في وقت دخوله.\n\nمثال:\nبالنسبة للدرجات [95, 92, 93, 100, 102, 99] وplayerIndex 3، يجب أن تُرجع الدالة 2.",
      "sw": "Inabainisha cheo cha mchezaji wakati wa kuingia kwake katika mashindano.\n\nKatika mashindano haya, alama hutangazwa moja baada ya nyingine, ikisasisha ubao wa viongozi kila wakati.\nKazi hii huhesabu cheo cha mchezaji maalum wakati walipoongezwa kwenye ubao wa viongozi.\n\nIngizo:\n- $scores: Mfululizo wa nambari za mzima zinazowakilisha alama za kila mchezaji.\n- $playerIndex: Nambari ya mzima inayowakilisha faharasa ya mchezaji (faharasa inayotegemea 1).\n\nMatokeo:\n- Inarudisha nambari ya mzima, cheo cha mchezaji wakati wa kuingia kwake.\n\nMfano:\nKwa alama [95, 92, 93, 100, 102, 99] na playerIndex 3, kazi inapaswa kurudisha 2.",
      "tr": "Bir oyuncunun bir yarışmaya katıldığı zamandaki sıralamasını belirler.\n\nBu yarışmada, puanlar birbiri ardına açıklanır ve her seferinde liderlik tablosu güncellenir.\nBu fonksiyon, belirli bir oyuncunun liderlik tablosuna eklendiği zamandaki sıralamasını hesaplar.\n\nGirdi:\n- $scores: Her oyuncunun puanlarını temsil eden bir tamsayı dizisi.\n- $playerIndex: Oyuncunun indeksini temsil eden bir tamsayı (1 tabanlı indeks).\n\nÇıktı:\n- Oyuncunun katıldığı zamandaki sıralamasını belirten bir tamsayı döndürür.\n\nÖrnek:\nPuanlar [95, 92, 93, 100, 102, 99] ve playerIndex 3 için, fonksiyon 2 döndürmelidir.",
      "vi": "Xác định thứ hạng của một người chơi tại thời điểm họ tham gia vào một cuộc thi.\n\nTrong cuộc thi này, điểm số được công bố lần lượt, cập nhật bảng xếp hạng mỗi lần.\nHàm này tính toán thứ hạng của một người chơi cụ thể tại thời điểm họ được thêm vào bảng xếp hạng.\n\nĐầu vào:\n- $scores: Một mảng các số nguyên đại diện cho điểm số của mỗi người chơi.\n- $playerIndex: Một số nguyên đại diện cho chỉ số của người chơi (chỉ số bắt đầu từ 1).\n\nĐầu ra:\n- Trả về một số nguyên, thứ hạng của người chơi tại thời điểm họ tham gia.\n\nVí dụ:\nVới điểm số [95, 92, 93, 100, 102, 99] và playerIndex 3, hàm nên trả về 2."
    },
    "docstring_bertscore": {
      "es": "0.9858128250345831",
      "arb": "0.9679698579062191",
      "sw": "0.9673016653044177",
      "tr": "0.9700048261599216",
      "vi": "0.9421050042093801"
    }
  },
  {
    "task_id": "PHP/21",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Determines if two months in a given year are \"related\".\n * Two months are considered related if the first day of each month falls on the same day of the week.\n * This condition is true if the difference in days between the first day of these months is divisible by 7.\n * Leap years are taken into account, as February has 29 days in a leap year.\n *\n * Input: \n * - $year: An integer representing the year.\n * - $month1: An integer representing the first month.\n * - $month2: An integer representing the second month.\n *\n * Output: \n * - Returns 'YES' if the months are related; 'NO' otherwise.\n *\n * Examples:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string ",
      "es": "<?php\n\n\n/**\n * Determina si dos meses en un año dado están \"relacionados\".\n * Se considera que dos meses están relacionados si el primer día de cada mes cae en el mismo día de la semana.\n * Esta condición es verdadera si la diferencia en días entre el primer día de estos meses es divisible por 7.\n * Se tienen en cuenta los años bisiestos, ya que febrero tiene 29 días en un año bisiesto.\n *\n * Entrada: \n * - $year: Un entero que representa el año.\n * - $month1: Un entero que representa el primer mes.\n * - $month2: Un entero que representa el segundo mes.\n *\n * Salida: \n * - Devuelve 'YES' si los meses están relacionados; 'NO' en caso contrario.\n *\n * Ejemplos:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string ",
      "arb": "<?php\n\n\n/**\n * يحدد ما إذا كان شهران في سنة معينة \"مرتبطين\".\n * يعتبر الشهران مرتبطين إذا كان اليوم الأول من كل شهر يقع في نفس اليوم من الأسبوع.\n * تكون هذه الحالة صحيحة إذا كان الفرق في الأيام بين اليوم الأول من هذه الأشهر قابلاً للقسمة على 7.\n * يتم أخذ السنوات الكبيسة في الاعتبار، حيث يحتوي شهر فبراير على 29 يومًا في السنة الكبيسة.\n *\n * المدخلات:\n * - $year: عدد صحيح يمثل السنة.\n * - $month1: عدد صحيح يمثل الشهر الأول.\n * - $month2: عدد صحيح يمثل الشهر الثاني.\n *\n * المخرجات:\n * - يعيد 'YES' إذا كانت الأشهر مرتبطة؛ 'NO' خلاف ذلك.\n *\n * أمثلة:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string ",
      "sw": "<?php\n\n\n/**\n * Inabainisha kama miezi miwili katika mwaka fulani ni \"inayohusiana\".\n * Miezi miwili inachukuliwa kuwa inayohusiana ikiwa siku ya kwanza ya kila mwezi inaangukia siku moja ya wiki.\n * Hali hii ni kweli ikiwa tofauti ya siku kati ya siku ya kwanza ya miezi hii inagawanyika kwa 7.\n * Miaka ya kuruka inazingatiwa, kwani Februari ina siku 29 katika mwaka wa kuruka.\n *\n * Ingizo: \n * - $year: Nambari nzima inayowakilisha mwaka.\n * - $month1: Nambari nzima inayowakilisha mwezi wa kwanza.\n * - $month2: Nambari nzima inayowakilisha mwezi wa pili.\n *\n * Matokeo: \n * - Inarudisha 'YES' ikiwa miezi inahusiana; 'NO' vinginevyo.\n *\n * Mifano:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string ",
      "tr": "<?php\n\n\n/**\n * Belirli bir yıldaki iki ayın \"ilişkili\" olup olmadığını belirler.\n * İki ay, her ayın ilk günü haftanın aynı gününe denk geliyorsa ilişkili kabul edilir.\n * Bu koşul, bu ayların ilk günü arasındaki gün farkının 7'ye bölünebilir olması durumunda doğrudur.\n * Artık yıllar dikkate alınır, çünkü Şubat ayı artık yılda 29 gündür.\n *\n * Girdi: \n * - $year: Yılı temsil eden bir tamsayı.\n * - $month1: İlk ayı temsil eden bir tamsayı.\n * - $month2: İkinci ayı temsil eden bir tamsayı.\n *\n * Çıktı: \n * - Aylar ilişkiliyse 'YES' döner; aksi takdirde 'NO' döner.\n *\n * Örnekler:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string ",
      "vi": "<?php\n\n\n/**\n * Xác định xem hai tháng trong một năm nhất định có \"liên quan\" hay không.\n * Hai tháng được coi là liên quan nếu ngày đầu tiên của mỗi tháng rơi vào cùng một ngày trong tuần.\n * Điều kiện này đúng nếu chênh lệch ngày giữa ngày đầu tiên của các tháng này chia hết cho 7.\n * Năm nhuận được tính đến, vì tháng Hai có 29 ngày trong năm nhuận.\n *\n * Đầu vào: \n * - $year: Một số nguyên đại diện cho năm.\n * - $month1: Một số nguyên đại diện cho tháng thứ nhất.\n * - $month2: Một số nguyên đại diện cho tháng thứ hai.\n *\n * Đầu ra: \n * - Trả về 'YES' nếu các tháng có liên quan; 'NO' nếu không.\n *\n * Ví dụ:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string "
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9924754839056363",
      "sw": "0.9989035602966874",
      "tr": "0.9920192299203993",
      "vi": "0.9894026719110266"
    },
    "canonical_solution": "{\n    // Check for leap year\n    $isLeapYear = ($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0);\n\n    // Days in each month\n    $daysInMonth = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    // Calculate the day of the year for the first day of each month\n    $dayOfYear1 = array_sum(array_slice($daysInMonth, 0, $month1 - 1));\n    $dayOfYear2 = array_sum(array_slice($daysInMonth, 0, $month2 - 1));\n\n    // Check if the difference in days is divisible by 7\n    return abs($dayOfYear1 - $dayOfYear2) % 7 == 0 ? 'YES' : 'NO';\n}",
    "instruction": {
      "en": "Write a PHP function `function areRelatedMonths($year, $month1, $month2): string` to solve the following problem:\nDetermines if two months in a given year are \"related\".\nTwo months are considered related if the first day of each month falls on the same day of the week.\nThis condition is true if the difference in days between the first day of these months is divisible by 7.\nLeap years are taken into account, as February has 29 days in a leap year.\n\nInput:\n- $year: An integer representing the year.\n- $month1: An integer representing the first month.\n- $month2: An integer representing the second month.\n\nOutput:\n- Returns 'YES' if the months are related; 'NO' otherwise.\n\nExamples:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "es": "Escribe una función PHP `function areRelatedMonths($year, $month1, $month2): string` para resolver el siguiente problema:\nDetermina si dos meses en un año dado están \"relacionados\".\nDos meses se consideran relacionados si el primer día de cada mes cae en el mismo día de la semana.\nEsta condición es verdadera si la diferencia en días entre el primer día de estos meses es divisible por 7.\nSe tienen en cuenta los años bisiestos, ya que febrero tiene 29 días en un año bisiesto.\n\nEntrada:\n- $year: Un entero que representa el año.\n- $month1: Un entero que representa el primer mes.\n- $month2: Un entero que representa el segundo mes.\n\nSalida:\n- Devuelve 'YES' si los meses están relacionados; 'NO' en caso contrario.\n\nEjemplos:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "arb": "اكتب دالة PHP `function areRelatedMonths($year, $month1, $month2): string` لحل المشكلة التالية:\nتحدد ما إذا كان الشهرين في سنة معينة \"مرتبطين\".\nيعتبر الشهرين مرتبطين إذا كان اليوم الأول من كل شهر يقع في نفس اليوم من الأسبوع.\nتكون هذه الحالة صحيحة إذا كان الفرق في الأيام بين اليوم الأول من هذه الأشهر قابلاً للقسمة على 7.\nيتم أخذ السنوات الكبيسة في الاعتبار، حيث يحتوي شهر فبراير على 29 يومًا في السنة الكبيسة.\n\nالمدخلات:\n- $year: عدد صحيح يمثل السنة.\n- $month1: عدد صحيح يمثل الشهر الأول.\n- $month2: عدد صحيح يمثل الشهر الثاني.\n\nالمخرجات:\n- يعيد 'YES' إذا كانت الأشهر مرتبطة؛ 'NO' خلاف ذلك.\n\nأمثلة:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "sw": "Andika kazi ya PHP `function areRelatedMonths($year, $month1, $month2): string` kutatua tatizo lifuatalo:\nInabainisha kama miezi miwili katika mwaka uliotolewa ni \"inayohusiana\".\nMiezi miwili inachukuliwa kuwa inahusiana ikiwa siku ya kwanza ya kila mwezi inaangukia siku hiyo hiyo ya juma.\nHali hii ni kweli ikiwa tofauti ya siku kati ya siku ya kwanza ya miezi hii inagawanyika kwa 7.\nMiaka ya kuruka inazingatiwa, kwani Februari ina siku 29 katika mwaka wa kuruka.\n\nIngizo:\n- $year: Nambari nzima inayowakilisha mwaka.\n- $month1: Nambari nzima inayowakilisha mwezi wa kwanza.\n- $month2: Nambari nzima inayowakilisha mwezi wa pili.\n\nMatokeo:\n- Inarudisha 'YES' ikiwa miezi inahusiana; 'NO' vinginevyo.\n\nMifano:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "tr": "Bir PHP fonksiyonu `function areRelatedMonths($year, $month1, $month2): string` yazın ve aşağıdaki problemi çözün:\nBelirli bir yıldaki iki ayın \"ilişkili\" olup olmadığını belirler.\nİki ay, her ayın ilk günü haftanın aynı gününe denk geliyorsa ilişkili kabul edilir.\nBu koşul, bu ayların ilk günü arasındaki gün farkı 7'ye bölünüyorsa doğrudur.\nArtık yıllar dikkate alınır, çünkü artık yıllarda Şubat ayı 29 gündür.\n\nGirdi:\n- $year: Yılı temsil eden bir tamsayı.\n- $month1: İlk ayı temsil eden bir tamsayı.\n- $month2: İkinci ayı temsil eden bir tamsayı.\n\nÇıktı:\n- Aylar ilişkiliyse 'YES' döner; aksi takdirde 'NO' döner.\n\nÖrnekler:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "vi": "Viết một hàm PHP `function areRelatedMonths($year, $month1, $month2): string` để giải quyết vấn đề sau:\nXác định xem hai tháng trong một năm nhất định có \"liên quan\" hay không.\nHai tháng được coi là liên quan nếu ngày đầu tiên của mỗi tháng rơi vào cùng một ngày trong tuần.\nĐiều kiện này đúng nếu chênh lệch số ngày giữa ngày đầu tiên của các tháng này chia hết cho 7.\nNăm nhuận được tính đến, vì tháng Hai có 29 ngày trong năm nhuận.\n\nĐầu vào:\n- $year: Một số nguyên đại diện cho năm.\n- $month1: Một số nguyên đại diện cho tháng thứ nhất.\n- $month2: Một số nguyên đại diện cho tháng thứ hai.\n\nĐầu ra:\n- Trả về 'YES' nếu các tháng có liên quan; 'NO' nếu không.\n\nVí dụ:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'"
    },
    "instruction_bertscore": {
      "es": "0.994597253635851",
      "arb": "0.9856324686486034",
      "sw": "0.9920359148724062",
      "tr": "0.9849851322368107",
      "vi": "0.9883161637267658"
    },
    "level": "middle",
    "test": "function main(){\n    assert(areRelatedMonths(1994, 10, 9) === 'NO');\n    assert(areRelatedMonths(1935, 12, 1) === 'NO');\n    assert(areRelatedMonths(1957, 1, 9) === 'NO');\n    assert(areRelatedMonths(1917, 9, 12) === 'YES');\n    assert(areRelatedMonths(1948, 1, 4) === 'YES');\n    \n}\n\nmain();\n?>",
    "entry_point": "areRelatedMonths",
    "signature": "function areRelatedMonths($year, $month1, $month2): string",
    "docstring": {
      "en": "Determines if two months in a given year are \"related\".\nTwo months are considered related if the first day of each month falls on the same day of the week.\nThis condition is true if the difference in days between the first day of these months is divisible by 7.\nLeap years are taken into account, as February has 29 days in a leap year.\n\nInput:\n- $year: An integer representing the year.\n- $month1: An integer representing the first month.\n- $month2: An integer representing the second month.\n\nOutput:\n- Returns 'YES' if the months are related; 'NO' otherwise.\n\nExamples:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "es": "Determina si dos meses en un año dado están \"relacionados\".\nDos meses se consideran relacionados si el primer día de cada mes cae en el mismo día de la semana.\nEsta condición es verdadera si la diferencia en días entre el primer día de estos meses es divisible por 7.\nSe tienen en cuenta los años bisiestos, ya que febrero tiene 29 días en un año bisiesto.\n\nEntrada:\n- $year: Un entero que representa el año.\n- $month1: Un entero que representa el primer mes.\n- $month2: Un entero que representa el segundo mes.\n\nSalida:\n- Devuelve 'YES' si los meses están relacionados; 'NO' en caso contrario.\n\nEjemplos:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "arb": "يحدد ما إذا كان الشهران في سنة معينة \"مرتبطين\". \nيعتبر الشهران مرتبطين إذا كان اليوم الأول من كل شهر يقع في نفس يوم الأسبوع.  \nتكون هذه الحالة صحيحة إذا كان الفرق في الأيام بين اليوم الأول من هذه الأشهر قابلاً للقسمة على 7.  \nيؤخذ في الاعتبار السنوات الكبيسة، حيث يحتوي شهر فبراير على 29 يومًا في السنة الكبيسة.   \nالمدخلات:  \n  - $year: عدد صحيح يمثل السنة.   \n  - $month1: عدد صحيح يمثل الشهر الأول. \n  - $month2: عدد صحيح يمثل الشهر الثاني.  \nالمخرجات:   \n  - يعيد 'YES' إذا كانت الأشهر مرتبطة؛ 'NO' خلاف ذلك.  \nأمثلة:  \n\n- areRelatedMonths(1994, 10, 9) -> 'NO'  \n- areRelatedMonths(1948, 1, 4) -> 'YES'  ",
      "sw": "Inabainisha kama miezi miwili katika mwaka uliotolewa ni \"inayohusiana\".  \nMiezi miwili inachukuliwa kuwa inayohusiana ikiwa siku ya kwanza ya kila mwezi inaangukia siku sawa ya wiki.  \nHali hii ni kweli ikiwa tofauti ya siku kati ya siku ya kwanza ya miezi hii inagawanyika kwa 7.  \nMiaka ya kuruka inazingatiwa, kwani Februari ina siku 29 katika mwaka wa kuruka.\n\nIngizo:  \n- $year: Nambari nzima inayowakilisha mwaka.  \n- $month1: Nambari nzima inayowakilisha mwezi wa kwanza.  \n- $month2: Nambari nzima inayowakilisha mwezi wa pili.  \n\nPato:  \n- Inarudisha 'YES' ikiwa miezi inahusiana; 'NO' vinginevyo.\n\nMifano:  \n- areRelatedMonths(1994, 10, 9) -> 'NO'  \n- areRelatedMonths(1948, 1, 4) -> 'YES'  ",
      "tr": "Belirtilen bir yıldaki iki ayın \"ilişkili\" olup olmadığını belirler.\nİki ay, her ayın ilk günü haftanın aynı gününe denk geliyorsa ilişkili kabul edilir.\nBu koşul, bu ayların ilk günü arasındaki gün farkı 7'ye bölünebiliyorsa doğrudur.\nArtık yıllar dikkate alınır, çünkü artık yılda Şubat ayı 29 gündür.\n\nGirdi:\n- $year: Yılı temsil eden bir tamsayı.\n- $month1: İlk ayı temsil eden bir tamsayı.\n- $month2: İkinci ayı temsil eden bir tamsayı.\n\nÇıktı:\n- Aylar ilişkiliyse 'YES' döner; aksi takdirde 'NO' döner.\n\nÖrnekler:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "vi": "Xác định xem hai tháng trong một năm nhất định có \"liên quan\" hay không.  \nHai tháng được coi là liên quan nếu ngày đầu tiên của mỗi tháng rơi vào cùng một ngày trong tuần.  \nĐiều kiện này đúng nếu chênh lệch số ngày giữa ngày đầu tiên của các tháng này chia hết cho 7.  \nNăm nhuận được tính đến, vì tháng Hai có 29 ngày trong năm nhuận.  \n\nĐầu vào:  \n- $year: Một số nguyên đại diện cho năm.  \n- $month1: Một số nguyên đại diện cho tháng thứ nhất.  \n- $month2: Một số nguyên đại diện cho tháng thứ hai.  \n\nĐầu ra:  \n- Trả về 'YES' nếu các tháng có liên quan; 'NO' nếu không.  \n\nVí dụ:  \n- areRelatedMonths(1994, 10, 9) -> 'NO'  \n- areRelatedMonths(1948, 1, 4) -> 'YES'  "
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.9985642996058798",
      "tr": "0.9871641075167634",
      "vi": "0.9801027974709732"
    }
  },
  {
    "task_id": "PHP/22",
    "prompt": {
      "en": "<?php\n/**\n    * Converts a number from one base to another.\n    * The function accepts three parameters: the number to convert, the base it's currently in, and the base to convert it to.\n    * The bases can range from 2 to 36.\n    * The number is assumed to be a string to accommodate larger bases and values.\n    * Characters in the number may include 0-9 and A-Z, representing values 0 through 35.\n    * Input: A string representing the number, an integer for the current base, and an integer for the target base.\n    * Output: The number converted to the target base as a string.\n    * Example: convertBase(\"123AB\", 16, 10) returns \"74667\".\n*/\n\nfunction convertBase($number, $fromBase, $toBase) ",
      "es": "<?php\n/**\n    * Convierte un número de una base a otra.\n    * La función acepta tres parámetros: el número a convertir, la base en la que está actualmente y la base a la que se va a convertir.\n    * Las bases pueden variar de 2 a 36.\n    * Se asume que el número es una cadena para acomodar bases y valores más grandes.\n    * Los caracteres en el número pueden incluir 0-9 y A-Z, representando valores de 0 a 35.\n    * Entrada: Una cadena que representa el número, un entero para la base actual y un entero para la base objetivo.\n    * Salida: El número convertido a la base objetivo como una cadena.\n    * Ejemplo: convertBase(\"123AB\", 16, 10) devuelve \"74667\".\n*/\n\nfunction convertBase($number, $fromBase, $toBase) ",
      "arb": "<?php\n/**\n    * يحول رقمًا من قاعدة إلى أخرى.\n    * تقبل الدالة ثلاثة معلمات: الرقم المراد تحويله، القاعدة التي هو فيها حاليًا، والقاعدة المراد تحويله إليها.\n    * يمكن أن تتراوح القواعد من 2 إلى 36.\n    * يُفترض أن الرقم هو سلسلة نصية لاستيعاب القواعد والقيم الأكبر.\n    * قد تتضمن الأحرف في الرقم 0-9 و A-Z، ممثلة القيم من 0 إلى 35.\n    * المدخلات: سلسلة نصية تمثل الرقم، عدد صحيح للقاعدة الحالية، وعدد صحيح للقاعدة المستهدفة.\n    * المخرجات: الرقم المحول إلى القاعدة المستهدفة كسلسلة نصية.\n    * مثال: convertBase(\"123AB\", 16, 10) يعيد \"74667\".\n*/\n\nfunction convertBase($number, $fromBase, $toBase) ",
      "sw": "<?php\n/**\n    * Inabadilisha nambari kutoka msingi mmoja hadi mwingine.\n    * Kazi inakubali vigezo vitatu: nambari ya kubadilisha, msingi ambao iko kwa sasa, na msingi wa kubadilisha.\n    * Misingi inaweza kuwa kati ya 2 hadi 36.\n    * Nambari inadhaniwa kuwa ni kamba ili kuendana na misingi na thamani kubwa zaidi.\n    * Herufi katika nambari zinaweza kujumuisha 0-9 na A-Z, zikionyesha thamani 0 hadi 35.\n    * Ingizo: Kamba inayowakilisha nambari, nambari kamili kwa msingi wa sasa, na nambari kamili kwa msingi lengwa.\n    * Tokeo: Nambari iliyobadilishwa hadi msingi lengwa kama kamba.\n    * Mfano: convertBase(\"123AB\", 16, 10) inarudisha \"74667\".\n*/\n\nfunction convertBase($number, $fromBase, $toBase) ",
      "tr": "<?php\n/**\n    * Bir sayıyı bir tabandan diğerine dönüştürür.\n    * Fonksiyon üç parametre kabul eder: dönüştürülecek sayı, şu anki tabanı ve dönüştürülecek taban.\n    * Tabanlar 2 ile 36 arasında olabilir.\n    * Sayının daha büyük tabanlar ve değerler için bir dize olduğu varsayılır.\n    * Sayıdaki karakterler 0-9 ve A-Z'yi içerebilir, 0'dan 35'e kadar değerleri temsil eder.\n    * Girdi: Sayıyı temsil eden bir dize, mevcut taban için bir tamsayı ve hedef taban için bir tamsayı.\n    * Çıktı: Hedef tabana dönüştürülmüş sayı bir dize olarak.\n    * Örnek: convertBase(\"123AB\", 16, 10) \"74667\" döndürür.\n*/\n\nfunction convertBase($number, $fromBase, $toBase) ",
      "vi": "<?php\n/**\n    * Chuyển đổi một số từ một cơ số này sang cơ số khác.\n    * Hàm chấp nhận ba tham số: số cần chuyển đổi, cơ số hiện tại của nó, và cơ số cần chuyển đổi sang.\n    * Các cơ số có thể nằm trong khoảng từ 2 đến 36.\n    * Số được giả định là một chuỗi để phù hợp với các cơ số và giá trị lớn hơn.\n    * Các ký tự trong số có thể bao gồm 0-9 và A-Z, đại diện cho các giá trị từ 0 đến 35.\n    * Đầu vào: Một chuỗi đại diện cho số, một số nguyên cho cơ số hiện tại, và một số nguyên cho cơ số đích.\n    * Đầu ra: Số được chuyển đổi sang cơ số đích dưới dạng chuỗi.\n    * Ví dụ: convertBase(\"123AB\", 16, 10) trả về \"74667\".\n*/\n\nfunction convertBase($number, $fromBase, $toBase) "
    },
    "prompt_bertscore": {
      "es": "0.9758912375018904",
      "arb": "0.9749864761162765",
      "sw": "0.9883074239900003",
      "tr": "0.9661011432814429",
      "vi": "0.9714891909973953"
    },
    "canonical_solution": "{\n    // Check if the bases are within the valid range\n    if ($fromBase < 2 || $fromBase > 36 || $toBase < 2 || $toBase > 36) {\n        return \"Invalid base. Bases must be between 2 and 36.\";\n    }\n\n    // Convert the number from the original base to base 10\n    $decValue = base_convert($number, $fromBase, 10);\n\n    // Convert the base 10 number to the target base\n\n    return strtoupper(base_convert($decValue, 10, $toBase));\n}",
    "instruction": {
      "en": "Write a PHP function `function convertBase($number, $fromBase, $toBase)` to solve the following problem:\nConverts a number from one base to another.\nThe function accepts three parameters: the number to convert, the base it's currently in, and the base to convert it to.\nThe bases can range from 2 to 36.\nThe number is assumed to be a string to accommodate larger bases and values.\nCharacters in the number may include 0-9 and A-Z, representing values 0 through 35.\nInput: A string representing the number, an integer for the current base, and an integer for the target base.\nOutput: The number converted to the target base as a string.\nExample: convertBase(\"123AB\", 16, 10) returns \"74667\".",
      "es": "Escribe una función PHP `function convertBase($number, $fromBase, $toBase)` para resolver el siguiente problema:\nConvierte un número de una base a otra.\nLa función acepta tres parámetros: el número a convertir, la base en la que se encuentra actualmente y la base a la que se va a convertir.\nLas bases pueden variar de 2 a 36.\nSe asume que el número es una cadena para acomodar bases y valores más grandes.\nLos caracteres en el número pueden incluir 0-9 y A-Z, representando valores del 0 al 35.\nEntrada: Una cadena que representa el número, un entero para la base actual y un entero para la base objetivo.\nSalida: El número convertido a la base objetivo como una cadena.\nEjemplo: convertBase(\"123AB\", 16, 10) devuelve \"74667\".",
      "arb": "اكتب دالة PHP `function convertBase($number, $fromBase, $toBase)` لحل المشكلة التالية:\nتحويل رقم من قاعدة إلى أخرى.\nتقبل الدالة ثلاثة معلمات: الرقم المراد تحويله، القاعدة التي هو فيها حاليًا، والقاعدة المراد التحويل إليها.\nيمكن أن تتراوح القواعد من 2 إلى 36.\nيفترض أن الرقم هو سلسلة نصية لاستيعاب القواعد والقيم الأكبر.\nقد تتضمن الأحرف في الرقم 0-9 و A-Z، مما يمثل القيم من 0 إلى 35.\nالمدخل: سلسلة نصية تمثل الرقم، عدد صحيح للقاعدة الحالية، وعدد صحيح للقاعدة المستهدفة.\nالمخرج: الرقم المحول إلى القاعدة المستهدفة كسلسلة نصية.\nمثال: convertBase(\"123AB\", 16, 10) يعيد \"74667\".",
      "sw": "Andika kazi ya PHP `function convertBase($number, $fromBase, $toBase)` kutatua tatizo lifuatalo:\nInabadilisha nambari kutoka msingi mmoja hadi mwingine.\nKazi inakubali vigezo vitatu: nambari ya kubadilisha, msingi ambao iko sasa, na msingi wa kubadilisha.\nMisingi inaweza kuwa kati ya 2 hadi 36.\nNambari inadhaniwa kuwa ni kamba ili kuweza kushughulikia misingi na thamani kubwa zaidi.\nHerufi katika nambari zinaweza kujumuisha 0-9 na A-Z, zikionyesha thamani 0 hadi 35.\nIngizo: Kamba inayowakilisha nambari, nambari kamili kwa msingi wa sasa, na nambari kamili kwa msingi lengwa.\nPato: Nambari iliyobadilishwa hadi msingi lengwa kama kamba.\nMfano: convertBase(\"123AB\", 16, 10) inarudisha \"74667\".",
      "tr": "Bir PHP fonksiyonu `function convertBase($number, $fromBase, $toBase)` yazın:\nBir sayıyı bir tabandan diğerine dönüştürür.\nFonksiyon üç parametre alır: dönüştürülecek sayı, şu an bulunduğu taban ve dönüştürüleceği taban.\nTabanlar 2 ile 36 arasında olabilir.\nSayı, daha büyük tabanlar ve değerler için bir dize olarak kabul edilir.\nSayıdaki karakterler, 0'dan 9'a ve A'dan Z'ye kadar olan değerleri temsil edebilir, 0'dan 35'e kadar.\nGirdi: Sayıyı temsil eden bir dize, mevcut taban için bir tamsayı ve hedef taban için bir tamsayı.\nÇıktı: Hedef tabana dönüştürülmüş sayıyı bir dize olarak verir.\nÖrnek: convertBase(\"123AB\", 16, 10) \"74667\" döndürür.",
      "vi": "Viết một hàm PHP `function convertBase($number, $fromBase, $toBase)` để giải quyết vấn đề sau:\nChuyển đổi một số từ một cơ số này sang cơ số khác.\nHàm chấp nhận ba tham số: số cần chuyển đổi, cơ số hiện tại của nó, và cơ số cần chuyển đổi sang.\nCác cơ số có thể nằm trong khoảng từ 2 đến 36.\nSố được giả định là một chuỗi để phù hợp với các cơ số và giá trị lớn hơn.\nCác ký tự trong số có thể bao gồm 0-9 và A-Z, đại diện cho các giá trị từ 0 đến 35.\nĐầu vào: Một chuỗi đại diện cho số, một số nguyên cho cơ số hiện tại, và một số nguyên cho cơ số mục tiêu.\nĐầu ra: Số đã được chuyển đổi sang cơ số mục tiêu dưới dạng chuỗi.\nVí dụ: convertBase(\"123AB\", 16, 10) trả về \"74667\"."
    },
    "instruction_bertscore": {
      "es": "0.9750786406130767",
      "arb": "0.9824635195495728",
      "sw": "0.9832401643394192",
      "tr": "0.9372842448616634",
      "vi": "0.9762229502382187"
    },
    "level": "easy",
    "test": "function main(){\n    assert(convertBase('2345678A123', 18, 18) === '2345678A123');\n    assert(convertBase('23456', 15, 18) === '114E0');\n    assert(convertBase('2345678', 12, 20) === '22B7A4');\n    assert(convertBase('12345678', 16, 23) === '21A976L');\n    assert(convertBase('3456AB', 25, 21) === '7C2136');\n    assert(convertBase('AB1234567', 18, 22) === '22JF0G367');\n    \n}\n\nmain();\n?>",
    "entry_point": "convertBase",
    "signature": "function convertBase($number, $fromBase, $toBase)",
    "docstring": {
      "en": "Converts a number from one base to another.\nThe function accepts three parameters: the number to convert, the base it's currently in, and the base to convert it to.\nThe bases can range from 2 to 36.\nThe number is assumed to be a string to accommodate larger bases and values.\nCharacters in the number may include 0-9 and A-Z, representing values 0 through 35.\nInput: A string representing the number, an integer for the current base, and an integer for the target base.\nOutput: The number converted to the target base as a string.\nExample: convertBase(\"123AB\", 16, 10) returns \"74667\".",
      "es": "Convierte un número de una base a otra.  \nLa función acepta tres parámetros: el número a convertir, la base en la que está actualmente y la base a la que se desea convertir.  \nLas bases pueden variar de 2 a 36.  \nSe asume que el número es una cadena para acomodar bases y valores más grandes.  \nLos caracteres en el número pueden incluir 0-9 y A-Z, representando valores del 0 al 35.  \nEntrada: Una cadena que representa el número, un entero para la base actual y un entero para la base objetivo.  \nSalida: El número convertido a la base objetivo como una cadena.  \nEjemplo: convertBase(\"123AB\", 16, 10) devuelve \"74667\".",
      "arb": "تحويل رقم من قاعدة إلى أخرى.\nتقبل الدالة ثلاثة معلمات: الرقم المراد تحويله، القاعدة التي هو فيها حاليًا، والقاعدة التي سيتم تحويله إليها.\nيمكن أن تتراوح القواعد من 2 إلى 36.\nمن المفترض أن يكون الرقم سلسلة نصية لاستيعاب القواعد والقيم الأكبر.\nقد تتضمن الأحرف في الرقم 0-9 و A-Z، مما يمثل القيم من 0 إلى 35.\nالمدخلات: سلسلة نصية تمثل الرقم، عدد صحيح للقاعدة الحالية، وعدد صحيح للقاعدة المستهدفة.\nالمخرجات: الرقم المحول إلى القاعدة المستهدفة كسلسلة نصية.\nمثال: convertBase(\"123AB\", 16, 10) يعيد \"74667\".",
      "sw": "Inabadilisha nambari kutoka msingi mmoja hadi mwingine.\nKazi hii inakubali vigezo vitatu: nambari ya kubadilisha, msingi ambao iko sasa, na msingi wa kuibadilisha.\nMisingi inaweza kuwa kati ya 2 hadi 36.\nNambari inachukuliwa kuwa kamba ili kukidhi misingi na thamani kubwa.\nHerufi katika nambari zinaweza kujumuisha 0-9 na A-Z, zikionyesha thamani 0 hadi 35.\nIngizo: Kamba inayowakilisha nambari, nambari kamili kwa msingi wa sasa, na nambari kamili kwa msingi lengwa.\nPato: Nambari iliyobadilishwa hadi msingi lengwa kama kamba.\nMfano: convertBase(\"123AB\", 16, 10) inarejesha \"74667\".",
      "tr": "Bir sayıyı bir tabandan başka bir tabana dönüştürür.\nFonksiyon üç parametre kabul eder: dönüştürülecek sayı, şu anki tabanı ve dönüştürüleceği taban.\nTabanlar 2 ile 36 arasında olabilir.\nSayı, daha büyük tabanlar ve değerler için bir dize olarak kabul edilir.\nSayıdaki karakterler 0-9 ve A-Z'yi içerebilir, bu da 0 ile 35 arasındaki değerleri temsil eder.\nGirdi: Sayıyı temsil eden bir dize, mevcut taban için bir tamsayı ve hedef taban için bir tamsayı.\nÇıktı: Hedef tabana dönüştürülmüş sayı bir dize olarak.\nÖrnek: convertBase(\"123AB\", 16, 10) \"74667\" döndürür.",
      "vi": "Chuyển đổi một số từ một cơ số này sang cơ số khác.  \nHàm chấp nhận ba tham số: số cần chuyển đổi, cơ số hiện tại của nó, và cơ số cần chuyển đổi sang.  \nCác cơ số có thể nằm trong khoảng từ 2 đến 36.  \nSố được giả định là một chuỗi để phù hợp với các cơ số và giá trị lớn hơn.  \nCác ký tự trong số có thể bao gồm 0-9 và A-Z, đại diện cho các giá trị từ 0 đến 35.  \nĐầu vào: Một chuỗi đại diện cho số, một số nguyên cho cơ số hiện tại, và một số nguyên cho cơ số đích.  \nĐầu ra: Số được chuyển đổi sang cơ số đích dưới dạng một chuỗi.  \nVí dụ: convertBase(\"123AB\", 16, 10) trả về \"74667\".  "
    },
    "docstring_bertscore": {
      "es": "0.9710194301462477",
      "arb": "0.9617481584810633",
      "sw": "0.9760634500422477",
      "tr": "0.9531585862835906",
      "vi": "0.9689616193987263"
    }
  },
  {
    "task_id": "PHP/23",
    "prompt": {
      "en": "<?php\n\n/**\n * Performs division of two large numbers provided as strings.\n * This function handles division of large numbers that may exceed the integer\n * or float limit in PHP. It only returns the integer part of the quotient.\n * \n * Inputs:\n * - $dividend: String representing the dividend (the number to be divided).\n * - $divisor: String representing the divisor (the number by which we divide).\n * \n * Output:\n * - Returns a string representing the integer part of the quotient.\n * \n * Example Cases:\n * - largeNumberDivision(\"2376\", \"24\") returns \"99\"\n * - largeNumberDivision(\"1000\", \"10\") returns \"100\"\n */\n\n function largeNumberDivision($dividend, $divisor) ",
      "es": "<?php\n\n/**\n * Realiza la división de dos números grandes proporcionados como cadenas.\n * Esta función maneja la división de números grandes que pueden exceder el límite\n * de enteros o flotantes en PHP. Solo devuelve la parte entera del cociente.\n * \n * Entradas:\n * - $dividend: Cadena que representa el dividendo (el número a dividir).\n * - $divisor: Cadena que representa el divisor (el número por el cual dividimos).\n * \n * Salida:\n * - Devuelve una cadena que representa la parte entera del cociente.\n * \n * Casos de Ejemplo:\n * - largeNumberDivision(\"2376\", \"24\") devuelve \"99\"\n * - largeNumberDivision(\"1000\", \"10\") devuelve \"100\"\n */\n\n function largeNumberDivision($dividend, $divisor) ",
      "arb": "<?php\n\n/**\n * ينفذ قسمة بين رقمين كبيرين مقدمة كسلاسل.\n * هذه الدالة تتعامل مع قسمة الأرقام الكبيرة التي قد تتجاوز حد الأعداد الصحيحة\n * أو العائمة في PHP. تعيد فقط الجزء الصحيح من خارج القسمة.\n * \n * المدخلات:\n * - $dividend: سلسلة تمثل المقسوم (الرقم الذي سيتم قسمته).\n * - $divisor: سلسلة تمثل القاسم (الرقم الذي نقسم عليه).\n * \n * المخرجات:\n * - تعيد سلسلة تمثل الجزء الصحيح من خارج القسمة.\n * \n * أمثلة الحالات:\n * - largeNumberDivision(\"2376\", \"24\") تعيد \"99\"\n * - largeNumberDivision(\"1000\", \"10\") تعيد \"100\"\n */\n\n function largeNumberDivision($dividend, $divisor) ",
      "sw": "<?php\n\n/**\n * Hufanya mgawanyiko wa namba kubwa mbili zinazotolewa kama kamba.\n * Kazi hii inashughulikia mgawanyiko wa namba kubwa ambazo zinaweza kuzidi\n * kikomo cha integer au float katika PHP. Inarudisha tu sehemu ya nambari kamili ya sehemu ya mgawo.\n * \n * Ingizo:\n * - $dividend: Kamba inayowakilisha dividend (namba inayogawanywa).\n * - $divisor: Kamba inayowakilisha divisor (namba ambayo tunagawanya nayo).\n * \n * Matokeo:\n * - Inarudisha kamba inayowakilisha sehemu ya nambari kamili ya mgawo.\n * \n * Mifano ya Kesi:\n * - largeNumberDivision(\"2376\", \"24\") inarudisha \"99\"\n * - largeNumberDivision(\"1000\", \"10\") inarudisha \"100\"\n */\n\n function largeNumberDivision($dividend, $divisor) ",
      "tr": "<?php\n\n/**\n * İki büyük sayının bölünmesini gerçekleştirir.\n * Bu fonksiyon, PHP'de tamsayı veya float sınırını aşabilecek büyük sayıların\n * bölünmesini ele alır. Sadece bölümün tamsayı kısmını döndürür.\n * \n * Girdiler:\n * - $dividend: Bölüneni temsil eden string (bölünecek sayı).\n * - $divisor: Böleni temsil eden string (bölen sayı).\n * \n * Çıktı:\n * - Bölümün tamsayı kısmını temsil eden bir string döndürür.\n * \n * Örnek Durumlar:\n * - largeNumberDivision(\"2376\", \"24\") \"99\" döndürür\n * - largeNumberDivision(\"1000\", \"10\") \"100\" döndürür\n */\n\n function largeNumberDivision($dividend, $divisor) ",
      "vi": "<?php\n\n/**\n * Thực hiện phép chia hai số lớn được cung cấp dưới dạng chuỗi.\n * Hàm này xử lý phép chia các số lớn có thể vượt quá giới hạn số nguyên\n * hoặc số thực trong PHP. Nó chỉ trả về phần nguyên của thương.\n * \n * Đầu vào:\n * - $dividend: Chuỗi đại diện cho số bị chia (số cần chia).\n * - $divisor: Chuỗi đại diện cho số chia (số mà chúng ta chia).\n * \n * Đầu ra:\n * - Trả về một chuỗi đại diện cho phần nguyên của thương.\n * \n * Ví dụ:\n * - largeNumberDivision(\"2376\", \"24\") trả về \"99\"\n * - largeNumberDivision(\"1000\", \"10\") trả về \"100\"\n */\n\n function largeNumberDivision($dividend, $divisor) "
    },
    "prompt_bertscore": {
      "es": "0.9806949146368382",
      "arb": "0.9726470074884476",
      "sw": "0.9829185817525238",
      "tr": "0.9805638185853551",
      "vi": "0.9686173929483929"
    },
    "canonical_solution": " {\n    // Handle division by zero\n    if ($divisor === \"0\") {\n        throw new Exception(\"Division by zero.\");\n    }\n\n    // Initialize variables\n    $quotient = \"\";\n    $remainder = \"\";\n\n    // Loop through each digit of the dividend\n    for ($i = 0; $i < strlen($dividend); $i++) {\n        $remainder .= $dividend[$i];\n        $partialQuotient = 0;\n\n        // Find the maximum quotient for this partial dividend\n        while ((int)$remainder >= (int)$divisor) {\n            $remainder = (string)((int)$remainder - (int)$divisor);\n            $partialQuotient++;\n        }\n\n        $quotient .= (string)$partialQuotient;\n    }\n\n    // Remove leading zeros and return the quotient\n    return ltrim($quotient, \"0\") ?: \"0\";\n}",
    "instruction": {
      "en": "Write a PHP function `function largeNumberDivision($dividend, $divisor)` to solve the following problem:\nPerforms division of two large numbers provided as strings.\nThis function handles division of large numbers that may exceed the integer\nor float limit in PHP. It only returns the integer part of the quotient.\n\nInputs:\n- $dividend: String representing the dividend (the number to be divided).\n- $divisor: String representing the divisor (the number by which we divide).\n\nOutput:\n- Returns a string representing the integer part of the quotient.\n\nExample Cases:\n- largeNumberDivision(\"2376\", \"24\") returns \"99\"\n- largeNumberDivision(\"1000\", \"10\") returns \"100\"",
      "es": "Escribe una función PHP `function largeNumberDivision($dividend, $divisor)` para resolver el siguiente problema:\nRealiza la división de dos números grandes proporcionados como cadenas.\nEsta función maneja la división de números grandes que pueden exceder el límite de enteros\no flotantes en PHP. Solo devuelve la parte entera del cociente.\n\nEntradas:\n- $dividend: Cadena que representa el dividendo (el número a dividir).\n- $divisor: Cadena que representa el divisor (el número por el cual dividimos).\n\nSalida:\n- Devuelve una cadena que representa la parte entera del cociente.\n\nCasos de Ejemplo:\n- largeNumberDivision(\"2376\", \"24\") devuelve \"99\"\n- largeNumberDivision(\"1000\", \"10\") devuelve \"100\"",
      "arb": "اكتب دالة PHP `function largeNumberDivision($dividend, $divisor)` لحل المشكلة التالية:\nتنفذ قسمة لرقمين كبيرين مقدمان كسلاسل نصية.\nتتعامل هذه الدالة مع قسمة الأرقام الكبيرة التي قد تتجاوز حد الأعداد الصحيحة\nأو الأعداد العشرية في PHP. تعيد فقط الجزء الصحيح من خارج القسمة.\n\nالمدخلات:\n- $dividend: سلسلة نصية تمثل المقسوم (العدد الذي سيتم قسمته).\n- $divisor: سلسلة نصية تمثل القاسم (العدد الذي نقسم عليه).\n\nالمخرجات:\n- تعيد سلسلة نصية تمثل الجزء الصحيح من خارج القسمة.\n\nحالات المثال:\n- largeNumberDivision(\"2376\", \"24\") تعيد \"99\"\n- largeNumberDivision(\"1000\", \"10\") تعيد \"100\"",
      "sw": "Andika kazi ya PHP `function largeNumberDivision($dividend, $divisor)` kutatua tatizo lifuatalo:\nInafanya mgawanyo wa namba kubwa mbili zinazotolewa kama mistari.\nKazi hii inashughulikia mgawanyo wa namba kubwa ambazo zinaweza kuzidi kikomo cha integer au float katika PHP. Inarudisha tu sehemu ya integer ya quotient.\n\nIngizo:\n- $dividend: Mstari unaowakilisha dividend (namba inayogawanywa).\n- $divisor: Mstari unaowakilisha divisor (namba tunayotumia kugawanya).\n\nPato:\n- Inarudisha mstari unaowakilisha sehemu ya integer ya quotient.\n\nMifano ya Matukio:\n- largeNumberDivision(\"2376\", \"24\") inarudisha \"99\"\n- largeNumberDivision(\"1000\", \"10\") inarudisha \"100\"",
      "tr": "Bir PHP fonksiyonu `function largeNumberDivision($dividend, $divisor)` yazın. Aşağıdaki problemi çözmek için:\nİki büyük sayının bölünmesini gerçekleştirir, bu sayılar string olarak sağlanır.\nBu fonksiyon, PHP'de tamsayı veya float limitini aşabilecek büyük sayıların bölünmesini işler. Yalnızca bölümün tamsayı kısmını döndürür.\n\nGirdiler:\n- $dividend: Bölüneni temsil eden string (bölünecek sayı).\n- $divisor: Böleni temsil eden string (bölen sayı).\n\nÇıktı:\n- Bölümün tamsayı kısmını temsil eden bir string döndürür.\n\nÖrnek Durumlar:\n- largeNumberDivision(\"2376\", \"24\") \"99\" döndürür\n- largeNumberDivision(\"1000\", \"10\") \"100\" döndürür",
      "vi": "Viết một hàm PHP `function largeNumberDivision($dividend, $divisor)` để giải quyết vấn đề sau:\nThực hiện phép chia hai số lớn được cung cấp dưới dạng chuỗi.\nHàm này xử lý phép chia các số lớn có thể vượt quá giới hạn số nguyên\nhoặc số thực trong PHP. Nó chỉ trả về phần nguyên của thương số.\n\nĐầu vào:\n- $dividend: Chuỗi đại diện cho số bị chia (số cần chia).\n- $divisor: Chuỗi đại diện cho số chia (số mà chúng ta chia).\n\nĐầu ra:\n- Trả về một chuỗi đại diện cho phần nguyên của thương số.\n\nCác trường hợp ví dụ:\n- largeNumberDivision(\"2376\", \"24\") trả về \"99\"\n- largeNumberDivision(\"1000\", \"10\") trả về \"100\""
    },
    "instruction_bertscore": {
      "es": "0.9839824460733466",
      "arb": "0.9670605280218414",
      "sw": "0.9805246884002913",
      "tr": "0.9710563753971202",
      "vi": "0.9815694842045348"
    },
    "level": "middle",
    "test": "function main(){\n    assert(largeNumberDivision(\"2376\", \"24\") === \"99\");\n    assert(largeNumberDivision(\"1000\", \"10\") === \"100\");\n    assert(largeNumberDivision(\"5000\", \"25\") === \"200\");\n    assert(largeNumberDivision(\"123456789\", \"12345\") === \"10000\");\n    assert(largeNumberDivision(\"102030\", \"5101\") === \"20\");\n    assert(largeNumberDivision(\"1020300000000000000000000000000000000000000000000\", \"10\") === \"102030000000000000000000000000000000000000000000\");\n    \n}\n\n\nmain();\n?>",
    "entry_point": "largeNumberDivision",
    "signature": "function largeNumberDivision($dividend, $divisor)",
    "docstring": {
      "en": "Performs division of two large numbers provided as strings.\nThis function handles division of large numbers that may exceed the integer\nor float limit in PHP. It only returns the integer part of the quotient.\n\nInputs:\n- $dividend: String representing the dividend (the number to be divided).\n- $divisor: String representing the divisor (the number by which we divide).\n\nOutput:\n- Returns a string representing the integer part of the quotient.\n\nExample Cases:\n- largeNumberDivision(\"2376\", \"24\") returns \"99\"\n- largeNumberDivision(\"1000\", \"10\") returns \"100\"",
      "es": "Realiza la división de dos números grandes proporcionados como cadenas.\nEsta función maneja la división de números grandes que pueden exceder el límite de enteros\no flotantes en PHP. Solo devuelve la parte entera del cociente.\n\nEntradas:\n- $dividend: Cadena que representa el dividendo (el número a dividir).\n- $divisor: Cadena que representa el divisor (el número por el cual dividimos).\n\nSalida:\n- Devuelve una cadena que representa la parte entera del cociente.\n\nCasos de Ejemplo:\n- largeNumberDivision(\"2376\", \"24\") devuelve \"99\"\n- largeNumberDivision(\"1000\", \"10\") devuelve \"100\"",
      "arb": "يقوم بإجراء قسمة لعددين كبيرين يتم تقديمهما كسلاسل نصية.\nتتعامل هذه الدالة مع قسمة الأعداد الكبيرة التي قد تتجاوز حد الأعداد الصحيحة\nأو العائمة في PHP. تعيد فقط الجزء الصحيح من خارج القسمة.\n\nالمدخلات:\n- $dividend: سلسلة نصية تمثل المقسوم (العدد الذي سيتم قسمته).\n- $divisor: سلسلة نصية تمثل المقسوم عليه (العدد الذي نقسم عليه).\n\nالمخرجات:\n- تعيد سلسلة نصية تمثل الجزء الصحيح من خارج القسمة.\n\nحالات المثال:\n- largeNumberDivision(\"2376\", \"24\") تعيد \"99\"\n- largeNumberDivision(\"1000\", \"10\") تعيد \"100\"",
      "sw": "Inafanya mgawanyo wa namba kubwa mbili zilizotolewa kama kamba.\nKazi hii inashughulikia mgawanyo wa namba kubwa ambazo zinaweza kuzidi kikomo cha integer au float katika PHP. Inarudisha tu sehemu ya integer ya mgawo.\n\nIngizo:\n- $dividend: Kamba inayowakilisha dividend (namba inayogawanywa).\n- $divisor: Kamba inayowakilisha divisor (namba tunayotumia kugawanya).\n\nMatokeo:\n- Inarudisha kamba inayowakilisha sehemu ya integer ya mgawo.\n\nMifano ya Kesi:\n- largeNumberDivision(\"2376\", \"24\") inarudisha \"99\"\n- largeNumberDivision(\"1000\", \"10\") inarudisha \"100\"",
      "tr": "İki büyük sayının bölünmesini gerçekleştirir, bu sayılar string olarak sağlanır.\nBu fonksiyon, PHP'de tamsayı veya float sınırını aşabilecek büyük sayıların bölünmesini ele alır. Yalnızca bölümün tamsayı kısmını döndürür.\n\nGirdiler:\n- $dividend: Bölen (bölünecek sayı) olarak string.\n- $divisor: Bölen (bölen sayı) olarak string.\n\nÇıktı:\n- Bölümün tamsayı kısmını temsil eden bir string döndürür.\n\nÖrnek Durumlar:\n- largeNumberDivision(\"2376\", \"24\") \"99\" döndürür\n- largeNumberDivision(\"1000\", \"10\") \"100\" döndürür",
      "vi": "Thực hiện phép chia của hai số lớn được cung cấp dưới dạng chuỗi.\nHàm này xử lý phép chia của các số lớn có thể vượt quá giới hạn số nguyên\nhoặc số thực trong PHP. Nó chỉ trả về phần nguyên của thương số.\n\nĐầu vào:\n- $dividend: Chuỗi đại diện cho số bị chia (số cần chia).\n- $divisor: Chuỗi đại diện cho số chia (số mà chúng ta chia).\n\nĐầu ra:\n- Trả về một chuỗi đại diện cho phần nguyên của thương số.\n\nCác trường hợp ví dụ:\n- largeNumberDivision(\"2376\", \"24\") trả về \"99\"\n- largeNumberDivision(\"1000\", \"10\") trả về \"100\""
    },
    "docstring_bertscore": {
      "es": "0.9806901475076933",
      "arb": "0.9733028850066249",
      "sw": "0.9741226325891558",
      "tr": "0.947519072505248",
      "vi": "0.9778407946917479"
    }
  },
  {
    "task_id": "PHP/24",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Calculates the largest integer x such that ax <= b < ax+1 or x <= logab < x + 1.\n * This function helps in understanding the relationship between two numbers in terms of logarithms and exponents.\n * - The function takes two positive integers 'a' and 'b' as inputs.\n * - It finds the largest integer 'x' that satisfies the conditions mentioned above.\n * \n * Args:\n *      $a (int): The base number, must be greater than 1.\n *      $b (int): The comparison number.\n * \n * Returns:\n *      int: The largest integer x satisfying the conditions.\n * \n * Examples:\n *      - If a = 10000 and b = 1000000000001, then the output should be 3.\n *      - If a = 3 and b = 27, then the output should be 3.\n */\n\nfunction calculateLogLimit($a, $b) ",
      "es": "<?php\n\n\n/**\n * Calcula el mayor entero x tal que ax <= b < ax+1 o x <= logab < x + 1.\n * Esta función ayuda a entender la relación entre dos números en términos de logaritmos y exponentes.\n * - La función toma dos enteros positivos 'a' y 'b' como entradas.\n * - Encuentra el mayor entero 'x' que satisface las condiciones mencionadas anteriormente.\n * \n * Argumentos:\n *      $a (int): El número base, debe ser mayor que 1.\n *      $b (int): El número de comparación.\n * \n * Devuelve:\n *      int: El mayor entero x que satisface las condiciones.\n * \n * Examples:\n *      - Si a = 10000 y b = 1000000000001, entonces la salida debería ser 3.\n *      - Si a = 3 y b = 27, entonces la salida debería ser 3.\n */\n\nfunction calculateLogLimit($a, $b) ",
      "arb": "<?php\n\n\n/**\n * يحسب أكبر عدد صحيح x بحيث ax <= b < ax+1 أو x <= logab < x + 1.\n * تساعد هذه الدالة في فهم العلاقة بين رقمين من حيث اللوغاريتمات والأسس.\n * - تأخذ الدالة عددين صحيحين موجبين 'a' و 'b' كمدخلات.\n * - تجد أكبر عدد صحيح 'x' الذي يحقق الشروط المذكورة أعلاه.\n * \n * يعيدالحجج:\n *      $a (int): الرقم الأساسي، يجب أن يكون أكبر من 1.\n *      $b (int): الرقم المقارن.\n * \n * يعيد:\n *      int: أكبر عدد صحيح x يحقق الشروط.\n * \n * أمثلة:\n *      - إذا كان a = 10000 و b = 1000000000001، فيجب أن يكون الناتج 3.\n *      - إذا كان a = 3 و b = 27، فيجب أن يكون الناتج 3.\n */\n\nfunction calculateLogLimit($a, $b) ",
      "sw": "<?php\n\n\n/**\n * Inahesabu nambari kubwa zaidi x ambapo ax <= b < ax+1 au x <= logab < x + 1.\n * Kazi hii husaidia katika kuelewa uhusiano kati ya nambari mbili kwa mujibu wa logaritimu na eksponenti.\n * - Kazi inachukua nambari mbili chanya 'a' na 'b' kama pembejeo.\n * - Inapata nambari kubwa zaidi 'x' inayokidhi masharti yaliyotajwa hapo juu.\n * \n * Hoja:\n *      $a (int): Nambari ya msingi, lazima iwe kubwa kuliko 1.\n *      $b (int): Nambari ya kulinganisha.\n * \n * Inarejesha:\n *      int: Nambari kubwa zaidi x inayokidhi masharti.\n * \n * Mifano:\n *      - Ikiwa a = 10000 na b = 1000000000001, basi matokeo yanapaswa kuwa 3.\n *      - Ikiwa a = 3 na b = 27, basi matokeo yanapaswa kuwa 3.\n */\n\nfunction calculateLogLimit($a, $b) ",
      "tr": "<?php\n\n\n/**\n * ax <= b < ax+1 veya x <= logab < x + 1 olacak şekilde en büyük tam sayı x'i hesaplar.\n * Bu fonksiyon, iki sayı arasındaki ilişkiyi logaritmalar ve üsler açısından anlamaya yardımcı olur.\n * - Fonksiyon, iki pozitif tam sayı 'a' ve 'b' alır.\n * - Yukarıda belirtilen koşulları sağlayan en büyük tam sayı 'x'i bulur.\n * \n * Argümanlar:\n *      $a (int): Taban numarası, 1'den büyük olmalıdır.\n *      $b (int): Karşılaştırma numarası.\n * \n * Döndürür:\n *      int: Koşulları sağlayan en büyük tam sayı x.\n * \n * Örnekler:\n *      - Eğer a = 10000 ve b = 1000000000001 ise, çıktı 3 olmalıdır.\n *      - Eğer a = 3 ve b = 27 ise, çıktı 3 olmalıdır.\n */\n\nfunction calculateLogLimit($a, $b) ",
      "vi": "<?php\n\n\n/**\n * Tính toán số nguyên lớn nhất x sao cho ax <= b < ax+1 hoặc x <= logab < x + 1.\n * Hàm này giúp hiểu mối quan hệ giữa hai số dưới dạng logarit và số mũ.\n * - Hàm nhận hai số nguyên dương 'a' và 'b' làm đầu vào.\n * - Nó tìm số nguyên lớn nhất 'x' thỏa mãn các điều kiện đã đề cập ở trên.\n * \n * Tham số:\n *      $a (int): Số cơ số, phải lớn hơn 1.\n *      $b (int): Số để so sánh.\n * \n * Trả về:\n *      int: Số nguyên lớn nhất x thỏa mãn các điều kiện.\n * \n * Ví dụ:\n *      - Nếu a = 10000 và b = 1000000000001, thì đầu ra sẽ là 3.\n *      - Nếu a = 3 và b = 27, thì đầu ra sẽ là 3.\n */\n\nfunction calculateLogLimit($a, $b) "
    },
    "prompt_bertscore": {
      "es": "0.9929416694099252",
      "arb": "0.99053188562721",
      "sw": "0.9714154991260313",
      "tr": "0.968026268934433",
      "vi": "0.9540679161679683"
    },
    "canonical_solution": "{\n    $x = 0;\n    while (pow($a, $x) <= $b) {\n        $x++;\n    }\n    return $x - 1;\n}",
    "instruction": {
      "en": "Write a PHP function `function calculateLogLimit($a, $b)` to solve the following problem:\nCalculates the largest integer x such that ax <= b < ax+1 or x <= logab < x + 1.\nThis function helps in understanding the relationship between two numbers in terms of logarithms and exponents.\n- The function takes two positive integers 'a' and 'b' as inputs.\n- It finds the largest integer 'x' that satisfies the conditions mentioned above.\n\nArgs:\n$a (int): The base number, must be greater than 1.\n$b (int): The comparison number.\n\nReturns:\nint: The largest integer x satisfying the conditions.\n\nExamples:\n- If a = 10000 and b = 1000000000001, then the output should be 3.\n- If a = 3 and b = 27, then the output should be 3.",
      "es": "Escribe una función PHP `function calculateLogLimit($a, $b)` para resolver el siguiente problema:\nCalcula el mayor entero x tal que ax <= b < ax+1 o x <= logab < x + 1.\nEsta función ayuda a entender la relación entre dos números en términos de logaritmos y exponentes.\n- La función toma dos enteros positivos 'a' y 'b' como entradas.\n- Encuentra el mayor entero 'x' que satisface las condiciones mencionadas anteriormente.\n\nArgumentos:\n$a (int): El número base, debe ser mayor que 1.\n$b (int): El número de comparación.\n\nDevuelve:\nint: El mayor entero x que satisface las condiciones.\n\nEjemplos:\n- Si a = 10000 y b = 1000000000001, entonces la salida debe ser 3.\n- Si a = 3 y b = 27, entonces la salida debe ser 3.",
      "arb": "اكتب دالة PHP `function calculateLogLimit($a, $b)` لحل المشكلة التالية:\nتحسب أكبر عدد صحيح x بحيث ax <= b < ax+1 أو x <= logab < x + 1.\nتساعد هذه الدالة في فهم العلاقة بين رقمين من حيث اللوغاريتمات والأسس.\n- تأخذ الدالة عددين صحيحين موجبين 'a' و 'b' كمدخلات.\n- تجد أكبر عدد صحيح 'x' يحقق الشروط المذكورة أعلاه.\n\nالمعطيات:\n$a (int): الرقم الأساسي، يجب أن يكون أكبر من 1.\n$b (int): الرقم المقارن.\n\nالقيم المعادة:\nint: أكبر عدد صحيح x يحقق الشروط.\n\nأمثلة:\n- إذا كان a = 10000 و b = 1000000000001، فيجب أن يكون الناتج 3.\n- إذا كان a = 3 و b = 27، فيجب أن يكون الناتج 3.",
      "sw": "Andika kazi ya PHP `function calculateLogLimit($a, $b)` kutatua tatizo lifuatalo:\nInahesabu nambari kubwa zaidi x kama kwamba ax <= b < ax+1 au x <= logab < x + 1.\nKazi hii inasaidia kuelewa uhusiano kati ya nambari mbili kwa kutumia logaritimu na viashiria.\n- Kazi inachukua nambari mbili chanya 'a' na 'b' kama pembejeo.\n- Inapata nambari kubwa zaidi 'x' inayokidhi masharti yaliyotajwa hapo juu.\n\nHoja:\n$a (int): Nambari ya msingi, lazima iwe kubwa kuliko 1.\n$b (int): Nambari ya kulinganisha.\n\nInarudisha:\nint: Nambari kubwa zaidi x inayokidhi masharti.\n\nMifano:\n- Ikiwa a = 10000 na b = 1000000000001, basi matokeo yanapaswa kuwa 3.\n- Ikiwa a = 3 na b = 27, basi matokeo yanapaswa kuwa 3.",
      "tr": "Bir PHP fonksiyonu `function calculateLogLimit($a, $b)` yazın ve aşağıdaki problemi çözün:\nax <= b < ax+1 veya x <= logab < x + 1 olacak şekilde en büyük tam sayı x'i hesaplar.\nBu fonksiyon, iki sayı arasındaki ilişkiyi logaritmalar ve üsler açısından anlamaya yardımcı olur.\n- Fonksiyon, iki pozitif tam sayı 'a' ve 'b'yi girdi olarak alır.\n- Yukarıda belirtilen koşulları sağlayan en büyük tam sayı 'x'i bulur.\n\nArgümanlar:\n$a (int): Taban numarası, 1'den büyük olmalıdır.\n$b (int): Karşılaştırma numarası.\n\nDöndürür:\nint: Koşulları sağlayan en büyük tam sayı x.\n\nÖrnekler:\n- Eğer a = 10000 ve b = 1000000000001 ise, çıktı 3 olmalıdır.\n- Eğer a = 3 ve b = 27 ise, çıktı 3 olmalıdır.",
      "vi": "Viết một hàm PHP `function calculateLogLimit($a, $b)` để giải quyết vấn đề sau:\nTính toán số nguyên lớn nhất x sao cho ax <= b < ax+1 hoặc x <= logab < x + 1.\nHàm này giúp hiểu mối quan hệ giữa hai số theo logarit và số mũ.\n- Hàm nhận hai số nguyên dương 'a' và 'b' làm đầu vào.\n- Nó tìm số nguyên lớn nhất 'x' thỏa mãn các điều kiện đã đề cập ở trên.\n\nTham số:\n$a (int): Số cơ số, phải lớn hơn 1.\n$b (int): Số so sánh.\n\nTrả về:\nint: Số nguyên lớn nhất x thỏa mãn các điều kiện.\n\nVí dụ:\n- Nếu a = 10000 và b = 1000000000001, thì kết quả nên là 3.\n- Nếu a = 3 và b = 27, thì kết quả nên là 3."
    },
    "instruction_bertscore": {
      "es": "0.9924854154246882",
      "arb": "0.9842595354548903",
      "sw": "0.9657042797801352",
      "tr": "0.9777118835744563",
      "vi": "0.9746257633443172"
    },
    "level": "easy",
    "test": "function main(){\n    assert(calculateLogLimit(10000, 1000000000001) === 3);\n    assert(calculateLogLimit(3, 27) === 3);\n    assert(calculateLogLimit(2, 32) === 5);\n    assert(calculateLogLimit(5, 3125) === 5);\n   \n    \n}\n\nmain();\n?>",
    "entry_point": "calculateLogLimit",
    "signature": "function calculateLogLimit($a, $b)",
    "docstring": {
      "en": "Calculates the largest integer x such that ax <= b < ax+1 or x <= logab < x + 1.\nThis function helps in understanding the relationship between two numbers in terms of logarithms and exponents.\n- The function takes two positive integers 'a' and 'b' as inputs.\n- It finds the largest integer 'x' that satisfies the conditions mentioned above.\n\nArgs:\n$a (int): The base number, must be greater than 1.\n$b (int): The comparison number.\n\nReturns:\nint: The largest integer x satisfying the conditions.\n\nExamples:\n- If a = 10000 and b = 1000000000001, then the output should be 3.\n- If a = 3 and b = 27, then the output should be 3.",
      "es": "Calcula el mayor entero x tal que ax <= b < ax+1 o x <= logab < x + 1.  \nEsta función ayuda a entender la relación entre dos números en términos de logaritmos y exponentes.  \n- La función toma dos enteros positivos 'a' y 'b' como entradas.  \n- Encuentra el mayor entero 'x' que satisface las condiciones mencionadas anteriormente.  \n\nArgumentos:  \n$a (int): El número base, debe ser mayor que 1.  \n$b (int): El número de comparación.  \n\nDevuelve:  \nint: El mayor entero x que satisface las condiciones.  \n\nEjemplos:  \n- Si a = 10000 y b = 1000000000001, entonces la salida debe ser 3.  \n- Si a = 3 y b = 27, entonces la salida debe ser 3.  ",
      "arb": "يحسب أكبر عدد صحيح x بحيث ax <= b < ax+1 أو x <= logab < x + 1.  \nتساعد هذه الدالة في فهم العلاقة بين عددين من حيث اللوغاريتمات والأسس.\n- تأخذ الدالة عددين صحيحين موجبين 'a' و 'b' كمدخلات.\n- تجد أكبر عدد صحيح 'x' يحقق الشروط المذكورة أعلاه.\n\nالمعاملات:\n$a (int): العدد الأساسي، يجب أن يكون أكبر من 1.\n$b (int): العدد المقارن.\n\nالقيم المعادة:\nint: أكبر عدد صحيح x يحقق الشروط.\n\nأمثلة:\n- إذا كان a = 10000 و b = 1000000000001، فيجب أن يكون الناتج 3.\n- إذا كان a = 3 و b = 27، فيجب أن يكون الناتج 3.",
      "sw": "Inahesabu nambari kubwa zaidi x ambapo ax <= b < ax+1 au x <= logab < x + 1. Kazi hii husaidia katika kuelewa uhusiano kati ya nambari mbili kwa kutumia logaritimu na eksponenti.\n- Kazi hii inachukua nambari mbili chanya 'a' na 'b' kama pembejeo.\n- Inapata nambari kubwa zaidi 'x' inayokidhi masharti yaliyotajwa hapo juu.\n\nHoja:\n$a (int): Nambari ya msingi, lazima iwe kubwa kuliko 1.\n$b (int): Nambari ya kulinganisha.\n\nInarejesha:\nint: Nambari kubwa zaidi x inayokidhi masharti.\n\nMifano:\n- Ikiwa a = 10000 na b = 1000000000001, basi matokeo yanapaswa kuwa 3.\n- Ikiwa a = 3 na b = 27, basi matokeo yanapaswa kuwa 3.",
      "tr": "ax <= b < ax+1 veya x <= logab < x + 1 olacak şekilde en büyük tam sayı x'i hesaplar.\nBu fonksiyon, iki sayı arasındaki ilişkiyi logaritmalar ve üsler açısından anlamaya yardımcı olur.\n- Fonksiyon, iki pozitif tam sayı 'a' ve 'b'yi girdi olarak alır.\n- Yukarıda belirtilen koşulları sağlayan en büyük tam sayı 'x'i bulur.\n\nArgümanlar:\n$a (int): Taban numarası, 1'den büyük olmalıdır.\n$b (int): Karşılaştırma numarası.\n\nDöndürür:\nint: Koşulları sağlayan en büyük tam sayı x.\n\nÖrnekler:\n- Eğer a = 10000 ve b = 1000000000001 ise, çıktı 3 olmalıdır.\n- Eğer a = 3 ve b = 27 ise, çıktı 3 olmalıdır.",
      "vi": "Tính toán số nguyên lớn nhất x sao cho ax <= b < ax+1 hoặc x <= logab < x + 1. Hàm này giúp hiểu mối quan hệ giữa hai số theo lôgarit và số mũ.\n- Hàm nhận hai số nguyên dương 'a' và 'b' làm đầu vào.\n- Nó tìm số nguyên lớn nhất 'x' thỏa mãn các điều kiện đã đề cập ở trên.\n\nTham số:\n$a (int): Số cơ số, phải lớn hơn 1.\n$b (int): Số để so sánh.\n\nTrả về:\nint: Số nguyên lớn nhất x thỏa mãn các điều kiện.\n\nVí dụ:\n- Nếu a = 10000 và b = 1000000000001, thì đầu ra sẽ là 3.\n- Nếu a = 3 và b = 27, thì đầu ra sẽ là 3."
    },
    "docstring_bertscore": {
      "es": "0.9938557664234478",
      "arb": "0.9854624410424375",
      "sw": "0.9533437097987151",
      "tr": "0.9829972393834135",
      "vi": "0.9642715588417305"
    }
  },
  {
    "task_id": "PHP/25",
    "prompt": {
      "en": "<?php\n\n/**\n   * Distribute candy to five children sitting around a round table.\n   *Each child initially has a certain number of candies. They play a game where, starting with one child, and going clockwise, each child divides their candy into three equal parts, and if there are extra candies that cannot be divided equally, the child eats them. Each child keeps one copy and gives the other two copies to their neighbors. The five children completed the above operations in turn.\n   * Input: An array of five integers representing the number of candies each child has.\n   * Output: An array of five integers representing the number of candies each child has after playing the game.\n   */\n\n function distributeCandies(array $candies): array",
      "es": "<?php\n\n/**\n   * Distribuir caramelos a cinco niños sentados alrededor de una mesa redonda.\n   * Cada niño inicialmente tiene una cierta cantidad de caramelos. Juegan un juego donde, comenzando con un niño y yendo en el sentido de las agujas del reloj, cada niño divide sus caramelos en tres partes iguales, y si hay caramelos extra que no se pueden dividir equitativamente, el niño se los come. Cada niño guarda una copia y da las otras dos copias a sus vecinos. Los cinco niños completaron las operaciones anteriores por turnos.\n   * Entrada: Un arreglo de cinco enteros que representa la cantidad de caramelos que tiene cada niño.\n   * Salida: Un arreglo de cinco enteros que representa la cantidad de caramelos que tiene cada niño después de jugar el juego.\n   */\n\n function distributeCandies(array $candies): array",
      "arb": "<?php\n\n/**\n   * توزيع الحلوى على خمسة أطفال يجلسون حول طاولة مستديرة.\n   * كل طفل لديه في البداية عدد معين من الحلوى. يلعبون لعبة حيث يبدأ أحد الأطفال، ويدورون في اتجاه عقارب الساعة، كل طفل يقسم حلواته إلى ثلاثة أجزاء متساوية، وإذا كان هناك حلوى زائدة لا يمكن تقسيمها بالتساوي، يأكلها الطفل. يحتفظ كل طفل بنسخة واحدة ويعطي النسختين الأخريين لجيرانه. أكمل الأطفال الخمسة العمليات المذكورة أعلاه بالتناوب.\n   * المدخلات: مصفوفة من خمسة أعداد صحيحة تمثل عدد الحلوى التي يمتلكها كل طفل.\n   * المخرجات: مصفوفة من خمسة أعداد صحيحة تمثل عدد الحلوى التي يمتلكها كل طفل بعد لعب اللعبة.\n   */\n\n function distributeCandies(array $candies): array",
      "sw": "<?php\n\n/**\n   * Gawa pipi kwa watoto watano walioketi kuzunguka meza ya duara.\n   * Kila mtoto awali ana idadi fulani ya pipi. Wanacheza mchezo ambapo, kuanzia na mtoto mmoja, na kwenda kwa mzunguko wa saa, kila mtoto anagawanya pipi zao katika sehemu tatu sawa, na ikiwa kuna pipi za ziada ambazo haziwezi kugawanywa sawa, mtoto huyo huzila. Kila mtoto huhifadhi nakala moja na kutoa nakala mbili kwa majirani zao. Watoto watano walikamilisha shughuli hizo kwa zamu.\n   * Ingizo: Mfululizo wa nambari tano za mzima zinazoonyesha idadi ya pipi kila mtoto anayo.\n   * Matokeo: Mfululizo wa nambari tano za mzima zinazoonyesha idadi ya pipi kila mtoto anayo baada ya kucheza mchezo.\n   */\n\n function distributeCandies(array $candies): array",
      "tr": "<?php\n\n/**\n   * Beş çocuğa yuvarlak bir masa etrafında şeker dağıtın.\n   * Her çocuğun başlangıçta belirli sayıda şekeri vardır. Bir oyun oynarlar, bir çocukla başlayarak ve saat yönünde ilerleyerek, her çocuk şekerlerini üç eşit parçaya böler ve eşit olarak bölünemeyen fazla şekerleri yer. Her çocuk bir kopyayı kendine saklar ve diğer iki kopyayı komşularına verir. Beş çocuk yukarıdaki işlemleri sırayla tamamlar.\n   * Girdi: Her çocuğun sahip olduğu şeker sayısını temsil eden beş tam sayıdan oluşan bir dizi.\n   * Çıktı: Oyunu oynadıktan sonra her çocuğun sahip olduğu şeker sayısını temsil eden beş tam sayıdan oluşan bir dizi.\n   */\n\n function distributeCandies(array $candies): array",
      "vi": "<?php\n\n/**\n   * Phân phát kẹo cho năm đứa trẻ ngồi quanh một bàn tròn.\n   * Mỗi đứa trẻ ban đầu có một số lượng kẹo nhất định. Chúng chơi một trò chơi, bắt đầu với một đứa trẻ, và đi theo chiều kim đồng hồ, mỗi đứa trẻ chia kẹo của mình thành ba phần bằng nhau, và nếu có kẹo thừa không thể chia đều, đứa trẻ sẽ ăn chúng. Mỗi đứa trẻ giữ một phần và đưa hai phần còn lại cho hai đứa trẻ ngồi cạnh. Năm đứa trẻ hoàn thành các thao tác trên lần lượt.\n   * Đầu vào: Một mảng gồm năm số nguyên đại diện cho số lượng kẹo mỗi đứa trẻ có.\n   * Đầu ra: Một mảng gồm năm số nguyên đại diện cho số lượng kẹo mỗi đứa trẻ có sau khi chơi trò chơi.\n   */\n\n function distributeCandies(array $candies): array"
    },
    "prompt_bertscore": {
      "es": "0.9804251745793928",
      "arb": "0.9574142421972631",
      "sw": "0.9496096572656403",
      "tr": "0.9498468219405959",
      "vi": "0.9566375974074167"
    },
    "canonical_solution": " {\n    $n = count($candies);\n    if ($n != 5) {\n        throw new InvalidArgumentException(\"Input must be an array of five integers.\");\n    }\n\n    // Calculate the candies to give and the new count for each child\n    for ($i = 0; $i < $n; $i++) {\n        $divided = intdiv($candies[$i], 3);\n  \n        $candies[$i] = $divided;\n        $leftNeighbor = ($i + $n - 1) % $n;\n        $rightNeighbor = ($i + 1) % $n;\n        $candies[$leftNeighbor]  += $divided;\n        $candies[$rightNeighbor] += $divided;\n    }\n    return $candies;\n}",
    "instruction": {
      "en": "Write a PHP function `function distributeCandies(array $candies): array` to solve the following problem:\nDistribute candy to five children sitting around a round table.\nEach child initially has a certain number of candies. They play a game where, starting with one child, and going clockwise, each child divides their candy into three equal parts, and if there are extra candies that cannot be divided equally, the child eats them. Each child keeps one copy and gives the other two copies to their neighbors. The five children completed the above operations in turn.\nInput: An array of five integers representing the number of candies each child has.\nOutput: An array of five integers representing the number of candies each child has after playing the game.",
      "es": "Escribe una función PHP `function distributeCandies(array $candies): array` para resolver el siguiente problema:\nDistribuir caramelos a cinco niños sentados alrededor de una mesa redonda.\nCada niño inicialmente tiene una cierta cantidad de caramelos. Juegan un juego donde, comenzando con un niño y yendo en el sentido de las agujas del reloj, cada niño divide sus caramelos en tres partes iguales, y si hay caramelos extra que no se pueden dividir equitativamente, el niño se los come. Cada niño guarda una copia y da las otras dos copias a sus vecinos. Los cinco niños completaron las operaciones anteriores por turnos.\nEntrada: Un arreglo de cinco enteros que representa la cantidad de caramelos que tiene cada niño.\nSalida: Un arreglo de cinco enteros que representa la cantidad de caramelos que tiene cada niño después de jugar el juego.",
      "arb": "اكتب دالة PHP `function distributeCandies(array $candies): array` لحل المشكلة التالية:\nتوزيع الحلوى على خمسة أطفال يجلسون حول طاولة مستديرة.\nكل طفل لديه في البداية عدد معين من الحلوى. يلعبون لعبة حيث يبدأون بطفل واحد، ويمرون في اتجاه عقارب الساعة، يقوم كل طفل بتقسيم حلواته إلى ثلاثة أجزاء متساوية، وإذا كانت هناك حلوى إضافية لا يمكن تقسيمها بالتساوي، يأكلها الطفل. يحتفظ كل طفل بنسخة واحدة ويعطي النسختين الأخريين لجيرانه. أكمل الأطفال الخمسة العمليات المذكورة أعلاه بالتناوب.\nالمدخل: مصفوفة تحتوي على خمسة أعداد صحيحة تمثل عدد الحلوى التي يمتلكها كل طفل.\nالمخرج: مصفوفة تحتوي على خمسة أعداد صحيحة تمثل عدد الحلوى التي يمتلكها كل طفل بعد لعب اللعبة.",
      "sw": "Andika kazi ya PHP `function distributeCandies(array $candies): array` kutatua tatizo lifuatalo:\nGawa pipi kwa watoto watano walioketi kuzunguka meza ya mviringo.\nKila mtoto awali ana idadi fulani ya pipi. Wanacheza mchezo ambapo, kuanzia na mtoto mmoja, na kwenda kwa mwendo wa saa, kila mtoto anagawanya pipi zao katika sehemu tatu sawa, na ikiwa kuna pipi za ziada ambazo haziwezi kugawanywa sawa, mtoto huyo huzila. Kila mtoto huweka nakala moja na kutoa nakala mbili kwa majirani zao. Watoto watano walikamilisha shughuli zilizo hapo juu kwa zamu.\nIngizo: Mfululizo wa nambari tano za mzima unaowakilisha idadi ya pipi kila mtoto anayo.\nPato: Mfululizo wa nambari tano za mzima unaowakilisha idadi ya pipi kila mtoto anayo baada ya kucheza mchezo.",
      "tr": "Bir PHP fonksiyonu `function distributeCandies(array $candies): array` yazın ve aşağıdaki problemi çözün:\nYuvarlak bir masa etrafında oturan beş çocuğa şeker dağıtın.\nHer çocuğun başlangıçta belirli sayıda şekeri vardır. Bir oyun oynarlar, bir çocukla başlayarak ve saat yönünde ilerleyerek, her çocuk şekerlerini üç eşit parçaya böler ve eğer eşit olarak bölünemeyen ekstra şekerler varsa, çocuk onları yer. Her çocuk bir kopyayı kendine saklar ve diğer iki kopyayı komşularına verir. Beş çocuk yukarıdaki işlemleri sırayla tamamlar.\nGirdi: Her çocuğun sahip olduğu şeker sayısını temsil eden beş tam sayıdan oluşan bir dizi.\nÇıktı: Oyunu oynadıktan sonra her çocuğun sahip olduğu şeker sayısını temsil eden beş tam sayıdan oluşan bir dizi.",
      "vi": "Viết một hàm PHP `function distributeCandies(array $candies): array` để giải quyết vấn đề sau:\nPhân phát kẹo cho năm đứa trẻ ngồi quanh một bàn tròn.\nMỗi đứa trẻ ban đầu có một số lượng kẹo nhất định. Chúng chơi một trò chơi mà, bắt đầu từ một đứa trẻ, và đi theo chiều kim đồng hồ, mỗi đứa trẻ chia kẹo của mình thành ba phần bằng nhau, và nếu có kẹo thừa không thể chia đều, đứa trẻ sẽ ăn chúng. Mỗi đứa trẻ giữ một phần và đưa hai phần còn lại cho hai đứa trẻ ngồi cạnh. Năm đứa trẻ hoàn thành các thao tác trên theo lượt.\nĐầu vào: Một mảng gồm năm số nguyên đại diện cho số lượng kẹo mỗi đứa trẻ có.\nĐầu ra: Một mảng gồm năm số nguyên đại diện cho số lượng kẹo mỗi đứa trẻ có sau khi chơi trò chơi."
    },
    "instruction_bertscore": {
      "es": "0.9919928120797216",
      "arb": "0.947991018290587",
      "sw": "0.961234103054945",
      "tr": "0.9712381221957671",
      "vi": "0.9602123483749015"
    },
    "level": "middle",
    "test": "function main(){\n    $candies = distributeCandies([8, 9, 10, 11, 12]);\n    assert($candies === [11, 7, 9, 11, 6]);\n    \n    \n}\n\nmain();\n?>",
    "entry_point": "distributeCandies",
    "signature": "function distributeCandies(array $candies): array",
    "docstring": {
      "en": "Distribute candy to five children sitting around a round table.\nEach child initially has a certain number of candies. They play a game where, starting with one child, and going clockwise, each child divides their candy into three equal parts, and if there are extra candies that cannot be divided equally, the child eats them. Each child keeps one copy and gives the other two copies to their neighbors. The five children completed the above operations in turn.\nInput: An array of five integers representing the number of candies each child has.\nOutput: An array of five integers representing the number of candies each child has after playing the game.",
      "es": "Distribuir caramelos a cinco niños sentados alrededor de una mesa redonda.  \nCada niño inicialmente tiene una cierta cantidad de caramelos. Juegan un juego donde, comenzando con un niño y yendo en el sentido de las agujas del reloj, cada niño divide sus caramelos en tres partes iguales, y si hay caramelos extra que no se pueden dividir equitativamente, el niño se los come. Cada niño guarda una copia y entrega las otras dos copias a sus vecinos. Los cinco niños completaron las operaciones anteriores por turnos.  \nEntrada: Un arreglo de cinco enteros que representa la cantidad de caramelos que tiene cada niño.  \nSalida: Un arreglo de cinco enteros que representa la cantidad de caramelos que tiene cada niño después de jugar el juego.",
      "arb": "توزيع الحلوى على خمسة أطفال جالسين حول طاولة مستديرة. \nكل طفل لديه في البداية عدد معين من الحلوى. يلعبون لعبة حيث يبدأون بطفل واحد، ويمرون باتجاه عقارب الساعة، يقوم كل طفل بتقسيم الحلوى الخاصة به إلى ثلاثة أجزاء متساوية، وإذا كانت هناك حلوى إضافية لا يمكن تقسيمها بالتساوي، يأكلها الطفل. يحتفظ كل طفل بنسخة واحدة ويعطي النسختين الأخريين لجيرانه. أكمل الأطفال الخمسة العمليات المذكورة أعلاه بالتناوب.\nالمدخلات: مصفوفة من خمسة أعداد صحيحة تمثل عدد الحلوى التي يمتلكها كل طفل.\nالمخرجات: مصفوفة من خمسة أعداد صحيحة تمثل عدد الحلوى التي يمتلكها كل طفل بعد لعب اللعبة.",
      "sw": "Sambaza pipi kwa watoto watano walioketi kuzunguka meza ya duara.  \nKila mtoto awali ana idadi fulani ya pipi. Wanacheza mchezo ambapo, kuanzia na mtoto mmoja, na kwenda kwa mwendo wa saa, kila mtoto anagawanya pipi zake katika sehemu tatu sawa, na kama kuna pipi za ziada ambazo haziwezi kugawanywa sawa, mtoto huyo anazila. Kila mtoto anabaki na nakala moja na anawapa majirani zake nakala mbili nyingine. Watoto watano wanakamilisha operesheni zilizo hapo juu kwa zamu.  \nIngizo: Mfululizo wa nambari tano za mzima zinazoashiria idadi ya pipi kila mtoto anayo.  \nMatokeo: Mfululizo wa nambari tano za mzima zinazoashiria idadi ya pipi kila mtoto anayo baada ya kucheza mchezo.",
      "tr": "Beş çocuğa yuvarlak bir masa etrafında şeker dağıtın.  \nHer çocuğun başlangıçta belirli sayıda şekeri vardır. Bir oyun oynarlar, burada bir çocukla başlayarak ve saat yönünde ilerleyerek, her çocuk şekerlerini üç eşit parçaya böler ve eğer eşit olarak bölünemeyen ekstra şekerler varsa, çocuk onları yer. Her çocuk bir kopyayı kendine saklar ve diğer iki kopyayı komşularına verir. Beş çocuk yukarıdaki işlemleri sırayla tamamladı.  \nGirdi: Her çocuğun sahip olduğu şeker sayısını temsil eden beş tamsayıdan oluşan bir dizi.  \nÇıktı: Oyunu oynadıktan sonra her çocuğun sahip olduğu şeker sayısını temsil eden beş tamsayıdan oluşan bir dizi.",
      "vi": "Phân phát kẹo cho năm đứa trẻ ngồi quanh một bàn tròn.  \nMỗi đứa trẻ ban đầu có một số lượng kẹo nhất định. Chúng chơi một trò chơi mà, bắt đầu từ một đứa trẻ và đi theo chiều kim đồng hồ, mỗi đứa trẻ chia kẹo của mình thành ba phần bằng nhau, và nếu có kẹo thừa không thể chia đều, đứa trẻ sẽ ăn chúng. Mỗi đứa trẻ giữ một phần và đưa hai phần còn lại cho hai đứa trẻ bên cạnh. Năm đứa trẻ lần lượt hoàn thành các thao tác trên.  \nĐầu vào: Một mảng gồm năm số nguyên đại diện cho số lượng kẹo mỗi đứa trẻ có.  \nĐầu ra: Một mảng gồm năm số nguyên đại diện cho số lượng kẹo mỗi đứa trẻ có sau khi chơi trò chơi."
    },
    "docstring_bertscore": {
      "es": "0.9892495278872487",
      "arb": "0.9582004212453992",
      "sw": "0.9546064031309539",
      "tr": "0.9649904021906958",
      "vi": "0.9526344007080395"
    }
  },
  {
    "task_id": "PHP/26",
    "prompt": {
      "en": "<?php\n\n/**\n * Determines a pen purchase plan to maximize the number of pens bought with a given amount of class fund.\n * There are three types of pens available at prices of 6, 5, and 4 units respectively.\n * The objective is to buy as many pens as possible without any remaining class fund.\n * \n * Input: An integer representing the total class fund available.\n * Output: An array with three integers representing the count of pens bought at 6 units, 5 units, and 4 units, in that order.\n * \n * Example:\n * findPenPurchasePlan(10)\n * Output: [1, 0, 1] (One pen of 6 units and one pen of 4 units)\n */\nfunction findPenPurchasePlan(int $totalFund): array ",
      "es": "<?php\n\n/**\n * Determina un plan de compra de bolígrafos para maximizar el número de bolígrafos comprados con una cantidad dada de fondo de clase.\n * Hay tres tipos de bolígrafos disponibles a precios de 6, 5 y 4 unidades respectivamente.\n * El objetivo es comprar la mayor cantidad posible de bolígrafos sin que sobre fondo de clase.\n * \n * Entrada: Un entero que representa el total del fondo de clase disponible.\n * Salida: Un arreglo con tres enteros que representan la cantidad de bolígrafos comprados a 6 unidades, 5 unidades y 4 unidades, en ese orden.\n * \n * Ejemplo:\n * findPenPurchasePlan(10)\n * Salida: [1, 0, 1] (Un bolígrafo de 6 unidades y un bolígrafo de 4 unidades)\n */\nfunction findPenPurchasePlan(int $totalFund): array ",
      "arb": "<?php\n\n/**\n * يحدد خطة شراء الأقلام لتعظيم عدد الأقلام المشتراة بمبلغ معين من صندوق الفصل.\n * هناك ثلاثة أنواع من الأقلام متوفرة بأسعار 6 و 5 و 4 وحدات على التوالي.\n * الهدف هو شراء أكبر عدد ممكن من الأقلام دون أي بقايا من صندوق الفصل.\n * \n * المدخلات: عدد صحيح يمثل إجمالي صندوق الفصل المتاح.\n * المخرجات: مصفوفة تحتوي على ثلاثة أعداد صحيحة تمثل عدد الأقلام المشتراة بأسعار 6 وحدات، 5 وحدات، و 4 وحدات، بهذا الترتيب.\n * \n * مثال:\n * findPenPurchasePlan(10)\n * المخرجات: [1, 0, 1] (قلم واحد بسعر 6 وحدات وقلم واحد بسعر 4 وحدات)\n */\nfunction findPenPurchasePlan(int $totalFund): array ",
      "sw": "<?php\n\n/**\n * Huamua mpango wa ununuzi wa kalamu ili kuongeza idadi ya kalamu zinazoweza kununuliwa kwa kiasi fulani cha mfuko wa darasa.\n * Kuna aina tatu za kalamu zinazopatikana kwa bei ya vitengo 6, 5, na 4 mtawalia.\n * Lengo ni kununua kalamu nyingi iwezekanavyo bila kubakiza mfuko wowote wa darasa.\n * \n * Ingizo: Nambari nzima inayowakilisha jumla ya mfuko wa darasa unaopatikana.\n * Tokeo: Mfululizo wa nambari tatu zinazowakilisha idadi ya kalamu zilizonunuliwa kwa vitengo 6, 5, na 4, kwa mpangilio huo.\n * \n * Mfano:\n * findPenPurchasePlan(10)\n * Tokeo: [1, 0, 1] (Kalamu moja ya vitengo 6 na kalamu moja ya vitengo 4)\n */\nfunction findPenPurchasePlan(int $totalFund): array ",
      "tr": "<?php\n\n/**\n * Belirli bir sınıf fonu miktarı ile satın alınabilecek maksimum kalem sayısını belirleyen bir kalem satın alma planı oluşturur.\n * Sırasıyla 6, 5 ve 4 birim fiyatlarında üç tür kalem bulunmaktadır.\n * Amaç, sınıf fonunda hiç para kalmayacak şekilde mümkün olduğunca fazla kalem satın almaktır.\n * \n * Girdi: Mevcut toplam sınıf fonunu temsil eden bir tamsayı.\n * Çıktı: Sırasıyla 6 birim, 5 birim ve 4 birim fiyatındaki kalemlerin sayısını temsil eden üç tamsayı içeren bir dizi.\n * \n * Örnek:\n * findPenPurchasePlan(10)\n * Çıktı: [1, 0, 1] (Bir adet 6 birimlik kalem ve bir adet 4 birimlik kalem)\n */\nfunction findPenPurchasePlan(int $totalFund): array ",
      "vi": "<?php\n\n/**\n * Xác định kế hoạch mua bút để tối đa hóa số lượng bút mua được với số tiền quỹ lớp cho trước.\n * Có ba loại bút có sẵn với giá lần lượt là 6, 5 và 4 đơn vị.\n * Mục tiêu là mua càng nhiều bút càng tốt mà không còn lại quỹ lớp.\n * \n * Đầu vào: Một số nguyên đại diện cho tổng số tiền quỹ lớp có sẵn.\n * Đầu ra: Một mảng với ba số nguyên đại diện cho số lượng bút mua được với giá 6 đơn vị, 5 đơn vị và 4 đơn vị, theo thứ tự đó.\n * \n * Ví dụ:\n * findPenPurchasePlan(10)\n * Đầu ra: [1, 0, 1] (Một bút giá 6 đơn vị và một bút giá 4 đơn vị)\n */\nfunction findPenPurchasePlan(int $totalFund): array "
    },
    "prompt_bertscore": {
      "es": "0.9844420767750613",
      "arb": "0.9656105262402866",
      "sw": "0.9519183381844087",
      "tr": "0.9320485466479648",
      "vi": "0.9695912777066069"
    },
    "canonical_solution": "{\n    $pensAt6Units = 0;\n    $pensAt5Units = 0;\n    $pensAt4Units = 0;\n\n    switch ($totalFund % 4) {\n        case 0:\n            $pensAt4Units = $totalFund / 4;\n            break;\n        case 1:\n            if ($totalFund >= 9) { // To avoid negative counts\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 9) / 4;\n            }\n            break;\n        case 2:\n            if ($totalFund >= 6) { // To avoid negative counts\n                $pensAt6Units = 1;\n                $pensAt4Units = ($totalFund - 6) / 4;\n            }\n            break;\n        case 3:\n            if ($totalFund >= 15) { // Ensures no negative counts\n                $pensAt6Units = 1;\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 15) / 4;\n            }\n            break;\n    }\n    echo $pensAt6Units;\n    echo \"\\n\";\n    echo $pensAt5Units;\n    echo \"\\n\";\n    echo $pensAt4Units;\n    echo \"\\n\";\n    return [$pensAt6Units, $pensAt5Units, $pensAt4Units];\n}",
    "instruction": {
      "en": "Write a PHP function `function findPenPurchasePlan(int $totalFund): array` to solve the following problem:\nDetermines a pen purchase plan to maximize the number of pens bought with a given amount of class fund.\nThere are three types of pens available at prices of 6, 5, and 4 units respectively.\nThe objective is to buy as many pens as possible without any remaining class fund.\n\nInput: An integer representing the total class fund available.\nOutput: An array with three integers representing the count of pens bought at 6 units, 5 units, and 4 units, in that order.\n\nExample:\nfindPenPurchasePlan(10)\nOutput: [1, 0, 1] (One pen of 6 units and one pen of 4 units)",
      "es": "Escribe una función PHP `function findPenPurchasePlan(int $totalFund): array` para resolver el siguiente problema:\nDetermina un plan de compra de bolígrafos para maximizar el número de bolígrafos comprados con una cantidad dada de fondos de la clase.\nHay tres tipos de bolígrafos disponibles a precios de 6, 5 y 4 unidades respectivamente.\nEl objetivo es comprar la mayor cantidad posible de bolígrafos sin que queden fondos de la clase.\n\nEntrada: Un entero que representa el total de fondos de la clase disponibles.\nSalida: Un arreglo con tres enteros que representan la cantidad de bolígrafos comprados a 6 unidades, 5 unidades y 4 unidades, en ese orden.\n\nEjemplo:\nfindPenPurchasePlan(10)\nSalida: [1, 0, 1] (Un bolígrafo de 6 unidades y un bolígrafo de 4 unidades)",
      "arb": "اكتب دالة PHP `function findPenPurchasePlan(int $totalFund): array` لحل المشكلة التالية:\nتحديد خطة شراء أقلام لزيادة عدد الأقلام المشتراة إلى أقصى حد ممكن باستخدام مبلغ معين من صندوق الفصل.\nهناك ثلاثة أنواع من الأقلام المتاحة بأسعار 6 و 5 و 4 وحدات على التوالي.\nالهدف هو شراء أكبر عدد ممكن من الأقلام دون أي بقايا من صندوق الفصل.\n\nالمدخلات: عدد صحيح يمثل إجمالي صندوق الفصل المتاح.\nالمخرجات: مصفوفة تحتوي على ثلاثة أعداد صحيحة تمثل عدد الأقلام المشتراة بأسعار 6 وحدات، 5 وحدات، و 4 وحدات، بهذا الترتيب.\n\nمثال:\nfindPenPurchasePlan(10)\nالمخرجات: [1, 0, 1] (قلم واحد بسعر 6 وحدات وقلم واحد بسعر 4 وحدات)",
      "sw": "Andika kazi ya PHP `function findPenPurchasePlan(int $totalFund): array` kutatua tatizo lifuatalo:\nInabainisha mpango wa kununua kalamu ili kuongeza idadi ya kalamu zinazoweza kununuliwa kwa kiasi fulani cha mfuko wa darasa.\nKuna aina tatu za kalamu zinazopatikana kwa bei ya vitengo 6, 5, na 4 mtawalia.\nLengo ni kununua kalamu nyingi iwezekanavyo bila kubakiza mfuko wowote wa darasa.\n\nIngizo: Nambari kamili inayowakilisha jumla ya mfuko wa darasa unaopatikana.\nPato: Mfululizo wa nambari tatu za nambari zinazowakilisha idadi ya kalamu zilizonunuliwa kwa vitengo 6, 5, na 4, kwa mpangilio huo.\n\nMfano:\nfindPenPurchasePlan(10)\nPato: [1, 0, 1] (Kalamu moja ya vitengo 6 na kalamu moja ya vitengo 4)",
      "tr": "Bir PHP fonksiyonu `function findPenPurchasePlan(int $totalFund): array` yazın:\nVerilen bir sınıf fondu miktarıyla satın alınan kalem sayısını en üst düzeye çıkarmak için bir kalem satın alma planı belirler.\nSırasıyla 6, 5 ve 4 birim fiyatla üç tür kalem mevcuttur.\nAmaç, herhangi bir sınıf fonu kalmadan mümkün olduğunca çok kalem satın almaktır.\n\nGirdi: Mevcut toplam sınıf fonunu temsil eden bir tam sayı.\nÇıktı: Sırasıyla 6 birim, 5 birim ve 4 birim fiyatla satın alınan kalem sayısını temsil eden üç tam sayıdan oluşan bir dizi.\n\nÖrnek:\nfindPenPurchasePlan(10)\nÇıktı: [1, 0, 1] (Bir adet 6 birimlik kalem ve bir adet 4 birimlik kalem)",
      "vi": "Viết một hàm PHP `function findPenPurchasePlan(int $totalFund): array` để giải quyết vấn đề sau:\nXác định một kế hoạch mua bút để tối đa hóa số lượng bút được mua với một số tiền quỹ lớp nhất định.\nCó ba loại bút có sẵn với giá lần lượt là 6, 5, và 4 đơn vị.\nMục tiêu là mua càng nhiều bút càng tốt mà không còn lại quỹ lớp.\n\nĐầu vào: Một số nguyên đại diện cho tổng quỹ lớp có sẵn.\nĐầu ra: Một mảng với ba số nguyên đại diện cho số lượng bút mua được với giá 6 đơn vị, 5 đơn vị, và 4 đơn vị, theo thứ tự đó.\n\nVí dụ:\nfindPenPurchasePlan(10)\nĐầu ra: [1, 0, 1] (Một bút giá 6 đơn vị và một bút giá 4 đơn vị)"
    },
    "instruction_bertscore": {
      "es": "0.9811861275691375",
      "arb": "0.9599501562719355",
      "sw": "0.9356751401448997",
      "tr": "0.9458464060665532",
      "vi": "0.9701150660213959"
    },
    "level": "hard",
    "test": "function main(){\n    assert(findPenPurchasePlan(10) === [1, 0, 1]);\n    assert(findPenPurchasePlan(14) === [1, 0, 2]);\n    assert(findPenPurchasePlan(24) === [0, 0, 6]);\n    \n}\n\nmain();\n?>",
    "entry_point": "findPenPurchasePlan",
    "signature": "function findPenPurchasePlan(int $totalFund): array",
    "docstring": {
      "en": "Determines a pen purchase plan to maximize the number of pens bought with a given amount of class fund.\nThere are three types of pens available at prices of 6, 5, and 4 units respectively.\nThe objective is to buy as many pens as possible without any remaining class fund.\n\nInput: An integer representing the total class fund available.\nOutput: An array with three integers representing the count of pens bought at 6 units, 5 units, and 4 units, in that order.\n\nExample:\nfindPenPurchasePlan(10)\nOutput: [1, 0, 1] (One pen of 6 units and one pen of 4 units)",
      "es": "Determina un plan de compra de bolígrafos para maximizar la cantidad de bolígrafos comprados con una cantidad dada del fondo de la clase.  \nHay tres tipos de bolígrafos disponibles a precios de 6, 5 y 4 unidades respectivamente.  \nEl objetivo es comprar la mayor cantidad posible de bolígrafos sin que sobre ningún fondo de la clase.\n\nEntrada: Un entero que representa el total del fondo de la clase disponible.  \nSalida: Un arreglo con tres enteros que representan la cantidad de bolígrafos comprados a 6 unidades, 5 unidades y 4 unidades, en ese orden.\n\nEjemplo:  \nfindPenPurchasePlan(10)  \nSalida: [1, 0, 1] (Un bolígrafo de 6 unidades y un bolígrafo de 4 unidades)",
      "arb": "يحدد خطة شراء الأقلام لتعظيم عدد الأقلام المشتراة بمبلغ معين من صندوق الفصل.\nهناك ثلاثة أنواع من الأقلام متوفرة بأسعار 6 و 5 و 4 وحدات على التوالي.\nالهدف هو شراء أكبر عدد ممكن من الأقلام دون أي بقايا من صندوق الفصل.\n\nالمدخلات: عدد صحيح يمثل إجمالي صندوق الفصل المتاح.\nالمخرجات: مصفوفة تحتوي على ثلاثة أعداد صحيحة تمثل عدد الأقلام المشتراة بأسعار 6 وحدات، 5 وحدات، و 4 وحدات، بهذا الترتيب.\n\nمثال:\nfindPenPurchasePlan(10)\nالمخرجات: [1, 0, 1] (قلم واحد بسعر 6 وحدات وقلم واحد بسعر 4 وحدات)",
      "sw": "Inabainisha mpango wa ununuzi wa kalamu ili kuongeza idadi ya kalamu zinazoweza kununuliwa kwa kiasi fulani cha fedha za darasa.\nKuna aina tatu za kalamu zinazopatikana kwa bei za vitengo 6, 5, na 4 mtawalia.\nLengo ni kununua kalamu nyingi iwezekanavyo bila kubakiza fedha zozote za darasa.\n\nIngizo: Nambari kamili inayowakilisha jumla ya fedha za darasa zinazopatikana.\nMatokeo: Mfululizo wa nambari tatu kamili zinazowakilisha idadi ya kalamu zilizonunuliwa kwa vitengo 6, 5, na 4, kwa mpangilio huo.\n\nMfano:\nfindPenPurchasePlan(10)\nMatokeo: [1, 0, 1] (Kalamu moja ya vitengo 6 na kalamu moja ya vitengo 4)",
      "tr": "Verilen sınıf fonuyla satın alınabilecek maksimum kalem sayısını belirleyen bir kalem satın alma planı belirler.\nFiyatları sırasıyla 6, 5 ve 4 birim olan üç tür kalem mevcuttur.\nAmaç, sınıf fonunda hiç para kalmayacak şekilde mümkün olduğunca fazla kalem satın almaktır.\n\nGirdi: Toplam mevcut sınıf fonunu temsil eden bir tamsayı.\nÇıktı: Sırasıyla 6 birim, 5 birim ve 4 birimlik kalemlerden satın alınan kalem sayısını temsil eden üç tamsayı içeren bir dizi.\n\nÖrnek:\nfindPenPurchasePlan(10)\nÇıktı: [1, 0, 1] (Bir adet 6 birimlik ve bir adet 4 birimlik kalem)",
      "vi": "Xác định kế hoạch mua bút để tối đa hóa số lượng bút mua được với số tiền quỹ lớp cho trước.  \nCó ba loại bút có sẵn với giá lần lượt là 6, 5 và 4 đơn vị.  \nMục tiêu là mua càng nhiều bút càng tốt mà không còn lại quỹ lớp.\n\nĐầu vào: Một số nguyên đại diện cho tổng số tiền quỹ lớp có sẵn.  \nĐầu ra: Một mảng với ba số nguyên đại diện cho số lượng bút mua được với giá 6 đơn vị, 5 đơn vị, và 4 đơn vị, theo thứ tự đó.\n\nVí dụ:  \nfindPenPurchasePlan(10)  \nĐầu ra: [1, 0, 1] (Một bút giá 6 đơn vị và một bút giá 4 đơn vị)"
    },
    "docstring_bertscore": {
      "es": "0.9825582662413265",
      "arb": "0.9575820848692376",
      "sw": "0.9288223919991961",
      "tr": "0.9148596693643486",
      "vi": "0.9576877562319481"
    }
  },
  {
    "task_id": "PHP/27",
    "prompt": {
      "en": "<?php\n\n/**\n    * Finds the smallest integer divisor greater than 1 that yields the same remainder when dividing three given numbers.\n    * This problem involves finding the minimum value of x (where x > 1) such that when x divides each of the \n    * three integers a, b, and c, the remainders are the same.\n    * Input: Three positive integers a, b, and c, each not exceeding 1,000,000.\n    * Output: Returns the smallest integer value of x that satisfies the condition.\n    * Example: For a = 300, b = 262, c = 205, the function returns 19.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)",
      "es": "<?php\n\n/**\n    * Encuentra el divisor entero más pequeño mayor que 1 que produce el mismo residuo al dividir tres números dados.\n    * Este problema implica encontrar el valor mínimo de x (donde x > 1) tal que cuando x divide cada uno de los \n    * tres enteros a, b y c, los residuos son los mismos.\n    * Entrada: Tres enteros positivos a, b y c, cada uno no excediendo 1,000,000.\n    * Salida: Devuelve el valor entero más pequeño de x que satisface la condición.\n    * Ejemplo: Para a = 300, b = 262, c = 205, la función devuelve 19.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)",
      "arb": "<?php\n\n/**\n    * يجد أصغر مقسوم صحيح أكبر من 1 الذي يعطي نفس الباقي عند قسمة ثلاثة أعداد معطاة.\n    * تتضمن هذه المشكلة إيجاد القيمة الدنيا لـ x (حيث x > 1) بحيث عندما يقسم x كل من \n    * الأعداد الصحيحة الثلاثة a و b و c، تكون البواقي متساوية.\n    * المدخلات: ثلاثة أعداد صحيحة موجبة a و b و c، كل منها لا يتجاوز 1,000,000.\n    * المخرجات: يعيد أصغر قيمة صحيحة لـ x التي تحقق الشرط.\n    * مثال: لـ a = 300، b = 262، c = 205، تعيد الدالة 19.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)",
      "sw": "<?php\n\n/**\n    * Inapata mgawanyiko mdogo zaidi wa nambari nzima kuliko 1 ambao unatoa baki sawa wakati wa kugawa nambari tatu zilizotolewa.\n    * Shida hii inahusisha kutafuta thamani ya chini ya x (ambapo x > 1) ili kwamba x ikigawa kila moja ya \n    * nambari tatu a, b, na c, mabaki ni sawa.\n    * Ingizo: Nambari tatu chanya a, b, na c, kila moja haizidi 1,000,000.\n    * Matokeo: Inarudisha thamani ndogo zaidi ya x ambayo inakidhi hali hiyo.\n    * Mfano: Kwa a = 300, b = 262, c = 205, kazi inarudisha 19.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)",
      "tr": "<?php\n\n/**\n    * Üç verilen sayı bölündüğünde aynı kalanı veren 1'den büyük en küçük tam sayı bölenini bulur.\n    * Bu problem, x > 1 olacak şekilde x'in minimum değerini bulmayı içerir, öyle ki x, \n    * üç tam sayı a, b ve c'yi böldüğünde kalanlar aynı olur.\n    * Girdi: Her biri 1.000.000'u aşmayan üç pozitif tam sayı a, b ve c.\n    * Çıktı: Koşulu sağlayan en küçük tam sayı x değerini döndürür.\n    * Örnek: a = 300, b = 262, c = 205 için, fonksiyon 19 döndürür.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)",
      "vi": "<?php\n\n/**\n    * Tìm ước số nguyên nhỏ nhất lớn hơn 1 mà cho cùng một số dư khi chia ba số đã cho.\n    * Vấn đề này liên quan đến việc tìm giá trị nhỏ nhất của x (với x > 1) sao cho khi x chia mỗi \n    * ba số nguyên a, b và c, các số dư là giống nhau.\n    * Đầu vào: Ba số nguyên dương a, b và c, mỗi số không vượt quá 1,000,000.\n    * Đầu ra: Trả về giá trị nguyên nhỏ nhất của x thỏa mãn điều kiện.\n    * Ví dụ: Với a = 300, b = 262, c = 205, hàm trả về 19.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)"
    },
    "prompt_bertscore": {
      "es": "0.9974595174265638",
      "arb": "0.9914495579875912",
      "sw": "0.9702445730298307",
      "tr": "0.9563023093242298",
      "vi": "0.9795472282952186"
    },
    "canonical_solution": " {\n    $minDiff = min(abs($a - $b), abs($b - $c), abs($c - $a));\n\n    for ($x = 2; $x <= $minDiff; $x++) {\n        if ($a % $x === $b % $x && $b % $x === $c % $x) {\n            return $x;\n        }\n    }\n\n    // In case no common divisor is found, which should not happen as per the problem's guarantee.\n    return -1;\n}",
    "instruction": {
      "en": "Write a PHP function `function findMinimumDivisor($a, $b, $c)` to solve the following problem:\nFinds the smallest integer divisor greater than 1 that yields the same remainder when dividing three given numbers.\nThis problem involves finding the minimum value of x (where x > 1) such that when x divides each of the\nthree integers a, b, and c, the remainders are the same.\nInput: Three positive integers a, b, and c, each not exceeding 1,000,000.\nOutput: Returns the smallest integer value of x that satisfies the condition.\nExample: For a = 300, b = 262, c = 205, the function returns 19.",
      "es": "Escribe una función PHP `function findMinimumDivisor($a, $b, $c)` para resolver el siguiente problema:\nEncuentra el divisor entero más pequeño mayor que 1 que produce el mismo residuo al dividir tres números dados.\nEste problema implica encontrar el valor mínimo de x (donde x > 1) tal que cuando x divide cada uno de los\ntres enteros a, b y c, los residuos son los mismos.\nEntrada: Tres enteros positivos a, b y c, cada uno no excediendo 1,000,000.\nSalida: Devuelve el valor entero más pequeño de x que satisface la condición.\nEjemplo: Para a = 300, b = 262, c = 205, la función devuelve 19.",
      "arb": "اكتب دالة PHP `function findMinimumDivisor($a, $b, $c)` لحل المشكلة التالية:\nتجد أصغر مقسوم صحيح أكبر من 1 يعطي نفس الباقي عند قسمة ثلاثة أعداد معطاة.\nتتضمن هذه المشكلة إيجاد القيمة الدنيا لـ x (حيث x > 1) بحيث عندما يقسم x كل من الأعداد الصحيحة الثلاثة a و b و c، تكون البواقي متساوية.\nالمدخلات: ثلاثة أعداد صحيحة موجبة a و b و c، كل منها لا يتجاوز 1,000,000.\nالمخرجات: تعيد أصغر قيمة صحيحة لـ x تحقق الشرط.\nمثال: لـ a = 300، b = 262، c = 205، تعيد الدالة 19.",
      "sw": "Andika kazi ya PHP `function findMinimumDivisor($a, $b, $c)` kutatua tatizo lifuatalo:\nInapata mgawanyiko mdogo zaidi wa nambari nzima zaidi ya 1 ambao unatoa baki sawa wakati wa kugawa nambari tatu zilizotolewa.\nTatizo hili linahusisha kupata thamani ndogo ya x (ambapo x > 1) ili kwamba x inagawanya kila moja ya\nnambari tatu a, b, na c, mabaki ni sawa.\nIngizo: Nambari tatu chanya a, b, na c, kila moja haizidi 1,000,000.\nMatokeo: Inarudisha thamani ndogo zaidi ya x ambayo inakidhi sharti.\nMfano: Kwa a = 300, b = 262, c = 205, kazi inarudisha 19.",
      "tr": "Bir PHP fonksiyonu `function findMinimumDivisor($a, $b, $c)` yazın ve aşağıdaki problemi çözün:\nÜç verilen sayıyı bölerken aynı kalanı veren 1'den büyük en küçük tam sayı bölenini bulun.\nBu problem, x > 1 olan x'in minimum değerini bulmayı içerir, öyle ki x, a, b ve c üç tam sayısının her birini böldüğünde kalanı aynı olur.\nGirdi: Her biri 1.000.000'u aşmayan üç pozitif tam sayı a, b ve c.\nÇıktı: Koşulu sağlayan x'in en küçük tam sayı değerini döndürür.\nÖrnek: a = 300, b = 262, c = 205 için fonksiyon 19 döner.",
      "vi": "Viết một hàm PHP `function findMinimumDivisor($a, $b, $c)` để giải quyết vấn đề sau:\nTìm ước số nguyên nhỏ nhất lớn hơn 1 mà cho cùng một số dư khi chia ba số đã cho.\nVấn đề này liên quan đến việc tìm giá trị nhỏ nhất của x (với x > 1) sao cho khi x chia mỗi\nba số nguyên a, b và c, các số dư là giống nhau.\nĐầu vào: Ba số nguyên dương a, b và c, mỗi số không vượt quá 1,000,000.\nĐầu ra: Trả về giá trị nguyên nhỏ nhất của x thỏa mãn điều kiện.\nVí dụ: Với a = 300, b = 262, c = 205, hàm trả về 19."
    },
    "instruction_bertscore": {
      "es": "0.9914064551949066",
      "arb": "0.9900321315885262",
      "sw": "0.9679783990126036",
      "tr": "0.9645996962312001",
      "vi": "0.979953626054816"
    },
    "level": "easy",
    "test": "function main(){\n    assert(findMinimumDivisor(300, 262, 205) === 19);\n    assert(findMinimumDivisor(100, 200, 300) === 2);\n    assert(findMinimumDivisor(15, 25, 35) === 2);\n    assert(findMinimumDivisor(7, 14, 21) === 7);\n    assert(findMinimumDivisor(9, 18, 27) === 3);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "findMinimumDivisor",
    "signature": "function findMinimumDivisor($a, $b, $c)",
    "docstring": {
      "en": "Finds the smallest integer divisor greater than 1 that yields the same remainder when dividing three given numbers.\nThis problem involves finding the minimum value of x (where x > 1) such that when x divides each of the\nthree integers a, b, and c, the remainders are the same.\nInput: Three positive integers a, b, and c, each not exceeding 1,000,000.\nOutput: Returns the smallest integer value of x that satisfies the condition.\nExample: For a = 300, b = 262, c = 205, the function returns 19.",
      "es": "Encuentra el divisor entero más pequeño mayor que 1 que produce el mismo residuo al dividir tres números dados.\nEste problema implica encontrar el valor mínimo de x (donde x > 1) tal que cuando x divide cada uno de los\ntres enteros a, b y c, los residuos sean los mismos.\nEntrada: Tres enteros positivos a, b y c, cada uno no excede 1,000,000.\nSalida: Devuelve el valor entero más pequeño de x que satisface la condición.\nEjemplo: Para a = 300, b = 262, c = 205, la función devuelve 19.",
      "arb": "يجد أصغر مقسوم صحيح أكبر من 1 الذي يعطي نفس الباقي عند قسمة ثلاثة أعداد معطاة.\nتتضمن هذه المشكلة إيجاد القيمة الدنيا لـ x (حيث x > 1) بحيث عندما يقسم x كل من الأعداد الصحيحة الثلاثة a و b و c، تكون البواقي متساوية.\nالمدخلات: ثلاثة أعداد صحيحة موجبة a و b و c، كل منها لا يتجاوز 1,000,000.\nالمخرجات: يعيد أصغر قيمة صحيحة لـ x تحقق الشرط.\nمثال: لـ a = 300 و b = 262 و c = 205، تعيد الدالة 19.",
      "sw": "Inapata mgawanyiko mdogo zaidi wa nambari nzima zaidi ya 1 ambao unatoa baki sawa wakati wa kugawa nambari tatu zilizotolewa. \n\nInasuluhisha tatizo la kutafuta thamani ndogo zaidi ya x (ambapo x > 1) kiasi kwamba x inapogawa kila moja ya namba tatu a, b, na c, mabaki yanakuwa sawa.\n\nHoja:\n    a: Nambari tatu za mzima chanya a, b, na c, kila moja haizidi 1,000,000.\n\nInarejesha:\n    Inarudisha thamani ndogo zaidi ya x ya mzima inayokidhi sharti.\n\nMifano:\n    Kwa a = 300, b = 262, c = 205, kazi inarudisha 19.",
      "tr": "Üç verilen sayıyı bölerken aynı kalanı veren 1'den büyük en küçük tam sayı bölenini bulur.\nBu problem, a, b ve c üç tam sayısını böldüğünde kalanların aynı olduğu en küçük x değerini (x > 1) bulmayı içerir.\nGirdi: Her biri 1.000.000'u geçmeyen üç pozitif tam sayı a, b ve c.\nÇıktı: Koşulu sağlayan en küçük x tam sayı değerini döndürür.\nÖrnek: a = 300, b = 262, c = 205 için, fonksiyon 19 döndürür.",
      "vi": "Tìm ước số nguyên nhỏ nhất lớn hơn 1 mà cho cùng một số dư khi chia ba số đã cho.  \nVấn đề này liên quan đến việc tìm giá trị nhỏ nhất của x (với x > 1) sao cho khi x chia mỗi  \nba số nguyên a, b và c, các số dư là như nhau.  \nĐầu vào: Ba số nguyên dương a, b và c, mỗi số không vượt quá 1.000.000.  \nĐầu ra: Trả về giá trị nguyên nhỏ nhất của x thỏa mãn điều kiện.  \nVí dụ: Với a = 300, b = 262, c = 205, hàm trả về 19."
    },
    "docstring_bertscore": {
      "es": "0.9917131405032245",
      "arb": "0.9827110130043423",
      "sw": "0.950046246843155",
      "tr": "0.9627718994649171",
      "vi": "0.9786241929145495"
    }
  },
  {
    "task_id": "PHP/28",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Calculates the minimum number of apples required to be distributed among children.\n * Each child should receive a different number of apples and every child must receive at least one apple.\n * The total count of children is a positive integer not greater than 1000.\n * Input: An integer representing the number of children.\n * Output: An integer representing the minimum number of apples required.\n */\n\n function minimumApplesForChildren(int $childrenCount): int ",
      "es": "<?php\n\n\n/**\n * Calcula el número mínimo de manzanas que se deben distribuir entre los niños.\n * Cada niño debe recibir un número diferente de manzanas y cada niño debe recibir al menos una manzana.\n * El número total de niños es un entero positivo no mayor que 1000.\n * Entrada: Un entero que representa el número de niños.\n * Salida: Un entero que representa el número mínimo de manzanas requeridas.\n */\n\n function minimumApplesForChildren(int $childrenCount): int ",
      "arb": "<?php\n\n\n/**\n * يحسب الحد الأدنى لعدد التفاح المطلوب توزيعه بين الأطفال.\n * يجب أن يحصل كل طفل على عدد مختلف من التفاح ويجب أن يحصل كل طفل على تفاحة واحدة على الأقل.\n * العدد الإجمالي للأطفال هو عدد صحيح موجب لا يزيد عن 1000.\n * المدخل: عدد صحيح يمثل عدد الأطفال.\n * المخرج: عدد صحيح يمثل الحد الأدنى لعدد التفاح المطلوب.\n */\n\n function minimumApplesForChildren(int $childrenCount): int ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi ndogo ya tufaha zinazohitajika kugawanywa kwa watoto.\n * Kila mtoto anapaswa kupokea idadi tofauti ya tufaha na kila mtoto lazima apokee angalau tufaha moja.\n * Jumla ya idadi ya watoto ni nambari chanya isiyozidi 1000.\n * Ingizo: Nambari ya mzima inayowakilisha idadi ya watoto.\n * Tokeo: Nambari ya mzima inayowakilisha idadi ndogo ya tufaha zinazohitajika.\n */\n\n function minimumApplesForChildren(int $childrenCount): int ",
      "tr": "<?php\n\n\n/**\n * Çocuklar arasında dağıtılması gereken minimum elma sayısını hesaplar.\n * Her çocuk farklı sayıda elma almalı ve her çocuk en az bir elma almalıdır.\n * Toplam çocuk sayısı 1000'den büyük olmayan pozitif bir tam sayıdır.\n * Girdi: Çocuk sayısını temsil eden bir tam sayı.\n * Çıktı: Gerekli minimum elma sayısını temsil eden bir tam sayı.\n */\n\n function minimumApplesForChildren(int $childrenCount): int ",
      "vi": "<?php\n\n\n/**\n * Tính toán số lượng táo tối thiểu cần được phân phát cho trẻ em.\n * Mỗi đứa trẻ nên nhận một số lượng táo khác nhau và mỗi đứa trẻ phải nhận ít nhất một quả táo.\n * Tổng số trẻ em là một số nguyên dương không lớn hơn 1000.\n * Đầu vào: Một số nguyên đại diện cho số lượng trẻ em.\n * Đầu ra: Một số nguyên đại diện cho số lượng táo tối thiểu cần thiết.\n */\n\n function minimumApplesForChildren(int $childrenCount): int "
    },
    "prompt_bertscore": {
      "es": "0.9794389747375546",
      "arb": "0.9808850039114886",
      "sw": "0.9755934905607192",
      "tr": "0.980687962573502",
      "vi": "0.977795705595253"
    },
    "canonical_solution": "{\n    // Sum of first n natural numbers\n    return ($childrenCount * ($childrenCount + 1)) / 2;\n}",
    "instruction": {
      "en": "Write a PHP function `function minimumApplesForChildren(int $childrenCount): int` to solve the following problem:\nCalculates the minimum number of apples required to be distributed among children.\nEach child should receive a different number of apples and every child must receive at least one apple.\nThe total count of children is a positive integer not greater than 1000.\nInput: An integer representing the number of children.\nOutput: An integer representing the minimum number of apples required.",
      "es": "Escribe una función PHP `function minimumApplesForChildren(int $childrenCount): int` para resolver el siguiente problema:\nCalcula el número mínimo de manzanas que se deben distribuir entre los niños.\nCada niño debe recibir un número diferente de manzanas y cada niño debe recibir al menos una manzana.\nEl número total de niños es un entero positivo no mayor que 1000.\nEntrada: Un entero que representa el número de niños.\nSalida: Un entero que representa el número mínimo de manzanas requeridas.",
      "arb": "اكتب دالة PHP `function minimumApplesForChildren(int $childrenCount): int` لحل المشكلة التالية:\nتحسب الحد الأدنى لعدد التفاح المطلوب توزيعه بين الأطفال.\nيجب أن يحصل كل طفل على عدد مختلف من التفاح ويجب أن يحصل كل طفل على تفاحة واحدة على الأقل.\nإجمالي عدد الأطفال هو عدد صحيح موجب لا يزيد عن 1000.\nالمدخل: عدد صحيح يمثل عدد الأطفال.\nالمخرج: عدد صحيح يمثل الحد الأدنى لعدد التفاح المطلوب.",
      "sw": "Andika kazi ya PHP `function minimumApplesForChildren(int $childrenCount): int` kutatua tatizo lifuatalo:\nHesabu idadi ndogo zaidi ya maapulo yanayohitajika kugawiwa kati ya watoto.\nKila mtoto anapaswa kupokea idadi tofauti ya maapulo na kila mtoto lazima apokee angalau tunda moja la apulo.\nJumla ya idadi ya watoto ni namba chanya isiyozidi 1000.\nIngizo: Nambari inayowakilisha idadi ya watoto.\nMatokeo: Nambari inayowakilisha idadi ndogo zaidi ya maapulo yanayohitajika.",
      "tr": "Bir PHP fonksiyonu `function minimumApplesForChildren(int $childrenCount): int` yazın. Aşağıdaki problemi çözmek için:\nÇocuklar arasında dağıtılması gereken minimum elma sayısını hesaplar.\nHer çocuk farklı sayıda elma almalı ve her çocuk en az bir elma almalıdır.\nToplam çocuk sayısı 1000'den büyük olmayan pozitif bir tam sayıdır.\nGirdi: Çocuk sayısını temsil eden bir tam sayı.\nÇıktı: Gerekli minimum elma sayısını temsil eden bir tam sayı.",
      "vi": "Viết một hàm PHP `function minimumApplesForChildren(int $childrenCount): int` để giải quyết vấn đề sau:\nTính toán số lượng táo tối thiểu cần được phân phát cho trẻ em.\nMỗi đứa trẻ nên nhận một số lượng táo khác nhau và mỗi đứa trẻ phải nhận ít nhất một quả táo.\nTổng số trẻ em là một số nguyên dương không lớn hơn 1000.\nĐầu vào: Một số nguyên đại diện cho số lượng trẻ em.\nĐầu ra: Một số nguyên đại diện cho số lượng táo tối thiểu cần thiết."
    },
    "instruction_bertscore": {
      "es": "0.9793718376687648",
      "arb": "0.9782463979298212",
      "sw": "0.9698266547081332",
      "tr": "0.9697754080698262",
      "vi": "0.9790411180843417"
    },
    "level": "easy",
    "test": "function main(){\n    assert(minimumApplesForChildren(1) === 1);\n    assert(minimumApplesForChildren(2) === 3);\n    assert(minimumApplesForChildren(3) === 6);\n    assert(minimumApplesForChildren(8) === 36);\n    assert(minimumApplesForChildren(10) === 55);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "minimumApplesForChildren",
    "signature": "function minimumApplesForChildren(int $childrenCount): int",
    "docstring": {
      "en": "Calculates the minimum number of apples required to be distributed among children.\nEach child should receive a different number of apples and every child must receive at least one apple.\nThe total count of children is a positive integer not greater than 1000.\nInput: An integer representing the number of children.\nOutput: An integer representing the minimum number of apples required.",
      "es": "Calcula el número mínimo de manzanas que se deben distribuir entre los niños.  \nCada niño debe recibir un número diferente de manzanas y cada niño debe recibir al menos una manzana.  \nEl número total de niños es un entero positivo no mayor que 1000.  \nEntrada: Un entero que representa el número de niños.  \nSalida: Un entero que representa el número mínimo de manzanas requeridas.",
      "arb": "يحسب الحد الأدنى لعدد التفاح المطلوب توزيعه بين الأطفال.\nيجب أن يتلقى كل طفل عددًا مختلفًا من التفاح ويجب أن يتلقى كل طفل تفاحة واحدة على الأقل.\nإجمالي عدد الأطفال هو عدد صحيح موجب لا يزيد عن 1000.\nالمدخلات: عدد صحيح يمثل عدد الأطفال.\nالمخرجات: عدد صحيح يمثل الحد الأدنى لعدد التفاح المطلوب.",
      "sw": "Hesabu idadi ndogo ya tufaha zinazohitajika kugawanywa kwa watoto.\nKila mtoto anapaswa kupokea idadi tofauti ya tufaha na kila mtoto lazima apokee angalau tufaha moja.\nJumla ya idadi ya watoto ni nambari chanya isiyozidi 1000.\nIngizo: Nambari ya mzima inayowakilisha idadi ya watoto.\nPato: Nambari ya mzima inayowakilisha idadi ndogo ya tufaha zinazohitajika.",
      "tr": "Çocuklar arasında dağıtılması gereken minimum elma sayısını hesaplar.\nHer çocuk farklı sayıda elma almalı ve her çocuk en az bir elma almalıdır.\nÇocukların toplam sayısı 1000'den büyük olmayan pozitif bir tam sayıdır.\nGirdi: Çocuk sayısını temsil eden bir tam sayı.\nÇıktı: Gerekli minimum elma sayısını temsil eden bir tam sayı.",
      "vi": "Tính toán số lượng táo tối thiểu cần được phân phát cho trẻ em.  \nMỗi trẻ em nên nhận số lượng táo khác nhau và mỗi trẻ em phải nhận ít nhất một quả táo.  \nTổng số trẻ em là một số nguyên dương không lớn hơn 1000.  \nĐầu vào: Một số nguyên đại diện cho số lượng trẻ em.  \nĐầu ra: Một số nguyên đại diện cho số lượng táo tối thiểu cần thiết."
    },
    "docstring_bertscore": {
      "es": "0.9698004354978367",
      "arb": "0.9695217570732447",
      "sw": "0.9598909644183871",
      "tr": "0.9630777902517108",
      "vi": "0.9649028061926594"
    }
  },
  {
    "task_id": "PHP/29",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Finds the nth digit after the decimal point in the decimal representation of the fraction a/b.\n * The function takes three integers as input: a (numerator), b (denominator), and n (position of the digit after the decimal point).\n * Conditions: 0 < a < b < 100, 1 <= n <= 10000.\n * The function calculates the decimal representation of a/b and returns the nth digit after the decimal point.\n * \n * Example:\n * Input: a = 1, b = 2, n = 1\n * Output: 5 (since 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int",
      "es": "<?php\n\n\n/**\n * Encuentra el enésimo dígito después del punto decimal en la representación decimal de la fracción a/b.\n * La función toma tres enteros como entrada: a (numerador), b (denominador), y n (posición del dígito después del punto decimal).\n * Condiciones: 0 < a < b < 100, 1 <= n <= 10000.\n * La función calcula la representación decimal de a/b y devuelve el enésimo dígito después del punto decimal.\n * \n * Ejemplo:\n * Entrada: a = 1, b = 2, n = 1\n * Salida: 5 (ya que 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int",
      "arb": "<?php\n\n\n/**\n * يجد الرقم العاشر بعد الفاصلة العشرية في التمثيل العشري للكسر a/b.\n * تأخذ الدالة ثلاثة أعداد صحيحة كمدخل: a (البسط)، b (المقام)، و n (موضع الرقم بعد الفاصلة العشرية).\n * الشروط: 0 < a < b < 100, 1 <= n <= 10000.\n * تقوم الدالة بحساب التمثيل العشري لـ a/b وتعيد الرقم العاشر بعد الفاصلة العشرية.\n * \n * مثال:\n * المدخلات: a = 1, b = 2, n = 1\n * الناتج: 5 (since 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int",
      "sw": "<?php\n\n\n/**\n * Inapata tarakimu ya n baada ya nukta katika uwakilishi wa desimali wa sehemu a/b.\n * Kazi inachukua nambari tatu kama pembejeo: a (kizidishi), b (mgawanyiko), na n (nafasi ya tarakimu baada ya nukta ya desimali).\n * Masharti: 0 < a < b < 100, 1 <= n <= 10000.\n * Kazi inahesabu uwakilishi wa desimali wa a/b na kurudisha tarakimu ya n baada ya nukta ya desimali.\n * \n * Mfano:\n * Ingizo: a = 1, b = 2, n = 1\n * Matokeo: 5 (kwa kuwa 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int",
      "tr": "<?php\n\n\n/**\n * Kesir a/b'nin ondalık gösteriminde ondalık noktadan sonraki n. basamağı bulur.\n * Fonksiyon, üç tam sayı alır: a (pay), b (payda) ve n (ondalık noktadan sonraki basamağın konumu).\n * Koşullar: 0 < a < b < 100, 1 <= n <= 10000.\n * Fonksiyon, a/b'nin ondalık gösterimini hesaplar ve ondalık noktadan sonraki n. basamağı döndürür.\n * \n * Örnek:\n * Girdi: a = 1, b = 2, n = 1\n * Çıktı: 5 (çünkü 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int",
      "vi": "<?php\n\n\n/**\n * Tìm chữ số thứ n sau dấu thập phân trong biểu diễn thập phân của phân số a/b.\n * Hàm nhận ba số nguyên làm đầu vào: a (tử số), b (mẫu số), và n (vị trí của chữ số sau dấu thập phân).\n * Điều kiện: 0 < a < b < 100, 1 <= n <= 10000.\n * Hàm tính toán biểu diễn thập phân của a/b và trả về chữ số thứ n sau dấu thập phân.\n * \n * Ví dụ:\n * Đầu vào: a = 1, b = 2, n = 1\n * Đầu ra: 5 (vì 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9881137593684912",
      "tr": "0.9841864394746694",
      "vi": "0.991266023515515"
    },
    "canonical_solution": "  {\n    if ($a <= 0 || $a >= $b || $b >= 100 || $n < 1 || $n > 10000) {\n        // Handle invalid input\n        return -1;\n    }\n\n    $decimal = $a / $b;\n    $decimalString = (string)$decimal;\n    $decimalPointPosition = strpos($decimalString, '.');\n\n    if ($decimalPointPosition === false || $decimalPointPosition + $n >= strlen($decimalString)) {\n        // Decimal point not found or n is beyond the length of the decimal part\n        return -1;\n    }\n\n    return (int)$decimalString[$decimalPointPosition + $n];\n}",
    "instruction": {
      "en": "Write a PHP function `function getDecimalDigit($a, $b, $n): int` to solve the following problem:\nFinds the nth digit after the decimal point in the decimal representation of the fraction a/b.\nThe function takes three integers as input: a (numerator), b (denominator), and n (position of the digit after the decimal point).\nConditions: 0 < a < b < 100, 1 <= n <= 10000.\nThe function calculates the decimal representation of a/b and returns the nth digit after the decimal point.\n\nExample:\nInput: a = 1, b = 2, n = 1\nOutput: 5 (since 1/2 = 0.5)",
      "es": "Escribe una función PHP `function getDecimalDigit($a, $b, $n): int` para resolver el siguiente problema:\nEncuentra el enésimo dígito después del punto decimal en la representación decimal de la fracción a/b.\nLa función toma tres enteros como entrada: a (numerador), b (denominador), y n (posición del dígito después del punto decimal).\nCondiciones: 0 < a < b < 100, 1 <= n <= 10000.\nLa función calcula la representación decimal de a/b y devuelve el enésimo dígito después del punto decimal.\n\nEjemplo:\nEntrada: a = 1, b = 2, n = 1\nSalida: 5 (ya que 1/2 = 0.5)",
      "arb": "اكتب دالة PHP `function getDecimalDigit($a, $b, $n): int` لحل المشكلة التالية:\nتجد الرقم n بعد الفاصلة العشرية في التمثيل العشري للكسر a/b.\nتأخذ الدالة ثلاثة أعداد صحيحة كمدخلات: a (البسط)، b (المقام)، و n (موضع الرقم بعد الفاصلة العشرية).\nالشروط: 0 < a < b < 100، 1 <= n <= 10000.\nتحسب الدالة التمثيل العشري لـ a/b وتعيد الرقم n بعد الفاصلة العشرية.\n\nمثال:\nالمدخلات: a = 1، b = 2، n = 1\nالمخرجات: 5 (لأن 1/2 = 0.5)",
      "sw": "Andika kazi ya PHP `function getDecimalDigit($a, $b, $n): int` kutatua tatizo lifuatalo:\nInapata tarakimu ya n baada ya nukta katika uwakilishi wa desimali wa sehemu a/b.\nKazi inachukua namba tatu kama pembejeo: a (kizidishi), b (mgawanyiko), na n (nafasi ya tarakimu baada ya nukta).\nMasharti: 0 < a < b < 100, 1 <= n <= 10000.\nKazi inahesabu uwakilishi wa desimali wa a/b na inarudisha tarakimu ya n baada ya nukta.\n\nMfano:\nPembejeo: a = 1, b = 2, n = 1\nMatokeo: 5 (kwa kuwa 1/2 = 0.5)",
      "tr": "Bir PHP fonksiyonu `function getDecimalDigit($a, $b, $n): int` yazın ve aşağıdaki problemi çözün:\na/b kesirinin ondalık gösteriminde ondalık noktadan sonraki n. basamağı bulur.\nFonksiyon, üç tam sayı alır: a (pay), b (payda) ve n (ondalık noktadan sonraki basamağın konumu).\nKoşullar: 0 < a < b < 100, 1 <= n <= 10000.\nFonksiyon, a/b'nin ondalık gösterimini hesaplar ve ondalık noktadan sonraki n. basamağı döndürür.\n\nÖrnek:\nGirdi: a = 1, b = 2, n = 1\nÇıktı: 5 (çünkü 1/2 = 0.5)",
      "vi": "Viết một hàm PHP `function getDecimalDigit($a, $b, $n): int` để giải quyết vấn đề sau:\nTìm chữ số thứ n sau dấu thập phân trong biểu diễn thập phân của phân số a/b.\nHàm nhận ba số nguyên làm đầu vào: a (tử số), b (mẫu số), và n (vị trí của chữ số sau dấu thập phân).\nĐiều kiện: 0 < a < b < 100, 1 <= n <= 10000.\nHàm tính toán biểu diễn thập phân của a/b và trả về chữ số thứ n sau dấu thập phân.\n\nVí dụ:\nĐầu vào: a = 1, b = 2, n = 1\nĐầu ra: 5 (vì 1/2 = 0.5)"
    },
    "instruction_bertscore": {
      "es": "0.9961894747702267",
      "arb": "0.9845980016241738",
      "sw": "0.9850614063031281",
      "tr": "0.9808774559570093",
      "vi": "0.9926725252436229"
    },
    "level": "middle",
    "test": "function main(){\n    assert(getDecimalDigit(1, 2, 1) === 5);\n    assert(getDecimalDigit(1, 3, 1) === 3);\n    assert(getDecimalDigit(1, 4, 2) === 5);\n    assert(getDecimalDigit(3, 7, 3) === 8);\n    assert(getDecimalDigit(50, 99, 4) === 0);   \n}\n\n\nmain();\n?>",
    "entry_point": "getDecimalDigit",
    "signature": "function getDecimalDigit($a, $b, $n): int",
    "docstring": {
      "en": "Finds the nth digit after the decimal point in the decimal representation of the fraction a/b.\nThe function takes three integers as input: a (numerator), b (denominator), and n (position of the digit after the decimal point).\nConditions: 0 < a < b < 100, 1 <= n <= 10000.\nThe function calculates the decimal representation of a/b and returns the nth digit after the decimal point.\n\nExample:\nInput: a = 1, b = 2, n = 1\nOutput: 5 (since 1/2 = 0.5)",
      "es": "Encuentra el enésimo dígito después del punto decimal en la representación decimal de la fracción a/b.  \nLa función toma tres enteros como entrada: a (numerador), b (denominador), y n (posición del dígito después del punto decimal).  \nCondiciones: 0 < a < b < 100, 1 <= n <= 10000.  \nLa función calcula la representación decimal de a/b y devuelve el enésimo dígito después del punto decimal.\n\nEjemplo:  \nEntrada: a = 1, b = 2, n = 1  \nSalida: 5 (ya que 1/2 = 0.5)",
      "arb": "يجد الرقم n بعد العلامة العشرية في التمثيل العشري للكسر a/b.\nتأخذ الدالة ثلاثة أعداد صحيحة كمدخلات: a (البسط), b (المقام), و n (موضع الرقم بعد العلامة العشرية).\nالشروط: 0 < a < b < 100, 1 <= n <= 10000.\nتحسب الدالة التمثيل العشري لـ a/b وتعيد الرقم n بعد العلامة العشرية.\n\nمثال:\nالمدخل: a = 1, b = 2, n = 1\nالمخرج: 5 (لأن 1/2 = 0.5)",
      "sw": "Inapata tarakimu ya n baada ya nukta katika uwakilishi wa desimali wa sehemu a/b.  \nKazi inachukua nambari tatu za mzima kama pembejeo: a (kizidishi), b (mgawanyiko), na n (nafasi ya tarakimu baada ya nukta ya desimali).  \nMasharti: 0 < a < b < 100, 1 <= n <= 10000.  \nKazi inahesabu uwakilishi wa desimali wa a/b na inarudisha tarakimu ya n baada ya nukta ya desimali.\n\nMfano:  \nPembejeo: a = 1, b = 2, n = 1  \nMatokeo: 5 (kwa kuwa 1/2 = 0.5)",
      "tr": "Ondalık kesir a/b'nin ondalık temsilinde ondalık noktadan sonraki n'inci basamağı bulur.\nFonksiyon, üç tam sayı alır: a (pay), b (payda) ve n (ondalık noktadan sonraki basamağın konumu).\nKoşullar: 0 < a < b < 100, 1 <= n <= 10000.\nFonksiyon, a/b'nin ondalık temsilini hesaplar ve ondalık noktadan sonraki n'inci basamağı döndürür.\n\nÖrnek:\nGirdi: a = 1, b = 2, n = 1\nÇıktı: 5 (çünkü 1/2 = 0.5)",
      "vi": "Tìm chữ số thứ n sau dấu thập phân trong biểu diễn thập phân của phân số a/b.  \nHàm nhận ba số nguyên làm đầu vào: a (tử số), b (mẫu số), và n (vị trí của chữ số sau dấu thập phân).  \nĐiều kiện: 0 < a < b < 100, 1 <= n <= 10000.  \nHàm tính toán biểu diễn thập phân của a/b và trả về chữ số thứ n sau dấu thập phân.\n\nVí dụ:  \nĐầu vào: a = 1, b = 2, n = 1  \nĐầu ra: 5 (vì 1/2 = 0.5)"
    },
    "docstring_bertscore": {
      "es": "0.9920821957511873",
      "arb": "0.9881300470597362",
      "sw": "0.9731203436864537",
      "tr": "0.9823089851131277",
      "vi": "0.9868552372742542"
    }
  },
  {
    "task_id": "PHP/30",
    "prompt": {
      "en": "<?php\n/**\n * Solves the Josephus Problem.\n * In this problem, N people are arranged in a circle and eliminated in every Mth position\n * until only one person remains. The function simulates this process and returns the order\n * in which people are eliminated.\n * \n * For example, with N = 8 and M = 5, the elimination order is 5, 2, 8, 7, 1, 4, 6, 3.\n * \n * Input: Two integers, N (number of people in the circle) and M (the elimination step).\n * Output: Returns an array representing the order in which people are eliminated.\n */\n\nfunction josephusProblem($n, $m) ",
      "es": "<?php\n/**\n * Resuelve el Problema de Josephus.\n * En este problema, N personas están dispuestas en un círculo y se eliminan en cada M-ésima posición\n * hasta que solo queda una persona. La función simula este proceso y devuelve el orden\n * en el que las personas son eliminadas.\n * \n * Por ejemplo, con N = 8 y M = 5, el orden de eliminación es 5, 2, 8, 7, 1, 4, 6, 3.\n * \n * Entrada: Dos enteros, N (número de personas en el círculo) y M (el paso de eliminación).\n * Salida: Devuelve un arreglo que representa el orden en el que las personas son eliminadas.\n */\n\nfunction josephusProblem($n, $m) ",
      "arb": "<?php\n/**\n * يحل مشكلة جوزيفوس.\n * في هذه المشكلة، يتم ترتيب N شخصًا في دائرة ويتم إقصاؤهم في كل موضع M حتى يبقى شخص واحد فقط.\n * تحاكي الدالة هذه العملية وتعيد الترتيب الذي يتم فيه إقصاء الأشخاص.\n * \n * على سبيل المثال، مع N = 8 و M = 5، يكون ترتيب الإقصاء هو 5، 2، 8، 7، 1، 4، 6، 3.\n * \n * المدخلات: عددان صحيحان، N (عدد الأشخاص في الدائرة) و M (خطوة الإقصاء).\n * المخرجات: تعيد مصفوفة تمثل الترتيب الذي يتم فيه إقصاء الأشخاص.\n */\n\nfunction josephusProblem($n, $m) ",
      "sw": "<?php\n/**\n * Hutatua Tatizo la Josephus.\n * Katika tatizo hili, watu N wamepangwa katika mduara na kuondolewa katika kila nafasi ya M\n * mpaka mtu mmoja tu abaki. Kazi hii inaiga mchakato huu na kurudisha mpangilio\n * ambao watu wanaondolewa.\n * \n * Kwa mfano, ikiwa N = 8 na M = 5, mpangilio wa kuondolewa ni 5, 2, 8, 7, 1, 4, 6, 3.\n * \n * Ingizo: Nambari mbili, N (idadi ya watu katika mduara) na M (hatua ya kuondolewa).\n * Matokeo: Inarudisha safu inayowakilisha mpangilio ambao watu wanaondolewa.\n */\n\nfunction josephusProblem($n, $m) ",
      "tr": "<?php\n/**\n * Josephus Problemini çözer.\n * Bu problemde, N kişi bir çemberde dizilir ve her M'inci pozisyonda \n * bir kişi elenir, sadece bir kişi kalana kadar bu süreç devam eder. \n * Fonksiyon bu süreci simüle eder ve kişilerin elenme sırasını döndürür.\n * \n * Örneğin, N = 8 ve M = 5 olduğunda, elenme sırası 5, 2, 8, 7, 1, 4, 6, 3 şeklindedir.\n * \n * Girdi: İki tamsayı, N (çemberdeki kişi sayısı) ve M (elenme adımı).\n * Çıktı: Kişilerin elenme sırasını temsil eden bir dizi döndürür.\n */\n\nfunction josephusProblem($n, $m) ",
      "vi": "<?php\n/**\n * Giải quyết Vấn đề Josephus.\n * Trong vấn đề này, N người được sắp xếp thành một vòng tròn và bị loại bỏ ở mỗi vị trí thứ M\n * cho đến khi chỉ còn lại một người. Hàm này mô phỏng quá trình này và trả về thứ tự\n * mà mọi người bị loại bỏ.\n * \n * Ví dụ, với N = 8 và M = 5, thứ tự loại bỏ là 5, 2, 8, 7, 1, 4, 6, 3.\n * \n * Đầu vào: Hai số nguyên, N (số người trong vòng tròn) và M (bước loại bỏ).\n * Đầu ra: Trả về một mảng đại diện cho thứ tự mà mọi người bị loại bỏ.\n */\n\nfunction josephusProblem($n, $m) "
    },
    "prompt_bertscore": {
      "es": "0.9836640415725477",
      "arb": "0.9759865800847872",
      "sw": "0.9773372666758244",
      "tr": "0.944626815526999",
      "vi": "0.9875748751447436"
    },
    "canonical_solution": "{\n    $people = range(1, $n);\n    $result = [];\n    $i = 0;\n\n    while (count($people) > 0) {\n        $i = ($i + $m - 1) % count($people);\n        $result[] = $people[$i];\n        array_splice($people, $i, 1);\n    }\n\n    return $result;\n}",
    "instruction": {
      "en": "Write a PHP function `function josephusProblem($n, $m)` to solve the following problem:\nSolves the Josephus Problem.\nIn this problem, N people are arranged in a circle and eliminated in every Mth position\nuntil only one person remains. The function simulates this process and returns the order\nin which people are eliminated.\n\nFor example, with N = 8 and M = 5, the elimination order is 5, 2, 8, 7, 1, 4, 6, 3.\n\nInput: Two integers, N (number of people in the circle) and M (the elimination step).\nOutput: Returns an array representing the order in which people are eliminated.",
      "es": "Escribe una función PHP `function josephusProblem($n, $m)` para resolver el siguiente problema:\nResuelve el Problema de Josephus.\nEn este problema, N personas están dispuestas en un círculo y se eliminan en cada posición M hasta que solo queda una persona. La función simula este proceso y devuelve el orden en el que las personas son eliminadas.\n\nPor ejemplo, con N = 8 y M = 5, el orden de eliminación es 5, 2, 8, 7, 1, 4, 6, 3.\n\nEntrada: Dos enteros, N (número de personas en el círculo) y M (el paso de eliminación).\nSalida: Devuelve un arreglo que representa el orden en el que las personas son eliminadas.",
      "arb": "اكتب دالة PHP `function josephusProblem($n, $m)` لحل المشكلة التالية:\nتحل مشكلة جوزيفوس.\nفي هذه المشكلة، يتم ترتيب N شخصًا في دائرة ويتم استبعادهم في كل موضع M حتى يبقى شخص واحد فقط. تحاكي الدالة هذه العملية وتعيد الترتيب الذي يتم فيه استبعاد الأشخاص.\n\nعلى سبيل المثال، مع N = 8 و M = 5، يكون ترتيب الاستبعاد هو 5، 2، 8، 7، 1، 4، 6، 3.\n\nالمدخلات: عددان صحيحان، N (عدد الأشخاص في الدائرة) و M (خطوة الاستبعاد).\nالمخرجات: تعيد مصفوفة تمثل الترتيب الذي يتم فيه استبعاد الأشخاص.",
      "sw": "Andika kazi ya PHP `function josephusProblem($n, $m)` kutatua tatizo lifuatalo:\nInatatua Tatizo la Josephus.\nKatika tatizo hili, watu N wamepangwa katika mduara na kuondolewa katika kila nafasi ya M\nmpaka mtu mmoja tu abaki. Kazi hii inaiga mchakato huu na kurudisha mpangilio\nambao watu wanaondolewa.\n\nKwa mfano, ikiwa N = 8 na M = 5, mpangilio wa kuondolewa ni 5, 2, 8, 7, 1, 4, 6, 3.\n\nIngizo: Nambari mbili za mzima, N (idadi ya watu katika mduara) na M (hatua ya kuondolewa).\nMatokeo: Inarudisha safu inayowakilisha mpangilio ambao watu wanaondolewa.",
      "tr": "Bir PHP fonksiyonu `function josephusProblem($n, $m)` yazın:\nJosephus Problemini çözer.\nBu problemde, N kişi bir daire şeklinde dizilir ve her M'inci pozisyonda bir kişi\nelimine edilir, ta ki sadece bir kişi kalana kadar. Fonksiyon bu süreci simüle eder ve\nkişilerin elendiği sırayı döndürür.\n\nÖrneğin, N = 8 ve M = 5 ile, eleme sırası 5, 2, 8, 7, 1, 4, 6, 3'tür.\n\nGirdi: İki tamsayı, N (dairedeki kişi sayısı) ve M (eleme adımı).\nÇıktı: Kişilerin elendiği sırayı temsil eden bir dizi döndürür.",
      "vi": "Viết một hàm PHP `function josephusProblem($n, $m)` để giải quyết vấn đề sau:\nGiải quyết Vấn đề Josephus.\nTrong vấn đề này, N người được sắp xếp thành một vòng tròn và bị loại bỏ ở mỗi vị trí thứ M\ncho đến khi chỉ còn lại một người. Hàm này mô phỏng quá trình này và trả về thứ tự\nmà mọi người bị loại bỏ.\n\nVí dụ, với N = 8 và M = 5, thứ tự loại bỏ là 5, 2, 8, 7, 1, 4, 6, 3.\n\nĐầu vào: Hai số nguyên, N (số người trong vòng tròn) và M (bước loại bỏ).\nĐầu ra: Trả về một mảng đại diện cho thứ tự mà mọi người bị loại bỏ."
    },
    "instruction_bertscore": {
      "es": "0.9875788477523643",
      "arb": "0.9740308653531177",
      "sw": "0.9723288016180297",
      "tr": "0.9688734275095469",
      "vi": "0.981012524616113"
    },
    "level": "easy",
    "test": "function main(){\n    assert(josephusProblem(8, 5) === [5, 2, 8, 7, 1, 4, 6, 3]);\n    assert(josephusProblem(4, 2) === [2, 4, 3, 1]);\n    assert(josephusProblem(6, 3) === [3, 6, 4, 2, 5, 1]);    \n}\n\n\nmain();\n?>",
    "entry_point": "josephusProblem",
    "signature": "function josephusProblem($n, $m)",
    "docstring": {
      "en": "Solves the Josephus Problem.\nIn this problem, N people are arranged in a circle and eliminated in every Mth position\nuntil only one person remains. The function simulates this process and returns the order\nin which people are eliminated.\n\nFor example, with N = 8 and M = 5, the elimination order is 5, 2, 8, 7, 1, 4, 6, 3.\n\nInput: Two integers, N (number of people in the circle) and M (the elimination step).\nOutput: Returns an array representing the order in which people are eliminated.",
      "es": "Resuelve el Problema de Josephus.\nEn este problema, N personas están dispuestas en un círculo y se eliminan en cada posición M hasta que solo queda una persona. La función simula este proceso y devuelve el orden en el que las personas son eliminadas.\n\nPor ejemplo, con N = 8 y M = 5, el orden de eliminación es 5, 2, 8, 7, 1, 4, 6, 3.\n\nEntrada: Dos enteros, N (número de personas en el círculo) y M (el paso de eliminación).\nSalida: Devuelve un arreglo que representa el orden en el que las personas son eliminadas.",
      "arb": "يحل مشكلة جوزيفوس.  \nفي هذه المشكلة، يتم ترتيب N شخصًا في دائرة ويتم التخلص من كل شخص في الموضع M حتى يبقى شخص واحد فقط. تقوم الدالة بمحاكاة هذه العملية وتعيد الترتيب الذي يتم فيه التخلص من الأشخاص.\n\nعلى سبيل المثال، مع N = 8 و M = 5، يكون ترتيب الإقصاء هو 5، 2، 8، 7، 1، 4، 6، 3.\n\nالمدخلات: عددان صحيحان، N (عدد الأشخاص في الدائرة) و M (خطوة الإقصاء).  \nالمخرجات: تعيد مصفوفة تمثل الترتيب الذي يتم فيه التخلص من الأشخاص.",
      "sw": "Hutatua Tatizo la Josephus.  \nKatika tatizo hili, watu N wamepangwa katika mduara na kuondolewa katika kila nafasi ya M hadi mtu mmoja tu abaki. Kazi hii huiga mchakato huu na kurudisha mpangilio ambao watu wanaondolewa.\n\nKwa mfano, ikiwa N = 8 na M = 5, mpangilio wa kuondolewa ni 5, 2, 8, 7, 1, 4, 6, 3.\n\nIngizo: Nambari mbili za mzima, N (idadi ya watu katika mduara) na M (hatua ya kuondolewa).  \nPato: Inarudisha safu inayowakilisha mpangilio ambao watu wanaondolewa.",
      "tr": "Josephus Problemini çözer.  \nBu problemde, N kişi bir daire şeklinde dizilir ve her M'inci pozisyonda bir kişi elenir  \nve sadece bir kişi kalana kadar bu süreç devam eder. Fonksiyon bu süreci simüle eder  \nve kişilerin elenme sırasını döndürür.\n\nÖrneğin, N = 8 ve M = 5 olduğunda, elenme sırası 5, 2, 8, 7, 1, 4, 6, 3'tür.\n\nGirdi: İki tamsayı, N (dairedeki kişi sayısı) ve M (elenme adımı).  \nÇıktı: Kişilerin elenme sırasını temsil eden bir dizi döndürür.",
      "vi": "Giải quyết Vấn đề Josephus.  \nTrong vấn đề này, N người được sắp xếp thành một vòng tròn và bị loại bỏ ở mỗi vị trí thứ M  \ncho đến khi chỉ còn một người duy nhất. Hàm này mô phỏng quá trình này và trả về thứ tự  \nmà mọi người bị loại bỏ.\n\nVí dụ, với N = 8 và M = 5, thứ tự loại bỏ là 5, 2, 8, 7, 1, 4, 6, 3.\n\nĐầu vào: Hai số nguyên, N (số người trong vòng tròn) và M (bước loại bỏ).  \nĐầu ra: Trả về một mảng đại diện cho thứ tự mà mọi người bị loại bỏ."
    },
    "docstring_bertscore": {
      "es": "0.9627351528444257",
      "arb": "0.977187102107762",
      "sw": "0.9711090124480944",
      "tr": "0.9262223203114495",
      "vi": "0.9882992801443778"
    }
  },
  {
    "task_id": "PHP/31",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Finds the positions of the k-th largest number in an array.\n * This function takes an array of integers and an integer k, \n * and returns the positions of the k-th largest number in the array. \n * If there are duplicates of the k-th largest number, it returns all positions.\n * If k is greater than the array's length or the array is empty, it returns an empty array.\n *\n * Example:\n * Input: numbers = [67, 43, 90, 78, 32], k = 1\n * Output: [3]\n * \n * Input: numbers = [1, 2, 3, 4, 5], k = 3\n * Output: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array ",
      "es": "<?php\n\n\n/**\n * Encuentra las posiciones del k-ésimo número más grande en un arreglo.\n * Esta función toma un arreglo de enteros y un entero k,\n * y devuelve las posiciones del k-ésimo número más grande en el arreglo.\n * Si hay duplicados del k-ésimo número más grande, devuelve todas las posiciones.\n * Si k es mayor que la longitud del arreglo o el arreglo está vacío, devuelve un arreglo vacío.\n *\n * Ejemplo:\n * Entrada: numbers = [67, 43, 90, 78, 32], k = 1\n * Salida: [3]\n * \n * Entrada: numbers = [1, 2, 3, 4, 5], k = 3\n * Salida: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array ",
      "arb": "<?php\n\n\n/**\n * يجد مواقع الرقم الأكبر في المرتبة k في مصفوفة.\n * تأخذ هذه الدالة مصفوفة من الأعداد الصحيحة وعدد صحيح k،\n * وتعيد مواقع الرقم الأكبر في المرتبة k في المصفوفة.\n * إذا كان هناك تكرارات للرقم الأكبر في المرتبة k، فإنها تعيد جميع المواقع.\n * إذا كان k أكبر من طول المصفوفة أو كانت المصفوفة فارغة، فإنها تعيد مصفوفة فارغة.\n *\n * مثال:\n * المدخل: numbers = [67, 43, 90, 78, 32], k = 1\n * المخرج: [3]\n * \n * المدخل: numbers = [1, 2, 3, 4, 5], k = 3\n * المخرج: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array ",
      "sw": "<?php\n\n\n/**\n * Inapata nafasi za nambari ya k-th kubwa zaidi katika safu.\n * Kazi hii inachukua safu ya nambari za mzima na nambari k,\n * na inarudisha nafasi za nambari ya k-th kubwa zaidi katika safu.\n * Ikiwa kuna nakala za nambari ya k-th kubwa zaidi, inarudisha nafasi zote.\n * Ikiwa k ni kubwa kuliko urefu wa safu au safu ni tupu, inarudisha safu tupu.\n *\n * Mfano:\n * Ingizo: numbers = [67, 43, 90, 78, 32], k = 1\n * Matokeo: [3]\n * \n * Ingizo: numbers = [1, 2, 3, 4, 5], k = 3\n * Matokeo: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array ",
      "tr": "<?php\n\n\n/**\n * Bir dizideki k. en büyük sayının pozisyonlarını bulur.\n * Bu fonksiyon bir tamsayı dizisi ve bir tamsayı k alır,\n * ve dizideki k. en büyük sayının pozisyonlarını döndürür.\n * Eğer k. en büyük sayının tekrarları varsa, tüm pozisyonları döndürür.\n * Eğer k dizinin uzunluğundan büyükse veya dizi boşsa, boş bir dizi döner.\n *\n * Örnek:\n * Girdi: numbers = [67, 43, 90, 78, 32], k = 1\n * Çıktı: [3]\n * \n * Girdi: numbers = [1, 2, 3, 4, 5], k = 3\n * Çıktı: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array ",
      "vi": "<?php\n\n\n/**\n * Tìm vị trí của số lớn thứ k trong một mảng.\n * Hàm này nhận một mảng các số nguyên và một số nguyên k,\n * và trả về các vị trí của số lớn thứ k trong mảng.\n * Nếu có các số trùng lặp của số lớn thứ k, nó trả về tất cả các vị trí.\n * Nếu k lớn hơn độ dài của mảng hoặc mảng rỗng, nó trả về một mảng rỗng.\n *\n * Ví dụ:\n * Đầu vào: numbers = [67, 43, 90, 78, 32], k = 1\n * Đầu ra: [3]\n * \n * Đầu vào: numbers = [1, 2, 3, 4, 5], k = 3\n * Đầu ra: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array "
    },
    "prompt_bertscore": {
      "es": "0.9955751110016858",
      "arb": "0.9955751110016858",
      "sw": "0.9922061411089531",
      "tr": "0.9927497924618456",
      "vi": "0.9918376817521334"
    },
    "canonical_solution": " {\n    $length = count($numbers);\n    if ($length === 0 || $k > $length) {\n        return [];\n    }\n\n    $indexedNumbers = array_combine(range(1, $length), $numbers);\n    arsort($indexedNumbers);\n    $sortedNumbers = array_values($indexedNumbers);\n    $kthLargest = $sortedNumbers[$k - 1];\n\n    return array_keys($indexedNumbers, $kthLargest);\n}",
    "instruction": {
      "en": "Write a PHP function `function findKthLargestPositions(array $numbers, int $k): array` to solve the following problem:\nFinds the positions of the k-th largest number in an array.\nThis function takes an array of integers and an integer k,\nand returns the positions of the k-th largest number in the array.\nIf there are duplicates of the k-th largest number, it returns all positions.\nIf k is greater than the array's length or the array is empty, it returns an empty array.\n\nExample:\nInput: numbers = [67, 43, 90, 78, 32], k = 1\nOutput: [3]\n\nInput: numbers = [1, 2, 3, 4, 5], k = 3\nOutput: [3]",
      "es": "Escribe una función PHP `function findKthLargestPositions(array $numbers, int $k): array` para resolver el siguiente problema:\nEncuentra las posiciones del número k-ésimo más grande en un arreglo.\nEsta función toma un arreglo de enteros y un entero k,\ny devuelve las posiciones del número k-ésimo más grande en el arreglo.\nSi hay duplicados del número k-ésimo más grande, devuelve todas las posiciones.\nSi k es mayor que la longitud del arreglo o el arreglo está vacío, devuelve un arreglo vacío.\n\nEjemplo:\nEntrada: numbers = [67, 43, 90, 78, 32], k = 1\nSalida: [3]\n\nEntrada: numbers = [1, 2, 3, 4, 5], k = 3\nSalida: [3]",
      "arb": "اكتب دالة PHP `function findKthLargestPositions(array $numbers, int $k): array` لحل المشكلة التالية:\nتجد مواقع العدد الأكبر في المرتبة k في مصفوفة.\nتأخذ هذه الدالة مصفوفة من الأعداد الصحيحة وعدد صحيح k،\nوتعيد مواقع العدد الأكبر في المرتبة k في المصفوفة.\nإذا كانت هناك تكرارات للعدد الأكبر في المرتبة k، فإنها تعيد جميع المواقع.\nإذا كان k أكبر من طول المصفوفة أو كانت المصفوفة فارغة، فإنها تعيد مصفوفة فارغة.\n\nمثال:\nالمدخلات: numbers = [67, 43, 90, 78, 32], k = 1\nالناتج: [3]\n\nالمدخلات: numbers = [1, 2, 3, 4, 5], k = 3\nالناتج: [3]",
      "sw": "Andika kazi ya PHP `function findKthLargestPositions(array $numbers, int $k): array` kutatua tatizo lifuatalo:\nInapata nafasi za nambari ya k-th kubwa katika safu.\nKazi hii inachukua safu ya nambari za mzima na mzima k,\nna inarudisha nafasi za nambari ya k-th kubwa katika safu.\nKama kuna nakala za nambari ya k-th kubwa, inarudisha nafasi zote.\nKama k ni kubwa kuliko urefu wa safu au safu ni tupu, inarudisha safu tupu.\n\nMfano:\nIngizo: numbers = [67, 43, 90, 78, 32], k = 1\nMatokeo: [3]\n\nIngizo: numbers = [1, 2, 3, 4, 5], k = 3\nMatokeo: [3]",
      "tr": "Bir PHP fonksiyonu `function findKthLargestPositions(array $numbers, int $k): array` yazın: \nBir dizideki k. en büyük sayının pozisyonlarını bulur. \nBu fonksiyon bir tamsayı dizisi ve bir tamsayı k alır, \nve dizideki k. en büyük sayının pozisyonlarını döndürür. \nEğer k. en büyük sayının tekrarları varsa, tüm pozisyonları döndürür. \nEğer k dizinin uzunluğundan büyükse veya dizi boşsa, boş bir dizi döndürür.\n\nÖrnek:\nGirdi: numbers = [67, 43, 90, 78, 32], k = 1\nÇıktı: [3]\n\nGirdi: numbers = [1, 2, 3, 4, 5], k = 3\nÇıktı: [3]",
      "vi": "Viết một hàm PHP `function findKthLargestPositions(array $numbers, int $k): array` để giải quyết vấn đề sau:\nTìm vị trí của số lớn thứ k trong một mảng.\nHàm này nhận một mảng các số nguyên và một số nguyên k,\nvà trả về các vị trí của số lớn thứ k trong mảng.\nNếu có các số trùng lặp của số lớn thứ k, nó trả về tất cả các vị trí.\nNếu k lớn hơn độ dài của mảng hoặc mảng trống, nó trả về một mảng trống.\n\nVí dụ:\nĐầu vào: numbers = [67, 43, 90, 78, 32], k = 1\nĐầu ra: [3]\n\nĐầu vào: numbers = [1, 2, 3, 4, 5], k = 3\nĐầu ra: [3]"
    },
    "instruction_bertscore": {
      "es": "0.9941183557871759",
      "arb": "0.9941183557871759",
      "sw": "0.9942973217604884",
      "tr": "0.9751990106239838",
      "vi": "0.9914575032028325"
    },
    "level": "easy",
    "test": "function main(){\n    // Test case 1: k-th largest is unique\n    assert(findKthLargestPositions([67, 43, 90, 78, 32], 1) === [3]);\n\n    // Test case 2: k-th largest has duplicates\n    assert(findKthLargestPositions([20, 50, 20, 40], 3) === [1, 3]);\n\n    // Test case 3: k is larger than the array length\n    assert(findKthLargestPositions([10, 20, 30], 4) === []);\n\n    // Test case 4: Array is empty\n    assert(findKthLargestPositions([], 1) === []);\n\n    // Test case 5: k-th largest in the middle\n    assert(findKthLargestPositions([1, 2, 3, 4, 5], 3) === [3]);\n}\n\n\nmain();\n?>",
    "entry_point": "findKthLargestPositions",
    "signature": "function findKthLargestPositions(array $numbers, int $k): array",
    "docstring": {
      "en": "Finds the positions of the k-th largest number in an array.\nThis function takes an array of integers and an integer k,\nand returns the positions of the k-th largest number in the array.\nIf there are duplicates of the k-th largest number, it returns all positions.\nIf k is greater than the array's length or the array is empty, it returns an empty array.\n\nExample:\nInput: numbers = [67, 43, 90, 78, 32], k = 1\nOutput: [3]\n\nInput: numbers = [1, 2, 3, 4, 5], k = 3\nOutput: [3]",
      "es": "Encuentra las posiciones del k-ésimo número más grande en un array.  \nEsta función toma un array de enteros y un entero k,  \ny devuelve las posiciones del k-ésimo número más grande en el array.  \nSi hay duplicados del k-ésimo número más grande, devuelve todas las posiciones.  \nSi k es mayor que la longitud del array o el array está vacío, devuelve un array vacío.\n\nEjemplo:  \nEntrada: numbers = [67, 43, 90, 78, 32], k = 1  \nSalida: [3]\n\nEntrada: numbers = [1, 2, 3, 4, 5], k = 3  \nSalida: [3]",
      "arb": "يعثر على مواقع العدد الأكبر في ترتيب معين في مصفوفة.\nتأخذ هذه الدالة مصفوفة من الأعداد الصحيحة وعدد صحيح k،\nوتعيد مواقع العدد الأكبر في ترتيب k في المصفوفة.\nإذا كان هناك تكرارات للعدد الأكبر في ترتيب k، فإنها تعيد جميع المواقع.\nإذا كان k أكبر من طول المصفوفة أو كانت المصفوفة فارغة، فإنها تعيد مصفوفة فارغة.\n\nمثال:\nالمدخلات: numbers = [67, 43, 90, 78, 32], k = 1\nالمخرجات: [3]\n\nالمدخلات: numbers = [1, 2, 3, 4, 5], k = 3\nالمخرجات: [3]",
      "sw": "Inapata nafasi za nambari ya k kubwa zaidi katika safu.\nKazi hii inachukua safu ya nambari za mzima na mzima k,\nna inarudisha nafasi za nambari ya k kubwa zaidi katika safu.\nKama kuna marudio ya nambari ya k kubwa zaidi, inarudisha nafasi zote.\nKama k ni kubwa kuliko urefu wa safu au safu ni tupu, inarudisha safu tupu.\n\nMfano:\nIngizo: numbers = [67, 43, 90, 78, 32], k = 1\nMatokeo: [3]\n\nIngizo: numbers = [1, 2, 3, 4, 5], k = 3\nMatokeo: [3]",
      "tr": "k. en büyük sayının bir dizideki konumlarını bulur.\nBu fonksiyon bir tamsayı dizisi ve bir tamsayı k alır ve dizideki k. en büyük sayının konumlarını döndürür.\nEğer k. en büyük sayının tekrarları varsa, tüm konumları döndürür.\nEğer k dizinin uzunluğundan büyükse veya dizi boşsa, boş bir dizi döndürür.\n\nÖrnek:\nGirdi: numbers = [67, 43, 90, 78, 32], k = 1\nÇıktı: [3]\n\nGirdi: numbers = [1, 2, 3, 4, 5], k = 3\nÇıktı: [3]",
      "vi": "Tìm vị trí của số lớn thứ k trong một mảng.  \nHàm này nhận một mảng các số nguyên và một số nguyên k,  \nvà trả về các vị trí của số lớn thứ k trong mảng.  \nNếu có các số trùng lặp của số lớn thứ k, nó trả về tất cả các vị trí.  \nNếu k lớn hơn độ dài của mảng hoặc mảng rỗng, nó trả về một mảng rỗng.  \n\nVí dụ:  \nĐầu vào: numbers = [67, 43, 90, 78, 32], k = 1  \nĐầu ra: [3]  \n\nĐầu vào: numbers = [1, 2, 3, 4, 5], k = 3  \nĐầu ra: [3]"
    },
    "docstring_bertscore": {
      "es": "0.9919177297956904",
      "arb": "0.956064548758131",
      "sw": "0.9605980885748713",
      "tr": "0.9350440914243519",
      "vi": "0.9903630498033303"
    }
  },
  {
    "task_id": "PHP/32",
    "prompt": {
      "en": "<?php\n\n/**\n    * Calculates the k-th term of the Pell sequence modulo 32767.\n    * The Pell sequence is defined as follows:\n    *   a[1] = 1, a[2] = 2, and a[n] = 2*a[n-1] + a[n-2] for n > 2.\n    * This function computes the k-th term of this sequence modulo 32767.\n    * Input: An integer $k (1 ≤ $k < 1000000), representing the position in the sequence.\n    * Output: Returns the k-th term of the Pell sequence modulo 32767 as an integer.\n    * Example:\n    *   For $k = 1, the function returns 1.\n    *   For $k = 8, the function returns 408.\n    */\n\n    function getPellNumberModulo($k)",
      "es": "<?php\n\n/**\n    * Calcula el término k-ésimo de la secuencia de Pell módulo 32767.\n    * La secuencia de Pell se define de la siguiente manera:\n    *   a[1] = 1, a[2] = 2, y a[n] = 2*a[n-1] + a[n-2] para n > 2.\n    * Esta función calcula el término k-ésimo de esta secuencia módulo 32767.\n    * Entrada: Un entero $k (1 ≤ $k < 1000000), que representa la posición en la secuencia.\n    * Salida: Devuelve el término k-ésimo de la secuencia de Pell módulo 32767 como un entero.\n    * Ejemplo:\n    *   Para $k = 1, la función devuelve 1.\n    *   Para $k = 8, la función devuelve 408.\n    */\n\n    function getPellNumberModulo($k)",
      "arb": "<?php\n\n/**\n    * يحسب الحد k من متتالية بيل بتردد 32767.\n    * تُعرّف متتالية بيل كما يلي:\n    *   a[1] = 1, a[2] = 2, و a[n] = 2*a[n-1] + a[n-2] لـ n > 2.\n    * تقوم هذه الدالة بحساب الحد k من هذه المتتالية بتردد 32767.\n    * المدخل: عدد صحيح $k (1 ≤ $k < 1000000)، يمثل الموضع في المتتالية.\n    * المخرج: يعيد الحد k من متتالية بيل بتردد 32767 كعدد صحيح.\n    * مثال:\n    *   لـ $k = 1، تعيد الدالة 1.\n    *   لـ $k = 8، تعيد الدالة 408.\n    */\n\n    function getPellNumberModulo($k)",
      "sw": "<?php\n\n/**\n    * Inahesabu neno la k katika mlolongo wa Pell modulo 32767.\n    * Mlolongo wa Pell umefafanuliwa kama ifuatavyo:\n    *   a[1] = 1, a[2] = 2, na a[n] = 2*a[n-1] + a[n-2] kwa n > 2.\n    * Kazi hii inahesabu neno la k katika mlolongo huu modulo 32767.\n    * Ingizo: Nambari kamili $k (1 ≤ $k < 1000000), inayowakilisha nafasi katika mlolongo.\n    * Tokeo: Inarudisha neno la k katika mlolongo wa Pell modulo 32767 kama nambari kamili.\n    * Mfano:\n    *   Kwa $k = 1, kazi inarudisha 1.\n    *   Kwa $k = 8, kazi inarudisha 408.\n    */\n\n    function getPellNumberModulo($k)",
      "tr": "<?php\n\n/**\n    * Pell dizisinin k. terimini 32767 modunda hesaplar.\n    * Pell dizisi şu şekilde tanımlanır:\n    *   a[1] = 1, a[2] = 2 ve a[n] = 2*a[n-1] + a[n-2] for n > 2.\n    * Bu fonksiyon, bu dizinin k. terimini 32767 modunda hesaplar.\n    * Girdi: Dizideki konumu temsil eden bir tamsayı $k (1 ≤ $k < 1000000).\n    * Çıktı: Pell dizisinin k. terimini 32767 modunda bir tamsayı olarak döndürür.\n    * Örnek:\n    *   $k = 1 için, fonksiyon 1 döndürür.\n    *   $k = 8 için, fonksiyon 408 döndürür.\n    */\n\n    function getPellNumberModulo($k)",
      "vi": "<?php\n\n/**\n    * Tính toán số hạng thứ k của dãy Pell theo modulo 32767.\n    * Dãy Pell được định nghĩa như sau:\n    *   a[1] = 1, a[2] = 2, và a[n] = 2*a[n-1] + a[n-2] cho n > 2.\n    * Hàm này tính toán số hạng thứ k của dãy này theo modulo 32767.\n    * Đầu vào: Một số nguyên $k (1 ≤ $k < 1000000), đại diện cho vị trí trong dãy.\n    * Đầu ra: Trả về số hạng thứ k của dãy Pell theo modulo 32767 dưới dạng số nguyên.\n    * Ví dụ:\n    *   Với $k = 1, hàm trả về 1.\n    *   Với $k = 8, hàm trả về 408.\n    */\n\n    function getPellNumberModulo($k)"
    },
    "prompt_bertscore": {
      "es": "0.9958676935529502",
      "arb": "0.9625186457290976",
      "sw": "0.9914932566714189",
      "tr": "0.9841900148215281",
      "vi": "0.9932398136118586"
    },
    "canonical_solution": "{\n        if ($k === 1) return 1;\n        if ($k === 2) return 2;\n    \n        $a = 1; // a[1]\n        $b = 2; // a[2]\n    \n        for ($i = 3; $i <= $k; $i++) {\n            $temp = (2 * $b + $a) % 32767;\n            $a = $b;\n            $b = $temp;\n        }\n    \n        return $b;\n    }",
    "instruction": {
      "en": "Write a PHP function `function getPellNumberModulo($k)` to solve the following problem:\nCalculates the k-th term of the Pell sequence modulo 32767.\nThe Pell sequence is defined as follows:\na[1] = 1, a[2] = 2, and a[n] = 2*a[n-1] + a[n-2] for n > 2.\nThis function computes the k-th term of this sequence modulo 32767.\nInput: An integer $k (1 ≤ $k < 1000000), representing the position in the sequence.\nOutput: Returns the k-th term of the Pell sequence modulo 32767 as an integer.\nExample:\nFor $k = 1, the function returns 1.\nFor $k = 8, the function returns 408.",
      "es": "Escribe una función PHP `function getPellNumberModulo($k)` para resolver el siguiente problema:\nCalcula el término k-ésimo de la secuencia de Pell módulo 32767.\nLa secuencia de Pell se define de la siguiente manera:\na[1] = 1, a[2] = 2, y a[n] = 2*a[n-1] + a[n-2] para n > 2.\nEsta función calcula el término k-ésimo de esta secuencia módulo 32767.\nEntrada: Un entero $k (1 ≤ $k < 1000000), que representa la posición en la secuencia.\nSalida: Devuelve el término k-ésimo de la secuencia de Pell módulo 32767 como un entero.\nEjemplo:\nPara $k = 1, la función devuelve 1.\nPara $k = 8, la función devuelve 408.",
      "arb": "اكتب دالة PHP `function getPellNumberModulo($k)` لحل المشكلة التالية:\nتحسب الحد k من تسلسل بيل بتطبيق عملية المودولو 32767.\nيتم تعريف تسلسل بيل كما يلي:\na[1] = 1, a[2] = 2, و a[n] = 2*a[n-1] + a[n-2] لـ n > 2.\nتقوم هذه الدالة بحساب الحد k من هذا التسلسل بتطبيق عملية المودولو 32767.\nالمدخل: عدد صحيح $k (1 ≤ $k < 1000000)، يمثل الموضع في التسلسل.\nالمخرج: تعيد الحد k من تسلسل بيل بتطبيق عملية المودولو 32767 كعدد صحيح.\nمثال:\nلـ $k = 1، تعيد الدالة 1.\nلـ $k = 8، تعيد الدالة 408.",
      "sw": "Andika kazi ya PHP `function getPellNumberModulo($k)` kutatua tatizo lifuatalo:\nInahesabu neno la k katika mfuatano wa Pell modulo 32767.\nMfuatano wa Pell umefafanuliwa kama ifuatavyo:\na[1] = 1, a[2] = 2, na a[n] = 2*a[n-1] + a[n-2] kwa n > 2.\nKazi hii inahesabu neno la k katika mfuatano huu modulo 32767.\nIngizo: Nambari kamili $k (1 ≤ $k < 1000000), inayowakilisha nafasi katika mfuatano.\nMatokeo: Inarudisha neno la k katika mfuatano wa Pell modulo 32767 kama nambari kamili.\nMfano:\nKwa $k = 1, kazi inarudisha 1.\nKwa $k = 8, kazi inarudisha 408.",
      "tr": "Bir PHP fonksiyonu `function getPellNumberModulo($k)` yazın ve aşağıdaki problemi çözün:\nPell dizisinin k-terimini 32767 modunda hesaplar.\nPell dizisi şu şekilde tanımlanır:\na[1] = 1, a[2] = 2 ve a[n] = 2*a[n-1] + a[n-2] for n > 2.\nBu fonksiyon, bu dizinin k-terimini 32767 modunda hesaplar.\nGirdi: Dizideki konumu temsil eden bir tamsayı $k (1 ≤ $k < 1000000).\nÇıktı: Pell dizisinin k-terimini 32767 modunda bir tamsayı olarak döndürür.\nÖrnek:\n$k = 1 için, fonksiyon 1 döndürür.\n$k = 8 için, fonksiyon 408 döndürür.",
      "vi": "Viết một hàm PHP `function getPellNumberModulo($k)` để giải quyết vấn đề sau:\nTính toán số hạng thứ k của dãy Pell theo modulo 32767.\nDãy Pell được định nghĩa như sau:\na[1] = 1, a[2] = 2, và a[n] = 2*a[n-1] + a[n-2] cho n > 2.\nHàm này tính toán số hạng thứ k của dãy này theo modulo 32767.\nĐầu vào: Một số nguyên $k (1 ≤ $k < 1000000), đại diện cho vị trí trong dãy.\nĐầu ra: Trả về số hạng thứ k của dãy Pell theo modulo 32767 dưới dạng số nguyên.\nVí dụ:\nVới $k = 1, hàm trả về 1.\nVới $k = 8, hàm trả về 408."
    },
    "instruction_bertscore": {
      "es": "0.9949255896557017",
      "arb": "0.9522788523259871",
      "sw": "0.9888556438416566",
      "tr": "0.9849267349047864",
      "vi": "0.9930163544331944"
    },
    "level": "easy",
    "test": "function main(){\n    assert(getPellNumberModulo(1) === 1);\n    assert(getPellNumberModulo(8) === 408);\n    assert(getPellNumberModulo(3) === 5);\n    assert(getPellNumberModulo(5) === 29);\n    assert(getPellNumberModulo(10) === 2378);\n    assert(getPellNumberModulo(100000) === 27550);\n    assert(getPellNumberModulo(999999) === 21600);\n    \n}",
    "entry_point": "getPellNumberModulo",
    "signature": "function getPellNumberModulo($k)",
    "docstring": {
      "en": "Calculates the k-th term of the Pell sequence modulo 32767.\nThe Pell sequence is defined as follows:\na[1] = 1, a[2] = 2, and a[n] = 2*a[n-1] + a[n-2] for n > 2.\nThis function computes the k-th term of this sequence modulo 32767.\nInput: An integer $k (1 ≤ $k < 1000000), representing the position in the sequence.\nOutput: Returns the k-th term of the Pell sequence modulo 32767 as an integer.\nExample:\nFor $k = 1, the function returns 1.\nFor $k = 8, the function returns 408.",
      "es": "Calcula el término k-ésimo de la secuencia de Pell módulo 32767.\nLa secuencia de Pell se define de la siguiente manera:\na[1] = 1, a[2] = 2, y a[n] = 2*a[n-1] + a[n-2] para n > 2.\nEsta función calcula el término k-ésimo de esta secuencia módulo 32767.\nEntrada: Un entero $k (1 ≤ $k < 1000000), que representa la posición en la secuencia.\nSalida: Devuelve el término k-ésimo de la secuencia de Pell módulo 32767 como un entero.\nEjemplo:\nPara $k = 1, la función devuelve 1.\nPara $k = 8, la función devuelve 408.",
      "arb": "يحسب الحد k من متتالية بيل بتطبيق 32767.\nيتم تعريف متتالية بيل كما يلي:\na[1] = 1, a[2] = 2, و a[n] = 2*a[n-1] + a[n-2] لـ n > 2.\nتقوم هذه الدالة بحساب الحد k من هذه المتتالية بتطبيق 32767.\nالمدخل: عدد صحيح $k (1 ≤ $k < 1000000)، يمثل الموضع في المتتالية.\nالمخرج: تعيد الحد k من متتالية بيل بتطبيق 32767 كعدد صحيح.\nمثال:\nبالنسبة لـ $k = 1، تعيد الدالة 1.\nبالنسبة لـ $k = 8، تعيد الدالة 408.",
      "sw": "Hesabu neno la k katika mlolongo wa Pell modulo 32767.  \nMlolongo wa Pell umefafanuliwa kama ifuatavyo:  \na[1] = 1, a[2] = 2, na a[n] = 2*a[n-1] + a[n-2] kwa n > 2.  \nKazi hii inahesabu neno la k katika mlolongo huu modulo 32767.  \nIngizo: Nambari nzima $k (1 ≤ $k < 1000000), inayowakilisha nafasi katika mlolongo.  \nPato: Inarudisha neno la k katika mlolongo wa Pell modulo 32767 kama nambari nzima.  \nMfano:  \nKwa $k = 1, kazi inarudisha 1.  \nKwa $k = 8, kazi inarudisha 408.",
      "tr": "Pell dizisinin k-terimini 32767 modunda hesaplar.\nPell dizisi şu şekilde tanımlanır:\na[1] = 1, a[2] = 2 ve a[n] = 2*a[n-1] + a[n-2] for n > 2.\nBu fonksiyon, bu dizinin k-terimini 32767 modunda hesaplar.\nGirdi: Dizideki konumu temsil eden bir tamsayı $k (1 ≤ $k < 1000000).\nÇıktı: Pell dizisinin k-terimini 32767 modunda bir tamsayı olarak döndürür.\nÖrnek:\n$k = 1 için, fonksiyon 1 döndürür.\n$k = 8 için, fonksiyon 408 döndürür.",
      "vi": "Tính toán số hạng thứ k của dãy Pell theo modulo 32767.  \nDãy Pell được định nghĩa như sau:  \na[1] = 1, a[2] = 2, và a[n] = 2*a[n-1] + a[n-2] cho n > 2.  \nHàm này tính toán số hạng thứ k của dãy này theo modulo 32767.  \nĐầu vào: Một số nguyên $k (1 ≤ $k < 1000000), đại diện cho vị trí trong dãy.  \nĐầu ra: Trả về số hạng thứ k của dãy Pell theo modulo 32767 dưới dạng một số nguyên.  \nVí dụ:  \nĐối với $k = 1, hàm trả về 1.  \nĐối với $k = 8, hàm trả về 408."
    },
    "docstring_bertscore": {
      "es": "0.9872080048309722",
      "arb": "0.954584355158659",
      "sw": "0.982800396675808",
      "tr": "0.9791163989987539",
      "vi": "0.9880503962769411"
    }
  },
  {
    "task_id": "PHP/33",
    "prompt": {
      "en": "<?php\n\n/**\n    * Counts the number of flu infections in a dormitory grid after a certain number of days.\n    * The dormitory is represented as an n*n grid where each cell can have:\n    * - '.' representing a healthy person\n    * - '#' representing an empty room\n    * - '@' representing a person infected with the flu\n    * Each day, infected individuals spread the flu to adjacent (up, down, left, right) healthy individuals.\n    * The function calculates the total number of infected individuals after 'm' days.\n    * Input: \n    *   - $dormitory: A 2D array representing the n*n dormitory grid.\n    *   - $days: An integer representing the number of days.\n    * Output: Returns the total number of flu infections after 'm' days.\n    * Example:\n    *   Input: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   Output: 16\n*/\nfunction countFluInfections($dormitory, $days) ",
      "es": "<?php\n\n/**\n    * Cuenta el número de infecciones de gripe en una cuadrícula de dormitorio después de un cierto número de días.\n    * El dormitorio se representa como una cuadrícula de n*n donde cada celda puede tener:\n    * - '.' representando a una persona sana\n    * - '#' representando una habitación vacía\n    * - '@' representando a una persona infectada con la gripe\n    * Cada día, los individuos infectados propagan la gripe a los individuos sanos adyacentes (arriba, abajo, izquierda, derecha).\n    * La función calcula el número total de individuos infectados después de 'm' días.\n    * Entrada: \n    *   - $dormitory: Un arreglo 2D que representa la cuadrícula de dormitorio n*n.\n    *   - $days: Un entero que representa el número de días.\n    * Salida: Devuelve el número total de infecciones de gripe después de 'm' días.\n    * Ejemplo:\n    *   Entrada: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   Salida: 16\n*/\nfunction countFluInfections($dormitory, $days) ",
      "arb": "<?php\n\n/**\n    * يحسب عدد حالات الإصابة بالإنفلونزا في شبكة سكنية بعد عدد معين من الأيام.\n    * يتم تمثيل السكن كشبكة n*n حيث يمكن أن تحتوي كل خلية على:\n    * - '.' تمثل شخصًا سليمًا\n    * - '#' تمثل غرفة فارغة\n    * - '@' تمثل شخصًا مصابًا بالإنفلونزا\n    * كل يوم، ينشر الأفراد المصابون الإنفلونزا إلى الأفراد الأصحاء المجاورين (أعلى، أسفل، يسار، يمين).\n    * تقوم الدالة بحساب العدد الإجمالي للأفراد المصابين بعد 'm' أيام.\n    * المدخلات: \n    *   - $dormitory: مصفوفة ثنائية الأبعاد تمثل شبكة السكن n*n.\n    *   - $days: عدد صحيح يمثل عدد الأيام.\n    * المخرجات: تعيد العدد الإجمالي لحالات الإصابة بالإنفلونزا بعد 'm' أيام.\n    * مثال:\n    *   المدخل: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   المخرج: 16\n*/\nfunction countFluInfections($dormitory, $days) ",
      "sw": "<?php\n\n/**\n    * Inahesabu idadi ya maambukizi ya mafua katika gridi ya bweni baada ya siku kadhaa.\n    * Bweni linawakilishwa kama gridi ya n*n ambapo kila seli inaweza kuwa na:\n    * - '.' inawakilisha mtu mwenye afya\n    * - '#' inawakilisha chumba tupu\n    * - '@' inawakilisha mtu aliyeambukizwa na mafua\n    * Kila siku, watu walioambukizwa hueneza mafua kwa watu wenye afya walio karibu (juu, chini, kushoto, kulia).\n    * Kazi hii inahesabu jumla ya watu walioambukizwa baada ya siku 'm'.\n    * Ingizo: \n    *   - $dormitory: Mfululizo wa vipimo viwili unaowakilisha gridi ya n*n ya bweni.\n    *   - $days: Nambari kamili inayoonyesha idadi ya siku.\n    * Tokeo: Inarejesha jumla ya maambukizi ya mafua baada ya siku 'm'.\n    * Mfano:\n    *   Ingizo: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   Tokeo: 16\n*/\nfunction countFluInfections($dormitory, $days) ",
      "tr": "<?php\n\n/**\n    * Belirli bir gün sayısından sonra bir yurt ızgarasında grip enfeksiyonlarının sayısını sayar.\n    * Yurt, her hücrenin şu şekilde olabileceği bir n*n ızgarası olarak temsil edilir:\n    * - '.' sağlıklı bir kişiyi temsil eder\n    * - '#' boş bir odayı temsil eder\n    * - '@' grip ile enfekte olmuş bir kişiyi temsil eder\n    * Her gün, enfekte bireyler griplerini bitişik (yukarı, aşağı, sol, sağ) sağlıklı bireylere yayar.\n    * Fonksiyon, 'm' gününden sonra enfekte olmuş toplam birey sayısını hesaplar.\n    * Girdi: \n    *   - $dormitory: n*n yurt ızgarasını temsil eden 2D bir dizi.\n    *   - $days: Gün sayısını temsil eden bir tamsayı.\n    * Çıktı: 'm' gününden sonra toplam grip enfeksiyonu sayısını döndürür.\n    * Örnek:\n    *   Girdi: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   Çıktı: 16\n*/\nfunction countFluInfections($dormitory, $days) ",
      "vi": "<?php\n\n/**\n    * Đếm số lượng ca nhiễm cúm trong một lưới ký túc xá sau một số ngày nhất định.\n    * Ký túc xá được biểu diễn dưới dạng lưới n*n, trong đó mỗi ô có thể có:\n    * - '.' đại diện cho một người khỏe mạnh\n    * - '#' đại diện cho một phòng trống\n    * - '@' đại diện cho một người bị nhiễm cúm\n    * Mỗi ngày, các cá nhân bị nhiễm bệnh lây lan cúm cho những người khỏe mạnh liền kề (trên, dưới, trái, phải).\n    * Hàm tính toán tổng số người bị nhiễm bệnh sau 'm' ngày.\n    * Đầu vào: \n    *   - $dormitory: Một mảng 2D đại diện cho lưới ký túc xá n*n.\n    *   - $days: Một số nguyên đại diện cho số ngày.\n    * Đầu ra: Trả về tổng số ca nhiễm cúm sau 'm' ngày.\n    * Ví dụ:\n    *   Đầu vào: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   Đầu ra: 16\n*/\nfunction countFluInfections($dormitory, $days) "
    },
    "prompt_bertscore": {
      "es": "0.993736985455589",
      "arb": "0.9690716606298196",
      "sw": "0.9646644497354175",
      "tr": "0.9943489656595574",
      "vi": "0.9877891973258802"
    },
    "canonical_solution": "{\n    $n = count($dormitory);\n    $directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\n    $b = $dormitory;\n\n    for ($k = 2; $k <= $days; $k++) {\n        for ($i = 0; $i < $n; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                if ($dormitory[$i][$j] == '@') {\n                    foreach ($directions as $dir) {\n                        $xx = $i + $dir[0];\n                        $yy = $j + $dir[1];\n                        if ($xx >= 0 && $xx < $n && $yy >= 0 && $yy < $n && $b[$xx][$yy] == '.') {\n                            $b[$xx][$yy] = '@';\n                        }\n                    }\n                }\n            }\n        }\n        $dormitory = $b;\n    }\n\n    $ans = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($dormitory[$i][$j] == '@') {\n                $ans++;\n            }\n        }\n    }\n    // echo $ans;\n    return $ans;\n}",
    "instruction": {
      "en": "Write a PHP function `function countFluInfections($dormitory, $days)` to solve the following problem:\nCounts the number of flu infections in a dormitory grid after a certain number of days.\nThe dormitory is represented as an n*n grid where each cell can have:\n- '.' representing a healthy person\n- '#' representing an empty room\n- '@' representing a person infected with the flu\nEach day, infected individuals spread the flu to adjacent (up, down, left, right) healthy individuals.\nThe function calculates the total number of infected individuals after 'm' days.\nInput:\n- $dormitory: A 2D array representing the n*n dormitory grid.\n- $days: An integer representing the number of days.\nOutput: Returns the total number of flu infections after 'm' days.\nExample:\nInput: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nOutput: 16",
      "es": "Escribe una función PHP `function countFluInfections($dormitory, $days)` para resolver el siguiente problema:\nCuenta el número de infecciones de gripe en una cuadrícula de un dormitorio después de un cierto número de días.\nEl dormitorio se representa como una cuadrícula n*n donde cada celda puede tener:\n- '.' representando a una persona sana\n- '#' representando una habitación vacía\n- '@' representando a una persona infectada con la gripe\nCada día, los individuos infectados propagan la gripe a los individuos sanos adyacentes (arriba, abajo, izquierda, derecha).\nLa función calcula el número total de individuos infectados después de 'm' días.\nEntrada:\n- $dormitory: Un arreglo 2D que representa la cuadrícula n*n del dormitorio.\n- $days: Un entero que representa el número de días.\nSalida: Devuelve el número total de infecciones de gripe después de 'm' días.\nEjemplo:\nEntrada: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nSalida: 16",
      "arb": "اكتب دالة PHP `function countFluInfections($dormitory, $days)` لحل المشكلة التالية:\nتحسب عدد الإصابات بالإنفلونزا في شبكة سكنية بعد عدد معين من الأيام.\nيتم تمثيل السكن كشبكة n*n حيث يمكن أن تحتوي كل خلية على:\n- '.' تمثل شخصًا سليمًا\n- '#' تمثل غرفة فارغة\n- '@' تمثل شخصًا مصابًا بالإنفلونزا\nكل يوم، ينشر الأفراد المصابون الإنفلونزا إلى الأفراد الأصحاء المجاورين (أعلى، أسفل، يسار، يمين).\nتحسب الدالة العدد الإجمالي للأفراد المصابين بعد 'm' أيام.\nالمدخلات:\n- $dormitory: مصفوفة ثنائية الأبعاد تمثل شبكة السكن n*n.\n- $days: عدد صحيح يمثل عدد الأيام.\nالمخرجات: تعيد العدد الإجمالي للإصابات بالإنفلونزا بعد 'm' أيام.\nمثال:\nالمدخلات: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nالمخرجات: 16",
      "sw": "Andika kazi ya PHP `function countFluInfections($dormitory, $days)` kutatua tatizo lifuatalo:\nHesabu idadi ya maambukizi ya mafua katika bweni baada ya siku kadhaa.\nBweni linaonyeshwa kama gridi ya n*n ambapo kila seli inaweza kuwa na:\n- '.' inawakilisha mtu mwenye afya\n- '#' inawakilisha chumba tupu\n- '@' inawakilisha mtu aliyeambukizwa na mafua\nKila siku, watu walioambukizwa hueneza mafua kwa watu wenye afya walioko karibu (juu, chini, kushoto, kulia).\nKazi inakokotoa jumla ya watu walioambukizwa baada ya siku 'm'.\nIngizo:\n- $dormitory: Safu ya 2D inayowakilisha gridi ya bweni ya n*n.\n- $days: Nambari kamili inayowakilisha idadi ya siku.\nMatokeo: Inarudisha jumla ya maambukizi ya mafua baada ya siku 'm'.\nMfano:\nIngizo: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nMatokeo: 16",
      "tr": "Bir PHP fonksiyonu `function countFluInfections($dormitory, $days)` yazın ve aşağıdaki problemi çözün:\nBelirli bir gün sayısından sonra bir yurt ızgarasındaki grip enfeksiyonlarının sayısını sayar.\nYurt, her hücrenin şu durumlardan birine sahip olabileceği n*n bir ızgara olarak temsil edilir:\n- '.' sağlıklı bir kişiyi temsil eder\n- '#' boş bir odayı temsil eder\n- '@' grip ile enfekte olmuş bir kişiyi temsil eder\nHer gün, enfekte bireyler grip virüsünü bitişik (yukarı, aşağı, sol, sağ) sağlıklı bireylere yayar.\nFonksiyon, 'm' gününden sonra enfekte olmuş toplam birey sayısını hesaplar.\nGirdi:\n- $dormitory: n*n yurt ızgarasını temsil eden bir 2D dizi.\n- $days: Gün sayısını temsil eden bir tamsayı.\nÇıktı: 'm' gününden sonra toplam grip enfeksiyonu sayısını döndürür.\nÖrnek:\nGirdi: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nÇıktı: 16",
      "vi": "Viết một hàm PHP `function countFluInfections($dormitory, $days)` để giải quyết vấn đề sau:\nĐếm số lượng ca nhiễm cúm trong một lưới ký túc xá sau một số ngày nhất định.\nKý túc xá được biểu diễn dưới dạng lưới n*n, trong đó mỗi ô có thể có:\n- '.' đại diện cho một người khỏe mạnh\n- '#' đại diện cho một phòng trống\n- '@' đại diện cho một người bị nhiễm cúm\nMỗi ngày, những người bị nhiễm bệnh lây lan cúm cho những người khỏe mạnh liền kề (trên, dưới, trái, phải).\nHàm tính toán tổng số người bị nhiễm bệnh sau 'm' ngày.\nĐầu vào:\n- $dormitory: Một mảng 2D đại diện cho lưới ký túc xá n*n.\n- $days: Một số nguyên đại diện cho số ngày.\nĐầu ra: Trả về tổng số ca nhiễm cúm sau 'm' ngày.\nVí dụ:\nĐầu vào: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nĐầu ra: 16"
    },
    "instruction_bertscore": {
      "es": "0.9887974451400133",
      "arb": "0.9771511500087947",
      "sw": "0.9581855239668216",
      "tr": "0.9638387432414555",
      "vi": "0.9903845018844821"
    },
    "level": "hard",
    "test": "function main(){\n    assert(countFluInfections([\n        ['.','.','.','.','#'], \n        ['.','#','.','@','.'], \n        ['.','#','@','.','.'], \n        ['#','.','.','.','.'], \n        ['#','.','.','.','.']], 4) === 16);\n    \n\n    assert(countFluInfections([\n            ['.','.','.','.','#'], \n            ['.','#','.','@','.'], \n            ['.','#','@','.','.'], \n            ['#','.','.','.','.'], \n            ['#','.','.','.','.']], 1) === 2);\n    \n\n    assert(countFluInfections([\n                ['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 2) === 7);\n\n    assert(countFluInfections([\n                    ['.','.','.','.','#'], \n                    ['.','#','.','#','.'], \n                    ['.','#','#','.','.'], \n                    ['#','.','.','.','.'], \n                    ['#','.','.','.','.']], 100) === 0);\n}\n\n\nmain();\n?>",
    "entry_point": "countFluInfections",
    "signature": "function countFluInfections($dormitory, $days)",
    "docstring": {
      "en": "Counts the number of flu infections in a dormitory grid after a certain number of days.\nThe dormitory is represented as an n*n grid where each cell can have:\n- '.' representing a healthy person\n- '#' representing an empty room\n- '@' representing a person infected with the flu\nEach day, infected individuals spread the flu to adjacent (up, down, left, right) healthy individuals.\nThe function calculates the total number of infected individuals after 'm' days.\nInput:\n- $dormitory: A 2D array representing the n*n dormitory grid.\n- $days: An integer representing the number of days.\nOutput: Returns the total number of flu infections after 'm' days.\nExample:\nInput: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nOutput: 16",
      "es": "Cuenta el número de infecciones de gripe en una cuadrícula de dormitorio después de un cierto número de días.  \nEl dormitorio se representa como una cuadrícula de n*n donde cada celda puede tener:  \n- '.' representando a una persona sana  \n- '#' representando una habitación vacía  \n- '@' representando a una persona infectada con la gripe  \nCada día, los individuos infectados propagan la gripe a los individuos sanos adyacentes (arriba, abajo, izquierda, derecha).  \nLa función calcula el número total de individuos infectados después de 'm' días.  \nEntrada:  \n- $dormitory: Un array 2D que representa la cuadrícula de dormitorio n*n.  \n- $days: Un entero que representa el número de días.  \nSalida: Devuelve el número total de infecciones de gripe después de 'm' días.  \nEjemplo:  \nEntrada: [['.','.','.','.','#'],  \n['.','#','.','@','.'],  \n['.','#','@','.','.'],  \n['#','.','.','.','.'],  \n['#','.','.','.','.']], 4  \nSalida: 16  ",
      "arb": "يحسب عدد حالات الإصابة بالأنفلونزا في شبكة سكنية بعد عدد معين من الأيام. يتم تمثيل السكن كشبكة n*n حيث يمكن أن تحتوي كل خلية على:\n- '.' تمثل شخصًا سليمًا\n- '#' تمثل غرفة فارغة\n- '@' تمثل شخصًا مصابًا بالأنفلونزا\nكل يوم، ينشر الأفراد المصابون الأنفلونزا إلى الأفراد الأصحاء المجاورين (أعلى، أسفل، يسار، يمين).\nتحسب الدالة العدد الإجمالي للأفراد المصابين بعد 'm' أيام.\nالمدخلات:\n- $dormitory: مصفوفة ثنائية الأبعاد تمثل شبكة السكن n*n.\n- $days: عدد صحيح يمثل عدد الأيام.\nالمخرجات: تعيد العدد الإجمالي لحالات الإصابة بالأنفلونزا بعد 'm' أيام.\nمثال:\nالمدخلات: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nالمخرجات: 16",
      "sw": "Hesabu idadi ya maambukizi ya mafua katika gridi ya bweni baada ya siku kadhaa.\nBweni linawakilishwa kama gridi ya n*n ambapo kila seli inaweza kuwa na:\n- '.' inawakilisha mtu mwenye afya\n- '#' inawakilisha chumba tupu\n- '@' inawakilisha mtu aliyeambukizwa na mafua\nKila siku, watu walioambukizwa hueneza mafua kwa watu wenye afya walioko karibu (juu, chini, kushoto, kulia).\nKazi hii huhesabu jumla ya watu walioambukizwa baada ya siku 'm'.\nIngizo:\n- $dormitory: Kichwa cha safu mbili kinachowakilisha gridi ya bweni ya n*n.\n- $days: Nambari kamili inayowakilisha idadi ya siku.\nPato: Inarudisha jumla ya maambukizi ya mafua baada ya siku 'm'.\nMfano:\nIngizo: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nPato: 16",
      "tr": "Belirli bir gün sayısından sonra bir yurt ızgarasında grip enfeksiyonlarının sayısını sayar.\nYurt, her hücrenin şu durumlardan birine sahip olabileceği bir n*n ızgarası olarak temsil edilir:\n- '.' sağlıklı bir kişiyi temsil eder\n- '#' boş bir odayı temsil eder\n- '@' grip ile enfekte olmuş bir kişiyi temsil eder\nHer gün, enfekte bireyler grip virüsünü bitişik (yukarı, aşağı, sol, sağ) sağlıklı bireylere yayar.\nFonksiyon, 'm' gününden sonra enfekte olmuş toplam birey sayısını hesaplar.\nGirdi:\n- $dormitory: n*n yurt ızgarasını temsil eden bir 2D dizi.\n- $days: Gün sayısını temsil eden bir tamsayı.\nÇıktı: 'm' gününden sonra toplam grip enfeksiyonu sayısını döndürür.\nÖrnek:\nGirdi: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nÇıktı: 16",
      "vi": "Đếm số ca nhiễm cúm trong một lưới ký túc xá sau một số ngày nhất định. Ký túc xá được biểu diễn dưới dạng lưới n*n, trong đó mỗi ô có thể có:\n- '.' đại diện cho một người khỏe mạnh\n- '#' đại diện cho một phòng trống\n- '@' đại diện cho một người bị nhiễm cúm\nMỗi ngày, những người bị nhiễm bệnh lây lan cúm cho những người khỏe mạnh liền kề (trên, dưới, trái, phải).\nHàm tính tổng số người bị nhiễm bệnh sau 'm' ngày.\nĐầu vào:\n- $dormitory: Một mảng 2D đại diện cho lưới ký túc xá n*n.\n- $days: Một số nguyên đại diện cho số ngày.\nĐầu ra: Trả về tổng số ca nhiễm cúm sau 'm' ngày.\nVí dụ:\nĐầu vào: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nĐầu ra: 16"
    },
    "docstring_bertscore": {
      "es": "0.9823493070804777",
      "arb": "0.9453283780328142",
      "sw": "0.9556478222187198",
      "tr": "0.9608686231538408",
      "vi": "0.9824043276960245"
    }
  },
  {
    "task_id": "PHP/34",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Counts the number of unique paths an ant can take to move from the bottom-left to the top-right corner of a grid.\n * The grid is defined by m rows and n columns. The ant starts at (1,1) and can only move right or up due to an injury.\n * - For a 1x1 grid (m = 1, n = 1), there is only 1 path.\n * - For a 2x3 grid (m = 2, n = 3), there are 3 possible paths.\n * Input: Two integers, m and n, representing the number of rows and columns of the grid.\n * Output: Returns the count of unique paths from (1,1) to (m,n).\n */\n\n function countAntPaths($m, $n): int ",
      "es": "<?php\n\n\n/**\n * Cuenta el número de caminos únicos que una hormiga puede tomar para moverse desde la esquina inferior izquierda hasta la esquina superior derecha de una cuadrícula.\n * La cuadrícula está definida por m filas y n columnas. La hormiga comienza en (1,1) y solo puede moverse a la derecha o hacia arriba debido a una lesión.\n * - Para una cuadrícula de 1x1 (m = 1, n = 1), solo hay 1 camino.\n * - Para una cuadrícula de 2x3 (m = 2, n = 3), hay 3 caminos posibles.\n * Entrada: Dos enteros, m y n, que representan el número de filas y columnas de la cuadrícula.\n * Salida: Devuelve el conteo de caminos únicos desde (1,1) hasta (m,n).\n */\n\n function countAntPaths($m, $n): int ",
      "arb": "<?php\n\n\n/**\n * يحسب عدد المسارات الفريدة التي يمكن للنملة أن تسلكها للتحرك من الزاوية السفلية اليسرى إلى الزاوية العلوية اليمنى للشبكة.\n * يتم تعريف الشبكة بواسطة m صفوف و n أعمدة. تبدأ النملة عند (1,1) ويمكنها التحرك فقط إلى اليمين أو للأعلى بسبب إصابة.\n * - لشبكة 1x1 (m = 1, n = 1)، هناك مسار واحد فقط.\n * - لشبكة 2x3 (m = 2, n = 3)، هناك 3 مسارات ممكنة.\n * المدخل: عددان صحيحان، m و n، يمثلان عدد الصفوف والأعمدة في الشبكة.\n * المخرج: يعيد عدد المسارات الفريدة من (1,1) إلى (m,n).\n */\n\n function countAntPaths($m, $n): int ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi ya njia za kipekee ambazo sisimizi anaweza kuchukua kuhamia kutoka kona ya chini-kushoto hadi kona ya juu-kulia ya gridi.\n * Gridi imefafanuliwa na mistari m na safu n. Sisimizi huanza katika (1,1) na anaweza kusonga kulia au juu tu kutokana na jeraha.\n * - Kwa gridi ya 1x1 (m = 1, n = 1), kuna njia 1 tu.\n * - Kwa gridi ya 2x3 (m = 2, n = 3), kuna njia 3 zinazowezekana.\n * Ingizo: Nambari mbili za mzima, m na n, zinazowakilisha idadi ya mistari na safu za gridi.\n * Matokeo: Inarudisha idadi ya njia za kipekee kutoka (1,1) hadi (m,n).\n */\n\n function countAntPaths($m, $n): int ",
      "tr": "<?php\n\n\n/**\n * Bir karıncanın bir ızgaranın sol alt köşesinden sağ üst köşesine hareket etmek için alabileceği benzersiz yolların sayısını sayar.\n * Izgara m satır ve n sütun ile tanımlanır. Karınca (1,1) noktasında başlar ve bir yaralanma nedeniyle sadece sağa veya yukarı hareket edebilir.\n * - 1x1 ızgara için (m = 1, n = 1), sadece 1 yol vardır.\n * - 2x3 ızgara için (m = 2, n = 3), 3 olası yol vardır.\n * Girdi: Izgaranın satır ve sütun sayısını temsil eden iki tamsayı, m ve n.\n * Çıktı: (1,1) noktasından (m,n) noktasına olan benzersiz yolların sayısını döndürür.\n */\n\n function countAntPaths($m, $n): int ",
      "vi": "<?php\n\n\n/**\n * Đếm số lượng đường đi duy nhất mà một con kiến có thể đi từ góc dưới bên trái đến góc trên bên phải của một lưới.\n * Lưới được xác định bởi m hàng và n cột. Con kiến bắt đầu tại (1,1) và chỉ có thể di chuyển sang phải hoặc lên trên do bị thương.\n * - Đối với lưới 1x1 (m = 1, n = 1), chỉ có 1 đường đi.\n * - Đối với lưới 2x3 (m = 2, n = 3), có 3 đường đi khả dĩ.\n * Đầu vào: Hai số nguyên, m và n, đại diện cho số hàng và số cột của lưới.\n * Đầu ra: Trả về số lượng đường đi duy nhất từ (1,1) đến (m,n).\n */\n\n function countAntPaths($m, $n): int "
    },
    "prompt_bertscore": {
      "es": "0.9865743739154709",
      "arb": "0.9857484687911278",
      "sw": "0.9814586484519173",
      "tr": "0.9739031460181122",
      "vi": "0.9839756926403914"
    },
    "canonical_solution": " {\n    // Base case\n    if ($m == 1 || $n == 1) {\n        return 1;\n    }\n\n    // Create a 2D array to store path counts\n    $pathCount = array_fill(0, $m, array_fill(0, $n, 0));\n\n    // Initialize the first row and first column\n    for ($i = 0; $i < $m; $i++) {\n        $pathCount[$i][0] = 1;\n    }\n    for ($j = 0; $j < $n; $j++) {\n        $pathCount[0][$j] = 1;\n    }\n\n    // Calculate path counts for other cells\n    for ($i = 1; $i < $m; $i++) {\n        for ($j = 1; $j < $n; $j++) {\n            $pathCount[$i][$j] = $pathCount[$i - 1][$j] + $pathCount[$i][$j - 1];\n        }\n    }\n\n    return $pathCount[$m - 1][$n - 1];\n}",
    "instruction": {
      "en": "Write a PHP function `function countAntPaths($m, $n): int` to solve the following problem:\nCounts the number of unique paths an ant can take to move from the bottom-left to the top-right corner of a grid.\nThe grid is defined by m rows and n columns. The ant starts at (1,1) and can only move right or up due to an injury.\n- For a 1x1 grid (m = 1, n = 1), there is only 1 path.\n- For a 2x3 grid (m = 2, n = 3), there are 3 possible paths.\nInput: Two integers, m and n, representing the number of rows and columns of the grid.\nOutput: Returns the count of unique paths from (1,1) to (m,n).",
      "es": "Escribe una función PHP `function countAntPaths($m, $n): int` para resolver el siguiente problema:\nCuenta el número de caminos únicos que una hormiga puede tomar para moverse desde la esquina inferior izquierda hasta la esquina superior derecha de una cuadrícula.\nLa cuadrícula está definida por m filas y n columnas. La hormiga comienza en (1,1) y solo puede moverse a la derecha o hacia arriba debido a una lesión.\n- Para una cuadrícula de 1x1 (m = 1, n = 1), solo hay 1 camino.\n- Para una cuadrícula de 2x3 (m = 2, n = 3), hay 3 caminos posibles.\nEntrada: Dos enteros, m y n, que representan el número de filas y columnas de la cuadrícula.\nSalida: Devuelve el conteo de caminos únicos desde (1,1) hasta (m,n).",
      "arb": "اكتب دالة PHP `function countAntPaths($m, $n): int` لحل المشكلة التالية:\nتحسب عدد المسارات الفريدة التي يمكن للنملة أن تسلكها للتحرك من الزاوية السفلية اليسرى إلى الزاوية العلوية اليمنى من الشبكة.\nيتم تعريف الشبكة بواسطة m صفوف و n أعمدة. تبدأ النملة عند (1,1) ويمكنها التحرك فقط إلى اليمين أو إلى الأعلى بسبب إصابة.\n- بالنسبة لشبكة 1x1 (m = 1, n = 1)، هناك مسار واحد فقط.\n- بالنسبة لشبكة 2x3 (m = 2, n = 3)، هناك 3 مسارات ممكنة.\nالمدخلات: عددان صحيحان، m و n، يمثلان عدد الصفوف والأعمدة في الشبكة.\nالمخرجات: تعيد عدد المسارات الفريدة من (1,1) إلى (m,n).",
      "sw": "Andika kazi ya PHP `function countAntPaths($m, $n): int` kutatua tatizo lifuatalo:\nInahesabu idadi ya njia za kipekee ambazo sisimizi anaweza kuchukua kuhamia kutoka kona ya chini-kushoto hadi kona ya juu-kulia ya gridi.\nGridi imefafanuliwa na mistari m na safu n. Sisimizi huanza katika (1,1) na anaweza tu kusonga kulia au juu kutokana na jeraha.\n- Kwa gridi ya 1x1 (m = 1, n = 1), kuna njia 1 tu.\n- Kwa gridi ya 2x3 (m = 2, n = 3), kuna njia 3 zinazowezekana.\nIngizo: Nambari mbili, m na n, zinazowakilisha idadi ya mistari na safu za gridi.\nMatokeo: Inarudisha hesabu ya njia za kipekee kutoka (1,1) hadi (m,n).",
      "tr": "Aşağıdaki problemi çözmek için `function countAntPaths($m, $n): int` adlı bir PHP fonksiyonu yazın:\nBir karıncanın bir ızgaranın sol alt köşesinden sağ üst köşesine hareket etmek için alabileceği benzersiz yolların sayısını sayar.\nIzgara, m satır ve n sütun ile tanımlanır. Karınca (1,1) noktasından başlar ve bir yaralanma nedeniyle sadece sağa veya yukarı hareket edebilir.\n- 1x1 ızgara için (m = 1, n = 1), yalnızca 1 yol vardır.\n- 2x3 ızgara için (m = 2, n = 3), 3 olası yol vardır.\nGirdi: Izgaranın satır ve sütun sayısını temsil eden iki tam sayı, m ve n.\nÇıktı: (1,1) noktasından (m,n) noktasına benzersiz yolların sayısını döndürür.",
      "vi": "Viết một hàm PHP `function countAntPaths($m, $n): int` để giải quyết vấn đề sau:\nĐếm số lượng đường đi duy nhất mà một con kiến có thể đi từ góc dưới bên trái đến góc trên bên phải của một lưới.\nLưới được định nghĩa bởi m hàng và n cột. Con kiến bắt đầu tại (1,1) và chỉ có thể di chuyển sang phải hoặc lên trên do bị thương.\n- Đối với lưới 1x1 (m = 1, n = 1), chỉ có 1 đường đi.\n- Đối với lưới 2x3 (m = 2, n = 3), có 3 đường đi có thể.\nĐầu vào: Hai số nguyên, m và n, đại diện cho số hàng và số cột của lưới.\nĐầu ra: Trả về số lượng đường đi duy nhất từ (1,1) đến (m,n)."
    },
    "instruction_bertscore": {
      "es": "0.9922842028486998",
      "arb": "0.9740821119914247",
      "sw": "0.9856010850483999",
      "tr": "0.9591349771881683",
      "vi": "0.9845827070848341"
    },
    "level": "middle",
    "test": "function main(){\n    assert(countAntPaths(1, 1) === 1); // One path in a 1x1 grid\n    assert(countAntPaths(2, 3) === 3); // Three paths in a 2x3 grid\n    assert(countAntPaths(3, 3) === 6); // Six paths in a 3x3 grid    \n    assert(countAntPaths(7, 13) === 18564);    \n}\n\n\nmain();\n?>",
    "entry_point": "countAntPaths",
    "signature": "function countAntPaths($m, $n): int",
    "docstring": {
      "en": "Counts the number of unique paths an ant can take to move from the bottom-left to the top-right corner of a grid.\nThe grid is defined by m rows and n columns. The ant starts at (1,1) and can only move right or up due to an injury.\n- For a 1x1 grid (m = 1, n = 1), there is only 1 path.\n- For a 2x3 grid (m = 2, n = 3), there are 3 possible paths.\nInput: Two integers, m and n, representing the number of rows and columns of the grid.\nOutput: Returns the count of unique paths from (1,1) to (m,n).",
      "es": "Cuenta el número de caminos únicos que una hormiga puede tomar para moverse desde la esquina inferior izquierda hasta la esquina superior derecha de una cuadrícula.  \nLa cuadrícula está definida por m filas y n columnas. La hormiga comienza en (1,1) y solo puede moverse a la derecha o hacia arriba debido a una lesión.  \n- Para una cuadrícula de 1x1 (m = 1, n = 1), solo hay 1 camino.  \n- Para una cuadrícula de 2x3 (m = 2, n = 3), hay 3 caminos posibles.  \nEntrada: Dos enteros, m y n, que representan el número de filas y columnas de la cuadrícula.  \nSalida: Devuelve el conteo de caminos únicos desde (1,1) hasta (m,n).  ",
      "arb": "يحسب عدد المسارات الفريدة التي يمكن لنملة اتخاذها للتحرك من الزاوية السفلية اليسرى إلى الزاوية العلوية اليمنى لشبكة.\nيتم تعريف الشبكة بواسطة m صفوف و n أعمدة. تبدأ النملة عند (1,1) ويمكنها التحرك فقط إلى اليمين أو إلى الأعلى بسبب إصابة.\n- بالنسبة لشبكة 1x1 (m = 1, n = 1)، هناك مسار واحد فقط.\n- بالنسبة لشبكة 2x3 (m = 2, n = 3)، هناك 3 مسارات ممكنة.\nالمدخلات: عددان صحيحان، m و n، يمثلان عدد الصفوف والأعمدة في الشبكة.\nالمخرجات: يعيد عدد المسارات الفريدة من (1,1) إلى (m,n).",
      "sw": "Hesabu idadi ya njia za kipekee ambazo sisimizi anaweza kuchukua kuhamia kutoka kona ya chini-kushoto hadi kona ya juu-kulia ya gridi.\n\nGridi imefafanuliwa na mistari m na safu n. Sisimizi huanza kwenye (1,1) na anaweza tu kusonga kulia au juu kutokana na jeraha.\n\n- Kwa gridi ya 1x1 (m = 1, n = 1), kuna njia 1 tu.\n- Kwa gridi ya 2x3 (m = 2, n = 3), kuna njia 3 zinazowezekana.\n\nIngizo: Nambari mbili za mzima, m na n, zinazowakilisha idadi ya mistari na safu za gridi.\n\nPato: Inarudisha hesabu ya njia za kipekee kutoka (1,1) hadi (m,n).",
      "tr": "Benzersiz yolların sayısını sayar; bir karınca, bir ızgaranın sol alt köşesinden sağ üst köşesine hareket edebilir.\nIzgara, m satır ve n sütun ile tanımlanır. Karınca (1,1) konumunda başlar ve sadece sağa veya yukarıya hareket edebilir, çünkü yaralanmıştır.\n- 1x1 ızgara için (m = 1, n = 1), yalnızca 1 yol vardır.\n- 2x3 ızgara için (m = 2, n = 3), 3 olası yol vardır.\nGirdi: Izgaranın satır ve sütun sayısını temsil eden iki tamsayı, m ve n.\nÇıktı: (1,1) konumundan (m,n) konumuna benzersiz yolların sayısını döndürür.",
      "vi": "Đếm số lượng đường đi duy nhất mà một con kiến có thể thực hiện để di chuyển từ góc dưới bên trái đến góc trên bên phải của một lưới.\nLưới được xác định bởi m hàng và n cột. Con kiến bắt đầu tại (1,1) và chỉ có thể di chuyển sang phải hoặc lên trên do bị thương.\n- Đối với lưới 1x1 (m = 1, n = 1), chỉ có 1 đường đi.\n- Đối với lưới 2x3 (m = 2, n = 3), có 3 đường đi khả thi.\nĐầu vào: Hai số nguyên, m và n, đại diện cho số hàng và số cột của lưới.\nĐầu ra: Trả về số lượng đường đi duy nhất từ (1,1) đến (m,n)."
    },
    "docstring_bertscore": {
      "es": "0.9888097602236375",
      "arb": "0.9708251696335957",
      "sw": "0.9910892424763939",
      "tr": "0.9533270248467082",
      "vi": "0.9850143309028229"
    }
  },
  {
    "task_id": "PHP/35",
    "prompt": {
      "en": "<?php\n\n/**\n * Determines if there exists at least one permutation of adding '+' or '-' \n * before each number in a sequence such that the sum of the sequence is \n * divisible by a given number k.\n * \n * The function takes two arguments: \n * - $numbers: An array of positive integers representing the sequence.\n * - $k: An integer representing the divisor.\n * \n * The function returns \"YES\" if at least one permutation of the sequence \n * can be divided by $k, otherwise returns \"NO\".\n * \n * Example:\n * Given $numbers = [1, 2, 4] and $k = 2, the function will return \"NO\".\n * Given $numbers = [1, 2, 4] and $k = 3, the function will return \"YES\".\n */\n\n function canBeDivided(array $numbers, int $k): string ",
      "es": "<?php\n\n/**\n * Determina si existe al menos una permutación de agregar '+' o '-' \n * antes de cada número en una secuencia tal que la suma de la secuencia sea \n * divisible por un número dado k.\n * \n * La función toma dos argumentos: \n * - $numbers: Un arreglo de enteros positivos que representa la secuencia.\n * - $k: Un entero que representa el divisor.\n * \n * La función devuelve \"YES\" si al menos una permutación de la secuencia \n * puede ser dividida por $k, de lo contrario devuelve \"NO\".\n * \n * Ejemplo:\n * Dado $numbers = [1, 2, 4] y $k = 2, la función devolverá \"NO\".\n * Dado $numbers = [1, 2, 4] y $k = 3, la función devolverá \"YES\".\n */\n\n function canBeDivided(array $numbers, int $k): string ",
      "arb": "<?php\n\n/**\n * يحدد ما إذا كان هناك على الأقل ترتيب واحد لإضافة '+' أو '-' \n * قبل كل رقم في تسلسل بحيث يكون مجموع التسلسل \n * قابلاً للقسمة على عدد معين k.\n * \n * تأخذ الدالة وسيطين: \n * - $numbers: مصفوفة من الأعداد الصحيحة الموجبة تمثل التسلسل.\n * - $k: عدد صحيح يمثل القاسم.\n * \n * تعيد الدالة \"YES\" إذا كان على الأقل ترتيب واحد للتسلسل \n * يمكن قسمته على $k، وإلا تعيد \"NO\".\n * \n * مثال:\n * إذا كان $numbers = [1, 2, 4] و $k = 2، ستعيد الدالة \"NO\".\n * إذا كان $numbers = [1, 2, 4] و $k = 3، ستعيد الدالة \"YES\".\n */\n\n function canBeDivided(array $numbers, int $k): string ",
      "sw": "<?php\n\n/**\n * Inabainisha kama kuna angalau mpangilio mmoja wa kuongeza '+' au '-' \n * kabla ya kila nambari katika mlolongo ili jumla ya mlolongo iweze \n * kugawanyika kwa nambari fulani k.\n * \n * Kazi inachukua hoja mbili: \n * - $numbers: Safu ya nambari za mzima chanya zinazowakilisha mlolongo.\n * - $k: Nambari ya mzima inayowakilisha mgawanyaji.\n * \n * Kazi inarudisha \"YES\" ikiwa angalau mpangilio mmoja wa mlolongo \n * unaweza kugawanyika kwa $k, vinginevyo inarudisha \"NO\".\n * \n * Mfano:\n * Ukipewa $numbers = [1, 2, 4] na $k = 2, kazi itarudisha \"NO\".\n * Ukipewa $numbers = [1, 2, 4] na $k = 3, kazi itarudisha \"YES\".\n */\n\n function canBeDivided(array $numbers, int $k): string ",
      "tr": "<?php\n\n/**\n * Bir dizideki her sayının önüne '+' veya '-' ekleyerek en az bir permütasyonun \n * toplamının verilen bir sayı k ile bölünebilir olup olmadığını belirler.\n * \n * Fonksiyon iki argüman alır: \n * - $numbers: Diziyi temsil eden pozitif tam sayılardan oluşan bir dizi.\n * - $k: Bölme işlemi için kullanılan tam sayı.\n * \n * Fonksiyon, dizinin en az bir permütasyonunun $k ile bölünebilir olması durumunda \"YES\", \n * aksi takdirde \"NO\" döndürür.\n * \n * Örnek:\n * $numbers = [1, 2, 4] ve $k = 2 verildiğinde, fonksiyon \"NO\" döndürecektir.\n * $numbers = [1, 2, 4] ve $k = 3 verildiğinde, fonksiyon \"YES\" döndürecektir.\n */\n\n function canBeDivided(array $numbers, int $k): string ",
      "vi": "<?php\n\n/**\n * Xác định xem có tồn tại ít nhất một hoán vị của việc thêm '+' hoặc '-' \n * trước mỗi số trong một dãy số sao cho tổng của dãy số đó chia hết cho \n * một số cho trước k.\n * \n * Hàm nhận hai tham số: \n * - $numbers: Một mảng các số nguyên dương đại diện cho dãy số.\n * - $k: Một số nguyên đại diện cho số chia.\n * \n * Hàm trả về \"YES\" nếu ít nhất một hoán vị của dãy số có thể chia hết cho \n * $k, nếu không sẽ trả về \"NO\".\n * \n * Ví dụ:\n * Cho $numbers = [1, 2, 4] và $k = 2, hàm sẽ trả về \"NO\".\n * Cho $numbers = [1, 2, 4] và $k = 3, hàm sẽ trả về \"YES\".\n */\n\n function canBeDivided(array $numbers, int $k): string "
    },
    "prompt_bertscore": {
      "es": "0.9951172679734004",
      "arb": "0.9657074578662317",
      "sw": "0.9711169576633358",
      "tr": "0.9393960830728263",
      "vi": "0.9824285606025107"
    },
    "canonical_solution": " {\n    $totalCombinations = pow(2, count($numbers));\n    for ($i = 0; $i < $totalCombinations; $i++) {\n        $sum = 0;\n        for ($j = 0; $j < count($numbers); $j++) {\n            // Check if the jth bit in i is set to decide if to add or subtract\n            if ($i & (1 << $j)) {\n                $sum += $numbers[$j];\n            } else {\n                $sum -= $numbers[$j];\n            }\n        }\n        if ($sum % $k == 0) {\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}",
    "instruction": {
      "en": "Write a PHP function `function canBeDivided(array $numbers, int $k): string` to solve the following problem:\nDetermines if there exists at least one permutation of adding '+' or '-'\nbefore each number in a sequence such that the sum of the sequence is\ndivisible by a given number k.\n\nThe function takes two arguments:\n- $numbers: An array of positive integers representing the sequence.\n- $k: An integer representing the divisor.\n\nThe function returns \"YES\" if at least one permutation of the sequence\ncan be divided by $k, otherwise returns \"NO\".\n\nExample:\nGiven $numbers = [1, 2, 4] and $k = 2, the function will return \"NO\".\nGiven $numbers = [1, 2, 4] and $k = 3, the function will return \"YES\".",
      "es": "Escribe una función PHP `function canBeDivided(array $numbers, int $k): string` para resolver el siguiente problema:\nDetermina si existe al menos una permutación de añadir '+' o '-'\nantes de cada número en una secuencia tal que la suma de la secuencia sea\ndivisible por un número dado k.\n\nLa función toma dos argumentos:\n- $numbers: Un arreglo de enteros positivos que representa la secuencia.\n- $k: Un entero que representa el divisor.\n\nLa función devuelve \"YES\" si al menos una permutación de la secuencia\npuede ser dividida por $k, de lo contrario devuelve \"NO\".\n\nEjemplo:\nDado $numbers = [1, 2, 4] y $k = 2, la función devolverá \"NO\".\nDado $numbers = [1, 2, 4] y $k = 3, la función devolverá \"YES\".",
      "arb": "اكتب دالة PHP `function canBeDivided(array $numbers, int $k): string` لحل المشكلة التالية:\nتحديد ما إذا كانت هناك على الأقل ترتيب واحد لإضافة '+' أو '-'\nقبل كل رقم في تسلسل بحيث يكون مجموع التسلسل\nقابلاً للقسمة على عدد معين k.\n\nتأخذ الدالة وسيطين:\n- $numbers: مصفوفة من الأعداد الصحيحة الموجبة تمثل التسلسل.\n- $k: عدد صحيح يمثل القاسم.\n\nتُرجع الدالة \"YES\" إذا كان هناك على الأقل ترتيب واحد للتسلسل\nيمكن قسمته على $k، وإلا تُرجع \"NO\".\n\nمثال:\nبالنظر إلى $numbers = [1, 2, 4] و $k = 2، ستُرجع الدالة \"NO\".\nبالنظر إلى $numbers = [1, 2, 4] و $k = 3، ستُرجع الدالة \"YES\".",
      "sw": "Andika kazi ya PHP `function canBeDivided(array $numbers, int $k): string` kutatua tatizo lifuatalo:\nInabainisha kama kuna angalau mpangilio mmoja wa kuongeza '+' au '-'\nkabla ya kila namba katika mlolongo ili jumla ya mlolongo iweze kugawanyika\nkwa namba iliyotolewa k.\n\nKazi inachukua hoja mbili:\n- $numbers: Mlolongo wa namba kamili chanya unaowakilisha mlolongo.\n- $k: Namba kamili inayowakilisha mgawanyaji.\n\nKazi inarudisha \"YES\" ikiwa angalau mpangilio mmoja wa mlolongo\nunaweza kugawanyika kwa $k, vinginevyo inarudisha \"NO\".\n\nMfano:\nUkitolewa $numbers = [1, 2, 4] na $k = 2, kazi itarudisha \"NO\".\nUkitolewa $numbers = [1, 2, 4] na $k = 3, kazi itarudisha \"YES\".",
      "tr": "Bir PHP fonksiyonu `function canBeDivided(array $numbers, int $k): string` yazın ve aşağıdaki problemi çözün:\nBir dizideki her sayının önüne '+' veya '-' ekleyerek en az bir permütasyonun var olup olmadığını belirler,\nböylece dizinin toplamı verilen bir sayı k ile bölünebilir.\n\nFonksiyon iki argüman alır:\n- $numbers: Diziyi temsil eden pozitif tam sayılardan oluşan bir dizi.\n- $k: Böleni temsil eden bir tam sayı.\n\nFonksiyon, dizinin en az bir permütasyonunun $k ile bölünebilir olması durumunda \"YES\" döndürür, aksi takdirde \"NO\" döndürür.\n\nÖrnek:\n$numbers = [1, 2, 4] ve $k = 2 verildiğinde, fonksiyon \"NO\" döndürecektir.\n$numbers = [1, 2, 4] ve $k = 3 verildiğinde, fonksiyon \"YES\" döndürecektir.",
      "vi": "Viết một hàm PHP `function canBeDivided(array $numbers, int $k): string` để giải quyết vấn đề sau:\nXác định xem có tồn tại ít nhất một hoán vị của việc thêm '+' hoặc '-'\ntrước mỗi số trong một dãy số sao cho tổng của dãy số đó chia hết cho một số cho trước k.\n\nHàm nhận hai tham số:\n- $numbers: Một mảng các số nguyên dương đại diện cho dãy số.\n- $k: Một số nguyên đại diện cho số chia.\n\nHàm trả về \"YES\" nếu ít nhất một hoán vị của dãy số có thể chia hết cho $k, nếu không trả về \"NO\".\n\nVí dụ:\nCho $numbers = [1, 2, 4] và $k = 2, hàm sẽ trả về \"NO\".\nCho $numbers = [1, 2, 4] và $k = 3, hàm sẽ trả về \"YES\"."
    },
    "instruction_bertscore": {
      "es": "0.9892002675527521",
      "arb": "0.9642505040213408",
      "sw": "0.9708980669834354",
      "tr": "0.9502144867758915",
      "vi": "0.9819675394881288"
    },
    "level": "middle",
    "test": "function main(){\n    assert(canBeDivided([1, 2, 4], 2) === \"NO\");\n    assert(canBeDivided([1, 2, 4], 3) === \"YES\");\n    assert(canBeDivided([1, 2, 3], 6) === \"YES\");\n    assert(canBeDivided([5, 10, 15], 7) === \"YES\");\n    assert(canBeDivided([10, 20, 30], 10) === \"YES\");\n    \n}\n\n\nmain();\n?>",
    "entry_point": "canBeDivided",
    "signature": "function canBeDivided(array $numbers, int $k): string",
    "docstring": {
      "en": "Determines if there exists at least one permutation of adding '+' or '-'\nbefore each number in a sequence such that the sum of the sequence is\ndivisible by a given number k.\n\nThe function takes two arguments:\n- $numbers: An array of positive integers representing the sequence.\n- $k: An integer representing the divisor.\n\nThe function returns \"YES\" if at least one permutation of the sequence\ncan be divided by $k, otherwise returns \"NO\".\n\nExample:\nGiven $numbers = [1, 2, 4] and $k = 2, the function will return \"NO\".\nGiven $numbers = [1, 2, 4] and $k = 3, the function will return \"YES\".",
      "es": "Determina si existe al menos una permutación de agregar '+' o '-'\nantes de cada número en una secuencia tal que la suma de la secuencia sea\ndivisible por un número dado k.\n\nLa función toma dos argumentos:\n- $numbers: Un arreglo de enteros positivos que representa la secuencia.\n- $k: Un entero que representa el divisor.\n\nLa función devuelve \"YES\" si al menos una permutación de la secuencia\npuede ser dividida por $k, de lo contrario devuelve \"NO\".\n\nEjemplo:\nDado $numbers = [1, 2, 4] y $k = 2, la función devolverá \"NO\".\nDado $numbers = [1, 2, 4] y $k = 3, la función devolverá \"YES\".",
      "arb": "يحدد ما إذا كان هناك على الأقل ترتيب واحد لإضافة '+' أو '-'\nقبل كل رقم في تسلسل بحيث يكون مجموع التسلسل قابلاً للقسمة\nعلى عدد معين k.\n\nتأخذ الدالة وسيطين:\n- $numbers: مصفوفة من الأعداد الصحيحة الموجبة تمثل التسلسل.\n- $k: عدد صحيح يمثل القاسم.\n\nتعيد الدالة \"YES\" إذا كان يمكن تقسيم على الأقل ترتيب واحد من التسلسل\nعلى $k، وإلا تعيد \"NO\".\n\nمثال:\nبالنظر إلى $numbers = [1, 2, 4] و $k = 2، ستعيد الدالة \"NO\".\nبالنظر إلى $numbers = [1, 2, 4] و $k = 3، ستعيد الدالة \"YES\".",
      "sw": "Inabainisha ikiwa kuna angalau mpangilio mmoja wa kuongeza '+' au '-'\nkabla ya kila nambari katika mlolongo ili jumla ya mlolongo iweze\nkugawanyika kwa nambari iliyotolewa k.\n\nKazi inachukua hoja mbili:\n- $numbers: Mfululizo wa nambari za mzima chanya zinazowakilisha mlolongo.\n- $k: Nambari ya mzima inayowakilisha mgawanyaji.\n\nKazi inarejesha \"YES\" ikiwa angalau mpangilio mmoja wa mlolongo\nunaweza kugawanywa na $k, vinginevyo inarejesha \"NO\".\n\nMfano:\nUkipewa $numbers = [1, 2, 4] na $k = 2, kazi itarejesha \"NO\".\nUkipewa $numbers = [1, 2, 4] na $k = 3, kazi itarejesha \"YES\".",
      "tr": "Belirli bir sayının önüne '+' veya '-' eklenerek en az bir permütasyonun var olup olmadığını belirler, böylece dizinin toplamı verilen bir sayı k ile bölünebilir.\n\nFonksiyon iki argüman alır:\n- $numbers: Diziyi temsil eden pozitif tam sayılardan oluşan bir dizi.\n- $k: Böleni temsil eden bir tam sayı.\n\nFonksiyon, dizinin en az bir permütasyonunun $k ile bölünebilmesi durumunda \"YES\" döndürür, aksi takdirde \"NO\" döndürür.\n\nÖrnek:\nVerilen $numbers = [1, 2, 4] ve $k = 2, fonksiyon \"NO\" döndürecektir.\nVerilen $numbers = [1, 2, 4] ve $k = 3, fonksiyon \"YES\" döndürecektir.",
      "vi": "Xác định xem có tồn tại ít nhất một hoán vị của việc thêm '+' hoặc '-'\ntrước mỗi số trong một dãy số sao cho tổng của dãy số đó chia hết cho một số cho trước k hay không.\n\nHàm nhận hai đối số:\n- $numbers: Một mảng các số nguyên dương đại diện cho dãy số.\n- $k: Một số nguyên đại diện cho số chia.\n\nHàm trả về \"YES\" nếu ít nhất một hoán vị của dãy số có thể chia hết cho $k, ngược lại trả về \"NO\".\n\nVí dụ:\nVới $numbers = [1, 2, 4] và $k = 2, hàm sẽ trả về \"NO\".\nVới $numbers = [1, 2, 4] và $k = 3, hàm sẽ trả về \"YES\"."
    },
    "docstring_bertscore": {
      "es": "0.9892243018288573",
      "arb": "0.9709207108468734",
      "sw": "0.969051201700573",
      "tr": "0.946682044079567",
      "vi": "0.9808395175542316"
    }
  },
  {
    "task_id": "PHP/36",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Evaluate a Polish expression and return the result.\n * In Polish notation, operators precede their operands. For example, the expression \"+ 11.0 12.0\" is equivalent to \"11.0 + 12.0\".\n * Supported operators are +, -, *, and /.\n * Input: A string containing a valid Polish expression separated by spaces.\n * Output: A float representing the result of evaluating the expression.\n * \n * Example:\n * - For the input \"+ 11.0 12.0\", the function should return 23.0.\n * - For the input \"* + 2.0 3.0 4.0\", the function should return 20.0.\n */\n\n\n function evaluatePolishExpression($expression) ",
      "es": "<?php\n\n\n/**\n * Evalúa una expresión polaca y devuelve el resultado.\n * En notación polaca, los operadores preceden a sus operandos. Por ejemplo, la expresión \"+ 11.0 12.0\" es equivalente a \"11.0 + 12.0\".\n * Los operadores soportados son +, -, * y /.\n * Entrada: Una cadena que contiene una expresión polaca válida separada por espacios.\n * Salida: Un flotante que representa el resultado de evaluar la expresión.\n * \n * Ejemplo:\n * - Para la entrada \"+ 11.0 12.0\", la función debería devolver 23.0.\n * - Para la entrada \"* + 2.0 3.0 4.0\", la función debería devolver 20.0.\n */\n\n\n function evaluatePolishExpression($expression) ",
      "arb": "<?php\n\n\n/**\n * تقييم تعبير بولندي وإرجاع النتيجة.\n * في التدوين البولندي، تسبق العمليات الحسابية المعاملات. على سبيل المثال، التعبير \"+ 11.0 12.0\" يعادل \"11.0 + 12.0\".\n * العمليات المدعومة هي +، -، *، و /.\n * المدخل: سلسلة تحتوي على تعبير بولندي صالح مفصول بمسافات.\n * المخرج: عدد عشري يمثل نتيجة تقييم التعبير.\n * \n * مثال:\n * - بالنسبة للمدخل \"+ 11.0 12.0\"، يجب أن تعيد الدالة 23.0.\n * - بالنسبة للمدخل \"* + 2.0 3.0 4.0\"، يجب أن تعيد الدالة 20.0.\n */\n\n\n function evaluatePolishExpression($expression) ",
      "sw": "<?php\n\n\n/**\n * Tambua usemi wa Kipolandi na urejeshe matokeo.\n * Katika noti ya Kipolandi, waendeshaji hutangulia wahusika wao. Kwa mfano, usemi \"+ 11.0 12.0\" ni sawa na \"11.0 + 12.0\".\n * Waendeshaji wanaoungwa mkono ni +, -, *, na /.\n * Ingizo: Kamba iliyo na usemi halali wa Kipolandi uliotenganishwa na nafasi.\n * Matokeo: Nambari ya desimali inayowakilisha matokeo ya kutathmini usemi huo.\n * \n * Mfano:\n * - Kwa ingizo \"+ 11.0 12.0\", kazi inapaswa kurejesha 23.0.\n * - Kwa ingizo \"* + 2.0 3.0 4.0\", kazi inapaswa kurejesha 20.0.\n */\n\n\n function evaluatePolishExpression($expression) ",
      "tr": "<?php\n\n\n/**\n * Bir Polonya ifadesini değerlendir ve sonucu döndür.\n * Polonya gösteriminde, operatörler operatörlerin önünde yer alır. Örneğin, \"+ 11.0 12.0\" ifadesi \"11.0 + 12.0\" eşdeğerdir.\n * Desteklenen operatörler +, -, *, ve /'dir.\n * Girdi: Boşluklarla ayrılmış geçerli bir Polonya ifadesi içeren bir dize.\n * Çıktı: İfadenin değerlendirilmesinin sonucunu temsil eden bir float.\n * \n * Örnek:\n * - Girdi \"+ 11.0 12.0\" için, fonksiyon 23.0 döndürmelidir.\n * - Girdi \"* + 2.0 3.0 4.0\" için, fonksiyon 20.0 döndürmelidir.\n */\n\n\n function evaluatePolishExpression($expression) ",
      "vi": "<?php\n\n\n/**\n * Đánh giá một biểu thức Ba Lan và trả về kết quả.\n * Trong ký hiệu Ba Lan, các toán tử đứng trước toán hạng của chúng. Ví dụ, biểu thức \"+ 11.0 12.0\" tương đương với \"11.0 + 12.0\".\n * Các toán tử được hỗ trợ là +, -, *, và /.\n * Đầu vào: Một chuỗi chứa một biểu thức Ba Lan hợp lệ được phân tách bằng dấu cách.\n * Đầu ra: Một số thực đại diện cho kết quả của việc đánh giá biểu thức.\n * \n * Ví dụ:\n * - Với đầu vào \"+ 11.0 12.0\", hàm sẽ trả về 23.0.\n * - Với đầu vào \"* + 2.0 3.0 4.0\", hàm sẽ trả về 20.0.\n */\n\n\n function evaluatePolishExpression($expression) "
    },
    "prompt_bertscore": {
      "es": "0.9917065857006503",
      "arb": "0.9803063936115339",
      "sw": "0.9810041821401095",
      "tr": "0.9923962303836035",
      "vi": "0.9758119839798576"
    },
    "canonical_solution": " {\n    $tokens = explode(' ', $expression);\n    $stack = new SplStack();\n\n    foreach (array_reverse($tokens) as $token) {\n        if (is_numeric($token)) {\n            $stack->push((float)$token);\n        } else {\n            $a = $stack->pop();\n            $b = $stack->pop();\n\n            switch ($token) {\n                case '+':\n                    $stack->push($a + $b);\n                    break;\n                case '-':\n                    $stack->push($a - $b);\n                    break;\n                case '*':\n                    $stack->push($a * $b);\n                    break;\n                case '/':\n                    $stack->push($a / $b);\n                    break;\n            }\n        }\n    }\n\n    return $stack->pop();\n}\n",
    "instruction": {
      "en": "Write a PHP function `function evaluatePolishExpression($expression)` to solve the following problem:\nEvaluate a Polish expression and return the result.\nIn Polish notation, operators precede their operands. For example, the expression \"+ 11.0 12.0\" is equivalent to \"11.0 + 12.0\".\nSupported operators are +, -, *, and /.\nInput: A string containing a valid Polish expression separated by spaces.\nOutput: A float representing the result of evaluating the expression.\n\nExample:\n- For the input \"+ 11.0 12.0\", the function should return 23.0.\n- For the input \"* + 2.0 3.0 4.0\", the function should return 20.0.",
      "es": "Escribe una función PHP `function evaluatePolishExpression($expression)` para resolver el siguiente problema:\nEvalúa una expresión polaca y devuelve el resultado.\nEn la notación polaca, los operadores preceden a sus operandos. Por ejemplo, la expresión \"+ 11.0 12.0\" es equivalente a \"11.0 + 12.0\".\nLos operadores soportados son +, -, *, y /.\nEntrada: Una cadena que contiene una expresión polaca válida separada por espacios.\nSalida: Un flotante que representa el resultado de evaluar la expresión.\n\nEjemplo:\n- Para la entrada \"+ 11.0 12.0\", la función debería devolver 23.0.\n- Para la entrada \"* + 2.0 3.0 4.0\", la función debería devolver 20.0.",
      "arb": "اكتب دالة PHP `function evaluatePolishExpression($expression)` لحل المشكلة التالية:\nتقييم تعبير بولندي وإرجاع النتيجة.\nفي الترميز البولندي، تسبق العمليات الحسابية المعاملات. على سبيل المثال، التعبير \"+ 11.0 12.0\" يعادل \"11.0 + 12.0\".\nالعمليات المدعومة هي +، -، *، و /.\nالمدخل: سلسلة تحتوي على تعبير بولندي صالح مفصول بمسافات.\nالمخرج: عدد عشري يمثل نتيجة تقييم التعبير.\n\nمثال:\n- للمدخل \"+ 11.0 12.0\"، يجب أن تعيد الدالة 23.0.\n- للمدخل \"* + 2.0 3.0 4.0\"، يجب أن تعيد الدالة 20.0.",
      "sw": "Andika kazi ya PHP `function evaluatePolishExpression($expression)` kutatua tatizo lifuatalo:\nTambua maelezo ya Kipolandi na rudisha matokeo.\nKatika noti ya Kipolandi, waendeshaji hutangulia wahusika wao. Kwa mfano, maelezo \"+ 11.0 12.0\" ni sawa na \"11.0 + 12.0\".\nWaendeshaji wanaoungwa mkono ni +, -, *, na /.\nIngizo: Kamba iliyo na maelezo sahihi ya Kipolandi iliyotenganishwa na nafasi.\nPato: Nambari ya kuelea inayowakilisha matokeo ya kutathmini maelezo.\n\nMfano:\n- Kwa ingizo \"+ 11.0 12.0\", kazi inapaswa kurudisha 23.0.\n- Kwa ingizo \"* + 2.0 3.0 4.0\", kazi inapaswa kurudisha 20.0.",
      "tr": "Bir PHP fonksiyonu `function evaluatePolishExpression($expression)` yazın ve aşağıdaki problemi çözün:\nBir Polonya ifadesini değerlendirin ve sonucu döndürün.\nPolonya gösteriminde, operatörler operatörlerin önünde yer alır. Örneğin, \"+ 11.0 12.0\" ifadesi \"11.0 + 12.0\" ifadesine eşdeğerdir.\nDesteklenen operatörler +, -, * ve /'dir.\nGirdi: Boşluklarla ayrılmış geçerli bir Polonya ifadesi içeren bir dize.\nÇıktı: İfadenin değerlendirilmesinin sonucunu temsil eden bir float.\n\nÖrnek:\n- Girdi \"+ 11.0 12.0\" için, fonksiyon 23.0 döndürmelidir.\n- Girdi \"* + 2.0 3.0 4.0\" için, fonksiyon 20.0 döndürmelidir.",
      "vi": "Viết một hàm PHP `function evaluatePolishExpression($expression)` để giải quyết vấn đề sau:\nĐánh giá một biểu thức Ba Lan và trả về kết quả.\nTrong ký pháp Ba Lan, các toán tử đứng trước toán hạng của chúng. Ví dụ, biểu thức \"+ 11.0 12.0\" tương đương với \"11.0 + 12.0\".\nCác toán tử được hỗ trợ là +, -, *, và /.\nĐầu vào: Một chuỗi chứa một biểu thức Ba Lan hợp lệ được phân tách bằng dấu cách.\nĐầu ra: Một số thực đại diện cho kết quả của việc đánh giá biểu thức.\n\nVí dụ:\n- Với đầu vào \"+ 11.0 12.0\", hàm nên trả về 23.0.\n- Với đầu vào \"* + 2.0 3.0 4.0\", hàm nên trả về 20.0."
    },
    "instruction_bertscore": {
      "es": "0.9939354172062428",
      "arb": "0.9729006584850292",
      "sw": "0.9713048620037948",
      "tr": "0.9799832219815902",
      "vi": "0.9779415002949325"
    },
    "level": "hard",
    "test": "function main(){\n    assert(evaluatePolishExpression(\"* + 11.0 12.0 + 24.0 35.0\") === 1357.0);\n    assert(evaluatePolishExpression(\"+ 2.0 2.0\") === 4.0);\n    assert(evaluatePolishExpression(\"- 10.0 5.0\") === 5.0);\n    // Testcase 1\n    $expression1 = \"+ 11.0 12.0\";\n    $result1 = evaluatePolishExpression($expression1);\n    assert($result1 === 23.0);\n\n    // Testcase 2\n    $expression2 = \"* + 2.0 3.0 4.0\";\n    $result2 = evaluatePolishExpression($expression2);\n    assert($result2 === 20.0);\n\n\n\n}\n\nmain();\n?>",
    "entry_point": "evaluatePolishExpression",
    "signature": "function evaluatePolishExpression($expression)",
    "docstring": {
      "en": "Evaluate a Polish expression and return the result.\nIn Polish notation, operators precede their operands. For example, the expression \"+ 11.0 12.0\" is equivalent to \"11.0 + 12.0\".\nSupported operators are +, -, *, and /.\nInput: A string containing a valid Polish expression separated by spaces.\nOutput: A float representing the result of evaluating the expression.\n\nExample:\n- For the input \"+ 11.0 12.0\", the function should return 23.0.\n- For the input \"* + 2.0 3.0 4.0\", the function should return 20.0.",
      "es": "Evaluar una expresión en notación polaca y devolver el resultado.  \nEn notación polaca, los operadores preceden a sus operandos. Por ejemplo, la expresión \"+ 11.0 12.0\" es equivalente a \"11.0 + 12.0\".  \nLos operadores soportados son +, -, *, y /.  \nEntrada: Una cadena que contiene una expresión polaca válida separada por espacios.  \nSalida: Un número flotante que representa el resultado de evaluar la expresión.  \n\nEjemplo:  \n- Para la entrada \"+ 11.0 12.0\", la función debería devolver 23.0.  \n- Para la entrada \"* + 2.0 3.0 4.0\", la función debería devolver 20.0.  ",
      "arb": "تقييم تعبير بولندي وإرجاع النتيجة.  \nفي التدوين البولندي، تسبق العوامل المعاملات الخاصة بها. على سبيل المثال، التعبير \"+ 11.0 12.0\" يعادل \"11.0 + 12.0\".  \nالعوامل المدعومة هي +، -، *، و /.  \nالمدخلات: سلسلة تحتوي على تعبير بولندي صالح مفصول بمسافات.  \nالمخرجات: عدد عشري يمثل نتيجة تقييم التعبير.\n\nمثال:  \n- بالنسبة للمدخل \"+ 11.0 12.0\"، يجب أن تعيد الدالة 23.0.  \n- بالنسبة للمدخل \"* + 2.0 3.0 4.0\"، يجب أن تعيد الدالة 20.0.",
      "sw": "Tambua usemi wa Kipolandi na urejeshe matokeo.  \nKatika noti ya Kipolandi, waendeshaji hutangulia wahusika wao. Kwa mfano, usemi \"+ 11.0 12.0\" ni sawa na \"11.0 + 12.0\".  \nWaendeshaji wanaoungwa mkono ni +, -, *, na /.  \nIngizo: Kamba iliyo na usemi halali wa Kipolandi uliotenganishwa na nafasi.  \nPato: Nambari ya aina ya float inayoashiria matokeo ya kutathmini usemi huo.\n\nMfano:  \n- Kwa ingizo \"+ 11.0 12.0\", kazi inapaswa kurejesha 23.0.  \n- Kwa ingizo \"* + 2.0 3.0 4.0\", kazi inapaswa kurejesha 20.0.",
      "tr": "Bir Polonya ifadesini değerlendir ve sonucu döndür.\nPolonya gösteriminde, operatörler operantlarından önce gelir. Örneğin, \"+ 11.0 12.0\" ifadesi \"11.0 + 12.0\" ifadesine eşdeğerdir.\nDesteklenen operatörler +, -, * ve /'dir.\nGirdi: Boşluklarla ayrılmış geçerli bir Polonya ifadesi içeren bir dize.\nÇıktı: İfadenin değerlendirilmesinin sonucunu temsil eden bir float.\n\nÖrnek:\n- Girdi \"+ 11.0 12.0\" için, fonksiyon 23.0 döndürmelidir.\n- Girdi \"* + 2.0 3.0 4.0\" için, fonksiyon 20.0 döndürmelidir.",
      "vi": "Đánh giá một biểu thức Ba Lan và trả về kết quả. Trong ký hiệu Ba Lan, các toán tử đứng trước các toán hạng của chúng. Ví dụ, biểu thức \"+ 11.0 12.0\" tương đương với \"11.0 + 12.0\". Các toán tử được hỗ trợ là +, -, *, và /. \n\nĐầu vào: Một chuỗi chứa một biểu thức Ba Lan hợp lệ được phân tách bằng dấu cách. Đầu ra: Một số thực biểu diễn kết quả của việc đánh giá biểu thức.\n\nVí dụ:\n- Với đầu vào \"+ 11.0 12.0\", hàm sẽ trả về 23.0.\n- Với đầu vào \"* + 2.0 3.0 4.0\", hàm sẽ trả về 20.0."
    },
    "docstring_bertscore": {
      "es": "0.9710947110606599",
      "arb": "0.9818118132693974",
      "sw": "0.9840070762405949",
      "tr": "0.9767562728112974",
      "vi": "0.9736568443456289"
    }
  },
  {
    "task_id": "PHP/37",
    "prompt": {
      "en": "<?php\n/**\n * Question Description:\nYou are given a string consisting of distinct lowercase letters. Your task is to write a function generatePermutations that generates all possible permutations of the input string and returns them in lexicographical order.\n\nInput:\nA string consisting of distinct lowercase letters, where the length of the string is at most 6.\n\nOutput:\nAn array containing all permutations of the input string, sorted in lexicographical order.\n\nExample:\n    $permutations = generatePermutations(\"abc\");\n    $permutations should contain the following array:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) ",
      "es": "<?php\n/**\n * Descripción de la pregunta:\nSe te da una cadena que consiste en letras minúsculas distintas. Tu tarea es escribir una función generatePermutations que genere todas las permutaciones posibles de la cadena de entrada y las devuelva en orden lexicográfico.\n\nEntrada:\nUna cadena que consiste en letras minúsculas distintas, donde la longitud de la cadena es como máximo 6.\n\nSalida:\nUn arreglo que contiene todas las permutaciones de la cadena de entrada, ordenadas en orden lexicográfico.\n\nEjemplo:\n    $permutations = generatePermutations(\"abc\");\n    $permutations debería contener el siguiente arreglo:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) ",
      "arb": "<?php\n/**\n * وصف السؤال:\nلديك سلسلة تتكون من أحرف صغيرة مميزة. مهمتك هي كتابة دالة generatePermutations التي تولد جميع التباديل الممكنة للسلسلة المدخلة وتعيدها بترتيب معجمي.\n\nالمدخل:\nسلسلة تتكون من أحرف صغيرة مميزة، حيث لا يزيد طول السلسلة عن 6.\n\nالمخرج:\nمصفوفة تحتوي على جميع التباديل للسلسلة المدخلة، مرتبة بترتيب معجمي.\n\nمثال:\n    $permutations = generatePermutations(\"abc\");\n    يجب أن تحتوي $permutations على المصفوفة التالية:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) ",
      "sw": "<?php\n/**\n * Maelezo ya Swali:\nUnapewa kamba inayojumuisha herufi ndogo za kipekee. Kazi yako ni kuandika kazi generatePermutations ambayo inazalisha mchanganyiko wote unaowezekana wa kamba ya ingizo na kuzirudisha kwa mpangilio wa kamusi.\n\nIngizo:\nKamba inayojumuisha herufi ndogo za kipekee, ambapo urefu wa kamba ni zaidi ya 6.\n\nPato:\nArray inayojumuisha mchanganyiko yote ya kamba ya ingizo, iliyopangwa kwa mpangilio wa kamusi.\n\nMfano:\n    $permutations = generatePermutations(\"abc\");\n    $permutations inapaswa kuwa na array ifuatayo:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) ",
      "tr": "<?php\n/**\n * Soru Açıklaması:\nElinizde farklı küçük harflerden oluşan bir dize var. Göreviniz, girdi dizisinin tüm olası permütasyonlarını üreten ve bunları sözlük sırasına göre döndüren bir generatePermutations fonksiyonu yazmaktır.\n\nGirdi:\nDizinin uzunluğunun en fazla 6 olduğu, farklı küçük harflerden oluşan bir dize.\n\nÇıktı:\nGirdi dizisinin tüm permütasyonlarını içeren ve sözlük sırasına göre sıralanmış bir dizi.\n\nÖrnek:\n    $permutations = generatePermutations(\"abc\");\n    $permutations aşağıdaki diziyi içermelidir:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) ",
      "vi": "<?php\n/**\n * Mô tả câu hỏi:\nBạn được cung cấp một chuỗi gồm các chữ cái thường khác nhau. Nhiệm vụ của bạn là viết một hàm generatePermutations để tạo ra tất cả các hoán vị có thể của chuỗi đầu vào và trả về chúng theo thứ tự từ điển.\n\nĐầu vào:\nMột chuỗi gồm các chữ cái thường khác nhau, trong đó độ dài của chuỗi tối đa là 6.\n\nĐầu ra:\nMột mảng chứa tất cả các hoán vị của chuỗi đầu vào, được sắp xếp theo thứ tự từ điển.\n\nVí dụ:\n    $permutations = generatePermutations(\"abc\");\n    $permutations nên chứa mảng sau:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) "
    },
    "prompt_bertscore": {
      "es": "0.9942975203908694",
      "arb": "0.9759359293376233",
      "sw": "0.9810975384191959",
      "tr": "0.9660286431923651",
      "vi": "0.9818878887053337"
    },
    "canonical_solution": " {\n    // Base case: if the string is empty, return an empty array\n    if (strlen($str) == 0) {\n        return [];\n    }\n\n    // If the string has only one character, return an array with that character\n    if (strlen($str) == 1) {\n        return [$str];\n    }\n\n    $permutations = [];\n\n    // Iterate through each character in the string\n    for ($i = 0; $i < strlen($str); $i++) {\n        // Remove the character at index $i\n        $char = $str[$i];\n        $remaining = substr($str, 0, $i) . substr($str, $i + 1);\n\n        // Generate permutations of the remaining string\n        $remainingPermutations = generatePermutations($remaining);\n\n        // Prepend the removed character to each permutation\n        foreach ($remainingPermutations as $perm) {\n            $permutations[] = $char . $perm;\n        }\n    }\n\n    // Sort the permutations in lexicographical order\n    sort($permutations);\n\n\n    return $permutations;\n}",
    "instruction": {
      "en": "Write a PHP function `function generatePermutations($str)` to solve the following problem:\nQuestion Description:\nYou are given a string consisting of distinct lowercase letters. Your task is to write a function generatePermutations that generates all possible permutations of the input string and returns them in lexicographical order.\n\nInput:\nA string consisting of distinct lowercase letters, where the length of the string is at most 6.\n\nOutput:\nAn array containing all permutations of the input string, sorted in lexicographical order.\n\nExample:\n$permutations = generatePermutations(\"abc\");\n$permutations should contain the following array:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "es": "Escribe una función PHP `function generatePermutations($str)` para resolver el siguiente problema:\nDescripción de la pregunta:\nSe te da una cadena que consiste en letras minúsculas distintas. Tu tarea es escribir una función generatePermutations que genere todas las permutaciones posibles de la cadena de entrada y las devuelva en orden lexicográfico.\n\nEntrada:\nUna cadena que consiste en letras minúsculas distintas, donde la longitud de la cadena es como máximo 6.\n\nSalida:\nUn arreglo que contiene todas las permutaciones de la cadena de entrada, ordenadas en orden lexicográfico.\n\nEjemplo:\n$permutations = generatePermutations(\"abc\");\n$permutations debería contener el siguiente arreglo:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "arb": "اكتب دالة PHP `function generatePermutations($str)` لحل المشكلة التالية:\nوصف السؤال:\nلديك سلسلة تتكون من أحرف صغيرة مميزة. مهمتك هي كتابة دالة generatePermutations التي تولد جميع التباديل الممكنة للسلسلة المدخلة وتعيدها بترتيب معجمي.\n\nالمدخل:\nسلسلة تتكون من أحرف صغيرة مميزة، حيث أن طول السلسلة لا يزيد عن 6.\n\nالمخرج:\nمصفوفة تحتوي على جميع التباديل للسلسلة المدخلة، مرتبة بترتيب معجمي.\n\nمثال:\n$permutations = generatePermutations(\"abc\");\nيجب أن تحتوي $permutations على المصفوفة التالية:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "sw": "Andika kazi ya PHP `function generatePermutations($str)` kutatua tatizo lifuatalo:\nMaelezo ya Swali:\nUmepewa kamba inayojumuisha herufi ndogo za kipekee. Kazi yako ni kuandika kazi generatePermutations ambayo inazalisha mchanganyiko wote unaowezekana wa kamba ya pembejeo na kuzirudisha katika mpangilio wa herufi.\n\nIngizo:\nKamba inayojumuisha herufi ndogo za kipekee, ambapo urefu wa kamba ni zaidi ya 6.\n\nPato:\nArray inayojumuisha mchanganyiko yote ya kamba ya pembejeo, iliyopangwa katika mpangilio wa herufi.\n\nMfano:\n$permutations = generatePermutations(\"abc\");\n$permutations inapaswa kuwa na array ifuatayo:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "tr": "Bir PHP fonksiyonu `function generatePermutations($str)` yazın ve aşağıdaki problemi çözün:\nSoru Açıklaması:\nSize farklı küçük harflerden oluşan bir dize veriliyor. Göreviniz, giriş dizisinin tüm olası permütasyonlarını üreten ve bunları sözlük sırasına göre döndüren bir generatePermutations fonksiyonu yazmaktır.\n\nGirdi:\nEn fazla 6 uzunluğunda olan, farklı küçük harflerden oluşan bir dize.\n\nÇıktı:\nGiriş dizisinin tüm permütasyonlarını içeren ve sözlük sırasına göre sıralanmış bir dizi.\n\nÖrnek:\n$permutations = generatePermutations(\"abc\");\n$permutations aşağıdaki diziyi içermelidir:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "vi": "Viết một hàm PHP `function generatePermutations($str)` để giải quyết vấn đề sau:\n\nMô tả câu hỏi:\nBạn được cung cấp một chuỗi bao gồm các chữ cái thường khác nhau. Nhiệm vụ của bạn là viết một hàm generatePermutations để tạo ra tất cả các hoán vị có thể của chuỗi đầu vào và trả về chúng theo thứ tự từ điển.\n\nĐầu vào:\nMột chuỗi bao gồm các chữ cái thường khác nhau, trong đó độ dài của chuỗi tối đa là 6.\n\nĐầu ra:\nMột mảng chứa tất cả các hoán vị của chuỗi đầu vào, được sắp xếp theo thứ tự từ điển.\n\nVí dụ:\n$permutations = generatePermutations(\"abc\");\n$permutations nên chứa mảng sau:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]"
    },
    "instruction_bertscore": {
      "es": "0.994079026971731",
      "arb": "0.9778886646135773",
      "sw": "0.9824349167747038",
      "tr": "0.9722978152785883",
      "vi": "0.980027516556561"
    },
    "level": "hard",
    "test": "function main(){\n    $permutations = generatePermutations(\"abc\");\n    assert($permutations === [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]);\n    $permutations = generatePermutations(\"abcd\");\n    assert($permutations === [\"abcd\",\"abdc\",\"acbd\",\"acdb\",\"adbc\",\"adcb\",\"bacd\",\"badc\",\"bcad\",\"bcda\",\"bdac\",\"bdca\",\"cabd\",\"cadb\",\"cbad\",\"cbda\",\"cdab\",\"cdba\",\"dabc\",\"dacb\",\"dbac\",\"dbca\",\"dcab\",\"dcba\"]);\n\n}\n\n\nmain();\n?>",
    "entry_point": "generatePermutations",
    "signature": "function generatePermutations($str)",
    "docstring": {
      "en": "Question Description:\nYou are given a string consisting of distinct lowercase letters. Your task is to write a function generatePermutations that generates all possible permutations of the input string and returns them in lexicographical order.\n\nInput:\nA string consisting of distinct lowercase letters, where the length of the string is at most 6.\n\nOutput:\nAn array containing all permutations of the input string, sorted in lexicographical order.\n\nExample:\n$permutations = generatePermutations(\"abc\");\n$permutations should contain the following array:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "es": "Descripción de la pregunta:\nSe te da una cadena que consiste en letras minúsculas distintas. Tu tarea es escribir una función generatePermutations que genere todas las posibles permutaciones de la cadena de entrada y las devuelva en orden lexicográfico.\n\nEntrada:\nUna cadena que consiste en letras minúsculas distintas, donde la longitud de la cadena es como máximo 6.\n\nSalida:\nUn arreglo que contiene todas las permutaciones de la cadena de entrada, ordenadas en orden lexicográfico.\n\nEjemplo:\n$permutations = generatePermutations(\"abc\");\n$permutations debería contener el siguiente arreglo:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "arb": "وصف السؤال:\nلديك سلسلة تتكون من حروف صغيرة مميزة. مهمتك هي كتابة دالة generatePermutations التي تولد جميع التباديل الممكنة للسلسلة المدخلة وتعيدها بترتيب معجمي.\n\nالمدخل:\nسلسلة تتكون من حروف صغيرة مميزة، حيث أن طول السلسلة لا يتجاوز 6.\n\nالمخرج:\nمصفوفة تحتوي على جميع التباديل للسلسلة المدخلة، مرتبة بترتيب معجمي.\n\nمثال:\n$permutations = generatePermutations(\"abc\");\nيجب أن تحتوي $permutations على المصفوفة التالية:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "sw": "Maelezo ya Swali:\nUmepewa kamba inayojumuisha herufi ndogo za kipekee. Kazi yako ni kuandika kazi generatePermutations ambayo inazalisha mchanganyiko wote unaowezekana wa kamba ya pembejeo na kuyarudisha kwa mpangilio wa kamusi.\n\nPembejeo:\nKamba inayojumuisha herufi ndogo za kipekee, ambapo urefu wa kamba ni zaidi ya 6.\n\nMatokeo:\nArray inayojumuisha mchanganyiko yote ya kamba ya pembejeo, iliyopangwa kwa mpangilio wa kamusi.\n\nMfano:\n$permutations = generatePermutations(\"abc\");\n$permutations inapaswa kuwa na array ifuatayo:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "tr": "Soru Açıklaması:\nSize, farklı küçük harflerden oluşan bir dize verilmektedir. Göreviniz, girdi dizisinin tüm olası permütasyonlarını üreten ve bunları sözlük sırasına göre döndüren generatePermutations adlı bir fonksiyon yazmaktır.\n\nGirdi:\nDizinin uzunluğunun en fazla 6 olduğu, farklı küçük harflerden oluşan bir dize.\n\nÇıktı:\nGirdi dizisinin tüm permütasyonlarını içeren ve sözlük sırasına göre sıralanmış bir dizi.\n\nÖrnek:\n$permutations = generatePermutations(\"abc\");\n$permutations aşağıdaki diziyi içermelidir:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "vi": "Mô tả Câu hỏi:\nBạn được cung cấp một chuỗi gồm các chữ cái thường khác nhau. Nhiệm vụ của bạn là viết một hàm generatePermutations để tạo ra tất cả các hoán vị có thể của chuỗi đầu vào và trả về chúng theo thứ tự từ điển.\n\nĐầu vào:\nMột chuỗi gồm các chữ cái thường khác nhau, trong đó độ dài của chuỗi tối đa là 6.\n\nĐầu ra:\nMột mảng chứa tất cả các hoán vị của chuỗi đầu vào, được sắp xếp theo thứ tự từ điển.\n\nVí dụ:\n$permutations = generatePermutations(\"abc\");\n$permutations nên chứa mảng sau:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]"
    },
    "docstring_bertscore": {
      "es": "0.9848093443495949",
      "arb": "0.9649200870358094",
      "sw": "0.9346637142446701",
      "tr": "0.9698256615562281",
      "vi": "0.9672142679367624"
    }
  },
  {
    "task_id": "PHP/38",
    "prompt": {
      "en": "<?php\n\n/**\n * Question:\n * You have M identical apples that need to be placed into N identical plates. You are allowed\n * to have some plates empty. How many different ways are there to distribute the apples into the plates?\n * 5,1,1 and 1,5,1 are the same division method.\n *\n * Example:\n * - Input: M = 7, N = 3\n * - Output: 8\n\n */\n\n function countDistributionMethods($M, $N) ",
      "es": "<?php\n\n/**\n * Pregunta:\n * Tienes M manzanas idénticas que deben colocarse en N platos idénticos. Se permite\n * tener algunos platos vacíos. ¿Cuántas formas diferentes hay de distribuir las manzanas en los platos?\n * 5,1,1 y 1,5,1 son el mismo método de división.\n *\n * Ejemplo:\n * - Entrada: M = 7, N = 3\n * - Salida: 8\n\n */\n\n function countDistributionMethods($M, $N) ",
      "arb": "<?php\n\n/**\n * سؤال:\n * لديك M من التفاح المتطابق الذي يجب وضعه في N من الأطباق المتطابقة. يُسمح لك\n * أن يكون لديك بعض الأطباق فارغة. كم عدد الطرق المختلفة لتوزيع التفاح في الأطباق؟\n * 5,1,1 و 1,5,1 هما نفس طريقة التقسيم.\n *\n * مثال:\n * - المدخل: M = 7, N = 3\n * - المخرج: 8\n */\n\n function countDistributionMethods($M, $N) ",
      "sw": "<?php\n\n/**\n * Swali:\n * Una maapulo M yanayofanana ambayo yanahitaji kuwekwa kwenye sahani N zinazofanana. Unaruhusiwa\n * kuwa na baadhi ya sahani tupu. Kuna njia ngapi tofauti za kugawa maapulo kwenye sahani?\n * 5,1,1 na 1,5,1 ni njia sawa ya kugawa.\n *\n * Mfano:\n * - Ingizo: M = 7, N = 3\n * - Matokeo: 8\n\n */\n\n function countDistributionMethods($M, $N) ",
      "tr": "<?php\n\n/**\n * Soru:\n * M adet özdeş elmayı N adet özdeş tabağa yerleştirmeniz gerekiyor. Bazı tabakların boş olmasına izin veriliyor.\n * Elmaları tabaklara dağıtmanın kaç farklı yolu vardır?\n * 5,1,1 ve 1,5,1 aynı bölme yöntemidir.\n *\n * Örnek:\n * - Girdi: M = 7, N = 3\n * - Çıktı: 8\n\n */\n\n function countDistributionMethods($M, $N) ",
      "vi": "<?php\n\n/**\n * Câu hỏi:\n * Bạn có M quả táo giống hệt nhau cần được đặt vào N đĩa giống hệt nhau. Bạn được phép\n * để một số đĩa trống. Có bao nhiêu cách khác nhau để phân phối táo vào các đĩa?\n * 5,1,1 và 1,5,1 là cùng một phương pháp phân chia.\n *\n * Ví dụ:\n * - Đầu vào: M = 7, N = 3\n * - Đầu ra: 8\n\n */\n\n function countDistributionMethods($M, $N) "
    },
    "prompt_bertscore": {
      "es": "0.9840231653014587",
      "arb": "0.9890399728352569",
      "sw": "0.970331771767105",
      "tr": "0.9612003358901691",
      "vi": "0.9809980245982974"
    },
    "canonical_solution": " {\n    // Initialize a 2D array to store the number of ways to distribute M apples into N plates\n    $dp = array_fill(0, $M + 1, array_fill(0, $N + 1, 0));\n\n    // There is one way to distribute 0 apples into any number of plates\n    for ($i = 0; $i <= $N; $i++) {\n        $dp[0][$i] = 1;\n    }\n\n    // Fill the dp array\n    for ($i = 1; $i <= $M; $i++) {\n        for ($j = 1; $j <= $N; $j++) {\n            // If the number of apples is less than the number of plates,\n            // the number of ways is the same as the number of ways to distribute i apples into j - 1 plates\n            if ($i < $j) {\n                $dp[$i][$j] = $dp[$i][$j - 1];\n            } else {\n                // Otherwise, the number of ways is the sum of the number of ways to distribute i apples into j - 1 plates\n                // and the number of ways to distribute i - j apples into j plates\n                $dp[$i][$j] = $dp[$i][$j - 1] + $dp[$i - $j][$j];\n            }\n        }\n    }\n\n    // The number of ways to distribute M apples into N plates is stored in dp[M][N]\n    return $dp[$M][$N];\n}\n",
    "instruction": {
      "en": "Write a PHP function `function countDistributionMethods($M, $N)` to solve the following problem:\nQuestion:\nYou have M identical apples that need to be placed into N identical plates. You are allowed\nto have some plates empty. How many different ways are there to distribute the apples into the plates?\n5,1,1 and 1,5,1 are the same division method.\n\nExample:\n- Input: M = 7, N = 3\n- Output: 8",
      "es": "Escribe una función PHP `function countDistributionMethods($M, $N)` para resolver el siguiente problema:\nPregunta:\nTienes M manzanas idénticas que deben colocarse en N platos idénticos. Se permite\ntener algunos platos vacíos. ¿Cuántas formas diferentes hay de distribuir las manzanas en los platos?\n5,1,1 y 1,5,1 son el mismo método de división.\n\nEjemplo:\n- Entrada: M = 7, N = 3\n- Salida: 8",
      "arb": "اكتب دالة PHP `function countDistributionMethods($M, $N)` لحل المشكلة التالية:\nالسؤال:\nلديك M تفاحة متطابقة تحتاج إلى وضعها في N طبق متطابق. يُسمح لك بترك بعض الأطباق فارغة. كم عدد الطرق المختلفة لتوزيع التفاح في الأطباق؟\n5,1,1 و 1,5,1 هما نفس طريقة التقسيم.\n\nمثال:\n- المدخل: M = 7, N = 3\n- المخرج: 8",
      "sw": "Andika kazi ya PHP `function countDistributionMethods($M, $N)` kutatua tatizo lifuatalo:  \nSwali:  \nUna maapulo M yanayofanana ambayo yanahitaji kuwekwa kwenye sahani N zinazofanana. Unaruhusiwa kuwa na baadhi ya sahani tupu. Kuna njia ngapi tofauti za kugawa maapulo kwenye sahani?  \n5,1,1 na 1,5,1 ni njia sawa ya mgawanyo.  \n\nMfano:  \n- Ingizo: M = 7, N = 3  \n- Matokeo: 8  ",
      "tr": "Bir PHP fonksiyonu `function countDistributionMethods($M, $N)` yazın ve aşağıdaki problemi çözün:\nSoru:\nM tane özdeş elmanız var ve bunları N tane özdeş tabağa yerleştirmeniz gerekiyor. Bazı tabakların boş olmasına izin veriliyor. Elmaları tabaklara dağıtmanın kaç farklı yolu vardır?\n5,1,1 ve 1,5,1 aynı bölme yöntemidir.\n\nÖrnek:\n- Girdi: M = 7, N = 3\n- Çıktı: 8",
      "vi": "Viết một hàm PHP `function countDistributionMethods($M, $N)` để giải quyết vấn đề sau:\n\nCâu hỏi:\nBạn có M quả táo giống hệt nhau cần được đặt vào N đĩa giống hệt nhau. Bạn được phép để một số đĩa trống. Có bao nhiêu cách khác nhau để phân phối táo vào các đĩa?\n5,1,1 và 1,5,1 là cùng một phương pháp phân chia.\n\nVí dụ:\n- Đầu vào: M = 7, N = 3\n- Đầu ra: 8"
    },
    "instruction_bertscore": {
      "es": "0.9805153527723827",
      "arb": "0.9865856958471899",
      "sw": "0.9859423320430178",
      "tr": "0.9732649466038471",
      "vi": "0.9829303009450048"
    },
    "level": "hard",
    "test": "function main(){\n    // Test cases\n    assert(countDistributionMethods(7, 3) === 8);\n    assert(countDistributionMethods(5, 2) === 3);\n    assert(countDistributionMethods(10, 5) === 30);\n\n}\n\n\nmain();\n?>",
    "entry_point": "countDistributionMethods",
    "signature": "function countDistributionMethods($M, $N)",
    "docstring": {
      "en": "Question:\nYou have M identical apples that need to be placed into N identical plates. You are allowed\nto have some plates empty. How many different ways are there to distribute the apples into the plates?\n5,1,1 and 1,5,1 are the same division method.\n\nExample:\n- Input: M = 7, N = 3\n- Output: 8",
      "es": "Pregunta:\nTienes M manzanas idénticas que deben colocarse en N platos idénticos. Se permite\ntener algunos platos vacíos. ¿Cuántas formas diferentes hay de distribuir las manzanas en los platos?\n5,1,1 y 1,5,1 son el mismo método de división.\n\nEjemplo:\n- Entrada: M = 7, N = 3\n- Salida: 8",
      "arb": "السؤال:\nلديك M من التفاح المتطابق الذي يجب وضعه في N من الأطباق المتطابقة. يُسمح لك بترك بعض الأطباق فارغة. كم عدد الطرق المختلفة لتوزيع التفاح في الأطباق؟\n5,1,1 و 1,5,1 هما نفس طريقة التقسيم.\n\nمثال:\n- المدخلات: M = 7, N = 3\n- المخرجات: 8",
      "sw": "Swali:\nUna maapulo M yanayofanana ambayo yanahitaji kuwekwa kwenye sahani N zinazofanana. Unaruhusiwa kuwa na baadhi ya sahani tupu. Kuna njia ngapi tofauti za kugawa maapulo kwenye sahani?\n5,1,1 na 1,5,1 ni njia sawa ya kugawa.\n\nMfano:\n- Ingizo: M = 7, N = 3\n- Matokeo: 8",
      "tr": "Soru:\nM adet özdeş elmayı N adet özdeş tabağa yerleştirmeniz gerekiyor. Bazı tabakların boş kalmasına izin veriliyor. Elmaların tabaklara dağıtılmasının kaç farklı yolu vardır?\n5,1,1 ve 1,5,1 aynı bölme yöntemidir.\n\nÖrnek:\n- Girdi: M = 7, N = 3\n- Çıktı: 8",
      "vi": "Câu hỏi:\nBạn có M quả táo giống hệt nhau cần được đặt vào N đĩa giống hệt nhau. Bạn được phép để một số đĩa trống. Có bao nhiêu cách khác nhau để phân phối táo vào các đĩa?\n5,1,1 và 1,5,1 là cùng một phương pháp phân chia.\n\nVí dụ:\n- Đầu vào: M = 7, N = 3\n- Đầu ra: 8"
    },
    "docstring_bertscore": {
      "es": "0.981086415117858",
      "arb": "0.9486312040086624",
      "sw": "0.9726845486304632",
      "tr": "0.957635516441736",
      "vi": "0.9889053014369152"
    }
  },
  {
    "task_id": "PHP/39",
    "prompt": {
      "en": "<?php\n\n/**\n * Generates all possible ways to express a natural number as the sum of smaller natural numbers.\n * For example, when n=7, there are 14 different ways to express it as the sum of smaller natural numbers.\n * This function returns all these expressions in lexicographical (dictionary) order.\n * below is output when n = 7\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n The input natural number (greater than 1).\n * @return array An array of strings representing all possible expressions.\n */\n\n function generateNumberExpressions($n) ",
      "es": "<?php\n\n/**\n * Genera todas las formas posibles de expresar un número natural como la suma de números naturales más pequeños.\n * Por ejemplo, cuando n=7, hay 14 formas diferentes de expresarlo como la suma de números naturales más pequeños.\n * Esta función devuelve todas estas expresiones en orden lexicográfico (de diccionario).\n * abajo está el resultado cuando n = 7\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n El número natural de entrada (mayor que 1).\n * @return array Un arreglo de cadenas que representa todas las posibles expresiones.\n */\n\n function generateNumberExpressions($n) ",
      "arb": "<?php\n\n/**\n * يولد جميع الطرق الممكنة للتعبير عن عدد طبيعي كمجموع لأعداد طبيعية أصغر.\n * على سبيل المثال، عندما n=7، هناك 14 طريقة مختلفة للتعبير عنه كمجموع لأعداد طبيعية أصغر.\n * هذه الدالة تعيد جميع هذه التعبيرات بترتيب معجمي (قاموسي).\n * أدناه هو الناتج عندما n = 7\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n العدد الطبيعي المدخل (أكبر من 1).\n * @return array مصفوفة من السلاسل النصية تمثل جميع التعبيرات الممكنة.\n */\n\n function generateNumberExpressions($n) ",
      "sw": "<?php\n\n/**\n * Hutoa njia zote zinazowezekana za kuonyesha nambari ya asili kama jumla ya nambari ndogo za asili.\n * Kwa mfano, wakati n=7, kuna njia 14 tofauti za kuonyesha kama jumla ya nambari ndogo za asili.\n * Kazi hii inarudisha maonyesho haya yote kwa mpangilio wa lexicographical (kamusi).\n * hapa chini ni matokeo wakati n = 7\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n Nambari ya asili ya ingizo (kubwa kuliko 1).\n * @return array Mfululizo wa maandishi yanayowakilisha maonyesho yote yanayowezekana.\n */\n\n function generateNumberExpressions($n) ",
      "tr": "<?php\n\n/**\n * Bir doğal sayıyı daha küçük doğal sayıların toplamı olarak ifade etmenin tüm olası yollarını üretir.\n * Örneğin, n=7 olduğunda, bunu daha küçük doğal sayıların toplamı olarak ifade etmenin 14 farklı yolu vardır.\n * Bu fonksiyon, tüm bu ifadeleri sözlük sırasına göre döndürür.\n * n = 7 olduğunda çıktı aşağıdaki gibidir\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n Girdi doğal sayısı (1'den büyük).\n * @return array Tüm olası ifadeleri temsil eden bir dizi.\n */\n\n function generateNumberExpressions($n) ",
      "vi": "<?php\n\n/**\n * Tạo ra tất cả các cách có thể để biểu diễn một số tự nhiên như là tổng của các số tự nhiên nhỏ hơn.\n * Ví dụ, khi n=7, có 14 cách khác nhau để biểu diễn nó như là tổng của các số tự nhiên nhỏ hơn.\n * Hàm này trả về tất cả các biểu thức này theo thứ tự từ điển.\n * dưới đây là đầu ra khi n = 7\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n Số tự nhiên đầu vào (lớn hơn 1).\n * @return array Một mảng các chuỗi biểu diễn tất cả các biểu thức có thể.\n */\n\n function generateNumberExpressions($n) "
    },
    "prompt_bertscore": {
      "es": "0.9923978194266517",
      "arb": "0.9915792636264069",
      "sw": "0.9872900391783396",
      "tr": "0.9728210077022342",
      "vi": "0.9664531163166367"
    },
    "canonical_solution": " {\n    // This function will store the results\n    $results = [];\n\n\n\n    // Initialize the recursion with an empty array for the output\n    findCombinations($n, 1, [], $results);\n\n    // Format the results\n    return array_map(function($expression) use ($n) {\n        return \"$n=$expression\";\n    }, $results);\n}\n\n    // Helper function for recursion\nfunction findCombinations($n, $start, $output, &$results)\n    {\n        if ($n == 0) {\n            // Add to results only if there are more than one number in the combination\n            if (count($output) > 1) {\n                $results[] = implode('+', $output);\n            }\n            return;\n        }\n\n        for ($i = $start; $i <= $n; $i++) {\n            findCombinations($n - $i, $i, array_merge($output, [$i]), $results);\n        }\n}\n",
    "instruction": {
      "en": "Write a PHP function `function generateNumberExpressions($n)` to solve the following problem:\nGenerates all possible ways to express a natural number as the sum of smaller natural numbers.\nFor example, when n=7, there are 14 different ways to express it as the sum of smaller natural numbers.\nThis function returns all these expressions in lexicographical (dictionary) order.\nbelow is output when n = 7\n7=1+1+1+1+1+1+1\n7=1+1+1+1+1+2\n7=1+1+1+1+3\n7=1+1+1+2+2\n7=1+1+1+4\n7=1+1+2+3\n7=1+1+5\n7=1+2+2+2\n7=1+2+4\n7=1+3+3\n7=1+6\n7=2+2+3\n7=2+5\n7=3+4\n@param int $n The input natural number (greater than 1).\n@return array An array of strings representing all possible expressions.",
      "es": "Escribe una función PHP `function generateNumberExpressions($n)` para resolver el siguiente problema:\nGenera todas las formas posibles de expresar un número natural como la suma de números naturales más pequeños.\nPor ejemplo, cuando n=7, hay 14 formas diferentes de expresarlo como la suma de números naturales más pequeños.\nEsta función devuelve todas estas expresiones en orden lexicográfico (de diccionario).\nabajo está el resultado cuando n = 7\n7=1+1+1+1+1+1+1\n7=1+1+1+1+1+2\n7=1+1+1+1+3\n7=1+1+1+2+2\n7=1+1+1+4\n7=1+1+2+3\n7=1+1+5\n7=1+2+2+2\n7=1+2+4\n7=1+3+3\n7=1+6\n7=2+2+3\n7=2+5\n7=3+4\n@param int $n El número natural de entrada (mayor que 1).\n@return array Un arreglo de cadenas que representa todas las expresiones posibles.",
      "arb": "اكتب دالة PHP `function generateNumberExpressions($n)` لحل المشكلة التالية:\nتولّد جميع الطرق الممكنة للتعبير عن عدد طبيعي كمجموع لأعداد طبيعية أصغر.\nعلى سبيل المثال، عندما n=7، هناك 14 طريقة مختلفة للتعبير عنه كمجموع لأعداد طبيعية أصغر.\nتقوم هذه الدالة بإرجاع جميع هذه التعبيرات بترتيب معجمي (قاموسي).\nفيما يلي المخرجات عندما n = 7\n7=1+1+1+1+1+1+1\n7=1+1+1+1+1+2\n7=1+1+1+1+3\n7=1+1+1+2+2\n7=1+1+1+4\n7=1+1+2+3\n7=1+1+5\n7=1+2+2+2\n7=1+2+4\n7=1+3+3\n7=1+6\n7=2+2+3\n7=2+5\n7=3+4\n@param int $n العدد الطبيعي المدخل (أكبر من 1).\n@return array مصفوفة من السلاسل النصية التي تمثل جميع التعبيرات الممكنة.",
      "sw": "Andika kazi ya PHP `function generateNumberExpressions($n)` kutatua tatizo lifuatalo:\nInazalisha njia zote zinazowezekana za kueleza nambari ya asili kama jumla ya nambari ndogo za asili.\nKwa mfano, wakati n=7, kuna njia 14 tofauti za kuieleza kama jumla ya nambari ndogo za asili.\nKazi hii inarudisha maelezo haya yote katika mpangilio wa alfabeti (kamusi).\nchini ni matokeo wakati n = 7\n7=1+1+1+1+1+1+1\n7=1+1+1+1+1+2\n7=1+1+1+1+3\n7=1+1+1+2+2\n7=1+1+1+4\n7=1+1+2+3\n7=1+1+5\n7=1+2+2+2\n7=1+2+4\n7=1+3+3\n7=1+6\n7=2+2+3\n7=2+5\n7=3+4\n@param int $n Nambari ya asili ya ingizo (kubwa kuliko 1).\n@return array Mfululizo wa maandishi yanayowakilisha maelezo yote yanayowezekana.",
      "tr": "Bir PHP fonksiyonu `function generateNumberExpressions($n)` yazın. Aşağıdaki problemi çözmek için:\nBir doğal sayıyı daha küçük doğal sayıların toplamı olarak ifade etmenin tüm olası yollarını üretir.\nÖrneğin, n=7 olduğunda, bunu daha küçük doğal sayıların toplamı olarak ifade etmenin 14 farklı yolu vardır.\nBu fonksiyon, tüm bu ifadeleri sözlük sırasına göre döndürür.\naşağıda n = 7 olduğunda çıktı verilmiştir\n7=1+1+1+1+1+1+1\n7=1+1+1+1+1+2\n7=1+1+1+1+3\n7=1+1+1+2+2\n7=1+1+1+4\n7=1+1+2+3\n7=1+1+5\n7=1+2+2+2\n7=1+2+4\n7=1+3+3\n7=1+6\n7=2+2+3\n7=2+5\n7=3+4\n@param int $n Girdi doğal sayısı (1'den büyük).\n@return array Tüm olası ifadeleri temsil eden bir dizi.",
      "vi": "Viết một hàm PHP `function generateNumberExpressions($n)` để giải quyết vấn đề sau:\nTạo ra tất cả các cách có thể để biểu diễn một số tự nhiên dưới dạng tổng của các số tự nhiên nhỏ hơn.\nVí dụ, khi n=7, có 14 cách khác nhau để biểu diễn nó dưới dạng tổng của các số tự nhiên nhỏ hơn.\nHàm này trả về tất cả các biểu thức này theo thứ tự từ điển.\ndưới đây là đầu ra khi n = 7\n7=1+1+1+1+1+1+1\n7=1+1+1+1+1+2\n7=1+1+1+1+3\n7=1+1+1+2+2\n7=1+1+1+4\n7=1+1+2+3\n7=1+1+5\n7=1+2+2+2\n7=1+2+4\n7=1+3+3\n7=1+6\n7=2+2+3\n7=2+5\n7=3+4\n@param int $n Số tự nhiên đầu vào (lớn hơn 1).\n@return array Một mảng các chuỗi biểu diễn tất cả các biểu thức có thể."
    },
    "instruction_bertscore": {
      "es": "0.9923521344390137",
      "arb": "0.992313600145093",
      "sw": "0.9770496498840859",
      "tr": "0.9676850219398151",
      "vi": "0.9683764542961976"
    },
    "level": "hard",
    "test": "function main(){\n    $result = generateNumberExpressions(7);\n    assert($result===[\"7=1+1+1+1+1+1+1\",\"7=1+1+1+1+1+2\",\"7=1+1+1+1+3\",\"7=1+1+1+2+2\",\"7=1+1+1+4\",\"7=1+1+2+3\",\"7=1+1+5\",\"7=1+2+2+2\",\"7=1+2+4\",\"7=1+3+3\",\"7=1+6\",\"7=2+2+3\",\"7=2+5\",\"7=3+4\"]);\n    $result = generateNumberExpressions(6);\n    assert($result===[  \"6=1+1+1+1+1+1\",\"6=1+1+1+1+2\",\"6=1+1+1+3\",\"6=1+1+2+2\",\"6=1+1+4\",\"6=1+2+3\",\"6=1+5\",\"6=2+2+2\",\"6=2+4\",\"6=3+3\"]);\n  \n  \n}\n\n\nmain();\n?>",
    "entry_point": "generateNumberExpressions",
    "signature": "function generateNumberExpressions($n)",
    "docstring": {
      "en": "Generates all possible ways to express a natural number as the sum of smaller natural numbers.\nFor example, when n=7, there are 14 different ways to express it as the sum of smaller natural numbers.\nThis function returns all these expressions in lexicographical (dictionary) order.\nbelow is output when n = 7\n7=1+1+1+1+1+1+1\n7=1+1+1+1+1+2\n7=1+1+1+1+3\n7=1+1+1+2+2\n7=1+1+1+4\n7=1+1+2+3\n7=1+1+5\n7=1+2+2+2\n7=1+2+4\n7=1+3+3\n7=1+6\n7=2+2+3\n7=2+5\n7=3+4\n@param int $n The input natural number (greater than 1).\n@return array An array of strings representing all possible expressions.",
      "es": "Genera todas las formas posibles de expresar un número natural como la suma de números naturales más pequeños.  \nPor ejemplo, cuando n=7, hay 14 formas diferentes de expresarlo como la suma de números naturales más pequeños.  \nEsta función devuelve todas estas expresiones en orden lexicográfico (de diccionario).  \na continuación se muestra la salida cuando n = 7  \n7=1+1+1+1+1+1+1  \n7=1+1+1+1+1+2  \n7=1+1+1+1+3  \n7=1+1+1+2+2  \n7=1+1+1+4  \n7=1+1+2+3  \n7=1+1+5  \n7=1+2+2+2  \n7=1+2+4  \n7=1+3+3  \n7=1+6  \n7=2+2+3  \n7=2+5  \n7=3+4  \n@param int $n El número natural de entrada (mayor que 1).  \n@return array Un array de cadenas que representa todas las expresiones posibles.",
      "arb": "ينشئ جميع الطرق الممكنة للتعبير عن عدد طبيعي كمجموع لأعداد طبيعية أصغر.  \nعلى سبيل المثال، عندما يكون n=7، هناك 14 طريقة مختلفة للتعبير عنه كمجموع لأعداد طبيعية أصغر.  \nتقوم هذه الدالة بإرجاع جميع هذه التعبيرات بترتيب معجمي (قاموسي).  \nفيما يلي المخرجات عندما n = 7  \n7=1+1+1+1+1+1+1  \n7=1+1+1+1+1+2  \n7=1+1+1+1+3  \n7=1+1+1+2+2  \n7=1+1+1+4  \n7=1+1+2+3  \n7=1+1+5  \n7=1+2+2+2  \n7=1+2+4  \n7=1+3+3  \n7=1+6  \n7=2+2+3  \n7=2+5  \n7=3+4  \n@param int $n العدد الطبيعي المدخل (أكبر من 1).  \n@return array مصفوفة من السلاسل النصية تمثل جميع التعبيرات الممكنة.",
      "sw": "Hutengeneza njia zote zinazowezekana za kuelezea nambari ya asili kama jumla ya nambari ndogo za asili. Kwa mfano, wakati n=7, kuna njia 14 tofauti za kuelezea kama jumla ya nambari ndogo za asili. Kazi hii inarudisha maelezo haya yote katika mpangilio wa lexicographical (kamusi). hapa chini ni matokeo wakati n = 7 7=1+1+1+1+1+1+1 7=1+1+1+1+1+2 7=1+1+1+1+3 7=1+1+1+2+2 7=1+1+1+4 7=1+1+2+3 7=1+1+5 7=1+2+2+2 7=1+2+4 7=1+3+3 7=1+6 7=2+2+3 7=2+5 7=3+4\n@param int $n Nambari ya asili ya ingizo (kubwa kuliko 1).\n@return array Mfululizo wa maandishi yanayowakilisha maelezo yote yanayowezekana.",
      "tr": "Doğal bir sayıyı daha küçük doğal sayıların toplamı olarak ifade etmenin tüm olası yollarını üretir.\nÖrneğin, n=7 olduğunda, bunu daha küçük doğal sayıların toplamı olarak ifade etmenin 14 farklı yolu vardır.\nBu fonksiyon, tüm bu ifadeleri sözlük sırasına göre döndürür.\naşağıda n = 7 olduğunda çıktı verilmiştir\n7=1+1+1+1+1+1+1\n7=1+1+1+1+1+2\n7=1+1+1+1+3\n7=1+1+1+2+2\n7=1+1+1+4\n7=1+1+2+3\n7=1+1+5\n7=1+2+2+2\n7=1+2+4\n7=1+3+3\n7=1+6\n7=2+2+3\n7=2+5\n7=3+4\n@param int $n Girdi doğal sayısı (1'den büyük).\n@return array Tüm olası ifadeleri temsil eden bir dizi.",
      "vi": "Tạo ra tất cả các cách có thể để biểu diễn một số tự nhiên như là tổng của các số tự nhiên nhỏ hơn.  \nVí dụ, khi n=7, có 14 cách khác nhau để biểu diễn nó như là tổng của các số tự nhiên nhỏ hơn.  \nHàm này trả về tất cả các biểu thức này theo thứ tự từ điển.  \ndưới đây là đầu ra khi n = 7  \n7=1+1+1+1+1+1+1  \n7=1+1+1+1+1+2  \n7=1+1+1+1+3  \n7=1+1+1+2+2  \n7=1+1+1+4  \n7=1+1+2+3  \n7=1+1+5  \n7=1+2+2+2  \n7=1+2+4  \n7=1+3+3  \n7=1+6  \n7=2+2+3  \n7=2+5  \n7=3+4  \n@param int $n Số tự nhiên đầu vào (lớn hơn 1).  \n@return array Một mảng các chuỗi biểu diễn tất cả các biểu thức có thể.  "
    },
    "docstring_bertscore": {
      "es": "0.9910528931166644",
      "arb": "0.9871754294484825",
      "sw": "0.9840575283573778",
      "tr": "0.9656301906480091",
      "vi": "0.96264576917296"
    }
  },
  {
    "task_id": "PHP/40",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Calculates the maximum number of distinct letters one can pass through in a letter matrix.\n * Starting from the top-left corner, you can move up, down, left, or right, but cannot visit a cell more than once.\n * This function finds the maximum number of distinct letters that can be traversed in the matrix.\n * \n * Inputs:\n * - $rows (int): The number of rows in the matrix.\n * - $cols (int): The number of columns in the matrix.\n * - $matrix (array): A 2D array representing the letter matrix.\n *\n * Output:\n * - Returns an integer representing the maximum number of distinct letters that can be traversed.\n *\n * Example:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) should return 9.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) ",
      "es": "<?php\n\n\n/**\n * Calcula el número máximo de letras distintas que se pueden atravesar en una matriz de letras.\n * Comenzando desde la esquina superior izquierda, puedes moverte hacia arriba, abajo, izquierda o derecha, pero no puedes visitar una celda más de una vez.\n * Esta función encuentra el número máximo de letras distintas que se pueden recorrer en la matriz.\n * \n * Entradas:\n * - $rows (int): El número de filas en la matriz.\n * - $cols (int): El número de columnas en la matriz.\n * - $matrix (array): Un arreglo 2D que representa la matriz de letras.\n *\n * Salida:\n * - Devuelve un entero que representa el número máximo de letras distintas que se pueden recorrer.\n *\n * Ejemplo:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) debería devolver 9.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) ",
      "arb": "<?php\n\n\n/**\n * يحسب الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها في مصفوفة الأحرف.\n * بدءًا من الزاوية العلوية اليسرى، يمكنك التحرك لأعلى، لأسفل، لليسار، أو لليمين، ولكن لا يمكنك زيارة الخلية أكثر من مرة.\n * هذه الدالة تجد الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها في المصفوفة.\n * \n * المدخلات:\n * - $rows (int): عدد الصفوف في المصفوفة.\n * - $cols (int): عدد الأعمدة في المصفوفة.\n * - $matrix (array): مصفوفة ثنائية الأبعاد تمثل مصفوفة الأحرف.\n *\n * المخرجات:\n * - تعيد عددًا صحيحًا يمثل الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها.\n *\n * مثال:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) يجب أن تعيد 9.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi ya juu zaidi ya herufi tofauti ambazo mtu anaweza kupita katika matrix ya herufi.\n * Kuanzia kona ya juu-kushoto, unaweza kusonga juu, chini, kushoto, au kulia, lakini huwezi kutembelea seli zaidi ya mara moja.\n * Kazi hii inapata idadi ya juu zaidi ya herufi tofauti ambazo zinaweza kupitiwa katika matrix.\n * \n * Ingizo:\n * - $rows (int): Idadi ya safu katika matrix.\n * - $cols (int): Idadi ya nguzo katika matrix.\n * - $matrix (array): Matrix ya 2D inayowakilisha matrix ya herufi.\n *\n * Tokeo:\n * - Inarudisha namba nzima inayowakilisha idadi ya juu zaidi ya herufi tofauti ambazo zinaweza kupitiwa.\n *\n * Mfano:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) inapaswa kurudisha 9.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) ",
      "tr": "<?php\n\n\n/**\n * Bir harf matrisinde geçilebilecek maksimum farklı harf sayısını hesaplar.\n * Sol üst köşeden başlayarak yukarı, aşağı, sola veya sağa hareket edebilirsiniz, ancak bir hücreyi birden fazla ziyaret edemezsiniz.\n * Bu fonksiyon, matris içinde geçilebilecek maksimum farklı harf sayısını bulur.\n * \n * Girdiler:\n * - $rows (int): Matrisin satır sayısı.\n * - $cols (int): Matrisin sütun sayısı.\n * - $matrix (array): Harf matrisini temsil eden 2D dizi.\n *\n * Çıktı:\n * - Geçilebilecek maksimum farklı harf sayısını temsil eden bir tamsayı döndürür.\n *\n * Örnek:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) 9 döndürmelidir.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) ",
      "vi": "<?php\n\n\n/**\n * Tính toán số lượng chữ cái khác nhau tối đa mà bạn có thể đi qua trong một ma trận chữ cái.\n * Bắt đầu từ góc trên bên trái, bạn có thể di chuyển lên, xuống, trái hoặc phải, nhưng không thể thăm một ô nhiều hơn một lần.\n * Hàm này tìm số lượng chữ cái khác nhau tối đa có thể đi qua trong ma trận.\n * \n * Đầu vào:\n * - $rows (int): Số hàng trong ma trận.\n * - $cols (int): Số cột trong ma trận.\n * - $matrix (array): Một mảng 2D đại diện cho ma trận chữ cái.\n *\n * Đầu ra:\n * - Trả về một số nguyên đại diện cho số lượng chữ cái khác nhau tối đa có thể đi qua.\n *\n * Ví dụ:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) nên trả về 9.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) "
    },
    "prompt_bertscore": {
      "es": "0.9794681734035667",
      "arb": "0.9688692562715451",
      "sw": "0.983916302156462",
      "tr": "0.9752266202469477",
      "vi": "0.9761017857057874"
    },
    "canonical_solution": "{\n    // Global variables to store the maximum count and visited letters\n    $maxCount = 0;\n    $visited = array_fill(0, 1001, false);\n\n    // Directions for movement (up, down, left, right)\n    $dx = [0, 1, -1, 0, 0];\n    $dy = [0, 0, 0, 1, -1];\n\n    // Inner function to perform DFS\n    $dfs = function($x, $y, $count) use (&$visited, &$maxCount, &$dfs, $matrix, $rows, $cols, $dx, $dy) {\n        $maxCount = max($maxCount, $count);\n        for ($i = 1; $i <= 4; $i++) {\n            $tx = $x + $dx[$i];\n            $ty = $y + $dy[$i];\n\n            // Check boundaries and if the cell is not visited\n            if ($tx > 0 && $tx <= $rows && $ty > 0 && $ty <= $cols && !$visited[ord($matrix[$tx - 1][$ty - 1])]) {\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = true;\n                $dfs($tx, $ty, $count + 1);\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = false;\n            }\n        }\n    };\n\n    // Start DFS from the top-left corner\n    $visited[ord($matrix[0][0])] = true;\n    $dfs(1, 1, 1);\n\n    return $maxCount;\n}",
    "instruction": {
      "en": "Write a PHP function `function maxDistinctLetters($rows, $cols, $matrix)` to solve the following problem:\nCalculates the maximum number of distinct letters one can pass through in a letter matrix.\nStarting from the top-left corner, you can move up, down, left, or right, but cannot visit a cell more than once.\nThis function finds the maximum number of distinct letters that can be traversed in the matrix.\n\nInputs:\n- $rows (int): The number of rows in the matrix.\n- $cols (int): The number of columns in the matrix.\n- $matrix (array): A 2D array representing the letter matrix.\n\nOutput:\n- Returns an integer representing the maximum number of distinct letters that can be traversed.\n\nExample:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) should return 9.",
      "es": "Escribe una función PHP `function maxDistinctLetters($rows, $cols, $matrix)` para resolver el siguiente problema:\nCalcula el número máximo de letras distintas que se pueden atravesar en una matriz de letras.\nComenzando desde la esquina superior izquierda, puedes moverte hacia arriba, abajo, izquierda o derecha, pero no puedes visitar una celda más de una vez.\nEsta función encuentra el número máximo de letras distintas que se pueden recorrer en la matriz.\n\nEntradas:\n- $rows (int): El número de filas en la matriz.\n- $cols (int): El número de columnas en la matriz.\n- $matrix (array): Un arreglo 2D que representa la matriz de letras.\n\nSalida:\n- Devuelve un entero que representa el número máximo de letras distintas que se pueden recorrer.\n\nEjemplo:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) debería devolver 9.",
      "arb": "اكتب دالة PHP `function maxDistinctLetters($rows, $cols, $matrix)` لحل المشكلة التالية:\nتحسب الحد الأقصى لعدد الأحرف المختلفة التي يمكن المرور بها في مصفوفة الأحرف.\nبدءًا من الزاوية العلوية اليسرى، يمكنك التحرك لأعلى، لأسفل، لليسار، أو لليمين، ولكن لا يمكنك زيارة خلية أكثر من مرة.\nتجد هذه الدالة الحد الأقصى لعدد الأحرف المختلفة التي يمكن المرور بها في المصفوفة.\n\nالمدخلات:\n- $rows (int): عدد الصفوف في المصفوفة.\n- $cols (int): عدد الأعمدة في المصفوفة.\n- $matrix (array): مصفوفة ثنائية الأبعاد تمثل مصفوفة الأحرف.\n\nالمخرجات:\n- تعيد عددًا صحيحًا يمثل الحد الأقصى لعدد الأحرف المختلفة التي يمكن المرور بها.\n\nمثال:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) يجب أن تعيد 9.",
      "sw": "Andika kazi ya PHP `function maxDistinctLetters($rows, $cols, $matrix)` kutatua tatizo lifuatalo:\nInakokotoa idadi kubwa zaidi ya herufi tofauti ambazo mtu anaweza kupita katika matrix ya herufi.\nKuanzia kwenye kona ya juu-kushoto, unaweza kusonga juu, chini, kushoto, au kulia, lakini huwezi kutembelea seli zaidi ya mara moja.\nKazi hii inapata idadi kubwa zaidi ya herufi tofauti ambazo zinaweza kupitiwa katika matrix.\n\nVipengele vya Kuingiza:\n- $rows (int): Idadi ya mistari katika matrix.\n- $cols (int): Idadi ya safu katika matrix.\n- $matrix (array): Safu ya 2D inayowakilisha matrix ya herufi.\n\nMatokeo:\n- Inarudisha nambari kamili inayowakilisha idadi kubwa zaidi ya herufi tofauti ambazo zinaweza kupitiwa.\n\nMfano:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) inapaswa kurudisha 9.",
      "tr": "Bir PHP fonksiyonu `function maxDistinctLetters($rows, $cols, $matrix)` yazın:\nBir harf matrisinde geçilebilecek maksimum farklı harf sayısını hesaplar.\nSol üst köşeden başlayarak yukarı, aşağı, sola veya sağa hareket edebilirsiniz, ancak bir hücreyi birden fazla ziyaret edemezsiniz.\nBu fonksiyon, matris içinde geçilebilecek maksimum farklı harf sayısını bulur.\n\nGirdiler:\n- $rows (int): Matrisin satır sayısı.\n- $cols (int): Matrisin sütun sayısı.\n- $matrix (array): Harf matrisini temsil eden 2D dizi.\n\nÇıktı:\n- Geçilebilecek maksimum farklı harf sayısını temsil eden bir tamsayı döndürür.\n\nÖrnek:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) 9 döndürmelidir.",
      "vi": "Viết một hàm PHP `function maxDistinctLetters($rows, $cols, $matrix)` để giải quyết vấn đề sau:\nTính toán số lượng tối đa các chữ cái khác nhau mà bạn có thể đi qua trong một ma trận chữ cái.\nBắt đầu từ góc trên bên trái, bạn có thể di chuyển lên, xuống, trái hoặc phải, nhưng không thể thăm một ô nhiều hơn một lần.\nHàm này tìm số lượng tối đa các chữ cái khác nhau có thể được đi qua trong ma trận.\n\nĐầu vào:\n- $rows (int): Số hàng trong ma trận.\n- $cols (int): Số cột trong ma trận.\n- $matrix (array): Một mảng 2D đại diện cho ma trận chữ cái.\n\nĐầu ra:\n- Trả về một số nguyên đại diện cho số lượng tối đa các chữ cái khác nhau có thể được đi qua.\n\nVí dụ:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) nên trả về 9."
    },
    "instruction_bertscore": {
      "es": "0.9797752559726467",
      "arb": "0.9721434794725242",
      "sw": "0.9800918728000163",
      "tr": "0.9047557391418659",
      "vi": "0.9795116734570134"
    },
    "level": "hard",
    "test": "function main(){\n    $matrix = [\n        ['H', 'F', 'D', 'F', 'F', 'B'],\n        ['A', 'J', 'H', 'G', 'D', 'H'],\n        ['D', 'G', 'A', 'G', 'E', 'H']\n    ];\n    assert(maxDistinctLetters(3, 6, $matrix) === 6);\n  \n    $matrix = [\n        ['H', 'F', 'Y' ],\n        ['A', 'J', 'Z' ],\n        ['D', 'G', 'A']\n    ];\n    assert(maxDistinctLetters(3, 3, $matrix) === 8);\n\n    $matrix = [\n        ['A', 'D', 'G' ],\n        ['B', 'E', 'H' ],\n        ['C', 'F', 'I']\n    ];\n    assert(maxDistinctLetters(3, 3, $matrix) === 9);\n\n}\n\n\nmain();\n?>",
    "entry_point": "maxDistinctLetters",
    "signature": "function maxDistinctLetters($rows, $cols, $matrix)",
    "docstring": {
      "en": "Calculates the maximum number of distinct letters one can pass through in a letter matrix.\nStarting from the top-left corner, you can move up, down, left, or right, but cannot visit a cell more than once.\nThis function finds the maximum number of distinct letters that can be traversed in the matrix.\n\nInputs:\n- $rows (int): The number of rows in the matrix.\n- $cols (int): The number of columns in the matrix.\n- $matrix (array): A 2D array representing the letter matrix.\n\nOutput:\n- Returns an integer representing the maximum number of distinct letters that can be traversed.\n\nExample:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) should return 9.",
      "es": "Calcula el número máximo de letras distintas que se pueden atravesar en una matriz de letras. Comenzando desde la esquina superior izquierda, puedes moverte hacia arriba, abajo, izquierda o derecha, pero no puedes visitar una celda más de una vez. Esta función encuentra el número máximo de letras distintas que se pueden recorrer en la matriz.\n\nEntradas:\n- $rows (int): El número de filas en la matriz.\n- $cols (int): El número de columnas en la matriz.\n- $matrix (array): Un arreglo 2D que representa la matriz de letras.\n\nSalida:\n- Devuelve un entero que representa el número máximo de letras distintas que se pueden recorrer.\n\nEjemplo:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) debería devolver 9.",
      "arb": "يحسب الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها في مصفوفة الأحرف.\nبدءًا من الزاوية العلوية اليسرى، يمكنك التحرك لأعلى، لأسفل، لليسار، أو لليمين، ولكن لا يمكنك زيارة الخلية أكثر من مرة.\nتجد هذه الدالة الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها في المصفوفة.\n\nالمدخلات:\n- $rows (int): عدد الصفوف في المصفوفة.\n- $cols (int): عدد الأعمدة في المصفوفة.\n- $matrix (array): مصفوفة ثنائية الأبعاد تمثل مصفوفة الأحرف.\n\nالمخرجات:\n- تعيد عددًا صحيحًا يمثل الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها.\n\nمثال:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) يجب أن تعيد 9.",
      "sw": "Hesabu idadi kubwa ya herufi tofauti ambazo mtu anaweza kupita katika matrix ya herufi. \nKuanzia kona ya juu-kushoto, unaweza kusonga juu, chini, kushoto, au kulia, lakini huwezi kutembelea seli zaidi ya mara moja. \nKazi hii inapata idadi kubwa ya herufi tofauti ambazo zinaweza kupitiwa katika matrix.\n\nVingizo:\n- $rows (int): Idadi ya mistari katika matrix.\n- $cols (int): Idadi ya safu katika matrix.\n- $matrix (array): Safu ya 2D inayowakilisha matrix ya herufi.\n\nMatokeo:\n- Inarudisha namba nzima inayowakilisha idadi kubwa ya herufi tofauti ambazo zinaweza kupitiwa.\n\nMfano:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) inapaswa kurudisha 9.",
      "tr": "Farklı harflerin geçilebileceği maksimum sayıyı bir harf matrisinde hesaplar.\nSol üst köşeden başlayarak yukarı, aşağı, sola veya sağa hareket edebilirsiniz, ancak bir hücreyi birden fazla ziyaret edemezsiniz.\nBu fonksiyon, matriste geçilebilecek maksimum farklı harf sayısını bulur.\n\nGirdiler:\n- $rows (int): Matrisin satır sayısı.\n- $cols (int): Matrisin sütun sayısı.\n- $matrix (array): Harf matrisini temsil eden 2D dizi.\n\nÇıktı:\n- Geçilebilecek maksimum farklı harf sayısını temsil eden bir tamsayı döndürür.\n\nÖrnek:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) 9 döndürmelidir.",
      "vi": "Tính toán số lượng chữ cái khác nhau tối đa mà bạn có thể đi qua trong một ma trận chữ cái. Bắt đầu từ góc trên bên trái, bạn có thể di chuyển lên, xuống, trái hoặc phải, nhưng không thể thăm một ô nhiều hơn một lần. Hàm này tìm số lượng chữ cái khác nhau tối đa có thể được đi qua trong ma trận.\n\nĐầu vào:\n- $rows (int): Số hàng trong ma trận.\n- $cols (int): Số cột trong ma trận.\n- $matrix (array): Một mảng 2D đại diện cho ma trận chữ cái.\n\nĐầu ra:\n- Trả về một số nguyên đại diện cho số lượng chữ cái khác nhau tối đa có thể được đi qua.\n\nVí dụ:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) nên trả về 9."
    },
    "docstring_bertscore": {
      "es": "0.9775104723680869",
      "arb": "0.965788499061694",
      "sw": "0.9584810859738014",
      "tr": "0.9745755098579153",
      "vi": "0.9696989353731278"
    }
  },
  {
    "task_id": "PHP/41",
    "prompt": {
      "en": "<?php\n\n/**\n * Counts the number of evenly matched pairs of students based on their exam scores.\n * Two students are considered evenly matched if the difference in each subject's score\n * is not greater than 5 and the total score difference is not greater than 10.\n * Input: An integer N representing the number of students followed by N lines of three integers each\n *         representing the scores of each student in Chinese, Mathematics, and English respectively.\n * Output: An integer representing the number of evenly matched pairs of students.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) ",
      "es": "<?php\n\n/**\n * Cuenta el número de pares de estudiantes que están igualados en base a sus calificaciones de examen.\n * Se considera que dos estudiantes están igualados si la diferencia en la puntuación de cada materia\n * no es mayor a 5 y la diferencia total de puntuación no es mayor a 10.\n * Entrada: Un entero N que representa el número de estudiantes seguido de N líneas de tres enteros cada una\n *          representando las calificaciones de cada estudiante en Chino, Matemáticas e Inglés respectivamente.\n * Salida: Un entero que representa el número de pares de estudiantes igualados.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) ",
      "arb": "<?php\n\n/**\n * يحسب عدد الأزواج المتطابقة من الطلاب بناءً على درجاتهم في الامتحانات.\n * يعتبر الطالبان متطابقين إذا كان الفرق في درجة كل مادة لا يتجاوز 5 والفرق الإجمالي في الدرجات لا يتجاوز 10.\n * المدخل: عدد صحيح N يمثل عدد الطلاب يليه N سطرًا من ثلاثة أعداد صحيحة\n *         تمثل درجات كل طالب في اللغة الصينية والرياضيات واللغة الإنجليزية على التوالي.\n * المخرج: عدد صحيح يمثل عدد الأزواج المتطابقة من الطلاب.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) ",
      "sw": "<?php\n\n/**\n * Inahesabu idadi ya wanandoa wa wanafunzi waliolingana vizuri kulingana na alama zao za mtihani.\n * Wanafunzi wawili wanachukuliwa kuwa wamefanana vizuri ikiwa tofauti ya alama za kila somo\n * si zaidi ya 5 na tofauti ya jumla ya alama si zaidi ya 10.\n * Ingizo: Nambari ya mzima N inayoashiria idadi ya wanafunzi ikifuatiwa na mistari N ya nambari tatu kila moja\n *         ikiwakilisha alama za kila mwanafunzi katika Kichina, Hisabati, na Kiingereza mtawalia.\n * Tokeo: Nambari inayoashiria idadi ya wanandoa wa wanafunzi waliolingana vizuri.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) ",
      "tr": "<?php\n\n/**\n * Öğrencilerin sınav notlarına göre eşit derecede eşleşen çiftlerin sayısını sayar.\n * İki öğrenci, her dersin not farkı 5'ten büyük değilse ve toplam not farkı 10'dan büyük değilse\n * eşit derecede eşleşmiş kabul edilir.\n * Girdi: Öğrenci sayısını temsil eden bir tam sayı N ve ardından her biri\n *         Çin Dili, Matematik ve İngilizce notlarını temsil eden üçer tam sayıdan oluşan N satır.\n * Çıktı: Eşit derecede eşleşen öğrenci çiftlerinin sayısını temsil eden bir tam sayı.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) ",
      "vi": "<?php\n\n/**\n * Đếm số cặp học sinh có điểm thi tương đồng.\n * Hai học sinh được coi là tương đồng nếu chênh lệch điểm số của mỗi môn học\n * không lớn hơn 5 và tổng chênh lệch điểm số không lớn hơn 10.\n * Đầu vào: Một số nguyên N đại diện cho số lượng học sinh, tiếp theo là N dòng, mỗi dòng gồm ba số nguyên\n *         đại diện cho điểm số của mỗi học sinh trong các môn Tiếng Trung, Toán và Tiếng Anh tương ứng.\n * Đầu ra: Một số nguyên đại diện cho số cặp học sinh có điểm số tương đồng.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) "
    },
    "prompt_bertscore": {
      "es": "0.9660059993289272",
      "arb": "0.9596754504549643",
      "sw": "0.9406607627088754",
      "tr": "0.95320069592437",
      "vi": "0.9376026493624623"
    },
    "canonical_solution": "{\n    $count = 0;\n    for ($i = 0; $i < $N - 1; $i++) {\n        for ($j = $i + 1; $j < $N; $j++) {\n            $diff = abs($students[$i][0] - $students[$j][0]) <= 5 &&\n                    abs($students[$i][1] - $students[$j][1]) <= 5 &&\n                    abs($students[$i][2] - $students[$j][2]) <= 5 &&\n                    abs(array_sum($students[$i]) - array_sum($students[$j])) <= 10;\n            if ($diff) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}",
    "instruction": {
      "en": "Write a PHP function `function countEvenlyMatchedPairs($N, $students)` to solve the following problem:\nCounts the number of evenly matched pairs of students based on their exam scores.\n  Two students are considered evenly matched if the difference in each subject's score\n  is not greater than 5 and the total score difference is not greater than 10.\n  Input: An integer N representing the number of students followed by N lines of three integers each\n          representing the scores of each student in Chinese, Mathematics, and English respectively.\n  Output: An integer representing the number of evenly matched pairs of students.",
      "es": "Escribe una función PHP `function countEvenlyMatchedPairs($N, $students)` para resolver el siguiente problema:\nCuenta el número de pares de estudiantes equitativamente emparejados basados en sus puntajes de examen.\n  Dos estudiantes se consideran equitativamente emparejados si la diferencia en el puntaje de cada materia\n  no es mayor que 5 y la diferencia total de puntaje no es mayor que 10.\n  Entrada: Un entero N que representa el número de estudiantes seguido de N líneas de tres enteros cada una\n          representando los puntajes de cada estudiante en Chino, Matemáticas e Inglés respectivamente.\n  Salida: Un entero que representa el número de pares de estudiantes equitativamente emparejados.",
      "arb": "اكتب دالة PHP `function countEvenlyMatchedPairs($N, $students)` لحل المشكلة التالية:\nتحسب عدد الأزواج المتطابقة بالتساوي من الطلاب بناءً على درجاتهم في الامتحان.\nيعتبر الطالبان متطابقين بالتساوي إذا كان الفرق في درجة كل مادة\nلا يزيد عن 5 والفرق الكلي في الدرجات لا يزيد عن 10.\nالمدخلات: عدد صحيح N يمثل عدد الطلاب يليه N سطرًا من ثلاثة أعداد صحيحة لكل منها\nيمثل درجات كل طالب في اللغة الصينية والرياضيات والإنجليزية على التوالي.\nالمخرجات: عدد صحيح يمثل عدد الأزواج المتطابقة بالتساوي من الطلاب.",
      "sw": "Andika kazi ya PHP `function countEvenlyMatchedPairs($N, $students)` kutatua tatizo lifuatalo:\nHesabu idadi ya jozi za wanafunzi wanaolingana vizuri kulingana na alama zao za mtihani.\n  Wanafunzi wawili wanachukuliwa kuwa wamefanana vizuri ikiwa tofauti ya alama katika kila somo\n  haizidi 5 na tofauti ya jumla ya alama haizidi 10.\n  Ingizo: Nambari nzima N inayowakilisha idadi ya wanafunzi ikifuatiwa na mistari N ya nambari tatu kila moja\n          inayowakilisha alama za kila mwanafunzi katika Kichina, Hisabati, na Kiingereza mtawalia.\n  Tokeo: Nambari nzima inayowakilisha idadi ya jozi za wanafunzi wanaolingana vizuri.",
      "tr": "Bir PHP fonksiyonu `function countEvenlyMatchedPairs($N, $students)` yazın: Aşağıdaki problemi çözmek için:\nÖğrencilerin sınav puanlarına göre eşit olarak eşleşmiş çiftlerin sayısını sayar.\n  İki öğrenci, her dersin puan farkı 5'ten büyük değilse ve toplam puan farkı 10'dan büyük değilse eşit olarak eşleşmiş kabul edilir.\n  Girdi: Öğrenci sayısını temsil eden bir tam sayı N ve ardından her biri öğrencinin Çince, Matematik ve İngilizce puanlarını temsil eden üç tam sayı içeren N satır.\n  Çıktı: Eşit olarak eşleşmiş öğrenci çiftlerinin sayısını temsil eden bir tam sayı.",
      "vi": "Viết một hàm PHP `function countEvenlyMatchedPairs($N, $students)` để giải quyết vấn đề sau:\nĐếm số cặp học sinh có điểm số tương đồng dựa trên điểm thi của họ.\n  Hai học sinh được coi là có điểm số tương đồng nếu chênh lệch điểm số của mỗi môn\n  không lớn hơn 5 và tổng chênh lệch điểm số không lớn hơn 10.\n  Đầu vào: Một số nguyên N đại diện cho số lượng học sinh, tiếp theo là N dòng, mỗi dòng gồm ba số nguyên\n          đại diện cho điểm số của mỗi học sinh trong các môn Ngữ văn, Toán, và Tiếng Anh tương ứng.\n  Đầu ra: Một số nguyên đại diện cho số cặp học sinh có điểm số tương đồng."
    },
    "instruction_bertscore": {
      "es": "0.9880064989627324",
      "arb": "0.9758815046132198",
      "sw": "0.9651282516751339",
      "tr": "0.9610384521296257",
      "vi": "0.9297797904357843"
    },
    "level": "easy",
    "test": "function main(){\n    assert(countEvenlyMatchedPairs(3, [[90, 90, 90], [85, 95, 90], [80, 100, 91]]) === 2);\n    assert(countEvenlyMatchedPairs(3, [[100, 100, 100], [85, 95, 90], [80, 100, 91]]) === 1);\n    assert(countEvenlyMatchedPairs(4, [[100, 100, 100],[100, 100, 100],[100, 100, 100],[100, 100, 100]]) === 6);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "countEvenlyMatchedPairs",
    "signature": "function countEvenlyMatchedPairs($N, $students)",
    "docstring": {
      "en": "Counts the number of evenly matched pairs of students based on their exam scores.\n  Two students are considered evenly matched if the difference in each subject's score\n  is not greater than 5 and the total score difference is not greater than 10.\n  Input: An integer N representing the number of students followed by N lines of three integers each\n          representing the scores of each student in Chinese, Mathematics, and English respectively.\n  Output: An integer representing the number of evenly matched pairs of students.",
      "es": "Cuenta el número de pares de estudiantes igualados en base a sus puntuaciones de examen.\n  Se considera que dos estudiantes están igualados si la diferencia en la puntuación de cada asignatura\n  no es mayor que 5 y la diferencia total de puntuación no es mayor que 10.\n  Entrada: Un entero N que representa el número de estudiantes seguido de N líneas de tres enteros cada una\n          representando las puntuaciones de cada estudiante en Chino, Matemáticas e Inglés respectivamente.\n  Salida: Un entero que representa el número de pares de estudiantes igualados.",
      "arb": "يحسب عدد الأزواج المتطابقة من الطلاب بناءً على درجاتهم في الامتحانات. يعتبر الطالبان متطابقين إذا لم يكن الفرق في درجة كل مادة أكبر من 5 ولم يكن الفرق في المجموع الكلي للدرجات أكبر من 10. المدخلات: عدد صحيح N يمثل عدد الطلاب يليه N سطرًا يحتوي كل منها على ثلاثة أعداد صحيحة تمثل درجات كل طالب في اللغة الصينية والرياضيات والإنجليزية على التوالي. المخرجات: عدد صحيح يمثل عدد الأزواج المتطابقة من الطلاب.",
      "sw": "Hesabu idadi ya wanandoa wa wanafunzi waliolingana vizuri kulingana na alama zao za mtihani.\n  Wanafunzi wawili wanachukuliwa kuwa wamefanana vizuri ikiwa tofauti ya alama katika kila somo\n  haizidi 5 na tofauti ya jumla ya alama haizidi 10.\n  Ingizo: Nambari ya N inayowakilisha idadi ya wanafunzi ikifuatiwa na mistari N ya nambari tatu kila moja\n          inayowakilisha alama za kila mwanafunzi katika Kichina, Hisabati, na Kiingereza mtawalia.\n  Tokeo: Nambari inayowakilisha idadi ya wanandoa wa wanafunzi waliolingana vizuri.",
      "tr": "Öğrencilerin sınav puanlarına göre eşit derecede eşleşmiş çiftlerin sayısını sayar.\n  İki öğrenci, her dersin puan farkı 5'ten büyük değilse ve toplam puan farkı 10'dan büyük değilse eşit derecede eşleşmiş olarak kabul edilir.\n  Girdi: Her biri sırasıyla öğrencinin Çince, Matematik ve İngilizce puanlarını temsil eden üçer tam sayıdan oluşan N satırını takip eden öğrencilerin sayısını temsil eden bir tam sayı N.\n  Çıktı: Eşit derecede eşleşmiş öğrenci çiftlerinin sayısını temsil eden bir tam sayı.",
      "vi": "Đếm số cặp học sinh có điểm thi tương đồng nhau.\n  Hai học sinh được coi là tương đồng nếu chênh lệch điểm số của mỗi môn học\n  không lớn hơn 5 và chênh lệch tổng điểm không lớn hơn 10.\n  Đầu vào: Một số nguyên N đại diện cho số lượng học sinh, tiếp theo là N dòng, mỗi dòng gồm ba số nguyên\n          đại diện cho điểm số của mỗi học sinh trong các môn Ngữ văn, Toán và Tiếng Anh tương ứng.\n  Đầu ra: Một số nguyên đại diện cho số cặp học sinh có điểm số tương đồng."
    },
    "docstring_bertscore": {
      "es": "0.9587790315453538",
      "arb": "0.9483551077790239",
      "sw": "0.9225311719406781",
      "tr": "0.9520575780815143",
      "vi": "0.9064031795221693"
    }
  },
  {
    "task_id": "PHP/42",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Calculates the total number of cigarettes Peter can smoke.\n * Peter starts with a certain number of cigarettes and can exchange a specific number of cigarette butts for a new cigarette.\n * This process repeats until he can no longer exchange butts for new cigarettes.\n *\n * Parameters:\n * - $initialCigarettes (int): The initial number of cigarettes Peter has.\n * - $buttsRequiredForNew (int): The number of cigarette butts required to exchange for a new cigarette.\n *\n * Returns:\n * int: The total number of cigarettes Peter can smoke.\n *\n * Example:\n * - With 4 initial cigarettes and 3 butts required for a new one, Peter can smoke 5 cigarettes in total.\n * - With 10 initial cigarettes and 3 butts required for a new one, Peter can smoke 14 cigarettes in total.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int ",
      "es": "<?php\n\n\n/**\n * Calcula el número total de cigarrillos que Peter puede fumar.\n * Peter comienza con un cierto número de cigarrillos y puede intercambiar una cantidad específica de colillas de cigarrillo por un nuevo cigarrillo.\n * Este proceso se repite hasta que ya no puede intercambiar colillas por nuevos cigarrillos.\n *\n * Parámetros:\n * - $initialCigarettes (int): El número inicial de cigarrillos que Peter tiene.\n * - $buttsRequiredForNew (int): El número de colillas de cigarrillo requeridas para intercambiar por un nuevo cigarrillo.\n *\n * Devuelve:\n * int: El número total de cigarrillos que Peter puede fumar.\n *\n * Ejemplo:\n * - Con 4 cigarrillos iniciales y 3 colillas requeridas para uno nuevo, Peter puede fumar 5 cigarrillos en total.\n * - Con 10 cigarrillos iniciales y 3 colillas requeridas para uno nuevo, Peter puede fumar 14 cigarrillos en total.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int ",
      "arb": "<?php\n\n\n/**\n * يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n * يبدأ بيتر بعدد معين من السجائر ويمكنه تبادل عدد محدد من أعقاب السجائر للحصول على سيجارة جديدة.\n * تتكرر هذه العملية حتى لا يتمكن من تبادل الأعقاب للحصول على سجائر جديدة.\n *\n * المعايير:\n * - $initialCigarettes (int): عدد السجائر الأولي الذي يمتلكه بيتر.\n * - $buttsRequiredForNew (int): عدد أعقاب السجائر المطلوب لتبادلها للحصول على سيجارة جديدة.\n *\n * يعيد:\n * int: العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n *\n * مثال:\n * - مع 4 سجائر أولية و3 أعقاب مطلوبة للحصول على واحدة جديدة، يمكن لبيتر تدخين 5 سجائر في المجموع.\n * - مع 10 سجائر أولية و3 أعقاب مطلوبة للحصول على واحدة جديدة، يمكن لبيتر تدخين 14 سيجارة في المجموع.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int ",
      "sw": "<?php\n\n\n/**\n * Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n * Peter anaanza na idadi fulani ya sigara na anaweza kubadilisha idadi maalum ya vishungi vya sigara kwa sigara mpya.\n * Mchakato huu unarudiwa hadi hawezi tena kubadilisha vishungi kwa sigara mpya.\n *\n * Vigezo:\n * - $initialCigarettes (int): Idadi ya awali ya sigara ambazo Peter anazo.\n * - $buttsRequiredForNew (int): Idadi ya vishungi vya sigara vinavyohitajika kubadilisha kwa sigara mpya.\n *\n * Inarudisha:\n * int: Jumla ya sigara ambazo Peter anaweza kuvuta.\n *\n * Mfano:\n * - Akiwa na sigara 4 za awali na vishungi 3 vinavyohitajika kwa mpya, Peter anaweza kuvuta sigara 5 kwa jumla.\n * - Akiwa na sigara 10 za awali na vishungi 3 vinavyohitajika kwa mpya, Peter anaweza kuvuta sigara 14 kwa jumla.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int ",
      "tr": "<?php\n\n\n/**\n * Peter'ın içebileceği toplam sigara sayısını hesaplar.\n * Peter belirli bir sayıda sigara ile başlar ve belirli bir sayıda sigara izmaritini yeni bir sigara ile değiştirebilir.\n * Bu işlem, izmaritleri yeni sigaralarla değiştiremeyeceği ana kadar tekrar eder.\n *\n * Parametreler:\n * - $initialCigarettes (int): Peter'ın sahip olduğu başlangıç sigara sayısı.\n * - $buttsRequiredForNew (int): Yeni bir sigara ile değiştirmek için gereken sigara izmariti sayısı.\n *\n * Döndürür:\n * int: Peter'ın içebileceği toplam sigara sayısı.\n *\n * Örnek:\n * - 4 başlangıç sigarası ve yeni bir sigara için gereken 3 izmarit ile, Peter toplamda 5 sigara içebilir.\n * - 10 başlangıç sigarası ve yeni bir sigara için gereken 3 izmarit ile, Peter toplamda 14 sigara içebilir.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int ",
      "vi": "<?php\n\n\n/**\n * Tính tổng số điếu thuốc lá mà Peter có thể hút.\n * Peter bắt đầu với một số lượng thuốc lá nhất định và có thể đổi một số lượng đầu lọc thuốc lá nhất định để lấy một điếu thuốc lá mới.\n * Quá trình này lặp lại cho đến khi anh ta không thể đổi đầu lọc lấy thuốc lá mới nữa.\n *\n * Tham số:\n * - $initialCigarettes (int): Số lượng thuốc lá ban đầu mà Peter có.\n * - $buttsRequiredForNew (int): Số lượng đầu lọc thuốc lá cần thiết để đổi lấy một điếu thuốc lá mới.\n *\n * Trả về:\n * int: Tổng số điếu thuốc lá mà Peter có thể hút.\n *\n * Ví dụ:\n * - Với 4 điếu thuốc lá ban đầu và 3 đầu lọc cần thiết cho một điếu mới, Peter có thể hút tổng cộng 5 điếu thuốc lá.\n * - Với 10 điếu thuốc lá ban đầu và 3 đầu lọc cần thiết cho một điếu mới, Peter có thể hút tổng cộng 14 điếu thuốc lá.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int "
    },
    "prompt_bertscore": {
      "es": "0.9899014327978053",
      "arb": "0.9863004626200238",
      "sw": "0.9912199412671149",
      "tr": "0.9869825593484975",
      "vi": "0.9861775104141631"
    },
    "canonical_solution": "{\n    $totalSmoked = $initialCigarettes;\n    $currentButts = $initialCigarettes;\n    \n    while ($currentButts >= $buttsRequiredForNew) {\n        $newCigarettes = intdiv($currentButts, $buttsRequiredForNew);\n        $totalSmoked += $newCigarettes;\n        $currentButts = ($currentButts % $buttsRequiredForNew) + $newCigarettes;\n    }\n    \n    return $totalSmoked;\n}",
    "instruction": {
      "en": "Write a PHP function `function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke.\n  Peter starts with a certain number of cigarettes and can exchange a specific number of cigarette butts for a new cigarette.\n  This process repeats until he can no longer exchange butts for new cigarettes.\n \n  Parameters:\n  - $initialCigarettes (int): The initial number of cigarettes Peter has.\n  - $buttsRequiredForNew (int): The number of cigarette butts required to exchange for a new cigarette.\n \n  Returns:\n  int: The total number of cigarettes Peter can smoke.\n \n  Example:\n  - With 4 initial cigarettes and 3 butts required for a new one, Peter can smoke 5 cigarettes in total.\n  - With 10 initial cigarettes and 3 butts required for a new one, Peter can smoke 14 cigarettes in total.",
      "es": "Escribe una función PHP `function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int` para resolver el siguiente problema:\nCalcula el número total de cigarrillos que Peter puede fumar.\n  Peter comienza con un cierto número de cigarrillos y puede intercambiar un número específico de colillas de cigarrillo por un cigarrillo nuevo.\n  Este proceso se repite hasta que ya no pueda intercambiar colillas por nuevos cigarrillos.\n\n  Parámetros:\n  - $initialCigarettes (int): El número inicial de cigarrillos que tiene Peter.\n  - $buttsRequiredForNew (int): El número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\n\n  Devuelve:\n  int: El número total de cigarrillos que Peter puede fumar.\n\n  Ejemplo:\n  - Con 4 cigarrillos iniciales y 3 colillas requeridas para uno nuevo, Peter puede fumar 5 cigarrillos en total.\n  - Con 10 cigarrillos iniciales y 3 colillas requeridas para uno nuevo, Peter puede fumar 14 cigarrillos en total.",
      "arb": "اكتب دالة PHP `function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int` لحل المشكلة التالية:\nتحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\nيبدأ بيتر بعدد معين من السجائر ويمكنه تبادل عدد محدد من أعقاب السجائر للحصول على سيجارة جديدة.\nتتكرر هذه العملية حتى لا يتمكن من تبادل الأعقاب للحصول على سجائر جديدة.\n\nالمعطيات:\n- $initialCigarettes (int): عدد السجائر الأولي الذي يمتلكه بيتر.\n- $buttsRequiredForNew (int): عدد أعقاب السجائر المطلوبة لتبادلها بسيجارة جديدة.\n\nالقيمة المعادة:\nint: العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n\nمثال:\n- مع 4 سجائر أولية و3 أعقاب مطلوبة للحصول على واحدة جديدة، يمكن لبيتر تدخين 5 سجائر في المجموع.\n- مع 10 سجائر أولية و3 أعقاب مطلوبة للحصول على واحدة جديدة، يمكن لبيتر تدخين 14 سيجارة في المجموع.",
      "sw": "Andika kazi ya PHP `function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int` kutatua tatizo lifuatalo:\nInakokotoa jumla ya sigara ambazo Peter anaweza kuvuta.\n  Peter anaanza na idadi fulani ya sigara na anaweza kubadilisha idadi maalum ya vishungi vya sigara kwa sigara mpya.\n  Mchakato huu unarudiwa hadi pale ambapo hawezi tena kubadilisha vishungi kwa sigara mpya.\n \n  Vigezo:\n  - $initialCigarettes (int): Idadi ya awali ya sigara ambazo Peter anazo.\n  - $buttsRequiredForNew (int): Idadi ya vishungi vya sigara vinavyohitajika kubadilishwa kwa sigara mpya.\n \n  Inarudisha:\n  int: Jumla ya sigara ambazo Peter anaweza kuvuta.\n \n  Mfano:\n  - Akiwa na sigara 4 za awali na vishungi 3 vinavyohitajika kwa sigara mpya, Peter anaweza kuvuta sigara 5 kwa jumla.\n  - Akiwa na sigara 10 za awali na vishungi 3 vinavyohitajika kwa sigara mpya, Peter anaweza kuvuta sigara 14 kwa jumla.",
      "tr": "Bir PHP fonksiyonu `function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int` yazın ve aşağıdaki problemi çözün:\nPeter'ın toplam kaç sigara içebileceğini hesaplar.\n  Peter belirli bir sayıda sigara ile başlar ve belirli bir sayıda sigara izmaritini yeni bir sigara ile değiştirebilir.\n  Bu işlem, izmaritleri yeni sigaralarla değiştiremeyene kadar tekrar eder.\n \n  Parametreler:\n  - $initialCigarettes (int): Peter'ın başlangıçta sahip olduğu sigara sayısı.\n  - $buttsRequiredForNew (int): Yeni bir sigara ile değiştirmek için gereken sigara izmariti sayısı.\n \n  Döndürür:\n  int: Peter'ın toplam içebileceği sigara sayısı.\n \n  Örnek:\n  - 4 başlangıç sigarası ve yeni bir sigara için gereken 3 izmarit ile, Peter toplamda 5 sigara içebilir.\n  - 10 başlangıç sigarası ve yeni bir sigara için gereken 3 izmarit ile, Peter toplamda 14 sigara içebilir.",
      "vi": "Viết một hàm PHP `function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int` để giải quyết vấn đề sau:\nTính tổng số điếu thuốc mà Peter có thể hút.\n  Peter bắt đầu với một số lượng điếu thuốc nhất định và có thể đổi một số lượng đầu lọc thuốc lá cụ thể để lấy một điếu thuốc mới.\n  Quá trình này lặp lại cho đến khi anh ta không thể đổi đầu lọc lấy điếu thuốc mới nữa.\n \n  Tham số:\n  - $initialCigarettes (int): Số lượng điếu thuốc ban đầu mà Peter có.\n  - $buttsRequiredForNew (int): Số lượng đầu lọc thuốc lá cần để đổi lấy một điếu thuốc mới.\n \n  Trả về:\n  int: Tổng số điếu thuốc mà Peter có thể hút.\n \n  Ví dụ:\n  - Với 4 điếu thuốc ban đầu và 3 đầu lọc cần cho một điếu mới, Peter có thể hút tổng cộng 5 điếu thuốc.\n  - Với 10 điếu thuốc ban đầu và 3 đầu lọc cần cho một điếu mới, Peter có thể hút tổng cộng 14 điếu thuốc."
    },
    "instruction_bertscore": {
      "es": "0.9940627392804862",
      "arb": "0.9678204878596809",
      "sw": "0.9816469500531384",
      "tr": "0.9828881913042254",
      "vi": "0.9846844058399239"
    },
    "level": "easy",
    "test": "function main(){\n    assert(calculateTotalCigarettes(4, 3) === 5, 'Test Case 1 Failed');\n    assert(calculateTotalCigarettes(10, 3) === 14, 'Test Case 2 Failed');\n    assert(calculateTotalCigarettes(1, 2) === 1, 'Test Case 3 Failed');\n    assert(calculateTotalCigarettes(20, 5) === 24, 'Test Case 4 Failed');\n    assert(calculateTotalCigarettes(0, 3) === 0, 'Test Case 5 Failed');\n}\n\n\nmain();\n?>",
    "entry_point": "calculateTotalCigarettes",
    "signature": "function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke.\n  Peter starts with a certain number of cigarettes and can exchange a specific number of cigarette butts for a new cigarette.\n  This process repeats until he can no longer exchange butts for new cigarettes.\n \n  Parameters:\n  - $initialCigarettes (int): The initial number of cigarettes Peter has.\n  - $buttsRequiredForNew (int): The number of cigarette butts required to exchange for a new cigarette.\n \n  Returns:\n  int: The total number of cigarettes Peter can smoke.\n \n  Example:\n  - With 4 initial cigarettes and 3 butts required for a new one, Peter can smoke 5 cigarettes in total.\n  - With 10 initial cigarettes and 3 butts required for a new one, Peter can smoke 14 cigarettes in total.",
      "es": "Calcula el número total de cigarrillos que Peter puede fumar. \n  Peter comienza con una cierta cantidad de cigarrillos y puede intercambiar un número específico de colillas de cigarrillo por un cigarrillo nuevo. \n  Este proceso se repite hasta que ya no pueda intercambiar colillas por cigarrillos nuevos.\n \n  Parámetros:\n  - $initialCigarettes (int): El número inicial de cigarrillos que tiene Peter.\n  - $buttsRequiredForNew (int): El número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\n \n  Devuelve:\n  int: El número total de cigarrillos que Peter puede fumar.\n \n  Ejemplo:\n  - Con 4 cigarrillos iniciales y 3 colillas requeridas para uno nuevo, Peter puede fumar 5 cigarrillos en total.\n  - Con 10 cigarrillos iniciales y 3 colillas requeridas para uno nuevo, Peter puede fumar 14 cigarrillos en total.",
      "arb": "يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n  يبدأ بيتر بعدد معين من السجائر ويمكنه تبادل عدد محدد من أعقاب السجائر للحصول على سيجارة جديدة.\n  تتكرر هذه العملية حتى لا يتمكن من تبادل الأعقاب للحصول على سجائر جديدة.\n\n  المعاملات:\n  - $initialCigarettes (int): عدد السجائر الأولي الذي يمتلكه بيتر.\n  - $buttsRequiredForNew (int): عدد أعقاب السجائر المطلوبة للتبادل للحصول على سيجارة جديدة.\n\n  يعيد:\n  int: العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n\n  مثال:\n  - مع 4 سجائر أولية و3 أعقاب مطلوبة للحصول على واحدة جديدة، يمكن لبيتر أن يدخن 5 سجائر في المجموع.\n  - مع 10 سجائر أولية و3 أعقاب مطلوبة للحصول على واحدة جديدة، يمكن لبيتر أن يدخن 14 سيجارة في المجموع.",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta.  \nPeter anaanza na idadi fulani ya sigara na anaweza kubadilisha idadi maalum ya vishungi vya sigara kwa sigara mpya.  \nMchakato huu unarudiwa hadi pale ambapo hawezi tena kubadilisha vishungi kwa sigara mpya.\n\nVigezo:  \n- $initialCigarettes (int): Idadi ya awali ya sigara ambazo Peter anazo.  \n- $buttsRequiredForNew (int): Idadi ya vishungi vya sigara vinavyohitajika kubadilishwa kwa sigara mpya.\n\nRudisha:  \nint: Jumla ya sigara ambazo Peter anaweza kuvuta.\n\nMfano:  \n- Akiwa na sigara 4 za awali na vishungi 3 vinavyohitajika kwa sigara mpya, Peter anaweza kuvuta sigara 5 kwa jumla.  \n- Akiwa na sigara 10 za awali na vishungi 3 vinavyohitajika kwa sigara mpya, Peter anaweza kuvuta sigara 14 kwa jumla.",
      "tr": "Peter'ın içebileceği toplam sigara sayısını hesaplar.\n  Peter belirli bir sayıda sigara ile başlar ve belirli bir sayıda sigara izmaritini yeni bir sigara ile değiştirebilir.\n  Bu süreç, izmaritleri yeni sigaralarla değiştiremeyeceği zamana kadar tekrar eder.\n \n  Parametreler:\n  - $initialCigarettes (int): Peter'ın sahip olduğu başlangıç sigara sayısı.\n  - $buttsRequiredForNew (int): Yeni bir sigara ile değiştirmek için gereken sigara izmariti sayısı.\n \n  Döndürür:\n  int: Peter'ın içebileceği toplam sigara sayısı.\n \n  Örnek:\n  - 4 başlangıç sigarası ve yeni bir sigara için gereken 3 izmarit ile, Peter toplamda 5 sigara içebilir.\n  - 10 başlangıç sigarası ve yeni bir sigara için gereken 3 izmarit ile, Peter toplamda 14 sigara içebilir.",
      "vi": "Tính tổng số điếu thuốc mà Peter có thể hút.  \nPeter bắt đầu với một số lượng điếu thuốc nhất định và có thể đổi một số lượng đầu mẩu thuốc lá cụ thể để lấy một điếu thuốc mới.  \nQuá trình này lặp lại cho đến khi anh ta không thể đổi đầu mẩu lấy điếu thuốc mới nữa.  \n\nTham số:  \n- $initialCigarettes (int): Số lượng điếu thuốc ban đầu mà Peter có.  \n- $buttsRequiredForNew (int): Số lượng đầu mẩu thuốc lá cần để đổi lấy một điếu thuốc mới.  \n\nTrả về:  \nint: Tổng số điếu thuốc mà Peter có thể hút.  \n\nVí dụ:  \n- Với 4 điếu thuốc ban đầu và 3 đầu mẩu cần thiết cho một điếu mới, Peter có thể hút tổng cộng 5 điếu thuốc.  \n- Với 10 điếu thuốc ban đầu và 3 đầu mẩu cần thiết cho một điếu mới, Peter có thể hút tổng cộng 14 điếu thuốc."
    },
    "docstring_bertscore": {
      "es": "0.9885350544066662",
      "arb": "0.9765119574426244",
      "sw": "0.9778787330945256",
      "tr": "0.972364356456235",
      "vi": "0.9787155628898255"
    }
  },
  {
    "task_id": "PHP/43",
    "prompt": {
      "en": "<?php\n\n/**\n * Finds the length of the longest sequence of consecutive numbers in an array.\n * Consecutive numbers are numbers which come one after the other in sequence without any gaps.\n * For example, in the array [1, 3, 5, 4, 2, 6], the longest sequence of consecutive numbers is [1, 2, 3, 4, 5, 6], which has a length of 6.\n * Input: An array of integers.\n * Output: The length of the longest sequence of consecutive numbers found in the array.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int ",
      "es": "<?php\n\n/**\n * Encuentra la longitud de la secuencia más larga de números consecutivos en un arreglo.\n * Los números consecutivos son números que vienen uno tras otro en secuencia sin huecos.\n * Por ejemplo, en el arreglo [1, 3, 5, 4, 2, 6], la secuencia más larga de números consecutivos es [1, 2, 3, 4, 5, 6], que tiene una longitud de 6.\n * Entrada: Un arreglo de enteros.\n * Salida: La longitud de la secuencia más larga de números consecutivos encontrada en el arreglo.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int ",
      "arb": "<?php\n\n/**\n * يجد طول أطول تسلسل من الأرقام المتتالية في مصفوفة.\n * الأرقام المتتالية هي الأرقام التي تأتي واحدة تلو الأخرى في تسلسل بدون أي فجوات.\n * على سبيل المثال، في المصفوفة [1, 3, 5, 4, 2, 6]، أطول تسلسل من الأرقام المتتالية هو [1, 2, 3, 4, 5, 6]، والذي له طول 6.\n * المدخل: مصفوفة من الأعداد الصحيحة.\n * المخرج: طول أطول تسلسل من الأرقام المتتالية الموجود في المصفوفة.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int ",
      "sw": "<?php\n\n/**\n * Inapata urefu wa mlolongo mrefu zaidi wa namba zinazofuatana katika safu.\n * Namba zinazofuatana ni namba ambazo zinakuja moja baada ya nyingine bila pengo lolote.\n * Kwa mfano, katika safu [1, 3, 5, 4, 2, 6], mlolongo mrefu zaidi wa namba zinazofuatana ni [1, 2, 3, 4, 5, 6], ambao una urefu wa 6.\n * Ingizo: Safu ya namba za integer.\n * Tokeo: Urefu wa mlolongo mrefu zaidi wa namba zinazofuatana uliopatikana katika safu.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int ",
      "tr": "<?php\n\n/**\n * Bir dizideki ardışık sayıların en uzun dizisinin uzunluğunu bulur.\n * Ardışık sayılar, arada boşluk olmadan sırayla gelen sayılardır.\n * Örneğin, [1, 3, 5, 4, 2, 6] dizisinde, ardışık sayıların en uzun dizisi [1, 2, 3, 4, 5, 6] olup, uzunluğu 6'dır.\n * Girdi: Bir tamsayı dizisi.\n * Çıktı: Dizide bulunan ardışık sayıların en uzun dizisinin uzunluğu.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int ",
      "vi": "<?php\n\n/**\n * Tìm độ dài của dãy số liên tiếp dài nhất trong một mảng.\n * Các số liên tiếp là các số xuất hiện liên tiếp nhau trong dãy mà không có khoảng trống.\n * Ví dụ, trong mảng [1, 3, 5, 4, 2, 6], dãy số liên tiếp dài nhất là [1, 2, 3, 4, 5, 6], có độ dài là 6.\n * Đầu vào: Một mảng các số nguyên.\n * Đầu ra: Độ dài của dãy số liên tiếp dài nhất tìm thấy trong mảng.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int "
    },
    "prompt_bertscore": {
      "es": "0.9899771109729796",
      "arb": "0.9911168520993577",
      "sw": "0.9747403730741743",
      "tr": "0.9686360642042101",
      "vi": "0.950263548480007"
    },
    "canonical_solution": "{\n    if (empty($numbers)) {\n        return 0;\n    }\n    sort($numbers);\n    $longest = 1;\n    $currentLength = 1;\n    for ($i = 1; $i < count($numbers); $i++) {\n        if ($numbers[$i] == $numbers[$i - 1] + 1) {\n            $currentLength++;\n        } elseif ($numbers[$i] != $numbers[$i - 1]) {\n            $longest = max($longest, $currentLength);\n            $currentLength = 1;\n        }\n    }\n    return max($longest, $currentLength);\n}",
    "instruction": {
      "en": "Write a PHP function `function findLongestConsecutiveSequence(array $numbers): int` to solve the following problem:\nFinds the length of the longest sequence of consecutive numbers in an array.\n  Consecutive numbers are numbers which come one after the other in sequence without any gaps.\n  For example, in the array [1, 3, 5, 4, 2, 6], the longest sequence of consecutive numbers is [1, 2, 3, 4, 5, 6], which has a length of 6.\n  Input: An array of integers.\n  Output: The length of the longest sequence of consecutive numbers found in the array.",
      "es": "Escribe una función PHP `function findLongestConsecutiveSequence(array $numbers): int` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia más larga de números consecutivos en un array.\n  Los números consecutivos son números que vienen uno tras otro en secuencia sin ningún hueco.\n  Por ejemplo, en el array [1, 3, 5, 4, 2, 6], la secuencia más larga de números consecutivos es [1, 2, 3, 4, 5, 6], que tiene una longitud de 6.\n  Entrada: Un array de enteros.\n  Salida: La longitud de la secuencia más larga de números consecutivos encontrada en el array.",
      "arb": "اكتب دالة PHP `function findLongestConsecutiveSequence(array $numbers): int` لحل المشكلة التالية:\nيجد طول أطول تسلسل من الأرقام المتتالية في مصفوفة.\nالأرقام المتتالية هي الأرقام التي تأتي واحدة تلو الأخرى في تسلسل بدون فجوات.\nعلى سبيل المثال، في المصفوفة [1, 3, 5, 4, 2, 6]، أطول تسلسل من الأرقام المتتالية هو [1, 2, 3, 4, 5, 6]، والذي يبلغ طوله 6.\nالمدخلات: مصفوفة من الأعداد الصحيحة.\nالمخرجات: طول أطول تسلسل من الأرقام المتتالية الموجود في المصفوفة.",
      "sw": "Andika kazi ya PHP `function findLongestConsecutiveSequence(array $numbers): int` kutatua tatizo lifuatalo:\nInapata urefu wa mlolongo mrefu zaidi wa namba zinazofuatana katika safu.\n  Namba zinazofuatana ni namba ambazo zinakuja moja baada ya nyingine katika mlolongo bila mapengo yoyote.\n  Kwa mfano, katika safu [1, 3, 5, 4, 2, 6], mlolongo mrefu zaidi wa namba zinazofuatana ni [1, 2, 3, 4, 5, 6], ambao una urefu wa 6.\n  Ingizo: Safu ya namba za mzima.\n  Tokeo: Urefu wa mlolongo mrefu zaidi wa namba zinazofuatana uliopatikana katika safu.",
      "tr": "Bir PHP fonksiyonu `function findLongestConsecutiveSequence(array $numbers): int` yazın:\nBir dizideki en uzun ardışık sayı dizisinin uzunluğunu bulur.\n  Ardışık sayılar, aralarında boşluk olmadan sırayla gelen sayılardır.\n  Örneğin, [1, 3, 5, 4, 2, 6] dizisinde, en uzun ardışık sayı dizisi [1, 2, 3, 4, 5, 6] olup, uzunluğu 6'dır.\n  Girdi: Bir tamsayı dizisi.\n  Çıktı: Dizide bulunan en uzun ardışık sayı dizisinin uzunluğu.",
      "vi": "Viết một hàm PHP `function findLongestConsecutiveSequence(array $numbers): int` để giải quyết vấn đề sau:\nTìm độ dài của dãy số liên tiếp dài nhất trong một mảng.\n  Các số liên tiếp là các số xuất hiện liên tiếp nhau trong dãy mà không có khoảng trống.\n  Ví dụ, trong mảng [1, 3, 5, 4, 2, 6], dãy số liên tiếp dài nhất là [1, 2, 3, 4, 5, 6], có độ dài là 6.\n  Đầu vào: Một mảng số nguyên.\n  Đầu ra: Độ dài của dãy số liên tiếp dài nhất tìm thấy trong mảng."
    },
    "instruction_bertscore": {
      "es": "0.9910169410176972",
      "arb": "0.987207011679067",
      "sw": "0.992798258274818",
      "tr": "0.942366600421203",
      "vi": "0.9492199444580498"
    },
    "level": "easy",
    "test": "function main(){\n    assert(findLongestConsecutiveSequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9]) === 6);\n    assert(findLongestConsecutiveSequence([10, 4, 20, 1, 3, 2]) === 4);\n    assert(findLongestConsecutiveSequence([1, 2, 2, 3]) === 3);\n    assert(findLongestConsecutiveSequence([]) === 0);\n    assert(findLongestConsecutiveSequence([7]) === 1);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "findLongestConsecutiveSequence",
    "signature": "function findLongestConsecutiveSequence(array $numbers): int",
    "docstring": {
      "en": "Finds the length of the longest sequence of consecutive numbers in an array.\n  Consecutive numbers are numbers which come one after the other in sequence without any gaps.\n  For example, in the array [1, 3, 5, 4, 2, 6], the longest sequence of consecutive numbers is [1, 2, 3, 4, 5, 6], which has a length of 6.\n  Input: An array of integers.\n  Output: The length of the longest sequence of consecutive numbers found in the array.",
      "es": "Encuentra la longitud de la secuencia más larga de números consecutivos en un arreglo.\n  Los números consecutivos son números que vienen uno tras otro en secuencia sin ningún hueco.\n  Por ejemplo, en el arreglo [1, 3, 5, 4, 2, 6], la secuencia más larga de números consecutivos es [1, 2, 3, 4, 5, 6], que tiene una longitud de 6.\n  Entrada: Un arreglo de enteros.\n  Salida: La longitud de la secuencia más larga de números consecutivos encontrada en el arreglo.",
      "arb": "يجد طول أطول تسلسل من الأرقام المتتالية في مصفوفة.\nالأرقام المتتالية هي الأرقام التي تأتي واحدة تلو الأخرى في تسلسل بدون أي فجوات.\nعلى سبيل المثال، في المصفوفة [1, 3, 5, 4, 2, 6]، أطول تسلسل من الأرقام المتتالية هو [1, 2, 3, 4, 5, 6]، والذي له طول 6.\nالمدخل: مصفوفة من الأعداد الصحيحة.\nالمخرج: طول أطول تسلسل من الأرقام المتتالية الموجود في المصفوفة.",
      "sw": "Inapata urefu wa mlolongo mrefu zaidi wa namba zinazofuatana katika safu.\n  Namba za mfululizo ni namba ambazo huja moja baada ya nyingine bila pengo lolote.\n  Kwa mfano, katika safu [1, 3, 5, 4, 2, 6], mfululizo mrefu zaidi wa namba za mfululizo ni [1, 2, 3, 4, 5, 6], ambao una urefu wa 6.\n  Ingizo: Safu ya namba nzima.\n  Matokeo: Urefu wa mfululizo mrefu zaidi wa namba za mfululizo uliopatikana kwenye safu.",
      "tr": "Bir dizideki en uzun ardışık sayı dizisinin uzunluğunu bulur.\n  Ardışık sayılar, arada boşluk olmadan art arda gelen sayılardır.\n  Örneğin, [1, 3, 5, 4, 2, 6] dizisinde, en uzun ardışık sayı dizisi [1, 2, 3, 4, 5, 6] olup, uzunluğu 6'dır.\n  Girdi: Bir tamsayı dizisi.\n  Çıktı: Dizide bulunan en uzun ardışık sayı dizisinin uzunluğu.",
      "vi": "Tìm độ dài của dãy số liên tiếp dài nhất trong một mảng.\n  Số liên tiếp là các số xuất hiện liên tục trong dãy mà không có khoảng cách nào.\n  Ví dụ, trong mảng [1, 3, 5, 4, 2, 6], dãy số liên tiếp dài nhất là [1, 2, 3, 4, 5, 6], có độ dài là 6.\n  Đầu vào: Một mảng các số nguyên.\n  Đầu ra: Độ dài của dãy số liên tiếp dài nhất được tìm thấy trong mảng."
    },
    "docstring_bertscore": {
      "es": "0.9866049629941502",
      "arb": "0.9909384820171884",
      "sw": "0.9840680557675726",
      "tr": "0.9708609231021819",
      "vi": "0.9429501764806836"
    }
  },
  {
    "task_id": "PHP/44",
    "prompt": {
      "en": "<?php\n\n/**\n * Compares the area of a square and a rectangle to determine which is larger.\n * The square's side length is represented by $a, while the rectangle's dimensions are represented by $b and $c.\n * Input: Three integers $a, $b, and $c, where $a is the side length of the square, and $b and $c are the width and height of the rectangle, respectively.\n * Output: Returns a string \"Alice\" if the square's area is greater, \"Bob\" if the rectangle's area is greater, or \"Equal\" if both areas are the same.\n */\nfunction compareArea($a, $b, $c): string ",
      "es": "<?php\n\n/**\n * Compara el área de un cuadrado y un rectángulo para determinar cuál es mayor.\n * La longitud del lado del cuadrado está representada por $a, mientras que las dimensiones del rectángulo están representadas por $b y $c.\n * Entrada: Tres enteros $a, $b y $c, donde $a es la longitud del lado del cuadrado, y $b y $c son el ancho y la altura del rectángulo, respectivamente.\n * Salida: Devuelve una cadena \"Alice\" si el área del cuadrado es mayor, \"Bob\" si el área del rectángulo es mayor, o \"Equal\" si ambas áreas son iguales.\n */\nfunction compareArea($a, $b, $c): string ",
      "arb": "<?php\n\n/**\n * يقارن بين مساحة المربع والمستطيل لتحديد أيهما أكبر.\n * يتم تمثيل طول ضلع المربع بواسطة $a، بينما يتم تمثيل أبعاد المستطيل بواسطة $b و $c.\n * المدخلات: ثلاثة أعداد صحيحة $a، $b، و $c، حيث $a هو طول ضلع المربع، و $b و $c هما عرض وارتفاع المستطيل، على التوالي.\n * المخرجات: يعيد سلسلة نصية \"Alice\" إذا كانت مساحة المربع أكبر، \"Bob\" إذا كانت مساحة المستطيل أكبر، أو \"Equal\" إذا كانت المساحتان متساويتين.\n */\nfunction compareArea($a, $b, $c): string ",
      "sw": "<?php\n\n/**\n * Inalinganisha eneo la mraba na mstatili ili kubaini ni lipi kubwa zaidi.\n * Urefu wa upande wa mraba unawakilishwa na $a, wakati vipimo vya mstatili vinawakilishwa na $b na $c.\n * Ingizo: Nambari tatu za mzima $a, $b, na $c, ambapo $a ni urefu wa upande wa mraba, na $b na $c ni upana na urefu wa mstatili, mtawalia.\n * Tokeo: Inarudisha kamba \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi, au \"Equal\" ikiwa maeneo yote ni sawa.\n */\nfunction compareArea($a, $b, $c): string ",
      "tr": "<?php\n\n/**\n * Bir karenin ve bir dikdörtgenin alanını karşılaştırarak hangisinin daha büyük olduğunu belirler.\n * Karenin kenar uzunluğu $a ile temsil edilirken, dikdörtgenin boyutları $b ve $c ile temsil edilir.\n * Girdi: $a, $b ve $c olmak üzere üç tamsayı, burada $a karenin kenar uzunluğudur ve $b ile $c sırasıyla dikdörtgenin genişliği ve yüksekliğidir.\n * Çıktı: Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" veya her iki alan da aynıysa \"Equal\" döndüren bir dize döndürür.\n */\nfunction compareArea($a, $b, $c): string ",
      "vi": "<?php\n\n/**\n * So sánh diện tích của một hình vuông và một hình chữ nhật để xác định cái nào lớn hơn.\n * Chiều dài cạnh của hình vuông được biểu diễn bởi $a, trong khi kích thước của hình chữ nhật được biểu diễn bởi $b và $c.\n * Đầu vào: Ba số nguyên $a, $b, và $c, trong đó $a là chiều dài cạnh của hình vuông, và $b và $c là chiều rộng và chiều cao của hình chữ nhật, tương ứng.\n * Đầu ra: Trả về một chuỗi \"Alice\" nếu diện tích của hình vuông lớn hơn, \"Bob\" nếu diện tích của hình chữ nhật lớn hơn, hoặc \"Equal\" nếu cả hai diện tích bằng nhau.\n */\nfunction compareArea($a, $b, $c): string "
    },
    "prompt_bertscore": {
      "es": "0.966682733037113",
      "arb": "0.9714301977742279",
      "sw": "0.962446741531163",
      "tr": "0.9640161201717197",
      "vi": "0.9709052176771527"
    },
    "canonical_solution": "{\n    $squareArea = $a * $a;\n    $rectangleArea = $b * $c;\n    if ($squareArea > $rectangleArea) {\n        return \"Alice\";\n    } elseif ($squareArea < $rectangleArea) {\n        return \"Bob\";\n    } else {\n        return \"Equal\";\n    }\n}",
    "instruction": {
      "en": "Write a PHP function `function compareArea($a, $b, $c): string` to solve the following problem:\nCompares the area of a square and a rectangle to determine which is larger.\n  The square's side length is represented by $a, while the rectangle's dimensions are represented by $b and $c.\n  Input: Three integers $a, $b, and $c, where $a is the side length of the square, and $b and $c are the width and height of the rectangle, respectively.\n  Output: Returns a string \"Alice\" if the square's area is greater, \"Bob\" if the rectangle's area is greater, or \"Equal\" if both areas are the same.",
      "es": "Escribe una función PHP `function compareArea($a, $b, $c): string` para resolver el siguiente problema:\nCompara el área de un cuadrado y un rectángulo para determinar cuál es mayor.\n  La longitud del lado del cuadrado está representada por $a, mientras que las dimensiones del rectángulo están representadas por $b y $c.\n  Entrada: Tres enteros $a, $b, y $c, donde $a es la longitud del lado del cuadrado, y $b y $c son el ancho y la altura del rectángulo, respectivamente.\n  Salida: Devuelve una cadena \"Alice\" si el área del cuadrado es mayor, \"Bob\" si el área del rectángulo es mayor, o \"Equal\" si ambas áreas son iguales.",
      "arb": "اكتب دالة PHP `function compareArea($a, $b, $c): string` لحل المشكلة التالية:\nيقارن مساحة مربع ومستطيل لتحديد أيهما أكبر.\n  طول ضلع المربع يُمثل بالمتغير $a، بينما أبعاد المستطيل تُمثل بالمتغيرين $b و $c.\n  المدخلات: ثلاثة أعداد صحيحة $a، $b، و $c، حيث $a هو طول ضلع المربع، و$b و$c هما عرض وارتفاع المستطيل، على التوالي.\n  المخرجات: تُرجع سلسلة نصية \"Alice\" إذا كانت مساحة المربع أكبر، \"Bob\" إذا كانت مساحة المستطيل أكبر، أو \"Equal\" إذا كانت المساحتان متساويتين.",
      "sw": "Andika kazi ya PHP `function compareArea($a, $b, $c): string` kutatua tatizo lifuatalo:\nInalinganisha eneo la mraba na mstatili ili kubaini ni lipi kubwa zaidi.\n  Urefu wa upande wa mraba unawakilishwa na $a, wakati vipimo vya mstatili vinawakilishwa na $b na $c.\n  Ingizo: Nambari tatu za mzima $a, $b, na $c, ambapo $a ni urefu wa upande wa mraba, na $b na $c ni upana na urefu wa mstatili, mtawalia.\n  Tokeo: Inarudisha kamba \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi, au \"Equal\" ikiwa maeneo yote mawili ni sawa.",
      "tr": "Bir PHP fonksiyonu `function compareArea($a, $b, $c): string` yazarak aşağıdaki problemi çözün:\nBir karenin ve bir dikdörtgenin alanını karşılaştırarak hangisinin daha büyük olduğunu belirler.\n  Karenin kenar uzunluğu $a ile temsil edilirken, dikdörtgenin boyutları $b ve $c ile temsil edilir.\n  Girdi: Üç tamsayı $a, $b ve $c, burada $a karenin kenar uzunluğudur ve $b ve $c sırasıyla dikdörtgenin genişliği ve yüksekliğidir.\n  Çıktı: Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" veya her iki alan da aynıysa \"Equal\" stringini döndürür.",
      "vi": "Viết một hàm PHP `function compareArea($a, $b, $c): string` để giải quyết vấn đề sau:\nSo sánh diện tích của một hình vuông và một hình chữ nhật để xác định cái nào lớn hơn.\n  Độ dài cạnh của hình vuông được biểu diễn bởi $a, trong khi kích thước của hình chữ nhật được biểu diễn bởi $b và $c.\n  Đầu vào: Ba số nguyên $a, $b, và $c, trong đó $a là độ dài cạnh của hình vuông, và $b và $c là chiều rộng và chiều cao của hình chữ nhật, tương ứng.\n  Đầu ra: Trả về một chuỗi \"Alice\" nếu diện tích của hình vuông lớn hơn, \"Bob\" nếu diện tích của hình chữ nhật lớn hơn, hoặc \"Equal\" nếu cả hai diện tích bằng nhau."
    },
    "instruction_bertscore": {
      "es": "0.9646265113326399",
      "arb": "0.9578367290177243",
      "sw": "0.9576478315253601",
      "tr": "0.968532975036453",
      "vi": "0.9775130545630403"
    },
    "level": "easy",
    "test": "function main(){\n    // Test cases\n    assert(compareArea(5, 4, 6) === \"Alice\"); \n    assert(compareArea(7, 5, 10) === \"Bob\"); \n    assert(compareArea(6, 3, 12) === \"Equal\"); \n\n}\n\n\nmain();\n?>",
    "entry_point": "compareArea",
    "signature": "function compareArea($a, $b, $c): string",
    "docstring": {
      "en": "Compares the area of a square and a rectangle to determine which is larger.\n  The square's side length is represented by $a, while the rectangle's dimensions are represented by $b and $c.\n  Input: Three integers $a, $b, and $c, where $a is the side length of the square, and $b and $c are the width and height of the rectangle, respectively.\n  Output: Returns a string \"Alice\" if the square's area is greater, \"Bob\" if the rectangle's area is greater, or \"Equal\" if both areas are the same.",
      "es": "Compara el área de un cuadrado y un rectángulo para determinar cuál es más grande.  \n  La longitud del lado del cuadrado está representada por $a, mientras que las dimensiones del rectángulo están representadas por $b y $c.  \n  Entrada: Tres enteros $a, $b y $c, donde $a es la longitud del lado del cuadrado, y $b y $c son el ancho y la altura del rectángulo, respectivamente.  \n  Salida: Devuelve una cadena \"Alice\" si el área del cuadrado es mayor, \"Bob\" si el área del rectángulo es mayor, o \"Equal\" si ambas áreas son iguales.",
      "arb": "يقارن مساحة المربع والمستطيل لتحديد أيهما أكبر.\n  يتم تمثيل طول ضلع المربع بواسطة $a، بينما يتم تمثيل أبعاد المستطيل بواسطة $b و $c.\n  المدخلات: ثلاثة أعداد صحيحة $a، $b، و $c، حيث $a هو طول ضلع المربع، و $b و $c هما عرض وارتفاع المستطيل، على التوالي.\n  المخرجات: يعيد سلسلة نصية \"Alice\" إذا كانت مساحة المربع أكبر، \"Bob\" إذا كانت مساحة المستطيل أكبر، أو \"Equal\" إذا كانت المساحتان متساويتين.",
      "sw": "Inalinganisha eneo la mraba na mstatili ili kubaini lipi ni kubwa zaidi.\n  Urefu wa upande wa mraba unawakilishwa na $a, wakati vipimo vya mstatili vinawakilishwa na $b na $c.\n  Ingizo: Nambari tatu za mzima $a, $b, na $c, ambapo $a ni urefu wa upande wa mraba, na $b na $c ni upana na urefu wa mstatili, mtawalia.\n  Tokeo: Inarejesha kamba \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi, au \"Equal\" ikiwa maeneo yote mawili ni sawa.",
      "tr": "Bir karenin ve bir dikdörtgenin alanlarını karşılaştırarak hangisinin daha büyük olduğunu belirler.\n  Karenin kenar uzunluğu $a ile temsil edilirken, dikdörtgenin boyutları $b ve $c ile temsil edilir.\n  Girdi: Üç tamsayı $a, $b ve $c, burada $a karenin kenar uzunluğudur, $b ve $c ise sırasıyla dikdörtgenin genişliği ve yüksekliğidir.\n  Çıktı: Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" veya her iki alan da aynıysa \"Equal\" döndüren bir string.",
      "vi": "So sánh diện tích của một hình vuông và một hình chữ nhật để xác định cái nào lớn hơn.  \nChiều dài cạnh của hình vuông được biểu diễn bởi $a, trong khi kích thước của hình chữ nhật được biểu diễn bởi $b và $c.  \nĐầu vào: Ba số nguyên $a, $b, và $c, trong đó $a là chiều dài cạnh của hình vuông, và $b và $c là chiều rộng và chiều cao của hình chữ nhật, tương ứng.  \nĐầu ra: Trả về một chuỗi \"Alice\" nếu diện tích của hình vuông lớn hơn, \"Bob\" nếu diện tích của hình chữ nhật lớn hơn, hoặc \"Equal\" nếu cả hai diện tích bằng nhau."
    },
    "docstring_bertscore": {
      "es": "0.9741663312729835",
      "arb": "0.956969111513364",
      "sw": "0.965624033106197",
      "tr": "0.945082076360331",
      "vi": "0.9649032034534215"
    }
  },
  {
    "task_id": "PHP/45",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Finds M positive integers whose sum is N and whose product is as large as possible.\n * Outputs the combination with the smallest lexicographical order if there are multiple possibilities.\n * The function aims to distribute the total sum N into M parts such that the product of these parts is maximized.\n * \n * Input: Two integers, $N representing the total sum and $M representing the number of parts.\n * Output: An array of integers representing the distribution that maximizes the product.\n * Example: Given N = 6 and M = 3, the function returns [2, 2, 2] as dividing 6 into three parts of 2 each maximizes the product 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) ",
      "es": "<?php\n\n\n/**\n * Encuentra M enteros positivos cuya suma es N y cuyo producto es lo más grande posible.\n * Muestra la combinación con el orden lexicográfico más pequeño si hay múltiples posibilidades.\n * La función tiene como objetivo distribuir la suma total N en M partes de manera que el producto de estas partes se maximice.\n * \n * Entrada: Dos enteros, $N que representa la suma total y $M que representa el número de partes.\n * Salida: Un array de enteros que representa la distribución que maximiza el producto.\n * Ejemplo: Dado N = 6 y M = 3, la función devuelve [2, 2, 2] ya que dividir 6 en tres partes de 2 cada una maximiza el producto 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) ",
      "arb": "<?php\n\n\n/**\n * يجد M من الأعداد الصحيحة الموجبة التي يكون مجموعها N ويكون حاصل ضربها أكبر ما يمكن.\n * يخرج التركيبة ذات الترتيب المعجمي الأصغر إذا كانت هناك احتمالات متعددة.\n * تهدف الدالة إلى توزيع المجموع الكلي N إلى M أجزاء بحيث يتم تعظيم حاصل ضرب هذه الأجزاء.\n * \n * المدخلات: عددان صحيحان، $N يمثل المجموع الكلي و $M يمثل عدد الأجزاء.\n * المخرجات: مصفوفة من الأعداد الصحيحة تمثل التوزيع الذي يعظم حاصل الضرب.\n * مثال: إذا كان N = 6 و M = 3، فإن الدالة تعيد [2, 2, 2] حيث أن تقسيم 6 إلى ثلاثة أجزاء كل منها 2 يعظم حاصل الضرب 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) ",
      "sw": "<?php\n\n\n/**\n * Inapata nambari M za kawaida ambazo jumla yake ni N na ambazo bidhaa yake ni kubwa iwezekanavyo.\n * Inatoa mchanganyiko wenye mpangilio mdogo wa lexicographical ikiwa kuna uwezekano kadhaa.\n * Kazi inalenga kugawa jumla ya N katika sehemu M ili bidhaa ya sehemu hizi iwe kubwa zaidi.\n * \n * Ingizo: Nambari mbili, $N inawakilisha jumla ya jumla na $M inawakilisha idadi ya sehemu.\n * Tokeo: Safu ya nambari inayoonyesha mgawanyo unaoongeza bidhaa.\n * Mfano: Ikitolewa N = 6 na M = 3, kazi inarudisha [2, 2, 2] kwani kugawa 6 katika sehemu tatu za 2 kila moja kunakuza bidhaa 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) ",
      "tr": "<?php\n\n\n/**\n * Toplamı N olan ve çarpımı mümkün olduğunca büyük olan M pozitif tam sayı bulur.\n * Birden fazla olasılık varsa, en küçük sözlük sırasına sahip kombinasyonu çıktılar.\n * Fonksiyon, toplam N'i M parçaya dağıtarak bu parçaların çarpımını maksimize etmeyi amaçlar.\n * \n * Girdi: Toplamı temsil eden $N ve parça sayısını temsil eden $M olmak üzere iki tam sayı.\n * Çıktı: Çarpımı maksimize eden dağılımı temsil eden bir tam sayı dizisi.\n * Örnek: N = 6 ve M = 3 verildiğinde, fonksiyon [2, 2, 2] döndürür çünkü 6'yı üç parça halinde 2'ye bölmek çarpımı maksimize eder: 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) ",
      "vi": "<?php\n\n\n/**\n * Tìm M số nguyên dương có tổng là N và tích của chúng là lớn nhất có thể.\n * Xuất ra tổ hợp có thứ tự từ điển nhỏ nhất nếu có nhiều khả năng.\n * Hàm này nhằm phân phối tổng số N thành M phần sao cho tích của các phần này được tối đa hóa.\n * \n * Đầu vào: Hai số nguyên, $N đại diện cho tổng số và $M đại diện cho số phần.\n * Đầu ra: Một mảng các số nguyên đại diện cho sự phân phối tối đa hóa tích.\n * Ví dụ: Cho N = 6 và M = 3, hàm trả về [2, 2, 2] vì chia 6 thành ba phần mỗi phần 2 sẽ tối đa hóa tích 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) "
    },
    "prompt_bertscore": {
      "es": "0.9847984196786379",
      "arb": "0.9617757681040272",
      "sw": "0.9467628866446482",
      "tr": "0.9526340034472774",
      "vi": "0.956793522256529"
    },
    "canonical_solution": "{\n    // Initial equal distribution\n    $baseValue = intdiv($N, $M);\n    $remainder = $N % $M;\n    \n    $result = array_fill(0, $M, $baseValue);\n    \n    // Adjust the distribution to distribute the remainder, enhancing the product\n    for ($i = 0; $i < $remainder; $i++) {\n        $result[$i]++;\n    }\n    \n    // Ensure lexicographical order is smallest by distributing remainder from the start\n    sort($result);\n    \n    return $result;\n}",
    "instruction": {
      "en": "Write a PHP function `function maxProductDistribution($N, $M)` to solve the following problem:\nFinds M positive integers whose sum is N and whose product is as large as possible.\n  Outputs the combination with the smallest lexicographical order if there are multiple possibilities.\n  The function aims to distribute the total sum N into M parts such that the product of these parts is maximized.\n  \n  Input: Two integers, $N representing the total sum and $M representing the number of parts.\n  Output: An array of integers representing the distribution that maximizes the product.\n  Example: Given N = 6 and M = 3, the function returns [2, 2, 2] as dividing 6 into three parts of 2 each maximizes the product 222 = 8.",
      "es": "Escribe una función PHP `function maxProductDistribution($N, $M)` para resolver el siguiente problema:\nEncuentra M enteros positivos cuya suma sea N y cuyo producto sea lo más grande posible.\n  Devuelve la combinación con el orden lexicográfico más pequeño si hay múltiples posibilidades.\n  La función tiene como objetivo distribuir la suma total N en M partes de manera que el producto de estas partes sea maximizado.\n  \n  Entrada: Dos enteros, $N que representa la suma total y $M que representa el número de partes.\n  Salida: Un arreglo de enteros que representa la distribución que maximiza el producto.\n  Ejemplo: Dado N = 6 y M = 3, la función devuelve [2, 2, 2] ya que dividir 6 en tres partes de 2 cada una maximiza el producto 222 = 8.",
      "arb": "اكتب دالة PHP `function maxProductDistribution($N, $M)` لحل المشكلة التالية:\nتجد M أعداد صحيحة موجبة يكون مجموعها N ويكون حاصل ضربها أكبر ما يمكن.\nتُخرج التوليفة ذات الترتيب المعجمي الأصغر إذا كانت هناك احتمالات متعددة.\nتهدف الدالة إلى توزيع المجموع الكلي N إلى M أجزاء بحيث يكون حاصل ضرب هذه الأجزاء هو الأقصى.\n\nالمدخلات: عددان صحيحان، $N يمثل المجموع الكلي و $M يمثل عدد الأجزاء.\nالمخرجات: مصفوفة من الأعداد الصحيحة تمثل التوزيع الذي يحقق أكبر حاصل ضرب.\nمثال: بالنظر إلى N = 6 و M = 3، تُرجع الدالة [2, 2, 2] حيث أن تقسيم 6 إلى ثلاثة أجزاء كل منها 2 يحقق أكبر حاصل ضرب 2*2*2 = 8.",
      "sw": "Andika kazi ya PHP `function maxProductDistribution($N, $M)` kutatua tatizo lifuatalo:\nInapata nambari M za kimaadili ambazo jumla yake ni N na ambazo bidhaa yake ni kubwa iwezekanavyo.\n  Inatoa mchanganyiko wenye mpangilio mdogo wa lexicographical ikiwa kuna uwezekano mwingi.\n  Kazi inalenga kugawa jumla ya N katika sehemu M ili bidhaa ya sehemu hizi iwe kubwa zaidi.\n  \n  Ingizo: Nambari mbili, $N inawakilisha jumla ya jumla na $M inawakilisha idadi ya sehemu.\n  Tokeo: Safu ya nambari inayoonyesha mgawanyo unaoongeza bidhaa.\n  Mfano: Ikitolewa N = 6 na M = 3, kazi inarudisha [2, 2, 2] kwani kugawanya 6 katika sehemu tatu za 2 kila moja kunafanya bidhaa 222 = 8 kuwa kubwa zaidi.",
      "tr": "Bir PHP fonksiyonu `function maxProductDistribution($N, $M)` yazın ve aşağıdaki problemi çözün:\nToplamı N olan ve çarpımı olabildiğince büyük olan M pozitif tam sayı bulun.\n  Birden fazla olasılık varsa, en küçük sözlük sırasına sahip kombinasyonu çıktılar.\n  Fonksiyon, toplam N'yi M parçaya dağıtarak bu parçaların çarpımını maksimize etmeyi amaçlar.\n  \n  Girdi: Toplamı temsil eden $N ve parça sayısını temsil eden $M olmak üzere iki tam sayı.\n  Çıktı: Çarpımı maksimize eden dağılımı temsil eden bir tam sayı dizisi.\n  Örnek: N = 6 ve M = 3 verildiğinde, fonksiyon [2, 2, 2] döndürür çünkü 6'yı üçer parça 2'ye bölmek çarpımı maksimize eder 222 = 8.",
      "vi": "Viết một hàm PHP `function maxProductDistribution($N, $M)` để giải quyết vấn đề sau:\nTìm M số nguyên dương có tổng là N và có tích lớn nhất có thể.\n  Xuất ra tổ hợp có thứ tự từ điển nhỏ nhất nếu có nhiều khả năng.\n  Hàm này nhằm phân phối tổng số N thành M phần sao cho tích của các phần này được tối đa hóa.\n  \n  Đầu vào: Hai số nguyên, $N đại diện cho tổng số và $M đại diện cho số phần.\n  Đầu ra: Một mảng các số nguyên đại diện cho sự phân phối mà tối đa hóa tích.\n  Ví dụ: Cho N = 6 và M = 3, hàm trả về [2, 2, 2] vì chia 6 thành ba phần mỗi phần là 2 sẽ tối đa hóa tích 222 = 8."
    },
    "instruction_bertscore": {
      "es": "0.9856267083675534",
      "arb": "0.9469001402379433",
      "sw": "0.9491957115515636",
      "tr": "0.9521835097430903",
      "vi": "0.9520869753779074"
    },
    "level": "easy",
    "test": "function main(){\n    // Test Case 1: Simple distribution\n    assert(maxProductDistribution(6, 3) === [2, 2, 2]);\n\n    // Test Case 2: When distribution is not perfectly even\n    assert(maxProductDistribution(7, 3) === [2, 2, 3]);\n\n    // Test Case 3: Larger numbers with an even distribution\n    assert(maxProductDistribution(10, 2) === [5, 5]);\n\n    // Test Case 4: Larger numbers with a remainder\n    assert(maxProductDistribution(9, 4) === [2, 2, 2, 3]);\n    assert(maxProductDistribution(9, 3) === [3,3, 3]);\n\n    // Test Case 5: Single part (edge case)\n    assert(maxProductDistribution(5, 1) === [5]);\n\n}\n\n\nmain();\n?>",
    "entry_point": "maxProductDistribution",
    "signature": "function maxProductDistribution($N, $M)",
    "docstring": {
      "en": "Finds M positive integers whose sum is N and whose product is as large as possible.\n  Outputs the combination with the smallest lexicographical order if there are multiple possibilities.\n  The function aims to distribute the total sum N into M parts such that the product of these parts is maximized.\n  \n  Input: Two integers, $N representing the total sum and $M representing the number of parts.\n  Output: An array of integers representing the distribution that maximizes the product.\n  Example: Given N = 6 and M = 3, the function returns [2, 2, 2] as dividing 6 into three parts of 2 each maximizes the product 222 = 8.",
      "es": "Encuentra M enteros positivos cuya suma sea N y cuyo producto sea lo más grande posible.\n  Devuelve la combinación con el orden lexicográfico más pequeño si hay múltiples posibilidades.\n  La función tiene como objetivo distribuir la suma total N en M partes de tal manera que el producto de estas partes sea maximizado.\n  \n  Entrada: Dos enteros, $N que representa la suma total y $M que representa el número de partes.\n  Salida: Un arreglo de enteros que representa la distribución que maximiza el producto.\n  Ejemplo: Dado N = 6 y M = 3, la función devuelve [2, 2, 2] ya que dividir 6 en tres partes de 2 cada una maximiza el producto 222 = 8.",
      "arb": "يعثر على M من الأعداد الصحيحة الموجبة التي يكون مجموعها N ويكون حاصل ضربها أكبر ما يمكن.\n  يعرض المجموعة ذات الترتيب الأبجدي الأصغر إذا كانت هناك احتمالات متعددة.\n  تهدف الدالة إلى توزيع المجموع الكلي N إلى M أجزاء بحيث يتم تعظيم حاصل ضرب هذه الأجزاء.\n\n  المدخلات: عددان صحيحان، $N يمثل المجموع الكلي و $M يمثل عدد الأجزاء.\n  المخرجات: مصفوفة من الأعداد الصحيحة تمثل التوزيع الذي يعظم حاصل الضرب.\n  مثال: بالنظر إلى N = 6 و M = 3، تعيد الدالة [2, 2, 2] حيث أن تقسيم 6 إلى ثلاثة أجزاء كل منها 2 يعظم حاصل الضرب 222 = 8.",
      "sw": "Inapata nambari za asili M ambazo jumla yake ni N na ambazo bidhaa yake ni kubwa iwezekanavyo.\n  Inatoa mchanganyiko wenye mpangilio mdogo wa lexicographical ikiwa kuna uwezekano mwingi.\n  Kazi inalenga kugawa jumla ya N katika sehemu M ili bidhaa ya sehemu hizi iwe kubwa zaidi.\n\n  Ingizo: Nambari mbili za asili, $N inayowakilisha jumla ya jumla na $M inayowakilisha idadi ya sehemu.\n  Matokeo: Safu ya nambari za asili zinazowakilisha mgawanyo unaoongeza bidhaa.\n  Mfano: Ikitolewa N = 6 na M = 3, kazi inarudisha [2, 2, 2] kwani kugawa 6 katika sehemu tatu za 2 kila moja kunakamilisha bidhaa 222 = 8.",
      "tr": "M pozitif tam sayının toplamı N olan ve çarpımı mümkün olduğunca büyük olan sayıları bulur.\n  Birden fazla olasılık varsa, en küçük sözlük sırasına sahip kombinasyonu çıktılar.\n  Fonksiyon, toplam N'i M parçaya dağıtarak bu parçaların çarpımını maksimize etmeyi amaçlar.\n  \n  Girdi: Toplamı temsil eden N ve parça sayısını temsil eden M olmak üzere iki tam sayı.\n  Çıktı: Çarpımı maksimize eden dağılımı temsil eden bir tamsayı dizisi.\n  Örnek: N = 6 ve M = 3 verildiğinde, fonksiyon [2, 2, 2] döndürür çünkü 6'yı her biri 2 olan üç parçaya bölmek çarpımı maksimize eder, 222 = 8.",
      "vi": "Tìm M số nguyên dương có tổng là N và có tích lớn nhất có thể.\n  Xuất ra tổ hợp có thứ tự từ điển nhỏ nhất nếu có nhiều khả năng.\n  Hàm này nhằm phân phối tổng số N thành M phần sao cho tích của các phần này được tối đa hóa.\n  \n  Đầu vào: Hai số nguyên, $N đại diện cho tổng số và $M đại diện cho số phần.\n  Đầu ra: Một mảng các số nguyên đại diện cho sự phân phối tối đa hóa tích.\n  Ví dụ: Cho N = 6 và M = 3, hàm trả về [2, 2, 2] vì chia 6 thành ba phần mỗi phần là 2 sẽ tối đa hóa tích 222 = 8."
    },
    "docstring_bertscore": {
      "es": "0.978291089765554",
      "arb": "0.9503872952073918",
      "sw": "0.9154980674089948",
      "tr": "0.8993410749548549",
      "vi": "0.9406518243417289"
    }
  },
  {
    "task_id": "PHP/46",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Calculates the number of characters in a composition's title.\n * The title may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n * The function counts the characters excluding spaces and newline characters.\n * \n * Example usage:\n * - For a title \"234\", the function returns 3.\n * - For a title \"Ca 45\\n\", including a newline character, the function returns 4.\n * \n * @param string $title The title of the composition.\n * @return int The number of characters in the title, excluding spaces and newline characters.\n */\n\nfunction countTitleCharacters(string $title): int ",
      "es": "<?php\n\n\n/**\n * Calcula el número de caracteres en el título de una composición.\n * El título puede contener letras mayúsculas y minúsculas en inglés, dígitos, espacios y caracteres de nueva línea.\n * La función cuenta los caracteres excluyendo espacios y caracteres de nueva línea.\n * \n * Ejemplo de uso:\n * - Para un título \"234\", la función devuelve 3.\n * - Para un título \"Ca 45\\n\", incluyendo un carácter de nueva línea, la función devuelve 4.\n * \n * @param string $title El título de la composición.\n * @return int El número de caracteres en el título, excluyendo espacios y caracteres de nueva línea.\n */\n\nfunction countTitleCharacters(string $title): int ",
      "arb": "<?php\n\n\n/**\n * يحسب عدد الأحرف في عنوان التركيبة.\n * قد يحتوي العنوان على أحرف إنجليزية كبيرة وصغيرة، أرقام، مسافات، وأحرف سطر جديد.\n * تقوم الدالة بعد الأحرف باستثناء المسافات وأحرف السطر الجديد.\n * \n * مثال على الاستخدام:\n * - بالنسبة للعنوان \"234\"، تعيد الدالة 3.\n * - بالنسبة للعنوان \"Ca 45\\n\"، بما في ذلك حرف السطر الجديد، تعيد الدالة 4.\n * \n * @param string $title عنوان التركيبة.\n * @return int عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.\n */\n\nfunction countTitleCharacters(string $title): int ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi ya herufi katika kichwa cha utunzi.\n * Kichwa kinaweza kuwa na herufi kubwa na ndogo za Kiingereza, nambari, nafasi, na herufi za kurudi mstari mpya.\n * Kazi inahesabu herufi isipokuwa nafasi na herufi za kurudi mstari mpya.\n * \n * Mfano wa matumizi:\n * - Kwa kichwa \"234\", kazi inarudisha 3.\n * - Kwa kichwa \"Ca 45\\n\", ikijumuisha herufi ya kurudi mstari mpya, kazi inarudisha 4.\n * \n * @param string $title Kichwa cha utunzi.\n * @return int Idadi ya herufi katika kichwa, isipokuwa nafasi na herufi za kurudi mstari mpya.\n */\n\nfunction countTitleCharacters(string $title): int ",
      "tr": "<?php\n\n\n/**\n * Bir kompozisyonun başlığındaki karakter sayısını hesaplar.\n * Başlık, büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilir.\n * Fonksiyon, boşluklar ve yeni satır karakterleri hariç karakterleri sayar.\n * \n * Örnek kullanım:\n * - \"234\" başlığı için, fonksiyon 3 döndürür.\n * - Yeni satır karakteri içeren \"Ca 45\\n\" başlığı için, fonksiyon 4 döndürür.\n * \n * @param string $title Kompozisyonun başlığı.\n * @return int Boşluklar ve yeni satır karakterleri hariç başlıktaki karakter sayısı.\n */\n\nfunction countTitleCharacters(string $title): int ",
      "vi": "<?php\n\n\n/**\n * Tính số ký tự trong tiêu đề của một tác phẩm.\n * Tiêu đề có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, chữ số, khoảng trắng và ký tự xuống dòng.\n * Hàm đếm các ký tự ngoại trừ khoảng trắng và ký tự xuống dòng.\n * \n * Ví dụ sử dụng:\n * - Đối với tiêu đề \"234\", hàm trả về 3.\n * - Đối với tiêu đề \"Ca 45\\n\", bao gồm ký tự xuống dòng, hàm trả về 4.\n * \n * @param string $title Tiêu đề của tác phẩm.\n * @return int Số ký tự trong tiêu đề, ngoại trừ khoảng trắng và ký tự xuống dòng.\n */\n\nfunction countTitleCharacters(string $title): int "
    },
    "prompt_bertscore": {
      "es": "0.9892252949807625",
      "arb": "0.9728438501960532",
      "sw": "0.9611751098317777",
      "tr": "0.9807344420826641",
      "vi": "0.9817691077374748"
    },
    "canonical_solution": "{\n    $count = 0;\n    for ($i = 0; $i < strlen($title); $i++) {\n        if ($title[$i] != \" \" && $title[$i] != \"\\n\") {\n            $count++;\n        }\n    }\n    return $count;\n}",
    "instruction": {
      "en": "Write a PHP function `function countTitleCharacters(string $title): int` to solve the following problem:\n* Calculates the number of characters in a composition's title.\n * The title may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n * The function counts the characters excluding spaces and newline characters.\n * \n * Example usage:\n * - For a title \"234\", the function returns 3.\n * - For a title \"Ca 45\\n\", including a newline character, the function returns 4.\n * \n * @param string $title The title of the composition.\n * @return int The number of characters in the title, excluding spaces and newline characters.  Calculates the number of characters in a composition's title.\n  The title may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n  The function counts the characters excluding spaces and newline characters.\n  \n  Example usage:\n  - For a title \"234\", the function returns 3.\n  - For a title \"Ca 45\\n\", including a newline character, the function returns 4.\n  \n  @param string $title The title of the composition.\n  @return int The number of characters in the title, excluding spaces and newline characters.",
      "es": "Escribe una función PHP `function countTitleCharacters(string $title): int` para resolver el siguiente problema:\n* Calcula el número de caracteres en el título de una composición.\n * El título puede contener letras inglesas mayúsculas y minúsculas, dígitos, espacios y caracteres de nueva línea.\n * La función cuenta los caracteres excluyendo espacios y caracteres de nueva línea.\n * \n * Ejemplo de uso:\n * - Para un título \"234\", la función devuelve 3.\n * - Para un título \"Ca 45\\n\", incluyendo un carácter de nueva línea, la función devuelve 4.\n * \n * @param string $title El título de la composición.\n * @return int El número de caracteres en el título, excluyendo espacios y caracteres de nueva línea.  Calcula el número de caracteres en el título de una composición.\n  El título puede contener letras inglesas mayúsculas y minúsculas, dígitos, espacios y caracteres de nueva línea.\n  La función cuenta los caracteres excluyendo espacios y caracteres de nueva línea.\n  \n  Ejemplo de uso:\n  - Para un título \"234\", la función devuelve 3.\n  - Para un título \"Ca 45\\n\", incluyendo un carácter de nueva línea, la función devuelve 4.\n  \n  @param string $title El título de la composición.\n  @return int El número de caracteres en el título, excluyendo espacios y caracteres de nueva línea.",
      "arb": "اكتب دالة PHP `function countTitleCharacters(string $title): int` لحل المشكلة التالية:\n* تحسب عدد الأحرف في عنوان التركيبة.\n * قد يحتوي العنوان على أحرف إنجليزية كبيرة وصغيرة، وأرقام، ومسافات، وأحرف سطر جديد.\n * تقوم الدالة بحساب الأحرف باستثناء المسافات وأحرف السطر الجديد.\n * \n * مثال على الاستخدام:\n * - بالنسبة لعنوان \"234\"، تعيد الدالة 3.\n * - بالنسبة لعنوان \"Ca 45\\n\"، بما في ذلك حرف السطر الجديد، تعيد الدالة 4.\n * \n * @param string $title عنوان التركيبة.\n * @return int عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.  تحسب عدد الأحرف في عنوان التركيبة.\n  قد يحتوي العنوان على أحرف إنجليزية كبيرة وصغيرة، وأرقام، ومسافات، وأحرف سطر جديد.\n  تقوم الدالة بحساب الأحرف باستثناء المسافات وأحرف السطر الجديد.\n  \n  مثال على الاستخدام:\n  - بالنسبة لعنوان \"234\"، تعيد الدالة 3.\n  - بالنسبة لعنوان \"Ca 45\\n\"، بما في ذلك حرف السطر الجديد، تعيد الدالة 4.\n  \n  @param string $title عنوان التركيبة.\n  @return int عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.",
      "sw": "Andika kazi ya PHP `function countTitleCharacters(string $title): int` kutatua tatizo lifuatalo:\n* Inahesabu idadi ya herufi katika kichwa cha utunzi.\n * Kichwa kinaweza kuwa na herufi kubwa na ndogo za Kiingereza, nambari, nafasi, na herufi za kurudi mstari mpya.\n * Kazi inahesabu herufi isipokuwa nafasi na herufi za kurudi mstari mpya.\n * \n * Mfano wa matumizi:\n * - Kwa kichwa \"234\", kazi inarudisha 3.\n * - Kwa kichwa \"Ca 45\\n\", ikiwa ni pamoja na herufi ya kurudi mstari mpya, kazi inarudisha 4.\n * \n * @param string $title Kichwa cha utunzi.\n * @return int Idadi ya herufi katika kichwa, isipokuwa nafasi na herufi za kurudi mstari mpya. Inahesabu idadi ya herufi katika kichwa cha utunzi.\n  Kichwa kinaweza kuwa na herufi kubwa na ndogo za Kiingereza, nambari, nafasi, na herufi za kurudi mstari mpya.\n  Kazi inahesabu herufi isipokuwa nafasi na herufi za kurudi mstari mpya.\n  \n  Mfano wa matumizi:\n  - Kwa kichwa \"234\", kazi inarudisha 3.\n  - Kwa kichwa \"Ca 45\\n\", ikiwa ni pamoja na herufi ya kurudi mstari mpya, kazi inarudisha 4.\n  \n  @param string $title Kichwa cha utunzi.\n  @return int Idadi ya herufi katika kichwa, isipokuwa nafasi na herufi za kurudi mstari mpya.",
      "tr": "Bir PHP fonksiyonu `function countTitleCharacters(string $title): int` yazın, aşağıdaki problemi çözmek için:\n* Bir kompozisyonun başlığındaki karakter sayısını hesaplar.\n * Başlık büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilir.\n * Fonksiyon, boşluklar ve yeni satır karakterleri hariç karakterleri sayar.\n * \n * Örnek kullanım:\n * - \"234\" başlığı için, fonksiyon 3 döndürür.\n * - Yeni satır karakteri içeren \"Ca 45\\n\" başlığı için, fonksiyon 4 döndürür.\n * \n * @param string $title Kompozisyonun başlığı.\n * @return int Başlıktaki karakter sayısı, boşluklar ve yeni satır karakterleri hariç. Bir kompozisyonun başlığındaki karakter sayısını hesaplar.\n  Başlık büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilir.\n  Fonksiyon, boşluklar ve yeni satır karakterleri hariç karakterleri sayar.\n  \n  Örnek kullanım:\n  - \"234\" başlığı için, fonksiyon 3 döndürür.\n  - Yeni satır karakteri içeren \"Ca 45\\n\" başlığı için, fonksiyon 4 döndürür.\n  \n  @param string $title Kompozisyonun başlığı.\n  @return int Başlıktaki karakter sayısı, boşluklar ve yeni satır karakterleri hariç.",
      "vi": "Viết một hàm PHP `function countTitleCharacters(string $title): int` để giải quyết vấn đề sau:\n* Tính số ký tự trong tiêu đề của một tác phẩm.\n* Tiêu đề có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, chữ số, khoảng trắng và ký tự xuống dòng.\n* Hàm đếm các ký tự ngoại trừ khoảng trắng và ký tự xuống dòng.\n* \n* Ví dụ sử dụng:\n* - Với tiêu đề \"234\", hàm trả về 3.\n* - Với tiêu đề \"Ca 45\\n\", bao gồm một ký tự xuống dòng, hàm trả về 4.\n* \n* @param string $title Tiêu đề của tác phẩm.\n* @return int Số ký tự trong tiêu đề, ngoại trừ khoảng trắng và ký tự xuống dòng. Tính số ký tự trong tiêu đề của một tác phẩm.\n  Tiêu đề có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, chữ số, khoảng trắng và ký tự xuống dòng.\n  Hàm đếm các ký tự ngoại trừ khoảng trắng và ký tự xuống dòng.\n  \n  Ví dụ sử dụng:\n  - Với tiêu đề \"234\", hàm trả về 3.\n  - Với tiêu đề \"Ca 45\\n\", bao gồm một ký tự xuống dòng, hàm trả về 4.\n  \n  @param string $title Tiêu đề của tác phẩm.\n  @return int Số ký tự trong tiêu đề, ngoại trừ khoảng trắng và ký tự xuống dòng."
    },
    "instruction_bertscore": {
      "es": "0.9823663892932467",
      "arb": "0.9674109120139869",
      "sw": "0.9494438008974762",
      "tr": "0.9720886574873585",
      "vi": "0.973093329954633"
    },
    "level": "easy",
    "test": "function main(){\n    assert(countTitleCharacters(\"234\") === 3, 'Testcase 1 failed');\n    assert(countTitleCharacters(\"Ca 45\") === 4, 'Testcase 2 failed');\n    assert(countTitleCharacters(\" \\nCa 45\\n \") === 4, 'Testcase 3 failed');\n    assert(countTitleCharacters(\"\") === 0, 'Testcase 5 failed');\n    \n}\n\n\nmain();\n?>",
    "entry_point": "countTitleCharacters",
    "signature": "function countTitleCharacters(string $title): int",
    "docstring": {
      "en": "* Calculates the number of characters in a composition's title.\n * The title may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n * The function counts the characters excluding spaces and newline characters.\n * \n * Example usage:\n * - For a title \"234\", the function returns 3.\n * - For a title \"Ca 45\\n\", including a newline character, the function returns 4.\n * \n * @param string $title The title of the composition.\n * @return int The number of characters in the title, excluding spaces and newline characters.  Calculates the number of characters in a composition's title.\n  The title may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n  The function counts the characters excluding spaces and newline characters.\n  \n  Example usage:\n  - For a title \"234\", the function returns 3.\n  - For a title \"Ca 45\\n\", including a newline character, the function returns 4.\n  \n  @param string $title The title of the composition.\n  @return int The number of characters in the title, excluding spaces and newline characters.",
      "es": "* Calcula el número de caracteres en el título de una composición.\n * El título puede contener letras mayúsculas y minúsculas en inglés, dígitos, espacios y caracteres de nueva línea.\n * La función cuenta los caracteres excluyendo espacios y caracteres de nueva línea.\n * \n * Ejemplo de uso:\n * - Para un título \"234\", la función devuelve 3.\n * - Para un título \"Ca 45\\n\", incluyendo un carácter de nueva línea, la función devuelve 4.\n * \n * @param string $title El título de la composición.\n * @return int El número de caracteres en el título, excluyendo espacios y caracteres de nueva línea. Calcula el número de caracteres en el título de una composición.\n  El título puede contener letras mayúsculas y minúsculas en inglés, dígitos, espacios y caracteres de nueva línea.\n  La función cuenta los caracteres excluyendo espacios y caracteres de nueva línea.\n  \n  Ejemplo de uso:\n  - Para un título \"234\", la función devuelve 3.\n  - Para un título \"Ca 45\\n\", incluyendo un carácter de nueva línea, la función devuelve 4.\n  \n  @param string $title El título de la composición.\n  @return int El número de caracteres en el título, excluyendo espacios y caracteres de nueva línea.",
      "arb": "* يحسب عدد الأحرف في عنوان التركيبة.\n * قد يحتوي العنوان على أحرف إنجليزية كبيرة وصغيرة، أرقام، مسافات، وأحرف سطر جديد.\n * تقوم الدالة بحساب الأحرف باستثناء المسافات وأحرف السطر الجديد.\n * \n * مثال على الاستخدام:\n * - لعناوين \"234\"، تعيد الدالة 3.\n * - لعناوين \"Ca 45\\n\"، بما في ذلك حرف سطر جديد، تعيد الدالة 4.\n * \n * @param string $title عنوان التركيبة.\n * @return int عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.  يحسب عدد الأحرف في عنوان التركيبة.\n  قد يحتوي العنوان على أحرف إنجليزية كبيرة وصغيرة، أرقام، مسافات، وأحرف سطر جديد.\n  تقوم الدالة بحساب الأحرف باستثناء المسافات وأحرف السطر الجديد.\n  \n  مثال على الاستخدام:\n  - لعناوين \"234\"، تعيد الدالة 3.\n  - لعناوين \"Ca 45\\n\"، بما في ذلك حرف سطر جديد، تعيد الدالة 4.\n  \n  @param string $title عنوان التركيبة.\n  @return int عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.",
      "sw": "* Inahesabu idadi ya herufi katika kichwa cha utunzi.\n * Kichwa kinaweza kuwa na herufi kubwa na ndogo za Kiingereza, namba, nafasi, na herufi za kurudi mstari mpya.\n * Kazi inahesabu herufi isipokuwa nafasi na herufi za kurudi mstari mpya.\n * \n * Mfano wa matumizi:\n * - Kwa kichwa \"234\", kazi inarudisha 3.\n * - Kwa kichwa \"Ca 45\\n\", ikiwa ni pamoja na herufi ya kurudi mstari mpya, kazi inarudisha 4.\n * \n * @param string $title Kichwa cha utunzi.\n * @return int Idadi ya herufi katika kichwa, isipokuwa nafasi na herufi za kurudi mstari mpya. Inahesabu idadi ya herufi katika kichwa cha utunzi.\n  Kichwa kinaweza kuwa na herufi kubwa na ndogo za Kiingereza, namba, nafasi, na herufi za kurudi mstari mpya.\n  Kazi inahesabu herufi isipokuwa nafasi na herufi za kurudi mstari mpya.\n  \n  Mfano wa matumizi:\n  - Kwa kichwa \"234\", kazi inarudisha 3.\n  - Kwa kichwa \"Ca 45\\n\", ikiwa ni pamoja na herufi ya kurudi mstari mpya, kazi inarudisha 4.\n  \n  @param string $title Kichwa cha utunzi.\n  @return int Idadi ya herufi katika kichwa, isipokuwa nafasi na herufi za kurudi mstari mpya.",
      "tr": "* Bir kompozisyonun başlığındaki karakter sayısını hesaplar.\n * Başlık, büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilir.\n * Fonksiyon, boşluklar ve yeni satır karakterleri hariç karakterleri sayar.\n * \n * Örnek kullanım:\n * - \"234\" başlığı için, fonksiyon 3 döndürür.\n * - Yeni satır karakteri içeren \"Ca 45\\n\" başlığı için, fonksiyon 4 döndürür.\n * \n * @param string $title Kompozisyonun başlığı.\n * @return int Boşluklar ve yeni satır karakterleri hariç başlıktaki karakter sayısı. Bir kompozisyonun başlığındaki karakter sayısını hesaplar.\n  Başlık, büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilir.\n  Fonksiyon, boşluklar ve yeni satır karakterleri hariç karakterleri sayar.\n  \n  Örnek kullanım:\n  - \"234\" başlığı için, fonksiyon 3 döndürür.\n  - Yeni satır karakteri içeren \"Ca 45\\n\" başlığı için, fonksiyon 4 döndürür.\n  \n  @param string $title Kompozisyonun başlığı.\n  @return int Boşluklar ve yeni satır karakterleri hariç başlıktaki karakter sayısı.",
      "vi": "* Tính số ký tự trong tiêu đề của một tác phẩm.\n * Tiêu đề có thể chứa các chữ cái tiếng Anh in hoa và in thường, chữ số, khoảng trắng và ký tự xuống dòng.\n * Hàm đếm các ký tự ngoại trừ khoảng trắng và ký tự xuống dòng.\n * \n * Ví dụ sử dụng:\n * - Với tiêu đề \"234\", hàm trả về 3.\n * - Với tiêu đề \"Ca 45\\n\", bao gồm ký tự xuống dòng, hàm trả về 4.\n * \n * @param string $title Tiêu đề của tác phẩm.\n * @return int Số ký tự trong tiêu đề, ngoại trừ khoảng trắng và ký tự xuống dòng. Tính số ký tự trong tiêu đề của một tác phẩm.\n  Tiêu đề có thể chứa các chữ cái tiếng Anh in hoa và in thường, chữ số, khoảng trắng và ký tự xuống dòng.\n  Hàm đếm các ký tự ngoại trừ khoảng trắng và ký tự xuống dòng.\n  \n  Ví dụ sử dụng:\n  - Với tiêu đề \"234\", hàm trả về 3.\n  - Với tiêu đề \"Ca 45\\n\", bao gồm ký tự xuống dòng, hàm trả về 4.\n  \n  @param string $title Tiêu đề của tác phẩm.\n  @return int Số ký tự trong tiêu đề, ngoại trừ khoảng trắng và ký tự xuống dòng."
    },
    "docstring_bertscore": {
      "es": "0.9781063635111915",
      "arb": "0.9511611591719038",
      "sw": "0.95771496859415",
      "tr": "0.9729592544474345",
      "vi": "0.9541223408923719"
    }
  },
  {
    "task_id": "PHP/47",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Counts the number of students enrolled in both courses A and B.\n * Given two arrays representing the student IDs of those who have enrolled in courses A and B,\n * this function calculates the total number of students who have enrolled in both courses.\n * \n * The function accepts two parameters:\n * - $courseA (array): An array of integers representing the IDs of students enrolled in course A.\n * - $courseB (array): An array of integers representing the IDs of students enrolled in course B.\n * \n * The function returns an integer representing the number of students enrolled in both courses.\n * \n * Example:\n * If course A has students with IDs [1, 2, 3, 4, 5] and course B has students with IDs [1, 3, 4, 5, 6],\n * the function should return 4 because students with IDs 1, 3, 4, and 5 are enrolled in both courses.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int ",
      "es": "<?php\n\n\n/**\n * Cuenta el número de estudiantes inscritos en ambos cursos A y B.\n * Dadas dos matrices que representan los IDs de estudiantes que se han inscrito en los cursos A y B,\n * esta función calcula el número total de estudiantes que se han inscrito en ambos cursos.\n * \n * La función acepta dos parámetros:\n * - $courseA (array): Una matriz de enteros que representa los IDs de los estudiantes inscritos en el curso A.\n * - $courseB (array): Una matriz de enteros que representa los IDs de los estudiantes inscritos en el curso B.\n * \n * La función devuelve un entero que representa el número de estudiantes inscritos en ambos cursos.\n * \n * Ejemplo:\n * Si el curso A tiene estudiantes con IDs [1, 2, 3, 4, 5] y el curso B tiene estudiantes con IDs [1, 3, 4, 5, 6],\n * la función debería devolver 4 porque los estudiantes con IDs 1, 3, 4 y 5 están inscritos en ambos cursos.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int ",
      "arb": "<?php\n\n\n/**\n * يحسب عدد الطلاب المسجلين في كلا الدورتين A و B.\n * بالنظر إلى مصفوفتين تمثلان معرفات الطلاب الذين سجلوا في الدورتين A و B،\n * تقوم هذه الدالة بحساب العدد الإجمالي للطلاب الذين سجلوا في كلا الدورتين.\n * \n * تقبل الدالة معاملين:\n * - $courseA (array): مصفوفة من الأعداد الصحيحة تمثل معرفات الطلاب المسجلين في الدورة A.\n * - $courseB (array): مصفوفة من الأعداد الصحيحة تمثل معرفات الطلاب المسجلين في الدورة B.\n * \n * تعيد الدالة عددًا صحيحًا يمثل عدد الطلاب المسجلين في كلا الدورتين.\n * \n * مثال:\n * إذا كان لدى الدورة A طلاب بمعرفات [1, 2, 3, 4, 5] والدورة B لديها طلاب بمعرفات [1, 3, 4, 5, 6]،\n * يجب أن تعيد الدالة 4 لأن الطلاب بمعرفات 1، 3، 4، و 5 مسجلون في كلا الدورتين.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi ya wanafunzi waliojiandikisha katika kozi zote A na B.\n * Ukipewa safu mbili zinazoonyesha vitambulisho vya wanafunzi waliojiandikisha katika kozi A na B,\n * kazi hii inahesabu jumla ya wanafunzi waliojiandikisha katika kozi zote mbili.\n * \n * Kazi hii inakubali vigezo viwili:\n * - $courseA (array): Safu ya nambari zinazoonyesha vitambulisho vya wanafunzi waliojiandikisha katika kozi A.\n * - $courseB (array): Safu ya nambari zinazoonyesha vitambulisho vya wanafunzi waliojiandikisha katika kozi B.\n * \n * Kazi hii inarudisha nambari inayoonyesha idadi ya wanafunzi waliojiandikisha katika kozi zote mbili.\n * \n * Mfano:\n * Ikiwa kozi A ina wanafunzi wenye vitambulisho [1, 2, 3, 4, 5] na kozi B ina wanafunzi wenye vitambulisho [1, 3, 4, 5, 6],\n * kazi inapaswa kurudisha 4 kwa sababu wanafunzi wenye vitambulisho 1, 3, 4, na 5 wamejiandikisha katika kozi zote mbili.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int ",
      "tr": "<?php\n\n\n/**\n * Hem A hem de B derslerine kayıtlı olan öğrencilerin sayısını sayar.\n * A ve B derslerine kayıtlı olan öğrencilerin kimlik numaralarını temsil eden iki dizi verildiğinde,\n * bu fonksiyon her iki derse de kayıtlı olan toplam öğrenci sayısını hesaplar.\n * \n * Fonksiyon iki parametre kabul eder:\n * - $courseA (array): A dersine kayıtlı öğrencilerin kimlik numaralarını temsil eden bir tamsayı dizisi.\n * - $courseB (array): B dersine kayıtlı öğrencilerin kimlik numaralarını temsil eden bir tamsayı dizisi.\n * \n * Fonksiyon, her iki derse de kayıtlı olan öğrencilerin sayısını temsil eden bir tamsayı döndürür.\n * \n * Örnek:\n * A dersinde kimlik numaraları [1, 2, 3, 4, 5] olan öğrenciler ve B dersinde kimlik numaraları [1, 3, 4, 5, 6] olan öğrenciler varsa,\n * fonksiyon 4 döndürmelidir çünkü kimlik numaraları 1, 3, 4 ve 5 olan öğrenciler her iki derse de kayıtlıdır.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int ",
      "vi": "<?php\n\n\n/**\n * Đếm số lượng sinh viên đăng ký cả hai khóa học A và B.\n * Cho hai mảng đại diện cho ID sinh viên đã đăng ký các khóa học A và B,\n * hàm này tính tổng số sinh viên đã đăng ký cả hai khóa học.\n * \n * Hàm chấp nhận hai tham số:\n * - $courseA (array): Một mảng số nguyên đại diện cho ID của sinh viên đăng ký khóa học A.\n * - $courseB (array): Một mảng số nguyên đại diện cho ID của sinh viên đăng ký khóa học B.\n * \n * Hàm trả về một số nguyên đại diện cho số lượng sinh viên đăng ký cả hai khóa học.\n * \n * Ví dụ:\n * Nếu khóa học A có sinh viên với ID [1, 2, 3, 4, 5] và khóa học B có sinh viên với ID [1, 3, 4, 5, 6],\n * hàm sẽ trả về 4 vì sinh viên với ID 1, 3, 4 và 5 đã đăng ký cả hai khóa học.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int "
    },
    "prompt_bertscore": {
      "es": "0.9945748084027941",
      "arb": "0.9767246905807129",
      "sw": "0.9682527075688128",
      "tr": "0.9580147018391315",
      "vi": "0.9661803968034758"
    },
    "canonical_solution": "{\n    // Find the intersection of both arrays to get common student IDs\n    $commonStudents = array_intersect($courseA, $courseB);\n    // Count and return the number of common student IDs\n    return count($commonStudents);\n}",
    "instruction": {
      "en": "Write a PHP function `function countCommonStudents(array $courseA, array $courseB): int` to solve the following problem:\nCounts the number of students enrolled in both courses A and B.\n  Given two arrays representing the student IDs of those who have enrolled in courses A and B,\n  this function calculates the total number of students who have enrolled in both courses.\n  \n  The function accepts two parameters:\n  - $courseA (array): An array of integers representing the IDs of students enrolled in course A.\n  - $courseB (array): An array of integers representing the IDs of students enrolled in course B.\n  \n  The function returns an integer representing the number of students enrolled in both courses.\n  \n  Example:\n  If course A has students with IDs [1, 2, 3, 4, 5] and course B has students with IDs [1, 3, 4, 5, 6],\n  the function should return 4 because students with IDs 1, 3, 4, and 5 are enrolled in both courses.",
      "es": "Escribe una función PHP `function countCommonStudents(array $courseA, array $courseB): int` para resolver el siguiente problema:\nCuenta el número de estudiantes inscritos en ambos cursos A y B.\n  Dado dos arreglos que representan los IDs de estudiantes que se han inscrito en los cursos A y B,\n  esta función calcula el número total de estudiantes que se han inscrito en ambos cursos.\n  \n  La función acepta dos parámetros:\n  - $courseA (array): Un arreglo de enteros que representa los IDs de los estudiantes inscritos en el curso A.\n  - $courseB (array): Un arreglo de enteros que representa los IDs de los estudiantes inscritos en el curso B.\n  \n  La función devuelve un entero que representa el número de estudiantes inscritos en ambos cursos.\n  \n  Ejemplo:\n  Si el curso A tiene estudiantes con IDs [1, 2, 3, 4, 5] y el curso B tiene estudiantes con IDs [1, 3, 4, 5, 6],\n  la función debería devolver 4 porque los estudiantes con IDs 1, 3, 4 y 5 están inscritos en ambos cursos.",
      "arb": "اكتب دالة PHP `function countCommonStudents(array $courseA, array $courseB): int` لحل المشكلة التالية:\nتحسب عدد الطلاب المسجلين في كلا الدورتين A و B.\n  بالنظر إلى مصفوفتين تمثلان معرفات الطلاب الذين سجلوا في الدورتين A و B،\n  تقوم هذه الدالة بحساب العدد الإجمالي للطلاب الذين سجلوا في كلا الدورتين.\n  \n  تقبل الدالة معاملين:\n  - $courseA (array): مصفوفة من الأعداد الصحيحة تمثل معرفات الطلاب المسجلين في الدورة A.\n  - $courseB (array): مصفوفة من الأعداد الصحيحة تمثل معرفات الطلاب المسجلين في الدورة B.\n  \n  تعيد الدالة عددًا صحيحًا يمثل عدد الطلاب المسجلين في كلا الدورتين.\n  \n  مثال:\n  إذا كانت الدورة A تحتوي على طلاب بمعرفات [1, 2, 3, 4, 5] والدورة B تحتوي على طلاب بمعرفات [1, 3, 4, 5, 6]،\n  يجب أن تعيد الدالة 4 لأن الطلاب بمعرفات 1، 3، 4، و5 مسجلون في كلا الدورتين.",
      "sw": "Andika kazi ya PHP `function countCommonStudents(array $courseA, array $courseB): int` kutatua tatizo lifuatalo:\nInahesabu idadi ya wanafunzi waliojiandikisha katika kozi zote A na B.\n  Ukipewa safu mbili zinazowakilisha nambari za kitambulisho za wanafunzi waliojiandikisha katika kozi A na B,\n  kazi hii inahesabu jumla ya wanafunzi waliojiandikisha katika kozi zote mbili.\n  \n  Kazi inakubali vigezo viwili:\n  - $courseA (array): Safu ya nambari za kitambulisho zinazowakilisha wanafunzi waliojiandikisha katika kozi A.\n  - $courseB (array): Safu ya nambari za kitambulisho zinazowakilisha wanafunzi waliojiandikisha katika kozi B.\n  \n  Kazi inarejesha nambari inayowakilisha idadi ya wanafunzi waliojiandikisha katika kozi zote mbili.\n  \n  Mfano:\n  Ikiwa kozi A ina wanafunzi wenye nambari za kitambulisho [1, 2, 3, 4, 5] na kozi B ina wanafunzi wenye nambari za kitambulisho [1, 3, 4, 5, 6],\n  kazi inapaswa kurudisha 4 kwa sababu wanafunzi wenye nambari za kitambulisho 1, 3, 4, na 5 wamejiandikisha katika kozi zote mbili.",
      "tr": "Bir PHP fonksiyonu `function countCommonStudents(array $courseA, array $courseB): int` yazın, aşağıdaki problemi çözmek için:\nHer iki kursa da A ve B kayıtlı olan öğrencilerin sayısını sayar.\n  Kurs A ve B'ye kayıtlı olan öğrenci kimliklerini temsil eden iki dizi verildiğinde,\n  bu fonksiyon her iki kursa da kayıtlı olan toplam öğrenci sayısını hesaplar.\n  \n  Fonksiyon iki parametre alır:\n  - $courseA (array): Kurs A'ya kayıtlı öğrencilerin kimliklerini temsil eden bir tamsayı dizisi.\n  - $courseB (array): Kurs B'ye kayıtlı öğrencilerin kimliklerini temsil eden bir tamsayı dizisi.\n  \n  Fonksiyon, her iki kursa da kayıtlı olan öğrencilerin sayısını temsil eden bir tamsayı döndürür.\n  \n  Örnek:\n  Eğer kurs A'da [1, 2, 3, 4, 5] kimlikli öğrenciler ve kurs B'de [1, 3, 4, 5, 6] kimlikli öğrenciler varsa,\n  fonksiyon 4 döndürmelidir çünkü 1, 3, 4 ve 5 kimlikli öğrenciler her iki kursa da kayıtlıdır.",
      "vi": "Viết một hàm PHP `function countCommonStudents(array $courseA, array $courseB): int` để giải quyết vấn đề sau:\nĐếm số lượng sinh viên đăng ký cả hai khóa học A và B.\n  Cho hai mảng đại diện cho ID sinh viên đã đăng ký các khóa học A và B,\n  hàm này tính tổng số lượng sinh viên đã đăng ký cả hai khóa học.\n  \n  Hàm chấp nhận hai tham số:\n  - $courseA (array): Một mảng các số nguyên đại diện cho ID của sinh viên đã đăng ký khóa học A.\n  - $courseB (array): Một mảng các số nguyên đại diện cho ID của sinh viên đã đăng ký khóa học B.\n  \n  Hàm trả về một số nguyên đại diện cho số lượng sinh viên đã đăng ký cả hai khóa học.\n  \n  Ví dụ:\n  Nếu khóa học A có sinh viên với ID [1, 2, 3, 4, 5] và khóa học B có sinh viên với ID [1, 3, 4, 5, 6],\n  hàm nên trả về 4 vì sinh viên với ID 1, 3, 4 và 5 đã đăng ký cả hai khóa học."
    },
    "instruction_bertscore": {
      "es": "0.9777976918990633",
      "arb": "0.9733660494677939",
      "sw": "0.9529323462795919",
      "tr": "0.9612668770678158",
      "vi": "0.969307434892108"
    },
    "level": "easy",
    "test": "function main(){\n    assert(countCommonStudents([1, 2, 3, 4, 5], [1, 3, 4, 5, 6]) === 4); // Expected: 4\n    assert(countCommonStudents([2, 4, 6, 8], [1, 3, 5, 7]) === 0); // Expected: 0, no common students\n    assert(countCommonStudents([1, 3, 5, 7, 9], [2, 3, 5, 7]) === 3); // Expected: 3, students with IDs 3, 5, and 7 are common\n    \n}\n\n\nmain();\n?>",
    "entry_point": "countCommonStudents",
    "signature": "function countCommonStudents(array $courseA, array $courseB): int",
    "docstring": {
      "en": "Counts the number of students enrolled in both courses A and B.\n  Given two arrays representing the student IDs of those who have enrolled in courses A and B,\n  this function calculates the total number of students who have enrolled in both courses.\n  \n  The function accepts two parameters:\n  - $courseA (array): An array of integers representing the IDs of students enrolled in course A.\n  - $courseB (array): An array of integers representing the IDs of students enrolled in course B.\n  \n  The function returns an integer representing the number of students enrolled in both courses.\n  \n  Example:\n  If course A has students with IDs [1, 2, 3, 4, 5] and course B has students with IDs [1, 3, 4, 5, 6],\n  the function should return 4 because students with IDs 1, 3, 4, and 5 are enrolled in both courses.",
      "es": "Cuenta el número de estudiantes inscritos en ambos cursos A y B.\n  Dadas dos matrices que representan los ID de estudiantes que se han inscrito en los cursos A y B,\n  esta función calcula el número total de estudiantes que se han inscrito en ambos cursos.\n  \n  La función acepta dos parámetros:\n  - $courseA (array): Una matriz de enteros que representa los ID de estudiantes inscritos en el curso A.\n  - $courseB (array): Una matriz de enteros que representa los ID de estudiantes inscritos en el curso B.\n  \n  La función devuelve un entero que representa el número de estudiantes inscritos en ambos cursos.\n  \n  Ejemplo:\n  Si el curso A tiene estudiantes con ID [1, 2, 3, 4, 5] y el curso B tiene estudiantes con ID [1, 3, 4, 5, 6],\n  la función debería devolver 4 porque los estudiantes con ID 1, 3, 4 y 5 están inscritos en ambos cursos.",
      "arb": "يحسب عدد الطلاب المسجلين في كلا الدورتين A و B.\n  بالنظر إلى مصفوفتين تمثلان معرفات الطلاب الذين سجلوا في الدورتين A و B،\n  تقوم هذه الدالة بحساب العدد الإجمالي للطلاب الذين سجلوا في كلا الدورتين.\n  \n  تقبل الدالة معلمتين:\n  - $courseA (array): مصفوفة من الأعداد الصحيحة تمثل معرفات الطلاب المسجلين في الدورة A.\n  - $courseB (array): مصفوفة من الأعداد الصحيحة تمثل معرفات الطلاب المسجلين في الدورة B.\n  \n  تعيد الدالة عددًا صحيحًا يمثل عدد الطلاب المسجلين في كلا الدورتين.\n  \n  مثال:\n  إذا كانت الدورة A تحتوي على طلاب بمعرفات [1, 2, 3, 4, 5] والدورة B تحتوي على طلاب بمعرفات [1, 3, 4, 5, 6]،\n  يجب أن تعيد الدالة 4 لأن الطلاب بمعرفات 1، 3، 4، و 5 مسجلون في كلا الدورتين.",
      "sw": "Hesabu idadi ya wanafunzi waliojiandikisha katika kozi zote mbili A na B.  \n  Ukipewa safu mbili zinazowakilisha vitambulisho vya wanafunzi waliojiandikisha katika kozi A na B,  \n  kazi hii inahesabu jumla ya wanafunzi waliojiandikisha katika kozi zote mbili.\n  \n  Kazi inakubali vigezo viwili:  \n  - $courseA (array): Safu ya namba za mzima zinazowakilisha vitambulisho vya wanafunzi waliojiandikisha katika kozi A.  \n  - $courseB (array): Safu ya namba za mzima zinazowakilisha vitambulisho vya wanafunzi waliojiandikisha katika kozi B.\n  \n  Kazi inarudisha namba ya mzima inayowakilisha idadi ya wanafunzi waliojiandikisha katika kozi zote mbili.\n  \n  Mfano:  \n  Ikiwa kozi A ina wanafunzi wenye vitambulisho [1, 2, 3, 4, 5] na kozi B ina wanafunzi wenye vitambulisho [1, 3, 4, 5, 6],  \n  kazi inapaswa kurudisha 4 kwa sababu wanafunzi wenye vitambulisho 1, 3, 4, na 5 wamejiandikisha katika kozi zote mbili.",
      "tr": "Her iki kursa da kayıtlı olan öğrencilerin sayısını sayar.\n  Kurs A ve B'ye kayıtlı olan öğrencilerin kimlik numaralarını temsil eden iki dizi verildiğinde,\n  bu fonksiyon her iki kursa da kayıtlı olan toplam öğrenci sayısını hesaplar.\n  \n  Fonksiyon iki parametre alır:\n  - $courseA (dizi): Kurs A'ya kayıtlı öğrencilerin kimlik numaralarını temsil eden bir tamsayı dizisi.\n  - $courseB (dizi): Kurs B'ye kayıtlı öğrencilerin kimlik numaralarını temsil eden bir tamsayı dizisi.\n  \n  Fonksiyon, her iki kursa da kayıtlı olan öğrenci sayısını temsil eden bir tamsayı döndürür.\n  \n  Örnek:\n  Eğer kurs A'da [1, 2, 3, 4, 5] kimlik numaralı öğrenciler ve kurs B'de [1, 3, 4, 5, 6] kimlik numaralı öğrenciler varsa,\n  fonksiyon 4 döndürmelidir çünkü 1, 3, 4 ve 5 kimlik numaralı öğrenciler her iki kursa da kayıtlıdır.",
      "vi": "Đếm số lượng sinh viên đăng ký cả hai khóa học A và B.  \nCho hai mảng đại diện cho ID sinh viên của những người đã đăng ký các khóa học A và B,  \nhàm này tính tổng số sinh viên đã đăng ký cả hai khóa học.\n\nHàm chấp nhận hai tham số:  \n- $courseA (array): Một mảng các số nguyên đại diện cho ID của sinh viên đã đăng ký khóa học A.  \n- $courseB (array): Một mảng các số nguyên đại diện cho ID của sinh viên đã đăng ký khóa học B.\n\nHàm trả về một số nguyên đại diện cho số lượng sinh viên đăng ký cả hai khóa học.\n\nVí dụ:  \nNếu khóa học A có sinh viên với ID [1, 2, 3, 4, 5] và khóa học B có sinh viên với ID [1, 3, 4, 5, 6],  \nhàm nên trả về 4 vì sinh viên với ID 1, 3, 4 và 5 đã đăng ký cả hai khóa học."
    },
    "docstring_bertscore": {
      "es": "0.9740982010522885",
      "arb": "0.9698957780807334",
      "sw": "0.9719039312329961",
      "tr": "0.9604949994071142",
      "vi": "0.9858271264220176"
    }
  },
  {
    "task_id": "PHP/48",
    "prompt": {
      "en": "<?php\n\n\n\n/**\n * Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n * Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n * Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n * \n * Arguments:\n * - $delivered: The number of successfully delivered packages (0 <= $delivered <= 100).\n * - $failed: The number of failed deliveries (0 <= $failed <= 100).\n * \n * Returns:\n * - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n * \n * Examples:\n * - calculateDroidEarnings(5, 2) returns 730.\n * - calculateDroidEarnings(0, 10) returns -100.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int ",
      "es": "<?php\n\n\n\n/**\n * Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas.\n * Deliv-e-droid gana 50 unidades de dinero por cada entrega exitosa y pierde 10 unidades por cada entrega fallida.\n * Además, si el número de entregas exitosas es mayor que el número de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n * \n * Argumentos:\n * - $delivered: El número de paquetes entregados exitosamente (0 <= $delivered <= 100).\n * - $failed: El número de entregas fallidas (0 <= $failed <= 100).\n * \n * Retorna:\n * - Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n * \n * Ejemplos:\n * - calculateDroidEarnings(5, 2) devuelve 730.\n * - calculateDroidEarnings(0, 10) devuelve -100.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int ",
      "arb": "<?php\n\n\n\n/**\n * يحسب إجمالي أرباح Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة.\n * يكسب Deliv-e-droid 50 وحدة من المال لكل عملية تسليم ناجحة ويفقد 10 وحدات لكل عملية تسليم فاشلة.\n * بالإضافة إلى ذلك، إذا كان عدد عمليات التسليم الناجحة أكبر من عدد الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n * \n * الوسائط:\n * - $delivered: عدد الطرود التي تم تسليمها بنجاح (0 <= $delivered <= 100).\n * - $failed: عدد عمليات التسليم الفاشلة (0 <= $failed <= 100).\n * \n * يعيد:\n * - إجمالي أرباح Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق المكاسب.\n * \n * أمثلة:\n * - calculateDroidEarnings(5, 2) يعيد 730.\n * - calculateDroidEarnings(0, 10) يعيد -100.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int ",
      "sw": "<?php\n\n\n\n/**\n * Inahesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya uwasilishaji uliofanikiwa na uliyoshindwa.\n * Deliv-e-droid hupata vitengo 50 vya pesa kwa kila uwasilishaji uliofanikiwa na hupoteza vitengo 10 kwa kila uwasilishaji ulioshindwa.\n * Zaidi ya hayo, ikiwa idadi ya uwasilishaji uliofanikiwa ni kubwa kuliko ile ya uliyoshindwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n * \n * Hoja:\n * - $delivered: Idadi ya vifurushi vilivyowasilishwa kwa mafanikio (0 <= $delivered <= 100).\n * - $failed: Idadi ya uwasilishaji ulioshindwa (0 <= $failed <= 100).\n * \n * Inarudisha:\n * - Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara inazidi faida.\n * \n * Mifano:\n * - calculateDroidEarnings(5, 2) inarudisha 730.\n * - calculateDroidEarnings(0, 10) inarudisha -100.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int ",
      "tr": "<?php\n\n\n\n/**\n * Başarıyla teslim edilen ve başarısız teslimatlar sayısına göre Deliv-e-droid'un toplam kazancını hesaplar.\n * Deliv-e-droid, her başarılı teslimat için 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder.\n * Ayrıca, başarılı teslimatların sayısı başarısız olanlardan fazlaysa, Deliv-e-droid 500 birim bonus alır.\n * \n * Argümanlar:\n * - $delivered: Başarıyla teslim edilen paketlerin sayısı (0 <= $delivered <= 100).\n * - $failed: Başarısız teslimatların sayısı (0 <= $failed <= 100).\n * \n * Döndürür:\n * - Deliv-e-droid'un toplam kazancı, kayıplar kazançlardan fazla olursa negatif olabilir.\n * \n * Örnekler:\n * - calculateDroidEarnings(5, 2) 730 döndürür.\n * - calculateDroidEarnings(0, 10) -100 döndürür.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int ",
      "vi": "<?php\n\n\n\n/**\n * Tính tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại.\n * Deliv-e-droid kiếm được 50 đơn vị tiền cho mỗi lần giao hàng thành công và mất 10 đơn vị cho mỗi lần giao hàng thất bại.\n * Ngoài ra, nếu số lượng giao hàng thành công lớn hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n * \n * Tham số:\n * - $delivered: Số lượng gói hàng được giao thành công (0 <= $delivered <= 100).\n * - $failed: Số lượng giao hàng thất bại (0 <= $failed <= 100).\n * \n * Trả về:\n * - Tổng thu nhập của Deliv-e-droid, có thể âm nếu tổn thất lớn hơn lợi nhuận.\n * \n * Ví dụ:\n * - calculateDroidEarnings(5, 2) trả về 730.\n * - calculateDroidEarnings(0, 10) trả về -100.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int "
    },
    "prompt_bertscore": {
      "es": "0.9890832742583225",
      "arb": "0.9736818717736394",
      "sw": "0.9749370171513988",
      "tr": "0.9812622030050738",
      "vi": "0.9723881921019591"
    },
    "canonical_solution": " {\n    $earnings = $delivered * 50;\n    $losses = $failed * 10;\n    if ($delivered > $failed) {\n        $earnings += 500; // Bonus\n    }\n    return $earnings - $losses;\n}\n",
    "instruction": {
      "en": "Write a PHP function `function calculateDroidEarnings(int $delivered, int $failed): int` to solve the following problem:\nCalculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n  \n  Arguments:\n  - $delivered: The number of successfully delivered packages (0 <= $delivered <= 100).\n  - $failed: The number of failed deliveries (0 <= $failed <= 100).\n  \n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n  \n  Examples:\n  - calculateDroidEarnings(5, 2) returns 730.\n  - calculateDroidEarnings(0, 10) returns -100.",
      "es": "Escribe una función PHP `function calculateDroidEarnings(int $delivered, int $failed): int` para resolver el siguiente problema:\nCalcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas.\n  Deliv-e-droid gana 50 unidades de dinero por cada entrega exitosa y pierde 10 unidades por cada entrega fallida.\n  Además, si el número de entregas exitosas es mayor que el número de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n  \n  Argumentos:\n  - $delivered: El número de paquetes entregados exitosamente (0 <= $delivered <= 100).\n  - $failed: El número de entregas fallidas (0 <= $failed <= 100).\n  \n  Retorna:\n  - Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n  \n  Ejemplos:\n  - calculateDroidEarnings(5, 2) devuelve 730.\n  - calculateDroidEarnings(0, 10) devuelve -100.",
      "arb": "اكتب دالة PHP `function calculateDroidEarnings(int $delivered, int $failed): int` لحل المشكلة التالية:\nتحسب إجمالي أرباح Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة.\nDeliv-e-droid يكسب 50 وحدة من المال لكل عملية تسليم ناجحة ويفقد 10 وحدات لكل عملية تسليم فاشلة.\nبالإضافة إلى ذلك، إذا كان عدد عمليات التسليم الناجحة أكبر من عدد الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n\nالمعطيات:\n- $delivered: عدد الطرود التي تم تسليمها بنجاح (0 <= $delivered <= 100).\n- $failed: عدد عمليات التسليم الفاشلة (0 <= $failed <= 100).\n\nالمخرجات:\n- إجمالي أرباح Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق المكاسب.\n\nأمثلة:\n- calculateDroidEarnings(5, 2) يعيد 730.\n- calculateDroidEarnings(0, 10) يعيد -100.",
      "sw": "Andika kazi ya PHP `function calculateDroidEarnings(int $delivered, int $failed): int` kutatua tatizo lifuatalo:\nInakokotoa mapato ya jumla ya Deliv-e-droid kulingana na idadi ya mafanikio ya kufikishwa na kufeli kwa kufikishwa.\n  Deliv-e-droid hupata vitengo 50 vya pesa kwa kila kufikishwa kwa mafanikio na hupoteza vitengo 10 kwa kila kufikishwa kwa kufeli.\n  Zaidi ya hayo, ikiwa idadi ya kufikishwa kwa mafanikio ni kubwa kuliko ya kufeli, Deliv-e-droid hupokea bonasi ya vitengo 500.\n  \n  Hoja:\n  - $delivered: Idadi ya vifurushi vilivyofikishwa kwa mafanikio (0 <= $delivered <= 100).\n  - $failed: Idadi ya kufikishwa kwa kufeli (0 <= $failed <= 100).\n  \n  Inarudisha:\n  - Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara ni kubwa kuliko faida.\n  \n  Mifano:\n  - calculateDroidEarnings(5, 2) inarudisha 730.\n  - calculateDroidEarnings(0, 10) inarudisha -100.",
      "tr": "Bir PHP fonksiyonu `function calculateDroidEarnings(int $delivered, int $failed): int` yazarak aşağıdaki problemi çözün:\nDeliv-e-droid'un başarılı teslimatlar ve başarısız teslimatlar sayısına göre toplam kazancını hesaplar.\n  Deliv-e-droid her başarılı teslimat için 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder.\n  Ayrıca, başarılı teslimat sayısı başarısız olanlardan fazlaysa, Deliv-e-droid 500 birim bonus alır.\n  \n  Argümanlar:\n  - $delivered: Başarıyla teslim edilen paketlerin sayısı (0 <= $delivered <= 100).\n  - $failed: Başarısız teslimatların sayısı (0 <= $failed <= 100).\n  \n  Döndürür:\n  - Deliv-e-droid'un toplam kazancı, kayıplar kazançlardan fazla olursa negatif olabilir.\n  \n  Örnekler:\n  - calculateDroidEarnings(5, 2) 730 döndürür.\n  - calculateDroidEarnings(0, 10) -100 döndürür.",
      "vi": "Viết một hàm PHP `function calculateDroidEarnings(int $delivered, int $failed): int` để giải quyết vấn đề sau:\nTính toán tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại.\n  Deliv-e-droid kiếm được 50 đơn vị tiền cho mỗi lần giao hàng thành công và mất 10 đơn vị cho mỗi lần giao hàng thất bại.\n  Ngoài ra, nếu số lượng giao hàng thành công lớn hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n  \n  Tham số:\n  - $delivered: Số lượng gói hàng được giao thành công (0 <= $delivered <= 100).\n  - $failed: Số lượng giao hàng thất bại (0 <= $failed <= 100).\n  \n  Trả về:\n  - Tổng thu nhập của Deliv-e-droid, có thể là số âm nếu tổn thất lớn hơn lợi nhuận.\n  \n  Ví dụ:\n  - calculateDroidEarnings(5, 2) trả về 730.\n  - calculateDroidEarnings(0, 10) trả về -100."
    },
    "instruction_bertscore": {
      "es": "0.9922057438481909",
      "arb": "0.9681619334846798",
      "sw": "0.9788913507770414",
      "tr": "0.9844555836409717",
      "vi": "0.9799951398044523"
    },
    "level": "easy",
    "test": "function main(){\n    assert(calculateDroidEarnings(5, 2) === 730, 'Test case 1 failed');\n    assert(calculateDroidEarnings(0, 10) === -100, 'Test case 2 failed');\n    assert(calculateDroidEarnings(10, 0) === 1000, 'Test case 3 failed');\n    assert(calculateDroidEarnings(3, 3) === 120, 'Test case 4 failed');\n    assert(calculateDroidEarnings(0, 0) === 0, 'Test case 5 failed');\n    \n}\n\n\nmain();\n?>",
    "entry_point": "calculateDroidEarnings",
    "signature": "function calculateDroidEarnings(int $delivered, int $failed): int",
    "docstring": {
      "en": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n  \n  Arguments:\n  - $delivered: The number of successfully delivered packages (0 <= $delivered <= 100).\n  - $failed: The number of failed deliveries (0 <= $failed <= 100).\n  \n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n  \n  Examples:\n  - calculateDroidEarnings(5, 2) returns 730.\n  - calculateDroidEarnings(0, 10) returns -100.",
      "es": "Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas.\n  Deliv-e-droid gana 50 unidades de dinero por cada entrega exitosa y pierde 10 unidades por cada entrega fallida.\n  Además, si el número de entregas exitosas es mayor que el de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n  \n  Argumentos:\n  - $delivered: El número de paquetes entregados exitosamente (0 <= $delivered <= 100).\n  - $failed: El número de entregas fallidas (0 <= $failed <= 100).\n  \n  Retorna:\n  - Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n  \n  Ejemplos:\n  - calculateDroidEarnings(5, 2) devuelve 730.\n  - calculateDroidEarnings(0, 10) devuelve -100.",
      "arb": "يحسب إجمالي أرباح Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة. يكسب Deliv-e-droid 50 وحدة من المال لكل عملية تسليم ناجحة ويفقد 10 وحدات لكل عملية تسليم فاشلة. بالإضافة إلى ذلك، إذا كان عدد عمليات التسليم الناجحة أكبر من عدد العمليات الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n\nالحجج:\n- $delivered: عدد الطرود التي تم تسليمها بنجاح (0 <= $delivered <= 100).\n- $failed: عدد عمليات التسليم الفاشلة (0 <= $failed <= 100).\n\nالقيم المعادة:\n- إجمالي أرباح Deliv-e-droid، والتي يمكن أن تكون سلبية إذا فاقت الخسائر المكاسب.\n\nأمثلة:\n- calculateDroidEarnings(5, 2) يعيد 730.\n- calculateDroidEarnings(0, 10) يعيد -100.",
      "sw": "Hesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya uwasilishaji uliofanikiwa na uliyoshindwa.\n  Deliv-e-droid hupata vitengo 50 vya pesa kwa kila uwasilishaji uliofanikiwa na hupoteza vitengo 10 kwa kila uwasilishaji ulioshindwa.\n  Zaidi ya hayo, ikiwa idadi ya uwasilishaji uliofanikiwa ni kubwa kuliko ile ya uliyoshindwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n  \n  Hoja:\n  - $delivered: Idadi ya vifurushi vilivyowasilishwa kwa mafanikio (0 <= $delivered <= 100).\n  - $failed: Idadi ya uwasilishaji ulioshindwa (0 <= $failed <= 100).\n  \n  Inarudisha:\n  - Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara ni kubwa kuliko faida.\n  \n  Mifano:\n  - calculateDroidEarnings(5, 2) inarudisha 730.\n  - calculateDroidEarnings(0, 10) inarudisha -100.",
      "tr": "Deliv-e-droid'un toplam kazancını, başarılı teslimatlar ve başarısız teslimatlar sayısına göre hesaplar.\n  Deliv-e-droid, her başarılı teslimat için 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder.\n  Ayrıca, başarılı teslimat sayısı başarısız olanlardan fazla ise, Deliv-e-droid 500 birim bonus alır.\n  \n  Argümanlar:\n  - $delivered: Başarıyla teslim edilen paketlerin sayısı (0 <= $delivered <= 100).\n  - $failed: Başarısız teslimatların sayısı (0 <= $failed <= 100).\n  \n  Döndürür:\n  - Deliv-e-droid'un toplam kazancı, kayıplar kazançları aştığında negatif olabilir.\n  \n  Örnekler:\n  - calculateDroidEarnings(5, 2) 730 döndürür.\n  - calculateDroidEarnings(0, 10) -100 döndürür.",
      "vi": "Tính tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại. Deliv-e-droid kiếm được 50 đơn vị tiền cho mỗi lần giao hàng thành công và mất 10 đơn vị cho mỗi lần giao hàng thất bại. Ngoài ra, nếu số lượng giao hàng thành công lớn hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n\nArguments:\n- $delivered: Số lượng gói hàng được giao thành công (0 <= $delivered <= 100).\n- $failed: Số lượng giao hàng thất bại (0 <= $failed <= 100).\n\nTrả về:\n- Tổng thu nhập của Deliv-e-droid, có thể là số âm nếu tổn thất vượt quá lợi nhuận.\n\nVí dụ:\n- calculateDroidEarnings(5, 2) trả về 730.\n- calculateDroidEarnings(0, 10) trả về -100."
    },
    "docstring_bertscore": {
      "es": "0.9837234320564772",
      "arb": "0.9854497286980514",
      "sw": "0.9762225529774566",
      "tr": "0.9782112403523779",
      "vi": "0.9759681074593509"
    }
  },
  {
    "task_id": "PHP/49",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Identifies the missing (broken) and duplicate IDs from a given set of ID groups.\n * Each ID group represents a collection of ticket IDs which are supposed to be consecutive but contain a mistake:\n * one ID is missing, and one ID is duplicated. This function calculates and returns the missing and duplicated IDs.\n *\n * Note: The missing ID will not be at the start or end of the overall ID range.\n *\n * Input: An array of arrays, where each sub-array contains integers representing ticket IDs.\n * Output: An array with two integers, the first being the missing (broken) ID and the second the duplicate ID.\n *\n * Example:\n * Input: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * Output: [7, 9] // 7 is missing, and 9 is duplicated.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array ",
      "es": "<?php\n\n\n/**\n * Identifica los IDs faltantes (rotos) y duplicados de un conjunto dado de grupos de IDs.\n * Cada grupo de IDs representa una colección de IDs de tickets que se supone son consecutivos pero contienen un error:\n * falta un ID y hay un ID duplicado. Esta función calcula y devuelve los IDs faltantes y duplicados.\n *\n * Nota: El ID faltante no estará al inicio o al final del rango total de IDs.\n *\n * Entrada: Un array de arrays, donde cada sub-array contiene enteros que representan IDs de tickets.\n * Salida: Un array con dos enteros, el primero es el ID faltante (roto) y el segundo el ID duplicado.\n *\n * Ejemplo:\n * Entrada: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * Salida: [7, 9] // 7 falta, y 9 está duplicado.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array ",
      "arb": "<?php\n\n\n/**\n * يحدد المعرفات المفقودة (المكسورة) والمكررة من مجموعة معينة من مجموعات المعرفات.\n * كل مجموعة معرفات تمثل مجموعة من معرفات التذاكر التي من المفترض أن تكون متتالية ولكن تحتوي على خطأ:\n * معرف واحد مفقود، ومعرف واحد مكرر. تقوم هذه الدالة بحساب وإرجاع المعرفات المفقودة والمكررة.\n *\n * ملاحظة: لن يكون المعرف المفقود في بداية أو نهاية نطاق المعرفات الكلي.\n *\n * المدخلات: مصفوفة من المصفوفات، حيث تحتوي كل مصفوفة فرعية على أعداد صحيحة تمثل معرفات التذاكر.\n * المخرجات: مصفوفة تحتوي على عددين صحيحين، الأول هو المعرف المفقود (المكسور) والثاني هو المعرف المكرر.\n *\n * مثال:\n * المدخلات: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * المخرجات: [7, 9] // 7 مفقود، و9 مكرر.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array ",
      "sw": "<?php\n\n\n/**\n * Inatambua vitambulisho vilivyopotea (vilivyovunjika) na vilivyodurufu kutoka kwenye seti iliyotolewa ya makundi ya vitambulisho.\n * Kila kundi la vitambulisho linaashiria mkusanyiko wa vitambulisho vya tiketi ambavyo vinapaswa kuwa mfululizo lakini vina kosa:\n * kitambulisho kimoja kimepotea, na kitambulisho kimoja kimejirudia. Kazi hii inahesabu na kurudisha vitambulisho vilivyopotea na vilivyodurufu.\n *\n * Kumbuka: Kitambulisho kilichopotea hakitakuwa mwanzoni au mwisho wa safu ya vitambulisho kwa ujumla.\n *\n * Ingizo: Safu ya safu, ambapo kila safu ndogo ina namba za mzima zinazowakilisha vitambulisho vya tiketi.\n * Tokeo: Safu yenye namba mbili, ya kwanza ikiwa ni kitambulisho kilichopotea (kilichovunjika) na ya pili ikiwa ni kitambulisho kilichodurufu.\n *\n * Mfano:\n * Ingizo: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * Tokeo: [7, 9] // 7 imepotea, na 9 imejirudia.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array ",
      "tr": "<?php\n\n\n/**\n * Belirtilen bir dizi ID grubundan eksik (bozuk) ve yinelenen ID'leri tanımlar.\n * Her ID grubu, ardışık olması gereken ancak bir hata içeren bilet ID'lerinin bir koleksiyonunu temsil eder:\n * bir ID eksik ve bir ID yinelenmiştir. Bu fonksiyon eksik ve yinelenen ID'leri hesaplar ve döndürür.\n *\n * Not: Eksik ID, genel ID aralığının başlangıcında veya sonunda olmayacaktır.\n *\n * Girdi: Her alt dizi, bilet ID'lerini temsil eden tamsayılar içeren dizilerin bir dizisi.\n * Çıktı: İlk elemanı eksik (bozuk) ID ve ikinci elemanı yinelenen ID olan iki tamsayı içeren bir dizi.\n *\n * Örnek:\n * Girdi: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * Çıktı: [7, 9] // 7 eksik ve 9 yinelenmiştir.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array ",
      "vi": "<?php\n\n\n/**\n * Xác định các ID bị thiếu (bị hỏng) và trùng lặp từ một tập hợp các nhóm ID đã cho.\n * Mỗi nhóm ID đại diện cho một tập hợp các ID vé mà đáng lẽ phải liên tiếp nhưng chứa một lỗi:\n * một ID bị thiếu và một ID bị trùng lặp. Hàm này tính toán và trả về các ID bị thiếu và bị trùng lặp.\n *\n * Lưu ý: ID bị thiếu sẽ không nằm ở đầu hoặc cuối của phạm vi ID tổng thể.\n *\n * Đầu vào: Một mảng các mảng, trong đó mỗi mảng con chứa các số nguyên đại diện cho các ID vé.\n * Đầu ra: Một mảng với hai số nguyên, số đầu tiên là ID bị thiếu (bị hỏng) và số thứ hai là ID bị trùng lặp.\n *\n * Ví dụ:\n * Đầu vào: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * Đầu ra: [7, 9] // 7 bị thiếu, và 9 bị trùng lặp.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array "
    },
    "prompt_bertscore": {
      "es": "0.97702740328141",
      "arb": "0.9663152668321985",
      "sw": "0.9760126006647027",
      "tr": "0.9560677268442276",
      "vi": "0.9616581789184545"
    },
    "canonical_solution": "{\n    // Flatten the array of ID groups into a single array\n    $allIds = array_merge(...$idGroups);\n    \n    // Sort the IDs to make it easier to find duplicates and missing IDs\n    sort($allIds);\n    \n    $missingID = null;\n    $duplicateID = null;\n    \n    // Iterate over the sorted IDs to find the missing and duplicate IDs\n    for ($i = 0; $i < count($allIds) - 1; $i++) {\n        // Check if the next ID is the same as the current ID (duplicate)\n        if ($allIds[$i] == $allIds[$i + 1]) {\n            $duplicateID = $allIds[$i];\n        }\n        // Check if the next ID is not the immediate successor (missing)\n        elseif ($allIds[$i] + 1 != $allIds[$i + 1]) {\n            $missingID = $allIds[$i] + 1;\n        }\n    }\n    \n    // Return both the missing and the duplicate IDs\n    return [$missingID, $duplicateID];\n}",
    "instruction": {
      "en": "Write a PHP function `function findMissingAndDuplicateIDs(array $idGroups): array` to solve the following problem:\nIdentifies the missing (broken) and duplicate IDs from a given set of ID groups.\n  Each ID group represents a collection of ticket IDs which are supposed to be consecutive but contain a mistake:\n  one ID is missing, and one ID is duplicated. This function calculates and returns the missing and duplicated IDs.\n \n  Note: The missing ID will not be at the start or end of the overall ID range.\n \n  Input: An array of arrays, where each sub-array contains integers representing ticket IDs.\n  Output: An array with two integers, the first being the missing (broken) ID and the second the duplicate ID.\n \n  Example:\n  Input: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  Output: [7, 9] // 7 is missing, and 9 is duplicated.",
      "es": "Escriba una función PHP `function findMissingAndDuplicateIDs(array $idGroups): array` para resolver el siguiente problema:\nIdentifica los IDs faltantes (rotos) y duplicados de un conjunto dado de grupos de IDs.\n  Cada grupo de IDs representa una colección de IDs de boletos que se supone que son consecutivos pero contienen un error:\n  falta un ID y un ID está duplicado. Esta función calcula y devuelve los IDs faltantes y duplicados.\n \n  Nota: El ID faltante no estará al inicio ni al final del rango total de IDs.\n \n  Entrada: Un arreglo de arreglos, donde cada sub-arreglo contiene enteros que representan IDs de boletos.\n  Salida: Un arreglo con dos enteros, el primero siendo el ID faltante (roto) y el segundo el ID duplicado.\n \n  Ejemplo:\n  Entrada: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  Salida: [7, 9] // 7 falta, y 9 está duplicado.",
      "arb": "اكتب دالة PHP `function findMissingAndDuplicateIDs(array $idGroups): array` لحل المشكلة التالية:\nتحديد المعرفات المفقودة (المعطلة) والمكررة من مجموعة معينة من مجموعات المعرفات.\n  تمثل كل مجموعة معرفات مجموعة من معرفات التذاكر التي من المفترض أن تكون متتالية ولكن تحتوي على خطأ:\n  معرف واحد مفقود، ومعرف واحد مكرر. تقوم هذه الدالة بحساب وإرجاع المعرفات المفقودة والمكررة.\n \n  ملاحظة: لن يكون المعرف المفقود في بداية أو نهاية نطاق المعرفات الكلي.\n \n  المدخل: مصفوفة من المصفوفات، حيث تحتوي كل مصفوفة فرعية على أعداد صحيحة تمثل معرفات التذاكر.\n  المخرج: مصفوفة تحتوي على عددين صحيحين، الأول هو المعرف المفقود (المعطل) والثاني هو المعرف المكرر.\n \n  مثال:\n  المدخل: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  المخرج: [7, 9] // 7 مفقود، و9 مكرر.",
      "sw": "Andika kazi ya PHP `function findMissingAndDuplicateIDs(array $idGroups): array` kutatua tatizo lifuatalo:\nInatambua vitambulisho vilivyopotea (vilivyovunjika) na vilivyodurufu kutoka kwenye seti iliyotolewa ya vikundi vya vitambulisho.\n  Kila kikundi cha vitambulisho kinawakilisha mkusanyiko wa vitambulisho vya tiketi ambavyo vinapaswa kuwa mfululizo lakini vina makosa:\n  kitambulisho kimoja kimepotea, na kitambulisho kimoja kimejirudia. Kazi hii inahesabu na kurudisha vitambulisho vilivyopotea na vilivyodurufu.\n \n  Kumbuka: Kitambulisho kilichopotea hakitakuwa mwanzoni au mwishoni mwa safu ya jumla ya vitambulisho.\n \n  Ingizo: Safu ya safu, ambapo kila safu ndogo ina namba za kipekee zinazoashiria vitambulisho vya tiketi.\n  Tokeo: Safu yenye namba mbili, ya kwanza ikiwa ni kitambulisho kilichopotea (kilichovunjika) na ya pili ikiwa ni kitambulisho kilichodurufu.\n \n  Mfano:\n  Ingizo: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  Tokeo: [7, 9] // 7 imepotea, na 9 imejirudia.",
      "tr": "Bir PHP fonksiyonu `function findMissingAndDuplicateIDs(array $idGroups): array` yazın. Aşağıdaki problemi çözmek için:\nVerilen bir ID grubu setinden eksik (bozuk) ve yinelenen ID'leri tanımlar.\n  Her ID grubu, ardışık olması gereken ancak bir hata içeren bilet ID'lerinin bir koleksiyonunu temsil eder:\n  bir ID eksik ve bir ID yinelenmiştir. Bu fonksiyon eksik ve yinelenen ID'leri hesaplar ve döndürür.\n \n  Not: Eksik ID, genel ID aralığının başında veya sonunda olmayacaktır.\n \n  Girdi: Her alt dizi, bilet ID'lerini temsil eden tamsayılar içeren dizilerin bir dizisi.\n  Çıktı: İlk elemanı eksik (bozuk) ID ve ikinci elemanı yinelenen ID olan iki tamsayıdan oluşan bir dizi.\n \n  Örnek:\n  Girdi: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  Çıktı: [7, 9] // 7 eksik ve 9 yinelenmiştir.",
      "vi": "Viết một hàm PHP `function findMissingAndDuplicateIDs(array $idGroups): array` để giải quyết vấn đề sau:\nXác định các ID bị thiếu (bị lỗi) và trùng lặp từ một tập hợp các nhóm ID được cho.\nMỗi nhóm ID đại diện cho một tập hợp các ID vé mà lẽ ra phải liên tiếp nhưng chứa một lỗi:\nmột ID bị thiếu và một ID bị trùng lặp. Hàm này tính toán và trả về các ID bị thiếu và trùng lặp.\n\nLưu ý: ID bị thiếu sẽ không nằm ở đầu hoặc cuối của phạm vi ID tổng thể.\n\nĐầu vào: Một mảng các mảng, trong đó mỗi mảng con chứa các số nguyên đại diện cho các ID vé.\nĐầu ra: Một mảng với hai số nguyên, số đầu tiên là ID bị thiếu (bị lỗi) và số thứ hai là ID bị trùng lặp.\n\nVí dụ:\nĐầu vào: [[5, 6, 8, 11, 9], [10, 12, 9]]\nĐầu ra: [7, 9] // 7 bị thiếu, và 9 bị trùng lặp."
    },
    "instruction_bertscore": {
      "es": "0.986073825355263",
      "arb": "0.9643035383330771",
      "sw": "0.9645490454840363",
      "tr": "0.9529154626972038",
      "vi": "0.9562967476735608"
    },
    "level": "hard",
    "test": "function main(){\n\n    // Test case based on the example provided\n    assert(findMissingAndDuplicateIDs([[5, 6, 8, 11, 9], [10, 12, 9]]) === [7, 9]);\n    \n    // Additional test cases\n    assert(findMissingAndDuplicateIDs([[1, 2, 4], [3, 5, 5, 7]]) === [6, 5]);\n    assert(findMissingAndDuplicateIDs([[10, 11, 12, 14, 17], [13, 15, 12]]) === [16, 12]);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "findMissingAndDuplicateIDs",
    "signature": "function findMissingAndDuplicateIDs(array $idGroups): array",
    "docstring": {
      "en": "Identifies the missing (broken) and duplicate IDs from a given set of ID groups.\n  Each ID group represents a collection of ticket IDs which are supposed to be consecutive but contain a mistake:\n  one ID is missing, and one ID is duplicated. This function calculates and returns the missing and duplicated IDs.\n \n  Note: The missing ID will not be at the start or end of the overall ID range.\n \n  Input: An array of arrays, where each sub-array contains integers representing ticket IDs.\n  Output: An array with two integers, the first being the missing (broken) ID and the second the duplicate ID.\n \n  Example:\n  Input: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  Output: [7, 9] // 7 is missing, and 9 is duplicated.",
      "es": "Identifica los IDs faltantes (rotos) y duplicados de un conjunto dado de grupos de IDs.  \n  Cada grupo de IDs representa una colección de IDs de tickets que se supone que son consecutivos pero contienen un error:  \n  falta un ID y un ID está duplicado. Esta función calcula y devuelve los IDs faltantes y duplicados.\n \n  Nota: El ID faltante no estará al inicio o al final del rango total de IDs.\n \n  Entrada: Un array de arrays, donde cada sub-array contiene enteros que representan IDs de tickets.  \n  Salida: Un array con dos enteros, el primero siendo el ID faltante (roto) y el segundo el ID duplicado.\n \n  Ejemplo:  \n  Entrada: [[5, 6, 8, 11, 9], [10, 12, 9]]  \n  Salida: [7, 9] // 7 falta y 9 está duplicado.",
      "arb": "يتعرف على المعرفات المفقودة (المكسورة) والمكررة من مجموعة معينة من مجموعات المعرفات.\n  تمثل كل مجموعة معرفات مجموعة من معرفات التذاكر التي من المفترض أن تكون متتالية ولكن تحتوي على خطأ:\n  معرف واحد مفقود ومعرف واحد مكرر. تقوم هذه الدالة بحساب وإرجاع المعرفات المفقودة والمكررة.\n\n  ملاحظة: لن يكون المعرف المفقود في بداية أو نهاية نطاق المعرفات الكلي.\n\n  المدخلات: مصفوفة من المصفوفات، حيث تحتوي كل مصفوفة فرعية على أعداد صحيحة تمثل معرفات التذاكر.\n  المخرجات: مصفوفة تحتوي على عددين صحيحين، الأول هو المعرف المفقود (المكسور) والثاني هو المعرف المكرر.\n\n  مثال:\n  المدخلات: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  المخرجات: [7, 9] // 7 مفقود، و9 مكرر.",
      "sw": "Inatambua vitambulisho vilivyokosekana (vilivyovunjika) na vilivyodurufu kutoka kwa seti iliyotolewa ya vikundi vya vitambulisho.\n  Kila kikundi cha vitambulisho kinawakilisha mkusanyiko wa vitambulisho vya tiketi ambavyo vinapaswa kuwa mfululizo lakini vina kosa:\n  kitambulisho kimoja kinakosekana, na kitambulisho kimoja kimerudiwa. Kazi hii inahesabu na kurudisha vitambulisho vilivyokosekana na vilivyorudiwa.\n \n  Kumbuka: Kitambulisho kilichokosekana hakitakuwa mwanzoni au mwishoni mwa safu ya jumla ya vitambulisho.\n \n  Ingizo: Safu ya safu, ambapo kila safu ndogo ina namba za kipekee zinazowakilisha vitambulisho vya tiketi.\n  Tokeo: Safu yenye namba mbili, ya kwanza ikiwa ni kitambulisho kilichokosekana (kilichovunjika) na ya pili ikiwa ni kitambulisho kilichorudiwa.\n \n  Mfano:\n  Ingizo: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  Tokeo: [7, 9] // 7 kinakosekana, na 9 kimerudiwa.",
      "tr": "Verilen ID gruplarından kayıp (bozuk) ve yinelenen ID'leri tanımlar. \n  Her ID grubu, ardışık olması gereken ancak bir hata içeren bilet ID'lerinin bir koleksiyonunu temsil eder:\n  bir ID eksiktir ve bir ID yinelenmiştir. Bu fonksiyon, eksik ve yinelenen ID'leri hesaplar ve döndürür.\n \n  Not: Eksik ID, genel ID aralığının başlangıcında veya sonunda olmayacaktır.\n \n  Girdi: Her alt dizi, bilet ID'lerini temsil eden tamsayılar içeren dizilerin bir dizisi.\n  Çıktı: İlk elemanı eksik (bozuk) ID ve ikinci elemanı yinelenen ID olan iki tamsayıdan oluşan bir dizi.\n \n  Örnek:\n  Girdi: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  Çıktı: [7, 9] // 7 eksik ve 9 yinelenmiştir.",
      "vi": "Xác định các ID bị thiếu (bị hỏng) và trùng lặp từ một tập hợp các nhóm ID đã cho. Mỗi nhóm ID đại diện cho một tập hợp các ID vé được cho là liên tiếp nhưng chứa một lỗi: một ID bị thiếu và một ID bị trùng lặp. Hàm này tính toán và trả về các ID bị thiếu và trùng lặp.\n\nLưu ý: ID bị thiếu sẽ không nằm ở đầu hoặc cuối của phạm vi ID tổng thể.\n\nĐầu vào: Một mảng các mảng, trong đó mỗi mảng con chứa các số nguyên đại diện cho các ID vé. Đầu ra: Một mảng với hai số nguyên, số đầu tiên là ID bị thiếu (bị hỏng) và số thứ hai là ID bị trùng lặp.\n\nVí dụ: Đầu vào: [[5, 6, 8, 11, 9], [10, 12, 9]] Đầu ra: [7, 9] // 7 bị thiếu, và 9 bị trùng lặp."
    },
    "docstring_bertscore": {
      "es": "0.9829380475298651",
      "arb": "0.9426262103292157",
      "sw": "0.9424295662519911",
      "tr": "0.9290339333549983",
      "vi": "0.9639748050524644"
    }
  },
  {
    "task_id": "PHP/50",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Counts the number of digits, lowercase letters, and uppercase letters in an 8-character string.\n *\n * This function takes a single string of exactly 8 characters as input.\n * It then counts and returns the number of digits, lowercase letters, and uppercase letters within the string.\n *\n * Input: A string of 8 characters.\n * Output: An array of three integers, where:\n * - The first integer is the count of digits in the string.\n * - The second integer is the count of lowercase letters in the string.\n * - The third integer is the count of uppercase letters in the string.\n *\n * Examples:\n * - For the string \"yLOI2022\", the output should be [4, 1, 3].\n * - For the string \"IAKIOIOI\", the output should be [0, 0, 8].\n * - For the string \"1n2s0e1s\", the output should be [4, 4, 0].\n */\n\n function countCharacters($s) ",
      "es": "<?php\n\n\n/**\n * Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena de 8 caracteres.\n *\n * Esta función toma una sola cadena de exactamente 8 caracteres como entrada.\n * Luego cuenta y devuelve el número de dígitos, letras minúsculas y letras mayúsculas dentro de la cadena.\n *\n * Entrada: Una cadena de 8 caracteres.\n * Salida: Un arreglo de tres enteros, donde:\n * - El primer entero es el conteo de dígitos en la cadena.\n * - El segundo entero es el conteo de letras minúsculas en la cadena.\n * - El tercer entero es el conteo de letras mayúsculas en la cadena.\n *\n * Ejemplos:\n * - Para la cadena \"yLOI2022\", la salida debería ser [4, 1, 3].\n * - Para la cadena \"IAKIOIOI\", la salida debería ser [0, 0, 8].\n * - Para la cadena \"1n2s0e1s\", la salida debería ser [4, 4, 0].\n */\n\n function countCharacters($s) ",
      "arb": "<?php\n\n\n/**\n * يحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة مكونة من 8 أحرف.\n *\n * تأخذ هذه الدالة سلسلة واحدة مكونة من 8 أحرف بالضبط كمدخل.\n * ثم تقوم بعد وإرجاع عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة داخل السلسلة.\n *\n * المدخل: سلسلة من 8 أحرف.\n * المخرج: مصفوفة من ثلاثة أعداد صحيحة، حيث:\n * - العدد الصحيح الأول هو عدد الأرقام في السلسلة.\n * - العدد الصحيح الثاني هو عدد الأحرف الصغيرة في السلسلة.\n * - العدد الصحيح الثالث هو عدد الأحرف الكبيرة في السلسلة.\n *\n * أمثلة:\n * - بالنسبة للسلسلة \"yLOI2022\"، يجب أن يكون المخرج [4, 1, 3].\n * - بالنسبة للسلسلة \"IAKIOIOI\"، يجب أن يكون المخرج [0, 0, 8].\n * - بالنسبة للسلسلة \"1n2s0e1s\"، يجب أن يكون المخرج [4, 4, 0].\n */\n\n function countCharacters($s) ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika mfuatano wa herufi 8.\n *\n * Kazi hii inachukua mfuatano mmoja wa herufi wa herufi 8 kamili kama ingizo.\n * Kisha inahesabu na kurudisha idadi ya tarakimu, herufi ndogo, na herufi kubwa ndani ya mfuatano huo.\n *\n * Ingizo: Mfuatano wa herufi 8.\n * Tokeo: Mfululizo wa namba tatu, ambapo:\n * - Namba ya kwanza ni idadi ya tarakimu katika mfuatano.\n * - Namba ya pili ni idadi ya herufi ndogo katika mfuatano.\n * - Namba ya tatu ni idadi ya herufi kubwa katika mfuatano.\n *\n * Mifano:\n * - Kwa mfuatano wa herufi \"yLOI2022\", matokeo yanapaswa kuwa [4, 1, 3].\n * - Kwa mfuatano wa herufi \"IAKIOIOI\", matokeo yanapaswa kuwa [0, 0, 8].\n * - Kwa mfuatano wa herufi \"1n2s0e1s\", matokeo yanapaswa kuwa [4, 4, 0].\n */\n\n function countCharacters($s) ",
      "tr": "<?php\n\n\n/**\n * Bir 8 karakterlik dizideki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n *\n * Bu fonksiyon, giriş olarak tam olarak 8 karakterden oluşan bir dize alır.\n * Daha sonra dizideki rakamların, küçük harflerin ve büyük harflerin sayısını sayar ve döndürür.\n *\n * Girdi: 8 karakterlik bir dize.\n * Çıktı: Üç tam sayıdan oluşan bir dizi, burada:\n * - İlk tam sayı dizideki rakamların sayısıdır.\n * - İkinci tam sayı dizideki küçük harflerin sayısıdır.\n * - Üçüncü tam sayı dizideki büyük harflerin sayısıdır.\n *\n * Örnekler:\n * - \"yLOI2022\" dizisi için çıktı [4, 1, 3] olmalıdır.\n * - \"IAKIOIOI\" dizisi için çıktı [0, 0, 8] olmalıdır.\n * - \"1n2s0e1s\" dizisi için çıktı [4, 4, 0] olmalıdır.\n */\n\n function countCharacters($s) ",
      "vi": "<?php\n\n\n/**\n * Đếm số chữ số, chữ cái viết thường và chữ cái viết hoa trong một chuỗi 8 ký tự.\n *\n * Hàm này nhận một chuỗi duy nhất gồm chính xác 8 ký tự làm đầu vào.\n * Sau đó, nó đếm và trả về số chữ số, chữ cái viết thường và chữ cái viết hoa trong chuỗi.\n *\n * Đầu vào: Một chuỗi gồm 8 ký tự.\n * Đầu ra: Một mảng gồm ba số nguyên, trong đó:\n * - Số nguyên đầu tiên là số lượng chữ số trong chuỗi.\n * - Số nguyên thứ hai là số lượng chữ cái viết thường trong chuỗi.\n * - Số nguyên thứ ba là số lượng chữ cái viết hoa trong chuỗi.\n *\n * Ví dụ:\n * - Đối với chuỗi \"yLOI2022\", đầu ra sẽ là [4, 1, 3].\n * - Đối với chuỗi \"IAKIOIOI\", đầu ra sẽ là [0, 0, 8].\n * - Đối với chuỗi \"1n2s0e1s\", đầu ra sẽ là [4, 4, 0].\n */\n\n function countCharacters($s) "
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9871772171219118",
      "sw": "0.9433138687083584",
      "tr": "0.9857290030137864",
      "vi": "0.9816741624153402"
    },
    "canonical_solution": " {\n    $digitCount = $lowerCount = $upperCount = 0;\n    \n    for ($i = 0; $i < strlen($s); $i++) {\n        if (ctype_digit($s[$i])) {\n            $digitCount++;\n        } elseif (ctype_lower($s[$i])) {\n            $lowerCount++;\n        } elseif (ctype_upper($s[$i])) {\n            $upperCount++;\n        }\n    }\n    \n    return [$digitCount, $lowerCount, $upperCount];\n}",
    "instruction": {
      "en": "Write a PHP function `function countCharacters($s)` to solve the following problem:\nCounts the number of digits, lowercase letters, and uppercase letters in an 8-character string.\n \n  This function takes a single string of exactly 8 characters as input.\n  It then counts and returns the number of digits, lowercase letters, and uppercase letters within the string.\n \n  Input: A string of 8 characters.\n  Output: An array of three integers, where:\n  - The first integer is the count of digits in the string.\n  - The second integer is the count of lowercase letters in the string.\n  - The third integer is the count of uppercase letters in the string.\n \n  Examples:\n  - For the string \"yLOI2022\", the output should be [4, 1, 3].\n  - For the string \"IAKIOIOI\", the output should be [0, 0, 8].\n  - For the string \"1n2s0e1s\", the output should be [4, 4, 0].",
      "es": "Escribe una función PHP `function countCharacters($s)` para resolver el siguiente problema:\nCuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena de 8 caracteres.\n\n  Esta función toma una sola cadena de exactamente 8 caracteres como entrada.\n  Luego cuenta y devuelve el número de dígitos, letras minúsculas y letras mayúsculas dentro de la cadena.\n\n  Entrada: Una cadena de 8 caracteres.\n  Salida: Un arreglo de tres enteros, donde:\n  - El primer entero es el conteo de dígitos en la cadena.\n  - El segundo entero es el conteo de letras minúsculas en la cadena.\n  - El tercer entero es el conteo de letras mayúsculas en la cadena.\n\n  Ejemplos:\n  - Para la cadena \"yLOI2022\", la salida debería ser [4, 1, 3].\n  - Para la cadena \"IAKIOIOI\", la salida debería ser [0, 0, 8].\n  - Para la cadena \"1n2s0e1s\", la salida debería ser [4, 4, 0].",
      "arb": "اكتب دالة PHP `function countCharacters($s)` لحل المشكلة التالية:\nتحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة مكونة من 8 أحرف.\n\nتأخذ هذه الدالة سلسلة واحدة مكونة من 8 أحرف بالضبط كمدخل.\nثم تحسب وتعيد عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة داخل السلسلة.\n\nالمدخل: سلسلة مكونة من 8 أحرف.\nالمخرج: مصفوفة من ثلاثة أعداد صحيحة، حيث:\n- العدد الصحيح الأول هو عدد الأرقام في السلسلة.\n- العدد الصحيح الثاني هو عدد الأحرف الصغيرة في السلسلة.\n- العدد الصحيح الثالث هو عدد الأحرف الكبيرة في السلسلة.\n\nأمثلة:\n- بالنسبة للسلسلة \"yLOI2022\"، يجب أن يكون المخرج [4, 1, 3].\n- بالنسبة للسلسلة \"IAKIOIOI\"، يجب أن يكون المخرج [0, 0, 8].\n- بالنسبة للسلسلة \"1n2s0e1s\"، يجب أن يكون المخرج [4, 4, 0].",
      "sw": "Andika kazi ya PHP `function countCharacters($s)` kutatua tatizo lifuatalo:\nInahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba ya herufi 8.\n\nKazi hii inapokea kamba moja yenye herufi 8 kamili kama ingizo.\nKisha inahesabu na kurudisha idadi ya tarakimu, herufi ndogo, na herufi kubwa ndani ya kamba hiyo.\n\nIngizo: Kamba ya herufi 8.\nMatokeo: Mfululizo wa namba tatu, ambapo:\n- Namba ya kwanza ni hesabu ya tarakimu katika kamba.\n- Namba ya pili ni hesabu ya herufi ndogo katika kamba.\n- Namba ya tatu ni hesabu ya herufi kubwa katika kamba.\n\nMifano:\n- Kwa kamba \"yLOI2022\", matokeo yanapaswa kuwa [4, 1, 3].\n- Kwa kamba \"IAKIOIOI\", matokeo yanapaswa kuwa [0, 0, 8].\n- Kwa kamba \"1n2s0e1s\", matokeo yanapaswa kuwa [4, 4, 0].",
      "tr": "Bir PHP fonksiyonu `function countCharacters($s)` yazın ve aşağıdaki problemi çözün:\nBir 8 karakterlik dizideki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n\nBu fonksiyon, tam olarak 8 karakterden oluşan bir dizeyi girdi olarak alır.\nDaha sonra dizideki rakamların, küçük harflerin ve büyük harflerin sayısını sayar ve döndürür.\n\nGirdi: 8 karakterlik bir dize.\nÇıktı: Üç tam sayıdan oluşan bir dizi, burada:\n- İlk tam sayı dizideki rakamların sayısıdır.\n- İkinci tam sayı dizideki küçük harflerin sayısıdır.\n- Üçüncü tam sayı dizideki büyük harflerin sayısıdır.\n\nÖrnekler:\n- \"yLOI2022\" dizisi için çıktı [4, 1, 3] olmalıdır.\n- \"IAKIOIOI\" dizisi için çıktı [0, 0, 8] olmalıdır.\n- \"1n2s0e1s\" dizisi için çıktı [4, 4, 0] olmalıdır.",
      "vi": "Viết một hàm PHP `function countCharacters($s)` để giải quyết vấn đề sau:  \nĐếm số chữ số, chữ cái thường, và chữ cái hoa trong một chuỗi có 8 ký tự.\n\nHàm này nhận một chuỗi duy nhất có đúng 8 ký tự làm đầu vào.  \nSau đó, nó đếm và trả về số lượng chữ số, chữ cái thường, và chữ cái hoa trong chuỗi.\n\nĐầu vào: Một chuỗi gồm 8 ký tự.  \nĐầu ra: Một mảng gồm ba số nguyên, trong đó:  \n- Số nguyên đầu tiên là số lượng chữ số trong chuỗi.  \n- Số nguyên thứ hai là số lượng chữ cái thường trong chuỗi.  \n- Số nguyên thứ ba là số lượng chữ cái hoa trong chuỗi.\n\nVí dụ:  \n- Với chuỗi \"yLOI2022\", đầu ra sẽ là [4, 1, 3].  \n- Với chuỗi \"IAKIOIOI\", đầu ra sẽ là [0, 0, 8].  \n- Với chuỗi \"1n2s0e1s\", đầu ra sẽ là [4, 4, 0]."
    },
    "instruction_bertscore": {
      "es": "0.9928554638245561",
      "arb": "0.9771755815456621",
      "sw": "0.9702451689209738",
      "tr": "0.9790627687958745",
      "vi": "0.9754679561599051"
    },
    "level": "easy",
    "test": "function main(){\n    // Testcases\n    assert(countCharacters(\"yLOI2022\") === [4, 1, 3]);\n    assert(countCharacters(\"IAKIOIOI\") === [0, 0, 8]);\n    assert(countCharacters(\"1n2s0e1s\") === [4, 4, 0]);\n\n    // echo \"All test cases passed!\";\n\n}\n\n\nmain();\n?>",
    "entry_point": "countCharacters",
    "signature": "function countCharacters($s)",
    "docstring": {
      "en": "Counts the number of digits, lowercase letters, and uppercase letters in an 8-character string.\n \n  This function takes a single string of exactly 8 characters as input.\n  It then counts and returns the number of digits, lowercase letters, and uppercase letters within the string.\n \n  Input: A string of 8 characters.\n  Output: An array of three integers, where:\n  - The first integer is the count of digits in the string.\n  - The second integer is the count of lowercase letters in the string.\n  - The third integer is the count of uppercase letters in the string.\n \n  Examples:\n  - For the string \"yLOI2022\", the output should be [4, 1, 3].\n  - For the string \"IAKIOIOI\", the output should be [0, 0, 8].\n  - For the string \"1n2s0e1s\", the output should be [4, 4, 0].",
      "es": "Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena de 8 caracteres.\n\nEsta función toma como entrada una sola cadena de exactamente 8 caracteres.\nLuego cuenta y devuelve el número de dígitos, letras minúsculas y letras mayúsculas dentro de la cadena.\n\nEntrada: Una cadena de 8 caracteres.\nSalida: Un arreglo de tres enteros, donde:\n- El primer entero es el conteo de dígitos en la cadena.\n- El segundo entero es el conteo de letras minúsculas en la cadena.\n- El tercer entero es el conteo de letras mayúsculas en la cadena.\n\nEjemplos:\n- Para la cadena \"yLOI2022\", la salida debería ser [4, 1, 3].\n- Para la cadena \"IAKIOIOI\", la salida debería ser [0, 0, 8].\n- Para la cadena \"1n2s0e1s\", la salida debería ser [4, 4, 0].",
      "arb": "يحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة مكونة من 8 أحرف.\n\nتأخذ هذه الدالة سلسلة واحدة مكونة من 8 أحرف بالضبط كمدخل.\nثم تقوم بعدّ وإرجاع عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة داخل السلسلة.\n\nالمدخل: سلسلة مكونة من 8 أحرف.\nالمخرج: مصفوفة من ثلاثة أعداد صحيحة، حيث:\n- العدد الصحيح الأول هو عدد الأرقام في السلسلة.\n- العدد الصحيح الثاني هو عدد الأحرف الصغيرة في السلسلة.\n- العدد الصحيح الثالث هو عدد الأحرف الكبيرة في السلسلة.\n\nأمثلة:\n- بالنسبة للسلسلة \"yLOI2022\"، يجب أن يكون المخرج [4, 1, 3].\n- بالنسبة للسلسلة \"IAKIOIOI\"، يجب أن يكون المخرج [0, 0, 8].\n- بالنسبة للسلسلة \"1n2s0e1s\"، يجب أن يكون المخرج [4, 4, 0].",
      "sw": "Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba ya herufi 8.\n\n  Kazi hii inachukua kamba moja ya herufi nane kamili kama ingizo.\n  Kisha inahesabu na kurudisha idadi ya tarakimu, herufi ndogo, na herufi kubwa ndani ya kamba hiyo.\n\n  Ingizo: Kamba ya herufi 8.\n  Tokeo: Safu ya nambari tatu, ambapo:\n  - Nambari ya kwanza ni hesabu ya tarakimu katika kamba.\n  - Nambari ya pili ni hesabu ya herufi ndogo katika kamba.\n  - Nambari ya tatu ni hesabu ya herufi kubwa katika kamba.\n\n  Mifano:\n  - Kwa kamba \"yLOI2022\", matokeo yanapaswa kuwa [4, 1, 3].\n  - Kwa kamba \"IAKIOIOI\", matokeo yanapaswa kuwa [0, 0, 8].\n  - Kwa kamba \"1n2s0e1s\", matokeo yanapaswa kuwa [4, 4, 0].",
      "tr": "8 karakterlik bir dizgideki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n\n  Bu fonksiyon, tam olarak 8 karakterden oluşan bir dizeyi girdi olarak alır.\n  Daha sonra dizideki rakamların, küçük harflerin ve büyük harflerin sayısını sayar ve döndürür.\n\n  Girdi: 8 karakterlik bir dize.\n  Çıktı: Üç tam sayıdan oluşan bir dizi, burada:\n  - İlk tam sayı dizideki rakamların sayısıdır.\n  - İkinci tam sayı dizideki küçük harflerin sayısıdır.\n  - Üçüncü tam sayı dizideki büyük harflerin sayısıdır.\n\n  Örnekler:\n  - \"yLOI2022\" dizisi için çıktı [4, 1, 3] olmalıdır.\n  - \"IAKIOIOI\" dizisi için çıktı [0, 0, 8] olmalıdır.\n  - \"1n2s0e1s\" dizisi için çıktı [4, 4, 0] olmalıdır.",
      "vi": "Đếm số chữ số, chữ cái viết thường và chữ cái viết hoa trong một chuỗi 8 ký tự.\n\nHàm này nhận một chuỗi duy nhất có đúng 8 ký tự làm đầu vào. Sau đó, nó đếm và trả về số lượng chữ số, chữ cái viết thường và chữ cái viết hoa trong chuỗi.\n\nĐầu vào: Một chuỗi gồm 8 ký tự. Đầu ra: Một mảng gồm ba số nguyên, trong đó: - Số nguyên đầu tiên là số lượng chữ số trong chuỗi. - Số nguyên thứ hai là số lượng chữ cái viết thường trong chuỗi. - Số nguyên thứ ba là số lượng chữ cái viết hoa trong chuỗi.\n\nVí dụ: - Đối với chuỗi \"yLOI2022\", đầu ra sẽ là [4, 1, 3]. - Đối với chuỗi \"IAKIOIOI\", đầu ra sẽ là [0, 0, 8]. - Đối với chuỗi \"1n2s0e1s\", đầu ra sẽ là [4, 4, 0]."
    },
    "docstring_bertscore": {
      "es": "0.9949251923949396",
      "arb": "0.9718232872982959",
      "sw": "0.966301561335907",
      "tr": "0.9828295953418201",
      "vi": "0.9793793856232441"
    }
  }
]