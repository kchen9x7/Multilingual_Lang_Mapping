[
  {
    "task_id": "C#/1",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Verificar si en la lista dada de números, hay dos números que estén más cerca uno del otro que\n   el umbral dado.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "arb": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من\n   العتبة المعطاة.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "sw": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Angalia kama katika orodha iliyotolewa ya namba, namba yoyote mbili ziko karibu zaidi kuliko\n   kizingiti kilichotolewa.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "tr": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Verilen sayı listesindeki herhangi iki sayının\n   verilen eşikten daha yakın olup olmadığını kontrol et.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "vi": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn\n   ngưỡng đã cho hay không.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)"
    },
    "prompt_bertscore": {
      "es": "0.9808506408555695",
      "arb": "0.9934285124738418",
      "sw": "0.9788444740071172",
      "tr": "0.9647605868398385",
      "vi": "0.9816409911417073"
    },
    "canonical_solution": "    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static bool HasCloseElements(List<double> numbers, double threshold)` para resolver el siguiente problema:\nVerificar si en la lista de números dada, hay dos números que estén más cerca uno del otro que el umbral dado.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "arb": "اكتب دالة C# `static bool HasCloseElements(List<double> numbers, double threshold)` لحل المشكلة التالية:\nتحقق مما إذا كان في القائمة المعطاة من الأرقام، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "sw": "Andika kazi ya C# `static bool HasCloseElements(List<double> numbers, double threshold)` kutatua tatizo lifuatalo:\nAngalia kama katika orodha iliyotolewa ya namba, namba yoyote mbili ziko karibu zaidi kuliko\n   kizingiti kilichopewa.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "tr": "Bir C# fonksiyonu `static bool HasCloseElements(List<double> numbers, double threshold)` yazın:\nVerilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "vi": "Viết một hàm C# `static bool HasCloseElements(List<double> numbers, double threshold)` để giải quyết vấn đề sau:\nKiểm tra xem trong danh sách các số đã cho, có hai số nào gần nhau hơn ngưỡng đã cho hay không.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true"
    },
    "instruction_bertscore": {
      "es": "0.96873200267825",
      "arb": "0.8158771847351379",
      "sw": "0.9860382705170577",
      "tr": "0.9609180821187185",
      "vi": "0.9892896512242177"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n\n        // Test cases\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.9, 4.0, 5.0, 2.2 }, 0.3) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.9, 4.0, 5.0, 2.2 }, 0.05) == false);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 5.9, 4.0, 5.0 }, 0.95) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 5.9, 4.0, 5.0 }, 0.8) == false);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.0, 4.0, 5.0, 2.0 }, 0.1) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.1, 2.2, 3.1, 4.1, 5.1 }, 1.0) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.1, 2.2, 3.1, 4.1, 5.1 }, 0.5) == false);\n    }\n}",
    "entry_point": "HasCloseElements",
    "signature": "static bool HasCloseElements(List<double> numbers, double threshold)",
    "docstring": {
      "es": "Verifica si en la lista dada de números, hay dos números que estén más cerca entre sí que el umbral dado.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "arb": "تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "sw": "Angalia kama katika orodha iliyotolewa ya nambari, nambari yoyote mbili ziko karibu zaidi na kila mmoja kuliko kizingiti kilichotolewa.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "vi": "Kiểm tra xem trong danh sách số đã cho, có hai số nào gần nhau hơn ngưỡng đã cho hay không.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true"
    },
    "docstring_bertscore": {
      "es": "0.9718461297921149",
      "arb": "0.9912743659915184",
      "sw": "0.9912743659915184",
      "tr": "0.959816478025499",
      "vi": "0.9821582246539222"
    }
  },
  {
    "task_id": "C#/2",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Convierte una temperatura dada en Fahrenheit a Celsius y devuelve el resultado como una cadena formateada a dos decimales.\n    La fórmula utilizada es: Celsius = 5/9 * (Fahrenheit - 32).\n    Ejemplo de uso:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* يحول درجة الحرارة المعطاة بالفهرنهايت إلى درجة مئوية ويعيد النتيجة كـ سلسلة نصية بتنسيق عشري مكون من رقمين.\n    الصيغة المستخدمة هي: Celsius = 5/9 * (Fahrenheit - 32).\n    مثال على الاستخدام:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Hubadilisha joto lililopewa la Fahrenheit kuwa Celsius na kurudisha matokeo kama kamba iliyofomatiwa kwa sehemu mbili za desimali.\n    Fomula inayotumika ni: Celsius = 5/9 * (Fahrenheit - 32).\n    Mfano wa matumizi:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Belirtilen Fahrenheit sıcaklığını Celsius'a dönüştürür ve sonucu iki ondalık basamağa yuvarlanmış bir string olarak döndürür.\n    Kullanılan formül: Celsius = 5/9 * (Fahrenheit - 32).\n    Örnek kullanım:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Chuyển đổi nhiệt độ Fahrenheit đã cho sang Celsius và trả về kết quả dưới dạng chuỗi được định dạng đến hai chữ số thập phân.\n    Công thức được sử dụng là: Celsius = 5/9 * (Fahrenheit - 32).\n    Ví dụ sử dụng:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)"
    },
    "prompt_bertscore": {
      "es": "0.9899892274262226",
      "arb": "0.9723879934715781",
      "sw": "0.9985915119680816",
      "tr": "0.9785568572153787",
      "vi": "0.9930282722560565"
    },
    "canonical_solution": "{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}",
    "instruction": {
      "es": "Escribe una función en C# `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` para resolver el siguiente problema:\nConvierte una temperatura dada en Fahrenheit a Celsius y devuelve el resultado como una cadena formateada con dos decimales.\n    La fórmula utilizada es: Celsius = 5/9 * (Fahrenheit - 32).\n    Ejemplo de uso:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "arb": "اكتب دالة C# `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` لحل المشكلة التالية:\nتحويل درجة حرارة معطاة بالفهرنهايت إلى درجة مئوية وإرجاع النتيجة كسلسلة نصية منسقة إلى منزلتين عشريتين.\n    الصيغة المستخدمة هي: Celsius = 5/9 * (Fahrenheit - 32).\n    مثال على الاستخدام:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "sw": "Andika kazi ya C# `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` kutatua tatizo lifuatalo:\nInabadilisha joto lililopewa la Fahrenheit kuwa Celsius na kurudisha matokeo kama kamba iliyopangwa kwa sehemu mbili za desimali.\n    Fomula inayotumika ni: Celsius = 5/9 * (Fahrenheit - 32).\n    Mfano wa matumizi:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "tr": "Bir C# fonksiyonu `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` yazın ve aşağıdaki problemi çözün:\nVerilen bir Fahrenheit sıcaklığını Celsius'a çevirir ve sonucu iki ondalık basamaklı bir string olarak döndürür.\n    Kullanılan formül: Celsius = 5/9 * (Fahrenheit - 32).\n    Örnek kullanım:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "vi": "Viết một hàm C# `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` để giải quyết vấn đề sau:\nChuyển đổi một nhiệt độ Fahrenheit đã cho sang Celsius và trả về kết quả dưới dạng chuỗi được định dạng đến hai chữ số thập phân.\n    Công thức được sử dụng là: Celsius = 5/9 * (Fahrenheit - 32).\n    Ví dụ sử dụng:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\""
    },
    "instruction_bertscore": {
      "es": "0.9795510022724583",
      "arb": "0.9893285827789007",
      "sw": "0.9985623133020695",
      "tr": "0.9797593655421638",
      "vi": "0.9942645477476176"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(ConvertFahrenheitToCelsius(32) == \"c=0.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(212) == \"c=100.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(-40) == \"c=-40.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(98.6) == \"c=37.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(0) == \"c=-17.78\");\n\n    }\n}",
    "entry_point": "ConvertFahrenheitToCelsius",
    "signature": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
    "docstring": {
      "es": "Convierte una temperatura dada en Fahrenheit a Celsius y devuelve el resultado como una cadena formateada a dos decimales.\n    La fórmula utilizada es: Celsius = 5/9 * (Fahrenheit - 32).\n    Ejemplo de uso:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "arb": "يقوم بتحويل درجة الحرارة المعطاة بالفهرنهايت إلى درجة مئوية ويعيد النتيجة كسلسلة نصية منسقة إلى منزلتين عشريتين.\n    الصيغة المستخدمة هي: Celsius = 5/9 * (Fahrenheit - 32).\n    مثال على الاستخدام:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "sw": "Inabadilisha joto lililopewa la Fahrenheit kuwa Celsius na kurudisha matokeo kama kamba iliyopangwa kwa sehemu mbili za desimali.  \n    Fomula inayotumika ni: Celsius = 5/9 * (Fahrenheit - 32).  \n    Mfano wa matumizi:  \n    >>> ConvertFahrenheitToCelsius(32)  \n    \"c=0.00\"  \n    >>> ConvertFahrenheitToCelsius(212)  \n    \"c=100.00\"  ",
      "tr": "Verilen Fahrenheit sıcaklığını Celsius'a dönüştürür ve sonucu iki ondalık basamağa yuvarlanmış bir string olarak döndürür. Kullanılan formül: Celsius = 5/9 * (Fahrenheit - 32). Örnek kullanım: >>> ConvertFahrenheitToCelsius(32) \"c=0.00\" >>> ConvertFahrenheitToCelsius(212) \"c=100.00\"",
      "vi": "Chuyển đổi nhiệt độ Fahrenheit đã cho sang Celsius và trả về kết quả dưới dạng chuỗi định dạng đến hai chữ số thập phân. Công thức được sử dụng là: Celsius = 5/9 * (Fahrenheit - 32). Ví dụ sử dụng: >>> ConvertFahrenheitToCelsius(32) \"c=0.00\" >>> ConvertFahrenheitToCelsius(212) \"c=100.00\""
    },
    "docstring_bertscore": {
      "es": "0.985908564878242",
      "arb": "0.9863060242706927",
      "sw": "0.998058586655765",
      "tr": "0.9831660752072933",
      "vi": "0.9895458844157528"
    }
  },
  {
    "task_id": "C#/3",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Codifica la cadena dada desplazando cada letra un número especificado de lugares en el alfabeto.\n    Si el desplazamiento lleva la letra más allá de 'z', se reinicia desde el principio del alfabeto.\n    \n    Ejemplos:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    يقوم بترميز السلسلة النصية المعطاة عن طريق تحريك كل حرف بعدد محدد من الأماكن في الأبجدية.\n    إذا أخذ التحريك الحرف إلى ما بعد 'z'، فإنه يلتف إلى بداية الأبجدية.\n    \n    أمثلة:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Husimba mfuatano wa herufi uliotolewa kwa kusogeza kila herufi kwa idadi maalum ya nafasi katika alfabeti.\n    Ikiwa mabadiliko yanapeleka herufi zaidi ya 'z', inarudi mwanzo wa alfabeti.\n    \n    Mifano:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Verilen string'i, alfabede belirtilen sayıda yer kaydırarak kodlar.\n    Eğer kaydırma harfi 'z' harfinden öteye götürürse, alfabenin başına döner.\n    \n    Örnekler:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Mã hóa chuỗi được cung cấp bằng cách dịch chuyển mỗi chữ cái một số vị trí nhất định trong bảng chữ cái.\n    Nếu dịch chuyển đưa chữ cái vượt quá 'z', nó sẽ quay lại đầu bảng chữ cái.\n    \n    Ví dụ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)"
    },
    "prompt_bertscore": {
      "es": "0.9760551075662443",
      "arb": "0.9885646503334404",
      "sw": "0.9821246561195273",
      "tr": "0.9818143954643508",
      "vi": "0.9736824676647825"
    },
    "canonical_solution": "{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}",
    "instruction": {
      "es": "Escribe una función en C# `static string EncodeString(string input, int shift)` para resolver el siguiente problema:\nCodifica la cadena dada desplazando cada letra un número especificado de lugares en el alfabeto.\n    Si el desplazamiento lleva la letra más allá de 'z', se reinicia al principio del alfabeto.\n    \n    Ejemplos:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "arb": "اكتب دالة C# `static string EncodeString(string input, int shift)` لحل المشكلة التالية:\nترميز السلسلة النصية المعطاة عن طريق تحريك كل حرف بعدد محدد من الأماكن في الأبجدية.\n    إذا أخذ التحريك الحرف إلى ما بعد 'z'، فإنه يلتف إلى بداية الأبجدية.\n    \n    أمثلة:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "sw": "Andika kazi ya C# `static string EncodeString(string input, int shift)` kutatua tatizo lifuatalo:\nInasimba mfululizo uliotolewa kwa kusogeza kila herufi kwa idadi maalum ya nafasi katika alfabeti.\n    Ikiwa mabadiliko yanachukua herufi zaidi ya 'z', inazunguka hadi mwanzo wa alfabeti.\n    \n    Mifano:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "tr": "Bir C# fonksiyonu `static string EncodeString(string input, int shift)` yazın:\nVerilen stringi, her harfi alfabede belirtilen sayıda kaydırarak kodlar.\n    Eğer kaydırma harfi 'z' harfinin ötesine taşırsa, alfabede başa döner.\n    \n    Örnekler:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "vi": "Viết một hàm C# `static string EncodeString(string input, int shift)` để giải quyết vấn đề sau:\nMã hóa chuỗi đã cho bằng cách dịch chuyển mỗi chữ cái một số vị trí xác định trong bảng chữ cái.\n    Nếu sự dịch chuyển đưa chữ cái vượt quá 'z', nó sẽ quay lại bắt đầu của bảng chữ cái.\n    \n    Ví dụ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\""
    },
    "instruction_bertscore": {
      "es": "0.9649411418561992",
      "arb": "0.9769860881621547",
      "sw": "0.9853758381963064",
      "tr": "0.9590686346409026",
      "vi": "0.9683071322932163"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n        Debug.Assert(EncodeString(\"China\", 4) == \"Glmre\");\n        Debug.Assert(EncodeString(\"apple\", 2) == \"crrng\");\n        Debug.Assert(EncodeString(\"hello\", 5) == \"mjqqt\");\n        Debug.Assert(EncodeString(\"xyz\", 3) == \"abc\");\n        Debug.Assert(EncodeString(\"AbCdE\", 1) == \"BcDeF\");\n        Debug.Assert(EncodeString(\"Java\", 10) == \"Tkfk\");\n        Debug.Assert(EncodeString(\"OpenAI\", 4) == \"StirEM\");\n        Debug.Assert(EncodeString(\"\", 5) == \"\");\n\n    }\n}\n",
    "entry_point": "EncodeString",
    "signature": "static string EncodeString(string input, int shift)",
    "docstring": {
      "es": "Codifica la cadena dada desplazando cada letra por un número especificado de lugares en el alfabeto. Si el desplazamiento lleva la letra más allá de 'z', se reinicia desde el principio del alfabeto.\n\n    Ejemplos:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "arb": "يشفر السلسلة النصية المعطاة عن طريق تحريك كل حرف بعدد محدد من الأماكن في الأبجدية. \n    إذا أخذ التحول الحرف إلى ما بعد 'z'، فإنه يلتف إلى بداية الأبجدية.\n    \n    أمثلة:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "sw": "Inasimba kamba iliyopewa kwa kusogeza kila herufi kwa idadi maalum ya nafasi katika alfabeti. Ikiwa mabadiliko yanachukua herufi zaidi ya 'z', inarudi mwanzo wa alfabeti.\n\n    Mifano:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "tr": "Verilen dizeyi, her harfi alfabede belirtilen sayıda yer kaydırarak kodlar. \n    Eğer kaydırma harfi 'z' harfinin ötesine taşırsa, alfabede başa döner.\n    \n    Örnekler:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "vi": "Mã hóa chuỗi được cung cấp bằng cách dịch chuyển mỗi chữ cái một số vị trí nhất định trong bảng chữ cái. Nếu sự dịch chuyển đưa chữ cái vượt quá 'z', nó sẽ quay trở lại đầu bảng chữ cái.\n\n    Ví dụ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\""
    },
    "docstring_bertscore": {
      "es": "0.9571133171699953",
      "arb": "0.9749060308119574",
      "sw": "0.9776072053636509",
      "tr": "0.964911943190187",
      "vi": "0.9501306647550948"
    }
  },
  {
    "task_id": "C#/4",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calcula un valor basado en la entrada x según funciones lineales especificadas.\n   La función aplica diferentes fórmulas basadas en el valor de x:\n   - Para x menor que 1, devuelve x.\n   - Para x entre 1 y 10, devuelve 2x - 1.\n   - Para x mayor o igual a 10, devuelve 3x - 11.\n   Casos de ejemplo:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* يحسب قيمة بناءً على المدخل x وفقًا للدوال الخطية المحددة.\n   تطبق الدالة صيغًا مختلفة بناءً على قيمة x:\n   - إذا كانت x أقل من 1، تعيد x.\n   - إذا كانت x بين 1 و 10، تعيد 2x - 1.\n   - إذا كانت x أكبر من أو تساوي 10، تعيد 3x - 11.\n   حالات المثال:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Inahesabu thamani kulingana na x iliyoingizwa kulingana na kazi za mstari maalum.\n   Kazi hutumia fomula tofauti kulingana na thamani ya x:\n   - Kwa x chini ya 1, inarudisha x.\n   - Kwa x kati ya 1 na 10, inarudisha 2x - 1.\n   - Kwa x kubwa au sawa na 10, inarudisha 3x - 11.\n   Mifano ya kesi:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Girdiye dayalı bir değeri belirtilen doğrusal fonksiyonlara göre hesaplar.\n   Fonksiyon, x değerine bağlı olarak farklı formüller uygular:\n   - x 1'den küçükse, x değerini döndürür.\n   - x 1 ile 10 arasında ise, 2x - 1 değerini döndürür.\n   - x 10 veya daha büyükse, 3x - 11 değerini döndürür.\n   Örnek durumlar:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Tính toán một giá trị dựa trên đầu vào x theo các hàm tuyến tính được chỉ định.\n   Hàm áp dụng các công thức khác nhau dựa trên giá trị của x:\n   - Đối với x nhỏ hơn 1, trả về x.\n   - Đối với x trong khoảng từ 1 đến 10, trả về 2x - 1.\n   - Đối với x lớn hơn hoặc bằng 10, trả về 3x - 11.\n   Các trường hợp ví dụ:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)"
    },
    "prompt_bertscore": {
      "es": "0.9953905833777044",
      "arb": "0.9715084581443556",
      "sw": "0.9780942470579483",
      "tr": "0.9543632795445672",
      "vi": "0.9767771290013061"
    },
    "canonical_solution": "{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}",
    "instruction": {
      "es": "Escribe una función en C# `static double ComputeValue(double x)` para resolver el siguiente problema:\nCalcula un valor basado en la entrada x según funciones lineales especificadas.\n   La función aplica diferentes fórmulas basadas en el valor de x:\n   - Para x menor que 1, devuelve x.\n   - Para x entre 1 y 10, devuelve 2x - 1.\n   - Para x mayor o igual a 10, devuelve 3x - 11.\n   Casos de ejemplo:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "arb": "اكتب دالة C# `static double ComputeValue(double x)` لحل المشكلة التالية:\nتحسب قيمة بناءً على المدخل x وفقًا لدوال خطية محددة.\n   تطبق الدالة صيغًا مختلفة بناءً على قيمة x:\n   - إذا كانت x أقل من 1، تعيد x.\n   - إذا كانت x بين 1 و 10، تعيد 2x - 1.\n   - إذا كانت x أكبر من أو تساوي 10، تعيد 3x - 11.\n   أمثلة على الحالات:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "sw": "Andika kazi ya C# `static double ComputeValue(double x)` kutatua tatizo lifuatalo:\nInahesabu thamani kulingana na x iliyoingizwa kulingana na kazi za mstari maalum.\n   Kazi inatumia fomula tofauti kulingana na thamani ya x:\n   - Kwa x chini ya 1, inarudisha x.\n   - Kwa x kati ya 1 na 10, inarudisha 2x - 1.\n   - Kwa x kubwa kuliko au sawa na 10, inarudisha 3x - 11.\n   Mifano ya kesi:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "tr": "Bir C# fonksiyonu `static double ComputeValue(double x)` yazın:\nGirdi x'e göre belirtilen doğrusal fonksiyonlara göre bir değer hesaplar.\n   Fonksiyon, x'in değerine bağlı olarak farklı formüller uygular:\n   - x 1'den küçükse, x'i döndürür.\n   - x 1 ile 10 arasında ise, 2x - 1'i döndürür.\n   - x 10 veya daha büyükse, 3x - 11'i döndürür.\n   Örnek durumlar:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "vi": "Viết một hàm C# `static double ComputeValue(double x)` để giải quyết vấn đề sau:\nTính toán một giá trị dựa trên đầu vào x theo các hàm tuyến tính được chỉ định.\n   Hàm áp dụng các công thức khác nhau dựa trên giá trị của x:\n   - Đối với x nhỏ hơn 1, trả về x.\n   - Đối với x trong khoảng từ 1 đến 10, trả về 2x - 1.\n   - Đối với x lớn hơn hoặc bằng 10, trả về 3x - 11.\n   Các trường hợp ví dụ:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19"
    },
    "instruction_bertscore": {
      "es": "0.9859224690049143",
      "arb": "0.9687842424684622",
      "sw": "0.9761623679720031",
      "tr": "0.9461117762556158",
      "vi": "0.9762628749448067"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(ComputeValue(0.5) == 0.5);\n        Debug.Assert(ComputeValue(2) == 3);\n        Debug.Assert(ComputeValue(5) == 9);\n        Debug.Assert(ComputeValue(10) == 19);\n        Debug.Assert(ComputeValue(15) == 34);\n        Debug.Assert(ComputeValue(0) == 0);\n        Debug.Assert(ComputeValue(1) == 1);\n\n    }\n}",
    "entry_point": "ComputeValue",
    "signature": "static double ComputeValue(double x)",
    "docstring": {
      "es": "Calcula un valor basado en la entrada x según funciones lineales especificadas.\n   La función aplica diferentes fórmulas según el valor de x:\n   - Para x menor que 1, devuelve x.\n   - Para x entre 1 y 10, devuelve 2x - 1.\n   - Para x mayor o igual a 10, devuelve 3x - 11.\n   Casos de ejemplo:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "arb": "يحسب قيمة بناءً على المدخل x وفقًا للدوال الخطية المحددة.  \nتطبق الدالة صيغًا مختلفة بناءً على قيمة x:  \n- بالنسبة لـ x أقل من 1، تعيد x.  \n- بالنسبة لـ x بين 1 و10، تعيد 2x - 1.  \n- بالنسبة لـ x أكبر من أو يساوي 10، تعيد 3x - 11.  \nحالات المثال:  \n>>> ComputeValue(0.5)  \n0.5  \n>>> ComputeValue(5)  \n9  \n>>> ComputeValue(10)  \n19  ",
      "sw": "Hesabu thamani kulingana na ingizo x kulingana na kazi za mstari maalum. \n   Kazi inatumia fomula tofauti kulingana na thamani ya x:\n   - Kwa x chini ya 1, inarudisha x.\n   - Kwa x kati ya 1 na 10, inarudisha 2x - 1.\n   - Kwa x kubwa au sawa na 10, inarudisha 3x - 11.\n   Mifano ya kesi:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "tr": "Girdi x'e göre belirtilen doğrusal fonksiyonlara göre bir değer hesaplar.\n   Fonksiyon, x'in değerine göre farklı formüller uygular:\n   - x 1'den küçükse, x'i döndürür.\n   - x 1 ile 10 arasında ise, 2x - 1'i döndürür.\n   - x 10 veya daha büyükse, 3x - 11'i döndürür.\n   Örnek durumlar:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "vi": "Tính toán một giá trị dựa trên đầu vào x theo các hàm tuyến tính được chỉ định.\n   Hàm áp dụng các công thức khác nhau dựa trên giá trị của x:\n   - Đối với x nhỏ hơn 1, trả về x.\n   - Đối với x từ 1 đến 10, trả về 2x - 1.\n   - Đối với x lớn hơn hoặc bằng 10, trả về 3x - 11.\n   Các trường hợp ví dụ:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19"
    },
    "docstring_bertscore": {
      "es": "0.982669499254706",
      "arb": "0.9735851387780754",
      "sw": "0.9664266984759591",
      "tr": "0.9405278789839631",
      "vi": "0.9797397011344414"
    }
  },
  {
    "task_id": "C#/5",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Esta función encuentra todos los números narcisistas dentro de un rango dado.\n   Un número narcisista es un número que es la suma de sus propios dígitos, cada uno elevado a la potencia del número de dígitos.\n   Por ejemplo, 153 es un número narcisista porque 153 = 1^3 + 5^3 + 3^3.\n   \n   Ejemplos:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* هذه الدالة تجد جميع الأرقام النرجسية ضمن نطاق معين.\n   الرقم النرجسي هو رقم يساوي مجموع أرقامه كل منها مرفوع إلى قوة عدد الأرقام.\n   على سبيل المثال، 153 هو رقم نرجسي لأن 153 = 1^3 + 5^3 + 3^3.\n   \n   أمثلة:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kazi ya hii kazi ni kupata namba zote za narcissistic ndani ya kipengele kilichopewa.\n   Namba ya narcissistic ni namba ambayo ni jumla ya tarakimu zake zote kila moja ikiwa imeinuliwa kwa nguvu ya idadi ya tarakimu.\n   Kwa mfano, 153 ni namba ya narcissistic kwa sababu 153 = 1^3 + 5^3 + 3^3.\n   \n   Mifano:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bu fonksiyon, belirli bir aralıktaki tüm narsistik sayıları bulur.\n   Narsistik bir sayı, kendi basamaklarının her birinin basamak sayısının kuvvetine yükseltilmiş toplamına eşit olan bir sayıdır.\n   Örneğin, 153 bir narsistik sayıdır çünkü 153 = 1^3 + 5^3 + 3^3.\n   \n   Örnekler:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hàm này tìm tất cả các số narcissistic trong một phạm vi cho trước.\n   Một số narcissistic là một số mà tổng của các chữ số của nó, mỗi chữ số được nâng lên lũy thừa của số lượng chữ số.\n   Ví dụ, 153 là một số narcissistic vì 153 = 1^3 + 5^3 + 3^3.\n   \n   Ví dụ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)"
    },
    "prompt_bertscore": {
      "es": "0.9962790570720734",
      "arb": "0.9854914410780686",
      "sw": "0.9783788843939714",
      "tr": "0.9868057783093765",
      "vi": "0.9937083826807199"
    },
    "canonical_solution": "{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static List<int> FindNarcissisticNumbers(int start, int end)` para resolver el siguiente problema:\nEsta función encuentra todos los números narcisistas dentro de un rango dado.\n   Un número narcisista es un número que es la suma de sus propios dígitos, cada uno elevado a la potencia del número de dígitos.\n   Por ejemplo, 153 es un número narcisista porque 153 = 1^3 + 5^3 + 3^3.\n   \n   Ejemplos:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "arb": "اكتب دالة C# `static List<int> FindNarcissisticNumbers(int start, int end)` لحل المشكلة التالية:\nتجد هذه الدالة جميع الأرقام النرجسية ضمن نطاق معين.\nالرقم النرجسي هو رقم يساوي مجموع أرقامه كل منها مرفوع لأس عدد الأرقام.\nعلى سبيل المثال، 153 هو رقم نرجسي لأن 153 = 1^3 + 5^3 + 3^3.\n\nأمثلة:\n>>> FindNarcissisticNumbers(100, 170)\n[153]\n>>> FindNarcissisticNumbers(100, 500)\n[153, 370, 371, 407]",
      "sw": "Andika kazi ya C# `static List<int> FindNarcissisticNumbers(int start, int end)` kutatua tatizo lifuatalo:\nKazi hii inapata nambari zote za narcissistic ndani ya safu fulani.\n   Nambari ya narcissistic ni nambari ambayo ni jumla ya tarakimu zake yenyewe kila moja ikiwa imeinuliwa kwa nguvu ya idadi ya tarakimu.\n   Kwa mfano, 153 ni nambari ya narcissistic kwa sababu 153 = 1^3 + 5^3 + 3^3.\n   \n   Mifano:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "tr": "Bir C# fonksiyonu `static List<int> FindNarcissisticNumbers(int start, int end)` yazın:\nBu fonksiyon, verilen bir aralıktaki tüm narsistik sayıları bulur.\n   Narsistik bir sayı, kendi basamaklarının her birinin basamak sayısının kuvvetine yükseltilmiş toplamına eşit olan bir sayıdır.\n   Örneğin, 153 bir narsistik sayıdır çünkü 153 = 1^3 + 5^3 + 3^3.\n\n   Örnekler:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "vi": "Viết một hàm C# `static List<int> FindNarcissisticNumbers(int start, int end)` để giải quyết vấn đề sau:\nHàm này tìm tất cả các số narcissistic trong một khoảng cho trước.\n   Một số narcissistic là một số mà tổng của các chữ số của nó mỗi chữ số được nâng lên lũy thừa của số lượng chữ số.\n   Ví dụ, 153 là một số narcissistic vì 153 = 1^3 + 5^3 + 3^3.\n   \n   Ví dụ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]"
    },
    "instruction_bertscore": {
      "es": "0.985954448496261",
      "arb": "0.9832870411093435",
      "sw": "1",
      "tr": "0.977397253050897",
      "vi": "0.9924399290674312"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n \n        Debug.Assert(FindNarcissisticNumbers(100, 170).SequenceEqual(new List<int> { 153 }));\n        Debug.Assert(FindNarcissisticNumbers(100, 500).SequenceEqual(new List<int> { 153, 370, 371, 407 }));\n        Debug.Assert(FindNarcissisticNumbers(1, 100).SequenceEqual(new List<int> { }));\n        Debug.Assert(FindNarcissisticNumbers(370, 380).SequenceEqual(new List<int> { 370, 371 }));\n        Debug.Assert(FindNarcissisticNumbers(0, 999).SequenceEqual(new List<int> { 153, 370, 371, 407 }));\n        Debug.Assert(FindNarcissisticNumbers(900, 1000).SequenceEqual(new List<int> { }));\n        Debug.Assert(FindNarcissisticNumbers(10, 15).SequenceEqual(new List<int> { }));\n\n    }\n}",
    "entry_point": "FindNarcissisticNumbers",
    "signature": "static List<int> FindNarcissisticNumbers(int start, int end)",
    "docstring": {
      "es": "Esta función encuentra todos los números narcisistas dentro de un rango dado.  \n   Un número narcisista es un número que es la suma de sus propios dígitos, cada uno elevado a la potencia del número de dígitos.  \n   Por ejemplo, 153 es un número narcisista porque 153 = 1^3 + 5^3 + 3^3.\n   \n   Ejemplos:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "arb": "هذه الدالة تجد جميع الأرقام النرجسية ضمن نطاق معين.\n   الرقم النرجسي هو رقم يساوي مجموع أرقامه كل منها مرفوع إلى قوة عدد الأرقام.\n   على سبيل المثال، 153 هو رقم نرجسي لأن 153 = 1^3 + 5^3 + 3^3.\n   \n   أمثلة:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "sw": "Kazi hii inapata nambari zote za narcissistic ndani ya safu fulani.\n   Nambari ya narcissistic ni nambari ambayo ni jumla ya tarakimu zake yenyewe kila moja ikiwa imeinuliwa kwa nguvu ya idadi ya tarakimu.\n   Kwa mfano, 153 ni nambari ya narcissistic kwa sababu 153 = 1^3 + 5^3 + 3^3.\n   \n   Mifano:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "tr": "Bu fonksiyon, verilen bir aralık içindeki tüm narsistik sayıları bulur.\n   Narsistik bir sayı, kendi basamaklarının her birinin basamak sayısı kadar üssü alınarak toplamına eşit olan bir sayıdır.\n   Örneğin, 153 bir narsistik sayıdır çünkü 153 = 1^3 + 5^3 + 3^3.\n   \n   Örnekler:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "vi": "Hàm này tìm tất cả các số narcissistic trong một phạm vi cho trước.\n   Một số narcissistic là một số mà tổng của các chữ số của nó, mỗi chữ số được nâng lên lũy thừa của số lượng chữ số.\n   Ví dụ, 153 là một số narcissistic vì 153 = 1^3 + 5^3 + 3^3.\n   \n   Ví dụ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]"
    },
    "docstring_bertscore": {
      "es": "0.9951589803534177",
      "arb": "0.9798813245961193",
      "sw": "1",
      "tr": "0.9878599097415287",
      "vi": "0.9889865412627585"
    }
  },
  {
    "task_id": "C#/6",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Ordena tres enteros dados en orden ascendente y devuelve la lista ordenada.\n    Ejemplo de uso:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* يقوم بترتيب ثلاثة أعداد صحيحة معطاة بترتيب تصاعدي ويعيد القائمة المرتبة.\n    مثال على الاستخدام:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hupanga nambari tatu zilizotolewa kwa mpangilio wa kupanda na kurudisha orodha iliyopangwa.\n    Mfano wa matumizi:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Verilen üç tam sayıyı artan sırayla sıralar ve sıralı listeyi döndürür.\n    Örnek kullanım:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Sắp xếp ba số nguyên đã cho theo thứ tự tăng dần và trả về danh sách đã sắp xếp.\n    Ví dụ sử dụng:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)"
    },
    "prompt_bertscore": {
      "es": "0.9945380617823026",
      "arb": "1",
      "sw": "0.9848854197855312",
      "tr": "0.9951530214419867",
      "vi": "0.9937357936733028"
    },
    "canonical_solution": "{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static List<int> SortIntegersAscending(int num1, int num2, int num3)` para resolver el siguiente problema:\nOrdena tres enteros dados en orden ascendente y devuelve la lista ordenada.\n    Ejemplo de uso:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "arb": "اكتب دالة C# `static List<int> SortIntegersAscending(int num1, int num2, int num3)` لحل المشكلة التالية:\nترتيب ثلاثة أعداد صحيحة معطاة بترتيب تصاعدي وإرجاع القائمة المرتبة.\n    مثال على الاستخدام:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "sw": "Andika kazi ya C# `static List<int> SortIntegersAscending(int num1, int num2, int num3)` kutatua tatizo lifuatalo:\nPanga namba tatu zilizotolewa kwa mpangilio wa kupanda na rudisha orodha iliyopangwa.\n    Mfano wa matumizi:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "tr": "Bir C# fonksiyonu `static List<int> SortIntegersAscending(int num1, int num2, int num3)` yazın:\nÜç verilen tam sayıyı artan sırayla sıralar ve sıralı listeyi döndürür.\n    Örnek kullanım:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "vi": "Viết một hàm C# `static List<int> SortIntegersAscending(int num1, int num2, int num3)` để giải quyết vấn đề sau:\nSắp xếp ba số nguyên đã cho theo thứ tự tăng dần và trả về danh sách đã sắp xếp.\n    Ví dụ sử dụng:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]"
    },
    "instruction_bertscore": {
      "es": "0.9856193590434551",
      "arb": "0.9940829995793518",
      "sw": "0.9878692453694373",
      "tr": "0.9723736920841436",
      "vi": "0.9925076620273641"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(SortIntegersAscending(3, 1, 2).SequenceEqual(new List<int> { 1, 2, 3 }));\n        Debug.Assert(SortIntegersAscending(5, 7, 2).SequenceEqual(new List<int> { 2, 5, 7 }));\n        Debug.Assert(SortIntegersAscending(-1, 0, -3).SequenceEqual(new List<int> { -3, -1, 0 }));\n        Debug.Assert(SortIntegersAscending(10, 10, 10).SequenceEqual(new List<int> { 10, 10, 10 }));\n        Debug.Assert(SortIntegersAscending(0, -1, 1).SequenceEqual(new List<int> { -1, 0, 1 }));\n        Debug.Assert(SortIntegersAscending(100, 50, 75).SequenceEqual(new List<int> { 50, 75, 100 }));\n        Debug.Assert(SortIntegersAscending(-5, -10, -7).SequenceEqual(new List<int> { -10, -7, -5 }));\n\n\n    }\n}",
    "entry_point": "SortIntegersAscending",
    "signature": "static List<int> SortIntegersAscending(int num1, int num2, int num3)",
    "docstring": {
      "es": "Ordena tres enteros dados en orden ascendente y devuelve la lista ordenada.\n    Ejemplo de uso:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "arb": "يرتب ثلاثة أعداد صحيحة معطاة بترتيب تصاعدي ويعيد القائمة المرتبة.\n    مثال على الاستخدام:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "sw": "Hupanga nambari tatu zilizotolewa kwa mpangilio wa kupanda na kurudisha orodha iliyopangwa.\n    Mfano wa matumizi:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "tr": "Üç verilen tam sayıyı artan sırayla sıralar ve sıralanmış listeyi döndürür.\n    Örnek kullanım:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "vi": "Sắp xếp ba số nguyên được cung cấp theo thứ tự tăng dần và trả về danh sách đã sắp xếp.\n    Ví dụ sử dụng:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]"
    },
    "docstring_bertscore": {
      "es": "0.9883852870993659",
      "arb": "0.993686334708425",
      "sw": "0.9830409380672412",
      "tr": "1",
      "vi": "0.9908633997331572"
    }
  },
  {
    "task_id": "C#/7",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Copia una subcadena desde el índice de inicio especificado en la cadena de entrada hasta el final de la cadena.\n   Si el índice de inicio es mayor que la longitud de la cadena, devuelve una cadena vacía.\n   Ejemplos:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* ينسخ جزءًا من السلسلة النصية من الفهرس المحدد كبداية إلى نهاية السلسلة.\n   إذا كان الفهرس المبدئي أكبر من طول السلسلة، يعيد سلسلة فارغة.\n   أمثلة:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hunakili sehemu ndogo ya maandishi kutoka kwa kiashiria cha mwanzo kilichobainishwa katika maandishi ya kuingiza hadi mwisho wa maandishi.\n   Ikiwa kiashiria cha mwanzo ni kikubwa kuliko urefu wa maandishi, inarudisha maandishi tupu.\n   Mifano:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Girdi dizesindeki belirtilen başlangıç indeksinden dize sonuna kadar olan alt dizeyi kopyalar.\n   Eğer başlangıç indeksi dizenin uzunluğundan büyükse, boş bir dize döner.\n   Örnekler:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Sao chép một chuỗi con từ chỉ số bắt đầu được chỉ định trong chuỗi đầu vào đến cuối chuỗi.\n   Nếu chỉ số bắt đầu lớn hơn độ dài của chuỗi, trả về một chuỗi rỗng.\n   Ví dụ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)"
    },
    "prompt_bertscore": {
      "es": "0.9856815303527191",
      "arb": "0.9584375859203548",
      "sw": "0.9717631022928424",
      "tr": "0.9797919409246536",
      "vi": "0.9862365036373305"
    },
    "canonical_solution": "{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}",
    "instruction": {
      "es": "Escribe una función en C# `static string CopySubstringFromIndex(string input, int startIndex)` para resolver el siguiente problema:\nCopia una subcadena desde el índice de inicio especificado en la cadena de entrada hasta el final de la cadena.\n   Si el índice de inicio es mayor que la longitud de la cadena, devuelve una cadena vacía.\n   Ejemplos:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "arb": "اكتب دالة C# `static string CopySubstringFromIndex(string input, int startIndex)` لحل المشكلة التالية:\nنسخ جزء من السلسلة النصية من الفهرس المحدد في السلسلة النصية المدخلة إلى نهاية السلسلة.\nإذا كان الفهرس المبدئي أكبر من طول السلسلة، يتم إرجاع سلسلة فارغة.\nأمثلة:\n>>> CopySubstringFromIndex(\"Hello World\", 6)\n\"World\"\n>>> CopySubstringFromIndex(\"Example\", 3)\n\"mple\"\n>>> CopySubstringFromIndex(\"Short\", 10)\n\"\"",
      "sw": "Andika kazi ya C# `static string CopySubstringFromIndex(string input, int startIndex)` kutatua tatizo lifuatalo:\nNakala sehemu ndogo ya maandishi kutoka kwenye kiashiria cha mwanzo kilichobainishwa katika maandishi ya pembejeo hadi mwisho wa maandishi.\n   Ikiwa kiashiria cha mwanzo ni kikubwa kuliko urefu wa maandishi, rudisha maandishi tupu.\n   Mifano:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "tr": "Bir C# fonksiyonu `static string CopySubstringFromIndex(string input, int startIndex)` yazın ve aşağıdaki problemi çözün:\nGirdi stringinde belirtilen başlangıç indeksinden stringin sonuna kadar olan alt diziyi kopyalar.\n   Eğer başlangıç indeksi stringin uzunluğundan büyükse, boş bir string döndürür.\n   Örnekler:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "vi": "Viết một hàm C# `static string CopySubstringFromIndex(string input, int startIndex)` để giải quyết vấn đề sau:\nSao chép một chuỗi con từ chỉ số bắt đầu được chỉ định trong chuỗi đầu vào đến cuối chuỗi.\n   Nếu chỉ số bắt đầu lớn hơn độ dài của chuỗi, trả về một chuỗi rỗng.\n   Ví dụ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\""
    },
    "instruction_bertscore": {
      "es": "0.9871309362431306",
      "arb": "0.971510245817785",
      "sw": "0.9750150788911456",
      "tr": "0.9787433711431704",
      "vi": "0.9891905346640814"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n        Debug.Assert(CopySubstringFromIndex(\"Hello World\", 6) == \"World\");\n        Debug.Assert(CopySubstringFromIndex(\"Example\", 3) == \"mple\");\n        Debug.Assert(CopySubstringFromIndex(\"Short\", 10) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"AnotherExample\", 0) == \"AnotherExample\");\n        Debug.Assert(CopySubstringFromIndex(\"Test\", 4) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"\", 0) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"LastOne\", 7) == \"\");\n\n    }\n}",
    "entry_point": "CopySubstringFromIndex",
    "signature": "static string CopySubstringFromIndex(string input, int startIndex)",
    "docstring": {
      "es": "Copia una subcadena desde el índice de inicio especificado en la cadena de entrada hasta el final de la cadena.\n   Si el índice de inicio es mayor que la longitud de la cadena, devuelve una cadena vacía.\n   Ejemplos:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "arb": "ينسخ جزءًا من السلسلة النصية من الفهرس المحدد كبداية إلى نهاية السلسلة.\n   إذا كان الفهرس الابتدائي أكبر من طول السلسلة، يُرجع سلسلة فارغة.\n   أمثلة:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "sw": "Nakala sehemu ndogo kutoka kwa kiashiria cha mwanzo kilichobainishwa katika kamba ya ingizo hadi mwisho wa kamba.\n   Ikiwa kiashiria cha mwanzo ni kikubwa kuliko urefu wa kamba, inarudisha kamba tupu.\n   Mifano:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "tr": "Belirtilen başlangıç indeksinden itibaren giriş dizgesinin sonuna kadar olan alt dizgiyi kopyalar.\n   Başlangıç indeksi dizgenin uzunluğundan büyükse, boş bir dizge döndürür.\n   Örnekler:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "vi": "Sao chép một chuỗi con từ chỉ số bắt đầu được chỉ định trong chuỗi đầu vào đến cuối chuỗi. Nếu chỉ số bắt đầu lớn hơn độ dài của chuỗi, trả về một chuỗi rỗng. Ví dụ: >>> CopySubstringFromIndex(\"Hello World\", 6) \"World\" >>> CopySubstringFromIndex(\"Example\", 3) \"mple\" >>> CopySubstringFromIndex(\"Short\", 10) \"\""
    },
    "docstring_bertscore": {
      "es": "0.9865282916670708",
      "arb": "0.9418944560054832",
      "sw": "0.9761248268299875",
      "tr": "0.9778008699851599",
      "vi": "0.9797980984664657"
    }
  },
  {
    "task_id": "C#/8",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Convierte un número dado de segundos en una cadena de tiempo formateada sin ceros a la izquierda.\n    El formato de la salida es \"<Horas>:<Minutos>:<Segundos>\". Cada componente es un entero sin ceros a la izquierda.\n    Ejemplos:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* يحول عددًا معينًا من الثواني إلى سلسلة زمنية منسقة بدون أصفار بادئة.\n    صيغة الإخراج هي \"<الساعات>:<الدقائق>:<الثواني>\". كل مكون هو عدد صحيح بدون أصفار بادئة.\n    أمثلة:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hubadilisha idadi fulani ya sekunde kuwa kamba ya muda iliyopangwa bila sifuri za mwanzo.\n    Muundo wa matokeo ni \"<Saa>:<Dakika>:<Sekunde>\". Kila kipengele ni nambari bila sifuri za mwanzo.\n    Mifano:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Belirtilen saniye sayısını baştaki sıfırlar olmadan biçimlendirilmiş bir zaman dizgesine dönüştürür.\n    Çıktının formatı \"<Saatler>:<Dakikalar>:<Saniyeler>\" şeklindedir. Her bileşen baştaki sıfırlar olmadan bir tam sayıdır.\n    Örnekler:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Chuyển đổi một số giây đã cho thành một chuỗi thời gian định dạng mà không có số 0 đứng đầu.\n    Định dạng của đầu ra là \"<Giờ>:<Phút>:<Giây>\". Mỗi thành phần là một số nguyên không có số 0 đứng đầu.\n    Ví dụ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)"
    },
    "prompt_bertscore": {
      "es": "0.9919175311653093",
      "arb": "0.9859371676531109",
      "sw": "0.9767743481759715",
      "tr": "0.9864524148615155",
      "vi": "0.9897548435766015"
    },
    "canonical_solution": "{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}",
    "instruction": {
      "es": "Escribe una función en C# `static string FormatTime(int seconds)` para resolver el siguiente problema:\nConvierte un número dado de segundos en una cadena de tiempo formateada sin ceros a la izquierda.\n    El formato de la salida es \"<Horas>:<Minutos>:<Segundos>\". Cada componente es un entero sin ceros a la izquierda.\n    Ejemplos:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "arb": "اكتب دالة C# `static string FormatTime(int seconds)` لحل المشكلة التالية:\nتحويل عدد معين من الثواني إلى سلسلة زمنية منسقة بدون أصفار بادئة.\n    صيغة الإخراج هي \"<Hours>:<Minutes>:<Seconds>\". كل مكون هو عدد صحيح بدون أصفار بادئة.\n    أمثلة:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "sw": "Andika kazi ya C# `static string FormatTime(int seconds)` kutatua tatizo lifuatalo:\nInabadilisha idadi fulani ya sekunde kuwa kamba ya muda iliyopangwa bila sifuri za mwanzo.\n    Muundo wa matokeo ni \"<Saa>:<Dakika>:<Sekunde>\". Kila sehemu ni nambari bila sifuri za mwanzo.\n    Mifano:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "tr": "Bir C# fonksiyonu `static string FormatTime(int seconds)` yazın ve aşağıdaki problemi çözün:\nVerilen bir saniye sayısını, başında sıfır olmadan biçimlendirilmiş bir zaman dizgesine dönüştürür.\n    Çıktının formatı \"<Saatler>:<Dakikalar>:<Saniyeler>\" şeklindedir. Her bileşen başında sıfır olmadan bir tam sayıdır.\n    Örnekler:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "vi": "Viết một hàm C# `static string FormatTime(int seconds)` để giải quyết vấn đề sau:\nChuyển đổi một số giây cho trước thành một chuỗi thời gian định dạng mà không có số 0 đứng đầu.\n    Định dạng của đầu ra là \"<Hours>:<Minutes>:<Seconds>\". Mỗi thành phần là một số nguyên không có số 0 đứng đầu.\n    Ví dụ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\""
    },
    "instruction_bertscore": {
      "es": "0.9860094691118076",
      "arb": "0.9863387982835635",
      "sw": "0.9755777987606173",
      "tr": "0.982476231893959",
      "vi": "0.993703615551575"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(FormatTime(0) == \"0:0:0\");\n        Debug.Assert(FormatTime(3661) == \"1:1:1\");\n        Debug.Assert(FormatTime(5436) == \"1:30:36\");\n        Debug.Assert(FormatTime(3600) == \"1:0:0\");\n        Debug.Assert(FormatTime(7200) == \"2:0:0\");\n        Debug.Assert(FormatTime(86399) == \"23:59:59\");\n        Debug.Assert(FormatTime(12345) == \"3:25:45\");\n\n    }\n}",
    "entry_point": "FormatTime",
    "signature": "static string FormatTime(int seconds)",
    "docstring": {
      "es": "Convierte un número dado de segundos en una cadena de tiempo formateada sin ceros a la izquierda.\n    El formato de la salida es \"<Horas>:<Minutos>:<Segundos>\". Cada componente es un entero sin ceros a la izquierda.\n    Ejemplos:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "arb": "يقوم بتحويل عدد معين من الثواني إلى سلسلة زمنية منسقة بدون أصفار بادئة.\n    صيغة الإخراج هي \"<ساعات>:<دقائق>:<ثواني>\". كل مكون هو عدد صحيح بدون أصفار بادئة.\n    أمثلة:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "sw": "Hubadilisha idadi fulani ya sekunde kuwa kamba ya muda iliyopangwa bila sifuri za mwanzo.\n    Muundo wa matokeo ni \"<Saa>:<Dakika>:<Sekunde>\". Kila sehemu ni nambari bila sifuri za mwanzo.\n    Mifano:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "tr": "Verilen saniye sayısını, baştaki sıfırlar olmadan biçimlendirilmiş bir zaman dizgesine dönüştürür.\n    Çıktının formatı \"<Saatler>:<Dakikalar>:<Saniyeler>\" şeklindedir. Her bileşen baştaki sıfırlar olmadan bir tam sayıdır.\n    Örnekler:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "vi": "Chuyển đổi một số giây đã cho thành một chuỗi thời gian định dạng mà không có số 0 đứng đầu.\n    Định dạng của đầu ra là \"<Giờ>:<Phút>:<Giây>\". Mỗi thành phần là một số nguyên không có số 0 đứng đầu.\n    Ví dụ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\""
    },
    "docstring_bertscore": {
      "es": "0.9910989753650646",
      "arb": "0.9835569797971699",
      "sw": "0.965003114535082",
      "tr": "0.9890485139416414",
      "vi": "0.990418269049258"
    }
  },
  {
    "task_id": "C#/9",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Calcula el área de intersección entre dos rectángulos.\n   Cada rectángulo se define por las coordenadas de su esquina superior izquierda (x1, y1) y su esquina inferior derecha (x2, y2).\n   \n   Ejemplos:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Sin intersección)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* يحسب مساحة التقاطع بين مستطيلين.\n   يتم تعريف كل مستطيل بواسطة إحداثيات الزاوية العلوية اليسرى (x1, y1) والزاوية السفلية اليمنى (x2, y2).\n   \n   أمثلة:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (لا يوجد تقاطع)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Inakokotoa eneo la makutano kati ya mistatili miwili.\n   Kila mstatili umefafanuliwa na kuratibu za kona zake za juu-kushoto (x1, y1) na chini-kulia (x2, y2).\n   \n   Mifano:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Hakuna Makutano)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* İki dikdörtgen arasındaki kesişim alanını hesaplar.\n   Her dikdörtgen, sol üst (x1, y1) ve sağ alt (x2, y2) köşelerinin koordinatları ile tanımlanır.\n   \n   Örnekler:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Kesişim Yok)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Tính diện tích giao nhau giữa hai hình chữ nhật.\n   Mỗi hình chữ nhật được xác định bởi tọa độ của góc trên bên trái (x1, y1) và góc dưới bên phải (x2, y2).\n   \n   Ví dụ:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Không giao nhau)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)"
    },
    "prompt_bertscore": {
      "es": "0.9852367969295819",
      "arb": "0.982504040147304",
      "sw": "0.9908655846673486",
      "tr": "0.9946341988867236",
      "vi": "0.9815571691209106"
    },
    "canonical_solution": "{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` para resolver el siguiente problema:\nCalcula el área de intersección entre dos rectángulos.\n   Cada rectángulo está definido por las coordenadas de su esquina superior izquierda (x1, y1) y su esquina inferior derecha (x2, y2).\n   \n   Ejemplos:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Sin intersección)",
      "arb": "اكتب دالة C# `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` لحل المشكلة التالية:\nتحسب مساحة التقاطع بين مستطيلين.\nكل مستطيل يتم تعريفه بواسطة إحداثيات الزاوية العلوية اليسرى (x1, y1) والزاوية السفلية اليمنى (x2, y2).\n\nأمثلة:\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (لا يوجد تقاطع)",
      "sw": "Andika kazi ya C# `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` kutatua tatizo lifuatalo:\nInahesabu eneo la makutano kati ya mistatili miwili.\n   Kila mstatili unafafanuliwa na kuratibu za kona yake ya juu-kushoto (x1, y1) na kona ya chini-kulia (x2, y2).\n   \n   Mifano:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Hakuna Makutano)",
      "tr": "Bir C# fonksiyonu `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` yazın ve aşağıdaki problemi çözün:\nİki dikdörtgen arasındaki kesişim alanını hesaplar.\n   Her dikdörtgen, sol üst (x1, y1) ve sağ alt (x2, y2) köşelerinin koordinatları ile tanımlanır.\n   \n   Örnekler:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Kesişim Yok)",
      "vi": "Viết một hàm C# `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` để giải quyết vấn đề sau:\nTính diện tích giao nhau giữa hai hình chữ nhật.\n   Mỗi hình chữ nhật được xác định bởi tọa độ của góc trên bên trái (x1, y1) và góc dưới bên phải (x2, y2).\n   \n   Ví dụ:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Không có giao nhau)"
    },
    "instruction_bertscore": {
      "es": "0.9802074756817786",
      "arb": "0.9837913636467911",
      "sw": "0.9866967302301883",
      "tr": "0.9854052354926995",
      "vi": "0.9821097588409496"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5) - 2.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3) - 0.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(1, 1, 4, 4, 3, 3, 6, 6) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 3, 3, 1, 1, 2, 2) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(2, 2, 5, 5, 3, 3, 6, 6) - 4.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 2, 2, 3, 3, 5, 5) - 0.00) < 0.01);\n\n    }\n}",
    "entry_point": "CalculateIntersectionArea",
    "signature": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
    "docstring": {
      "es": "Calcula el área de intersección entre dos rectángulos.  \n   Cada rectángulo está definido por las coordenadas de su esquina superior izquierda (x1, y1) y esquina inferior derecha (x2, y2).\n\n   Ejemplos:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Sin intersección)",
      "arb": "يحسب مساحة التقاطع بين مستطيلين. يتم تعريف كل مستطيل بواسطة إحداثيات الزاوية العلوية اليسرى (x1, y1) والزاوية السفلية اليمنى (x2, y2).\n\nأمثلة:\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (لا يوجد تقاطع)",
      "sw": "Hesabu eneo la makutano kati ya mistatili miwili.  \n   Kila mstatili unafafanuliwa na kuratibu za kona zake za juu-kushoto (x1, y1) na chini-kulia (x2, y2).\n   \n   Mifano:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Hakuna Makutano)",
      "tr": "İki dikdörtgen arasındaki kesişim alanını hesaplar.  \n   Her dikdörtgen, sol üst (x1, y1) ve sağ alt (x2, y2) köşelerinin koordinatları ile tanımlanır.\n   \n   Örnekler:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Kesişim Yok)",
      "vi": "Tính diện tích giao nhau giữa hai hình chữ nhật.  \nMỗi hình chữ nhật được xác định bởi tọa độ của góc trên-trái (x1, y1) và góc dưới-phải (x2, y2).\n\nVí dụ:\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (Không có giao nhau)"
    },
    "docstring_bertscore": {
      "es": "0.9691544894987112",
      "arb": "0.9770776567678119",
      "sw": "0.9848945567830588",
      "tr": "0.9935474920720817",
      "vi": "0.9745288317183721"
    }
  },
  {
    "task_id": "C#/10",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Resuelve una ecuación lineal de la forma ax + b = 0.\n    La función devuelve la solución como un double con precisión de dos decimales.\n    Supone que 'a' no es cero.\n\n    Ejemplos:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    يحل معادلة خطية من الشكل ax + b = 0.\n    تُرجع الدالة الحل كعدد عشري بدقة تصل إلى منزلتين عشريتين.\n    يفترض أن 'a' ليست صفراً.\n\n    أمثلة:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Hutatua mlinganyo wa mstari wa fomu ax + b = 0.\n    Kazi inarudisha suluhisho kama namba ya desimali yenye usahihi wa sehemu mbili za desimali.\n    Inadhani kwamba 'a' si sifuri.\n\n    Mifano:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    ax + b = 0 formundaki bir doğrusal denklemi çözer.\n    Fonksiyon, çözümü iki ondalık basamak hassasiyetinde bir double olarak döndürür.\n    'a'nın sıfır olmadığını varsayar.\n\n    Örnekler:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Giải phương trình bậc nhất dạng ax + b = 0.\n    Hàm trả về nghiệm dưới dạng số thực với độ chính xác hai chữ số thập phân.\n    Giả sử rằng 'a' không bằng không.\n\n    Ví dụ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)"
    },
    "prompt_bertscore": {
      "es": "0.9913331605843048",
      "arb": "0.9640739216126009",
      "sw": "0.9769777456861513",
      "tr": "0.9837945417328876",
      "vi": "0.9729884531134466"
    },
    "canonical_solution": "{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}",
    "instruction": {
      "es": "Escribe una función en C# `static double SolveLinearEquation(double a, double b)` para resolver el siguiente problema:\nResuelve una ecuación lineal de la forma ax + b = 0.\n    La función devuelve la solución como un double con precisión de dos decimales.\n    Supone que 'a' no es cero.\n\n    Ejemplos:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "arb": "اكتب دالة C# `static double SolveLinearEquation(double a, double b)` لحل المشكلة التالية:\nتحل معادلة خطية من الشكل ax + b = 0.\n    تعيد الدالة الحل كعدد عشري بدقة تصل إلى منزلتين عشريتين.\n    تفترض أن 'a' ليس صفراً.\n\n    أمثلة:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "sw": "Andika kazi ya C# `static double SolveLinearEquation(double a, double b)` kutatua tatizo lifuatalo:  \nInatatua mlingano wa mstari wa fomu ax + b = 0.  \nKazi inarudisha suluhisho kama double na usahihi wa sehemu mbili za desimali.  \nInadhani kuwa 'a' si sifuri.\n\n    Mifano:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "tr": "Bir C# fonksiyonu `static double SolveLinearEquation(double a, double b)` yazın:\nax + b = 0 formundaki bir doğrusal denklemi çözer.\n    Fonksiyon, çözümü iki ondalık basamak hassasiyetinde bir double olarak döndürür.\n    'a'nın sıfır olmadığını varsayar.\n\n    Örnekler:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "vi": "Viết một hàm C# `static double SolveLinearEquation(double a, double b)` để giải quyết vấn đề sau:\nGiải phương trình tuyến tính dạng ax + b = 0.\n    Hàm trả về nghiệm dưới dạng số thực với độ chính xác hai chữ số thập phân.\n    Giả sử rằng 'a' không bằng không.\n\n    Ví dụ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00"
    },
    "instruction_bertscore": {
      "es": "0.9860438321677267",
      "arb": "0.967513802551363",
      "sw": "0.982168553433736",
      "tr": "0.9652460394910877",
      "vi": "0.9697773943736366"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(SolveLinearEquation(1, -3) == 3.00);\n        Debug.Assert(SolveLinearEquation(4, 8) == -2.00);\n        Debug.Assert(SolveLinearEquation(-2, 6) == 3.00);\n        Debug.Assert(SolveLinearEquation(3, -9) == 3.00);\n        Debug.Assert(SolveLinearEquation(0.5, -1.5) == 3.00);\n        Debug.Assert(SolveLinearEquation(-5, 10) == 2.00);\n        Debug.Assert(SolveLinearEquation(10, -20) == 2.00);\n\n    }\n}",
    "entry_point": "SolveLinearEquation",
    "signature": "static double SolveLinearEquation(double a, double b)",
    "docstring": {
      "es": "Resuelve una ecuación lineal de la forma ax + b = 0.\n    La función devuelve la solución como un número de tipo double con precisión de dos decimales.\n    Supone que 'a' no es cero.\n\n    Ejemplos:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "arb": "يحل معادلة خطية من الشكل ax + b = 0.  \nتُرجع الدالة الحل كعدد عشري بدقة تصل إلى منزلتين عشريتين.  \nتفترض أن 'a' ليست صفرًا.\n\nأمثلة:\n>>> SolveLinearEquation(2, -4)\n2.00\n>>> SolveLinearEquation(5, 10)\n-2.00",
      "sw": "Hutatua mlinganyo wa mstari wa fomu ax + b = 0.  \n    Kazi inarudisha suluhisho kama namba ya desimali yenye usahihi wa sehemu mbili za desimali.  \n    Inadhani kwamba 'a' si sifuri.\n\n    Mifano:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "tr": "ax + b = 0 biçimindeki bir lineer denklemi çözer. \n    Fonksiyon, çözümü iki ondalık basamak hassasiyetinde bir double olarak döndürür. \n    'a'nın sıfır olmadığını varsayar.\n\n    Örnekler:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "vi": "Giải một phương trình tuyến tính có dạng ax + b = 0. Hàm trả về nghiệm dưới dạng số thực với độ chính xác hai chữ số thập phân. Giả sử rằng 'a' không bằng không.\n\n    Ví dụ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00"
    },
    "docstring_bertscore": {
      "es": "0.9760461691990977",
      "arb": "0.9642274628971408",
      "sw": "0.9658782799939217",
      "tr": "0.9486572245885779",
      "vi": "0.9676629739675202"
    }
  },
  {
    "task_id": "C#/11",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Calcula el número total de vacas después de un número dado de años, siguiendo la regla de que cada vaca da a luz a otra vaca cada año a partir de su cuarto año.\n    Casos de ejemplo:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* يحسب العدد الإجمالي للأبقار بعد عدد معين من السنوات، وفقًا للقاعدة التي تنص على أن كل بقرة تلد بقرة أخرى كل عام بدءًا من عامها الرابع.\n    أمثلة الحالات:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Inahesabu jumla ya ng'ombe baada ya miaka fulani, kufuatia kanuni kwamba kila ng'ombe anazaa ng'ombe mwingine kila mwaka kuanzia mwaka wake wa nne.\n    Mifano ya kesi:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Belirli bir yıl sayısından sonra toplam inek sayısını hesaplar, her ineğin dördüncü yılından itibaren her yıl başka bir inek doğurduğu kuralını takip eder.\n    Örnek durumlar:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Tính tổng số bò sau một số năm nhất định, theo quy tắc rằng mỗi con bò sinh ra một con bò khác mỗi năm kể từ năm thứ tư của nó.\n    Các trường hợp ví dụ:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)"
    },
    "prompt_bertscore": {
      "es": "0.9946989523909409",
      "arb": "0.9835712811846044",
      "sw": "0.98937069241968",
      "tr": "0.98937069241968",
      "vi": "0.9823783071161089"
    },
    "canonical_solution": "{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int TotalCows(int years)` para resolver el siguiente problema:\nCalcula el número total de vacas después de un número dado de años, siguiendo la regla de que cada vaca da a luz a otra vaca cada año a partir de su cuarto año.\n    Casos de ejemplo:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "arb": "اكتب دالة C# `static int TotalCows(int years)` لحل المشكلة التالية:\nتحسب العدد الإجمالي للأبقار بعد عدد معين من السنوات، وفقًا للقاعدة التي تنص على أن كل بقرة تلد بقرة أخرى كل عام بدءًا من عامها الرابع.\n    أمثلة الحالات:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "sw": "Andika kazi ya C# `static int TotalCows(int years)` kutatua tatizo lifuatalo:\nHesabu jumla ya idadi ya ng'ombe baada ya miaka fulani, kufuatia kanuni kwamba kila ng'ombe huzaa ng'ombe mwingine kila mwaka kuanzia mwaka wake wa nne.\n    Mifano ya kesi:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "tr": "C# dilinde `static int TotalCows(int years)` fonksiyonunu aşağıdaki problemi çözmek için yazın:\nHer ineğin dördüncü yılından itibaren her yıl başka bir inek doğurduğu kuralını takip ederek, belirli bir yıl sayısından sonra toplam inek sayısını hesaplar.\n    Örnek durumlar:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "vi": "Viết một hàm C# `static int TotalCows(int years)` để giải quyết vấn đề sau:  \nTính tổng số bò sau một số năm cho trước, theo quy tắc rằng mỗi con bò sinh ra một con bò khác mỗi năm từ năm thứ tư của nó.  \n    Các trường hợp ví dụ:  \n    >>> TotalCows(1)  \n    1  \n    >>> TotalCows(4)  \n    2  \n    >>> TotalCows(5)  \n    3  \n    >>> TotalCows(6)  \n    4  "
    },
    "instruction_bertscore": {
      "es": "0.981968929900796",
      "arb": "0.9797255983773879",
      "sw": "0.9773183967896261",
      "tr": "0.9705504638166244",
      "vi": "0.9926737170259092"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(TotalCows(1) == 1);\n        Debug.Assert(TotalCows(2) == 1);\n        Debug.Assert(TotalCows(3) == 1);\n        Debug.Assert(TotalCows(4) == 2);\n        Debug.Assert(TotalCows(5) == 3);\n        Debug.Assert(TotalCows(6) == 4);\n        Debug.Assert(TotalCows(7) == 6);\n        Debug.Assert(TotalCows(8) == 9);\n        Debug.Assert(TotalCows(10) == 19);\n    }\n}\n",
    "entry_point": "TotalCows",
    "signature": "static int TotalCows(int years)",
    "docstring": {
      "es": "Calcula el número total de vacas después de un número dado de años, siguiendo la regla de que cada vaca da a luz a otra vaca cada año a partir de su cuarto año.\n    Casos de ejemplo:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "arb": "يحسب العدد الإجمالي للأبقار بعد عدد معين من السنوات، وفقًا للقاعدة التي تنص على أن كل بقرة تلد بقرة أخرى كل عام من عامها الرابع.\n    حالات المثال:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "sw": "Hesabu jumla ya idadi ya ng'ombe baada ya miaka fulani, kufuatia kanuni kwamba kila ng'ombe anazaa ng'ombe mwingine kila mwaka kuanzia mwaka wake wa nne.\n    Mifano ya kesi:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "tr": "Verilen bir yıl sayısından sonra toplam inek sayısını hesaplar, her ineğin dördüncü yılından itibaren her yıl başka bir inek doğurduğu kuralını takip eder.\n    Örnek durumlar:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "vi": "Tính tổng số bò sau một số năm nhất định, theo quy tắc rằng mỗi con bò sinh ra một con bò khác mỗi năm từ năm thứ tư của nó.\n    Các trường hợp ví dụ:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4"
    },
    "docstring_bertscore": {
      "es": "0.9863707777749101",
      "arb": "0.9799440917965263",
      "sw": "0.9722306782097985",
      "tr": "0.9912364275887408",
      "vi": "0.9761385323262789"
    }
  },
  {
    "task_id": "C#/12",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Esta función cuenta cuántas manzanas son alcanzables.\n    Toma una lista de enteros que representan las alturas de las manzanas desde el suelo y un entero que representa la altura máxima que se puede alcanzar (con o sin un taburete).\n    Se considera que una manzana es alcanzable si su altura es menor o igual a la altura máxima alcanzable.\n    Ejemplo:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* هذه الدالة تحسب عدد التفاحات التي يمكن الوصول إليها.\n    تأخذ قائمة من الأعداد الصحيحة تمثل ارتفاعات التفاحات من الأرض وعدد صحيح يمثل أقصى ارتفاع يمكن الوصول إليه (مع أو بدون كرسي).\n    تعتبر التفاحة قابلة للوصول إذا كان ارتفاعها أقل من أو يساوي أقصى ارتفاع يمكن الوصول إليه.\n    مثال:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kazi ya hii kazi ni kuhesabu ni tufaha ngapi zinaweza kufikiwa.\n    Inachukua orodha ya namba nzima zinazowakilisha urefu wa tufaha kutoka ardhini na namba nzima inayowakilisha urefu wa juu zaidi unaoweza kufikiwa (kwa kutumia kigoda au bila).\n    Tufaha inachukuliwa kuwa inaweza kufikiwa ikiwa urefu wake ni chini au sawa na urefu wa juu zaidi unaoweza kufikiwa.\n    Mfano:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bu fonksiyon ulaşılabilir elma sayısını sayar.\n    Yerden elma yüksekliklerini temsil eden bir tamsayı listesi ve ulaşılabilecek maksimum yüksekliği temsil eden bir tamsayı alır (tabureli veya taburesiz).\n    Bir elma, yüksekliği ulaşılabilir maksimum yüksekliğe eşit veya daha az ise ulaşılabilir kabul edilir.\n    Örnek:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hàm này đếm có bao nhiêu quả táo có thể với tới được.\n    Nó nhận vào một danh sách các số nguyên đại diện cho độ cao của các quả táo từ mặt đất và một số nguyên đại diện cho độ cao tối đa có thể với tới (có hoặc không có ghế).\n    Một quả táo được coi là có thể với tới nếu độ cao của nó nhỏ hơn hoặc bằng độ cao tối đa có thể với tới.\n    Ví dụ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)"
    },
    "prompt_bertscore": {
      "es": "0.9971123115205148",
      "arb": "0.9818874914445717",
      "sw": "0.9709606355534615",
      "tr": "0.9784309255538025",
      "vi": "0.9839409323237103"
    },
    "canonical_solution": "{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` para resolver el siguiente problema:\nEsta función cuenta cuántas manzanas son alcanzables.\n    Toma una lista de enteros que representan las alturas de las manzanas desde el suelo y un entero que representa la altura máxima que se puede alcanzar (con o sin un taburete).\n    Se considera que una manzana es alcanzable si su altura es menor o igual a la altura máxima alcanzable.\n    Ejemplo:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "arb": "اكتب دالة C# `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` لحل المشكلة التالية:\nهذه الدالة تحسب عدد التفاحات التي يمكن الوصول إليها.\nتأخذ قائمة من الأعداد الصحيحة التي تمثل ارتفاعات التفاحات من الأرض وعددًا صحيحًا يمثل أقصى ارتفاع يمكن الوصول إليه (مع أو بدون كرسي).\nتعتبر التفاحة قابلة للوصول إذا كان ارتفاعها أقل من أو يساوي أقصى ارتفاع يمكن الوصول إليه.\nمثال:\n>>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n3\n>>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n2",
      "sw": "Andika kazi ya C# `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` kutatua tatizo lifuatalo:\nKazi hii inahesabu ni tufaha ngapi zinaweza kufikiwa.\n    Inachukua orodha ya namba nzima inayowakilisha urefu wa tufaha kutoka ardhini na namba nzima inayowakilisha urefu wa juu zaidi unaoweza kufikiwa (kwa kutumia kiti au bila).\n    Tufaha inachukuliwa kuwa inaweza kufikiwa ikiwa urefu wake ni mdogo au sawa na urefu wa juu zaidi unaoweza kufikiwa.\n    Mfano:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "tr": "Bir C# fonksiyonu `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` yazın:\nBu fonksiyon kaç elmanın ulaşılabilir olduğunu sayar.\n    Yerden elmaların yüksekliklerini temsil eden bir tamsayı listesi ve ulaşılabilecek maksimum yüksekliği temsil eden bir tamsayı alır (tabureli veya taburesiz).\n    Bir elma, yüksekliği maksimum ulaşılabilir yüksekliğe eşit veya daha az ise ulaşılabilir kabul edilir.\n    Örnek:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "vi": "Viết một hàm C# `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` để giải quyết vấn đề sau:\nHàm này đếm có bao nhiêu quả táo có thể với tới được.\nNó nhận một danh sách các số nguyên đại diện cho độ cao của các quả táo từ mặt đất và một số nguyên đại diện cho độ cao tối đa có thể với tới (có hoặc không có ghế đẩu).\nMột quả táo được coi là có thể với tới nếu độ cao của nó nhỏ hơn hoặc bằng độ cao tối đa có thể với tới.\nVí dụ:\n>>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n3\n>>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n2"
    },
    "instruction_bertscore": {
      "es": "0.9915548320895397",
      "arb": "0.9813980661857017",
      "sw": "0.9764263477483984",
      "tr": "0.9702392100095427",
      "vi": "0.9865960246270037"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountReachableApples(new List<int> {150, 190, 300, 210, 220}, 200) == 2);\n        Debug.Assert(CountReachableApples(new List<int> {120, 180, 260, 310, 150}, 250) == 3);\n        Debug.Assert(CountReachableApples(new List<int> {100, 200, 300, 400, 500}, 350) == 3);\n\n    }\n}",
    "entry_point": "CountReachableApples",
    "signature": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
    "docstring": {
      "es": "Esta función cuenta cuántas manzanas son alcanzables.\n    Toma una lista de enteros que representa las alturas de las manzanas desde el suelo y un entero que representa la altura máxima que se puede alcanzar (con o sin un taburete).\n    Se considera que una manzana es alcanzable si su altura es menor o igual a la altura máxima alcanzable.\n    Ejemplo:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "arb": "هذه الدالة تحسب عدد التفاحات التي يمكن الوصول إليها.\n    تأخذ قائمة من الأعداد الصحيحة التي تمثل ارتفاعات التفاحات من الأرض وعدد صحيح يمثل أقصى ارتفاع يمكن الوصول إليه (مع أو بدون كرسي).\n    تعتبر التفاحة قابلة للوصول إذا كان ارتفاعها أقل من أو يساوي أقصى ارتفاع يمكن الوصول إليه.\n    مثال:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "sw": "Kazi ya hii kazi ni kuhesabu ni maapulo mangapi yanaweza kufikiwa.\nInachukua orodha ya namba nzima inayowakilisha urefu wa maapulo kutoka ardhini na namba nzima inayowakilisha urefu wa juu kabisa unaoweza kufikiwa (kwa kutumia kiti au bila).\nTufaha linachukuliwa kuwa linaweza kufikiwa ikiwa urefu wake ni sawa au chini ya urefu wa juu kabisa unaoweza kufikiwa.\nMfano:\n>>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n3\n>>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n2",
      "tr": "Bu fonksiyon, ulaşılabilir kaç elma olduğunu sayar.\n    Yerden elmaların yüksekliklerini temsil eden bir tamsayı listesi ve ulaşılabilecek maksimum yüksekliği temsil eden bir tamsayı alır (tabure ile veya taburesiz).\n    Bir elma, yüksekliği ulaşılabilir maksimum yüksekliğe eşit veya daha az ise ulaşılabilir kabul edilir.\n    Örnek:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "vi": "Hàm này đếm có bao nhiêu quả táo có thể với tới được.\n    Nó nhận một danh sách các số nguyên đại diện cho độ cao của các quả táo từ mặt đất và một số nguyên đại diện cho độ cao tối đa có thể với tới (có hoặc không có ghế đẩu).\n    Một quả táo được coi là có thể với tới nếu độ cao của nó nhỏ hơn hoặc bằng độ cao tối đa có thể với tới.\n    Ví dụ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9967079000647278",
      "arb": "0.979264577263006",
      "sw": "0.9467267359152999",
      "tr": "0.9830540476723896",
      "vi": "0.9864456614285603"
    }
  },
  {
    "task_id": "C#/13",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Calcula el valor total máximo de hierbas que se pueden recolectar dentro de un tiempo dado.\n    La función toma el tiempo total disponible para recolectar hierbas, el número de diferentes hierbas,\n    un arreglo de costos de tiempo para cada hierba, y un arreglo de valores para cada hierba.\n\n    Parámetros:\n    totalMinutes - el tiempo total disponible para recolectar hierbas.\n    herbCount - el número de diferentes hierbas disponibles.\n    timeCosts - un arreglo donde timeCosts[i] representa el tiempo requerido para recolectar la i-ésima hierba.\n    values - un arreglo donde values[i] representa el valor de la i-ésima hierba.\n\n    Retorna:\n    El valor total máximo de las hierbas que se pueden recolectar dentro del tiempo dado.\n\n    Ejemplos:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    يحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها في وقت معين.\n    تأخذ الدالة الوقت الإجمالي المتاح لجمع الأعشاب، وعدد الأعشاب المختلفة،\n    ومصفوفة تكاليف الوقت لكل عشب، ومصفوفة القيم لكل عشب.\n\n    المعلمات:\n    totalMinutes - الوقت الإجمالي المتاح لجمع الأعشاب.\n    herbCount - عدد الأعشاب المختلفة المتاحة.\n    timeCosts - مصفوفة حيث timeCosts[i] تمثل الوقت المطلوب لجمع العشب i.\n    values - مصفوفة حيث values[i] تمثل قيمة العشب i.\n\n    يعيد:\n    القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها في الوقت المحدد.\n\n    أمثلة:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Inahesabu thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\n    Kazi hii inachukua muda wote unaopatikana kwa ajili ya kukusanya mimea, idadi ya mimea tofauti,\n    safu ya gharama za muda kwa kila mmea, na safu ya thamani kwa kila mmea.\n\n    Vigezo:\n    totalMinutes - muda wote unaopatikana kwa ajili ya kukusanya mimea.\n    herbCount - idadi ya mimea tofauti inayopatikana.\n    timeCosts - safu ambapo timeCosts[i] inawakilisha muda unaohitajika kukusanya mmea wa i.\n    values - safu ambapo values[i] inawakilisha thamani ya mmea wa i.\n\n    Inarudisha:\n    Thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\n\n    Mifano:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Belirli bir süre içinde toplanabilecek otların maksimum toplam değerini hesaplar.\n    Fonksiyon, ot toplamak için mevcut toplam süreyi, farklı otların sayısını,\n    her bir ot için zaman maliyetlerini içeren bir dizi ve her bir ot için değerleri içeren bir dizi alır.\n\n    Parametreler:\n    totalMinutes - ot toplamak için mevcut toplam süre.\n    herbCount - mevcut farklı otların sayısı.\n    timeCosts - timeCosts[i], i'inci otu toplamak için gereken zamanı temsil eden bir dizidir.\n    values - values[i], i'inci otun değerini temsil eden bir dizidir.\n\n    Döndürür:\n    Belirtilen süre içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Tính toán giá trị tối đa của các loại thảo mộc có thể thu thập trong một khoảng thời gian nhất định.\n    Hàm nhận tổng thời gian có sẵn để thu thập thảo mộc, số lượng các loại thảo mộc khác nhau,\n    một mảng chi phí thời gian cho mỗi loại thảo mộc, và một mảng giá trị cho mỗi loại thảo mộc.\n\n    Tham số:\n    totalMinutes - tổng thời gian có sẵn để thu thập thảo mộc.\n    herbCount - số lượng các loại thảo mộc khác nhau có sẵn.\n    timeCosts - một mảng mà timeCosts[i] đại diện cho thời gian cần thiết để thu thập loại thảo mộc thứ i.\n    values - một mảng mà values[i] đại diện cho giá trị của loại thảo mộc thứ i.\n\n    Trả về:\n    Giá trị tổng tối đa của các loại thảo mộc có thể thu thập trong thời gian cho phép.\n\n    Ví dụ:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)"
    },
    "prompt_bertscore": {
      "es": "0.9981992169655377",
      "arb": "0.9691427703062301",
      "sw": "0.9712816222492138",
      "tr": "0.9767844783254044",
      "vi": "0.9651481147132375"
    },
    "canonical_solution": "{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` para resolver el siguiente problema:\nCalcula el valor total máximo de hierbas que se pueden recolectar dentro de un tiempo dado.\n    La función toma el tiempo total disponible para recolectar hierbas, el número de diferentes hierbas,\n    un arreglo de costos de tiempo para cada hierba, y un arreglo de valores para cada hierba.\n\n    Parámetros:\n    totalMinutes - el tiempo total disponible para recolectar hierbas.\n    herbCount - el número de diferentes hierbas disponibles.\n    timeCosts - un arreglo donde timeCosts[i] representa el tiempo requerido para recolectar la i-ésima hierba.\n    values - un arreglo donde values[i] representa el valor de la i-ésima hierba.\n\n    Devuelve:\n    El valor total máximo de las hierbas que se pueden recolectar dentro del tiempo dado.\n\n    Ejemplos:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "arb": "اكتب دالة C# `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` لحل المشكلة التالية:\nتحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها في غضون وقت معين.\nتأخذ الدالة الوقت الإجمالي المتاح لجمع الأعشاب، وعدد الأعشاب المختلفة،\nومصفوفة تكاليف الوقت لكل عشب، ومصفوفة القيم لكل عشب.\n\nالمعطيات:\ntotalMinutes - الوقت الإجمالي المتاح لجمع الأعشاب.\nherbCount - عدد الأعشاب المختلفة المتاحة.\ntimeCosts - مصفوفة حيث timeCosts[i] تمثل الوقت المطلوب لجمع العشب i.\nvalues - مصفوفة حيث values[i] تمثل قيمة العشب i.\n\nالإرجاع:\nالقيمة الإجمالية القصوى للأعشاب التي يمكن جمعها في الوقت المعطى.\n\nأمثلة:\n>>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n550\n>>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n450",
      "sw": "Andika kazi ya C# `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` kutatua tatizo lifuatalo:\nHesabu thamani ya juu kabisa ya jumla ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\nKazi inachukua muda wote unaopatikana kwa ajili ya kukusanya mimea, idadi ya mimea tofauti,\norodha ya gharama za muda kwa kila mmea, na orodha ya thamani kwa kila mmea.\n\nVigezo:\ntotalMinutes - muda wote unaopatikana kwa ajili ya kukusanya mimea.\nherbCount - idadi ya mimea tofauti inayopatikana.\ntimeCosts - orodha ambapo timeCosts[i] inawakilisha muda unaohitajika kukusanya mmea wa i-th.\nvalues - orodha ambapo values[i] inawakilisha thamani ya mmea wa i-th.\n\nInarudisha:\nThamani ya juu kabisa ya jumla ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\n\nMifano:\n>>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n550\n>>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n450",
      "tr": "Bir C# fonksiyonu `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` yazın ve aşağıdaki problemi çözün:\nVerilen bir zaman dilimi içinde toplanabilecek otların maksimum toplam değerini hesaplar.\n    Fonksiyon, ot toplamak için mevcut toplam zamanı, farklı otların sayısını,\n    her ot için zaman maliyetlerini içeren bir dizi ve her otun değerlerini içeren bir dizi alır.\n\n    Parametreler:\n    totalMinutes - ot toplamak için mevcut toplam zaman.\n    herbCount - mevcut farklı otların sayısı.\n    timeCosts - timeCosts[i], i. otu toplamak için gereken zamanı temsil eden bir dizi.\n    values - values[i], i. otun değerini temsil eden bir dizi.\n\n    Döndürür:\n    Verilen zaman içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "vi": "Viết một hàm C# `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` để giải quyết vấn đề sau:\nTính toán tổng giá trị tối đa của các loại thảo mộc có thể thu thập trong một khoảng thời gian nhất định.\nHàm nhận tổng thời gian có sẵn để thu thập thảo mộc, số lượng các loại thảo mộc khác nhau,\nmột mảng chi phí thời gian cho mỗi loại thảo mộc, và một mảng giá trị cho mỗi loại thảo mộc.\n\nCác tham số:\ntotalMinutes - tổng thời gian có sẵn để thu thập thảo mộc.\nherbCount - số lượng các loại thảo mộc khác nhau có sẵn.\ntimeCosts - một mảng trong đó timeCosts[i] đại diện cho thời gian cần thiết để thu thập loại thảo mộc thứ i.\nvalues - một mảng trong đó values[i] đại diện cho giá trị của loại thảo mộc thứ i.\n\nTrả về:\nTổng giá trị tối đa của các loại thảo mộc có thể thu thập trong thời gian cho phép.\n\nVí dụ:\n>>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n550\n>>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n450"
    },
    "instruction_bertscore": {
      "es": "0.9900722549254952",
      "arb": "0.9630692491453263",
      "sw": "0.9853371052720046",
      "tr": "0.9803044073077236",
      "vi": "0.9656351564075351"
    },
    "level": "middle",
    "test": "static void Main()\n    {\n        Debug.Assert(MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350}) == 650);\n        Debug.Assert(MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300}) == 450);\n        Debug.Assert(MaxHerbValue(7, 3, new int[] {2, 3, 5}, new int[] {100, 200, 300}) == 400);\n        Debug.Assert(MaxHerbValue(12, 4, new int[] {2, 4, 6, 3}, new int[] {100, 200, 300, 150}) == 600);\n        Debug.Assert(MaxHerbValue(8, 3, new int[] {1, 3, 4}, new int[] {150, 250, 350}) == 750);\n        Debug.Assert(MaxHerbValue(15, 5, new int[] {3, 5, 7, 4, 2}, new int[] {120, 280, 350, 220, 180}) == 810);\n\n\n    }\n}",
    "entry_point": "MaxHerbValue",
    "signature": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
    "docstring": {
      "es": "Calcula el valor total máximo de hierbas que se pueden recolectar dentro de un tiempo dado. La función toma el tiempo total disponible para recolectar hierbas, el número de diferentes hierbas, un arreglo de costos de tiempo para cada hierba y un arreglo de valores para cada hierba.\n\n    Parámetros:\n    totalMinutes - el tiempo total disponible para recolectar hierbas.\n    herbCount - el número de diferentes hierbas disponibles.\n    timeCosts - un arreglo donde timeCosts[i] representa el tiempo requerido para recolectar la i-ésima hierba.\n    values - un arreglo donde values[i] representa el valor de la i-ésima hierba.\n\n    Devuelve:\n    El valor total máximo de las hierbas que se pueden recolectar dentro del tiempo dado.\n\n    Ejemplos:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "arb": "يحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها في وقت معين.\n    تأخذ الدالة الوقت الإجمالي المتاح لجمع الأعشاب، وعدد الأعشاب المختلفة،\n    ومصفوفة تكاليف الوقت لكل عشب، ومصفوفة القيم لكل عشب.\n\n    Args:\n    totalMinutes - الوقت الإجمالي المتاح لجمع الأعشاب.\n    herbCount - عدد الأعشاب المختلفة المتاحة.\n    timeCosts - مصفوفة حيث timeCosts[i] تمثل الوقت المطلوب لجمع العشب i.\n    values - مصفوفة حيث values[i] تمثل قيمة العشب i.\n\n    Returns:\n    القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها في الوقت المحدد.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "sw": "Hesabu thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa. \n    Kazi hii inachukua muda wote unaopatikana kwa ajili ya kukusanya mimea, idadi ya mimea tofauti, \n    safu ya gharama za muda kwa kila mmea, na safu ya thamani za kila mmea.\n\n    Vigezo:\n    totalMinutes - muda wote unaopatikana kwa ajili ya kukusanya mimea.\n    herbCount - idadi ya mimea tofauti inayopatikana.\n    timeCosts - safu ambapo timeCosts[i] inawakilisha muda unaohitajika kukusanya mmea wa i.\n    values - safu ambapo values[i] inawakilisha thamani ya mmea wa i.\n\n    Inarejesha:\n    Thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\n\n    Mifano:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "tr": "Toplanabilecek otların maksimum toplam değerini verilen süre içinde hesaplar. \n    Fonksiyon, ot toplamak için mevcut toplam süreyi, farklı otların sayısını,\n    her ot için zaman maliyetlerinin bir dizisini ve her otun değerlerinin bir dizisini alır.\n\n    Parametreler:\n    totalMinutes - ot toplamak için mevcut toplam süre.\n    herbCount - mevcut farklı otların sayısı.\n    timeCosts - timeCosts[i], i. otu toplamak için gereken süreyi temsil eden bir dizi.\n    values - values[i], i. otun değerini temsil eden bir dizi.\n\n    Döndürür:\n    Verilen süre içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "vi": "Tính toán giá trị tối đa của các loại thảo mộc có thể thu thập trong một khoảng thời gian nhất định. \n    Hàm này nhận tổng thời gian có sẵn để thu thập thảo mộc, số lượng các loại thảo mộc khác nhau, \n    một mảng chi phí thời gian cho mỗi loại thảo mộc, và một mảng giá trị cho mỗi loại thảo mộc.\n\n    Tham số:\n    totalMinutes - tổng thời gian có sẵn để thu thập thảo mộc.\n    herbCount - số lượng các loại thảo mộc khác nhau có sẵn.\n    timeCosts - một mảng trong đó timeCosts[i] đại diện cho thời gian cần thiết để thu thập loại thảo mộc thứ i.\n    values - một mảng trong đó values[i] đại diện cho giá trị của loại thảo mộc thứ i.\n\n    Trả về:\n    Giá trị tổng tối đa của các loại thảo mộc có thể thu thập trong thời gian đã cho.\n\n    Ví dụ:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450"
    },
    "docstring_bertscore": {
      "es": "0.995383035423225",
      "arb": "0.9605593556505695",
      "sw": "0.9662177393151103",
      "tr": "0.9773805680988901",
      "vi": "0.9641366888130078"
    }
  },
  {
    "task_id": "C#/14",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Esta función toma una lista de enteros y realiza dos operaciones. En primer lugar, elimina cualquier número duplicado, asegurando que cada número sea único. En segundo lugar, ordena los números restantes en orden ascendente.\n    Ejemplo de uso:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    تأخذ هذه الدالة قائمة من الأعداد الصحيحة وتقوم بعمليتين. أولاً، تزيل أي أرقام مكررة، مما يضمن أن كل رقم فريد. ثانياً، تقوم بترتيب الأرقام المتبقية بترتيب تصاعدي.\n    مثال على الاستخدام:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Kazi hii inachukua orodha ya nambari za mzima na inafanya shughuli mbili. Kwanza, inaondoa nambari zozote zinazojirudia, kuhakikisha kila nambari ni ya kipekee. Pili, inapanga nambari zilizobaki kwa mpangilio wa kuongezeka.\n    Mfano wa matumizi:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Bu fonksiyon bir tamsayı listesini alır ve iki işlem gerçekleştirir. İlk olarak, her sayının benzersiz olmasını sağlayarak yinelenen sayıları kaldırır. İkinci olarak, kalan sayıları artan sırayla sıralar.\n    Örnek kullanım:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Hàm này nhận một danh sách các số nguyên và thực hiện hai thao tác. Thứ nhất, nó loại bỏ bất kỳ số trùng lặp nào, đảm bảo mỗi số là duy nhất. Thứ hai, nó sắp xếp các số còn lại theo thứ tự tăng dần.\n    Ví dụ sử dụng:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)"
    },
    "prompt_bertscore": {
      "es": "0.9869527647913423",
      "arb": "0.9876124162867592",
      "sw": "0.9904172758973528",
      "tr": "0.9899987616845124",
      "vi": "0.9938416636663944"
    },
    "canonical_solution": "{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static List<int> UniqueAndSorted(List<int> numbers)` para resolver el siguiente problema:\nEsta función toma una lista de enteros y realiza dos operaciones. En primer lugar, elimina cualquier número duplicado, asegurando que cada número sea único. En segundo lugar, ordena los números restantes en orden ascendente.\n    Ejemplo de uso:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "arb": "اكتب دالة C# `static List<int> UniqueAndSorted(List<int> numbers)` لحل المشكلة التالية:\nتأخذ هذه الدالة قائمة من الأعداد الصحيحة وتقوم بعمليتين. أولاً، تزيل أي أرقام مكررة، مما يضمن أن كل رقم فريد. ثانياً، ترتب الأرقام المتبقية بترتيب تصاعدي.\n    مثال على الاستخدام:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "sw": "Andika kazi ya C# `static List<int> UniqueAndSorted(List<int> numbers)` kutatua tatizo lifuatalo:\nKazi hii inachukua orodha ya nambari za mzima na inafanya shughuli mbili. Kwanza, inaondoa nambari zozote zinazojirudia, kuhakikisha kila nambari ni ya kipekee. Pili, inapanga nambari zilizobaki kwa mpangilio wa kupanda.\n    Mfano wa matumizi:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "tr": "C# dilinde `static List<int> UniqueAndSorted(List<int> numbers)` fonksiyonunu yazın ve aşağıdaki problemi çözün:\nBu fonksiyon bir tamsayı listesini alır ve iki işlem gerçekleştirir. İlk olarak, her sayının benzersiz olmasını sağlayarak yinelenen sayıları kaldırır. İkinci olarak, kalan sayıları artan sırayla sıralar.\n    Örnek kullanım:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "vi": "Viết một hàm C# `static List<int> UniqueAndSorted(List<int> numbers)` để giải quyết vấn đề sau:\nHàm này nhận một danh sách các số nguyên và thực hiện hai thao tác. Thứ nhất, nó loại bỏ bất kỳ số trùng lặp nào, đảm bảo mỗi số là duy nhất. Thứ hai, nó sắp xếp các số còn lại theo thứ tự tăng dần.\n    Ví dụ sử dụng:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]"
    },
    "instruction_bertscore": {
      "es": "0.9862885447971617",
      "arb": "0.9978269836314784",
      "sw": "0.9978269836314784",
      "tr": "0.9841596243732298",
      "vi": "0.9978269836314784"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n        Debug.Assert(UniqueAndSorted(new List<int> { 3, 1, 2, 1 }) .SequenceEqual(new List<int> { 1, 2, 3 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 5, 4, 5, 4, 5 }) .SequenceEqual(new List<int> { 4, 5 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 8, 7, 9, 6, 10 }) .SequenceEqual(new List<int> { 6, 7, 8, 9, 10 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 11, 11, 11 }) .SequenceEqual(new List<int> { 11 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 15, 14, 13, 12, 11, 15, 14 }) .SequenceEqual(new List<int> { 11, 12, 13, 14, 15 }));\n\n    }\n}",
    "entry_point": "UniqueAndSorted",
    "signature": "static List<int> UniqueAndSorted(List<int> numbers)",
    "docstring": {
      "es": "Esta función toma una lista de enteros y realiza dos operaciones. En primer lugar, elimina cualquier número duplicado, asegurando que cada número sea único. En segundo lugar, ordena los números restantes en orden ascendente.\n    Ejemplo de uso:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "arb": "هذه الدالة تأخذ قائمة من الأعداد الصحيحة وتقوم بعمليتين. أولاً، تزيل أي أرقام مكررة، مما يضمن أن كل رقم يكون فريداً. ثانياً، تقوم بترتيب الأرقام المتبقية بترتيب تصاعدي.\n    مثال على الاستخدام:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "sw": "Kazi hii inachukua orodha ya nambari za mzima na inafanya shughuli mbili. Kwanza, inaondoa nambari zozote zinazojirudia, kuhakikisha kila nambari ni ya kipekee. Pili, inapanga nambari zilizobaki kwa mpangilio wa kupanda.\nKazi ya mfano:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "tr": "Bu fonksiyon bir tamsayı listesini alır ve iki işlem gerçekleştirir. İlk olarak, her sayının benzersiz olmasını sağlayarak yinelenen sayıları kaldırır. İkinci olarak, kalan sayıları artan sırayla sıralar.\n    Örnek kullanım:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "vi": "Hàm này nhận một danh sách các số nguyên và thực hiện hai thao tác. Thứ nhất, nó loại bỏ bất kỳ số trùng lặp nào, đảm bảo mỗi số là duy nhất. Thứ hai, nó sắp xếp các số còn lại theo thứ tự tăng dần.\n    Ví dụ sử dụng:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]"
    },
    "docstring_bertscore": {
      "es": "0.9829952530796032",
      "arb": "0.9909394751690935",
      "sw": "0.9918968736056817",
      "tr": "0.9887013080355924",
      "vi": "0.9966626123378518"
    }
  },
  {
    "task_id": "C#/15",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Esta función premia a los 5 mejores estudiantes basándose en sus puntuaciones totales. Los estudiantes se ordenan primero por su puntuación total (Chino, Matemáticas, Inglés),\n   luego por su puntuación en Chino, y finalmente por su ID de estudiante si hay un empate. La función devuelve una lista de los 5 mejores estudiantes con sus IDs y puntuaciones totales.\n   Ejemplo:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* تقوم هذه الدالة بمنح الجوائز لأفضل 5 طلاب بناءً على إجمالي درجاتهم. يتم ترتيب الطلاب أولاً حسب إجمالي درجاتهم (الصينية، الرياضيات، الإنجليزية)،\n   ثم حسب درجاتهم في اللغة الصينية، وأخيراً حسب معرف الطالب في حالة التعادل. تعيد الدالة قائمة بأفضل 5 طلاب مع معرفاتهم وإجمالي درجاتهم.\n   مثال:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kazi ya hii kazi ni kutoa tuzo kwa wanafunzi 5 bora kulingana na jumla ya alama zao. Wanafunzi wanapangwa kwanza kwa jumla ya alama zao (Kichina, Hisabati, Kiingereza),\n   kisha kwa alama zao za Kichina, na hatimaye kwa kitambulisho cha mwanafunzi ikiwa kuna sare. Kazi hii inarudisha orodha ya wanafunzi 5 bora na vitambulisho vyao na jumla ya alama zao.\n   Mfano:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bu fonksiyon, toplam puanlarına göre en iyi 5 öğrenciyi ödüllendirir. Öğrenciler önce toplam puanlarına (Çince, Matematik, İngilizce),\n   sonra Çince puanlarına ve son olarak eşitlik durumunda öğrenci kimlik numaralarına göre sıralanır. Fonksiyon, en iyi 5 öğrencinin kimlik numaralarını ve toplam puanlarını içeren bir liste döndürür.\n   Örnek:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hàm này trao thưởng cho 5 học sinh đứng đầu dựa trên tổng điểm của họ. Học sinh được sắp xếp trước tiên theo tổng điểm (Tiếng Trung, Toán, Tiếng Anh),\n   sau đó theo điểm Tiếng Trung, và cuối cùng theo mã số học sinh nếu có điểm bằng nhau. Hàm trả về danh sách 5 học sinh đứng đầu với mã số và tổng điểm của họ.\n   Ví dụ:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)"
    },
    "prompt_bertscore": {
      "es": "0.9858231538143969",
      "arb": "0.9713912662195451",
      "sw": "0.9717547598168389",
      "tr": "0.9776248834675629",
      "vi": "0.9783490898368161"
    },
    "canonical_solution": "{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` para resolver el siguiente problema:\nEsta función premia a los 5 mejores estudiantes basándose en sus puntajes totales. Los estudiantes se ordenan primero por su puntaje total (Chino, Matemáticas, Inglés),\n   luego por su puntaje en Chino, y finalmente por su ID de estudiante si hay un empate. La función devuelve una lista de los 5 mejores estudiantes con sus IDs y puntajes totales.\n   Ejemplo:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]",
      "arb": "اكتب دالة C# `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` لحل المشكلة التالية:\nتقوم هذه الدالة بمنح الجوائز لأفضل 5 طلاب بناءً على مجموع درجاتهم. يتم ترتيب الطلاب أولاً حسب مجموع درجاتهم (الصينية، الرياضيات، الإنجليزية)،\nثم حسب درجاتهم في اللغة الصينية، وأخيراً حسب معرف الطالب في حالة التعادل. تعيد الدالة قائمة بأفضل 5 طلاب مع معرفاتهم ومجموع درجاتهم.\nمثال:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "sw": "Andika kazi ya C# `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` kutatua tatizo lifuatalo:\nKazi hii inatoa tuzo kwa wanafunzi 5 bora kulingana na jumla ya alama zao. Wanafunzi wanapangwa kwanza kwa jumla ya alama zao (Kichina, Hisabati, Kiingereza), kisha kwa alama zao za Kichina, na hatimaye kwa kitambulisho cha mwanafunzi ikiwa kuna sare. Kazi hii inarejesha orodha ya wanafunzi 5 bora na vitambulisho vyao na jumla ya alama zao.\nMfano:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "tr": "C# dilinde `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` fonksiyonunu aşağıdaki problemi çözmek için yazın:\nBu fonksiyon, toplam puanlarına göre en iyi 5 öğrenciyi ödüllendirir. Öğrenciler önce toplam puanlarına (Çince, Matematik, İngilizce), ardından Çince puanlarına ve eşitlik durumunda öğrenci kimlik numaralarına göre sıralanır. Fonksiyon, en iyi 5 öğrencinin kimlik numaralarını ve toplam puanlarını içeren bir liste döndürür.\nÖrnek:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "vi": "Viết một hàm C# `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` để giải quyết vấn đề sau:\nHàm này trao giải cho 5 học sinh đứng đầu dựa trên tổng điểm của họ. Học sinh được sắp xếp trước tiên theo tổng điểm của họ (Tiếng Trung, Toán, Tiếng Anh),\nsau đó theo điểm Tiếng Trung, và cuối cùng theo ID học sinh nếu có sự hòa điểm. Hàm trả về danh sách 5 học sinh đứng đầu với ID và tổng điểm của họ.\nVí dụ:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]"
    },
    "instruction_bertscore": {
      "es": "0.9922134904330513",
      "arb": "0.9876547245579196",
      "sw": "0.9909778108326333",
      "tr": "0.9671975829847554",
      "vi": "0.9853361121200994"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        // Test Case 1\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80) }).SequenceEqual(new List<(int, int)> { (3, 255), (2, 255), (1, 255) }));\n\n        // Test Case 2\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (4, 88, 75, 95), (5, 95, 88, 75) }).SequenceEqual(new List<(int, int)> { (5, 258), (4, 258) }));\n\n        // Test Case 3\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (6, 75, 85, 90), (7, 90, 75, 85) }).SequenceEqual(new List<(int, int)> { (7, 250), (6, 250) }));\n\n        // Test Case 4\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (8, 80, 90, 80), (9, 90, 80, 80) }).SequenceEqual(new List<(int, int)> { (9, 250), (8, 250) }));\n\n        // Test Case 5\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (10, 85, 85, 85), (11, 86, 85, 84), (12, 84, 86, 85) }).SequenceEqual(new List<(int, int)> { (11, 255), (10, 255), (12, 255) }));\n        }\n}\n",
    "entry_point": "AwardTopStudents",
    "signature": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
    "docstring": {
      "es": "Esta función premia a los 5 mejores estudiantes basándose en sus puntajes totales. Los estudiantes se ordenan primero por su puntaje total (Chino, Matemáticas, Inglés), luego por su puntaje en Chino, y finalmente por su ID de estudiante en caso de empate. La función devuelve una lista de los 5 mejores estudiantes con sus IDs y puntajes totales.\n   Ejemplo:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]",
      "arb": "هذه الدالة تمنح الجوائز لأفضل 5 طلاب بناءً على مجموع درجاتهم. يتم ترتيب الطلاب أولاً حسب مجموع درجاتهم (الصينية، الرياضيات، الإنجليزية)، ثم حسب درجاتهم في الصينية، وأخيراً حسب معرف الطالب في حالة التعادل. تعيد الدالة قائمة بأفضل 5 طلاب مع معرفاتهم ومجموع درجاتهم.\nمثال:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "sw": "Kazi hii inatoa tuzo kwa wanafunzi 5 bora kulingana na alama zao jumla. Wanafunzi wanapangwa kwanza kwa alama zao jumla (Kichina, Hisabati, Kiingereza), kisha kwa alama zao za Kichina, na hatimaye kwa kitambulisho cha mwanafunzi ikiwa kuna sare. Kazi hii inarejesha orodha ya wanafunzi 5 bora na vitambulisho vyao na alama zao jumla.\nMfano:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "tr": "Bu fonksiyon, toplam puanlarına göre en iyi 5 öğrenciyi ödüllendirir. Öğrenciler önce toplam puanlarına (Çince, Matematik, İngilizce), sonra Çince puanlarına ve eşitlik durumunda öğrenci kimlik numaralarına göre sıralanır. Fonksiyon, en iyi 5 öğrencinin kimlik numaralarını ve toplam puanlarını içeren bir liste döndürür.\n   Örnek:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]",
      "vi": "Hàm này trao giải cho 5 học sinh có tổng điểm cao nhất. Học sinh được sắp xếp trước tiên theo tổng điểm (Tiếng Trung, Toán, Tiếng Anh), sau đó theo điểm Tiếng Trung, và cuối cùng theo mã số học sinh nếu có điểm bằng nhau. Hàm trả về danh sách 5 học sinh đứng đầu với mã số và tổng điểm của họ.\nVí dụ:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]"
    },
    "docstring_bertscore": {
      "es": "0.9884035610944212",
      "arb": "0.9779494455101739",
      "sw": "0.9793064882734043",
      "tr": "0.9622558577349885",
      "vi": "0.9744303110493788"
    }
  },
  {
    "task_id": "C#/16",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Determinar el número mínimo de grupos necesarios para distribuir recuerdos donde cada grupo puede tener como máximo dos recuerdos y el precio total de los recuerdos en un grupo no puede exceder un límite especificado.\n    Ejemplo:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    تحديد الحد الأدنى لعدد المجموعات اللازمة لتوزيع التذكارات حيث يمكن أن تحتوي كل مجموعة على تذكارتين كحد أقصى ولا يمكن أن يتجاوز السعر الإجمالي للتذكارات في مجموعة حدًا محددًا.\n    مثال:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Tambua idadi ndogo ya makundi yanayohitajika kusambaza zawadi ambapo kila kundi linaweza kuwa na zawadi zisizozidi mbili na jumla ya bei ya zawadi katika kundi haiwezi kuzidi kikomo kilichobainishwa.\n    Mfano:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Her bir grup en fazla iki hatıra eşyası içerebileceği ve bir gruptaki hatıra eşyalarının toplam fiyatı belirtilen bir limiti aşamayacağı şekilde hatıra eşyalarını dağıtmak için gereken minimum grup sayısını belirleyin.\n    Örnek:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Xác định số nhóm tối thiểu cần thiết để phân phối quà lưu niệm, trong đó mỗi nhóm có thể có tối đa hai quà lưu niệm và tổng giá của quà lưu niệm trong một nhóm không được vượt quá một giới hạn đã chỉ định.\n    Ví dụ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)"
    },
    "prompt_bertscore": {
      "es": "0.9973447090663257",
      "arb": "0.9845610563733013",
      "sw": "0.9682306595965179",
      "tr": "0.9806051337046104",
      "vi": "0.980944195765037"
    },
    "canonical_solution": "{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` para resolver el siguiente problema:\nDeterminar el número mínimo de grupos necesarios para distribuir souvenirs donde cada grupo puede tener como máximo dos souvenirs y el precio total de los souvenirs en un grupo no puede exceder un límite especificado.\n    Ejemplo:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "arb": "اكتب دالة C# `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` لحل المشكلة التالية:\nتحديد الحد الأدنى لعدد المجموعات اللازمة لتوزيع التذكارات حيث يمكن أن تحتوي كل مجموعة على تذكارتين كحد أقصى ولا يمكن أن يتجاوز السعر الإجمالي للتذكارات في مجموعة حدًا محددًا.\n    مثال:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "sw": "Andika kazi ya C# `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` kutatua tatizo lifuatalo:\nTambua idadi ndogo zaidi ya makundi yanayohitajika kusambaza zawadi ambapo kila kundi linaweza kuwa na zawadi zisizozidi mbili na jumla ya bei ya zawadi katika kundi haiwezi kuzidi kikomo kilichobainishwa.\n    Mfano:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "tr": "Bir C# fonksiyonu `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` yazın ve aşağıdaki problemi çözün:\nHer grubun en fazla iki hatıra eşyası içerebileceği ve bir gruptaki hatıra eşyalarının toplam fiyatının belirtilen bir limiti aşamayacağı şekilde hatıra eşyalarını dağıtmak için gereken minimum grup sayısını belirleyin.\n    Örnek:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "vi": "Viết một hàm C# `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` để giải quyết vấn đề sau:\nXác định số lượng nhóm tối thiểu cần thiết để phân phối quà lưu niệm, trong đó mỗi nhóm có thể có tối đa hai món quà lưu niệm và tổng giá của các món quà trong một nhóm không được vượt quá giới hạn đã chỉ định.\n    Ví dụ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9833384863780316",
      "arb": "0.9843590492757888",
      "sw": "0.9686175915787739",
      "tr": "0.9764164162293467",
      "vi": "0.9779375276873119"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30) == 2);\n        Debug.Assert(MinimumGroups(new List<int> { 10, 20, 30, 40, 50 }, 60) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 25, 30, 35, 5, 15, 20 }, 40) == 4);\n        Debug.Assert(MinimumGroups(new List<int> { 32, 42, 52, 12, 22 }, 70) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 30, 35, 40, 10, 15, 20, 25}, 45) == 4);\n        Debug.Assert(MinimumGroups(new List<int> { 5, 10, 15, 20, 25 }, 30) == 3);\n\n    }\n}\n",
    "entry_point": "MinimumGroups",
    "signature": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
    "docstring": {
      "es": "Determinar el número mínimo de grupos necesarios para distribuir recuerdos donde cada grupo puede tener como máximo dos recuerdos y el precio total de los recuerdos en un grupo no puede exceder un límite especificado.\n    Ejemplo:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "arb": "تحديد الحد الأدنى لعدد المجموعات اللازمة لتوزيع الهدايا التذكارية حيث يمكن لكل مجموعة أن تحتوي على ما لا يزيد عن هديتين تذكاريتين ولا يمكن أن يتجاوز السعر الإجمالي للهدايا التذكارية في مجموعة حدًا محددًا.\n    مثال:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "sw": "Amua idadi ndogo ya vikundi vinavyohitajika kusambaza zawadi ambapo kila kikundi kinaweza kuwa na zawadi zisizozidi mbili na bei ya jumla ya zawadi katika kikundi haiwezi kuzidi kikomo kilichobainishwa.\n    Mfano:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "tr": "Hediyelik eşyaları dağıtmak için gereken minimum grup sayısını belirleyin; her grup en fazla iki hediyelik eşya içerebilir ve bir gruptaki hediyelik eşyaların toplam fiyatı belirtilen bir sınırı aşamaz.\n    Örnek:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "vi": "Xác định số lượng nhóm tối thiểu cần thiết để phân phối quà lưu niệm, trong đó mỗi nhóm có thể có tối đa hai quà lưu niệm và tổng giá của quà lưu niệm trong một nhóm không được vượt quá một giới hạn đã chỉ định.\n    Ví dụ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9961243240052473",
      "arb": "0.9741540161893593",
      "sw": "0.9539884640155544",
      "tr": "0.9741875847237542",
      "vi": "0.9761558131694289"
    }
  },
  {
    "task_id": "C#/17",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calcular el número inicial de melocotones que tenía un mono, dado que cada día come la mitad de los melocotones más uno más, y en el día N solo queda un melocotón.\n    Ejemplos:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* حساب العدد الأولي من الخوخ الذي كان لدى القرد، مع العلم أنه كل يوم يأكل نصف الخوخ بالإضافة إلى خوخة واحدة أخرى، وفي اليوم N يتبقى خوخة واحدة فقط.\n    أمثلة:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hesabu idadi ya awali ya pichi ambazo tumbili alikuwa nazo, ikizingatiwa kwamba kila siku anakula nusu ya pichi pamoja na moja zaidi, na katika siku ya N pichi moja tu imebaki.\n    Mifano:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bir maymunun başlangıçta kaç tane şeftaliye sahip olduğunu hesapla, her gün şeftalilerin yarısını ve bir tane daha yediği ve N. günde sadece bir şeftali kaldığı verildiğinde.\n    Örnekler:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Tính toán số lượng đào ban đầu mà một con khỉ có, biết rằng mỗi ngày nó ăn một nửa số đào cộng thêm một quả nữa, và vào ngày thứ N chỉ còn lại một quả đào.\n    Ví dụ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)"
    },
    "prompt_bertscore": {
      "es": "0.9824214099087935",
      "arb": "0.9764056901887708",
      "sw": "0.9799985165209298",
      "tr": "0.9748456471761228",
      "vi": "0.9818727927963751"
    },
    "canonical_solution": "{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int InitialPeachesCount(int days)` para resolver el siguiente problema:\nCalcular el número inicial de duraznos que tenía un mono, dado que cada día come la mitad de los duraznos más uno más, y en el día N solo queda un durazno.\n    Ejemplos:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "arb": "اكتب دالة C# `static int InitialPeachesCount(int days)` لحل المشكلة التالية:  \nاحسب العدد الأولي للخوخ الذي كان لدى القرد، مع العلم أنه كل يوم يأكل نصف الخوخ بالإضافة إلى خوخة واحدة أخرى، وفي اليوم N يتبقى خوخة واحدة فقط.  \n    أمثلة:  \n    >>> InitialPeachesCount(1)  \n    1  \n    >>> InitialPeachesCount(2)  \n    4  \n    >>> InitialPeachesCount(3)  \n    10  ",
      "sw": "Andika kazi ya C# `static int InitialPeachesCount(int days)` kutatua tatizo lifuatalo:\nHesabu idadi ya awali ya peaches ambayo tumbili alikuwa nayo, ikizingatiwa kwamba kila siku anakula nusu ya peaches pamoja na moja zaidi, na katika siku ya N moja tu ya peach imebaki.\n    Mifano:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "tr": "Bir C# fonksiyonu `static int InitialPeachesCount(int days)` yazın:\nBir maymunun başlangıçta kaç tane şeftaliye sahip olduğunu hesaplayın, her gün şeftalilerin yarısını ve bir tane daha yediği ve N. günde sadece bir şeftali kaldığı verildiğinde.\n    Örnekler:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "vi": "Viết một hàm C# `static int InitialPeachesCount(int days)` để giải quyết vấn đề sau:\nTính toán số lượng quả đào ban đầu mà một con khỉ có, biết rằng mỗi ngày nó ăn một nửa số quả đào cộng thêm một quả nữa, và vào ngày thứ N chỉ còn lại một quả đào.\n    Ví dụ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10"
    },
    "instruction_bertscore": {
      "es": "0.9811928810020927",
      "arb": "0.9757382921084936",
      "sw": "0.9811031000698649",
      "tr": "0.9535741210407156",
      "vi": "0.9846252139863755"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(InitialPeachesCount(1) == 1);\n        Debug.Assert(InitialPeachesCount(2) == 4);\n        Debug.Assert(InitialPeachesCount(3) == 10);\n        Debug.Assert(InitialPeachesCount(4) == 22);\n\n\n    }\n}",
    "entry_point": "InitialPeachesCount",
    "signature": "static int InitialPeachesCount(int days)",
    "docstring": {
      "es": "Calcular el número inicial de duraznos que tenía un mono, dado que cada día come la mitad de los duraznos más uno más, y en el día N solo queda un durazno.\n    Ejemplos:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "arb": "احسب العدد الأولي من الخوخ الذي كان لدى القرد، مع العلم أنه في كل يوم يأكل نصف الخوخ بالإضافة إلى واحدة أخرى، وفي اليوم N يبقى خوخة واحدة فقط.\n    أمثلة:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "sw": "Hesabu idadi ya awali ya pichi ambazo tumbili alikuwa nazo, ikizingatiwa kwamba kila siku anakula nusu ya pichi pamoja na moja zaidi, na katika siku ya N moja tu ya pichi imebaki.\n    Mifano:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "tr": "Başlangıçta bir maymunun kaç tane şeftaliye sahip olduğunu hesaplayın. Her gün şeftalilerin yarısını ve bir tane daha yediği ve N. günde sadece bir şeftali kaldığı verilmiştir.\n    Örnekler:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "vi": "Tính toán số lượng đào ban đầu mà một con khỉ có, với điều kiện mỗi ngày nó ăn một nửa số đào cộng thêm một quả nữa, và vào ngày thứ N chỉ còn lại một quả đào.\n\n    Ví dụ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10"
    },
    "docstring_bertscore": {
      "es": "0.9801955578589164",
      "arb": "0.9696727161628312",
      "sw": "0.9708716491427578",
      "tr": "0.9458265430284498",
      "vi": "0.9871607308002859"
    }
  },
  {
    "task_id": "C#/18",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Encuentra todos los pares de números amigos dentro de un límite especificado.\n    Los números amigos son dos números diferentes relacionados de tal manera que la suma de los divisores propios de cada uno es igual al otro número.\n\n    Ejemplo de uso:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - يجد جميع أزواج الأعداد المتحابّة ضمن حد معين.\n    الأعداد المتحابّة هي عددان مختلفان بحيث يكون مجموع القواسم الصحيحة لكل منهما مساوياً للعدد الآخر.\n\n    مثال على الاستخدام:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Inapata jozi zote za nambari za kirafiki ndani ya kikomo kilichobainishwa.\n    Nambari za kirafiki ni nambari mbili tofauti zinazohusiana kwa namna kwamba jumla ya wagawanyaji sahihi wa kila moja ni sawa na nambari nyingine.\n\n    Mfano wa matumizi:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Belirtilen bir sınır içinde tüm dost sayı çiftlerini bulur.\n    Dost sayılar, her birinin uygun bölenlerinin toplamının diğer sayıya eşit olduğu iki farklı sayıdır.\n\n    Örnek kullanım:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Tìm tất cả các cặp số thân thiện trong một giới hạn được chỉ định.\n    Số thân thiện là hai số khác nhau có liên quan như vậy mà tổng các ước số thực sự của mỗi số bằng với số kia.\n\n    Ví dụ sử dụng:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)"
    },
    "prompt_bertscore": {
      "es": "0.9747189209930225",
      "arb": "0.9772166980345363",
      "sw": "0.9797154682279552",
      "tr": "0.9845602618517771",
      "vi": "0.9782618910995419"
    },
    "canonical_solution": "{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static List<(int, int)> FindAmicableNumbers(int limit)` para resolver el siguiente problema:\nFindAmicableNumbers - Encuentra todos los pares de números amigos dentro de un límite especificado.\n    Los números amigos son dos números diferentes relacionados de tal manera que la suma de los divisores propios de cada uno es igual al otro número.\n\n    Ejemplo de uso:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "arb": "اكتب دالة C# `static List<(int, int)> FindAmicableNumbers(int limit)` لحل المشكلة التالية:\nFindAmicableNumbers - يجد جميع أزواج الأعداد الصديقة ضمن حد معين.\n    الأعداد الصديقة هي عددان مختلفان بحيث يكون مجموع القواسم الصحيحة لكل منهما مساوياً للعدد الآخر.\n\n    مثال على الاستخدام:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "sw": "Andika kazi ya C# `static List<(int, int)> FindAmicableNumbers(int limit)` kutatua tatizo lifuatalo:\nFindAmicableNumbers - Inapata jozi zote za namba rafiki ndani ya kikomo kilichobainishwa.\n    Namba rafiki ni namba mbili tofauti ambazo zimehusiana kwa namna kwamba jumla ya wagawanyaji halisi wa kila moja ni sawa na namba nyingine.\n\n    Mfano wa matumizi:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "tr": "Bir C# fonksiyonu `static List<(int, int)> FindAmicableNumbers(int limit)` yazın:\nFindAmicableNumbers - Belirtilen bir sınır içinde tüm dost sayı çiftlerini bulur.\n    Dost sayılar, her birinin uygun bölenlerinin toplamının diğer sayıya eşit olduğu iki farklı sayıdır.\n\n    Örnek kullanım:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "vi": "Viết một hàm C# `static List<(int, int)> FindAmicableNumbers(int limit)` để giải quyết vấn đề sau:\nFindAmicableNumbers - Tìm tất cả các cặp số thân thiện trong một giới hạn được chỉ định.\n    Số thân thiện là hai số khác nhau có liên quan sao cho tổng các ước số thực sự của mỗi số bằng với số kia.\n\n    Ví dụ sử dụng:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)"
    },
    "instruction_bertscore": {
      "es": "0.9693267020390685",
      "arb": "0.9725608019030785",
      "sw": "0.9742122148910025",
      "tr": "0.9567953099299583",
      "vi": "0.9832417533824676"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindAmicableNumbers(300).SequenceEqual(new List<(int, int)> { (220, 284) }));\n        Debug.Assert(FindAmicableNumbers(2000).SequenceEqual(new List<(int, int)> { (220, 284), (1184, 1210) }));\n        Debug.Assert(FindAmicableNumbers(500).Count == 1);\n        Debug.Assert(FindAmicableNumbers(100).Count == 0);\n        Debug.Assert(FindAmicableNumbers(3000).SequenceEqual(new List<(int, int)> { (220, 284), (1184, 1210) ,(2620,2924)}));\n\n    }\n}\n\n\n\n",
    "entry_point": "FindAmicableNumbers",
    "signature": "static List<(int, int)> FindAmicableNumbers(int limit)",
    "docstring": {
      "es": "FindAmicableNumbers - Encuentra todos los pares de números amigos dentro de un límite especificado.\n    Los números amigos son dos números diferentes relacionados de tal manera que la suma de los divisores propios de cada uno es igual al otro número.\n\n    Ejemplo de uso:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "arb": "FindAmicableNumbers - يجد جميع أزواج الأعداد المتحابّة ضمن حد محدد.\n    الأعداد المتحابّة هي عددان مختلفان بحيث يكون مجموع القواسم الصحيحة لكل منهما مساوياً للعدد الآخر.\n\n    مثال على الاستخدام:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "sw": "FindAmicableNumbers - Inapata jozi zote za nambari za kirafiki ndani ya kikomo kilichobainishwa. \n    Nambari za kirafiki ni nambari mbili tofauti ambazo zinahusiana kwa njia kwamba jumla ya wagawanyiko sahihi wa kila moja ni sawa na nambari nyingine.\n\n    Matumizi ya mfano:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "tr": "FindAmicableNumbers - Belirtilen bir sınır içinde tüm dost sayı çiftlerini bulur.\n    Dost sayılar, her birinin uygun bölenlerinin toplamının diğer sayıya eşit olduğu iki farklı sayıdır.\n\n    Örnek kullanım:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "vi": "FindAmicableNumbers - Tìm tất cả các cặp số thân thiện trong một giới hạn được chỉ định. \n    Số thân thiện là hai số khác nhau có liên quan sao cho tổng các ước số thực sự của mỗi số bằng số kia.\n\n    Ví dụ sử dụng:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)"
    },
    "docstring_bertscore": {
      "es": "0.9582770925724786",
      "arb": "0.9716043966183955",
      "sw": "0.9682713788246301",
      "tr": "0.9755990522113881",
      "vi": "0.9754900041322"
    }
  },
  {
    "task_id": "C#/19",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Esta función toma una cadena, la invierte y luego la concatena con la cadena original.\n    Ejemplo de uso:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* تأخذ هذه الدالة سلسلة نصية، تعكسها، ثم تدمجها مع السلسلة الأصلية.\n    مثال على الاستخدام:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kazi ya hii kazi ni kuchukua kamba, kuigeuza, na kisha kuunganisha na kamba ya awali.\n    Mfano wa matumizi:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bu fonksiyon bir dize alır, ters çevirir ve ardından orijinal dize ile birleştirir.\n    Örnek kullanım:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hàm này nhận một chuỗi, đảo ngược nó, và sau đó nối nó với chuỗi gốc.\n    Ví dụ sử dụng:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)"
    },
    "prompt_bertscore": {
      "es": "0.9936617045411767",
      "arb": "0.9959874676727142",
      "sw": "0.9715050814278781",
      "tr": "1",
      "vi": "1"
    },
    "canonical_solution": "{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}",
    "instruction": {
      "es": "Escribe una función en C# `static string ReverseAndConcatenate(string input)` para resolver el siguiente problema:\nEsta función toma una cadena, la invierte y luego la concatena con la cadena original.\n    Ejemplo de uso:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "arb": "اكتب دالة C# `static string ReverseAndConcatenate(string input)` لحل المشكلة التالية:\nتقوم هذه الدالة بأخذ سلسلة نصية، ثم تقوم بعكسها، وبعد ذلك تقوم بدمجها مع السلسلة الأصلية.\n    مثال على الاستخدام:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "sw": "Andika kazi ya C# `static string ReverseAndConcatenate(string input)` kutatua tatizo lifuatalo: \nKazi hii inachukua kamba, inairejelea, na kisha inaiunganisha na kamba ya asili.\n    Mfano wa matumizi:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "tr": "Bir C# fonksiyonu `static string ReverseAndConcatenate(string input)` yazın:\nBu fonksiyon bir string alır, onu ters çevirir ve ardından orijinal string ile birleştirir.\n    Örnek kullanım:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "vi": "Viết một hàm C# `static string ReverseAndConcatenate(string input)` để giải quyết vấn đề sau:\nHàm này nhận một chuỗi, đảo ngược nó, và sau đó nối nó với chuỗi gốc.\n    Ví dụ sử dụng:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\""
    },
    "instruction_bertscore": {
      "es": "0.9876843204846938",
      "arb": "0.9949251923949396",
      "sw": "1",
      "tr": "0.9767721632417802",
      "vi": "1"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(ReverseAndConcatenate(\"abc\") == \"abccba\");\n        Debug.Assert(ReverseAndConcatenate(\"test\") == \"testtset\");\n        Debug.Assert(ReverseAndConcatenate(\"\") == \"\");\n        Debug.Assert(ReverseAndConcatenate(\"12345\") == \"1234554321\");\n\n    }\n}",
    "entry_point": "ReverseAndConcatenate",
    "signature": "static string ReverseAndConcatenate(string input)",
    "docstring": {
      "es": "Esta función toma una cadena, la invierte y luego la concatena con la cadena original.\n    Ejemplo de uso:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "arb": "هذه الدالة تأخذ سلسلة نصية، تعكسها، ثم تقوم بدمجها مع السلسلة الأصلية.\n    مثال على الاستخدام:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "sw": "Kazi ya hii kazi ni kuchukua kamba, kuigeuza, na kisha kuiunganisha na kamba ya asili.\n    Mfano wa matumizi:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "tr": "Bu fonksiyon bir dize alır, ters çevirir ve ardından orijinal dize ile birleştirir.\n    Örnek kullanım:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "vi": "Hàm này nhận một chuỗi, đảo ngược nó, và sau đó nối nó với chuỗi gốc.\n    Ví dụ sử dụng:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\""
    },
    "docstring_bertscore": {
      "es": "0.9916609007130123",
      "arb": "0.9920637231257511",
      "sw": "0.9400950633836881",
      "tr": "1",
      "vi": "1"
    }
  },
  {
    "task_id": "C#/20",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calcula el número de valores de franqueo únicos que se pueden crear usando un número dado de sellos de 3 centavos y 5 centavos.\n        Parámetros:\n        threeCentStamps - el número de sellos de 3 centavos disponibles\n        fiveCentStamps - el número de sellos de 5 centavos disponibles\n\n        Devuelve:\n        El número de valores de franqueo únicos que se pueden crear.\n\n        Ejemplo:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* يحسب عدد القيم الفريدة للطوابع البريدية التي يمكن إنشاؤها باستخدام عدد معين من الطوابع ذات 3 سنتات و5 سنتات.\n        المعاملات:\n        threeCentStamps - عدد الطوابع المتوفرة ذات 3 سنتات\n        fiveCentStamps - عدد الطوابع المتوفرة ذات 5 سنتات\n\n        يعيد:\n        عدد القيم الفريدة للطوابع البريدية التي يمكن إنشاؤها.\n\n        مثال:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Inahesabu idadi ya thamani za kipekee za stempu zinazoweza kuundwa kwa kutumia idadi fulani ya stempu za senti 3 na senti 5.\n        Vigezo:\n        threeCentStamps - idadi ya stempu za senti 3 zinazopatikana\n        fiveCentStamps - idadi ya stempu za senti 5 zinazopatikana\n\n        Inarudisha:\n        Idadi ya thamani za kipekee za stempu zinazoweza kuundwa.\n\n        Mfano:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Belirli bir sayıda 3 sentlik ve 5 sentlik pul kullanarak oluşturulabilecek benzersiz posta değerlerinin sayısını hesaplar.\n        Parametreler:\n        threeCentStamps - mevcut 3 sentlik pulların sayısı\n        fiveCentStamps - mevcut 5 sentlik pulların sayısı\n\n        Döndürür:\n        Oluşturulabilecek benzersiz posta değerlerinin sayısı.\n\n        Örnek:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Tính toán số lượng giá trị bưu phí duy nhất có thể được tạo ra bằng cách sử dụng một số lượng tem 3 xu và 5 xu nhất định.\n        Tham số:\n        threeCentStamps - số lượng tem 3 xu có sẵn\n        fiveCentStamps - số lượng tem 5 xu có sẵn\n\n        Trả về:\n        Số lượng giá trị bưu phí duy nhất có thể được tạo ra.\n\n        Ví dụ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9841304257072176",
      "sw": "0.9888186985907841",
      "tr": "0.9921135793513908",
      "vi": "0.9949243978734155"
    },
    "canonical_solution": "   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` para resolver el siguiente problema:\nCalcula el número de valores de franqueo únicos que se pueden crear utilizando un número dado de sellos de 3 centavos y sellos de 5 centavos.\n        Parámetros:\n        threeCentStamps - el número de sellos de 3 centavos disponibles\n        fiveCentStamps - el número de sellos de 5 centavos disponibles\n\n        Devuelve:\n        El número de valores de franqueo únicos que se pueden crear.\n\n        Ejemplo:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "arb": "اكتب دالة C# `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` لحل المشكلة التالية:\nتحسب عدد القيم البريدية الفريدة التي يمكن إنشاؤها باستخدام عدد معين من الطوابع ذات 3 سنتات و5 سنتات.\n        المعاملات:\n        threeCentStamps - عدد الطوابع ذات 3 سنتات المتاحة\n        fiveCentStamps - عدد الطوابع ذات 5 سنتات المتاحة\n\n        يعيد:\n        عدد القيم البريدية الفريدة التي يمكن إنشاؤها.\n\n        مثال:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "sw": "Andika kazi ya C# `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` kutatua tatizo lifuatalo:\nInakokotoa idadi ya thamani za kipekee za stempu zinazoweza kuundwa kwa kutumia idadi fulani ya stempu za senti 3 na senti 5.\n        Vigezo:\n        threeCentStamps - idadi ya stempu za senti 3 zinazopatikana\n        fiveCentStamps - idadi ya stempu za senti 5 zinazopatikana\n\n        Inarudisha:\n        Idadi ya thamani za kipekee za stempu zinazoweza kuundwa.\n\n        Mfano:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "tr": "Bir C# fonksiyonu `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` yazın ve aşağıdaki problemi çözün:\nBelirli sayıda 3 sentlik ve 5 sentlik pullar kullanılarak oluşturulabilecek benzersiz posta değerlerinin sayısını hesaplar.\n        Parametreler:\n        threeCentStamps - mevcut 3 sentlik pulların sayısı\n        fiveCentStamps - mevcut 5 sentlik pulların sayısı\n\n        Döndürür:\n        Oluşturulabilecek benzersiz posta değerlerinin sayısı.\n\n        Örnek:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "vi": "Viết một hàm C# `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` để giải quyết vấn đề sau:\nTính toán số lượng giá trị bưu phí duy nhất có thể được tạo ra bằng cách sử dụng một số lượng tem 3 xu và tem 5 xu nhất định.\n        \n        Tham số:\n        threeCentStamps - số lượng tem 3 xu có sẵn\n        fiveCentStamps - số lượng tem 5 xu có sẵn\n\n        Trả về:\n        Số lượng giá trị bưu phí duy nhất có thể được tạo ra.\n\n        Ví dụ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8"
    },
    "instruction_bertscore": {
      "es": "0.9895297953548889",
      "arb": "0.984087124284152",
      "sw": "0.9814350114365742",
      "tr": "0.9820900944332273",
      "vi": "0.9863270790910824"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountUniquePostageCombinations(4, 3) == 19); \n        Debug.Assert(CountUniquePostageCombinations(2, 2) == 8); \n        Debug.Assert(CountUniquePostageCombinations(3, 1) == 7);\n        Debug.Assert(CountUniquePostageCombinations(1, 3) == 7); \n\n    }\n}\n",
    "entry_point": "CountUniquePostageCombinations",
    "signature": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
    "docstring": {
      "es": "Calcula el número de valores de franqueo únicos que se pueden crear usando una cantidad dada de sellos de 3 centavos y 5 centavos.\n        Parámetros:\n        threeCentStamps - el número de sellos de 3 centavos disponibles\n        fiveCentStamps - el número de sellos de 5 centavos disponibles\n\n        Devuelve:\n        El número de valores de franqueo únicos que se pueden crear.\n\n        Ejemplo:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "arb": "يحسب عدد قيم الطوابع الفريدة التي يمكن إنشاؤها باستخدام عدد معين من الطوابع ذات 3 سنتات و 5 سنتات.\n        المعلمات:\n        threeCentStamps - عدد الطوابع المتاحة ذات 3 سنتات\n        fiveCentStamps - عدد الطوابع المتاحة ذات 5 سنتات\n\n        يعيد:\n        عدد قيم الطوابع الفريدة التي يمكن إنشاؤها.\n\n        مثال:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "sw": "Hesabu idadi ya thamani za kipekee za posta ambazo zinaweza kuundwa kwa kutumia idadi fulani ya stempu za senti 3 na senti 5.\n        \n        Vigezo:\n        threeCentStamps - idadi ya stempu za senti 3 zinazopatikana\n        fiveCentStamps - idadi ya stempu za senti 5 zinazopatikana\n\n        Inarejesha:\n        Idadi ya thamani za kipekee za posta ambazo zinaweza kuundwa.\n\n        Mfano:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "tr": "Belli bir sayıda 3 sentlik ve 5 sentlik pul kullanarak oluşturulabilecek benzersiz posta değerlerinin sayısını hesaplar.\n        Parametreler:\n        threeCentStamps - mevcut 3 sentlik pulların sayısı\n        fiveCentStamps - mevcut 5 sentlik pulların sayısı\n\n        Döndürür:\n        Oluşturulabilecek benzersiz posta değerlerinin sayısı.\n\n        Örnek:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "vi": "Tính toán số lượng giá trị bưu phí duy nhất có thể được tạo ra bằng cách sử dụng một số lượng tem 3 xu và 5 xu nhất định.\n        \n        Tham số:\n        threeCentStamps - số lượng tem 3 xu có sẵn\n        fiveCentStamps - số lượng tem 5 xu có sẵn\n\n        Trả về:\n        Số lượng giá trị bưu phí duy nhất có thể được tạo ra.\n\n        Ví dụ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8"
    },
    "docstring_bertscore": {
      "es": "0.9954553368819218",
      "arb": "0.9696079626586138",
      "sw": "0.9726597198328338",
      "tr": "0.9889972673033345",
      "vi": "0.9913129002854392"
    }
  },
  {
    "task_id": "C#/21",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Determina si una secuencia tiene \"Jolly Jumps\" donde las diferencias absolutas entre elementos adyacentes,\n   cuando se ordenan, forman una secuencia continua desde 1 hasta (longitud de la secuencia - 1).\n   Una secuencia con un solo elemento siempre se considera jolly.\n   \n        Ejemplos:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* يحدد ما إذا كانت سلسلة تحتوي على \"قفزات مرحة\" حيث تشكل الفروق المطلقة بين العناصر المتجاورة، \n   عند ترتيبها، تسلسلاً مستمراً من 1 إلى (طول السلسلة - 1).\n   تعتبر السلسلة التي تحتوي على عنصر واحد دائماً مرحة.\n   \n        أمثلة:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Huamua ikiwa mlolongo una \"Jolly Jumps\" ambapo tofauti za thamani kabisa kati ya vipengele vya karibu, \n   zinapopangwa, huunda mlolongo unaoendelea kutoka 1 hadi (urefu wa mlolongo - 1).\n   Mlolongo wenye kipengele kimoja daima huchukuliwa kuwa jolly.\n   \n        Mifano:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bir dizinin \"Jolly Jumps\" içerip içermediğini belirler; burada bitişik elemanlar arasındaki mutlak farklar, \n   sıralandığında 1'den (dizinin uzunluğu - 1)'e kadar kesintisiz bir dizi oluşturur.\n   Tek bir eleman içeren bir dizi her zaman jolly olarak kabul edilir.\n   \n        Örnekler:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Xác định xem một dãy có \"Jolly Jumps\" hay không, trong đó các độ chênh lệch tuyệt đối giữa các phần tử liền kề, \n   khi được sắp xếp, tạo thành một dãy liên tục từ 1 đến (độ dài của dãy - 1).\n   Một dãy với một phần tử luôn được coi là jolly.\n   \n        Ví dụ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)"
    },
    "prompt_bertscore": {
      "es": "0.9971462773156717",
      "arb": "0.99175068164524",
      "sw": "0.9973323939827015",
      "tr": "0.9744058795125116",
      "vi": "0.9722568974200951"
    },
    "canonical_solution": "{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static string IsSequenceJolly(int[] sequence)` para resolver el siguiente problema:\nDetermina si una secuencia tiene \"Jolly Jumps\" donde las diferencias absolutas entre elementos adyacentes, \n   cuando se ordenan, forman una secuencia continua desde 1 hasta (longitud de la secuencia - 1).\n   Una secuencia con un solo elemento siempre se considera jolly.\n   \n        Ejemplos:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "arb": "اكتب دالة C# `static string IsSequenceJolly(int[] sequence)` لحل المشكلة التالية:\nتحديد ما إذا كانت التسلسلات تحتوي على \"قفزات جولي\" حيث أن الفروق المطلقة بين العناصر المتجاورة، عند ترتيبها، تشكل تسلسلاً مستمراً من 1 إلى (طول التسلسل - 1).\nيعتبر التسلسل الذي يحتوي على عنصر واحد دائمًا جولي.\n\n        أمثلة:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "sw": "Andika kazi ya C# `static string IsSequenceJolly(int[] sequence)` kutatua tatizo lifuatalo:\nInabainisha kama mlolongo una \"Jolly Jumps\" ambapo tofauti za thamani kati ya vipengele vya karibu, \n   zinapopangwa, zinaunda mlolongo endelevu kutoka 1 hadi (urefu wa mlolongo - 1).\n   Mlolongo wenye kipengele kimoja daima unachukuliwa kuwa jolly.\n   \n        Mifano:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "tr": "Bir C# fonksiyonu `static string IsSequenceJolly(int[] sequence)` yazarak aşağıdaki problemi çözün:\nBir dizinin, bitişik elemanlar arasındaki mutlak farkların, sıralandığında 1'den (dizinin uzunluğu - 1)'e kadar kesintisiz bir dizi oluşturduğu \"Jolly Jumps\" olup olmadığını belirler.\n   Tek bir elemanı olan bir dizi her zaman jolly olarak kabul edilir.\n   \n        Örnekler:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "vi": "Viết một hàm C# `static string IsSequenceJolly(int[] sequence)` để giải quyết vấn đề sau:\nXác định xem một dãy có \"Jolly Jumps\" hay không, trong đó các chênh lệch tuyệt đối giữa các phần tử liền kề, \n   khi được sắp xếp, tạo thành một dãy liên tục từ 1 đến (độ dài của dãy - 1).\n   Một dãy với một phần tử luôn được coi là jolly.\n   \n        Ví dụ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\""
    },
    "instruction_bertscore": {
      "es": "0.9888034040514444",
      "arb": "0.9620169053866036",
      "sw": "0.989683336639429",
      "tr": "0.9789561042812588",
      "vi": "0.9824029372833571"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(IsSequenceJolly(new int[] {1, 4, 2, 3}) == \"Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {1, 3}) == \"Not Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {5}) == \"Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {10, 7, 8, 9}) == \"Not Jolly\");\n\n    }\n}",
    "entry_point": "IsSequenceJolly",
    "signature": "static string IsSequenceJolly(int[] sequence)",
    "docstring": {
      "es": "Determina si una secuencia tiene \"Jolly Jumps\" donde las diferencias absolutas entre elementos adyacentes, \n   cuando se ordenan, forman una secuencia continua de 1 a (longitud de la secuencia - 1).\n   Una secuencia con un solo elemento siempre se considera jolly.\n   \n        Ejemplos:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "arb": "يحدد ما إذا كانت تسلسل يحتوي على \"قفزات جولي\" حيث أن الفروق المطلقة بين العناصر المتجاورة، عند ترتيبها، تشكل تسلسلًا مستمرًا من 1 إلى (طول التسلسل - 1). يعتبر التسلسل الذي يحتوي على عنصر واحد دائمًا جولي.\n\n        أمثلة:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "sw": "Inabainisha kama mlolongo una \"Jolly Jumps\" ambapo tofauti za thamani kati ya vipengele vya karibu, \n   zinapopangwa, zinaunda mlolongo unaoendelea kutoka 1 hadi (urefu wa mlolongo - 1).\n   Mlolongo wenye kipengele kimoja daima unachukuliwa kuwa jolly.\n   \n        Mifano:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "tr": "Bir dizinin \"Jolly Jumps\" olup olmadığını belirler; burada bitişik elemanlar arasındaki mutlak farklar, sıralandığında 1'den (dizi uzunluğu - 1)'e kadar kesintisiz bir dizi oluşturur. \n   Tek bir elemanı olan bir dizi her zaman jolly olarak kabul edilir.\n   \n        Örnekler:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "vi": "Xác định xem một dãy có \"Jolly Jumps\" hay không, nơi mà các giá trị tuyệt đối của sự khác biệt giữa các phần tử liền kề, khi được sắp xếp, tạo thành một dãy liên tục từ 1 đến (độ dài của dãy - 1). \n   Một dãy với một phần tử luôn được coi là jolly.\n   \n        Ví dụ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\""
    },
    "docstring_bertscore": {
      "es": "0.9969101057926213",
      "arb": "0.9841588298517056",
      "sw": "0.981382970276743",
      "tr": "0.9827821226807528",
      "vi": "0.9744166055530874"
    }
  },
  {
    "task_id": "C#/22",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Determina el ganador en un juego de Piedra-Papel-Tijeras jugado durante un número de rondas.\n    Los jugadores A y B tienen sus propios patrones repetitivos de movimientos.\n    Piedra (representada por 0) vence a Tijeras (2), Tijeras vence a Papel (5), y Papel vence a Piedra.\n    Si ambos jugadores eligen el mismo movimiento, la ronda es un empate.\n\n    Ejemplos:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* يحدد الفائز في لعبة حجر-ورقة-مقص التي تُلعب لعدد من الجولات.\n    اللاعبان A و B لديهما أنماط متكررة خاصة بهما من الحركات.\n    الحجر (يمثله 0) يهزم المقص (2)، المقص يهزم الورقة (5)، والورقة تهزم الحجر.\n    إذا اختار كلا اللاعبين نفس الحركة، فإن الجولة تكون تعادل.\n\n    أمثلة:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Huamua mshindi katika mchezo wa Jiwe-Karatasi-Makasi uliochezwa kwa idadi ya raundi.\n    Wachezaji A na B wana mifumo yao inayojirudia ya hatua.\n    Jiwe (linalowakilishwa na 0) linashinda Makasi (2), Makasi yanashinda Karatasi (5), na Karatasi inashinda Jiwe.\n    Ikiwa wachezaji wote wawili watachagua hatua sawa, raundi hiyo ni sare.\n\n    Mifano:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Bir dizi tur için oynanan Taş-Kağıt-Makas oyununda kazananı belirler.\n    Oyuncular A ve B'nin kendi tekrar eden hamle desenleri vardır.\n    Taş (0 ile temsil edilir) Makas'ı (2) yener, Makas Kağıt'ı (5) yener ve Kağıt Taş'ı yener.\n    Eğer her iki oyuncu da aynı hamleyi seçerse, tur berabere biter.\n\n    Örnekler:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Xác định người chiến thắng trong trò chơi Kéo-Búa-Bao được chơi trong một số vòng.\n    Người chơi A và B có mẫu di chuyển lặp lại riêng của họ.\n    Đá (được biểu thị bằng 0) thắng Kéo (2), Kéo thắng Bao (5), và Bao thắng Đá.\n    Nếu cả hai người chơi chọn cùng một nước đi, vòng đó hòa.\n\n    Ví dụ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)"
    },
    "prompt_bertscore": {
      "es": "0.9924776688398278",
      "arb": "0.9957435495648034",
      "sw": "0.9858374552018314",
      "tr": "0.9713618689231519",
      "vi": "0.9713785538751588"
    },
    "canonical_solution": "    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` para resolver el siguiente problema:\nDetermina el ganador en un juego de Piedra-Papel-Tijeras jugado durante un número de rondas.\n    Los jugadores A y B tienen sus propios patrones repetitivos de movimientos.\n    Piedra (representada por 0) vence a Tijeras (2), Tijeras vence a Papel (5), y Papel vence a Piedra.\n    Si ambos jugadores eligen el mismo movimiento, la ronda es un empate.\n\n    Ejemplos:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "arb": "اكتب دالة C# `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` لحل المشكلة التالية:\nتحديد الفائز في لعبة حجر-ورق-مقص تُلعب لعدد من الجولات.\n    اللاعبان A و B لديهما أنماط متكررة خاصة بهما من الحركات.\n    الحجر (يمثله 0) يهزم المقص (2)، المقص يهزم الورق (5)، والورق يهزم الحجر.\n    إذا اختار كلا اللاعبين نفس الحركة، تكون الجولة تعادل.\n\n    أمثلة:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "sw": "Andika kazi ya C# `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` kutatua tatizo lifuatalo:\nInabainisha mshindi katika mchezo wa Jiwe-Karatasi-Makasi uliochezwa kwa idadi ya raundi.\n    Wachezaji A na B wana mifumo yao inayorudiwa ya hatua.\n    Jiwe (linalowakilishwa na 0) linashinda Makasi (2), Makasi yanashinda Karatasi (5), na Karatasi inashinda Jiwe.\n    Ikiwa wachezaji wote wawili watachagua hatua sawa, raundi ni sare.\n\n    Mifano:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "tr": "Bir C# fonksiyonu `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` yazın ve aşağıdaki problemi çözün:\nTaş-Kağıt-Makas oyununda belirli sayıda tur için kazananı belirler.\n    Oyuncular A ve B'nin kendi tekrar eden hamle desenleri vardır.\n    Taş (0 ile temsil edilir) Makas'ı (2) yener, Makas Kağıt'ı (5) yener, ve Kağıt Taş'ı yener.\n    Eğer her iki oyuncu da aynı hamleyi seçerse, tur berabere biter.\n\n    Örnekler:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "vi": "Viết một hàm C# `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` để giải quyết vấn đề sau:\nXác định người chiến thắng trong trò chơi Kéo-Búa-Bao được chơi trong một số vòng.\nNgười chơi A và B có mẫu di chuyển lặp lại riêng của họ.\nBúa (được biểu diễn bằng 0) thắng Kéo (2), Kéo thắng Bao (5), và Bao thắng Búa.\nNếu cả hai người chơi chọn cùng một nước đi, vòng đó là hòa.\n\n    Ví dụ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\""
    },
    "instruction_bertscore": {
      "es": "0.9877004095455576",
      "arb": "0.9889712467234189",
      "sw": "0.9894912610609682",
      "tr": "0.9841995490798178",
      "vi": "0.9794369884337443"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(5, new List<int> {0, 0, 0}, new List<int> {2, 2, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2}) == \"draw\");\n    }\n}",
    "entry_point": "DetermineWinner",
    "signature": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
    "docstring": {
      "es": "Determina el ganador en un juego de Piedra-Papel-Tijeras jugado durante un número de rondas.\n    Los jugadores A y B tienen sus propios patrones repetitivos de movimientos.\n    Piedra (representada por 0) vence a Tijeras (2), Tijeras vence a Papel (5), y Papel vence a Piedra.\n    Si ambos jugadores eligen el mismo movimiento, la ronda es un empate.\n\n    Ejemplos:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "arb": "يحدد الفائز في لعبة حجر-ورقة-مقص التي تُلعب لعدد من الجولات.\n    اللاعبان A و B لديهما أنماط متكررة خاصة بهما من الحركات.\n    الحجر (يمثله 0) يهزم المقص (2)، المقص يهزم الورقة (5)، والورقة تهزم الحجر.\n    إذا اختار كلا اللاعبين نفس الحركة، تكون الجولة تعادل.\n\n    أمثلة:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "sw": "Inabainisha mshindi katika mchezo wa Jiwe-Karatasi-Makasi uliochezwa kwa idadi ya raundi.\n    Wachezaji A na B wana mifumo yao ya kurudia ya hatua.\n    Jiwe (linalowakilishwa na 0) linashinda Makasi (2), Makasi yanashinda Karatasi (5), na Karatasi inashinda Jiwe.\n    Ikiwa wachezaji wote wawili watachagua hatua sawa, raundi ni sare.\n\n    Mifano:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "tr": "Bir dizi tur için oynanan Taş-Kağıt-Makas oyununda kazananı belirler.\n    Oyuncular A ve B'nin kendi tekrar eden hamle desenleri vardır.\n    Taş (0 ile temsil edilir) Makas'ı (2) yener, Makas Kağıt'ı (5) yener ve Kağıt Taş'ı yener.\n    Her iki oyuncu da aynı hamleyi seçerse, tur berabere biter.\n\n    Örnekler:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "vi": "Xác định người chiến thắng trong trò chơi Kéo-Búa-Bao được chơi qua một số vòng.  \nNgười chơi A và B có các mẫu di chuyển lặp lại của riêng họ.  \nBúa (được biểu diễn bởi 0) thắng Kéo (2), Kéo thắng Bao (5), và Bao thắng Búa.  \nNếu cả hai người chơi chọn cùng một nước đi, vòng đó là hòa.\n\nVí dụ:\n>>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n\"draw\""
    },
    "docstring_bertscore": {
      "es": "0.9819035805054355",
      "arb": "0.9946228769550045",
      "sw": "0.9857488660518898",
      "tr": "0.9869271414721889",
      "vi": "0.9673276858843333"
    }
  },
  {
    "task_id": "C#/23",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Calcular el producto punto de dos vectores enteros n-dimensionales.\n    El producto punto es la suma de los productos de los elementos correspondientes de los dos vectores.\n\n    Ejemplo 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Ejemplo 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    احسب الجداء النقطي لمتجهين صحيحين ذوي أبعاد n.\n    الجداء النقطي هو مجموع نواتج العناصر المقابلة للمتجهين.\n\n    مثال 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    مثال 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Hesabu tokeo la nukta la vekta mbili za n-dimensional integer.\n    Tokeo la nukta ni jumla ya bidhaa za vipengele vinavyolingana vya vekta mbili.\n\n    Mfano 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Mfano 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    İki n boyutlu tamsayı vektörünün nokta çarpımını hesapla.\n    Nokta çarpımı, iki vektörün karşılık gelen elemanlarının çarpımlarının toplamıdır.\n\n    Örnek 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Örnek 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Tính tích vô hướng của hai vector số nguyên n chiều.\n    Tích vô hướng là tổng của các tích của các phần tử tương ứng của hai vector.\n\n    Ví dụ 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Ví dụ 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9879923962056789",
      "sw": "1",
      "tr": "1",
      "vi": "1"
    },
    "canonical_solution": "{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` para resolver el siguiente problema:\nCalcula el producto punto de dos vectores enteros n-dimensionales.\n    El producto punto es la suma de los productos de los elementos correspondientes de los dos vectores.\n\n    Ejemplo 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Ejemplo 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "arb": "اكتب دالة C# `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` لحل المشكلة التالية:\nاحسب حاصل الضرب النقطي لمتجهين صحيحين ذوي أبعاد n.\n    حاصل الضرب النقطي هو مجموع نواتج العناصر المقابلة للمتجهين.\n\n    المثال 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    المثال 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "sw": "Andika kazi ya C# `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` kutatua tatizo lifuatalo:\nHesabu dot product ya vectors mbili za n-dimensional integer.\n    Dot product ni jumla ya bidhaa za vipengele vinavyolingana vya vectors mbili.\n\n    Mfano 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Mfano 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "tr": "Bir C# fonksiyonu `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` yazın ve aşağıdaki problemi çözün:\nİki n boyutlu tamsayı vektörünün nokta çarpımını hesaplayın.\n    Nokta çarpımı, iki vektörün karşılık gelen elemanlarının çarpımlarının toplamıdır.\n\n    Örnek 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Örnek 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "vi": "Viết một hàm C# `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` để giải quyết vấn đề sau:\nTính tích vô hướng của hai vector số nguyên n chiều.\n    Tích vô hướng là tổng của các tích của các phần tử tương ứng của hai vector.\n\n    Ví dụ 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Ví dụ 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100"
    },
    "instruction_bertscore": {
      "es": "0.9949176444404603",
      "arb": "0.9886200682097492",
      "sw": "1",
      "tr": "0.9977197232257194",
      "vi": "1"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1}) == 3);\n        Debug.Assert(CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8}) == 92);\n        Debug.Assert(CalculateDotProduct(new List<int> {0, 0, 0}, new List<int> {0, 0, 0}) == 0);\n        Debug.Assert(CalculateDotProduct(new List<int> {1, 2}, new List<int> {3, 4}) == 11);\n\n    }\n}",
    "entry_point": "CalculateDotProduct",
    "signature": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
    "docstring": {
      "es": "Calcular el producto punto de dos vectores enteros n-dimensionales.  \n    El producto punto es la suma de los productos de los elementos correspondientes de los dos vectores.\n\n    Ejemplo 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Ejemplo 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "arb": "احسب الجداء النقطي لمتجهين صحيحين ذو أبعاد n.\n    الجداء النقطي هو مجموع نواتج العناصر المتناظرة للمتجهين.\n\n    المثال 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    المثال 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "sw": "Hesabu tokeo la nukta la vekta mbili za n-dimensional zenye namba nzima.\n    Tokeo la nukta ni jumla ya bidhaa za vipengele vinavyolingana vya vekta hizo mbili.\n\n    Mfano 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Mfano 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "tr": "İki n boyutlu tamsayı vektörünün nokta çarpımını hesaplayın. \n    Nokta çarpımı, iki vektörün karşılık gelen elemanlarının çarpımlarının toplamıdır.\n\n    Örnek 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Örnek 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "vi": "Tính tích vô hướng của hai vector số nguyên n chiều.  \n    Tích vô hướng là tổng của các tích của các phần tử tương ứng của hai vector.\n\n    Ví dụ 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Ví dụ 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9821437246361067",
      "sw": "0.9889593289005568",
      "tr": "1",
      "vi": "1"
    }
  },
  {
    "task_id": "C#/24",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Calcular el valor de 2 elevado a la potencia de un entero no negativo dado 'n'.\n    Esta función utiliza aritmética de alta precisión para manejar exponentes grandes.\n    Ejemplos:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* احسب قيمة 2 مرفوعة إلى قوة عدد صحيح غير سالب 'n'.\n    تستخدم هذه الدالة الحسابات ذات الدقة العالية للتعامل مع الأسس الكبيرة.\n    أمثلة:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Hesabu thamani ya 2 iliyopandishwa kwa nguvu ya nambari kamili isiyo hasi 'n'.\n    Kazi hii hutumia hesabu ya usahihi wa juu kushughulikia viinua vikubwa.\n    Mifano:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Verilen negatif olmayan bir tam sayı 'n' için 2'nin kuvvetini hesapla.\n    Bu fonksiyon, büyük üsleri işlemek için yüksek hassasiyetli aritmetik kullanır.\n    Örnekler:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Tính giá trị của 2 lũy thừa của một số nguyên không âm 'n' cho trước.\n    Hàm này sử dụng số học độ chính xác cao để xử lý các số mũ lớn.\n    Ví dụ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9904321731759305",
      "sw": "0.9946620071400684",
      "tr": "0.9656820331774593",
      "vi": "0.9961030705544766"
    },
    "canonical_solution": "    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static BigInteger CalculatePowerOfTwo(int n)` para resolver el siguiente problema:\nCalcula el valor de 2 elevado a la potencia de un entero no negativo 'n'.\n    Esta función utiliza aritmética de alta precisión para manejar exponentes grandes.\n    Ejemplos:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "arb": "اكتب دالة C# `static BigInteger CalculatePowerOfTwo(int n)` لحل المشكلة التالية:\nاحسب قيمة 2 مرفوعة إلى قوة عدد صحيح غير سالب 'n'.\n    تستخدم هذه الدالة الحسابات عالية الدقة للتعامل مع الأسس الكبيرة.\n    أمثلة:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "sw": "Andika kazi ya C# `static BigInteger CalculatePowerOfTwo(int n)` kutatua tatizo lifuatalo:\nHesabu thamani ya 2 iliyoinuliwa kwa nguvu ya nambari isiyo hasi 'n' iliyotolewa.\n    Kazi hii hutumia hesabu ya usahihi wa hali ya juu kushughulikia viinua vikubwa.\n    Mifano:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "tr": "Bir C# fonksiyonu `static BigInteger CalculatePowerOfTwo(int n)` yazın ve aşağıdaki problemi çözün:\nVerilen bir negatif olmayan tamsayı 'n' için 2'nin n'inci kuvvetini hesaplayın.\n    Bu fonksiyon, büyük üsleri işlemek için yüksek hassasiyetli aritmetik kullanır.\n    Örnekler:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "vi": "Viết một hàm C# `static BigInteger CalculatePowerOfTwo(int n)` để giải quyết vấn đề sau:\nTính giá trị của 2 mũ một số nguyên không âm 'n' đã cho.\n    Hàm này sử dụng số học độ chính xác cao để xử lý các số mũ lớn.\n    Ví dụ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1"
    },
    "instruction_bertscore": {
      "es": "0.9908457216292451",
      "arb": "0.9892656169481125",
      "sw": "0.9916958596600745",
      "tr": "0.9563070764533746",
      "vi": "0.9983195869764449"
    },
    "level": "easy",
    "test": "    static void Main()\n    {           \n        Debug.Assert(CalculatePowerOfTwo(3).Equals(new BigInteger(8)));\n        Debug.Assert(CalculatePowerOfTwo(10).Equals(new BigInteger(1024)));\n        Debug.Assert(CalculatePowerOfTwo(15).Equals(new BigInteger(32768)));\n        Debug.Assert(CalculatePowerOfTwo(0).Equals(new BigInteger(1)));\n\n    }\n}\n",
    "entry_point": "CalculatePowerOfTwo",
    "signature": "static BigInteger CalculatePowerOfTwo(int n)",
    "docstring": {
      "es": "Calcular el valor de 2 elevado a la potencia de un entero no negativo 'n'.\n    Esta función utiliza aritmética de alta precisión para manejar exponentes grandes.\n    Ejemplos:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "arb": "احسب قيمة 2 مرفوعة إلى قوة عدد صحيح غير سالب 'n'.\n    تستخدم هذه الدالة الحساب الدقيق للتعامل مع الأسس الكبيرة.\n    أمثلة:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "sw": "Hesabu thamani ya 2 iliyoinuliwa kwa nguvu ya nambari kamili isiyo na hasi 'n'.\n    Kazi hii inatumia hesabu ya usahihi wa juu kushughulikia viinua juu vikubwa.\n    Mifano:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "tr": "Verilen negatif olmayan bir tamsayı 'n' için 2'nin kuvvetini hesaplayın.\n    Bu fonksiyon, büyük üsleri işlemek için yüksek hassasiyetli aritmetik kullanır.\n    Örnekler:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "vi": "Tính giá trị của 2 lũy thừa của một số nguyên không âm 'n' được cho.\n    Hàm này sử dụng số học độ chính xác cao để xử lý các số mũ lớn.\n    Ví dụ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1"
    },
    "docstring_bertscore": {
      "es": "0.9912008727505355",
      "arb": "0.9672901447423177",
      "sw": "0.9718588421365012",
      "tr": "0.9611985482167398",
      "vi": "0.9976281546200624"
    }
  },
  {
    "task_id": "C#/25",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Encuentra el primer carácter en una cadena que aparece solo una vez.\n   Si todos los caracteres aparecen más de una vez o la cadena está vacía, devuelve 'n' como carácter.\n   Ejemplos:\n   - FirstUniqueChar(\"aabbcdde\") debería devolver 'c'.\n   - FirstUniqueChar(\"aabbcc\") debería devolver 'n', representando \"no\".\n   - FirstUniqueChar(\"xxyyzz\") debería devolver 'n'.\n   - FirstUniqueChar(\"\") debería devolver 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يجد أول حرف في سلسلة يظهر مرة واحدة فقط.\n   إذا ظهرت جميع الأحرف أكثر من مرة أو كانت السلسلة فارغة، فإنه يعيد 'n' كحرف.\n   أمثلة:\n   - FirstUniqueChar(\"aabbcdde\") يجب أن يعيد 'c'.\n   - FirstUniqueChar(\"aabbcc\") يجب أن يعيد 'n'، ممثلاً \"لا\".\n   - FirstUniqueChar(\"xxyyzz\") يجب أن يعيد 'n'.\n   - FirstUniqueChar(\"\") يجب أن يعيد 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inapata herufi ya kwanza katika kamba ambayo inaonekana mara moja tu.\n   Ikiwa herufi zote zinaonekana zaidi ya mara moja au kamba ni tupu, inarudisha 'no' kama herufi.\n   Mifano:\n   - FirstUniqueChar(\"aabbcdde\") inapaswa kurudisha 'c'.\n   - FirstUniqueChar(\"aabbcc\") inapaswa kurudisha 'n', ikiwakilisha \"no\".\n   - FirstUniqueChar(\"xxyyzz\") inapaswa kurudisha 'n'.\n   - FirstUniqueChar(\"\") inapaswa kurudisha 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bir dizgede yalnızca bir kez görünen ilk karakteri bulur.\n   Tüm karakterler birden fazla kez görünüyorsa veya dizge boşsa, bir karakter olarak 'no' döndürür.\n   Örnekler:\n   - FirstUniqueChar(\"aabbcdde\") 'c' döndürmelidir.\n   - FirstUniqueChar(\"aabbcc\") 'n', yani \"no\" döndürmelidir.\n   - FirstUniqueChar(\"xxyyzz\") 'n' döndürmelidir.\n   - FirstUniqueChar(\"\") 'n' döndürmelidir.\n*/\n    static char FirstUniqueChar(string str)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tìm ký tự đầu tiên trong một chuỗi chỉ xuất hiện một lần.\n   Nếu tất cả các ký tự xuất hiện nhiều hơn một lần hoặc chuỗi rỗng, nó trả về 'n' như một ký tự.\n   Ví dụ:\n   - FirstUniqueChar(\"aabbcdde\") nên trả về 'c'.\n   - FirstUniqueChar(\"aabbcc\") nên trả về 'n', đại diện cho \"không\".\n   - FirstUniqueChar(\"xxyyzz\") nên trả về 'n'.\n   - FirstUniqueChar(\"\") nên trả về 'n'.\n*/\n    static char FirstUniqueChar(string str)"
    },
    "prompt_bertscore": {
      "es": "0.9910677903952421",
      "arb": "0.9946862400465547",
      "sw": "0.9973774830791964",
      "tr": "0.9910932150840146",
      "vi": "0.9850411460042626"
    },
    "canonical_solution": "    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static char FirstUniqueChar(string str)` para resolver el siguiente problema:\nEncuentra el primer carácter en una cadena que aparece solo una vez.\n   Si todos los caracteres aparecen más de una vez o la cadena está vacía, devuelve 'n' como carácter.\n   Ejemplos:\n   - FirstUniqueChar(\"aabbcdde\") debería devolver 'c'.\n   - FirstUniqueChar(\"aabbcc\") debería devolver 'n', representando \"no\".\n   - FirstUniqueChar(\"xxyyzz\") debería devolver 'n'.\n   - FirstUniqueChar(\"\") debería devolver 'n'.",
      "arb": "اكتب دالة C# `static char FirstUniqueChar(string str)` لحل المشكلة التالية:\nيجد أول حرف في سلسلة يظهر مرة واحدة فقط.\nإذا ظهرت جميع الأحرف أكثر من مرة أو كانت السلسلة فارغة، فإنه يعيد 'n' كحرف.\nأمثلة:\n- يجب أن تعيد FirstUniqueChar(\"aabbcdde\") الحرف 'c'.\n- يجب أن تعيد FirstUniqueChar(\"aabbcc\") الحرف 'n'، مما يمثل \"no\".\n- يجب أن تعيد FirstUniqueChar(\"xxyyzz\") الحرف 'n'.\n- يجب أن تعيد FirstUniqueChar(\"\") الحرف 'n'.",
      "sw": "Andika kazi ya C# `static char FirstUniqueChar(string str)` kutatua tatizo lifuatalo:\nInapata herufi ya kwanza katika kamba ambayo inaonekana mara moja tu.\n   Ikiwa herufi zote zinaonekana zaidi ya mara moja au kamba ni tupu, inarudisha 'no' kama herufi.\n   Mifano:\n   - FirstUniqueChar(\"aabbcdde\") inapaswa kurudisha 'c'.\n   - FirstUniqueChar(\"aabbcc\") inapaswa kurudisha 'n', ikiwakilisha \"no\".\n   - FirstUniqueChar(\"xxyyzz\") inapaswa kurudisha 'n'.\n   - FirstUniqueChar(\"\") inapaswa kurudisha 'n'.",
      "tr": "Bir C# fonksiyonu `static char FirstUniqueChar(string str)` yazın ve aşağıdaki problemi çözün:\nBir dizgede yalnızca bir kez görünen ilk karakteri bulur.\n   Eğer tüm karakterler birden fazla kez görünüyorsa veya dizge boşsa, bir karakter olarak 'no' döndürür.\n   Örnekler:\n   - FirstUniqueChar(\"aabbcdde\") 'c' döndürmelidir.\n   - FirstUniqueChar(\"aabbcc\") 'n', yani \"no\"yu temsil eden bir değer döndürmelidir.\n   - FirstUniqueChar(\"xxyyzz\") 'n' döndürmelidir.\n   - FirstUniqueChar(\"\") 'n' döndürmelidir.",
      "vi": "Viết một hàm C# `static char FirstUniqueChar(string str)` để giải quyết vấn đề sau:\nTìm ký tự đầu tiên trong một chuỗi chỉ xuất hiện một lần.\n   Nếu tất cả các ký tự xuất hiện nhiều hơn một lần hoặc chuỗi rỗng, nó trả về 'n' như một ký tự.\n   Ví dụ:\n   - FirstUniqueChar(\"aabbcdde\") nên trả về 'c'.\n   - FirstUniqueChar(\"aabbcc\") nên trả về 'n', đại diện cho \"no\".\n   - FirstUniqueChar(\"xxyyzz\") nên trả về 'n'.\n   - FirstUniqueChar(\"\") nên trả về 'n'."
    },
    "instruction_bertscore": {
      "es": "0.9827400130399734",
      "arb": "0.9709324300393545",
      "sw": "0.994170396947007",
      "tr": "0.9758848813296973",
      "vi": "0.9871941007042997"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n        Debug.Assert(FirstUniqueChar(\"aabbcdde\") == 'c');\n        Debug.Assert(FirstUniqueChar(\"aabbcc\") == 'n');\n        Debug.Assert(FirstUniqueChar(\"xxyyazz\") == 'a');\n        Debug.Assert(FirstUniqueChar(\"\") == 'n');\n        Debug.Assert(FirstUniqueChar(\"aabbcceeddf\") == 'f');\n\n    }\n}",
    "entry_point": "FirstUniqueChar",
    "signature": "static char FirstUniqueChar(string str)",
    "docstring": {
      "es": "Encuentra el primer carácter en una cadena que aparece solo una vez.\n   Si todos los caracteres aparecen más de una vez o la cadena está vacía, devuelve 'n' como carácter.\n   Ejemplos:\n   - FirstUniqueChar(\"aabbcdde\") debería devolver 'c'.\n   - FirstUniqueChar(\"aabbcc\") debería devolver 'n', representando \"no\".\n   - FirstUniqueChar(\"xxyyzz\") debería devolver 'n'.\n   - FirstUniqueChar(\"\") debería devolver 'n'.",
      "arb": "يعثر على أول حرف في سلسلة يظهر مرة واحدة فقط. \n   إذا ظهرت جميع الأحرف أكثر من مرة أو كانت السلسلة فارغة، فإنه يعيد 'n' كحرف. \n   أمثلة:\n   - FirstUniqueChar(\"aabbcdde\") يجب أن يعيد 'c'.\n   - FirstUniqueChar(\"aabbcc\") يجب أن يعيد 'n'، مما يمثل \"لا\".\n   - FirstUniqueChar(\"xxyyzz\") يجب أن يعيد 'n'.\n   - FirstUniqueChar(\"\") يجب أن يعيد 'n'.",
      "sw": "Inapata herufi ya kwanza katika kamba ambayo inaonekana mara moja tu.  \nIkiwa herufi zote zinaonekana zaidi ya mara moja au kamba ni tupu, inarudisha 'n' kama herufi.  \nMifano:  \n- FirstUniqueChar(\"aabbcdde\") inapaswa kurudisha 'c'.  \n- FirstUniqueChar(\"aabbcc\") inapaswa kurudisha 'n', ikiwakilisha \"hapana\".  \n- FirstUniqueChar(\"xxyyzz\") inapaswa kurudisha 'n'.  \n- FirstUniqueChar(\"\") inapaswa kurudisha 'n'.  ",
      "tr": "İlk kez yalnızca bir kez görünen bir karakteri bir dizede bulur.\n   Eğer tüm karakterler birden fazla kez görünüyorsa veya dize boşsa, bir karakter olarak 'n' döndürür.\n   Örnekler:\n   - FirstUniqueChar(\"aabbcdde\") 'c' döndürmelidir.\n   - FirstUniqueChar(\"aabbcc\") 'n' döndürmelidir, bu \"hayır\" anlamına gelir.\n   - FirstUniqueChar(\"xxyyzz\") 'n' döndürmelidir.\n   - FirstUniqueChar(\"\") 'n' döndürmelidir.",
      "vi": "Tìm ký tự đầu tiên trong một chuỗi chỉ xuất hiện một lần.\n   Nếu tất cả các ký tự xuất hiện nhiều hơn một lần hoặc chuỗi rỗng, nó trả về 'n' như một ký tự.\n   Ví dụ:\n   - FirstUniqueChar(\"aabbcdde\") nên trả về 'c'.\n   - FirstUniqueChar(\"aabbcc\") nên trả về 'n', đại diện cho \"không\".\n   - FirstUniqueChar(\"xxyyzz\") nên trả về 'n'.\n   - FirstUniqueChar(\"\") nên trả về 'n'."
    },
    "docstring_bertscore": {
      "es": "0.9717192049786336",
      "arb": "0.9919806956264785",
      "sw": "0.9829094447549962",
      "tr": "0.9539552927419216",
      "vi": "0.9782469938209643"
    }
  },
  {
    "task_id": "C#/26",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina si dos secuencias de ADN están relacionadas basándose en el umbral de similitud.\n   La función compara dos secuencias de ADN de la misma longitud, par de bases por par de bases.\n   Si la proporción de pares de bases idénticos es mayor o igual al umbral dado,\n   las secuencias se consideran relacionadas.\n   \n   Ejemplo:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد ما إذا كانت سلسلتان من الحمض النووي متعلقتين بناءً على عتبة التشابه.\n   تقارن الدالة سلسلتين من الحمض النووي لهما نفس الطول، زوج قاعدة بزوج قاعدة.\n   إذا كانت نسبة أزواج القواعد المتطابقة أكبر من أو تساوي العتبة المعطاة،\n   تعتبر السلسلتان متعلقتين.\n   \n   مثال:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Huamua ikiwa mlolongo miwili ya DNA yanahusiana kulingana na kizingiti cha ufanano.\n   Kazi inalinganisha mlolongo miwili ya DNA yenye urefu sawa, jozi kwa jozi.\n   Ikiwa uwiano wa jozi sawa za msingi ni mkubwa au sawa na kizingiti kilichopewa,\n   milolongo hiyo inachukuliwa kuwa inahusiana.\n   \n   Mfano:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* İki DNA dizisinin benzerlik eşiğine göre ilişkili olup olmadığını belirler.\n   Fonksiyon, aynı uzunluktaki iki DNA dizisini baz çift bazında karşılaştırır.\n   Eğer aynı baz çiftlerinin oranı verilen eşikten büyük veya eşitse,\n   diziler ilişkili kabul edilir.\n   \n   Örnek:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định xem hai chuỗi DNA có liên quan dựa trên ngưỡng tương đồng hay không.\n   Hàm so sánh hai chuỗi DNA có cùng độ dài, từng cặp base một.\n   Nếu tỷ lệ các cặp base giống nhau lớn hơn hoặc bằng ngưỡng cho trước,\n   các chuỗi được coi là liên quan.\n   \n   Ví dụ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9883854857297469",
      "sw": "0.9821375670942946",
      "tr": "0.9737011389205997",
      "vi": "0.9817772515830973"
    },
    "canonical_solution": "    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` para resolver el siguiente problema:\nDetermina si dos secuencias de ADN están relacionadas basándose en el umbral de similitud.\n   La función compara dos secuencias de ADN de la misma longitud, par de bases por par de bases.\n   Si la proporción de pares de bases idénticos es mayor o igual al umbral dado,\n   las secuencias se consideran relacionadas.\n   \n   Ejemplo:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "arb": "اكتب دالة C# `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` لحل المشكلة التالية:\nتحديد ما إذا كانت سلسلتان من الحمض النووي مرتبطتين بناءً على عتبة التشابه.\n   تقارن الدالة بين سلسلتين من الحمض النووي لهما نفس الطول، زوج قاعدة بزوج قاعدة.\n   إذا كانت نسبة أزواج القواعد المتطابقة أكبر من أو تساوي العتبة المعطاة،\n   تعتبر السلاسل مرتبطة.\n\n   مثال:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "sw": "Andika kazi ya C# `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` kutatua tatizo lifuatalo:\nInabainisha kama mlolongo miwili ya DNA inahusiana kulingana na kizingiti cha kufanana.\n   Kazi inalinganisha milolongo miwili ya DNA yenye urefu sawa, jozi ya besi kwa jozi ya besi.\n   Ikiwa uwiano wa jozi za besi zinazofanana ni mkubwa au sawa na kizingiti kilichopewa,\n   milolongo inachukuliwa kuwa inahusiana.\n   \n   Mfano:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "tr": "Bir C# fonksiyonu `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` yazın:\nAşağıdaki problemi çözmek için:\nİki DNA dizisinin benzerlik eşiğine göre ilişkili olup olmadığını belirler.\n   Fonksiyon, aynı uzunluktaki iki DNA dizisini baz çift baz çift karşılaştırır.\n   Eğer özdeş baz çiftlerinin oranı verilen eşikten büyük veya eşitse,\n   diziler ilişkili kabul edilir.\n   \n   Örnek:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "vi": "Viết một hàm C# `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` để giải quyết vấn đề sau:\nXác định xem hai chuỗi DNA có liên quan hay không dựa trên ngưỡng tương đồng.\n   Hàm so sánh hai chuỗi DNA có cùng độ dài, từng cặp base với nhau.\n   Nếu tỷ lệ các cặp base giống nhau lớn hơn hoặc bằng ngưỡng đã cho,\n   các chuỗi được coi là có liên quan.\n   \n   Ví dụ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true"
    },
    "instruction_bertscore": {
      "es": "0.9877280191685215",
      "arb": "0.9797097079469052",
      "sw": "0.9829970407530325",
      "tr": "0.9795589474876997",
      "vi": "0.9804913184962775"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(AreDNAsRelated(\"ATCGCCGTAAGTAACGGTTTTAAATAGGCC\", \"ATCGCCGGAAGTAACGGTCTTAAATAGGCC\", 0.85) == true);\n        Debug.Assert(AreDNAsRelated(\"GGCATGAC\", \"TGACATGC\", 0.50) == false);\n        Debug.Assert(AreDNAsRelated(\"AAAA\", \"AAAA\", 1.00) == true);\n        Debug.Assert(AreDNAsRelated(\"CCCC\", \"GGTT\", 0.25) == false);\n\n    }\n}",
    "entry_point": "AreDNAsRelated",
    "signature": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
    "docstring": {
      "es": "Determina si dos secuencias de ADN están relacionadas basándose en el umbral de similitud.\n   La función compara dos secuencias de ADN de la misma longitud, par de bases por par de bases.\n   Si la proporción de pares de bases idénticos es mayor o igual al umbral dado,\n   las secuencias se consideran relacionadas.\n   \n   Ejemplo:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "arb": "يحدد ما إذا كانت سلسلتان من الحمض النووي مرتبطتين بناءً على عتبة التشابه.\n   تقارن الدالة سلسلتين من الحمض النووي لهما نفس الطول، زوج قاعدة بزوج قاعدة.\n   إذا كانت نسبة أزواج القواعد المتطابقة أكبر من أو تساوي العتبة المعطاة،\n   تعتبر السلاسل مرتبطة.\n   \n   مثال:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "sw": "Inabainisha ikiwa mlolongo miwili ya DNA yanahusiana kulingana na kizingiti cha kufanana.\n   Kazi inalinganisha mlolongo miwili ya DNA yenye urefu sawa, jozi ya besi kwa jozi ya besi.\n   Ikiwa uwiano wa jozi za besi zinazofanana ni kubwa au sawa na kizingiti kilichopewa,\n   milolongo hiyo inachukuliwa kuwa inahusiana.\n   \n   Mfano:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "tr": "İki DNA dizisinin benzerlik eşiğine göre ilişkili olup olmadığını belirler.\n   Fonksiyon, aynı uzunluktaki iki DNA dizisini baz çift bazında karşılaştırır.\n   Eğer özdeş baz çiftlerinin oranı verilen eşikten büyük veya eşit ise,\n   diziler ilişkili kabul edilir.\n   \n   Örnek:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "vi": "Xác định xem hai chuỗi DNA có liên quan với nhau dựa trên ngưỡng tương đồng.\n   Hàm so sánh hai chuỗi DNA có cùng độ dài, từng cặp base một.\n   Nếu tỷ lệ các cặp base giống nhau lớn hơn hoặc bằng ngưỡng đã cho,\n   các chuỗi được coi là có liên quan.\n\n   Ví dụ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9842718505385144",
      "sw": "0.9857943524091468",
      "tr": "0.9652945053040602",
      "vi": "0.9725327950193525"
    }
  },
  {
    "task_id": "C#/27",
    "prompt": {
      "es": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Esta función toma una cadena como entrada y devuelve una cadena 'Amigo Cercano' basada en manipulaciones específicas de valores ASCII.\n   La cadena Amigo Cercano se genera sumando los valores ASCII de cada par de caracteres adyacentes en la cadena de entrada,\n   creando un nuevo carácter a partir de la suma. Para el último carácter de la cadena Amigo Cercano, suma el valor ASCII del\n   último y primer caracteres de la cadena de entrada. La longitud de la cadena de entrada debe estar entre 2 y 100 caracteres, y\n   el valor ASCII de cada carácter no debe exceder 63.\n\n   Ejemplo:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "arb": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* تأخذ هذه الدالة سلسلة نصية كمدخل وتعيد سلسلة \"الصديق المقرب\" بناءً على تلاعبات محددة بقيم ASCII.\n   يتم إنشاء سلسلة الصديق المقرب عن طريق جمع قيم ASCII لكل زوج من الأحرف المتجاورة في السلسلة المدخلة،\n   وإنشاء حرف جديد من المجموع. بالنسبة للحرف الأخير من سلسلة الصديق المقرب، يتم جمع قيمة ASCII للحرف الأخير والأول\n   من السلسلة المدخلة. يجب أن يكون طول السلسلة المدخلة بين 2 و100 حرف، ويجب ألا تتجاوز قيمة ASCII لكل حرف 63.\n\n   مثال:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "sw": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Kazi ya hii kazi ni kuchukua kamba kama ingizo na kurudisha kamba ya 'Rafiki wa Karibu' kulingana na mabadiliko maalum ya thamani za ASCII.\n   Kamba ya Rafiki wa Karibu inatengenezwa kwa kujumlisha thamani za ASCII za kila jozi ya herufi zinazofuatana katika kamba ya ingizo,\n   ikitengeneza herufi mpya kutoka kwenye jumla hiyo. Kwa herufi ya mwisho ya kamba ya Rafiki wa Karibu, jumlisha thamani ya ASCII ya \n   herufi ya mwisho na ya kwanza ya kamba ya ingizo. Urefu wa kamba ya ingizo unapaswa kuwa kati ya herufi 2 na 100, na \n   thamani ya ASCII ya kila herufi haipaswi kuzidi 63.\n\n   Mfano:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "tr": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Bu fonksiyon bir dizeyi girdi olarak alır ve belirli ASCII değeri manipülasyonlarına dayalı bir 'Yakın Arkadaş' dizesi döndürür.\n   Yakın Arkadaş dizesi, giriş dizisindeki bitişik karakter çiftlerinin ASCII değerlerinin toplanmasıyla oluşturulur,\n   toplamdan yeni bir karakter oluşturulur. Yakın Arkadaş dizesinin son karakteri için, giriş dizisinin \n   son ve ilk karakterlerinin ASCII değerlerini toplayın. Giriş dizisinin uzunluğu 2 ile 100 karakter arasında olmalı ve \n   her karakterin ASCII değeri 63'ü geçmemelidir.\n\n   Örnek:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "vi": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Hàm này nhận một chuỗi đầu vào và trả về một chuỗi 'Close Friend' dựa trên các thao tác giá trị ASCII cụ thể.\n   Chuỗi Close Friend được tạo ra bằng cách cộng các giá trị ASCII của từng cặp ký tự liền kề trong chuỗi đầu vào,\n   tạo ra một ký tự mới từ tổng đó. Đối với ký tự cuối cùng của chuỗi Close Friend, cộng giá trị ASCII của \n   ký tự cuối cùng và ký tự đầu tiên của chuỗi đầu vào. Độ dài chuỗi đầu vào nên nằm trong khoảng từ 2 đến 100 ký tự, và \n   giá trị ASCII của mỗi ký tự không được vượt quá 63.\n\n   Ví dụ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)"
    },
    "prompt_bertscore": {
      "es": "0.972859939256917",
      "arb": "0.9698806821717747",
      "sw": "0.9664348423215815",
      "tr": "0.9762205666736463",
      "vi": "0.9605674994961919"
    },
    "canonical_solution": "    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static string GenerateCloseFriendString(string inputString)` para resolver el siguiente problema:\nEsta función toma una cadena como entrada y devuelve una cadena de 'Amigo Cercano' basada en manipulaciones específicas de valores ASCII.\n   La cadena de Amigo Cercano se genera sumando los valores ASCII de cada par de caracteres adyacentes en la cadena de entrada,\n   creando un nuevo carácter a partir de la suma. Para el último carácter de la cadena de Amigo Cercano, suma el valor ASCII de los\n   últimos y primeros caracteres de la cadena de entrada. La longitud de la cadena de entrada debe estar entre 2 y 100 caracteres, y\n   el valor ASCII de cada carácter no debe exceder 63.\n\n   Ejemplo:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "arb": "اكتب دالة C# `static string GenerateCloseFriendString(string inputString)` لحل المشكلة التالية:\nتأخذ هذه الدالة سلسلة نصية كمدخل وتعيد سلسلة \"الصديق المقرب\" بناءً على تلاعبات معينة بقيم ASCII.\n   يتم إنشاء سلسلة الصديق المقرب عن طريق جمع قيم ASCII لكل زوج من الأحرف المتجاورة في السلسلة المدخلة،\n   وإنشاء حرف جديد من المجموع. بالنسبة للحرف الأخير من سلسلة الصديق المقرب، اجمع قيمة ASCII للحرف الأخير والأول من السلسلة المدخلة. يجب أن يكون طول السلسلة المدخلة بين 2 و100 حرف، \n   ويجب ألا تتجاوز قيمة ASCII لكل حرف 63.\n\n   مثال:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "sw": "Andika kazi ya C# `static string GenerateCloseFriendString(string inputString)` kutatua tatizo lifuatalo:\nKazi hii inachukua kamba kama ingizo na kurudisha kamba ya 'Rafiki wa Karibu' kulingana na manipulations maalum ya thamani za ASCII.\n   Kamba ya Rafiki wa Karibu inazalishwa kwa kujumuisha thamani za ASCII za kila jozi ya herufi zinazofuatana katika kamba ya ingizo,\n   ikitengeneza herufi mpya kutoka kwa jumla. Kwa herufi ya mwisho ya kamba ya Rafiki wa Karibu, jumlisha thamani ya ASCII ya \n   herufi ya mwisho na ya kwanza ya kamba ya ingizo. Urefu wa kamba ya ingizo unapaswa kuwa kati ya herufi 2 na 100, na \n   thamani ya ASCII ya kila herufi haipaswi kuzidi 63.\n\n   Mfano:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "tr": "Bir C# fonksiyonu `static string GenerateCloseFriendString(string inputString)` yazın ve aşağıdaki problemi çözün:\nBu fonksiyon bir dizeyi girdi olarak alır ve belirli ASCII değeri manipülasyonlarına dayalı bir 'Yakın Arkadaş' dizesi döndürür.\n   Yakın Arkadaş dizesi, giriş dizesindeki bitişik karakter çiftlerinin ASCII değerlerini toplayarak ve toplamdan yeni bir karakter oluşturarak üretilir.\n   Yakın Arkadaş dizesinin son karakteri için, giriş dizesinin son ve ilk karakterlerinin ASCII değerlerini toplayın. Giriş dizesinin uzunluğu 2 ile 100 karakter arasında olmalı ve\n   her karakterin ASCII değeri 63'ü geçmemelidir.\n\n   Örnek:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "vi": "Viết một hàm C# `static string GenerateCloseFriendString(string inputString)` để giải quyết vấn đề sau:\nHàm này nhận một chuỗi làm đầu vào và trả về một chuỗi 'Close Friend' dựa trên các thao tác giá trị ASCII cụ thể.\n   Chuỗi Close Friend được tạo ra bằng cách cộng các giá trị ASCII của mỗi cặp ký tự liền kề trong chuỗi đầu vào,\n   tạo ra một ký tự mới từ tổng đó. Đối với ký tự cuối cùng của chuỗi Close Friend, cộng giá trị ASCII của \n   ký tự cuối cùng và ký tự đầu tiên của chuỗi đầu vào. Độ dài của chuỗi đầu vào nên nằm trong khoảng từ 2 đến 100 ký tự, và \n   giá trị ASCII của mỗi ký tự không được vượt quá 63.\n\n   Ví dụ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\""
    },
    "instruction_bertscore": {
      "es": "0.9727284459446719",
      "arb": "0.9702308675335393",
      "sw": "0.9816648267874315",
      "tr": "0.978569966820527",
      "vi": "0.9605319446579866"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(GenerateCloseFriendString(\"1234\") == \"cege\");\n        Debug.Assert(GenerateCloseFriendString(\"4312\") == \"gdcf\");\n\n    }\n}",
    "entry_point": "GenerateCloseFriendString",
    "signature": "static string GenerateCloseFriendString(string inputString)",
    "docstring": {
      "es": "Esta función toma una cadena como entrada y devuelve una cadena 'Amigo Cercano' basada en manipulaciones específicas de valores ASCII.\n   La cadena Amigo Cercano se genera sumando los valores ASCII de cada par de caracteres adyacentes en la cadena de entrada,\n   creando un nuevo carácter a partir de la suma. Para el último carácter de la cadena Amigo Cercano, suma el valor ASCII de los\n   últimos y primeros caracteres de la cadena de entrada. La longitud de la cadena de entrada debe estar entre 2 y 100 caracteres, y\n   el valor ASCII de cada carácter no debe exceder 63.\n\n   Ejemplo:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "arb": "هذه الدالة تأخذ سلسلة نصية كمدخل وتعيد سلسلة \"الصديق المقرب\" بناءً على تلاعبات معينة بقيم ASCII.\n   يتم إنشاء سلسلة الصديق المقرب عن طريق جمع قيم ASCII لكل زوج من الأحرف المتجاورة في السلسلة المدخلة،\n   وإنشاء حرف جديد من المجموع. بالنسبة للحرف الأخير من سلسلة الصديق المقرب، يتم جمع قيمة ASCII للحرف الأخير والأول من السلسلة المدخلة. يجب أن يكون طول السلسلة المدخلة بين 2 و 100 حرف، \n   ولا يجب أن تتجاوز قيمة ASCII لكل حرف 63.\n\n   مثال:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "sw": "Kazi hii inachukua kamba kama ingizo na kurudisha kamba ya 'Rafiki wa Karibu' kulingana na manipulations maalum ya thamani za ASCII.\n   Kamba ya Rafiki wa Karibu inazalishwa kwa kujumuisha thamani za ASCII za kila jozi ya herufi zinazofuatana katika kamba ya ingizo,\n   ikitengeneza herufi mpya kutoka kwa jumla. Kwa herufi ya mwisho ya kamba ya Rafiki wa Karibu, jumlisha thamani ya ASCII ya \n   herufi ya mwisho na ya kwanza ya kamba ya ingizo. Urefu wa kamba ya ingizo unapaswa kuwa kati ya herufi 2 na 100, na \n   thamani ya ASCII ya kila herufi haipaswi kuzidi 63.\n\n   Mfano:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "tr": "Bu fonksiyon bir dizeyi girdi olarak alır ve belirli ASCII değeri manipülasyonlarına dayalı olarak bir 'Yakın Arkadaş' dizesi döndürür.\n   Yakın Arkadaş dizesi, giriş dizisindeki bitişik karakter çiftlerinin ASCII değerlerinin toplanmasıyla oluşturulur,\n   toplamdan yeni bir karakter oluşturulur. Yakın Arkadaş dizisinin son karakteri için, giriş dizisinin son ve ilk karakterlerinin \n   ASCII değerlerini toplayın. Giriş dizisinin uzunluğu 2 ile 100 karakter arasında olmalı ve \n   her karakterin ASCII değeri 63'ü geçmemelidir.\n\n   Örnek:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "vi": "Hàm này nhận một chuỗi làm đầu vào và trả về một chuỗi 'Close Friend' dựa trên các thao tác giá trị ASCII cụ thể. Chuỗi Close Friend được tạo ra bằng cách cộng các giá trị ASCII của từng cặp ký tự liền kề trong chuỗi đầu vào, tạo ra một ký tự mới từ tổng đó. Đối với ký tự cuối cùng của chuỗi Close Friend, cộng giá trị ASCII của ký tự cuối và ký tự đầu tiên của chuỗi đầu vào. Độ dài chuỗi đầu vào nên nằm trong khoảng từ 2 đến 100 ký tự, và giá trị ASCII của mỗi ký tự không được vượt quá 63.\n\n   Ví dụ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\""
    },
    "docstring_bertscore": {
      "es": "0.9607319654516888",
      "arb": "0.9652386901669894",
      "sw": "0.999999801369619",
      "tr": "0.9687554410632121",
      "vi": "0.9482208336414443"
    }
  },
  {
    "task_id": "C#/28",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Descifra un texto cifrado que fue encriptado usando un cifrado César con un desplazamiento de 5 letras.\n    La función solo desplaza caracteres alfabéticos en mayúsculas y deja otros caracteres sin cambios.\n    Ejemplo:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    يفك تشفير نص مشفر تم تشفيره باستخدام شفرة قيصر مع إزاحة 5 حروف.\n    تقوم الدالة فقط بإزاحة الأحرف الأبجدية الكبيرة وتترك الأحرف الأخرى دون تغيير.\n    مثال:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Hufungua maandishi ya siri ambayo yalifichwa kwa kutumia sifuri ya Caesar yenye mabadiliko ya herufi 5.\n    Kazi hii inabadilisha tu herufi kubwa za alfabeti na inaacha herufi nyingine bila kubadilika.\n    Mfano:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    5 harf kaydırmalı bir Sezar şifresi kullanılarak şifrelenmiş bir metni çözer.\n    Fonksiyon yalnızca büyük harfli alfabetik karakterleri kaydırır ve diğer karakterleri değiştirmeden bırakır.\n    Örnek:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Giải mã một văn bản mã hóa đã được mã hóa bằng mật mã Caesar với dịch chuyển 5 chữ cái.\n    Hàm chỉ dịch chuyển các ký tự chữ hoa và giữ nguyên các ký tự khác.\n    Ví dụ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)"
    },
    "prompt_bertscore": {
      "es": "0.986506839585919",
      "arb": "0.9846857962525911",
      "sw": "0.9500651167293532",
      "tr": "0.9745189001993204",
      "vi": "0.9662133694467276"
    },
    "canonical_solution": "    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static string DecryptCaesarCipher(string cipherText)` para resolver el siguiente problema:\nDesencripta un texto cifrado que fue encriptado usando un cifrado César con un desplazamiento de 5 letras.\n    La función solo desplaza caracteres alfabéticos en mayúsculas y deja otros caracteres sin cambios.\n    Ejemplo:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "اكتب دالة C# `static string DecryptCaesarCipher(string cipherText)` لحل المشكلة التالية:\nتفك تشفير نص مشفر تم تشفيره باستخدام شيفرة قيصر مع إزاحة 5 حروف.\n    تقوم الدالة بإزاحة الأحرف الأبجدية الكبيرة فقط وتترك الأحرف الأخرى دون تغيير.\n    مثال:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Andika kazi ya C# `static string DecryptCaesarCipher(string cipherText)` kutatua tatizo lifuatalo:\nInafungua maandiko yaliyofichwa ambayo yalifichwa kwa kutumia njia ya Caesar cipher na mabadiliko ya herufi 5.\n    Kazi inahamisha tu herufi kubwa za alfabeti na inaacha herufi nyingine bila kubadilika.\n    Mfano:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Bir C# fonksiyonu `static string DecryptCaesarCipher(string cipherText)` yazın:\n5 harf kaydırmalı bir Sezar şifresi kullanılarak şifrelenmiş bir metni çözer.\n    Fonksiyon sadece büyük harfli alfabetik karakterleri kaydırır ve diğer karakterleri değiştirmeden bırakır.\n    Örnek:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "vi": "Viết một hàm C# `static string DecryptCaesarCipher(string cipherText)` để giải quyết vấn đề sau:\nGiải mã một văn bản mã hóa đã được mã hóa bằng mã Caesar với một dịch chuyển 5 chữ cái.\n    Hàm chỉ dịch chuyển các ký tự chữ cái viết hoa và giữ nguyên các ký tự khác.\n    Ví dụ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "instruction_bertscore": {
      "es": "0.9831037052676482",
      "arb": "0.9856757700716691",
      "sw": "0.984639714004191",
      "tr": "0.9663315545234433",
      "vi": "0.9834060207075833"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n        Debug.Assert(DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n        Debug.Assert(DecryptCaesarCipher(\"F XYWNFYNTS YT XJHWJY\") == \"A STRIATION TO SECRET\");\n        Debug.Assert(DecryptCaesarCipher(\"YMJ VZNHP TS X HNUMJW\") == \"THE QUICK ON S CIPHER\");\n        Debug.Assert(DecryptCaesarCipher(\"JXU UQFSI QDT TZW YMZXW\") == \"ESP PLAND LYO OUR THUSR\");\n    }\n}",
    "entry_point": "DecryptCaesarCipher",
    "signature": "static string DecryptCaesarCipher(string cipherText)",
    "docstring": {
      "es": "Desencripta un texto cifrado que fue encriptado usando un cifrado César con un desplazamiento de 5 letras. \n    La función solo desplaza caracteres alfabéticos en mayúsculas y deja otros caracteres sin cambios.\n    Ejemplo:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "يفك تشفير نص مشفر تم تشفيره باستخدام شيفرة قيصر مع إزاحة بمقدار 5 أحرف.\n    تقوم الدالة فقط بإزاحة الحروف الأبجدية الكبيرة وتترك الأحرف الأخرى دون تغيير.\n    مثال:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Inafungua maandiko ya siri ambayo yalifichwa kwa kutumia msimbo wa Caesar na mabadiliko ya herufi 5.\n    Kazi hii inahamisha tu herufi kubwa za alfabeti na inaacha herufi nyingine bila kubadilika.\n    Mfano:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Şifreli metni, 5 harf kaydırmalı bir Sezar şifresi kullanılarak şifrelenmiş olan metni çözer.\n    Fonksiyon yalnızca büyük harfli alfabetik karakterleri kaydırır ve diğer karakterleri değiştirmeden bırakır.\n    Örnek:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "vi": "Giải mã một văn bản mã hóa đã được mã hóa bằng mã Caesar với dịch chuyển 5 chữ cái.  \n    Hàm chỉ dịch chuyển các ký tự chữ hoa và để nguyên các ký tự khác.  \n    Ví dụ:  \n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "es": "0.9906727145673637",
      "arb": "0.9763975463431483",
      "sw": "0.9360374419599073",
      "tr": "0.9920059216848699",
      "vi": "0.9476938672405587"
    }
  },
  {
    "task_id": "C#/29",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Determina cuál de las dos cadenas proporcionadas es una subcadena de la otra. \n    Si ninguna cadena es una subcadena de la otra, devuelve \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* يحدد أي من السلسلتين المقدمتين هو جزء من السلسلة الأخرى.\n    إذا لم تكن أي من السلسلتين جزءًا من الأخرى، فإنه يعيد \"لا يوجد جزء\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Huamua ni ipi kati ya kamba mbili zilizotolewa ni sehemu ya kamba nyingine.\n    Ikiwa hakuna kamba yoyote ni sehemu ya kamba nyingine, inarudisha \"Hakuna sehemu ya kamba\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Hakuna sehemu ya kamba\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code ni sehemu ya kamba ya decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book ni sehemu ya kamba ya notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Sağlanan iki stringden hangisinin diğerinin alt dizisi olduğunu belirler.\n    Eğer hiçbir string diğerinin alt dizisi değilse, \"No substring\" döner.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Xác định chuỗi nào trong hai chuỗi được cung cấp là chuỗi con của chuỗi kia.\n    Nếu không có chuỗi nào là chuỗi con của chuỗi kia, nó trả về \"Không có chuỗi con\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)"
    },
    "prompt_bertscore": {
      "es": "0.9968084070375314",
      "arb": "0.9965424409573257",
      "sw": "0.9907315091601501",
      "tr": "1",
      "vi": "0.9897369668423084"
    },
    "canonical_solution": "    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static string CheckSubstring(string str1, string str2)` para resolver el siguiente problema:\nDetermina cuál de las dos cadenas proporcionadas es una subcadena de la otra. \n    Si ninguna cadena es una subcadena de la otra, devuelve \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "arb": "اكتب دالة C# `static string CheckSubstring(string str1, string str2)` لحل المشكلة التالية:\nتحدد أي من السلسلتين المقدمتين هي جزء من الأخرى.\n    إذا لم تكن أي من السلسلتين جزءًا من الأخرى، فإنها تعيد \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "sw": "Andika kazi ya C# `static string CheckSubstring(string str1, string str2)` kutatua tatizo lifuatalo:\nInabainisha ni ipi kati ya nyuzi mbili zilizotolewa ni sehemu ya nyingine. \n    Ikiwa hakuna nyuzi ambayo ni sehemu ya nyingine, inarejesha \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "tr": "Bir C# fonksiyonu `static string CheckSubstring(string str1, string str2)` yazın: \nVerilen iki stringden hangisinin diğerinin alt dizisi olduğunu belirler. \n    Eğer hiçbir string diğerinin alt dizisi değilse, \"No substring\" döner.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "vi": "Viết một hàm C# `static string CheckSubstring(string str1, string str2)` để giải quyết vấn đề sau:\nXác định chuỗi nào trong hai chuỗi được cung cấp là chuỗi con của chuỗi kia.\n    Nếu không chuỗi nào là chuỗi con của chuỗi kia, nó trả về \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\""
    },
    "instruction_bertscore": {
      "es": "0.9860942842845095",
      "arb": "0.992661004681523",
      "sw": "0.975114195451282",
      "tr": "0.9717203967609198",
      "vi": "0.9892052333122779"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CheckSubstring(\"apple\", \"pineapple\") == \"\\\"apple\\\" is substring of \\\"pineapple\\\"\");\n        Debug.Assert(CheckSubstring(\"star\", \"astrophysics\") == \"No substring\");\n        Debug.Assert(CheckSubstring(\"sun\", \"sunset\") == \"\\\"sun\\\" is substring of \\\"sunset\\\"\");\n        Debug.Assert(CheckSubstring(\"moon\", \"moonlight\") == \"\\\"moon\\\" is substring of \\\"moonlight\\\"\");\n\n\n    }\n}",
    "entry_point": "CheckSubstring",
    "signature": "static string CheckSubstring(string str1, string str2)",
    "docstring": {
      "es": "Determina cuál de las dos cadenas proporcionadas es una subcadena de la otra. \n    Si ninguna cadena es una subcadena de la otra, devuelve \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "arb": "يحدد أي من السلسلتين المقدمتين هو جزء من السلسلة الأخرى. \n    إذا لم تكن أي من السلسلتين جزءًا من الأخرى، فإنه يعيد \"لا يوجد جزء\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "sw": "Inabainisha ni ipi kati ya mistari miwili iliyotolewa ni sehemu ndogo ya nyingine. \n    Ikiwa hakuna mstari wowote ni sehemu ndogo ya mwingine, inarejesha \"Hakuna sehemu ndogo\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Hakuna sehemu ndogo\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code ni sehemu ndogo ya decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book ni sehemu ndogo ya notebook\"",
      "tr": "Belirtilen iki stringden hangisinin diğerinin alt dizesi olduğunu belirler. \n    Eğer hiçbir string diğerinin alt dizesi değilse, \"Alt dize yok\" döner.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Alt dize yok\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code, decode'nin alt dizisidir\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book, notebook'un alt dizisidir\"",
      "vi": "Xác định chuỗi nào trong hai chuỗi được cung cấp là chuỗi con của chuỗi kia. \n    Nếu không có chuỗi nào là chuỗi con của chuỗi kia, nó trả về \"Không có chuỗi con\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code là chuỗi con của decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book là chuỗi con của notebook\""
    },
    "docstring_bertscore": {
      "es": "0.9831029107461241",
      "arb": "0.9720151642463757",
      "sw": "0.9896289119150253",
      "tr": "0.9862112775789391",
      "vi": "0.9840311105167001"
    }
  },
  {
    "task_id": "C#/30",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Elimina un sufijo específico ('er', 'ly', o 'ing') de la palabra dada si termina con uno de estos sufijos.\n    La función asegura que la palabra restante no esté vacía.\n    Ejemplos:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يزيل لاحقة معينة ('er', 'ly', أو 'ing') من الكلمة المعطاة إذا انتهت بإحدى هذه اللواحق.\n    تضمن الدالة أن الكلمة المتبقية ليست فارغة.\n    أمثلة:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Huondoa kiambishi tamati maalum ('er', 'ly', au 'ing') kutoka kwa neno lililopeanwa ikiwa linaisha na mojawapo ya viambishi hivi. \n    Kazi hii inahakikisha neno linalobaki haliko tupu.\n    Mifano:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Verilen kelimenin sonu belirli bir ekle ('er', 'ly' veya 'ing') bitiyorsa, bu eki kaldırır.\n    Fonksiyon, kalan kelimenin boş olmadığından emin olur.\n    Örnekler:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Loại bỏ một hậu tố cụ thể ('er', 'ly', hoặc 'ing') từ từ đã cho nếu nó kết thúc bằng một trong những hậu tố này. \n    Hàm đảm bảo từ còn lại không bị rỗng.\n    Ví dụ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)"
    },
    "prompt_bertscore": {
      "es": "0.9973947639223464",
      "arb": "0.9973947639223464",
      "sw": "0.997972976961539",
      "tr": "0.95543866442749",
      "vi": "0.9943026847807763"
    },
    "canonical_solution": "{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static string RemoveSuffix(string word)` para resolver el siguiente problema:\nElimina un sufijo específico ('er', 'ly', o 'ing') de la palabra dada si termina con uno de estos sufijos.\n    La función asegura que la palabra restante no esté vacía.\n    Ejemplos:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "arb": "اكتب دالة C# `static string RemoveSuffix(string word)` لحل المشكلة التالية:\nإزالة لاحقة محددة ('er', 'ly', أو 'ing') من الكلمة المعطاة إذا كانت تنتهي بإحدى هذه اللواحق.\n    تضمن الدالة أن الكلمة المتبقية ليست فارغة.\n    أمثلة:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "sw": "Andika kazi ya C# `static string RemoveSuffix(string word)` kutatua tatizo lifuatalo:\nHuondoa kiambishi tamati maalum ('er', 'ly', au 'ing') kutoka kwenye neno lililopewa ikiwa linaisha na moja ya viambishi hivi tamati. \n    Kazi hii inahakikisha neno linalobaki haliko tupu.\n    Mifano:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "tr": "Bir C# fonksiyonu `static string RemoveSuffix(string word)` yazın:\nVerilen kelimenin sonu belirli bir ekle ('er', 'ly' veya 'ing') bitiyorsa bu eki kaldırır.\n    Fonksiyon, kalan kelimenin boş olmadığını garanti eder.\n    Örnekler:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "vi": "Viết một hàm C# `static string RemoveSuffix(string word)` để giải quyết vấn đề sau:  \nLoại bỏ một hậu tố cụ thể ('er', 'ly', hoặc 'ing') khỏi từ đã cho nếu nó kết thúc bằng một trong những hậu tố này.  \nHàm đảm bảo từ còn lại không bị trống.  \nVí dụ:  \n    >>> RemoveSuffix(\"happily\")  \n    \"happi\"  \n    >>> RemoveSuffix(\"dancing\")  \n    \"danc\"  \n    >>> RemoveSuffix(\"flower\")  \n    \"flow\"  "
    },
    "instruction_bertscore": {
      "es": "0.9871289499393203",
      "arb": "0.9881290539078309",
      "sw": "0.9981644566488566",
      "tr": "0.9483950324856119",
      "vi": "0.9936130400978231"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(RemoveSuffix(\"happily\") == \"happi\");\n        Debug.Assert(RemoveSuffix(\"dancing\") == \"danc\");\n        Debug.Assert(RemoveSuffix(\"flower\") == \"flow\");\n        Debug.Assert(RemoveSuffix(\"computer\") == \"comput\");\n        Debug.Assert(RemoveSuffix(\"flying\") == \"fly\");\n        Debug.Assert(RemoveSuffix(\"ing\") == \"ing\");\n        Debug.Assert(RemoveSuffix(\"er\") == \"er\");\n    }\n}",
    "entry_point": "RemoveSuffix",
    "signature": "static string RemoveSuffix(string word)",
    "docstring": {
      "es": "Elimina un sufijo específico ('er', 'ly' o 'ing') de la palabra dada si termina con uno de estos sufijos. \n    La función asegura que la palabra restante no esté vacía.\n    Ejemplos:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "arb": "يزيل لاحقة محددة ('er'، 'ly'، أو 'ing') من الكلمة المعطاة إذا انتهت بإحدى هذه اللواحق. \n    تضمن الدالة أن الكلمة المتبقية ليست فارغة.\n    أمثلة:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "sw": "Huondoa kiambishi tamati maalum ('er', 'ly', au 'ing') kutoka kwenye neno lililopewa ikiwa linaishia na moja ya viambishi hivi. \n    Kazi hii inahakikisha neno linalobaki haliko tupu.\n    Mifano:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "tr": "Belirtilen kelimenin sonundaki belirli bir eki ('er', 'ly' veya 'ing') kaldırır. \n    Fonksiyon, geriye kalan kelimenin boş olmadığını garanti eder.\n    Örnekler:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "vi": "Loại bỏ một hậu tố cụ thể ('er', 'ly', hoặc 'ing') từ từ được cung cấp nếu nó kết thúc bằng một trong những hậu tố này. \n    Hàm đảm bảo từ còn lại không bị trống.\n    Ví dụ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\""
    },
    "docstring_bertscore": {
      "es": "0.9905722075945601",
      "arb": "0.9973039898382134",
      "sw": "0.997329811787748",
      "tr": "0.9517469201655756",
      "vi": "0.991659311669964"
    }
  },
  {
    "task_id": "C#/31",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Encuentra la primera palabra más larga y la primera palabra más corta en una oración dada. \n    Una palabra se define como una secuencia continua de letras (A-Z, a-z), \n    y las palabras están separadas por espacios y comas. Las comillas y otros \n    signos de puntuación no son parte de las palabras.\n\n    Ejemplos:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    يجد أول أطول كلمة وأول أقصر كلمة في جملة معينة.\n    تُعرف الكلمة على أنها سلسلة متصلة من الأحرف (A-Z, a-z)،\n    ويتم فصل الكلمات بواسطة المسافات والفواصل. علامات الاقتباس وعلامات الترقيم الأخرى\n    ليست جزءًا من الكلمات.\n\n    أمثلة:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Inapata neno la kwanza refu zaidi na neno la kwanza fupi zaidi katika sentensi iliyotolewa. \n    Neno linafafanuliwa kama mfululizo wa herufi (A-Z, a-z), \n    na maneno yanatenganishwa na nafasi na koma. Alama za nukuu na \n    alama nyingine za uakifishaji si sehemu ya maneno.\n\n    Mifano:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Verilen bir cümledeki ilk en uzun ve ilk en kısa kelimeyi bulur.\n    Bir kelime, harflerin (A-Z, a-z) sürekli bir dizisi olarak tanımlanır\n    ve kelimeler boşluklar ve virgüllerle ayrılır. Tırnak işaretleri ve diğer\n    noktalama işaretleri kelimelerin bir parçası değildir.\n\n    Örnekler:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Tìm từ dài nhất đầu tiên và từ ngắn nhất đầu tiên trong một câu cho trước. \n    Một từ được định nghĩa là một chuỗi liên tục của các chữ cái (A-Z, a-z), \n    và các từ được phân tách bởi dấu cách và dấu phẩy. Dấu ngoặc kép và các \n    dấu câu khác không phải là một phần của từ.\n\n    Ví dụ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)"
    },
    "prompt_bertscore": {
      "es": "0.9919689764339974",
      "arb": "0.9898509806810224",
      "sw": "0.978382261110449",
      "tr": "0.9954124327196182",
      "vi": "0.9843640150353147"
    },
    "canonical_solution": "    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static (string, string) FindLongestAndShortestWord(string sentence)` para resolver el siguiente problema:\nEncuentra la primera palabra más larga y la primera palabra más corta en una oración dada.\n    Una palabra se define como una secuencia continua de letras (A-Z, a-z),\n    y las palabras están separadas por espacios y comas. Las comillas y otros\n    signos de puntuación no son parte de las palabras.\n\n    Ejemplos:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "arb": "اكتب دالة C# `static (string, string) FindLongestAndShortestWord(string sentence)` لحل المشكلة التالية:\nتجد أول أطول كلمة وأول أقصر كلمة في جملة معينة.\n    تُعرّف الكلمة على أنها تسلسل مستمر من الحروف (A-Z، a-z)،\n    ويتم فصل الكلمات بالمسافات والفواصل. علامات الاقتباس وعلامات الترقيم الأخرى\n    ليست جزءًا من الكلمات.\n\n    أمثلة:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "sw": "Andika kazi ya C# `static (string, string) FindLongestAndShortestWord(string sentence)` kutatua tatizo lifuatalo:\nInapata neno refu zaidi la kwanza na neno fupi zaidi la kwanza katika sentensi iliyopewa.\n    Neno linaelezewa kama mfululizo wa herufi (A-Z, a-z), \n    na maneno yanatenganishwa na nafasi na koma. Alama za nukuu na \n    alama nyingine za uakifishaji si sehemu ya maneno.\n\n    Mifano:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "tr": "Bir C# fonksiyonu `static (string, string) FindLongestAndShortestWord(string sentence)` yazın ve aşağıdaki problemi çözün:\nVerilen bir cümledeki ilk en uzun ve ilk en kısa kelimeyi bulur.\n    Bir kelime, harflerin (A-Z, a-z) sürekli bir dizisi olarak tanımlanır \n    ve kelimeler boşluklar ve virgüllerle ayrılır. Tırnak işaretleri ve diğer \n    noktalama işaretleri kelimelerin parçası değildir.\n\n    Örnekler:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "vi": "Viết một hàm C# `static (string, string) FindLongestAndShortestWord(string sentence)` để giải quyết vấn đề sau:\nTìm từ dài nhất đầu tiên và từ ngắn nhất đầu tiên trong một câu cho trước. \n    Một từ được định nghĩa là một chuỗi liên tục của các chữ cái (A-Z, a-z), \n    và các từ được phân tách bởi dấu cách và dấu phẩy. Dấu ngoặc kép và các \n    dấu câu khác không phải là một phần của các từ.\n\n    Ví dụ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")"
    },
    "instruction_bertscore": {
      "es": "0.9890018358020982",
      "arb": "0.9955701452421599",
      "sw": "0.9840543502712813",
      "tr": "0.9885002940899852",
      "vi": "0.989518076162408"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindLongestAndShortestWord(\"Fast cars, smooth drives\") == (\"smooth\", \"Fast\"));\n        Debug.Assert(FindLongestAndShortestWord(\"Sunshine brings happiness\") == (\"happiness\", \"brings\"));\n        Debug.Assert(FindLongestAndShortestWord(\"A\") == (\"A\", \"A\")); // Edge case: Only one word\n        Debug.Assert(FindLongestAndShortestWord(\"Every cloud has a silver lining\") == (\"silver\", \"a\"));\n\n\n    }\n}",
    "entry_point": "FindLongestAndShortestWord",
    "signature": "static (string, string) FindLongestAndShortestWord(string sentence)",
    "docstring": {
      "es": "Encuentra la primera palabra más larga y la primera palabra más corta en una oración dada. \n    Una palabra se define como una secuencia continua de letras (A-Z, a-z), \n    y las palabras están separadas por espacios y comas. Las comillas y otros \n    signos de puntuación no son parte de las palabras.\n\n    Ejemplos:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "arb": "يجد أول أطول كلمة وأول أقصر كلمة في جملة معينة.\n    تُعرف الكلمة على أنها تسلسل مستمر من الأحرف (A-Z، a-z)،\n    ويتم فصل الكلمات بواسطة مسافات وفواصل. علامات الاقتباس وعلامات الترقيم الأخرى\n    ليست جزءًا من الكلمات.\n\n    أمثلة:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "sw": "Inapata neno la kwanza refu zaidi na neno la kwanza fupi zaidi katika sentensi iliyotolewa. \n    Neno linaelezwa kama mlolongo unaoendelea wa herufi (A-Z, a-z), \n    na maneno yanatenganishwa na nafasi na koma. Alama za nukuu na \n    alama nyingine za uakifishaji si sehemu ya maneno.\n\n    Mifano:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "tr": "Verilen bir cümledeki ilk en uzun ve ilk en kısa kelimeyi bulur.\n    Bir kelime, harflerin (A-Z, a-z) kesintisiz bir dizisi olarak tanımlanır \n    ve kelimeler boşluklar ve virgüllerle ayrılır. Tırnak işaretleri ve diğer \n    noktalama işaretleri kelimelerin parçası değildir.\n\n    Örnekler:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "vi": "Tìm từ dài nhất đầu tiên và từ ngắn nhất đầu tiên trong một câu cho trước. \n    Một từ được định nghĩa là một chuỗi liên tục của các chữ cái (A-Z, a-z), \n    và các từ được phân tách bằng dấu cách và dấu phẩy. Dấu ngoặc kép và các \n    dấu câu khác không phải là một phần của từ.\n\n    Ví dụ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")"
    },
    "docstring_bertscore": {
      "es": "0.9892882608115505",
      "arb": "0.9876507519502989",
      "sw": "0.9843822890303698",
      "tr": "0.9869702442648735",
      "vi": "0.980386044394329"
    }
  },
  {
    "task_id": "C#/32",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calcular la velocidad de un vehículo y el siguiente número palindrómico en el odómetro.\n     Dada la lectura actual palindrómica del odómetro y el tiempo transcurrido en horas,\n     encontrar la velocidad constante del vehículo y la siguiente lectura palindrómica del odómetro.\n     La velocidad se calcula por hora.\n     Ejemplo:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* حساب سرعة المركبة والرقم التالي المتناظر على عداد المسافات.\n     بالنظر إلى قراءة عداد المسافات المتناظرة الحالية والوقت المنقضي بالساعات،\n     ابحث عن السرعة الثابتة للمركبة وقراءة عداد المسافات المتناظرة التالية.\n     يتم حساب السرعة لكل ساعة.\n     مثال:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Hesabu kasi ya gari na namba inayofuata ya palindromic kwenye odometer.\n     Ukipewa usomaji wa sasa wa odometer ya palindromic na muda uliopita kwa saa,\n     pata kasi ya gari isiyobadilika na usomaji unaofuata wa odometer ya palindromic.\n     Kasi inahesabiwa kwa saa.\n     Mfano:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Bir aracın hızını ve kilometre sayacındaki bir sonraki palindromik sayıyı hesaplayın.\n     Mevcut palindromik kilometre sayacı okuması ve geçen süre saat cinsinden verildiğinde, \n     aracın sabit hızını ve bir sonraki palindromik kilometre sayacı okumasını bulun.\n     Hız saat başına hesaplanır.\n     Örnek:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Tính toán tốc độ của một phương tiện và số đối xứng tiếp theo trên đồng hồ đo quãng đường.\n     Cho số đọc đồng hồ đo quãng đường đối xứng hiện tại và thời gian đã trôi qua tính bằng giờ,\n     tìm tốc độ không đổi của phương tiện và số đọc đồng hồ đo quãng đường đối xứng tiếp theo.\n     Tốc độ được tính theo giờ.\n     Ví dụ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)"
    },
    "prompt_bertscore": {
      "es": "0.9813875387755069",
      "arb": "0.988562068138487",
      "sw": "0.9880505949073222",
      "tr": "0.9955409465761478",
      "vi": "0.9886462874200458"
    },
    "canonical_solution": "{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "instruction": {
      "es": "Escriba una función en C# `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` para resolver el siguiente problema:\nCalcular la velocidad de un vehículo y el siguiente número palindrómico en el odómetro.\n     Dada la lectura actual palindrómica del odómetro y el tiempo transcurrido en horas,\n     encuentre la velocidad constante del vehículo y la siguiente lectura palindrómica del odómetro.\n     La velocidad se calcula por hora.\n     Ejemplo:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "arb": "اكتب دالة C# `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` لحل المشكلة التالية:\nاحسب سرعة المركبة والرقم التالي الذي يظهر على عداد المسافات والذي يكون رقمًا متناظرًا.\n     بالنظر إلى قراءة عداد المسافات المتناظرة الحالية والوقت المنقضي بالساعات،\n     ابحث عن سرعة المركبة الثابتة وقراءة عداد المسافات التالية التي تكون متناظرة.\n     يتم حساب السرعة لكل ساعة.\n     مثال:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "sw": "Andika kazi ya C# `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` kutatua tatizo lifuatalo:\nHesabu kasi ya gari na namba inayofuata ya palindromu kwenye odometer.\n     Ukipewa usomaji wa sasa wa odometer wa palindromu na muda uliopita kwa saa,\n     pata kasi ya gari isiyobadilika na usomaji wa odometer wa palindromu unaofuata.\n     Kasi inahesabiwa kwa saa.\n     Mfano:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "tr": "Bir C# fonksiyonu `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` yazın:\nBir aracın hızını ve kilometre sayacındaki bir sonraki palindromik sayıyı hesaplayın.\n     Verilen mevcut palindromik kilometre sayacı okuması ve geçen saat cinsinden süre ile,\n     aracın sabit hızını ve bir sonraki palindromik kilometre sayacı okumasını bulun.\n     Hız saat başına hesaplanır.\n     Örnek:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "vi": "Viết một hàm C# `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` để giải quyết vấn đề sau:\nTính toán tốc độ của một phương tiện và số đối xứng tiếp theo trên đồng hồ đo quãng đường.\n     Cho số đọc đồng hồ đo quãng đường đối xứng hiện tại và thời gian đã trôi qua tính bằng giờ,\n     tìm tốc độ không đổi của phương tiện và số đọc đồng hồ đo quãng đường đối xứng tiếp theo.\n     Tốc độ được tính theo giờ.\n     Ví dụ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)"
    },
    "instruction_bertscore": {
      "es": "0.9768416838751424",
      "arb": "0.9669073839980635",
      "sw": "0.9715952596208679",
      "tr": "0.9733044740496731",
      "vi": "0.9733340699764473"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n        Debug.Assert(CalculateSpeedAndNextPalindrome(12321, 2) == (50, 12421));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(11111, 1) == (100, 11211));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(23332, 2) == (50, 23432));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(45654, 4) == (25, 45754));\n\n    }\n}",
    "entry_point": "CalculateSpeedAndNextPalindrome",
    "signature": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
    "docstring": {
      "es": "Calcular la velocidad de un vehículo y el siguiente número palindrómico en el odómetro.\n     Dada la lectura actual palindrómica del odómetro y el tiempo transcurrido en horas,\n     encuentre la velocidad constante del vehículo y la siguiente lectura palindrómica del odómetro.\n     La velocidad se calcula por hora.\n     Ejemplo:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "arb": "احسب سرعة المركبة والرقم التالي المتناظر على عداد المسافات.\n     بالنظر إلى قراءة عداد المسافات المتناظرة الحالية والوقت المنقضي بالساعات،\n     ابحث عن السرعة الثابتة للمركبة وقراءة عداد المسافات المتناظرة التالية.\n     يتم حساب السرعة لكل ساعة.\n     مثال:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "sw": "Hesabu kasi ya gari na nambari inayofuata ya palindromic kwenye odometer.\n     Ukipewa usomaji wa sasa wa odometer wa palindromic na muda uliopita kwa saa,\n     pata kasi ya gari isiyobadilika na usomaji wa odometer wa palindromic unaofuata.\n     Kasi inahesabiwa kwa saa.\n     Mfano:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "tr": "Bir aracın hızını ve kilometre sayacındaki bir sonraki palindromik sayıyı hesaplayın.\n     Mevcut palindromik kilometre sayacı okuması ve geçen süre saat cinsinden verildiğinde,\n     aracın sabit hızını ve bir sonraki palindromik kilometre sayacı okumasını bulun.\n     Hız saat başına hesaplanır.\n     Örnek:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "vi": "Tính toán tốc độ của một phương tiện và số đối xứng tiếp theo trên đồng hồ đo quãng đường.\n     Cho số đọc đồng hồ đo quãng đường đối xứng hiện tại và thời gian đã trôi qua tính bằng giờ,\n     tìm tốc độ không đổi của phương tiện và số đọc đồng hồ đo quãng đường đối xứng tiếp theo.\n     Tốc độ được tính theo giờ.\n     Ví dụ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)"
    },
    "docstring_bertscore": {
      "es": "0.9794346048691718",
      "arb": "0.9882269786856811",
      "sw": "0.9883374171775365",
      "tr": "0.9947227880366651",
      "vi": "0.9828683282661219"
    }
  },
  {
    "task_id": "C#/33",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Encuentra todos los números automórficos dentro de un límite especificado.\n    Un número automórfico es un número cuyo cuadrado termina en el número mismo.\n    Ejemplos:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يجد جميع الأعداد الذاتية ضمن حد محدد.\n    العدد الذاتي هو عدد ينتهي مربعه بالعدد نفسه.\n    أمثلة:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inapata namba zote za kiotomatiki ndani ya kikomo kilichobainishwa.\n    Namba ya kiotomatiki ni namba ambayo mraba wake unamalizika kwa namba yenyewe.\n    Mifano:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Belirtilen bir limit dahilinde tüm otomorfik sayıları bulur.\n    Bir otomorfik sayı, karesi kendisiyle biten bir sayıdır.\n    Örnekler:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tìm tất cả các số tự động trong một giới hạn được chỉ định.\n    Một số tự động là một số mà bình phương của nó kết thúc bằng chính số đó.\n    Ví dụ:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)"
    },
    "prompt_bertscore": {
      "es": "0.994984384248488",
      "arb": "0.9982790663787138",
      "sw": "0.9982790663787138",
      "tr": "0.9982790663787138",
      "vi": "0.9923706070644499"
    },
    "canonical_solution": "{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static List<int> FindAutomorphicNumbers(int limit)` para resolver el siguiente problema:\nEncuentra todos los números automórficos dentro de un límite especificado.\n    Un número automórfico es un número cuyo cuadrado termina en el mismo número.\n    Ejemplos:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "arb": "اكتب دالة C# `static List<int> FindAutomorphicNumbers(int limit)` لحل المشكلة التالية:\nيجد جميع الأعداد الذاتية ضمن حد معين.\n    العدد الذاتي هو عدد ينتهي مربعه بالعدد نفسه.\n    أمثلة:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "sw": "Andika kazi ya C# `static List<int> FindAutomorphicNumbers(int limit)` kutatua tatizo lifuatalo:\nInapata namba zote za kiotomatiki ndani ya kikomo kilichobainishwa.\n    Namba ya kiotomatiki ni namba ambayo mraba wake unamalizika kwa namba yenyewe.\n    Mifano:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "tr": "Bir C# fonksiyonu `static List<int> FindAutomorphicNumbers(int limit)` yazın:\nBelirtilen bir sınır içinde tüm otomorfik sayıları bulur.\n    Bir otomorfik sayı, karesi kendisiyle biten bir sayıdır.\n    Örnekler:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "vi": "Viết một hàm C# `static List<int> FindAutomorphicNumbers(int limit)` để giải quyết vấn đề sau:\nTìm tất cả các số tự động trong một giới hạn được chỉ định.\n    Một số tự động là một số mà bình phương của nó kết thúc bằng chính số đó.\n    Ví dụ:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]"
    },
    "instruction_bertscore": {
      "es": "0.9806281748288105",
      "arb": "0.9859165100934834",
      "sw": "0.9907692489325467",
      "tr": "0.968008988091283",
      "vi": "0.98939373354388"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n     Debug.Assert(FindAutomorphicNumbers(100).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76 }));\n    Debug.Assert(FindAutomorphicNumbers(500).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376 }));\n    Debug.Assert(FindAutomorphicNumbers(1000).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376, 625 }));\n    Debug.Assert(FindAutomorphicNumbers(200000).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376, 625,9376, 90625, 109376 }));\n\n    }\n}",
    "entry_point": "FindAutomorphicNumbers",
    "signature": "static List<int> FindAutomorphicNumbers(int limit)",
    "docstring": {
      "es": "Encuentra todos los números automórficos dentro de un límite especificado.\n    Un número automórfico es un número cuyo cuadrado termina en el mismo número.\n    Ejemplos:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "arb": "يجد جميع الأعداد الذاتية ضمن حد محدد.\n    العدد الذاتي هو عدد ينتهي مربعه بالعدد نفسه.\n    أمثلة:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "sw": "Inapata nambari zote za kiotomatiki ndani ya kikomo kilichobainishwa.\n    Nambari ya kiotomatiki ni nambari ambayo mraba wake unamalizika kwa nambari yenyewe.\n    Mifano:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "tr": "Belirtilen bir sınır içinde tüm otomorfik sayıları bulur.\n    Otomorfik bir sayı, karesi kendisiyle biten bir sayıdır.\n    Örnekler:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "vi": "Tìm tất cả các số tự động trong giới hạn được chỉ định.  \nMột số tự động là một số mà bình phương của nó kết thúc bằng chính số đó.  \nVí dụ:  \n>>> FindAutomorphicNumbers(100)  \n[0, 1, 5, 6, 25, 76]  \n>>> FindAutomorphicNumbers(500)  \n[0, 1, 5, 6, 25, 76, 376]  "
    },
    "docstring_bertscore": {
      "es": "0.9737021320725049",
      "arb": "0.987856533025051",
      "sw": "0.9977272711801988",
      "tr": "0.987856533025051",
      "vi": "0.9694929556679946"
    }
  },
  {
    "task_id": "C#/34",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determinar el número de la última persona restante en un juego de conteo circular.\n   En este juego, las personas están numeradas del 1 al totalPeople y se sientan en un círculo.\n   Comenzando con la primera persona, cuentan del 1 al countNumber.\n   La persona que está en countNumber es removida del círculo,\n   y el conteo se reanuda desde la siguiente persona.\n   Este proceso continúa hasta que solo queda una persona.\n\n   Ejemplo:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* تحديد رقم الشخص الأخير المتبقي في لعبة العد الدائرية.\n   في هذه اللعبة، يتم ترقيم الأشخاص من 1 إلى totalPeople ويجلسون في دائرة.\n   بدءًا من الشخص الأول، يعدون من 1 إلى countNumber.\n   الشخص الذي يكون عند countNumber يتم إزالته من الدائرة،\n   ويستأنف العد من الشخص التالي.\n   تستمر هذه العملية حتى يبقى شخص واحد فقط.\n\n   مثال:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Kuamua namba ya mtu wa mwisho aliyebaki katika mchezo wa kuhesabu wa mduara.\n   Katika mchezo huu, watu wanapewa namba kutoka 1 hadi totalPeople na wanakaa katika mduara. \n   Kuanzia na mtu wa kwanza, wanahesabu kutoka 1 hadi countNumber. \n   Mtu ambaye yuko kwenye countNumber anaondolewa kwenye mduara, \n   na kuhesabu kunaendelea kutoka kwa mtu anayefuata. \n   Mchakato huu unaendelea hadi mtu mmoja tu abaki.\n\n   Mfano:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Dairesel bir sayma oyununda son kalan kişinin numarasını belirleyin.\n   Bu oyunda, insanlar 1'den totalPeople'a kadar numaralandırılır ve bir daire içinde otururlar.\n   İlk kişiden başlayarak, countNumber'a kadar sayarlar.\n   countNumber'da olan kişi daireden çıkarılır,\n   ve sayma bir sonraki kişiden devam eder.\n   Bu süreç sadece bir kişi kalana kadar devam eder.\n\n   Örnek:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định số của người còn lại cuối cùng trong một trò chơi đếm vòng tròn.\n   Trong trò chơi này, mọi người được đánh số từ 1 đến totalPeople và ngồi thành vòng tròn.\n   Bắt đầu với người đầu tiên, họ đếm từ 1 đến countNumber.\n   Người ở vị trí countNumber sẽ bị loại khỏi vòng tròn,\n   và việc đếm tiếp tục từ người kế tiếp.\n   Quá trình này tiếp tục cho đến khi chỉ còn lại một người.\n\n   Ví dụ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)"
    },
    "prompt_bertscore": {
      "es": "0.9926983471931575",
      "arb": "0.9893665211816783",
      "sw": "0.9678874262980897",
      "tr": "0.9818292927429284",
      "vi": "0.9751380310970061"
    },
    "canonical_solution": "{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int LastRemainingPerson(int totalPeople, int countNumber)` para resolver el siguiente problema:\nDeterminar el número de la última persona restante en un juego de conteo circular.\n   En este juego, las personas están numeradas del 1 a totalPeople y se sientan en un círculo.\n   Comenzando con la primera persona, cuentan del 1 a countNumber.\n   La persona que está en countNumber es eliminada del círculo,\n   y el conteo se reanuda desde la siguiente persona.\n   Este proceso continúa hasta que solo queda una persona.\n\n   Ejemplo:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "arb": "اكتب دالة C# `static int LastRemainingPerson(int totalPeople, int countNumber)` لحل المشكلة التالية:\nتحديد رقم الشخص الأخير المتبقي في لعبة العد الدائرية.\n   في هذه اللعبة، يتم ترقيم الأشخاص من 1 إلى totalPeople ويجلسون في دائرة.\n   بدءًا من الشخص الأول، يقومون بالعد من 1 إلى countNumber.\n   الشخص الذي يكون عند countNumber يتم إزالته من الدائرة،\n   ويستأنف العد من الشخص التالي.\n   تستمر هذه العملية حتى يبقى شخص واحد فقط.\n\n   مثال:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "sw": "Andika kazi ya C# `static int LastRemainingPerson(int totalPeople, int countNumber)` kutatua tatizo lifuatalo:\nTambua namba ya mtu wa mwisho aliyebaki katika mchezo wa kuhesabu wa mduara.\n   Katika mchezo huu, watu wanapewa namba kutoka 1 hadi totalPeople na wanakaa kwenye mduara.\n   Kuanzia na mtu wa kwanza, wanahesabu kutoka 1 hadi countNumber.\n   Mtu ambaye yuko kwenye countNumber anaondolewa kwenye mduara,\n   na kuhesabu kunaanza tena kutoka kwa mtu anayefuata.\n   Mchakato huu unaendelea hadi mtu mmoja tu atakapobaki.\n\n   Mfano:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "tr": "Bir C# fonksiyonu `static int LastRemainingPerson(int totalPeople, int countNumber)` yazın ve aşağıdaki problemi çözün:\nDairesel bir sayma oyununda son kalan kişinin numarasını belirleyin.\n   Bu oyunda, insanlar 1'den totalPeople'a kadar numaralandırılır ve bir daire şeklinde otururlar.\n   İlk kişiden başlayarak, 1'den countNumber'a kadar sayarlar.\n   countNumber'da olan kişi daireden çıkarılır,\n   ve sayma bir sonraki kişiden devam eder.\n   Bu süreç yalnızca bir kişi kalana kadar devam eder.\n\n   Örnek:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "vi": "Viết một hàm C# `static int LastRemainingPerson(int totalPeople, int countNumber)` để giải quyết vấn đề sau:\nXác định số của người cuối cùng còn lại trong một trò chơi đếm vòng tròn.\n   Trong trò chơi này, mọi người được đánh số từ 1 đến totalPeople và ngồi thành vòng tròn.\n   Bắt đầu với người đầu tiên, họ đếm từ 1 đến countNumber.\n   Người ở vị trí countNumber sẽ bị loại khỏi vòng tròn,\n   và việc đếm tiếp tục từ người kế tiếp.\n   Quá trình này tiếp tục cho đến khi chỉ còn một người.\n\n   Ví dụ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5"
    },
    "instruction_bertscore": {
      "es": "0.9866742849971314",
      "arb": "0.9870991553821651",
      "sw": "0.9816999843648747",
      "tr": "0.9803729347891806",
      "vi": "0.9744378590038582"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n        Debug.Assert(LastRemainingPerson(5, 2) == 3);\n        Debug.Assert(LastRemainingPerson(6, 4) == 5);\n        Debug.Assert(LastRemainingPerson(10, 3) == 4);\n        Debug.Assert(LastRemainingPerson(7, 2) == 7);\n\n    }\n}",
    "entry_point": "LastRemainingPerson",
    "signature": "static int LastRemainingPerson(int totalPeople, int countNumber)",
    "docstring": {
      "es": "Determinar el número de la última persona restante en un juego de conteo circular. \n   En este juego, las personas están numeradas del 1 al totalPeople y se sientan en un círculo. \n   Comenzando con la primera persona, cuentan del 1 al countNumber. \n   La persona que está en countNumber es removida del círculo, \n   y el conteo se reanuda desde la siguiente persona. \n   Este proceso continúa hasta que solo queda una persona.\n\n   Ejemplo:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "arb": "تحديد رقم الشخص الأخير المتبقي في لعبة العد الدائري.\n   في هذه اللعبة، يتم ترقيم الأشخاص من 1 إلى totalPeople ويجلسون في دائرة.\n   بدءًا من الشخص الأول، يقومون بالعد من 1 إلى countNumber.\n   الشخص الذي يكون عند countNumber يتم إزالته من الدائرة،\n   ويستأنف العد من الشخص التالي.\n   تستمر هذه العملية حتى يبقى شخص واحد فقط.\n\n   مثال:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "sw": "Amua namba ya mtu wa mwisho aliyebaki katika mchezo wa kuhesabu wa mduara.\n   Katika mchezo huu, watu wanapewa namba kutoka 1 hadi totalPeople na wanakaa katika mduara.\n   Kuanzia na mtu wa kwanza, wanahesabu kutoka 1 hadi countNumber.\n   Mtu ambaye yuko kwenye countNumber anaondolewa kwenye mduara,\n   na kuhesabu kunaanza tena kutoka kwa mtu anayefuata.\n   Mchakato huu unaendelea hadi mtu mmoja tu abaki.\n\n   Mfano:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "tr": "Son kalan kişinin numarasını dairesel bir sayma oyununda belirleyin.\n   Bu oyunda, insanlar 1'den toplamKisi sayısına kadar numaralandırılır ve bir daire içinde otururlar.\n   İlk kişiden başlayarak, 1'den sayiNumarasi'na kadar sayarlar.\n   sayiNumarasi'ndaki kişi daireden çıkarılır,\n   ve sayma işlemi bir sonraki kişiden devam eder.\n   Bu işlem sadece bir kişi kalana kadar devam eder.\n\n   Örnek:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "vi": "Xác định số của người còn lại cuối cùng trong một trò chơi đếm vòng tròn. Trong trò chơi này, mọi người được đánh số từ 1 đến totalPeople và ngồi thành một vòng tròn. Bắt đầu với người đầu tiên, họ đếm từ 1 đến countNumber. Người ở vị trí countNumber sẽ bị loại khỏi vòng tròn, và việc đếm tiếp tục từ người tiếp theo. Quá trình này tiếp tục cho đến khi chỉ còn một người.\n\nVí dụ:\n>>> LastRemainingPerson(5, 2)\n3\n>>> LastRemainingPerson(6, 4)\n5"
    },
    "docstring_bertscore": {
      "es": "0.9900877480952159",
      "arb": "0.9866520383944555",
      "sw": "0.9781355621772037",
      "tr": "0.9666847193409234",
      "vi": "0.9707276421165075"
    }
  },
  {
    "task_id": "C#/35",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Determina el número mínimo de pasos necesarios para convertir un número en un palíndromo en una base dada (de 2 a 16).\n   La función toma un entero que representa la base y una cadena que representa el número en esa base.\n   Un palíndromo es un número que se lee igual hacia adelante y hacia atrás en la misma base.\n   Calcula el número de pasos necesarios para alcanzar un palíndromo sumando repetidamente el número a su inverso en la base dada.\n   Si no se obtiene un palíndromo dentro de 30 pasos, devuelve \"¡Imposible!\".\n\n   Casos de ejemplo:\n   >>> StepsToPalindrome(10, \"56\")  // En base 10, \"56\" se convierte en el palíndromo \"121\" en 1 paso\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // En base 9, \"87\" se convierte en el palíndromo \"4884\" en 6 pasos\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* يحدد الحد الأدنى لعدد الخطوات المطلوبة لتحويل رقم إلى عدد متناظر في قاعدة معينة (من 2 إلى 16).\n   تأخذ الدالة عددًا صحيحًا يمثل القاعدة وسلسلة تمثل الرقم في تلك القاعدة.\n   العدد المتناظر هو رقم يقرأ نفسه بنفس الطريقة عند قراءته من الأمام والخلف في نفس القاعدة.\n   تحسب عدد الخطوات المطلوبة للوصول إلى عدد متناظر عن طريق إضافة الرقم إلى معكوسه في القاعدة المعطاة بشكل متكرر.\n   إذا لم يتم الحصول على عدد متناظر في غضون 30 خطوة، فإنه يعيد \"مستحيل!\".\n\n   أمثلة على الحالات:\n   >>> StepsToPalindrome(10, \"56\")  // في القاعدة 10، يصبح \"56\" العدد المتناظر \"121\" في خطوة واحدة\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // في القاعدة 9، يصبح \"87\" العدد المتناظر \"4884\" في 6 خطوات\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Huamua idadi ndogo ya hatua zinazohitajika kubadilisha nambari kuwa palindrome katika msingi uliotolewa (kutoka 2 hadi 16). \n   Kazi inachukua nambari nzima inayowakilisha msingi na kamba inayowakilisha nambari katika msingi huo. \n   Palindrome ni nambari inayosomwa sawa mbele na nyuma katika msingi huo huo.\n   Inahesabu idadi ya hatua zinazohitajika kufikia palindrome kwa kuongeza nambari hiyo kwa kinyume chake katika msingi uliotolewa.\n   Ikiwa palindrome haipatikani ndani ya hatua 30, inarudisha \"Haiwezekani!\".\n\n   Mifano ya kesi:\n   >>> StepsToPalindrome(10, \"56\")  // Katika msingi 10, \"56\" inakuwa palindrome \"121\" katika hatua 1\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Katika msingi 9, \"87\" inakuwa palindrome \"4884\" katika hatua 6\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Bir sayıyı belirli bir tabanda (2'den 16'ya kadar) palindroma dönüştürmek için gereken minimum adım sayısını belirler.\n   Fonksiyon, tabanı temsil eden bir tam sayı ve bu tabandaki sayıyı temsil eden bir dize alır.\n   Palindrom, aynı tabanda ileri ve geri okunduğunda aynı olan bir sayıdır.\n   Verilen tabanda sayıyı tersine ekleyerek bir palindroma ulaşmak için gereken adım sayısını hesaplar.\n   Eğer 30 adım içinde bir palindrom elde edilmezse, \"Impossible!\" döner.\n\n   Örnek durumlar:\n   >>> StepsToPalindrome(10, \"56\")  // Taban 10'da, \"56\" 1 adımda \"121\" palindromuna dönüşür\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Taban 9'da, \"87\" 6 adımda \"4884\" palindromuna dönüşür\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Xác định số bước tối thiểu cần thiết để chuyển đổi một số thành số đối xứng trong một cơ số cho trước (từ 2 đến 16).\n   Hàm nhận một số nguyên đại diện cho cơ số và một chuỗi đại diện cho số trong cơ số đó.\n   Một số đối xứng là một số mà đọc xuôi hay ngược đều giống nhau trong cùng một cơ số.\n   Nó tính toán số bước cần thiết để đạt được số đối xứng bằng cách liên tục cộng số với số đảo ngược của nó trong cơ số cho trước.\n   Nếu không đạt được số đối xứng trong vòng 30 bước, nó trả về \"Không thể!\".\n\n   Các trường hợp ví dụ:\n   >>> StepsToPalindrome(10, \"56\")  // Trong cơ số 10, \"56\" trở thành số đối xứng \"121\" trong 1 bước\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Trong cơ số 9, \"87\" trở thành số đối xứng \"4884\" trong 6 bước\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)"
    },
    "prompt_bertscore": {
      "es": "0.9886731025214855",
      "arb": "0.971715033740632",
      "sw": "0.9897031996775324",
      "tr": "0.9794711528592822",
      "vi": "0.987850971374382"
    },
    "canonical_solution": "    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }",
    "instruction": {
      "es": "Escribe una función en C# `public static string StepsToPalindrome(int baseNum, string num)` para resolver el siguiente problema:\nDetermina el número mínimo de pasos necesarios para convertir un número en un palíndromo en una base dada (de 2 a 16).\n   La función toma un entero que representa la base y una cadena que representa el número en esa base.\n   Un palíndromo es un número que se lee igual hacia adelante y hacia atrás en la misma base.\n   Calcula el número de pasos necesarios para alcanzar un palíndromo sumando repetidamente el número a su reverso en la base dada.\n   Si no se obtiene un palíndromo en 30 pasos, devuelve \"¡Imposible!\".\n\n   Casos de ejemplo:\n   >>> StepsToPalindrome(10, \"56\")  // En base 10, \"56\" se convierte en el palíndromo \"121\" en 1 paso\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // En base 9, \"87\" se convierte en el palíndromo \"4884\" en 6 pasos\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "arb": "اكتب دالة C# `public static string StepsToPalindrome(int baseNum, string num)` لحل المشكلة التالية:\nتحديد الحد الأدنى لعدد الخطوات المطلوبة لتحويل رقم إلى عدد متناظر في قاعدة معينة (من 2 إلى 16).\nتأخذ الدالة عددًا صحيحًا يمثل القاعدة وسلسلة نصية تمثل الرقم في تلك القاعدة.\nالعدد المتناظر هو رقم يقرأ بنفس الطريقة من الأمام والخلف في نفس القاعدة.\nتحسب عدد الخطوات المطلوبة للوصول إلى عدد متناظر عن طريق إضافة الرقم إلى معكوسه في القاعدة المعطاة بشكل متكرر.\nإذا لم يتم الحصول على عدد متناظر في غضون 30 خطوة، فإنها تعيد \"مستحيل!\".\n\nحالات المثال:\n>>> StepsToPalindrome(10, \"56\")  // في القاعدة 10، \"56\" يصبح العدد المتناظر \"121\" في خطوة واحدة\n\"STEP=1\"\n>>> StepsToPalindrome(9, \"87\")   // في القاعدة 9، \"87\" يصبح العدد المتناظر \"4884\" في 6 خطوات\n\"STEP=6\"\n>>> StepsToPalindrome(2, \"1001\") \n\"STEP=0\"",
      "sw": "Andika kazi ya C# `public static string StepsToPalindrome(int baseNum, string num)` kutatua tatizo lifuatalo:\nInabainisha idadi ndogo zaidi ya hatua zinazohitajika kubadilisha namba kuwa palindromu katika msingi uliotolewa (kutoka 2 hadi 16).\n   Kazi inachukua nambari ya mzima inayowakilisha msingi na kamba inayowakilisha namba katika msingi huo.\n   Palindromu ni namba inayosomwa sawa mbele na nyuma katika msingi huo huo.\n   Inahesabu idadi ya hatua zinazohitajika kufikia palindromu kwa kuongeza namba kwa kinyume chake katika msingi uliotolewa.\n   Ikiwa palindromu haipatikani ndani ya hatua 30, inarudisha \"Impossible!\".\n\n   Mifano ya kesi:\n   >>> StepsToPalindrome(10, \"56\")  // Katika msingi wa 10, \"56\" inakuwa palindromu \"121\" katika hatua 1\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Katika msingi wa 9, \"87\" inakuwa palindromu \"4884\" katika hatua 6\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "tr": "Bir C# fonksiyonu `public static string StepsToPalindrome(int baseNum, string num)` yazın:\nBelirli bir tabanda (2'den 16'ya kadar) bir sayıyı palindroma dönüştürmek için gereken minimum adım sayısını belirler. \n   Fonksiyon, tabanı temsil eden bir tam sayı ve o tabandaki sayıyı temsil eden bir dize alır. \n   Palindrom, aynı tabanda ileri ve geri okunduğunda aynı olan bir sayıdır.\n   Verilen tabanda sayıyı tersine ekleyerek bir palindroma ulaşmak için gereken adım sayısını hesaplar.\n   Eğer 30 adım içinde bir palindrom elde edilmezse, \"Impossible!\" döner.\n\n   Örnek durumlar:\n   >>> StepsToPalindrome(10, \"56\")  // Taban 10'da, \"56\" 1 adımda palindrom \"121\" olur\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Taban 9'da, \"87\" 6 adımda palindrom \"4884\" olur\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "vi": "Viết một hàm C# `public static string StepsToPalindrome(int baseNum, string num)` để giải quyết vấn đề sau:\nXác định số bước tối thiểu cần thiết để chuyển một số thành số palindrome trong một cơ số cho trước (từ 2 đến 16).\n   Hàm nhận một số nguyên đại diện cho cơ số và một chuỗi đại diện cho số trong cơ số đó.\n   Một số palindrome là một số đọc giống nhau từ trái sang phải và từ phải sang trái trong cùng một cơ số.\n   Nó tính toán số bước cần thiết để đạt được một số palindrome bằng cách liên tục cộng số đó với số đảo ngược của nó trong cơ số cho trước.\n   Nếu không đạt được số palindrome trong vòng 30 bước, nó trả về \"Impossible!\".\n\n   Các trường hợp ví dụ:\n   >>> StepsToPalindrome(10, \"56\")  // Trong cơ số 10, \"56\" trở thành palindrome \"121\" trong 1 bước\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Trong cơ số 9, \"87\" trở thành palindrome \"4884\" trong 6 bước\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\""
    },
    "instruction_bertscore": {
      "es": "0.9807485448397176",
      "arb": "0.9865590793761312",
      "sw": "0.982704060941006",
      "tr": "0.9714687320681487",
      "vi": "0.9626135910512323"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(StepsToPalindrome(10, \"56\") == \"STEP=1\");\n        Debug.Assert(StepsToPalindrome(9, \"87\") == \"STEP=6\");\n        Debug.Assert(StepsToPalindrome(10, \"87\") == \"STEP=4\");\n        Debug.Assert(StepsToPalindrome(2, \"1001\") == \"STEP=0\"); // Already a palindrome\n        Debug.Assert(StepsToPalindrome(16, \"1A3\") == \"STEP=2\");\n\n\n    }\n}",
    "entry_point": "StepsToPalindrome",
    "signature": "public static string StepsToPalindrome(int baseNum, string num)",
    "docstring": {
      "es": "Determina el número mínimo de pasos necesarios para convertir un número en un palíndromo en una base dada (de 2 a 16). \n   La función toma un entero que representa la base y una cadena que representa el número en esa base. \n   Un palíndromo es un número que se lee igual hacia adelante y hacia atrás en la misma base.\n   Calcula el número de pasos necesarios para alcanzar un palíndromo sumando repetidamente el número a su inverso en la base dada.\n   Si no se obtiene un palíndromo en 30 pasos, devuelve \"¡Imposible!\".\n\n   Casos de ejemplo:\n   >>> StepsToPalindrome(10, \"56\")  // En base 10, \"56\" se convierte en el palíndromo \"121\" en 1 paso\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // En base 9, \"87\" se convierte en el palíndromo \"4884\" en 6 pasos\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "arb": "يحدد الحد الأدنى لعدد الخطوات المطلوبة لتحويل رقم إلى عدد متناظر في قاعدة معينة (من 2 إلى 16).\nتأخذ الدالة عددًا صحيحًا يمثل القاعدة وسلسلة نصية تمثل الرقم في تلك القاعدة.\nالعدد المتناظر هو الرقم الذي يقرأ بنفس الطريقة من الأمام والخلف في نفس القاعدة.\nتحسب عدد الخطوات المطلوبة للوصول إلى عدد متناظر عن طريق إضافة الرقم إلى معكوسه في القاعدة المعطاة بشكل متكرر.\nإذا لم يتم الحصول على عدد متناظر خلال 30 خطوة، فإنها تعيد \"مستحيل!\".\n\nحالات المثال:\n>>> StepsToPalindrome(10, \"56\")  // في القاعدة 10، يصبح \"56\" العدد المتناظر \"121\" في خطوة واحدة\n\"STEP=1\"\n>>> StepsToPalindrome(9, \"87\")   // في القاعدة 9، يصبح \"87\" العدد المتناظر \"4884\" في 6 خطوات\n\"STEP=6\"\n>>> StepsToPalindrome(2, \"1001\") \n\"STEP=0\"",
      "sw": "Inabainisha idadi ndogo ya hatua zinazohitajika kubadilisha nambari kuwa palindromu katika msingi uliotolewa (kutoka 2 hadi 16). \n   Kazi inachukua nambari nzima inayowakilisha msingi na kamba inayowakilisha nambari katika msingi huo. \n   Palindromu ni nambari inayosomwa sawa mbele na nyuma katika msingi huo huo.\n   Inahesabu idadi ya hatua zinazohitajika kufikia palindromu kwa kuongeza nambari kwa kinyume chake katika msingi uliotolewa mara kwa mara.\n   Ikiwa palindromu haipatikani ndani ya hatua 30, inarudisha \"Impossible!\".\n\n   Mifano ya kesi:\n   >>> StepsToPalindrome(10, \"56\")  // Katika msingi 10, \"56\" inakuwa palindromu \"121\" katika hatua 1\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Katika msingi 9, \"87\" inakuwa palindromu \"4884\" katika hatua 6\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "tr": "Verilen bir tabanda (2'den 16'ya kadar) bir sayıyı palindroma dönüştürmek için gereken minimum adım sayısını belirler. \n   Fonksiyon, tabanı temsil eden bir tam sayı ve bu tabandaki sayıyı temsil eden bir dize alır. \n   Palindrom, aynı tabanda ileri ve geri okunduğunda aynı olan bir sayıdır.\n   Verilen tabanda sayıyı tersine ekleyerek bir palindroma ulaşmak için gereken adım sayısını hesaplar.\n   Eğer 30 adım içinde bir palindrom elde edilmezse, \"Impossible!\" döndürür.\n\n   Örnek durumlar:\n   >>> StepsToPalindrome(10, \"56\")  // Taban 10'da, \"56\" 1 adımda palindrom \"121\" olur\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Taban 9'da, \"87\" 6 adımda palindrom \"4884\" olur\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "vi": "Xác định số bước tối thiểu cần thiết để chuyển đổi một số thành số đối xứng trong một cơ số cho trước (từ 2 đến 16). \n   Hàm nhận một số nguyên đại diện cho cơ số và một chuỗi đại diện cho số trong cơ số đó. \n   Một số đối xứng là một số mà đọc xuôi hay ngược đều giống nhau trong cùng một cơ số.\n   Nó tính toán số bước cần thiết để đạt được số đối xứng bằng cách liên tục cộng số đó với số đảo ngược của nó trong cơ số cho trước.\n   Nếu không đạt được số đối xứng trong vòng 30 bước, nó trả về \"Impossible!\".\n\n   Các trường hợp ví dụ:\n   >>> StepsToPalindrome(10, \"56\")  // Trong cơ số 10, \"56\" trở thành số đối xứng \"121\" trong 1 bước\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Trong cơ số 9, \"87\" trở thành số đối xứng \"4884\" trong 6 bước\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\""
    },
    "docstring_bertscore": {
      "es": "0.9860340992790559",
      "arb": "0.9876831287024076",
      "sw": "0.983415157705111",
      "tr": "0.9811307096928287",
      "vi": "0.9839884049847777"
    }
  },
  {
    "task_id": "C#/36",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina si una contraseña dada es segura según criterios específicos.\n   Una contraseña segura debe:\n   1. Tener al menos 8 caracteres de largo y no más de 16 caracteres.\n   2. Incluir caracteres de al menos tres de las siguientes categorías:\n      - Letras mayúsculas (A-Z)\n      - Letras minúsculas (a-z)\n      - Números (0-9)\n      - Símbolos especiales (~, !, @, #, $, %, ^)\n\n   Ejemplos:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد ما إذا كانت كلمة المرور المعطاة آمنة بناءً على معايير محددة.\n   يجب أن تكون كلمة المرور الآمنة:\n   1. لا تقل عن 8 أحرف ولا تزيد عن 16 حرفًا.\n   2. تتضمن أحرفًا من ثلاث فئات على الأقل من الفئات التالية:\n      - أحرف كبيرة (A-Z)\n      - أحرف صغيرة (a-z)\n      - أرقام (0-9)\n      - رموز خاصة (~, !, @, #, $, %, ^)\n\n   أمثلة:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Huamua kama nenosiri lililopeanwa ni salama kulingana na vigezo maalum.\n   Nenosiri salama lazima:\n   1. Liwe na urefu wa angalau herufi 8 na si zaidi ya herufi 16.\n   2. Lijumuishe herufi kutoka angalau makundi matatu kati ya yafuatayo:\n      - Herufi kubwa (A-Z)\n      - Herufi ndogo (a-z)\n      - Nambari (0-9)\n      - Alama maalum (~, !, @, #, $, %, ^)\n\n   Mifano:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Belirli kriterlere göre verilen bir şifrenin güvenli olup olmadığını belirler.\n   Güvenli bir şifre:\n   1. En az 8 karakter uzunluğunda ve en fazla 16 karakter olmalıdır.\n   2. Aşağıdaki kategorilerden en az üçünden karakterler içermelidir:\n      - Büyük harfler (A-Z)\n      - Küçük harfler (a-z)\n      - Sayılar (0-9)\n      - Özel semboller (~, !, @, #, $, %, ^)\n\n   Örnekler:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định xem một mật khẩu đã cho có an toàn dựa trên các tiêu chí cụ thể hay không.\n   Một mật khẩu an toàn phải:\n   1. Dài ít nhất 8 ký tự và không quá 16 ký tự.\n   2. Bao gồm các ký tự từ ít nhất ba trong số các danh mục sau:\n      - Chữ cái viết hoa (A-Z)\n      - Chữ cái viết thường (a-z)\n      - Số (0-9)\n      - Ký hiệu đặc biệt (~, !, @, #, $, %, ^)\n\n   Ví dụ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)"
    },
    "prompt_bertscore": {
      "es": "0.9971287978421407",
      "arb": "0.996111015769718",
      "sw": "0.9866474698956917",
      "tr": "0.9856793454185276",
      "vi": "0.9923749769328327"
    },
    "canonical_solution": "{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}",
    "instruction": {
      "es": "Escribe una función en C# `static string IsPasswordSecure(string password)` para resolver el siguiente problema:\nDetermina si una contraseña dada es segura según criterios específicos.\n   Una contraseña segura debe:\n   1. Tener al menos 8 caracteres y no más de 16 caracteres.\n   2. Incluir caracteres de al menos tres de las siguientes categorías:\n      - Letras mayúsculas (A-Z)\n      - Letras minúsculas (a-z)\n      - Números (0-9)\n      - Símbolos especiales (~, !, @, #, $, %, ^)\n\n   Ejemplos:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "arb": "اكتب دالة C# `static string IsPasswordSecure(string password)` لحل المشكلة التالية:\nتحديد ما إذا كانت كلمة المرور المعطاة آمنة بناءً على معايير محددة.\n   يجب أن تكون كلمة المرور الآمنة:\n   1. لا تقل عن 8 أحرف ولا تزيد عن 16 حرفًا.\n   2. تتضمن أحرفًا من ثلاث فئات على الأقل من الفئات التالية:\n      - أحرف كبيرة (A-Z)\n      - أحرف صغيرة (a-z)\n      - أرقام (0-9)\n      - رموز خاصة (~, !, @, #, $, %, ^)\n\n   أمثلة:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "sw": "Andika kazi ya C# `static string IsPasswordSecure(string password)` kutatua tatizo lifuatalo:  \nInabainisha kama nenosiri lililopewa ni salama kulingana na vigezo maalum.  \n   Nenosiri salama lazima:  \n   1. Liwe na urefu wa angalau herufi 8 na si zaidi ya herufi 16.  \n   2. Lijumuishe herufi kutoka angalau makundi matatu kati ya yafuatayo:  \n      - Herufi kubwa (A-Z)  \n      - Herufi ndogo (a-z)  \n      - Nambari (0-9)  \n      - Alama maalum (~, !, @, #, $, %, ^)  \n\n   Mifano:  \n   >>> IsPasswordSecure(\"Password123!\")  \n   \"YES\"  \n   >>> IsPasswordSecure(\"short\")  \n   \"NO\"  \n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")  \n   \"NO\"",
      "tr": "Bir C# fonksiyonu `static string IsPasswordSecure(string password)` yazın, aşağıdaki problemi çözmek için:\nBelirli kriterlere göre verilen bir şifrenin güvenli olup olmadığını belirler.\n   Güvenli bir şifre:\n   1. En az 8 karakter uzunluğunda ve en fazla 16 karakter olmalıdır.\n   2. Aşağıdaki kategorilerden en az üçünden karakterler içermelidir:\n      - Büyük harfler (A-Z)\n      - Küçük harfler (a-z)\n      - Sayılar (0-9)\n      - Özel semboller (~, !, @, #, $, %, ^)\n\n   Örnekler:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "vi": "Viết một hàm C# `static string IsPasswordSecure(string password)` để giải quyết vấn đề sau:  \nXác định xem một mật khẩu cho trước có an toàn hay không dựa trên các tiêu chí cụ thể.  \n   Một mật khẩu an toàn phải:  \n   1. Dài ít nhất 8 ký tự và không quá 16 ký tự.  \n   2. Bao gồm các ký tự từ ít nhất ba trong số các danh mục sau:  \n      - Chữ cái viết hoa (A-Z)  \n      - Chữ cái viết thường (a-z)  \n      - Số (0-9)  \n      - Ký hiệu đặc biệt (~, !, @, #, $, %, ^)  \n\n   Ví dụ:  \n   >>> IsPasswordSecure(\"Password123!\")  \n   \"YES\"  \n   >>> IsPasswordSecure(\"short\")  \n   \"NO\"  \n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")  \n   \"NO\"  "
    },
    "instruction_bertscore": {
      "es": "0.9842710560169903",
      "arb": "0.9844990836944184",
      "sw": "0.9985571489121625",
      "tr": "0.9810449013682216",
      "vi": "0.9916906952701675"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(IsPasswordSecure(\"Password123!\") == \"YES\");\n        Debug.Assert(IsPasswordSecure(\"short\") == \"NO\");\n        Debug.Assert(IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\") == \"NO\");\n        Debug.Assert(IsPasswordSecure(\"Good@Pass1\") == \"YES\");\n        Debug.Assert(IsPasswordSecure(\"1234567890\") == \"NO\");\n\n    }\n}",
    "entry_point": "IsPasswordSecure",
    "signature": "static string IsPasswordSecure(string password)",
    "docstring": {
      "es": "Determina si una contraseña dada es segura según criterios específicos.\n   Una contraseña segura debe:\n   1. Tener al menos 8 caracteres y no más de 16 caracteres.\n   2. Incluir caracteres de al menos tres de las siguientes categorías:\n      - Letras mayúsculas (A-Z)\n      - Letras minúsculas (a-z)\n      - Números (0-9)\n      - Símbolos especiales (~, !, @, #, $, %, ^)\n\n   Ejemplos:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "arb": "يحدد ما إذا كانت كلمة المرور المعطاة آمنة بناءً على معايير محددة.\n   يجب أن تكون كلمة المرور الآمنة:\n   1. لا تقل عن 8 أحرف ولا تزيد عن 16 حرفًا.\n   2. تتضمن أحرفًا من ثلاث فئات على الأقل من الفئات التالية:\n      - أحرف كبيرة (A-Z)\n      - أحرف صغيرة (a-z)\n      - أرقام (0-9)\n      - رموز خاصة (~, !, @, #, $, %, ^)\n\n   أمثلة:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "sw": "Inabainisha ikiwa nenosiri lililotolewa ni salama kulingana na vigezo maalum.  \nNenosiri salama lazima:  \n1. Liwe na urefu wa angalau herufi 8 na si zaidi ya herufi 16.  \n2. Lijumuishe herufi kutoka angalau makundi matatu kati ya yafuatayo:  \n   - Herufi kubwa (A-Z)  \n   - Herufi ndogo (a-z)  \n   - Nambari (0-9)  \n   - Alama maalum (~, !, @, #, $, %, ^)  \n\n   Mifano:  \n   >>> IsPasswordSecure(\"Password123!\")  \n   \"YES\"  \n   >>> IsPasswordSecure(\"short\")  \n   \"NO\"  \n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")  \n   \"NO\"  ",
      "tr": "Belirli kriterlere göre verilen bir şifrenin güvenli olup olmadığını belirler.\n   Güvenli bir şifre:\n   1. En az 8 karakter uzunluğunda ve en fazla 16 karakter olmalıdır.\n   2. Aşağıdaki kategorilerden en az üçünden karakterler içermelidir:\n      - Büyük harfler (A-Z)\n      - Küçük harfler (a-z)\n      - Sayılar (0-9)\n      - Özel semboller (~, !, @, #, $, %, ^)\n\n   Örnekler:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "vi": "Xác định xem một mật khẩu đã cho có an toàn hay không dựa trên các tiêu chí cụ thể.  \nMột mật khẩu an toàn phải:\n1. Dài ít nhất 8 ký tự và không quá 16 ký tự.\n2. Bao gồm các ký tự từ ít nhất ba trong số các danh mục sau:\n   - Chữ cái viết hoa (A-Z)\n   - Chữ cái viết thường (a-z)\n   - Số (0-9)\n   - Ký hiệu đặc biệt (~, !, @, #, $, %, ^)\n\nVí dụ:\n>>> IsPasswordSecure(\"Password123!\")\n\"YES\"\n>>> IsPasswordSecure(\"short\")\n\"NO\"\n>>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n\"NO\""
    },
    "docstring_bertscore": {
      "es": "0.9904432964772685",
      "arb": "0.9935391495960781",
      "sw": "0.9863010585111669",
      "tr": "0.9808677230683386",
      "vi": "0.9897812614172792"
    }
  },
  {
    "task_id": "C#/37",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Cuenta el número de formas en que un grupo de niños puede hacer fila para comprar boletos, asegurando que el vendedor de boletos siempre pueda dar cambio.\n   - totalKids: Número total de niños.\n   - oneDollarKids: Número de niños con exactamente 1 dólar.\n   - twoDollarKids: Número de niños con exactamente 2 dólares.\n   El vendedor de boletos no tiene cambio inicialmente, y el boleto cuesta 1 dólar.\n   Diferentes permutaciones de niños con la misma cantidad se consideran arreglos distintos.\n   Ejemplo:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* يحسب عدد الطرق التي يمكن لمجموعة من الأطفال الاصطفاف لشراء التذاكر، مع ضمان أن البائع يمكنه دائمًا إعطاء الباقي.\n   - totalKids: العدد الإجمالي للأطفال.\n   - oneDollarKids: عدد الأطفال الذين لديهم دولار واحد بالضبط.\n   - twoDollarKids: عدد الأطفال الذين لديهم دولارين بالضبط.\n   لا يمتلك بائع التذاكر أي فكة في البداية، وتكلفة التذكرة دولار واحد.\n   تعتبر التباديل المختلفة للأطفال الذين لديهم نفس المبلغ ترتيبات مميزة.\n   مثال:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Inahesabu idadi ya njia ambazo kundi la watoto linaweza kupanga foleni kununua tiketi, kuhakikisha muuzaji wa tiketi anaweza kila mara kutoa chenji.\n   - totalKids: Jumla ya watoto.\n   - oneDollarKids: Idadi ya watoto wenye dola 1 tu.\n   - twoDollarKids: Idadi ya watoto wenye dola 2 tu.\n   Muuzaji wa tiketi hana chenji mwanzoni, na tiketi inagharimu dola 1.\n   Mchanganyiko tofauti wa watoto wenye kiasi sawa huzingatiwa kama mipangilio tofauti.\n   Mfano:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Bir grup çocuğun bilet almak için sıraya girmesinin kaç farklı yolu olduğunu sayar, bilet satıcısının her zaman para üstü verebilmesini sağlar.\n   - totalKids: Toplam çocuk sayısı.\n   - oneDollarKids: Tam olarak 1 doları olan çocuk sayısı.\n   - twoDollarKids: Tam olarak 2 doları olan çocuk sayısı.\n   Bilet satıcısının başlangıçta para üstü yoktur ve bilet 1 dolar tutarındadır.\n   Aynı miktara sahip çocukların farklı permütasyonları farklı düzenlemeler olarak kabul edilir.\n   Örnek:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Đếm số cách mà một nhóm trẻ có thể xếp hàng để mua vé, đảm bảo rằng người bán vé luôn có thể thối tiền.\n   - totalKids: Tổng số trẻ em.\n   - oneDollarKids: Số trẻ có đúng 1 đô la.\n   - twoDollarKids: Số trẻ có đúng 2 đô la.\n   Người bán vé không có tiền thối ban đầu, và vé có giá 1 đô la.\n   Các hoán vị khác nhau của trẻ có cùng số tiền được coi là các sắp xếp khác biệt.\n   Ví dụ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)"
    },
    "prompt_bertscore": {
      "es": "0.9896167954617823",
      "arb": "0.9629027968860191",
      "sw": "0.9677859261733808",
      "tr": "0.9795563652927463",
      "vi": "0.9829728078465463"
    },
    "canonical_solution": "    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n",
    "instruction": {
      "es": "Escribe una función en C# `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` para resolver el siguiente problema:\nCuenta el número de formas en que un grupo de niños puede hacer fila para comprar boletos, asegurando que el vendedor de boletos siempre pueda dar cambio.\n   - totalKids: Número total de niños.\n   - oneDollarKids: Número de niños con exactamente 1 dólar.\n   - twoDollarKids: Número de niños con exactamente 2 dólares.\n   El vendedor de boletos no tiene cambio inicialmente, y el boleto cuesta 1 dólar.\n   Diferentes permutaciones de niños con la misma cantidad se consideran arreglos distintos.\n   Ejemplo:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "arb": "اكتب دالة C# `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` لحل المشكلة التالية:\nتحسب عدد الطرق التي يمكن لمجموعة من الأطفال أن يصطفوا فيها لشراء التذاكر، مع ضمان أن البائع يمكنه دائمًا إعطاء الباقي.\n   - totalKids: العدد الإجمالي للأطفال.\n   - oneDollarKids: عدد الأطفال الذين لديهم دولار واحد بالضبط.\n   - twoDollarKids: عدد الأطفال الذين لديهم دولاران بالضبط.\n   لا يمتلك البائع أي فكة في البداية، وتكلفة التذكرة دولار واحد.\n   تعتبر التباديل المختلفة للأطفال الذين لديهم نفس المبلغ ترتيبات مميزة.\n   مثال:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "sw": "Andika kazi ya C# `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` kutatua tatizo lifuatalo:\nHesabu idadi ya njia ambazo kundi la watoto linaweza kupanga foleni kununua tiketi, kuhakikisha muuzaji wa tiketi anaweza kila mara kutoa chenji.\n   - totalKids: Jumla ya watoto.\n   - oneDollarKids: Idadi ya watoto walio na dola 1 tu.\n   - twoDollarKids: Idadi ya watoto walio na dola 2 tu.\n   Muuzaji wa tiketi hana chenji mwanzoni, na tiketi inagharimu dola 1.\n   Mchanganyiko tofauti wa watoto wenye kiasi sawa huzingatiwa kama mipangilio tofauti.\n   Mfano:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "tr": "Bir C# fonksiyonu `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` yazın ve aşağıdaki problemi çözün:\nBir grup çocuğun bilet almak için sıraya girmesinin kaç farklı yolu olduğunu sayar, bilet satıcısının her zaman para üstü verebilmesini sağlar.\n   - totalKids: Toplam çocuk sayısı.\n   - oneDollarKids: Tam olarak 1 doları olan çocuk sayısı.\n   - twoDollarKids: Tam olarak 2 doları olan çocuk sayısı.\n   Bilet satıcısının başlangıçta para üstü yoktur ve bilet 1 dolar tutarındadır.\n   Aynı miktarda parası olan çocukların farklı permütasyonları farklı düzenlemeler olarak kabul edilir.\n   Örnek:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "vi": "Viết một hàm C# `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` để giải quyết vấn đề sau:\nĐếm số cách mà một nhóm trẻ có thể xếp hàng để mua vé, đảm bảo rằng người bán vé luôn có thể trả lại tiền thừa.\n   - totalKids: Tổng số trẻ.\n   - oneDollarKids: Số trẻ có đúng 1 đô la.\n   - twoDollarKids: Số trẻ có đúng 2 đô la.\n   Người bán vé ban đầu không có tiền thừa, và vé có giá 1 đô la.\n   Các hoán vị khác nhau của trẻ có cùng số tiền được coi là các cách sắp xếp khác nhau.\n   Ví dụ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8"
    },
    "instruction_bertscore": {
      "es": "0.987252498036324",
      "arb": "0.9640101612602886",
      "sw": "0.9787312546899273",
      "tr": "0.9818547174317009",
      "vi": "0.9826192457683042"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountQueueArrangements(4, 2, 2) == 8);\n        Debug.Assert(CountQueueArrangements(5, 3, 2) == 60); // Expected output: True\n        Debug.Assert(CountQueueArrangements(6, 4, 2) == 432); // Expected output: True\n\n    }\n}\n",
    "entry_point": "CountQueueArrangements",
    "signature": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
    "docstring": {
      "es": "Cuenta el número de formas en que un grupo de niños puede hacer fila para comprar boletos, asegurando que el vendedor de boletos siempre pueda dar cambio.\n   - totalKids: Número total de niños.\n   - oneDollarKids: Número de niños con exactamente 1 dólar.\n   - twoDollarKids: Número de niños con exactamente 2 dólares.\n   El vendedor de boletos no tiene cambio inicialmente, y el boleto cuesta 1 dólar.\n   Diferentes permutaciones de niños con la misma cantidad se consideran arreglos distintos.\n   Ejemplo:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "arb": "يحسب عدد الطرق التي يمكن لمجموعة من الأطفال أن يصطفوا فيها لشراء التذاكر، مع ضمان أن بائع التذاكر يمكنه دائمًا إعطاء الباقي.\n   - totalKids: العدد الإجمالي للأطفال.\n   - oneDollarKids: عدد الأطفال الذين لديهم دولار واحد بالضبط.\n   - twoDollarKids: عدد الأطفال الذين لديهم دولارين بالضبط.\n   لا يملك بائع التذاكر أي فكة في البداية، وسعر التذكرة دولار واحد.\n   تُعتبر الترتيبات المختلفة للأطفال الذين لديهم نفس المبلغ ترتيبات مميزة.\n   مثال:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "sw": "Hesabu idadi ya njia ambazo kundi la watoto linaweza kupanga foleni kununua tiketi, kuhakikisha muuzaji wa tiketi anaweza daima kutoa chenji.\n   - totalKids: Jumla ya idadi ya watoto.\n   - oneDollarKids: Idadi ya watoto walio na dola 1 tu.\n   - twoDollarKids: Idadi ya watoto walio na dola 2 tu.\n   Muuzaji wa tiketi hana chenji mwanzoni, na tiketi inagharimu dola 1.\n   Mchanganyiko tofauti wa watoto wenye kiasi sawa huzingatiwa kama mipangilio tofauti.\n   Mfano:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "tr": "Çocukların bilet almak için sıraya girebileceği yolların sayısını sayar, bilet satıcısının her zaman para üstü verebilmesini sağlar.\n   - totalKids: Toplam çocuk sayısı.\n   - oneDollarKids: Tam olarak 1 doları olan çocuk sayısı.\n   - twoDollarKids: Tam olarak 2 doları olan çocuk sayısı.\n   Bilet satıcısının başlangıçta para üstü yoktur ve bilet 1 dolar tutarındadır.\n   Aynı miktara sahip çocukların farklı permütasyonları farklı düzenlemeler olarak kabul edilir.\n   Örnek:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "vi": "Đếm số cách mà một nhóm trẻ em có thể xếp hàng để mua vé, đảm bảo rằng người bán vé luôn có thể trả lại tiền thừa.\n   - totalKids: Tổng số trẻ em.\n   - oneDollarKids: Số trẻ em có chính xác 1 đô la.\n   - twoDollarKids: Số trẻ em có chính xác 2 đô la.\n   Người bán vé không có tiền thừa ban đầu, và vé có giá 1 đô la.\n   Các hoán vị khác nhau của trẻ em với cùng số tiền được coi là các sắp xếp khác biệt.\n   Ví dụ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8"
    },
    "docstring_bertscore": {
      "es": "0.9829807530617877",
      "arb": "0.9354624070068114",
      "sw": "0.960192286706417",
      "tr": "0.9722467672706623",
      "vi": "0.9743595986337305"
    }
  },
  {
    "task_id": "C#/38",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina la diferencia absoluta mínima entre elementos de dos arreglos ordenados.\n   Se asume que cada arreglo está ordenado en orden ascendente.\n   Ejemplos:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد الحد الأدنى للفرق المطلق بين عناصر مصفوفتين مرتبتين.\n   يُفترض أن كل مصفوفة مرتبة بترتيب تصاعدي.\n   أمثلة:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inabainisha tofauti ndogo kabisa kati ya vipengele vya safu mbili zilizopangwa.\n   Kila safu inadhaniwa kupangwa kwa mpangilio wa kupanda.\n   Mifano:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* İki sıralı dizinin elemanları arasındaki minimum mutlak farkı belirler.\n   Her dizinin artan sırada sıralandığı varsayılır.\n   Örnekler:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định sự khác biệt tuyệt đối nhỏ nhất giữa các phần tử của hai mảng đã được sắp xếp.\n   Mỗi mảng được giả định là đã sắp xếp theo thứ tự tăng dần.\n   Ví dụ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)"
    },
    "prompt_bertscore": {
      "es": "0.9917431336907607",
      "arb": "0.9917431336907607",
      "sw": "0.977824109739741",
      "tr": "0.9852568585980664",
      "vi": "0.9859324005239661"
    },
    "canonical_solution": "{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int MinArrayDistance(int[] array1, int[] array2)` para resolver el siguiente problema:\nDetermina la diferencia absoluta mínima entre elementos de dos arreglos ordenados.\n   Se asume que cada arreglo está ordenado en orden ascendente.\n   Ejemplos:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "arb": "اكتب دالة C# `static int MinArrayDistance(int[] array1, int[] array2)` لحل المشكلة التالية:\nتحديد الحد الأدنى للفرق المطلق بين عناصر مصفوفتين مرتبتين.\n   يُفترض أن كل مصفوفة مرتبة بترتيب تصاعدي.\n   أمثلة:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "sw": "Andika kazi ya C# `static int MinArrayDistance(int[] array1, int[] array2)` kutatua tatizo lifuatalo:\nInabainisha tofauti ndogo kabisa ya thamani kati ya vipengele vya safu mbili zilizopangwa.\n   Kila safu inadhaniwa kupangwa kwa mpangilio wa kupanda.\n   Mifano:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "tr": "Bir C# fonksiyonu `static int MinArrayDistance(int[] array1, int[] array2)` yazın:\nİki sıralı dizinin elemanları arasındaki minimum mutlak farkı belirler.\n   Her dizinin artan sırayla sıralandığı varsayılır.\n   Örnekler:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "vi": "Viết một hàm C# `static int MinArrayDistance(int[] array1, int[] array2)` để giải quyết vấn đề sau:\nXác định sự khác biệt tuyệt đối nhỏ nhất giữa các phần tử của hai mảng đã được sắp xếp.\n   Mỗi mảng được giả định là sắp xếp theo thứ tự tăng dần.\n   Ví dụ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5"
    },
    "instruction_bertscore": {
      "es": "0.9842722477992765",
      "arb": "0.9876432039958196",
      "sw": "0.979942105492716",
      "tr": "0.9752292024419011",
      "vi": "0.9864969080668673"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6}) == 1);\n        Debug.Assert(MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35}) == 5);\n\n    }\n}",
    "entry_point": "MinArrayDistance",
    "signature": "static int MinArrayDistance(int[] array1, int[] array2)",
    "docstring": {
      "es": "Determina la diferencia mínima absoluta entre elementos de dos arreglos ordenados.  \n   Se asume que cada arreglo está ordenado en orden ascendente.  \n   Ejemplos:  \n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})  \n   1  \n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})  \n   5  ",
      "arb": "يحدد الحد الأدنى للفرق المطلق بين عناصر مصفوفتين مرتبتين.\n   يُفترض أن تكون كل مصفوفة مرتبة بترتيب تصاعدي.\n   أمثلة:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "sw": "Inabainisha tofauti ndogo kabisa ya thamani kati ya vipengele vya safu mbili zilizopangwa.\n   Kila safu inadhaniwa kupangwa kwa mpangilio wa kupanda.\n   Mifano:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "tr": "İki sıralı dizinin elemanları arasındaki minimum mutlak farkı belirler.  \nHer dizinin artan sırada sıralandığı varsayılır.  \nÖrnekler:  \n>>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})  \n1  \n>>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})  \n5  ",
      "vi": "Xác định sự khác biệt tuyệt đối nhỏ nhất giữa các phần tử của hai mảng đã được sắp xếp.\n   Mỗi mảng được giả định là đã được sắp xếp theo thứ tự tăng dần.\n   Ví dụ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5"
    },
    "docstring_bertscore": {
      "es": "0.9843822890303698",
      "arb": "0.9921795246378944",
      "sw": "0.9706263406221797",
      "tr": "0.9876501560591558",
      "vi": "0.9783945761940731"
    }
  },
  {
    "task_id": "C#/39",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Ordena una lista de enteros en orden descendente basado en sus valores absolutos.\n    Ejemplos:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* قم بفرز قائمة من الأعداد الصحيحة بترتيب تنازلي بناءً على قيمها المطلقة.\n    أمثلة:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Panga orodha ya nambari za mzima katika mpangilio wa kushuka kulingana na thamani zao kamili.\n    Mifano:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Bir tamsayı listesini mutlak değerlerine göre azalan sırayla sırala.\n    Örnekler:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Sắp xếp một danh sách các số nguyên theo thứ tự giảm dần dựa trên giá trị tuyệt đối của chúng.\n    Ví dụ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)"
    },
    "prompt_bertscore": {
      "es": "0.9953210627443422",
      "arb": "0.999999801369619",
      "sw": "0.999999801369619",
      "tr": "0.999999801369619",
      "vi": "0.9989442795247996"
    },
    "canonical_solution": "{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static List<int> SortByAbsoluteDescending(List<int> numbers)` para resolver el siguiente problema:\nOrdena una lista de enteros en orden descendente basado en sus valores absolutos.\n    Ejemplos:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "arb": "اكتب دالة C# `static List<int> SortByAbsoluteDescending(List<int> numbers)` لحل المشكلة التالية:\nترتيب قائمة من الأعداد الصحيحة بترتيب تنازلي بناءً على قيمها المطلقة.\n    أمثلة:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "sw": "Andika kazi ya C# `static List<int> SortByAbsoluteDescending(List<int> numbers)` kutatua tatizo lifuatalo:\nPanga orodha ya nambari nzima kwa mpangilio wa kushuka kulingana na thamani zao kamili.\n    Mifano:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "tr": "Bir C# fonksiyonu `static List<int> SortByAbsoluteDescending(List<int> numbers)` yazın:\nBir tamsayı listesini mutlak değerlerine göre azalan sırada sıralayın.\n    Örnekler:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "vi": "Viết một hàm C# `static List<int> SortByAbsoluteDescending(List<int> numbers)` để giải quyết vấn đề sau:\nSắp xếp một danh sách các số nguyên theo thứ tự giảm dần dựa trên giá trị tuyệt đối của chúng.\n    Ví dụ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]"
    },
    "instruction_bertscore": {
      "es": "0.9944006095586265",
      "arb": "0.9999996027392379",
      "sw": "0.9999996027392379",
      "tr": "0.9637553184814208",
      "vi": "0.9985656900185471"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(SortByAbsoluteDescending(new List<int> { 3, -4, 2 }).SequenceEqual(new List<int> { -4, 3, 2 }));\n        Debug.Assert(SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 }).SequenceEqual(new List<int> { -3, 2, 1, 0 }));\n\n\n    }\n}",
    "entry_point": "SortByAbsoluteDescending",
    "signature": "static List<int> SortByAbsoluteDescending(List<int> numbers)",
    "docstring": {
      "es": "Ordenar una lista de enteros en orden descendente basado en sus valores absolutos.\n    Ejemplos:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "arb": "فرز قائمة من الأعداد الصحيحة بترتيب تنازلي بناءً على قيمها المطلقة.\n    أمثلة:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "sw": "Panga orodha ya nambari nzima kwa mpangilio wa kushuka kulingana na thamani zao kamili.\n    Mifano:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "tr": "Tam sayıların bir listesini mutlak değerlerine göre azalan sırayla sıralayın.\n    Örnekler:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "vi": "Sắp xếp một danh sách các số nguyên theo thứ tự giảm dần dựa trên giá trị tuyệt đối của chúng.\n    Ví dụ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.9926039977621659",
      "vi": "0.9981149976839789"
    }
  },
  {
    "task_id": "C#/40",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calcula el valor total máximo de compras dentro de un presupuesto, considerando los artículos principales y sus accesorios.\n    - `totalMoney` es el presupuesto total.\n    - `items` es una lista de tuplas, donde cada tupla representa un artículo con su precio, importancia y categoría (0 para artículos principales, número del artículo principal si es un accesorio).\n    Por ejemplo:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* يحسب القيمة الإجمالية القصوى للمشتريات ضمن الميزانية، مع الأخذ في الاعتبار العناصر الرئيسية وملحقاتها.\n    - `totalMoney` هو إجمالي الميزانية.\n    - `items` هي قائمة من الأزواج، حيث يمثل كل زوج عنصرًا مع سعره وأهميته وفئته (0 للعناصر الرئيسية، رقم العنصر الرئيسي إذا كان ملحقًا).\n    على سبيل المثال:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Inahesabu thamani ya juu kabisa ya manunuzi ndani ya bajeti, ikizingatia vitu vikuu na vifaa vya ziada.\n    - `totalMoney` ni bajeti jumla.\n    - `items` ni orodha ya jozi, ambapo kila jozi inawakilisha kipengee na bei yake, umuhimu, na aina (0 kwa vitu vikuu, namba ya kipengee kikuu ikiwa ni kifaa cha ziada).\n    Kwa mfano:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Bir bütçe dahilinde, ana ürünler ve bunların aksesuarlarını dikkate alarak satın alımların maksimum toplam değerini hesaplar.\n    - `totalMoney` toplam bütçedir.\n    - `items` her bir demetin bir ürünün fiyatını, önemini ve kategorisini temsil ettiği demetlerin bir listesidir (0 ana ürünler için, bir aksesuar ise ana ürünün ürün numarası).\n    Örneğin:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Tính toán tổng giá trị tối đa của các lần mua hàng trong phạm vi ngân sách, xem xét các mặt hàng chính và phụ kiện của chúng.\n    - `totalMoney` là tổng ngân sách.\n    - `items` là danh sách các bộ giá trị, trong đó mỗi bộ đại diện cho một mặt hàng với giá, tầm quan trọng và loại (0 cho mặt hàng chính, số thứ tự của mặt hàng chính nếu là phụ kiện).\n    Ví dụ:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)"
    },
    "prompt_bertscore": {
      "es": "0.9922411000560152",
      "arb": "0.9927303266845041",
      "sw": "0.9851376803694455",
      "tr": "0.9731008779091124",
      "vi": "0.984383480812656"
    },
    "canonical_solution": "{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}",
    "instruction": {
      "es": "Escribe una función en C# `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` para resolver el siguiente problema:\nCalcula el valor total máximo de las compras dentro de un presupuesto, considerando los artículos principales y sus accesorios.\n- `totalMoney` es el presupuesto total.\n- `items` es una lista de tuplas, donde cada tupla representa un artículo con su precio, importancia y categoría (0 para artículos principales, número de artículo del artículo principal si es un accesorio).\nPor ejemplo:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "arb": "اكتب دالة C# `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` لحل المشكلة التالية:\nتحسب القيمة الإجمالية القصوى للمشتريات ضمن الميزانية، مع الأخذ في الاعتبار العناصر الرئيسية وملحقاتها.\n- `totalMoney` هو إجمالي الميزانية.\n- `items` هي قائمة من الأزواج، حيث يمثل كل زوج عنصرًا مع سعره وأهميته وفئته (0 للعناصر الرئيسية، رقم العنصر الرئيسي إذا كان ملحقًا).\nعلى سبيل المثال:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "sw": "Andika kazi ya C# `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` kutatua tatizo lifuatalo:\nHesabu thamani ya juu kabisa ya manunuzi ndani ya bajeti, ukizingatia vitu vikuu na vifaa vyao.\n- `totalMoney` ni jumla ya bajeti.\n- `items` ni orodha ya jozi, ambapo kila jozi inawakilisha kipengee na bei yake, umuhimu, na kategoria (0 kwa vitu vikuu, nambari ya kipengee kikuu ikiwa ni kifaa).\nKwa mfano:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "tr": "Bir C# fonksiyonu `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` yazın ve aşağıdaki problemi çözün:\nAna ürünler ve bunların aksesuarlarını dikkate alarak, bir bütçe dahilinde satın alımların maksimum toplam değerini hesaplar.\n- `totalMoney` toplam bütçedir.\n- `items`, her bir demetin fiyatını, önemini ve kategorisini temsil ettiği demetlerin bir listesidir (0 ana ürünler için, bir aksesuar ise ana ürünün numarası).\nÖrneğin:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "vi": "Viết một hàm C# `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` để giải quyết vấn đề sau:\nTính toán tổng giá trị mua hàng tối đa trong một ngân sách, xem xét các mặt hàng chính và phụ kiện của chúng.\n   - `totalMoney` là tổng ngân sách.\n   - `items` là một danh sách các bộ giá trị, trong đó mỗi bộ giá trị đại diện cho một mặt hàng với giá, tầm quan trọng và loại (0 cho mặt hàng chính, số thứ tự của mặt hàng chính nếu là phụ kiện).\n   Ví dụ:\n   >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n   2200\n   >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n   1700"
    },
    "instruction_bertscore": {
      "es": "0.987275539160524",
      "arb": "0.9791581113787713",
      "sw": "0.9907327009424363",
      "tr": "0.969830825946135",
      "vi": "0.9776896369717804"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) }) == 2200);\n        Debug.Assert(MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) }) == 1700);\n\n    }\n}\n",
    "entry_point": "MaxValueOfPurchases",
    "signature": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
    "docstring": {
      "es": "Calcula el valor total máximo de compras dentro de un presupuesto, considerando artículos principales y sus accesorios.\n    - `totalMoney` es el presupuesto total.\n    - `items` es una lista de tuplas, donde cada tupla representa un artículo con su precio, importancia y categoría (0 para artículos principales, número de artículo del principal si es un accesorio).\n    Por ejemplo:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700",
      "arb": "يحسب القيمة الإجمالية القصوى للمشتريات ضمن ميزانية، مع الأخذ في الاعتبار العناصر الرئيسية وملحقاتها.\n- `totalMoney` هو إجمالي الميزانية.\n- `items` هي قائمة من الأزواج، حيث يمثل كل زوج عنصرًا مع سعره وأهميته وفئته (0 للعناصر الرئيسية، رقم العنصر الرئيسي إذا كان ملحقًا).\nعلى سبيل المثال:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "sw": "Huhesabu thamani ya juu kabisa ya ununuzi ndani ya bajeti, kwa kuzingatia vitu vikuu na vifaa vyake.\n- `totalMoney` ni jumla ya bajeti.\n- `items` ni orodha ya jozi, ambapo kila jozi inawakilisha kipengee na bei yake, umuhimu, na kategoria (0 kwa vitu vikuu, nambari ya kipengee kikuu ikiwa ni kifaa).\nKwa mfano:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "tr": "Satın alımların toplam maksimum değerini, ana öğeler ve bunların aksesuarlarını dikkate alarak bir bütçe dahilinde hesaplar.\n- `totalMoney` toplam bütçedir.\n- `items`, her bir demetin bir öğeyi fiyatı, önemi ve kategorisiyle temsil ettiği demetlerin bir listesidir (0 ana öğeler için, bir aksesuar ise ana öğenin öğe numarası).\nÖrneğin:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "vi": "Tính toán giá trị tổng tối đa của các lần mua hàng trong phạm vi ngân sách, xem xét các món hàng chính và phụ kiện của chúng.\n- `totalMoney` là tổng ngân sách.\n- `items` là một danh sách các bộ giá trị, trong đó mỗi bộ đại diện cho một món hàng với giá của nó, tầm quan trọng và loại (0 cho món hàng chính, số thứ tự của món hàng chính nếu là phụ kiện).\n\nVí dụ:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700"
    },
    "docstring_bertscore": {
      "es": "0.9895595899120442",
      "arb": "0.9859822567496058",
      "sw": "0.9846158783584669",
      "tr": "0.9830715271459206",
      "vi": "0.9792828512580611"
    }
  },
  {
    "task_id": "C#/41",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calcula el número total de cigarrillos que Peter puede fumar dado un número inicial de cigarrillos y una tasa de conversión de colillas a nuevos cigarrillos.\n    Se asume que Peter puede continuar fumando y convirtiendo colillas en nuevos cigarrillos siempre que tenga suficientes colillas para hacerlo.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بالنظر إلى عدد السجائر الأولي ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.\n    يُفترض أن بيتر يمكنه الاستمرار في التدخين وتحويل الأعقاب إلى سجائر جديدة طالما كان لديه ما يكفي من الأعقاب للقيام بذلك.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta akipewa idadi ya awali ya sigara na kiwango cha ubadilishaji wa vishina kuwa sigara mpya.\n    Inadhaniwa kuwa Peter anaweza kuendelea kuvuta na kubadilisha vishina kuwa sigara mpya mradi ana vishina vya kutosha kufanya hivyo.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Peter'ın başlangıçtaki sigara sayısı ve izmaritlerin yeni sigaralara dönüşüm oranı verildiğinde, Peter'ın içebileceği toplam sigara sayısını hesaplar.\n    Peter'ın yeterli izmariti olduğu sürece sigara içmeye ve izmaritleri yeni sigaralara dönüştürmeye devam edebileceği varsayılmaktadır.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tính tổng số điếu thuốc mà Peter có thể hút được với số lượng thuốc ban đầu và tỷ lệ chuyển đổi từ đầu lọc thành thuốc mới.\n    Giả sử rằng Peter có thể tiếp tục hút và chuyển đổi đầu lọc thành thuốc mới miễn là anh ta có đủ đầu lọc để làm điều đó.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)"
    },
    "prompt_bertscore": {
      "es": "0.9970171675679991",
      "arb": "0.9872761350516671",
      "sw": "0.9988243067746545",
      "tr": "0.9840040967848794",
      "vi": "0.9762483749269911"
    },
    "canonical_solution": "{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` para resolver el siguiente problema:\nCalcula el número total de cigarrillos que Peter puede fumar dado un número inicial de cigarrillos y una tasa de conversión de colillas a nuevos cigarrillos.\n    Se asume que Peter puede continuar fumando y convirtiendo colillas en nuevos cigarrillos mientras tenga suficientes colillas para hacerlo.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "arb": "اكتب دالة C# `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` لحل المشكلة التالية:\nتحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بالنظر إلى عدد السجائر الأولي ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.\n    يُفترض أن بيتر يمكنه الاستمرار في التدخين وتحويل الأعقاب إلى سجائر جديدة طالما كان لديه ما يكفي من الأعقاب للقيام بذلك.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "sw": "Andika kazi ya C# `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` kutatua tatizo lifuatalo:\nHesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na idadi ya awali ya sigara na kiwango cha ubadilishaji wa vipande vya sigara kuwa sigara mpya.\n    Inadhaniwa kuwa Peter anaweza kuendelea kuvuta na kubadilisha vipande vya sigara kuwa sigara mpya mradi tu ana vipande vya kutosha kufanya hivyo. \n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "tr": "Bir C# fonksiyonu `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` yazarak aşağıdaki problemi çözün:\nPeter'ın, başlangıçta sahip olduğu sigara sayısı ve izmaritleri yeni sigaralara dönüştürme oranı verildiğinde, toplam kaç sigara içebileceğini hesaplar.\n    Peter'ın, yeterli izmarite sahip olduğu sürece sigara içmeye ve izmaritleri yeni sigaralara dönüştürmeye devam edebileceği varsayılır.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "vi": "Viết một hàm C# `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` để giải quyết vấn đề sau:\nTính tổng số điếu thuốc mà Peter có thể hút được với một số lượng điếu thuốc ban đầu và tỷ lệ chuyển đổi đầu lọc thành điếu thuốc mới.\n    Giả sử rằng Peter có thể tiếp tục hút và chuyển đổi đầu lọc thành điếu thuốc mới miễn là anh ta có đủ đầu lọc để làm điều đó.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14"
    },
    "instruction_bertscore": {
      "es": "0.9869551483559148",
      "arb": "0.9854314547029961",
      "sw": "0.9759389087933388",
      "tr": "0.9679196044198173",
      "vi": "0.98531704360352"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n        Debug.Assert(TotalSmokedCigarettes(4, 3) == 5);\n        Debug.Assert(TotalSmokedCigarettes(10, 3) == 14);\n        Debug.Assert(TotalSmokedCigarettes(1, 2) == 1); // No conversion possible, should return initial cigarettes\n        Debug.Assert(TotalSmokedCigarettes(20, 4) ==26); // Additional case to test\n\n    }\n}",
    "entry_point": "TotalSmokedCigarettes",
    "signature": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
    "docstring": {
      "es": "Calcula el número total de cigarrillos que Peter puede fumar dado un número inicial de cigarrillos y una tasa de conversión de colillas a nuevos cigarrillos. Se asume que Peter puede continuar fumando y convirtiendo colillas en nuevos cigarrillos mientras tenga suficientes colillas para hacerlo.\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "arb": "يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بالنظر إلى عدد السجائر الأولي ومعدل تحويل أعقاب السجائر إلى سجائر جديدة. يُفترض أن بيتر يمكنه الاستمرار في التدخين وتحويل الأعقاب إلى سجائر جديدة طالما كان لديه ما يكفي من الأعقاب للقيام بذلك.\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta kwa kuzingatia idadi ya awali ya sigara na kiwango cha ubadilishaji wa vishungi kuwa sigara mpya. Inadhaniwa kwamba Peter anaweza kuendelea kuvuta na kubadilisha vishungi kuwa sigara mpya mradi tu ana vishungi vya kutosha kufanya hivyo.\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "tr": "Peter'ın başlangıçtaki sigara sayısı ve izmaritlerin yeni sigaralara dönüşüm oranı verildiğinde toplam kaç sigara içebileceğini hesaplar.\n    Peter'ın yeterli izmariti olduğu sürece sigara içmeye ve izmaritleri yeni sigaralara dönüştürmeye devam edebileceği varsayılmaktadır.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "vi": "Tính tổng số điếu thuốc lá mà Peter có thể hút được với số lượng điếu thuốc ban đầu và tỷ lệ chuyển đổi từ đầu lọc sang điếu thuốc mới. \n    Giả sử rằng Peter có thể tiếp tục hút và chuyển đổi đầu lọc thành điếu thuốc mới miễn là anh ta có đủ đầu lọc để làm điều đó.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14"
    },
    "docstring_bertscore": {
      "es": "0.9924715112980157",
      "arb": "0.9832753219168624",
      "sw": "0.9747310374462657",
      "tr": "0.9320143822224267",
      "vi": "0.9251709697046318"
    }
  },
  {
    "task_id": "C#/42",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina el número de pares de estudiantes que se consideran \"oponentes iguales\". Dos estudiantes son oponentes iguales si la diferencia en cada una de sus puntuaciones de las asignaturas (Chino, Matemáticas, Inglés) no supera 5, y la diferencia total en sus puntuaciones no supera 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد عدد الأزواج من الطلاب الذين يعتبرون \"خصوماً متساوين\". يعتبر الطالبان خصوماً متساوين إذا لم يتجاوز الفرق في درجات كل منهم في المواد (الصينية، الرياضيات، الإنجليزية) 5، ولم يتجاوز الفرق الإجمالي في درجاتهم 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inabainisha idadi ya jozi za wanafunzi ambao wanachukuliwa kuwa \"wapinzani sawa\". Wanafunzi wawili ni wapinzani sawa ikiwa tofauti katika alama za kila moja ya masomo yao (Kichina, Hisabati, Kiingereza) haizidi 5, na tofauti ya jumla katika alama zao haizidi 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \"Eşit rakipler\" olarak kabul edilen öğrenci çiftlerinin sayısını belirler. İki öğrenci, her bir dersin (Çince, Matematik, İngilizce) puanlarındaki fark 5'i geçmiyorsa ve toplam puan farkı 10'u geçmiyorsa eşit rakipler olarak kabul edilir.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định số lượng cặp học sinh được coi là \"đối thủ ngang bằng\". Hai học sinh là đối thủ ngang bằng nếu sự khác biệt trong điểm số của từng môn học (Ngữ văn, Toán, Tiếng Anh) không vượt quá 5, và tổng sự khác biệt trong điểm số của họ không vượt quá 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)"
    },
    "prompt_bertscore": {
      "es": "0.9851247693946783",
      "arb": "0.9915006059955171",
      "sw": "0.9956609193262929",
      "tr": "0.968567338092372",
      "vi": "0.9660125541315013"
    },
    "canonical_solution": "{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` para resolver el siguiente problema:\nDetermina el número de pares de estudiantes que se consideran \"oponentes iguales\". Dos estudiantes son oponentes iguales si la diferencia en cada una de sus puntuaciones de las materias (Chino, Matemáticas, Inglés) no excede 5, y la diferencia total en sus puntuaciones no excede 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "arb": "اكتب دالة C# `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` لحل المشكلة التالية:\nتحدد عدد أزواج الطلاب الذين يعتبرون \"خصوماً متساوين\". يعتبر طالبان خصوماً متساوين إذا لم يتجاوز الفرق في كل من درجاتهم في المواد (الصينية، الرياضيات، الإنجليزية) 5، ولم يتجاوز الفرق الإجمالي في درجاتهم 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "sw": "Andika kazi ya C# `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` kutatua tatizo lifuatalo:\nInabainisha idadi ya jozi za wanafunzi wanaoonekana kuwa \"wapinzani sawa\". Wanafunzi wawili ni wapinzani sawa ikiwa tofauti katika kila moja ya alama zao za masomo (Kichina, Hisabati, Kiingereza) haizidi 5, na tofauti ya jumla ya alama zao haizidi 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "tr": "Bir C# fonksiyonu `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` yazın ve aşağıdaki problemi çözün:\nÖğrencilerin \"eşit rakipler\" olarak kabul edildiği çiftlerin sayısını belirler. İki öğrenci, her bir derslerinin (Çince, Matematik, İngilizce) puanlarındaki fark 5'i geçmiyorsa ve toplam puanlarındaki fark 10'u geçmiyorsa eşit rakipler olarak kabul edilir.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "vi": "Viết một hàm C# `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` để giải quyết vấn đề sau:\nXác định số lượng cặp học sinh được coi là \"đối thủ ngang tài\". Hai học sinh là đối thủ ngang tài nếu chênh lệch điểm số của từng môn học (Ngữ văn, Toán, Tiếng Anh) không vượt quá 5, và tổng chênh lệch điểm số của họ không vượt quá 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9849267349047864",
      "arb": "0.9872042308537325",
      "sw": "0.8862155793760694",
      "tr": "0.9705300048873777",
      "vi": "0.9570596869671159"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) }) == 2);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(92, 95, 98), Tuple.Create(85, 90, 95) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 95, 90), Tuple.Create(95, 90, 85), Tuple.Create(90, 85, 80) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(80, 80, 80) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(100, 100, 99), Tuple.Create(101, 100, 99) }) == 3);\n\n    }\n}\n",
    "entry_point": "FindEqualOpponents",
    "signature": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
    "docstring": {
      "es": "Determina el número de pares de estudiantes que se consideran \"oponentes iguales\". Dos estudiantes son oponentes iguales si la diferencia en cada una de sus puntuaciones de asignaturas (Chino, Matemáticas, Inglés) no supera 5, y la diferencia total en sus puntuaciones no supera 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "arb": "يحدد عدد أزواج الطلاب الذين يُعتبرون \"خصومًا متساوين\". يُعتبر طالبان خصومًا متساوين إذا لم يتجاوز الفرق في درجات كل من موادهم (الصينية، الرياضيات، الإنجليزية) 5، ولم يتجاوز الفرق الإجمالي في درجاتهم 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "sw": "Inabainisha idadi ya jozi za wanafunzi ambao wanachukuliwa kuwa \"wapinzani sawa\". Wanafunzi wawili ni wapinzani sawa ikiwa tofauti katika kila moja ya alama zao za masomo (Kichina, Hisabati, Kiingereza) haizidi 5, na tofauti ya jumla katika alama zao haizidi 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "tr": "Öğrencilerin \"eşit rakipler\" olarak kabul edildiği çiftlerin sayısını belirler. İki öğrenci, her bir derslerinin (Çince, Matematik, İngilizce) puanlarındaki fark 5'i aşmıyorsa ve toplam puanlarındaki fark 10'u aşmıyorsa eşit rakipler olarak kabul edilir.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "vi": "Xác định số lượng cặp học sinh được coi là \"đối thủ ngang bằng\". Hai học sinh được coi là đối thủ ngang bằng nếu chênh lệch điểm số của từng môn học (Ngữ văn, Toán, Tiếng Anh) không vượt quá 5, và tổng chênh lệch điểm số của họ không vượt quá 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9825250949676937",
      "arb": "0.9905414198854997",
      "sw": "0.9843115766147215",
      "tr": "0.9819313887587804",
      "vi": "0.9554418425135867"
    }
  },
  {
    "task_id": "C#/43",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Encuentra la longitud de la secuencia de elementos consecutivos más larga en una lista dada de enteros.\n    La secuencia no necesita estar en orden pero debe consistir en números naturales consecutivos.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يجد طول أطول تسلسل من العناصر المتتالية في قائمة معينة من الأعداد الصحيحة.\n    لا يحتاج التسلسل إلى أن يكون بالترتيب ولكنه يجب أن يتكون من أعداد طبيعية متتالية.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inapata urefu wa mlolongo mrefu zaidi wa vipengele vinavyofuatana katika orodha iliyotolewa ya nambari za mzima.\n    Mlolongo hauhitaji kuwa katika mpangilio lakini lazima uwe na nambari za asili zinazofuatana.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Verilen bir tamsayı listesindeki en uzun ardışık elemanlar dizisinin uzunluğunu bulur.\n    Dizi sıralı olmak zorunda değildir ancak ardışık doğal sayılardan oluşmalıdır.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tìm độ dài của dãy phần tử liên tiếp dài nhất trong một danh sách số nguyên cho trước.\n    Dãy số không cần phải theo thứ tự nhưng phải bao gồm các số tự nhiên liên tiếp.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)"
    },
    "prompt_bertscore": {
      "es": "0.9936062866648679",
      "arb": "0.9936062866648679",
      "sw": "0.990543207558929",
      "tr": "0.9858843319717556",
      "vi": "0.9890707605443173"
    },
    "canonical_solution": "{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int LongestConsecutiveSequence(List<int> sequence)` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia de elementos consecutivos más larga en una lista dada de enteros.\n    La secuencia no necesita estar en orden, pero debe consistir en números naturales consecutivos.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "arb": "اكتب دالة C# `static int LongestConsecutiveSequence(List<int> sequence)` لحل المشكلة التالية:\nإيجاد طول أطول تسلسل من العناصر المتتالية في قائمة معينة من الأعداد الصحيحة.\n    لا يحتاج التسلسل إلى أن يكون مرتبًا ولكنه يجب أن يتكون من أعداد طبيعية متتالية.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "sw": "Andika kazi ya C# `static int LongestConsecutiveSequence(List<int> sequence)` kutatua tatizo lifuatalo:\nInapata urefu wa mlolongo mrefu zaidi wa vipengele vinavyofuatana katika orodha iliyotolewa ya nambari za mzima.\n    Mlolongo hauhitaji kuwa katika mpangilio lakini lazima uwe na nambari za asili zinazofuatana.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "tr": "Bir C# fonksiyonu `static int LongestConsecutiveSequence(List<int> sequence)` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı listesindeki en uzun ardışık elemanlar dizisinin uzunluğunu bulun.\n    Dizi sıralı olmak zorunda değildir ancak ardışık doğal sayılardan oluşmalıdır.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "vi": "Viết một hàm C# `static int LongestConsecutiveSequence(List<int> sequence)` để giải quyết vấn đề sau:\nTìm độ dài của dãy các phần tử liên tiếp dài nhất trong một danh sách số nguyên đã cho.\n    Dãy số không cần phải theo thứ tự nhưng phải bao gồm các số tự nhiên liên tiếp.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4"
    },
    "instruction_bertscore": {
      "es": "0.974527838566467",
      "arb": "0.980784894199447",
      "sw": "0.9863920312256809",
      "tr": "0.9776912260148286",
      "vi": "0.9850979542932385"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9}) == 6);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2}) == 4);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {100, 4, 200, 1, 3, 2}) == 4);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {1, 1}) == 1);\n\n    }\n}\n\n",
    "entry_point": "LongestConsecutiveSequence",
    "signature": "static int LongestConsecutiveSequence(List<int> sequence)",
    "docstring": {
      "es": "Encuentra la longitud de la secuencia de elementos consecutivos más larga en una lista dada de enteros.\n    La secuencia no necesita estar en orden, pero debe consistir en números naturales consecutivos.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "arb": "يجد طول أطول تسلسل من العناصر المتتالية في قائمة معينة من الأعداد الصحيحة.\n    لا يحتاج التسلسل إلى أن يكون بالترتيب ولكن يجب أن يتكون من أعداد طبيعية متتالية.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "sw": "Inapata urefu wa mlolongo mrefu zaidi wa vipengele vinavyoendelea katika orodha iliyotolewa ya nambari za mzima. \n    Mlolongo hauhitaji kuwa katika mpangilio lakini lazima uwe na nambari za asili zinazoendelea.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "tr": "Verilen bir tamsayı listesindeki en uzun ardışık elemanlar dizisinin uzunluğunu bulur.\n    Dizi sıralı olmak zorunda değildir ancak ardışık doğal sayılardan oluşmalıdır.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "vi": "Tìm độ dài của dãy phần tử liên tiếp dài nhất trong một danh sách số nguyên cho trước. \n    Dãy này không cần phải theo thứ tự nhưng phải bao gồm các số tự nhiên liên tiếp.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4"
    },
    "docstring_bertscore": {
      "es": "0.9799907699360695",
      "arb": "0.9919308394008387",
      "sw": "0.9890050138881948",
      "tr": "0.9826994924422423",
      "vi": "0.9699678809090491"
    }
  },
  {
    "task_id": "C#/44",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina cuál forma geométrica tiene un área más grande: el cuadrado de Alice con lado de longitud a, o el rectángulo de Bob con lados b y c.\n    - Si el cuadrado de Alice tiene un área más grande, devuelve \"Alice\".\n    - Si el rectángulo de Bob tiene un área más grande, devuelve \"Bob\".\n    \n    Ejemplos:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد الشكل الهندسي الذي يمتلك مساحة أكبر: مربع أليس بطول ضلع a، أو مستطيل بوب بأضلاع b و c.\n    - إذا كان مربع أليس يمتلك مساحة أكبر، يعيد \"Alice\".\n    - إذا كان مستطيل بوب يمتلك مساحة أكبر، يعيد \"Bob\".\n    \n    أمثلة:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inabainisha umbo la kijiometri la nani lina eneo kubwa zaidi: mraba wa Alice wenye urefu wa upande a, au mstatili wa Bob wenye pande b na c.\n    - Ikiwa mraba wa Alice una eneo kubwa zaidi, rudisha \"Alice\".\n    - Ikiwa mstatili wa Bob una eneo kubwa zaidi, rudisha \"Bob\".\n    \n    Mifano:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Kimin geometrik şeklinin daha büyük bir alana sahip olduğunu belirler: Alice'in kenar uzunluğu a olan karesi mi, yoksa Bob'un kenarları b ve c olan dikdörtgeni mi.\n    - Eğer Alice'in karesi daha büyük bir alana sahipse, \"Alice\" döndür.\n    - Eğer Bob'un dikdörtgeni daha büyük bir alana sahipse, \"Bob\" döndür.\n    \n    Örnekler:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định hình dạng hình học của ai có diện tích lớn hơn: hình vuông của Alice với độ dài cạnh a, hay hình chữ nhật của Bob với các cạnh b và c.\n    - Nếu hình vuông của Alice có diện tích lớn hơn, trả về \"Alice\".\n    - Nếu hình chữ nhật của Bob có diện tích lớn hơn, trả về \"Bob\".\n    \n    Ví dụ:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "es": "0.9958684880744744",
      "arb": "0.9862255789663736",
      "sw": "0.9935339852061713",
      "tr": "0.9999996027392379",
      "vi": "0.9919630175225663"
    },
    "canonical_solution": "{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}",
    "instruction": {
      "es": "Escribe una función en C# `static string CompareArea(int a, int b, int c)` para resolver el siguiente problema:\nDetermina qué figura geométrica tiene un área más grande: el cuadrado de Alice con lado de longitud a, o el rectángulo de Bob con lados b y c.\n   - Si el cuadrado de Alice tiene un área más grande, devuelve \"Alice\".\n   - Si el rectángulo de Bob tiene un área más grande, devuelve \"Bob\".\n    \n    Ejemplos:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "arb": "اكتب دالة C# `static string CompareArea(int a, int b, int c)` لحل المشكلة التالية:\nتحديد أي شكل هندسي له مساحة أكبر: مربع أليس بطول ضلع a، أو مستطيل بوب بأضلاع b و c.\n   - إذا كان مربع أليس له مساحة أكبر، أعد \"Alice\".\n   - إذا كان مستطيل بوب له مساحة أكبر، أعد \"Bob\".\n   \n   أمثلة:\n   >>> CompareArea(5, 4, 6)\n   \"Alice\"\n   \n   >>> CompareArea(7, 5, 10)\n   \"Bob\"",
      "sw": "Andika kazi ya C# `static string CompareArea(int a, int b, int c)` kutatua tatizo lifuatalo:\nInabainisha ni nani kati ya Alice au Bob ana umbo la kijiometri lenye eneo kubwa zaidi: mraba wa Alice wenye urefu wa upande a, au mstatili wa Bob wenye pande b na c.\n   - Ikiwa mraba wa Alice una eneo kubwa zaidi, rudisha \"Alice\".\n   - Ikiwa mstatili wa Bob una eneo kubwa zaidi, rudisha \"Bob\".\n   \n   Mifano:\n   >>> CompareArea(5, 4, 6)\n   \"Alice\"\n   \n   >>> CompareArea(7, 5, 10)\n   \"Bob\"",
      "tr": "C# dilinde `static string CompareArea(int a, int b, int c)` fonksiyonunu aşağıdaki problemi çözmek için yazın:\nKimin geometrik şeklinin daha büyük bir alana sahip olduğunu belirler: Kenar uzunluğu a olan Alice'in karesi mi, yoksa kenarları b ve c olan Bob'un dikdörtgeni mi.\n   - Eğer Alice'in karesi daha büyük bir alana sahipse, \"Alice\" döndürün.\n   - Eğer Bob'un dikdörtgeni daha büyük bir alana sahipse, \"Bob\" döndürün.\n    \n    Örnekler:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "vi": "Viết một hàm C# `static string CompareArea(int a, int b, int c)` để giải quyết vấn đề sau:\nXác định hình dạng hình học của ai có diện tích lớn hơn: hình vuông của Alice với độ dài cạnh a, hay hình chữ nhật của Bob với các cạnh b và c.\n   - Nếu hình vuông của Alice có diện tích lớn hơn, trả về \"Alice\".\n   - Nếu hình chữ nhật của Bob có diện tích lớn hơn, trả về \"Bob\".\n    \n    Ví dụ:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\""
    },
    "instruction_bertscore": {
      "es": "0.9804428526833049",
      "arb": "0.9879256563976512",
      "sw": "0.9693614623557495",
      "tr": "0.9825715744768558",
      "vi": "0.9895911721426287"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CompareArea(5, 4, 6) == \"Alice\");\n        Debug.Assert(CompareArea(7, 5, 10) == \"Bob\");\n        Debug.Assert(CompareArea(2, 2, 8) == \"Bob\"); // Testing with a square of side 2 and a rectangle 2x8\n        Debug.Assert(CompareArea(10, 5, 5) == \"Alice\"); // Testing with a square of side 10 and a rectangle 5x5\n\n\n    }\n}\n\n",
    "entry_point": "CompareArea",
    "signature": "static string CompareArea(int a, int b, int c)",
    "docstring": {
      "es": "Determina qué forma geométrica tiene un área mayor: el cuadrado de Alice con lado de longitud a, o el rectángulo de Bob con lados b y c.\n    - Si el cuadrado de Alice tiene un área mayor, devuelve \"Alice\".\n    - Si el rectángulo de Bob tiene un área mayor, devuelve \"Bob\".\n    \n    Ejemplos:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "arb": "يحدد الشكل الهندسي الذي يمتلك مساحة أكبر: مربع أليس بطول ضلع a، أو مستطيل بوب بأضلاع b و c.\n- إذا كان لمربع أليس مساحة أكبر، أعد \"Alice\".\n- إذا كان لمستطيل بوب مساحة أكبر، أعد \"Bob\".\n\nأمثلة:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "sw": "Inabainisha ni nani mwenye umbo la kijiometri lenye eneo kubwa zaidi: mraba wa Alice wenye urefu wa upande a, au mstatili wa Bob wenye pande b na c.\n- Ikiwa mraba wa Alice una eneo kubwa zaidi, rudisha \"Alice\".\n- Ikiwa mstatili wa Bob una eneo kubwa zaidi, rudisha \"Bob\".\n\nMifano:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "tr": "Alice'in kenar uzunluğu a olan karesinin mi, yoksa Bob'un kenarları b ve c olan dikdörtgeninin mi daha büyük bir alana sahip olduğunu belirler.\n- Eğer Alice'in karesi daha büyük bir alana sahipse, \"Alice\" döndür.\n- Eğer Bob'un dikdörtgeni daha büyük bir alana sahipse, \"Bob\" döndür.\n\nÖrnekler:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "vi": "Xác định hình dạng hình học của ai có diện tích lớn hơn: hình vuông của Alice với độ dài cạnh a, hoặc hình chữ nhật của Bob với các cạnh b và c.\n- Nếu hình vuông của Alice có diện tích lớn hơn, trả về \"Alice\".\n- Nếu hình chữ nhật của Bob có diện tích lớn hơn, trả về \"Bob\".\n\nVí dụ:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\""
    },
    "docstring_bertscore": {
      "es": "0.9842213984217316",
      "arb": "0.9941604654279553",
      "sw": "0.9814232922440931",
      "tr": "0.9580256265100885",
      "vi": "0.9874821147568004"
    }
  },
  {
    "task_id": "C#/45",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Encuentra M enteros positivos que suman N y tienen el producto máximo posible. Si existen múltiples soluciones,\n   devuelve la secuencia lexicográficamente más pequeña.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يجد M من الأعداد الصحيحة الموجبة التي مجموعها N ولها أكبر حاصل ضرب ممكن. إذا وجدت حلول متعددة،\n   يعيد الحل الذي يحتوي على التسلسل الأصغر لغويًا.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inapata nambari M za kimaadili ambazo jumla yake ni N na zina bidhaa kubwa zaidi inayowezekana. Ikiwa suluhisho nyingi zipo,\n   inarudisha ile iliyo na mlolongo mdogo wa lexicographically.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* M pozitif tam sayıyı bulur, bu sayılar N'ye toplamı eşittir ve mümkün olan en büyük çarpıma sahiptir. Birden fazla çözüm varsa, \n   sözlük sırasına göre en küçük olan diziyi döndürür.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tìm M số nguyên dương có tổng bằng N và có tích lớn nhất có thể. Nếu có nhiều giải pháp, \n   trả về giải pháp có dãy từ điển nhỏ nhất.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)"
    },
    "prompt_bertscore": {
      "es": "0.9729091995914136",
      "arb": "0.9736999471383135",
      "sw": "0.9684827215500512",
      "tr": "0.9398467754073945",
      "vi": "0.956463001302487"
    },
    "canonical_solution": "    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }",
    "instruction": {
      "es": "Escribe una función en C# `public static List<int> MaxProductPartition(int N, int M)` para resolver el siguiente problema:\nEncuentra M enteros positivos que sumen N y tengan el producto máximo posible. Si existen múltiples soluciones, \n   devuelve la secuencia lexicográficamente más pequeña.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "arb": "اكتب دالة C# `public static List<int> MaxProductPartition(int N, int M)` لحل المشكلة التالية:\nإيجاد M من الأعداد الصحيحة الموجبة التي يكون مجموعها N وتكون لها أكبر حاصل ضرب ممكن. إذا كانت هناك حلول متعددة، \n   تعيد الحل الذي يحتوي على التسلسل الأصغر لغويًا.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "sw": "Andika kazi ya C# `public static List<int> MaxProductPartition(int N, int M)` kutatua tatizo lifuatalo:\nInapata nambari M chanya ambazo jumla yake ni N na zina bidhaa kubwa zaidi inayowezekana. Ikiwa suluhisho nyingi zipo,\n   inarudisha ile yenye mlolongo mdogo zaidi kwa mpangilio wa alfabeti.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "tr": "Bir C# fonksiyonu `public static List<int> MaxProductPartition(int N, int M)` yazın ve aşağıdaki problemi çözün:\nN'ye toplamı olan ve maksimum olası çarpıma sahip M pozitif tam sayı bulun. Birden fazla çözüm varsa, \n   sözlük sırasına göre en küçük diziyi döndürür.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "vi": "Viết một hàm C# `public static List<int> MaxProductPartition(int N, int M)` để giải quyết vấn đề sau:\nTìm M số nguyên dương có tổng bằng N và có tích lớn nhất có thể. Nếu tồn tại nhiều giải pháp, \n   trả về giải pháp có dãy từ điển nhỏ nhất.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]"
    },
    "instruction_bertscore": {
      "es": "0.9683667214075268",
      "arb": "0.9561590968195036",
      "sw": "0.9487789850121523",
      "tr": "0.9346533854648563",
      "vi": "0.9540500394336752"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MaxProductPartition(6, 3).SequenceEqual(new List<int> { 2, 2, 2 }));\n        Debug.Assert(MaxProductPartition(8, 3).SequenceEqual(new List<int> { 2, 3, 3 }));\n        Debug.Assert(MaxProductPartition(10, 2).SequenceEqual(new List<int> { 5, 5 }));\n        Debug.Assert(MaxProductPartition(7, 3).SequenceEqual(new List<int> { 2, 2, 3 }));\n\n    }\n}\n",
    "entry_point": "MaxProductPartition",
    "signature": "public static List<int> MaxProductPartition(int N, int M)",
    "docstring": {
      "es": "Encuentra M enteros positivos que suman N y tienen el producto máximo posible. Si existen múltiples soluciones, \n   devuelve la que tiene la secuencia lexicográficamente más pequeña.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "arb": "يعثر على M من الأعداد الصحيحة الموجبة التي تجمع إلى N وتحقق أكبر حاصل ضرب ممكن. إذا وجدت حلول متعددة، \n   يُرجع الحل الذي يحتوي على التسلسل الأصغر ترتيبًا لغويًا.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "sw": "Inapata nambari kamili za M ambazo jumla yake ni N na zina bidhaa kubwa zaidi inayowezekana. Ikiwa suluhisho kadhaa zipo, \n   inarudisha ile iliyo na mlolongo mdogo zaidi kwa mpangilio wa herufi.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "tr": "N'ye toplamı M olan ve mümkün olan en büyük çarpıma sahip M pozitif tam sayı bulur. Birden fazla çözüm varsa, sözlük sırasına göre en küçük olan diziyi döndürür.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "vi": "Tìm M số nguyên dương mà tổng bằng N và có tích lớn nhất có thể. Nếu có nhiều giải pháp, \n   trả về giải pháp có dãy từ điển nhỏ nhất.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]"
    },
    "docstring_bertscore": {
      "es": "0.9721981028273088",
      "arb": "0.9521777494620404",
      "sw": "0.9122055702129604",
      "tr": "0.8876063893040758",
      "vi": "0.9224155690589158"
    }
  },
  {
    "task_id": "C#/46",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Cuenta el número de caracteres en una cadena de título dada, excluyendo espacios y caracteres de nueva línea.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحسب عدد الأحرف في سلسلة عنوان معينة، باستثناء المسافات وأحرف السطر الجديد.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inahesabu idadi ya herufi katika mfuatano wa herufi wa kichwa kilichopewa, bila kujumuisha nafasi na herufi za kurudi mstari mpya.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Verilen bir başlık dizesindeki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç tutarak sayar.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Đếm số ký tự trong một chuỗi tiêu đề đã cho, không bao gồm khoảng trắng và ký tự xuống dòng.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9898009258250016",
      "sw": "0.9969228181370076",
      "tr": "1",
      "vi": "0.9955326041001443"
    },
    "canonical_solution": "{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int CountTitleCharacters(string title)` para resolver el siguiente problema:\nCuenta el número de caracteres en una cadena de título dada, excluyendo espacios y caracteres de nueva línea.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "arb": "اكتب دالة C# `static int CountTitleCharacters(string title)` لحل المشكلة التالية:\nتحسب عدد الأحرف في سلسلة عنوان معينة، باستثناء المسافات وأحرف السطر الجديد.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "sw": "Andika kazi ya C# `static int CountTitleCharacters(string title)` kutatua tatizo lifuatalo:  \nHesabu idadi ya herufi katika mfuatano wa maandishi uliotolewa wa kichwa, ukiondoa nafasi na herufi za kurudi kwenye mstari mpya.  \n    >>> CountTitleCharacters(\"234\")  \n    3  \n    >>> CountTitleCharacters(\"Ca 45\")  \n    4  \n    >>> CountTitleCharacters(\"Hello World\\n\")  \n    10  \n    >>> CountTitleCharacters(\" 123 \")  \n    3",
      "tr": "Bir C# fonksiyonu `static int CountTitleCharacters(string title)` yazın:\nVerilen bir başlık dizesindeki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç tutarak sayar.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "vi": "Viết một hàm C# `static int CountTitleCharacters(string title)` để giải quyết vấn đề sau:  \nĐếm số ký tự trong một chuỗi tiêu đề cho trước, ngoại trừ các ký tự khoảng trắng và ký tự xuống dòng.  \n    >>> CountTitleCharacters(\"234\")  \n    3  \n    >>> CountTitleCharacters(\"Ca 45\")  \n    4  \n    >>> CountTitleCharacters(\"Hello World\\n\")  \n    10  \n    >>> CountTitleCharacters(\" 123 \")  \n    3  "
    },
    "instruction_bertscore": {
      "es": "0.829364584868169",
      "arb": "0.9843896383544681",
      "sw": "0.9873551899433191",
      "tr": "0.9704642582312553",
      "vi": "0.9899224876181949"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountTitleCharacters(\"234\") == 3);\n        Debug.Assert(CountTitleCharacters(\"Ca 45\") == 4);\n        Debug.Assert(CountTitleCharacters(\"Hello World\\n\") == 10);\n        Debug.Assert(CountTitleCharacters(\" 123 \") == 3);\n        Debug.Assert(CountTitleCharacters(\"\\nNew\\tLine\") == 7);\n\n    }\n}",
    "entry_point": "CountTitleCharacters",
    "signature": "static int CountTitleCharacters(string title)",
    "docstring": {
      "es": "Cuenta el número de caracteres en una cadena de título dada, excluyendo espacios y caracteres de nueva línea.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "arb": "يحسب عدد الأحرف في سلسلة عنوان معينة، باستثناء المسافات وأحرف السطر الجديد.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "sw": "Hesabu idadi ya herufi katika kamba ya kichwa kilichopewa, ukiondoa nafasi na herufi za kurudi mstari mpya.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "tr": "Verilen başlık dizesindeki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç, sayar.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "vi": "Đếm số ký tự trong một chuỗi tiêu đề cho trước, không bao gồm khoảng trắng và ký tự xuống dòng.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9919222982944542",
      "arb": "0.98208870402056",
      "sw": "0.9864798258540982",
      "tr": "0.9950940282188193",
      "vi": "0.9919222982944542"
    }
  },
  {
    "task_id": "C#/47",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina el número de estudiantes que se han inscrito tanto en el Curso A como en el Curso B.\n    Dadas dos listas de identificaciones de estudiantes para cada curso, esta función cuenta cuántas identificaciones aparecen en ambas listas.\n    - courseAStudents: List<int> que representa las identificaciones de estudiantes inscritos en el Curso A.\n    - courseBStudents: List<int> que representa las identificaciones de estudiantes inscritos en el Curso B.\n    \n    Ejemplo de uso:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد عدد الطلاب الذين سجلوا في كل من الدورة A والدورة B.\n    بالنظر إلى قائمتين من معرفات الطلاب لكل دورة، تقوم هذه الدالة بحساب عدد المعرفات التي تظهر في كلتا القائمتين.\n    - courseAStudents: List<int> تمثل معرفات الطلاب المسجلين في الدورة A.\n    - courseBStudents: List<int> تمثل معرفات الطلاب المسجلين في الدورة B.\n    \n    مثال على الاستخدام:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Huamua idadi ya wanafunzi ambao wamejiandikisha katika Kozi A na Kozi B.\n    Ukipewa orodha mbili za vitambulisho vya wanafunzi kwa kila kozi, kazi hii inahesabu ni vitambulisho vingapi vinavyoonekana katika orodha zote mbili.\n    - courseAStudents: List<int> inayowakilisha vitambulisho vya wanafunzi waliojiandikisha katika Kozi A.\n    - courseBStudents: List<int> inayowakilisha vitambulisho vya wanafunzi waliojiandikisha katika Kozi B.\n    \n    Mfano wa matumizi:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Hem Kurs A hem de Kurs B'ye kayıtlı olan öğrencilerin sayısını belirler.\n    Her kurs için öğrenci kimlik numaralarının iki listesi verildiğinde, bu fonksiyon her iki listede de kaç kimlik numarasının göründüğünü sayar.\n    - courseAStudents: Kurs A'ya kayıtlı öğrenci kimlik numaralarını temsil eden List<int>.\n    - courseBStudents: Kurs B'ye kayıtlı öğrenci kimlik numaralarını temsil eden List<int>.\n    \n    Örnek kullanım:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định số lượng sinh viên đã đăng ký cả Khóa học A và Khóa học B.\n    Cho hai danh sách mã số sinh viên cho mỗi khóa học, hàm này đếm có bao nhiêu mã số xuất hiện trong cả hai danh sách.\n    - courseAStudents: List<int> đại diện cho mã số sinh viên đã đăng ký Khóa học A.\n    - courseBStudents: List<int> đại diện cho mã số sinh viên đã đăng ký Khóa học B.\n    \n    Ví dụ sử dụng:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)"
    },
    "prompt_bertscore": {
      "es": "0.9801850304487216",
      "arb": "0.9707214845746954",
      "sw": "0.9773050885540968",
      "tr": "0.984901111585633",
      "vi": "0.9795458378825513"
    },
    "canonical_solution": "{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}",
    "instruction": {
      "arb": "اكتب دالة C# `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` لحل المشكلة التالية:\nتحدد عدد الطلاب الذين سجلوا في كل من الدورة A والدورة B.\n    بالنظر إلى قائمتين من معرفات الطلاب لكل دورة، تقوم هذه الدالة بحساب عدد المعرفات التي تظهر في كلتا القائمتين.\n    - courseAStudents: List<int> تمثل معرفات الطلاب المسجلين في الدورة A.\n    - courseBStudents: List<int> تمثل معرفات الطلاب المسجلين في الدورة B.\n    \n    مثال على الاستخدام:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "sw": "Andika kazi ya C# `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` kutatua tatizo lifuatalo:\nInabainisha idadi ya wanafunzi ambao wamejiandikisha katika Kozi A na Kozi B.\n    Ukipewa orodha mbili za vitambulisho vya wanafunzi kwa kila kozi, kazi hii inahesabu ni vitambulisho vingapi vinavyoonekana katika orodha zote mbili.\n    - courseAStudents: List<int> inawakilisha vitambulisho vya wanafunzi waliojiandikisha katika Kozi A.\n    - courseBStudents: List<int> inawakilisha vitambulisho vya wanafunzi waliojiandikisha katika Kozi B.\n    \n    Mfano wa matumizi:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "tr": "Bir C# fonksiyonu `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` yazın:\nHem Kurs A'ya hem de Kurs B'ye kayıtlı olan öğrencilerin sayısını belirler.\n    Her kurs için öğrenci kimlik numaralarının iki listesi verildiğinde, bu fonksiyon her iki listede de kaç kimlik numarasının göründüğünü sayar.\n    - courseAStudents: Kurs A'ya kayıtlı öğrenci kimlik numaralarını temsil eden List<int>.\n    - courseBStudents: Kurs B'ye kayıtlı öğrenci kimlik numaralarını temsil eden List<int>.\n    \n    Örnek kullanım:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "vi": "Viết một hàm C# `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` để giải quyết vấn đề sau:\nXác định số lượng sinh viên đã đăng ký cả Khóa học A và Khóa học B.\n    Cho hai danh sách ID sinh viên cho mỗi khóa học, hàm này đếm có bao nhiêu ID xuất hiện trong cả hai danh sách.\n    - courseAStudents: List<int> đại diện cho ID sinh viên đã đăng ký Khóa học A.\n    - courseBStudents: List<int> đại diện cho ID sinh viên đã đăng ký Khóa học B.\n    \n    Ví dụ sử dụng:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0"
    },
    "instruction_bertscore": {
      "es": "0.9747602361122778",
      "arb": "0.967735275426217",
      "sw": "0.978741186208979",
      "tr": "0.9688251603269553",
      "vi": "0.9878132316019854"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountCommonStudents(new List<int> { 1, 2, 3, 4, 5 }, new List<int> { 1, 3, 4, 5, 6 }) == 4);\n        Debug.Assert(CountCommonStudents(new List<int> { 7, 8, 9 }, new List<int> { 10, 11, 12 }) == 0);\n        Debug.Assert(CountCommonStudents(new List<int> { 1, 3, 5, 7, 9 }, new List<int> { 2, 4, 6, 8, 10 }) == 0);\n        Debug.Assert(CountCommonStudents(new List<int> { 2, 4, 6, 8 }, new List<int> { 1, 3, 5, 7, 8 }) == 1);\n\n\n    }\n}",
    "entry_point": "CountCommonStudents",
    "signature": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
    "docstring": {
      "es": "Determina el número de estudiantes que se han inscrito tanto en el Curso A como en el Curso B.\n    Dadas dos listas de IDs de estudiantes para cada curso, esta función cuenta cuántos IDs aparecen en ambas listas.\n    - courseAStudents: List<int> que representa los IDs de estudiantes inscritos en el Curso A.\n    - courseBStudents: List<int> que representa los IDs de estudiantes inscritos en el Curso B.\n    \n    Ejemplo de uso:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "arb": "يحدد عدد الطلاب الذين سجلوا في كل من الدورة A والدورة B.   \nمع إعطاء قائمتين من معرفات الطلاب لكل دورة، تقوم هذه الدالة بعدّ عدد المعرفات التي تظهر في كلتا القائمتين.  \n- courseAStudents: List<int> تمثل معرفات الطلاب المسجلين في الدورة A.  \n- courseBStudents: List<int> تمثل معرفات الطلاب المسجلين في الدورة B.  \n\nمثال على الاستخدام:  \n>>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})  \n4  \n>>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})  \n0  ",
      "sw": "Inabainisha idadi ya wanafunzi ambao wamejiandikisha katika Kozi A na Kozi B.\n    Ukipewa orodha mbili za vitambulisho vya wanafunzi kwa kila kozi, kazi hii inahesabu ni vitambulisho vingapi vinavyoonekana katika orodha zote mbili.\n    - courseAStudents: List<int> inayowakilisha vitambulisho vya wanafunzi waliosajiliwa katika Kozi A.\n    - courseBStudents: List<int> inayowakilisha vitambulisho vya wanafunzi waliosajiliwa katika Kozi B.\n    \n    Mfano wa matumizi:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "tr": "Her iki Kurs A ve Kurs B'ye kaydolmuş öğrenci sayısını belirler.\n    Her kurs için iki öğrenci kimlik listesi verildiğinde, bu fonksiyon her iki listede de kaç kimliğin göründüğünü sayar.\n    - courseAStudents: Kurs A'ya kaydolmuş öğrenci kimliklerini temsil eden List<int>.\n    - courseBStudents: Kurs B'ye kaydolmuş öğrenci kimliklerini temsil eden List<int>.\n    \n    Örnek kullanım:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "vi": "Xác định số lượng sinh viên đã đăng ký cả Khóa học A và Khóa học B.  \n    Cho hai danh sách mã số sinh viên cho mỗi khóa học, hàm này đếm có bao nhiêu mã số xuất hiện trong cả hai danh sách.  \n    - courseAStudents: List<int> đại diện cho mã số sinh viên đã đăng ký Khóa học A.  \n    - courseBStudents: List<int> đại diện cho mã số sinh viên đã đăng ký Khóa học B.  \n    \n    Ví dụ sử dụng:  \n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})  \n    4  \n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})  \n    0  "
    },
    "docstring_bertscore": {
      "es": "0.9734087549997165",
      "arb": "0.9688491946030605",
      "sw": "0.97276261037021",
      "tr": "0.9900869535736918",
      "vi": "0.9850564405436023"
    }
  },
  {
    "task_id": "C#/48",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calcula el número de manzanas enteras que quedan después de comer manzanas durante un tiempo determinado.\n   Cada manzana toma una cantidad específica de tiempo para comer, y la función devuelve cuántas manzanas enteras quedan sin comer.\n   - totalApples: el número total de manzanas disponibles\n   - timePerApple: el tiempo que se tarda en comer una manzana (timePerApple>=0)\n   - timeElapsed: el tiempo total transcurrido\n\n   Ejemplos:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحسب عدد التفاح الكامل المتبقي بعد تناول التفاح لفترة زمنية معينة.\n   يستغرق كل تفاحة وقتًا محددًا لتناولها، وتعيد الدالة عدد التفاح الكامل المتبقي غير المأكول.\n   - totalApples: العدد الإجمالي للتفاح المتاح\n   - timePerApple: الوقت الذي يستغرقه تناول تفاحة واحدة (timePerApple>=0)\n   - timeElapsed: إجمالي الوقت المنقضي\n\n   أمثلة:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inahesabu idadi ya tufaha nzima zilizobaki baada ya kula tufaha kwa muda uliotolewa.\n   Kila tufaha inachukua muda maalum kuliwa, na kazi hii inarudisha ni tufaha ngapi nzima zimebaki bila kuliwa.\n   - totalApples: jumla ya idadi ya tufaha zinazopatikana\n   - timePerApple: muda unaochukua kula tufaha moja (timePerApple>=0)\n   - timeElapsed: muda wote uliopita\n\n   Mifano:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Belirli bir süre boyunca elma yedikten sonra kalan bütün elmaların sayısını hesaplar.\n   Her bir elmanın yenmesi belirli bir süre alır ve fonksiyon kaç tane bütün elmanın yenmeden kaldığını döndürür.\n   - totalApples: mevcut toplam elma sayısı\n   - timePerApple: bir elmanın yenmesi için gereken süre (timePerApple>=0)\n   - timeElapsed: geçen toplam süre\n\n   Örnekler:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tính số lượng táo nguyên còn lại sau khi ăn táo trong một khoảng thời gian nhất định.\n   Mỗi quả táo mất một khoảng thời gian cụ thể để ăn, và hàm trả về số lượng táo nguyên còn lại chưa ăn.\n   - totalApples: tổng số lượng táo có sẵn\n   - timePerApple: thời gian để ăn một quả táo (timePerApple>=0)\n   - timeElapsed: tổng thời gian đã trôi qua\n\n   Ví dụ:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)"
    },
    "prompt_bertscore": {
      "es": "0.9949132745720776",
      "arb": "0.9816699911773384",
      "sw": "0.9754202848684568",
      "tr": "0.9769892662482513",
      "vi": "0.9667514591489511"
    },
    "canonical_solution": "{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}",
    "instruction": {
      "es": "Escribe una función en C# `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` para resolver el siguiente problema:\nCalcula el número de manzanas enteras que quedan después de comer manzanas durante un tiempo determinado.\n   Cada manzana toma una cantidad específica de tiempo para comer, y la función devuelve cuántas manzanas enteras quedan sin comer.\n   - totalApples: el número total de manzanas disponibles\n   - timePerApple: el tiempo que se tarda en comer una manzana (timePerApple>=0)\n   - timeElapsed: el tiempo total transcurrido\n\n   Ejemplos:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "arb": "اكتب دالة C# `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` لحل المشكلة التالية:\nتحسب عدد التفاح الكامل المتبقي بعد تناول التفاح لوقت معين.\n   كل تفاحة تستغرق وقتًا محددًا لتناولها، وتعيد الدالة عدد التفاح الكامل المتبقي الذي لم يؤكل.\n   - totalApples: العدد الإجمالي للتفاح المتاح\n   - timePerApple: الوقت الذي يستغرقه تناول تفاحة واحدة (timePerApple>=0)\n   - timeElapsed: إجمالي الوقت المنقضي\n\n   أمثلة:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "sw": "Andika kazi ya C# `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` kutatua tatizo lifuatalo:\nHesabu idadi ya tufaha nzima zilizobaki baada ya kula tufaha kwa muda fulani.\n   Kila tufaha inachukua muda maalum kuliwa, na kazi inarudisha ni tufaha ngapi nzima zimebaki bila kuliwa.\n   - totalApples: jumla ya idadi ya tufaha zinazopatikana\n   - timePerApple: muda unaochukua kula tufaha moja (timePerApple>=0)\n   - timeElapsed: muda wote uliopita\n\n   Mifano:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "tr": "Bir C# fonksiyonu `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` yazın ve aşağıdaki problemi çözün:\nBelirli bir süre boyunca elma yedikten sonra kalan bütün elmaların sayısını hesaplar.\n   Her bir elmayı yemek belirli bir zaman alır ve fonksiyon, yenmemiş kaç bütün elma kaldığını döndürür.\n   - totalApples: mevcut toplam elma sayısı\n   - timePerApple: bir elmayı yemek için geçen süre (timePerApple>=0)\n   - timeElapsed: geçen toplam süre\n\n   Örnekler:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "vi": "Viết một hàm C# `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` để giải quyết vấn đề sau:\nTính toán số lượng táo nguyên còn lại sau khi ăn táo trong một khoảng thời gian nhất định.\n   Mỗi quả táo cần một khoảng thời gian cụ thể để ăn, và hàm trả về số lượng táo nguyên còn lại chưa ăn.\n   - totalApples: tổng số lượng táo có sẵn\n   - timePerApple: thời gian cần để ăn một quả táo (timePerApple>=0)\n   - timeElapsed: tổng thời gian đã trôi qua\n\n   Ví dụ:\n   >>> RemainingApples(50, 10, 200)\n   30"
    },
    "instruction_bertscore": {
      "es": "0.9938144513041925",
      "arb": "0.9723409180712729",
      "sw": "0.9898976588205656",
      "tr": "0.9784716447819147",
      "vi": "0.9691050305338335"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n        Debug.Assert(RemainingApples(50, 10, 200) == 30);\n        Debug.Assert(RemainingApples(10, 2, 5) == 7);\n        Debug.Assert(RemainingApples(5, 15, 10) == 4);\n        Debug.Assert(RemainingApples(20, 0, 100) == 0); // Case to test division by zero handling\n        Debug.Assert(RemainingApples(3, 10, 130) == 0); // Case where all apples are eaten\n\n    }\n}",
    "entry_point": "RemainingApples",
    "signature": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
    "docstring": {
      "es": "Calcula el número de manzanas enteras que quedan después de comer manzanas durante un tiempo determinado.\n   Cada manzana toma una cantidad específica de tiempo para comer, y la función devuelve cuántas manzanas enteras quedan sin comer.\n   - totalApples: el número total de manzanas disponibles\n   - timePerApple: el tiempo que se tarda en comer una manzana (timePerApple>=0)\n   - timeElapsed: el tiempo total transcurrido\n\n   Ejemplos:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "arb": "يحسب عدد التفاح الكامل المتبقي بعد تناول التفاح لفترة زمنية معينة. \n   كل تفاحة تستغرق وقتًا محددًا لتناولها، وتعيد الدالة عدد التفاح الكامل المتبقي غير المأكول.\n   - totalApples: العدد الإجمالي للتفاح المتاح\n   - timePerApple: الوقت الذي يستغرقه تناول تفاحة واحدة (timePerApple>=0)\n   - timeElapsed: إجمالي الوقت المنقضي\n\n   أمثلة:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "sw": "Hesabu idadi ya tufaha nzima zilizobaki baada ya kula tufaha kwa muda fulani.\n   Kila tufaha inachukua muda maalum kuliwa, na kazi hii inarudisha idadi ya tufaha nzima zilizobaki bila kuliwa.\n   - totalApples: jumla ya idadi ya tufaha zinazopatikana\n   - timePerApple: muda unaochukua kula tufaha moja (timePerApple>=0)\n   - timeElapsed: jumla ya muda uliopita\n\n   Mifano:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "tr": "Belli bir süre boyunca elma yedikten sonra kalan bütün elmaların sayısını hesaplar.\n   Her elmayı yemek belirli bir zaman alır ve fonksiyon yenmemiş kaç bütün elma kaldığını döndürür.\n   - totalApples: mevcut toplam elma sayısı\n   - timePerApple: bir elmayı yemek için geçen süre (timePerApple>=0)\n   - timeElapsed: geçen toplam süre\n\n   Örnekler:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "vi": "Tính toán số lượng táo nguyên còn lại sau khi ăn táo trong một khoảng thời gian nhất định.  \nMỗi quả táo mất một khoảng thời gian cụ thể để ăn, và hàm trả về số lượng táo nguyên còn lại chưa ăn.  \n- totalApples: tổng số lượng táo có sẵn  \n- timePerApple: thời gian cần để ăn một quả táo (timePerApple>=0)  \n- timeElapsed: tổng thời gian đã trôi qua  \n\nVí dụ:  \n>>> RemainingApples(50, 10, 200)  \n30"
    },
    "docstring_bertscore": {
      "es": "0.9818275050694991",
      "arb": "0.9757954976582316",
      "sw": "0.9517352009730946",
      "tr": "0.9619509601001",
      "vi": "0.9490793141482771"
    }
  },
  {
    "task_id": "C#/49",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Encuentra el ID faltante (roto) y el duplicado de una serie de secuencias de ID.\n    Se supone que los IDs son continuos, pero debido a un error, falta un ID y uno está duplicado.\n    La función devuelve una tupla con el primer elemento siendo el ID faltante y el segundo el ID duplicado.\n\n    Args:\n    ids: Una lista de listas, cada sublista contiene una serie de IDs de tickets.\n\n    Returns:\n    Una tupla de dos enteros: el primero es el ID faltante (m) y el segundo es el ID duplicado (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    يجد المعرف المفقود (المعطل) والمكرر من سلسلة من تسلسلات المعرفات.\n    من المفترض أن تكون المعرفات متسلسلة بشكل مستمر ولكن بسبب خطأ، يوجد معرف مفقود وآخر مكرر.\n    تُرجع الدالة زوجاً حيث العنصر الأول هو المعرف المفقود والعنصر الثاني هو المعرف المكرر.\n\n    الوسائط:\n    ids: قائمة من القوائم، تحتوي كل قائمة فرعية على سلسلة من معرفات التذاكر.\n\n    الإرجاع:\n    زوج من الأعداد الصحيحة: الأول هو المعرف المفقود (m) والثاني هو المعرف المكرر (n).\n\n    أمثلة:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Inapata kitambulisho kilichopotea (kilichovunjika) na kilichorudiwa kutoka kwa mfuatano wa vitambulisho.\n    Vitambulisho vinatakiwa kuwa vinaendelea lakini kutokana na hitilafu, kitambulisho kimoja kinakosekana na kingine kinarudiwa.\n    Kazi inarudisha jozi na kipengele cha kwanza kikiwa kitambulisho kilichopotea na cha pili kitambulisho kilichorudiwa.\n\n    Args:\n    ids: Orodha ya orodha, kila orodha ndogo ina mfuatano wa vitambulisho vya tiketi.\n\n    Returns:\n    Jozi ya namba mbili: ya kwanza ni kitambulisho kilichopotea (m) na ya pili ni kitambulisho kilichorudiwa (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Bir dizi kimlik dizisinden eksik (bozuk) ve yinelenen kimliği bulur.\n    Kimliklerin sürekli olması gerekir ancak bir hata nedeniyle bir kimlik eksik ve biri yinelenmiştir.\n    Fonksiyon, ilk elemanı eksik kimlik ve ikinci elemanı yinelenen kimlik olan bir ikili döndürür.\n\n    Argümanlar:\n    ids: Her alt liste bir dizi bilet kimliği içeren listelerin bir listesi.\n\n    Döndürür:\n    İki tamsayıdan oluşan bir ikili: ilki eksik kimlik (m) ve ikincisi yinelenen kimlik (n).\n\n    Örnekler:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Tìm ID bị thiếu (bị hỏng) và ID bị trùng lặp từ một loạt các chuỗi ID.\n    Các ID được cho là liên tục nhưng do lỗi, một ID bị thiếu và một ID bị trùng lặp.\n    Hàm trả về một tuple với phần tử đầu tiên là ID bị thiếu và phần tử thứ hai là ID bị trùng lặp.\n\n    Tham số:\n    ids: Một danh sách các danh sách, mỗi danh sách con chứa một chuỗi các ID vé.\n\n    Trả về:\n    Một tuple của hai số nguyên: số đầu tiên là ID bị thiếu (m) và số thứ hai là ID bị trùng lặp (n).\n\n    Ví dụ:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)"
    },
    "prompt_bertscore": {
      "es": "0.9843898369848492",
      "arb": "0.9625967074688443",
      "sw": "0.9676443027117029",
      "tr": "0.975142996856532",
      "vi": "0.962572077301596"
    },
    "canonical_solution": "    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static (int, int) FindErrorIds(List<List<int>> ids)` para resolver el siguiente problema:\nEncuentra el ID faltante (roto) y el duplicado de una serie de secuencias de ID.\n    Se supone que los IDs son continuos, pero debido a un error, falta un ID y uno está duplicado.\n    La función devuelve una tupla con el primer elemento siendo el ID faltante y el segundo el ID duplicado.\n\n    Args:\n    ids: Una lista de listas, cada sublista contiene una serie de IDs de tickets.\n\n    Returns:\n    Una tupla de dos enteros: el primero es el ID faltante (m) y el segundo es el ID duplicado (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "arb": "اكتب دالة C# `static (int, int) FindErrorIds(List<List<int>> ids)` لحل المشكلة التالية:\nتجد المعرف المفقود (المعطل) والمكرر من سلسلة من تسلسلات المعرفات.\n    من المفترض أن تكون المعرفات متتالية ولكن بسبب خطأ، يوجد معرف مفقود وآخر مكرر.\n    تعيد الدالة زوجًا مع العنصر الأول هو المعرف المفقود والعنصر الثاني هو المعرف المكرر.\n\n    Args:\n    ids: قائمة من القوائم، تحتوي كل قائمة فرعية على سلسلة من معرفات التذاكر.\n\n    Returns:\n    زوج من عددين صحيحين: الأول هو المعرف المفقود (m) والثاني هو المعرف المكرر (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "sw": "Andika kazi ya C# `static (int, int) FindErrorIds(List<List<int>> ids)` kutatua tatizo lifuatalo:\nInapata ID iliyopotea (iliyovunjika) na ID iliyojirudia kutoka kwenye mfululizo wa mlolongo wa ID.\n    ID zinatakiwa kuwa endelevu lakini kutokana na hitilafu, ID moja imepotea na moja imejirudia.\n    Kazi inarudisha jozi yenye kipengele cha kwanza kuwa ID iliyopotea na cha pili kuwa ID iliyojirudia.\n\n    Args:\n    ids: Orodha ya orodha, kila orodha ndogo ina mlolongo wa ID za tiketi.\n\n    Returns:\n    Jozi ya namba mbili: ya kwanza ni ID iliyopotea (m) na ya pili ni ID iliyojirudia (n).\n\n    Mfano:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "tr": "Bir C# fonksiyonu `static (int, int) FindErrorIds(List<List<int>> ids)` yazarak aşağıdaki problemi çözün:\nBir dizi kimlik dizisinden eksik (bozuk) ve yinelenen kimliği bulur.\n    Kimliklerin sürekli olması gerekir, ancak bir hata nedeniyle bir kimlik eksik ve biri yinelenmiştir.\n    Fonksiyon, ilk elemanı eksik kimlik ve ikinci elemanı yinelenen kimlik olan bir demet döndürür.\n\n    Argümanlar:\n    ids: Her alt liste bir dizi bilet kimliği içeren listelerin bir listesi.\n\n    Döndürülenler:\n    İki tam sayıdan oluşan bir demet: ilki eksik kimlik (m) ve ikincisi yinelenen kimlik (n).\n\n    Örnekler:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "vi": "Viết một hàm C# `static (int, int) FindErrorIds(List<List<int>> ids)` để giải quyết vấn đề sau:\nTìm ID bị thiếu (bị hỏng) và ID bị trùng lặp từ một loạt các chuỗi ID.\n    Các ID được cho là liên tục nhưng do lỗi, một ID bị thiếu và một ID bị trùng lặp.\n    Hàm trả về một tuple với phần tử đầu tiên là ID bị thiếu và phần tử thứ hai là ID bị trùng lặp.\n\n    Tham số:\n    ids: Một danh sách các danh sách, mỗi danh sách con chứa một chuỗi các ID vé.\n\n    Trả về:\n    Một tuple của hai số nguyên: số đầu tiên là ID bị thiếu (m) và số thứ hai là ID bị trùng lặp (n).\n\n    Ví dụ:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)"
    },
    "instruction_bertscore": {
      "es": "0.9804797979341774",
      "arb": "0.9753815519441549",
      "sw": "0.9699273603113179",
      "tr": "0.9669767060010447",
      "vi": "0.969449256984167"
    },
    "level": "middle",
    "test": "static void Main()\n    {\n\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} }) == (7, 9));\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4, 6}, new List<int> {3, 3} }) == (5, 3));\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> { 110, 112, 108 }, new List<int> { 107, 109, 108 } }) == (111, 108));\n\n    }\n}",
    "entry_point": "FindErrorIds",
    "signature": "static (int, int) FindErrorIds(List<List<int>> ids)",
    "docstring": {
      "es": "Encuentra el ID faltante (roto) y duplicado de una serie de secuencias de ID.\n    Se supone que los IDs son continuos, pero debido a un error, falta un ID y uno está duplicado.\n    La función devuelve una tupla con el primer elemento siendo el ID faltante y el segundo el ID duplicado.\n\n    Args:\n    ids: Una lista de listas, cada sublista contiene una serie de IDs de boletos.\n\n    Returns:\n    Una tupla de dos enteros: el primero es el ID faltante (m) y el segundo es el ID duplicado (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "arb": "يجد المعرف المفقود (المعطوب) والمكرر من سلسلة من تسلسلات المعرفات.\n    من المفترض أن تكون المعرفات متتابعة ولكن بسبب خطأ، هناك معرف مفقود وآخر مكرر.\n    تُرجع الدالة زوجًا، العنصر الأول هو المعرف المفقود والعنصر الثاني هو المعرف المكرر.\n\n    Args:\n    ids: قائمة من القوائم، تحتوي كل قائمة فرعية على سلسلة من معرفات التذاكر.\n\n    Returns:\n    زوج من عددين صحيحين: الأول هو المعرف المفقود (m) والثاني هو المعرف المكرر (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "sw": "Inapata ID iliyokosekana (iliyovunjika) na ID iliyozidishwa kutoka kwa mfululizo wa misururu ya ID.\n    ID zinatakiwa kuwa endelevu lakini kutokana na hitilafu, ID moja imekosekana na moja imezidishwa.\n    Kazi inarudisha jozi yenye kipengele cha kwanza kuwa ID iliyokosekana na cha pili kuwa ID iliyozidishwa.\n\n    Args:\n    ids: Orodha ya orodha, kila orodha ndogo ina mfululizo wa ID za tiketi.\n\n    Returns:\n    Jozi ya nambari mbili: ya kwanza ni ID iliyokosekana (m) na ya pili ni ID iliyozidishwa (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "tr": "Eksik (bozuk) ve yinelenen kimliği bir dizi kimlik dizisinden bulur.\n    Kimliklerin kesintisiz olması gerekir, ancak bir hata nedeniyle bir kimlik eksik ve biri yinelenmiştir.\n    Fonksiyon, ilk elemanı eksik kimlik ve ikinci elemanı yinelenen kimlik olan bir demet döndürür.\n\n    Args:\n    ids: Her alt liste bir dizi bilet kimliği içeren listelerin bir listesi.\n\n    Returns:\n    İki tam sayıdan oluşan bir demet: ilki eksik kimlik (m) ve ikincisi yinelenen kimlik (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "vi": "Tìm ID bị thiếu (bị hỏng) và ID bị trùng lặp từ một chuỗi các dãy ID.\n    Các ID được cho là liên tục nhưng do lỗi, một ID bị thiếu và một ID bị trùng lặp.\n    Hàm trả về một bộ giá trị với phần tử đầu tiên là ID bị thiếu và phần tử thứ hai là ID bị trùng lặp.\n\n    Tham số:\n    ids: Một danh sách các danh sách, mỗi danh sách con chứa một chuỗi các ID vé.\n\n    Trả về:\n    Một bộ gồm hai số nguyên: số đầu tiên là ID bị thiếu (m) và số thứ hai là ID bị trùng lặp (n).\n\n    Ví dụ:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)"
    },
    "docstring_bertscore": {
      "es": "0.9934902865223436",
      "arb": "0.9499836782731289",
      "sw": "0.9715521568281833",
      "tr": "0.9657827387806439",
      "vi": "0.9533200727833719"
    }
  },
  {
    "task_id": "C#/50",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Cuenta el número de caracteres numéricos, minúsculas y mayúsculas en una cadena dada de longitud 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* يحسب عدد الأحرف الرقمية، والأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika mfuatano wa herufi uliotolewa wa urefu wa 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Verilen 8 uzunluğundaki bir stringdeki rakam, küçük harf ve büyük harf karakterlerinin sayısını sayar.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Đếm số lượng ký tự chữ số, chữ thường và chữ hoa trong một chuỗi có độ dài 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)"
    },
    "prompt_bertscore": {
      "es": "0.9818203543757819",
      "arb": "0.9583553529426064",
      "sw": "0.9678073782545326",
      "tr": "1",
      "vi": "0.9765761150556987"
    },
    "canonical_solution": "    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }",
    "instruction": {
      "es": "Escribe una función en C# `static (int, int, int) CountCharacters(string s)` para resolver el siguiente problema:\nCuenta el número de caracteres dígitos, minúsculas y mayúsculas en una cadena dada de longitud 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "arb": "اكتب دالة C# `static (int, int, int) CountCharacters(string s)` لحل المشكلة التالية:\nتحسب عدد الأحرف الرقمية، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "sw": "Andika kazi ya C# `static (int, int, int) CountCharacters(string s)` kutatua tatizo lifuatalo:  \nHesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba iliyo na urefu wa 8.  \n        >>> CountCharacters(\"1n2s0e1s\")  \n        (4, 4, 0)",
      "tr": "C# dilinde `static (int, int, int) CountCharacters(string s)` fonksiyonunu aşağıdaki problemi çözmek için yazın:\nVerilen 8 uzunluğundaki bir stringdeki rakam, küçük harf ve büyük harf karakterlerinin sayısını sayar.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "vi": "Viết một hàm C# `static (int, int, int) CountCharacters(string s)` để giải quyết vấn đề sau:  \nĐếm số lượng ký tự chữ số, chữ thường, và chữ hoa trong một chuỗi có độ dài 8.  \n        >>> CountCharacters(\"1n2s0e1s\")  \n        (4, 4, 0)"
    },
    "instruction_bertscore": {
      "es": "0.9834797125789473",
      "arb": "0.9687470985872086",
      "sw": "0.9716449172161266",
      "tr": "0.9824327318405124",
      "vi": "0.9749004691612885"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountCharacters(\"yLAX2022\") == (4, 1, 3));\n        Debug.Assert(CountCharacters(\"MBKKOKOK\") == (0, 0, 8));\n        Debug.Assert(CountCharacters(\"1n2s0e1s\") == (4, 4, 0));\n        Debug.Assert(CountCharacters(\"1234ABCD\") == (4, 0, 4));\n\n\n    }\n}",
    "entry_point": "CountCharacters",
    "signature": "static (int, int, int) CountCharacters(string s)",
    "docstring": {
      "es": "Cuenta el número de caracteres numéricos, minúsculas y mayúsculas en una cadena dada de longitud 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "arb": "يحسب عدد الأحرف الرقمية، والأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "sw": "Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika mfuatano wa herufi uliotolewa wa urefu wa 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "tr": "Verilen 8 uzunluğundaki bir dizgede rakam, küçük harf ve büyük harf karakterlerinin sayısını sayar.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "vi": "Đếm số lượng ký tự chữ số, chữ thường và chữ hoa trong một chuỗi có độ dài 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)"
    },
    "docstring_bertscore": {
      "es": "0.9691145647921232",
      "arb": "0.9495506640424729",
      "sw": "0.9513091388057747",
      "tr": "1",
      "vi": "0.9518309408167535"
    }
  }
]