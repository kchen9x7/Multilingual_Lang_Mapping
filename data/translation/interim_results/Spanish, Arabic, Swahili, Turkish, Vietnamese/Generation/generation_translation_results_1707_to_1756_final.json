[
  {
    "task_id": "Shell/1",
    "prompt": {
      "en": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Check if in given list of numbers, are any two numbers closer to each other than\n#given threshold.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "es": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Verificar si en la lista dada de números, hay dos números más cercanos entre sí que\n#el umbral dado.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "arb": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n# تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "sw": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Angalia kama katika orodha iliyotolewa ya namba, kuna namba mbili zozote zinazokaribiana zaidi kuliko kizingiti kilichotolewa.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "tr": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n# Verilen sayı listesinde, herhangi iki sayı birbirine verilen eşikten daha yakın mı kontrol et.\n# >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n# False\n# >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# True",
      "vi": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn\n#ngưỡng đã cho không.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True"
    },
    "prompt_bertscore": {
      "es": "0.9814302443074293",
      "arb": "0.9847157894401274",
      "sw": "0.9727495007650616",
      "tr": "0.9617777544078375",
      "vi": "0.9729614393816258"
    },
    "canonical_solution": "local n=${#numbers[@]}\n\nfor (( i=0; i<$n; i++ )); do\nfor (( j=0; j<$n; j++ )); do\nif [[ $i -ne $j ]]; then\nlocal diff=$(echo \"${numbers[$i]} - ${numbers[$j]}\" | bc)\ndiff=$(echo \"$diff\" | tr -d -) # Absolute value\n\nlocal result=$(echo \"$diff < $threshold\" | bc)\nif [[ $result -eq 1 ]]; then\necho \"true\"\nreturn 0\nfi\nfi\ndone\ndone\n\necho \"false\"\n}",
    "instruction": {
      "en": "Write a Shell function `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "es": "Escribe una función Shell `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` para resolver el siguiente problema:\nVerifica si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "arb": "اكتب دالة شل `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` لحل المشكلة التالية:\nتحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sw": "Andika kazi ya Shell `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` kutatua tatizo lifuatalo:\nAngalia kama katika orodha iliyotolewa ya nambari, kuna nambari mbili zozote zilizo karibu zaidi kuliko\nkizingiti kilichopewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "tr": "Bir Shell fonksiyonu yazın `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` aşağıdaki problemi çözmek için:\nVerilen sayı listesindeki herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "vi": "Viết một hàm Shell `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` để giải quyết vấn đề sau:\nKiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho không.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "instruction_bertscore": {
      "es": "0.982851246053353",
      "arb": "0.984946796573271",
      "sw": "0.974966613078173",
      "tr": "0.9253862850376736",
      "vi": "0.9821995397731774"
    },
    "level": "easy",
    "test": "# Testing function\ntest_close_elements() {\n[[ $(has_close_elements \"1.0 2.0 3.9 4.0 5.0 2.2\" 0.3) == \"true\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 3.9 4.0 5.0 2.2\" 0.05) == \"false\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 5.9 4.0 5.0\" 0.95) == \"true\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 5.9 4.0 5.0\" 0.8) == \"false\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 3.0 4.0 5.0 2.0\" 0.1) == \"true\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(has_close_elements \"1.1 2.2 3.1 4.1 5.1\" 1.0) == \"true\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(has_close_elements \"1.1 2.2 3.1 4.1 5.1\" 0.5) == \"false\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_close_elements",
    "entry_point": "has_close_elements",
    "signature": "has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n",
    "docstring": {
      "en": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "es": "Verificar si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "arb": "التحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما من العتبة المعطاة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sw": "Angalia kama katika orodha iliyotolewa ya namba, kuna namba mbili zozote zilizo karibu zaidi kuliko kizingiti kilichotolewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, belirtilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "vi": "Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho không."
    },
    "docstring_bertscore": {
      "es": "0.9730839943267243",
      "arb": "0.9793702486257165",
      "sw": "0.9606733694892835",
      "tr": "0.9550809311112463",
      "vi": "0.6683188459023213"
    }
  },
  {
    "task_id": "Shell/2",
    "prompt": {
      "en": "#!/bin/bash\n\n# Function to find the third largest number in an array. If the third largest number does not exist, returns the largest number.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "es": "#!/bin/bash\n\n# Función para encontrar el tercer número más grande en un arreglo. Si el tercer número más grande no existe, devuelve el número más grande.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "arb": "#!/bin/bash\n\n# دالة لإيجاد ثالث أكبر رقم في مصفوفة. إذا لم يكن هناك ثالث أكبر رقم، تعيد الدالة أكبر رقم.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "sw": "#!/bin/bash\n\n# Kazi ya kupata nambari ya tatu kwa ukubwa katika safu. Ikiwa nambari ya tatu kwa ukubwa haipo, inarudisha nambari kubwa zaidi.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "tr": "#!/bin/bash\n\n# Bir dizideki üçüncü en büyük sayıyı bulmak için fonksiyon. Eğer üçüncü en büyük sayı yoksa, en büyük sayıyı döndürür.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "vi": "#!/bin/bash\n\n# Hàm để tìm số lớn thứ ba trong một mảng. Nếu số lớn thứ ba không tồn tại, trả về số lớn nhất.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)"
    },
    "prompt_bertscore": {
      "es": "0.9954048847651389",
      "arb": "0.9734208714529595",
      "sw": "0.9886969381672097",
      "tr": "0.9845096111046132",
      "vi": "0.9985917105984626"
    },
    "canonical_solution": "local n=${#numbers[@]}\nlocal first=-INF second=-INF third=-INF\n\nfor num in ${numbers[@]}; do\nif (( num > first )); then\nthird=$second\nsecond=$first\nfirst=$num\nelif (( num > second && num != first )); then\nthird=$second\nsecond=$num\nelif (( num > third && num != second && num != first )); then\nthird=$num\nfi\ndone\n\nif [[ $third == -INF ]]; then\necho $first\nelse\necho $third\nfi\n}",
    "instruction": {
      "en": "Write a Shell function `third_largest_number() {\nlocal numbers=($1)` to solve the following problem:\n\nFunction to find the third largest number in an array. If the third largest number does not exist, returns the largest number.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1\n",
      "es": "Escribe una función de Shell `third_largest_number() {\nlocal numbers=($1)` para resolver el siguiente problema:\n\nFunción para encontrar el tercer número más grande en un arreglo. Si el tercer número más grande no existe, devuelve el número más grande.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "arb": "اكتب دالة Shell `third_largest_number() { local numbers=($1)` لحل المشكلة التالية:\n\nدالة لإيجاد ثالث أكبر عدد في مصفوفة. إذا لم يكن هناك ثالث أكبر عدد، تعيد الدالة أكبر عدد.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "sw": "Andika kazi ya Shell `third_largest_number() {\nlocal numbers=($1)` kutatua tatizo lifuatalo:\n\nKazi ya kupata nambari ya tatu kwa ukubwa katika safu. Ikiwa nambari ya tatu kwa ukubwa haipo, inarudisha nambari kubwa zaidi.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "tr": "Bir Shell fonksiyonu `third_largest_number() { local numbers=($1)` yazın:\n\nBir dizideki üçüncü en büyük sayıyı bulma fonksiyonu. Üçüncü en büyük sayı yoksa, en büyük sayıyı döndürür.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1\n",
      "vi": "Viết một hàm Shell `third_largest_number() {\nlocal numbers=($1)` để giải quyết vấn đề sau:\n\nHàm để tìm số lớn thứ ba trong một mảng. Nếu số lớn thứ ba không tồn tại, trả về số lớn nhất.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1\n"
    },
    "instruction_bertscore": {
      "es": "0.9986125667884713",
      "arb": "0.9742451875342544",
      "sw": "0.9879451221749926",
      "tr": "0.9523590989999252",
      "vi": "0.9986125667884713"
    },
    "level": "middle",
    "test": "test_third_largest_number() {\n[[ $(third_largest_number \"4 5 1 3 2\") == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(third_largest_number \"10 5 1\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(third_largest_number \"7 7 7 7\") == \"7\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(third_largest_number \"9 8 7 6 5\") == \"7\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(third_largest_number \"1 2\") == \"2\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(third_largest_number \"3 3 3 2 1\") == \"1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(third_largest_number \"1\") == \"1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_third_largest_number",
    "entry_point": "third_largest_number",
    "signature": "third_largest_number() {\nlocal numbers=($1)",
    "docstring": {
      "en": "\nFunction to find the third largest number in an array. If the third largest number does not exist, returns the largest number.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1\n",
      "es": "Función para encontrar el tercer número más grande en un array. Si el tercer número más grande no existe, devuelve el número más grande.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "arb": "دالة للعثور على ثالث أكبر رقم في مصفوفة. إذا لم يكن هناك ثالث أكبر رقم، تعيد الدالة أكبر رقم.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "sw": "Kazi ya kupata nambari ya tatu kwa ukubwa katika safu. Ikiwa nambari ya tatu kwa ukubwa haipo, inarudisha nambari kubwa zaidi.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "tr": "Üçüncü en büyük sayıyı bir dizide bulmak için fonksiyon. Üçüncü en büyük sayı mevcut değilse, en büyük sayıyı döndürür.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "vi": "Hàm để tìm số lớn thứ ba trong một mảng. Nếu số lớn thứ ba không tồn tại, trả về số lớn nhất.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1"
    },
    "docstring_bertscore": {
      "es": "0.9979241138878043",
      "arb": "0.9528439557600313",
      "sw": "0.9914495579875912",
      "tr": "0.9915675444339259",
      "vi": "0.9979241138878043"
    }
  },
  {
    "task_id": "Shell/3",
    "prompt": {
      "en": "#!/bin/bash\n\n# Calculate taxes based on a progressive tax bracket system.\n# The function takes two arguments:\n# 1. A string representing the tax brackets in the format \"upper0 percent0 upper1 percent1 ...\"\n# 2. An integer representing the total income.\n# It returns the total tax amount.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "es": "#!/bin/bash\n\n# Calcular impuestos basados en un sistema de tramos impositivos progresivos.\n# La función toma dos argumentos:\n# 1. Una cadena que representa los tramos impositivos en el formato \"upper0 percent0 upper1 percent1 ...\"\n# 2. Un entero que representa el ingreso total.\n# Devuelve el monto total de impuestos.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "arb": "#!/bin/bash\n\n# حساب الضرائب بناءً على نظام الشرائح الضريبية التصاعدي.\n# تأخذ الدالة وسيطين:\n# 1. سلسلة تمثل الشرائح الضريبية بالصيغة \"الحد الأعلى0 النسبة0 الحد الأعلى1 النسبة1 ...\"\n# 2. عدد صحيح يمثل إجمالي الدخل.\n# تُرجع المبلغ الإجمالي للضريبة.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "sw": "#!/bin/bash\n\n# Hesabu kodi kulingana na mfumo wa viwango vya kodi vinavyoongezeka.\n# Kazi inachukua hoja mbili:\n# 1. Mfuatano wa herufi unaowakilisha viwango vya kodi katika muundo \"upper0 percent0 upper1 percent1 ...\"\n# 2. Nambari kamili inayowakilisha jumla ya mapato.\n# Inarudisha kiasi cha jumla ya kodi.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "tr": "#!/bin/bash\n\n# Kademeli vergi dilimi sistemine göre vergileri hesapla.\n# Fonksiyon iki argüman alır:\n# 1. \"üst0 yüzde0 üst1 yüzde1 ...\" formatında vergi dilimlerini temsil eden bir string\n# 2. Toplam geliri temsil eden bir tamsayı.\n# Toplam vergi miktarını döndürür.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "vi": "#!/bin/bash\n\n# Tính thuế dựa trên hệ thống thuế lũy tiến.\n# Hàm nhận hai tham số:\n# 1. Một chuỗi đại diện cho các khung thuế theo định dạng \"upper0 percent0 upper1 percent1 ...\"\n# 2. Một số nguyên đại diện cho tổng thu nhập.\n# Hàm trả về tổng số tiền thuế.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2"
    },
    "prompt_bertscore": {
      "es": "0.9921666136631271",
      "arb": "0.9575783108919979",
      "sw": "0.9890703632835552",
      "tr": "0.9913812291365152",
      "vi": "0.9926034018710228"
    },
    "canonical_solution": "local tax=0\nlocal prev_upper=0\n\nfor (( i=0; i<${#brackets[@]}; i+=2 )); do\nlocal upper=${brackets[i]}\nlocal percent=${brackets[i+1]}\n\nif (( income <= upper )); then\ntax=$(echo \"$tax + (($income - $prev_upper) * $percent / 100)\" | bc)\necho $tax\nreturn\nelse\ntax=$(echo \"$tax + (($upper - $prev_upper) * $percent / 100)\" | bc)\nprev_upper=$upper\nfi\ndone\n\necho $tax\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` to solve the following problem:\n\nCalculate taxes based on a progressive tax bracket system.\nThe function takes two arguments:\n1. A string representing the tax brackets in the format \"upper0 percent0 upper1 percent1 ...\"\n2. An integer representing the total income.\nIt returns the total tax amount.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000\n",
      "es": "Escribe una función Shell `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` para resolver el siguiente problema:\n\nCalcular impuestos basados en un sistema de tramos impositivos progresivos.\nLa función toma dos argumentos:\n1. Una cadena que representa los tramos impositivos en el formato \"upper0 percent0 upper1 percent1 ...\"\n2. Un entero que representa el ingreso total.\nDevuelve la cantidad total de impuestos.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000\n",
      "arb": "اكتب دالة شل `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` لحل المشكلة التالية:\n\nحساب الضرائب بناءً على نظام شرائح ضريبية تصاعدي.\nتأخذ الدالة وسيطين:\n1. سلسلة تمثل الشرائح الضريبية بالصيغة \"upper0 percent0 upper1 percent1 ...\"\n2. عدد صحيح يمثل إجمالي الدخل.\nتعيد المبلغ الإجمالي للضريبة.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "sw": "Andika kazi ya Shell `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` kutatua tatizo lifuatalo:\n\nHesabu kodi kulingana na mfumo wa viwango vya kodi vinavyoongezeka.\nKazi inachukua hoja mbili:\n1. Kamba inayowakilisha viwango vya kodi katika muundo \"upper0 percent0 upper1 percent1 ...\"\n2. Nambari ya mzima inayowakilisha jumla ya kipato.\nInarudisha kiasi cha jumla ya kodi.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "tr": "Bir Shell fonksiyonu yazın `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` aşağıdaki problemi çözmek için:\n\nKademeli bir vergi dilimi sistemine dayalı olarak vergileri hesaplayın.\nFonksiyon iki argüman alır:\n1. \"upper0 percent0 upper1 percent1 ...\" formatında vergi dilimlerini temsil eden bir string\n2. Toplam geliri temsil eden bir tamsayı.\nToplam vergi miktarını döndürür.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "vi": "Viết một hàm Shell `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` để giải quyết vấn đề sau:\n\nTính thuế dựa trên hệ thống thuế lũy tiến.\nHàm nhận hai tham số:\n1. Một chuỗi đại diện cho các khung thuế theo định dạng \"upper0 percent0 upper1 percent1 ...\"\n2. Một số nguyên đại diện cho tổng thu nhập.\nHàm trả về tổng số tiền thuế.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000"
    },
    "instruction_bertscore": {
      "es": "0.9944379520702611",
      "arb": "0.9858455990474538",
      "sw": "0.9987825943946371",
      "tr": "0.9889585343790326",
      "vi": "0.9833796028669057"
    },
    "level": "easy",
    "test": "# Testing function\ntest_calculate_tax() {\n[[ $(calculate_tax \"10000 10 20000 20 30000 30\" 25000) == \"4500\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_tax \"10000 10 20000 20 30000 30\" 15000) == \"2000\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_tax \"5000 5 10000 10 20000 20\" 12000) == \"1150\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_tax \"5000 5 10000 10 20000 20\" 5000) == \"250\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_tax \"10000 10 20000 20\" 0) == \"0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_tax",
    "entry_point": "calculate_tax",
    "signature": "calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
    "docstring": {
      "en": "\nCalculate taxes based on a progressive tax bracket system.\nThe function takes two arguments:\n1. A string representing the tax brackets in the format \"upper0 percent0 upper1 percent1 ...\"\n2. An integer representing the total income.\nIt returns the total tax amount.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000\n",
      "es": "Calcular impuestos basados en un sistema de tramos fiscales progresivos.  \nLa función toma dos argumentos:  \n1. Una cadena que representa los tramos fiscales en el formato \"upper0 percent0 upper1 percent1 ...\"  \n2. Un entero que representa el ingreso total.  \nDevuelve el monto total de impuestos.  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000  \n4500  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000  \n2000  ",
      "arb": "احسب الضرائب بناءً على نظام شرائح ضريبية تصاعدي.  \nتأخذ الدالة وسيطين:  \n1. سلسلة نصية تمثل الشرائح الضريبية بالتنسيق \"الحد الأعلى0 النسبة0 الحد الأعلى1 النسبة1 ...\"  \n2. عدد صحيح يمثل إجمالي الدخل.  \nتعيد المبلغ الإجمالي للضريبة.  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000  \n4500  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000  \n2000  ",
      "sw": "Hesabu kodi kulingana na mfumo wa viwango vya kodi vinavyoongezeka.\nKazi inachukua hoja mbili:\n1. Kamba inayowakilisha viwango vya kodi katika muundo \"upper0 percent0 upper1 percent1 ...\"\n2. Nambari nzima inayowakilisha jumla ya mapato.\nInarudisha kiasi cha jumla cha kodi.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "tr": "Progressif vergi dilimi sistemine dayalı olarak vergileri hesaplayın.\nFonksiyon iki argüman alır:\n1. \"üst0 yüzde0 üst1 yüzde1 ...\" formatında vergi dilimlerini temsil eden bir dize\n2. Toplam geliri temsil eden bir tamsayı.\nToplam vergi miktarını döndürür.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "vi": "Tính thuế dựa trên hệ thống thuế lũy tiến.  \nHàm nhận hai đối số:  \n1. Một chuỗi đại diện cho các khung thuế theo định dạng \"upper0 percent0 upper1 percent1 ...\"  \n2. Một số nguyên đại diện cho tổng thu nhập.  \nHàm trả về tổng số tiền thuế.  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000  \n4500  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000  \n2000  "
    },
    "docstring_bertscore": {
      "es": "0.9922385178610618",
      "arb": "0.940532844743489",
      "sw": "0.9764573340878399",
      "tr": "0.9584425516798807",
      "vi": "0.9919844696037181"
    }
  },
  {
    "task_id": "Shell/4",
    "prompt": {
      "en": "#!/bin/bash\n\n# Check if a given square matrix is an X Matrix.\n# An X Matrix has non-zero elements on its diagonals and zero elements elsewhere.\n# The function takes a single string argument representing the matrix, where rows are separated by semicolons and elements by spaces.\n# Returns true if it's an X Matrix, false otherwise.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "es": "#!/bin/bash\n\n# Verifica si una matriz cuadrada dada es una Matriz X.\n# Una Matriz X tiene elementos no cero en sus diagonales y elementos cero en otras partes.\n# La función toma un único argumento de cadena que representa la matriz, donde las filas están separadas por puntos y coma y los elementos por espacios.\n# Devuelve true si es una Matriz X, false en caso contrario.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "arb": "#!/bin/bash\n\n# التحقق مما إذا كانت المصفوفة المربعة المعطاة هي مصفوفة X.\n# تحتوي مصفوفة X على عناصر غير صفرية على أقطارها وعناصر صفرية في أماكن أخرى.\n# تأخذ الدالة وسيطًا نصيًا واحدًا يمثل المصفوفة، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.\n# تعيد true إذا كانت مصفوفة X، false خلاف ذلك.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "sw": "#!/bin/bash\n\n# Angalia kama mraba uliotolewa ni X Matrix.\n# X Matrix ina vipengele visivyo sifuri kwenye diagonali zake na vipengele vya sifuri kwingineko.\n# Kazi inachukua hoja moja ya kamba inayowakilisha matrix, ambapo mistari imetenganishwa na alama ya nukta na koma na vipengele kwa nafasi.\n# Inarudisha kweli ikiwa ni X Matrix, vinginevyo uongo.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "tr": "#!/bin/bash\n\n# Verilen bir kare matrisin bir X Matrisi olup olmadığını kontrol edin.\n# Bir X Matrisi, köşegenlerinde sıfır olmayan elemanlara ve diğer yerlerde sıfır elemanlara sahiptir.\n# Fonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı matrisi temsil eden tek bir dize argümanı alır.\n# Eğer bir X Matrisi ise true, aksi takdirde false döndürür.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "vi": "#!/bin/bash\n\n# Kiểm tra xem một ma trận vuông cho trước có phải là ma trận X hay không.\n# Một ma trận X có các phần tử khác không trên đường chéo của nó và các phần tử bằng không ở những vị trí khác.\n# Hàm nhận một đối số chuỗi duy nhất đại diện cho ma trận, trong đó các hàng được ngăn cách bằng dấu chấm phẩy và các phần tử được ngăn cách bằng dấu cách.\n# Trả về true nếu nó là ma trận X, ngược lại trả về false.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\""
    },
    "prompt_bertscore": {
      "es": "0.9984304227290624",
      "arb": "0.9928697652119907",
      "sw": "0.990509639024534",
      "tr": "0.9931728751734499",
      "vi": "0.9670386786799275"
    },
    "canonical_solution": "local n=${#rows[@]}\n\nfor (( i=0; i<$n; i++ )); do\nIFS=' ' read -ra cols <<< \"${rows[i]}\"\nfor (( j=0; j<$n; j++ )); do\nif (( i == j || i + j == n - 1 )); then\nif (( cols[j] == 0 )); then\necho \"false\"\nreturn\nfi\nelse\nif (( cols[j] != 0 )); then\necho \"false\"\nreturn\nfi\nfi\ndone\ndone\n\necho \"true\"\n}",
    "instruction": {
      "en": "Write a Shell function `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` to solve the following problem:\n\nCheck if a given square matrix is an X Matrix.\nAn X Matrix has non-zero elements on its diagonals and zero elements elsewhere.\nThe function takes a single string argument representing the matrix, where rows are separated by semicolons and elements by spaces.\nReturns true if it's an X Matrix, false otherwise.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue\n",
      "es": "Escribe una función de Shell `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` para resolver el siguiente problema:\n\nVerifica si una matriz cuadrada dada es una Matriz X.\nUna Matriz X tiene elementos no cero en sus diagonales y elementos cero en otros lugares.\nLa función toma un único argumento de cadena que representa la matriz, donde las filas están separadas por punto y coma y los elementos por espacios.\nDevuelve verdadero si es una Matriz X, falso en caso contrario.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue\n",
      "arb": "اكتب دالة شل `is_x_matrix() { IFS=';' read -ra rows <<< \"$1\"` لحل المشكلة التالية:\n\nتحقق مما إذا كانت المصفوفة المربعة المعطاة هي مصفوفة X.\nمصفوفة X تحتوي على عناصر غير صفرية على أقطارها وعناصر صفرية في أماكن أخرى.\nتأخذ الدالة وسيطًا واحدًا على شكل سلسلة تمثل المصفوفة، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.\nتعيد true إذا كانت مصفوفة X، false خلاف ذلك.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "sw": "Andika kazi ya Shell `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` kutatua tatizo lifuatalo:\n\nKagua kama mraba uliotolewa ni X Matrix.\nX Matrix ina vipengele visivyo sifuri kwenye diagonali zake na vipengele vya sifuri kwingineko.\nKazi inachukua hoja moja ya kamba inayowakilisha matrix, ambapo mistari imetenganishwa na alama ya nukta na koma na vipengele kwa nafasi.\nInarejesha kweli ikiwa ni X Matrix, vinginevyo si kweli.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "tr": "Bir Shell fonksiyonu `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` yazın ve aşağıdaki problemi çözün:\n\nVerilen bir kare matrisin X Matrisi olup olmadığını kontrol edin.\nBir X Matrisi, köşegenlerinde sıfır olmayan elemanlara ve diğer yerlerde sıfır elemanlara sahiptir.\nFonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı matrisi temsil eden tek bir string argüman alır.\nEğer X Matrisi ise true, değilse false döner.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "vi": "Viết một hàm Shell `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` để giải quyết vấn đề sau:\n\nKiểm tra xem một ma trận vuông cho trước có phải là Ma trận X hay không.\nMột Ma trận X có các phần tử khác không trên đường chéo và các phần tử bằng không ở những vị trí khác.\nHàm nhận một đối số chuỗi duy nhất đại diện cho ma trận, trong đó các hàng được phân tách bằng dấu chấm phẩy và các phần tử được phân tách bằng dấu cách.\nTrả về true nếu đó là Ma trận X, false nếu không phải.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue\n"
    },
    "instruction_bertscore": {
      "es": "0.9992968484511365",
      "arb": "0.9729834873539207",
      "sw": "0.9891498154359692",
      "tr": "0.9771577048113689",
      "vi": "0.9783324048848092"
    },
    "level": "easy",
    "test": "# Testing function\ntest_is_x_matrix() {\n[[ $(is_x_matrix \"1 0 0;0 1 0;0 0 1\") == \"false\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 2;0 1 0;3 0 1\") == \"true\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(is_x_matrix \"2 0 0 0;0 3 0 0;0 0 5 0;0 0 0 7\") == \"false\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 0;0 0 0;0 0 1\") == \"false\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(is_x_matrix \"0\") == \"false\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(is_x_matrix \"5\") == \"true\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 1;0 1 0;1 0 1\") == \"true\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_is_x_matrix",
    "entry_point": "is_x_matrix",
    "signature": "is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
    "docstring": {
      "en": "\nCheck if a given square matrix is an X Matrix.\nAn X Matrix has non-zero elements on its diagonals and zero elements elsewhere.\nThe function takes a single string argument representing the matrix, where rows are separated by semicolons and elements by spaces.\nReturns true if it's an X Matrix, false otherwise.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue\n",
      "es": "Verificar si una matriz cuadrada dada es una matriz X.  \nUna matriz X tiene elementos no nulos en sus diagonales y elementos cero en otras partes.  \nLa función toma un único argumento de cadena que representa la matriz, donde las filas están separadas por punto y coma y los elementos por espacios.  \nDevuelve verdadero si es una matriz X, falso en caso contrario.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "arb": "التحقق مما إذا كانت المصفوفة المربعة المعطاة هي مصفوفة X.\nالمصفوفة X تحتوي على عناصر غير صفرية على أقطارها وعناصر صفرية في أماكن أخرى.\nتأخذ الدالة وسيطًا واحدًا من نوع سلسلة يمثل المصفوفة، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.\nتُرجع true إذا كانت مصفوفة X، false خلاف ذلك.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "sw": "Angalia kama mraba uliotolewa wa matrix ni X Matrix.  \nX Matrix ina vipengele visivyo sifuri kwenye diagonali zake na vipengele vya sifuri kwingineko.  \nKazi inachukua hoja moja ya kamba inayowakilisha matrix, ambapo safu zimegawanywa na alama ya semicolon na vipengele kwa nafasi.  \nInarudisha kweli ikiwa ni X Matrix, uongo vinginevyo.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "tr": "Verilen bir kare matrisin bir X Matrisi olup olmadığını kontrol edin.  \nBir X Matrisi, köşegenlerinde sıfır olmayan elemanlara ve diğer yerlerde sıfır elemanlara sahiptir.  \nFonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı matrisi temsil eden tek bir string argüman alır.  \nEğer bu bir X Matrisi ise true, aksi takdirde false döner.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "vi": "Kiểm tra xem một ma trận vuông cho trước có phải là ma trận X hay không.  \nMột ma trận X có các phần tử khác không trên các đường chéo của nó và các phần tử bằng không ở những nơi khác.  \nHàm nhận một đối số chuỗi duy nhất đại diện cho ma trận, trong đó các hàng được phân tách bằng dấu chấm phẩy và các phần tử bằng dấu cách.  \nTrả về true nếu nó là ma trận X, ngược lại trả về false.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  "
    },
    "docstring_bertscore": {
      "es": "0.9922085246735255",
      "arb": "0.97395260498299",
      "sw": "0.9710966973644704",
      "tr": "0.9725828498753734",
      "vi": "0.9864063326131154"
    }
  },
  {
    "task_id": "Shell/5",
    "prompt": {
      "en": "#!/bin/bash\n\n# Perform operations on an array to remove pairs of equal integers.\n# Returns a two-element array: [number of pairs formed, number of remaining integers].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "es": "#!/bin/bash\n\n# Realiza operaciones en un array para eliminar pares de enteros iguales.\n# Devuelve un array de dos elementos: [número de pares formados, número de enteros restantes].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "arb": "#!/bin/bash\n\n# تنفيذ العمليات على مصفوفة لإزالة أزواج الأعداد الصحيحة المتساوية.\n# يعيد مصفوفة مكونة من عنصرين: [عدد الأزواج المتكونة، عدد الأعداد المتبقية].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "sw": "#!/bin/bash\n\n# Fanya shughuli kwenye safu ili kuondoa jozi za nambari sawa.\n# Inarudisha safu yenye vipengele viwili: [idadi ya jozi zilizoundwa, idadi ya nambari zilizobaki].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "tr": "#!/bin/bash\n\n# Eşit tamsayı çiftlerini kaldırmak için bir dizi üzerinde işlemler yapar.\n# İki elemanlı bir dizi döndürür: [oluşturulan çiftlerin sayısı, kalan tamsayıların sayısı].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "vi": "#!/bin/bash\n\n# Thực hiện các thao tác trên một mảng để loại bỏ các cặp số nguyên bằng nhau.\n# Trả về một mảng hai phần tử: [số lượng cặp được tạo thành, số lượng số nguyên còn lại].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)"
    },
    "prompt_bertscore": {
      "es": "0.9830061777505601",
      "arb": "0.9785985695953959",
      "sw": "0.96790669344505",
      "tr": "0.9567923304742428",
      "vi": "0.9990406152596015"
    },
    "canonical_solution": "local -A count_map\nlocal pairs=0\nlocal remaining=0\n\nfor num in ${nums[@]}; do\n((count_map[$num]++))\ndone\n\nfor count in ${count_map[@]}; do\npairs=$((pairs + count / 2))\nremaining=$((remaining + count % 2))\ndone\n\necho \"$pairs $remaining\"\n}",
    "instruction": {
      "en": "Write a Shell function `process_array() {\nlocal nums=($1)` to solve the following problem:\n\nPerform operations on an array to remove pairs of equal integers.\nReturns a two-element array: [number of pairs formed, number of remaining integers].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4\n",
      "es": "Escribe una función de Shell `process_array() {\nlocal nums=($1)` para resolver el siguiente problema:\n\nRealiza operaciones en un arreglo para eliminar pares de enteros iguales.  \nDevuelve un arreglo de dos elementos: [número de pares formados, número de enteros restantes].  \n>>> process_array \"3 1 2 3 2\"  \n2 1  \n>>> process_array \"1 2 3 4\"  \n0 4  ",
      "arb": "اكتب دالة شل `process_array() { local nums=($1)` لحل المشكلة التالية:\n\nقم بإجراء عمليات على مصفوفة لإزالة أزواج الأعداد الصحيحة المتساوية.\nتُرجع مصفوفة مكونة من عنصرين: [عدد الأزواج المتكونة، عدد الأعداد الصحيحة المتبقية].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "sw": "Andika kazi ya Shell `process_array() { local nums=($1)` kutatua tatizo lifuatalo:\n\nFanya shughuli kwenye safu ili kuondoa jozi za namba sawa.\nInarudisha safu yenye vipengele viwili: [idadi ya jozi zilizoundwa, idadi ya namba zilizobaki].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "tr": "Bir Shell fonksiyonu `process_array() {\nlocal nums=($1)` yazın ve aşağıdaki problemi çözün:\n\nEşit tamsayı çiftlerini kaldırmak için bir dizi üzerinde işlemler gerçekleştirin.\nİki elemanlı bir dizi döndürür: [oluşturulan çiftlerin sayısı, kalan tamsayıların sayısı].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "vi": "Viết một hàm Shell `process_array() {\nlocal nums=($1)` để giải quyết vấn đề sau:\n\nThực hiện các thao tác trên một mảng để loại bỏ các cặp số nguyên bằng nhau.  \nTrả về một mảng hai phần tử: [số lượng cặp đã tạo, số lượng số nguyên còn lại].  \n>>> process_array \"3 1 2 3 2\"  \n2 1  \n>>> process_array \"1 2 3 4\"  \n0 4  "
    },
    "instruction_bertscore": {
      "es": "0.9958160496538812",
      "arb": "0.985112057050292",
      "sw": "0.9672988844790833",
      "tr": "0.9831180066550828",
      "vi": "0.9904186663100201"
    },
    "level": "easy",
    "test": "# Testing function\ntest_process_array() {\n[[ $(process_array \"3 1 2 3 2\") == \"2 1\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(process_array \"1 2 3 4\") == \"0 4\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(process_array \"5 5 5 5 5\") == \"2 1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(process_array \"1 1 2 2 3 3 4 4\") == \"4 0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(process_array \"1\") == \"0 1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(process_array \"\") == \"0 0\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(process_array \"2 2 2 2 3 3 3\") == \"3 1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_process_array",
    "entry_point": "process_array",
    "signature": "process_array() {\nlocal nums=($1)",
    "docstring": {
      "en": "\nPerform operations on an array to remove pairs of equal integers.\nReturns a two-element array: [number of pairs formed, number of remaining integers].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4\n",
      "es": "Realiza operaciones en un arreglo para eliminar pares de enteros iguales.  \nDevuelve un arreglo de dos elementos: [número de pares formados, número de enteros restantes].  \n>>> process_array \"3 1 2 3 2\"  \n2 1  \n>>> process_array \"1 2 3 4\"  \n0 4  ",
      "arb": "إجراء عمليات على مصفوفة لإزالة أزواج من الأعداد الصحيحة المتساوية.  \nيعيد مصفوفة مكونة من عنصرين: [عدد الأزواج المشكلة، عدد الأعداد الصحيحة المتبقية].  \n>>> process_array \"3 1 2 3 2\"  \n2 1  \n>>> process_array \"1 2 3 4\"  \n0 4  ",
      "sw": "Fanya operesheni kwenye safu ili kuondoa jozi za namba sawa.\nInarudisha safu yenye vipengele viwili: [idadi ya jozi zilizoundwa, idadi ya namba zilizobaki].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "tr": "Dizideki eşit tamsayı çiftlerini kaldırmak için işlemler yapın.\nİki elemanlı bir dizi döndürür: [oluşturulan çift sayısı, kalan tamsayı sayısı].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "vi": "Thực hiện các thao tác trên một mảng để loại bỏ các cặp số nguyên bằng nhau.  \nTrả về một mảng hai phần tử: [số lượng cặp được tạo thành, số lượng số nguyên còn lại].  \n>>> process_array \"3 1 2 3 2\"  \n2 1  \n>>> process_array \"1 2 3 4\"  \n0 4  "
    },
    "docstring_bertscore": {
      "es": "0.9741480572779283",
      "arb": "0.9829741982592135",
      "sw": "0.9656431016227764",
      "tr": "0.9361580106011955",
      "vi": "0.9967585508118917"
    }
  },
  {
    "task_id": "Shell/6",
    "prompt": {
      "en": "#!/bin/bash\n\n# Evaluate poker hands based on given ranks and suits.\n# The function takes two strings: one for ranks and one for suits, each value separated by spaces.\n# Returns the best hand type: \"Flush\", \"Three of a Kind\", \"Pair\", or \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "es": "#!/bin/bash\n\n# Evalúa manos de póker basadas en los rangos y palos dados.\n# La función toma dos cadenas: una para los rangos y otra para los palos, cada valor separado por espacios.\n# Devuelve el mejor tipo de mano: \"Flush\", \"Three of a Kind\", \"Pair\", o \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "arb": "#!/bin/bash\n\n# تقييم أيدي البوكر بناءً على الرتب والأنواع المعطاة.\n# تأخذ الدالة سلسلتين: واحدة للرتب وواحدة للأنواع، كل قيمة مفصولة بمسافات.\n# تعيد نوع اليد الأفضل: \"Flush\"، \"Three of a Kind\"، \"Pair\"، أو \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "sw": "#!/bin/bash\n\n# Tambua mikono ya poker kulingana na vyeo na suti zilizotolewa.\n# Kazi inachukua mistari miwili: moja kwa vyeo na moja kwa suti, kila thamani imetenganishwa na nafasi.\n# Inarudisha aina bora ya mkono: \"Flush\", \"Three of a Kind\", \"Pair\", au \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "tr": "#!/bin/bash\n\n# Verilen sıralamalar ve türlere göre poker ellerini değerlendirir.\n# Fonksiyon iki dize alır: biri sıralamalar için, diğeri türler için, her değer boşluklarla ayrılmıştır.\n# En iyi el tipini döndürür: \"Flush\", \"Three of a Kind\", \"Pair\" veya \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "vi": "#!/bin/bash\n\n# Đánh giá tay bài poker dựa trên các hạng và chất bài đã cho.\n# Hàm nhận hai chuỗi: một cho các hạng và một cho các chất bài, mỗi giá trị được phân tách bằng dấu cách.\n# Trả về loại tay bài tốt nhất: \"Flush\", \"Three of a Kind\", \"Pair\", hoặc \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)"
    },
    "prompt_bertscore": {
      "es": "0.977039122473891",
      "arb": "0.9962494611452992",
      "sw": "0.9650625050190115",
      "tr": "0.9934920741957729",
      "vi": "0.9776032327560301"
    },
    "canonical_solution": "local -A rank_count\nlocal -A suit_count\nlocal max_rank_count=0\nlocal max_suit_count=0\n\nfor i in ${ranks[@]}; do\n((rank_count[$i]++))\nmax_rank_count=$((max_rank_count < rank_count[$i] ? rank_count[$i] : max_rank_count))\ndone\n\nfor i in ${suits[@]}; do\n((suit_count[$i]++))\nmax_suit_count=$((max_suit_count < suit_count[$i] ? suit_count[$i] : max_suit_count))\ndone\n\nif (( max_suit_count == 5 )); then\necho \"Flush\"\nelif (( max_rank_count == 3 || max_rank_count == 4)); then\necho \"Three of a Kind\"\nelif (( max_rank_count == 2 )); then\necho \"Pair\"\nelse\necho \"High Card\"\nfi\n}\n\n# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand",
    "instruction": {
      "en": "Write a Shell function `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` to solve the following problem:\n\nEvaluate poker hands based on given ranks and suits.\nThe function takes two strings: one for ranks and one for suits, each value separated by spaces.\nReturns the best hand type: \"Flush\", \"Three of a Kind\", \"Pair\", or \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind\n",
      "es": "Escribe una función de Shell `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` para resolver el siguiente problema:\n\nEvalúa manos de póker basadas en los rangos y palos dados.\nLa función toma dos cadenas: una para los rangos y otra para los palos, cada valor separado por espacios.\nDevuelve el mejor tipo de mano: \"Flush\", \"Three of a Kind\", \"Pair\", o \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "arb": "اكتب دالة شيل `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` لحل المشكلة التالية:\n\nتقييم أيدي البوكر بناءً على الرتب والأنواع المعطاة.\nتأخذ الدالة سلسلتين: واحدة للرتب وواحدة للأنواع، كل قيمة مفصولة بمسافات.\nتُرجع أفضل نوع يد: \"Flush\"، \"Three of a Kind\"، \"Pair\"، أو \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "sw": "Andika kazi ya Shell `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` kutatua tatizo lifuatalo:\n\nTambua mikono ya poker kulingana na vyeo na suti zilizotolewa.\nKazi inachukua mistari miwili: moja kwa vyeo na moja kwa suti, kila thamani imetenganishwa na nafasi.\nInarudisha aina bora ya mkono: \"Flush\", \"Three of a Kind\", \"Pair\", au \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "tr": "Bir Shell fonksiyonu `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` yazın:\n\nVerilen rank ve suitlere göre poker ellerini değerlendirin.\nFonksiyon, her biri boşluklarla ayrılmış değerler içeren iki dize alır: biri rankler için, diğeri suitler için.\nEn iyi el tipini döndürür: \"Flush\", \"Three of a Kind\", \"Pair\" veya \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "vi": "Viết một hàm Shell `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` để giải quyết vấn đề sau:\n\nĐánh giá các tay bài poker dựa trên các hạng và chất đã cho.\nHàm nhận hai chuỗi: một cho hạng và một cho chất, mỗi giá trị được ngăn cách bằng khoảng trắng.\nTrả về loại tay bài tốt nhất: \"Flush\", \"Three of a Kind\", \"Pair\", hoặc \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind"
    },
    "instruction_bertscore": {
      "es": "0.9827012801156716",
      "arb": "0.9966882356570053",
      "sw": "0.9655308754574917",
      "tr": "0.9216375338564021",
      "vi": "0.9927058951476369"
    },
    "level": "hard",
    "test": "# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand",
    "entry_point": "evaluate_hand",
    "signature": "evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
    "docstring": {
      "en": "\nEvaluate poker hands based on given ranks and suits.\nThe function takes two strings: one for ranks and one for suits, each value separated by spaces.\nReturns the best hand type: \"Flush\", \"Three of a Kind\", \"Pair\", or \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind\n",
      "es": "Evalúa manos de póker basadas en los rangos y palos dados.\nLa función toma dos cadenas: una para los rangos y otra para los palos, cada valor separado por espacios.\nDevuelve el mejor tipo de mano: \"Flush\", \"Three of a Kind\", \"Pair\", o \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "arb": "تقييم أيدي البوكر بناءً على الرتب والأنماط المعطاة.  \nتأخذ الدالة سلسلتين نصيتين: واحدة للرتب وواحدة للأنماط، كل قيمة مفصولة بمسافات.  \nتعيد نوع اليد الأفضل: \"Flush\"، \"Three of a Kind\"، \"Pair\"، أو \"High Card\".  \n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"  \nFlush  \n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"  \nThree of a Kind  ",
      "sw": "Tambua mikono ya poker kulingana na vyeo na suti zilizotolewa.  \nKazi inachukua mistari miwili: moja kwa vyeo na nyingine kwa suti, kila thamani ikitenganishwa na nafasi.  \nInarudisha aina bora ya mkono: \"Flush\", \"Three of a Kind\", \"Pair\", au \"High Card\".  \n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"  \nFlush  \n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"  \nThree of a Kind  ",
      "tr": "Verilen sıralamalar ve türlere göre poker ellerini değerlendirir.\nFonksiyon iki dize alır: biri sıralamalar için, diğeri türler için, her bir değer boşluklarla ayrılmıştır.\nEn iyi el türünü döndürür: \"Flush\", \"Three of a Kind\", \"Pair\" veya \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "vi": "Đánh giá các tay bài poker dựa trên các hạng và chất bài đã cho.  \nHàm nhận hai chuỗi: một cho hạng và một cho chất bài, mỗi giá trị được ngăn cách bởi dấu cách.  \nTrả về loại tay bài tốt nhất: \"Flush\", \"Three of a Kind\", \"Pair\", hoặc \"High Card\".  \n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"  \nFlush  \n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"  \nThree of a Kind  "
    },
    "docstring_bertscore": {
      "es": "0.9760269020521373",
      "arb": "0.9951635488521815",
      "sw": "0.9574573449899476",
      "tr": "0.9813474154385378",
      "vi": "0.9816467514227574"
    }
  },
  {
    "task_id": "Shell/7",
    "prompt": {
      "en": "#!/bin/bash\n\n# Calculate the minimum number of operations to reduce all elements of an array to zero.\n# Each operation consists of subtracting a positive integer x (less than or equal to the smallest non-zero element) from each positive element in the array.\n# The function takes a string representing the array, with elements separated by spaces.\n# Returns the minimum number of operations required.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "es": "#!/bin/bash\n\n# Calcular el número mínimo de operaciones para reducir todos los elementos de un arreglo a cero.\n# Cada operación consiste en restar un número entero positivo x (menor o igual al elemento no cero más pequeño) de cada elemento positivo en el arreglo.\n# La función toma una cadena que representa el arreglo, con elementos separados por espacios.\n# Devuelve el número mínimo de operaciones requeridas.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "arb": "#!/bin/bash\n\n# حساب الحد الأدنى لعدد العمليات لتقليل جميع عناصر المصفوفة إلى الصفر.\n# تتكون كل عملية من طرح عدد صحيح موجب x (أقل من أو يساوي أصغر عنصر غير صفري) من كل عنصر موجب في المصفوفة.\n# تأخذ الدالة سلسلة تمثل المصفوفة، مع العناصر مفصولة بمسافات.\n# تعيد الحد الأدنى لعدد العمليات المطلوبة.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "sw": "#!/bin/bash\n\n# Hesabu idadi ndogo ya operesheni za kupunguza vipengele vyote vya safu hadi sifuri.\n# Kila operesheni inajumuisha kutoa namba nzima chanya x (ndogo au sawa na kipengele kidogo zaidi kisicho sifuri) kutoka kwa kila kipengele chanya katika safu.\n# Kazi inachukua kamba inayoashiria safu, na vipengele vilivyotenganishwa na nafasi.\n# Inarejesha idadi ndogo ya operesheni zinazohitajika.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "tr": "#!/bin/bash\n\n# Bir dizinin tüm elemanlarını sıfıra indirmek için gereken minimum işlem sayısını hesaplayın.\n# Her işlem, dizideki her pozitif elemandan pozitif bir tam sayı x (sıfır olmayan en küçük elemana eşit veya daha küçük) çıkarmaktan oluşur.\n# Fonksiyon, elemanları boşluklarla ayrılmış diziyi temsil eden bir dize alır.\n# Gerekli minimum işlem sayısını döndürür.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "vi": "#!/bin/bash\n\n# Tính số lượng thao tác tối thiểu để giảm tất cả các phần tử của một mảng về không.\n# Mỗi thao tác bao gồm việc trừ đi một số nguyên dương x (nhỏ hơn hoặc bằng phần tử dương nhỏ nhất) từ mỗi phần tử dương trong mảng.\n# Hàm nhận một chuỗi đại diện cho mảng, với các phần tử được ngăn cách bằng dấu cách.\n# Trả về số lượng thao tác tối thiểu cần thiết.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9963257352116166",
      "sw": "0.9916497774116744",
      "tr": "0.9862253803359926",
      "vi": "0.9827286911082544"
    },
    "canonical_solution": "local operations=0\nlocal min_non_zero=99999\n\n# Find the minimum non-zero element in the array\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\n\nwhile (( min_non_zero != 99999 )); do\n# Subtract min_non_zero from each element and count operation\nfor i in ${!nums[@]}; do\nif (( nums[i] > 0 )); then\nnums[i]=$(( nums[i] - min_non_zero ))\nfi\ndone\noperations=$((operations + 1))\n\n# Find new minimum non-zero element\nmin_non_zero=99999\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\ndone\n\necho $operations\n}",
    "instruction": {
      "en": "Write a Shell function `min_operations_to_zero() {\nlocal nums=($1)` to solve the following problem:\n\nCalculate the minimum number of operations to reduce all elements of an array to zero.\nEach operation consists of subtracting a positive integer x (less than or equal to the smallest non-zero element) from each positive element in the array.\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the minimum number of operations required.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "es": "Escribe una función de Shell `min_operations_to_zero() {\nlocal nums=($1)` para resolver el siguiente problema:\n\nCalcula el número mínimo de operaciones para reducir todos los elementos de un arreglo a cero.\nCada operación consiste en restar un entero positivo x (menor o igual al elemento no cero más pequeño) de cada elemento positivo en el arreglo.\nLa función toma una cadena que representa el arreglo, con elementos separados por espacios.\nDevuelve el número mínimo de operaciones requeridas.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "arb": "اكتب دالة شل `min_operations_to_zero() {\nlocal nums=($1)` لحل المشكلة التالية:\n\nاحسب الحد الأدنى لعدد العمليات لتقليل جميع عناصر المصفوفة إلى صفر.\nتتكون كل عملية من طرح عدد صحيح موجب x (أقل من أو يساوي أصغر عنصر غير صفري) من كل عنصر موجب في المصفوفة.\nتأخذ الدالة سلسلة تمثل المصفوفة، مع العناصر مفصولة بمسافات.\nتعيد الحد الأدنى لعدد العمليات المطلوبة.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "sw": "Andika kazi ya Shell `min_operations_to_zero() {\nlocal nums=($1)` kutatua tatizo lifuatalo:\n\nHesabu idadi ndogo ya operesheni za kupunguza vipengele vyote vya safu hadi sifuri.\nKila operesheni inajumuisha kutoa nambari nzima chanya x (ndogo au sawa na kipengele kidogo zaidi kisicho sifuri) kutoka kwa kila kipengele chanya katika safu.\nKazi inachukua kamba inayowakilisha safu, na vipengele vikitenganishwa na nafasi.\nInarejesha idadi ndogo ya operesheni zinazohitajika.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "tr": "Bir Shell fonksiyonu `min_operations_to_zero() {\nlocal nums=($1)` yazın, aşağıdaki problemi çözmek için:\n\nBir dizinin tüm elemanlarını sıfıra indirmek için gereken minimum işlem sayısını hesaplayın.\nHer işlem, dizideki her pozitif elemandan, pozitif bir tamsayı x (sıfır olmayan en küçük elemana eşit veya daha küçük) çıkarmaktan oluşur.\nFonksiyon, elemanları boşluklarla ayrılmış diziyi temsil eden bir dize alır.\nGerekli minimum işlem sayısını döndürür.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "vi": "Viết một hàm Shell `min_operations_to_zero() {\nlocal nums=($1)` để giải quyết vấn đề sau:\n\nTính toán số lượng thao tác tối thiểu để giảm tất cả các phần tử của một mảng về không.\nMỗi thao tác bao gồm việc trừ đi một số nguyên dương x (nhỏ hơn hoặc bằng phần tử nhỏ nhất khác không) từ mỗi phần tử dương trong mảng.\nHàm nhận một chuỗi đại diện cho mảng, với các phần tử được ngăn cách bằng dấu cách.\nTrả về số lượng thao tác tối thiểu cần thiết.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.988852664385941",
      "sw": "0.996475899779679",
      "tr": "0.9724453976516972",
      "vi": "0.9982500663430827"
    },
    "level": "hard",
    "test": "test_min_operations_to_zero() {\n[[ $(min_operations_to_zero \"3 3 2 2 1\") == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"4 0 0 4\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"1 2 3 4 5\") == \"5\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"0 0 0\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"5 5 5 5 5\") == \"1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"1 1 1 1\") == \"1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"10 10 10 10 20\") == \"2\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_min_operations_to_zero",
    "entry_point": "min_operations_to_zero",
    "signature": "min_operations_to_zero() {\nlocal nums=($1)",
    "docstring": {
      "en": "\nCalculate the minimum number of operations to reduce all elements of an array to zero.\nEach operation consists of subtracting a positive integer x (less than or equal to the smallest non-zero element) from each positive element in the array.\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the minimum number of operations required.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "es": "Calcular el número mínimo de operaciones para reducir todos los elementos de un array a cero.\nCada operación consiste en restar un entero positivo x (menor o igual al elemento no cero más pequeño) de cada elemento positivo en el array.\nLa función toma una cadena que representa el array, con elementos separados por espacios.\nDevuelve el número mínimo de operaciones requeridas.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "arb": "احسب الحد الأدنى لعدد العمليات لتقليل جميع عناصر المصفوفة إلى الصفر.\nكل عملية تتكون من طرح عدد صحيح موجب x (أقل من أو يساوي أصغر عنصر غير صفري) من كل عنصر موجب في المصفوفة.\nتأخذ الدالة سلسلة تمثل المصفوفة، مع العناصر مفصولة بمسافات.\nتعيد الحد الأدنى لعدد العمليات المطلوبة.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "sw": "Hesabu idadi ndogo ya operesheni za kupunguza vipengele vyote vya safu hadi sifuri.\nKila operesheni inajumuisha kutoa nambari nzima chanya x (ndogo au sawa na kipengele kidogo kisicho sifuri) kutoka kwa kila kipengele chanya katika safu.\nKazi inachukua kamba inayowakilisha safu, na vipengele vikitenganishwa na nafasi.\nInarejesha idadi ndogo ya operesheni zinazohitajika.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "tr": "Dizinin tüm elemanlarını sıfıra indirmek için minimum işlem sayısını hesaplayın. Her işlem, dizideki her pozitif elemandan pozitif bir tamsayı x (sıfırdan büyük en küçük elemana eşit veya daha küçük) çıkarmaktan oluşur. Fonksiyon, elemanları boşluklarla ayrılmış diziyi temsil eden bir dize alır. Gerekli minimum işlem sayısını döndürür.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "vi": "Tính số lượng thao tác tối thiểu để giảm tất cả các phần tử của một mảng về không.\nMỗi thao tác bao gồm việc trừ đi một số nguyên dương x (nhỏ hơn hoặc bằng phần tử dương nhỏ nhất) từ mỗi phần tử dương trong mảng.\nHàm nhận một chuỗi đại diện cho mảng, với các phần tử được ngăn cách bởi dấu cách.\nTrả về số lượng thao tác tối thiểu cần thiết.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9960758581922747",
      "sw": "0.9898211861238672",
      "tr": "0.9669814731301895",
      "vi": "0.9790977277429367"
    }
  },
  {
    "task_id": "Shell/8",
    "prompt": {
      "en": "#!/bin/bash\n\n# Merge two sets of items and sum the weights of items with the same value.\n# Each item is represented as [value, weight].\n# The function takes two strings, each representing an array of items, where items are separated by semicolons and values by spaces.\n# Returns a sorted array of unique values and their cumulative weights.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "es": "#!/bin/bash\n\n# Fusionar dos conjuntos de elementos y sumar los pesos de los elementos con el mismo valor.\n# Cada elemento se representa como [valor, peso].\n# La función toma dos cadenas, cada una representando un arreglo de elementos, donde los elementos están separados por punto y coma y los valores por espacios.\n# Devuelve un arreglo ordenado de valores únicos y sus pesos acumulativos.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "arb": "#!/bin/bash\n\n# دمج مجموعتين من العناصر وجمع أوزان العناصر ذات القيمة نفسها.\n# يتم تمثيل كل عنصر كـ [قيمة، وزن].\n# تأخذ الدالة سلسلتين، كل منهما تمثل مصفوفة من العناصر، حيث يتم فصل العناصر بفواصل منقوطة والقيم بمسافات.\n# تعيد مصفوفة مرتبة من القيم الفريدة وأوزانها التراكمية.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "sw": "#!/bin/bash\n\n# Unganisha seti mbili za vitu na jumlisha uzito wa vitu vyenye thamani sawa.\n# Kila kipengee kinawakilishwa kama [thamani, uzito].\n# Kazi inachukua mistari miwili, kila moja ikiwakilisha safu ya vitu, ambapo vitu vinatenganishwa na alama ya nukta na mkato na thamani kwa nafasi.\n# Inarudisha safu iliyopangwa ya thamani za kipekee na uzito wao wa jumla.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "tr": "#!/bin/bash\n\n# İki öğe kümesini birleştir ve aynı değere sahip öğelerin ağırlıklarını topla.\n# Her öğe [değer, ağırlık] olarak temsil edilir.\n# Fonksiyon, her biri öğeleri temsil eden iki dize alır, burada öğeler noktalı virgülle ve değerler boşlukla ayrılır.\n# Benzersiz değerlerin ve bunların kümülatif ağırlıklarının sıralanmış bir dizisini döndürür.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "vi": "#!/bin/bash\n\n# Gộp hai tập hợp các mục và tính tổng trọng lượng của các mục có cùng giá trị.\n# Mỗi mục được biểu diễn dưới dạng [giá trị, trọng lượng].\n# Hàm nhận hai chuỗi, mỗi chuỗi đại diện cho một mảng các mục, trong đó các mục được phân tách bằng dấu chấm phẩy và các giá trị bằng dấu cách.\n# Trả về một mảng đã sắp xếp của các giá trị duy nhất và trọng lượng tích lũy của chúng.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })"
    },
    "prompt_bertscore": {
      "es": "0.9780090346244844",
      "arb": "1",
      "sw": "0.9710301561868236",
      "tr": "0.9814074018136103",
      "vi": "0.986141955575958"
    },
    "canonical_solution": "local -A item_map\nlocal IFS=$'\\n'\n\n# Process items1\nfor (( i=0; i<${#items1[@]}; i+=2 )); do\nitem_map[${items1[i]}]=$((item_map[${items1[i]}] + items1[i+1]))\ndone\n\n# Process items2\nfor (( i=0; i<${#items2[@]}; i+=2 )); do\nitem_map[${items2[i]}]=$((item_map[${items2[i]}] + items2[i+1]))\ndone\n\n# Sort and output the result\nfor item in $(echo ${!item_map[@]} | tr ' ' '\\n' | sort -n); do\necho -n \"$item ${item_map[$item]};\"\ndone\n}",
    "instruction": {
      "en": "Write a Shell function `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` to solve the following problem:\n\nMerge two sets of items and sum the weights of items with the same value.\nEach item is represented as [value, weight].\nThe function takes two strings, each representing an array of items, where items are separated by semicolons and values by spaces.\nReturns a sorted array of unique values and their cumulative weights.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20\n",
      "es": "Escribe una función de Shell `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` para resolver el siguiente problema:\n\nFusionar dos conjuntos de elementos y sumar los pesos de los elementos con el mismo valor.\nCada elemento está representado como [valor, peso].\nLa función toma dos cadenas, cada una representando un array de elementos, donde los elementos están separados por punto y coma y los valores por espacios.\nDevuelve un array ordenado de valores únicos y sus pesos acumulativos.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "arb": "اكتب دالة Shell `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` لحل المشكلة التالية:\n\nدمج مجموعتين من العناصر وجمع أوزان العناصر ذات القيمة نفسها.\nيتم تمثيل كل عنصر كـ [قيمة، وزن].\nتأخذ الدالة سلسلتين، كل منهما تمثل مصفوفة من العناصر، حيث يتم فصل العناصر بفواصل منقوطة والقيم بمسافات.\nتعيد مصفوفة مرتبة من القيم الفريدة وأوزانها التراكمية.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "sw": "Andika kazi ya Shell `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` kutatua tatizo lifuatalo:\n\nUnganisha seti mbili za vitu na jumlisha uzito wa vitu vyenye thamani sawa.\nKila kipengee kinawakilishwa kama [thamani, uzito].\nKazi inachukua mistari miwili, kila moja ikiwakilisha safu ya vitu, ambapo vitu vimetenganishwa na alama ya nukta na koma na thamani kwa nafasi.\nInarudisha safu iliyopangwa ya thamani za kipekee na uzito wao wa jumla.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "tr": "Bir Shell fonksiyonu `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` yazın:\n\nİki öğe kümesini birleştirin ve aynı değere sahip öğelerin ağırlıklarını toplayın.\nHer öğe [değer, ağırlık] olarak temsil edilir.\nFonksiyon, her biri bir dizi öğeyi temsil eden iki dize alır, burada öğeler noktalı virgülle ve değerler boşlukla ayrılır.\nBenzersiz değerlerin ve bunların kümülatif ağırlıklarının sıralanmış bir dizisini döndürür.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "vi": "Viết một hàm Shell `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` để giải quyết vấn đề sau:\n\nGộp hai tập hợp các mục và cộng tổng trọng lượng của các mục có cùng giá trị.\nMỗi mục được biểu diễn dưới dạng [giá trị, trọng lượng].\nHàm nhận hai chuỗi, mỗi chuỗi biểu diễn một mảng các mục, trong đó các mục được phân tách bằng dấu chấm phẩy và các giá trị bằng dấu cách.\nTrả về một mảng đã sắp xếp của các giá trị duy nhất và trọng lượng tích lũy của chúng.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20"
    },
    "instruction_bertscore": {
      "es": "0.9912769481864718",
      "arb": "0.9953866107700837",
      "sw": "0.9800364549237075",
      "tr": "0.9746567496837586",
      "vi": "0.9974479968644637"
    },
    "level": "middle",
    "test": "test_merge_items() {\n[[ $(merge_items \"10 5;15 10\" \"15 15;20 20\") == \"10 5;15 25;20 20;\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(merge_items \"1 2;3 4\" \"5 6;7 8\") == \"1 2;3 4;5 6;7 8;\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(merge_items \"2 2;4 4\" \"2 3;4 5\") == \"2 5;4 9;\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(merge_items \"\" \"\") == \"\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(merge_items \"10 10\" \"10 10\") == \"10 20;\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(merge_items \"1 1;2 2;3 3\" \"4 4;5 5;6 6\") == \"1 1;2 2;3 3;4 4;5 5;6 6;\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(merge_items \"9 9;8 8\" \"7 7;6 6\") == \"6 6;7 7;8 8;9 9;\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_merge_items",
    "entry_point": "merge_items",
    "signature": "merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
    "docstring": {
      "en": "\nMerge two sets of items and sum the weights of items with the same value.\nEach item is represented as [value, weight].\nThe function takes two strings, each representing an array of items, where items are separated by semicolons and values by spaces.\nReturns a sorted array of unique values and their cumulative weights.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20\n",
      "es": "Fusionar dos conjuntos de elementos y sumar los pesos de los elementos con el mismo valor.\nCada elemento se representa como [valor, peso].\nLa función toma dos cadenas, cada una representando un arreglo de elementos, donde los elementos están separados por punto y coma y los valores por espacios.\nDevuelve un arreglo ordenado de valores únicos y sus pesos acumulativos.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "arb": "دمج مجموعتين من العناصر وجمع أوزان العناصر ذات القيمة نفسها.\nكل عنصر يتم تمثيله كـ [قيمة، وزن].\nتأخذ الدالة سلسلتين نصيتين، كل واحدة تمثل مصفوفة من العناصر، حيث يتم فصل العناصر بفواصل منقوطة والقيم بمسافات.\nتعيد مصفوفة مرتبة من القيم الفريدة وأوزانها التراكمية.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "sw": "Unganisha seti mbili za vitu na uongeze uzito wa vitu vyenye thamani sawa. \nKila kipengee kinawakilishwa kama [thamani, uzito]. \nKazi inachukua mistari miwili, kila moja ikiwakilisha safu ya vitu, ambapo vitu vinatenganishwa na alama ya nukta na mkato na thamani kwa nafasi. \nInarudisha safu iliyopangwa ya thamani za kipekee na uzito wao wa jumla. \n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "tr": "İki öğe kümesini birleştirin ve aynı değere sahip öğelerin ağırlıklarını toplayın. Her öğe [değer, ağırlık] olarak temsil edilir. Fonksiyon, her biri öğeleri noktalı virgülle ve değerleri boşlukla ayıran bir dizi öğeyi temsil eden iki dize alır. Benzersiz değerlerin ve bunların kümülatif ağırlıklarının sıralı bir dizisini döndürür.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "vi": "Gộp hai tập hợp các mục và tổng trọng lượng của các mục có cùng giá trị.  \nMỗi mục được biểu diễn dưới dạng [giá trị, trọng lượng].  \nHàm nhận hai chuỗi, mỗi chuỗi đại diện cho một mảng các mục, trong đó các mục được phân tách bằng dấu chấm phẩy và các giá trị bằng dấu cách.  \nTrả về một mảng đã sắp xếp của các giá trị duy nhất và trọng lượng tích lũy của chúng.  \n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"  \n10 5;15 25;20 20  "
    },
    "docstring_bertscore": {
      "es": "0.9723808427778609",
      "arb": "1",
      "sw": "0.967308815998135",
      "tr": "0.9506514736141682",
      "vi": "0.9957318303723223"
    }
  },
  {
    "task_id": "Shell/9",
    "prompt": {
      "en": "#!/bin/bash\n\n# Count the number of distinct arithmetic triplets in a strictly increasing integer array.\n# A triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.\n# The function takes a string representing the array and an integer diff, with elements separated by spaces.\n# Returns the count of distinct arithmetic triplets.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "es": "#!/bin/bash\n\n# Cuenta el número de tripletas aritméticas distintas en un arreglo de enteros estrictamente creciente.\n# Una tripleta (i, j, k) es aritmética si nums[j] - nums[i] == diff y nums[k] - nums[j] == diff.\n# La función toma una cadena que representa el arreglo y un entero diff, con elementos separados por espacios.\n# Devuelve el conteo de tripletas aritméticas distintas.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "arb": "#!/bin/bash\n\n# عد عدد الثلاثيات الحسابية المميزة في مصفوفة أعداد صحيحة تزداد بشكل صارم.\n# تكون الثلاثية (i, j, k) حسابية إذا كان nums[j] - nums[i] == diff و nums[k] - nums[j] == diff.\n# تأخذ الدالة سلسلة تمثل المصفوفة وعددًا صحيحًا diff، مع العناصر مفصولة بمسافات.\n# تُعيد عدد الثلاثيات الحسابية المميزة.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "sw": "#!/bin/bash\n\n# Hesabu idadi ya tatu tofauti za hesabu katika safu ya nambari za mzima zinazoongezeka kwa utaratibu.\n# Tatu (i, j, k) ni ya hesabu ikiwa nums[j] - nums[i] == diff na nums[k] - nums[j] == diff.\n# Kazi inachukua kamba inayowakilisha safu na nambari mzima diff, na vipengele vimetenganishwa na nafasi.\n# Inarudisha hesabu ya tatu tofauti za hesabu.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "tr": "#!/bin/bash\n\n# Sıkı artan bir tamsayı dizisinde farklı aritmetik üçlülerin sayısını sayar.\n# Bir üçlü (i, j, k) aritmetik ise nums[j] - nums[i] == diff ve nums[k] - nums[j] == diff olur.\n# Fonksiyon, diziyi temsil eden bir dize ve elemanların boşluklarla ayrıldığı bir tamsayı diff alır.\n# Farklı aritmetik üçlülerin sayısını döndürür.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "vi": "#!/bin/bash\n\n# Đếm số bộ ba số học khác nhau trong một mảng số nguyên tăng dần chặt chẽ.\n# Một bộ ba (i, j, k) là số học nếu nums[j] - nums[i] == diff và nums[k] - nums[j] == diff.\n# Hàm nhận một chuỗi đại diện cho mảng và một số nguyên diff, với các phần tử được ngăn cách bởi dấu cách.\n# Trả về số lượng bộ ba số học khác nhau.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2"
    },
    "prompt_bertscore": {
      "es": "0.9964925847316859",
      "arb": "0.9930179434762426",
      "sw": "0.9682801185613956",
      "tr": "0.9910816945219145",
      "vi": "0.9928783063183751"
    },
    "canonical_solution": "local count=0\n\nfor (( i=0; i<${#nums[@]}; i++ )); do\nfor (( j=i+1; j<${#nums[@]}; j++ )); do\nif (( nums[j] - nums[i] == diff )); then\nfor (( k=j+1; k<${#nums[@]}; k++ )); do\nif (( nums[k] - nums[j] == diff )); then\ncount=$((count + 1))\nfi\ndone\nfi\ndone\ndone\n\necho $count\n}",
    "instruction": {
      "en": "Write a Shell function `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` to solve the following problem:\n\nCount the number of distinct arithmetic triplets in a strictly increasing integer array.\nA triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.\nThe function takes a string representing the array and an integer diff, with elements separated by spaces.\nReturns the count of distinct arithmetic triplets.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4\n",
      "es": "Escribe una función Shell `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` para resolver el siguiente problema:\n\nCuenta el número de tripletes aritméticos distintos en un arreglo de enteros estrictamente creciente.\nUn triplete (i, j, k) es aritmético si nums[j] - nums[i] == diff y nums[k] - nums[j] == diff.\nLa función toma una cadena que representa el arreglo y un entero diff, con elementos separados por espacios.\nDevuelve el conteo de tripletes aritméticos distintos.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4\n",
      "arb": "اكتب دالة شل `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` لحل المشكلة التالية:\n\nاحسب عدد الثلاثيات الحسابية المميزة في مصفوفة أعداد صحيحة متزايدة بشكل صارم.\nالثلاثية (i, j, k) تكون حسابية إذا كان nums[j] - nums[i] == diff و nums[k] - nums[j] == diff.\nتأخذ الدالة سلسلة تمثل المصفوفة وعددًا صحيحًا diff، مع العناصر مفصولة بمسافات.\nتعيد عدد الثلاثيات الحسابية المميزة.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "sw": "Andika kazi ya Shell `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` kutatua tatizo lifuatalo:\n\nHesabu idadi ya triplets tofauti za hesabu katika safu ya nambari za mzima zinazoongezeka kwa ukali.\nTriplet (i, j, k) ni hesabu ikiwa nums[j] - nums[i] == diff na nums[k] - nums[j] == diff.\nKazi inachukua kamba inayowakilisha safu na nambari ya mzima diff, na vipengele vilivyotenganishwa na nafasi.\nInarudisha hesabu ya triplets tofauti za hesabu.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "tr": "Bir Shell fonksiyonu `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` yazın.\n\nSıkı bir şekilde artan bir tamsayı dizisinde farklı aritmetik üçlülerin sayısını sayın.\nBir üçlü (i, j, k) aritmetik ise nums[j] - nums[i] == diff ve nums[k] - nums[j] == diff.\nFonksiyon, diziyi temsil eden bir dize ve bir tamsayı diff alır, elemanlar boşluklarla ayrılır.\nFarklı aritmetik üçlülerin sayısını döndürür.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "vi": "Viết một hàm Shell `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` để giải quyết vấn đề sau:\n\nĐếm số lượng bộ ba số học khác nhau trong một mảng số nguyên tăng dần chặt chẽ.\nMột bộ ba (i, j, k) là số học nếu nums[j] - nums[i] == diff và nums[k] - nums[j] == diff.\nHàm nhận một chuỗi đại diện cho mảng và một số nguyên diff, với các phần tử được ngăn cách bởi dấu cách.\nTrả về số lượng bộ ba số học khác nhau.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9808740792405316",
      "sw": "0.9867809495117471",
      "tr": "0.9708927039631475",
      "vi": "0.9885028762849386"
    },
    "level": "easy",
    "test": "test_count_arithmetic_triplets() {\n[[ $(count_arithmetic_triplets \"1 2 3 4 5\" 1) == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 3 5 7 9\" 2) == \"3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"2 4 6 8 10\" 2) == \"3\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 4 7 10 13\" 3) == \"3\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 2 4 5 7\" 2) == \"0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 5 9 13 17\" 4) == \"3\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"10 20 30 40 50\" 10) == \"3\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_count_arithmetic_triplets",
    "entry_point": "count_arithmetic_triplets",
    "signature": "count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
    "docstring": {
      "en": "\nCount the number of distinct arithmetic triplets in a strictly increasing integer array.\nA triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.\nThe function takes a string representing the array and an integer diff, with elements separated by spaces.\nReturns the count of distinct arithmetic triplets.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4\n",
      "es": "Cuenta el número de tríos aritméticos distintos en un array de enteros estrictamente creciente.\nUn trío (i, j, k) es aritmético si nums[j] - nums[i] == diff y nums[k] - nums[j] == diff.\nLa función toma una cadena que representa el array y un entero diff, con elementos separados por espacios.\nDevuelve el conteo de tríos aritméticos distintos.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "arb": "احسب عدد الثلاثيات الحسابية المختلفة في مصفوفة أعداد صحيحة تزداد بصرامة.\nالثلاثية (i, j, k) تكون حسابية إذا كان nums[j] - nums[i] == diff و nums[k] - nums[j] == diff.\nتأخذ الدالة سلسلة تمثل المصفوفة وعددًا صحيحًا diff، مع العناصر مفصولة بمسافات.\nتعيد عدد الثلاثيات الحسابية المختلفة.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "sw": "Hesabu idadi ya tatu za hesabu tofauti katika safu ya nambari za mzima zinazoongezeka kwa utaratibu. \nTatu (i, j, k) ni hesabu ikiwa nums[j] - nums[i] == diff na nums[k] - nums[j] == diff. \nKazi inachukua kamba inayowakilisha safu na nambari mzima diff, na vipengele vimetenganishwa na nafasi. \nInarudisha hesabu ya tatu za hesabu tofauti.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "tr": "Tamamen artan bir tam sayı dizisinde farklı aritmetik üçlülerin sayısını sayın.\nBir üçlü (i, j, k), nums[j] - nums[i] == diff ve nums[k] - nums[j] == diff olduğunda aritmetiktir.\nFonksiyon, diziyi temsil eden bir dize ve bir tam sayı diff alır, elemanlar boşluklarla ayrılmıştır.\nFarklı aritmetik üçlülerin sayısını döndürür.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "vi": "Đếm số bộ ba số học khác nhau trong một mảng số nguyên tăng chặt chẽ.  \nMột bộ ba (i, j, k) là số học nếu nums[j] - nums[i] == diff và nums[k] - nums[j] == diff.  \nHàm nhận một chuỗi đại diện cho mảng và một số nguyên diff, với các phần tử được ngăn cách bằng dấu cách.  \nTrả về số lượng bộ ba số học khác nhau.  \n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1  \n3  \n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2  \n4  "
    },
    "docstring_bertscore": {
      "es": "0.9953977340714216",
      "arb": "0.9797663176055",
      "sw": "0.9533788673761583",
      "tr": "0.9977292574840092",
      "vi": "0.9862152501865598"
    }
  },
  {
    "task_id": "Shell/10",
    "prompt": {
      "en": "#!/bin/bash\n\n# Generate a matrix of maximum values from each 3x3 sub-matrix in a given n x n matrix.\n# The function takes a string representing the n x n matrix, where rows are separated by semicolons and elements by spaces.\n# Returns the (n-2) x (n-2) matrix of maximum values.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "es": "#!/bin/bash\n\n# Generar una matriz de valores máximos de cada submatriz 3x3 en una matriz n x n dada.\n# La función toma una cadena que representa la matriz n x n, donde las filas están separadas por puntos y coma y los elementos por espacios.\n# Devuelve la matriz (n-2) x (n-2) de valores máximos.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "arb": "#!/bin/bash\n\n# توليد مصفوفة من القيم القصوى من كل مصفوفة فرعية 3x3 في مصفوفة n x n معينة.\n# تأخذ الدالة سلسلة تمثل المصفوفة n x n، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.\n# تعيد المصفوفة (n-2) x (n-2) من القيم القصوى.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "sw": "#!/bin/bash\n\n# Tengeneza matrix ya thamani za juu zaidi kutoka kila sub-matrix ya 3x3 katika matrix iliyotolewa ya n x n.\n# Kazi inachukua kamba inayowakilisha matrix ya n x n, ambapo mistari imetenganishwa na alama ya semicolon na vipengele kwa nafasi.\n# Inarudisha matrix ya (n-2) x (n-2) ya thamani za juu zaidi.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "tr": "#!/bin/bash\n\n# Verilen n x n matrisinde her 3x3 alt matristen maksimum değerlerin bir matrisini oluşturun.\n# Fonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı n x n matrisini temsil eden bir dize alır.\n# Maksimum değerlerin (n-2) x (n-2) matrisini döndürür.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "vi": "#!/bin/bash\n\n# Tạo một ma trận các giá trị lớn nhất từ mỗi ma trận con 3x3 trong một ma trận n x n cho trước.\n# Hàm nhận một chuỗi đại diện cho ma trận n x n, trong đó các hàng được phân tách bằng dấu chấm phẩy và các phần tử bằng dấu cách.\n# Trả về ma trận (n-2) x (n-2) của các giá trị lớn nhất.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\""
    },
    "prompt_bertscore": {
      "es": "0.9969575784536886",
      "arb": "0.9744102493808943",
      "sw": "0.9762694297473808",
      "tr": "0.984855625228376",
      "vi": "0.9847596867543361"
    },
    "canonical_solution": "local -a maxLocal\nlocal n=${#grid[@]}\n\nfor (( i=0; i<n-2; i++ )); do\nlocal row=\"\"\nfor (( j=0; j<n-2; j++ )); do\nlocal max=0\nfor (( x=i; x<=i+2; x++ )); do\nIFS=' ' read -ra rowVals <<< \"${grid[x]}\"\nfor (( y=j; y<=j+2; y++ )); do\nmax=$((max < rowVals[y] ? rowVals[y] : max))\ndone\ndone\nrow+=\"$max \"\ndone\nmaxLocal+=(\"${row% }\")\ndone\n\necho \"${maxLocal[@]}\"\n}",
    "instruction": {
      "en": "Write a Shell function `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` to solve the following problem:\n\nGenerate a matrix of maximum values from each 3x3 sub-matrix in a given n x n matrix.\nThe function takes a string representing the n x n matrix, where rows are separated by semicolons and elements by spaces.\nReturns the (n-2) x (n-2) matrix of maximum values.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8\n",
      "es": "Escribe una función de Shell `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` para resolver el siguiente problema:\n\nGenerar una matriz de valores máximos de cada submatriz 3x3 en una matriz n x n dada.\nLa función toma una cadena que representa la matriz n x n, donde las filas están separadas por punto y coma y los elementos por espacios.\nDevuelve la matriz (n-2) x (n-2) de valores máximos.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8\n",
      "arb": "اكتب دالة شيل `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` لحل المشكلة التالية:\n\nتوليد مصفوفة من القيم القصوى من كل مصفوفة فرعية 3x3 في مصفوفة n x n معطاة.\nتأخذ الدالة سلسلة تمثل المصفوفة n x n، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.\nتُرجع المصفوفة (n-2) x (n-2) للقيم القصوى.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8\n",
      "sw": "Andika kazi ya Shell `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` kutatua tatizo lifuatalo:\n\nTengeneza matriki ya thamani za juu zaidi kutoka kwa kila sub-matrix ya 3x3 katika matriki iliyotolewa ya n x n.\nKazi inachukua kamba inayowakilisha matriki ya n x n, ambapo mistari imetenganishwa na alama za nukta mkato na vipengele kwa nafasi.\nInarudisha matriki ya (n-2) x (n-2) ya thamani za juu zaidi.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8\n",
      "tr": "Bir Shell fonksiyonu yazın `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` aşağıdaki problemi çözmek için:\n\nVerilen bir n x n matrisinde her 3x3 alt matristen maksimum değerlerin bir matrisini oluşturun.\nFonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı n x n matrisini temsil eden bir dize alır.\nMaksimum değerlerin (n-2) x (n-2) matrisini döndürür.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "vi": "Viết một hàm Shell `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` để giải quyết vấn đề sau:\n\nTạo một ma trận các giá trị lớn nhất từ mỗi ma trận con 3x3 trong một ma trận n x n cho trước.\nHàm nhận một chuỗi đại diện cho ma trận n x n, trong đó các hàng được phân tách bằng dấu chấm phẩy và các phần tử bằng dấu cách.\nTrả về ma trận (n-2) x (n-2) của các giá trị lớn nhất.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8"
    },
    "instruction_bertscore": {
      "es": "0.9960124951007246",
      "arb": "0.9950779391579555",
      "sw": "0.9756199084013968",
      "tr": "0.985220509238337",
      "vi": "0.9848738992234312"
    },
    "level": "easy",
    "test": "# Testing function\ntest_generate_max_local() {\n[[ $(generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\") == \"11 12 15 16\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(generate_max_local \"9 1 7;4 8 2;3 6 5\") == \"9\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(generate_max_local \"1 2 3;4 5 6;7 8 9\") == \"9\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(generate_max_local \"5 6 7;8 9 10;11 12 13\") == \"13\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(generate_max_local \"10 20 30;40 50 60;70 80 90\") == \"90\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_generate_max_local",
    "entry_point": "generate_max_local",
    "signature": "generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
    "docstring": {
      "en": "\nGenerate a matrix of maximum values from each 3x3 sub-matrix in a given n x n matrix.\nThe function takes a string representing the n x n matrix, where rows are separated by semicolons and elements by spaces.\nReturns the (n-2) x (n-2) matrix of maximum values.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8\n",
      "es": "Genera una matriz de valores máximos de cada submatriz 3x3 en una matriz n x n dada.\nLa función toma una cadena que representa la matriz n x n, donde las filas están separadas por punto y coma y los elementos por espacios.\nDevuelve la matriz (n-2) x (n-2) de valores máximos.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "arb": "إنشاء مصفوفة من القيم القصوى من كل مصفوفة فرعية 3x3 في مصفوفة n x n معينة.  \nتأخذ الدالة سلسلة تمثل المصفوفة n x n، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.  \nتعيد مصفوفة (n-2) x (n-2) من القيم القصوى.  \n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"  \n11 12;15 16  \n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"  \n9 8  ",
      "sw": "Tengeneza matrix ya thamani za juu zaidi kutoka kila matrix ndogo ya 3x3 katika matrix iliyotolewa ya n x n. \nKazi inachukua kamba inayowakilisha matrix ya n x n, ambapo mistari imetenganishwa na alama ya nukta mkato na vipengele kwa nafasi. \nInarejesha matrix ya (n-2) x (n-2) ya thamani za juu zaidi.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "tr": "Her bir 3x3 alt matristen maksimum değerlerin matrisini, verilen bir n x n matristen oluşturun.\nFonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı n x n matrisi temsil eden bir dize alır.\nMaksimum değerlerin (n-2) x (n-2) matrisini döndürür.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "vi": "Tạo một ma trận các giá trị lớn nhất từ mỗi ma trận con 3x3 trong một ma trận n x n cho trước. Hàm nhận một chuỗi ký tự đại diện cho ma trận n x n, trong đó các hàng được ngăn cách bởi dấu chấm phẩy và các phần tử được ngăn cách bởi dấu cách. Trả về ma trận (n-2) x (n-2) của các giá trị lớn nhất.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8"
    },
    "docstring_bertscore": {
      "es": "0.9968618386100297",
      "arb": "0.9523908798608908",
      "sw": "0.9670561581534586",
      "tr": "0.9857393317936002",
      "vi": "0.964672990841802"
    }
  },
  {
    "task_id": "Shell/11",
    "prompt": {
      "en": "#!/bin/bash\n\n# Find the maximum amount of water that can be contained between two lines.\n# The function takes a string representing the array of line heights, with elements separated by spaces.\n# Returns the maximum water container capacity.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "es": "#!/bin/bash\n\n# Encuentra la cantidad máxima de agua que se puede contener entre dos líneas.\n# La función toma una cadena que representa el arreglo de alturas de las líneas, con elementos separados por espacios.\n# Devuelve la capacidad máxima del contenedor de agua.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "arb": "#!/bin/bash\n\n# إيجاد الحد الأقصى لكمية الماء التي يمكن احتواؤها بين خطين.\n# تأخذ الدالة سلسلة نصية تمثل مصفوفة ارتفاعات الخطوط، مع العناصر مفصولة بمسافات.\n# تعيد سعة حاوية الماء القصوى.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "sw": "#!/bin/bash\n\n# Tafuta kiasi cha juu zaidi cha maji kinachoweza kushikiliwa kati ya mistari miwili.\n# Kazi inachukua kamba inayowakilisha safu ya urefu wa mistari, na vipengele vimetenganishwa kwa nafasi.\n# Inarudisha uwezo wa juu zaidi wa chombo cha maji.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "tr": "#!/bin/bash\n\n# İki çizgi arasında tutulabilecek maksimum su miktarını bulun.\n# Fonksiyon, elemanları boşluklarla ayrılmış çizgi yüksekliklerini temsil eden bir dize alır.\n# Maksimum su kabı kapasitesini döndürür.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "vi": "#!/bin/bash\n\n# Tìm lượng nước tối đa có thể chứa giữa hai đường thẳng.\n# Hàm nhận một chuỗi đại diện cho mảng chiều cao của các đường thẳng, với các phần tử được ngăn cách bằng dấu cách.\n# Trả về dung tích chứa nước tối đa.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)"
    },
    "prompt_bertscore": {
      "es": "0.9908095708998967",
      "arb": "0.9971683252879666",
      "sw": "0.9765056012704314",
      "tr": "0.9652496148379464",
      "vi": "0.9913681195313668"
    },
    "canonical_solution": "local max_capacity=0\nlocal left=0\nlocal right=$((${#heights[@]} - 1))\n\nwhile (( left < right )); do\nlocal width=$((right - left))\nlocal height=$((heights[left] < heights[right] ? heights[left] : heights[right]))\nmax_capacity=$((max_capacity > width * height ? max_capacity : width * height))\n\nif (( heights[left] < heights[right] )); then\n((left++))\nelse\n((right--))\nfi\ndone\n\necho $max_capacity\n}",
    "instruction": {
      "en": "Write a Shell function `max_water_container() {\nlocal -a heights=($1)` to solve the following problem:\n\nFind the maximum amount of water that can be contained between two lines.\nThe function takes a string representing the array of line heights, with elements separated by spaces.\nReturns the maximum water container capacity.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1\n",
      "es": "Escribe una función Shell `max_water_container() {\nlocal -a heights=($1)` para resolver el siguiente problema:\n\nEncuentra la cantidad máxima de agua que se puede contener entre dos líneas.  \nLa función toma una cadena que representa el array de alturas de las líneas, con elementos separados por espacios.  \nDevuelve la capacidad máxima del contenedor de agua.  \n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"  \n49  \n>>> max_water_container \"1 1\"  \n1  ",
      "arb": "اكتب دالة Shell `max_water_container() { local -a heights=($1)` لحل المشكلة التالية:\n\nابحث عن أقصى كمية من الماء يمكن احتواؤها بين خطين. تأخذ الدالة سلسلة تمثل مصفوفة ارتفاعات الخطوط، مع العناصر مفصولة بمسافات. تُرجع سعة حاوية الماء القصوى.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "sw": "Andika kazi ya Shell `max_water_container() {\nlocal -a heights=($1)` kutatua tatizo lifuatalo:\n\nPata kiasi cha juu zaidi cha maji kinachoweza kushikiliwa kati ya mistari miwili. \nKazi inachukua kamba inayowakilisha safu ya urefu wa mistari, na vipengele vimetenganishwa na nafasi. \nInarudisha uwezo wa juu wa kontena la maji. \n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "tr": "Bir Shell fonksiyonu `max_water_container() {\nlocal -a heights=($1)` yazın ve aşağıdaki problemi çözün:\n\nİki çizgi arasında tutulabilecek maksimum su miktarını bulun.\nFonksiyon, elemanları boşluklarla ayrılmış çizgi yüksekliklerini temsil eden bir dize alır.\nMaksimum su kabı kapasitesini döndürür.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1\n",
      "vi": "Viết một hàm Shell `max_water_container() {\nlocal -a heights=($1)` để giải quyết vấn đề sau:\n\nTìm lượng nước tối đa có thể chứa giữa hai đường thẳng.  \nHàm nhận một chuỗi đại diện cho mảng chiều cao của các đường thẳng, với các phần tử được phân tách bằng dấu cách.  \nTrả về dung tích chứa nước tối đa.  \n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1"
    },
    "instruction_bertscore": {
      "es": "0.9915651608693534",
      "arb": "0.9934533412714711",
      "sw": "0.9790903784188384",
      "tr": "0.9657009030636575",
      "vi": "0.9922071342608583"
    },
    "level": "middle",
    "test": "test_max_water_container() {\n[[ $(max_water_container \"1 8 6 2 5 4 8 3 7\") == \"49\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(max_water_container \"1 1\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(max_water_container \"4 3 2 1 4\") == \"16\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(max_water_container \"1 2 1\") == \"2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(max_water_container \"2 3 4 5 18 17 6\") == \"17\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(max_water_container \"1 2 4 3\") == \"4\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(max_water_container \"3 9 3 4 7 2 12 6\") == \"45\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_max_water_container",
    "entry_point": "max_water_container",
    "signature": "max_water_container() {\nlocal -a heights=($1)",
    "docstring": {
      "en": "\nFind the maximum amount of water that can be contained between two lines.\nThe function takes a string representing the array of line heights, with elements separated by spaces.\nReturns the maximum water container capacity.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1\n",
      "es": "Encuentra la cantidad máxima de agua que se puede contener entre dos líneas.\nLa función toma una cadena que representa el arreglo de alturas de las líneas, con elementos separados por espacios.\nDevuelve la capacidad máxima del contenedor de agua.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "arb": "اكتشف أقصى كمية من الماء التي يمكن احتواؤها بين خطين.\nتأخذ الدالة سلسلة نصية تمثل مصفوفة ارتفاعات الخطوط، مع عناصر مفصولة بمسافات.\nتعيد أقصى سعة لحاوية الماء.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "sw": "Pata kiasi cha juu zaidi cha maji kinachoweza kushikiliwa kati ya mistari miwili. \nKazi inachukua kamba inayowakilisha safu ya urefu wa mistari, na vipengele vimetenganishwa na nafasi. \nInarudisha uwezo wa juu zaidi wa chombo cha maji. \n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "tr": "İki çizgi arasında tutulabilecek maksimum su miktarını bulun.  \nFonksiyon, elemanları boşluklarla ayrılmış çizgi yüksekliklerini temsil eden bir dize alır.  \nMaksimum su kap kapasitesini döndürür.  \n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"  \n49  \n>>> max_water_container \"1 1\"  \n1  ",
      "vi": "Tìm lượng nước tối đa có thể chứa giữa hai đường thẳng. Hàm nhận một chuỗi đại diện cho mảng chiều cao của các đường thẳng, với các phần tử được phân tách bằng dấu cách. Trả về dung tích chứa nước tối đa.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1"
    },
    "docstring_bertscore": {
      "es": "0.9886736984126286",
      "arb": "0.9842384806345006",
      "sw": "0.9678252549888257",
      "tr": "0.9522526331156905",
      "vi": "0.9839147131134137"
    }
  },
  {
    "task_id": "Shell/12",
    "prompt": {
      "en": "#!/bin/bash\n\n# Find the next permutation of the array in lexicographic order.\n# If the array is in descending order, rearrange it to the first permutation (ascending order).\n# The function takes a string representing the array, with elements separated by spaces.\n# Returns the next permutation of the array.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "es": "#!/bin/bash\n\n# Encuentra la siguiente permutación del arreglo en orden lexicográfico.\n# Si el arreglo está en orden descendente, reorganízalo a la primera permutación (orden ascendente).\n# La función toma una cadena que representa el arreglo, con elementos separados por espacios.\n# Devuelve la siguiente permutación del arreglo.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "arb": "#!/bin/bash\n\n# إيجاد التبديل التالي للمصفوفة بترتيب معجمي.\n# إذا كانت المصفوفة بترتيب تنازلي، قم بإعادة ترتيبها إلى التبديل الأول (ترتيب تصاعدي).\n# تأخذ الدالة سلسلة تمثل المصفوفة، مع العناصر مفصولة بمسافات.\n# تعيد التبديل التالي للمصفوفة.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "sw": "#!/bin/bash\n\n# Tafuta mpangilio unaofuata wa safu katika mpangilio wa kamusi.\n# Ikiwa safu iko katika mpangilio wa kushuka, iipange upya kuwa mpangilio wa kwanza (mpangilio wa kupanda).\n# Kazi inachukua kamba inayowakilisha safu, na vipengele vilivyotenganishwa na nafasi.\n# Inarudisha mpangilio unaofuata wa safu.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "tr": "#!/bin/bash\n\n# Dizinin bir sonraki permütasyonunu sözlük sırasına göre bul.\n# Eğer dizi azalan sıradaysa, onu ilk permütasyona (artan sıraya) göre yeniden düzenle.\n# Fonksiyon, elemanları boşluklarla ayrılmış diziyi temsil eden bir dize alır.\n# Dizinin bir sonraki permütasyonunu döndürür.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "vi": "#!/bin/bash\n\n# Tìm hoán vị tiếp theo của mảng theo thứ tự từ điển.\n# Nếu mảng đang ở thứ tự giảm dần, sắp xếp lại thành hoán vị đầu tiên (thứ tự tăng dần).\n# Hàm nhận một chuỗi đại diện cho mảng, với các phần tử được ngăn cách bởi dấu cách.\n# Trả về hoán vị tiếp theo của mảng.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9987271765183284",
      "sw": "0.9761343610882771",
      "tr": "0.993145066920105",
      "vi": "0.9951933434093367"
    },
    "canonical_solution": "local i j n=${#nums[@]}\n\n# Find the first index i such that nums[i] < nums[i + 1]\nfor (( i=n-2; i>=0 && nums[i]>=nums[i+1]; i-- )); do :; done\n\n# If such index exists, find the first index j > i such that nums[i] < nums[j]\nif (( i >= 0 )); then\nfor (( j=n-1; j>i && nums[j]<=nums[i]; j-- )); do :; done\n# Swap nums[i] and nums[j]\nlocal temp=${nums[i]}\nnums[i]=${nums[j]}\nnums[j]=$temp\nfi\n\n# Reverse the subarray nums[i+1...end]\nfor (( j=i+1, k=n-1; j<k; j++, k-- )); do\nlocal temp=${nums[j]}\nnums[j]=${nums[k]}\nnums[k]=$temp\ndone\n\necho \"${nums[@]}\"\n}",
    "instruction": {
      "en": "Write a Shell function `next_permutation() {\nlocal -a nums=($1)` to solve the following problem:\n\nFind the next permutation of the array in lexicographic order.\nIf the array is in descending order, rearrange it to the first permutation (ascending order).\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the next permutation of the array.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3\n",
      "es": "Escribe una función de Shell `next_permutation() {\nlocal -a nums=($1)` para resolver el siguiente problema:\n\nEncuentra la siguiente permutación del arreglo en orden lexicográfico.\nSi el arreglo está en orden descendente, reorganízalo a la primera permutación (orden ascendente).\nLa función toma una cadena que representa el arreglo, con elementos separados por espacios.\nDevuelve la siguiente permutación del arreglo.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "arb": "اكتب دالة شل `next_permutation() { local -a nums=($1)` لحل المشكلة التالية:\n\nاعثر على الترتيب التالي للمصفوفة بترتيب معجمي.\nإذا كانت المصفوفة بترتيب تنازلي، أعد ترتيبها إلى الترتيب الأول (ترتيب تصاعدي).\nتأخذ الدالة سلسلة تمثل المصفوفة، مع العناصر مفصولة بمسافات.\nتعيد الترتيب التالي للمصفوفة.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "sw": "Andika kazi ya Shell `next_permutation() {\nlocal -a nums=($1)` kutatua tatizo lifuatalo:\n\nPata mpangilio unaofuata wa safu katika mpangilio wa alfabeti.\nIkiwa safu iko katika mpangilio wa kushuka, ipange upya kuwa mpangilio wa kwanza (mpangilio wa kupanda).\nKazi inachukua kamba inayowakilisha safu, na vipengele vilivyotenganishwa na nafasi.\nInarudisha mpangilio unaofuata wa safu.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "tr": "Bir Shell fonksiyonu `next_permutation() { local -a nums=($1)` yazın:\n\nDizinin sözlük sırasındaki bir sonraki permütasyonunu bulun.\nEğer dizi azalan sıradaysa, ilk permütasyona (artan sıra) yeniden düzenleyin.\nFonksiyon, elemanları boşluklarla ayrılmış diziyi temsil eden bir string alır.\nDizinin bir sonraki permütasyonunu döndürür.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3\n",
      "vi": "Viết một hàm Shell `next_permutation() {\nlocal -a nums=($1)` để giải quyết vấn đề sau:\n\nTìm hoán vị tiếp theo của mảng theo thứ tự từ điển.\nNếu mảng đang ở thứ tự giảm dần, sắp xếp lại nó thành hoán vị đầu tiên (thứ tự tăng dần).\nHàm nhận một chuỗi đại diện cho mảng, với các phần tử được ngăn cách bằng dấu cách.\nTrả về hoán vị tiếp theo của mảng.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9880710538365688",
      "sw": "0.9939334309024325",
      "tr": "0.9709443478622165",
      "vi": "0.9954084601119976"
    },
    "level": "hard",
    "test": "test_next_permutation() {\n[[ $(next_permutation \"1 2 3\") == \"1 3 2\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(next_permutation \"3 2 1\") == \"1 2 3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(next_permutation \"1 3 2\") == \"2 1 3\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(next_permutation \"2 3 1\") == \"3 1 2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(next_permutation \"1 1 5\") == \"1 5 1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(next_permutation \"2 1 3\") == \"2 3 1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(next_permutation \"5 4 3 2 1\") == \"1 2 3 4 5\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_next_permutation",
    "entry_point": "next_permutation",
    "signature": "next_permutation() {\nlocal -a nums=($1)",
    "docstring": {
      "en": "\nFind the next permutation of the array in lexicographic order.\nIf the array is in descending order, rearrange it to the first permutation (ascending order).\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the next permutation of the array.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3\n",
      "es": "Encuentra la siguiente permutación del arreglo en orden lexicográfico.  \nSi el arreglo está en orden descendente, reorganízalo a la primera permutación (orden ascendente).  \nLa función toma una cadena que representa el arreglo, con elementos separados por espacios.  \nDevuelve la siguiente permutación del arreglo.  \n>>> next_permutation \"1 2 3\"  \n1 3 2  \n>>> next_permutation \"3 2 1\"  \n1 2 3  ",
      "arb": "ابحث عن الترتيب التالي للمصفوفة بترتيب معجمي.  \nإذا كانت المصفوفة بترتيب تنازلي، أعد ترتيبها إلى الترتيب الأول (ترتيب تصاعدي).  \nتأخذ الدالة سلسلة تمثل المصفوفة، مع العناصر مفصولة بمسافات.  \nتعيد الترتيب التالي للمصفوفة.  \n>>> next_permutation \"1 2 3\"  \n1 3 2  \n>>> next_permutation \"3 2 1\"  \n1 2 3  ",
      "sw": "Pata mpangilio unaofuata wa safu katika mpangilio wa lexicographic. Ikiwa safu iko katika mpangilio wa kushuka, ipange upya kuwa mpangilio wa kwanza (mpangilio wa kupanda). Kazi inachukua kamba inayoonyesha safu, na vipengele vilivyotenganishwa na nafasi. Inarudisha mpangilio unaofuata wa safu. \n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "tr": "Dizinin sözlük sırasına göre bir sonraki permütasyonunu bulun.  \nEğer dizi azalan sıradaysa, onu ilk permütasyona (artan sıra) yeniden düzenleyin.  \nFonksiyon, elemanları boşluklarla ayrılmış diziyi temsil eden bir dize alır.  \nDizinin bir sonraki permütasyonunu döndürür.  \n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "vi": "Tìm hoán vị tiếp theo của mảng theo thứ tự từ điển. Nếu mảng đang ở thứ tự giảm dần, sắp xếp lại nó thành hoán vị đầu tiên (thứ tự tăng dần). Hàm nhận một chuỗi đại diện cho mảng, với các phần tử được ngăn cách bằng dấu cách. Trả về hoán vị tiếp theo của mảng.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9886498627669044",
      "sw": "0.9872091966132583",
      "tr": "0.9957272618735585",
      "vi": "0.9927335047706007"
    }
  },
  {
    "task_id": "Shell/13",
    "prompt": {
      "en": "#!/bin/bash\n\n# Perform modified binary search to find the target in a rotated sorted array.\n# The function takes a string representing the rotated array and an integer target.\n# Returns the index of the target if found, otherwise -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "es": "#!/bin/bash\n\n# Realiza una búsqueda binaria modificada para encontrar el objetivo en un array ordenado y rotado.\n# La función toma una cadena que representa el array rotado y un objetivo entero.\n# Devuelve el índice del objetivo si se encuentra, de lo contrario -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "arb": "#!/bin/bash\n\n# تنفيذ بحث ثنائي معدل للعثور على الهدف في مصفوفة مرتبة ومُدوّرة.\n# تأخذ الدالة سلسلة تمثل المصفوفة المدورة وعدد صحيح كهدف.\n# تعيد فهرس الهدف إذا تم العثور عليه، وإلا تعيد -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "sw": "#!/bin/bash\n\n# Fanya utafutaji wa binary uliobadilishwa ili kupata lengo katika safu iliyopangwa iliyozungushwa.\n# Kazi inachukua kamba inayowakilisha safu iliyozungushwa na lengo la nambari nzima.\n# Inarudisha index ya lengo ikiwa limepatikana, vinginevyo -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "tr": "#!/bin/bash\n\n# Döndürülmüş sıralı bir dizide hedefi bulmak için değiştirilmiş ikili arama yapar.\n# Fonksiyon, döndürülmüş diziyi temsil eden bir string ve bir tamsayı hedefi alır.\n# Hedef bulunursa indeksini, aksi takdirde -1 döndürür.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "vi": "#!/bin/bash\n\n# Thực hiện tìm kiếm nhị phân đã chỉnh sửa để tìm mục tiêu trong một mảng đã sắp xếp và xoay vòng.\n# Hàm nhận một chuỗi đại diện cho mảng đã xoay vòng và một số nguyên mục tiêu.\n# Trả về chỉ số của mục tiêu nếu tìm thấy, nếu không thì -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2"
    },
    "prompt_bertscore": {
      "es": "0.9828677323749788",
      "arb": "0.972358794805566",
      "sw": "0.9915633731959241",
      "tr": "0.9778215275447875",
      "vi": "0.9890389796833517"
    },
    "canonical_solution": "local left=0\nlocal right=$((${#nums[@]} - 1))\n\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\n\nif (( nums[mid] == target )); then\necho $mid\nreturn\nfi\n\nif (( nums[left] <= nums[mid] )); then\nif (( nums[left] <= target && target < nums[mid] )); then\nright=$((mid - 1))\nelse\nleft=$((mid + 1))\nfi\nelse\nif (( nums[mid] < target && target <= nums[right] )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\nfi\ndone\n\necho -1\n}",
    "instruction": {
      "en": "Write a Shell function `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` to solve the following problem:\n\nPerform modified binary search to find the target in a rotated sorted array.\nThe function takes a string representing the rotated array and an integer target.\nReturns the index of the target if found, otherwise -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1\n",
      "es": "Escribe una función Shell `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` para resolver el siguiente problema:\n\nRealizar una búsqueda binaria modificada para encontrar el objetivo en un array ordenado rotado.\nLa función toma una cadena que representa el array rotado y un objetivo entero.\nDevuelve el índice del objetivo si se encuentra, de lo contrario -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "arb": "اكتب دالة Shell `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` لحل المشكلة التالية:\n\nقم بتنفيذ بحث ثنائي معدل للعثور على الهدف في مصفوفة مرتبة ومدورة.\nتأخذ الدالة سلسلة تمثل المصفوفة المدورة وعددًا صحيحًا كهدف.\nتُرجع مؤشر الهدف إذا تم العثور عليه، وإلا -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "sw": "Andika kazi ya Shell `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` kutatua tatizo lifuatalo:\n\nFanya utafutaji wa binary uliobadilishwa ili kupata lengo katika safu iliyopangwa iliyozungushwa.\nKazi inachukua kamba inayowakilisha safu iliyozungushwa na lengo la nambari nzima.\nInarudisha faharasa ya lengo ikiwa limepatikana, vinginevyo -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "tr": "Bir Shell fonksiyonu `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` oluşturun ve aşağıdaki problemi çözün:\n\nDöndürülmüş sıralı bir dizide hedefi bulmak için değiştirilmiş ikili arama gerçekleştirin.\nFonksiyon, döndürülmüş diziyi temsil eden bir dize ve bir tam sayı hedefi alır.\nHedef bulunursa indeksini döndürür, aksi takdirde -1 döndürür.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "vi": "Viết một hàm Shell `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` để giải quyết vấn đề sau:\n\nThực hiện tìm kiếm nhị phân đã được sửa đổi để tìm mục tiêu trong một mảng đã sắp xếp và xoay vòng.\nHàm nhận một chuỗi đại diện cho mảng đã xoay vòng và một số nguyên mục tiêu.\nTrả về chỉ số của mục tiêu nếu tìm thấy, nếu không thì -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1"
    },
    "instruction_bertscore": {
      "es": "0.9966755233126191",
      "arb": "0.971886451759465",
      "sw": "0.9919731476719992",
      "tr": "0.9622937961377661",
      "vi": "0.9889571439663654"
    },
    "level": "middle",
    "test": "test_search_rotated_array() {\n[[ $(search_rotated_array \"4 5 6 7 0 1 2\" 0) == \"4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(search_rotated_array \"4 5 6 7 0 1 2\" 3) == \"-1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(search_rotated_array \"0 1 2 4 5 6 7\" 3) == \"-1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(search_rotated_array \"6 7 0 1 2 4 5\" 3) == \"-1\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(search_rotated_array \"7 0 1 2 4 5 6\" 0) == \"1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(search_rotated_array \"1\" 0) == \"-1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(search_rotated_array \"1 3\" 3) == \"1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_search_rotated_array",
    "entry_point": "search_rotated_array",
    "signature": "search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
    "docstring": {
      "en": "\nPerform modified binary search to find the target in a rotated sorted array.\nThe function takes a string representing the rotated array and an integer target.\nReturns the index of the target if found, otherwise -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1\n",
      "es": "Realiza una búsqueda binaria modificada para encontrar el objetivo en un array ordenado y rotado.  \nLa función toma una cadena que representa el array rotado y un entero objetivo.  \nDevuelve el índice del objetivo si se encuentra, de lo contrario -1.  \n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0  \n4  \n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3  \n-1  ",
      "arb": "قم بإجراء بحث ثنائي معدل للعثور على الهدف في مصفوفة مرتبة ومدورة.\nتأخذ الدالة سلسلة تمثل المصفوفة المدورة وعددًا صحيحًا كهدف.\nتُرجع فهرس الهدف إذا تم العثور عليه، وإلا -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "sw": "Fanya utafutaji wa binary uliobadilishwa ili kupata lengo katika safu iliyopangwa iliyozungushwa. \nKazi inachukua kamba inayowakilisha safu iliyozungushwa na lengo la nambari nzima. \nInarudisha faharasa ya lengo ikiwa limepatikana, vinginevyo -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "tr": "Döndürülmüş sıralı bir dizide hedefi bulmak için değiştirilmiş ikili arama gerçekleştirir.\nFonksiyon, döndürülmüş diziyi temsil eden bir dize ve bir tamsayı hedefi alır.\nHedef bulunursa indeksini, aksi takdirde -1 döndürür.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "vi": "Thực hiện tìm kiếm nhị phân đã được sửa đổi để tìm mục tiêu trong một mảng đã được xoay vòng và sắp xếp.\nHàm nhận một chuỗi đại diện cho mảng đã xoay vòng và một số nguyên mục tiêu.\nTrả về chỉ số của mục tiêu nếu tìm thấy, nếu không trả về -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1"
    },
    "docstring_bertscore": {
      "es": "0.9654849918394727",
      "arb": "0.9593842583163671",
      "sw": "0.9806627365151105",
      "tr": "0.9468671675946916",
      "vi": "0.9731423916587486"
    }
  },
  {
    "task_id": "Shell/14",
    "prompt": {
      "en": "#!/bin/bash\n\n# Find the start and end positions of the target value in a non-decreasing array.\n# The function takes a string representing the array and an integer target.\n# Returns the start and end positions of the target, or [-1, -1] if not found.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "es": "#!/bin/bash\n\n# Encuentra las posiciones de inicio y fin del valor objetivo en un arreglo no decreciente.\n# La función toma una cadena que representa el arreglo y un objetivo entero.\n# Devuelve las posiciones de inicio y fin del objetivo, o [-1, -1] si no se encuentra.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "arb": "#!/bin/bash\n\n# إيجاد مواضع البداية والنهاية للقيمة المستهدفة في مصفوفة غير متناقصة.\n# تأخذ الدالة سلسلة تمثل المصفوفة وعددًا صحيحًا كهدف.\n# تعيد مواضع البداية والنهاية للهدف، أو [-1, -1] إذا لم يتم العثور عليه.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "sw": "#!/bin/bash\n\n# Tafuta nafasi za mwanzo na mwisho za thamani lengwa katika safu isiyopungua.\n# Kazi inachukua kamba inayowakilisha safu na nambari lengwa.\n# Inarejesha nafasi za mwanzo na mwisho za lengwa, au [-1, -1] ikiwa haijapatikana.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "tr": "#!/bin/bash\n\n# Hedef değerin, azalmayan bir dizideki başlangıç ve bitiş pozisyonlarını bulun.\n# Fonksiyon, diziyi temsil eden bir dize ve bir tamsayı hedefi alır.\n# Hedefin başlangıç ve bitiş pozisyonlarını döndürür, bulunamazsa [-1, -1] döndürür.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "vi": "#!/bin/bash\n\n# Tìm vị trí bắt đầu và kết thúc của giá trị mục tiêu trong một mảng không giảm.\n# Hàm nhận một chuỗi đại diện cho mảng và một số nguyên mục tiêu.\n# Trả về vị trí bắt đầu và kết thúc của mục tiêu, hoặc [-1, -1] nếu không tìm thấy.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2"
    },
    "prompt_bertscore": {
      "es": "0.9957006454024998",
      "arb": "0.9759122923222802",
      "sw": "0.984895549934964",
      "tr": "0.995496850631558",
      "vi": "0.9999996027392379"
    },
    "canonical_solution": "local n=${#nums[@]}\nlocal start=-1 end=-1\n\n# Binary search for the starting position\nlocal left=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nstart=$mid\nright=$((mid - 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\n# Binary search for the ending position\nleft=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nend=$mid\nleft=$((mid + 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\necho \"$start $end\"\n}",
    "instruction": {
      "en": "Write a Shell function `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` to solve the following problem:\n\nFind the start and end positions of the target value in a non-decreasing array.\nThe function takes a string representing the array and an integer target.\nReturns the start and end positions of the target, or [-1, -1] if not found.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1\n",
      "es": "Escribe una función Shell `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` para resolver el siguiente problema:\n\nEncuentra las posiciones de inicio y fin del valor objetivo en un arreglo no decreciente.\nLa función toma una cadena que representa el arreglo y un objetivo entero.\nDevuelve las posiciones de inicio y fin del objetivo, o [-1, -1] si no se encuentra.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "arb": "اكتب دالة Shell `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` لحل المشكلة التالية:\n\nابحث عن مواضع البداية والنهاية لقيمة الهدف في مصفوفة غير متناقصة.\nتأخذ الدالة سلسلة تمثل المصفوفة وعددًا صحيحًا كهدف.\nتعيد مواضع البداية والنهاية للهدف، أو [-1, -1] إذا لم يتم العثور عليه.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "sw": "Andika kazi ya Shell `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` kutatua tatizo lifuatalo:\n\nPata nafasi za mwanzo na mwisho za thamani lengwa katika safu isiyopungua.\nKazi inachukua kamba inayowakilisha safu na lengo la nambari nzima.\nInarudisha nafasi za mwanzo na mwisho za lengo, au [-1, -1] ikiwa halijapatikana.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "tr": "Bir Shell fonksiyonu `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` yazın:\n\nBir hedef değerin başlangıç ve bitiş pozisyonlarını artmayan bir dizide bulun.\nFonksiyon, diziyi temsil eden bir string ve bir tamsayı hedef alır.\nHedefin başlangıç ve bitiş pozisyonlarını döndürür veya bulunamazsa [-1, -1] döndürür.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "vi": "Viết một hàm Shell `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` để giải quyết vấn đề sau:\n\nTìm vị trí bắt đầu và kết thúc của giá trị mục tiêu trong một mảng không giảm.\nHàm nhận một chuỗi đại diện cho mảng và một số nguyên mục tiêu.\nTrả về vị trí bắt đầu và kết thúc của mục tiêu, hoặc [-1, -1] nếu không tìm thấy.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9756357988318796",
      "sw": "0.9930701832664548",
      "tr": "0.963585290875255",
      "vi": "0.9912346399153115"
    },
    "level": "hard",
    "test": "test_find_target_positions() {\n[[ $(find_target_positions \"5 7 7 8 8 10\" 8) == \"3 4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_target_positions \"5 7 7 8 8 10\" 6) == \"-1 -1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 4 5\" 5) == \"4 4\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 4 5\" 1) == \"0 0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_target_positions \"1 1 1 1 1\" 1) == \"0 4\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 3 3 4 5\" 3) == \"2 4\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 2 3 4 5\" 2) == \"1 2\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_find_target_positions",
    "entry_point": "find_target_positions",
    "signature": "find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
    "docstring": {
      "en": "\nFind the start and end positions of the target value in a non-decreasing array.\nThe function takes a string representing the array and an integer target.\nReturns the start and end positions of the target, or [-1, -1] if not found.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1\n",
      "es": "Encuentra las posiciones de inicio y fin del valor objetivo en un arreglo no decreciente.  \nLa función toma una cadena que representa el arreglo y un entero objetivo.  \nDevuelve las posiciones de inicio y fin del objetivo, o [-1, -1] si no se encuentra.  \n>>> find_target_positions \"5 7 7 8 8 10\" 8  \n3 4  \n>>> find_target_positions \"5 7 7 8 8 10\" 6  \n-1 -1  ",
      "arb": "ابحث عن مواضع البداية والنهاية للقيمة المستهدفة في مصفوفة غير متناقصة.\nتأخذ الدالة سلسلة تمثل المصفوفة وعددًا صحيحًا كهدف.\nتعيد مواضع البداية والنهاية للهدف، أو [-1, -1] إذا لم يتم العثور عليه.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "sw": "Pata nafasi za mwanzo na mwisho za thamani lengwa katika safu isiyopungua.\nKazi inachukua kamba inayowakilisha safu na lengo la nambari nzima.\nInarejesha nafasi za mwanzo na mwisho za lengo, au [-1, -1] ikiwa halijapatikana.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "tr": "Hedef değerin başlangıç ve bitiş pozisyonlarını artmayan bir dizide bulun.\nFonksiyon, diziyi temsil eden bir dize ve bir tamsayı hedef alır.\nHedefin başlangıç ve bitiş pozisyonlarını döndürür veya bulunamazsa [-1, -1] döndürür.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "vi": "Tìm vị trí bắt đầu và kết thúc của giá trị mục tiêu trong một mảng không giảm dần. Hàm nhận một chuỗi đại diện cho mảng và một số nguyên mục tiêu. Trả về vị trí bắt đầu và kết thúc của mục tiêu, hoặc [-1, -1] nếu không tìm thấy.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1"
    },
    "docstring_bertscore": {
      "es": "0.9964633860656739",
      "arb": "0.9796592558301223",
      "sw": "0.9910409752938024",
      "tr": "0.9891758360158848",
      "vi": "0.9951871858675246"
    }
  },
  {
    "task_id": "Shell/15",
    "prompt": {
      "en": "#!/bin/bash\n\n# Validate a 9x9 Sudoku board.\n# The function takes a 9x9 Sudoku board as a string, where rows are separated by semicolons and elements by spaces.\n# Returns \"true\" if the Sudoku is valid, \"false\" otherwise.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Convert string to 2D array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "es": "#!/bin/bash\n\n# Validar un tablero de Sudoku de 9x9.\n# La función toma un tablero de Sudoku de 9x9 como una cadena, donde las filas están separadas por puntos y comas y los elementos por espacios.\n# Devuelve \"true\" si el Sudoku es válido, \"false\" en caso contrario.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Convertir cadena a matriz 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "arb": "#!/bin/bash\n\n# التحقق من صحة لوحة سودوكو بحجم 9x9.\n# تأخذ الدالة لوحة سودوكو بحجم 9x9 كـ سلسلة نصية، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.\n# تعيد \"true\" إذا كانت السودوكو صحيحة، و\"false\" خلاف ذلك.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# تحويل السلسلة النصية إلى مصفوفة ثنائية الأبعاد\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "sw": "#!/bin/bash\n\n# Thibitisha ubao wa Sudoku wa 9x9.\n# Kazi inachukua ubao wa Sudoku wa 9x9 kama kamba, ambapo mistari imetenganishwa na nukta na koma na vipengele kwa nafasi.\n# Inarudisha \"true\" ikiwa Sudoku ni sahihi, \"false\" vinginevyo.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Badilisha kamba kuwa safu ya 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "tr": "#!/bin/bash\n\n# 9x9 bir Sudoku tahtasını doğrulayın.\n# Fonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı bir 9x9 Sudoku tahtasını bir dize olarak alır.\n# Sudoku geçerliyse \"true\", aksi takdirde \"false\" döndürür.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Dizeyi 2D diziye dönüştür\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "vi": "#!/bin/bash\n\n# Xác thực một bảng Sudoku 9x9.\n# Hàm nhận một bảng Sudoku 9x9 dưới dạng chuỗi, trong đó các hàng được ngăn cách bằng dấu chấm phẩy và các phần tử bằng dấu cách.\n# Trả về \"true\" nếu Sudoku hợp lệ, \"false\" nếu không.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Chuyển đổi chuỗi thành mảng 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\""
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9896136173756857",
      "sw": "0.9895913707730097",
      "tr": "0.9945658700356476",
      "vi": "0.9932811287311138"
    },
    "canonical_solution": "for i in ${!grid[@]}; do\nIFS=' ' read -ra gridRow <<< \"${grid[i]}\"\nfor j in ${!gridRow[@]}; do\nlocal num=${gridRow[j]}\nif [[ \"$num\" != \".\" ]]; then\nlocal boxIndex=$((i / 3 * 3 + j / 3))\n\n# Check if the number has been seen before in the row, column, or box\nif [[ -n ${rowSeen[$i,$num]} || -n ${colSeen[$j,$num]} || -n ${boxSeen[$boxIndex,$num]} ]]; then\necho \"false\"\nreturn\nfi\n\n# Mark the number as seen for the row, column, and box\nrowSeen[$i,$num]=1\ncolSeen[$j,$num]=1\nboxSeen[$boxIndex,$num]=1\nfi\ndone\ndone\n\necho \"true\"\n}",
    "instruction": {
      "en": "Write a Shell function `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` to solve the following problem:\nConvert string to 2D array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "es": "Escribe una función Shell `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` para resolver el siguiente problema:\nConvertir cadena a un array 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "arb": "اكتب دالة شل `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` لحل المشكلة التالية:\nتحويل سلسلة إلى مصفوفة ثنائية الأبعاد\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "sw": "Andika kazi ya Shell `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` kutatua tatizo lifuatalo:\nBadilisha kamba kuwa safu ya 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "tr": "Bir Shell fonksiyonu yazın `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` aşağıdaki problemi çözmek için:\nDizgiyi 2D diziye dönüştür\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "vi": "Viết một hàm Shell `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` để giải quyết vấn đề sau:\nChuyển đổi chuỗi thành mảng 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`"
    },
    "instruction_bertscore": {
      "es": "0.9888345890212669",
      "arb": "0.9690090920597937",
      "sw": "0.981240750923922",
      "tr": "0.9817649364994732",
      "vi": "0.9933881905064916"
    },
    "level": "middle",
    "test": "# Testing function\ntest_is_valid_sudoku() {\nlocal validSudoku=\"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\nlocal invalidSudoku=\"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n\n[[ $(is_valid_sudoku \"$validSudoku\") == \"true\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(is_valid_sudoku \"$invalidSudoku\") == \"false\" ]] || { echo \"Test 2 failed\"; exit 1; }\n}\n\ntest_is_valid_sudoku",
    "entry_point": "is_valid_sudoku",
    "signature": "is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n",
    "docstring": {
      "en": "Convert string to 2D array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "es": "Convertir cadena a matriz 2D  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "arb": "تحويل السلسلة إلى مصفوفة ثنائية الأبعاد\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "sw": "Badilisha kamba kuwa safu ya vipimo viwili  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "tr": "Dizgiyi 2D diziye dönüştür  \nyerel -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "vi": "Chuyển đổi chuỗi thành mảng 2D  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\""
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9435875813734245",
      "sw": "0.9265095398424259",
      "tr": "0.9730919395419658",
      "vi": "0.9686024956698153"
    }
  },
  {
    "task_id": "Shell/16",
    "prompt": {
      "en": "#!/bin/bash\n\n# Count the number of strings that appear exactly once in both arrays.\n# The function takes two strings representing the arrays, where elements are separated by spaces.\n# Returns the count of strings that appear exactly once in both arrays.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "es": "#!/bin/bash\n\n# Cuenta el número de cadenas que aparecen exactamente una vez en ambos arreglos.\n# La función toma dos cadenas que representan los arreglos, donde los elementos están separados por espacios.\n# Devuelve la cuenta de cadenas que aparecen exactamente una vez en ambos arreglos.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "arb": "#!/bin/bash\n\n# احسب عدد السلاسل النصية التي تظهر مرة واحدة بالضبط في كلا المصفوفتين.\n# تأخذ الدالة سلسلتين تمثلان المصفوفتين، حيث العناصر مفصولة بمسافات.\n# تُرجع عدد السلاسل النصية التي تظهر مرة واحدة بالضبط في كلا المصفوفتين.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "sw": "#!/bin/bash\n\n# Hesabu idadi ya mistari inayojitokeza mara moja tu katika safu zote mbili.\n# Kazi inachukua mistari miwili inayowakilisha safu, ambapo vipengele vinatenganishwa na nafasi.\n# Inarudisha idadi ya mistari inayojitokeza mara moja tu katika safu zote mbili.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "tr": "#!/bin/bash\n\n# İki dizide tam olarak bir kez görünen dizelerin sayısını sayar.\n# Fonksiyon, dizileri temsil eden iki dize alır, burada elemanlar boşluklarla ayrılmıştır.\n# İki dizide tam olarak bir kez görünen dizelerin sayısını döndürür.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "vi": "#!/bin/bash\n\n# Đếm số lượng chuỗi xuất hiện chính xác một lần trong cả hai mảng.\n# Hàm nhận hai chuỗi đại diện cho các mảng, trong đó các phần tử được phân tách bằng dấu cách.\n# Trả về số lượng chuỗi xuất hiện chính xác một lần trong cả hai mảng.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)"
    },
    "prompt_bertscore": {
      "es": "0.9921958123291392",
      "arb": "0.9846629537587721",
      "sw": "0.9635556949484808",
      "tr": "0.9913901675036617",
      "vi": "0.9885785544601129"
    },
    "canonical_solution": "local -A count1 count2\nlocal unique_count=0\n\n# Count occurrences in words1\nfor word in \"${words1[@]}\"; do\n((count1[$word]++))\ndone\n\n# Count occurrences in words2\nfor word in \"${words2[@]}\"; do\n((count2[$word]++))\ndone\n\n# Find common strings with exactly one occurrence in each array\nfor word in \"${!count1[@]}\"; do\nif [[ ${count1[$word]} -eq 1 && ${count2[$word]} -eq 1 ]]; then\n((unique_count++))\nfi\ndone\n\necho $unique_count\n}",
    "instruction": {
      "en": "Write a Shell function `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` to solve the following problem:\n\nCount the number of strings that appear exactly once in both arrays.\nThe function takes two strings representing the arrays, where elements are separated by spaces.\nReturns the count of strings that appear exactly once in both arrays.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "es": "Escribe una función Shell `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` para resolver el siguiente problema:\n\nCuenta el número de cadenas que aparecen exactamente una vez en ambos arreglos.\nLa función toma dos cadenas que representan los arreglos, donde los elementos están separados por espacios.\nDevuelve el conteo de cadenas que aparecen exactamente una vez en ambos arreglos.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "arb": "اكتب دالة شل `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` لحل المشكلة التالية:\n\nعد عدد السلاسل النصية التي تظهر مرة واحدة بالضبط في كلا المصفوفتين.\nتأخذ الدالة سلسلتين تمثلان المصفوفتين، حيث يتم فصل العناصر بمسافات.\nتعيد الدالة عدد السلاسل النصية التي تظهر مرة واحدة بالضبط في كلا المصفوفتين.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "sw": "Andika kazi ya Shell `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` kutatua tatizo lifuatalo:\n\nHesabu idadi ya nyuzi ambazo zinaonekana mara moja tu katika safu zote mbili.\nKazi inachukua nyuzi mbili zinazowakilisha safu, ambapo vipengele vimetenganishwa na nafasi.\nInarudisha hesabu ya nyuzi ambazo zinaonekana mara moja tu katika safu zote mbili.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "tr": "Bir Shell fonksiyonu yazın `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` aşağıdaki problemi çözmek için:\n\nHer iki dizide de tam olarak bir kez görünen dizelerin sayısını sayın.\nFonksiyon, elemanların boşluklarla ayrıldığı dizileri temsil eden iki dize alır.\nHer iki dizide de tam olarak bir kez görünen dizelerin sayısını döndürür.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "vi": "Viết một hàm Shell `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` để giải quyết vấn đề sau:\n\nĐếm số lượng chuỗi xuất hiện chính xác một lần trong cả hai mảng.\nHàm nhận hai chuỗi đại diện cho các mảng, trong đó các phần tử được ngăn cách bởi dấu cách.\nTrả về số lượng chuỗi xuất hiện chính xác một lần trong cả hai mảng.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n"
    },
    "instruction_bertscore": {
      "es": "0.9966502972542276",
      "arb": "0.9869575319204872",
      "sw": "0.9836666237675011",
      "tr": "0.9814640114722053",
      "vi": "0.990491960920622"
    },
    "level": "middle",
    "test": "# Testing function\ntest_count_unique_strings() {\n[[ $(count_unique_strings \"apple banana mango\" \"banana fruits apple\") == \"2\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_unique_strings \"hello world\" \"world hello planet\") == \"2\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_unique_strings \"one two three\" \"four five six\") == \"0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_unique_strings \"one two two\" \"two one one\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_unique_strings \"a b c d e\" \"a b c d e\") == \"5\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(count_unique_strings \"dog cat\" \"cat dog bird\") == \"2\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(count_unique_strings \"x y z\" \"x y z a b c\") == \"3\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_count_unique_strings",
    "entry_point": "count_unique_strings",
    "signature": "count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
    "docstring": {
      "en": "\nCount the number of strings that appear exactly once in both arrays.\nThe function takes two strings representing the arrays, where elements are separated by spaces.\nReturns the count of strings that appear exactly once in both arrays.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "es": "Cuenta el número de cadenas que aparecen exactamente una vez en ambos arreglos.  \nLa función toma dos cadenas que representan los arreglos, donde los elementos están separados por espacios.  \nDevuelve el conteo de cadenas que aparecen exactamente una vez en ambos arreglos.  \n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"  \n2  \n>>> count_unique_strings \"hello world\" \"world hello planet\"  \n2  ",
      "arb": "احسب عدد السلاسل النصية التي تظهر مرة واحدة بالضبط في كلا المصفوفتين.\nتأخذ الدالة سلسلتين تمثلان المصفوفتين، حيث يتم فصل العناصر بمسافات.\nتعيد عدد السلاسل النصية التي تظهر مرة واحدة بالضبط في كلا المصفوفتين.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "sw": "Hesabu idadi ya mistari inayotokea mara moja tu katika safu zote mbili.  \nKazi inachukua mistari miwili inayowakilisha safu, ambapo vipengele vinatenganishwa na nafasi.  \nInarudisha hesabu ya mistari inayotokea mara moja tu katika safu zote mbili.  \n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"  \n2  \n>>> count_unique_strings \"hello world\" \"world hello planet\"  \n2  ",
      "tr": "Her iki dizide de tam olarak bir kez görünen dizelerin sayısını sayın.  \nFonksiyon, elemanların boşluklarla ayrıldığı dizileri temsil eden iki dize alır.  \nHer iki dizide de tam olarak bir kez görünen dizelerin sayısını döndürür.  \n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"  \n2  \n>>> count_unique_strings \"hello world\" \"world hello planet\"  \n2  ",
      "vi": "Đếm số chuỗi xuất hiện chính xác một lần trong cả hai mảng.  \nHàm nhận hai chuỗi đại diện cho các mảng, trong đó các phần tử được phân tách bằng dấu cách.  \nTrả về số lượng chuỗi xuất hiện chính xác một lần trong cả hai mảng.  \n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"  \n2  \n>>> count_unique_strings \"hello world\" \"world hello planet\"  \n2  "
    },
    "docstring_bertscore": {
      "es": "0.9959757484802332",
      "arb": "0.9799232356065176",
      "sw": "0.9494420132240468",
      "tr": "0.9796880572353723",
      "vi": "0.9878150192754148"
    }
  },
  {
    "task_id": "Shell/17",
    "prompt": {
      "en": "#!/bin/bash\n\n# Count the frequency of each word in frequency.txt\n# example\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "es": "#!/bin/bash\n\n# Contar la frecuencia de cada palabra en frequency.txt\n# ejemplo\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "arb": "#!/bin/bash\n\n# عد تكرار كل كلمة في frequency.txt\n# مثال\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "sw": "#!/bin/bash\n\n# Hesabu mara ngapi kila neno linapatikana katika frequency.txt\n# mfano\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "tr": "#!/bin/bash\n\n# frequency.txt dosyasındaki her kelimenin sıklığını say\n# örnek\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "vi": "#!/bin/bash\n\n# Đếm tần suất của mỗi từ trong frequency.txt\n# ví dụ\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9975244695611621",
      "sw": "0.9674818230600164",
      "tr": "0.9771376431428843",
      "vi": "1"
    },
    "canonical_solution": "tr -s ' ' '\\n' < frequency.txt | grep -v '^$' | sort | uniq -c | awk '{print $2, $1}'\n}",
    "instruction": {
      "en": "Write a Shell function `count_word_frequency() {` to solve the following problem:\n\nCount the frequency of each word in frequency.txt\nexample\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3\n\n",
      "es": "Escribe una función de Shell `count_word_frequency() {` para resolver el siguiente problema:\n\nCuenta la frecuencia de cada palabra en frequency.txt\nejemplo\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "arb": "اكتب دالة شل `count_word_frequency() {` لحل المشكلة التالية:\n\nاحسب تكرار كل كلمة في frequency.txt\nمثال\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "sw": "Andika kazi ya Shell `count_word_frequency() {` kutatua tatizo lifuatalo:\n\nHesabu mara ngapi kila neno linatokea katika frequency.txt\nmfano\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "tr": "Bir Shell fonksiyonu `count_word_frequency() {` yazın ve aşağıdaki problemi çözün:\n\nfrequency.txt dosyasındaki her kelimenin sıklığını sayın\nörnek\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "vi": "Viết một hàm Shell `count_word_frequency() {` để giải quyết vấn đề sau:\n\nĐếm tần suất của mỗi từ trong frequency.txt\nví dụ\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.970258477156503",
      "sw": "0.9682874678854939",
      "tr": "0.9655372316296849",
      "vi": "1"
    },
    "level": "easy",
    "test": "# Test function for count_word_frequency\ntest_count_word_frequency() {\n# Create a sample frequency.txt file\necho -e \"apple banana apple\\nbanana banana apple\" > frequency.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"apple 3\\nbanana 3\")\n\n# Actual output from the function\nlocal actual_output=$(count_word_frequency)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm frequency.txt\n}\n\n# Call the test function\ntest_count_word_frequency",
    "entry_point": "count_word_frequency",
    "signature": "count_word_frequency() {",
    "docstring": {
      "en": "\nCount the frequency of each word in frequency.txt\nexample\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3\n\n",
      "es": "Cuenta la frecuencia de cada palabra en frequency.txt  \nejemplo  \napple banana apple\\nbanana banana apple  \napple 3\\nbanana 3  ",
      "arb": "احسب تكرار كل كلمة في frequency.txt  \nمثال  \napple banana apple\\nbanana banana apple  \napple 3\\nbanana 3  ",
      "sw": "Hesabu mara ngapi kila neno linatokea katika frequency.txt\nmfano\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "tr": "Her kelimenin sıklığını frequency.txt dosyasında sayın\nörnek\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "vi": "Đếm tần suất của mỗi từ trong frequency.txt\nví dụ\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9599352589933579",
      "sw": "0.9451096859832948",
      "tr": "0.9507601244325943",
      "vi": "1"
    }
  },
  {
    "task_id": "Shell/18",
    "prompt": {
      "en": "#!/bin/bash\n\n# Single-line script to output all valid phone numbers from file.txt\n# example\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "es": "#!/bin/bash\n\n# Script de una sola línea para mostrar todos los números de teléfono válidos de file.txt\n# ejemplo\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "arb": "#!/bin/bash\n\n# سكربت سطر واحد لإخراج جميع أرقام الهاتف الصالحة من file.txt\n# مثال\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "sw": "#!/bin/bash\n\n# Skripti ya mstari mmoja kutoa namba zote za simu halali kutoka file.txt\n# mfano\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "tr": "#!/bin/bash\n\n# file.txt dosyasından tüm geçerli telefon numaralarını çıkarmak için tek satırlık betik\n# örnek\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "vi": "#!/bin/bash\n\n# Tập lệnh một dòng để xuất tất cả các số điện thoại hợp lệ từ file.txt\n# ví dụ\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {"
    },
    "prompt_bertscore": {
      "es": "0.9940283762245671",
      "arb": "0.9849001184337278",
      "sw": "0.9847346593263258",
      "tr": "0.989706377763629",
      "vi": "0.9907362762892948"
    },
    "canonical_solution": "grep -P '^(\\(\\d{3}\\) \\d{3}-\\d{4}|\\d{3}-\\d{3}-\\d{4})$' file.txt\n}",
    "instruction": {
      "en": "Write a Shell function `find_valid_numbers() {` to solve the following problem:\n\nSingle-line script to output all valid phone numbers from file.txt\nexample\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890\n",
      "es": "Escribe una función de Shell `find_valid_numbers() {` para resolver el siguiente problema:\n\nScript de una sola línea para mostrar todos los números de teléfono válidos desde file.txt\nejemplo\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "arb": "اكتب دالة شل `find_valid_numbers() {` لحل المشكلة التالية:\n\nنص برمجي ذو سطر واحد لإخراج جميع أرقام الهاتف الصالحة من file.txt\nمثال\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "sw": "Andika kazi ya Shell `find_valid_numbers() {` kutatua tatizo lifuatalo:\n\nSkripti ya mstari mmoja kutoa namba zote za simu halali kutoka file.txt\nmfano\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "tr": "Bir Shell fonksiyonu `find_valid_numbers() {` yazın ve aşağıdaki problemi çözün:\n\nfile.txt dosyasından tüm geçerli telefon numaralarını çıktılayan tek satırlık betik\nörnek\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "vi": "Viết một hàm Shell `find_valid_numbers() {` để giải quyết vấn đề sau:\n\nTập lệnh một dòng để xuất tất cả các số điện thoại hợp lệ từ file.txt\nví dụ\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890"
    },
    "instruction_bertscore": {
      "es": "0.9868707304439749",
      "arb": "0.9845701933708289",
      "sw": "0.9869092647378956",
      "tr": "0.9653920328211483",
      "vi": "0.9925285182173726"
    },
    "level": "easy",
    "test": "test_find_valid_numbers() {\n# Create a sample file.txt file\necho -e \"123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\" > file.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"123-456-7890\\n(123) 456-7890\")\n\n# Actual output from the function\nlocal actual_output=$(find_valid_numbers)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_find_valid_numbers",
    "entry_point": "find_valid_numbers",
    "signature": "find_valid_numbers() {",
    "docstring": {
      "en": "\nSingle-line script to output all valid phone numbers from file.txt\nexample\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890\n",
      "es": "Script de una sola línea para mostrar todos los números de teléfono válidos de file.txt\nejemplo\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "arb": "برنامج سطر واحد لإخراج جميع أرقام الهاتف الصحيحة من file.txt\nمثال\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "sw": "Skripti ya mstari mmoja kutoa namba zote za simu halali kutoka file.txt\nmfano\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "tr": "Tek satırlık betik, file.txt dosyasından tüm geçerli telefon numaralarını çıkarmak için\nörnek\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "vi": "Kịch bản một dòng để xuất tất cả các số điện thoại hợp lệ từ file.txt\nví dụ\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890"
    },
    "docstring_bertscore": {
      "es": "0.9919079969070197",
      "arb": "0.9539459571140129",
      "sw": "0.9755380726844104",
      "tr": "0.9764140326647742",
      "vi": "0.983267575332002"
    }
  },
  {
    "task_id": "Shell/19",
    "prompt": {
      "en": "#!/bin/bash\n\n# Transpose the content of file.txt\n# example\n# input:1 2 3\\n4 5 6\\n7 8 9\n# output:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "es": "#!/bin/bash\n\n# Transponer el contenido de file.txt\n# ejemplo\n# entrada:1 2 3\\n4 5 6\\n7 8 9\n# salida:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "arb": "#!/bin/bash\n\n# تبديل محتوى الملف file.txt\n# مثال\n# الإدخال:1 2 3\\n4 5 6\\n7 8 9\n# الإخراج:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "sw": "#!/bin/bash\n\n# Badilisha maudhui ya file.txt\n# mfano\n# ingizo:1 2 3\\n4 5 6\\n7 8 9\n# pato:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "tr": "#!/bin/bash\n\n# file.txt dosyasının içeriğini ters çevir\n# örnek\n# giriş:1 2 3\\n4 5 6\\n7 8 9\n# çıkış:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "vi": "#!/bin/bash\n\n# Chuyển vị nội dung của file.txt\n# ví dụ\n# đầu vào:1 2 3\\n4 5 6\\n7 8 9\n# đầu ra:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9768536016980045",
      "sw": "0.9818727927963751",
      "tr": "0.979002981051183",
      "vi": "0.9964963587089256"
    },
    "canonical_solution": "awk '\n{\nfor (i = 1; i <= NF; i++) {\nif(NR == 1) {\ntransposed[i] = $i;\n} else {\ntransposed[i] = transposed[i] \" \" $i;\n}\n}\n}\nEND {\nfor (i = 1; i <= NF; i++) {\nprint transposed[i];\n}\n}' file.txt\n}",
    "instruction": {
      "en": "Write a Shell function `transpose_file() {` to solve the following problem:\n\nTranspose the content of file.txt\nexample\ninput:1 2 3\\n4 5 6\\n7 8 9\noutput:1 4 7\\n2 5 8\\n3 6 9\n",
      "es": "Escribe una función de Shell `transpose_file() {` para resolver el siguiente problema:\n\nTransponer el contenido de file.txt\nejemplo\ninput:1 2 3\\n4 5 6\\n7 8 9\nsalida:1 4 7\\n2 5 8\\n3 6 9",
      "arb": "اكتب دالة Shell `transpose_file() {` لحل المشكلة التالية:\n\nتبديل محتوى file.txt\nمثال\ninput:1 2 3\\n4 5 6\\n7 8 9\nالناتج:1 4 7\\n2 5 8\\n3 6 9",
      "sw": "Andika kazi ya Shell `transpose_file() {` kutatua tatizo lifuatalo:\n\nGeuza yaliyomo ya file.txt\nmfano\ningizo:1 2 3\\n4 5 6\\n7 8 9\nmatokeo:1 4 7\\n2 5 8\\n3 6 9",
      "tr": "Bir Shell fonksiyonu `transpose_file() {` yazın:\n\nfile.txt dosyasının içeriğini transpoze edin\nörnek\ngirdi:1 2 3\\n4 5 6\\n7 8 9\nçıktı:1 4 7\\n2 5 8\\n3 6 9",
      "vi": "Viết một hàm Shell `transpose_file() {` để giải quyết vấn đề sau:\n\nChuyển vị nội dung của file.txt\nví dụ\ninput:1 2 3\\n4 5 6\\n7 8 9\nĐầu ra:1 4 7\\n2 5 8\\n3 6 9"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9883981980741332",
      "sw": "0.9972402294859013",
      "tr": "0.9463487423001905",
      "vi": "0.9972402294859013"
    },
    "level": "easy",
    "test": "# Test function for transpose_file\ntest_transpose_file() {\n# Create a sample file.txt file\necho -e \"1 2 3\\n4 5 6\\n7 8 9\" > file.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"1 4 7\\n2 5 8\\n3 6 9\")\n\n# Actual output from the function\nlocal actual_output=$(transpose_file)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_transpose_file",
    "entry_point": "transpose_file",
    "signature": "transpose_file() {",
    "docstring": {
      "en": "\nTranspose the content of file.txt\nexample\ninput:1 2 3\\n4 5 6\\n7 8 9\noutput:1 4 7\\n2 5 8\\n3 6 9\n",
      "es": "Transponer el contenido de file.txt  \nejemplo  \nentrada:1 2 3\\n4 5 6\\n7 8 9  \nsalida:1 4 7\\n2 5 8\\n3 6 9  ",
      "arb": "نقل محتوى الملف file.txt  \nمثال  \nالإدخال: 1 2 3\\n4 5 6\\n7 8 9  \nالإخراج: 1 4 7\\n2 5 8\\n3 6 9  ",
      "sw": "Badilisha yaliyomo ya file.txt  \nmfano  \ningizo:1 2 3\\n4 5 6\\n7 8 9  \nmatokeo:1 4 7\\n2 5 8\\n3 6 9  ",
      "tr": "Dosya.txt içeriğini ters çevir\nörnek\ngirdi:1 2 3\\n4 5 6\\n7 8 9\nçıktı:1 4 7\\n2 5 8\\n3 6 9",
      "vi": "Chuyển đổi nội dung của file.txt  \nví dụ  \nđầu vào:1 2 3\\n4 5 6\\n7 8 9  \nđầu ra:1 4 7\\n2 5 8\\n3 6 9  "
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9401322072649416",
      "sw": "0.971151717980017",
      "tr": "0.9496670614457593",
      "vi": "0.9796870640834672"
    }
  },
  {
    "task_id": "Shell/20",
    "prompt": {
      "en": "#!/bin/bash\n\n# Extract the tenth line from file.txt\n# example\n# input: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# output:Line 10\nextract_tenth_line() {",
      "es": "#!/bin/bash\n\n# Extraer la décima línea de file.txt\n# ejemplo\n# entrada: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# salida:Line 10\nextract_tenth_line() {",
      "arb": "#!/bin/bash\n\n# استخراج السطر العاشر من file.txt\n# مثال\n# الإدخال: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# الإخراج:Line 10\nextract_tenth_line() {",
      "sw": "#!/bin/bash\n\n# Toa mstari wa kumi kutoka file.txt\n# mfano\n# ingizo: kwa i katika {1..20}; fanya echo \"Line $i\"; fanya > file.txt\n# pato:Mstari wa 10\nextract_tenth_line() {",
      "tr": "#!/bin/bash\n\n# file.txt dosyasından onuncu satırı çıkar\n# örnek\n# giriş: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# çıkış:Line 10\nextract_tenth_line() {",
      "vi": "#!/bin/bash\n\n# Trích xuất dòng thứ mười từ file.txt\n# ví dụ\n# đầu vào: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# đầu ra:Line 10\nextract_tenth_line() {"
    },
    "prompt_bertscore": {
      "es": "0.99395984874311",
      "arb": "0.9935600057860868",
      "sw": "0.99395984874311",
      "tr": "0.9883179514001951",
      "vi": "0.99395984874311"
    },
    "canonical_solution": "sed -n '10p' file.txt\n}",
    "instruction": {
      "en": "Write a Shell function `extract_tenth_line() {` to solve the following problem:\n\nExtract the tenth line from file.txt\nexample\ninput: for i in {1..20}; do echo \"Line $i\"; done > file.txt\noutput:Line 10\n",
      "es": "Escribe una función de Shell `extract_tenth_line() {` para resolver el siguiente problema:\n\nExtraer la décima línea de file.txt\nejemplo\nentrada: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nsalida:Line 10",
      "arb": "اكتب دالة Shell `extract_tenth_line() {` لحل المشكلة التالية:\n\nاستخراج السطر العاشر من file.txt\nمثال\ninput: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nالناتج:Line 10",
      "sw": "Andika kazi ya Shell `extract_tenth_line() {` kutatua tatizo lifuatalo:\n\nToa mstari wa kumi kutoka file.txt\nmfano\ningizo: kwa i katika {1..20}; fanya echo \"Line $i\"; fanya > file.txt\nmatokeo:Mstari 10",
      "tr": "Bir Shell fonksiyonu `extract_tenth_line() {` yazın:\n\nfile.txt dosyasından onuncu satırı çıkarın\nörnek\ngirdi: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nçıktı:Line 10",
      "vi": "Viết một hàm Shell `extract_tenth_line() {` để giải quyết vấn đề sau:\n\nTrích xuất dòng thứ mười từ file.txt\nví dụ\nđầu vào: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nđầu ra:Line 10"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9892183429174263",
      "sw": "0.9841916038645764",
      "tr": "0.9587871753909762",
      "vi": "1"
    },
    "level": "easy",
    "test": "test_extract_tenth_line() {\n# Create a sample file.txt file\nfor i in {1..20}; do echo \"Line $i\"; done > file.txt\n\n# Expected output\nlocal expected_output=\"Line 10\"\n\n# Actual output from the function\nlocal actual_output=$(extract_tenth_line)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_extract_tenth_line",
    "entry_point": "extract_tenth_line",
    "signature": "extract_tenth_line() {",
    "docstring": {
      "en": "\nExtract the tenth line from file.txt\nexample\ninput: for i in {1..20}; do echo \"Line $i\"; done > file.txt\noutput:Line 10\n",
      "es": "Extraer la décima línea de file.txt  \nejemplo  \nentrada: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nsalida: Line 10  ",
      "arb": "استخراج السطر العاشر من الملف file.txt  \nمثال  \nالإدخال: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nالإخراج:Line 10  ",
      "sw": "Toa mstari wa kumi kutoka file.txt  \nmfano  \ningizo: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nmatokeo:Mstari 10  ",
      "tr": "Onuncu satırı file.txt dosyasından çıkar\nörnek\ngirdi: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nçıktı:Line 10",
      "vi": "Trích dòng thứ mười từ file.txt  \nví dụ  \nđầu vào: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nđầu ra:Line 10  "
    },
    "docstring_bertscore": {
      "es": "0.9944214657486352",
      "arb": "0.9696780791831191",
      "sw": "0.9944214657486352",
      "tr": "0.9721687055309156",
      "vi": "0.999999801369619"
    }
  },
  {
    "task_id": "Shell/21",
    "prompt": {
      "en": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "es": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Esta función encuentra la primera aparición de la subcadena 'needle' en la cadena 'haystack'.\n# Devuelve el índice del primer carácter de la primera aparición de 'needle'.\n# Si 'needle' no es parte de 'haystack', devuelve -1.\n# Ejemplo de uso:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "arb": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# هذه الدالة تجد أول ظهور للجزء الفرعي 'needle' في السلسلة 'haystack'.\n# تُرجع فهرس الحرف الأول من أول ظهور لـ 'needle'.\n# إذا لم يكن 'needle' جزءًا من 'haystack'، فإنها تُرجع -1.\n# مثال على الاستخدام:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "sw": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Kazi ya hii kazi ni kutafuta tukio la kwanza la 'needle' ndani ya kamba 'haystack'.\n# Inarudisha index ya herufi ya kwanza ya tukio la kwanza la 'needle'.\n# Kama 'needle' si sehemu ya 'haystack', inarudisha -1.\n# Mfano wa Matumizi:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "tr": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Bu fonksiyon, 'needle' alt dizisinin 'haystack' dizisindeki ilk meydana gelişini bulur.\n# 'needle'ın ilk meydana gelişinin ilk karakterinin indeksini döndürür.\n# Eğer 'needle', 'haystack'in bir parçası değilse, -1 döndürür.\n# Örnek Kullanım:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "vi": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Hàm này tìm lần xuất hiện đầu tiên của chuỗi con 'needle' trong chuỗi 'haystack'.\n# Nó trả về chỉ số của ký tự đầu tiên của lần xuất hiện đầu tiên của 'needle'.\n# Nếu 'needle' không phải là một phần của 'haystack', nó trả về -1.\n# Ví dụ sử dụng:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4"
    },
    "prompt_bertscore": {
      "es": "0.9855176602883653",
      "arb": "0.9948546786096722",
      "sw": "0.9721321575408052",
      "tr": "0.9848929677400106",
      "vi": "0.998257415667181"
    },
    "canonical_solution": "# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4\n\nif [ -z \"$needle\" ]; then\necho 0\nreturn 0\nfi\n\nlocal length=${#haystack}\nlocal needle_length=${#needle}\n\nfor (( i=0; i<=$length-needle_length; i++ )); do\nif [ \"${haystack:$i:$needle_length}\" == \"$needle\" ]; then\necho $i\nreturn 0\nfi\ndone\n\necho -1\n}",
    "instruction": {
      "en": "Write a Shell function `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` to solve the following problem:\nThis function finds the first occurrence of the substring 'needle' in the string 'haystack'.\nIt returns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', it returns -1.\nExample Usage:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "es": "Escribe una función Shell `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` para resolver el siguiente problema:\nEsta función encuentra la primera aparición de la subcadena 'needle' en la cadena 'haystack'.\nDevuelve el índice del primer carácter de la primera aparición de 'needle'.\nSi 'needle' no es parte de 'haystack', devuelve -1.\nEjemplo de uso:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "arb": "اكتب دالة Shell `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` لحل المشكلة التالية:\nتجد هذه الدالة أول ظهور للجزء الفرعي 'needle' في السلسلة 'haystack'.\nتعيد الدالة فهرس الحرف الأول من أول ظهور لـ 'needle'.\nإذا لم يكن 'needle' جزءًا من 'haystack'، فإنها تعيد -1.\nمثال على الاستخدام:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "sw": "Andika kazi ya Shell `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` kutatua tatizo lifuatalo:\nKazi hii inapata tukio la kwanza la sehemu ndogo ya 'needle' katika kamba 'haystack'.\nInarudisha faharasa ya herufi ya kwanza ya tukio la kwanza la 'needle'.\nIkiwa 'needle' si sehemu ya 'haystack', inarudisha -1.\nMfano wa Matumizi:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "tr": "Bir Shell fonksiyonu yazın `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` aşağıdaki problemi çözmek için:\nBu fonksiyon, 'needle' alt dizisinin 'haystack' dizisindeki ilk oluşumunu bulur.\n'needle'ın ilk oluşumunun ilk karakterinin indeksini döndürür.\nEğer 'needle', 'haystack'in bir parçası değilse, -1 döndürür.\nÖrnek Kullanım:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "vi": "Viết một hàm Shell `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` để giải quyết vấn đề sau:\nHàm này tìm lần xuất hiện đầu tiên của chuỗi con 'needle' trong chuỗi 'haystack'.\nNó trả về chỉ số của ký tự đầu tiên của lần xuất hiện đầu tiên của 'needle'.\nNếu 'needle' không phải là một phần của 'haystack', nó trả về -1.\nVí dụ Sử dụng:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4"
    },
    "instruction_bertscore": {
      "es": "0.984792858027969",
      "arb": "0.9907607078261622",
      "sw": "0.9978226137630956",
      "tr": "0.9795825845030428",
      "vi": "1"
    },
    "level": "hard",
    "test": "test_find_substring_index() {\n[[ $(find_substring_index \"hello\" \"ll\") -eq 2 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_substring_index \"abcd\" \"e\") -eq -1 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_substring_index \"openai\" \"ai\") -eq 4 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_substring_index \"apple\" \"pp\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_substring_index \"banana\" \"na\") -eq 2 ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_substring_index \"teststring\" \"string\") -eq 4 ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_substring_index \"abcd\" \"\") -eq 0 ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_find_substring_index",
    "entry_point": "find_substring_index",
    "signature": "find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n",
    "docstring": {
      "en": "This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\nIt returns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', it returns -1.\nExample Usage:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "es": "Esta función encuentra la primera aparición de la subcadena 'needle' en la cadena 'haystack'.\nDevuelve el índice del primer carácter de la primera aparición de 'needle'.\nSi 'needle' no es parte de 'haystack', devuelve -1.\nEjemplo de uso:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "arb": "هذه الدالة تجد أول ظهور للجزء النصي 'needle' في السلسلة النصية 'haystack'.\nتعيد الدالة فهرس أول حرف من أول ظهور لـ 'needle'.\nإذا لم يكن 'needle' جزءًا من 'haystack'، فإنها تعيد -1.\nمثال على الاستخدام:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "sw": "Kazi ya hii kazi ni kupata tukio la kwanza la sehemu ndogo ya 'needle' katika kamba 'haystack'.\nInarudisha faharasa ya herufi ya kwanza ya tukio la kwanza la 'needle'.\nKama 'needle' si sehemu ya 'haystack', inarudisha -1.\nMfano wa Matumizi:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "tr": "Bu fonksiyon, 'haystack' stringi içinde 'needle' alt dizisinin ilk geçtiği yeri bulur.\n'Needle'ın ilk geçtiği yerin ilk karakterinin indeksini döndürür.\nEğer 'needle', 'haystack'in bir parçası değilse, -1 döndürür.\nÖrnek Kullanım:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "vi": "Hàm này tìm lần xuất hiện đầu tiên của chuỗi con 'needle' trong chuỗi 'haystack'.  \nNó trả về chỉ số của ký tự đầu tiên của lần xuất hiện đầu tiên của 'needle'.  \nNếu 'needle' không phải là một phần của 'haystack', nó trả về -1.  \nVí dụ sử dụng:  \n>>> find_substring_index \"hello\" \"ll\"  \n2  \n>>> find_substring_index \"abcd\" \"e\"  \n-1  \n>>> find_substring_index \"openai\" \"ai\"  \n4  "
    },
    "docstring_bertscore": {
      "es": "0.9824591496811901",
      "arb": "0.9890266645997277",
      "sw": "0.9710140671259598",
      "tr": "0.9802819620746667",
      "vi": "0.9985944914237971"
    }
  },
  {
    "task_id": "Shell/22",
    "prompt": {
      "en": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# This function simulates a sequence of toggling lights. Initially, all lights are off. \n# In each round, a person toggles the state of lights that are multiples of their number. \n# For example, the first person toggles all lights, the second person toggles every second light, and so on.\n# The function outputs the numbers of the lights that remain on after N rounds.\n# Example Usage:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "es": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Esta función simula una secuencia de encendido y apagado de luces. Inicialmente, todas las luces están apagadas.\n# En cada ronda, una persona cambia el estado de las luces que son múltiplos de su número.\n# Por ejemplo, la primera persona cambia todas las luces, la segunda persona cambia cada segunda luz, y así sucesivamente.\n# La función muestra los números de las luces que permanecen encendidas después de N rondas.\n# Ejemplo de uso:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "arb": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# هذه الدالة تحاكي تسلسل تبديل الأضواء. في البداية، جميع الأضواء مطفأة.\n# في كل جولة، يقوم شخص بتبديل حالة الأضواء التي هي مضاعفات لرقمه.\n# على سبيل المثال، الشخص الأول يبدل جميع الأضواء، الشخص الثاني يبدل كل ضوء ثاني، وهكذا.\n# تقوم الدالة بإخراج أرقام الأضواء التي تبقى مضاءة بعد N جولة.\n# مثال على الاستخدام:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "sw": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Kazi hii inasimulate mfululizo wa kuwasha na kuzima taa. Mwanzoni, taa zote zimezimwa.\n# Katika kila raundi, mtu anabadilisha hali ya taa ambazo ni maradufu ya namba yao.\n# Kwa mfano, mtu wa kwanza anabadilisha taa zote, mtu wa pili anabadilisha kila taa ya pili, na kadhalika.\n# Kazi hii inatoa namba za taa ambazo zinabaki kuwaka baada ya raundi N.\n# Mfano wa Matumizi:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "tr": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Bu fonksiyon, ışıkların açılıp kapatılmasını simüle eder. Başlangıçta, tüm ışıklar kapalıdır.\n# Her turda, bir kişi kendi numarasının katı olan ışıkların durumunu değiştirir.\n# Örneğin, birinci kişi tüm ışıkları değiştirir, ikinci kişi her ikinci ışığı değiştirir, vb.\n# Fonksiyon, N turdan sonra açık kalan ışıkların numaralarını çıktılar.\n# Örnek Kullanım:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "vi": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Hàm này mô phỏng một chuỗi bật tắt đèn. Ban đầu, tất cả đèn đều tắt. \n# Trong mỗi vòng, một người sẽ bật tắt trạng thái của các đèn mà là bội số của số của họ. \n# Ví dụ, người đầu tiên bật tắt tất cả các đèn, người thứ hai bật tắt mỗi đèn thứ hai, và cứ thế tiếp tục.\n# Hàm này xuất ra các số của các đèn còn sáng sau N vòng.\n# Ví dụ sử dụng:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9"
    },
    "prompt_bertscore": {
      "es": "0.9597116011843126",
      "arb": "0.9845934331254099",
      "sw": "0.9490936155357116",
      "tr": "0.9731207409472158",
      "vi": "0.9867154014860057"
    },
    "canonical_solution": "local lights=()\n\n# Initialize all lights to off (0)\nfor (( i=1; i<=n; i++ )); do\nlights[$i]=0\ndone\n\n# Toggle lights\nfor (( i=1; i<=n; i++ )); do\nfor (( j=i; j<=n; j+=i )); do\nlights[$j]=$((1 - lights[$j]))\ndone\ndone\n\n# Output lights that are on (1)\nfor (( i=1; i<=n; i++ )); do\nif [[ ${lights[$i]} -eq 1 ]]; then\necho -n \"$i \"\nfi\ndone\necho\n}",
    "instruction": {
      "en": "Write a Shell function `toggle_lights() {\nlocal n=$1\n` to solve the following problem:\nThis function simulates a sequence of toggling lights. Initially, all lights are off. \nIn each round, a person toggles the state of lights that are multiples of their number. \nFor example, the first person toggles all lights, the second person toggles every second light, and so on.\nThe function outputs the numbers of the lights that remain on after N rounds.\nExample Usage:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "es": "Escribe una función Shell `toggle_lights() {\nlocal n=$1\n` para resolver el siguiente problema:\nEsta función simula una secuencia de alternancia de luces. Inicialmente, todas las luces están apagadas.\nEn cada ronda, una persona alterna el estado de las luces que son múltiplos de su número.\nPor ejemplo, la primera persona alterna todas las luces, la segunda persona alterna cada segunda luz, y así sucesivamente.\nLa función muestra los números de las luces que permanecen encendidas después de N rondas.\nEjemplo de uso:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "arb": "اكتب دالة Shell `toggle_lights() {\nlocal n=$1\n` لحل المشكلة التالية:\nهذه الدالة تحاكي تسلسل تبديل الأضواء. في البداية، جميع الأضواء مطفأة.\nفي كل جولة، يقوم شخص بتبديل حالة الأضواء التي هي مضاعفات لرقمه.\nعلى سبيل المثال، الشخص الأول يبدل جميع الأضواء، الشخص الثاني يبدل كل ضوء ثاني، وهكذا.\nتقوم الدالة بإخراج أرقام الأضواء التي تبقى مضاءة بعد N جولة.\nمثال على الاستخدام:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "sw": "Andika kazi ya Shell `toggle_lights() {\nlocal n=$1\n` kutatua tatizo lifuatalo:\nKazi hii inasimulate mfululizo wa kuwasha na kuzima taa. Awali, taa zote zimezimwa. \nKatika kila mzunguko, mtu anabadilisha hali ya taa ambazo ni maradufu ya namba yao. \nKwa mfano, mtu wa kwanza anabadilisha taa zote, mtu wa pili anabadilisha kila taa ya pili, na kadhalika.\nKazi hii inatoa namba za taa ambazo zinabaki kuwaka baada ya mizunguko N.\nMfano wa Matumizi:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "tr": "Bir Shell fonksiyonu `toggle_lights() {\nlocal n=$1\n` aşağıdaki problemi çözmek için yazın:\nBu fonksiyon, ışıkların açılıp kapanma sırasını simüle eder. Başlangıçta, tüm ışıklar kapalıdır.\nHer turda, bir kişi kendi numarasının katları olan ışıkların durumunu değiştirir.\nÖrneğin, birinci kişi tüm ışıkları değiştirir, ikinci kişi her ikinci ışığı değiştirir, ve bu şekilde devam eder.\nFonksiyon, N turdan sonra açık kalan ışıkların numaralarını çıktılar.\nÖrnek Kullanım:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "vi": "Viết một hàm Shell `toggle_lights() {\nlocal n=$1\n` để giải quyết vấn đề sau:\nHàm này mô phỏng một chuỗi bật tắt đèn. Ban đầu, tất cả các đèn đều tắt. \nTrong mỗi vòng, một người sẽ bật tắt trạng thái của các đèn là bội số của số của họ. \nVí dụ, người đầu tiên bật tắt tất cả các đèn, người thứ hai bật tắt mỗi đèn thứ hai, và cứ tiếp tục như vậy.\nHàm xuất ra các số của các đèn còn sáng sau N vòng.\nVí dụ Sử Dụng:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9"
    },
    "instruction_bertscore": {
      "es": "0.9871752308181014",
      "arb": "0.8586417098808063",
      "sw": "0.976355238071988",
      "tr": "0.9459483034520242",
      "vi": "0.988237506095876"
    },
    "level": "easy",
    "test": "test_toggle_lights() {\n[[ $(toggle_lights 5) == \"1 4 \" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(toggle_lights 6) == \"1 4 \" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(toggle_lights 10) == \"1 4 9 \" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(toggle_lights 3) == \"1 \" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(toggle_lights 7) == \"1 4 \" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_toggle_lights",
    "entry_point": "toggle_lights",
    "signature": "toggle_lights() {\nlocal n=$1\n",
    "docstring": {
      "en": "This function simulates a sequence of toggling lights. Initially, all lights are off. \nIn each round, a person toggles the state of lights that are multiples of their number. \nFor example, the first person toggles all lights, the second person toggles every second light, and so on.\nThe function outputs the numbers of the lights that remain on after N rounds.\nExample Usage:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "es": "Esta función simula una secuencia de encendido y apagado de luces. Inicialmente, todas las luces están apagadas. En cada ronda, una persona cambia el estado de las luces que son múltiplos de su número. Por ejemplo, la primera persona cambia todas las luces, la segunda persona cambia cada segunda luz, y así sucesivamente. La función muestra los números de las luces que permanecen encendidas después de N rondas.\nEjemplo de uso:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "arb": "هذه الدالة تحاكي تسلسل تبديل الأضواء. في البداية، جميع الأضواء مطفأة. \nفي كل جولة، يقوم شخص بتبديل حالة الأضواء التي هي مضاعفات لرقمه. \nعلى سبيل المثال، الشخص الأول يبدل جميع الأضواء، الشخص الثاني يبدل كل ضوء ثاني، وهكذا.\nالدالة تعرض أرقام الأضواء التي تبقى مضاءة بعد N جولة.\nمثال على الاستخدام:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "sw": "Kazi hii inasimulate mfululizo wa kuwasha na kuzima taa. Awali, taa zote zimezimwa. \nKila mzunguko, mtu hubadilisha hali ya taa ambazo ni maradufu ya namba yao. \nKwa mfano, mtu wa kwanza hubadilisha taa zote, mtu wa pili hubadilisha kila taa ya pili, na kadhalika.\nKazi hii inatoa namba za taa ambazo zinabaki kuwaka baada ya mizunguko N.\nMfano wa Matumizi:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "tr": "Bu fonksiyon, bir dizi ışık açma-kapama işlemini simüle eder. Başlangıçta tüm ışıklar kapalıdır. Her turda, bir kişi kendi numarasının katı olan ışıkların durumunu değiştirir. Örneğin, birinci kişi tüm ışıkları değiştirir, ikinci kişi her ikinci ışığı değiştirir ve bu şekilde devam eder. Fonksiyon, N turdan sonra açık kalan ışıkların numaralarını çıktılar.\nÖrnek Kullanım:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "vi": "Hàm này mô phỏng một chuỗi bật tắt đèn. Ban đầu, tất cả đèn đều tắt. Trong mỗi vòng, một người sẽ bật tắt trạng thái của các đèn mà là bội số của số của họ. Ví dụ, người đầu tiên bật tắt tất cả các đèn, người thứ hai bật tắt mỗi đèn thứ hai, và cứ tiếp tục như vậy. Hàm xuất ra các số của các đèn còn sáng sau N vòng.\nVí dụ Sử dụng:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9"
    },
    "docstring_bertscore": {
      "es": "0.9397995013767082",
      "arb": "0.977602239604125",
      "sw": "0.9516152282229495",
      "tr": "0.9734161043238148",
      "vi": "0.9872161486765946"
    }
  },
  {
    "task_id": "Shell/23",
    "prompt": {
      "en": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# This function finds M positive integers that sum up to N and have the maximum possible product.\n# The function outputs the integers in a lexicographically smallest order.\n# If no such combination exists, it outputs an error message.\n# Example Usage:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "es": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Esta función encuentra M enteros positivos que suman N y tienen el producto máximo posible.\n# La función muestra los enteros en el orden lexicográficamente más pequeño.\n# Si no existe tal combinación, muestra un mensaje de error.\n# Ejemplo de uso:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "arb": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# هذه الدالة تجد M عددًا صحيحًا موجبًا مجموعها N وتكون لها أكبر حاصل ضرب ممكن.\n# تقوم الدالة بإخراج الأعداد بترتيب معجمي أصغر.\n# إذا لم يكن هناك مثل هذا التوليف، فإنها تخرج رسالة خطأ.\n# مثال على الاستخدام:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "sw": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Kazi hii inapata nambari M ambazo ni chanya ambazo jumla yake ni N na zina bidhaa kubwa zaidi inayowezekana.\n# Kazi hii inatoa nambari katika mpangilio mdogo wa lexicographically.\n# Ikiwa hakuna mchanganyiko kama huo, inatoa ujumbe wa kosa.\n# Mfano wa Matumizi:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "tr": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Bu fonksiyon, toplamları N olan ve mümkün olan en büyük çarpıma sahip M pozitif tam sayı bulur.\n# Fonksiyon, tam sayıları sözlük sırasına göre en küçük şekilde çıktılar.\n# Eğer böyle bir kombinasyon yoksa, bir hata mesajı verir.\n# Örnek Kullanım:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "vi": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Hàm này tìm M số nguyên dương có tổng bằng N và có tích lớn nhất có thể.\n# Hàm xuất ra các số theo thứ tự từ điển nhỏ nhất.\n# Nếu không tồn tại kết hợp nào như vậy, nó sẽ xuất ra thông báo lỗi.\n# Ví dụ sử dụng:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4"
    },
    "prompt_bertscore": {
      "es": "0.9851188104832472",
      "arb": "0.9681496184010557",
      "sw": "0.9579064482814675",
      "tr": "0.972296424865921",
      "vi": "0.9728337200466204"
    },
    "canonical_solution": "if (( sum_n < num_m )); then\necho \"Error: Cannot divide $sum_n into $num_m parts\"\nreturn 1\nfi\n\n# Initialize an array to hold the numbers\nlocal -a numbers\nfor (( i=0; i<num_m; i++ )); do\nnumbers[$i]=$((sum_n / num_m))\ndone\n\n# Distribute the remainder\nlocal remainder=$((sum_n % num_m))\nfor (( i=0; i<remainder; i++ )); do\n((numbers[i]++))\ndone\n\n# Output the numbers in reverse to get lexicographically smallest order\nfor (( i=num_m-1; i>=0; i-- )); do\necho -n \"${numbers[i]} \"\ndone\necho\n}",
    "instruction": {
      "en": "Write a Shell function `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` to solve the following problem:\nThis function finds M positive integers that sum up to N and have the maximum possible product.\nThe function outputs the integers in a lexicographically smallest order.\nIf no such combination exists, it outputs an error message.\nExample Usage:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "es": "Escribe una función de Shell `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` para resolver el siguiente problema:\nEsta función encuentra M enteros positivos que suman N y tienen el producto máximo posible.\nLa función imprime los enteros en el orden lexicográficamente más pequeño.\nSi no existe tal combinación, imprime un mensaje de error.\nEjemplo de uso:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "arb": "اكتب دالة شل `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` لحل المشكلة التالية:\nتجد هذه الدالة M من الأعداد الصحيحة الموجبة التي يكون مجموعها N وتكون لها أكبر حاصل ضرب ممكن.\nتقوم الدالة بإخراج الأعداد بترتيب معجمي أصغر.\nإذا لم يكن هناك مثل هذا التكوين، فإنها تخرج رسالة خطأ.\nمثال على الاستخدام:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "sw": "Andika kazi ya Shell `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` kutatua tatizo lifuatalo:\nKazi hii inapata nambari M za mzima chanya ambazo jumla yake ni N na zina bidhaa kubwa zaidi inayowezekana.\nKazi hii inatoa nambari katika mpangilio mdogo wa lexicographically.\nIkiwa hakuna mchanganyiko kama huo, inatoa ujumbe wa kosa.\nMfano wa Matumizi:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "tr": "Bir Shell fonksiyonu yazın `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` aşağıdaki problemi çözmek için:\nBu fonksiyon, toplamları N olan ve mümkün olan en büyük çarpıma sahip M pozitif tam sayı bulur.\nFonksiyon, tam sayıları sözlük sırasına göre en küçük şekilde çıktılar.\nEğer böyle bir kombinasyon yoksa, bir hata mesajı çıktılar.\nÖrnek Kullanım:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "vi": "Viết một hàm Shell `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` để giải quyết vấn đề sau:\nHàm này tìm M số nguyên dương có tổng bằng N và có tích lớn nhất có thể.\nHàm xuất ra các số theo thứ tự từ điển nhỏ nhất.\nNếu không tồn tại kết hợp nào như vậy, nó sẽ xuất ra một thông báo lỗi.\nVí dụ Sử dụng:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4"
    },
    "instruction_bertscore": {
      "es": "0.9839741035973432",
      "arb": "0.9615461513835508",
      "sw": "0.9675205559843182",
      "tr": "0.968430283129458",
      "vi": "0.9632589411592146"
    },
    "level": "middle",
    "test": "test_maximize_product() {\n[[ $(maximize_product 6 3) == \"2 2 2 \" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(maximize_product 8 3) == \"2 3 3 \" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(maximize_product 10 2) == \"5 5 \" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(maximize_product 20 5) == \"4 4 4 4 4 \" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(maximize_product 7 3) == \"2 2 3 \" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(maximize_product 12 4) == \"3 3 3 3 \" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(maximize_product 5 6) == \"Error: Cannot divide 5 into 6 parts\" ]] && { echo \"Test 7 passed\"; } || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_maximize_product",
    "entry_point": "maximize_product",
    "signature": "maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n",
    "docstring": {
      "en": "This function finds M positive integers that sum up to N and have the maximum possible product.\nThe function outputs the integers in a lexicographically smallest order.\nIf no such combination exists, it outputs an error message.\nExample Usage:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "es": "Esta función encuentra M enteros positivos que suman N y tienen el producto máximo posible.  \nLa función devuelve los enteros en el orden lexicográficamente más pequeño.  \nSi no existe tal combinación, muestra un mensaje de error.  \nUso de ejemplo:  \n>>> maximize_product 6 3  \n2 2 2  \n>>> maximize_product 8 3  \n2 3 3  \n>>> maximize_product 10 2  \n5 5  \n>>> maximize_product 20 5  \n4 4 4 4 4  ",
      "arb": "هذه الدالة تجد M من الأعداد الصحيحة الموجبة التي يكون مجموعها N ولديها أكبر حاصل ضرب ممكن.\nتقوم الدالة بإخراج الأعداد بترتيب معجمي أصغر.\nإذا لم يكن هناك مثل هذا التوليف، فإنها تخرج رسالة خطأ.\nمثال على الاستخدام:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "sw": "Kazi ya hii kazi ni kupata nambari M za asili ambazo jumla yake ni N na zina bidhaa kubwa zaidi inayowezekana. \nKazi hii hutoa nambari katika mpangilio mdogo wa leksikografia. \nIkiwa hakuna mchanganyiko kama huo, inatoa ujumbe wa kosa. \nMatumizi ya Mfano:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "tr": "Bu fonksiyon, toplamları N olan ve mümkün olan en yüksek çarpıma sahip M pozitif tam sayı bulur.\nFonksiyon, tam sayıları sözlük sıralamasına göre en küçük sırada çıktılar.\nEğer böyle bir kombinasyon yoksa, bir hata mesajı verir.\nÖrnek Kullanım:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "vi": "Hàm này tìm M số nguyên dương có tổng bằng N và có tích lớn nhất có thể. Hàm xuất ra các số theo thứ tự từ điển nhỏ nhất. Nếu không tồn tại kết hợp nào như vậy, nó sẽ xuất ra thông báo lỗi.\n\nVí dụ sử dụng:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4"
    },
    "docstring_bertscore": {
      "es": "0.9742741875698854",
      "arb": "0.9563702409145437",
      "sw": "0.914708313014",
      "tr": "0.9628708173946725",
      "vi": "0.9629155092304054"
    }
  },
  {
    "task_id": "Shell/24",
    "prompt": {
      "en": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# This function calculates the sine of the smaller acute angle in a Pythagorean triplet (a, b, c).\n# It outputs the sine value in reduced fraction format.\n# The Pythagorean triplet is provided as three positive integers, which represent the sides of a right-angled triangle.\n# The function assumes that the input numbers form a valid Pythagorean triplet.\n# Example Usage:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "es": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Esta función calcula el seno del ángulo agudo menor en un triplete pitagórico (a, b, c).\n# Muestra el valor del seno en formato de fracción reducida.\n# El triplete pitagórico se proporciona como tres enteros positivos, que representan los lados de un triángulo rectángulo.\n# La función asume que los números de entrada forman un triplete pitagórico válido.\n# Ejemplo de uso:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "arb": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# تقوم هذه الدالة بحساب جيب الزاوية الحادة الأصغر في ثلاثية فيثاغورس (a, b, c).\n# تقوم بإخراج قيمة الجيب في صيغة كسر مبسط.\n# يتم تقديم ثلاثية فيثاغورس كثلاثة أعداد صحيحة موجبة، والتي تمثل أضلاع مثلث قائم الزاوية.\n# تفترض الدالة أن الأرقام المدخلة تشكل ثلاثية فيثاغورس صحيحة.\n# مثال على الاستخدام:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "sw": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Kazi ya hii kazi ni kuhesabu sine ya pembe ndogo kali katika pythagorean triplet (a, b, c).\n# Inatoa thamani ya sine katika muundo wa sehemu iliyopunguzwa.\n# Pythagorean triplet inatolewa kama namba tatu chanya, ambazo zinawakilisha pande za pembetatu ya mraba.\n# Kazi inadhani kwamba namba za pembejeo zinaunda pythagorean triplet halali.\n# Mfano wa Matumizi:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "tr": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Bu fonksiyon, bir Pisagor üçlüsündeki (a, b, c) daha küçük dik açının sinüsünü hesaplar.\n# Sinüs değerini sadeleştirilmiş kesir formatında çıktılar.\n# Pisagor üçlüsü, bir dik açılı üçgenin kenarlarını temsil eden üç pozitif tam sayı olarak verilir.\n# Fonksiyon, girilen sayıların geçerli bir Pisagor üçlüsü oluşturduğunu varsayar.\n# Örnek Kullanım:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "vi": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Hàm này tính sin của góc nhọn nhỏ hơn trong một bộ ba số Pythagoras (a, b, c).\n# Nó xuất giá trị sin dưới dạng phân số tối giản.\n# Bộ ba số Pythagoras được cung cấp dưới dạng ba số nguyên dương, đại diện cho các cạnh của một tam giác vuông.\n# Hàm giả định rằng các số đầu vào tạo thành một bộ ba số Pythagoras hợp lệ.\n# Ví dụ sử dụng:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17"
    },
    "prompt_bertscore": {
      "es": "0.9842513916092679",
      "arb": "0.9680640087068296",
      "sw": "0.9653892519958138",
      "tr": "0.9681949061279317",
      "vi": "0.9709284574317337"
    },
    "canonical_solution": "local -a sides=($(echo -e \"$a\\n$b\\n$c\" | sort -n))\nlocal opposite=${sides[0]} # Smallest side, opposite to the smaller acute angle\nlocal hypotenuse=${sides[2]} # Largest side, the hypotenuse\n\n# Function to calculate GCD (Greatest Common Divisor)\ngcd() {\nlocal x=$1\nlocal y=$2\nwhile [[ $y -ne 0 ]]; do\nlocal temp=$y\ny=$((x % y))\nx=$temp\ndone\necho $x\n}\n\n# Calculate GCD of opposite and hypotenuse\nlocal common_divisor=$(gcd $opposite $hypotenuse)\n\n# Calculate reduced fraction\nlocal numerator=$((opposite / common_divisor))\nlocal denominator=$((hypotenuse / common_divisor))\n\necho \"$numerator/$denominator\"\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` to solve the following problem:\nThis function calculates the sine of the smaller acute angle in a Pythagorean triplet (a, b, c).\nIt outputs the sine value in reduced fraction format.\nThe Pythagorean triplet is provided as three positive integers, which represent the sides of a right-angled triangle.\nThe function assumes that the input numbers form a valid Pythagorean triplet.\nExample Usage:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "es": "Escribe una función de Shell `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` para resolver el siguiente problema:\nEsta función calcula el seno del ángulo agudo menor en un triplete pitagórico (a, b, c).\nMuestra el valor del seno en formato de fracción reducida.\nEl triplete pitagórico se proporciona como tres enteros positivos, que representan los lados de un triángulo rectángulo.\nLa función asume que los números de entrada forman un triplete pitagórico válido.\nEjemplo de uso:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "arb": "اكتب دالة Shell `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` لحل المشكلة التالية:\nهذه الدالة تحسب جيب الزاوية الحادة الأصغر في ثلاثي فيثاغورس (a, b, c).\nتقوم بإخراج قيمة الجيب في صيغة كسر مبسط.\nيتم تقديم ثلاثي فيثاغورس كثلاثة أعداد صحيحة موجبة، والتي تمثل أضلاع مثلث قائم الزاوية.\nتفترض الدالة أن الأرقام المدخلة تشكل ثلاثي فيثاغورس صحيح.\nمثال على الاستخدام:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "sw": "Andika kazi ya Shell `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` kutatua tatizo lifuatalo:\nKazi hii inahesabu sine ya pembe ndogo kali katika tripleti ya Pythagoras (a, b, c).\nInatoa thamani ya sine katika muundo wa sehemu iliyopunguzwa.\nTripleti ya Pythagoras inatolewa kama nambari tatu chanya, ambazo zinawakilisha pande za pembetatu ya mstatili.\nKazi inadhani kwamba nambari za pembejeo zinaunda tripleti halali ya Pythagoras.\nMfano wa Matumizi:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "tr": "Bir Shell fonksiyonu yazın `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` şu problemi çözmek için:\nBu fonksiyon, bir Pisagor üçlüsündeki küçük dik açının sinüsünü hesaplar (a, b, c).\nSinüs değerini sadeleştirilmiş kesir formatında çıktılar.\nPisagor üçlüsü, bir dik üçgenin kenarlarını temsil eden üç pozitif tam sayı olarak verilir.\nFonksiyon, girilen sayıların geçerli bir Pisagor üçlüsü oluşturduğunu varsayar.\nÖrnek Kullanım:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "vi": "Viết một hàm Shell `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` để giải quyết vấn đề sau:\nHàm này tính sin của góc nhọn nhỏ hơn trong một bộ ba Pythagore (a, b, c).\nNó xuất giá trị sin dưới dạng phân số tối giản.\nBộ ba Pythagore được cung cấp dưới dạng ba số nguyên dương, đại diện cho các cạnh của một tam giác vuông.\nHàm giả định rằng các số đầu vào tạo thành một bộ ba Pythagore hợp lệ.\nVí dụ Sử Dụng:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17"
    },
    "instruction_bertscore": {
      "es": "0.9812641893088841",
      "arb": "0.9669659799604687",
      "sw": "0.9757706688606023",
      "tr": "0.9660034171339738",
      "vi": "0.9704666417958276"
    },
    "level": "hard",
    "test": "test_calculate_sine() {\n[[ $(calculate_sine 3 5 4) == \"3/5\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_sine 5 12 13) == \"5/13\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_sine 8 15 17) == \"8/17\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_sine 7 24 25) == \"7/25\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_sine 9 40 41) == \"9/41\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_sine",
    "entry_point": "calculate_sine",
    "signature": "calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n",
    "docstring": {
      "en": "This function calculates the sine of the smaller acute angle in a Pythagorean triplet (a, b, c).\nIt outputs the sine value in reduced fraction format.\nThe Pythagorean triplet is provided as three positive integers, which represent the sides of a right-angled triangle.\nThe function assumes that the input numbers form a valid Pythagorean triplet.\nExample Usage:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "es": "Esta función calcula el seno del ángulo agudo más pequeño en un triplete pitagórico (a, b, c).  \nDevuelve el valor del seno en formato de fracción reducida.  \nEl triplete pitagórico se proporciona como tres enteros positivos, que representan los lados de un triángulo rectángulo.  \nLa función asume que los números de entrada forman un triplete pitagórico válido.  \nUso de Ejemplo:  \n>>> calculate_sine 3 5 4  \n3/5  \n>>> calculate_sine 5 12 13  \n5/13  \n>>> calculate_sine 8 15 17  \n8/17  ",
      "arb": "هذه الدالة تحسب جيب الزاوية الحادة الأصغر في ثلاثية فيثاغورس (a, b, c).\nتُخرج قيمة الجيب بصيغة الكسر المبسط.\nتُعطى ثلاثية فيثاغورس كثلاثة أعداد صحيحة موجبة، والتي تمثل أضلاع مثلث قائم الزاوية.\nتفترض الدالة أن الأعداد المدخلة تشكل ثلاثية فيثاغورس صحيحة.\nمثال على الاستخدام:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "sw": "Kazi hii inahesabu sine ya pembe ndogo kali katika tatu pacha za Pythagoras (a, b, c).  \nInatoa thamani ya sine katika muundo wa sehemu iliyopunguzwa. \nTatu pacha za Pythagoras zinatolewa kama namba tatu nzima chanya, ambazo zinawakilisha pande za pembetatu ya pembe moja kwa moja.  \nKazi inadhani kwamba namba za pembejeo zinaunda tatu pacha halali za Pythagoras.  \nMfano wa Matumizi:  \n>>> calculate_sine 3 5 4  \n3/5  \n>>> calculate_sine 5 12 13  \n5/13  \n>>> calculate_sine 8 15 17  \n8/17  ",
      "tr": "Bu fonksiyon, bir Pisagor üçlüsündeki (a, b, c) daha küçük dik açının sinüsünü hesaplar.\nSinüs değerini sadeleştirilmiş kesir formatında çıktılar.\nPisagor üçlüsü, bir dik üçgenin kenarlarını temsil eden üç pozitif tam sayı olarak verilir.\nFonksiyon, girilen sayıların geçerli bir Pisagor üçlüsü oluşturduğunu varsayar.\nÖrnek Kullanım:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "vi": "Hàm này tính sin của góc nhọn nhỏ hơn trong một bộ ba Pythagoras (a, b, c). Nó xuất ra giá trị sin dưới dạng phân số tối giản. Bộ ba Pythagoras được cung cấp dưới dạng ba số nguyên dương, đại diện cho các cạnh của một tam giác vuông. Hàm giả định rằng các số đầu vào tạo thành một bộ ba Pythagoras hợp lệ. Ví dụ Sử dụng: \n>>> calculate_sine 3 5 4 \n3/5 \n>>> calculate_sine 5 12 13 \n5/13 \n>>> calculate_sine 8 15 17 \n8/17"
    },
    "docstring_bertscore": {
      "es": "0.9727729391500237",
      "arb": "0.9644602577037137",
      "sw": "0.8542462181788852",
      "tr": "0.9568133852946326",
      "vi": "0.9628008995005483"
    }
  },
  {
    "task_id": "Shell/25",
    "prompt": {
      "en": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# This function calculates the minimum cost needed to buy at least 'n' pencils,\n# where pencils are available in three different packaging options, each with its own quantity and price.\n# The function does not allow breaking the packaging, so it may require buying more pencils than 'n'.\n# Each packaging option is given in the format 'quantity price'.\n# Input: Number of pencils needed and three packaging options.\n# Output: Minimum cost to buy at least 'n' pencils.\n# Example Usage:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "es": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Esta función calcula el costo mínimo necesario para comprar al menos 'n' lápices,\n# donde los lápices están disponibles en tres opciones de empaque diferentes, cada una con su propia cantidad y precio.\n# La función no permite romper el empaque, por lo que puede requerir comprar más lápices que 'n'.\n# Cada opción de empaque se da en el formato 'cantidad precio'.\n# Entrada: Número de lápices necesarios y tres opciones de empaque.\n# Salida: Costo mínimo para comprar al menos 'n' lápices.\n# Ejemplo de uso:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "arb": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# هذه الدالة تحسب التكلفة الدنيا اللازمة لشراء ما لا يقل عن 'n' من الأقلام الرصاص،\n# حيث تتوفر الأقلام الرصاص في ثلاث خيارات تغليف مختلفة، كل منها بكمية وسعر خاص به.\n# لا تسمح الدالة بكسر التغليف، لذلك قد يتطلب الأمر شراء المزيد من الأقلام الرصاص أكثر من 'n'.\n# يتم إعطاء كل خيار تغليف في صيغة 'الكمية السعر'.\n# المدخلات: عدد الأقلام الرصاص المطلوبة وثلاثة خيارات تغليف.\n# المخرجات: التكلفة الدنيا لشراء ما لا يقل عن 'n' من الأقلام الرصاص.\n# مثال على الاستخدام:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "sw": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Kazi ya hii kazi ni kuhesabu gharama ndogo zaidi inayohitajika kununua angalau 'n' penseli,\n# ambapo penseli zinapatikana katika chaguo tatu tofauti za ufungaji, kila moja ikiwa na idadi na bei yake.\n# Kazi hii hairuhusu kuvunja ufungaji, hivyo inaweza kuhitaji kununua penseli zaidi ya 'n'.\n# Kila chaguo la ufungaji linatolewa katika muundo 'idadi bei'.\n# Ingizo: Idadi ya penseli zinazohitajika na chaguo tatu za ufungaji.\n# Tokeo: Gharama ndogo zaidi ya kununua angalau 'n' penseli.\n# Mfano wa Matumizi:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "tr": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Bu fonksiyon, en az 'n' kalem satın almak için gereken minimum maliyeti hesaplar,\n# kalemlerin her biri kendi miktar ve fiyatına sahip üç farklı paketleme seçeneğinde mevcut olduğu durumlarda.\n# Fonksiyon, paketlemeyi bozmayı izin vermez, bu yüzden 'n'den fazla kalem satın almayı gerektirebilir.\n# Her paketleme seçeneği 'miktar fiyat' formatında verilir.\n# Girdi: Gerekli kalem sayısı ve üç paketleme seçeneği.\n# Çıktı: En az 'n' kalem satın almak için minimum maliyet.\n# Örnek Kullanım:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "vi": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Hàm này tính toán chi phí tối thiểu cần thiết để mua ít nhất 'n' bút chì,\n# trong đó bút chì có sẵn trong ba tùy chọn đóng gói khác nhau, mỗi tùy chọn có số lượng và giá riêng.\n# Hàm không cho phép phá vỡ bao bì, vì vậy có thể cần mua nhiều bút chì hơn 'n'.\n# Mỗi tùy chọn đóng gói được đưa ra theo định dạng 'số lượng giá'.\n# Đầu vào: Số lượng bút chì cần thiết và ba tùy chọn đóng gói.\n# Đầu ra: Chi phí tối thiểu để mua ít nhất 'n' bút chì.\n# Ví dụ sử dụng:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18"
    },
    "prompt_bertscore": {
      "es": "0.99596939230804",
      "arb": "0.9843709670986509",
      "sw": "0.9702417922044961",
      "tr": "0.9569790430324157",
      "vi": "0.983130718999469"
    },
    "canonical_solution": "local min_cost=1000000 # Arbitrary large number\n\n# Function to calculate cost\ncalculate_cost() {\nlocal quantity=$1\nlocal price=$2\nlocal cost=$(( (n + quantity - 1) / quantity * price ))\nif (( cost < min_cost )); then\nmin_cost=$cost\nfi\n}\n\n# Calculate cost for each packaging option\ncalculate_cost ${pack1[0]} ${pack1[1]}\ncalculate_cost ${pack2[0]} ${pack2[1]}\ncalculate_cost ${pack3[0]} ${pack3[1]}\n\necho $min_cost\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` to solve the following problem:\nThis function calculates the minimum cost needed to buy at least 'n' pencils,\nwhere pencils are available in three different packaging options, each with its own quantity and price.\nThe function does not allow breaking the packaging, so it may require buying more pencils than 'n'.\nEach packaging option is given in the format 'quantity price'.\nInput: Number of pencils needed and three packaging options.\nOutput: Minimum cost to buy at least 'n' pencils.\nExample Usage:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "es": "Escribe una función de Shell `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` para resolver el siguiente problema:\nEsta función calcula el costo mínimo necesario para comprar al menos 'n' lápices,\ndonde los lápices están disponibles en tres opciones de empaque diferentes, cada una con su propia cantidad y precio.\nLa función no permite romper el empaque, por lo que puede requerir comprar más lápices de los que se necesitan 'n'.\nCada opción de empaque se da en el formato 'cantidad precio'.\nEntrada: Número de lápices necesarios y tres opciones de empaque.\nSalida: Costo mínimo para comprar al menos 'n' lápices.\nEjemplo de uso:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "arb": "اكتب دالة شيل `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` لحل المشكلة التالية:\nتحسب هذه الدالة التكلفة الدنيا اللازمة لشراء ما لا يقل عن 'n' من الأقلام الرصاص،\nحيث تتوفر الأقلام الرصاص في ثلاث خيارات تغليف مختلفة، كل منها بكمية وسعر خاصين بها.\nلا تسمح الدالة بكسر التغليف، لذا قد يتطلب الأمر شراء المزيد من الأقلام الرصاص عن 'n'.\nيتم تقديم كل خيار تغليف في صيغة 'الكمية السعر'.\nالمدخل: عدد الأقلام الرصاص المطلوبة وثلاث خيارات تغليف.\nالمخرج: التكلفة الدنيا لشراء ما لا يقل عن 'n' من الأقلام الرصاص.\nمثال على الاستخدام:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "sw": "Andika kazi ya Shell `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` kutatua tatizo lifuatalo:\nKazi hii inakokotoa gharama ya chini kabisa inayohitajika kununua angalau 'n' penseli,\nambapo penseli zinapatikana katika chaguo tatu tofauti za ufungaji, kila moja ikiwa na idadi na bei yake.\nKazi haikubali kuvunja ufungaji, hivyo inaweza kuhitaji kununua penseli zaidi ya 'n'.\nKila chaguo la ufungaji limetolewa katika muundo 'idadi bei'.\nIngizo: Idadi ya penseli zinazohitajika na chaguo tatu za ufungaji.\nPato: Gharama ya chini kabisa kununua angalau 'n' penseli.\nMfano wa Matumizi:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "tr": "Bir Shell fonksiyonu yazın `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` aşağıdaki problemi çözmek için:\nBu fonksiyon, en az 'n' kalem satın almak için gereken minimum maliyeti hesaplar,\nkalemlerin her biri kendi miktar ve fiyatına sahip üç farklı paketleme seçeneğiyle mevcut olduğu durumlarda.\nFonksiyon paketlemeyi bozmayı izin vermez, bu nedenle 'n'den fazla kalem satın almayı gerektirebilir.\nHer paketleme seçeneği 'miktar fiyat' formatında verilir.\nGirdi: Gerekli kalem sayısı ve üç paketleme seçeneği.\nÇıktı: En az 'n' kalem satın almak için minimum maliyet.\nÖrnek Kullanım:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "vi": "Viết một hàm Shell `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` để giải quyết vấn đề sau:\nHàm này tính toán chi phí tối thiểu cần thiết để mua ít nhất 'n' bút chì,\ntrong đó bút chì có sẵn trong ba tùy chọn đóng gói khác nhau, mỗi tùy chọn có số lượng và giá riêng.\nHàm không cho phép phá vỡ bao bì, vì vậy có thể cần mua nhiều bút chì hơn 'n'.\nMỗi tùy chọn đóng gói được đưa ra theo định dạng 'số lượng giá'.\nĐầu vào: Số lượng bút chì cần thiết và ba tùy chọn đóng gói.\nĐầu ra: Chi phí tối thiểu để mua ít nhất 'n' bút chì.\nVí dụ sử dụng:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18"
    },
    "instruction_bertscore": {
      "es": "0.9913655373364134",
      "arb": "0.9879888208588203",
      "sw": "0.9909227902170866",
      "tr": "0.9537185253277279",
      "vi": "0.9811877166121857"
    },
    "level": "middle",
    "test": "test_calculate_minimum_cost() {\n[[ $(calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\") -eq 54 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\") -eq 40 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\") -eq 27 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 80 \"8 4\" \"40 19\" \"60 28\") -eq 38 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 120 \"12 6\" \"24 9\" \"48 18\") -eq 45 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_minimum_cost",
    "entry_point": "calculate_minimum_cost",
    "signature": "calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n",
    "docstring": {
      "en": "This function calculates the minimum cost needed to buy at least 'n' pencils,\nwhere pencils are available in three different packaging options, each with its own quantity and price.\nThe function does not allow breaking the packaging, so it may require buying more pencils than 'n'.\nEach packaging option is given in the format 'quantity price'.\nInput: Number of pencils needed and three packaging options.\nOutput: Minimum cost to buy at least 'n' pencils.\nExample Usage:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "es": "Esta función calcula el costo mínimo necesario para comprar al menos 'n' lápices,\ndonde los lápices están disponibles en tres opciones de empaque diferentes, cada una con su propia cantidad y precio.\nLa función no permite romper el empaque, por lo que puede requerir comprar más lápices de los que se necesitan.\nCada opción de empaque se da en el formato 'cantidad precio'.\nEntrada: Número de lápices necesarios y tres opciones de empaque.\nSalida: Costo mínimo para comprar al menos 'n' lápices.\nEjemplo de uso:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "arb": "هذه الدالة تحسب التكلفة الدنيا اللازمة لشراء ما لا يقل عن 'n' من الأقلام الرصاص، حيث تتوفر الأقلام الرصاص في ثلاث خيارات تغليف مختلفة، كل منها يحتوي على كمية وسعر خاص به. لا تسمح الدالة بكسر التغليف، لذا قد يتطلب الأمر شراء أقلام أكثر من 'n'. يتم تقديم كل خيار تغليف بالصيغة 'الكمية السعر'. المدخلات: عدد الأقلام المطلوبة وثلاثة خيارات تغليف. المخرجات: التكلفة الدنيا لشراء ما لا يقل عن 'n' من الأقلام الرصاص. مثال على الاستخدام:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "sw": "Kazi ya kazi hii ni kuhesabu gharama ndogo zaidi inayohitajika kununua angalau 'n' penseli, ambapo penseli zinapatikana katika chaguo tatu tofauti za ufungaji, kila moja ikiwa na idadi na bei yake. Kazi hii hairuhusu kuvunja ufungaji, kwa hivyo inaweza kuhitaji kununua penseli zaidi ya 'n'. Kila chaguo la ufungaji linatolewa katika muundo wa 'idadi bei'.\n\nPembejeo: Idadi ya penseli zinazohitajika na chaguo tatu za ufungaji.\nPato: Gharama ndogo zaidi ya kununua angalau 'n' penseli.\n\nMfano wa Matumizi:\n\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "tr": "Bu fonksiyon, en az 'n' kalem satın almak için gereken minimum maliyeti hesaplar,\nkalemlerin her biri kendi miktar ve fiyatına sahip üç farklı paketleme seçeneğiyle mevcut olduğu durumlarda.\nFonksiyon, paketlemeyi bozmayı izin vermez, bu nedenle 'n' kalemden daha fazlasını satın almak gerekebilir.\nHer paketleme seçeneği 'miktar fiyat' formatında verilir.\nGirdi: Gerekli kalem sayısı ve üç paketleme seçeneği.\nÇıktı: En az 'n' kalem satın almak için minimum maliyet.\nÖrnek Kullanım:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "vi": "Hàm này tính toán chi phí tối thiểu cần thiết để mua ít nhất 'n' bút chì,\ntrong đó bút chì có sẵn trong ba tùy chọn đóng gói khác nhau, mỗi tùy chọn có số lượng và giá riêng.\nHàm không cho phép phá vỡ bao bì, vì vậy có thể cần mua nhiều bút chì hơn 'n'.\nMỗi tùy chọn đóng gói được đưa ra dưới dạng 'số lượng giá'.\nĐầu vào: Số lượng bút chì cần thiết và ba tùy chọn đóng gói.\nĐầu ra: Chi phí tối thiểu để mua ít nhất 'n' bút chì.\nVí dụ sử dụng:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18"
    },
    "docstring_bertscore": {
      "es": "0.9904148923327805",
      "arb": "0.9741164750473437",
      "sw": "1",
      "tr": "0.9343532549591126",
      "vi": "0.9712186564184258"
    }
  },
  {
    "task_id": "Shell/26",
    "prompt": {
      "en": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# This function generates a password by shifting each letter of the given string by 'n' positions in the alphabet.\n# The shift wraps around the alphabet, so 'z' followed by a shift of 1 would be 'a'.\n# Input: Shift amount 'n' and the original string.\n# Output: Transformed string representing the password.\n# Example Usage:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "es": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Esta función genera una contraseña desplazando cada letra de la cadena dada por 'n' posiciones en el alfabeto.\n# El desplazamiento envuelve el alfabeto, por lo que 'z' seguido de un desplazamiento de 1 sería 'a'.\n# Entrada: Cantidad de desplazamiento 'n' y la cadena original.\n# Salida: Cadena transformada que representa la contraseña.\n# Ejemplo de uso:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "arb": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# تقوم هذه الدالة بتوليد كلمة مرور عن طريق تحريك كل حرف من الحروف في السلسلة المعطاة بمقدار 'n' من المواضع في الأبجدية.\n# يتم الالتفاف حول الأبجدية، لذا فإن 'z' متبوعًا بتحريك بمقدار 1 سيكون 'a'.\n# المدخلات: مقدار التحريك 'n' والسلسلة الأصلية.\n# المخرجات: سلسلة محولة تمثل كلمة المرور.\n# مثال على الاستخدام:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "sw": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Kazi ya hii kazi ni kutengeneza nenosiri kwa kusogeza kila herufi ya string iliyotolewa kwa nafasi 'n' katika alfabeti.\n# Mabadiliko yanazunguka katika alfabeti, hivyo 'z' ikifuatiwa na mabadiliko ya 1 itakuwa 'a'.\n# Ingizo: Kiasi cha mabadiliko 'n' na string ya asili.\n# Tokeo: String iliyobadilishwa inayowakilisha nenosiri.\n# Mfano wa Matumizi:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "tr": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Bu fonksiyon, verilen stringin her harfini alfabede 'n' pozisyon kaydırarak bir şifre oluşturur.\n# Kaydırma alfabenin etrafında döner, bu yüzden 'z' harfi 1 kaydırıldığında 'a' olur.\n# Girdi: Kaydırma miktarı 'n' ve orijinal string.\n# Çıktı: Şifreyi temsil eden dönüştürülmüş string.\n# Örnek Kullanım:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "vi": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Hàm này tạo mật khẩu bằng cách dịch chuyển mỗi chữ cái của chuỗi đã cho theo 'n' vị trí trong bảng chữ cái.\n# Sự dịch chuyển này quay vòng quanh bảng chữ cái, vì vậy 'z' sau khi dịch chuyển 1 vị trí sẽ trở thành 'a'.\n# Đầu vào: Số lượng dịch chuyển 'n' và chuỗi gốc.\n# Đầu ra: Chuỗi đã biến đổi đại diện cho mật khẩu.\n# Ví dụ sử dụng:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab"
    },
    "prompt_bertscore": {
      "es": "0.9859002224022385",
      "arb": "0.9824273688202245",
      "sw": "0.9561531379080725",
      "tr": "0.9663843902047986",
      "vi": "0.9655872864857056"
    },
    "canonical_solution": "local shifted_string=\"\"\nlocal alphabet=(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n\n# Function to find index of a character in the alphabet array\nfind_index() {\nlocal char=$1\nfor i in \"${!alphabet[@]}\"; do\nif [[ \"${alphabet[$i]}\" = \"${char}\" ]]; then\necho $i\nreturn\nfi\ndone\n}\n\n# Shift each character\nfor (( i=0; i<${#string}; i++ )); do\nlocal char=${string:$i:1}\nlocal index=$(find_index $char)\nlocal new_index=$(((index + shift) % 26))\nshifted_string+=\"${alphabet[$new_index]}\"\ndone\n\necho $shifted_string\n}",
    "instruction": {
      "en": "Write a Shell function `generate_password() {\nlocal shift=$1\nlocal string=$2\n` to solve the following problem:\nThis function generates a password by shifting each letter of the given string by 'n' positions in the alphabet.\nThe shift wraps around the alphabet, so 'z' followed by a shift of 1 would be 'a'.\nInput: Shift amount 'n' and the original string.\nOutput: Transformed string representing the password.\nExample Usage:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "es": "Escribe una función de Shell `generate_password() {\nlocal shift=$1\nlocal string=$2\n` para resolver el siguiente problema:\nEsta función genera una contraseña desplazando cada letra de la cadena dada por 'n' posiciones en el alfabeto.\nEl desplazamiento envuelve el alfabeto, por lo que 'z' seguido de un desplazamiento de 1 sería 'a'.\nEntrada: Cantidad de desplazamiento 'n' y la cadena original.\nSalida: Cadena transformada que representa la contraseña.\nEjemplo de uso:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "arb": "اكتب دالة شل `generate_password() {\nlocal shift=$1\nlocal string=$2\n` لحل المشكلة التالية:\nتقوم هذه الدالة بإنشاء كلمة مرور عن طريق تحريك كل حرف من السلسلة المعطاة بمقدار 'n' من المواضع في الأبجدية.\nالتحريك يلتف حول الأبجدية، لذا فإن 'z' متبوعًا بتحريك بمقدار 1 سيكون 'a'.\nالمدخلات: مقدار التحريك 'n' والسلسلة الأصلية.\nالمخرجات: سلسلة محولة تمثل كلمة المرور.\nمثال على الاستخدام:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "sw": "Andika kazi ya Shell `generate_password() {\nlocal shift=$1\nlocal string=$2\n` kutatua tatizo lifuatalo:\nKazi hii inazalisha nenosiri kwa kusogeza kila herufi ya kamba iliyotolewa kwa nafasi 'n' katika alfabeti.\nKusogeza kunazunguka alfabeti, hivyo 'z' ikifuatiwa na kusogeza kwa 1 itakuwa 'a'.\nIngizo: Kiasi cha kusogeza 'n' na kamba asilia.\nMatokeo: Kamba iliyobadilishwa inayowakilisha nenosiri.\nMfano wa Matumizi:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "tr": "Bir Shell fonksiyonu `generate_password() {\nlocal shift=$1\nlocal string=$2\n` aşağıdaki problemi çözmek için yazın:\nBu fonksiyon, verilen dizenin her harfini alfabede 'n' pozisyon kaydırarak bir şifre oluşturur.\nKaydırma alfabe etrafında döner, bu yüzden 'z' 1 kaydırıldığında 'a' olur.\nGirdi: Kaydırma miktarı 'n' ve orijinal dize.\nÇıktı: Şifreyi temsil eden dönüştürülmüş dize.\nÖrnek Kullanım:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "vi": "Viết một hàm Shell `generate_password() {\nlocal shift=$1\nlocal string=$2\n` để giải quyết vấn đề sau:\nHàm này tạo ra một mật khẩu bằng cách dịch chuyển mỗi chữ cái của chuỗi đã cho 'n' vị trí trong bảng chữ cái.\nSự dịch chuyển sẽ quay vòng quanh bảng chữ cái, vì vậy 'z' khi dịch chuyển 1 sẽ thành 'a'.\nĐầu vào: Số lượng dịch chuyển 'n' và chuỗi gốc.\nĐầu ra: Chuỗi đã biến đổi đại diện cho mật khẩu.\nVí dụ Sử dụng:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab"
    },
    "instruction_bertscore": {
      "es": "0.9888606096011824",
      "arb": "0.9745574344932412",
      "sw": "0.9833420617248901",
      "tr": "0.9503702129946229",
      "vi": "0.9538998748656128"
    },
    "level": "middle",
    "test": "test_generate_password() {\n[[ $(generate_password 1 \"qwe\") == \"rxf\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(generate_password 3 \"abc\") == \"def\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(generate_password 2 \"xyz\") == \"zab\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(generate_password 4 \"hello\") == \"lipps\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(generate_password 5 \"password\") == \"ufxxbtwi\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_generate_password",
    "entry_point": "generate_password",
    "signature": "generate_password() {\nlocal shift=$1\nlocal string=$2\n",
    "docstring": {
      "en": "This function generates a password by shifting each letter of the given string by 'n' positions in the alphabet.\nThe shift wraps around the alphabet, so 'z' followed by a shift of 1 would be 'a'.\nInput: Shift amount 'n' and the original string.\nOutput: Transformed string representing the password.\nExample Usage:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "es": "Esta función genera una contraseña desplazando cada letra de la cadena dada por 'n' posiciones en el alfabeto.  \nEl desplazamiento envuelve el alfabeto, por lo que 'z' seguido de un desplazamiento de 1 sería 'a'.  \nEntrada: Cantidad de desplazamiento 'n' y la cadena original.  \nSalida: Cadena transformada que representa la contraseña.  \nEjemplo de uso:  \n>>> generate_password 1 \"qwe\"  \nrxf  \n>>> generate_password 3 \"abc\"  \ndef  \n>>> generate_password 2 \"xyz\"  \nzab  ",
      "arb": "هذه الدالة تولد كلمة مرور عن طريق تحريك كل حرف من السلسلة المعطاة بمقدار 'n' من المواقع في الأبجدية.\nالتحريك يلتف حول الأبجدية، لذلك 'z' متبوعًا بتحريك بمقدار 1 سيكون 'a'.\nالمدخلات: مقدار التحريك 'n' والسلسلة الأصلية.\nالمخرجات: سلسلة محولة تمثل كلمة المرور.\nمثال على الاستخدام:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "sw": "Kazi ya kazi hii ni kuzalisha nywila kwa kusogeza kila herufi ya mfululizo uliotolewa kwa nafasi 'n' katika alfabeti. \nMabadiliko yanazunguka alfabeti, hivyo 'z' ikifuatiwa na mabadiliko ya 1 itakuwa 'a'. \nIngizo: Kiasi cha mabadiliko 'n' na mfululizo wa asili. \nMatokeo: Mfululizo uliobadilishwa unaowakilisha nywila. \nMfano wa Matumizi:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "tr": "Bu fonksiyon, verilen dizenin her harfini alfabede 'n' pozisyon kaydırarak bir şifre oluşturur.  \nKaydırma alfabede döner, bu yüzden 'z' harfinden sonra 1 kaydırma 'a' olur.  \nGirdi: Kaydırma miktarı 'n' ve orijinal dize.  \nÇıktı: Şifreyi temsil eden dönüştürülmüş dize.  \nÖrnek Kullanım:  \n>>> generate_password 1 \"qwe\"  \nrxf  \n>>> generate_password 3 \"abc\"  \ndef  \n>>> generate_password 2 \"xyz\"  \nzab  ",
      "vi": "Hàm này tạo ra một mật khẩu bằng cách dịch chuyển mỗi chữ cái của chuỗi đã cho theo 'n' vị trí trong bảng chữ cái.  \nSự dịch chuyển này quay vòng quanh bảng chữ cái, vì vậy 'z' sau khi dịch chuyển 1 sẽ là 'a'.  \nĐầu vào: Số lượng dịch chuyển 'n' và chuỗi gốc.  \nĐầu ra: Chuỗi đã biến đổi đại diện cho mật khẩu.  \nVí dụ Sử dụng:  \n>>> generate_password 1 \"qwe\"  \nrxf  \n>>> generate_password 3 \"abc\"  \ndef  \n>>> generate_password 2 \"xyz\"  \nzab  "
    },
    "docstring_bertscore": {
      "es": "0.9837816307581203",
      "arb": "0.9687083656629069",
      "sw": "0.9430022176405147",
      "tr": "0.9245947429692495",
      "vi": "0.9612692606323882"
    }
  },
  {
    "task_id": "Shell/27",
    "prompt": {
      "en": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# generate shell function\n# This function calculates the number of times a specific digit 'x' appears in all integers from 1 to 'n'.\n# Input: Upper limit of the range 'n' and the digit 'x' to be counted.\n# Output: Number of occurrences of the digit 'x'.\n# Example Usage:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "es": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# generar función de shell\n# Esta función calcula el número de veces que un dígito específico 'x' aparece en todos los enteros desde 1 hasta 'n'.\n# Entrada: Límite superior del rango 'n' y el dígito 'x' que se va a contar.\n# Salida: Número de ocurrencias del dígito 'x'.\n# Ejemplo de uso:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "arb": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# توليد دالة شل\n# تقوم هذه الدالة بحساب عدد المرات التي يظهر فيها رقم معين 'x' في جميع الأعداد الصحيحة من 1 إلى 'n'.\n# المدخل: الحد الأعلى للنطاق 'n' والرقم 'x' الذي سيتم حسابه.\n# المخرج: عدد مرات ظهور الرقم 'x'.\n# مثال على الاستخدام:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "sw": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# tengeneza kazi ya shell\n# Kazi hii inahesabu idadi ya mara ambazo tarakimu maalum 'x' inaonekana katika nambari zote kutoka 1 hadi 'n'.\n# Ingizo: Kiwango cha juu cha safu 'n' na tarakimu 'x' inayopaswa kuhesabiwa.\n# Matokeo: Idadi ya matukio ya tarakimu 'x'.\n# Mfano wa Matumizi:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "tr": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# shell fonksiyonu oluştur\n# Bu fonksiyon, belirli bir 'x' rakamının 1'den 'n'ye kadar olan tüm tamsayılarda kaç kez göründüğünü hesaplar.\n# Girdi: Aralığın üst sınırı 'n' ve sayılacak olan rakam 'x'.\n# Çıktı: 'x' rakamının kaç kez geçtiği.\n# Örnek Kullanım:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "vi": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# tạo hàm shell\n# Hàm này tính số lần một chữ số cụ thể 'x' xuất hiện trong tất cả các số nguyên từ 1 đến 'n'.\n# Đầu vào: Giới hạn trên của phạm vi 'n' và chữ số 'x' cần đếm.\n# Đầu ra: Số lần xuất hiện của chữ số 'x'.\n# Ví dụ sử dụng:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20"
    },
    "prompt_bertscore": {
      "es": "0.9978955111129354",
      "arb": "0.9683252076578905",
      "sw": "0.9764358820066881",
      "tr": "0.9746748250484328",
      "vi": "0.9863117845517427"
    },
    "canonical_solution": "local count=0\n\nfor (( i=1; i<=n; i++ )); do\nlocal num=$i\nwhile [[ $num -gt 0 ]]; do\nif [[ $((num % 10)) -eq $x ]]; then\n((count++))\nfi\nnum=$((num / 10))\ndone\ndone\n\necho $count\n}",
    "instruction": {
      "en": "Write a Shell function `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` to solve the following problem:\ngenerate shell function\nThis function calculates the number of times a specific digit 'x' appears in all integers from 1 to 'n'.\nInput: Upper limit of the range 'n' and the digit 'x' to be counted.\nOutput: Number of occurrences of the digit 'x'.\nExample Usage:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "es": "Escribe una función Shell `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` para resolver el siguiente problema:\ngenera función shell\nEsta función calcula el número de veces que un dígito específico 'x' aparece en todos los enteros desde 1 hasta 'n'.\nEntrada: Límite superior del rango 'n' y el dígito 'x' a contar.\nSalida: Número de ocurrencias del dígito 'x'.\nEjemplo de uso:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "arb": "اكتب دالة شل `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` لحل المشكلة التالية:\nتوليد دالة شل\nتحسب هذه الدالة عدد المرات التي يظهر فيها رقم معين 'x' في جميع الأعداد الصحيحة من 1 إلى 'n'.\nالمدخلات: الحد الأعلى للنطاق 'n' والرقم 'x' الذي سيتم حسابه.\nالمخرجات: عدد مرات ظهور الرقم 'x'.\nمثال على الاستخدام:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "sw": "Andika kazi ya Shell `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` kutatua tatizo lifuatalo:\nzalisha kazi ya shell\nKazi hii inahesabu idadi ya mara ambazo tarakimu maalum 'x' inaonekana katika nambari zote kutoka 1 hadi 'n'.\nIngizo: Kiwango cha juu cha safu 'n' na tarakimu 'x' inayohesabiwa.\nMatokeo: Idadi ya matukio ya tarakimu 'x'.\nMfano wa Matumizi:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "tr": "Bir Shell fonksiyonu yazın `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` aşağıdaki problemi çözmek için:\nshell fonksiyonu oluştur\nBu fonksiyon, 1'den 'n'ye kadar olan tüm tamsayılarda belirli bir 'x' rakamının kaç kez göründüğünü hesaplar.\nGirdi: Aralığın üst sınırı 'n' ve sayılacak rakam 'x'.\nÇıktı: 'x' rakamının kaç kez geçtiği.\nÖrnek Kullanım:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "vi": "Viết một hàm Shell `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` để giải quyết vấn đề sau:\ntạo hàm shell\nHàm này tính toán số lần một chữ số cụ thể 'x' xuất hiện trong tất cả các số nguyên từ 1 đến 'n'.\nĐầu vào: Giới hạn trên của phạm vi 'n' và chữ số 'x' cần đếm.\nĐầu ra: Số lần xuất hiện của chữ số 'x'.\nVí dụ Sử dụng:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20"
    },
    "instruction_bertscore": {
      "es": "0.9935246495782627",
      "arb": "0.9683065364020732",
      "sw": "0.9756405659610244",
      "tr": "0.9772445062878812",
      "vi": "0.9858906881439488"
    },
    "level": "easy",
    "test": "test_count_digit_occurrences() {\n[[ $(count_digit_occurrences 11 1) -eq 4 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_digit_occurrences 20 2) -eq 3 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_digit_occurrences 100 3) -eq 20 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_digit_occurrences 50 4) -eq 15 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_digit_occurrences 99 5) -eq 20 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_count_digit_occurrences",
    "entry_point": "count_digit_occurrences",
    "signature": "count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n",
    "docstring": {
      "en": "generate shell function\nThis function calculates the number of times a specific digit 'x' appears in all integers from 1 to 'n'.\nInput: Upper limit of the range 'n' and the digit 'x' to be counted.\nOutput: Number of occurrences of the digit 'x'.\nExample Usage:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "es": "generate shell function  \nEsta función calcula el número de veces que un dígito específico 'x' aparece en todos los enteros desde 1 hasta 'n'.  \nEntrada: Límite superior del rango 'n' y el dígito 'x' a contar.  \nSalida: Número de ocurrencias del dígito 'x'.  \nEjemplo de uso:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "arb": "generate shell function  \nهذه الدالة تحسب عدد المرات التي يظهر فيها رقم معين 'x' في جميع الأعداد الصحيحة من 1 إلى 'n'.  \nالمدخلات: الحد الأعلى للنطاق 'n' والرقم 'x' الذي سيتم حسابه.  \nالمخرجات: عدد مرات ظهور الرقم 'x'.  \nمثال على الاستخدام:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "sw": "generate shell function  \nKazi ya kazi hii ni kuhesabu mara ngapi tarakimu maalum 'x' inaonekana katika nambari zote kutoka 1 hadi 'n'.  \nIngizo: Kiwango cha juu cha safu 'n' na tarakimu 'x' inayopaswa kuhesabiwa.  \nPato: Idadi ya matukio ya tarakimu 'x'.  \nMfano wa Matumizi:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "tr": "generate shell function  \nBu fonksiyon, belirli bir 'x' rakamının 1'den 'n'ye kadar olan tüm tamsayılarda kaç kez göründüğünü hesaplar.  \nGirdi: Aralığın üst sınırı 'n' ve sayılması gereken rakam 'x'.  \nÇıktı: 'x' rakamının kaç kez geçtiği.  \nÖrnek Kullanım:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "vi": "generate shell function  \nHàm này tính toán số lần một chữ số cụ thể 'x' xuất hiện trong tất cả các số nguyên từ 1 đến 'n'.  \nĐầu vào: Giới hạn trên của phạm vi 'n' và chữ số 'x' cần đếm.  \nĐầu ra: Số lần xuất hiện của chữ số 'x'.  \nVí dụ sử dụng:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  "
    },
    "docstring_bertscore": {
      "es": "0.9881209100622085",
      "arb": "0.9554768014606487",
      "sw": "0.9568976045761913",
      "tr": "0.9788087205385309",
      "vi": "0.9899379807879156"
    }
  },
  {
    "task_id": "Shell/28",
    "prompt": {
      "en": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# This function converts a number 'N' from base 'M' to its decimal representation as an expression.\n# It outputs the expression as a sum of terms, each term in the form of coefficient*base^power.\n# Coefficients that are zero are omitted in the output.\n# Input: Base 'M' and number 'N' in base 'M'.\n# Output: Decimal representation as an expression.\n# Example Usage:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "es": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Esta función convierte un número 'N' de base 'M' a su representación decimal como una expresión.\n# Produce la expresión como una suma de términos, cada término en la forma de coeficiente*base^potencia.\n# Los coeficientes que son cero se omiten en la salida.\n# Entrada: Base 'M' y número 'N' en base 'M'.\n# Salida: Representación decimal como una expresión.\n# Ejemplo de uso:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "arb": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# تقوم هذه الدالة بتحويل الرقم 'N' من الأساس 'M' إلى تمثيله العشري كتعبير.\n# تقوم بإخراج التعبير كمجموع من الحدود، كل حد في شكل معامل*أساس^قوة.\n# يتم حذف المعاملات التي تساوي صفر في الإخراج.\n# المدخلات: الأساس 'M' والرقم 'N' في الأساس 'M'.\n# المخرجات: التمثيل العشري كتعبير.\n# مثال على الاستخدام:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "sw": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Kazi hii inabadilisha nambari 'N' kutoka msingi 'M' hadi uwakilishi wake wa desimali kama usemi.\n# Inatoa usemi kama jumla ya maneno, kila neno likiwa katika umbo la coefficient*base^power.\n# Vipengele ambavyo ni sifuri havionyeshwi katika matokeo.\n# Ingizo: Msingi 'M' na nambari 'N' katika msingi 'M'.\n# Matokeo: Uwakilishi wa desimali kama usemi.\n# Mfano wa Matumizi:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "tr": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Bu fonksiyon, 'N' sayısını 'M' tabanından ondalık gösterimine bir ifade olarak dönüştürür.\n# Her terim, katsayı*taban^kuvvet şeklinde olan terimlerin toplamı olarak ifadeyi çıktılar.\n# Katsayıları sıfır olan terimler çıktıda yer almaz.\n# Girdi: 'M' tabanı ve 'M' tabanında 'N' sayısı.\n# Çıktı: Ondalık gösterim olarak ifade.\n# Örnek Kullanım:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "vi": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Hàm này chuyển đổi một số 'N' từ cơ số 'M' sang biểu diễn thập phân dưới dạng một biểu thức.\n# Nó xuất biểu thức dưới dạng tổng của các hạng tử, mỗi hạng tử có dạng hệ số*cơ số^mũ.\n# Các hệ số bằng không sẽ bị loại bỏ trong đầu ra.\n# Đầu vào: Cơ số 'M' và số 'N' trong cơ số 'M'.\n# Đầu ra: Biểu diễn thập phân dưới dạng một biểu thức.\n# Ví dụ sử dụng:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0"
    },
    "prompt_bertscore": {
      "es": "0.9969718798411231",
      "arb": "0.984685001731067",
      "sw": "0.973258193170892",
      "tr": "0.9629441120052744",
      "vi": "0.9679942894430864"
    },
    "canonical_solution": "local length=${#num}\nlocal expression=\"\"\nlocal coefficient\n\nfor (( i=0; i<length; i++ )); do\ncoefficient=${num:$i:1}\nif [[ $coefficient -ne 0 ]]; then\nif [[ -n $expression ]]; then\nexpression+=\"+\"\nfi\nexpression+=\"${coefficient}*${base}^$((length-i-1))\"\nfi\ndone\n\necho $expression\n}",
    "instruction": {
      "en": "Write a Shell function `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` to solve the following problem:\nThis function converts a number 'N' from base 'M' to its decimal representation as an expression.\nIt outputs the expression as a sum of terms, each term in the form of coefficient*base^power.\nCoefficients that are zero are omitted in the output.\nInput: Base 'M' and number 'N' in base 'M'.\nOutput: Decimal representation as an expression.\nExample Usage:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "es": "Escribe una función de Shell `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` para resolver el siguiente problema:\nEsta función convierte un número 'N' de base 'M' a su representación decimal como una expresión.\nMuestra la expresión como una suma de términos, cada término en la forma de coeficiente*base^potencia.\nLos coeficientes que son cero se omiten en la salida.\nEntrada: Base 'M' y número 'N' en base 'M'.\nSalida: Representación decimal como una expresión.\nEjemplo de uso:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "arb": "اكتب دالة Shell `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` لحل المشكلة التالية:\nهذه الدالة تقوم بتحويل الرقم 'N' من الأساس 'M' إلى تمثيله العشري كتعبير.\nتقوم بإخراج التعبير كمجموع من الحدود، كل حد في شكل معامل*الأساس^الأس.\nالمعاملات التي تكون صفرًا يتم حذفها في الإخراج.\nالمدخل: الأساس 'M' والرقم 'N' في الأساس 'M'.\nالمخرج: التمثيل العشري كتعبير.\nمثال على الاستخدام:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "sw": "Andika kazi ya Shell `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` kutatua tatizo lifuatalo:\nKazi hii hubadilisha nambari 'N' kutoka msingi 'M' hadi uwakilishi wake wa desimali kama usemi.\nInatoa usemi kama jumla ya maneno, kila neno katika umbo la coefficient*base^power.\nViwango ambavyo ni sifuri havijumuishwi katika matokeo.\nIngizo: Msingi 'M' na nambari 'N' katika msingi 'M'.\nMatokeo: Uwakilishi wa desimali kama usemi.\nMfano wa Matumizi:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "tr": "Bir Shell fonksiyonu yazın `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` aşağıdaki problemi çözmek için:\nBu fonksiyon, bir sayıyı 'N' taban 'M' den ondalık gösterimine bir ifade olarak dönüştürür.\nHer terim katsayı*taban^kuvvet şeklinde olan terimlerin toplamı olarak ifadeyi çıktı verir.\nKatsayıları sıfır olan terimler çıktıda atlanır.\nGirdi: Taban 'M' ve taban 'M'de sayı 'N'.\nÇıktı: Ondalık gösterim olarak ifade.\nÖrnek Kullanım:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "vi": "Viết một hàm Shell `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` để giải quyết vấn đề sau:\nHàm này chuyển đổi một số 'N' từ cơ số 'M' sang biểu diễn thập phân dưới dạng biểu thức.\nNó xuất biểu thức dưới dạng tổng của các hạng tử, mỗi hạng tử có dạng hệ số*cơ số^số mũ.\nCác hệ số bằng không sẽ bị loại bỏ trong đầu ra.\nĐầu vào: Cơ số 'M' và số 'N' trong cơ số 'M'.\nĐầu ra: Biểu diễn thập phân dưới dạng biểu thức.\nVí dụ Sử dụng:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0"
    },
    "instruction_bertscore": {
      "es": "0.992724169142692",
      "arb": "0.9819589983817442",
      "sw": "0.9837671307403048",
      "tr": "0.960596102271061",
      "vi": "0.9823354029538053"
    },
    "level": "easy",
    "test": "test_convert_to_decimal_expression() {\n[[ $(convert_to_decimal_expression 2 10101) == \"1*2^4+1*2^2+1*2^0\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 3 102) == \"1*3^2+2*3^0\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 5 143) == \"1*5^2+4*5^1+3*5^0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 8 123) == \"1*8^2+2*8^1+3*8^0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 4 1302) == \"1*4^3+3*4^2+2*4^0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_convert_to_decimal_expression",
    "entry_point": "convert_to_decimal_expression",
    "signature": "convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n",
    "docstring": {
      "en": "This function converts a number 'N' from base 'M' to its decimal representation as an expression.\nIt outputs the expression as a sum of terms, each term in the form of coefficient*base^power.\nCoefficients that are zero are omitted in the output.\nInput: Base 'M' and number 'N' in base 'M'.\nOutput: Decimal representation as an expression.\nExample Usage:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "es": "Esta función convierte un número 'N' de base 'M' a su representación decimal como una expresión.\nProduce la expresión como una suma de términos, cada término en la forma de coeficiente*base^potencia.\nLos coeficientes que son cero se omiten en la salida.\nEntrada: Base 'M' y número 'N' en base 'M'.\nSalida: Representación decimal como una expresión.\nEjemplo de uso:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "arb": "هذه الدالة تحول الرقم 'N' من الأساس 'M' إلى تمثيله العشري كتعبير.\nتقوم بإخراج التعبير كمجموع من الحدود، كل حد في شكل معامل*أساس^قوة.\nالمعاملات التي تساوي صفر يتم تجاهلها في المخرجات.\nالمدخلات: الأساس 'M' والرقم 'N' في الأساس 'M'.\nالمخرجات: التمثيل العشري كتعبير.\nمثال على الاستخدام:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "sw": "Kazi ya hii kazi ni kubadilisha namba 'N' kutoka msingi 'M' kwenda uwakilishi wake wa desimali kama usemi.\nInatoa usemi kama jumla ya maneno, kila neno likiwa katika umbo la coefficient*base^power.\nViwango ambavyo ni sifuri havionyeshwi katika matokeo.\nIngizo: Msingi 'M' na namba 'N' katika msingi 'M'.\nMatokeo: Uwakilishi wa desimali kama usemi.\nMfano wa Matumizi:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "tr": "Bu fonksiyon, bir sayıyı 'M' tabanından ondalık gösterimine bir ifade olarak dönüştürür.\nÇıktı, her terim katsayı*taban^kuvvet şeklinde olan terimlerin toplamı olarak verilir.\nKatsayıları sıfır olan terimler çıktıda yer almaz.\nGirdi: 'M' tabanı ve 'M' tabanında 'N' sayısı.\nÇıktı: Ondalık gösterim olarak ifade.\nÖrnek Kullanım:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "vi": "Hàm này chuyển đổi một số 'N' từ cơ số 'M' sang biểu diễn thập phân dưới dạng biểu thức. Nó xuất ra biểu thức dưới dạng tổng của các hạng tử, mỗi hạng tử có dạng hệ số*cơ số^lũy thừa. Các hệ số bằng không được bỏ qua trong đầu ra. Đầu vào: Cơ số 'M' và số 'N' trong cơ số 'M'. Đầu ra: Biểu diễn thập phân dưới dạng biểu thức. Ví dụ sử dụng: \n>>> convert_to_decimal_expression 2 10101 \n1*2^4+1*2^2+1*2^0 \n>>> convert_to_decimal_expression 3 102 \n1*3^2+2*3^0"
    },
    "docstring_bertscore": {
      "es": "0.9945525618001182",
      "arb": "0.9668897058941514",
      "sw": "0.9406440777568685",
      "tr": "0.9427833269606143",
      "vi": "0.9617870900357461"
    }
  },
  {
    "task_id": "Shell/29",
    "prompt": {
      "en": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# This function arranges cards with numbers 0 and 5 to form the largest number divisible by 90.\n# If it's not possible to form such a number, the function returns -1.\n# Input: A string of numbers (only 0s and 5s) representing the cards.\n# Output: The largest number divisible by 90 that can be formed, or -1 if it's not possible.\n# Example Usage:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "es": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Esta función organiza cartas con números 0 y 5 para formar el número más grande divisible por 90.\n# Si no es posible formar tal número, la función devuelve -1.\n# Entrada: Una cadena de números (solo 0s y 5s) que representan las cartas.\n# Salida: El número más grande divisible por 90 que se puede formar, o -1 si no es posible.\n# Ejemplo de uso:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "arb": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# تقوم هذه الدالة بترتيب البطاقات التي تحتوي على الأرقام 0 و 5 لتشكيل أكبر رقم قابل للقسمة على 90.\n# إذا لم يكن من الممكن تشكيل مثل هذا الرقم، فإن الدالة تُرجع -1.\n# المدخل: سلسلة من الأرقام (فقط 0 و 5) تمثل البطاقات.\n# المخرج: أكبر رقم قابل للقسمة على 90 يمكن تشكيله، أو -1 إذا لم يكن ذلك ممكنًا.\n# مثال على الاستخدام:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "sw": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Kazi ya hii kazi ni kupanga kadi zenye namba 0 na 5 ili kuunda namba kubwa zaidi inayogawanyika kwa 90.\n# Ikiwa haiwezekani kuunda namba kama hiyo, kazi inarudisha -1.\n# Ingizo: Mfululizo wa namba (ni 0s na 5s pekee) zinazowakilisha kadi.\n# Tokeo: Namba kubwa zaidi inayogawanyika kwa 90 inayoweza kuundwa, au -1 ikiwa haiwezekani.\n# Mfano wa Matumizi:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "tr": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Bu fonksiyon, 0 ve 5 numaralı kartları 90'a bölünebilen en büyük sayıyı oluşturacak şekilde düzenler.\n# Böyle bir sayı oluşturmak mümkün değilse, fonksiyon -1 döndürür.\n# Girdi: Kartları temsil eden bir sayı dizisi (yalnızca 0 ve 5'ler).\n# Çıktı: Oluşturulabilecek 90'a bölünebilen en büyük sayı veya mümkün değilse -1.\n# Örnek Kullanım:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "vi": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Hàm này sắp xếp các lá bài với các số 0 và 5 để tạo thành số lớn nhất chia hết cho 90.\n# Nếu không thể tạo ra một số như vậy, hàm sẽ trả về -1.\n# Đầu vào: Một chuỗi các số (chỉ 0 và 5) đại diện cho các lá bài.\n# Đầu ra: Số lớn nhất chia hết cho 90 có thể được tạo thành, hoặc -1 nếu không thể.\n# Ví dụ sử dụng:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1"
    },
    "prompt_bertscore": {
      "es": "0.9984532652228814",
      "arb": "0.9850330021586401",
      "sw": "0.9769106086173615",
      "tr": "0.9745761057490584",
      "vi": "0.9784919050807802"
    },
    "canonical_solution": "local count_5=0\nlocal count_0=0\n\n# Count the number of 5s and 0s\nfor card in \"${cards[@]}\"; do\nif [[ $card -eq 5 ]]; then\n((count_5++))\nelif [[ $card -eq 0 ]]; then\n((count_0++))\nfi\ndone\n\n# Special case: if only zeros are present, return 0\nif (( count_0 > 0 && count_5 < 9 )); then\necho 0\nreturn\nfi\n\n# Check if it's possible to form a number\nif (( count_0 == 0 || count_5 < 9 )); then\necho -1\nreturn\nfi\n\n# Calculate the number of 5s to use (multiple of 9)\ncount_5=$((count_5 / 9 * 9))\n\n# Construct the largest number\nlocal result=\"\"\nfor (( i=0; i<count_5; i++ )); do\nresult+=\"5\"\ndone\nfor (( i=0; i<count_0; i++ )); do\nresult+=\"0\"\ndone\n\necho $result\n}",
    "instruction": {
      "en": "Write a Shell function `arrange_cards_for_max_number() {\nlocal cards=($1)\n` to solve the following problem:\nThis function arranges cards with numbers 0 and 5 to form the largest number divisible by 90.\nIf it's not possible to form such a number, the function returns -1.\nInput: A string of numbers (only 0s and 5s) representing the cards.\nOutput: The largest number divisible by 90 that can be formed, or -1 if it's not possible.\nExample Usage:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "es": "Escribe una función de Shell `arrange_cards_for_max_number() {\nlocal cards=($1)\n` para resolver el siguiente problema:\nEsta función organiza cartas con números 0 y 5 para formar el número más grande divisible por 90.\nSi no es posible formar tal número, la función devuelve -1.\nEntrada: Una cadena de números (solo 0s y 5s) que representan las cartas.\nSalida: El número más grande divisible por 90 que se puede formar, o -1 si no es posible.\nEjemplo de uso:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "arb": "اكتب دالة Shell `arrange_cards_for_max_number() {\nlocal cards=($1)\n` لحل المشكلة التالية:\nهذه الدالة ترتب البطاقات التي تحتوي على الأرقام 0 و 5 لتكوين أكبر رقم قابل للقسمة على 90.\nإذا لم يكن من الممكن تكوين مثل هذا الرقم، تعيد الدالة -1.\nالمدخلات: سلسلة من الأرقام (فقط 0 و 5) تمثل البطاقات.\nالمخرجات: أكبر رقم قابل للقسمة على 90 يمكن تكوينه، أو -1 إذا لم يكن ذلك ممكنًا.\nمثال على الاستخدام:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "sw": "Andika kazi ya Shell `arrange_cards_for_max_number() {\nlocal cards=($1)\n` kutatua tatizo lifuatalo:\nKazi hii inapanga kadi zenye namba 0 na 5 ili kuunda namba kubwa zaidi inayoweza kugawanyika kwa 90.\nIkiwa haiwezekani kuunda namba kama hiyo, kazi inarudisha -1.\nIngizo: Mlolongo wa namba (ni 0 na 5 pekee) unaowakilisha kadi.\nMatokeo: Namba kubwa zaidi inayoweza kugawanyika kwa 90 ambayo inaweza kuundwa, au -1 ikiwa haiwezekani.\nMfano wa Matumizi:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "tr": "Bir Shell fonksiyonu `arrange_cards_for_max_number() {\nlocal cards=($1)\n` aşağıdaki problemi çözmek için yazın:\nBu fonksiyon, 0 ve 5 sayılarıyla kartları, 90'a bölünebilen en büyük sayıyı oluşturacak şekilde düzenler.\nBöyle bir sayı oluşturmak mümkün değilse, fonksiyon -1 döndürür.\nGirdi: Kartları temsil eden bir sayı dizisi (yalnızca 0 ve 5'ler).\nÇıktı: Oluşturulabilecek 90'a bölünebilen en büyük sayı veya mümkün değilse -1.\nÖrnek Kullanım:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "vi": "Viết một hàm Shell `arrange_cards_for_max_number() {\nlocal cards=($1)\n` để giải quyết vấn đề sau:\nHàm này sắp xếp các quân bài với các số 0 và 5 để tạo thành số lớn nhất chia hết cho 90.\nNếu không thể tạo ra một số như vậy, hàm trả về -1.\nĐầu vào: Một chuỗi các số (chỉ gồm các số 0 và 5) đại diện cho các quân bài.\nĐầu ra: Số lớn nhất chia hết cho 90 có thể được tạo ra, hoặc -1 nếu không thể.\nVí dụ sử dụng:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1"
    },
    "instruction_bertscore": {
      "es": "0.9970125990692352",
      "arb": "0.9799697151156798",
      "sw": "0.9796874613442292",
      "tr": "0.9746954826080604",
      "vi": "0.9723389317674626"
    },
    "level": "hard",
    "test": "test_arrange_cards_for_max_number() {\n[[ $(arrange_cards_for_max_number \"5 0 5 0\") == \"0\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\") == \"5555555550\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5\") == \"-1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"0 0 0\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 5 0\") == \"5555555550\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_arrange_cards_for_max_number",
    "entry_point": "arrange_cards_for_max_number",
    "signature": "arrange_cards_for_max_number() {\nlocal cards=($1)\n",
    "docstring": {
      "en": "This function arranges cards with numbers 0 and 5 to form the largest number divisible by 90.\nIf it's not possible to form such a number, the function returns -1.\nInput: A string of numbers (only 0s and 5s) representing the cards.\nOutput: The largest number divisible by 90 that can be formed, or -1 if it's not possible.\nExample Usage:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "es": "Esta función organiza cartas con números 0 y 5 para formar el número más grande divisible por 90.  \nSi no es posible formar tal número, la función devuelve -1.  \nEntrada: Una cadena de números (solo 0s y 5s) que representan las cartas.  \nSalida: El número más grande divisible por 90 que se puede formar, o -1 si no es posible.  \nEjemplo de Uso:  \n>>> arrange_cards_for_max_number \"5 0 5 0\"  \n0  \n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"  \n5555555550  \n>>> arrange_cards_for_max_number \"5 5\"  \n-1  ",
      "arb": "هذه الدالة ترتب البطاقات التي تحتوي على الأرقام 0 و 5 لتكوين أكبر رقم قابل للقسمة على 90.  \nإذا لم يكن من الممكن تكوين مثل هذا الرقم، فإن الدالة تُرجع -1.  \nالمدخل: سلسلة من الأرقام (فقط 0 و 5) تمثل البطاقات.  \nالمخرج: أكبر رقم قابل للقسمة على 90 يمكن تكوينه، أو -1 إذا لم يكن ذلك ممكنًا.  \nمثال على الاستخدام:  \n>>> arrange_cards_for_max_number \"5 0 5 0\"  \n0  \n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"  \n5555555550  \n>>> arrange_cards_for_max_number \"5 5\"  \n-1  ",
      "sw": "Kazi ya kazi hii ni kupanga kadi zilizo na namba 0 na 5 ili kuunda namba kubwa zaidi inayogawanyika kwa 90. Ikiwa haiwezekani kuunda namba kama hiyo, kazi inarudisha -1. \n\nIngizo: Mfuatano wa namba (ni 0 na 5 pekee) inayowakilisha kadi. \nPato: Namba kubwa zaidi inayogawanyika kwa 90 inayoweza kuundwa, au -1 ikiwa haiwezekani. \n\nMfano wa Matumizi:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "tr": "Bu fonksiyon, 0 ve 5 numaralı kartları 90'a bölünebilen en büyük sayıyı oluşturacak şekilde düzenler.\nBöyle bir sayı oluşturmak mümkün değilse, fonksiyon -1 döndürür.\nGirdi: Kartları temsil eden bir sayı dizisi (yalnızca 0 ve 5'ler).\nÇıktı: Oluşturulabilecek 90'a bölünebilen en büyük sayı veya bu mümkün değilse -1.\nÖrnek Kullanım:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "vi": "Hàm này sắp xếp các lá bài với các số 0 và 5 để tạo thành số lớn nhất chia hết cho 90.  \nNếu không thể tạo thành số như vậy, hàm trả về -1.  \nĐầu vào: Một chuỗi số (chỉ gồm các số 0 và 5) đại diện cho các lá bài.  \nĐầu ra: Số lớn nhất chia hết cho 90 có thể được tạo thành, hoặc -1 nếu không thể.  \nVí dụ sử dụng:  \n>>> arrange_cards_for_max_number \"5 0 5 0\"  \n0  \n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"  \n5555555550  \n>>> arrange_cards_for_max_number \"5 5\"  \n-1"
    },
    "docstring_bertscore": {
      "es": "0.9970302771731474",
      "arb": "0.9804676814809342",
      "sw": "0.967331658491954",
      "tr": "0.9689959824546454",
      "vi": "0.9713481634268605"
    }
  },
  {
    "task_id": "Shell/30",
    "prompt": {
      "en": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# This function calculates the lexicographical rank of a given permutation of numbers from 1 to 'N'.\n# Input: The number of elements 'N' and the permutation 'X' as a string.\n# Output: The lexicographical rank of the permutation.\n# The permutation is considered as a sequence of digits without spaces.\n# Example Usage:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "es": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Esta función calcula el rango lexicográfico de una permutación dada de números del 1 al 'N'.\n# Entrada: El número de elementos 'N' y la permutación 'X' como una cadena.\n# Salida: El rango lexicográfico de la permutación.\n# La permutación se considera como una secuencia de dígitos sin espacios.\n# Ejemplo de uso:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "arb": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# تقوم هذه الدالة بحساب الترتيب المعجمي لتبديل معين من الأرقام من 1 إلى 'N'.\n# المدخلات: عدد العناصر 'N' والتبديل 'X' كسلسلة نصية.\n# المخرجات: الترتيب المعجمي للتبديل.\n# يعتبر التبديل كسلسلة من الأرقام بدون مسافات.\n# مثال على الاستخدام:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "sw": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Kazi hii inakokotoa nafasi ya leksikografia ya mpangilio uliotolewa wa nambari kutoka 1 hadi 'N'.\n# Ingizo: Idadi ya vipengele 'N' na mpangilio 'X' kama kamba.\n# Tokeo: Nafasi ya leksikografia ya mpangilio.\n# Mpangilio unachukuliwa kama mlolongo wa tarakimu bila nafasi.\n# Mfano wa Matumizi:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "tr": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Bu fonksiyon, 1'den 'N'ye kadar olan sayıların bir permütasyonunun leksikografik sırasını hesaplar.\n# Girdi: Eleman sayısı 'N' ve permütasyon 'X' bir string olarak.\n# Çıktı: Permütasyonun leksikografik sırası.\n# Permütasyon, boşluksuz bir rakam dizisi olarak kabul edilir.\n# Örnek Kullanım:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "vi": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Hàm này tính toán thứ hạng từ điển của một hoán vị cho trước của các số từ 1 đến 'N'.\n# Đầu vào: Số lượng phần tử 'N' và hoán vị 'X' dưới dạng chuỗi.\n# Đầu ra: Thứ hạng từ điển của hoán vị.\n# Hoán vị được coi là một dãy các chữ số không có khoảng trắng.\n# Ví dụ sử dụng:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8"
    },
    "prompt_bertscore": {
      "es": "0.99781387402633",
      "arb": "0.9781699252331227",
      "sw": "0.9764267450091605",
      "tr": "0.9767733550240664",
      "vi": "0.9854560848702445"
    },
    "canonical_solution": "local rank=0\nlocal factorial=1\nlocal smaller\n\n# Function to calculate factorial\ncalculate_factorial() {\nlocal num=$1\nlocal fact=1\nfor (( i=1; i<=num; i++ )); do\nfact=$((fact * i))\ndone\necho $fact\n}\n\nfor (( i=0; i<N-1; i++ )); do\nsmaller=0\nfor (( j=i+1; j<N; j++ )); do\nif [[ ${permutation:i:1} > ${permutation:j:1} ]]; then\n((smaller++))\nfi\ndone\nfactorial=$(calculate_factorial $((N-i-1)))\nrank=$((rank + smaller * factorial))\ndone\n\n# Adding 1 because rank starts from 1\necho $((rank + 1))\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` to solve the following problem:\nThis function calculates the lexicographical rank of a given permutation of numbers from 1 to 'N'.\nInput: The number of elements 'N' and the permutation 'X' as a string.\nOutput: The lexicographical rank of the permutation.\nThe permutation is considered as a sequence of digits without spaces.\nExample Usage:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "es": "Escribe una función de Shell `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` para resolver el siguiente problema:\nEsta función calcula el rango lexicográfico de una permutación dada de números del 1 al 'N'.\nEntrada: El número de elementos 'N' y la permutación 'X' como una cadena.\nSalida: El rango lexicográfico de la permutación.\nLa permutación se considera como una secuencia de dígitos sin espacios.\nEjemplo de uso:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "arb": "اكتب دالة Shell `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` لحل المشكلة التالية:\nهذه الدالة تحسب الترتيب المعجمي لتبديل معين من الأرقام من 1 إلى 'N'.\nالمدخل: عدد العناصر 'N' والتبديل 'X' كسلسلة نصية.\nالمخرج: الترتيب المعجمي للتبديل.\nيعتبر التبديل كسلسلة من الأرقام بدون مسافات.\nمثال على الاستخدام:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "sw": "Andika kazi ya Shell `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` kutatua tatizo lifuatalo:\nKazi hii inahesabu nafasi ya leksikografia ya mpangilio uliotolewa wa nambari kutoka 1 hadi 'N'.\nIngizo: Idadi ya vipengele 'N' na mpangilio 'X' kama kamba.\nMatokeo: Nafasi ya leksikografia ya mpangilio.\nMpangilio unachukuliwa kama mfuatano wa tarakimu bila nafasi.\nMfano wa Matumizi:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "tr": "Bir Shell fonksiyonu yazın `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` aşağıdaki problemi çözmek için:\nBu fonksiyon, 1'den 'N'ye kadar olan sayıların verilen bir permütasyonunun leksikografik sırasını hesaplar.\nGirdi: Eleman sayısı 'N' ve permütasyon 'X' bir dize olarak.\nÇıktı: Permütasyonun leksikografik sırası.\nPermütasyon, boşluksuz bir rakamlar dizisi olarak kabul edilir.\nÖrnek Kullanım:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "vi": "Viết một hàm Shell `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` để giải quyết vấn đề sau:\nHàm này tính toán thứ hạng từ điển của một hoán vị cho trước của các số từ 1 đến 'N'.\nĐầu vào: Số lượng phần tử 'N' và hoán vị 'X' dưới dạng chuỗi.\nĐầu ra: Thứ hạng từ điển của hoán vị.\nHoán vị được coi là một chuỗi các chữ số không có khoảng trắng.\nVí dụ Sử dụng:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8"
    },
    "instruction_bertscore": {
      "es": "0.9953385422178732",
      "arb": "0.989256479950585",
      "sw": "0.985276920266551",
      "tr": "0.9875575943015936",
      "vi": "0.9835577743186941"
    },
    "level": "middle",
    "test": "test_calculate_lexicographical_rank() {\n[[ $(calculate_lexicographical_rank 3 \"231\") -eq 4 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 4 \"2143\") -eq 8 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 5 \"31245\") -eq 49 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 3 \"123\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 4 \"4321\") -eq 24 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_lexicographical_rank",
    "entry_point": "calculate_lexicographical_rank",
    "signature": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n",
    "docstring": {
      "en": "This function calculates the lexicographical rank of a given permutation of numbers from 1 to 'N'.\nInput: The number of elements 'N' and the permutation 'X' as a string.\nOutput: The lexicographical rank of the permutation.\nThe permutation is considered as a sequence of digits without spaces.\nExample Usage:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "es": "Esta función calcula el rango lexicográfico de una permutación dada de números del 1 al 'N'.\nEntrada: El número de elementos 'N' y la permutación 'X' como una cadena.\nSalida: El rango lexicográfico de la permutación.\nLa permutación se considera como una secuencia de dígitos sin espacios.\nEjemplo de uso:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "arb": "هذه الدالة تحسب الترتيب المعجمي لتبديل معين من الأرقام من 1 إلى 'N'.\nالمدخلات: عدد العناصر 'N' والتبديل 'X' كسلسلة نصية.\nالمخرجات: الترتيب المعجمي للتبديل.\nيعتبر التبديل كسلسلة من الأرقام بدون مسافات.\nمثال على الاستخدام:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "sw": "Kazi ya kazi hii ni kuhesabu cheo cha leksikografia cha mpangilio fulani wa nambari kutoka 1 hadi 'N'.\nIngizo: Idadi ya vipengele 'N' na mpangilio 'X' kama kamba.\nPato: Cheo cha leksikografia cha mpangilio.\nMpangilio unachukuliwa kama mfuatano wa tarakimu bila nafasi.\nMfano wa Matumizi:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "tr": "Bu fonksiyon, 1'den 'N'ye kadar olan sayıların verilen bir permütasyonunun sözlük sırasındaki derecesini hesaplar.\nGirdi: Eleman sayısı 'N' ve permütasyon 'X' bir string olarak.\nÇıktı: Permütasyonun sözlük sırasındaki derecesi.\nPermütasyon, boşluksuz bir rakam dizisi olarak kabul edilir.\nÖrnek Kullanım:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "vi": "Hàm này tính thứ hạng từ điển của một hoán vị cho trước của các số từ 1 đến 'N'.\nĐầu vào: Số lượng phần tử 'N' và hoán vị 'X' dưới dạng chuỗi.\nĐầu ra: Thứ hạng từ điển của hoán vị.\nHoán vị được coi là một dãy chữ số không có khoảng trắng.\nVí dụ Sử dụng:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8"
    },
    "docstring_bertscore": {
      "es": "0.9969736675145524",
      "arb": "0.9721208356090862",
      "sw": "0.9683635433214303",
      "tr": "1",
      "vi": "0.9831944793517812"
    }
  },
  {
    "task_id": "Shell/31",
    "prompt": {
      "en": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# This function finds the maximum sum of a continuous non-empty subsequence in a given sequence of integers.\n# Input: A string of integers representing the sequence.\n# Output: The maximum sum of a continuous non-empty subsequence.\n# Example Usage:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "es": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Esta función encuentra la suma máxima de una subsecuencia continua no vacía en una secuencia dada de enteros.\n# Entrada: Una cadena de enteros que representa la secuencia.\n# Salida: La suma máxima de una subsecuencia continua no vacía.\n# Ejemplo de uso:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "arb": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# هذه الدالة تجد أكبر مجموع لتسلسل فرعي متصل وغير فارغ في تسلسل معين من الأعداد الصحيحة.\n# المدخل: سلسلة من الأعداد الصحيحة تمثل التسلسل.\n# المخرج: أكبر مجموع لتسلسل فرعي متصل وغير فارغ.\n# مثال على الاستخدام:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "sw": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Kazi ya hii kazi ni kupata jumla kubwa zaidi ya mlolongo usio na nafasi tupu ndani ya mlolongo uliotolewa wa namba kamili.\n# Ingizo: Mlolongo wa namba kamili unaowakilisha mlolongo.\n# Matokeo: Jumla kubwa zaidi ya mlolongo usio na nafasi tupu.\n# Mfano wa Matumizi:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "tr": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Bu fonksiyon, verilen bir tamsayı dizisindeki ardışık ve boş olmayan bir alt dizinin maksimum toplamını bulur.\n# Girdi: Diziyi temsil eden bir tamsayı dizisi.\n# Çıktı: Ardışık ve boş olmayan bir alt dizinin maksimum toplamı.\n# Örnek Kullanım:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "vi": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Hàm này tìm tổng lớn nhất của một dãy con liên tục không rỗng trong một dãy số nguyên cho trước.\n# Đầu vào: Một chuỗi các số nguyên đại diện cho dãy số.\n# Đầu ra: Tổng lớn nhất của một dãy con liên tục không rỗng.\n# Ví dụ sử dụng:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11"
    },
    "prompt_bertscore": {
      "es": "0.9964463038529048",
      "arb": "0.9642217026160907",
      "sw": "0.9548024513170353",
      "tr": "0.9706319022728487",
      "vi": "0.9951965214954333"
    },
    "canonical_solution": "local max_so_far=0\n    local max_ending_here=0\n\n    for num in \"${sequence[@]}\"; do\n        max_ending_here=$((max_ending_here + num))\n        if (( max_ending_here < 0 )); then\n            max_ending_here=0\n        elif (( max_so_far < max_ending_here )); then\n            max_so_far=$max_ending_here\n        fi\n    done\n\n    if (( max_so_far == 0 )); then\n        max_so_far=${sequence[0]}\n        for num in \"${sequence[@]}\"; do\n            if (( num > max_so_far )); then\n                max_so_far=$num\n            fi\n        done\n    fi\n\n    echo $max_so_far\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` to solve the following problem:\nThis function finds the maximum sum of a continuous non-empty subsequence in a given sequence of integers.\nInput: A string of integers representing the sequence.\nOutput: The maximum sum of a continuous non-empty subsequence.\nExample Usage:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "es": "Escribe una función Shell `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` para resolver el siguiente problema:\nEsta función encuentra la suma máxima de una subsecuencia continua no vacía en una secuencia dada de enteros.\nEntrada: Una cadena de enteros que representa la secuencia.\nSalida: La suma máxima de una subsecuencia continua no vacía.\nEjemplo de uso:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "arb": "اكتب دالة شل `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` لحل المشكلة التالية:\nهذه الدالة تجد أكبر مجموع لتسلسل فرعي مستمر غير فارغ في تسلسل معين من الأعداد الصحيحة.\nالمدخل: سلسلة من الأعداد الصحيحة تمثل التسلسل.\nالمخرج: أكبر مجموع لتسلسل فرعي مستمر غير فارغ.\nمثال على الاستخدام:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "sw": "Andika kazi ya Shell `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` kutatua tatizo lifuatalo:\nKazi hii inapata jumla ya juu zaidi ya mlolongo usio na nafasi tupu unaoendelea katika mlolongo uliotolewa wa nambari nzima.\nIngizo: Mlolongo wa nambari nzima unaowakilisha mlolongo.\nMatokeo: Jumla ya juu zaidi ya mlolongo usio na nafasi tupu unaoendelea.\nMfano wa Matumizi:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "tr": "Bir Shell fonksiyonu `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` yazın. Aşağıdaki problemi çözmek için:\nBu fonksiyon, verilen bir tamsayı dizisindeki sürekli ve boş olmayan bir alt dizinin maksimum toplamını bulur.\nGirdi: Diziyi temsil eden bir tamsayılar dizisi.\nÇıktı: Sürekli ve boş olmayan bir alt dizinin maksimum toplamı.\nÖrnek Kullanım:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "vi": "Viết một hàm Shell `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` để giải quyết vấn đề sau:\nHàm này tìm tổng lớn nhất của một dãy con liên tục không rỗng trong một dãy số nguyên cho trước.\nĐầu vào: Một chuỗi các số nguyên đại diện cho dãy số.\nĐầu ra: Tổng lớn nhất của một dãy con liên tục không rỗng.\nVí dụ sử dụng:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11"
    },
    "instruction_bertscore": {
      "es": "0.9923380316819602",
      "arb": "0.9799440917965263",
      "sw": "0.9611911988926415",
      "tr": "0.9257906964934606",
      "vi": "0.9881586498346051"
    },
    "level": "easy",
    "test": "test_calculate_max_subsequence_sum() {\n    [[ $(calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\") -eq 4 ]] || { echo \"Test 1 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"-1 -2 -3 -4\") -eq -1 ]] || { echo \"Test 2 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\") -eq 11 ]] || { echo \"Test 3 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"1 2 3 4 5 6\") -eq 21 ]] || { echo \"Test 4 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"-1 -2 -3 -4 -5 -6\") -eq -1 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_max_subsequence_sum",
    "entry_point": "calculate_max_subsequence_sum",
    "signature": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n",
    "docstring": {
      "en": "This function finds the maximum sum of a continuous non-empty subsequence in a given sequence of integers.\nInput: A string of integers representing the sequence.\nOutput: The maximum sum of a continuous non-empty subsequence.\nExample Usage:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "es": "Esta función encuentra la suma máxima de una subsecuencia continua no vacía en una secuencia dada de enteros.\nEntrada: Una cadena de enteros que representa la secuencia.\nSalida: La suma máxima de una subsecuencia continua no vacía.\nEjemplo de uso:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "arb": "هذه الدالة تجد أكبر مجموع لتسلسل فرعي متصل وغير فارغ في تسلسل معين من الأعداد الصحيحة.\nالمدخلات: سلسلة من الأعداد الصحيحة تمثل التسلسل.\nالمخرجات: أكبر مجموع لتسلسل فرعي متصل وغير فارغ.\nمثال على الاستخدام:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "sw": "Kazi ya kazi hii ni kupata jumla kubwa zaidi ya mfuatano usio na kikomo na usio tupu katika mfuatano uliotolewa wa namba nzima.\nIngizo: Mfuatano wa namba nzima unaowakilisha mfuatano.\nMatokeo: Jumla kubwa zaidi ya mfuatano usio na kikomo na usio tupu.\nMfano wa Matumizi:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "tr": "Bu fonksiyon, verilen bir tamsayı dizisindeki ardışık ve boş olmayan bir alt dizinin maksimum toplamını bulur.\nGirdi: Diziyi temsil eden bir tamsayılar dizisi.\nÇıktı: Ardışık ve boş olmayan bir alt dizinin maksimum toplamı.\nÖrnek Kullanım:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "vi": "Hàm này tìm tổng lớn nhất của một dãy con liên tục không rỗng trong một dãy số nguyên đã cho.  \nĐầu vào: Một chuỗi các số nguyên đại diện cho dãy số.  \nĐầu ra: Tổng lớn nhất của một dãy con liên tục không rỗng.  \nVí dụ Sử dụng:  \n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"  \n4  \n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"  \n-1  \n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"  \n11  "
    },
    "docstring_bertscore": {
      "es": "0.9944909863819974",
      "arb": "0.9466296056589738",
      "sw": "0.9410238590454072",
      "tr": "0.9481481349219856",
      "vi": "0.9970330579984819"
    }
  },
  {
    "task_id": "Shell/32",
    "prompt": {
      "en": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# This function calculates the minimum number of bridge rotations required to sort train carriages.\n# The bridge can hold two carriages at a time and rotate 180 degrees to swap them.\n# Input: Number of carriages 'N' and a string representing the initial order of carriages.\n# Output: The minimum number of bridge rotations needed to sort the carriages in ascending order.\n# Example Usage:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "es": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Esta función calcula el número mínimo de rotaciones de puente necesarias para ordenar los vagones de tren.\n# El puente puede sostener dos vagones a la vez y girar 180 grados para intercambiarlos.\n# Entrada: Número de vagones 'N' y una cadena que representa el orden inicial de los vagones.\n# Salida: El número mínimo de rotaciones de puente necesarias para ordenar los vagones en orden ascendente.\n# Ejemplo de uso:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "arb": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# تقوم هذه الدالة بحساب الحد الأدنى لعدد دورانات الجسر المطلوبة لترتيب عربات القطار.\n# يمكن للجسر أن يحمل عربتين في وقت واحد ويدور 180 درجة لتبديلهما.\n# المدخل: عدد العربات 'N' وسلسلة تمثل الترتيب الأولي للعربات.\n# المخرج: الحد الأدنى لعدد دورانات الجسر المطلوبة لترتيب العربات بترتيب تصاعدي.\n# مثال على الاستخدام:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "sw": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Kazi ya hii function ni kuhesabu idadi ndogo zaidi ya mizunguko ya daraja inayohitajika kupanga mabehewa ya treni.\n# Daraja linaweza kubeba mabehewa mawili kwa wakati mmoja na kuzunguka nyuzi 180 ili kubadilisha nafasi zao.\n# Ingizo: Idadi ya mabehewa 'N' na kamba inayoonyesha mpangilio wa awali wa mabehewa.\n# Tokeo: Idadi ndogo zaidi ya mizunguko ya daraja inayohitajika kupanga mabehewa kwa mpangilio wa kupanda.\n# Mfano wa Matumizi:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "tr": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Bu fonksiyon, tren vagonlarını sıralamak için gereken minimum köprü dönüşü sayısını hesaplar.\n# Köprü, aynı anda iki vagonu tutabilir ve bunları değiştirmek için 180 derece dönebilir.\n# Girdi: Vagon sayısı 'N' ve vagonların başlangıç sırasını temsil eden bir dize.\n# Çıktı: Vagonları artan sırayla sıralamak için gereken minimum köprü dönüşü sayısı.\n# Örnek Kullanım:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "vi": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Hàm này tính toán số lần quay cầu tối thiểu cần thiết để sắp xếp các toa tàu.\n# Cầu có thể chứa hai toa tàu cùng một lúc và quay 180 độ để hoán đổi chúng.\n# Đầu vào: Số lượng toa tàu 'N' và một chuỗi đại diện cho thứ tự ban đầu của các toa tàu.\n# Đầu ra: Số lần quay cầu tối thiểu cần thiết để sắp xếp các toa tàu theo thứ tự tăng dần.\n# Ví dụ sử dụng:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2"
    },
    "prompt_bertscore": {
      "es": "0.9921789287467513",
      "arb": "0.9778775413122394",
      "sw": "0.9619636724444861",
      "tr": "0.9876213546539058",
      "vi": "0.9881413689914551"
    },
    "canonical_solution": "local count=0\n\nfor (( i=0; i<N; i++ )); do\nfor (( j=0; j<N-i-1; j++ )); do\nif (( carriages[j] > carriages[j+1] )); then\n# Swap carriages\nlocal temp=${carriages[j]}\ncarriages[j]=${carriages[j+1]}\ncarriages[j+1]=$temp\n((count++))\nfi\ndone\ndone\n\necho $count\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` to solve the following problem:\nThis function calculates the minimum number of bridge rotations required to sort train carriages.\nThe bridge can hold two carriages at a time and rotate 180 degrees to swap them.\nInput: Number of carriages 'N' and a string representing the initial order of carriages.\nOutput: The minimum number of bridge rotations needed to sort the carriages in ascending order.\nExample Usage:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "es": "Escribe una función de Shell `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` para resolver el siguiente problema:\nEsta función calcula el número mínimo de rotaciones de puente necesarias para ordenar los vagones de tren.\nEl puente puede sostener dos vagones a la vez y girar 180 grados para intercambiarlos.\nEntrada: Número de vagones 'N' y una cadena que representa el orden inicial de los vagones.\nSalida: El número mínimo de rotaciones de puente necesarias para ordenar los vagones en orden ascendente.\nEjemplo de uso:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "arb": "اكتب دالة شيل `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` لحل المشكلة التالية:\nهذه الدالة تحسب الحد الأدنى لعدد دورانات الجسر المطلوبة لترتيب عربات القطار.\nيمكن للجسر أن يحمل عربتين في وقت واحد ويدور 180 درجة لتبديلهما.\nالمدخلات: عدد العربات 'N' وسلسلة تمثل الترتيب الأولي للعربات.\nالمخرجات: الحد الأدنى لعدد دورانات الجسر اللازمة لترتيب العربات بترتيب تصاعدي.\nمثال على الاستخدام:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "sw": "Andika kazi ya Shell `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` kutatua tatizo lifuatalo:\nKazi hii inahesabu idadi ndogo ya mizunguko ya daraja inayohitajika kupanga mabehewa ya treni.\nDaraja linaweza kushikilia mabehewa mawili kwa wakati mmoja na kuzunguka kwa digrii 180 ili kubadilisha nafasi zao.\nIngizo: Idadi ya mabehewa 'N' na kamba inayowakilisha mpangilio wa awali wa mabehewa.\nMatokeo: Idadi ndogo ya mizunguko ya daraja inayohitajika kupanga mabehewa kwa mpangilio wa kupanda.\nMfano wa Matumizi:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "tr": "Bir Shell fonksiyonu yazın `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` aşağıdaki problemi çözmek için:\nBu fonksiyon, tren vagonlarını sıralamak için gereken minimum köprü dönüş sayısını hesaplar.\nKöprü, aynı anda iki vagonu tutabilir ve bunları değiştirmek için 180 derece dönebilir.\nGirdi: Vagon sayısı 'N' ve vagonların başlangıç sırasını temsil eden bir dize.\nÇıktı: Vagonları artan sıraya göre sıralamak için gereken minimum köprü dönüş sayısı.\nÖrnek Kullanım:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "vi": "Viết một hàm Shell `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` để giải quyết vấn đề sau:\nHàm này tính toán số lần quay cầu tối thiểu cần thiết để sắp xếp các toa tàu.\nCầu có thể giữ hai toa tàu cùng một lúc và quay 180 độ để hoán đổi chúng.\nĐầu vào: Số lượng toa tàu 'N' và một chuỗi đại diện cho thứ tự ban đầu của các toa tàu.\nĐầu ra: Số lần quay cầu tối thiểu cần thiết để sắp xếp các toa tàu theo thứ tự tăng dần.\nVí dụ sử dụng:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2"
    },
    "instruction_bertscore": {
      "es": "0.989860514939312",
      "arb": "0.9732675287988006",
      "sw": "0.9759945253000286",
      "tr": "0.984223583355923",
      "vi": "0.9845455632035806"
    },
    "level": "easy",
    "test": "test_calculate_min_bridge_rotations() {\n[[ $(calculate_min_bridge_rotations 4 \"4 3 2 1\") -eq 6 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 5 \"5 4 3 2 1\") -eq 10 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 3 \"3 1 2\") -eq 2 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 6 \"6 5 4 3 2 1\") -eq 15 ]] || { echo \"Test 4 failed\"; exit 1; }\n}\n\ntest_calculate_min_bridge_rotations",
    "entry_point": "calculate_min_bridge_rotations",
    "signature": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n",
    "docstring": {
      "en": "This function calculates the minimum number of bridge rotations required to sort train carriages.\nThe bridge can hold two carriages at a time and rotate 180 degrees to swap them.\nInput: Number of carriages 'N' and a string representing the initial order of carriages.\nOutput: The minimum number of bridge rotations needed to sort the carriages in ascending order.\nExample Usage:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "es": "Esta función calcula el número mínimo de rotaciones de puente necesarias para ordenar los vagones de tren.\nEl puente puede sostener dos vagones a la vez y girar 180 grados para intercambiarlos.\nEntrada: Número de vagones 'N' y una cadena que representa el orden inicial de los vagones.\nSalida: El número mínimo de rotaciones de puente necesarias para ordenar los vagones en orden ascendente.\nEjemplo de uso:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "arb": "هذه الدالة تحسب الحد الأدنى لعدد دورانات الجسر المطلوبة لترتيب عربات القطار.\nيمكن للجسر أن يحمل عربتين في وقت واحد ويدور 180 درجة لتبديلهما.\nالمدخلات: عدد العربات 'N' وسلسلة نصية تمثل الترتيب الأولي للعربات.\nالمخرجات: الحد الأدنى لعدد دورانات الجسر المطلوبة لترتيب العربات بترتيب تصاعدي.\nمثال على الاستخدام:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "sw": "Kazi ya kazi hii ni kuhesabu idadi ndogo ya mizunguko ya daraja inayohitajika kupanga mabehewa ya treni.  \nDaraja linaweza kubeba mabehewa mawili kwa wakati mmoja na kuzunguka digrii 180 ili kubadilisha nafasi zao.  \nIngizo: Idadi ya mabehewa 'N' na kamba inayoonyesha mpangilio wa awali wa mabehewa.  \nPato: Idadi ndogo ya mizunguko ya daraja inayohitajika kupanga mabehewa kwa mpangilio wa kupanda.   \nMfano wa Matumizi:  \n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"  \n6  \n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"  \n10  \n>>> calculate_min_bridge_rotations 3 \"3 1 2\"  \n2  ",
      "tr": "Bu fonksiyon, tren vagonlarını sıralamak için gereken minimum köprü dönüşü sayısını hesaplar.\nKöprü aynı anda iki vagonu tutabilir ve onları değiştirmek için 180 derece dönebilir.\nGirdi: Vagon sayısı 'N' ve vagonların başlangıç sırasını temsil eden bir dize.\nÇıktı: Vagonları artan sırayla sıralamak için gereken minimum köprü dönüşü sayısı.\nÖrnek Kullanım:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "vi": "Hàm này tính toán số lần quay cầu tối thiểu cần thiết để sắp xếp các toa tàu. Cầu có thể chứa hai toa tàu cùng một lúc và quay 180 độ để hoán đổi chúng. Đầu vào: Số lượng toa tàu 'N' và một chuỗi đại diện cho thứ tự ban đầu của các toa tàu. Đầu ra: Số lần quay cầu tối thiểu cần thiết để sắp xếp các toa tàu theo thứ tự tăng dần. Ví dụ sử dụng:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2"
    },
    "docstring_bertscore": {
      "es": "0.9704884911377415",
      "arb": "0.9650984571179788",
      "sw": "0.8702538405864869",
      "tr": "0.9475959424627085",
      "vi": "0.9701772373306599"
    }
  },
  {
    "task_id": "Shell/33",
    "prompt": {
      "en": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# This function checks if the given word is a \"Lucky Word\".\n# A word is considered \"Lucky\" if the difference between the highest and lowest letter frequency is a prime number.\n# Input: A single word consisting of lowercase letters and with a length less than 100.\n# Output: Two lines - the first line is either 'Lucky Word' or 'No Answer', and the second line is the difference if the word is \"Lucky\", or 0 otherwise.\n# Example Usage:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "es": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Esta función verifica si la palabra dada es una \"Palabra de la Suerte\".\n# Una palabra se considera \"de la Suerte\" si la diferencia entre la frecuencia más alta y la más baja de las letras es un número primo.\n# Entrada: Una sola palabra que consiste en letras minúsculas y con una longitud menor a 100.\n# Salida: Dos líneas - la primera línea es 'Lucky Word' o 'No Answer', y la segunda línea es la diferencia si la palabra es \"de la Suerte\", o 0 en caso contrario.\n# Ejemplo de uso:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "arb": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# هذه الدالة تتحقق مما إذا كانت الكلمة المعطاة هي \"كلمة محظوظة\".\n# تعتبر الكلمة \"محظوظة\" إذا كان الفرق بين أعلى وأدنى تكرار للحروف هو عدد أولي.\n# المدخل: كلمة واحدة تتكون من حروف صغيرة وبطول أقل من 100.\n# المخرج: سطران - السطر الأول إما 'كلمة محظوظة' أو 'لا إجابة'، والسطر الثاني هو الفرق إذا كانت الكلمة \"محظوظة\"، أو 0 خلاف ذلك.\n# مثال على الاستخدام:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "sw": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Kazi hii hukagua kama neno lililotolewa ni \"Neno la Bahati\".\n# Neno linachukuliwa kuwa \"la Bahati\" ikiwa tofauti kati ya marudio ya herufi ya juu na ya chini ni nambari ya kwanza.\n# Ingizo: Neno moja linalojumuisha herufi ndogo na lenye urefu chini ya 100.\n# Tokeo: Mistari miwili - mstari wa kwanza ni ama 'Neno la Bahati' au 'Hakuna Jibu', na mstari wa pili ni tofauti ikiwa neno ni \"la Bahati\", au 0 vinginevyo.\n# Mfano wa Matumizi:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "tr": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Bu fonksiyon verilen kelimenin \"Şanslı Kelime\" olup olmadığını kontrol eder.\n# Bir kelime, en yüksek ve en düşük harf frekansı arasındaki fark asal sayı ise \"Şanslı\" olarak kabul edilir.\n# Girdi: Küçük harflerden oluşan ve uzunluğu 100'den az olan tek bir kelime.\n# Çıktı: İki satır - ilk satır 'Şanslı Kelime' veya 'Cevap Yok', ikinci satır ise kelime \"Şanslı\" ise farkı, aksi takdirde 0.\n# Örnek Kullanım:\n# >>> is_lucky_word \"error\"\n# Şanslı Kelime\n# 2\n# >>> is_lucky_word \"olympic\"\n# Cevap Yok\n# 0",
      "vi": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Hàm này kiểm tra xem từ được đưa ra có phải là \"Từ May Mắn\" hay không.\n# Một từ được coi là \"May Mắn\" nếu sự chênh lệch giữa tần suất chữ cái cao nhất và thấp nhất là một số nguyên tố.\n# Đầu vào: Một từ đơn gồm các chữ cái thường và có độ dài nhỏ hơn 100.\n# Đầu ra: Hai dòng - dòng đầu tiên là 'Lucky Word' hoặc 'No Answer', và dòng thứ hai là sự chênh lệch nếu từ là \"May Mắn\", hoặc 0 nếu không phải.\n# Ví dụ sử dụng:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0"
    },
    "prompt_bertscore": {
      "es": "0.9900098849858503",
      "arb": "0.9844696863980252",
      "sw": "0.9919401750287473",
      "tr": "0.9726559458555942",
      "vi": "0.9874137859057243"
    },
    "canonical_solution": "local max_count=0\nlocal min_count=100\nlocal count diff\n\n# Function to check if a number is prime\nis_prime() {\nlocal num=$1\nif (( num < 2 )); then return 1; fi\nfor (( i=2; i*i<=num; i++ )); do\nif (( num % i == 0 )); then return 1; fi\ndone\nreturn 0\n}\n\n# Count letter frequencies\nfor (( i=0; i<${#word}; i++ )); do\nletter=${word:$i:1}\n((letter_counts[$letter]++))\ndone\n\n# Find max and min counts\nfor letter in \"${!letter_counts[@]}\"; do\ncount=${letter_counts[$letter]}\nif (( count > max_count )); then max_count=$count; fi\nif (( count < min_count )); then min_count=$count; fi\ndone\n\ndiff=$((max_count - min_count))\n\nif is_prime $diff; then\necho \"Lucky Word\"\necho $diff\nelse\necho \"No Answer\"\necho 0\nfi\n}",
    "instruction": {
      "en": "Write a Shell function `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` to solve the following problem:\nThis function checks if the given word is a \"Lucky Word\".\nA word is considered \"Lucky\" if the difference between the highest and lowest letter frequency is a prime number.\nInput: A single word consisting of lowercase letters and with a length less than 100.\nOutput: Two lines - the first line is either 'Lucky Word' or 'No Answer', and the second line is the difference if the word is \"Lucky\", or 0 otherwise.\nExample Usage:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "es": "Escribe una función Shell `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` para resolver el siguiente problema:\nEsta función verifica si la palabra dada es una \"Palabra Afortunada\".\nUna palabra se considera \"Afortunada\" si la diferencia entre la frecuencia más alta y la más baja de las letras es un número primo.\nEntrada: Una sola palabra que consiste en letras minúsculas y con una longitud menor a 100.\nSalida: Dos líneas - la primera línea es 'Lucky Word' o 'No Answer', y la segunda línea es la diferencia si la palabra es \"Afortunada\", o 0 de lo contrario.\nEjemplo de Uso:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "arb": "اكتب دالة شل `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` لحل المشكلة التالية:\nتتحقق هذه الدالة مما إذا كانت الكلمة المعطاة هي \"كلمة محظوظة\".\nتعتبر الكلمة \"محظوظة\" إذا كان الفرق بين أعلى وأدنى تكرار للحروف هو عدد أولي.\nالمدخلات: كلمة واحدة تتكون من حروف صغيرة وطولها أقل من 100.\nالمخرجات: سطران - السطر الأول إما 'Lucky Word' أو 'No Answer'، والسطر الثاني هو الفرق إذا كانت الكلمة \"محظوظة\"، أو 0 خلاف ذلك.\nمثال على الاستخدام:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "sw": "Andika kazi ya Shell `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` kutatua tatizo lifuatalo:\nKazi hii inachunguza kama neno lililopewa ni \"Neno la Bahati\".\nNeno linachukuliwa kuwa \"la Bahati\" ikiwa tofauti kati ya mara nyingi zaidi na mara chache zaidi ya herufi ni nambari ya kwanza.\nIngizo: Neno moja linalojumuisha herufi ndogo na lenye urefu chini ya 100.\nMatokeo: Mistari miwili - mstari wa kwanza ni 'Lucky Word' au 'No Answer', na mstari wa pili ni tofauti ikiwa neno ni \"la Bahati\", au 0 vinginevyo.\nMfano wa Matumizi:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "tr": "Bir Shell fonksiyonu `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` aşağıdaki problemi çözmek için yazın:\nBu fonksiyon verilen kelimenin \"Şanslı Kelime\" olup olmadığını kontrol eder.\nBir kelime, en yüksek ve en düşük harf frekansı arasındaki fark asal bir sayı ise \"Şanslı\" olarak kabul edilir.\nGirdi: Küçük harflerden oluşan ve uzunluğu 100'den az olan tek bir kelime.\nÇıktı: İki satır - ilk satır 'Lucky Word' veya 'No Answer', ikinci satır ise kelime \"Şanslı\" ise fark, değilse 0.\nÖrnek Kullanım:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "vi": "Viết một hàm Shell `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` để giải quyết vấn đề sau:\nHàm này kiểm tra xem từ được cho có phải là \"Từ May Mắn\" hay không.\nMột từ được coi là \"May Mắn\" nếu sự khác biệt giữa tần suất chữ cái cao nhất và thấp nhất là một số nguyên tố.\nĐầu vào: Một từ đơn bao gồm các chữ cái thường và có độ dài nhỏ hơn 100.\nĐầu ra: Hai dòng - dòng đầu tiên là 'Lucky Word' hoặc 'No Answer', và dòng thứ hai là sự khác biệt nếu từ là \"May Mắn\", hoặc 0 nếu không phải.\nVí dụ Sử dụng:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0"
    },
    "instruction_bertscore": {
      "es": "0.9898875286711328",
      "arb": "0.9752955449891668",
      "sw": "0.9842549669561265",
      "tr": "0.978559240779951",
      "vi": "0.9793082759468337"
    },
    "level": "hard",
    "test": "test_is_lucky_word() {\nlocal result\nresult=$(is_lucky_word \"error\")\n[[ $result == $'Lucky Word\\n2' ]] || { echo \"Test 1 failed\"; exit 1; }\nresult=$(is_lucky_word \"olympic\")\n[[ $result == $'No Answer\\n0' ]] || { echo \"Test 2 failed\"; exit 1; }\nresult=$(is_lucky_word \"apple\")\n[[ $result == $'No Answer\\n0' ]] || { echo \"Test 3 failed\"; exit 1; }\n}\n\ntest_is_lucky_word",
    "entry_point": "is_lucky_word",
    "signature": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n",
    "docstring": {
      "en": "This function checks if the given word is a \"Lucky Word\".\nA word is considered \"Lucky\" if the difference between the highest and lowest letter frequency is a prime number.\nInput: A single word consisting of lowercase letters and with a length less than 100.\nOutput: Two lines - the first line is either 'Lucky Word' or 'No Answer', and the second line is the difference if the word is \"Lucky\", or 0 otherwise.\nExample Usage:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "es": "Esta función verifica si la palabra dada es una \"Palabra Afortunada\".  \nUna palabra se considera \"Afortunada\" si la diferencia entre la frecuencia más alta y la más baja de las letras es un número primo.  \nEntrada: Una sola palabra que consiste en letras minúsculas y con una longitud menor a 100.  \nSalida: Dos líneas - la primera línea es 'Lucky Word' o 'No Answer', y la segunda línea es la diferencia si la palabra es \"Afortunada\", o 0 en caso contrario.  \nEjemplo de Uso:  \n>>> is_lucky_word \"error\"  \nLucky Word  \n2  \n>>> is_lucky_word \"olympic\"  \nNo Answer  \n0  ",
      "arb": "هذه الدالة تتحقق مما إذا كانت الكلمة المعطاة هي \"كلمة محظوظة\".\nتعتبر الكلمة \"محظوظة\" إذا كان الفرق بين تكرار الحرف الأعلى والأدنى عددًا أوليًا.\nالمدخل: كلمة واحدة تتكون من حروف صغيرة وطولها أقل من 100.\nالمخرج: سطران - السطر الأول إما 'كلمة محظوظة' أو 'لا إجابة'، والسطر الثاني هو الفرق إذا كانت الكلمة \"محظوظة\"، أو 0 خلاف ذلك.\nمثال على الاستخدام:\n>>> is_lucky_word \"error\"\nكلمة محظوظة\n2\n>>> is_lucky_word \"olympic\"\nلا إجابة\n0",
      "sw": "Kazi ya kazi hii ni kukagua kama neno lililopewa ni \"Neno la Bahati\".\nNeno linachukuliwa kuwa \"la Bahati\" ikiwa tofauti kati ya marudio ya herufi ya juu na ya chini ni nambari ya kwanza.\nIngizo: Neno moja linalojumuisha herufi ndogo na lenye urefu chini ya 100.\nMatokeo: Mistari miwili - mstari wa kwanza ni aidha 'Neno la Bahati' au 'Hakuna Jibu', na mstari wa pili ni tofauti ikiwa neno ni \"la Bahati\", au 0 vinginevyo.\nMfano wa Matumizi:\n>>> is_lucky_word \"error\"\nNeno la Bahati\n2\n>>> is_lucky_word \"olympic\"\nHakuna Jibu\n0",
      "tr": "Bu fonksiyon, verilen kelimenin \"Şanslı Kelime\" olup olmadığını kontrol eder.  \nBir kelime, en yüksek ve en düşük harf frekansı arasındaki fark asal bir sayı ise \"Şanslı\" olarak kabul edilir.  \nGirdi: Küçük harflerden oluşan ve uzunluğu 100'den az olan tek bir kelime.  \nÇıktı: İki satır - ilk satır 'Şanslı Kelime' veya 'Cevap Yok', ikinci satır ise kelime \"Şanslı\" ise farkı, aksi takdirde 0.  \nÖrnek Kullanım:  \n>>> is_lucky_word \"error\"  \nŞanslı Kelime  \n2  \n>>> is_lucky_word \"olympic\"  \nCevap Yok  \n0  ",
      "vi": "Hàm này kiểm tra xem từ được cho có phải là \"Từ May Mắn\" hay không.  \nMột từ được coi là \"May Mắn\" nếu hiệu số giữa tần suất chữ cái cao nhất và thấp nhất là một số nguyên tố.  \nĐầu vào: Một từ duy nhất bao gồm các chữ cái thường và có độ dài nhỏ hơn 100.  \nĐầu ra: Hai dòng - dòng đầu tiên là 'Lucky Word' hoặc 'No Answer', và dòng thứ hai là hiệu số nếu từ là \"May Mắn\", hoặc 0 nếu không phải.  \nVí dụ sử dụng:  \n>>> is_lucky_word \"error\"  \nLucky Word  \n2  \n>>> is_lucky_word \"olympic\"  \nNo Answer  \n0  "
    },
    "docstring_bertscore": {
      "es": "0.9873224159304482",
      "arb": "0.9726998431698028",
      "sw": "0.9678584262624585",
      "tr": "0.9704253266765724",
      "vi": "0.9849801664772848"
    }
  },
  {
    "task_id": "Shell/34",
    "prompt": {
      "en": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# This function finds the kth smallest unique number from a list of positive integers. \n# Duplicate numbers are only counted once. If k is greater than the number of unique elements, \n# it returns 'NO RESULT'.\n# Args:\n# $1: A string of space-separated positive integers.\n# $2: An integer representing the value of k.\n# Returns:\n# The kth smallest unique number or 'NO RESULT' if k is too large.\n# Example:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Returns: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Returns: NO RESULT",
      "es": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Esta función encuentra el k-ésimo número único más pequeño de una lista de enteros positivos.\n# Los números duplicados solo se cuentan una vez. Si k es mayor que el número de elementos únicos,\n# devuelve 'NO RESULT'.\n# Argumentos:\n# $1: Una cadena de enteros positivos separados por espacios.\n# $2: Un entero que representa el valor de k.\n# Devuelve:\n# El k-ésimo número único más pequeño o 'NO RESULT' si k es demasiado grande.\n# Ejemplo:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Devuelve: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Devuelve: NO RESULT",
      "arb": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# هذه الدالة تجد الرقم الفريد الأصغر في المرتبة k من قائمة الأعداد الصحيحة الموجبة.\n# الأرقام المكررة تُحسب مرة واحدة فقط. إذا كان k أكبر من عدد العناصر الفريدة،\n# فإنها تُرجع 'NO RESULT'.\n# الوسائط:\n# $1: سلسلة من الأعداد الصحيحة الموجبة مفصولة بمسافات.\n# $2: عدد صحيح يمثل قيمة k.\n# تُرجع:\n# الرقم الفريد الأصغر في المرتبة k أو 'NO RESULT' إذا كانت k كبيرة جداً.\n# مثال:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # يُرجع: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # يُرجع: NO RESULT",
      "sw": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Kazi hii inapata nambari ya kipekee ya k ndogo kutoka kwenye orodha ya nambari za mzima chanya.\n# Nambari zinazojirudia zinahesabiwa mara moja tu. Ikiwa k ni kubwa kuliko idadi ya vipengele vya kipekee,\n# inarudisha 'NO RESULT'.\n# Hoja:\n# $1: Mfuatano wa nambari za mzima chanya zilizotenganishwa kwa nafasi.\n# $2: Nambari ya mzima inayowakilisha thamani ya k.\n# Inarudisha:\n# Nambari ya kipekee ya k ndogo au 'NO RESULT' ikiwa k ni kubwa mno.\n# Mfano:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Inarudisha: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Inarudisha: NO RESULT",
      "tr": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Bu fonksiyon, pozitif tamsayılar listesinden k. en küçük benzersiz sayıyı bulur.\n# Yinelenen sayılar yalnızca bir kez sayılır. Eğer k, benzersiz elemanların sayısından büyükse,\n# 'SONUÇ YOK' döndürür.\n# Argümanlar:\n# $1: Boşlukla ayrılmış pozitif tamsayılar içeren bir dize.\n# $2: k değerini temsil eden bir tamsayı.\n# Döndürür:\n# k. en küçük benzersiz sayı veya k çok büyükse 'SONUÇ YOK'.\n# Örnek:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Döndürür: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Döndürür: SONUÇ YOK",
      "vi": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Hàm này tìm số duy nhất nhỏ thứ k từ một danh sách các số nguyên dương.\n# Các số trùng lặp chỉ được tính một lần. Nếu k lớn hơn số lượng phần tử duy nhất,\n# nó trả về 'NO RESULT'.\n# Tham số:\n# $1: Một chuỗi các số nguyên dương cách nhau bằng dấu cách.\n# $2: Một số nguyên đại diện cho giá trị của k.\n# Trả về:\n# Số duy nhất nhỏ thứ k hoặc 'NO RESULT' nếu k quá lớn.\n# Ví dụ:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Trả về: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Trả về: NO RESULT"
    },
    "prompt_bertscore": {
      "es": "0.9802591195808477",
      "arb": "0.9799913658272126",
      "sw": "0.9681241937122832",
      "tr": "0.9778503289500375",
      "vi": "0.9788105082119603"
    },
    "canonical_solution": "local sorted_unique_numbers=($(printf '%s\\n' \"${numbers[@]}\" | sort -n | uniq))\n\n# Check if k is within the range\nif [[ $k -le ${#sorted_unique_numbers[@]} && $k -gt 0 ]]; then\necho ${sorted_unique_numbers[$((k-1))]}\nelse\necho \"NO RESULT\"\nfi\n}",
    "instruction": {
      "en": "Write a Shell function `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` to solve the following problem:\nThis function finds the kth smallest unique number from a list of positive integers. \nDuplicate numbers are only counted once. If k is greater than the number of unique elements, \nit returns 'NO RESULT'.\nArgs:\n$1: A string of space-separated positive integers.\n$2: An integer representing the value of k.\nReturns:\nThe kth smallest unique number or 'NO RESULT' if k is too large.\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT",
      "es": "Escribe una función de Shell `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` para resolver el siguiente problema:\nEsta función encuentra el k-ésimo número único más pequeño de una lista de enteros positivos.\nLos números duplicados solo se cuentan una vez. Si k es mayor que el número de elementos únicos,\ndevuelve 'NO RESULT'.\nArgumentos:\n$1: Una cadena de enteros positivos separados por espacios.\n$2: Un entero que representa el valor de k.\nDevuelve:\nEl k-ésimo número único más pequeño o 'NO RESULT' si k es demasiado grande.\nEjemplo:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nDevuelve: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nDevuelve: NO RESULT",
      "arb": "اكتب دالة Shell `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` لحل المشكلة التالية:\nهذه الدالة تجد العدد الفريد الأصغر في المرتبة k من قائمة الأعداد الصحيحة الموجبة.\nالأعداد المكررة تُحسب مرة واحدة فقط. إذا كان k أكبر من عدد العناصر الفريدة،\nفإنها تعيد 'NO RESULT'.\nالمعاملات:\n$1: سلسلة من الأعداد الصحيحة الموجبة مفصولة بمسافات.\n$2: عدد صحيح يمثل قيمة k.\nالإرجاع:\nالعدد الفريد الأصغر في المرتبة k أو 'NO RESULT' إذا كان k كبيرًا جدًا.\nمثال:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nالإرجاع: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nالإرجاع: NO RESULT",
      "sw": "Andika kazi ya Shell `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` kutatua tatizo lifuatalo:\nKazi hii inapata nambari ya kipekee ya k ndogo zaidi kutoka kwenye orodha ya nambari chanya. \nNambari zinazojirudia zinahesabiwa mara moja tu. Ikiwa k ni kubwa kuliko idadi ya vipengele vya kipekee, \ninarudisha 'NO RESULT'.\nHoja:\n$1: Msururu wa nambari chanya zilizotenganishwa na nafasi.\n$2: Nambari inayowakilisha thamani ya k.\nInarudisha:\nNambari ya kipekee ya k ndogo zaidi au 'NO RESULT' ikiwa k ni kubwa sana.\nMfano:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nInarudisha: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nInarudisha: NO RESULT",
      "tr": "Bir Shell fonksiyonu yazın `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` aşağıdaki problemi çözmek için:\nBu fonksiyon, pozitif tamsayılar listesinden k. en küçük benzersiz sayıyı bulur. \nYinelenen sayılar yalnızca bir kez sayılır. Eğer k, benzersiz elemanların sayısından büyükse, \n'NO RESULT' döndürür.\nArgümanlar:\n$1: Boşluklarla ayrılmış pozitif tamsayıların bir dizgesi.\n$2: k değerini temsil eden bir tamsayı.\nDöndürür:\nk. en küçük benzersiz sayı veya k çok büyükse 'NO RESULT'.\nÖrnek:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nDöndürür: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nDöndürür: NO RESULT",
      "vi": "Viết một hàm Shell `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` để giải quyết vấn đề sau:\nHàm này tìm số duy nhất nhỏ thứ k từ một danh sách các số nguyên dương. \nCác số trùng lặp chỉ được đếm một lần. Nếu k lớn hơn số lượng phần tử duy nhất, \nnó trả về 'NO RESULT'.\nTham số:\n$1: Một chuỗi các số nguyên dương cách nhau bằng dấu cách.\n$2: Một số nguyên đại diện cho giá trị của k.\nTrả về:\nSố duy nhất nhỏ thứ k hoặc 'NO RESULT' nếu k quá lớn.\nVí dụ:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nTrả về: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nTrả về: NO RESULT"
    },
    "instruction_bertscore": {
      "es": "0.9844412822535372",
      "arb": "0.9310905523202335",
      "sw": "0.974317091732189",
      "tr": "0.9795045227632961",
      "vi": "0.9798924478974572"
    },
    "level": "easy",
    "test": "test_kth_smallest_unique_number() {\n[[ $(find_kth_smallest_unique_number \"5 1 3 5 2 4 1\" 4) == \"4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"8 7 6 5 4 3 2 1\" 3) == \"3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"9 9 8 8 7 7\" 2) == \"8\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"10 20 30 40 50\" 5) == \"50\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"15 15 15 15 15\" 1) == \"15\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"1 2 3 4 5\" 6) == \"NO RESULT\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"3 3 3 3 3\" 2) == \"NO RESULT\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_kth_smallest_unique_number",
    "entry_point": "find_kth_smallest_unique_number",
    "signature": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n",
    "docstring": {
      "en": "This function finds the kth smallest unique number from a list of positive integers. \nDuplicate numbers are only counted once. If k is greater than the number of unique elements, \nit returns 'NO RESULT'.\nArgs:\n$1: A string of space-separated positive integers.\n$2: An integer representing the value of k.\nReturns:\nThe kth smallest unique number or 'NO RESULT' if k is too large.\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT",
      "es": "Esta función encuentra el k-ésimo número único más pequeño de una lista de enteros positivos. \nLos números duplicados solo se cuentan una vez. Si k es mayor que el número de elementos únicos, \ndevuelve 'SIN RESULTADO'.\nArgumentos:\n$1: Una cadena de enteros positivos separados por espacios.\n$2: Un entero que representa el valor de k.\nDevuelve:\nEl k-ésimo número único más pequeño o 'SIN RESULTADO' si k es demasiado grande.\nEjemplo:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nDevuelve: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nDevuelve: NO RESULT",
      "arb": "هذه الدالة تجد العدد الفريد الأصغر في المرتبة k من قائمة الأعداد الصحيحة الموجبة. الأعداد المكررة تُحسب مرة واحدة فقط. إذا كان k أكبر من عدد العناصر الفريدة، فإنها تعيد 'NO RESULT'.\nالمعطيات:\n$1: سلسلة من الأعداد الصحيحة الموجبة مفصولة بمسافات.\n$2: عدد صحيح يمثل قيمة k.\nالقيم المعادة:\nالعدد الفريد الأصغر في المرتبة k أو 'NO RESULT' إذا كان k كبيرًا جدًا.\nمثال:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nيعيد: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nيعيد: NO RESULT",
      "sw": "Kazi hii inapata nambari ya kipekee ya kth ndogo zaidi kutoka kwenye orodha ya nambari nzima chanya.\nNambari zinazojirudia zinahesabiwa mara moja tu. Ikiwa k ni kubwa kuliko idadi ya vipengele vya kipekee,\ninarudisha 'HAKUNA MATOKEO'.\nHoja:\n$1: Mstari wa maandishi wa nambari nzima chanya zilizotenganishwa kwa nafasi.\n$2: Nambari nzima inayowakilisha thamani ya k.\nInarudisha nambari ya kipekee ya kth ndogo zaidi au 'HAKUNA MATOKEO' ikiwa k ni kubwa sana.\nMfano:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nInarudisha: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nInarudisha: HAKUNA MATOKEO",
      "tr": "Bu fonksiyon, pozitif tam sayılardan oluşan bir listeden k. en küçük benzersiz sayıyı bulur. \nYinelenen sayılar yalnızca bir kez sayılır. Eğer k, benzersiz elemanların sayısından büyükse, \n'SONUÇ YOK' döndürür.\nArgümanlar:\n$1: Boşlukla ayrılmış pozitif tam sayılardan oluşan bir dize.\n$2: k değerini temsil eden bir tam sayı.\nDöndürür:\nk. en küçük benzersiz sayı veya k çok büyükse 'SONUÇ YOK'.\nÖrnek:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nDöndürür: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nDöndürür: NO RESULT",
      "vi": "Hàm này tìm số nhỏ nhất thứ k duy nhất từ một danh sách các số nguyên dương. \nCác số trùng lặp chỉ được tính một lần. Nếu k lớn hơn số lượng phần tử duy nhất, \nnó trả về 'NO RESULT'.\nTham số:\n$1: Một chuỗi các số nguyên dương cách nhau bằng dấu cách.\n$2: Một số nguyên đại diện cho giá trị của k.\nTrả về:\nSố nhỏ nhất thứ k duy nhất hoặc 'NO RESULT' nếu k quá lớn.\nVí dụ:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nTrả về: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nTrả về: NO RESULT"
    },
    "docstring_bertscore": {
      "es": "0.981832272198644",
      "arb": "0.9435704991606555",
      "sw": "1",
      "tr": "0.9815156553712744",
      "vi": "0.9737754266831068"
    }
  },
  {
    "task_id": "Shell/35",
    "prompt": {
      "en": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# This function converts a number from one base to another.\n# The function accepts three arguments: the base of the input number (2 to 16),\n# the number to be converted (in string format), and the base to which it should be converted (2 to 16).\n# The function returns the converted number in string format.\n# The input number may include digits 0-9 and uppercase letters A-F for bases higher than 10.\n# If the input number or the base is invalid, the function returns 'INVALID INPUT'.\n# Examples:\n# convert_bases 10 \"255\" 2\n# # Returns: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Returns: \"A\"\n# convert_bases 8 \"17\" 10\n# # Returns: \"15\"",
      "es": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Esta función convierte un número de una base a otra.\n# La función acepta tres argumentos: la base del número de entrada (2 a 16),\n# el número a convertir (en formato de cadena), y la base a la que debe ser convertido (2 a 16).\n# La función devuelve el número convertido en formato de cadena.\n# El número de entrada puede incluir dígitos del 0 al 9 y letras mayúsculas de la A a la F para bases superiores a 10.\n# Si el número de entrada o la base son inválidos, la función devuelve 'INVALID INPUT'.\n# Ejemplos:\n# convert_bases 10 \"255\" 2\n# # Devuelve: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Devuelve: \"A\"\n# convert_bases 8 \"17\" 10\n# # Devuelve: \"15\"",
      "arb": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# تقوم هذه الدالة بتحويل رقم من أساس إلى آخر.\n# تقبل الدالة ثلاثة معطيات: أساس الرقم المدخل (من 2 إلى 16)،\n# الرقم الذي سيتم تحويله (بصيغة سلسلة نصية)، والأساس الذي يجب التحويل إليه (من 2 إلى 16).\n# تعيد الدالة الرقم المحول بصيغة سلسلة نصية.\n# قد يتضمن الرقم المدخل الأرقام من 0-9 والحروف الكبيرة A-F للأسس الأكبر من 10.\n# إذا كان الرقم المدخل أو الأساس غير صالح، تعيد الدالة 'INVALID INPUT'.\n# أمثلة:\n# convert_bases 10 \"255\" 2\n# # يعيد: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # يعيد: \"A\"\n# convert_bases 8 \"17\" 10\n# # يعيد: \"15\"",
      "sw": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Kazi hii inabadilisha nambari kutoka msingi mmoja kwenda mwingine.\n# Kazi inakubali hoja tatu: msingi wa nambari ya ingizo (2 hadi 16),\n# nambari inayopaswa kubadilishwa (katika muundo wa kamba), na msingi ambao inapaswa kubadilishwa (2 hadi 16).\n# Kazi inarejesha nambari iliyobadilishwa katika muundo wa kamba.\n# Nambari ya ingizo inaweza kujumuisha tarakimu 0-9 na herufi kubwa A-F kwa misingi zaidi ya 10.\n# Ikiwa nambari ya ingizo au msingi si sahihi, kazi inarejesha 'INVALID INPUT'.\n# Mifano:\n# convert_bases 10 \"255\" 2\n# # Inarejesha: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Inarejesha: \"A\"\n# convert_bases 8 \"17\" 10\n# # Inarejesha: \"15\"",
      "tr": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Bu fonksiyon bir sayıyı bir tabandan başka bir tabana dönüştürür.\n# Fonksiyon üç argüman alır: giriş sayısının tabanı (2'den 16'ya kadar),\n# dönüştürülecek sayı (string formatında) ve dönüştürülmesi gereken taban (2'den 16'ya kadar).\n# Fonksiyon, dönüştürülmüş sayıyı string formatında döndürür.\n# Giriş sayısı, 10'dan büyük tabanlar için 0-9 arası rakamlar ve A-F büyük harflerini içerebilir.\n# Eğer giriş sayısı veya taban geçersizse, fonksiyon 'GEÇERSİZ GİRİŞ' döndürür.\n# Örnekler:\n# convert_bases 10 \"255\" 2\n# # Döndürür: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Döndürür: \"A\"\n# convert_bases 8 \"17\" 10\n# # Döndürür: \"15\"",
      "vi": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Hàm này chuyển đổi một số từ một hệ cơ số sang một hệ cơ số khác.\n# Hàm chấp nhận ba tham số: cơ số của số đầu vào (2 đến 16),\n# số cần chuyển đổi (dưới dạng chuỗi), và cơ số mà nó cần được chuyển đổi sang (2 đến 16).\n# Hàm trả về số đã được chuyển đổi dưới dạng chuỗi.\n# Số đầu vào có thể bao gồm các chữ số 0-9 và các chữ cái in hoa A-F cho các cơ số lớn hơn 10.\n# Nếu số đầu vào hoặc cơ số không hợp lệ, hàm trả về 'INVALID INPUT'.\n# Ví dụ:\n# convert_bases 10 \"255\" 2\n# # Trả về: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Trả về: \"A\"\n# convert_bases 8 \"17\" 10\n# # Trả về: \"15\""
    },
    "prompt_bertscore": {
      "es": "0.9883392048509658",
      "arb": "0.9827849035060873",
      "sw": "0.99340130011164",
      "tr": "0.9849603034391814",
      "vi": "0.9832576438129503"
    },
    "canonical_solution": "if [[ $input_base -lt 2 || $input_base -gt 16 || $target_base -lt 2 || $target_base -gt 16 ]]; then\necho \"INVALID INPUT\"\nreturn 1\nfi\n\n# Convert input number to decimal\nlocal decimal_number=$(echo \"ibase=$input_base; $number\" | bc)\n\n# Convert decimal number to target base\nlocal converted_number=$(echo \"obase=$target_base; $decimal_number\" | bc)\n\necho $converted_number\n}",
    "instruction": {
      "en": "Write a Shell function `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` to solve the following problem:\nThis function converts a number from one base to another.\nThe function accepts three arguments: the base of the input number (2 to 16),\nthe number to be converted (in string format), and the base to which it should be converted (2 to 16).\nThe function returns the converted number in string format.\nThe input number may include digits 0-9 and uppercase letters A-F for bases higher than 10.\nIf the input number or the base is invalid, the function returns 'INVALID INPUT'.\nExamples:\nconvert_bases 10 \"255\" 2\nReturns: \"11111111\"\nconvert_bases 2 \"1010\" 16\nReturns: \"A\"\nconvert_bases 8 \"17\" 10\nReturns: \"15\"",
      "es": "Escribe una función de Shell `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` para resolver el siguiente problema:\nEsta función convierte un número de una base a otra.\nLa función acepta tres argumentos: la base del número de entrada (2 a 16),\nel número a convertir (en formato de cadena) y la base a la que debe ser convertido (2 a 16).\nLa función devuelve el número convertido en formato de cadena.\nEl número de entrada puede incluir dígitos del 0-9 y letras mayúsculas A-F para bases superiores a 10.\nSi el número de entrada o la base no son válidos, la función devuelve 'INVALID INPUT'.\nEjemplos:\nconvert_bases 10 \"255\" 2\nDevuelve: \"11111111\"\nconvert_bases 2 \"1010\" 16\nDevuelve: \"A\"\nconvert_bases 8 \"17\" 10\nDevuelve: \"15\"",
      "arb": "اكتب دالة شل `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` لحل المشكلة التالية:\nهذه الدالة تقوم بتحويل رقم من أساس إلى آخر.\nتقبل الدالة ثلاثة معطيات: أساس الرقم المدخل (من 2 إلى 16)،\nالرقم الذي سيتم تحويله (بصيغة سلسلة نصية)، والأساس الذي سيتم التحويل إليه (من 2 إلى 16).\nتعيد الدالة الرقم المحول بصيغة سلسلة نصية.\nقد يتضمن الرقم المدخل الأرقام 0-9 والحروف الكبيرة A-F للأسس الأعلى من 10.\nإذا كان الرقم المدخل أو الأساس غير صالح، تعيد الدالة 'INVALID INPUT'.\nأمثلة:\nconvert_bases 10 \"255\" 2\nيعيد: \"11111111\"\nconvert_bases 2 \"1010\" 16\nيعيد: \"A\"\nconvert_bases 8 \"17\" 10\nيعيد: \"15\"",
      "sw": "Andika kazi ya Shell `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` kutatua tatizo lifuatalo:\nKazi hii hubadilisha nambari kutoka msingi mmoja hadi mwingine.\nKazi inakubali hoja tatu: msingi wa nambari ya ingizo (2 hadi 16),\nnambari inayopaswa kubadilishwa (katika umbizo la kamba), na msingi ambao inapaswa kubadilishwa (2 hadi 16).\nKazi inarudisha nambari iliyobadilishwa katika umbizo la kamba.\nNambari ya ingizo inaweza kujumuisha tarakimu 0-9 na herufi kubwa A-F kwa misingi ya juu ya 10.\nIkiwa nambari ya ingizo au msingi si sahihi, kazi inarudisha 'INVALID INPUT'.\nMifano:\nconvert_bases 10 \"255\" 2\nInarudisha: \"11111111\"\nconvert_bases 2 \"1010\" 16\nInarudisha: \"A\"\nconvert_bases 8 \"17\" 10\nInarudisha: \"15\"",
      "tr": "Bir Shell fonksiyonu yazın `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` aşağıdaki problemi çözmek için:\nBu fonksiyon bir sayıyı bir tabandan başka bir tabana dönüştürür.\nFonksiyon üç argüman kabul eder: giriş sayısının tabanı (2'den 16'ya kadar),\ndönüştürülecek sayı (string formatında) ve dönüştürülmesi gereken taban (2'den 16'ya kadar).\nFonksiyon dönüştürülmüş sayıyı string formatında döndürür.\nGiriş sayısı, 10'dan büyük tabanlar için 0-9 rakamlarını ve büyük harf A-F harflerini içerebilir.\nEğer giriş sayısı veya taban geçersizse, fonksiyon 'INVALID INPUT' döndürür.\nÖrnekler:\nconvert_bases 10 \"255\" 2\nDöndürür: \"11111111\"\nconvert_bases 2 \"1010\" 16\nDöndürür: \"A\"\nconvert_bases 8 \"17\" 10\nDöndürür: \"15\"",
      "vi": "Viết một hàm Shell `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` để giải quyết vấn đề sau:\nHàm này chuyển đổi một số từ một cơ số này sang cơ số khác.\nHàm chấp nhận ba tham số: cơ số của số đầu vào (2 đến 16),\nsố cần chuyển đổi (dưới dạng chuỗi), và cơ số mà nó cần được chuyển đổi sang (2 đến 16).\nHàm trả về số đã chuyển đổi dưới dạng chuỗi.\nSố đầu vào có thể bao gồm các chữ số 0-9 và các chữ cái in hoa A-F cho các cơ số lớn hơn 10.\nNếu số đầu vào hoặc cơ số không hợp lệ, hàm trả về 'INVALID INPUT'.\nVí dụ:\nconvert_bases 10 \"255\" 2\nTrả về: \"11111111\"\nconvert_bases 2 \"1010\" 16\nTrả về: \"A\"\nconvert_bases 8 \"17\" 10\nTrả về: \"15\""
    },
    "instruction_bertscore": {
      "es": "0.9911959069910096",
      "arb": "0.9846573921081032",
      "sw": "0.9917717364656298",
      "tr": "0.9887136231192166",
      "vi": "0.9852699682032148"
    },
    "level": "easy",
    "test": "test_convert_bases() {\n[[ $(convert_bases 10 \"1024\" 2) == \"10000000000\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(convert_bases 16 \"1A3\" 8) == \"643\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(convert_bases 2 \"1101\" 10) == \"13\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(convert_bases 16 \"ABC\" 2) == \"101010111100\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(convert_bases 8 \"777\" 16) == \"1FF\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(convert_bases 4 \"123\" 10) == \"27\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(convert_bases 20 \"1A\" 2) == \"INVALID INPUT\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_convert_bases",
    "entry_point": "convert_bases",
    "signature": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n",
    "docstring": {
      "en": "This function converts a number from one base to another.\nThe function accepts three arguments: the base of the input number (2 to 16),\nthe number to be converted (in string format), and the base to which it should be converted (2 to 16).\nThe function returns the converted number in string format.\nThe input number may include digits 0-9 and uppercase letters A-F for bases higher than 10.\nIf the input number or the base is invalid, the function returns 'INVALID INPUT'.\nExamples:\nconvert_bases 10 \"255\" 2\nReturns: \"11111111\"\nconvert_bases 2 \"1010\" 16\nReturns: \"A\"\nconvert_bases 8 \"17\" 10\nReturns: \"15\"",
      "es": "Esta función convierte un número de una base a otra.  \nLa función acepta tres argumentos: la base del número de entrada (2 a 16),  \nel número a convertir (en formato de cadena), y la base a la que debe ser convertido (2 a 16).  \nLa función devuelve el número convertido en formato de cadena.  \nEl número de entrada puede incluir dígitos del 0 al 9 y letras mayúsculas de la A a la F para bases superiores a 10.  \nSi el número de entrada o la base son inválidos, la función devuelve 'ENTRADA INVÁLIDA'.  \nEjemplos:  \nconvert_bases 10 \"255\" 2  \nDevuelve: \"11111111\"  \nconvert_bases 2 \"1010\" 16  \nDevuelve: \"A\"  \nconvert_bases 8 \"17\" 10  \nDevuelve: \"15\"  ",
      "arb": "هذه الدالة تحول رقمًا من قاعدة إلى أخرى.  \nتقبل الدالة ثلاثة معطيات: قاعدة الرقم المدخل (من 2 إلى 16)،  \nالرقم الذي سيتم تحويله (بصيغة نصية)، والقاعدة التي يجب تحويله إليها (من 2 إلى 16).  \nتعيد الدالة الرقم المحول بصيغة نصية.  \nقد يتضمن الرقم المدخل الأرقام من 0-9 والحروف الكبيرة من A-F للقواعد التي تزيد عن 10.  \nإذا كان الرقم المدخل أو القاعدة غير صالحين، تعيد الدالة 'INVALID INPUT'.  \nأمثلة:  \nconvert_bases 10 \"255\" 2  \nيعيد: \"11111111\"  \nconvert_bases 2 \"1010\" 16  \nيعيد: \"A\"  \nconvert_bases 8 \"17\" 10  \nيعيد: \"15\"  ",
      "sw": "Kazi hii hubadilisha nambari kutoka msingi mmoja hadi mwingine.\nKazi inakubali hoja tatu: msingi wa nambari ya ingizo (2 hadi 16),\nnambari inayopaswa kubadilishwa (katika umbizo la kamba), na msingi ambao inapaswa kubadilishwa (2 hadi 16).\nKazi inarudisha nambari iliyobadilishwa katika umbizo la kamba.\nNambari ya ingizo inaweza kujumuisha tarakimu 0-9 na herufi kubwa A-F kwa misingi ya juu ya 10.\nIkiwa nambari ya ingizo au msingi si sahihi, kazi inarudisha 'INVALID INPUT'.\nMifano:\nconvert_bases 10 \"255\" 2\nInarudisha: \"11111111\"\nconvert_bases 2 \"1010\" 16\nInarudisha: \"A\"\nconvert_bases 8 \"17\" 10\nInarudisha: \"15\"",
      "tr": "Bu fonksiyon bir sayıyı bir tabandan diğerine dönüştürür.\nFonksiyon üç argüman kabul eder: giriş sayısının tabanı (2'den 16'ya kadar),\ndönüştürülecek sayı (string formatında) ve dönüştürüleceği taban (2'den 16'ya kadar).\nFonksiyon, dönüştürülmüş sayıyı string formatında döndürür.\nGiriş sayısı, 10'dan büyük tabanlar için 0-9 arası rakamları ve büyük harf A-F'yi içerebilir.\nEğer giriş sayısı veya taban geçersizse, fonksiyon 'GEÇERSİZ GİRİŞ' döndürür.\nÖrnekler:\nconvert_bases 10 \"255\" 2\nDöndürülen: \"11111111\"\nconvert_bases 2 \"1010\" 16\nDöndürülen: \"A\"\nconvert_bases 8 \"17\" 10\nDöndürülen: \"15\"",
      "vi": "Hàm này chuyển đổi một số từ một cơ số sang cơ số khác.  \nHàm chấp nhận ba đối số: cơ số của số đầu vào (2 đến 16), số cần chuyển đổi (dưới dạng chuỗi), và cơ số mà nó cần được chuyển đổi sang (2 đến 16).  \nHàm trả về số đã chuyển đổi dưới dạng chuỗi.  \nSố đầu vào có thể bao gồm các chữ số 0-9 và các chữ cái in hoa A-F cho các cơ số lớn hơn 10.  \nNếu số đầu vào hoặc cơ số không hợp lệ, hàm trả về 'INVALID INPUT'.  \nVí dụ:  \nconvert_bases 10 \"255\" 2  \nTrả về: \"11111111\"  \nconvert_bases 2 \"1010\" 16  \nTrả về: \"A\"  \nconvert_bases 8 \"17\" 10  \nTrả về: \"15\"  "
    },
    "docstring_bertscore": {
      "es": "0.9842257682901143",
      "arb": "0.979469762446615",
      "sw": "1",
      "tr": "0.9755885248011933",
      "vi": "0.9834685892776094"
    }
  },
  {
    "task_id": "Shell/36",
    "prompt": {
      "en": "find_sum_segments() {\nlocal M=$1\n# This function identifies all the continuous segments of positive integers that sum to a given integer M.\n# Each segment must contain at least two consecutive numbers.\n# Args:\n# $1: A positive integer M, the target sum (10 <= M <= 2,000,000).\n# Returns:\n# The output consists of several lines, each containing two positive integers separated by a space.\n# These integers represent the first and last numbers in a continuous segment that sums to M.\n# The lines are sorted in ascending order based on the starting number of each segment.\n# Example:\n# find_sum_segments 21\n# # Returns:\n# # 6 8\n# # 10 11",
      "es": "find_sum_segments() {\nlocal M=$1\n# Esta función identifica todos los segmentos continuos de enteros positivos que suman un entero dado M.\n# Cada segmento debe contener al menos dos números consecutivos.\n# Argumentos:\n# $1: Un entero positivo M, la suma objetivo (10 <= M <= 2,000,000).\n# Devuelve:\n# La salida consiste en varias líneas, cada una contiene dos enteros positivos separados por un espacio.\n# Estos enteros representan el primer y último número en un segmento continuo que suma M.\n# Las líneas están ordenadas en orden ascendente según el número inicial de cada segmento.\n# Ejemplo:\n# find_sum_segments 21\n# # Devuelve:\n# # 6 8\n# # 10 11",
      "arb": "find_sum_segments() {\nlocal M=$1\n# تحدد هذه الدالة جميع المقاطع المتتالية من الأعداد الصحيحة الموجبة التي يكون مجموعها عددًا صحيحًا معينًا M.\n# يجب أن يحتوي كل مقطع على رقمين متتاليين على الأقل.\n# الوسائط:\n# $1: عدد صحيح موجب M، المجموع المستهدف (10 <= M <= 2,000,000).\n# يعيد:\n# يتكون الإخراج من عدة أسطر، يحتوي كل منها على عددين صحيحين موجبين مفصولين بمسافة.\n# تمثل هذه الأعداد الأرقام الأولى والأخيرة في مقطع متتالي يكون مجموعها M.\n# يتم ترتيب الأسطر بترتيب تصاعدي بناءً على الرقم الأول لكل مقطع.\n# مثال:\n# find_sum_segments 21\n# # يعيد:\n# # 6 8\n# # 10 11",
      "sw": "find_sum_segments() {\nlocal M=$1\n# Kazi ya hii kazi ni kutambua sehemu zote za mfululizo za namba chanya ambazo jumla yake ni sawa na namba fulani M.\n# Kila sehemu lazima iwe na angalau namba mbili zinazofuatana.\n# Hoja:\n# $1: Namba chanya M, jumla lengwa (10 <= M <= 2,000,000).\n# Inarudisha:\n# Matokeo yanajumuisha mistari kadhaa, kila moja ikiwa na namba mbili chanya zilizotenganishwa na nafasi.\n# Namba hizi zinawakilisha namba ya kwanza na ya mwisho katika sehemu ya mfululizo ambayo jumla yake ni M.\n# Mistari imepangwa kwa mpangilio wa kupanda kulingana na namba ya kuanzia ya kila sehemu.\n# Mfano:\n# find_sum_segments 21\n# # Inarudisha:\n# # 6 8\n# # 10 11",
      "tr": "find_sum_segments() {\nlocal M=$1\n# Bu fonksiyon, belirli bir M tamsayısına eşit olan pozitif tamsayıların sürekli segmentlerini belirler.\n# Her segment en az iki ardışık sayı içermelidir.\n# Argümanlar:\n# $1: Hedef toplam olan pozitif bir tamsayı M (10 <= M <= 2,000,000).\n# Döndürür:\n# Çıktı, her biri bir boşlukla ayrılmış iki pozitif tamsayı içeren birkaç satırdan oluşur.\n# Bu tamsayılar, M'e toplamı eşit olan sürekli bir segmentin ilk ve son sayılarını temsil eder.\n# Satırlar, her segmentin başlangıç sayısına göre artan sırayla sıralanır.\n# Örnek:\n# find_sum_segments 21\n# # Döndürür:\n# # 6 8\n# # 10 11",
      "vi": "find_sum_segments() {\nlocal M=$1\n# Hàm này xác định tất cả các đoạn liên tục của các số nguyên dương có tổng bằng một số nguyên M cho trước.\n# Mỗi đoạn phải chứa ít nhất hai số liên tiếp.\n# Tham số:\n# $1: Một số nguyên dương M, tổng mục tiêu (10 <= M <= 2,000,000).\n# Trả về:\n# Đầu ra bao gồm nhiều dòng, mỗi dòng chứa hai số nguyên dương được ngăn cách bởi một khoảng trắng.\n# Các số nguyên này đại diện cho số đầu tiên và cuối cùng trong một đoạn liên tục có tổng bằng M.\n# Các dòng được sắp xếp theo thứ tự tăng dần dựa trên số bắt đầu của mỗi đoạn.\n# Ví dụ:\n# find_sum_segments 21\n# # Trả về:\n# # 6 8\n# # 10 11"
    },
    "prompt_bertscore": {
      "es": "0.992575394987297",
      "arb": "0.9638752912315659",
      "sw": "0.9153363822788324",
      "tr": "0.9660983624561084",
      "vi": "0.9683643378429544"
    },
    "canonical_solution": "local start=1\nlocal end=2\nlocal sum=$((start + end))\n\nwhile [[ start -lt end ]]; do\nif [[ sum -lt M ]]; then\nend=$((end + 1))\nsum=$((sum + end))\nelif [[ sum -gt M ]]; then\nsum=$((sum - start))\nstart=$((start + 1))\nelse\necho \"$start $end\"\nsum=$((sum - start))\nstart=$((start + 1))\nfi\ndone\n}",
    "instruction": {
      "en": "Write a Shell function `find_sum_segments() {\nlocal M=$1\n` to solve the following problem:\nThis function identifies all the continuous segments of positive integers that sum to a given integer M.\nEach segment must contain at least two consecutive numbers.\nArgs:\n$1: A positive integer M, the target sum (10 <= M <= 2,000,000).\nReturns:\nThe output consists of several lines, each containing two positive integers separated by a space.\nThese integers represent the first and last numbers in a continuous segment that sums to M.\nThe lines are sorted in ascending order based on the starting number of each segment.\nExample:\nfind_sum_segments 21\nReturns:\n6 8\n10 11",
      "es": "Escribe una función de Shell `find_sum_segments() {\nlocal M=$1\n` para resolver el siguiente problema:\nEsta función identifica todos los segmentos continuos de enteros positivos que suman un entero dado M.\nCada segmento debe contener al menos dos números consecutivos.\nArgumentos:\n$1: Un entero positivo M, la suma objetivo (10 <= M <= 2,000,000).\nDevuelve:\nLa salida consiste en varias líneas, cada una conteniendo dos enteros positivos separados por un espacio.\nEstos enteros representan el primer y último número en un segmento continuo que suma M.\nLas líneas están ordenadas en orden ascendente basado en el número inicial de cada segmento.\nEjemplo:\nfind_sum_segments 21\nDevuelve:\n6 8\n10 11",
      "arb": "اكتب دالة شل `find_sum_segments() {\nlocal M=$1\n` لحل المشكلة التالية:\nتحدد هذه الدالة جميع الأجزاء المتتالية من الأعداد الصحيحة الموجبة التي يكون مجموعها عددًا صحيحًا معينًا M.\nيجب أن يحتوي كل جزء على رقمين متتاليين على الأقل.\nالمعطيات:\n$1: عدد صحيح موجب M، المجموع المستهدف (10 <= M <= 2,000,000).\nالمخرجات:\nيتكون الإخراج من عدة أسطر، يحتوي كل منها على عددين صحيحين موجبين مفصولين بمسافة.\nتمثل هذه الأعداد الأرقام الأولى والأخيرة في جزء متتالي يكون مجموعها M.\nيتم ترتيب الأسطر بترتيب تصاعدي بناءً على الرقم الأول لكل جزء.\nمثال:\nfind_sum_segments 21\nيعيد:\n6 8\n10 11",
      "sw": "Andika kazi ya Shell `find_sum_segments() {\nlocal M=$1\n` kutatua tatizo lifuatalo:\nKazi hii inatambua sehemu zote za mfululizo za nambari chanya ambazo jumla yake ni nambari iliyotolewa M.\nKila sehemu lazima iwe na angalau nambari mbili mfululizo.\nHoja:\n$1: Nambari chanya M, jumla lengwa (10 <= M <= 2,000,000).\nInarudisha:\nPato lina mistari kadhaa, kila moja ikiwa na nambari mbili chanya zilizotenganishwa na nafasi.\nNambari hizi zinawakilisha nambari ya kwanza na ya mwisho katika sehemu ya mfululizo inayojumlisha M.\nMistari imepangwa kwa mpangilio wa kupanda kulingana na nambari ya kuanzia ya kila sehemu.\nMfano:\nfind_sum_segments 21\nInarudisha:\n6 8\n10 11",
      "tr": "Bir Shell fonksiyonu yazın `find_sum_segments() {\nlocal M=$1\n` aşağıdaki problemi çözmek için:\nBu fonksiyon, belirli bir M tamsayısına toplamı eşit olan tüm pozitif tam sayıların ardışık segmentlerini tanımlar.\nHer segment en az iki ardışık sayı içermelidir.\nArgümanlar:\n$1: Hedef toplam olan pozitif bir tamsayı M (10 <= M <= 2,000,000).\nDöndürür:\nÇıktı, her biri bir boşlukla ayrılmış iki pozitif tamsayı içeren birkaç satırdan oluşur.\nBu tamsayılar, toplamı M olan ardışık bir segmentteki ilk ve son sayıları temsil eder.\nSatırlar, her segmentin başlangıç sayısına göre artan sırayla sıralanır.\nÖrnek:\nfind_sum_segments 21\nDöndürür:\n6 8\n10 11",
      "vi": "Viết một hàm Shell `find_sum_segments() {\nlocal M=$1\n` để giải quyết vấn đề sau:\nHàm này xác định tất cả các đoạn liên tục của các số nguyên dương có tổng bằng một số nguyên M cho trước.\nMỗi đoạn phải chứa ít nhất hai số liên tiếp.\nTham số:\n$1: Một số nguyên dương M, tổng mục tiêu (10 <= M <= 2,000,000).\nTrả về:\nĐầu ra bao gồm nhiều dòng, mỗi dòng chứa hai số nguyên dương được ngăn cách bởi một khoảng trắng.\nNhững số nguyên này đại diện cho số đầu tiên và số cuối cùng trong một đoạn liên tục có tổng bằng M.\nCác dòng được sắp xếp theo thứ tự tăng dần dựa trên số bắt đầu của mỗi đoạn.\nVí dụ:\nfind_sum_segments 21\nTrả về:\n6 8\n10 11"
    },
    "instruction_bertscore": {
      "es": "0.9922718877650756",
      "arb": "0.9485012997394656",
      "sw": "0.9436165814090556",
      "tr": "0.978331213102523",
      "vi": "0.9622622139071816"
    },
    "level": "easy",
    "test": "test_find_sum_segments() {\nlocal result=$(find_sum_segments 10000)\nlocal expected=\"18 142\n297 328\n388 412\n1998 2002\"\n[[ $result == \"$expected\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\nresult=$(find_sum_segments 100)\nexpected=\"9 16\n18 22\"\n[[ $result == \"$expected\" ]] || { echo \"Test 2 failed\"; exit 1; }\n}\n\ntest_find_sum_segments",
    "entry_point": "find_sum_segments",
    "signature": "find_sum_segments() {\nlocal M=$1\n",
    "docstring": {
      "en": "This function identifies all the continuous segments of positive integers that sum to a given integer M.\nEach segment must contain at least two consecutive numbers.\nArgs:\n$1: A positive integer M, the target sum (10 <= M <= 2,000,000).\nReturns:\nThe output consists of several lines, each containing two positive integers separated by a space.\nThese integers represent the first and last numbers in a continuous segment that sums to M.\nThe lines are sorted in ascending order based on the starting number of each segment.\nExample:\nfind_sum_segments 21\nReturns:\n6 8\n10 11",
      "es": "Esta función identifica todos los segmentos continuos de enteros positivos que suman un entero dado M. \nCada segmento debe contener al menos dos números consecutivos.\nArgumentos:\n$1: Un entero positivo M, la suma objetivo (10 <= M <= 2,000,000).\nDevuelve:\nLa salida consiste en varias líneas, cada una conteniendo dos enteros positivos separados por un espacio. \nEstos enteros representan el primer y último número en un segmento continuo que suma M. \nLas líneas están ordenadas en orden ascendente según el número de inicio de cada segmento.\nEjemplo:\nfind_sum_segments 21\nDevuelve:\n6 8\n10 11",
      "arb": "هذه الدالة تحدد جميع المقاطع المتصلة من الأعداد الصحيحة الموجبة التي مجموعها يساوي عددًا صحيحًا معينًا M.\nيجب أن يحتوي كل مقطع على رقمين متتاليين على الأقل.\nالمعاملات:\n$1: عدد صحيح موجب M، المجموع المستهدف (10 <= M <= 2,000,000).\nالقيم المعادة:\nيتكون الإخراج من عدة أسطر، يحتوي كل منها على عددين صحيحين موجبين مفصولين بمسافة.\nتمثل هذه الأعداد الأرقام الأولى والأخيرة في مقطع متصل مجموعها يساوي M.\nيتم ترتيب الأسطر بترتيب تصاعدي بناءً على الرقم الأول من كل مقطع.\nمثال:\nfind_sum_segments 21\nالقيم المعادة:\n6 8\n10 11",
      "sw": "Kazi ya kazi hii ni kutambua sehemu zote za mfululizo za namba za mzima chanya ambazo jumla yake ni sawa na namba M iliyotolewa.  \nKila sehemu lazima iwe na angalau namba mbili mfululizo.  \nHoja:  \n$1: Namba mzima chanya M, jumla inayolengwa (10 <= M <= 2,000,000).  \nInarejesha:  \nMatokeo yanajumuisha mistari kadhaa, kila moja ikiwa na namba mbili chanya zilizotenganishwa na nafasi.  \nNamba hizi zinawakilisha namba ya kwanza na ya mwisho katika sehemu ya mfululizo ambayo jumla yake ni M.  \nMistari imepangwa kwa mpangilio wa kupanda kulingana na namba ya kuanzia ya kila sehemu.   \nMfano:  \nfind_sum_segments 21   \nMatokeo:  \n6 8  \n10 11  ",
      "tr": "Bu fonksiyon, toplamı verilen bir M tamsayısına eşit olan tüm pozitif tamsayıların ardışık segmentlerini tanımlar. \nHer segment en az iki ardışık sayı içermelidir.\nArgümanlar:\n$1: Hedef toplam olan pozitif bir tamsayı M (10 <= M <= 2,000,000).\nDöndürür:\nÇıktı, her biri bir boşlukla ayrılmış iki pozitif tamsayı içeren birkaç satırdan oluşur. \nBu tamsayılar, toplamı M olan ardışık bir segmentteki ilk ve son sayıları temsil eder. \nSatırlar, her segmentin başlangıç sayısına göre artan sırayla sıralanır.\nÖrnekler:\nfind_sum_segments 21\nDöndürür:\n6 8\n10 11",
      "vi": "Hàm này xác định tất cả các đoạn liên tục của các số nguyên dương có tổng bằng một số nguyên M cho trước. Mỗi đoạn phải chứa ít nhất hai số liên tiếp.  \nTham số:  \n$1: Một số nguyên dương M, tổng mục tiêu (10 <= M <= 2,000,000).  \nTrả về:  \nĐầu ra bao gồm nhiều dòng, mỗi dòng chứa hai số nguyên dương được ngăn cách bởi một dấu cách.  \nNhững số nguyên này đại diện cho số đầu tiên và số cuối cùng trong một đoạn liên tục có tổng bằng M.  \nCác dòng được sắp xếp theo thứ tự tăng dần dựa trên số bắt đầu của mỗi đoạn.  \nVí dụ:  \nfind_sum_segments 21  \nTrả về:  \n6 8  \n10 11  "
    },
    "docstring_bertscore": {
      "es": "0.991596544469557",
      "arb": "0.9478867373405436",
      "sw": "1",
      "tr": "0.9598534232763715",
      "vi": "0.9886409243997578"
    }
  },
  {
    "task_id": "Shell/37",
    "prompt": {
      "en": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# This function calculates the number of ways to spend all available money on a selection of dishes in a restaurant. Each dish can only be purchased once. The function takes the number of dishes available, the total amount of money, and a string containing the price of each dish.\n\n# Example Cases:\n\n# count_meal_combinations 3 5 \"1 2 3\" should return 2 (1+2+2 or 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" should return 3 (1+2+3, 1+1+2+2, or 2+3+1).",
      "es": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Esta función calcula el número de formas de gastar todo el dinero disponible en una selección de platos en un restaurante. Cada plato solo se puede comprar una vez. La función toma el número de platos disponibles, la cantidad total de dinero y una cadena que contiene el precio de cada plato.\n\n# Casos de Ejemplo:\n\n# count_meal_combinations 3 5 \"1 2 3\" debería devolver 2 (1+2+2 o 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" debería devolver 3 (1+2+3, 1+1+2+2, o 2+3+1).",
      "arb": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# هذه الدالة تحسب عدد الطرق لإنفاق كل المال المتاح على اختيار من الأطباق في مطعم. يمكن شراء كل طبق مرة واحدة فقط. تأخذ الدالة عدد الأطباق المتاحة، المبلغ الإجمالي من المال، وسلسلة تحتوي على سعر كل طبق.\n\n# حالات المثال:\n\n# count_meal_combinations 3 5 \"1 2 3\" يجب أن تعيد 2 (1+2+2 أو 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" يجب أن تعيد 3 (1+2+3، 1+1+2+2، أو 2+3+1).",
      "sw": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Kazi ya hii function ni kuhesabu idadi ya njia za kutumia pesa zote zilizopo kwenye uchaguzi wa vyakula katika mgahawa. Kila chakula kinaweza kununuliwa mara moja tu. Function inachukua idadi ya vyakula vilivyopo, jumla ya kiasi cha pesa, na string inayojumuisha bei ya kila chakula.\n\n# Mifano ya Matukio:\n\n# count_meal_combinations 3 5 \"1 2 3\" inapaswa kurudisha 2 (1+2+2 au 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" inapaswa kurudisha 3 (1+2+3, 1+1+2+2, au 2+3+1).",
      "tr": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Bu fonksiyon, bir restoranda mevcut tüm parayı yemek seçimlerine harcamanın kaç farklı yolu olduğunu hesaplar. Her yemek yalnızca bir kez satın alınabilir. Fonksiyon, mevcut yemek sayısını, toplam para miktarını ve her yemeğin fiyatını içeren bir dizeyi alır.\n\n# Örnek Durumlar:\n\n# count_meal_combinations 3 5 \"1 2 3\" 2 döndürmelidir (1+2+2 veya 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" 3 döndürmelidir (1+2+3, 1+1+2+2 veya 2+3+1).",
      "vi": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Hàm này tính toán số cách để tiêu hết số tiền có sẵn vào việc chọn món ăn trong một nhà hàng. Mỗi món ăn chỉ có thể được mua một lần. Hàm nhận vào số lượng món ăn có sẵn, tổng số tiền, và một chuỗi chứa giá của mỗi món ăn.\n\n# Các trường hợp ví dụ:\n\n# count_meal_combinations 3 5 \"1 2 3\" sẽ trả về 2 (1+2+2 hoặc 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" sẽ trả về 3 (1+2+3, 1+1+2+2, hoặc 2+3+1)."
    },
    "prompt_bertscore": {
      "es": "0.9958663031402829",
      "arb": "0.9872576624262309",
      "sw": "0.9650611146063443",
      "tr": "0.9749942227011369",
      "vi": "0.9846484537409566"
    },
    "canonical_solution": "local dp=()\ndp[0]=1\n\nfor price in ${dish_prices[@]}; do\nfor (( i=m; i>=price; i-- )); do\n(( dp[i]+=${dp[i-price]:-0} ))\ndone\ndone\n\necho ${dp[m]:-0}\n}",
    "instruction": {
      "en": "Write a Shell function `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` to solve the following problem:\nThis function calculates the number of ways to spend all available money on a selection of dishes in a restaurant. Each dish can only be purchased once. The function takes the number of dishes available, the total amount of money, and a string containing the price of each dish.\n\nExample Cases:\n\ncount_meal_combinations 3 5 \"1 2 3\" should return 2 (1+2+2 or 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" should return 3 (1+2+3, 1+1+2+2, or 2+3+1).",
      "es": "Escribe una función Shell `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` para resolver el siguiente problema:\nEsta función calcula el número de maneras de gastar todo el dinero disponible en una selección de platos en un restaurante. Cada plato solo se puede comprar una vez. La función toma el número de platos disponibles, la cantidad total de dinero y una cadena que contiene el precio de cada plato.\n\nCasos de Ejemplo:\n\ncount_meal_combinations 3 5 \"1 2 3\" debería devolver 2 (1+2+2 o 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" debería devolver 3 (1+2+3, 1+1+2+2, o 2+3+1).",
      "arb": "اكتب دالة Shell `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` لحل المشكلة التالية:\nتحسب هذه الدالة عدد الطرق لإنفاق كل المال المتاح على مجموعة من الأطباق في مطعم. يمكن شراء كل طبق مرة واحدة فقط. تأخذ الدالة عدد الأطباق المتاحة، المبلغ الإجمالي من المال، وسلسلة تحتوي على سعر كل طبق.\n\nحالات المثال:\n\ncount_meal_combinations 3 5 \"1 2 3\" يجب أن تعيد 2 (1+2+2 أو 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" يجب أن تعيد 3 (1+2+3، 1+1+2+2، أو 2+3+1).",
      "sw": "Andika kazi ya Shell `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` kutatua tatizo lifuatalo:\nKazi hii inahesabu idadi ya njia za kutumia pesa zote zilizopo kwenye uchaguzi wa vyakula katika mgahawa. Kila chakula kinaweza kununuliwa mara moja tu. Kazi inachukua idadi ya vyakula vinavyopatikana, jumla ya kiasi cha pesa, na kamba inayojumuisha bei ya kila chakula.\n\nMifano ya Matukio:\n\ncount_meal_combinations 3 5 \"1 2 3\" inapaswa kurudisha 2 (1+2+2 au 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" inapaswa kurudisha 3 (1+2+3, 1+1+2+2, au 2+3+1).",
      "tr": "Bir Shell fonksiyonu yazın `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` aşağıdaki problemi çözmek için:\nBu fonksiyon, bir restoranda mevcut tüm parayı bir dizi yemek seçimi üzerinde harcamanın kaç yolu olduğunu hesaplar. Her yemek yalnızca bir kez satın alınabilir. Fonksiyon, mevcut yemeklerin sayısını, toplam para miktarını ve her yemeğin fiyatını içeren bir dizeyi alır.\n\nÖrnek Durumlar:\n\ncount_meal_combinations 3 5 \"1 2 3\" 2 döndürmelidir (1+2+2 veya 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" 3 döndürmelidir (1+2+3, 1+1+2+2 veya 2+3+1).",
      "vi": "Viết một hàm Shell `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` để giải quyết vấn đề sau:\nHàm này tính toán số cách để tiêu hết số tiền có sẵn vào việc chọn món ăn trong một nhà hàng. Mỗi món ăn chỉ có thể được mua một lần. Hàm nhận số lượng món ăn có sẵn, tổng số tiền, và một chuỗi chứa giá của mỗi món ăn.\n\nCác trường hợp ví dụ:\n\ncount_meal_combinations 3 5 \"1 2 3\" nên trả về 2 (1+2+2 hoặc 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" nên trả về 3 (1+2+3, 1+1+2+2, hoặc 2+3+1)."
    },
    "instruction_bertscore": {
      "es": "0.9952926585998542",
      "arb": "0.9935697386747576",
      "sw": "0.9644775385468637",
      "tr": "0.9531311752910078",
      "vi": "0.9913685167921289"
    },
    "level": "easy",
    "test": "test_meal_combinations() {\n[[ $(count_meal_combinations 3 5 \"1 2 3\") -eq 1 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_meal_combinations 4 6 \"1 2 3 1\") -eq 2 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_meal_combinations 5 10 \"2 2 2 2 2\") -eq 1 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_meal_combinations 3 3 \"1 1 1\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_meal_combinations 4 8 \"1 2 3 5\") -eq 2 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_meal_combinations",
    "entry_point": "count_meal_combinations",
    "signature": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n",
    "docstring": {
      "en": "This function calculates the number of ways to spend all available money on a selection of dishes in a restaurant. Each dish can only be purchased once. The function takes the number of dishes available, the total amount of money, and a string containing the price of each dish.\n\nExample Cases:\n\ncount_meal_combinations 3 5 \"1 2 3\" should return 2 (1+2+2 or 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" should return 3 (1+2+3, 1+1+2+2, or 2+3+1).",
      "es": "Esta función calcula el número de formas de gastar todo el dinero disponible en una selección de platos en un restaurante. Cada plato solo se puede comprar una vez. La función toma el número de platos disponibles, la cantidad total de dinero y una cadena que contiene el precio de cada plato.\n\nCasos de Ejemplo:\n\ncount_meal_combinations 3 5 \"1 2 3\" debería devolver 2 (1+2+2 o 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" debería devolver 3 (1+2+3, 1+1+2+2, o 2+3+1).",
      "arb": "هذه الدالة تحسب عدد الطرق لإنفاق كل المال المتاح على اختيار من الأطباق في مطعم. يمكن شراء كل طبق مرة واحدة فقط. تأخذ الدالة عدد الأطباق المتاحة، المبلغ الإجمالي من المال، وسلسلة تحتوي على سعر كل طبق.\n\nأمثلة الحالات:\n\ncount_meal_combinations 3 5 \"1 2 3\" يجب أن تعيد 2 (1+2+2 أو 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" يجب أن تعيد 3 (1+2+3، 1+1+2+2، أو 2+3+1).",
      "sw": "Kazi hii huhesabu idadi ya njia za kutumia pesa zote zilizopo kwenye uchaguzi wa vyakula katika mgahawa. Kila chakula kinaweza kununuliwa mara moja tu. Kazi hii inachukua idadi ya vyakula vilivyopo, jumla ya kiasi cha pesa, na kamba iliyo na bei ya kila chakula.\n\nMifano ya Kesi:\n\ncount_meal_combinations 3 5 \"1 2 3\" inapaswa kurudisha 2 (1+2+2 au 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" inapaswa kurudisha 3 (1+2+3, 1+1+2+2, au 2+3+1).",
      "tr": "Bu fonksiyon, bir restoranda mevcut tüm parayı bir yemek seçkisi üzerinde harcamanın kaç yolu olduğunu hesaplar. Her yemek yalnızca bir kez satın alınabilir. Fonksiyon, mevcut yemek sayısını, toplam para miktarını ve her yemeğin fiyatını içeren bir dize alır.\n\nÖrnek Durumlar:\n\ncount_meal_combinations 3 5 \"1 2 3\" 2 döndürmelidir (1+2+2 veya 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" 3 döndürmelidir (1+2+3, 1+1+2+2 veya 2+3+1).",
      "vi": "Hàm này tính toán số cách để tiêu hết số tiền có sẵn cho một lựa chọn các món ăn trong nhà hàng. Mỗi món ăn chỉ có thể được mua một lần. Hàm nhận vào số lượng món ăn có sẵn, tổng số tiền, và một chuỗi chứa giá của mỗi món ăn.\n\nCác trường hợp ví dụ:\n\ncount_meal_combinations 3 5 \"1 2 3\" nên trả về 2 (1+2+2 hoặc 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" nên trả về 3 (1+2+3, 1+1+2+2, hoặc 2+3+1)."
    },
    "docstring_bertscore": {
      "es": "0.9953194737012939",
      "arb": "0.9938595404006875",
      "sw": "0.9686118312977239",
      "tr": "0.9686712217816533",
      "vi": "0.5230036399625315"
    }
  },
  {
    "task_id": "Shell/38",
    "prompt": {
      "en": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# This function finds the previous lexicographical permutation of a given sequence.\n# If the current permutation is the first one in lexicographical order, it returns 'ERROR'.\n# The function takes the number of elements and the current permutation as arguments.\n# Example usage:\n# previous_permutation 3 \"1 2 3\"\n# This would return 'ERROR', as '1 2 3' is the first permutation.\n\n# previous_permutation 4 \"1 3 4 2\"\n# This would return '1 3 2 4', as it's the previous permutation in lexicographical order.\n",
      "es": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Esta función encuentra la permutación lexicográfica anterior de una secuencia dada.\n# Si la permutación actual es la primera en orden lexicográfico, devuelve 'ERROR'.\n# La función toma el número de elementos y la permutación actual como argumentos.\n# Ejemplo de uso:\n# previous_permutation 3 \"1 2 3\"\n# Esto devolvería 'ERROR', ya que '1 2 3' es la primera permutación.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Esto devolvería '1 3 2 4', ya que es la permutación anterior en orden lexicográfico.",
      "arb": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# تقوم هذه الدالة بإيجاد التبديل السابق في الترتيب المعجمي لتسلسل معين.\n# إذا كان التبديل الحالي هو الأول في الترتيب المعجمي، فإنها تعيد 'ERROR'.\n# تأخذ الدالة عدد العناصر والتبديل الحالي كوسائط.\n# مثال على الاستخدام:\n# previous_permutation 3 \"1 2 3\"\n# سيعيد هذا 'ERROR'، لأن '1 2 3' هو أول تبديل.\n\n# previous_permutation 4 \"1 3 4 2\"\n# سيعيد هذا '1 3 2 4'، لأنه التبديل السابق في الترتيب المعجمي.",
      "sw": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Kazi ya hii kazi ni kupata mpangilio wa awali wa leksikografia wa mpangilio uliotolewa.\n# Ikiwa mpangilio wa sasa ni wa kwanza katika mpangilio wa leksikografia, inarudisha 'ERROR'.\n# Kazi hii inachukua idadi ya vipengele na mpangilio wa sasa kama hoja.\n# Mfano wa matumizi:\n# previous_permutation 3 \"1 2 3\"\n# Hii ingerudisha 'ERROR', kwa kuwa '1 2 3' ni mpangilio wa kwanza.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Hii ingerudisha '1 3 2 4', kwa kuwa ni mpangilio wa awali katika mpangilio wa leksikografia.",
      "tr": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Bu fonksiyon, verilen bir dizinin bir önceki sözlük sıralamasındaki permütasyonunu bulur.\n# Eğer mevcut permütasyon sözlük sıralamasındaki ilk permütasyon ise, 'ERROR' döndürür.\n# Fonksiyon, eleman sayısını ve mevcut permütasyonu argüman olarak alır.\n# Örnek kullanım:\n# previous_permutation 3 \"1 2 3\"\n# Bu, '1 2 3' sözlük sıralamasındaki ilk permütasyon olduğundan 'ERROR' döndürecektir.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Bu, sözlük sıralamasında bir önceki permütasyon olan '1 3 2 4' döndürecektir.",
      "vi": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Hàm này tìm hoán vị từ điển trước của một dãy cho trước.\n# Nếu hoán vị hiện tại là hoán vị đầu tiên theo thứ tự từ điển, nó trả về 'ERROR'.\n# Hàm nhận số lượng phần tử và hoán vị hiện tại làm đối số.\n# Ví dụ sử dụng:\n# previous_permutation 3 \"1 2 3\"\n# Điều này sẽ trả về 'ERROR', vì '1 2 3' là hoán vị đầu tiên.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Điều này sẽ trả về '1 3 2 4', vì đó là hoán vị trước theo thứ tự từ điển."
    },
    "prompt_bertscore": {
      "es": "0.9878084644728407",
      "arb": "0.9760038609279372",
      "sw": "0.9636091265209792",
      "tr": "0.9637843185170519",
      "vi": "0.986159236419108"
    },
    "canonical_solution": "for (( i=n-2; i>=0; i-- )); do\nif [[ ${permutation[i]} -gt ${permutation[i+1]} ]]; then\nbreak\nfi\ndone\n\n# If no such index exists, the permutation is the first one\nif [[ i -eq -1 ]]; then\necho \"ERROR\"\nreturn\nfi\n\n# Find the largest index j greater than i such that permutation[j] < permutation[i]\nfor (( j=n-1; j>i; j-- )); do\nif [[ ${permutation[j]} -lt ${permutation[i]} ]]; then\nbreak\nfi\ndone\n\n# Swap values at i and j\nlocal temp=${permutation[i]}\npermutation[i]=${permutation[j]}\npermutation[j]=$temp\n\n# Reverse the sequence from i+1 to the end\nlocal left=$((i+1))\nlocal right=$((n-1))\nwhile [[ left -lt right ]]; do\ntemp=${permutation[left]}\npermutation[left]=${permutation[right]}\npermutation[right]=$temp\nleft=$((left+1))\nright=$((right-1))\ndone\n\necho \"${permutation[@]}\"\n}",
    "instruction": {
      "en": "Write a Shell function `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` to solve the following problem:\nThis function finds the previous lexicographical permutation of a given sequence.\nIf the current permutation is the first one in lexicographical order, it returns 'ERROR'.\nThe function takes the number of elements and the current permutation as arguments.\nExample usage:\nprevious_permutation 3 \"1 2 3\"\nThis would return 'ERROR', as '1 2 3' is the first permutation.\n\nprevious_permutation 4 \"1 3 4 2\"\nThis would return '1 3 2 4', as it's the previous permutation in lexicographical order.\n",
      "es": "Escribe una función de Shell `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` para resolver el siguiente problema:\nEsta función encuentra la permutación lexicográfica anterior de una secuencia dada.\nSi la permutación actual es la primera en orden lexicográfico, devuelve 'ERROR'.\nLa función toma el número de elementos y la permutación actual como argumentos.\nEjemplo de uso:\nprevious_permutation 3 \"1 2 3\"\nEsto devolvería 'ERROR', ya que '1 2 3' es la primera permutación.\n\nprevious_permutation 4 \"1 3 4 2\"\nEsto devolvería '1 3 2 4', ya que es la permutación anterior en orden lexicográfico.",
      "arb": "اكتب دالة Shell `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` لحل المشكلة التالية:\nتجد هذه الدالة الترتيب السابق في الترتيب المعجمي لتسلسل معين.\nإذا كان الترتيب الحالي هو الأول في الترتيب المعجمي، فإنها تعيد 'ERROR'.\nتأخذ الدالة عدد العناصر والترتيب الحالي كوسائط.\nمثال على الاستخدام:\nprevious_permutation 3 \"1 2 3\"\nسيعيد هذا 'ERROR'، حيث أن '1 2 3' هو الترتيب الأول.\n\nprevious_permutation 4 \"1 3 4 2\"\nسيعيد هذا '1 3 2 4'، حيث أنه الترتيب السابق في الترتيب المعجمي.",
      "sw": "Andika kazi ya Shell `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` kutatua tatizo lifuatalo:\nKazi hii inapata mpangilio wa awali wa lexicographical wa mlolongo uliotolewa.\nIkiwa mpangilio wa sasa ni wa kwanza katika mpangilio wa lexicographical, inarudisha 'ERROR'.\nKazi inachukua idadi ya vipengele na mpangilio wa sasa kama hoja.\nMfano wa matumizi:\nprevious_permutation 3 \"1 2 3\"\nHii ingerudisha 'ERROR', kwa kuwa '1 2 3' ni mpangilio wa kwanza.\n\nprevious_permutation 4 \"1 3 4 2\"\nHii ingerudisha '1 3 2 4', kwa kuwa ni mpangilio wa awali katika mpangilio wa lexicographical.",
      "tr": "Bir Shell fonksiyonu yazın `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` aşağıdaki problemi çözmek için:\nBu fonksiyon, verilen bir dizinin önceki sözlükbilimsel permütasyonunu bulur.\nEğer mevcut permütasyon sözlükbilimsel sırada ilk permütasyonsa, 'ERROR' döndürür.\nFonksiyon, eleman sayısını ve mevcut permütasyonu argüman olarak alır.\nÖrnek kullanım:\nprevious_permutation 3 \"1 2 3\"\nBu, '1 2 3' ilk permütasyon olduğu için 'ERROR' döndürecektir.\n\nprevious_permutation 4 \"1 3 4 2\"\nBu, sözlükbilimsel sırada önceki permütasyon olduğu için '1 3 2 4' döndürecektir.",
      "vi": "Viết một hàm Shell `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` để giải quyết vấn đề sau:\nHàm này tìm hoán vị từ điển trước của một chuỗi cho trước.\nNếu hoán vị hiện tại là hoán vị đầu tiên theo thứ tự từ điển, nó trả về 'ERROR'.\nHàm nhận số lượng phần tử và hoán vị hiện tại làm tham số.\nVí dụ sử dụng:\nprevious_permutation 3 \"1 2 3\"\nĐiều này sẽ trả về 'ERROR', vì '1 2 3' là hoán vị đầu tiên.\n\nprevious_permutation 4 \"1 3 4 2\"\nĐiều này sẽ trả về '1 3 2 4', vì đó là hoán vị trước theo thứ tự từ điển."
    },
    "instruction_bertscore": {
      "es": "0.9890775139772725",
      "arb": "0.9800521467238092",
      "sw": "0.9921572780352185",
      "tr": "0.982561245697042",
      "vi": "0.9859747087951265"
    },
    "level": "hard",
    "test": "test_previous_permutation() {\n[[ $(previous_permutation 3 \"1 3 2\") == \"1 2 3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(previous_permutation 3 \"1 2 3\") == \"ERROR\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(previous_permutation 4 \"2 1 4 3\") == \"2 1 3 4\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(previous_permutation 5 \"5 4 3 2 1\") == \"5 4 3 1 2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(previous_permutation 4 \"1 4 3 2\") == \"1 4 2 3\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_previous_permutation",
    "entry_point": "previous_permutation",
    "signature": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n",
    "docstring": {
      "en": "This function finds the previous lexicographical permutation of a given sequence.\nIf the current permutation is the first one in lexicographical order, it returns 'ERROR'.\nThe function takes the number of elements and the current permutation as arguments.\nExample usage:\nprevious_permutation 3 \"1 2 3\"\nThis would return 'ERROR', as '1 2 3' is the first permutation.\n\nprevious_permutation 4 \"1 3 4 2\"\nThis would return '1 3 2 4', as it's the previous permutation in lexicographical order.\n",
      "es": "Esta función encuentra la permutación lexicográfica anterior de una secuencia dada.\nSi la permutación actual es la primera en orden lexicográfico, devuelve 'ERROR'.\nLa función toma el número de elementos y la permutación actual como argumentos.\nEjemplo de uso:\nprevious_permutation 3 \"1 2 3\"\nEsto devolvería 'ERROR', ya que '1 2 3' es la primera permutación.\n\nprevious_permutation 4 \"1 3 4 2\"\nEsto devolvería '1 3 2 4', ya que es la permutación anterior en orden lexicográfico.",
      "arb": "هذه الدالة تجد الترتيب السابق في الترتيب المعجمي لتسلسل معين.  \nإذا كان الترتيب الحالي هو الأول في الترتيب المعجمي، فإنها تعيد 'ERROR'.  \nتأخذ الدالة عدد العناصر والترتيب الحالي كوسائط.  \n\nاستخدام المثال:  \nprevious_permutation 3 \"1 2 3\"  \nهذا سيعيد 'ERROR'، لأن '1 2 3' هو الترتيب الأول.  \n\nprevious_permutation 4 \"1 3 4 2\"  \nهذا سيعيد '1 3 2 4'، لأنه الترتيب السابق في الترتيب المعجمي.",
      "sw": "Kazi ya kazi hii ni kupata mpangilio wa awali wa leksikografia wa mlolongo uliotolewa. Ikiwa mpangilio wa sasa ni wa kwanza katika mpangilio wa leksikografia, inarudisha 'ERROR'. Kazi hii inachukua idadi ya vipengele na mpangilio wa sasa kama hoja.\n\nMfano wa matumizi:\nprevious_permutation 3 \"1 2 3\"\nHii ingerudisha 'ERROR', kwani '1 2 3' ni mpangilio wa kwanza.\n\nprevious_permutation 4 \"1 3 4 2\"\nHii ingerudisha '1 3 2 4', kwani ni mpangilio wa awali katika mpangilio wa leksikografia.",
      "tr": "Bu fonksiyon, verilen bir dizinin önceki sözlük sıralamasına göre permütasyonunu bulur.\nEğer mevcut permütasyon sözlük sıralamasında ilk sıradaysa, 'ERROR' döner.\nFonksiyon, eleman sayısını ve mevcut permütasyonu argüman olarak alır.\nÖrnek kullanım:\nprevious_permutation 3 \"1 2 3\"\nBu, '1 2 3' ilk permütasyon olduğundan 'ERROR' döndürecektir.\n\nprevious_permutation 4 \"1 3 4 2\"\nBu, sözlük sıralamasında önceki permütasyon olduğu için '1 3 2 4' döndürecektir.",
      "vi": "Hàm này tìm hoán vị từ điển trước của một dãy cho trước.  \nNếu hoán vị hiện tại là hoán vị đầu tiên theo thứ tự từ điển, nó sẽ trả về 'ERROR'.  \nHàm nhận số lượng phần tử và hoán vị hiện tại làm tham số.  \n\nVí dụ sử dụng:  \nprevious_permutation 3 \"1 2 3\"  \nĐiều này sẽ trả về 'ERROR', vì '1 2 3' là hoán vị đầu tiên.  \n\nprevious_permutation 4 \"1 3 4 2\"  \nĐiều này sẽ trả về '1 3 2 4', vì đó là hoán vị trước đó theo thứ tự từ điển.  "
    },
    "docstring_bertscore": {
      "es": "0.9862075036016994",
      "arb": "0.976902266141358",
      "sw": "0.9656629646608799",
      "tr": "0.9593349979818705",
      "vi": "0.9784198022524646"
    }
  },
  {
    "task_id": "Shell/39",
    "prompt": {
      "en": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# This function checks the number of matches each lottery ticket has with the winning numbers\n# and categorizes each ticket based on the prize won. It returns the count of tickets for each prize category.\n# The function takes the winning numbers and the lottery tickets as arguments.\n# Example usage:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# This would return '0 1 0 0 0 0 0', as the second ticket wins a first prize.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# This would return '0 0 0 0 0 0 0', as no tickets match any winning numbers.",
      "es": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Esta función verifica el número de coincidencias que tiene cada boleto de lotería con los números ganadores\n# y categoriza cada boleto según el premio ganado. Devuelve el conteo de boletos para cada categoría de premio.\n# La función toma los números ganadores y los boletos de lotería como argumentos.\n# Ejemplo de uso:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Esto devolvería '0 1 0 0 0 0 0', ya que el segundo boleto gana un primer premio.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Esto devolvería '0 0 0 0 0 0 0', ya que ningún boleto coincide con los números ganadores.",
      "arb": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# تقوم هذه الدالة بالتحقق من عدد المطابقات التي يمتلكها كل تذكرة يانصيب مع الأرقام الفائزة\n# وتصنف كل تذكرة بناءً على الجائزة التي فازت بها. تعيد الدالة عدد التذاكر لكل فئة جائزة.\n# تأخذ الدالة الأرقام الفائزة وتذاكر اليانصيب كمعطيات.\n# مثال على الاستخدام:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# سيعيد هذا '0 1 0 0 0 0 0'، حيث أن التذكرة الثانية تفوز بالجائزة الأولى.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# سيعيد هذا '0 0 0 0 0 0 0'، حيث لا توجد أي تذاكر تطابق الأرقام الفائزة.",
      "sw": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Kazi ya hii kazi ni kuangalia idadi ya mechi kila tiketi ya bahati nasibu inayo na namba za ushindi\n# na kuainisha kila tiketi kulingana na zawadi iliyoshinda. Inarudisha idadi ya tiketi kwa kila aina ya zawadi.\n# Kazi hii inachukua namba za ushindi na tiketi za bahati nasibu kama hoja.\n# Mfano wa matumizi:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Hii ingerudisha '0 1 0 0 0 0 0', kwani tiketi ya pili inashinda zawadi ya kwanza.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Hii ingerudisha '0 0 0 0 0 0 0', kwani hakuna tiketi inayolingana na namba zozote za ushindi.",
      "tr": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Bu fonksiyon, her piyango biletinin kazanan numaralarla kaç eşleşmesi olduğunu kontrol eder\n# ve her bileti kazanılan ödüle göre kategorize eder. Her ödül kategorisi için bilet sayısını döndürür.\n# Fonksiyon, kazanan numaraları ve piyango biletlerini argüman olarak alır.\n# Örnek kullanım:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Bu, '0 1 0 0 0 0 0' döndürecektir, çünkü ikinci bilet birinci ödülü kazanır.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Bu, '0 0 0 0 0 0 0' döndürecektir, çünkü hiçbir bilet kazanan numaralarla eşleşmez.",
      "vi": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Hàm này kiểm tra số lượng khớp của mỗi vé số với các số trúng thưởng\n# và phân loại mỗi vé dựa trên giải thưởng đã trúng. Nó trả về số lượng vé cho mỗi hạng mục giải thưởng.\n# Hàm nhận các số trúng thưởng và các vé số làm tham số.\n# Ví dụ sử dụng:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Điều này sẽ trả về '0 1 0 0 0 0 0', vì vé thứ hai trúng giải nhất.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Điều này sẽ trả về '0 0 0 0 0 0 0', vì không có vé nào khớp với bất kỳ số trúng thưởng nào."
    },
    "prompt_bertscore": {
      "es": "0.9918096748684074",
      "arb": "0.9674345490293301",
      "sw": "0.9632132561715766",
      "tr": "0.9778548974488014",
      "vi": "0.9844547891194476"
    },
    "canonical_solution": "shift\nlocal tickets=(\"$@\")\nlocal prizes=(0 0 0 0 0 0 0)\n\nfor ticket in \"${tickets[@]}\"; do\nlocal matches=0\nfor number in $ticket; do\nfor win_num in \"${winning_numbers[@]}\"; do\nif [[ $number -eq $win_num ]]; then\n((matches++))\nbreak\nfi\ndone\ndone\nif (( matches > 0 )); then\n((prizes[7-matches]++))\nfi\ndone\n\necho \"${prizes[@]}\"\n}",
    "instruction": {
      "en": "Write a Shell function `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` to solve the following problem:\nThis function checks the number of matches each lottery ticket has with the winning numbers\nand categorizes each ticket based on the prize won. It returns the count of tickets for each prize category.\nThe function takes the winning numbers and the lottery tickets as arguments.\nExample usage:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nThis would return '0 1 0 0 0 0 0', as the second ticket wins a first prize.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nThis would return '0 0 0 0 0 0 0', as no tickets match any winning numbers.",
      "es": "Escribe una función de Shell `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` para resolver el siguiente problema:\nEsta función verifica el número de coincidencias que tiene cada boleto de lotería con los números ganadores\ny categoriza cada boleto según el premio ganado. Devuelve el conteo de boletos para cada categoría de premio.\nLa función toma los números ganadores y los boletos de lotería como argumentos.\nEjemplo de uso:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nEsto devolvería '0 1 0 0 0 0 0', ya que el segundo boleto gana un primer premio.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nEsto devolvería '0 0 0 0 0 0 0', ya que ningún boleto coincide con ningún número ganador.",
      "arb": "اكتب دالة Shell `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` لحل المشكلة التالية:\nتتحقق هذه الدالة من عدد التطابقات التي يمتلكها كل تذكرة يانصيب مع الأرقام الفائزة\nوتصنف كل تذكرة بناءً على الجائزة التي فازت بها. تُرجع عدد التذاكر لكل فئة جائزة.\nتأخذ الدالة الأرقام الفائزة وتذاكر اليانصيب كمعطيات.\nمثال على الاستخدام:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nهذا سيعيد '0 1 0 0 0 0 0'، حيث أن التذكرة الثانية تفوز بالجائزة الأولى.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nهذا سيعيد '0 0 0 0 0 0 0'، حيث لا تتطابق أي تذاكر مع أي أرقام فائزة.",
      "sw": "Andika kazi ya Shell `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` kutatua tatizo lifuatalo:\nKazi hii inakagua idadi ya mechi kila tiketi ya bahati nasibu inavyolingana na namba za ushindi\nna kuainisha kila tiketi kulingana na zawadi iliyoshindwa. Inarudisha idadi ya tiketi kwa kila kategoria ya zawadi.\nKazi inachukua namba za ushindi na tiketi za bahati nasibu kama hoja.\nMfano wa matumizi:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nHii ingerudisha '0 1 0 0 0 0 0', kwani tiketi ya pili inashinda zawadi ya kwanza.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nHii ingerudisha '0 0 0 0 0 0 0', kwani hakuna tiketi inayolingana na namba zozote za ushindi.",
      "tr": "Bir Shell fonksiyonu yazın `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` aşağıdaki problemi çözmek için:\nBu fonksiyon, her piyango biletinin kazanan numaralarla eşleşme sayısını kontrol eder ve her bileti kazanılan ödüle göre kategorize eder. Her ödül kategorisi için bilet sayısını döndürür.\nFonksiyon, kazanan numaraları ve piyango biletlerini argüman olarak alır.\nÖrnek kullanım:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nBu, '0 1 0 0 0 0 0' döndürecektir, çünkü ikinci bilet birinci ödülü kazanır.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nBu, '0 0 0 0 0 0 0' döndürecektir, çünkü hiçbir bilet kazanan numaralarla eşleşmez.",
      "vi": "Viết một hàm Shell `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` để giải quyết vấn đề sau:\nHàm này kiểm tra số lượng trùng khớp mà mỗi vé số có với các số trúng thưởng và phân loại mỗi vé dựa trên giải thưởng đã trúng. Nó trả về số lượng vé cho mỗi hạng mục giải thưởng.\nHàm nhận các số trúng thưởng và các vé số làm đối số.\nVí dụ sử dụng:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nĐiều này sẽ trả về '0 1 0 0 0 0 0', vì vé thứ hai trúng giải nhất.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nĐiều này sẽ trả về '0 0 0 0 0 0 0', vì không có vé nào trùng với bất kỳ số trúng thưởng nào."
    },
    "instruction_bertscore": {
      "es": "0.9932692109082518",
      "arb": "0.9819681353792719",
      "sw": "0.9855319616757998",
      "tr": "0.9850814679716127",
      "vi": "0.9899699602792623"
    },
    "level": "easy",
    "test": "test_check_lottery_winnings() {\nlocal result\nresult=$(check_lottery_winnings \"23 31 1 14 19 17 18\" \"12 8 9 23 1 16 7\" \"11 7 10 21 2 9 31\")\n[[ $result == \"0 0 0 0 0 1 1\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\nresult=$(check_lottery_winnings \"5 6 7 8 9 10 11\" \"1 2 3 4 5 6 7\" \"5 6 7 12 13 14 15\")\n[[ $result == \"0 0 0 0 2 0 0\" ]] || { echo \"Test 2 failed\"; exit 1; }\n\nresult=$(check_lottery_winnings \"15 16 17 18 19 20 21\" \"22 23 24 25 26 27 28\" \"29 30 31 32 33 1 2\")\n[[ $result == \"0 0 0 0 0 0 0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n}\n\ntest_check_lottery_winnings",
    "entry_point": "check_lottery_winnings",
    "signature": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n",
    "docstring": {
      "en": "This function checks the number of matches each lottery ticket has with the winning numbers\nand categorizes each ticket based on the prize won. It returns the count of tickets for each prize category.\nThe function takes the winning numbers and the lottery tickets as arguments.\nExample usage:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nThis would return '0 1 0 0 0 0 0', as the second ticket wins a first prize.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nThis would return '0 0 0 0 0 0 0', as no tickets match any winning numbers.",
      "es": "Esta función verifica el número de coincidencias que cada boleto de lotería tiene con los números ganadores y categoriza cada boleto según el premio ganado. Devuelve el conteo de boletos para cada categoría de premio. La función toma los números ganadores y los boletos de lotería como argumentos.\nEjemplo de uso:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nEsto devolvería '0 1 0 0 0 0 0', ya que el segundo boleto gana un primer premio.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nEsto devolvería '0 0 0 0 0 0 0', ya que ningún boleto coincide con los números ganadores.",
      "arb": "هذه الدالة تتحقق من عدد المطابقات لكل تذكرة يانصيب مع الأرقام الفائزة وتقوم بتصنيف كل تذكرة بناءً على الجائزة التي فازت بها. تُرجع عدد التذاكر لكل فئة جائزة. تأخذ الدالة الأرقام الفائزة وتذاكر اليانصيب كوسائط.\n\nمثال على الاستخدام:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nهذا سيعيد '0 1 0 0 0 0 0'، حيث أن التذكرة الثانية تفوز بالجائزة الأولى.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nهذا سيعيد '0 0 0 0 0 0 0'، حيث أنه لا توجد تذاكر تطابق أي من الأرقام الفائزة.",
      "sw": "Kazi hii inakagua idadi ya mechi kila tiketi ya bahati nasibu inavyolingana na nambari za ushindi na kuainisha kila tiketi kulingana na zawadi iliyoshindwa. Inarudisha idadi ya tiketi kwa kila aina ya zawadi. Kazi inachukua nambari za ushindi na tiketi za bahati nasibu kama hoja.\n\nMfano wa matumizi:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nHii ingerudisha '0 1 0 0 0 0 0', kwani tiketi ya pili inashinda zawadi ya kwanza.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nHii ingerudisha '0 0 0 0 0 0 0', kwani hakuna tiketi inayolingana na nambari zozote za ushindi.",
      "tr": "Bu fonksiyon, her piyango biletinin kazanan numaralarla eşleşme sayısını kontrol eder ve her bileti kazanılan ödül kategorisine göre sınıflandırır. Her ödül kategorisi için bilet sayısını döndürür. Fonksiyon, kazanan numaraları ve piyango biletlerini argüman olarak alır.\nÖrnek kullanım:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nBu, '0 1 0 0 0 0 0' döndürecektir, çünkü ikinci bilet birinci ödülü kazanır.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nBu, '0 0 0 0 0 0 0' döndürecektir, çünkü hiçbir bilet kazanan numaralarla eşleşmez.",
      "vi": "Hàm này kiểm tra số lượng kết quả trùng khớp của mỗi vé số với các số trúng thưởng và phân loại từng vé dựa trên giải thưởng đã thắng. Nó trả về số lượng vé cho mỗi hạng mục giải thưởng. Hàm nhận các số trúng thưởng và các vé số làm tham số đầu vào.\nVí dụ sử dụng:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nĐiều này sẽ trả về '0 1 0 0 0 0 0', vì vé thứ hai thắng giải nhất.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nĐiều này sẽ trả về '0 0 0 0 0 0 0', vì không có vé nào trùng khớp với bất kỳ số trúng thưởng nào."
    },
    "docstring_bertscore": {
      "es": "0.9890213015794397",
      "arb": "0.9724563223226541",
      "sw": "0.9650559502164373",
      "tr": "0.9801800646891957",
      "vi": "0.9695642639747861"
    }
  },
  {
    "task_id": "Shell/40",
    "prompt": {
      "en": "calculate_max_pens() {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.",
      "es": "calculate_max_pens() {\n    # Esta función calcula el número máximo de bolígrafos que se pueden comprar con una cantidad dada de dinero.\n    # El precio de un bolígrafo es de 1 Yuan y 9 Jiao (1.9 Yuan).\n    # La función toma dos enteros, a y b, como entrada donde 'a' representa la parte en Yuan y 'b' representa la parte en Jiao del total de dinero disponible.\n    # Devuelve el número máximo de bolígrafos que se pueden comprar.\n    # Por ejemplo, si a=5 y b=0, la función devolverá 2, ya que el dinero total es 5 Yuan, y dos bolígrafos cuestan 3.8 Yuan.",
      "arb": "calculate_max_pens() {\n    # هذه الدالة تحسب العدد الأقصى من الأقلام التي يمكن شراؤها بمبلغ معين من المال.\n    # سعر قلم واحد هو 1 يوان و9 جياو (1.9 يوان).\n    # تأخذ الدالة عددين صحيحين، a و b، كمدخل حيث يمثل 'a' جزء اليوان و 'b' يمثل جزء الجياو من إجمالي المال المتاح.\n    # تعيد الدالة العدد الأقصى من الأقلام التي يمكن شراؤها.\n    # على سبيل المثال، إذا كان a=5 و b=0، ستعيد الدالة 2، حيث أن إجمالي المال هو 5 يوان، وقلمان يكلفان 3.8 يوان.",
      "sw": "calculate_max_pens() {\n    # Kazi ya hii kazi ni kuhesabu idadi kubwa zaidi ya kalamu zinazoweza kununuliwa kwa kiasi fulani cha pesa.\n    # Bei ya kalamu moja ni Yuan 1 na Jiao 9 (Yuan 1.9).\n    # Kazi hii inachukua namba mbili za mzima, a na b, kama pembejeo ambapo 'a' inawakilisha Yuan na 'b' inawakilisha sehemu ya Jiao ya jumla ya pesa inayopatikana.\n    # Inarudisha idadi kubwa zaidi ya kalamu zinazoweza kununuliwa.\n    # Kwa mfano, ikiwa a=5 na b=0, kazi itarudisha 2, kwani jumla ya pesa ni Yuan 5, na kalamu mbili zinagharimu Yuan 3.8.",
      "tr": "calculate_max_pens() {\n    # Bu fonksiyon, belirli bir miktar parayla satın alınabilecek maksimum kalem sayısını hesaplar.\n    # Bir kalemin fiyatı 1 Yuan ve 9 Jiao'dur (1.9 Yuan).\n    # Fonksiyon, 'a' Yuan'ı ve 'b' Jiao'yu temsil eden iki tam sayı alır ve bu, mevcut toplam parayı ifade eder.\n    # Satın alınabilecek maksimum kalem sayısını döndürür.\n    # Örneğin, eğer a=5 ve b=0 ise, fonksiyon 2 döndürecektir, çünkü toplam para 5 Yuan'dır ve iki kalem 3.8 Yuan tutarındadır.",
      "vi": "calculate_max_pens() {\n    # Hàm này tính toán số lượng bút tối đa có thể mua được với một số tiền nhất định.\n    # Giá của một cây bút là 1 Nhân dân tệ và 9 Jiao (1.9 Nhân dân tệ).\n    # Hàm nhận hai số nguyên, a và b, làm đầu vào, trong đó 'a' đại diện cho phần Nhân dân tệ và 'b' đại diện cho phần Jiao của tổng số tiền có sẵn.\n    # Nó trả về số lượng bút tối đa có thể mua được.\n    # Ví dụ, nếu a=5 và b=0, hàm sẽ trả về 2, vì tổng số tiền là 5 Nhân dân tệ, và hai cây bút có giá 3.8 Nhân dân tệ."
    },
    "prompt_bertscore": {
      "es": "0.9887011094052114",
      "arb": "0.975865415552356",
      "sw": "0.9623621249888421",
      "tr": "0.9451118709174863",
      "vi": "0.9803268525407806"
    },
    "canonical_solution": "    local yuan=$1\n    local jiao=$2\n    # Convert everything to jiao for simplicity\n    local total_jiao=$((yuan * 10 + jiao))\n    local price_per_pen=19  # 1 yuan 9 jiao equals 19 jiao\n    # Calculate max pens\n    local max_pens=$((total_jiao / price_per_pen))\n    echo \"$max_pens\"\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_max_pens() {` to solve the following problem: This function calculates the maximum number of pens that can be bought with a given amount of money.\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n It returns the maximum number of pens that can be purchased.\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.",
      "es": "Escribe una función de Shell `calculate_max_pens() {` para resolver el siguiente problema: Esta función calcula el número máximo de bolígrafos que se pueden comprar con una cantidad dada de dinero.\n El precio de un bolígrafo es de 1 Yuan y 9 Jiao (1.9 Yuan).\n La función toma dos enteros, a y b, como entrada donde 'a' representa la parte en Yuan y 'b' representa la parte en Jiao del total de dinero disponible.\n Devuelve el número máximo de bolígrafos que se pueden comprar.\n Por ejemplo, si a=5 y b=0, la función devolverá 2, ya que el dinero total es de 5 Yuan, y dos bolígrafos cuestan 3.8 Yuan.",
      "arb": "اكتب دالة Shell `calculate_max_pens() {` لحل المشكلة التالية: تقوم هذه الدالة بحساب الحد الأقصى لعدد الأقلام التي يمكن شراؤها بمبلغ معين من المال.\n سعر القلم الواحد هو 1 يوان و9 جياو (1.9 يوان).\n تأخذ الدالة عددين صحيحين، a و b، كمدخل حيث يمثل 'a' جزء اليوان و 'b' يمثل جزء الجياو من إجمالي المال المتاح.\n تعيد الدالة الحد الأقصى لعدد الأقلام التي يمكن شراؤها.\n على سبيل المثال، إذا كان a=5 و b=0، ستعيد الدالة 2، حيث أن إجمالي المال هو 5 يوان، وسعر قلمين هو 3.8 يوان.",
      "sw": "Andika kazi ya Shell `calculate_max_pens() {` kutatua tatizo lifuatalo: Kazi hii inahesabu idadi kubwa zaidi ya kalamu zinazoweza kununuliwa kwa kiasi fulani cha pesa.\n Bei ya kalamu moja ni Yuan 1 na Jiao 9 (Yuan 1.9).\n Kazi inachukua namba mbili za mzima, a na b, kama pembejeo ambapo 'a' inawakilisha Yuan na 'b' inawakilisha sehemu ya Jiao ya jumla ya pesa inayopatikana.\n Inarudisha idadi kubwa zaidi ya kalamu zinazoweza kununuliwa.\n Kwa mfano, ikiwa a=5 na b=0, kazi itarudisha 2, kwani jumla ya pesa ni Yuan 5, na kalamu mbili zinagharimu Yuan 3.8.",
      "tr": "Bir Shell fonksiyonu `calculate_max_pens() {` yazın: Bu fonksiyon, belirli bir miktar parayla satın alınabilecek maksimum kalem sayısını hesaplar.\n Bir kalemin fiyatı 1 Yuan ve 9 Jiao'dur (1.9 Yuan).\n Fonksiyon, 'a' Yuan'ı ve 'b' Jiao'yu temsil eden iki tam sayı alır ve toplam mevcut parayı belirtir.\n Satın alınabilecek maksimum kalem sayısını döndürür.\n Örneğin, eğer a=5 ve b=0 ise, fonksiyon 2 döndürecektir, çünkü toplam para 5 Yuan'dır ve iki kalem 3.8 Yuan tutarındadır.",
      "vi": "Viết một hàm Shell `calculate_max_pens() {` để giải quyết vấn đề sau: Hàm này tính toán số lượng bút tối đa có thể mua được với một số tiền nhất định. \nGiá của một chiếc bút là 1 Yuan và 9 Jiao (1.9 Yuan). \nHàm nhận hai số nguyên, a và b, làm đầu vào, trong đó 'a' đại diện cho phần Yuan và 'b' đại diện cho phần Jiao của tổng số tiền có sẵn. \nNó trả về số lượng bút tối đa có thể mua được. \nVí dụ, nếu a=5 và b=0, hàm sẽ trả về 2, vì tổng số tiền là 5 Yuan, và hai chiếc bút có giá 3.8 Yuan."
    },
    "instruction_bertscore": {
      "es": "0.9880619168390411",
      "arb": "0.9744533521735789",
      "sw": "0.9736177141605651",
      "tr": "0.925530887955067",
      "vi": "0.9784156310144628"
    },
    "level": "easy",
    "test": "test_calculate_max_pens() {\n    local result\n\n    result=$(calculate_max_pens 5 5)\n    [[ \"$result\" -eq 2 ]] || { echo \"Test 1 failed: Expected 2, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 20 1)\n    [[ \"$result\" -eq 10 ]] || { echo \"Test 2 failed: Expected 10, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 3 8)\n    [[ \"$result\" -eq 2 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 11 0)\n    [[ \"$result\" -eq 5 ]] || { echo \"Test 4 failed: Expected 5, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 100 5)\n    [[ \"$result\" -eq 52 ]] || { echo \"Test 5 failed: Expected 52, got $result\"; exit 1; }\n}\n\ntest_calculate_max_pens",
    "entry_point": "calculate_max_pens",
    "signature": "calculate_max_pens() {",
    "docstring": {
      "en": " This function calculates the maximum number of pens that can be bought with a given amount of money.\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n It returns the maximum number of pens that can be purchased.\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.",
      "es": "Esta función calcula el número máximo de bolígrafos que se pueden comprar con una cantidad dada de dinero.  \nEl precio de un bolígrafo es 1 Yuan y 9 Jiao (1.9 Yuan).  \nLa función toma dos enteros, a y b, como entrada donde 'a' representa la parte en Yuan y 'b' representa la parte en Jiao del total de dinero disponible.  \nDevuelve el número máximo de bolígrafos que se pueden comprar.  \nPor ejemplo, si a=5 y b=0, la función devolverá 2, ya que el dinero total es 5 Yuan, y dos bolígrafos cuestan 3.8 Yuan.",
      "arb": "هذه الدالة تحسب الحد الأقصى لعدد الأقلام التي يمكن شراؤها بمبلغ معين من المال.\nسعر القلم الواحد هو 1 يوان و9 جياو (1.9 يوان).\nتأخذ الدالة عددين صحيحين، a و b، كمدخل حيث يمثل 'a' جزء اليوان ويمثل 'b' جزء الجياو من إجمالي المال المتاح.\nتعيد الدالة الحد الأقصى لعدد الأقلام التي يمكن شراؤها.\nعلى سبيل المثال، إذا كان a=5 و b=0، فإن الدالة ستعيد 2، حيث أن إجمالي المال هو 5 يوان، وتكلفة قلمين هي 3.8 يوان.",
      "sw": "Kazi ya hii kazi ni kuhesabu idadi kubwa zaidi ya kalamu ambazo zinaweza kununuliwa kwa kiasi fulani cha pesa.\nBei ya kalamu moja ni Yuan 1 na Jiao 9 (Yuan 1.9).\nKazi hii inachukua namba mbili kamili, a na b, kama pembejeo ambapo 'a' inawakilisha Yuan na 'b' inawakilisha sehemu ya Jiao ya jumla ya pesa inayopatikana.\nInarudisha idadi kubwa zaidi ya kalamu ambazo zinaweza kununuliwa.\nKwa mfano, ikiwa a=5 na b=0, kazi itarudisha 2, kwani jumla ya pesa ni Yuan 5, na kalamu mbili zinagharimu Yuan 3.8.",
      "tr": "Bu fonksiyon, belirli bir miktar parayla satın alınabilecek maksimum kalem sayısını hesaplar.\nBir kalemin fiyatı 1 Yuan ve 9 Jiao'dur (1.9 Yuan).\nFonksiyon, 'a' Yuan'ı ve 'b' Jiao'yu temsil eden iki tam sayı alır ve toplam mevcut parayı belirtir.\nSatın alınabilecek maksimum kalem sayısını döndürür.\nÖrneğin, eğer a=5 ve b=0 ise, fonksiyon 2 döndürecektir, çünkü toplam para 5 Yuan'dır ve iki kalem 3.8 Yuan tutar.",
      "vi": "Hàm này tính toán số lượng bút tối đa có thể mua được với một số tiền nhất định. Giá của một chiếc bút là 1 Nhân dân tệ và 9 Jiao (1.9 Nhân dân tệ). Hàm nhận hai số nguyên, a và b, làm đầu vào, trong đó 'a' đại diện cho phần Nhân dân tệ và 'b' đại diện cho phần Jiao của tổng số tiền có sẵn. Nó trả về số lượng bút tối đa có thể mua được. Ví dụ, nếu a=5 và b=0, hàm sẽ trả về 2, vì tổng số tiền là 5 Nhân dân tệ, và hai chiếc bút có giá 3.8 Nhân dân tệ."
    },
    "docstring_bertscore": {
      "es": "0.9878883138860166",
      "arb": "0.9685168859755892",
      "sw": "1",
      "tr": "0.8598434236860674",
      "vi": "0.41854908696619075"
    }
  },
  {
    "task_id": "Shell/41",
    "prompt": {
      "en": "calculate_expression() {\n    # Calculate the value of the expression (a+b)*c with given integers a, b, and c.\n    # Args:\n    #     a (int): The first integer.\n    #     b (int): The second integer.\n    #     c (int): The third integer.\n    #\n    # Returns:\n    #     The result of the expression (a+b)*c.\n    #\n    # Examples:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "es": "calculate_expression() {\n    # Calcula el valor de la expresión (a+b)*c con los enteros dados a, b y c.\n    # Argumentos:\n    #     a (int): El primer entero.\n    #     b (int): El segundo entero.\n    #     c (int): El tercer entero.\n    #\n    # Devuelve:\n    #     El resultado de la expresión (a+b)*c.\n    #\n    # Ejemplos:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "arb": "calculate_expression() {\n    # حساب قيمة التعبير (a+b)*c مع الأعداد الصحيحة المعطاة a و b و c.\n    # الوسائط:\n    #     a (int): العدد الصحيح الأول.\n    #     b (int): العدد الصحيح الثاني.\n    #     c (int): العدد الصحيح الثالث.\n    #\n    # يعيد:\n    #     نتيجة التعبير (a+b)*c.\n    #\n    # أمثلة:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "sw": "calculate_expression() {\n    # Hesabu thamani ya usemi (a+b)*c na nambari kamili zilizotolewa a, b, na c.\n    # Hoja:\n    #     a (int): Nambari ya kwanza kamili.\n    #     b (int): Nambari ya pili kamili.\n    #     c (int): Nambari ya tatu kamili.\n    #\n    # Inarejesha:\n    #     Matokeo ya usemi (a+b)*c.\n    #\n    # Mifano:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "tr": "calculate_expression() {\n    # Verilen tamsayılar a, b ve c ile (a+b)*c ifadesinin değerini hesapla.\n    # Argümanlar:\n    #     a (int): Birinci tamsayı.\n    #     b (int): İkinci tamsayı.\n    #     c (int): Üçüncü tamsayı.\n    #\n    # Dönüş:\n    #     (a+b)*c ifadesinin sonucu.\n    #\n    # Örnekler:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "vi": "calculate_expression() {\n    # Tính giá trị của biểu thức (a+b)*c với các số nguyên a, b và c đã cho.\n    # Tham số:\n    #     a (int): Số nguyên thứ nhất.\n    #     b (int): Số nguyên thứ hai.\n    #     c (int): Số nguyên thứ ba.\n    #\n    # Trả về:\n    #     Kết quả của biểu thức (a+b)*c.\n    #\n    # Ví dụ:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3"
    },
    "prompt_bertscore": {
      "es": "0.9858285168346849",
      "arb": "0.9869670661787768",
      "sw": "0.995986474520809",
      "tr": "0.9750772502004095",
      "vi": "0.9845980016241738"
    },
    "canonical_solution": "    local a=$1\n    local b=$2\n    local c=$3\n\n    # Calculate (a+b)*c\n    local result=$(( (a + b) * c ))\n    echo \"$result\"\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_expression() {` to solve the following problem: Calculate the value of the expression (a+b)*c with given integers a, b, and c.\n Args:\n a (int): The first integer.\n b (int): The second integer.\n c (int): The third integer.\n\n Returns:\n The result of the expression (a+b)*c.\n\n Examples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "es": "Escribe una función de Shell `calculate_expression() {` para resolver el siguiente problema: Calcular el valor de la expresión (a+b)*c con los enteros dados a, b y c.\n Argumentos:\n a (int): El primer entero.\n b (int): El segundo entero.\n c (int): El tercer entero.\n\n Devuelve:\n El resultado de la expresión (a+b)*c.\n\n Ejemplos:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "arb": "اكتب دالة شل `calculate_expression() {` لحل المشكلة التالية: حساب قيمة التعبير (a+b)*c مع الأعداد الصحيحة المعطاة a، b، و c.\n يعيدالحجج:\n a (int): العدد الصحيح الأول.\n b (int): العدد الصحيح الثاني.\n c (int): العدد الصحيح الثالث.\n\n يعيد:\n نتيجة التعبير (a+b)*c.\n\n امثله:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "sw": "Andika kazi ya Shell `calculate_expression() {` kutatua tatizo lifuatalo: Hesabu thamani ya usemi (a+b)*c na namba kamili zilizotolewa a, b, na c.\n Hoja:\n a (int): Namba kamili ya kwanza.\n b (int): Namba kamili ya pili.\n c (int): Namba kamili ya tatu.\n\n Inarudisha:\n Matokeo ya usemi (a+b)*c.\n\n Mifano:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "tr": "Bir Shell fonksiyonu `calculate_expression() {` yazın: Aşağıdaki problemi çözmek için: Verilen tamsayılar a, b ve c ile (a+b)*c ifadesinin değerini hesaplayın.\n Argümanlar:\n a (int): Birinci tamsayı.\n b (int): İkinci tamsayı.\n c (int): Üçüncü tamsayı.\n\n Döndürür:\n İfadenin sonucu (a+b)*c.\n\n Örnekler:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "vi": "Viết một hàm Shell `calculate_expression() {` để giải quyết vấn đề sau: Tính giá trị của biểu thức (a+b)*c với các số nguyên a, b và c đã cho.\n Tham số:\n a (int): Số nguyên thứ nhất.\n b (int): Số nguyên thứ hai.\n c (int): Số nguyên thứ ba.\n\n Trả về:\n Kết quả của biểu thức (a+b)*c.\n\n Ví dụ:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3"
    },
    "instruction_bertscore": {
      "es": "0.9963537420953426",
      "arb": "0.9948346169411877",
      "sw": "0.9963537420953426",
      "tr": "0.9840450146433726",
      "vi": "0.9857341674036934"
    },
    "level": "easy",
    "test": "test_calculate_expression() {\n    local result\n\n    result=$(calculate_expression 1 2 3)\n    [[ \"$result\" -eq 9 ]] || { echo \"Test 1 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(calculate_expression -1 2 -3)\n    [[ \"$result\" -eq -3 ]] || { echo \"Test 2 failed: Expected -3, got $result\"; exit 1; }\n\n    result=$(calculate_expression 0 0 1)\n    [[ \"$result\" -eq 0 ]] || { echo \"Test 3 failed: Expected 0, got $result\"; exit 1; }\n\n    result=$(calculate_expression 10 -5 2)\n    [[ \"$result\" -eq 10 ]] || { echo \"Test 4 failed: Expected 10, got $result\"; exit 1; }\n\n    result=$(calculate_expression 100 200 -1)\n    [[ \"$result\" -eq -300 ]] || { echo \"Test 5 failed: Expected -300, got $result\"; exit 1; }\n}\n\ntest_calculate_expression",
    "entry_point": "calculate_expression",
    "signature": "calculate_expression() {",
    "docstring": {
      "en": " Calculate the value of the expression (a+b)*c with given integers a, b, and c.\n Args:\n a (int): The first integer.\n b (int): The second integer.\n c (int): The third integer.\n\n Returns:\n The result of the expression (a+b)*c.\n\n Examples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "es": "Calcular el valor de la expresión (a+b)*c con los enteros dados a, b y c.\nArgumentos:\n a (int): El primer entero.\n b (int): El segundo entero.\n c (int): El tercer entero.\n\nDevuelve:\n El resultado de la expresión (a+b)*c.\n\nEjemplos:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "arb": "حساب قيمة التعبير (a+b)*c باستخدام الأعداد الصحيحة المعطاة a، b، و c.\nيعيدالحجج:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nيعيد:\nنتيجة التعبير (a+b)*c.\n\nامثله:\n>>> calculate_expression 1 2 3\n9\n>>> calculate_expression -1 2 -3\n-3",
      "sw": "Kokotoa thamani ya usemi (a+b)*c na nambari kamili zilizotolewa a, b, na c.\n\nHoja:\n a (int): Nambari kamili ya kwanza.\n b (int): Nambari kamili ya pili.\n c (int): Nambari kamili ya tatu.\n\nInarejesha:\n Matokeo ya usemi (a+b)*c.\n\nMifano:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "tr": "İfadeyi verilen tam sayılar a, b ve c ile (a+b)*c şeklinde hesaplayın.\nArgümanlar:\n a (int): Birinci tam sayı.\n b (int): İkinci tam sayı.\n c (int): Üçüncü tam sayı.\n\nDöndürür:\n İfadenin sonucu (a+b)*c.\n\nÖrnekler:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "vi": "Tính giá trị của biểu thức (a+b)*c với các số nguyên a, b và c được cho.\n\nTham số:\n a (int): Số nguyên thứ nhất.\n b (int): Số nguyên thứ hai.\n c (int): Số nguyên thứ ba.\n\nTrả về:\n Kết quả của biểu thức (a+b)*c.\n\nVí dụ:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3"
    },
    "docstring_bertscore": {
      "es": "0.9956978645771654",
      "arb": "0.9931685053050671",
      "sw": "0.9956978645771654",
      "tr": "0.95351929905555",
      "vi": "0.9956978645771654"
    }
  },
  {
    "task_id": "Shell/42",
    "prompt": {
      "en": "print_ascii_code() {\n    # Prints the ASCII code of a given visible character (excluding space).\n    # Args:\n    #     char (string): A single character for which the ASCII code will be printed.\n    #\n    # Output:\n    #     Prints the ASCII code of the given character.\n    #\n    # Examples:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "es": "print_ascii_code() {\n    # Imprime el código ASCII de un carácter visible dado (excluyendo el espacio).\n    # Argumentos:\n    #     char (string): Un solo carácter para el cual se imprimirá el código ASCII.\n    #\n    # Salida:\n    #     Imprime el código ASCII del carácter dado.\n    #\n    # Ejemplos:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "arb": "print_ascii_code() {\n    # يطبع الكود ASCII لحرف مرئي معين (باستثناء المسافة).\n    # يعيدالحجج:\n    #     char (string): حرف واحد سيتم طباعة كود ASCII له.\n    #\n    # الناتج:\n    #     يطبع كود ASCII للحرف المعطى.\n    #\n    # أمثلة:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "sw": "print_ascii_code() {\n    # Chapisha msimbo wa ASCII wa herufi inayoonekana iliyotolewa (isipokuwa nafasi).\n    # Hoja:\n    #     char (string): Herufi moja ambayo msimbo wa ASCII utaonyeshwa.\n    #\n    # Matokeo:\n    #     Chapisha msimbo wa ASCII wa herufi iliyotolewa.\n    #\n    # Mifano:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "tr": "print_ascii_code() {\n    # Belirtilen görünür karakterin (boşluk hariç) ASCII kodunu yazdırır.\n    # Argümanlar:\n    #     char (string): ASCII kodu yazdırılacak tek bir karakter.\n    #\n    # Çıktı:\n    #     Belirtilen karakterin ASCII kodunu yazdırır.\n    #\n    # Örnekler:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "vi": "print_ascii_code() {\n    # In ra mã ASCII của một ký tự có thể nhìn thấy được (không bao gồm khoảng trắng).\n    # Tham số:\n    #     char (string): Một ký tự duy nhất mà mã ASCII sẽ được in ra.\n    #\n    # Đầu ra:\n    #     In ra mã ASCII của ký tự được cung cấp.\n    #\n    # Ví dụ:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122"
    },
    "prompt_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9866160862954882",
      "sw": "0.9673117954538505",
      "tr": "0.9604896363868263",
      "vi": "0.9425960185112984"
    },
    "canonical_solution": "    local char=\"$1\"\n    # Print the ASCII code of the character\n    printf \"%d\\n\" \"'$char\"\n}",
    "instruction": {
      "en": "Write a Shell function `print_ascii_code() {` to solve the following problem: Prints the ASCII code of a given visible character (excluding space).\n Args:\n char (string): A single character for which the ASCII code will be printed.\n\n Output:\n Prints the ASCII code of the given character.\n\n Examples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "es": "Escribe una función de Shell `print_ascii_code() {` para resolver el siguiente problema: Imprime el código ASCII de un carácter visible dado (excluyendo el espacio).  \n Argumentos:  \n char (string): Un solo carácter para el cual se imprimirá el código ASCII.  \n\n Salida:  \n Imprime el código ASCII del carácter dado.  \n\n Ejemplos:  \n >>> print_ascii_code 'B'  \n 66  \n >>> print_ascii_code 'z'  \n 122  ",
      "arb": "اكتب دالة شل `print_ascii_code() {` لحل المشكلة التالية: تطبع كود ASCII لحرف مرئي معين (باستثناء المسافة).\n يعيدالحجج:\n char (string): حرف واحد سيتم طباعة كود ASCII له.\n\n الناتج:\n تطبع كود ASCII للحرف المعطى.\n\n امثله:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "sw": "Andika kazi ya Shell `print_ascii_code() {` kutatua tatizo lifuatalo: Chapisha msimbo wa ASCII wa herufi inayoonekana iliyotolewa (ukiondoa nafasi). \n Hoja:\n char (string): Herufi moja ambayo msimbo wa ASCII utachapishwa.\n\n Matokeo:\n Inachapisha msimbo wa ASCII wa herufi iliyotolewa.\n\n Mifano:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "tr": "Bir Shell fonksiyonu `print_ascii_code() {` yazın: Aşağıdaki problemi çözmek için: Verilen bir görünen karakterin (boşluk hariç) ASCII kodunu yazdırır.\n Argümanlar:\n char (string): ASCII kodu yazdırılacak tek bir karakter.\n\n Çıktı:\n Verilen karakterin ASCII kodunu yazdırır.\n\n Örnekler:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "vi": "Viết một hàm Shell `print_ascii_code() {` để giải quyết vấn đề sau: In mã ASCII của một ký tự có thể nhìn thấy được (không bao gồm khoảng trắng). \n Tham số:\n char (string): Một ký tự duy nhất mà mã ASCII sẽ được in ra.\n\n Đầu ra:\n In mã ASCII của ký tự đã cho.\n\n Ví dụ:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122"
    },
    "instruction_bertscore": {
      "es": "0.9918599283548093",
      "arb": "0.9747761265427606",
      "sw": "0.984867344420857",
      "tr": "0.9846998990096446",
      "vi": "0.9555318220761955"
    },
    "level": "easy",
    "test": "test_print_ascii_code() {\n    local result\n\n    result=$(print_ascii_code 'B')\n    [[ \"$result\" -eq 66 ]] || { echo \"Test 1 failed: Expected 66, got $result\"; exit 1; }\n\n    result=$(print_ascii_code 'z')\n    [[ \"$result\" -eq 122 ]] || { echo \"Test 2 failed: Expected 122, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '1')\n    [[ \"$result\" -eq 49 ]] || { echo \"Test 3 failed: Expected 49, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '%')\n    [[ \"$result\" -eq 37 ]] || { echo \"Test 4 failed: Expected 37, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '?')\n    [[ \"$result\" -eq 63 ]] || { echo \"Test 5 failed: Expected 63, got $result\"; exit 1; }\n}\n\ntest_print_ascii_code",
    "entry_point": "print_ascii_code",
    "signature": "print_ascii_code() {",
    "docstring": {
      "en": " Prints the ASCII code of a given visible character (excluding space).\n Args:\n char (string): A single character for which the ASCII code will be printed.\n\n Output:\n Prints the ASCII code of the given character.\n\n Examples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "es": "Imprime el código ASCII de un carácter visible dado (excluyendo el espacio).\nArgumentos:\n char (string): Un solo carácter para el cual se imprimirá el código ASCII.\n\nSalida:\n Imprime el código ASCII del carácter dado.\n\nEjemplos:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "arb": "يطبع الكود ASCII لحرف مرئي معين (باستثناء المسافة).\nيعيدالحجج:\nchar (string): حرف واحد سيتم طباعة الكود ASCII له.\n\nالناتج:\nيطبع الكود ASCII للحرف المعطى.\n\nامثله:\n>>> print_ascii_code 'B'\n66\n>>> print_ascii_code 'z'\n122",
      "sw": "Inachapisha msimbo wa ASCII wa herufi inayoonekana iliyotolewa (isipokuwa nafasi).\nHoja:\n char (string): Herufi moja ambayo msimbo wa ASCII utaonyeshwa.\n\nMatokeo:\n Inachapisha msimbo wa ASCII wa herufi iliyotolewa.\n\nMifano:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "tr": " Belirtilen görünen karakterin (boşluk hariç) ASCII kodunu yazdırır.\n Argümanlar:\n char (string): ASCII kodu yazdırılacak tek bir karakter.\n\n Çıktı:\n Verilen karakterin ASCII kodunu yazdırır.\n\n Örnekler:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "vi": "In ra mã ASCII của một ký tự có thể nhìn thấy được (không bao gồm dấu cách).  \nTham số:  \nchar (string): Một ký tự duy nhất mà mã ASCII sẽ được in ra.  \n\nĐầu ra:  \nIn ra mã ASCII của ký tự đã cho.  \n\nVí dụ:  \n>>> print_ascii_code 'B'  \n66  \n>>> print_ascii_code 'z'  \n122  "
    },
    "docstring_bertscore": {
      "es": "0.992894792640001",
      "arb": "0.9864935313503896",
      "sw": "0.9736467141961962",
      "tr": "0.9772989310122847",
      "vi": "0.9700048261599216"
    }
  },
  {
    "task_id": "Shell/43",
    "prompt": {
      "en": "ascii_to_char() {\n    # Converts an ASCII code to its corresponding character.\n    # Args:\n    #     ascii_code (int): The ASCII code to be converted.\n    #\n    # Output:\n    #     Prints the character corresponding to the given ASCII code.\n    #\n    # Examples:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "es": "ascii_to_char() {\n    # Convierte un código ASCII a su carácter correspondiente.\n    # Argumentos:\n    #     ascii_code (int): El código ASCII que se va a convertir.\n    #\n    # Salida:\n    #     Imprime el carácter correspondiente al código ASCII dado.\n    #\n    # Ejemplos:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "arb": "ascii_to_char() {\n    # يحول رمز ASCII إلى الحرف المقابل له.\n    # الوسائط:\n    #     ascii_code (int): رمز ASCII الذي سيتم تحويله.\n    #\n    # الناتج:\n    #     يطبع الحرف المقابل لرمز ASCII المعطى.\n    #\n    # أمثلة:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "sw": "ascii_to_char() {\n    # Hubadilisha msimbo wa ASCII kuwa herufi inayolingana.\n    # Hoja:\n    #     ascii_code (int): Msimbo wa ASCII utakaobadilishwa.\n    #\n    # Matokeo:\n    #     Huchapisha herufi inayolingana na msimbo wa ASCII uliotolewa.\n    #\n    # Mifano:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "tr": "ascii_to_char() {\n    # Bir ASCII kodunu karşılık gelen karaktere dönüştürür.\n    # Argümanlar:\n    #     ascii_code (int): Dönüştürülecek ASCII kodu.\n    #\n    # Çıktı:\n    #     Verilen ASCII koduna karşılık gelen karakteri yazdırır.\n    #\n    # Örnekler:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "vi": "ascii_to_char() {\n    # Chuyển đổi một mã ASCII thành ký tự tương ứng.\n    # Tham số:\n    #     ascii_code (int): Mã ASCII cần được chuyển đổi.\n    #\n    # Đầu ra:\n    #     In ra ký tự tương ứng với mã ASCII đã cho.\n    #\n    # Ví dụ:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a"
    },
    "prompt_bertscore": {
      "es": "0.9880092797880669",
      "arb": "0.9880092797880669",
      "sw": "0.9687588177796896",
      "tr": "0.9825975950567714",
      "vi": "0.9653856766489552"
    },
    "canonical_solution": "    local ascii_code=$1\n    # Convert ASCII code to character\n    printf \"\\\\$(printf '%03o' \"$ascii_code\")\\n\"\n}",
    "instruction": {
      "en": "Write a Shell function `ascii_to_char() {` to solve the following problem: Converts an ASCII code to its corresponding character.\n Args:\n ascii_code (int): The ASCII code to be converted.\n\n Output:\n Prints the character corresponding to the given ASCII code.\n\n Examples:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "es": "Escribe una función Shell `ascii_to_char() {` para resolver el siguiente problema: Convierte un código ASCII a su carácter correspondiente.\n Argumentos:\n ascii_code (int): El código ASCII a convertir.\n\n Salida:\n Imprime el carácter correspondiente al código ASCII dado.\n\n Ejemplos:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "arb": "اكتب دالة شل `ascii_to_char() {` لحل المشكلة التالية: تحويل كود ASCII إلى الحرف المقابل له.\n يعيدالحجج:\n ascii_code (int): كود ASCII الذي سيتم تحويله.\n\n الناتج:\n يطبع الحرف المقابل لكود ASCII المعطى.\n\n أمثلة:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "sw": "Andika kazi ya Shell `ascii_to_char() {` kutatua tatizo lifuatalo: Inabadilisha msimbo wa ASCII kuwa herufi inayolingana nayo.\n Hoja:\n ascii_code (int): Msimbo wa ASCII utakaobadilishwa.\n\n Matokeo:\n Inachapisha herufi inayolingana na msimbo wa ASCII uliotolewa.\n\n Mifano:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "tr": "Bir Shell fonksiyonu `ascii_to_char() {` yazın: Bir ASCII kodunu karşılık gelen karaktere dönüştürür.\n Argümanlar:\n ascii_code (int): Dönüştürülecek ASCII kodu.\n\n Çıktı:\n Verilen ASCII koduna karşılık gelen karakteri yazdırır.\n\n Örnekler:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "vi": "Viết một hàm Shell `ascii_to_char() {` để giải quyết vấn đề sau: Chuyển đổi một mã ASCII thành ký tự tương ứng.\n Tham số:\n ascii_code (int): Mã ASCII cần được chuyển đổi.\n\n Đầu ra:\n In ký tự tương ứng với mã ASCII đã cho.\n\n Ví dụ:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a"
    },
    "instruction_bertscore": {
      "es": "0.9888272396971686",
      "arb": "0.9903274949651251",
      "sw": "0.9888592191885152",
      "tr": "0.9503233362246986",
      "vi": "0.9688609137955416"
    },
    "level": "easy",
    "test": "test_ascii_to_char() {\n    local result\n\n    result=$(ascii_to_char 66)\n    [[ \"$result\" == \"B\" ]] || { echo \"Test 1 failed: Expected B, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 97)\n    [[ \"$result\" == \"a\" ]] || { echo \"Test 2 failed: Expected a, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 36)\n    [[ \"$result\" == \"$\" ]] || { echo \"Test 3 failed: Expected $, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 57)\n    [[ \"$result\" == \"9\" ]] || { echo \"Test 4 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 32)\n    [[ \"$result\" == \" \" ]] || { echo \"Test 5 failed: Expected space, got $result\"; exit 1; }\n}\n\ntest_ascii_to_char",
    "entry_point": "ascii_to_char",
    "signature": "ascii_to_char() {",
    "docstring": {
      "en": " Converts an ASCII code to its corresponding character.\n Args:\n ascii_code (int): The ASCII code to be converted.\n\n Output:\n Prints the character corresponding to the given ASCII code.\n\n Examples:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "es": "Convierte un código ASCII a su carácter correspondiente.\nArgumentos:\n ascii_code (int): El código ASCII que se va a convertir.\n\nSalida:\n Imprime el carácter correspondiente al código ASCII dado.\n\nEjemplos:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "arb": "يحول رمز ASCII إلى الحرف المقابل له.\nيعيدالحجج:\nascii_code (int): رمز ASCII الذي سيتم تحويله.\n\nالناتج:\nيطبع الحرف المقابل لرمز ASCII المعطى.\n\nامثله:\n>>> ascii_to_char 66\nB\n>>> ascii_to_char 97\na",
      "sw": "Inabadilisha msimbo wa ASCII kuwa herufi inayolingana.\nHoja:\n ascii_code (int): Msimbo wa ASCII utakaobadilishwa.\n\n Matokeo:\n Huchapisha herufi inayolingana na msimbo wa ASCII uliotolewa.\n\n Mifano:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "tr": "ASCII kodunu karşılık gelen karaktere dönüştürür.\nArgümanlar:\n    ascii_code (int): Dönüştürülecek ASCII kodu.\n\nÇıktı:\n    Verilen ASCII koduna karşılık gelen karakteri yazdırır.\n\nÖrnekler:\n    >>> ascii_to_char 66\n    B\n    >>> ascii_to_char 97\n    a",
      "vi": "Chuyển đổi một mã ASCII thành ký tự tương ứng của nó.\nTham số:\n ascii_code (int): Mã ASCII cần được chuyển đổi.\n\nĐầu ra:\n In ra ký tự tương ứng với mã ASCII đã cho.\n\nVí dụ:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9902502277469025",
      "tr": "1",
      "vi": "0.9863491270633773"
    }
  },
  {
    "task_id": "Shell/44",
    "prompt": {
      "en": "int_to_bool_to_int() {\n    # Converts an integer to a boolean value, then converts this boolean back to an integer.\n    # The process involves assigning an integer value to a boolean variable and then\n    # assigning this boolean value back to an integer variable.\n    # Args:\n    #     initial_int (int): The initial integer value.\n    #\n    # Output:\n    #     Prints the integer value obtained after conversion from integer to boolean and back to integer.\n    #\n    # Examples:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "es": "int_to_bool_to_int() {\n    # Convierte un entero a un valor booleano, luego convierte este booleano de nuevo a un entero.\n    # El proceso implica asignar un valor entero a una variable booleana y luego\n    # asignar este valor booleano de nuevo a una variable entera.\n    # Argumentos:\n    #     initial_int (int): El valor entero inicial.\n    #\n    # Salida:\n    #     Imprime el valor entero obtenido después de la conversión de entero a booleano y de vuelta a entero.\n    #\n    # Ejemplos:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "arb": "int_to_bool_to_int() {\n    # يحول عددًا صحيحًا إلى قيمة منطقية، ثم يحول هذه القيمة المنطقية مرة أخرى إلى عدد صحيح.\n    # تتضمن العملية تعيين قيمة عدد صحيح لمتغير منطقي ثم\n    # تعيين هذه القيمة المنطقية مرة أخرى لمتغير عدد صحيح.\n    # الوسائط:\n    #     initial_int (int): القيمة العددية الأولية.\n    #\n    # المخرجات:\n    #     يطبع القيمة العددية التي تم الحصول عليها بعد التحويل من عدد صحيح إلى منطقي ثم العودة إلى عدد صحيح.\n    #\n    # أمثلة:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "sw": "int_to_bool_to_int() {\n    # Inabadilisha nambari nzima kuwa thamani ya boolean, kisha inabadilisha boolean hii kurudi kuwa nambari nzima.\n    # Mchakato unahusisha kupeana thamani ya nambari nzima kwa kigezo cha boolean na kisha\n    # kupeana thamani hii ya boolean kurudi kwa kigezo cha nambari nzima.\n    # Hoja:\n    #     initial_int (int): Thamani ya awali ya nambari nzima.\n    #\n    # Matokeo:\n    #     Inachapisha thamani ya nambari nzima iliyopatikana baada ya kubadilishwa kutoka nambari nzima hadi boolean na kurudi kwa nambari nzima.\n    #\n    # Mifano:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "tr": "int_to_bool_to_int() {\n    # Bir tam sayıyı boolean bir değere dönüştürür, ardından bu boolean değeri tekrar bir tam sayıya dönüştürür.\n    # Süreç, bir tam sayı değerini bir boolean değişkene atamayı ve ardından\n    # bu boolean değerini tekrar bir tam sayı değişkenine atamayı içerir.\n    # Argümanlar:\n    #     initial_int (int): Başlangıçtaki tam sayı değeri.\n    #\n    # Çıktı:\n    #     Tam sayıdan boolean'a ve tekrar tam sayıya dönüşümden sonra elde edilen tam sayı değerini yazdırır.\n    #\n    # Örnekler:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "vi": "int_to_bool_to_int() {\n    # Chuyển đổi một số nguyên thành một giá trị boolean, sau đó chuyển đổi giá trị boolean này trở lại thành một số nguyên.\n    # Quá trình này bao gồm việc gán một giá trị số nguyên cho một biến boolean và sau đó\n    # gán giá trị boolean này trở lại cho một biến số nguyên.\n    # Tham số:\n    #     initial_int (int): Giá trị số nguyên ban đầu.\n    #\n    # Đầu ra:\n    #     In ra giá trị số nguyên thu được sau khi chuyển đổi từ số nguyên sang boolean và trở lại số nguyên.\n    #\n    # Ví dụ:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1"
    },
    "prompt_bertscore": {
      "es": "0.9923588878719689",
      "arb": "0.9762046762431635",
      "sw": "0.9632184205614835",
      "tr": "0.9906129268226722",
      "vi": "0.9784408570728542"
    },
    "canonical_solution": "    local initial_int=$1\n    local bool_val\n    local final_int\n\n    # Convert initial_int to boolean\n    if [[ initial_int -ne 0 ]]; then\n        bool_val=1\n    else\n        bool_val=0\n    fi\n\n    # Convert boolean back to integer\n    final_int=$bool_val\n\n    echo \"$final_int\"\n}",
    "instruction": {
      "en": "Write a Shell function `int_to_bool_to_int() {` to solve the following problem: Converts an integer to a boolean value, then converts this boolean back to an integer.\n The process involves assigning an integer value to a boolean variable and then\n assigning this boolean value back to an integer variable.\n Args:\n initial_int (int): The initial integer value.\n\n Output:\n Prints the integer value obtained after conversion from integer to boolean and back to integer.\n\n Examples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "es": "Escriba una función de Shell `int_to_bool_to_int() {` para resolver el siguiente problema: Convierte un entero a un valor booleano, luego convierte este booleano de nuevo a un entero. \n El proceso implica asignar un valor entero a una variable booleana y luego \n asignar este valor booleano de nuevo a una variable entera.\n Argumentos:\n initial_int (int): El valor entero inicial.\n\n Salida:\n Imprime el valor entero obtenido después de la conversión de entero a booleano y de vuelta a entero.\n\n Ejemplos:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "arb": "اكتب دالة Shell `int_to_bool_to_int() {` لحل المشكلة التالية: تحويل عدد صحيح إلى قيمة منطقية، ثم تحويل هذه القيمة المنطقية مرة أخرى إلى عدد صحيح.\n تتضمن العملية تعيين قيمة عدد صحيح إلى متغير منطقي ثم\n تعيين هذه القيمة المنطقية مرة أخرى إلى متغير عدد صحيح.\n يعيدالحجج:\n initial_int (int): القيمة العددية الصحيحة الأولية.\n\n الناتج:\n يطبع القيمة العددية الصحيحة التي تم الحصول عليها بعد التحويل من عدد صحيح إلى منطقي ثم إلى عدد صحيح مرة أخرى.\n\n أمثلة:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "sw": "Andika kazi ya Shell `int_to_bool_to_int() {` kutatua tatizo lifuatalo: Inabadilisha nambari kamili kuwa thamani ya boolean, kisha inabadilisha boolean hii kurudi kwenye nambari kamili. \n Mchakato unahusisha kuweka thamani ya nambari kamili kwenye kigezo cha boolean na kisha\n kuweka thamani hii ya boolean kurudi kwenye kigezo cha nambari kamili.\n Hoja:\n initial_int (int): Thamani ya awali ya nambari kamili.\n\n Matokeo:\n Inachapisha thamani ya nambari kamili iliyopatikana baada ya kubadilisha kutoka nambari kamili hadi boolean na kurudi kwenye nambari kamili.\n\n Mifano:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "tr": "Bir Shell fonksiyonu `int_to_bool_to_int() {` yazın: Aşağıdaki problemi çözmek için: Bir tam sayıyı boolean bir değere dönüştürür, ardından bu boolean değeri tekrar bir tam sayıya dönüştürür.\n Süreç, bir tam sayı değerini bir boolean değişkene atamayı ve ardından\n bu boolean değerini tekrar bir tam sayı değişkene atamayı içerir.\n Argümanlar:\n initial_int (int): İlk tam sayı değeri.\n\n Çıktı:\n Tam sayıdan boolean'a ve tekrar tam sayıya dönüştürme işleminden sonra elde edilen tam sayı değerini yazdırır.\n\n Örnekler:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "vi": "Viết một hàm Shell `int_to_bool_to_int() {` để giải quyết vấn đề sau: Chuyển đổi một số nguyên thành một giá trị boolean, sau đó chuyển đổi boolean này trở lại thành một số nguyên. \n Quá trình này bao gồm việc gán một giá trị số nguyên cho một biến boolean và sau đó\n gán giá trị boolean này trở lại cho một biến số nguyên.\n Tham số:\n initial_int (int): Giá trị số nguyên ban đầu.\n\n Đầu ra:\n In ra giá trị số nguyên thu được sau khi chuyển đổi từ số nguyên sang boolean và trở lại số nguyên.\n\n Ví dụ:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1"
    },
    "instruction_bertscore": {
      "es": "0.9939517048974876",
      "arb": "0.9916670582548244",
      "sw": "0.9651691695336272",
      "tr": "0.9832800890460073",
      "vi": "0.9785449393925165"
    },
    "level": "easy",
    "test": "test_int_to_bool_to_int() {\n    local result\n\n    result=$(int_to_bool_to_int 0)\n    [[ \"$result\" -eq 0 ]] || { echo \"Test 1 failed: Expected 0, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int -5)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 2 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int 10)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int -1)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 4 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int 1)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 5 failed: Expected 1, got $result\"; exit 1; }\n}\n\ntest_int_to_bool_to_int",
    "entry_point": "int_to_bool_to_int",
    "signature": "int_to_bool_to_int() {",
    "docstring": {
      "en": " Converts an integer to a boolean value, then converts this boolean back to an integer.\n The process involves assigning an integer value to a boolean variable and then\n assigning this boolean value back to an integer variable.\n Args:\n initial_int (int): The initial integer value.\n\n Output:\n Prints the integer value obtained after conversion from integer to boolean and back to integer.\n\n Examples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "es": "Convierte un entero a un valor booleano, luego convierte este booleano de nuevo a un entero. El proceso implica asignar un valor entero a una variable booleana y luego asignar este valor booleano de nuevo a una variable entera.\n\nArgumentos:\n initial_int (int): El valor entero inicial.\n\nSalida:\n Imprime el valor entero obtenido después de la conversión de entero a booleano y de nuevo a entero.\n\nEjemplos:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "arb": "يقوم بتحويل عدد صحيح إلى قيمة منطقية، ثم يعيد تحويل هذه القيمة المنطقية إلى عدد صحيح.\n تتضمن العملية تعيين قيمة عدد صحيح إلى متغير منطقي ثم تعيين هذه القيمة المنطقية مرة أخرى إلى متغير عدد صحيح.\n يعيدالحجج:\n initial_int (int): القيمة العددية الصحيحة الأولية.\n\n الناتج:\n يطبع القيمة العددية الصحيحة التي تم الحصول عليها بعد التحويل من عدد صحيح إلى منطقي ثم العودة إلى عدد صحيح.\n\nامثله:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "sw": "Inabadilisha nambari kamili kuwa thamani ya boolean, kisha inabadilisha boolean hii tena kuwa nambari kamili. \nMchakato unahusisha kuweka thamani ya nambari kamili kwenye kigezo cha boolean na kisha \nkuweka thamani hii ya boolean tena kwenye kigezo cha nambari kamili.\nHoja:\n initial_int (int): Thamani ya awali ya nambari kamili.\n\n Matokeo:\n Inachapisha thamani ya nambari kamili inayopatikana baada ya kubadilishwa kutoka nambari kamili hadi boolean na kurudi kwenye nambari kamili.\n\n Mifano:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "tr": "Bir tam sayıyı boolean bir değere dönüştürür, ardından bu boolean değeri tekrar bir tam sayıya dönüştürür. \nBu süreç, bir tam sayı değerini bir boolean değişkene atamayı ve ardından bu boolean değerini tekrar bir tam sayı değişkene atamayı içerir.\nArgümanlar:\n initial_int (int): Başlangıçtaki tam sayı değeri.\n\n Çıktı:\n Tam sayıdan boolean'a ve tekrar tam sayıya dönüştürme işleminden sonra elde edilen tam sayı değerini yazdırır.\n\n Örnekler:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "vi": "Chuyển đổi một số nguyên thành giá trị boolean, sau đó chuyển đổi boolean này trở lại thành số nguyên. Quá trình này bao gồm việc gán một giá trị số nguyên cho một biến boolean và sau đó gán giá trị boolean này trở lại cho một biến số nguyên. \nTham số:\n initial_int (int): Giá trị số nguyên ban đầu.\n\nĐầu ra:\n In ra giá trị số nguyên thu được sau khi chuyển đổi từ số nguyên sang boolean và trở lại số nguyên.\n\nVí dụ:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1"
    },
    "docstring_bertscore": {
      "es": "0.9989554028261375",
      "arb": "0.9931265942946688",
      "sw": "0.9953260285038681",
      "tr": "0.9946532674033028",
      "vi": "0.985151783126499"
    }
  },
  {
    "task_id": "Shell/45",
    "prompt": {
      "en": "reverse_number() {\n    # Reverses a three-digit number.\n    # This function takes a three-digit number as input and prints its reverse.\n    # The output maintains leading zeros if present.\n    # Args:\n    #     number (int): A three-digit number to be reversed.\n    #\n    # Output:\n    #     Prints the reversed number, maintaining any leading zeros.\n    #\n    # Examples:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "es": "reverse_number() {\n    # Invierte un número de tres dígitos.\n    # Esta función toma un número de tres dígitos como entrada e imprime su inverso.\n    # La salida mantiene los ceros a la izquierda si están presentes.\n    # Argumentos:\n    #     number (int): Un número de tres dígitos que se va a invertir.\n    #\n    # Salida:\n    #     Imprime el número invertido, manteniendo cualquier cero a la izquierda.\n    #\n    # Ejemplos:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "arb": "reverse_number() {\n    # يعكس رقمًا مكونًا من ثلاثة أرقام.\n    # تأخذ هذه الدالة رقمًا مكونًا من ثلاثة أرقام كمدخل وتطبع عكسه.\n    # يحافظ الإخراج على الأصفار البادئة إذا كانت موجودة.\n    # الوسائط:\n    #     number (int): رقم مكون من ثلاثة أرقام ليتم عكسه.\n    #\n    # الإخراج:\n    #     يطبع الرقم المعكوس، مع الحفاظ على أي أصفار بادئة.\n    #\n    # أمثلة:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "sw": "reverse_number() {\n    # Inarudisha namba ya tarakimu tatu kwa nyuma.\n    # Kazi hii inachukua namba ya tarakimu tatu kama ingizo na kuchapisha kinyume chake.\n    # Matokeo yanahifadhi sifuri za mwanzo ikiwa zipo.\n    # Hoja:\n    #     number (int): Namba ya tarakimu tatu inayopaswa kurudishwa nyuma.\n    #\n    # Matokeo:\n    #     Inachapisha namba iliyogeuzwa, ikihifadhi sifuri zozote za mwanzo.\n    #\n    # Mifano:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "tr": "reverse_number() {\n    # Üç basamaklı bir sayıyı ters çevirir.\n    # Bu fonksiyon, üç basamaklı bir sayıyı girdi olarak alır ve tersini yazdırır.\n    # Çıktı, varsa baştaki sıfırları korur.\n    # Argümanlar:\n    #     number (int): Ters çevrilecek üç basamaklı bir sayı.\n    #\n    # Çıktı:\n    #     Baştaki sıfırları koruyarak ters çevrilmiş sayıyı yazdırır.\n    #\n    # Örnekler:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "vi": "reverse_number() {\n    # Đảo ngược một số có ba chữ số.\n    # Hàm này nhận một số có ba chữ số làm đầu vào và in ra số đảo ngược của nó.\n    # Đầu ra giữ nguyên các số 0 đứng đầu nếu có.\n    # Tham số:\n    #     number (int): Một số có ba chữ số cần đảo ngược.\n    #\n    # Đầu ra:\n    #     In ra số đã đảo ngược, giữ nguyên bất kỳ số 0 đứng đầu nào.\n    #\n    # Ví dụ:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040"
    },
    "prompt_bertscore": {
      "es": "0.9962856118746476",
      "arb": "0.9850578309562695",
      "sw": "0.9728444460871963",
      "tr": "0.9690402770296161",
      "vi": "0.959713786118504"
    },
    "canonical_solution": "    local number=$1\n    # Reverse the number and maintain leading zeros\n    echo $number | rev\n}",
    "instruction": {
      "en": "Write a Shell function `reverse_number() {` to solve the following problem: Reverses a three-digit number.\n This function takes a three-digit number as input and prints its reverse.\n The output maintains leading zeros if present.\n Args:\n number (int): A three-digit number to be reversed.\n\n Output:\n Prints the reversed number, maintaining any leading zeros.\n\n Examples:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "es": "Escribe una función de Shell `reverse_number() {` para resolver el siguiente problema: Invierte un número de tres dígitos.  \nEsta función toma un número de tres dígitos como entrada e imprime su inverso.  \nLa salida mantiene los ceros a la izquierda si están presentes.  \nArgumentos:  \nnumber (int): Un número de tres dígitos para ser invertido.\n\nSalida:  \nImprime el número invertido, manteniendo cualquier cero a la izquierda.\n\nEjemplos:  \n>>> reverse_number 123  \n321  \n>>> reverse_number 040  \n040  ",
      "arb": "اكتب دالة Shell `reverse_number() {` لحل المشكلة التالية: عكس رقم مكون من ثلاثة أرقام. \n تأخذ هذه الدالة رقمًا مكونًا من ثلاثة أرقام كمدخل وتطبع عكسه. \n يحافظ الإخراج على الأصفار البادئة إذا كانت موجودة.\n المعطيات:\n number (int): رقم مكون من ثلاثة أرقام ليتم عكسه.\n\n الإخراج:\n يطبع الرقم المعكوس، مع الحفاظ على أي أصفار بادئة.\n\n أمثلة:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "sw": "Andika kazi ya Shell `reverse_number() {` kutatua tatizo lifuatalo: Inageuza namba ya tarakimu tatu.\n Kazi hii inachukua namba ya tarakimu tatu kama ingizo na kuchapisha mgeuzo wake.\n Matokeo yanahifadhi sifuri za mwanzo ikiwa zipo.\n Hoja:\n number (int): Namba ya tarakimu tatu inayopaswa kugeuzwa.\n\n Matokeo:\n Inachapisha namba iliyogeuzwa, ikihifadhi sifuri zozote za mwanzo.\n\n Mifano:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "tr": "Bir Shell fonksiyonu `reverse_number() {` yazın: Üç basamaklı bir sayıyı tersine çevirme problemini çözmek için. \n Bu fonksiyon, üç basamaklı bir sayıyı girdi olarak alır ve tersini yazdırır.\n Çıktı, varsa baştaki sıfırları korur.\n Argümanlar:\n number (int): Tersine çevrilecek üç basamaklı bir sayı.\n\n Çıktı:\n Baştaki sıfırları koruyarak ters çevrilmiş sayıyı yazdırır.\n\n Örnekler:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "vi": "Viết một hàm Shell `reverse_number() {` để giải quyết vấn đề sau: Đảo ngược một số có ba chữ số. \n Hàm này nhận một số có ba chữ số làm đầu vào và in ra số đảo ngược của nó.\n Đầu ra giữ nguyên các số 0 ở đầu nếu có.\n Tham số:\n number (int): Một số có ba chữ số cần được đảo ngược.\n\n Đầu ra:\n In ra số đã đảo ngược, giữ nguyên bất kỳ số 0 ở đầu nào.\n\n Ví dụ:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040"
    },
    "instruction_bertscore": {
      "es": "0.9835132811133422",
      "arb": "0.9714917731923487",
      "sw": "0.9829585064591118",
      "tr": "0.9491784307084135",
      "vi": "0.9585510038679257"
    },
    "level": "easy",
    "test": "test_reverse_number() {\n    local result\n\n    result=$(reverse_number 123)\n    [[ \"$result\" == \"321\" ]] || { echo \"Test 1 failed: Expected 321, got $result\"; exit 1; }\n\n    result=$(reverse_number 040)\n    [[ \"$result\" == \"040\" ]] || { echo \"Test 2 failed: Expected 040, got $result\"; exit 1; }\n\n    result=$(reverse_number 500)\n    [[ \"$result\" == \"005\" ]] || { echo \"Test 3 failed: Expected 005, got $result\"; exit 1; }\n\n    result=$(reverse_number 999)\n    [[ \"$result\" == \"999\" ]] || { echo \"Test 4 failed: Expected 999, got $result\"; exit 1; }\n\n    result=$(reverse_number 100)\n    [[ \"$result\" == \"001\" ]] || { echo \"Test 5 failed: Expected 001, got $result\"; exit 1; }\n}\n\ntest_reverse_number",
    "entry_point": "reverse_number",
    "signature": "reverse_number() {",
    "docstring": {
      "en": " Reverses a three-digit number.\n This function takes a three-digit number as input and prints its reverse.\n The output maintains leading zeros if present.\n Args:\n number (int): A three-digit number to be reversed.\n\n Output:\n Prints the reversed number, maintaining any leading zeros.\n\n Examples:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "es": "Invierte un número de tres dígitos.  \nEsta función toma un número de tres dígitos como entrada e imprime su reverso.  \nLa salida mantiene los ceros a la izquierda si están presentes.  \nArgumentos:  \nnumber (int): Un número de tres dígitos a invertir.\n\nSalida:  \nImprime el número invertido, manteniendo cualquier cero a la izquierda.\n\nEjemplos:  \n>>> reverse_number 123  \n321  \n>>> reverse_number 040  \n040  ",
      "arb": "يعكس رقمًا مكونًا من ثلاثة أرقام.  \nتأخذ هذه الدالة رقمًا مكونًا من ثلاثة أرقام كمدخل وتطبع عكسه.  \nيحافظ الإخراج على الأصفار البادئة إذا كانت موجودة.  \nيعيدالحجج:  \nnumber (int): رقم مكون من ثلاثة أرقام ليتم عكسه.\n\nالناتج:  \nيطبع الرقم المعكوس، مع الحفاظ على أي أصفار بادئة.\n\nامثله:  \n>>> reverse_number 123  \n321  \n>>> reverse_number 040  \n040  ",
      "sw": "Rejelea namba ya tarakimu tatu.  \nKazi hii inachukua namba ya tarakimu tatu kama ingizo na kuchapisha kinyume chake.  \nMatokeo yanahifadhi sifuri za mwanzo ikiwa zipo.  \nHoja:  \nnumber (int): Namba ya tarakimu tatu inayotakiwa kurejeshwa nyuma.  \n\nMatokeo:  \nInachapisha namba iliyorejeshwa nyuma, ikihifadhi sifuri zozote za mwanzo.  \n\nMifano:  \n>>> reverse_number 123  \n321  \n>>> reverse_number 040  \n040  ",
      "tr": "Üç basamaklı bir sayıyı tersine çevirir.  \nBu fonksiyon, giriş olarak üç basamaklı bir sayı alır ve tersini yazdırır.  \nÇıktı, varsa baştaki sıfırları korur.  \nArgümanlar:  \nnumber (int): Tersine çevrilecek üç basamaklı bir sayı.  \n\nÇıktı:  \nTers çevrilmiş sayıyı, varsa baştaki sıfırları koruyarak yazdırır.  \n\nÖrnekler:  \n>>> reverse_number 123  \n321  \n>>> reverse_number 040  \n040  ",
      "vi": "Đảo ngược một số có ba chữ số.  \nHàm này nhận một số có ba chữ số làm đầu vào và in ra số đảo ngược của nó.  \nĐầu ra duy trì các số không đứng đầu nếu có.  \nTham số:  \nnumber (int): Một số có ba chữ số cần được đảo ngược.\n\nĐầu ra:  \nIn ra số đã đảo ngược, duy trì bất kỳ số không đứng đầu nào.\n\nVí dụ:  \n>>> reverse_number 123  \n321  \n>>> reverse_number 040  \n040  "
    },
    "docstring_bertscore": {
      "es": "0.9721899589816864",
      "arb": "0.969608757180138",
      "sw": "0.9517421530364308",
      "tr": "0.9548973966391701",
      "vi": "0.9722795412835331"
    }
  },
  {
    "task_id": "Shell/46",
    "prompt": {
      "en": "calculate_nth_term() {\n    # Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2.\n    # The difference between any two consecutive terms is constant.\n    # Args:\n    #     a1 (int): The first term of the arithmetic sequence.\n    #     a2 (int): The second term of the arithmetic sequence.\n    #     n (int): The term number to calculate.\n    #\n    # Output:\n    #     Prints the value of the nth term in the arithmetic sequence.\n    #\n    # Examples:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "es": "calculate_nth_term() {\n    # Calcula el enésimo término de una secuencia aritmética dada los dos primeros términos a1 y a2.\n    # La diferencia entre dos términos consecutivos es constante.\n    # Argumentos:\n    #     a1 (int): El primer término de la secuencia aritmética.\n    #     a2 (int): El segundo término de la secuencia aritmética.\n    #     n (int): El número del término a calcular.\n    #\n    # Salida:\n    #     Imprime el valor del enésimo término en la secuencia aritmética.\n    #\n    # Ejemplos:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "arb": "calculate_nth_term() {\n    # يحسب الحد النوني لمتتالية حسابية معطاة أول حدين a1 و a2.\n    # الفرق بين أي حدين متتاليين ثابت.\n    # الوسائط:\n    #     a1 (int): الحد الأول من المتتالية الحسابية.\n    #     a2 (int): الحد الثاني من المتتالية الحسابية.\n    #     n (int): رقم الحد المراد حسابه.\n    #\n    # المخرجات:\n    #     يطبع قيمة الحد النوني في المتتالية الحسابية.\n    #\n    # أمثلة:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "sw": "calculate_nth_term() {\n    # Inahesabu neno la nth la mlolongo wa hesabu ukizingatia maneno mawili ya kwanza a1 na a2.\n    # Tofauti kati ya maneno mawili mfululizo ni ya kudumu.\n    # Hoja:\n    #     a1 (int): Neno la kwanza la mlolongo wa hesabu.\n    #     a2 (int): Neno la pili la mlolongo wa hesabu.\n    #     n (int): Nambari ya neno la kuhesabu.\n    #\n    # Matokeo:\n    #     Inachapisha thamani ya neno la nth katika mlolongo wa hesabu.\n    #\n    # Mifano:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "tr": "calculate_nth_term() {\n    # İlk iki terim a1 ve a2 verilen bir aritmetik dizinin n'inci terimini hesaplar.\n    # Herhangi iki ardışık terim arasındaki fark sabittir.\n    # Argümanlar:\n    #     a1 (int): Aritmetik dizinin ilk terimi.\n    #     a2 (int): Aritmetik dizinin ikinci terimi.\n    #     n (int): Hesaplanacak terim numarası.\n    #\n    # Çıktı:\n    #     Aritmetik dizideki n'inci terimin değerini yazdırır.\n    #\n    # Örnekler:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "vi": "calculate_nth_term() {\n    # Tính toán số hạng thứ n của một dãy số học cho trước hai số hạng đầu tiên a1 và a2.\n    # Hiệu giữa hai số hạng liên tiếp bất kỳ là không đổi.\n    # Tham số:\n    #     a1 (int): Số hạng đầu tiên của dãy số học.\n    #     a2 (int): Số hạng thứ hai của dãy số học.\n    #     n (int): Số thứ tự của số hạng cần tính.\n    #\n    # Đầu ra:\n    #     In ra giá trị của số hạng thứ n trong dãy số học.\n    #\n    # Ví dụ:\n    # >>> calculate_nth_term 1 3 5\n    # 9"
    },
    "prompt_bertscore": {
      "es": "0.9808335586428005",
      "arb": "0.9833577535249919",
      "sw": "0.987150203390091",
      "tr": "0.977329321460583",
      "vi": "0.9646817305785675"
    },
    "canonical_solution": "    local a1=$1\n    local a2=$2\n    local n=$3\n    local d=$((a2 - a1)) # Common difference\n    local nth_term=$((a1 + (n - 1) * d))\n    echo \"$nth_term\"\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_nth_term() {` to solve the following problem: Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2.\n The difference between any two consecutive terms is constant.\n Args:\n a1 (int): The first term of the arithmetic sequence.\n a2 (int): The second term of the arithmetic sequence.\n n (int): The term number to calculate.\n\n Output:\n Prints the value of the nth term in the arithmetic sequence.\n\n Examples:\n >>> calculate_nth_term 1 3 5\n 9",
      "es": "Escribe una función de Shell `calculate_nth_term() {` para resolver el siguiente problema: Calcula el enésimo término de una secuencia aritmética dada los dos primeros términos a1 y a2.\n La diferencia entre dos términos consecutivos es constante.\n Argumentos:\n a1 (int): El primer término de la secuencia aritmética.\n a2 (int): El segundo término de la secuencia aritmética.\n n (int): El número del término a calcular.\n\n Salida:\n Imprime el valor del enésimo término en la secuencia aritmética.\n\n Ejemplos:\n >>> calculate_nth_term 1 3 5\n 9",
      "arb": "اكتب دالة شل `calculate_nth_term() {` لحل المشكلة التالية: حساب الحد النوني لمتتالية حسابية معطى الحدين الأولين a1 و a2.\n الفرق بين أي حدين متتاليين ثابت.\n يعيدالحجج:\n a1 (int): الحد الأول من المتتالية الحسابية.\n a2 (int): الحد الثاني من المتتالية الحسابية.\n n (int): رقم الحد المراد حسابه.\n\n الناتج:\n يطبع قيمة الحد النوني في المتتالية الحسابية.\n\n أمثلة:\n >>> calculate_nth_term 1 3 5\n 9",
      "sw": "Andika kazi ya Shell `calculate_nth_term() {` kutatua tatizo lifuatalo: Inahesabu neno la nth la mlolongo wa hesabu ukizingatia maneno mawili ya kwanza a1 na a2. \n Tofauti kati ya maneno mawili mfululizo ni thabiti.\n Hoja:\n a1 (int): Neno la kwanza la mlolongo wa hesabu.\n a2 (int): Neno la pili la mlolongo wa hesabu.\n n (int): Nambari ya neno la kuhesabu.\n\n Pato:\n Inachapisha thamani ya neno la nth katika mlolongo wa hesabu.\n\n Mifano:\n >>> calculate_nth_term 1 3 5\n 9",
      "tr": "Bir Shell fonksiyonu `calculate_nth_term() {` yazın: İlk iki terim a1 ve a2 verildiğinde bir aritmetik dizinin n'inci terimini hesaplar.\n Herhangi iki ardışık terim arasındaki fark sabittir.\n Argümanlar:\n a1 (int): Aritmetik dizinin ilk terimi.\n a2 (int): Aritmetik dizinin ikinci terimi.\n n (int): Hesaplanacak terim numarası.\n\n Çıktı:\n Aritmetik dizideki n'inci terimin değerini yazdırır.\n\n Örnekler:\n >>> calculate_nth_term 1 3 5\n 9",
      "vi": "Viết một hàm Shell `calculate_nth_term() {` để giải quyết vấn đề sau: Tính toán số hạng thứ n của một dãy số học cho trước hai số hạng đầu tiên a1 và a2. \nHiệu giữa bất kỳ hai số hạng liên tiếp nào là không đổi.\nTham số:\na1 (int): Số hạng đầu tiên của dãy số học.\na2 (int): Số hạng thứ hai của dãy số học.\nn (int): Số thứ tự của số hạng cần tính.\n\nĐầu ra:\nIn ra giá trị của số hạng thứ n trong dãy số học.\n\nVí dụ:\n>>> calculate_nth_term 1 3 5\n9"
    },
    "instruction_bertscore": {
      "es": "0.9862577570881013",
      "arb": "0.9893065348066058",
      "sw": "0.9889237740623515",
      "tr": "0.9067021182456269",
      "vi": "0.9685764750898996"
    },
    "level": "easy",
    "test": "test_calculate_nth_term() {\n    local result\n\n    result=$(calculate_nth_term 1 3 5)\n    [[ \"$result\" -eq 9 ]] || { echo \"Test 1 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term 2 5 10)\n    [[ \"$result\" -eq 29 ]] || { echo \"Test 2 failed: Expected 20, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term -1 1 50)\n    [[ \"$result\" -eq 97 ]] || { echo \"Test 3 failed: Expected 97, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term 100 -100 3)\n    [[ \"$result\" -eq -300 ]] || { echo \"Test 4 failed: Expected -300, got $result\"; exit 1; }\n\n}\n\ntest_calculate_nth_term",
    "entry_point": "calculate_nth_term",
    "signature": "calculate_nth_term() {",
    "docstring": {
      "en": " Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2.\n The difference between any two consecutive terms is constant.\n Args:\n a1 (int): The first term of the arithmetic sequence.\n a2 (int): The second term of the arithmetic sequence.\n n (int): The term number to calculate.\n\n Output:\n Prints the value of the nth term in the arithmetic sequence.\n\n Examples:\n >>> calculate_nth_term 1 3 5\n 9",
      "es": "Calcula el enésimo término de una secuencia aritmética dada los dos primeros términos a1 y a2.  \nLa diferencia entre dos términos consecutivos es constante.  \nArgumentos:  \na1 (int): El primer término de la secuencia aritmética.  \na2 (int): El segundo término de la secuencia aritmética.  \nn (int): El número de término a calcular.  \n\nSalida:  \nImprime el valor del enésimo término en la secuencia aritmética.  \n\nامثله:  \n>>> calculate_nth_term 1 3 5  \n9",
      "arb": "يحسب الحد النوني لمتتالية حسابية معطاة الحدين الأولين a1 و a2. الفرق بين أي حدين متتاليين ثابت.  \nالمعاملات:  \na1 (int): الحد الأول من المتتالية الحسابية.  \na2 (int): الحد الثاني من المتتالية الحسابية.  \nn (int): رقم الحد المراد حسابه.  \n\nالمخرجات:  \nيطبع قيمة الحد النوني في المتتالية الحسابية.  \n\nأمثلة:  \n>>> calculate_nth_term 1 3 5  \n9",
      "sw": "Hesabu neno la nth la mlolongo wa hesabu ukizingatia maneno mawili ya kwanza a1 na a2. Tofauti kati ya maneno yoyote mawili mfululizo ni thabiti.\n\nHoja:\n a1 (int): Neno la kwanza la mlolongo wa hesabu.\n a2 (int): Neno la pili la mlolongo wa hesabu.\n n (int): Nambari ya neno la kuhesabu.\n\nMatokeo:\n Chapisha thamani ya neno la nth katika mlolongo wa hesabu.\n\nMifano:\n >>> calculate_nth_term 1 3 5\n 9",
      "tr": "n. terimi, ilk iki terim a1 ve a2 verilen bir aritmetik dizinin hesaplar.  \nHerhangi iki ardışık terim arasındaki fark sabittir.  \nArgümanlar:  \n    a1 (int): Aritmetik dizinin ilk terimi.  \n    a2 (int): Aritmetik dizinin ikinci terimi.  \n    n (int): Hesaplanacak terim numarası.  \n\nÇıktı:  \nAritmetik dizideki n. terimin değerini yazdırır.  \n\nÖrnekler:  \n>>> calculate_nth_term 1 3 5  \n9",
      "vi": "Tính toán số hạng thứ n của một dãy số học cho trước hai số hạng đầu tiên a1 và a2. \nHiệu giữa hai số hạng liên tiếp bất kỳ là không đổi.\nTham số:\n a1 (int): Số hạng đầu tiên của dãy số học.\n a2 (int): Số hạng thứ hai của dãy số học.\n n (int): Số thứ tự của số hạng cần tính.\n\nĐầu ra:\nIn ra giá trị của số hạng thứ n trong dãy số học.\n\nVí dụ:\n >>> calculate_nth_term 1 3 5\n 9"
    },
    "docstring_bertscore": {
      "es": "0.9886109312122215",
      "arb": "0.9732945425306213",
      "sw": "0.9931718820215447",
      "tr": "0.962594919795415",
      "vi": "0.9691387976986094"
    }
  },
  {
    "task_id": "Shell/47",
    "prompt": {
      "en": "multiply_numbers() {\n    # Calculates the product of two positive integers A and B.\n    # Given two positive integers, this function computes their product.\n    # It is important to consider the range of the result to ensure that it does not exceed shell arithmetic limits.\n    # Args:\n    #     A (int): The first positive integer.\n    #     B (int): The second positive integer.\n    #\n    # Output:\n    #     Prints the product of A and B.\n    #\n    # Examples:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "es": "multiply_numbers() {\n    # Calcula el producto de dos enteros positivos A y B.\n    # Dados dos enteros positivos, esta función calcula su producto.\n    # Es importante considerar el rango del resultado para asegurar que no exceda los límites aritméticos del shell.\n    # Argumentos:\n    #     A (int): El primer entero positivo.\n    #     B (int): El segundo entero positivo.\n    #\n    # Salida:\n    #     Imprime el producto de A y B.\n    #\n    # Ejemplos:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "arb": "multiply_numbers() {\n    # يحسب حاصل ضرب عددين صحيحين موجبين A و B.\n    # بالنظر إلى عددين صحيحين موجبين، تقوم هذه الدالة بحساب حاصل ضربهما.\n    # من المهم مراعاة نطاق النتيجة للتأكد من أنها لا تتجاوز حدود الحساب في الشل.\n    # يعيدالحجج:\n    #     A (int): العدد الصحيح الموجب الأول.\n    #     B (int): العدد الصحيح الموجب الثاني.\n    #\n    # الناتج:\n    #     يطبع حاصل ضرب A و B.\n    #\n    # أمثلة:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "sw": "multiply_numbers() {\n    # Inahesabu bidhaa ya nambari mbili nzima chanya A na B.\n    # Ukipewa nambari mbili nzima chanya, kazi hii inahesabu bidhaa yao.\n    # Ni muhimu kuzingatia upeo wa matokeo ili kuhakikisha kuwa hayazidi mipaka ya hesabu ya shell.\n    # Hoja:\n    #     A (int): Nambari ya kwanza nzima chanya.\n    #     B (int): Nambari ya pili nzima chanya.\n    #\n    # Matokeo:\n    #     Inachapisha bidhaa ya A na B.\n    #\n    # Mifano:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "tr": "multiply_numbers() {\n    # İki pozitif tam sayının A ve B çarpımını hesaplar.\n    # İki pozitif tam sayı verildiğinde, bu fonksiyon onların çarpımını hesaplar.\n    # Sonucun kabuk aritmetik sınırlarını aşmamasını sağlamak için aralığı dikkate almak önemlidir.\n    # Argümanlar:\n    #     A (int): İlk pozitif tam sayı.\n    #     B (int): İkinci pozitif tam sayı.\n    #\n    # Çıktı:\n    #     A ve B'nin çarpımını yazdırır.\n    #\n    # Örnekler:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "vi": "multiply_numbers() {\n    # Tính tích của hai số nguyên dương A và B.\n    # Cho hai số nguyên dương, hàm này tính tích của chúng.\n    # Điều quan trọng là phải xem xét phạm vi của kết quả để đảm bảo rằng nó không vượt quá giới hạn số học của shell.\n    # Tham số:\n    #     A (int): Số nguyên dương thứ nhất.\n    #     B (int): Số nguyên dương thứ hai.\n    #\n    # Đầu ra:\n    #     In ra tích của A và B.\n    #\n    # Ví dụ:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088"
    },
    "prompt_bertscore": {
      "es": "0.985185748921656",
      "arb": "0.9876823341808835",
      "sw": "0.9703663334534051",
      "tr": "0.9715896979701989",
      "vi": "0.9697909012395469"
    },
    "canonical_solution": "    local A=$1\n    local B=$2\n    # Calculate and print the product of A and B\n    echo $((A * B))\n}",
    "instruction": {
      "en": "Write a Shell function `multiply_numbers() {` to solve the following problem: Calculates the product of two positive integers A and B.\n Given two positive integers, this function computes their product.\n It is important to consider the range of the result to ensure that it does not exceed shell arithmetic limits.\n Args:\n A (int): The first positive integer.\n B (int): The second positive integer.\n\n Output:\n Prints the product of A and B.\n\n Examples:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "es": "Escribe una función de Shell `multiply_numbers() {` para resolver el siguiente problema: Calcula el producto de dos enteros positivos A y B.\n Dados dos enteros positivos, esta función calcula su producto.\n Es importante considerar el rango del resultado para asegurar que no exceda los límites aritméticos de Shell.\n Argumentos:\n A (int): El primer entero positivo.\n B (int): El segundo entero positivo.\n\n Salida:\n Imprime el producto de A y B.\n\n Ejemplos:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "arb": "اكتب دالة Shell `multiply_numbers() {` لحل المشكلة التالية: حساب حاصل ضرب عددين صحيحين موجبين A و B.\nبالنظر إلى عددين صحيحين موجبين، تقوم هذه الدالة بحساب حاصل ضربهما.\nمن المهم مراعاة نطاق النتيجة لضمان عدم تجاوزها حدود الحساب في shell.\nالمعطيات:\nA (int): العدد الصحيح الموجب الأول.\nB (int): العدد الصحيح الموجب الثاني.\n\nالمخرجات:\nتطبع حاصل ضرب A و B.\n\nأمثلة:\n>>> multiply_numbers 5 10\n50\n>>> multiply_numbers 123 456\n56088",
      "sw": "Andika kazi ya Shell `multiply_numbers() {` kutatua tatizo lifuatalo: Inahesabu bidhaa ya namba mbili nzima chanya A na B.\n Kwa kupewa namba mbili nzima chanya, kazi hii inahesabu bidhaa yao.\n Ni muhimu kuzingatia wigo wa matokeo ili kuhakikisha kuwa hayazidi mipaka ya hesabu ya shell.\n Hoja:\n A (int): Namba ya kwanza nzima chanya.\n B (int): Namba ya pili nzima chanya.\n\n Matokeo:\n Inachapisha bidhaa ya A na B.\n\n Mifano:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "tr": "Bir Shell fonksiyonu `multiply_numbers() {` yazın: İki pozitif tam sayı A ve B'nin çarpımını hesaplar.\n İki pozitif tam sayı verildiğinde, bu fonksiyon onların çarpımını hesaplar.\n Sonucun shell aritmetik sınırlarını aşmadığından emin olmak için aralığı dikkate almak önemlidir.\n Argümanlar:\n A (int): Birinci pozitif tam sayı.\n B (int): İkinci pozitif tam sayı.\n\n Çıktı:\n A ve B'nin çarpımını yazdırır.\n\n Örnekler:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "vi": "Viết một hàm Shell `multiply_numbers() {` để giải quyết vấn đề sau: Tính tích của hai số nguyên dương A và B. \n Cho hai số nguyên dương, hàm này tính tích của chúng.\n Điều quan trọng là phải xem xét phạm vi của kết quả để đảm bảo rằng nó không vượt quá giới hạn số học của shell.\n Tham số:\n A (int): Số nguyên dương thứ nhất.\n B (int): Số nguyên dương thứ hai.\n\n Đầu ra:\n In ra tích của A và B.\n\n Ví dụ:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088"
    },
    "instruction_bertscore": {
      "es": "0.9862243871840874",
      "arb": "0.9684251187395511",
      "sw": "0.9834280686798782",
      "tr": "0.9492145814377618",
      "vi": "0.9705300048873777"
    },
    "level": "easy",
    "test": "test_multiply_numbers() {\n    local result\n\n    result=$(multiply_numbers 5 10)\n    [[ \"$result\" -eq 50 ]] || { echo \"Test 1 failed: Expected 50, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 123 456)\n    [[ \"$result\" -eq 56088 ]] || { echo \"Test 2 failed: Expected 56088, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 1 50000)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 3 failed: Expected 50000, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 250 200)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 4 failed: Expected 50000, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 500 100)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 5 failed: Expected 50000, got $result\"; exit 1; }\n}\n\ntest_multiply_numbers",
    "entry_point": "multiply_numbers",
    "signature": "multiply_numbers() {",
    "docstring": {
      "en": " Calculates the product of two positive integers A and B.\n Given two positive integers, this function computes their product.\n It is important to consider the range of the result to ensure that it does not exceed shell arithmetic limits.\n Args:\n A (int): The first positive integer.\n B (int): The second positive integer.\n\n Output:\n Prints the product of A and B.\n\n Examples:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "es": "Calcula el producto de dos enteros positivos A y B.\nDado dos enteros positivos, esta función calcula su producto.\nEs importante considerar el rango del resultado para asegurar que no exceda los límites de la aritmética del shell.\nArgumentos:\nA (int): El primer entero positivo.\nB (int): El segundo entero positivo.\n\nSalida:\nImprime el producto de A y B.\n\nEjemplos:\n>>> multiply_numbers 5 10\n50\n>>> multiply_numbers 123 456\n56088",
      "arb": "يحسب حاصل ضرب عددين صحيحين موجبين A و B.  \nمعطى عددين صحيحين موجبين، تقوم هذه الدالة بحساب حاصل ضربهما.  \nمن المهم مراعاة نطاق النتيجة لضمان عدم تجاوز حدود الحساب في الشيل.  \nالمعطيات:  \nA (int): العدد الصحيح الموجب الأول.  \nB (int): العدد الصحيح الموجب الثاني.  \n\nالمخرجات:  \nيطبع حاصل ضرب A و B.  \n\nأمثلة:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  ",
      "sw": "Inahesabu bidhaa ya nambari mbili nzima chanya A na B.  \nKwa kuzingatia nambari mbili nzima chanya, kazi hii inahesabu bidhaa yao.  \nNi muhimu kuzingatia wigo wa matokeo ili kuhakikisha kuwa hauzidi mipaka ya hesabu ya shell.  \nHoja:  \nA (int): Nambari ya kwanza nzima chanya.  \nB (int): Nambari ya pili nzima chanya.  \n\nMatokeo:  \nInachapisha bidhaa ya A na B.  \n\nMifano:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  ",
      "tr": "İki pozitif tam sayı A ve B'nin çarpımını hesaplar.  \nİki pozitif tam sayı verildiğinde, bu fonksiyon onların çarpımını hesaplar.  \nSonucun shell aritmetik sınırlarını aşmadığından emin olmak için aralığı dikkate almak önemlidir.  \nArgümanlar:  \nA (int): İlk pozitif tam sayı.  \nB (int): İkinci pozitif tam sayı.  \n\nÇıktı:  \nA ve B'nin çarpımını yazdırır.  \n\nÖrnekler:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  ",
      "vi": "Tính tích của hai số nguyên dương A và B.  \nCho hai số nguyên dương, hàm này tính tích của chúng.  \nĐiều quan trọng là phải xem xét phạm vi của kết quả để đảm bảo rằng nó không vượt quá giới hạn số học của shell.  \nTham số:  \nA (int): Số nguyên dương thứ nhất.  \nB (int): Số nguyên dương thứ hai.  \n\nĐầu ra:  \nIn ra tích của A và B.  \n\nVí dụ:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  "
    },
    "docstring_bertscore": {
      "es": "0.9837609731984928",
      "arb": "0.9652577586835688",
      "sw": "0.9732568027582247",
      "tr": "0.975456435597805",
      "vi": "0.9600393413130202"
    }
  },
  {
    "task_id": "Shell/48",
    "prompt": {
      "en": "calculate_power_of_two() {\n    # Calculates 2 to the power of n.\n    # Given a non-negative integer n, this function computes 2^n.\n    # It is important to ensure that n is within the valid range to avoid arithmetic overflow in shell.\n    # Args:\n    #     n (int): The exponent to raise 2 to. Must be a non-negative integer.\n    #\n    # Output:\n    #     Prints the value of 2 raised to the power of n.\n    #\n    # Examples:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "es": "calculate_power_of_two() {\n    # Calcula 2 elevado a la potencia de n.\n    # Dado un entero no negativo n, esta función calcula 2^n.\n    # Es importante asegurarse de que n esté dentro del rango válido para evitar desbordamiento aritmético en shell.\n    # Argumentos:\n    #     n (int): El exponente al que se eleva 2. Debe ser un entero no negativo.\n    #\n    # Salida:\n    #     Imprime el valor de 2 elevado a la potencia de n.\n    #\n    # Ejemplos:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "arb": "calculate_power_of_two() {\n    # يحسب 2 مرفوعًا إلى أس n.\n    # بالنظر إلى عدد صحيح غير سالب n، تقوم هذه الدالة بحساب 2^n.\n    # من المهم التأكد من أن n ضمن النطاق الصالح لتجنب تجاوز الحساب في الشيل.\n    # الوسائط:\n    #     n (int): الأس الذي سيتم رفع 2 إليه. يجب أن يكون عددًا صحيحًا غير سالب.\n    #\n    # المخرجات:\n    #     يطبع قيمة 2 مرفوعة إلى الأس n.\n    #\n    # أمثلة:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "sw": "calculate_power_of_two() {\n    # Inahesabu 2 kwa nguvu ya n.\n    # Ukipewa nambari isiyo hasi n, kazi hii inahesabu 2^n.\n    # Ni muhimu kuhakikisha kwamba n iko ndani ya kiwango halali ili kuepuka kufurika kwa hesabu kwenye shell.\n    # Hoja:\n    #     n (int): Kielezo cha kuinua 2. Lazima iwe nambari isiyo hasi.\n    #\n    # Matokeo:\n    #     Inachapisha thamani ya 2 iliyoinuliwa kwa nguvu ya n.\n    #\n    # Mifano:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "tr": "calculate_power_of_two() {\n    # n'ninci kuvvetini hesaplar.\n    # Negatif olmayan bir tamsayı n verildiğinde, bu fonksiyon 2^n'i hesaplar.\n    # Aritmetik taşmayı önlemek için n'nin geçerli aralıkta olduğundan emin olmak önemlidir.\n    # Argümanlar:\n    #     n (int): 2'nin üssü olarak alınacak sayı. Negatif olmayan bir tamsayı olmalıdır.\n    #\n    # Çıktı:\n    #     2'nin n'inci kuvveti olan değeri yazdırır.\n    #\n    # Örnekler:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "vi": "calculate_power_of_two() {\n    # Tính 2 lũy thừa n.\n    # Cho một số nguyên không âm n, hàm này tính 2^n.\n    # Điều quan trọng là đảm bảo rằng n nằm trong phạm vi hợp lệ để tránh tràn số học trong shell.\n    # Tham số:\n    #     n (int): Số mũ để nâng 2 lên. Phải là một số nguyên không âm.\n    #\n    # Đầu ra:\n    #     In ra giá trị của 2 nâng lên lũy thừa n.\n    #\n    # Ví dụ:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024"
    },
    "prompt_bertscore": {
      "es": "0.9795013446771995",
      "arb": "0.9648718198532179",
      "sw": "0.9701806140471374",
      "tr": "0.9192676747802748",
      "vi": "0.9709671903560355"
    },
    "canonical_solution": "    local n=$1\n    # Calculate 2^n using left shift operation ((2**n))\n    echo $((2**n))\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_power_of_two() {` to solve the following problem: Calculates 2 to the power of n.\n Given a non-negative integer n, this function computes 2^n.\n It is important to ensure that n is within the valid range to avoid arithmetic overflow in shell.\n Args:\n n (int): The exponent to raise 2 to. Must be a non-negative integer.\n\n Output:\n Prints the value of 2 raised to the power of n.\n\n Examples:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "es": "Escribe una función de Shell `calculate_power_of_two() {` para resolver el siguiente problema: Calcula 2 elevado a la potencia de n.\n Dado un entero no negativo n, esta función calcula 2^n.\n Es importante asegurar que n esté dentro del rango válido para evitar desbordamiento aritmético en shell.\n Argumentos:\n n (int): El exponente al que se eleva 2. Debe ser un entero no negativo.\n\n Salida:\n Imprime el valor de 2 elevado a la potencia de n.\n\n امثله:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "arb": "اكتب دالة شيل `calculate_power_of_two() {` لحل المشكلة التالية: حساب 2 مرفوعًا للقوة n.\n معطى عدد صحيح غير سالب n، تقوم هذه الدالة بحساب 2^n.\n من المهم التأكد من أن n ضمن النطاق الصالح لتجنب تجاوز الحساب في الشيل.\n الوسائط:\n n (int): الأس الذي سيتم رفع 2 إليه. يجب أن يكون عددًا صحيحًا غير سالب.\n\n المخرجات:\n تطبع قيمة 2 مرفوعة للقوة n.\n\n أمثلة:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "sw": "Andika kazi ya Shell `calculate_power_of_two() {` kutatua tatizo lifuatalo: Inahesabu 2 kwa nguvu ya n. \n Kwa kupewa nambari isiyo hasi n, kazi hii inahesabu 2^n.\n Ni muhimu kuhakikisha kwamba n iko ndani ya anuwai halali ili kuepuka kufurika kwa hesabu katika shell.\n Hoja:\n n (int): Kipimo cha kuongeza 2. Lazima iwe nambari isiyo hasi.\n\n Matokeo:\n Inachapisha thamani ya 2 iliyoinuliwa kwa nguvu ya n.\n\n Mifano:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "tr": "Bir Shell fonksiyonu `calculate_power_of_two() {` yazın: Aşağıdaki problemi çözmek için: n'inci kuvvetine 2'yi hesaplar.\n Negatif olmayan bir tamsayı n verildiğinde, bu fonksiyon 2^n'i hesaplar.\n n'in geçerli aralıkta olduğundan emin olmak önemlidir, aksi takdirde shell'de aritmetik taşma olabilir.\n Argümanlar:\n n (int): 2'nin kuvvetini alacağı üs. Negatif olmayan bir tamsayı olmalıdır.\n\n Çıktı:\n 2'nin n'inci kuvvetine yükseltilmiş değerini yazdırır.\n\n Örnekler:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "vi": "Viết một hàm Shell `calculate_power_of_two() {` để giải quyết vấn đề sau: Tính 2 lũy thừa n. \n Cho một số nguyên không âm n, hàm này tính 2^n.\n Điều quan trọng là đảm bảo rằng n nằm trong phạm vi hợp lệ để tránh tràn số học trong shell.\n Tham số:\n n (int): Số mũ để nâng 2 lên. Phải là một số nguyên không âm.\n\n Đầu ra:\n In ra giá trị của 2 lũy thừa n.\n\n Ví dụ:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024"
    },
    "instruction_bertscore": {
      "es": "0.9834131714013006",
      "arb": "0.9628118241715051",
      "sw": "0.969540825589824",
      "tr": "0.9377683071002454",
      "vi": "0.9728460351302446"
    },
    "level": "easy",
    "test": "test_calculate_power_of_two() {\n    local result\n\n    result=$(calculate_power_of_two 5)\n    [[ \"$result\" -eq 32 ]] || { echo \"Test 1 failed: Expected 32, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 10)\n    [[ \"$result\" -eq 1024 ]] || { echo \"Test 2 failed: Expected 1024, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 0)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 15)\n    [[ \"$result\" -eq 32768 ]] || { echo \"Test 4 failed: Expected 32768, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 20)\n    [[ \"$result\" -eq 1048576 ]] || { echo \"Test 5 failed: Expected 1048576, got $result\"; exit 1; }\n}\n\ntest_calculate_power_of_two",
    "entry_point": "calculate_power_of_two",
    "signature": "calculate_power_of_two() {",
    "docstring": {
      "en": " Calculates 2 to the power of n.\n Given a non-negative integer n, this function computes 2^n.\n It is important to ensure that n is within the valid range to avoid arithmetic overflow in shell.\n Args:\n n (int): The exponent to raise 2 to. Must be a non-negative integer.\n\n Output:\n Prints the value of 2 raised to the power of n.\n\n Examples:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "es": "Calcula 2 elevado a la potencia de n.  \nDado un entero no negativo n, esta función calcula 2^n.  \nEs importante asegurar que n esté dentro del rango válido para evitar desbordamiento aritmético en shell.  \nArgumentos:  \nn (int): El exponente al que se eleva 2. Debe ser un entero no negativo.  \n\nSalida:  \nImprime el valor de 2 elevado a la potencia de n.  \n\nEjemplos:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  ",
      "arb": "يحسب 2 مرفوعًا إلى قوة n.  \nبالنظر إلى عدد صحيح غير سالب n، تقوم هذه الدالة بحساب 2^n.  \nمن المهم التأكد من أن n ضمن النطاق الصالح لتجنب تجاوز الحساب في الشيل.  \nالمعطيات:  \nn (int): الأس الذي سيتم رفع 2 إليه. يجب أن يكون عددًا صحيحًا غير سالب.\n\nالناتج:  \nيطبع قيمة 2 مرفوعة إلى قوة n.\n\nأمثلة:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  ",
      "sw": "Inahesabu 2 kwa nguvu ya n.\nKwa kupewa nambari kamili isiyo na alama n, kazi hii inahesabu 2^n.\nNi muhimu kuhakikisha kuwa n iko ndani ya safu halali ili kuepuka kufurika kwa hesabu kwenye shell.\nHoja:\n n (int): Kielezo cha kuinua 2. Lazima iwe nambari kamili isiyo na alama.\n\nMatokeo:\n Inachapisha thamani ya 2 iliyoinuliwa kwa nguvu ya n.\n\nMifano:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "tr": "2'nin n'inci kuvvetini hesaplar.\nNegatif olmayan bir tamsayı n verildiğinde, bu fonksiyon 2^n'i hesaplar.\nAritmetik taşmayı önlemek için n'in geçerli aralıkta olduğundan emin olmak önemlidir.\nArgümanlar:\n n (int): 2'nin üssü olarak yükseltileceği sayı. Negatif olmayan bir tamsayı olmalıdır.\n\nÇıktı:\n 2'nin n'inci kuvvetine yükseltilmiş değerini yazdırır.\n\nÖrnekler:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "vi": "Tính 2 lũy thừa của n.  \nCho một số nguyên không âm n, hàm này tính 2^n.  \nĐiều quan trọng là đảm bảo rằng n nằm trong phạm vi hợp lệ để tránh tràn số học trong shell.  \nTham số:  \nn (int): Số mũ để nâng 2 lên. Phải là một số nguyên không âm.\n\nĐầu ra:  \nIn giá trị của 2 nâng lên lũy thừa của n.\n\nVí dụ:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  "
    },
    "docstring_bertscore": {
      "es": "0.9778862810490049",
      "arb": "0.960038348161115",
      "sw": "0.9585889422707035",
      "tr": "0.9302143937094886",
      "vi": "0.9863453530861377"
    }
  },
  {
    "task_id": "Shell/49",
    "prompt": {
      "en": "check_sign() {\n    # Check the sign of a given integer.\n    # If the integer is greater than zero, return \"positive\".\n    # If the integer is zero, return \"zero\".\n    # If the integer is less than zero, return \"negative\".\n    #\n    # Example:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "es": "check_sign() {\n    # Verificar el signo de un número entero dado.\n    # Si el número entero es mayor que cero, devolver \"positive\".\n    # Si el número entero es cero, devolver \"zero\".\n    # Si el número entero es menor que cero, devolver \"negative\".\n    #\n    # Ejemplo:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "arb": "check_sign() {\n    # تحقق من إشارة عدد صحيح معين.\n    # إذا كان العدد الصحيح أكبر من الصفر، أعد \"positive\".\n    # إذا كان العدد الصحيح يساوي الصفر، أعد \"zero\".\n    # إذا كان العدد الصحيح أقل من الصفر، أعد \"negative\".\n    #\n    # مثال:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "sw": "check_sign() {\n    # Angalia ishara ya nambari nzima iliyotolewa.\n    # Ikiwa nambari nzima ni kubwa kuliko sifuri, rudisha \"positive\".\n    # Ikiwa nambari nzima ni sifuri, rudisha \"zero\".\n    # Ikiwa nambari nzima ni ndogo kuliko sifuri, rudisha \"negative\".\n    #\n    # Mfano:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "tr": "check_sign() {\n    # Verilen bir tam sayının işaretini kontrol et.\n    # Eğer tam sayı sıfırdan büyükse, \"positive\" döndür.\n    # Eğer tam sayı sıfırsa, \"zero\" döndür.\n    # Eğer tam sayı sıfırdan küçükse, \"negative\" döndür.\n    #\n    # Örnek:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "vi": "check_sign() {\n    # Kiểm tra dấu của một số nguyên đã cho.\n    # Nếu số nguyên lớn hơn không, trả về \"positive\".\n    # Nếu số nguyên bằng không, trả về \"zero\".\n    # Nếu số nguyên nhỏ hơn không, trả về \"negative\".\n    #\n    # Ví dụ:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9882567732428363",
      "sw": "0.9970002839856111",
      "tr": "1",
      "vi": "0.9882567732428363"
    },
    "canonical_solution": "    if [ $1 -gt 0 ]; then\n        echo \"positive\"\n    elif [ $1 -eq 0 ]; then\n        echo \"zero\"\n    else\n        echo \"negative\"\n    fi\n}",
    "instruction": {
      "en": "Write a Shell function `check_sign() {` to solve the following problem: Check the sign of a given integer.\n If the integer is greater than zero, return \"positive\".\n If the integer is zero, return \"zero\".\n If the integer is less than zero, return \"negative\".\n\n Example:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "es": "Escribe una función de Shell `check_sign() {` para resolver el siguiente problema: Verificar el signo de un entero dado.\n Si el entero es mayor que cero, devuelve \"positive\".\n Si el entero es cero, devuelve \"zero\".\n Si el entero es menor que cero, devuelve \"negative\".\n\n Ejemplo:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "arb": "اكتب دالة Shell `check_sign() {` لحل المشكلة التالية: تحقق من إشارة عدد صحيح معطى.\nإذا كان العدد الصحيح أكبر من الصفر، أعد \"positive\".\nإذا كان العدد الصحيح يساوي الصفر، أعد \"zero\".\nإذا كان العدد الصحيح أقل من الصفر، أعد \"negative\".\n\nمثال:\n>>> check_sign 95\npositive\n>>> check_sign 0\nzero\n>>> check_sign -95\nnegative",
      "sw": "Andika kazi ya Shell `check_sign() {` kutatua tatizo lifuatalo: Angalia ishara ya nambari kamili iliyotolewa. Ikiwa nambari kamili ni kubwa kuliko sifuri, rudisha \"positive\". Ikiwa nambari kamili ni sifuri, rudisha \"zero\". Ikiwa nambari kamili ni ndogo kuliko sifuri, rudisha \"negative\".\n\nMfano:\n>>> check_sign 95\npositive\n>>> check_sign 0\nzero\n>>> check_sign -95\nnegative",
      "tr": "Bir Shell fonksiyonu `check_sign() {` yazın ve aşağıdaki problemi çözün: Verilen bir tam sayının işaretini kontrol edin.\n Eğer tam sayı sıfırdan büyükse, \"positive\" döndürün.\n Eğer tam sayı sıfırsa, \"zero\" döndürün.\n Eğer tam sayı sıfırdan küçükse, \"negative\" döndürün.\n\n Örnek:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "vi": "Viết một hàm Shell `check_sign() {` để giải quyết vấn đề sau: Kiểm tra dấu của một số nguyên cho trước. \nNếu số nguyên lớn hơn không, trả về \"positive\".\nNếu số nguyên bằng không, trả về \"zero\".\nNếu số nguyên nhỏ hơn không, trả về \"negative\".\n\nVí dụ:\n>>> check_sign 95\npositive\n>>> check_sign 0\nzero\n>>> check_sign -95\nnegative"
    },
    "instruction_bertscore": {
      "es": "0.9943892876269075",
      "arb": "0.9898128436478637",
      "sw": "0.9949609458635259",
      "tr": "0.9964470983744289",
      "vi": "1"
    },
    "level": "easy",
    "test": "\ntest_check_sign() {\n    [[ $(check_sign 95) == \"positive\" ]] || { echo \"Test 1 failed\"; exit 1; }\n    [[ $(check_sign 0) == \"zero\" ]] || { echo \"Test 2 failed\"; exit 1; }\n    [[ $(check_sign -95) == \"negative\" ]] || { echo \"Test 3 failed\"; exit 1; }\n    [[ $(check_sign 1000000000) == \"positive\" ]] || { echo \"Test 4 failed\"; exit 1; }\n    [[ $(check_sign -1000000000) == \"negative\" ]] || { echo \"Test 5 failed\"; exit 1; }\n    [[ $(check_sign 1) == \"positive\" ]] || { echo \"Test 6 failed\"; exit 1; }\n    [[ $(check_sign -1) == \"negative\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_check_sign",
    "entry_point": "check_sign",
    "signature": "check_sign() {",
    "docstring": {
      "en": " Check the sign of a given integer.\n If the integer is greater than zero, return \"positive\".\n If the integer is zero, return \"zero\".\n If the integer is less than zero, return \"negative\".\n\n Example:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "es": "Verificar el signo de un entero dado.  \nSi el entero es mayor que cero, devuelve \"positive\".  \nSi el entero es cero, devuelve \"zero\".  \nSi el entero es menor que cero, devuelve \"negative\".  \n\nEjemplo:  \n>>> check_sign 95  \npositive  \n>>> check_sign 0  \nzero  \n>>> check_sign -95  \nnegative  ",
      "arb": "تحقق من إشارة عدد صحيح معين.  \nإذا كان العدد الصحيح أكبر من الصفر، أعد \"positive\".  \nإذا كان العدد الصحيح يساوي الصفر، أعد \"zero\".  \nإذا كان العدد الصحيح أقل من الصفر، أعد \"negative\".  \n\nمثال:  \n>>> check_sign 95  \npositive  \n>>> check_sign 0  \nzero  \n>>> check_sign -95  \nnegative  ",
      "sw": "Angalia ishara ya nambari kamili iliyotolewa.  \nIkiwa nambari kamili ni kubwa kuliko sifuri, rudisha \"positive\".  \nIkiwa nambari kamili ni sifuri, rudisha \"zero\".  \nIkiwa nambari kamili ni ndogo kuliko sifuri, rudisha \"negative\".  \n\nMfano:  \n>>> check_sign 95  \npositive  \n>>> check_sign 0  \nzero  \n>>> check_sign -95  \nnegative  ",
      "tr": " Belirtilen bir tam sayının işaretini kontrol edin.\n Eğer tam sayı sıfırdan büyükse, \"pozitif\" döndürün.\n Eğer tam sayı sıfırsa, \"sıfır\" döndürün.\n Eğer tam sayı sıfırdan küçükse, \"negatif\" döndürün.\n\n Örnek:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "vi": "Kiểm tra dấu của một số nguyên cho trước.  \nNếu số nguyên lớn hơn không, trả về \"positive\".  \nNếu số nguyên bằng không, trả về \"zero\".  \nNếu số nguyên nhỏ hơn không, trả về \"negative\".  \n\nVí dụ:  \n>>> check_sign 95  \npositive  \n>>> check_sign 0  \nzero  \n>>> check_sign -95  \nnegative  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9870782991921564",
      "sw": "0.9964069750374599",
      "tr": "1",
      "vi": "0.9870782991921564"
    }
  },
  {
    "task_id": "Shell/50",
    "prompt": {
      "en": "absolute_value() {\n    # Calculate the absolute value of a given integer.\n    # If the integer is positive, return the number as is.\n    # If the integer is negative, return the number multiplied by -1.\n    #\n    # Example:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "es": "absolute_value() {\n    # Calcular el valor absoluto de un entero dado.\n    # Si el entero es positivo, devuelve el número tal cual.\n    # Si el entero es negativo, devuelve el número multiplicado por -1.\n    #\n    # Ejemplo:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "arb": "absolute_value() {\n    # حساب القيمة المطلقة لعدد صحيح معطى.\n    # إذا كان العدد الصحيح موجبًا، قم بإرجاع الرقم كما هو.\n    # إذا كان العدد الصحيح سالبًا، قم بإرجاع الرقم مضروبًا في -1.\n    #\n    # مثال:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "sw": "absolute_value() {\n    # Hesabu thamani kamili ya nambari nzima iliyotolewa.\n    # Ikiwa nambari ni chanya, rudisha nambari kama ilivyo.\n    # Ikiwa nambari ni hasi, rudisha nambari iliyozidishwa na -1.\n    #\n    # Mfano:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "tr": "absolute_value() {\n    # Verilen bir tamsayının mutlak değerini hesapla.\n    # Eğer tamsayı pozitifse, sayıyı olduğu gibi döndür.\n    # Eğer tamsayı negatifse, sayıyı -1 ile çarparak döndür.\n    #\n    # Örnek:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "vi": "absolute_value() {\n    # Tính giá trị tuyệt đối của một số nguyên cho trước.\n    # Nếu số nguyên là dương, trả về số đó như nó vốn có.\n    # Nếu số nguyên là âm, trả về số đó nhân với -1.\n    #\n    # Ví dụ:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9817430871575593",
      "tr": "0.992666764962573",
      "vi": "0.992666764962573"
    },
    "canonical_solution": "    if [ $1 -lt 0 ]; then\n        echo $((-$1))\n    else\n        echo $1\n    fi\n}",
    "instruction": {
      "en": "Write a Shell function `absolute_value() {` to solve the following problem: Calculate the absolute value of a given integer.\n If the integer is positive, return the number as is.\n If the integer is negative, return the number multiplied by -1.\n\n Example:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "es": "Escribe una función de Shell `absolute_value() {` para resolver el siguiente problema: Calcular el valor absoluto de un entero dado.\n Si el entero es positivo, devuelve el número tal cual.\n Si el entero es negativo, devuelve el número multiplicado por -1.\n\n Ejemplo:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "arb": "اكتب دالة شل `absolute_value() {` لحل المشكلة التالية: حساب القيمة المطلقة لعدد صحيح معين.\n إذا كان العدد الصحيح موجبًا، أعد الرقم كما هو.\n إذا كان العدد الصحيح سالبًا، أعد الرقم مضروبًا في -1.\n\n مثال:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "sw": "Andika kazi ya Shell `absolute_value() {` kutatua tatizo lifuatalo: Hesabu thamani kamili ya nambari nzima iliyotolewa.\n Ikiwa nambari ni chanya, rudisha nambari kama ilivyo.\n Ikiwa nambari ni hasi, rudisha nambari iliyozidishwa na -1.\n\n Mfano:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "tr": "Bir Shell fonksiyonu `absolute_value() {` yazın: Verilen bir tam sayının mutlak değerini hesaplayın.\n Eğer tam sayı pozitifse, sayıyı olduğu gibi döndürün.\n Eğer tam sayı negatifse, sayıyı -1 ile çarparak döndürün.\n\n Örnek:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "vi": "Viết một hàm Shell `absolute_value() {` để giải quyết vấn đề sau: Tính giá trị tuyệt đối của một số nguyên cho trước.\n Nếu số nguyên là dương, trả về số đó như là.\n Nếu số nguyên là âm, trả về số đó nhân với -1.\n\n Ví dụ:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9978460521480577",
      "sw": "0.9860301266714353",
      "tr": "0.8862946342677214",
      "vi": "0.9934996221502522"
    },
    "level": "easy",
    "test": "test_absolute_value() {\n    [[ $(absolute_value 95) -eq 95 ]] || { echo \"Test 1 failed\"; exit 1; }\n    [[ $(absolute_value -95) -eq 95 ]] || { echo \"Test 2 failed\"; exit 1; }\n    [[ $(absolute_value 0) -eq 0 ]] || { echo \"Test 3 failed\"; exit 1; }\n    [[ $(absolute_value 10000) -eq 10000 ]] || { echo \"Test 4 failed\"; exit 1; }\n    [[ $(absolute_value -10000) -eq 10000 ]] || { echo \"Test 5 failed\"; exit 1; }\n    [[ $(absolute_value 1) -eq 1 ]] || { echo \"Test 6 failed\"; exit 1; }\n    [[ $(absolute_value -1) -eq 1 ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_absolute_value",
    "entry_point": "absolute_value",
    "signature": "absolute_value() {",
    "docstring": {
      "en": " Calculate the absolute value of a given integer.\n If the integer is positive, return the number as is.\n If the integer is negative, return the number multiplied by -1.\n\n Example:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "es": "Calcular el valor absoluto de un número entero dado.  \nSi el número entero es positivo, devuelve el número tal cual.  \nSi el número entero es negativo, devuelve el número multiplicado por -1.\n\nEjemplo:\n>>> absolute_value 95\n95\n>>> absolute_value -95\n95\n>>> absolute_value 0\n0",
      "arb": "احسب القيمة المطلقة لعدد صحيح معين.  \nإذا كان العدد الصحيح موجبًا، قم بإرجاع الرقم كما هو.  \nإذا كان العدد الصحيح سالبًا، قم بإرجاع الرقم مضروبًا في -1.  \n\nمثال:  \n>>> absolute_value 95  \n95  \n>>> absolute_value -95  \n95  \n>>> absolute_value 0  \n0  ",
      "sw": " Hesabu thamani kamili ya nambari nzima iliyotolewa.\n Ikiwa nambari nzima ni chanya, rudisha nambari kama ilivyo.\n Ikiwa nambari nzima ni hasi, rudisha nambari iliyozidishwa na -1.\n\n Mfano:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "tr": " Belirtilen bir tamsayının mutlak değerini hesapla.\n Eğer tamsayı pozitifse, sayıyı olduğu gibi döndür.\n Eğer tamsayı negatifse, sayıyı -1 ile çarparak döndür.\n\n Örnek:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "vi": "Tính giá trị tuyệt đối của một số nguyên cho trước.  \nNếu số nguyên là dương, trả về số đó như là.  \nNếu số nguyên là âm, trả về số đó nhân với -1.\n\nVí dụ:  \n>>> absolute_value 95  \n95  \n>>> absolute_value -95  \n95  \n>>> absolute_value 0  \n0  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9885586914220094",
      "sw": "0.9944707260831318",
      "tr": "1",
      "vi": "0.9751932503429338"
    }
  }
]