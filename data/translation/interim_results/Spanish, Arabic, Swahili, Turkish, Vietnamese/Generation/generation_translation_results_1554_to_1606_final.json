[
  {
    "task_id": "Rust/1",
    "prompt": {
      "en": "\n /*\n  Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n ",
      "es": " /*\n  Verificar si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{",
      "arb": " /*\n  تحقق مما إذا كان في قائمة الأرقام المعطاة، يوجد أي رقمين أقرب إلى بعضهما من العتبة المعطاة.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "sw": " /*\n  Angalia kama katika orodha iliyotolewa ya nambari, kuna nambari mbili zozote ambazo ziko karibu zaidi na kila mmoja kuliko kizingiti kilichotolewa.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "tr": " /*\n  Verilen sayı listesindeki herhangi iki sayının\n  verilen eşikten daha yakın olup olmadığını kontrol edin.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "vi": " /*\n  Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn\n  ngưỡng đã cho hay không.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n"
    },
    "prompt_bertscore": {
      "es": "0.9826371225025973",
      "arb": "0.9796838859973706",
      "sw": "0.9700010521826818",
      "tr": "0.9741853997895629",
      "vi": "0.9796838859973706"
    },
    "canonical_solution": "\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n ",
    "instruction": {
      "en": "Write a Rust function `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\n  given threshold.",
      "es": "Escribe una función en Rust `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` para resolver el siguiente problema:\nVerifica si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.",
      "arb": "اكتب دالة Rust `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` لحل المشكلة التالية:\nتحقق مما إذا كان في قائمة الأرقام المعطاة، هناك أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.",
      "sw": "Andika kazi ya Rust `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` kutatua tatizo lifuatalo:\nAngalia kama katika orodha iliyotolewa ya namba, kuna namba mbili zozote zilizo karibu zaidi kuliko \n  kizingiti kilichotolewa.",
      "tr": "Bir Rust fonksiyonu `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` yazın: \nVerilen sayı listesinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol edin.",
      "vi": "Viết một hàm Rust `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` để giải quyết vấn đề sau:\nKiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho không."
    },
    "instruction_bertscore": {
      "es": "0.9731284875320761",
      "arb": "0.9838793569055895",
      "sw": "0.9648873130229387",
      "tr": "0.9440531709865703",
      "vi": "0.9838793569055895"
    },
    "level": "easy",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n  #[test]\n  fn test_has_close_elements() {\n  assert_eq!(has_close_elements(vec![11.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n  assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n  assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n  }\n \n }\n ",
    "entry_point": "has_close_elements",
    "signature": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{",
    "docstring": {
      "en": "Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.",
      "es": "Verifica si en la lista dada de números, hay dos números que estén más cerca entre sí que el umbral dado.",
      "arb": "التحقق مما إذا كان في قائمة الأرقام المعطاة، يوجد أي رقمين أقرب إلى بعضهما البعض من العتبة المحددة.",
      "sw": "Angalia ikiwa katika orodha iliyotolewa ya nambari, kuna nambari mbili ambazo ziko karibu zaidi kuliko kizingiti kilichopewa.",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.",
      "vi": "Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không."
    },
    "docstring_bertscore": {
      "es": "0.9226362474122456",
      "arb": "0.938062478694558",
      "sw": "0.8841547891728325",
      "tr": "0.8800314210929293",
      "vi": "0.8824644446302257"
    }
  },
  {
    "task_id": "Rust/2",
    "prompt": {
      "en": "\n /*\n  Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n ",
      "es": " /*\n  La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es\n  separar esos grupos en cadenas separadas y devolver la lista de estos.\n  Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí.\n  Ignorar cualquier espacio en la cadena de entrada.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "arb": " /*\n  الإدخال لهذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو\n  فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بها.\n  المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض\n  تجاهل أي مسافات في سلسلة الإدخال.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "sw": " /*\n  Ingizo kwa kazi hii ni kamba inayo na makundi mengi ya mabano yaliyojificha. Lengo lako ni\n  kutenganisha makundi hayo kuwa kamba tofauti na kurudisha orodha ya hizo.\n  Makundi tofauti yamebalansiwa (kila kifungua mabano kinafungwa ipasavyo) na hayajafichwa ndani ya kila moja\n  Puuza nafasi zozote kwenye kamba ya ingizo.\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "tr": " /*\n  Bu fonksiyona girdi, birden fazla iç içe parantez grubu içeren bir dizedir. Amacınız,\n  bu grupları ayrı dizelere ayırmak ve bunların listesini döndürmektir.\n  Ayrı gruplar dengelidir (her açık parantez doğru şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir.\n  Girdi dizesindeki boşlukları görmezden gelin.\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{",
      "vi": " /*\n  Đầu vào của hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là\n  tách các nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó.\n  Các nhóm riêng biệt là cân bằng (mỗi dấu mở được đóng đúng cách) và không lồng vào nhau\n  Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n"
    },
    "prompt_bertscore": {
      "es": "0.9590908812435786",
      "arb": "0.9485271216890001",
      "sw": "0.9459719404673673",
      "tr": "0.9614945074844817",
      "vi": "0.9557534935814304"
    },
    "canonical_solution": "\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n ",
    "instruction": {
      "en": "Write a Rust function `fn separate_paren_groups(paren_string: String) -> Vec<String>{` to solve the following problem:\nInput to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.",
      "es": "Escribe una función en Rust `fn separate_paren_groups(paren_string: String) -> Vec<String>{` para resolver el siguiente problema:\nLa entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es\n  separar esos grupos en cadenas separadas y devolver la lista de estas.\n  Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí.\n  Ignora cualquier espacio en la cadena de entrada.",
      "arb": "اكتب دالة Rust `fn separate_paren_groups(paren_string: String) -> Vec<String>{` لحل المشكلة التالية:\nالإدخال لهذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو\nفصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بها.\nالمجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض.\nتجاهل أي مسافات في سلسلة الإدخال.",
      "sw": "Andika kazi ya Rust `fn separate_paren_groups(paren_string: String) -> Vec<String>{` kutatua tatizo lifuatalo:\nIngizo kwa kazi hii ni kamba inayojumuisha vikundi vingi vya mabano yaliyopachikwa. Lengo lako ni\n  kutenganisha vikundi hivyo katika kamba tofauti na kurudisha orodha ya hizo.\n  Vikundi vilivyotenganishwa vina uwiano (kila bano la kufungua limefungwa ipasavyo) na havijapachikwa ndani ya kila kimoja\n  Puuzia nafasi zozote kwenye kamba ya ingizo.",
      "tr": "Bir Rust fonksiyonu `fn separate_paren_groups(paren_string: String) -> Vec<String>{` yazın:\nBu fonksiyona girdi, birden fazla iç içe geçmiş parantez grubunu içeren bir dizedir. Amacınız, bu grupları ayrı dizelere ayırmak ve bunların listesini döndürmektir.\nAyrı gruplar dengelidir (her açık parantez düzgün bir şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir.\nGirdi dizesindeki boşlukları yok sayın.",
      "vi": "Viết một hàm Rust `fn separate_paren_groups(paren_string: String) -> Vec<String>{` để giải quyết vấn đề sau:\nĐầu vào của hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là\n  tách các nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó.\n  Các nhóm riêng biệt là cân bằng (mỗi dấu mở được đóng đúng cách) và không lồng vào nhau.\n  Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào."
    },
    "instruction_bertscore": {
      "es": "0.9490344236821632",
      "arb": "0.9489643071576579",
      "sw": "0.9382313145184377",
      "tr": "0.9094158065113255",
      "vi": "0.9294623790868906"
    },
    "level": "middle",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_separate_paren_groups() {\n  assert_eq!(\n  separate_paren_groups(String::from(\"(()()) ((())) () ((())()())\")),\n  vec![\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"() (()) ((())) (((())))\")),\n  vec![\"()\", \"(())\", \"((()))\", \"(((())))\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"(()(())((())))\")),\n  vec![\"(()(())((())))\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"( ) (( )) (( )( ))\")),\n  vec![\"()\", \"(())\", \"(()())\"]\n  );\n  }\n \n }\n ",
    "entry_point": "separate_paren_groups",
    "signature": "fn separate_paren_groups(paren_string: String) -> Vec<String>{",
    "docstring": {
      "en": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.",
      "es": "La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es separar esos grupos en cadenas separadas y devolver la lista de estos. Los grupos separados están equilibrados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí. Ignora cualquier espacio en la cadena de entrada.",
      "arb": "مدخل هذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بها. المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وغير متداخلة مع بعضها البعض. تجاهل أي مسافات في سلسلة المدخلات.",
      "sw": "Ingizo kwa kazi hii ni kamba yenye vikundi vingi vya mabano yaliyopachikwa. Lengo lako ni\n  kutenganisha vikundi hivyo katika kamba tofauti na kurudisha orodha ya hivyo.\n  Vikundi tofauti vimebalansishwa (kila mabano ya kufungua yamefungwa ipasavyo) na havijapachikwa ndani ya kila mmoja.\n  Puuzia nafasi zozote kwenye kamba ya ingizo.",
      "tr": "Bu fonksiyona girdi, birden fazla iç içe geçmiş parantez grubunu içeren bir dizedir. Amacınız, bu grupları ayrı dizelere ayırmak ve bunların listesini döndürmektir. Ayrı gruplar dengelidir (her açılış parantezi düzgün bir şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir. Girdi dizesindeki boşlukları yok sayın.",
      "vi": "Đầu vào cho hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là tách những nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó. Các nhóm riêng biệt là cân bằng (mỗi dấu ngoặc mở được đóng đúng cách) và không lồng vào nhau. Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào."
    },
    "docstring_bertscore": {
      "es": "0.9240973724951381",
      "arb": "0.8930603823065317",
      "sw": "0.8925489090753669",
      "tr": "0.901334529458921",
      "vi": "0.9090588677166057"
    }
  },
  {
    "task_id": "Rust/3",
    "prompt": {
      "en": "\n /*\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n ",
      "es": " /*\n  Dado un número de punto flotante positivo, se puede descomponer en\n  una parte entera (el entero más grande menor que el número dado) y decimales\n  (parte sobrante siempre menor que 1).\n \n  Devuelve la parte decimal del número.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "arb": " /*\n  بالنظر إلى عدد عشري موجب، يمكن تقسيمه إلى جزء صحيح (أكبر عدد صحيح أصغر من العدد المعطى) وأجزاء عشرية\n  (الجزء المتبقي دائماً أصغر من 1).\n \n  أعد الجزء العشري من العدد.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{",
      "sw": " /*\n  Ukipewa nambari chanya ya nukta inayotembea, inaweza kugawanywa katika\n  sehemu ya nambari kamili (nambari kamili kubwa zaidi ndogo kuliko nambari iliyotolewa) na desimali\n  (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n \n  Rudisha sehemu ya desimali ya nambari.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{",
      "tr": " /*\n  Pozitif bir kayan nokta sayısı verildiğinde, bu sayı bir tamsayı kısmına\n  (verilen sayıdan küçük en büyük tamsayı) ve ondalık kısma\n  (her zaman 1'den küçük kalan kısım) ayrılabilir.\n \n  Sayının ondalık kısmını döndür.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "vi": " /*\n  Cho một số thực dương, nó có thể được phân tách thành\n  phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n  (phần còn lại luôn nhỏ hơn 1).\n\n  Trả về phần thập phân của số.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{"
    },
    "prompt_bertscore": {
      "es": "0.9695894900331776",
      "arb": "0.95638295325893",
      "sw": "0.9488048069616869",
      "tr": "0.9357770375303707",
      "vi": "0.9518132627128413"
    },
    "canonical_solution": "\n  return number % 1.0;\n }\n ",
    "instruction": {
      "en": "Write a Rust function `fn truncate_number(number: &f32) -> f32{` to solve the following problem:\nGiven a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.",
      "es": "Escribe una función de Rust `fn truncate_number(number: &f32) -> f32{` para resolver el siguiente problema:\nDado un número de punto flotante positivo, se puede descomponer en\n  una parte entera (el entero más grande menor que el número dado) y decimales\n  (parte sobrante siempre menor que 1).\n \n  Devuelve la parte decimal del número.",
      "arb": "اكتب دالة Rust `fn truncate_number(number: &f32) -> f32{` لحل المشكلة التالية:\nبالنظر إلى رقم عشري موجب، يمكن تقسيمه إلى\nجزء صحيح (أكبر عدد صحيح أصغر من الرقم المعطى) وأجزاء عشرية\n(الجزء المتبقي دائماً أصغر من 1).\n\nأعد الجزء العشري من الرقم.",
      "sw": "Andika kazi ya Rust `fn truncate_number(number: &f32) -> f32{` kutatua tatizo lifuatalo:  \nKwa kuzingatia nambari chanya ya nukta inayozunguka, inaweza kugawanywa kuwa sehemu ya nambari kamili (nambari kamili kubwa zaidi ndogo kuliko nambari iliyotolewa) na desimali (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n\nRudisha sehemu ya desimali ya nambari.",
      "tr": "Bir Rust fonksiyonu `fn truncate_number(number: &f32) -> f32{` yazın ve aşağıdaki problemi çözün:\nPozitif bir kayan nokta sayısı verildiğinde, bu sayı bir tamsayı kısmına (verilen sayıdan küçük en büyük tamsayı) ve ondalık kısmına (her zaman 1'den küçük kalan kısım) ayrılabilir.\n\nSayının ondalık kısmını döndürün.",
      "vi": "Viết một hàm Rust `fn truncate_number(number: &f32) -> f32{` để giải quyết vấn đề sau:\nCho một số thực dương, nó có thể được phân tách thành\n  phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n  (phần còn lại luôn nhỏ hơn 1).\n \n  Trả về phần thập phân của số đó."
    },
    "instruction_bertscore": {
      "es": "0.9594954913297467",
      "arb": "0.9199817510000953",
      "sw": "0.9151401354623699",
      "tr": "0.9158319650795144",
      "vi": "0.9091744705983681"
    },
    "level": "easy",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_truncate_number() {\n  assert_eq!(truncate_number(&3.5), 0.5);\n  let t1: f32 = 1.33 - 0.33;\n  assert!(truncate_number(&t1) < 0.000001);\n  let t2: f32 = 123.456 - 0.456;\n  assert!(truncate_number(&t2) < 0.000001);\n  }\n \n }\n ",
    "entry_point": "truncate_number",
    "signature": "fn truncate_number(number: &f32) -> f32{",
    "docstring": {
      "en": "Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.",
      "es": "Dado un número de punto flotante positivo, se puede descomponer en una parte entera (el entero más grande menor que el número dado) y decimales (la parte restante siempre menor que 1).\n\nDevuelve la parte decimal del número.",
      "arb": "بالنظر إلى رقم عشري موجب، يمكن تحليله إلى جزء صحيح (أكبر عدد صحيح أصغر من الرقم المعطى) وأجزاء عشرية (الجزء المتبقي الذي يكون دائماً أصغر من 1).\n\nإرجاع الجزء العشري من الرقم.",
      "sw": "Kwa kupewa nambari chanya ya nukta, inaweza kugawanywa katika sehemu ya nambari kamili (nambari kamili kubwa zaidi ndogo kuliko nambari iliyotolewa) na desimali (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n\nRudisha sehemu ya desimali ya nambari.",
      "tr": "Verilen pozitif bir ondalık sayı, bir tamsayı kısmına (verilen sayıdan küçük en büyük tamsayı) ve ondalık kısımlara (her zaman 1'den küçük kalan kısım) ayrılabilir.\n\nSayının ondalık kısmını döndürün.",
      "vi": "Đưa ra một số thực dương, nó có thể được phân tách thành\n  phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n  (phần dư luôn nhỏ hơn 1).\n \n  Trả về phần thập phân của số."
    },
    "docstring_bertscore": {
      "es": "0.9449336994656979",
      "arb": "0.8914582296531043",
      "sw": "0.8877345058998433",
      "tr": "0.8575961195550387",
      "vi": "0.8659115818266832"
    }
  },
  {
    "task_id": "Rust/4",
    "prompt": {
      "en": " /*\n  You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n ",
      "es": " /*\n  Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con\n  saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y\n  en ese punto la función debe devolver True. De lo contrario, debe devolver False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "arb": " /*\n  لديك قائمة بعمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفر. مهمتك هي اكتشاف ما إذا كان في أي لحظة ينخفض رصيد الحساب إلى ما دون الصفر، وفي تلك اللحظة يجب أن تعيد الدالة True. خلاف ذلك، يجب أن تعيد False.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "sw": " /*\n  Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na\n  salio la sifuri. Kazi yako ni kugundua kama wakati wowote salio la akaunti linashuka chini ya sifuri, na\n  wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "tr": " /*\n  Sıfır bakiye ile başlayan bir banka hesabı üzerinde yapılan para yatırma ve çekme işlemlerinin bir listesini veriyorsunuz. Göreviniz, herhangi bir noktada hesabın bakiyesinin sıfırın altına düşüp düşmediğini tespit etmektir ve bu noktada fonksiyon True döndürmelidir. Aksi takdirde False döndürmelidir.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "vi": " /*\n  Bạn được cung cấp một danh sách các giao dịch gửi tiền và rút tiền trên một tài khoản ngân hàng bắt đầu với\n  số dư bằng không. Nhiệm vụ của bạn là phát hiện nếu tại bất kỳ thời điểm nào số dư của tài khoản giảm xuống dưới không, và\n  tại thời điểm đó hàm nên trả về True. Ngược lại, nó nên trả về False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n"
    },
    "prompt_bertscore": {
      "es": "0.9860865376996492",
      "arb": "0.9662453489380742",
      "sw": "0.9749981953087576",
      "tr": "0.9666489658723371",
      "vi": "0.973691207401548"
    },
    "canonical_solution": "\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n ",
    "instruction": {
      "en": "Write a Rust function `fn below_zero(operations:Vec<i32>) -> bool{` to solve the following problem:\nYou're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.",
      "es": "Escribe una función en Rust `fn below_zero(operations:Vec<i32>) -> bool{` para resolver el siguiente problema:\nSe te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con\nun saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y\nen ese momento la función debería devolver True. De lo contrario, debería devolver False.",
      "arb": "اكتب دالة Rust `fn below_zero(operations:Vec<i32>) -> bool{` لحل المشكلة التالية:\nأنت مُعطى قائمة من عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفر. مهمتك هي اكتشاف ما إذا كان في أي لحظة ينخفض رصيد الحساب إلى ما دون الصفر، وعند تلك النقطة يجب أن تُرجع الدالة True. خلاف ذلك، يجب أن تُرجع False.",
      "sw": "Andika kazi ya Rust `fn below_zero(operations:Vec<i32>) -> bool{` kutatua tatizo lifuatalo:\nUmepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na salio la sifuri. Kazi yako ni kugundua kama wakati wowote salio la akaunti linashuka chini ya sifuri, na wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.",
      "tr": "Bir Rust fonksiyonu `fn below_zero(operations:Vec<i32>) -> bool{` yazın ve aşağıdaki problemi çözün:\nBir bankadaki sıfır bakiyeyle başlayan bir hesap üzerinde yapılan para yatırma ve çekme işlemlerinin bir listesini veriliyor. Göreviniz, herhangi bir noktada hesap bakiyesinin sıfırın altına düşüp düşmediğini tespit etmektir ve bu noktada fonksiyon True döndürmelidir. Aksi takdirde False döndürmelidir.",
      "vi": "Viết một hàm Rust `fn below_zero(operations:Vec<i32>) -> bool{` để giải quyết vấn đề sau:\nBạn được cung cấp một danh sách các giao dịch nạp và rút tiền trên một tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ thời điểm nào số dư của tài khoản có giảm xuống dưới không, và tại thời điểm đó hàm sẽ trả về True. Ngược lại, nó sẽ trả về False."
    },
    "instruction_bertscore": {
      "es": "0.9664076299593797",
      "arb": "0.9601718277771705",
      "sw": "0.9601718277771705",
      "tr": "0.932704622796523",
      "vi": "0.9537763267686091"
    },
    "level": "easy",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_below_zero() {\n  assert_eq!(below_zero(vec![]), false);\n  assert_eq!(below_zero(vec![1, 2, -3, 1, 2, -3]), false);\n  assert_eq!(below_zero(vec![1, 2, -4, 5, 6]), true);\n  assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n  assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n  assert_eq!(below_zero(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n  }\n \n }\n ",
    "entry_point": "below_zero",
    "signature": "fn below_zero(operations:Vec<i32>) -> bool{",
    "docstring": {
      "en": "You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.",
      "es": "Se le proporciona una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con un saldo cero. Su tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y en ese momento la función debe devolver True. De lo contrario, debe devolver False.",
      "arb": "أنت مُعطى قائمة من عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفر. مهمتك هي اكتشاف ما إذا كان في أي لحظة ينخفض رصيد الحساب إلى ما دون الصفر، وفي هذه الحالة يجب أن تُرجع الدالة القيمة True. خلاف ذلك، يجب أن تُرجع القيمة False.",
      "sw": "Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti linashuka chini ya sifuri, na wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.",
      "tr": "Size sıfır bakiye ile başlayan bir banka hesabı üzerinde yapılan para yatırma ve çekme işlemlerinin bir listesi verilmektedir. Göreviniz, herhangi bir noktada hesabın bakiyesinin sıfırın altına düşüp düşmediğini tespit etmektir ve bu noktada fonksiyon True döndürmelidir. Aksi takdirde, False döndürmelidir.",
      "vi": "Bạn được cung cấp một danh sách các giao dịch gửi tiền và rút tiền trên một tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện nếu tại bất kỳ thời điểm nào số dư của tài khoản giảm xuống dưới không, và tại thời điểm đó hàm nên trả về True. Nếu không, nó nên trả về False."
    },
    "docstring_bertscore": {
      "es": "0.9539074228200921",
      "arb": "0.9127261804416529",
      "sw": "0.9308094903310691",
      "tr": "0.9146890458670397",
      "vi": "0.9433972934683931"
    }
  },
  {
    "task_id": "Rust/5",
    "prompt": {
      "en": "\n /*\n  For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n ",
      "es": " /*\n  Para una lista dada de números de entrada, calcular la Desviación Absoluta Media\n  alrededor de la media de este conjunto de datos.\n  La Desviación Absoluta Media es la diferencia absoluta promedio entre cada\n  elemento y un punto central (la media en este caso):\n  MAD = promedio | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "arb": " /*\n  لحساب الانحراف المطلق المتوسط لقائمة معينة من الأرقام المدخلة\n  حول متوسط هذه المجموعة من البيانات.\n  الانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل\n  عنصر ونقطة مركزية (المتوسط في هذه الحالة):\n  MAD = المتوسط | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "sw": " /*\n  Kwa orodha iliyotolewa ya namba za ingizo, hesabu Mkengeuko wa Wastani wa Kawaida\n  kuzunguka wastani wa seti hii ya data.\n  Mkengeuko wa Wastani wa Kawaida ni wastani wa tofauti ya kawaida kati ya kila\n  kipengele na sehemu ya katikati (wastani katika kesi hii):\n  MAD = wastani | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{",
      "tr": " /*\n  Verilen bir sayı listesi için, bu veri kümesinin ortalaması etrafındaki Ortalama Mutlak Sapmayı hesaplayın.\n  Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:\n  OMS = ortalama | x - x_ortalama |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "vi": " /*\n  Đối với một danh sách các số đầu vào đã cho, tính Độ lệch tuyệt đối trung bình\n  xung quanh giá trị trung bình của tập dữ liệu này.\n  Độ lệch tuyệt đối trung bình là trung bình của sự khác biệt tuyệt đối giữa mỗi\n  phần tử và một điểm trung tâm (trung bình trong trường hợp này):\n  MAD = trung bình | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n"
    },
    "prompt_bertscore": {
      "es": "0.9719069106887116",
      "arb": "0.9512638510788988",
      "sw": "0.9643037369634582",
      "tr": "0.9672162542405728",
      "vi": "0.9672927269372712"
    },
    "canonical_solution": "\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n ",
    "instruction": {
      "en": "Write a Rust function `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` to solve the following problem:\nFor a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |",
      "es": "Escribe una función en Rust `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` para resolver el siguiente problema:\nPara una lista dada de números de entrada, calcula la Desviación Absoluta Media\n  alrededor de la media de este conjunto de datos.\n  La Desviación Absoluta Media es la diferencia absoluta promedio entre cada\n  elemento y un punto central (la media en este caso):\n  MAD = promedio | x - x_mean |",
      "arb": "اكتب دالة Rust `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` لحل المشكلة التالية:\nبالنسبة لقائمة معينة من الأرقام المدخلة، احسب الانحراف المطلق المتوسط\nحول متوسط هذه المجموعة من البيانات.\nالانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل\nعنصر ونقطة مركزية (المتوسط في هذه الحالة):\nMAD = average | x - x_mean |",
      "sw": "Andika kazi ya Rust `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` kutatua tatizo lifuatalo:\nKwa orodha iliyotolewa ya namba za ingizo, hesabu Upotofu Wastani wa Absolute\n  kuzunguka wastani wa seti hii ya data.\n  Upotofu Wastani wa Absolute ni tofauti ya wastani ya absolute kati ya kila\n  kipengele na kituo (wastani katika kesi hii):\n  MAD = wastani | x - x_mean |",
      "tr": "Bir Rust fonksiyonu `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` yazın:\nVerilen bir sayı listesinin etrafında Ortalama Mutlak Sapmayı hesaplayın.\n  Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:\n  MAD = average | x - x_mean |",
      "vi": "Viết một hàm Rust `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` để giải quyết vấn đề sau:\nĐối với một danh sách các số đầu vào, tính Độ lệch tuyệt đối trung bình\nxung quanh giá trị trung bình của tập dữ liệu này.\nĐộ lệch tuyệt đối trung bình là trung bình của các chênh lệch tuyệt đối giữa mỗi\nphần tử và một điểm trung tâm (trong trường hợp này là giá trị trung bình):\nMAD = trung bình | x - x_mean |"
    },
    "instruction_bertscore": {
      "es": "0.9667806578149633",
      "arb": "0.9522240303408215",
      "sw": "0.9766621220106868",
      "tr": "0.9229266450293185",
      "vi": "0.9477959632564107"
    },
    "level": "easy",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n  #[test]\n  fn test_mean_absolute_deviation() {\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0]) - 2.0 / 3.0 < 0.000001);\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0]) - 1.0 < 0.000001);\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0 < 0.000001);\n  }\n \n }\n ",
    "entry_point": "mean_absolute_deviation",
    "signature": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{",
    "docstring": {
      "en": "For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |",
      "es": "Para una lista dada de números de entrada, calcular la Desviación Absoluta Media alrededor de la media de este conjunto de datos. La Desviación Absoluta Media es la diferencia absoluta promedio entre cada elemento y un punto central (la media en este caso): MAD = promedio | x - x_mean |",
      "arb": "لحساب الانحراف المطلق المتوسط لقائمة معينة من الأرقام المدخلة\n  حول متوسط هذه المجموعة من البيانات.\n  الانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل\n  عنصر ونقطة مركزية (المتوسط في هذه الحالة):\n  MAD = متوسط | x - x_mean |",
      "sw": "Kwa orodha iliyotolewa ya namba za ingizo, hesabu Mkengeuko Wastani wa Absolute\n  kuzunguka wastani wa seti hii ya data.\n  Mkengeuko Wastani wa Absolute ni wastani wa tofauti ya absolute kati ya kila\n  kipengele na kituo (wastani katika kesi hii):\n  MAD = wastani | x - x_mean |",
      "tr": "Verilen bir giriş numaraları listesi için, bu veri kümesinin ortalaması etrafında Ortalama Mutlak Sapmayı hesaplayın.\nOrtalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:\nMAD = ortalama | x - x_mean |",
      "vi": "Đối với một danh sách các số đầu vào đã cho, tính Độ lệch tuyệt đối trung bình xung quanh giá trị trung bình của tập dữ liệu này. Độ lệch tuyệt đối trung bình là trung bình của sự khác biệt tuyệt đối giữa mỗi phần tử và một điểm trung tâm (trong trường hợp này là giá trị trung bình): MAD = trung bình | x - x_mean |"
    },
    "docstring_bertscore": {
      "es": "0.9595793133505434",
      "arb": "0.8884463971854724",
      "sw": "0.9444605618980728",
      "tr": "0.9586356204102466",
      "vi": "0.9390715210302153"
    }
  },
  {
    "task_id": "Rust/6",
    "prompt": {
      "en": "/*\n  Determines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "es": "/*\n  Determina la longitud de la secuencia contigua más larga de caracteres de 'target' que está contenida en 'source'.\n  La función no requiere que los caracteres estén posicionados consecutivamente en 'source', pero deben mantener su orden de 'target'.\n\n  Argumentos:\n  - source: Una cadena que consiste en letras mayúsculas del alfabeto inglés.\n  - target: Una cadena que consiste en letras mayúsculas del alfabeto inglés.\n\n  Devuelve:\n  - La longitud de la secuencia contigua más larga de caracteres de 'target' que está contenida en 'source'.\n\n  Ejemplo:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") devuelve 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") devuelve 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") devuelve 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "arb": "/*\n  يحدد طول أطول تسلسل متجاور من الأحرف من 'target' الموجود في 'source'.\n  لا تتطلب الدالة أن تكون الأحرف متتالية في 'source'، ولكن يجب أن تحتفظ بترتيبها من 'target'.\n\n  الوسائط:\n  - source: سلسلة تتكون من أحرف إنجليزية كبيرة.\n  - target: سلسلة تتكون من أحرف إنجليزية كبيرة.\n\n  يعيد:\n  - طول أطول تسلسل متجاور من الأحرف من 'target' الموجود في 'source'.\n\n  مثال:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") يعيد 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") يعيد 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") يعيد 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "sw": "/*\n  Huamua urefu wa mlolongo mrefu zaidi wa herufi mfululizo kutoka 'target' ambao unapatikana ndani ya 'source'.\n  Kazi hii haihitaji herufi kuwa zimepangwa mfululizo ndani ya 'source', lakini lazima zibaki katika mpangilio wao kutoka 'target'.\n\n  Hoja:\n  - source: Mlolongo wa herufi zinazojumuisha herufi kubwa za Kiingereza.\n  - target: Mlolongo wa herufi zinazojumuisha herufi kubwa za Kiingereza.\n\n  Inarudisha:\n  - Urefu wa mlolongo mrefu zaidi wa herufi mfululizo kutoka 'target' ambao unapatikana ndani ya 'source'.\n\n  Mfano:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") inarudisha 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") inarudisha 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") inarudisha 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "tr": "/*\n  'target' içindeki en uzun ardışık karakter dizisinin 'source' içinde bulunduğu uzunluğu belirler.\n  Fonksiyon, karakterlerin 'source' içinde ardışık olarak konumlandırılmasını gerektirmez, ancak 'target' içindeki sırayı korumalıdırlar.\n\n  Argümanlar:\n  - source: Büyük harf İngilizce harflerden oluşan bir dize.\n  - target: Büyük harf İngilizce harflerden oluşan bir dize.\n\n  Döndürür:\n  - 'target' içindeki en uzun ardışık karakter dizisinin 'source' içinde bulunduğu uzunluk.\n\n  Örnek:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 döndürür\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 döndürür\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 döndürür\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "vi": "/*\n  Xác định độ dài của chuỗi ký tự liền kề dài nhất từ 'target' có trong 'source'.\n  Hàm không yêu cầu các ký tự phải được đặt liên tiếp trong 'source', nhưng chúng phải giữ nguyên thứ tự từ 'target'.\n\n  Tham số:\n  - source: Một chuỗi gồm các chữ cái tiếng Anh viết hoa.\n  - target: Một chuỗi gồm các chữ cái tiếng Anh viết hoa.\n\n  Trả về:\n  - Độ dài của chuỗi ký tự liền kề dài nhất từ 'target' có trong 'source'.\n\n  Ví dụ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") trả về 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") trả về 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") trả về 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.9727379802029616",
      "arb": "0.9727788980614548",
      "sw": "0.9545372797583538",
      "tr": "0.9587750589377331",
      "vi": "0.9558238087363168"
    },
    "canonical_solution": "{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}",
    "instruction": {
      "en": "Write a Rust function `fn longest_contained_sequence(source: &str, target: &str) -> usize` to solve the following problem:\nDetermines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0",
      "es": "Escribe una función de Rust `fn longest_contained_sequence(source: &str, target: &str) -> usize` para resolver el siguiente problema:\nDetermina la longitud de la secuencia contigua más larga de caracteres de 'target' que está contenida en 'source'.\n  La función no requiere que los caracteres estén posicionados consecutivamente en 'source', pero deben mantener su orden de 'target'.\n\n  Argumentos:\n  - source: Una cadena que consiste en letras mayúsculas del alfabeto inglés.\n  - target: Una cadena que consiste en letras mayúsculas del alfabeto inglés.\n\n  Retorna:\n  - La longitud de la secuencia contigua más larga de caracteres de 'target' que está contenida en 'source'.\n\n  Ejemplo:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") retorna 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") retorna 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") retorna 0",
      "arb": "اكتب دالة بلغة Rust `fn longest_contained_sequence(source: &str, target: &str) -> usize` لحل المشكلة التالية:\nتحدد طول أطول تسلسل متتابع من الأحرف من 'target' الموجود في 'source'.\n  لا تتطلب الدالة أن تكون الأحرف متتابعة في 'source'، ولكن يجب أن تحتفظ بترتيبها من 'target'.\n\n  الوسائط:\n  - source: سلسلة نصية تتكون من أحرف إنجليزية كبيرة.\n  - target: سلسلة نصية تتكون من أحرف إنجليزية كبيرة.\n\n  تعيد:\n  - طول أطول تسلسل متتابع من الأحرف من 'target' الموجود في 'source'.\n\n  مثال:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") يعيد 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") يعيد 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") يعيد 0",
      "sw": "Andika kazi ya Rust `fn longest_contained_sequence(source: &str, target: &str) -> usize` kutatua tatizo lifuatalo:\nInabainisha urefu wa mlolongo mrefu zaidi wa herufi mfululizo kutoka 'target' ambao unapatikana ndani ya 'source'.\n  Kazi hii haihitaji herufi kuwa zimepangwa mfululizo ndani ya 'source', lakini lazima zibaki katika mpangilio wao kutoka 'target'.\n\n  Hoja:\n  - source: Mlolongo wa herufi zinazojumuisha herufi kubwa za Kiingereza.\n  - target: Mlolongo wa herufi zinazojumuisha herufi kubwa za Kiingereza.\n\n  Inarudisha:\n  - Urefu wa mlolongo mrefu zaidi wa herufi mfululizo kutoka 'target' ambao unapatikana ndani ya 'source'.\n\n  Mfano:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") inarudisha 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") inarudisha 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") inarudisha 0",
      "tr": "Bir Rust fonksiyonu `fn longest_contained_sequence(source: &str, target: &str) -> usize` yazın ve aşağıdaki problemi çözün:\n'Target' içindeki karakterlerin 'source' içinde bulunan en uzun ardışık dizisinin uzunluğunu belirler.\n  Fonksiyon, karakterlerin 'source' içinde ardışık olarak konumlandırılmasını gerektirmez, ancak 'target' içindeki sıralarını korumalıdırlar.\n\n  Argümanlar:\n  - source: Büyük harf İngilizce harflerden oluşan bir dize.\n  - target: Büyük harf İngilizce harflerden oluşan bir dize.\n\n  Döndürür:\n  - 'Target' içindeki karakterlerin 'source' içinde bulunan en uzun ardışık dizisinin uzunluğu.\n\n  Örnek:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 döndürür\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 döndürür\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 döndürür",
      "vi": "Viết một hàm Rust `fn longest_contained_sequence(source: &str, target: &str) -> usize` để giải quyết vấn đề sau:\nXác định độ dài của dãy ký tự liên tiếp dài nhất từ 'target' mà có trong 'source'.\n  Hàm không yêu cầu các ký tự phải được đặt liên tiếp trong 'source', nhưng chúng phải giữ nguyên thứ tự từ 'target'.\n\n  Tham số:\n  - source: Một chuỗi gồm các chữ cái tiếng Anh viết hoa.\n  - target: Một chuỗi gồm các chữ cái tiếng Anh viết hoa.\n\n  Trả về:\n  - Độ dài của dãy ký tự liên tiếp dài nhất từ 'target' mà có trong 'source'.\n\n  Ví dụ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") trả về 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") trả về 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") trả về 0"
    },
    "instruction_bertscore": {
      "es": "0.978343130925385",
      "arb": "0.9661208076891653",
      "sw": "0.9641625107625423",
      "tr": "0.9747016401498725",
      "vi": "0.9657197729498559"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_contained_sequence(\"ABCDEABCD\", \"AABZ\"), 3);\n        assert_eq!(longest_contained_sequence(\"XYZ\", \"XYZ\"), 3);\n        assert_eq!(longest_contained_sequence(\"ABCDEF\", \"FED\"), 1);\n        assert_eq!(longest_contained_sequence(\"ABCD\", \"BCD\"), 3);\n    }\n    \n\n}",
    "entry_point": "longest_contained_sequence",
    "signature": "fn longest_contained_sequence(source: &str, target: &str) -> usize",
    "docstring": {
      "en": "Determines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0",
      "es": "Determina la longitud de la secuencia contigua más larga de caracteres de 'target' que está contenida en 'source'.  \nLa función no requiere que los caracteres estén posicionados consecutivamente en 'source', pero deben mantener su orden de 'target'.\n\nArgumentos:\n- source: Una cadena que consiste en letras mayúsculas del alfabeto inglés.\n- target: Una cadena que consiste en letras mayúsculas del alfabeto inglés.\n\nDevuelve:\n- La longitud de la secuencia contigua más larga de caracteres de 'target' que está contenida en 'source'.\n\nEjemplo:\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") devuelve 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") devuelve 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") devuelve 0",
      "arb": "يحدد طول أطول تسلسل متجاور من الأحرف من 'target' الذي يحتويه 'source'. \nلا تتطلب الدالة أن تكون الأحرف متتالية في 'source'، ولكن يجب أن تحتفظ بترتيبها من 'target'.\n\nالأوساط:\n- source: سلسلة تتكون من حروف إنجليزية كبيرة.\n- target: سلسلة تتكون من حروف إنجليزية كبيرة.\n\nالقيم المعادة:\n- طول أطول تسلسل متجاور من الأحرف من 'target' الذي يحتويه 'source'.\n\nمثال:\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") يعيد 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") يعيد 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") يعيد 0",
      "sw": "Inabainisha urefu wa mlolongo mrefu zaidi wa herufi mfululizo kutoka 'target' ambao unapatikana ndani ya 'source'. \n  Kazi hii haihitaji herufi kuwa zimepangwa mfululizo ndani ya 'source', lakini lazima zibaki katika mpangilio wao kutoka 'target'.\n\n  Hoja:\n  - source: Kamba ya herufi inayojumuisha herufi kubwa za Kiingereza.\n  - target: Kamba ya herufi inayojumuisha herufi kubwa za Kiingereza.\n\n  Inarejesha:\n  - Urefu wa mlolongo mrefu zaidi wa herufi mfululizo kutoka 'target' ambao unapatikana ndani ya 'source'.\n\n  Mfano:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") inarejesha 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") inarejesha 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") inarejesha 0",
      "tr": "'Target' içindeki karakterlerin 'source' içinde bulunan en uzun ardışık dizisinin uzunluğunu belirler. \n  Fonksiyon, karakterlerin 'source' içinde ardışık olarak konumlandırılmasını gerektirmez, ancak 'target' içindeki sıralarını korumalıdırlar.\n\n  Argümanlar:\n  - source: Büyük harf İngilizce harflerden oluşan bir dize.\n  - target: Büyük harf İngilizce harflerden oluşan bir dize.\n\n  Döndürür:\n  - 'target' içindeki karakterlerin 'source' içinde bulunan en uzun ardışık dizisinin uzunluğu.\n\n  Örnek:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 döndürür\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 döndürür\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 döndürür",
      "vi": "Xác định độ dài của chuỗi ký tự liền mạch dài nhất từ 'target' có trong 'source'. \nHàm không yêu cầu các ký tự phải được đặt liên tiếp trong 'source', nhưng chúng phải giữ nguyên thứ tự từ 'target'.\n\nCác tham số:\n- source: Một chuỗi gồm các chữ cái tiếng Anh in hoa.\n- target: Một chuỗi gồm các chữ cái tiếng Anh in hoa.\n\nTrả về:\n- Độ dài của chuỗi ký tự liền mạch dài nhất từ 'target' có trong 'source'.\n\nVí dụ:\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") trả về 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") trả về 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.9699869494256284",
      "arb": "0.9647158950041056",
      "sw": "0.9450930010312879",
      "tr": "0.9679084811184794",
      "vi": "0.9584071954720564"
    }
  },
  {
    "task_id": "Rust/7",
    "prompt": {
      "en": "/*\n  Calculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "es": "/*\n  Calcula la puntuación más alta, la puntuación más baja y la puntuación promedio de una lista de puntuaciones de estudiantes.\n  \n  La función toma un vector de puntuaciones enteras, cada una en el rango de 0 a 100, que representan las puntuaciones de los estudiantes en un examen. Devuelve una tupla que contiene la puntuación más alta, la puntuación más baja y la puntuación promedio calculada a partir de estas puntuaciones.\n\n  Argumentos:\n  - scores: Un Vec<i32> que contiene las puntuaciones del examen de los estudiantes.\n\n  Devuelve:\n  - Una tupla (i32, i32, f64), donde el primer elemento es la puntuación más alta, el segundo es la puntuación más baja, y el tercero es la puntuación promedio redondeada a dos decimales.\n\n  Ejemplo:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) devuelve (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) devuelve (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) devuelve (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "arb": "/*\n  يحسب أعلى درجة، وأدنى درجة، ومتوسط الدرجات من قائمة درجات الطلاب.\n  \n  تأخذ الدالة متجهًا من درجات صحيحة، كل منها يتراوح بين 0 إلى 100، ويمثل درجات الطلاب في امتحان. تعيد الدالة زوجًا يحتوي على أعلى درجة، وأدنى درجة، ومتوسط الدرجات المحسوب من هذه الدرجات.\n\n  الوسائط:\n  - scores: متجه Vec<i32> يحتوي على درجات الامتحان للطلاب.\n\n  يعيد:\n  - زوج (i32, i32, f64)، حيث أن العنصر الأول هو أعلى درجة، والثاني هو أدنى درجة، والثالث هو متوسط الدرجات مقربًا إلى منزلتين عشريتين.\n\n  مثال:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) يعيد (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) يعيد (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) يعيد (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "sw": "/*\n  Inahesabu alama ya juu zaidi, alama ya chini zaidi, na wastani wa alama kutoka kwenye orodha ya alama za wanafunzi.\n  \n  Kazi inachukua vector ya alama za nambari kamili, kila moja ikiwa kati ya 0 hadi 100, ikiwakilisha alama za wanafunzi katika mtihani. Inarudisha tuple inayojumuisha alama ya juu zaidi, alama ya chini zaidi, na wastani wa alama uliokokotolewa kutoka kwenye alama hizi.\n\n  Hoja:\n  - scores: A Vec<i32> inayojumuisha alama za mtihani za wanafunzi.\n\n  Inarudisha:\n  - Tuple (i32, i32, f64), ambapo kipengele cha kwanza ni alama ya juu zaidi, cha pili ni alama ya chini zaidi, na cha tatu ni wastani wa alama uliopigwa hadi sehemu mbili za desimali.\n\n  Mfano:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) inarudisha (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) inarudisha (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) inarudisha (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "tr": "/*\n  Bir öğrenci notları listesinden en yüksek notu, en düşük notu ve ortalama notu hesaplar.\n  \n  Fonksiyon, bir sınavda öğrencilerin notlarını temsil eden, 0 ile 100 arasında değişen tamsayı notlarının bir vektörünü alır. Bu notlardan hesaplanan en yüksek notu, en düşük notu ve ortalama notu içeren bir demet döndürür.\n\n  Argümanlar:\n  - scores: Öğrencilerin sınav notlarını içeren bir Vec<i32>.\n\n  Döndürür:\n  - Bir demet (i32, i32, f64), burada ilk eleman en yüksek not, ikinci eleman en düşük not ve üçüncü eleman iki ondalık basamağa yuvarlanmış ortalama nottur.\n\n  Örnek:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) (99, 10, 71.29) döndürür\n  - exam_statistics(vec![100, 85, 76, 90]) (100, 76, 87.75) döndürür\n  - exam_statistics(vec![50, 50, 50, 50]) (50, 50, 50.00) döndürür\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "vi": "/*\n  Tính điểm cao nhất, điểm thấp nhất và điểm trung bình từ danh sách điểm số của học sinh.\n  \n  Hàm nhận vào một vector các điểm số nguyên, mỗi điểm nằm trong khoảng từ 0 đến 100, đại diện cho điểm số của học sinh trong một kỳ thi. Nó trả về một bộ giá trị chứa điểm cao nhất, điểm thấp nhất, và điểm trung bình được tính từ các điểm số này.\n\n  Tham số:\n  - scores: Một Vec<i32> chứa điểm thi của học sinh.\n\n  Trả về:\n  - Một bộ giá trị (i32, i32, f64), trong đó phần tử đầu tiên là điểm cao nhất, phần tử thứ hai là điểm thấp nhất, và phần tử thứ ba là điểm trung bình được làm tròn đến hai chữ số thập phân.\n\n  Ví dụ:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) trả về (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) trả về (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) trả về (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)"
    },
    "prompt_bertscore": {
      "es": "0.974692900413107",
      "arb": "0.9928800939918044",
      "sw": "0.9854582698044358",
      "tr": "0.9846200495964686",
      "vi": "0.9813964771426534"
    },
    "canonical_solution": "{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}",
    "instruction": {
      "en": "Write a Rust function `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` to solve the following problem:\nCalculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "es": "Escribe una función en Rust `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` para resolver el siguiente problema:\nCalcula la puntuación más alta, la puntuación más baja y la puntuación promedio de una lista de puntuaciones de estudiantes.\n\nLa función toma un vector de puntuaciones enteras, cada una en el rango de 0 a 100, representando las puntuaciones de los estudiantes en un examen. Devuelve una tupla que contiene la puntuación más alta, la puntuación más baja y la puntuación promedio calculada a partir de estas puntuaciones.\n\nArgumentos:\n- scores: Un Vec<i32> que contiene las puntuaciones de los estudiantes en el examen.\n\nDevuelve:\n- Una tupla (i32, i32, f64), donde el primer elemento es la puntuación más alta, el segundo es la puntuación más baja, y el tercero es la puntuación promedio redondeada a dos decimales.\n\nEjemplo:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) devuelve (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) devuelve (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) devuelve (50, 50, 50.00)",
      "arb": "اكتب دالة بلغة Rust باسم `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` لحل المشكلة التالية:\nتحسب أعلى درجة، وأدنى درجة، ومتوسط الدرجات من قائمة درجات الطلاب.\n\nتأخذ الدالة متجهًا من الدرجات الصحيحة، تتراوح كل منها من 0 إلى 100، وتمثل درجات الطلاب في الامتحان. وتعيد دالة تحتوي على أعلى درجة، وأدنى درجة، ومتوسط الدرجات المحسوب من هذه الدرجات.\n\nالمعطيات:\n- scores: متجه Vec<i32> يحتوي على درجات الامتحان للطلاب.\n\nالقيم المعادة:\n- دالة (i32, i32, f64)، حيث أن العنصر الأول هو أعلى درجة، والثاني هو أدنى درجة، والثالث هو متوسط الدرجات مقربًا إلى منزلتين عشريتين.\n\nمثال:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) يعيد (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) يعيد (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) يعيد (50, 50, 50.00)",
      "sw": "Andika kazi ya Rust `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` kutatua tatizo lifuatalo:\nInakokotoa alama ya juu zaidi, alama ya chini zaidi, na alama ya wastani kutoka kwenye orodha ya alama za wanafunzi.\n\nKazi hiyo inachukua vekta ya alama za nambari kamili, kila moja ikiwa kati ya 0 hadi 100, ikiwakilisha alama za wanafunzi katika mtihani. Inarudisha tuple inayojumuisha alama ya juu zaidi, alama ya chini zaidi, na alama ya wastani iliyokokotolewa kutoka kwa alama hizi.\n\nHoja:\n- scores: A Vec<i32> yenye alama za mtihani za wanafunzi.\n\nInarudisha:\n- Tuple (i32, i32, f64), ambapo kipengele cha kwanza ni alama ya juu zaidi, cha pili ni alama ya chini zaidi, na cha tatu ni alama ya wastani iliyokatwa hadi sehemu mbili za desimali.\n\nMfano:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) inarudisha (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) inarudisha (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) inarudisha (50, 50, 50.00)",
      "tr": "Bir Rust fonksiyonu `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` yazın ve aşağıdaki problemi çözün:\nBir öğrenci puanları listesinden en yüksek puanı, en düşük puanı ve ortalama puanı hesaplar.\n\n  Fonksiyon, her biri 0 ile 100 arasında değişen, bir sınavda öğrencilerin puanlarını temsil eden bir tam sayı puanları vektörü alır. Bu puanlardan hesaplanan en yüksek puanı, en düşük puanı ve ortalama puanı içeren bir demet döndürür.\n\n  Argümanlar:\n  - scores: Öğrencilerin sınav puanlarını içeren bir Vec<i32>.\n\n  Döndürür:\n  - Bir demet (i32, i32, f64), burada ilk eleman en yüksek puan, ikinci eleman en düşük puan ve üçüncü eleman iki ondalık basamağa yuvarlanmış ortalama puandır.\n\n  Örnek:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) (99, 10, 71.29) döndürür\n  - exam_statistics(vec![100, 85, 76, 90]) (100, 76, 87.75) döndürür\n  - exam_statistics(vec![50, 50, 50, 50]) (50, 50, 50.00) döndürür",
      "vi": "Viết một hàm Rust `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` để giải quyết vấn đề sau:\nTính toán điểm cao nhất, điểm thấp nhất, và điểm trung bình từ danh sách điểm số của học sinh.\n\nHàm nhận vào một vector các điểm số nguyên, mỗi điểm nằm trong khoảng từ 0 đến 100, đại diện cho điểm số của học sinh trong một kỳ thi. Nó trả về một bộ giá trị chứa điểm cao nhất, điểm thấp nhất, và điểm trung bình được tính từ các điểm số này.\n\nTham số:\n- scores: Một Vec<i32> chứa điểm thi của học sinh.\n\nTrả về:\n- Một bộ giá trị (i32, i32, f64), trong đó phần tử đầu tiên là điểm cao nhất, phần tử thứ hai là điểm thấp nhất, và phần tử thứ ba là điểm trung bình được làm tròn đến hai chữ số thập phân.\n\nVí dụ:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) trả về (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) trả về (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) trả về (50, 50, 50.00)"
    },
    "instruction_bertscore": {
      "es": "0.9735344880309115",
      "arb": "0.9670009389075309",
      "sw": "0.9838142061406101",
      "tr": "0.9871289499393203",
      "vi": "0.9854429752650962"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn main() {\n        assert_eq!(exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]), (99, 10, 71.29));\n        assert_eq!(exam_statistics(vec![100, 85, 76, 90]), (100, 76, 87.75));\n        assert_eq!(exam_statistics(vec![50, 50, 50, 50]), (50, 50, 50.00));\n    }\n}",
    "entry_point": "exam_statistics",
    "signature": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
    "docstring": {
      "en": "Calculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "es": "Calcula la puntuación más alta, la puntuación más baja y la puntuación promedio de una lista de puntuaciones de estudiantes.\n\n  La función toma un vector de puntuaciones enteras, cada una en el rango de 0 a 100, que representan las puntuaciones de los estudiantes en un examen. Devuelve una tupla que contiene la puntuación más alta, la puntuación más baja y la puntuación promedio calculada a partir de estas puntuaciones.\n\n  Argumentos:\n  - scores: Un Vec<i32> que contiene las puntuaciones del examen de los estudiantes.\n\n  Retorna:\n  - Una tupla (i32, i32, f64), donde el primer elemento es la puntuación más alta, el segundo es la puntuación más baja, y el tercero es la puntuación promedio redondeada a dos decimales.\n\n  Ejemplo:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) retorna (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) retorna (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) retorna (50, 50, 50.00)",
      "arb": "يحسب أعلى درجة، وأدنى درجة، ومتوسط الدرجات من قائمة درجات الطلاب.\n\nتأخذ الدالة متجهًا من الدرجات الصحيحة، كل منها يتراوح بين 0 إلى 100، ويمثل درجات الطلاب في امتحان. تُرجع دالة تحتوي على أعلى درجة، وأدنى درجة، ومتوسط الدرجات المحسوب من هذه الدرجات.\n\nالحجج:\n- scores: Vec<i32> يحتوي على درجات امتحان الطلاب.\n\nالقيم المعادة:\n- دالة (i32, i32, f64)، حيث أن العنصر الأول هو أعلى درجة، والعنصر الثاني هو أدنى درجة، والعنصر الثالث هو متوسط الدرجات مقربًا إلى منزلتين عشريتين.\n\nمثال:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) يعيد (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) يعيد (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) يعيد (50, 50, 50.00)",
      "sw": "Huhesabu alama ya juu zaidi, alama ya chini zaidi, na alama ya wastani kutoka kwenye orodha ya alama za wanafunzi.\n\n  Kazi hii inachukua vector ya alama za nambari nzima, kila moja ikiwa kati ya 0 hadi 100, ikiwakilisha alama za wanafunzi katika mtihani. Inarudisha tuple inayojumuisha alama ya juu zaidi, alama ya chini zaidi, na alama ya wastani iliyohesabiwa kutoka kwenye alama hizi.\n\n  Hoja:\n  - scores: A Vec<i32> inayojumuisha alama za mtihani za wanafunzi.\n\n  Inarudisha:\n  - Tuple (i32, i32, f64), ambapo kipengele cha kwanza ni alama ya juu zaidi, cha pili ni alama ya chini zaidi, na cha tatu ni alama ya wastani iliyokokotolewa hadi sehemu mbili za desimali.\n\n  Mfano:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) inarudisha (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) inarudisha (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) inarudisha (50, 50, 50.00)",
      "tr": "En yüksek puanı, en düşük puanı ve bir öğrenci puanları listesinden ortalama puanı hesaplar.\n\n  Fonksiyon, bir sınavda öğrencilerin puanlarını temsil eden, her biri 0 ile 100 arasında değişen bir tamsayı puanları vektörünü alır. Bu puanlardan hesaplanan en yüksek puanı, en düşük puanı ve ortalama puanı içeren bir demet döndürür.\n\n  Argümanlar:\n  - scores: Öğrencilerin sınav puanlarını içeren bir Vec<i32>.\n\n  Döndürülenler:\n  - Bir demet (i32, i32, f64), burada ilk eleman en yüksek puan, ikincisi en düşük puan ve üçüncüsü iki ondalık basamağa yuvarlanmış ortalama puandır.\n\n  Örnek:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) (99, 10, 71.29) döndürür\n  - exam_statistics(vec![100, 85, 76, 90]) (100, 76, 87.75) döndürür\n  - exam_statistics(vec![50, 50, 50, 50]) (50, 50, 50.00) döndürür",
      "vi": "Tính điểm cao nhất, điểm thấp nhất và điểm trung bình từ danh sách điểm số của học sinh.\n\nHàm này nhận một vector điểm số nguyên, mỗi điểm nằm trong khoảng từ 0 đến 100, đại diện cho điểm số của học sinh trong một kỳ thi. Nó trả về một bộ giá trị chứa điểm cao nhất, điểm thấp nhất và điểm trung bình được tính từ các điểm số này.\n\nĐối số:\n- scores: Một Vec<i32> chứa điểm thi của học sinh.\n\nTrả về:\n- Một bộ giá trị (i32, i32, f64), trong đó phần tử đầu tiên là điểm cao nhất, phần tử thứ hai là điểm thấp nhất, và phần tử thứ ba là điểm trung bình được làm tròn đến hai chữ số thập phân.\n\nVí dụ:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) trả về (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) trả về (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) trả về (50, 50, 50.00)"
    },
    "docstring_bertscore": {
      "es": "0.9727091787977116",
      "arb": "0.9746776058737673",
      "sw": "0.9832157328025519",
      "tr": "0.9969162633344334",
      "vi": "0.976987279944441"
    }
  },
  {
    "task_id": "Rust/8",
    "prompt": {
      "en": "/*\n  Calculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "es": "/*\n  Calcula la suma de puntuaciones para todas las subcadenas no vacías de una cadena dada, donde la puntuación de una subcadena se define como el conteo de caracteres que aparecen exactamente una vez en ella.\n\n  Argumentos:\n  - s: Una cadena que consiste en letras minúsculas del alfabeto inglés.\n\n  Devuelve:\n  - Un entero que representa la suma total de puntuaciones para todas las subcadenas no vacías.\n\n  Ejemplo:\n  - sum_of_unique_chars_scores(\"abc\") devuelve 10 (Puntuaciones: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") devuelve 4 (Puntuaciones: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "arb": "/*\n  يحسب مجموع الدرجات لجميع المقاطع غير الفارغة من سلسلة معينة، حيث يتم تعريف درجة المقطع على أنها عدد الأحرف التي تظهر مرة واحدة بالضبط فيه.\n\n  الحجج:\n  - s: سلسلة تتكون من أحرف إنجليزية صغيرة.\n\n  يعيد:\n  - عدد صحيح يمثل مجموع الدرجات الكلي لجميع المقاطع غير الفارغة.\n\n  مثال:\n  - sum_of_unique_chars_scores(\"abc\") يعيد 10 (الدرجات: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") يعيد 4 (الدرجات: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "sw": "/*\n  Inahesabu jumla ya alama za vifungu vidogo vyote visivyo tupu vya kamba fulani, ambapo alama ya kifungu kidogo inafafanuliwa kama idadi ya herufi zinazotokea mara moja tu ndani yake.\n\n  Hoja:\n  - s: Kamba inayojumuisha herufi ndogo za Kiingereza.\n\n  Inarejesha:\n  - Nambari nzima inayowakilisha jumla ya alama za vifungu vidogo vyote visivyo tupu.\n\n  Mfano:\n  - sum_of_unique_chars_scores(\"abc\") inarejesha 10 (Alama: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") inarejesha 4 (Alama: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "tr": "/*\n  Verilen bir stringin tüm boş olmayan alt dizelerinin puanlarının toplamını hesaplar. Bir alt dizenin puanı, içinde tam olarak bir kez görünen karakterlerin sayısı olarak tanımlanır.\n\n  Argümanlar:\n  - s: Küçük harfli İngilizce harflerden oluşan bir string.\n\n  Döndürür:\n  - Tüm boş olmayan alt dizelerin puanlarının toplamını temsil eden bir tamsayı.\n\n  Örnek:\n  - sum_of_unique_chars_scores(\"abc\") 10 döndürür (Puanlar: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 döndürür (Puanlar: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "vi": "/*\n  Tính tổng điểm của tất cả các chuỗi con không rỗng của một chuỗi cho trước, trong đó điểm của một chuỗi con được định nghĩa là số ký tự xuất hiện chính xác một lần trong chuỗi đó.\n\n  Tham số:\n  - s: Một chuỗi bao gồm các chữ cái tiếng Anh viết thường.\n\n  Trả về:\n  - Một số nguyên đại diện cho tổng điểm của tất cả các chuỗi con không rỗng.\n\n  Ví dụ:\n  - sum_of_unique_chars_scores(\"abc\") trả về 10 (Điểm: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") trả về 4 (Điểm: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9869247579076165",
      "arb": "0.9957218988532706",
      "sw": "0.9743355643576253",
      "tr": "0.9866081410802469",
      "vi": "0.9761210528527479"
    },
    "canonical_solution": "{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}",
    "instruction": {
      "en": "Write a Rust function `fn sum_of_unique_chars_scores(s: &str) -> i32` to solve the following problem:\nCalculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "es": "Escribe una función de Rust `fn sum_of_unique_chars_scores(s: &str) -> i32` para resolver el siguiente problema:\nCalcula la suma de puntuaciones para todas las subcadenas no vacías de una cadena dada, donde la puntuación de una subcadena se define como el conteo de caracteres que aparecen exactamente una vez en ella.\n\n  Argumentos:\n  - s: Una cadena que consiste en letras minúsculas del alfabeto inglés.\n\n  Retorna:\n  - Un entero que representa la suma total de puntuaciones para todas las subcadenas no vacías.\n\n  Ejemplo:\n  - sum_of_unique_chars_scores(\"abc\") retorna 10 (Puntuaciones: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") retorna 4 (Puntuaciones: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "arb": "اكتب دالة بلغة Rust `fn sum_of_unique_chars_scores(s: &str) -> i32` لحل المشكلة التالية:\nتحسب مجموع النقاط لجميع الأجزاء الفرعية غير الفارغة من سلسلة معينة، حيث يتم تعريف نقطة الجزء الفرعي على أنها عدد الأحرف التي تظهر مرة واحدة بالضبط فيه.\n\n  الوسيطات:\n  - s: سلسلة تتكون من حروف إنجليزية صغيرة.\n\n  تعيد:\n  - عدد صحيح يمثل المجموع الكلي للنقاط لجميع الأجزاء الفرعية غير الفارغة.\n\n  مثال:\n  - sum_of_unique_chars_scores(\"abc\") تعيد 10 (النقاط: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") تعيد 4 (النقاط: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "sw": "Andika kazi ya Rust `fn sum_of_unique_chars_scores(s: &str) -> i32` kutatua tatizo lifuatalo:\nHesabu jumla ya alama kwa vifungu vyote visivyo tupu vya kamba iliyotolewa, ambapo alama ya kifungu inafafanuliwa kama idadi ya herufi zinazotokea mara moja tu ndani yake.\n\n  Hoja:\n  - s: Kamba inayojumuisha herufi ndogo za Kiingereza.\n\n  Inarudisha:\n  - Nambari kamili inayowakilisha jumla ya alama kwa vifungu vyote visivyo tupu.\n\n  Mfano:\n  - sum_of_unique_chars_scores(\"abc\") inarudisha 10 (Alama: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") inarudisha 4 (Alama: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "tr": "Bir Rust fonksiyonu `fn sum_of_unique_chars_scores(s: &str) -> i32` yazın ve aşağıdaki problemi çözün:\nVerilen bir dizgenin tüm boş olmayan alt dizgelerinin puanlarının toplamını hesaplar, burada bir alt dizgenin puanı, içinde tam olarak bir kez görünen karakterlerin sayısı olarak tanımlanır.\n\n  Argümanlar:\n  - s: Küçük harfli İngilizce harflerden oluşan bir dize.\n\n  Döndürür:\n  - Tüm boş olmayan alt dizgelerin puanlarının toplamını temsil eden bir tamsayı.\n\n  Örnek:\n  - sum_of_unique_chars_scores(\"abc\") 10 döndürür (Puanlar: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 döndürür (Puanlar: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "vi": "Viết một hàm Rust `fn sum_of_unique_chars_scores(s: &str) -> i32` để giải quyết vấn đề sau:\nTính tổng điểm cho tất cả các chuỗi con không rỗng của một chuỗi cho trước, trong đó điểm của một chuỗi con được định nghĩa là số lượng ký tự xuất hiện chính xác một lần trong đó.\n\n  Tham số:\n  - s: Một chuỗi bao gồm các chữ cái tiếng Anh viết thường.\n\n  Trả về:\n  - Một số nguyên đại diện cho tổng điểm của tất cả các chuỗi con không rỗng.\n\n  Ví dụ:\n  - sum_of_unique_chars_scores(\"abc\") trả về 10 (Điểm: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") trả về 4 (Điểm: a=0, a=0, b=1, aa=0, ab=1, aab=1)"
    },
    "instruction_bertscore": {
      "es": "0.9873466488369346",
      "arb": "0.99136295514146",
      "sw": "0.978148671782352",
      "tr": "0.9870890252327322",
      "vi": "0.9757603400807885"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(sum_of_unique_chars_scores(\"abc\"), 10); // a=1, b=1, c=1, ab=2, bc=2, abc=3\n        assert_eq!(sum_of_unique_chars_scores(\"aab\"), 6);  // a=1, a=1, b=1, aa=0, ab=2, aab=1\n        assert_eq!(sum_of_unique_chars_scores(\"ababc\"), 21);\n    }\n\n\n}",
    "entry_point": "sum_of_unique_chars_scores",
    "signature": "fn sum_of_unique_chars_scores(s: &str) -> i32",
    "docstring": {
      "en": "Calculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "es": "Calcula la suma de puntuaciones para todas las subcadenas no vacías de una cadena dada, donde la puntuación de una subcadena se define como el conteo de caracteres que aparecen exactamente una vez en ella.\n\n  Argumentos:\n  - s: Una cadena que consiste en letras minúsculas del alfabeto inglés.\n\n  Retorna:\n  - Un entero que representa la suma total de puntuaciones para todas las subcadenas no vacías.\n\n  Ejemplo:\n  - sum_of_unique_chars_scores(\"abc\") retorna 10 (Puntuaciones: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") retorna 4 (Puntuaciones: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "arb": "يحسب مجموع الدرجات لجميع المقاطع الفرعية غير الفارغة لسلسلة معينة، حيث يتم تعريف درجة المقطع الفرعي على أنها عدد الأحرف التي تظهر مرة واحدة فقط فيه.\n\n  الحجج:\n  - s: سلسلة تتكون من أحرف إنجليزية صغيرة.\n\n  العوائد:\n  - عدد صحيح يمثل مجموع الدرجات الكلي لجميع المقاطع الفرعية غير الفارغة.\n\n  مثال:\n  - sum_of_unique_chars_scores(\"abc\") يعيد 10 (الدرجات: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") يعيد 4 (الدرجات: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "sw": "Hesabu jumla ya alama za maneno madogo yote yasiyo tupu ya kamba fulani, ambapo alama ya maneno madogo inafafanuliwa kama idadi ya herufi zinazoonekana mara moja tu ndani yake.\n\n  Hoja:\n  - s: Kamba inayojumuisha herufi ndogo za Kiingereza.\n\n  Inarudisha:\n  - Nambari kamili inayowakilisha jumla ya alama za maneno madogo yote yasiyo tupu.\n\n  Mfano:\n  - sum_of_unique_chars_scores(\"abc\") inarudisha 10 (Alama: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") inarudisha 4 (Alama: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "tr": "Verilen bir stringin tüm boş olmayan alt dizelerinin puanlarının toplamını hesaplar, burada bir alt dizenin puanı, içinde tam olarak bir kez görünen karakterlerin sayısı olarak tanımlanır.\n\n  Argümanlar:\n  - s: Küçük harflerden oluşan bir string.\n\n  Döndürür:\n  - Tüm boş olmayan alt dizeler için puanların toplamını temsil eden bir tamsayı.\n\n  Örnek:\n  - sum_of_unique_chars_scores(\"abc\") 10 döndürür (Puanlar: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 döndürür (Puanlar: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "vi": "Tính tổng điểm của tất cả các chuỗi con không rỗng của một chuỗi cho trước, trong đó điểm của một chuỗi con được định nghĩa là số lượng ký tự xuất hiện chính xác một lần trong đó.\n\n  Tham số:\n  - s: Một chuỗi bao gồm các chữ cái tiếng Anh viết thường.\n\n  Trả về:\n  - Một số nguyên đại diện cho tổng điểm của tất cả các chuỗi con không rỗng.\n\n  Ví dụ:\n  - sum_of_unique_chars_scores(\"abc\") trả về 10 (Điểm: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") trả về 4 (Điểm: a=0, a=0, b=1, aa=0, ab=1, aab=1)"
    },
    "docstring_bertscore": {
      "es": "0.9872548816008964",
      "arb": "0.9916428253483381",
      "sw": "0.975808805893761",
      "tr": "0.9864269901727429",
      "vi": "0.9681178375400901"
    }
  },
  {
    "task_id": "Rust/9",
    "prompt": {
      "en": "/*\n  Generates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "es": "/*\n  Genera una secuencia de enteros donde cada entero subsiguiente es la mitad del anterior, redondeado hacia abajo, comenzando desde un valor inicial.\n\n  Argumentos:\n  - initial_value: Un entero que representa el valor inicial de la secuencia.\n\n  Devuelve:\n  - Un vector de enteros que representa la secuencia donde cada elemento es la mitad de su predecesor, deteniéndose cuando el valor se convierte en menos de 1.\n\n  Ejemplo:\n  - generate_dividing_sequence(20) devuelve [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) devuelve [5, 2, 1]\n  - generate_dividing_sequence(1) devuelve [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "arb": "/*\n  يولد تسلسلًا من الأعداد الصحيحة حيث يكون كل عدد لاحق نصف العدد السابق، مقربًا إلى الأسفل، بدءًا من قيمة ابتدائية.\n\n  الحجج:\n  - initial_value: عدد صحيح يمثل القيمة الابتدائية للتسلسل.\n\n  يعيد:\n  - متجه من الأعداد الصحيحة يمثل التسلسل حيث يكون كل عنصر نصف سابقه، ويتوقف عندما تصبح القيمة أقل من 1.\n\n  مثال:\n  - generate_dividing_sequence(20) يعيد [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) يعيد [5, 2, 1]\n  - generate_dividing_sequence(1) يعيد [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "sw": "/*\n  Hutoa mlolongo wa nambari za mzima ambapo kila nambari inayofuata ni nusu ya ile ya awali, ikipunguzwa chini, kuanzia thamani ya awali.\n\n  Hoja:\n  - initial_value: Nambari ya mzima inayowakilisha thamani ya kuanzia ya mlolongo.\n\n  Inarudisha:\n  - Vekta ya nambari za mzima inayowakilisha mlolongo ambapo kila kipengele ni nusu ya kile kilichotangulia, ikisimama wakati thamani inakuwa chini ya 1.\n\n  Mfano:\n  - generate_dividing_sequence(20) inarudisha [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) inarudisha [5, 2, 1]\n  - generate_dividing_sequence(1) inarudisha [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "tr": "/*\n  Her bir sonraki tam sayının bir öncekinin yarısı olduğu, aşağı yuvarlanmış bir tam sayı dizisi oluşturur, başlangıç değerinden başlayarak.\n\n  Argümanlar:\n  - initial_value: Dizinin başlangıç değerini temsil eden bir tam sayı.\n\n  Döndürür:\n  - Her bir elemanın selefinin yarısı olduğu, değer 1'den küçük olduğunda duran diziyi temsil eden bir tam sayı vektörü.\n\n  Örnek:\n  - generate_dividing_sequence(20) [20, 10, 5, 2, 1] döndürür\n  - generate_dividing_sequence(5) [5, 2, 1] döndürür\n  - generate_dividing_sequence(1) [1] döndürür\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "vi": "/*\n  Tạo ra một dãy số nguyên mà mỗi số nguyên tiếp theo là một nửa của số trước đó, làm tròn xuống, bắt đầu từ một giá trị ban đầu.\n\n  Tham số:\n  - initial_value: Một số nguyên đại diện cho giá trị bắt đầu của dãy số.\n\n  Trả về:\n  - Một vector các số nguyên đại diện cho dãy số mà mỗi phần tử là một nửa của phần tử trước đó, dừng lại khi giá trị trở nên nhỏ hơn 1.\n\n  Ví dụ:\n  - generate_dividing_sequence(20) trả về [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) trả về [5, 2, 1]\n  - generate_dividing_sequence(1) trả về [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>"
    },
    "prompt_bertscore": {
      "es": "0.9978943193306492",
      "arb": "0.995046356927371",
      "sw": "0.9909138518499401",
      "tr": "0.9753992300480671",
      "vi": "0.9864091134384498"
    },
    "canonical_solution": "{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}",
    "instruction": {
      "en": "Write a Rust function `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` to solve the following problem:\nGenerates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]",
      "es": "Escribe una función de Rust `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` para resolver el siguiente problema:\nGenera una secuencia de enteros donde cada entero subsiguiente es la mitad del anterior, redondeado hacia abajo, comenzando desde un valor inicial.\n\n  Argumentos:\n  - initial_value: Un entero que representa el valor inicial de la secuencia.\n\n  Devuelve:\n  - Un vector de enteros que representa la secuencia donde cada elemento es la mitad de su predecesor, deteniéndose cuando el valor se convierte en menos de 1.\n\n  Ejemplo:\n  - generate_dividing_sequence(20) devuelve [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) devuelve [5, 2, 1]\n  - generate_dividing_sequence(1) devuelve [1]",
      "arb": "اكتب دالة بلغة Rust `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` لحل المشكلة التالية:\nتوليد تسلسل من الأعداد الصحيحة حيث يكون كل عدد لاحق هو نصف العدد السابق، مقربًا إلى الأسفل، بدءًا من قيمة ابتدائية.\n\n  الوسائط:\n  - initial_value: عدد صحيح يمثل القيمة الابتدائية للتسلسل.\n\n  يعيد:\n  - متجه من الأعداد الصحيحة يمثل التسلسل حيث يكون كل عنصر نصف سابقه، ويتوقف عندما تصبح القيمة أقل من 1.\n\n  مثال:\n  - generate_dividing_sequence(20) يعيد [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) يعيد [5, 2, 1]\n  - generate_dividing_sequence(1) يعيد [1]",
      "sw": "Andika kazi ya Rust `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` kutatua tatizo lifuatalo:\nInazalisha mlolongo wa namba ambapo kila namba inayofuata ni nusu ya ile iliyotangulia, ikipunguzwa chini, kuanzia thamani ya awali.\n\n  Hoja:\n  - initial_value: Nambari inayowakilisha thamani ya kuanzia ya mlolongo.\n\n  Inarudisha:\n  - Vector ya namba inayowakilisha mlolongo ambapo kila kipengele ni nusu ya kile kilichotangulia, ikisimama wakati thamani inapokuwa chini ya 1.\n\n  Mfano:\n  - generate_dividing_sequence(20) inarudisha [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) inarudisha [5, 2, 1]\n  - generate_dividing_sequence(1) inarudisha [1]",
      "tr": "Bir Rust fonksiyonu `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` yazın. Aşağıdaki problemi çözmek için:\nBaşlangıç değerinden başlayarak, her bir sonraki tam sayının bir öncekinin yarısı olduğu, aşağı yuvarlanmış bir tam sayı dizisi oluşturur.\n\n  Argümanlar:\n  - initial_value: Dizinin başlangıç değerini temsil eden bir tam sayı.\n\n  Döndürür:\n  - Her bir elemanın selefinin yarısı olduğu, değer 1'den küçük olduğunda duran diziyi temsil eden bir tam sayı vektörü.\n\n  Örnek:\n  - generate_dividing_sequence(20) [20, 10, 5, 2, 1] döndürür\n  - generate_dividing_sequence(5) [5, 2, 1] döndürür\n  - generate_dividing_sequence(1) [1] döndürür",
      "vi": "Viết một hàm Rust `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` để giải quyết vấn đề sau:\nTạo ra một dãy số nguyên mà mỗi số nguyên tiếp theo là một nửa của số trước đó, làm tròn xuống, bắt đầu từ một giá trị ban đầu.\n\n  Tham số:\n  - initial_value: Một số nguyên đại diện cho giá trị bắt đầu của dãy số.\n\n  Trả về:\n  - Một vector các số nguyên đại diện cho dãy số mà mỗi phần tử là một nửa của phần tử trước đó, dừng lại khi giá trị nhỏ hơn 1.\n\n  Ví dụ:\n  - generate_dividing_sequence(20) trả về [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) trả về [5, 2, 1]\n  - generate_dividing_sequence(1) trả về [1]"
    },
    "instruction_bertscore": {
      "es": "0.9955417410976719",
      "arb": "0.9832707534180987",
      "sw": "0.9792729197390094",
      "tr": "0.9666783631687302",
      "vi": "0.9877464917939578"
    },
    "level": "easy",
    "test": "   \n#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(generate_dividing_sequence(20), vec![20, 10, 5, 2, 1]);\n        assert_eq!(generate_dividing_sequence(5), vec![5, 2, 1]);\n        assert_eq!(generate_dividing_sequence(1), vec![1]);\n        assert_eq!(generate_dividing_sequence(15), vec![15, 7, 3, 1]);        \n    }\n    \n\n}\n ",
    "entry_point": "generate_dividing_sequence",
    "signature": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
    "docstring": {
      "en": "Generates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]",
      "es": "Genera una secuencia de enteros donde cada entero subsiguiente es la mitad del anterior, redondeado hacia abajo, comenzando desde un valor inicial.\n\n  Argumentos:\n  - initial_value: Un entero que representa el valor inicial de la secuencia.\n\n  Retorna:\n  - Un vector de enteros que representa la secuencia donde cada elemento es la mitad de su predecesor, deteniéndose cuando el valor se vuelve menor que 1.\n\n  Ejemplo:\n  - generate_dividing_sequence(20) devuelve [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) devuelve [5, 2, 1]\n  - generate_dividing_sequence(1) devuelve [1]",
      "arb": "ينشئ تسلسلاً من الأعداد الصحيحة حيث يكون كل عدد صحيح لاحق نصف العدد السابق، مقربًا إلى الأسفل، بدءًا من قيمة ابتدائية.\n\nالأوساط:\n- initial_value: عدد صحيح يمثل القيمة الابتدائية للتسلسل.\n\nالقيم المعادة:\n- متجه من الأعداد الصحيحة يمثل التسلسل حيث يكون كل عنصر نصف سابقه، ويتوقف عندما تصبح القيمة أقل من 1.\n\nمثال:\n- generate_dividing_sequence(20) يعيد [20, 10, 5, 2, 1]\n- generate_dividing_sequence(5) يعيد [5, 2, 1]\n- generate_dividing_sequence(1) يعيد [1]",
      "sw": "Hutoa mlolongo wa nambari za mzima ambapo kila nambari inayofuata ni nusu ya ile iliyotangulia, ikipunguzwa chini, kuanzia thamani ya awali.\n\n  Hoja:\n  - initial_value: Nambari ya mzima inayowakilisha thamani ya kuanzia ya mlolongo.\n\n  Inarejesha:\n  - Vekta ya nambari za mzima inayowakilisha mlolongo ambapo kila kipengele ni nusu ya kile kilichotangulia, ikisimama wakati thamani inakuwa chini ya 1.\n\n  Mfano:\n  - generate_dividing_sequence(20) inarejesha [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) inarejesha [5, 2, 1]\n  - generate_dividing_sequence(1) inarejesha [1]",
      "tr": "Başlangıç değerinden başlayarak, her bir sonraki tamsayının bir öncekinin yarısı olduğu, aşağı yuvarlanmış bir tamsayı dizisi oluşturur.\n\n  Argümanlar:\n  - initial_value: Dizinin başlangıç değerini temsil eden bir tamsayı.\n\n  Döndürür:\n  - Her bir elemanın kendisinden öncekinin yarısı olduğu, değer 1'den küçük olduğunda duran bir tamsayı dizisini döndürür.\n\n  Örnek:\n  - generate_dividing_sequence(20) [20, 10, 5, 2, 1] döndürür\n  - generate_dividing_sequence(5) [5, 2, 1] döndürür\n  - generate_dividing_sequence(1) [1] döndürür",
      "vi": "Tạo ra một dãy số nguyên mà mỗi số nguyên tiếp theo là một nửa của số trước đó, làm tròn xuống, bắt đầu từ một giá trị ban đầu.\n\n  Tham số:\n  - initial_value: Một số nguyên đại diện cho giá trị bắt đầu của dãy số.\n\n  Trả về:\n  - Một vector số nguyên đại diện cho dãy số mà mỗi phần tử là một nửa của phần tử trước đó, dừng lại khi giá trị trở nên nhỏ hơn 1.\n\n  Ví dụ:\n  - generate_dividing_sequence(20) trả về [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) trả về [5, 2, 1]\n  - generate_dividing_sequence(1) trả về [1]"
    },
    "docstring_bertscore": {
      "es": "0.9954388505602959",
      "arb": "0.9787207272797325",
      "sw": "0.9897538504246963",
      "tr": "0.9506403503128303",
      "vi": "0.9823993619364986"
    }
  },
  {
    "task_id": "Rust/10",
    "prompt": {
      "en": "/*\n  Expands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "es": "/*\n  Expande una cadena comprimida donde los caracteres consecutivos están representados por el carácter seguido de su cuenta.\n  La cuenta es un solo dígito (1-9), y especifica cuántas veces aparece el carácter consecutivamente. Si un carácter aparece solo una vez, no está seguido por una cuenta.\n\n  Argumentos:\n  - compressed: Una cadena que contiene el formato comprimido, que consiste en caracteres y cuentas de un solo dígito.\n\n  Devuelve:\n  - Una cadena que representa la forma expandida de la cadena comprimida.\n\n  Ejemplo:\n  - expand_compressed_string(\"a3b2c\") devuelve \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") devuelve \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") devuelve \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "arb": "/*\n  يوسع سلسلة مضغوطة حيث يتم تمثيل الأحرف المتتالية بالحرف متبوعًا بعدده.\n  العدد هو رقم واحد (1-9)، ويحدد عدد مرات ظهور الحرف بشكل متتالٍ. إذا ظهر الحرف مرة واحدة فقط، فإنه لا يتبعه عدد.\n\n  الوسائط:\n  - compressed: سلسلة تحتوي على التنسيق المضغوط، تتكون من أحرف وأعداد مكونة من رقم واحد.\n\n  يعيد:\n  - سلسلة تمثل الشكل الموسع للسلسلة المضغوطة.\n\n  مثال:\n  - expand_compressed_string(\"a3b2c\") يعيد \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") يعيد \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") يعيد \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "sw": "/*\n  Hupanua mfuatano uliobanwa ambapo herufi zinazofuatana zinawakilishwa na herufi ikifuatiwa na idadi yake.\n  Idadi ni tarakimu moja (1-9), na inaeleza ni mara ngapi herufi inaonekana mfululizo. Ikiwa herufi inaonekana mara moja tu, haifuatiwi na idadi.\n\n  Hoja:\n  - compressed: Mfuatano wa herufi unaoonyesha muundo uliobanwa, unaojumuisha herufi na idadi za tarakimu moja.\n\n  Inarudisha:\n  - Mfuatano wa herufi unaowakilisha muundo uliopanuliwa wa mfuatano uliobanwa.\n\n  Mfano:\n  - expand_compressed_string(\"a3b2c\") inarudisha \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") inarudisha \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") inarudisha \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "tr": "/*\n  Ardışık karakterlerin karakter ve ardından sayısıyla temsil edildiği sıkıştırılmış bir dizeyi genişletir.\n  Sayı tek basamaklıdır (1-9) ve karakterin ardışık olarak kaç kez göründüğünü belirtir. Bir karakter yalnızca bir kez görünüyorsa, ardından bir sayı gelmez.\n\n  Argümanlar:\n  - compressed: Karakterler ve tek basamaklı sayılardan oluşan sıkıştırılmış formatı içeren bir dize.\n\n  Döndürür:\n  - Sıkıştırılmış dizenin genişletilmiş biçimini temsil eden bir dize.\n\n  Örnek:\n  - expand_compressed_string(\"a3b2c\") \"aaabbc\" döndürür\n  - expand_compressed_string(\"H3el5o2\") \"HHHellllloo\" döndürür\n  - expand_compressed_string(\"x9y1z2\") \"xxxxxxxxxyzz\" döndürür\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "vi": "/*\n  Mở rộng một chuỗi nén nơi các ký tự liên tiếp được biểu diễn bằng ký tự theo sau là số đếm của nó.\n  Số đếm là một chữ số đơn (1-9), và nó chỉ định số lần ký tự xuất hiện liên tiếp. Nếu một ký tự chỉ xuất hiện một lần, nó không được theo sau bởi số đếm.\n\n  Tham số:\n  - compressed: Một chuỗi chứa định dạng nén, bao gồm các ký tự và các chữ số đơn.\n\n  Trả về:\n  - Một chuỗi biểu diễn dạng mở rộng của chuỗi nén.\n\n  Ví dụ:\n  - expand_compressed_string(\"a3b2c\") trả về \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") trả về \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") trả về \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String "
    },
    "prompt_bertscore": {
      "es": "0.9940251981384706",
      "arb": "0.9706694434148643",
      "sw": "0.9377909509636834",
      "tr": "0.9576192287504911",
      "vi": "0.9736719402545876"
    },
    "canonical_solution": "{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}",
    "instruction": {
      "en": "Write a Rust function `fn expand_compressed_string(compressed: &str) -> String` to solve the following problem:\nExpands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"",
      "es": "Escribe una función de Rust `fn expand_compressed_string(compressed: &str) -> String` para resolver el siguiente problema:\nExpande una cadena comprimida donde los caracteres consecutivos están representados por el carácter seguido de su cantidad.\n  La cantidad es un solo dígito (1-9), y especifica cuántas veces aparece el carácter consecutivamente. Si un carácter aparece solo una vez, no va seguido de una cantidad.\n\n  Argumentos:\n  - compressed: Una cadena que contiene el formato comprimido, que consiste en caracteres y cantidades de un solo dígito.\n\n  Devuelve:\n  - Una cadena que representa la forma expandida de la cadena comprimida.\n\n  Ejemplo:\n  - expand_compressed_string(\"a3b2c\") devuelve \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") devuelve \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") devuelve \"xxxxxxxxxyzz\"",
      "arb": "اكتب دالة Rust `fn expand_compressed_string(compressed: &str) -> String` لحل المشكلة التالية:\nتوسع سلسلة مضغوطة حيث يتم تمثيل الأحرف المتتالية بالحرف متبوعًا بعدده.\n  العدد هو رقم واحد (1-9)، ويحدد عدد مرات ظهور الحرف بشكل متتالٍ. إذا ظهر الحرف مرة واحدة فقط، فإنه لا يتبعه عدد.\n\n  الوسائط:\n  - compressed: سلسلة تحتوي على التنسيق المضغوط، تتكون من أحرف وأعداد مكونة من رقم واحد.\n\n  يعيد:\n  - سلسلة تمثل الشكل الموسع للسلسلة المضغوطة.\n\n  مثال:\n  - expand_compressed_string(\"a3b2c\") يعيد \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") يعيد \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") يعيد \"xxxxxxxxxyzz\"",
      "sw": "Andika kazi ya Rust `fn expand_compressed_string(compressed: &str) -> String` kutatua tatizo lifuatalo:\nInapanua kamba iliyoshinikizwa ambapo herufi mfululizo zinawakilishwa na herufi ikifuatiwa na idadi yake.\n  Idadi ni tarakimu moja (1-9), na inabainisha ni mara ngapi herufi inaonekana mfululizo. Ikiwa herufi inaonekana mara moja tu, haifuatiwi na idadi.\n\n  Hoja:\n  - compressed: Kamba inayojumuisha muundo ulioshinikizwa, unaojumuisha herufi na idadi za tarakimu moja.\n\n  Inarudisha:\n  - Kamba inayowakilisha muundo ulioongezwa wa kamba iliyoshinikizwa.\n\n  Mfano:\n  - expand_compressed_string(\"a3b2c\") inarudisha \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") inarudisha \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") inarudisha \"xxxxxxxxxyzz\"",
      "tr": "Bir Rust fonksiyonu `fn expand_compressed_string(compressed: &str) -> String` yazın ve aşağıdaki problemi çözün:\nArdışık karakterlerin karakter ve ardından gelen sayıyla temsil edildiği sıkıştırılmış bir dizeyi genişletir.\n  Sayı tek basamaklıdır (1-9) ve karakterin ardışık olarak kaç kez göründüğünü belirtir. Bir karakter yalnızca bir kez görünüyorsa, ardından bir sayı gelmez.\n\n  Argümanlar:\n  - compressed: Karakterler ve tek basamaklı sayılardan oluşan sıkıştırılmış formatı içeren bir dize.\n\n  Döndürür:\n  - Sıkıştırılmış dizenin genişletilmiş biçimini temsil eden bir dize.\n\n  Örnek:\n  - expand_compressed_string(\"a3b2c\") \"aaabbc\" döndürür\n  - expand_compressed_string(\"H3el5o2\") \"HHHellllloo\" döndürür\n  - expand_compressed_string(\"x9y1z2\") \"xxxxxxxxxyzz\" döndürür",
      "vi": "Viết một hàm Rust `fn expand_compressed_string(compressed: &str) -> String` để giải quyết vấn đề sau:\nMở rộng một chuỗi nén nơi các ký tự liên tiếp được biểu diễn bằng ký tự theo sau là số đếm của nó.\n  Số đếm là một chữ số đơn (1-9), và nó chỉ định số lần ký tự xuất hiện liên tiếp. Nếu một ký tự chỉ xuất hiện một lần, nó không được theo sau bởi số đếm.\n\n  Tham số:\n  - compressed: Một chuỗi chứa định dạng nén, bao gồm các ký tự và các chữ số đơn.\n\n  Trả về:\n  - Một chuỗi biểu diễn dạng mở rộng của chuỗi nén.\n\n  Ví dụ:\n  - expand_compressed_string(\"a3b2c\") trả về \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") trả về \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") trả về \"xxxxxxxxxyzz\""
    },
    "instruction_bertscore": {
      "es": "0.9762551283599463",
      "arb": "0.9838146034013722",
      "sw": "0.9799399205585245",
      "tr": "0.9585073051840981",
      "vi": "0.9742803451116975"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(expand_compressed_string(\"a3b2c\"), \"aaabbc\");\n        assert_eq!(expand_compressed_string(\"H3el5o2\"), \"HHHellllloo\");\n        assert_eq!(expand_compressed_string(\"x9y1z2\"), \"xxxxxxxxxyzz\");\n        assert_eq!(expand_compressed_string(\"r4s\"), \"rrrrs\");\n        \n    }\n    \n\n}\n ",
    "entry_point": "expand_compressed_string",
    "signature": "fn expand_compressed_string(compressed: &str) -> String",
    "docstring": {
      "en": "Expands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"",
      "es": "Expande una cadena comprimida donde los caracteres consecutivos están representados por el carácter seguido de su cantidad.\n  La cantidad es un solo dígito (1-9), y especifica cuántas veces aparece el carácter consecutivamente. Si un carácter aparece solo una vez, no va seguido de una cantidad.\n\n  Argumentos:\n  - compressed: Una cadena que contiene el formato comprimido, compuesto por caracteres y cantidades de un solo dígito.\n\n  Retorna:\n  - Una cadena que representa la forma expandida de la cadena comprimida.\n\n  Ejemplo:\n  - expand_compressed_string(\"a3b2c\") devuelve \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") devuelve \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") devuelve \"xxxxxxxxxyzz\"",
      "arb": "يقوم بتوسيع سلسلة مضغوطة حيث يتم تمثيل الأحرف المتتالية بواسطة الحرف متبوعًا بعدده.\n  العدد هو رقم واحد (1-9)، ويحدد عدد مرات ظهور الحرف بشكل متتالٍ. إذا ظهر الحرف مرة واحدة فقط، فإنه لا يتبعه عدد.\n\n  الحجج:\n  - compressed: سلسلة تحتوي على التنسيق المضغوط، تتكون من أحرف وأعداد مكونة من رقم واحد.\n\n  العوائد:\n  - سلسلة تمثل الشكل الموسع للسلسلة المضغوطة.\n\n  مثال:\n  - expand_compressed_string(\"a3b2c\") يعيد \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") يعيد \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") يعيد \"xxxxxxxxxyzz\"",
      "sw": "Inapanua mfuatano uliobanwa ambapo herufi zinazofuatana zinawakilishwa na herufi ikifuatiwa na idadi yake. \n  Idadi ni tarakimu moja (1-9), na inaeleza ni mara ngapi herufi inaonekana mfululizo. Ikiwa herufi inaonekana mara moja tu, haifuatiwi na idadi.\n\n  Hoja:\n  - compressed: Mfuatano wa herufi unaoelezea muundo uliobanwa, unaojumuisha herufi na idadi ya tarakimu moja.\n\n  Inarudisha:\n  - Mfuatano wa herufi unaowakilisha umbo lililopanuliwa la mfuatano uliobanwa.\n\n  Mfano:\n  - expand_compressed_string(\"a3b2c\") inarudisha \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") inarudisha \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") inarudisha \"xxxxxxxxxyzz\"",
      "tr": "Sıkıştırılmış bir dizeyi genişletir, burada ardışık karakterler karakterin ardından gelen sayıyla temsil edilir.\n  Sayı tek basamaklıdır (1-9) ve karakterin ardışık olarak kaç kez göründüğünü belirtir. Bir karakter yalnızca bir kez görünüyorsa, ardından bir sayı gelmez.\n\n  Argümanlar:\n  - compressed: Karakterler ve tek basamaklı sayılardan oluşan sıkıştırılmış formatı içeren bir dize.\n\n  Döndürür:\n  - Sıkıştırılmış dizenin genişletilmiş biçimini temsil eden bir dize.\n\n  Örnek:\n  - expand_compressed_string(\"a3b2c\") \"aaabbc\" döndürür\n  - expand_compressed_string(\"H3el5o2\") \"HHHellllloo\" döndürür\n  - expand_compressed_string(\"x9y1z2\") \"xxxxxxxxxyzz\" döndürür",
      "vi": "Mở rộng một chuỗi nén nơi các ký tự liên tiếp được biểu diễn bằng ký tự theo sau là số lượng của nó. \nSố lượng là một chữ số đơn (1-9), và nó chỉ định số lần ký tự xuất hiện liên tiếp. Nếu một ký tự chỉ xuất hiện một lần, nó không được theo sau bởi số lượng.\n\nTham số:\n- compressed: Một chuỗi chứa định dạng nén, bao gồm các ký tự và số lượng là chữ số đơn.\n\nTrả về:\n- Một chuỗi biểu diễn dạng mở rộng của chuỗi nén.\n\nVí dụ:\n- expand_compressed_string(\"a3b2c\") trả về \"aaabbc\"\n- expand_compressed_string(\"H3el5o2\") trả về \"HHHellllloo\"\n- expand_compressed_string(\"x9y1z2\") trả về \"xxxxxxxxxyzz\""
    },
    "docstring_bertscore": {
      "es": "0.9954914876112702",
      "arb": "0.9730009668274517",
      "sw": "0.9484027790704723",
      "tr": "0.9496833491370041",
      "vi": "0.9820573204203564"
    }
  },
  {
    "task_id": "Rust/11",
    "prompt": {
      "en": "/*\n  Calculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "es": "/*\n  Calcula el número de caminos distintos desde la esquina superior izquierda hasta la esquina inferior derecha de una cuadrícula,\n  con la restricción de que solo se puede mover a la derecha o hacia abajo y no se pueden ingresar celdas donde tanto el número de fila como de columna sean pares.\n\n  Argumentos:\n  - rows: El número de filas en la cuadrícula.\n  - cols: El número de columnas en la cuadrícula.\n\n  Devuelve:\n  - El número de caminos distintos que satisfacen las restricciones dadas.\n\n  Ejemplo:\n  - count_walking_paths(3, 4) devuelve 2\n  - count_walking_paths(2, 2) devuelve 0\n  - count_walking_paths(4, 5) devuelve 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "arb": "/*\n  يحسب عدد المسارات المميزة من الزاوية العلوية اليسرى إلى الزاوية السفلية اليمنى من الشبكة،\n  مع القيد أنه يمكن التحرك فقط إلى اليمين أو الأسفل ولا يمكن الدخول إلى الخلايا حيث يكون كل من أرقام الصفوف والأعمدة زوجية.\n\n  الحجج:\n  - rows: عدد الصفوف في الشبكة.\n  - cols: عدد الأعمدة في الشبكة.\n\n  يعيد:\n  - عدد المسارات المميزة التي تفي بالقيود المعطاة.\n\n  مثال:\n  - count_walking_paths(3, 4) يعيد 2\n  - count_walking_paths(2, 2) يعيد 0\n  - count_walking_paths(4, 5) يعيد 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ya njia tofauti kutoka kona ya juu-kushoto hadi kona ya chini-kulia ya gridi,\n  na kizuizi kwamba mtu anaweza kusonga kulia au chini tu na hawezi kuingia kwenye seli ambapo namba za safu na safu wima ni sawa.\n\n  Hoja:\n  - rows: Idadi ya safu katika gridi.\n  - cols: Idadi ya safu wima katika gridi.\n\n  Inarudisha:\n  - Idadi ya njia tofauti zinazokidhi vikwazo vilivyotolewa.\n\n  Mfano:\n  - count_walking_paths(3, 4) inarudisha 2\n  - count_walking_paths(2, 2) inarudisha 0\n  - count_walking_paths(4, 5) inarudisha 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32",
      "tr": "/*\n  Bir ızgaranın sol üst köşesinden sağ alt köşesine kadar farklı yolların sayısını hesaplar,\n  yalnızca sağa veya aşağıya hareket edilebileceği ve hem satır hem de sütun numaralarının çift olduğu hücrelere girilemeyeceği kısıtlamasıyla.\n\n  Argümanlar:\n  - rows: Izgaradaki satır sayısı.\n  - cols: Izgaradaki sütun sayısı.\n\n  Döndürür:\n  - Verilen kısıtlamaları karşılayan farklı yolların sayısı.\n\n  Örnek:\n  - count_walking_paths(3, 4) 2 döndürür\n  - count_walking_paths(2, 2) 0 döndürür\n  - count_walking_paths(4, 5) 3 döndürür\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "vi": "/*\n  Tính toán số lượng đường đi khác nhau từ góc trên bên trái đến góc dưới bên phải của một lưới,\n  với điều kiện rằng chỉ có thể di chuyển sang phải hoặc xuống dưới và không thể vào các ô mà cả số hàng và số cột đều là số chẵn.\n\n  Tham số:\n  - rows: Số hàng trong lưới.\n  - cols: Số cột trong lưới.\n\n  Trả về:\n  - Số lượng đường đi khác nhau thỏa mãn các điều kiện đã cho.\n\n  Ví dụ:\n  - count_walking_paths(3, 4) trả về 2\n  - count_walking_paths(2, 2) trả về 0\n  - count_walking_paths(4, 5) trả về 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9800227494274161",
      "arb": "0.9696876134414089",
      "sw": "0.9762223543470756",
      "tr": "0.9929361077592562",
      "vi": "0.9627470706672877"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_walking_paths(rows: i32, cols: i32) -> i32` to solve the following problem:\nCalculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3",
      "es": "Escribe una función de Rust `fn count_walking_paths(rows: i32, cols: i32) -> i32` para resolver el siguiente problema:\nCalcula el número de caminos distintos desde la esquina superior izquierda hasta la esquina inferior derecha de una cuadrícula,\ncon la restricción de que solo se puede mover a la derecha o hacia abajo y no se puede entrar en celdas donde tanto el número de fila como el de columna son pares.\n\nArgumentos:\n- rows: El número de filas en la cuadrícula.\n- cols: El número de columnas en la cuadrícula.\n\nDevuelve:\n- El número de caminos distintos que satisfacen las restricciones dadas.\n\nEjemplo:\n- count_walking_paths(3, 4) devuelve 2\n- count_walking_paths(2, 2) devuelve 0\n- count_walking_paths(4, 5) devuelve 3",
      "arb": "اكتب دالة بلغة Rust `fn count_walking_paths(rows: i32, cols: i32) -> i32` لحل المشكلة التالية:\nتحسب عدد المسارات المميزة من الزاوية العلوية اليسرى إلى الزاوية السفلية اليمنى من الشبكة،\nمع القيد أنه يمكن التحرك فقط إلى اليمين أو إلى الأسفل ولا يمكن دخول الخلايا حيث يكون كلا من رقم الصف ورقم العمود زوجيين.\n\nالمعاملات:\n- rows: عدد الصفوف في الشبكة.\n- cols: عدد الأعمدة في الشبكة.\n\nالقيم المعادة:\n- عدد المسارات المميزة التي تفي بالقيود المعطاة.\n\nمثال:\n- count_walking_paths(3, 4) يعيد 2\n- count_walking_paths(2, 2) يعيد 0\n- count_walking_paths(4, 5) يعيد 3",
      "sw": "Andika kazi ya Rust `fn count_walking_paths(rows: i32, cols: i32) -> i32` kutatua tatizo lifuatalo:\nInakokotoa idadi ya njia tofauti kutoka kona ya juu-kushoto hadi kona ya chini-kulia ya gridi,\n  kwa kizuizi kwamba mtu anaweza kusonga kulia au chini na hawezi kuingia kwenye seli ambapo namba za safu na safu wima zote ni sawa.\n\n  Hoja:\n  - rows: Idadi ya safu katika gridi.\n  - cols: Idadi ya safu wima katika gridi.\n\n  Inarejesha:\n  - Idadi ya njia tofauti zinazokidhi vizuizi vilivyotolewa.\n\n  Mfano:\n  - count_walking_paths(3, 4) inarejesha 2\n  - count_walking_paths(2, 2) inarejesha 0\n  - count_walking_paths(4, 5) inarejesha 3",
      "tr": "Bir Rust fonksiyonu `fn count_walking_paths(rows: i32, cols: i32) -> i32` yazarak aşağıdaki problemi çözün:\nBir ızgaranın sol üst köşesinden sağ alt köşesine kadar olan farklı yolların sayısını hesaplar,\n  yalnızca sağa veya aşağı hareket edilebileceği ve hem satır hem de sütun numaralarının çift olduğu hücrelere girilemeyeceği kısıtlamasıyla.\n\n  Argümanlar:\n  - rows: Izgaradaki satır sayısı.\n  - cols: Izgaradaki sütun sayısı.\n\n  Döndürür:\n  - Verilen kısıtlamaları karşılayan farklı yolların sayısı.\n\n  Örnek:\n  - count_walking_paths(3, 4) 2 döndürür\n  - count_walking_paths(2, 2) 0 döndürür\n  - count_walking_paths(4, 5) 3 döndürür",
      "vi": "Viết một hàm Rust `fn count_walking_paths(rows: i32, cols: i32) -> i32` để giải quyết vấn đề sau:\nTính toán số lượng đường đi khác nhau từ góc trên bên trái đến góc dưới bên phải của một lưới,\nvới điều kiện rằng chỉ có thể di chuyển sang phải hoặc xuống dưới và không thể đi vào các ô mà cả số hàng và số cột đều là số chẵn.\n\nTham số:\n- rows: Số hàng trong lưới.\n- cols: Số cột trong lưới.\n\nTrả về:\n- Số lượng đường đi khác nhau thỏa mãn các điều kiện đã cho.\n\nVí dụ:\n- count_walking_paths(3, 4) trả về 2\n- count_walking_paths(2, 2) trả về 0\n- count_walking_paths(4, 5) trả về 3"
    },
    "instruction_bertscore": {
      "es": "0.9871400732406582",
      "arb": "0.9703798403193155",
      "sw": "0.9679837620328915",
      "tr": "0.961148493360719",
      "vi": "0.9693833116976633"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn main() {\n        assert_eq!(count_walking_paths(3, 4), 2);\n        assert_eq!(count_walking_paths(2, 2), 0);\n        assert_eq!(count_walking_paths(4, 5), 3);\n        assert_eq!(count_walking_paths(1, 1), 1);        \n    }\n    \n\n}",
    "entry_point": "count_walking_paths",
    "signature": "fn count_walking_paths(rows: i32, cols: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3",
      "es": "Calcula el número de caminos distintos desde la esquina superior izquierda hasta la esquina inferior derecha de una cuadrícula, con la restricción de que solo se puede mover hacia la derecha o hacia abajo y no se pueden ingresar a celdas donde tanto el número de fila como de columna sean pares.\n\n  Argumentos:\n  - rows: El número de filas en la cuadrícula.\n  - cols: El número de columnas en la cuadrícula.\n\n  Retorna:\n  - El número de caminos distintos que satisfacen las restricciones dadas.\n\n  Ejemplo:\n  - count_walking_paths(3, 4) devuelve 2\n  - count_walking_paths(2, 2) devuelve 0\n  - count_walking_paths(4, 5) devuelve 3",
      "arb": "يحسب عدد المسارات المميزة من الزاوية العلوية اليسرى إلى الزاوية السفلية اليمنى من الشبكة، مع القيد الذي يسمح بالتحرك فقط إلى اليمين أو إلى الأسفل ولا يمكن الدخول إلى الخلايا حيث يكون كل من أرقام الصفوف والأعمدة زوجيًا.\n\nالحجج:\n- rows: عدد الصفوف في الشبكة.\n- cols: عدد الأعمدة في الشبكة.\n\nالقيم المعادة:\n- عدد المسارات المميزة التي تفي بالقيود المعطاة.\n\nمثال:\n- count_walking_paths(3, 4) يعيد 2\n- count_walking_paths(2, 2) يعيد 0\n- count_walking_paths(4, 5) يعيد 3",
      "sw": "Hesabu idadi ya njia tofauti kutoka kona ya juu-kushoto hadi kona ya chini-kulia ya gridi,\n  kwa kizuizi kwamba mtu anaweza kusonga kulia au chini tu na hawezi kuingia kwenye seli ambapo namba za safu na safu wima ni sawa.\n\n  Hoja:\n  - rows: Idadi ya safu kwenye gridi.\n  - cols: Idadi ya safu wima kwenye gridi.\n\n  Inarudisha:\n  - Idadi ya njia tofauti zinazokidhi vizuizi vilivyotolewa.\n\n  Mfano:\n  - count_walking_paths(3, 4) inarudisha 2\n  - count_walking_paths(2, 2) inarudisha 0\n  - count_walking_paths(4, 5) inarudisha 3",
      "tr": "Üst sol köşeden alt sağ köşeye bir ızgara boyunca farklı yolların sayısını hesaplar,\n  yalnızca sağa veya aşağı hareket edilebileceği ve hem satır hem de sütun numaralarının çift olduğu hücrelere girilemeyeceği kısıtlamasıyla.\n\n  Argümanlar:\n  - rows: Izgaradaki satır sayısı.\n  - cols: Izgaradaki sütun sayısı.\n\n  Döndürür:\n  - Verilen kısıtlamaları karşılayan farklı yolların sayısı.\n\n  Örnek:\n  - count_walking_paths(3, 4) 2 döndürür\n  - count_walking_paths(2, 2) 0 döndürür\n  - count_walking_paths(4, 5) 3 döndürür",
      "vi": "Tính toán số lượng đường đi khác nhau từ góc trên bên trái đến góc dưới bên phải của một lưới,\nvới điều kiện rằng chỉ có thể di chuyển sang phải hoặc xuống dưới và không thể vào các ô mà cả số hàng và số cột đều là số chẵn.\n\nTham số:\n- rows: Số hàng trong lưới.\n- cols: Số cột trong lưới.\n\nTrả về:\n- Số lượng đường đi khác nhau thỏa mãn các điều kiện đã cho.\n\nVí dụ:\n- count_walking_paths(3, 4) trả về 2\n- count_walking_paths(2, 2) trả về 0\n- count_walking_paths(4, 5) trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.9756242782697796",
      "arb": "0.9696256407625259",
      "sw": "0.9608636573943149",
      "tr": "0.9481977925172442",
      "vi": "0.9642095861628477"
    }
  },
  {
    "task_id": "Rust/12",
    "prompt": {
      "en": "/*\n  Counts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "es": "/*\n  Cuenta el número de letras mayúsculas, letras minúsculas y dígitos en una cadena dada.\n\n  Argumentos:\n  - input: Una cadena que puede contener letras mayúsculas y minúsculas en inglés, así como dígitos.\n\n  Devuelve:\n  - Una tupla que contiene tres valores usize que representan los conteos de letras mayúsculas, letras minúsculas y dígitos, respectivamente.\n\n  Ejemplo:\n  - count_character_types(\"Rust3IsFun!\") devuelve (3, 6, 1)\n  - count_character_types(\"1234\") devuelve (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") devuelve (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "arb": "/*\n  يحسب عدد الأحرف الكبيرة، الأحرف الصغيرة، والأرقام في سلسلة معينة.\n\n  الحجج:\n  - input: سلسلة قد تحتوي على أحرف إنجليزية كبيرة وصغيرة، بالإضافة إلى أرقام.\n\n  يعيد:\n  - زوج يحتوي على ثلاث قيم من نوع usize تمثل عدد الأحرف الكبيرة، الأحرف الصغيرة، والأرقام، على التوالي.\n\n  مثال:\n  - count_character_types(\"Rust3IsFun!\") يعيد (3, 6, 1)\n  - count_character_types(\"1234\") يعيد (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") يعيد (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "sw": "/*\n  Inahesabu idadi ya herufi kubwa, herufi ndogo, na tarakimu katika kamba iliyotolewa.\n\n  Hoja:\n  - input: Kamba ambayo inaweza kuwa na herufi kubwa na ndogo za Kiingereza, pamoja na tarakimu.\n\n  Inarejesha:\n  - Nyuzi yenye thamani tatu za usize zinazowakilisha hesabu ya herufi kubwa, herufi ndogo, na tarakimu, mtawalia.\n\n  Mfano:\n  - count_character_types(\"Rust3IsFun!\") inarejesha (3, 6, 1)\n  - count_character_types(\"1234\") inarejesha (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") inarejesha (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "tr": "/*\n  Verilen bir stringdeki büyük harflerin, küçük harflerin ve rakamların sayısını sayar.\n\n  Argümanlar:\n  - input: Büyük ve küçük İngilizce harfler ile rakamlar içerebilen bir string.\n\n  Döndürür:\n  - Sırasıyla büyük harflerin, küçük harflerin ve rakamların sayılarını temsil eden üç usize değer içeren bir demet.\n\n  Örnek:\n  - count_character_types(\"Rust3IsFun!\") (3, 6, 1) döndürür\n  - count_character_types(\"1234\") (0, 0, 4) döndürür\n  - count_character_types(\"HelloWorld!\") (2, 8, 0) döndürür\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "vi": "/*\n  Đếm số lượng chữ cái viết hoa, chữ cái viết thường và chữ số trong một chuỗi cho trước.\n\n  Tham số:\n  - input: Một chuỗi có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, cũng như các chữ số.\n\n  Trả về:\n  - Một bộ giá trị chứa ba giá trị usize đại diện cho số lượng chữ cái viết hoa, chữ cái viết thường và chữ số, tương ứng.\n\n  Ví dụ:\n  - count_character_types(\"Rust3IsFun!\") trả về (3, 6, 1)\n  - count_character_types(\"1234\") trả về (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") trả về (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9929712653366994",
      "sw": "0.9928604295840819",
      "tr": "0.9865437848367915",
      "vi": "0.9856368385169862"
    },
    "canonical_solution": "{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_character_types(input: &str) -> (usize, usize, usize)` to solve the following problem:\nCounts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "es": "Escribe una función en Rust `fn count_character_types(input: &str) -> (usize, usize, usize)` para resolver el siguiente problema:\nCuenta el número de letras mayúsculas, letras minúsculas y dígitos en una cadena dada.\n\n  Argumentos:\n  - input: Una cadena que puede contener letras inglesas mayúsculas y minúsculas, así como dígitos.\n\n  Retorna:\n  - Una tupla que contiene tres valores usize que representan los conteos de letras mayúsculas, letras minúsculas y dígitos, respectivamente.\n\n  Ejemplo:\n  - count_character_types(\"Rust3IsFun!\") devuelve (3, 6, 1)\n  - count_character_types(\"1234\") devuelve (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") devuelve (2, 8, 0)",
      "arb": "اكتب دالة بلغة Rust `fn count_character_types(input: &str) -> (usize, usize, usize)` لحل المشكلة التالية:\nتحسب عدد الأحرف الكبيرة، الأحرف الصغيرة، والأرقام في سلسلة معينة.\n\n  الوسائط:\n  - input: سلسلة قد تحتوي على أحرف إنجليزية كبيرة وصغيرة، بالإضافة إلى أرقام.\n\n  تعيد:\n  - زوج يحتوي على ثلاث قيم من نوع usize تمثل عدد الأحرف الكبيرة، الأحرف الصغيرة، والأرقام، على التوالي.\n\n  مثال:\n  - count_character_types(\"Rust3IsFun!\") يعيد (3, 6, 1)\n  - count_character_types(\"1234\") يعيد (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") يعيد (2, 8, 0)",
      "sw": "Andika kazi ya Rust `fn count_character_types(input: &str) -> (usize, usize, usize)` kutatua tatizo lifuatalo:\nHesabu idadi ya herufi kubwa, herufi ndogo, na tarakimu katika kamba iliyotolewa.\n\n  Hoja:\n  - input: Kamba ambayo inaweza kuwa na herufi kubwa na ndogo za Kiingereza, pamoja na tarakimu.\n\n  Inarejesha:\n  - Jozi inayojumuisha thamani tatu za usize zinazowakilisha hesabu za herufi kubwa, herufi ndogo, na tarakimu, mtawalia.\n\n  Mfano:\n  - count_character_types(\"Rust3IsFun!\") inarejesha (3, 6, 1)\n  - count_character_types(\"1234\") inarejesha (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") inarejesha (2, 8, 0)",
      "tr": "Bir Rust fonksiyonu `fn count_character_types(input: &str) -> (usize, usize, usize)` yazın: \nVerilen bir stringdeki büyük harflerin, küçük harflerin ve rakamların sayısını sayar.\n\n  Argümanlar:\n  - input: Büyük ve küçük İngilizce harfler ile rakamlar içerebilen bir string.\n\n  Döndürür:\n  - Büyük harflerin, küçük harflerin ve rakamların sayısını temsil eden üç usize değer içeren bir demet.\n\n  Örnek:\n  - count_character_types(\"Rust3IsFun!\") (3, 6, 1) döndürür\n  - count_character_types(\"1234\") (0, 0, 4) döndürür\n  - count_character_types(\"HelloWorld!\") (2, 8, 0) döndürür",
      "vi": "Viết một hàm Rust `fn count_character_types(input: &str) -> (usize, usize, usize)` để giải quyết vấn đề sau:\nĐếm số lượng chữ cái viết hoa, chữ cái viết thường và chữ số trong một chuỗi cho trước.\n\n  Tham số:\n  - input: Một chuỗi có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, cũng như các chữ số.\n\n  Trả về:\n  - Một bộ ba giá trị usize đại diện cho số lượng chữ cái viết hoa, chữ cái viết thường và chữ số, tương ứng.\n\n  Ví dụ:\n  - count_character_types(\"Rust3IsFun!\") trả về (3, 6, 1)\n  - count_character_types(\"1234\") trả về (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") trả về (2, 8, 0)"
    },
    "instruction_bertscore": {
      "es": "0.9955727274371133",
      "arb": "0.9777833905116288",
      "sw": "0.9907744133224535",
      "tr": "0.9726523705087355",
      "vi": "0.9845777413253082"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_character_types(\"Rust3IsFun!\"), (3, 6, 1));\n        assert_eq!(count_character_types(\"1234\"), (0, 0, 4));\n        assert_eq!(count_character_types(\"HelloWorld!\"), (2, 8, 0));\n        assert_eq!(count_character_types(\"NoDigitsHere\"), (3, 9, 0));        \n    }\n    \n\n}",
    "entry_point": "count_character_types",
    "signature": "fn count_character_types(input: &str) -> (usize, usize, usize)",
    "docstring": {
      "en": "Counts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "es": "Cuenta el número de letras mayúsculas, letras minúsculas y dígitos en una cadena dada.\n\n  Argumentos:\n  - input: Una cadena que puede contener letras inglesas mayúsculas y minúsculas, así como dígitos.\n\n  Retorna:\n  - Una tupla que contiene tres valores usize que representan los conteos de letras mayúsculas, letras minúsculas y dígitos, respectivamente.\n\n  Ejemplo:\n  - count_character_types(\"Rust3IsFun!\") devuelve (3, 6, 1)\n  - count_character_types(\"1234\") devuelve (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") devuelve (2, 8, 0)",
      "arb": "يحسب عدد الأحرف الكبيرة، الأحرف الصغيرة، والأرقام في سلسلة معينة.\n\n  الحجج:\n  - input: سلسلة قد تحتوي على أحرف إنجليزية كبيرة وصغيرة، بالإضافة إلى أرقام.\n\n  يعيد:\n  - زوج يحتوي على ثلاث قيم من نوع usize تمثل عدد الأحرف الكبيرة، الأحرف الصغيرة، والأرقام، على التوالي.\n\n  مثال:\n  - count_character_types(\"Rust3IsFun!\") يعيد (3, 6, 1)\n  - count_character_types(\"1234\") يعيد (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") يعيد (2, 8, 0)",
      "sw": "Hesabu idadi ya herufi kubwa, herufi ndogo, na nambari katika kamba iliyotolewa.\n\n  Hoja:\n  - input: Kamba ambayo inaweza kuwa na herufi kubwa na ndogo za Kiingereza, pamoja na nambari.\n\n  Inarejesha:\n  - Jozi inayojumuisha thamani tatu za usize zinazowakilisha hesabu ya herufi kubwa, herufi ndogo, na nambari, mtawalia.\n\n  Mfano:\n  - count_character_types(\"Rust3IsFun!\") inarejesha (3, 6, 1)\n  - count_character_types(\"1234\") inarejesha (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") inarejesha (2, 8, 0)",
      "tr": "Büyük harflerin, küçük harflerin ve rakamların sayısını verilen bir string içinde sayar.\n\n  Argümanlar:\n  - input: Büyük ve küçük İngilizce harfler ile rakamlar içerebilen bir string.\n\n  Döndürür:\n  - Büyük harflerin, küçük harflerin ve rakamların sayısını temsil eden üç usize değer içeren bir demet.\n\n  Örnek:\n  - count_character_types(\"Rust3IsFun!\") Döndürür (3, 6, 1)\n  - count_character_types(\"1234\") Döndürür (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") Döndürür (2, 8, 0)",
      "vi": "Đếm số lượng chữ cái viết hoa, chữ cái viết thường và chữ số trong một chuỗi cho trước.\n\n  Tham số:\n  - input: Một chuỗi có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, cũng như các chữ số.\n\n  Trả về:\n  - Một bộ giá trị chứa ba giá trị usize đại diện cho số lượng chữ cái viết hoa, chữ cái viết thường và chữ số, tương ứng.\n\n  Ví dụ:\n  - count_character_types(\"Rust3IsFun!\") trả về (3, 6, 1)\n  - count_character_types(\"1234\") trả về (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") trả về (2, 8, 0)"
    },
    "docstring_bertscore": {
      "es": "0.9977509081955419",
      "arb": "0.9883954172487988",
      "sw": "0.9657448003778663",
      "tr": "0.9789451796103018",
      "vi": "0.9832894246739159"
    }
  },
  {
    "task_id": "Rust/13",
    "prompt": {
      "en": "\n/*\n  Converts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "es": "/*\n  Convierte una secuencia dada de números en la cadena más grande posible lexicográficamente de letras mayúsculas del alfabeto inglés, donde cada letra corresponde a su posición en el alfabeto (A=1, B=2, ..., Z=26).\n\n  La función interpreta la secuencia de números como un número de un solo dígito o de dos dígitos (que representa una letra) para maximizar el orden lexicográfico de la cadena resultante.\n\n  Argumentos:\n  - encoded_sequence: Una cadena que consiste en dígitos que representan las posiciones de las letras codificadas.\n\n  Devuelve:\n  - Una cadena de letras mayúsculas del alfabeto inglés que representa la interpretación más grande posible lexicográficamente de la secuencia codificada.\n\n  Ejemplos:\n  - max_lexicographic_string(\"123242526\") devuelve \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") devuelve \"WRS\"\n  - max_lexicographic_string(\"102\") devuelve \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "arb": "/*\n  يحول تسلسلًا معينًا من الأرقام إلى أكبر سلسلة ممكنة من الأحرف الإنجليزية الكبيرة بترتيب معجمي، حيث يتوافق كل حرف مع موضعه في الأبجدية (A=1, B=2, ..., Z=26).\n\n  تقوم الدالة بتفسير تسلسل الأرقام كرقم مكون من رقم واحد أو رقمين (يمثل حرفًا) لتعظيم الترتيب المعجمي للسلسلة الناتجة.\n\n  الوسائط:\n  - encoded_sequence: سلسلة تتكون من أرقام تمثل مواضع الحروف المشفرة.\n\n  يعيد:\n  - سلسلة من الأحرف الإنجليزية الكبيرة التي تمثل أكبر تفسير ممكن للترتيب المعجمي للتسلسل المشفر.\n\n  أمثلة:\n  - max_lexicographic_string(\"123242526\") يعيد \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") يعيد \"WRS\"\n  - max_lexicographic_string(\"102\") يعيد \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "sw": "/*\n  Inabadilisha mlolongo uliotolewa wa nambari kuwa herufi kubwa za Kiingereza kwa mpangilio wa lexicographically mkubwa zaidi, ambapo kila herufi inalingana na nafasi yake katika alfabeti (A=1, B=2, ..., Z=26).\n\n  Kazi hii inatafsiri mlolongo wa nambari kama nambari ya tarakimu moja au nambari ya tarakimu mbili (inayowakilisha herufi) ili kuongeza mpangilio wa lexicographic wa mfululizo unaotokana.\n\n  Hoja:\n  - encoded_sequence: Mlolongo wa herufi unaojumuisha tarakimu zinazowakilisha nafasi za herufi zilizofichwa.\n\n  Inarudisha:\n  - Mlolongo wa herufi kubwa za Kiingereza unaowakilisha tafsiri ya lexicographically kubwa zaidi ya mlolongo uliowekwa.\n\n  Mifano:\n  - max_lexicographic_string(\"123242526\") inarudisha \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") inarudisha \"WRS\"\n  - max_lexicographic_string(\"102\") inarudisha \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "tr": "/*\n  Verilen bir sayı dizisini, her harfin alfabedeki konumuna karşılık geldiği (A=1, B=2, ..., Z=26) en büyük leksikografik sıradaki büyük harflerden oluşan bir dizeye dönüştürür.\n\n  Fonksiyon, sayı dizisini, ortaya çıkan dizenin leksikografik sırasını en üst düzeye çıkarmak için tek haneli veya çift haneli bir sayı (bir harfi temsil eden) olarak yorumlar.\n\n  Argümanlar:\n  - encoded_sequence: Kodlanmış harf konumlarını temsil eden rakamlardan oluşan bir dize.\n\n  Döndürür:\n  - Kodlanmış dizinin leksikografik olarak en büyük olası yorumunu temsil eden büyük harflerden oluşan bir dize.\n\n  Örnekler:\n  - max_lexicographic_string(\"123242526\") Döndürür \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") Döndürür \"WRS\"\n  - max_lexicographic_string(\"102\") Döndürür \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "vi": "/*\n  Chuyển đổi một dãy số đã cho thành chuỗi lớn nhất có thể theo thứ tự từ điển của các chữ cái tiếng Anh viết hoa, trong đó mỗi chữ cái tương ứng với vị trí của nó trong bảng chữ cái (A=1, B=2, ..., Z=26).\n\n  Hàm diễn giải dãy số dưới dạng số một chữ số hoặc hai chữ số (đại diện cho một chữ cái) để tối đa hóa thứ tự từ điển của chuỗi kết quả.\n\n  Tham số:\n  - encoded_sequence: Một chuỗi gồm các chữ số đại diện cho các vị trí chữ cái được mã hóa.\n\n  Trả về:\n  - Một chuỗi các chữ cái tiếng Anh viết hoa đại diện cho cách diễn giải lớn nhất có thể theo thứ tự từ điển của dãy mã hóa.\n\n  Ví dụ:\n  - max_lexicographic_string(\"123242526\") trả về \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") trả về \"WRS\"\n  - max_lexicographic_string(\"102\") trả về \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String "
    },
    "prompt_bertscore": {
      "es": "0.9710710740453168",
      "arb": "0.9736020223604633",
      "sw": "0.9517556599023412",
      "tr": "0.9766082931774264",
      "vi": "0.9690823866703955"
    },
    "canonical_solution": "{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_lexicographic_string(encoded_sequence: &str) -> String` to solve the following problem:\nConverts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "es": "Escribe una función en Rust `fn max_lexicographic_string(encoded_sequence: &str) -> String` para resolver el siguiente problema:\nConvierte una secuencia dada de números en la cadena más grande posible en orden lexicográfico de letras mayúsculas del alfabeto inglés, donde cada letra corresponde a su posición en el alfabeto (A=1, B=2, ..., Z=26).\n\n  La función interpreta la secuencia de números como un número de uno o dos dígitos (que representa una letra) para maximizar el orden lexicográfico de la cadena resultante.\n\n  Argumentos:\n  - encoded_sequence: Una cadena que consiste en dígitos que representan las posiciones de las letras codificadas.\n\n  Retorna:\n  - Una cadena de letras mayúsculas del alfabeto inglés que representa la interpretación más grande posible en orden lexicográfico de la secuencia codificada.\n\n  Ejemplos:\n  - max_lexicographic_string(\"123242526\") devuelve \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") devuelve \"WRS\"\n  - max_lexicographic_string(\"102\") devuelve \"JB\"",
      "arb": "اكتب دالة بلغة Rust `fn max_lexicographic_string(encoded_sequence: &str) -> String` لحل المشكلة التالية:\nتحول تسلسلًا معينًا من الأرقام إلى أكبر سلسلة ممكنة من الأحرف الإنجليزية الكبيرة حسب الترتيب المعجمي، حيث يتوافق كل حرف مع موقعه في الأبجدية (A=1, B=2, ..., Z=26).\n\nتفسر الدالة تسلسل الأرقام كرقم مكون من خانة واحدة أو رقم مكون من خانتين (يمثل حرفًا) لتعظيم الترتيب المعجمي للسلسلة الناتجة.\n\nالمعطيات:\n- encoded_sequence: سلسلة تتكون من أرقام تمثل مواقع الحروف المشفرة.\n\nالقيم المعادة:\n- سلسلة من الأحرف الإنجليزية الكبيرة التي تمثل أكبر تفسير ممكن حسب الترتيب المعجمي للتسلسل المشفر.\n\nأمثلة:\n- max_lexicographic_string(\"123242526\") تعيد \"LCXYZ\"\n- max_lexicographic_string(\"231819\") تعيد \"WRS\"\n- max_lexicographic_string(\"102\") تعيد \"JB\"",
      "sw": "Andika kazi ya Rust `fn max_lexicographic_string(encoded_sequence: &str) -> String` kutatua tatizo lifuatalo:\nInabadilisha mlolongo uliotolewa wa nambari kuwa herufi kubwa za Kiingereza zinazowezekana kwa mpangilio wa lexicographic, ambapo kila herufi inalingana na nafasi yake katika alfabeti (A=1, B=2, ..., Z=26).\n\n  Kazi hii inatafsiri mlolongo wa nambari kama nambari ya tarakimu moja au tarakimu mbili (inayowakilisha herufi) ili kuongeza mpangilio wa lexicographic wa mlolongo unaopatikana.\n\n  Hoja:\n  - encoded_sequence: Mlolongo wa herufi unaojumuisha tarakimu zinazowakilisha nafasi za herufi zilizofichwa.\n\n  Inarudisha:\n  - Mlolongo wa herufi kubwa za Kiingereza unaowakilisha tafsiri kubwa zaidi ya lexicographic inayowezekana ya mlolongo uliosimbwa.\n\n  Mifano:\n  - max_lexicographic_string(\"123242526\") inarudisha \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") inarudisha \"WRS\"\n  - max_lexicographic_string(\"102\") inarudisha \"JB\"",
      "tr": "Bir Rust fonksiyonu `fn max_lexicographic_string(encoded_sequence: &str) -> String` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı dizisini, her harfin alfabedeki konumuna karşılık geldiği (A=1, B=2, ..., Z=26) en büyük leksikografik sıraya sahip büyük harfli İngilizce harflerden oluşan bir dizeye dönüştürür.\n\n  Fonksiyon, sayı dizisini tek haneli veya çift haneli bir sayı (bir harfi temsil eden) olarak yorumlayarak, ortaya çıkan dizenin leksikografik sırasını maksimize eder.\n\n  Argümanlar:\n  - encoded_sequence: Kodlanmış harf pozisyonlarını temsil eden rakamlardan oluşan bir dize.\n\n  Döndürür:\n  - Kodlanmış dizinin leksikografik olarak en büyük olası yorumunu temsil eden büyük harfli İngilizce harflerden oluşan bir dize.\n\n  Örnekler:\n  - max_lexicographic_string(\"123242526\") \"LCXYZ\" döndürür\n  - max_lexicographic_string(\"231819\") \"WRS\" döndürür\n  - max_lexicographic_string(\"102\") \"JB\" döndürür",
      "vi": "Viết một hàm Rust `fn max_lexicographic_string(encoded_sequence: &str) -> String` để giải quyết vấn đề sau:\nChuyển đổi một dãy số cho trước thành chuỗi lớn nhất có thể theo thứ tự từ điển của các chữ cái tiếng Anh viết hoa, trong đó mỗi chữ cái tương ứng với vị trí của nó trong bảng chữ cái (A=1, B=2, ..., Z=26).\n\nHàm này diễn giải dãy số dưới dạng số một chữ số hoặc hai chữ số (đại diện cho một chữ cái) để tối đa hóa thứ tự từ điển của chuỗi kết quả.\n\nTham số:\n- encoded_sequence: Một chuỗi gồm các chữ số đại diện cho vị trí chữ cái được mã hóa.\n\nTrả về:\n- Một chuỗi các chữ cái tiếng Anh viết hoa đại diện cho cách diễn giải lớn nhất có thể theo thứ tự từ điển của dãy mã hóa.\n\nVí dụ:\n- max_lexicographic_string(\"123242526\") trả về \"LCXYZ\"\n- max_lexicographic_string(\"231819\") trả về \"WRS\"\n- max_lexicographic_string(\"102\") trả về \"JB\""
    },
    "instruction_bertscore": {
      "es": "0.9595973887152175",
      "arb": "0.9598599780789456",
      "sw": "0.9630346874590263",
      "tr": "0.9810878055305252",
      "vi": "0.9727256651193374"
    },
    "level": "hard",
    "test": "   \n#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_lexicographic_string(\"123242526\"), \"LCXYZ\");\n        assert_eq!(max_lexicographic_string(\"231819\"), \"WRS\");\n        assert_eq!(max_lexicographic_string(\"102\"), \"JB\");\n        assert_eq!(max_lexicographic_string(\"26\"), \"Z\");   \n    }\n    \n\n}",
    "entry_point": "max_lexicographic_string",
    "signature": "fn max_lexicographic_string(encoded_sequence: &str) -> String",
    "docstring": {
      "en": "Converts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "es": "Convierte una secuencia dada de números en la cadena más grande posible lexicográficamente de letras mayúsculas del alfabeto inglés, donde cada letra corresponde a su posición en el alfabeto (A=1, B=2, ..., Z=26).\n\n  La función interpreta la secuencia de números como un número de uno o dos dígitos (que representa una letra) para maximizar el orden lexicográfico de la cadena resultante.\n\n  Argumentos:\n  - encoded_sequence: Una cadena que consiste en dígitos que representan las posiciones de las letras codificadas.\n\n  Retorna:\n  - Una cadena de letras mayúsculas del alfabeto inglés que representa la interpretación más grande posible lexicográficamente de la secuencia codificada.\n\n  Ejemplos:\n  - max_lexicographic_string(\"123242526\") retorna \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") retorna \"WRS\"\n  - max_lexicographic_string(\"102\") retorna \"JB\"",
      "arb": "تحول تسلسل الأرقام المعطى إلى أكبر سلسلة ممكنة من الأحرف الإنجليزية الكبيرة بترتيب معجمي، حيث يتوافق كل حرف مع موضعه في الأبجدية (A=1, B=2, ..., Z=26).\n\nتفسر الدالة تسلسل الأرقام كرقم مكون من رقم واحد أو رقمين (يمثل حرفًا) لتعظيم الترتيب المعجمي للسلسلة الناتجة.\n\nالأوساط:\n- encoded_sequence: سلسلة تتكون من أرقام تمثل مواضع الأحرف المشفرة.\n\nالقيم المعادة:\n- سلسلة من الأحرف الإنجليزية الكبيرة التي تمثل أكبر تفسير ممكن بترتيب معجمي للتسلسل المشفر.\n\nأمثلة:\n- max_lexicographic_string(\"123242526\") تعيد \"LCXYZ\"\n- max_lexicographic_string(\"231819\") تعيد \"WRS\"\n- max_lexicographic_string(\"102\") تعيد \"JB\"",
      "sw": "Inabadilisha mlolongo uliotolewa wa nambari kuwa herufi kubwa za Kiingereza kwa mpangilio wa lexicographically mkubwa zaidi, ambapo kila herufi inalingana na nafasi yake katika alfabeti (A=1, B=2, ..., Z=26).\n\n  Kazi ya kifanyiko ni kutafsiri mlolongo wa namba kama namba ya tarakimu moja au mbili (inayowakilisha herufi) ili kuongeza mpangilio wa lexicographic wa herufi zinazotokana.\n\n  Hoja:\n  - encoded_sequence: Mlolongo wa herufi unaojumuisha tarakimu zinazowakilisha nafasi za herufi zilizofichwa.\n\n  Inarejesha:\n  - Mlolongo wa herufi kubwa za Kiingereza unaowakilisha tafsiri kubwa zaidi ya lexicographic inayowezekana ya mlolongo uliofichwa.\n\n  Mifano:\n  - max_lexicographic_string(\"123242526\") inarejesha \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") inarejesha \"WRS\"\n  - max_lexicographic_string(\"102\") inarejesha \"JB\"",
      "tr": "Verilen bir sayı dizisini, her harfin alfabedeki konumuna karşılık geldiği (A=1, B=2, ..., Z=26) en büyük sözlük sırasına sahip olabilecek şekilde büyük harfli İngilizce harflerden oluşan bir dizeye dönüştürür.\n\n  Fonksiyon, sayı dizisini (bir harfi temsil eden) tek haneli veya çift haneli bir sayı olarak yorumlayarak, ortaya çıkan dizenin sözlük sırasını en üst düzeye çıkarır.\n\n  Argümanlar:\n  - encoded_sequence: Kodlanmış harf konumlarını temsil eden rakamlardan oluşan bir dize.\n\n  Döndürür:\n  - Kodlanmış dizinin sözlük sırasına göre en büyük olası yorumunu temsil eden büyük harfli İngilizce harflerden oluşan bir dize.\n\n  Örnekler:\n  - max_lexicographic_string(\"123242526\") \"LCXYZ\" döndürür\n  - max_lexicographic_string(\"231819\") \"WRS\" döndürür\n  - max_lexicographic_string(\"102\") \"JB\" döndürür",
      "vi": "Chuyển đổi một dãy số đã cho thành chuỗi lớn nhất có thể theo thứ tự từ điển của các chữ cái tiếng Anh viết hoa, trong đó mỗi chữ cái tương ứng với vị trí của nó trong bảng chữ cái (A=1, B=2, ..., Z=26).\n\nHàm này diễn giải dãy số dưới dạng số một chữ số hoặc số hai chữ số (đại diện cho một chữ cái) để tối đa hóa thứ tự từ điển của chuỗi kết quả.\n\nCác tham số:\n- encoded_sequence: Một chuỗi gồm các chữ số đại diện cho các vị trí chữ cái được mã hóa.\n\nKết quả trả về:\n- Một chuỗi các chữ cái tiếng Anh viết hoa đại diện cho cách diễn giải lớn nhất có thể theo thứ tự từ điển của dãy mã hóa.\n\nVí dụ:\n- max_lexicographic_string(\"123242526\") trả về \"LCXYZ\"\n- max_lexicographic_string(\"231819\") trả về \"WRS\"\n- max_lexicographic_string(\"102\") trả về \"JB\""
    },
    "docstring_bertscore": {
      "es": "0.9670136512519172",
      "arb": "0.9668914935675808",
      "sw": "0.9604383897485193",
      "tr": "0.9422114700936148",
      "vi": "0.9595745462213985"
    }
  },
  {
    "task_id": "Rust/14",
    "prompt": {
      "en": "/*\n    Calculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "es": "/*\n    Calcula la suma máxima de números a lo largo de un camino desde la parte superior hasta la inferior de un triángulo numérico dado.\n\n    El camino se mueve hacia abajo ya sea al número más cercano a la izquierda o a la derecha en la siguiente fila. La diferencia entre el número de movimientos hacia la izquierda y hacia la derecha no debe exceder uno.\n\n    Argumentos:\n    - triangle: Un vector de vectores de i32, que representa las filas del triángulo numérico. Cada vector interno representa una fila en el triángulo.\n\n    Devuelve:\n    - La suma máxima alcanzable en cualquier camino válido desde la parte superior hasta la inferior del triángulo.\n\n    Ejemplos:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) devuelve 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) devuelve 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "arb": "/*\n    يحسب المجموع الأقصى للأرقام على طول مسار من القمة إلى القاع في مثلث رقمي معطى.\n\n    يتحرك المسار لأسفل إما إلى الرقم الأقرب إلى اليسار أو اليمين في الصف التالي. يجب ألا يتجاوز الفرق بين عدد الحركات إلى اليسار واليمين واحدًا.\n\n    المعطيات:\n    - triangle: متجه من المتجهات من i32، يمثل صفوف المثلث الرقمي. كل متجه داخلي يمثل صفًا في المثلث.\n\n    يعيد:\n    - المجموع الأقصى الممكن تحقيقه على أي مسار صالح من القمة إلى القاع في المثلث.\n\n    أمثلة:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) يعيد 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) يعيد 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "sw": "/*\n    Inahesabu jumla ya juu zaidi ya namba kando ya njia kutoka juu hadi chini ya pembetatu ya namba iliyotolewa.\n\n    Njia inasogea chini kwa ama namba ya karibu kushoto au kulia kwenye safu inayofuata. Tofauti kati ya idadi ya hatua kwenda kushoto na kulia haipaswi kuzidi moja.\n\n    Hoja:\n    - triangle: Kivector cha vectors cha i32, kinachowakilisha safu za pembetatu ya namba. Kila vector ya ndani inawakilisha safu kwenye pembetatu.\n\n    Inarudisha:\n    - Jumla ya juu zaidi inayoweza kupatikana kwenye njia yoyote halali kutoka juu hadi chini ya pembetatu.\n\n    Mifano:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) inarudisha 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) inarudisha 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "tr": "/*\n    Verilen sayısal bir üçgenin tepesinden tabanına kadar olan bir yoldaki maksimum sayı toplamını hesaplar.\n\n    Yol, bir sonraki satırdaki en yakın sol veya sağ sayıya doğru hareket eder. Sola ve sağa yapılan hareket sayıları arasındaki fark birden fazla olmamalıdır.\n\n    Argümanlar:\n    - triangle: Sayısal üçgenin satırlarını temsil eden i32 vektörlerinin bir vektörü. Her iç vektör üçgendeki bir satırı temsil eder.\n\n    Döndürür:\n    - Üçgenin tepesinden tabanına kadar geçerli herhangi bir yolda elde edilebilecek maksimum toplam.\n\n    Örnekler:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 27 döndürür\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 11 döndürür\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "vi": "/*\n    Tính tổng lớn nhất của các số dọc theo một đường đi từ đỉnh đến đáy của một tam giác số cho trước.\n\n    Đường đi di chuyển xuống đến số gần nhất bên trái hoặc bên phải ở hàng tiếp theo. Sự khác biệt giữa số lần di chuyển sang trái và sang phải không được vượt quá một.\n\n    Tham số:\n    - triangle: Một vector của các vector i32, đại diện cho các hàng của tam giác số. Mỗi vector bên trong đại diện cho một hàng trong tam giác.\n\n    Trả về:\n    - Tổng lớn nhất có thể đạt được trên bất kỳ đường đi hợp lệ nào từ đỉnh đến đáy của tam giác.\n\n    Ví dụ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) trả về 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) trả về 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9756683742143692",
      "arb": "0.9845552960922512",
      "sw": "0.9763737106974242",
      "tr": "0.9701756482876115",
      "vi": "0.9794941939834823"
    },
    "canonical_solution": "{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` to solve the following problem:\nCalculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "es": "Escribe una función de Rust `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` para resolver el siguiente problema:\nCalcula la suma máxima de números a lo largo de un camino desde la parte superior hasta la parte inferior de un triángulo numérico dado.\n\n    El camino se mueve hacia abajo ya sea al número más cercano a la izquierda o a la derecha en la siguiente fila. La diferencia entre el número de movimientos hacia la izquierda y hacia la derecha no debe exceder uno.\n\n    Argumentos:\n    - triangle: Un vector de vectores de i32, que representa las filas del triángulo numérico. Cada vector interno representa una fila en el triángulo.\n\n    Retorna:\n    - La suma máxima alcanzable en cualquier camino válido desde la parte superior hasta la parte inferior del triángulo.\n\n    Ejemplos:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) retorna 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) retorna 11",
      "arb": "اكتب دالة Rust `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` لحل المشكلة التالية:\nتحسب المجموع الأقصى للأرقام على طول مسار من أعلى إلى أسفل مثلث رقمي معين.\n\n    يتحرك المسار لأسفل إما إلى أقرب رقم على اليسار أو اليمين في الصف التالي. يجب ألا يتجاوز الفرق بين عدد الحركات إلى اليسار وإلى اليمين واحدًا.\n\n    الوسائط:\n    - triangle: متجه من المتجهات من i32، يمثل صفوف المثلث الرقمي. يمثل كل متجه داخلي صفًا في المثلث.\n\n    يعيد:\n    - المجموع الأقصى الممكن تحقيقه على أي مسار صالح من أعلى إلى أسفل المثلث.\n\n    أمثلة:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) يعيد 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) يعيد 11",
      "sw": "Andika kazi ya Rust `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` kutatua tatizo lifuatalo:\nInakokotoa jumla ya juu zaidi ya namba kando ya njia kutoka juu hadi chini ya pembetatu ya namba iliyotolewa.\n\nNjia inasogea chini hadi namba ya karibu ya kushoto au kulia kwenye safu inayofuata. Tofauti kati ya idadi ya hatua za kushoto na kulia haipaswi kuzidi moja.\n\nHoja:\n- triangle: Kifurushi cha vekta za i32, kinachowakilisha safu za pembetatu ya namba. Kila vekta ya ndani inawakilisha safu katika pembetatu.\n\nInarejesha:\n- Jumla ya juu zaidi inayoweza kupatikana kwenye njia yoyote halali kutoka juu hadi chini ya pembetatu.\n\nMifano:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) inarejesha 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) inarejesha 11",
      "tr": "Bir Rust fonksiyonu `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` yazarak aşağıdaki problemi çözün:\nVerilen sayısal bir üçgende, yukarıdan aşağıya bir yol boyunca sayıların maksimum toplamını hesaplar.\n\n    Yol, bir sonraki satırda ya en yakın soldaki ya da sağdaki sayıya doğru hareket eder. Sola ve sağa yapılan hareketlerin sayısı arasındaki fark birden fazla olmamalıdır.\n\n    Argümanlar:\n    - triangle: Sayısal üçgenin satırlarını temsil eden i32 vektörlerinin bir vektörü. Her iç vektör üçgendeki bir satırı temsil eder.\n\n    Döndürür:\n    - Üçgenin tepesinden tabanına kadar herhangi bir geçerli yolda elde edilebilecek maksimum toplam.\n\n    Örnekler:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 27 döndürür\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 11 döndürür",
      "vi": "Viết một hàm Rust `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` để giải quyết vấn đề sau:\nTính tổng lớn nhất của các số dọc theo một đường đi từ đỉnh đến đáy của một tam giác số đã cho.\n\n    Đường đi di chuyển xuống tới số gần nhất bên trái hoặc bên phải ở hàng tiếp theo. Sự khác biệt giữa số lần di chuyển sang trái và sang phải không được vượt quá một.\n\n    Tham số:\n    - triangle: Một vector của các vector của i32, đại diện cho các hàng của tam giác số. Mỗi vector bên trong đại diện cho một hàng trong tam giác.\n\n    Trả về:\n    - Tổng lớn nhất có thể đạt được trên bất kỳ đường đi hợp lệ nào từ đỉnh đến đáy của tam giác.\n\n    Ví dụ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) trả về 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) trả về 11"
    },
    "instruction_bertscore": {
      "es": "0.9875677244510264",
      "arb": "0.9943414177050781",
      "sw": "0.961683802237608",
      "tr": "0.9633101877975216",
      "vi": "0.9708172244183543"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]), 27);\n        assert_eq!(max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]), 8);      \n    }\n    \n\n}",
    "entry_point": "max_triangle_path_sum",
    "signature": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32",
    "docstring": {
      "en": "Calculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "es": "Calcula la suma máxima de números a lo largo de un camino desde la parte superior hasta la inferior de un triángulo numérico dado.\n\n    El camino se mueve hacia abajo, ya sea al número más cercano a la izquierda o a la derecha en la siguiente fila. La diferencia entre el número de movimientos hacia la izquierda y hacia la derecha no debe exceder uno.\n\n    Argumentos:\n    - triangle: Un vector de vectores de i32, que representa las filas del triángulo numérico. Cada vector interno representa una fila en el triángulo.\n\n    Retorna:\n    - La suma máxima alcanzable en cualquier camino válido desde la parte superior hasta la inferior del triángulo.\n\n    Ejemplos:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) devuelve 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) devuelve 11",
      "arb": "يحسب مجموع الأرقام الأقصى على طول مسار من الأعلى إلى الأسفل في مثلث رقمي معين.\n\n    يتحرك المسار إلى الأسفل إما إلى أقرب رقم على اليسار أو اليمين في الصف التالي. يجب ألا يتجاوز الفرق بين عدد التحركات إلى اليسار وإلى اليمين واحدًا.\n\n    يعيدالحجج:\n    - triangle: متجه من المتجهات من i32، يمثل صفوف المثلث الرقمي. كل متجه داخلي يمثل صفًا في المثلث.\n\n    يعيد:\n    - أقصى مجموع يمكن تحقيقه على أي مسار صالح من الأعلى إلى الأسفل في المثلث.\n\n    امثله:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) يعيد 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) يعيد 11",
      "sw": "Hesabu jumla ya juu zaidi ya nambari kwenye njia kutoka juu hadi chini ya pembetatu ya nambari iliyotolewa.\n\nNjia inasogea chini hadi kwenye nambari ya karibu kushoto au kulia kwenye safu inayofuata. Tofauti kati ya idadi ya hatua kwenda kushoto na kulia haipaswi kuzidi moja.\n\nHoja:\n- pembetatu: Vector ya vectors ya i32, inayowakilisha safu za pembetatu ya nambari. Kila vector ya ndani inawakilisha safu katika pembetatu.\n\nInarejesha:\n- Jumla ya juu zaidi inayoweza kupatikana kwenye njia yoyote halali kutoka juu hadi chini ya pembetatu.\n\nMifano:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) inarejesha 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) inarejesha 11",
      "tr": "Verilen sayısal üçgenin tepesinden tabanına kadar bir yol boyunca sayıların maksimum toplamını hesaplar.\n\nYol, bir sonraki satırdaki en yakın sol veya sağ sayıya doğru hareket eder. Sola ve sağa yapılan hareket sayısı arasındaki fark birden fazla olmamalıdır.\n\nArgümanlar:\n- triangle: Sayısal üçgenin satırlarını temsil eden i32 vektörlerinin bir vektörü. Her iç vektör üçgendeki bir satırı temsil eder.\n\nDöndürülenler:\n- Üçgenin tepesinden tabanına kadar herhangi bir geçerli yolda elde edilebilecek maksimum toplam.\n\nÖrnekler:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 27 döndürür\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 11 döndürür",
      "vi": "Tính tổng lớn nhất của các số dọc theo một đường đi từ đỉnh đến đáy của một tam giác số cho trước.\n\nĐường đi di chuyển xuống đến số gần nhất bên trái hoặc bên phải ở hàng tiếp theo. Sự khác biệt giữa số lần di chuyển sang trái và sang phải không được vượt quá một.\n\nCác đối số:\n- triangle: Một vector của các vector của i32, đại diện cho các hàng của tam giác số. Mỗi vector bên trong đại diện cho một hàng trong tam giác.\n\nTrả về:\n- Tổng lớn nhất có thể đạt được trên bất kỳ đường đi hợp lệ nào từ đỉnh đến đáy của tam giác.\n\nVí dụ:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) trả về 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) trả về 11"
    },
    "docstring_bertscore": {
      "es": "0.9793909061853442",
      "arb": "0.981815785877018",
      "sw": "0.9493772597198294",
      "tr": "0.9665647465907783",
      "vi": "0.9772997255338088"
    }
  },
  {
    "task_id": "Rust/15",
    "prompt": {
      "en": "\n/*\n    Calculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "es": "/*\n    Calcula el número de secciones distintas formadas en un plano por un conjunto dado de líneas.\n\n    Cada línea está representada por una tupla (pendiente, intersección con el eje y), siguiendo la ecuación y = pendiente * x + intersección con el eje y.\n    Esta función asume que las líneas no se superponen y que las líneas paralelas no contribuyen a nuevas secciones.\n\n    Argumentos:\n    - lines: Un slice de tuplas, donde cada tupla representa una línea en el plano con su pendiente e intersección con el eje y como (i32, i32).\n\n    Retorna:\n    - Un entero que representa el número total de secciones distintas formadas en el plano.\n\n    Ejemplo:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) retorna 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) retorna 2 (Líneas paralelas)\n    - count_plane_sections(&[]) retorna 0 (Sin líneas)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "arb": "/*\n    يحسب عدد الأقسام المميزة التي تتكون على المستوى بواسطة مجموعة معينة من الخطوط.\n\n    يتم تمثيل كل خط بزوج (ميل، تقاطع y)، وفقًا للمعادلة y = ميل * x + تقاطع y.\n    تفترض هذه الدالة أن الخطوط ليست متداخلة وأن الخطوط المتوازية لا تساهم في أقسام جديدة.\n\n    المعطيات:\n    - lines: شريحة من الأزواج، حيث يمثل كل زوج خطًا على المستوى مع ميله وتقاطع y كـ (i32، i32).\n\n    يعيد:\n    - عدد صحيح يمثل إجمالي عدد الأقسام المميزة التي تتكون على المستوى.\n\n    مثال:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) يعيد 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) يعيد 2 (خطوط متوازية)\n    - count_plane_sections(&[]) يعيد 0 (لا توجد خطوط)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize",
      "sw": "/*\n    Inahesabu idadi ya sehemu tofauti zinazoundwa kwenye ndege na seti fulani ya mistari.\n\n    Kila mstari unawakilishwa na jozi (mteremko, y-intercept), kufuatia mlinganyo y = mteremko * x + y-intercept.\n    Kazi hii inadhani mistari haipishani na mistari sambamba haichangii sehemu mpya.\n\n    Hoja:\n    - mistari: Sehemu ya jozi, ambapo kila jozi inawakilisha mstari kwenye ndege na mteremko wake na y-intercept kama (i32, i32).\n\n    Inarudisha:\n    - Nambari nzima inayowakilisha jumla ya idadi ya sehemu tofauti zinazoundwa kwenye ndege.\n\n    Mfano:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) inarudisha 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) inarudisha 2 (Mistari sambamba)\n    - count_plane_sections(&[]) inarudisha 0 (Hakuna mistari)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "tr": "/*\n    Verilen bir dizi doğru tarafından bir düzlemde oluşturulan farklı bölümlerin sayısını hesaplar.\n\n    Her doğru, y = slope * x + y-intercept denklemini takip eden bir (eğim, y-kesişimi) demeti ile temsil edilir.\n    Bu fonksiyon doğruların örtüşmediğini varsayar ve paralel doğrular yeni bölümlere katkıda bulunmaz.\n\n    Argümanlar:\n    - lines: Her bir demetin düzlemdeki bir doğruyu eğim ve y-kesişimi ile (i32, i32) olarak temsil ettiği bir demet dilimi.\n\n    Döndürür:\n    - Düzlemde oluşturulan toplam farklı bölümlerin sayısını temsil eden bir tamsayı.\n\n    Örnek:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 döndürür\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 döndürür (Paralel doğrular)\n    - count_plane_sections(&[]) 0 döndürür (Doğru yok)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "vi": "/*\n    Tính toán số lượng phần khác biệt được tạo ra trên một mặt phẳng bởi một tập hợp các đường thẳng cho trước.\n\n    Mỗi đường thẳng được biểu diễn bởi một bộ (hệ số góc, giao điểm y), theo phương trình y = hệ số góc * x + giao điểm y.\n    Hàm này giả định rằng các đường thẳng không trùng lặp và các đường thẳng song song không đóng góp vào các phần mới.\n\n    Tham số:\n    - lines: Một mảng các bộ, trong đó mỗi bộ đại diện cho một đường thẳng trên mặt phẳng với hệ số góc và giao điểm y của nó dưới dạng (i32, i32).\n\n    Trả về:\n    - Một số nguyên đại diện cho tổng số phần khác biệt được tạo ra trên mặt phẳng.\n\n    Ví dụ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) trả về 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) trả về 2 (Các đường thẳng song song)\n    - count_plane_sections(&[]) trả về 0 (Không có đường thẳng nào)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.985749263312652",
      "arb": "0.9758332374306282",
      "sw": "0.9840501790332795",
      "tr": "0.9813811826033138",
      "vi": "0.9708625121452302"
    },
    "canonical_solution": "{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` to solve the following problem:\nCalculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)",
      "es": "Escribe una función en Rust `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` para resolver el siguiente problema:\nCalcula el número de secciones distintas formadas en un plano por un conjunto dado de líneas.\n\n    Cada línea está representada por una tupla (pendiente, intersección-y), siguiendo la ecuación y = pendiente * x + intersección-y.\n    Esta función asume que las líneas no se superponen y las líneas paralelas no contribuyen a nuevas secciones.\n\n    Argumentos:\n    - lines: Un slice de tuplas, donde cada tupla representa una línea en el plano con su pendiente e intersección-y como (i32, i32).\n\n    Retorna:\n    - Un entero que representa el número total de secciones distintas formadas en el plano.\n\n    Ejemplo:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) devuelve 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) devuelve 2 (Líneas paralelas)\n    - count_plane_sections(&[]) devuelve 0 (Sin líneas)",
      "arb": "اكتب دالة Rust `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` لحل المشكلة التالية:\nتحسب عدد الأقسام المميزة التي تشكلت على مستوى بواسطة مجموعة معينة من الخطوط.\n\n    يتم تمثيل كل خط بواسطة زوج (الميل، التقاطع مع محور y)، وفقاً للمعادلة y = الميل * x + التقاطع مع محور y.\n    تفترض هذه الدالة أن الخطوط غير متداخلة وأن الخطوط المتوازية لا تساهم في تشكيل أقسام جديدة.\n\n    الوسائط:\n    - lines: جزء من الأزواج، حيث يمثل كل زوج خطاً على المستوى مع ميله وتقاطعه مع محور y كـ (i32, i32).\n\n    يعيد:\n    - عدد صحيح يمثل العدد الإجمالي للأقسام المميزة التي تشكلت على المستوى.\n\n    مثال:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) يعيد 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) يعيد 2 (خطوط متوازية)\n    - count_plane_sections(&[]) يعيد 0 (لا خطوط)",
      "sw": "Andika kazi ya Rust `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` kutatua tatizo lifuatalo:\nInahesabu idadi ya sehemu tofauti zinazoundwa kwenye ndege na seti fulani ya mistari.\n\n    Kila mstari unawakilishwa na jozi (mteremko, y-intercept), kufuata mlinganyo y = mteremko * x + y-intercept.\n    Kazi hii inadhani mistari haipishani na mistari inayolingana haichangii sehemu mpya.\n\n    Hoja:\n    - lines: Kipande cha jozi, ambapo kila jozi inawakilisha mstari kwenye ndege na mteremko wake na y-intercept kama (i32, i32).\n\n    Inarejesha:\n    - Nambari kamili inayowakilisha jumla ya idadi ya sehemu tofauti zinazoundwa kwenye ndege.\n\n    Mfano:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) inarejesha 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) inarejesha 2 (Mistari inayolingana)\n    - count_plane_sections(&[]) inarejesha 0 (Hakuna mistari)",
      "tr": "Bir Rust fonksiyonu `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` yazın ve aşağıdaki problemi çözün:\nVerilen bir dizi doğru tarafından bir düzlemde oluşturulan farklı bölümlerin sayısını hesaplar.\n\n    Her bir doğru, y = eğim * x + y-kesim noktası denklemini takip eden bir (eğim, y-kesim noktası) demeti ile temsil edilir.\n    Bu fonksiyon, doğruların üst üste binmediğini ve paralel doğruların yeni bölümlere katkıda bulunmadığını varsayar.\n\n    Argümanlar:\n    - lines: Her bir demetin düzlemdeki bir doğruyu eğim ve y-kesim noktası olarak (i32, i32) ile temsil ettiği bir demet dilimi.\n\n    Döner:\n    - Düzlemde oluşturulan toplam farklı bölüm sayısını temsil eden bir tamsayı.\n\n    Örnek:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 döner\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 döner (Paralel doğrular)\n    - count_plane_sections(&[]) 0 döner (Doğru yok)",
      "vi": "Viết một hàm Rust `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` để giải quyết vấn đề sau:\nTính toán số lượng phần khác biệt được tạo ra trên một mặt phẳng bởi một tập hợp các đường thẳng cho trước.\n\n    Mỗi đường thẳng được biểu diễn bằng một bộ (hệ số góc, giao điểm y), theo phương trình y = hệ số góc * x + giao điểm y.\n    Hàm này giả định rằng các đường thẳng không trùng lặp và các đường thẳng song song không đóng góp vào các phần mới.\n\n    Tham số:\n    - lines: Một lát cắt của các bộ, trong đó mỗi bộ đại diện cho một đường thẳng trên mặt phẳng với hệ số góc và giao điểm y của nó là (i32, i32).\n\n    Trả về:\n    - Một số nguyên đại diện cho tổng số phần khác biệt được tạo ra trên mặt phẳng.\n\n    Ví dụ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) trả về 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) trả về 2 (Đường thẳng song song)\n    - count_plane_sections(&[]) trả về 0 (Không có đường thẳng nào)"
    },
    "instruction_bertscore": {
      "es": "0.9860301266714353",
      "arb": "0.9720844862493568",
      "sw": "0.9725536512093612",
      "tr": "0.9762388406687015",
      "vi": "0.9863107913998376"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_plane_sections(&[(1, 1), (2, 2), (3, 3)]), 6);\n        assert_eq!(count_plane_sections(&[(0, 1), (0, 2)]), 3);\n    }\n    \n\n}\n ",
    "entry_point": "count_plane_sections",
    "signature": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize",
    "docstring": {
      "en": "Calculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)",
      "es": "Calcula el número de secciones distintas formadas en un plano por un conjunto dado de líneas.\n\n    Cada línea está representada por una tupla (pendiente, intersección en y), siguiendo la ecuación y = pendiente * x + intersección en y.\n    Esta función asume que las líneas no se superponen y que las líneas paralelas no contribuyen a nuevas secciones.\n\n    Argumentos:\n    - lines: Un segmento de tuplas, donde cada tupla representa una línea en el plano con su pendiente e intersección en y como (i32, i32).\n\n    Retorna:\n    - Un entero que representa el número total de secciones distintas formadas en el plano.\n\n    Ejemplo:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) retorna 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) retorna 2 (Líneas paralelas)\n    - count_plane_sections(&[]) retorna 0 (Sin líneas)",
      "arb": "يحسب عدد الأقسام المميزة التي تتشكل على مستوى بواسطة مجموعة معينة من الخطوط.\n\n    يتم تمثيل كل خط بواسطة زوج (الميل، التقاطع مع المحور y)، وفقًا للمعادلة y = الميل * x + التقاطع مع المحور y.\n    تفترض هذه الدالة أن الخطوط غير متداخلة وأن الخطوط المتوازية لا تساهم في أقسام جديدة.\n\n    الحجج:\n    - lines: جزء من الأزواج، حيث يمثل كل زوج خطًا على المستوى بميله وتقاطعه مع المحور y كـ (i32, i32).\n\n    يعيد:\n    - عدد صحيح يمثل العدد الإجمالي للأقسام المميزة التي تتشكل على المستوى.\n\n    مثال:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) يعيد 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) يعيد 2 (خطوط متوازية)\n    - count_plane_sections(&[]) يعيد 0 (لا توجد خطوط)",
      "sw": "Hesabu idadi ya sehemu tofauti zinazoundwa kwenye ndege na seti fulani ya mistari.\n\n    Kila mstari unawakilishwa na jozi (mwelekeo, y-intercept), kufuata mlinganyo y = mwelekeo * x + y-intercept.\n    Kazi hii inadhani mistari haijakutana na mistari sambamba haichangii sehemu mpya.\n\n    Hoja:\n    - mistari: Sehemu ya jozi, ambapo kila jozi inawakilisha mstari kwenye ndege na mwelekeo wake na y-intercept kama (i32, i32).\n\n    Inarudisha:\n    - Nambari kamili inayowakilisha jumla ya idadi ya sehemu tofauti zinazoundwa kwenye ndege.\n\n    Mfano:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) inarudisha 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) inarudisha 2 (Mistari sambamba)\n    - count_plane_sections(&[]) inarudisha 0 (Hakuna mistari)",
      "tr": "Uçakta verilen bir dizi çizgi tarafından oluşturulan farklı bölümlerin sayısını hesaplar.\n\n    Her çizgi, y = slope * x + y-intercept denklemini takip eden bir (eğim, y-kesişimi) demeti ile temsil edilir.\n    Bu fonksiyon, çizgilerin üst üste gelmediğini ve paralel çizgilerin yeni bölümler oluşturmadığını varsayar.\n\n    Argümanlar:\n    - lines: Her bir demetin eğim ve y-kesişimi (i32, i32) olarak düzlemde bir çizgiyi temsil ettiği bir demet dilimi.\n\n    Döndürür:\n    - Düzlemde oluşturulan toplam farklı bölüm sayısını temsil eden bir tamsayı.\n\n    Örnek:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 döndürür\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 döndürür (Paralel çizgiler)\n    - count_plane_sections(&[]) 0 döndürür (Çizgi yok)",
      "vi": "Tính toán số lượng phần riêng biệt được tạo ra trên một mặt phẳng bởi một tập hợp các đường thẳng cho trước.\n\nMỗi đường thẳng được biểu diễn bằng một bộ giá trị (độ dốc, giao điểm y), theo phương trình y = độ dốc * x + giao điểm y. Hàm này giả định rằng các đường thẳng không trùng lặp và các đường thẳng song song không đóng góp vào các phần mới.\n\nTham số:\n- lines: Một mảng các bộ giá trị, trong đó mỗi bộ giá trị đại diện cho một đường thẳng trên mặt phẳng với độ dốc và giao điểm y của nó là (i32, i32).\n\nTrả về:\n- Một số nguyên đại diện cho tổng số phần riêng biệt được tạo ra trên mặt phẳng.\n\nVí dụ:\n- count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) trả về 6\n- count_plane_sections(&[(0, 1), (0, 2)]) trả về 2 (Các đường thẳng song song)\n- count_plane_sections(&[]) trả về 0 (Không có đường thẳng nào)"
    },
    "docstring_bertscore": {
      "es": "0.9793094677291199",
      "arb": "0.9729523023840982",
      "sw": "0.963237489078063",
      "tr": "0.9686064682774359",
      "vi": "0.9678355837686395"
    }
  },
  {
    "task_id": "Rust/16",
    "prompt": {
      "en": "\n/*\n  Calculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "es": "/*\n  Calcula el número de pesos distintos que se pueden medir usando un conjunto dado de pesas en una balanza.\n  Las pesas se pueden colocar en cualquiera de los lados de la balanza, y la misma pesa no se puede usar más de una vez.\n\n  Argumentos:\n  - weights: Una porción de enteros que representa las pesas.\n\n  Devuelve:\n  - El número total de pesos distintos que se pueden medir.\n\n  Ejemplo:\n  - distinct_weights_count(&[1, 4, 6]) devuelve 10\n  - distinct_weights_count(&[2, 3]) devuelve 5 (pesas: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) devuelve 1 (solo se puede medir cero)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "arb": "/*\n  يحسب عدد الأوزان المميزة التي يمكن قياسها باستخدام مجموعة معينة من الأوزان على ميزان.\n  يمكن وضع الأوزان على أي من جانبي الميزان، ولا يمكن استخدام الوزن نفسه أكثر من مرة.\n\n  المعطيات:\n  - weights: مجموعة من الأعداد الصحيحة تمثل الأوزان.\n\n  يعيد:\n  - العدد الإجمالي للأوزان المميزة التي يمكن قياسها.\n\n  مثال:\n  - distinct_weights_count(&[1, 4, 6]) يعيد 10\n  - distinct_weights_count(&[2, 3]) يعيد 5 (الأوزان: 1، 2، 3، 5)\n  - distinct_weights_count(&[]) يعيد 1 (فقط الصفر يمكن قياسه)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ya uzito tofauti ambao unaweza kupimwa kwa kutumia seti fulani ya uzito kwenye mizani.\n  Uzito unaweza kuwekwa upande wowote wa mizani, na uzito huo huo hauwezi kutumiwa zaidi ya mara moja.\n\n  Hoja:\n  - weights: Sehemu ya nambari za mzima inayowakilisha uzito.\n\n  Inarudisha:\n  - Jumla ya idadi ya uzito tofauti ambao unaweza kupimwa.\n\n  Mfano:\n  - distinct_weights_count(&[1, 4, 6]) inarudisha 10\n  - distinct_weights_count(&[2, 3]) inarudisha 5 (uzito: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) inarudisha 1 (ni sifuri pekee inayoweza kupimwa)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "tr": "/*\n  Bir terazi üzerinde verilen bir ağırlık seti kullanılarak ölçülebilecek farklı ağırlıkların sayısını hesaplar.\n  Ağırlıklar terazinin her iki tarafına da yerleştirilebilir ve aynı ağırlık birden fazla kez kullanılamaz.\n\n  Argümanlar:\n  - weights: Ağırlıkları temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Ölçülebilecek toplam farklı ağırlık sayısı.\n\n  Örnek:\n  - distinct_weights_count(&[1, 4, 6]) 10 döndürür\n  - distinct_weights_count(&[2, 3]) 5 döndürür (ağırlıklar: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 1 döndürür (sadece sıfır ölçülebilir)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "vi": "/*\n  Tính toán số lượng trọng lượng khác nhau có thể đo được bằng cách sử dụng một tập hợp các quả cân trên cân thăng bằng.\n  Các quả cân có thể được đặt ở bất kỳ bên nào của cân, và cùng một quả cân không thể được sử dụng nhiều hơn một lần.\n\n  Tham số:\n  - weights: Một mảng số nguyên đại diện cho các quả cân.\n\n  Trả về:\n  - Tổng số lượng trọng lượng khác nhau có thể đo được.\n\n  Ví dụ:\n  - distinct_weights_count(&[1, 4, 6]) trả về 10\n  - distinct_weights_count(&[2, 3]) trả về 5 (trọng lượng: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) trả về 1 (chỉ có thể đo được số không)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9937042114427181",
      "arb": "0.9773577256050711",
      "sw": "0.9729763366602034",
      "tr": "0.9752629696066771",
      "vi": "0.9693398116442167"
    },
    "canonical_solution": "{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}",
    "instruction": {
      "en": "Write a Rust function `fn distinct_weights_count(weights: &[i32]) -> i32` to solve the following problem:\nCalculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)",
      "es": "Escribe una función de Rust `fn distinct_weights_count(weights: &[i32]) -> i32` para resolver el siguiente problema:\nCalcula el número de pesos distintos que se pueden medir usando un conjunto dado de pesos en una balanza.\n  Los pesos pueden colocarse en cualquiera de los lados de la balanza, y el mismo peso no puede usarse más de una vez.\n\n  Argumentos:\n  - weights: Un slice de enteros que representa los pesos.\n\n  Retorna:\n  - El número total de pesos distintos que se pueden medir.\n\n  Ejemplo:\n  - distinct_weights_count(&[1, 4, 6]) devuelve 10\n  - distinct_weights_count(&[2, 3]) devuelve 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) devuelve 1 (solo se puede medir cero)",
      "arb": "اكتب دالة Rust `fn distinct_weights_count(weights: &[i32]) -> i32` لحل المشكلة التالية:\nتحسب عدد الأوزان المختلفة التي يمكن قياسها باستخدام مجموعة معينة من الأوزان على ميزان.\n\nيمكن وضع الأوزان على أي جانب من الميزان، ولا يمكن استخدام الوزن نفسه أكثر من مرة.\n\nالمعاملات:\n- weights: شريحة من الأعداد الصحيحة تمثل الأوزان.\n\nالقيم المعادة:\n- العدد الإجمالي للأوزان المختلفة التي يمكن قياسها.\n\nمثال:\n- distinct_weights_count(&[1, 4, 6]) يعيد 10\n- distinct_weights_count(&[2, 3]) يعيد 5 (weights: 1, 2, 3, 5)\n- distinct_weights_count(&[]) يعيد 1 (only zero can be measured)",
      "sw": "Andika kazi ya Rust `fn distinct_weights_count(weights: &[i32]) -> i32` kutatua tatizo lifuatalo:\nHesabu idadi ya uzito tofauti ambao unaweza kupimwa kwa kutumia seti fulani ya uzito kwenye mizani.\n  Uzito unaweza kuwekwa upande wowote wa mizani, na uzito huo huo hauwezi kutumika zaidi ya mara moja.\n\n  Hoja:\n  - weights: Sehemu ya nambari za mzima inayowakilisha uzito.\n\n  Inarudisha:\n  - Jumla ya idadi ya uzito tofauti ambao unaweza kupimwa.\n\n  Mfano:\n  - distinct_weights_count(&[1, 4, 6]) inarudisha 10\n  - distinct_weights_count(&[2, 3]) inarudisha 5 (uzito: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) inarudisha 1 (ni sifuri pekee inayoweza kupimwa)",
      "tr": "Bir Rust fonksiyonu `fn distinct_weights_count(weights: &[i32]) -> i32` yazın:\nVerilen bir ağırlık setini kullanarak bir denge terazisinde ölçülebilecek farklı ağırlıkların sayısını hesaplar.\n  Ağırlıklar terazinin her iki tarafına da yerleştirilebilir ve aynı ağırlık birden fazla kullanılamaz.\n\n  Argümanlar:\n  - weights: Ağırlıkları temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Ölçülebilecek toplam farklı ağırlık sayısı.\n\n  Örnek:\n  - distinct_weights_count(&[1, 4, 6]) 10 döndürür\n  - distinct_weights_count(&[2, 3]) 5 döndürür (ağırlıklar: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 1 döndürür (sadece sıfır ölçülebilir)",
      "vi": "Viết một hàm Rust `fn distinct_weights_count(weights: &[i32]) -> i32` để giải quyết vấn đề sau:\nTính toán số lượng trọng lượng khác nhau có thể đo được bằng cách sử dụng một tập hợp trọng lượng cho trước trên một cân thăng bằng.\n  Các trọng lượng có thể được đặt ở bất kỳ bên nào của cân, và cùng một trọng lượng không thể được sử dụng nhiều hơn một lần.\n\n  Tham số:\n  - weights: Một lát cắt của các số nguyên đại diện cho các trọng lượng.\n\n  Trả về:\n  - Tổng số trọng lượng khác nhau có thể đo được.\n\n  Ví dụ:\n  - distinct_weights_count(&[1, 4, 6]) trả về 10\n  - distinct_weights_count(&[2, 3]) trả về 5 (trọng lượng: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) trả về 1 (chỉ có thể đo được số không)"
    },
    "instruction_bertscore": {
      "es": "0.9881042251102016",
      "arb": "0.9796306530552532",
      "sw": "0.972051910866867",
      "tr": "0.9627081391126049",
      "vi": "0.9819784641590856"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(distinct_weights_count(&[1, 4, 6]), 10);\n        assert_eq!(distinct_weights_count(&[2, 3]), 4);\n        assert_eq!(distinct_weights_count(&[]), 0);\n        assert_eq!(distinct_weights_count(&[1, 2, 2]), 5);  \n        \n    }\n    \n\n}",
    "entry_point": "distinct_weights_count",
    "signature": "fn distinct_weights_count(weights: &[i32]) -> i32",
    "docstring": {
      "en": "Calculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)",
      "es": "Calcula el número de pesos distintos que se pueden medir utilizando un conjunto dado de pesos en una balanza.\n  Los pesos pueden colocarse en cualquiera de los lados de la balanza, y el mismo peso no puede usarse más de una vez.\n\n  Argumentos:\n  - weights: Un slice de enteros que representa los pesos.\n\n  Retorna:\n  - El número total de pesos distintos que se pueden medir.\n\n  Ejemplo:\n  - distinct_weights_count(&[1, 4, 6]) retorna 10\n  - distinct_weights_count(&[2, 3]) retorna 5 (pesos: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) retorna 1 (solo se puede medir cero)",
      "arb": "يحسب عدد الأوزان المميزة التي يمكن قياسها باستخدام مجموعة معينة من الأوزان على ميزان.\nيمكن وضع الأوزان على أي جانب من الميزان، ولا يمكن استخدام نفس الوزن أكثر من مرة.\n\n  الحجج:\n  - weights: شريحة من الأعداد الصحيحة تمثل الأوزان.\n\n  العوائد:\n  - العدد الإجمالي للأوزان المميزة التي يمكن قياسها.\n\n  مثال:\n  - distinct_weights_count(&[1, 4, 6]) يعيد 10\n  - distinct_weights_count(&[2, 3]) يعيد 5 (الأوزان: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) يعيد 1 (يمكن قياس الصفر فقط)",
      "sw": "Hesabu idadi ya uzito tofauti ambao unaweza kupimwa kwa kutumia seti iliyotolewa ya uzito kwenye mizani ya usawa.\n  Uzito unaweza kuwekwa upande wowote wa mizani, na uzito huo huo hauwezi kutumiwa zaidi ya mara moja.\n\n  Hoja:\n  - weights: Sehemu ya nambari za mzima inayowakilisha uzito.\n\n  Inarudisha:\n  - Jumla ya idadi ya uzito tofauti ambao unaweza kupimwa.\n\n  Mfano:\n  - distinct_weights_count(&[1, 4, 6]) inarudisha 10\n  - distinct_weights_count(&[2, 3]) inarudisha 5 (uzito: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) inarudisha 1 (ni sifuri pekee inayoweza kupimwa)",
      "tr": "Belirli bir ağırlık seti kullanılarak bir denge terazisinde ölçülebilecek farklı ağırlıkların sayısını hesaplar. \nAğırlıklar terazinin her iki tarafına yerleştirilebilir ve aynı ağırlık birden fazla kez kullanılamaz.\n\nArgümanlar:\n- weights: Ağırlıkları temsil eden bir tamsayı dilimi.\n\nDöndürür:\n- Ölçülebilecek toplam farklı ağırlık sayısı.\n\nÖrnek:\n- distinct_weights_count(&[1, 4, 6]) 10 döndürür\n- distinct_weights_count(&[2, 3]) 5 döndürür (ağırlıklar: 1, 2, 3, 5)\n- distinct_weights_count(&[]) 1 döndürür (sadece sıfır ölçülebilir)",
      "vi": "Tính toán số lượng trọng lượng khác nhau có thể đo được bằng cách sử dụng một tập hợp trọng lượng cho trước trên một cái cân thăng bằng. Các trọng lượng có thể được đặt ở hai bên của cân, và cùng một trọng lượng không thể được sử dụng nhiều hơn một lần.\n\nTham số:\n- weights: Một mảng số nguyên đại diện cho các trọng lượng.\n\nTrả về:\n- Tổng số trọng lượng khác nhau có thể đo được.\n\nVí dụ:\n- distinct_weights_count(&[1, 4, 6]) trả về 10\n- distinct_weights_count(&[2, 3]) trả về 5 (trọng lượng: 1, 2, 3, 5)\n- distinct_weights_count(&[]) trả về 1 (chỉ có thể đo được số không)"
    },
    "docstring_bertscore": {
      "es": "0.9861916131712166",
      "arb": "0.9871519910635204",
      "sw": "0.9680586456865417",
      "tr": "0.9758809087220767",
      "vi": "0.9817198474029782"
    }
  },
  {
    "task_id": "Rust/17",
    "prompt": {
      "en": "/*\n  Finds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "es": "/*\n  Encuentra el sueño de mayor valor que está dentro de la capacidad del usuario.\n\n  Esta función toma un arreglo de valores de sueños y la puntuación de capacidad del usuario. Devuelve el valor del sueño más alto que no excede la capacidad del usuario.\n\n  Argumentos:\n  - dreams: Un arreglo de enteros sin signo de 32 bits, cada uno representando la capacidad requerida para un sueño.\n  - ability: Un entero sin signo de 32 bits que representa la puntuación de capacidad del usuario.\n\n  Devuelve:\n  - El valor del sueño que es el más alto pero aún dentro de la capacidad del usuario.\n\n  Ejemplos:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) devuelve 98\n  - max_dream_within_ability(&[20, 40, 60], 50) devuelve 40\n  - max_dream_within_ability(&[10, 20, 30], 5) devuelve 0 (Ningún sueño dentro de la capacidad)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "arb": "/*\n  يجد الحلم ذو القيمة الأعلى الذي يكون ضمن قدرة المستخدم.\n\n  تأخذ هذه الدالة مصفوفة من قيم الأحلام ودرجة قدرة المستخدم. وتعيد أعلى قيمة حلم لا تتجاوز قدرة المستخدم.\n\n  الحجج:\n  - dreams: مصفوفة من الأعداد الصحيحة غير الموقعة 32 بت، كل منها يمثل القدرة المطلوبة لحلم.\n  - ability: عدد صحيح غير موقع 32 بت يمثل درجة قدرة المستخدم.\n\n  يعيد:\n  - قيمة الحلم التي هي الأعلى ولكن لا تزال ضمن قدرة المستخدم.\n\n  أمثلة:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) يعيد 98\n  - max_dream_within_ability(&[20, 40, 60], 50) يعيد 40\n  - max_dream_within_ability(&[10, 20, 30], 5) يعيد 0 (لا يوجد حلم ضمن القدرة)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "sw": "/*\n  Inapata ndoto yenye thamani ya juu zaidi ambayo iko ndani ya uwezo wa mtumiaji.\n\n  Kazi hii inachukua safu ya thamani za ndoto na alama ya uwezo wa mtumiaji. Inarudisha thamani ya juu zaidi ya ndoto ambayo haizidi uwezo wa mtumiaji.\n\n  Hoja:\n  - dreams: Safu ya namba zisizo na alama za biti 32, kila moja ikiwakilisha uwezo unaohitajika kwa ndoto.\n  - ability: Namba isiyo na alama ya biti 32 inayowakilisha alama ya uwezo wa mtumiaji.\n\n  Inarudisha:\n  - Thamani ya ndoto ambayo ni ya juu zaidi lakini bado iko ndani ya uwezo wa mtumiaji.\n\n  Mifano:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) inarudisha 98\n  - max_dream_within_ability(&[20, 40, 60], 50) inarudisha 40\n  - max_dream_within_ability(&[10, 20, 30], 5) inarudisha 0 (Hakuna ndoto ndani ya uwezo)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "tr": "/*\n  Kullanıcının yeteneği dahilinde olan en yüksek değerli hayali bulur.\n\n  Bu fonksiyon, hayal değerlerinin bir dizisini ve kullanıcının yetenek puanını alır. Kullanıcının yeteneğini aşmayan en yüksek hayal değerini döndürür.\n\n  Argümanlar:\n  - dreams: Her biri bir hayal için gereken yeteneği temsil eden, 32-bit işaretsiz tamsayıların bir dizisi.\n  - ability: Kullanıcının yetenek puanını temsil eden, 32-bit işaretsiz bir tamsayı.\n\n  Döndürür:\n  - Kullanıcının yeteneği dahilinde olan en yüksek hayalin değeri.\n\n  Örnekler:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 döndürür\n  - max_dream_within_ability(&[20, 40, 60], 50) 40 döndürür\n  - max_dream_within_ability(&[10, 20, 30], 5) 0 döndürür (Yetenek dahilinde hayal yok)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "vi": "/*\n  Tìm giấc mơ có giá trị cao nhất nằm trong khả năng của người dùng.\n\n  Hàm này nhận một mảng các giá trị giấc mơ và điểm khả năng của người dùng. Nó trả về giá trị giấc mơ cao nhất mà không vượt quá khả năng của người dùng.\n\n  Tham số:\n  - dreams: Một mảng các số nguyên không dấu 32-bit, mỗi số đại diện cho khả năng cần thiết cho một giấc mơ.\n  - ability: Một số nguyên không dấu 32-bit đại diện cho điểm khả năng của người dùng.\n\n  Trả về:\n  - Giá trị của giấc mơ cao nhất nhưng vẫn nằm trong khả năng của người dùng.\n\n  Ví dụ:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) trả về 98\n  - max_dream_within_ability(&[20, 40, 60], 50) trả về 40\n  - max_dream_within_ability(&[10, 20, 30], 5) trả về 0 (Không có giấc mơ nào trong khả năng)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 "
    },
    "prompt_bertscore": {
      "es": "0.9611850413508294",
      "arb": "0.9789030699695225",
      "sw": "0.9787143711075393",
      "tr": "0.9716484925629852",
      "vi": "0.9692023594205406"
    },
    "canonical_solution": "{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` to solve the following problem:\nFinds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)",
      "es": "Escribe una función en Rust `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` para resolver el siguiente problema:\nEncuentra el sueño de mayor valor que esté dentro de la habilidad del usuario.\n\n  Esta función toma un arreglo de valores de sueños y la puntuación de habilidad del usuario. Devuelve el valor del sueño más alto que no excede la habilidad del usuario.\n\n  Argumentos:\n  - dreams: Un arreglo de enteros sin signo de 32 bits, cada uno representando la habilidad requerida para un sueño.\n  - ability: Un entero sin signo de 32 bits que representa la puntuación de habilidad del usuario.\n\n  Devuelve:\n  - El valor del sueño que es el más alto pero aún dentro de la habilidad del usuario.\n\n  Ejemplos:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) devuelve 98\n  - max_dream_within_ability(&[20, 40, 60], 50) devuelve 40\n  - max_dream_within_ability(&[10, 20, 30], 5) devuelve 0 (Ningún sueño dentro de la habilidad)",
      "arb": "اكتب دالة بلغة Rust `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` لحل المشكلة التالية:\nتجد الحلم الأعلى قيمة الذي يكون ضمن قدرة المستخدم.\n\nتأخذ هذه الدالة مصفوفة من قيم الأحلام ودرجة قدرة المستخدم. وتعيد أعلى قيمة حلم لا تتجاوز قدرة المستخدم.\n\nالمعاملات:\n- dreams: مصفوفة من الأعداد الصحيحة غير الموقعة 32 بت، كل منها يمثل القدرة المطلوبة لحلم.\n- ability: عدد صحيح غير موقع 32 بت يمثل درجة قدرة المستخدم.\n\nالقيم المعادة:\n- قيمة الحلم الذي هو الأعلى ولكنه لا يزال ضمن قدرة المستخدم.\n\nأمثلة:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) يعيد 98\n- max_dream_within_ability(&[20, 40, 60], 50) يعيد 40\n- max_dream_within_ability(&[10, 20, 30], 5) يعيد 0 (لا يوجد حلم ضمن القدرة)",
      "sw": "Andika kazi ya Rust `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` kutatua tatizo lifuatalo:\nInapata ndoto yenye thamani ya juu zaidi ambayo iko ndani ya uwezo wa mtumiaji.\n\n  Kazi hii inachukua safu ya thamani za ndoto na alama ya uwezo wa mtumiaji. Inarudisha thamani ya juu zaidi ya ndoto ambayo haizidi uwezo wa mtumiaji.\n\n  Hoja:\n  - dreams: Safu ya namba zisizo na ishara za biti 32, kila moja ikiwakilisha uwezo unaohitajika kwa ndoto.\n  - ability: Namba isiyo na ishara ya biti 32 inayowakilisha alama ya uwezo wa mtumiaji.\n\n  Inarudisha:\n  - Thamani ya ndoto ambayo ni ya juu zaidi lakini bado iko ndani ya uwezo wa mtumiaji.\n\n  Mifano:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) inarudisha 98\n  - max_dream_within_ability(&[20, 40, 60], 50) inarudisha 40\n  - max_dream_within_ability(&[10, 20, 30], 5) inarudisha 0 (Hakuna ndoto ndani ya uwezo)",
      "tr": "Bir Rust fonksiyonu `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` yazarak aşağıdaki problemi çözün:\nKullanıcının yeteneği dahilindeki en yüksek değerli hayali bulur.\n\n  Bu fonksiyon, hayal değerlerinin bir dizisini ve kullanıcının yetenek puanını alır. Kullanıcının yeteneğini aşmayan en yüksek hayal değerini döndürür.\n\n  Argümanlar:\n  - dreams: Her biri bir hayal için gereken yeteneği temsil eden, işaretsiz 32-bit tamsayıların bir dizisi.\n  - ability: Kullanıcının yetenek puanını temsil eden işaretsiz 32-bit bir tamsayı.\n\n  Döndürür:\n  - Kullanıcının yeteneği dahilinde olan en yüksek hayalin değeri.\n\n  Örnekler:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 döndürür\n  - max_dream_within_ability(&[20, 40, 60], 50) 40 döndürür\n  - max_dream_within_ability(&[10, 20, 30], 5) 0 döndürür (Yetenek dahilinde hayal yok)",
      "vi": "Viết một hàm Rust `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` để giải quyết vấn đề sau:\nTìm giấc mơ có giá trị cao nhất nằm trong khả năng của người dùng.\n\nHàm này nhận một mảng các giá trị giấc mơ và điểm khả năng của người dùng. Nó trả về giá trị giấc mơ cao nhất không vượt quá khả năng của người dùng.\n\nTham số:\n- dreams: Một mảng các số nguyên không dấu 32-bit, mỗi số đại diện cho khả năng cần thiết cho một giấc mơ.\n- ability: Một số nguyên không dấu 32-bit đại diện cho điểm khả năng của người dùng.\n\nTrả về:\n- Giá trị của giấc mơ cao nhất nhưng vẫn nằm trong khả năng của người dùng.\n\nVí dụ:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) trả về 98\n- max_dream_within_ability(&[20, 40, 60], 50) trả về 40\n- max_dream_within_ability(&[10, 20, 30], 5) trả về 0 (Không có giấc mơ nào trong khả năng)"
    },
    "instruction_bertscore": {
      "es": "0.9858160031206796",
      "arb": "0.9770681225095221",
      "sw": "0.9821653753476395",
      "tr": "0.9696504695601553",
      "vi": "0.9694276062726341"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_dream_within_ability(&[50, 69, 240, 135, 98], 100), 98);\n        assert_eq!(max_dream_within_ability(&[20, 40, 60], 50), 40);\n        assert_eq!(max_dream_within_ability(&[10, 20, 30], 5), 0); // No dream within ability\n        assert_eq!(max_dream_within_ability(&[120, 200, 300, 400], 350), 300);\n    \n    }\n    \n\n}",
    "entry_point": "max_dream_within_ability",
    "signature": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32",
    "docstring": {
      "en": "Finds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)",
      "es": "Encuentra el sueño de mayor valor que está dentro de la capacidad del usuario.\n\n  Esta función toma un arreglo de valores de sueños y la puntuación de capacidad del usuario. Devuelve el valor del sueño más alto que no excede la capacidad del usuario.\n\n  Argumentos:\n  - dreams: Un arreglo de enteros sin signo de 32 bits, cada uno representando la capacidad requerida para un sueño.\n  - ability: Un entero sin signo de 32 bits que representa la puntuación de capacidad del usuario.\n\n  Devuelve:\n  - El valor del sueño que es el más alto pero aún dentro de la capacidad del usuario.\n\n  Ejemplos:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) devuelve 98\n  - max_dream_within_ability(&[20, 40, 60], 50) devuelve 40\n  - max_dream_within_ability(&[10, 20, 30], 5) devuelve 0 (Ningún sueño dentro de la capacidad)",
      "arb": "يعثر على الحلم الأعلى قيمة الذي يكون ضمن قدرة المستخدم.\n\nتأخذ هذه الدالة مصفوفة من قيم الأحلام ودرجة قدرة المستخدم. وتعيد أعلى قيمة للحلم لا تتجاوز قدرة المستخدم.\n\nالأوساط:\n- dreams: مصفوفة من الأعداد الصحيحة غير الموقعة ذات 32 بت، كل منها يمثل القدرة المطلوبة لتحقيق حلم.\n- ability: عدد صحيح غير موقع ذو 32 بت يمثل درجة قدرة المستخدم.\n\nالقيم المعادة:\n- قيمة الحلم الذي هو الأعلى ولكنه لا يزال ضمن قدرة المستخدم.\n\nأمثلة:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) يعيد 98\n- max_dream_within_ability(&[20, 40, 60], 50) يعيد 40\n- max_dream_within_ability(&[10, 20, 30], 5) يعيد 0 (لا يوجد حلم ضمن القدرة)",
      "sw": "Inapata ndoto yenye thamani ya juu zaidi ambayo iko ndani ya uwezo wa mtumiaji.\n\n  Kazi hii inachukua safu ya thamani za ndoto na alama ya uwezo wa mtumiaji. Inarejesha thamani ya juu zaidi ya ndoto ambayo haizidi uwezo wa mtumiaji.\n\n  Hoja:\n  - dreams: Safu ya nambari zisizo na ishara za biti 32, kila moja ikiwakilisha uwezo unaohitajika kwa ndoto.\n  - ability: Nambari isiyo na ishara ya biti 32 inayowakilisha alama ya uwezo wa mtumiaji.\n\n  Inarejesha:\n  - Thamani ya ndoto ambayo ni ya juu zaidi lakini bado iko ndani ya uwezo wa mtumiaji.\n\n  Mifano:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) inarejesha 98\n  - max_dream_within_ability(&[20, 40, 60], 50) inarejesha 40\n  - max_dream_within_ability(&[10, 20, 30], 5) inarejesha 0 (Hakuna ndoto ndani ya uwezo)",
      "tr": "Kullanıcının yeteneği dahilinde en yüksek değerli hayali bulur.\n\n  Bu fonksiyon, hayal değerlerinin bir dizisini ve kullanıcının yetenek puanını alır. Kullanıcının yeteneğini aşmayan en yüksek hayal değerini döndürür.\n\n  Argümanlar:\n  - dreams: Her biri bir hayal için gereken yeteneği temsil eden, işaretsiz 32-bit tamsayıların bir dizisi.\n  - ability: Kullanıcının yetenek puanını temsil eden işaretsiz 32-bit bir tamsayı.\n\n  Döndürür:\n  - Kullanıcının yeteneği dahilinde olan en yüksek hayalin değeri.\n\n  Örnekler:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 döndürür\n  - max_dream_within_ability(&[20, 40, 60], 50) 40 döndürür\n  - max_dream_within_ability(&[10, 20, 30], 5) 0 döndürür (Yetenek dahilinde hayal yok)",
      "vi": "Tìm giấc mơ có giá trị cao nhất nằm trong khả năng của người dùng.\n\nHàm này nhận một mảng các giá trị giấc mơ và điểm khả năng của người dùng. Nó trả về giá trị giấc mơ cao nhất mà không vượt quá khả năng của người dùng.\n\nCác tham số:\n- dreams: Một mảng các số nguyên không dấu 32-bit, mỗi số đại diện cho khả năng cần thiết cho một giấc mơ.\n- ability: Một số nguyên không dấu 32-bit đại diện cho điểm khả năng của người dùng.\n\nTrả về:\n- Giá trị của giấc mơ cao nhất nhưng vẫn nằm trong khả năng của người dùng.\n\nVí dụ:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) trả về 98\n- max_dream_within_ability(&[20, 40, 60], 50) trả về 40\n- max_dream_within_ability(&[10, 20, 30], 5) trả về 0 (Không có giấc mơ nào trong khả năng)"
    },
    "docstring_bertscore": {
      "es": "0.9747072018005415",
      "arb": "0.9695894900331776",
      "sw": "0.9818235324618784",
      "tr": "0.9709179300215389",
      "vi": "0.9639414351484505"
    }
  },
  {
    "task_id": "Rust/18",
    "prompt": {
      "en": "/*\n  Calculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "es": "/*\n  Calcula el valor del polinomio f(x) = ax^3 + bx^2 + cx + d para un conjunto dado de coeficientes y el valor de x.\n  Esta función utiliza números reales tanto para los coeficientes como para el valor de x, proporcionando el valor del polinomio como un número de punto flotante de doble precisión.\n\n  Argumentos:\n  - x: El valor en el cual se evalúa el polinomio.\n  - a: El coeficiente de x^3.\n  - b: El coeficiente de x^2.\n  - c: El coeficiente de x.\n  - d: El término constante en el polinomio.\n\n  Retorna:\n  - El valor calculado del polinomio en x, como un número de punto flotante de doble precisión.\n\n  Ejemplo:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) devuelve 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "arb": "/*\n  يحسب قيمة كثير الحدود f(x) = ax^3 + bx^2 + cx + d لمجموعة معينة من المعاملات وقيمة x.\n  تستخدم هذه الدالة الأعداد الحقيقية لكل من المعاملات وقيمة x، وتقدم قيمة كثير الحدود كرقم عائم بدقة مزدوجة.\n\n  الوسائط:\n  - x: القيمة التي يتم تقييم كثير الحدود عندها.\n  - a: معامل x^3.\n  - b: معامل x^2.\n  - c: معامل x.\n  - d: الحد الثابت في كثير الحدود.\n\n  يعيد:\n  - القيمة المحسوبة لكثير الحدود عند x، كرقم عائم بدقة مزدوجة.\n\n  مثال:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) يعيد 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "sw": "/*\n  Inakokotoa thamani ya polinomu f(x) = ax^3 + bx^2 + cx + d kwa seti fulani ya vikokotoo na thamani ya x.\n  Kazi hii inatumia namba halisi kwa vikokotoo vyote na thamani ya x, ikitoa thamani ya polinomu kama namba ya nukta-mbili ya usahihi wa juu.\n\n  Hoja:\n  - x: Thamani ambayo polinomu inakokotolewa.\n  - a: Kikokotoo cha x^3.\n  - b: Kikokotoo cha x^2.\n  - c: Kikokotoo cha x.\n  - d: Neno la kudumu katika polinomu.\n\n  Inarudisha:\n  - Thamani iliyokokotolewa ya polinomu katika x, kama namba ya nukta-mbili ya usahihi wa juu.\n\n  Mfano:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) inarudisha 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "tr": "/*\n  f(x) = ax^3 + bx^2 + cx + d polinomunun değerini verilen katsayılar kümesi ve x değeri için hesaplar.\n  Bu fonksiyon hem katsayılar hem de x değeri için gerçek sayılar kullanır ve polinomun değerini çift hassasiyetli kayan nokta sayısı olarak sağlar.\n\n  Argümanlar:\n  - x: Polinomun değerlendirildiği değer.\n  - a: x^3'ün katsayısı.\n  - b: x^2'nin katsayısı.\n  - c: x'in katsayısı.\n  - d: Polinomdaki sabit terim.\n\n  Döndürür:\n  - x'teki polinomun hesaplanan değerini, çift hassasiyetli kayan nokta sayısı olarak.\n\n  Örnek:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 döndürür\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "vi": "/*\n  Tính giá trị của đa thức f(x) = ax^3 + bx^2 + cx + d cho một tập hợp các hệ số và giá trị của x đã cho.\n  Hàm này sử dụng số thực cho cả hệ số và giá trị của x, cung cấp giá trị của đa thức dưới dạng số dấu phẩy động có độ chính xác kép.\n\n  Tham số:\n  - x: Giá trị tại đó đa thức được đánh giá.\n  - a: Hệ số của x^3.\n  - b: Hệ số của x^2.\n  - c: Hệ số của x.\n  - d: Hằng số trong đa thức.\n\n  Trả về:\n  - Giá trị đã tính toán của đa thức tại x, dưới dạng số dấu phẩy động có độ chính xác kép.\n\n  Ví dụ:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) trả về 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 "
    },
    "prompt_bertscore": {
      "es": "0.9802756059024735",
      "arb": "0.9824464373368038",
      "sw": "0.9609544314784478",
      "tr": "0.9624020496954302",
      "vi": "0.9613034250579262"
    },
    "canonical_solution": "{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}",
    "instruction": {
      "en": "Write a Rust function `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` to solve the following problem:\nCalculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "es": "Escribe una función en Rust `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` para resolver el siguiente problema:\nCalcula el valor del polinomio f(x) = ax^3 + bx^2 + cx + d para un conjunto dado de coeficientes y el valor de x.\n  Esta función utiliza números reales tanto para los coeficientes como para el valor de x, proporcionando el valor del polinomio como un número de punto flotante de doble precisión.\n\n  Argumentos:\n  - x: El valor en el cual se evalúa el polinomio.\n  - a: El coeficiente de x^3.\n  - b: El coeficiente de x^2.\n  - c: El coeficiente de x.\n  - d: El término constante en el polinomio.\n\n  Retorna:\n  - El valor calculado del polinomio en x, como un número de punto flotante de doble precisión.\n\n  Ejemplo:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) devuelve 33.0838692",
      "arb": "اكتب دالة Rust `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` لحل المشكلة التالية:\nتحسب قيمة كثير الحدود f(x) = ax^3 + bx^2 + cx + d لمجموعة معينة من المعاملات وقيمة x.\nتستخدم هذه الدالة الأعداد الحقيقية لكل من المعاملات وقيمة x، وتوفر قيمة كثير الحدود كرقم عائم ذو دقة مزدوجة.\n\nالمعطيات:\n- x: القيمة التي يتم تقييم كثير الحدود عندها.\n- a: معامل x^3.\n- b: معامل x^2.\n- c: معامل x.\n- d: الحد الثابت في كثير الحدود.\n\nالقيم المعادة:\n- القيمة المحسوبة لكثير الحدود عند x، كرقم عائم ذو دقة مزدوجة.\n\nمثال:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) يعيد 33.0838692",
      "sw": "Andika kazi ya Rust `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` kutatua tatizo lifuatalo:\nHesabu thamani ya polinomu f(x) = ax^3 + bx^2 + cx + d kwa seti fulani ya vigezo na thamani ya x.\n  Kazi hii inatumia namba halisi kwa vigezo vyote na thamani ya x, ikitoa thamani ya polinomu kama namba ya pointi inayozunguka mara mbili.\n\n  Hoja:\n  - x: Thamani ambayo polinomu inakadiria.\n  - a: Kigezo cha x^3.\n  - b: Kigezo cha x^2.\n  - c: Kigezo cha x.\n  - d: Kigezo kisichobadilika katika polinomu.\n\n  Inarudisha:\n  - Thamani iliyohesabiwa ya polinomu katika x, kama namba ya pointi inayozunguka mara mbili.\n\n  Mfano:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) inarudisha 33.0838692",
      "tr": "Bir Rust fonksiyonu `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` yazın:\nVerilen katsayılar ve x değeri için f(x) = ax^3 + bx^2 + cx + d polinomunun değerini hesaplar.\n  Bu fonksiyon, hem katsayılar hem de x değeri için gerçek sayılar kullanır ve polinomun değerini çift hassasiyetli kayan nokta sayısı olarak sağlar.\n\n  Argümanlar:\n  - x: Polinomun değerlendirildiği değer.\n  - a: x^3'ün katsayısı.\n  - b: x^2'nin katsayısı.\n  - c: x'in katsayısı.\n  - d: Polinomdaki sabit terim.\n\n  Döndürülen:\n  - x'teki polinomun hesaplanan değeri, çift hassasiyetli kayan nokta sayısı olarak.\n\n  Örnek:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 döndürür.",
      "vi": "Viết một hàm Rust `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` để giải quyết vấn đề sau:\nTính giá trị của đa thức f(x) = ax^3 + bx^2 + cx + d cho một tập hợp các hệ số và giá trị của x.\nHàm này sử dụng số thực cho cả hệ số và giá trị của x, cung cấp giá trị của đa thức dưới dạng số dấu phẩy động kép.\n\nCác tham số:\n- x: Giá trị tại đó đa thức được đánh giá.\n- a: Hệ số của x^3.\n- b: Hệ số của x^2.\n- c: Hệ số của x.\n- d: Hằng số trong đa thức.\n\nTrả về:\n- Giá trị đã tính của đa thức tại x, dưới dạng số dấu phẩy động kép.\n\nVí dụ:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) trả về 33.0838692"
    },
    "instruction_bertscore": {
      "es": "0.9881644101156551",
      "arb": "0.9755422439224122",
      "sw": "0.9689032220667021",
      "tr": "0.9285933711698628",
      "vi": "0.9690071057559833"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert!((polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) - 33.0838692).abs() < 1e-7);\n        assert!((polynomial_value(0.0, 1.0, 1.0, 1.0, 1.0) - 1.0).abs() < 1e-7);\n        assert!((polynomial_value(1.0, 1.0, 1.0, 1.0, 1.0) - 4.0).abs() < 1e-7);\n    }\n    \n\n}",
    "entry_point": "polynomial_value",
    "signature": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64",
    "docstring": {
      "en": "Calculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "es": "Calcula el valor del polinomio f(x) = ax^3 + bx^2 + cx + d para un conjunto dado de coeficientes y el valor de x. Esta función utiliza números reales tanto para los coeficientes como para el valor de x, proporcionando el valor del polinomio como un número de punto flotante de doble precisión.\n\n  Argumentos:\n  - x: El valor en el cual se evalúa el polinomio.\n  - a: El coeficiente de x^3.\n  - b: El coeficiente de x^2.\n  - c: El coeficiente de x.\n  - d: El término constante en el polinomio.\n\n  Retorna:\n  - El valor calculado del polinomio en x, como un número de punto flotante de doble precisión.\n\n  Ejemplo:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) retorna 33.0838692",
      "arb": "يحسب قيمة كثير الحدود f(x) = ax^3 + bx^2 + cx + d لمجموعة معينة من المعاملات وقيمة x. \nتستخدم هذه الدالة الأعداد الحقيقية لكل من المعاملات وقيمة x، وتوفر قيمة كثير الحدود كرقم عائم مزدوج الدقة.\n\nالمعطيات:\n- x: القيمة التي يتم تقييم كثير الحدود عندها.\n- a: معامل x^3.\n- b: معامل x^2.\n- c: معامل x.\n- d: الحد الثابت في كثير الحدود.\n\nالقيم المعادة:\n- القيمة المحسوبة لكثير الحدود عند x، كرقم عائم مزدوج الدقة.\n\nمثال:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) يعيد 33.0838692",
      "sw": "Inahesabu thamani ya polinomia f(x) = ax^3 + bx^2 + cx + d kwa seti fulani ya viwango na thamani ya x. Kazi hii hutumia namba halisi kwa viwango vyote na thamani ya x, ikitoa thamani ya polinomia kama namba ya pointi inayozunguka mara mbili.\n\nHoja:\n- x: Thamani ambayo polinomia inakokotolewa.\n- a: Kiwango cha x^3.\n- b: Kiwango cha x^2.\n- c: Kiwango cha x.\n- d: Neno la mara kwa mara katika polinomia.\n\nInarudisha:\n- Thamani iliyokokotolewa ya polinomia kwa x, kama namba ya pointi inayozunguka mara mbili.\n\nMfano:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) inarudisha 33.0838692",
      "tr": "Verilen katsayılar kümesi ve x değeri için f(x) = ax^3 + bx^2 + cx + d polinomunun değerini hesaplar. \nBu fonksiyon hem katsayılar hem de x değeri için reel sayılar kullanır ve polinomun değerini çift hassasiyetli kayan noktalı sayı olarak sağlar.\n\nArgümanlar:\n- x: Polinomun değerlendirildiği değer.\n- a: x^3'ün katsayısı.\n- b: x^2'nin katsayısı.\n- c: x'in katsayısı.\n- d: Polinomdaki sabit terim.\n\nDöndürülen:\n- x'te polinomun hesaplanan değeri, çift hassasiyetli kayan noktalı sayı olarak.\n\nÖrnek:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 döndürür.",
      "vi": "Tính giá trị của đa thức f(x) = ax^3 + bx^2 + cx + d cho một tập hợp hệ số đã cho và giá trị của x. \nHàm này sử dụng số thực cho cả hệ số và giá trị của x, cung cấp giá trị của đa thức dưới dạng số dấu phẩy động có độ chính xác kép.\n\n  Tham số:\n  - x: Giá trị tại đó đa thức được đánh giá.\n  - a: Hệ số của x^3.\n  - b: Hệ số của x^2.\n  - c: Hệ số của x.\n  - d: Hằng số trong đa thức.\n\n  Trả về:\n  - Giá trị đã tính của đa thức tại x, dưới dạng số dấu phẩy động có độ chính xác kép.\n\n  Ví dụ:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) trả về 33.0838692"
    },
    "docstring_bertscore": {
      "es": "0.9925078606577451",
      "arb": "0.9742060573491904",
      "sw": "0.9566411727542753",
      "tr": "0.9497667738970389",
      "vi": "0.9646582921936054"
    }
  },
  {
    "task_id": "Rust/19",
    "prompt": {
      "en": "/*\n  Calculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "es": "/*\n  Calcula el número mínimo de cubetas que una jirafa necesita beber para saciar su sed, dada la capacidad de las cubetas.\n  \n  Una jirafa necesita beber 20 litros de agua para saciar su sed. Esta función determina cuántas cubetas de agua necesitaría, basándose en el volumen de cada cubeta. Las cubetas tienen forma cilíndrica, con una altura y un radio dados.\n\n  Argumentos:\n  - height: La altura de la cubeta en centímetros (entero).\n  - radius: El radio de la base de la cubeta en centímetros (entero).\n\n  Retorna:\n  - Un entero que representa el número mínimo de cubetas necesarias para que la jirafa sacie su sed.\n\n  Ejemplo:\n  - min_buckets_needed(23, 11) devuelve 3\n  - min_buckets_needed(30, 10) devuelve 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "arb": "/*\n  يحسب الحد الأدنى لعدد الدلاء التي يحتاجها الزرافة للشرب لإرواء عطشها، بالنظر إلى حجم الدلاء.\n\n  تحتاج الزرافة إلى شرب 20 لترًا من الماء لإرواء عطشها. تحدد هذه الدالة عدد الدلاء التي ستحتاجها من الماء، بناءً على حجم كل دلو. الدلاء تكون على شكل أسطواني، مع ارتفاع ونصف قطر معينين.\n\n  الوسائط:\n  - height: ارتفاع الدلو بالسنتيمترات (عدد صحيح).\n  - radius: نصف قطر قاعدة الدلو بالسنتيمترات (عدد صحيح).\n\n  يعيد:\n  - عدد صحيح يمثل الحد الأدنى لعدد الدلاء اللازمة للزرافة لإرواء عطشها.\n\n  مثال:\n  - min_buckets_needed(23, 11) يعيد 3\n  - min_buckets_needed(30, 10) يعيد 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ndogo ya ndoo ambazo twiga anahitaji kunywa ili kuzima kiu chake, kutokana na ukubwa wa ndoo.\n\n  Twiga anahitaji kunywa lita 20 za maji ili kuzima kiu chake. Kazi hii inaamua ni ndoo ngapi za maji zitahitajika, kulingana na ujazo wa kila ndoo. Ndoo ni za umbo la silinda, zikiwa na urefu na kipenyo vilivyotolewa.\n\n  Hoja:\n  - height: Urefu wa ndoo kwa sentimita (nambari kamili).\n  - radius: Kipenyo cha msingi cha ndoo kwa sentimita (nambari kamili).\n\n  Inarudisha:\n  - Nambari kamili inayowakilisha idadi ndogo ya ndoo zinazohitajika kwa twiga kuzima kiu chake.\n\n  Mfano:\n  - min_buckets_needed(23, 11) inarudisha 3\n  - min_buckets_needed(30, 10) inarudisha 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "tr": "/*\n  Bir zürafanın susuzluğunu gidermek için içmesi gereken minimum kova sayısını, kovaların boyutuna göre hesaplar.\n  \n  Bir zürafa susuzluğunu gidermek için 20 litre su içmelidir. Bu fonksiyon, her bir kovanın hacmine bağlı olarak kaç kova suya ihtiyaç duyulacağını belirler. Kovalar, verilen yükseklik ve yarıçap ile silindirik şekildedir.\n\n  Argümanlar:\n  - height: Kovanın yüksekliği santimetre cinsinden (tamsayı).\n  - radius: Kovanın tabanının yarıçapı santimetre cinsinden (tamsayı).\n\n  Döndürür:\n  - Zürafanın susuzluğunu gidermek için ihtiyaç duyduğu minimum kova sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - min_buckets_needed(23, 11) 3 döndürür\n  - min_buckets_needed(30, 10) 3 döndürür\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "vi": "/*\n  Tính toán số xô tối thiểu mà một con hươu cao cổ cần để uống nước giải khát, dựa trên kích thước của các xô.\n\n  Một con hươu cao cổ cần uống 20 lít nước để giải khát. Hàm này xác định số xô nước cần thiết, dựa trên thể tích của mỗi xô. Các xô có hình trụ, với chiều cao và bán kính cho trước.\n\n  Tham số:\n  - height: Chiều cao của xô tính bằng centimet (số nguyên).\n  - radius: Bán kính của đáy xô tính bằng centimet (số nguyên).\n\n  Trả về:\n  - Một số nguyên đại diện cho số xô tối thiểu cần thiết để con hươu cao cổ giải khát.\n\n  Ví dụ:\n  - min_buckets_needed(23, 11) trả về 3\n  - min_buckets_needed(30, 10) trả về 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9868359701272938",
      "arb": "0.9721039520266982",
      "sw": "0.9733577069917905",
      "tr": "0.9863425722608031",
      "vi": "0.9711231152051479"
    },
    "canonical_solution": "{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}",
    "instruction": {
      "en": "Write a Rust function `fn min_buckets_needed(height: i32, radius: i32) -> i32` to solve the following problem:\nCalculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3",
      "es": "Escribe una función en Rust `fn min_buckets_needed(height: i32, radius: i32) -> i32` para resolver el siguiente problema:\nCalcula el número mínimo de cubos que una jirafa necesita beber para saciar su sed, dada la capacidad de los cubos.\n\nUna jirafa necesita beber 20 litros de agua para saciar su sed. Esta función determina cuántos cubos de agua necesitaría, basándose en el volumen de cada cubo. Los cubos tienen forma cilíndrica, con una altura y un radio dados.\n\nArgumentos:\n- height: La altura del cubo en centímetros (entero).\n- radius: El radio de la base del cubo en centímetros (entero).\n\nDevuelve:\n- Un entero que representa el número mínimo de cubos necesarios para que la jirafa sacie su sed.\n\nEjemplo:\n- min_buckets_needed(23, 11) devuelve 3\n- min_buckets_needed(30, 10) devuelve 3",
      "arb": "اكتب دالة بلغة Rust `fn min_buckets_needed(height: i32, radius: i32) -> i32` لحل المشكلة التالية:\nتحسب الحد الأدنى لعدد الدلاء التي يحتاجها الزرافة للشرب لإرواء عطشه، بالنظر إلى حجم الدلاء.\n\nيحتاج الزرافة إلى شرب 20 لترًا من الماء لإرواء عطشه. تحدد هذه الدالة عدد الدلاء من الماء التي سيحتاجها، بناءً على حجم كل دلو. الدلاء تكون على شكل أسطواني، مع ارتفاع ونصف قطر معطى.\n\nالمعطيات:\n- height: ارتفاع الدلو بالسنتيمترات (عدد صحيح).\n- radius: نصف قطر قاعدة الدلو بالسنتيمترات (عدد صحيح).\n\nالإرجاع:\n- عدد صحيح يمثل الحد الأدنى لعدد الدلاء اللازمة للزرافة لإرواء عطشه.\n\nمثال:\n- min_buckets_needed(23, 11) يعيد 3\n- min_buckets_needed(30, 10) يعيد 3",
      "sw": "Andika kazi ya Rust `fn min_buckets_needed(height: i32, radius: i32) -> i32` kutatua tatizo lifuatalo:\nInakokotoa idadi ndogo zaidi ya ndoo ambazo twiga anahitaji kunywa ili kuzima kiu yake, kutokana na ukubwa wa ndoo hizo.\n\nTwiga anahitaji kunywa lita 20 za maji ili kuzima kiu yake. Kazi hii inaamua ni ndoo ngapi za maji atahitaji, kulingana na ujazo wa kila ndoo. Ndoo ni za umbo la mviringo, zikiwa na urefu na kipenyo vilivyotolewa.\n\nHoja:\n- height: Urefu wa ndoo kwa sentimita (nambari kamili).\n- radius: Kipenyo cha msingi wa ndoo kwa sentimita (nambari kamili).\n\nInarudisha:\n- Nambari kamili inayowakilisha idadi ndogo zaidi ya ndoo zinazohitajika kwa twiga kuzima kiu chake.\n\nMfano:\n- min_buckets_needed(23, 11) inarudisha 3\n- min_buckets_needed(30, 10) inarudisha 3",
      "tr": "Bir Rust fonksiyonu `fn min_buckets_needed(height: i32, radius: i32) -> i32` yazın ve aşağıdaki problemi çözün:\nBir zürafanın susuzluğunu gidermek için içmesi gereken minimum kova sayısını, kovaların boyutuna göre hesaplar.\n\nBir zürafa, susuzluğunu gidermek için 20 litre su içmelidir. Bu fonksiyon, her bir kovanın hacmine göre kaç kova suya ihtiyaç duyulacağını belirler. Kovalar, verilen yükseklik ve yarıçap ile silindirik şekildedir.\n\nArgümanlar:\n- height: Kovanın yüksekliği santimetre cinsinden (tam sayı).\n- radius: Kovanın tabanının yarıçapı santimetre cinsinden (tam sayı).\n\nDöndürür:\n- Zürafanın susuzluğunu gidermek için gereken minimum kova sayısını temsil eden bir tam sayı.\n\nÖrnek:\n- min_buckets_needed(23, 11) 3 döndürür\n- min_buckets_needed(30, 10) 3 döndürür",
      "vi": "Viết một hàm Rust `fn min_buckets_needed(height: i32, radius: i32) -> i32` để giải quyết vấn đề sau:\nTính toán số lượng xô tối thiểu mà một con hươu cao cổ cần uống để giải khát, dựa trên kích thước của các xô.\n\nMột con hươu cao cổ cần uống 20 lít nước để giải khát. Hàm này xác định số lượng xô nước cần thiết, dựa trên thể tích của mỗi xô. Các xô có hình dạng hình trụ, với chiều cao và bán kính được cho.\n\nTham số:\n- height: Chiều cao của xô tính bằng centimet (số nguyên).\n- radius: Bán kính của đáy xô tính bằng centimet (số nguyên).\n\nTrả về:\n- Một số nguyên đại diện cho số lượng xô tối thiểu cần thiết để hươu cao cổ giải khát.\n\nVí dụ:\n- min_buckets_needed(23, 11) trả về 3\n- min_buckets_needed(30, 10) trả về 3"
    },
    "instruction_bertscore": {
      "es": "0.9805302500509603",
      "arb": "0.966238595505119",
      "sw": "0.9677384535123135",
      "tr": "0.9796163516678187",
      "vi": "0.9777974932686823"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(min_buckets_needed(23, 11), 3);\n        assert_eq!(min_buckets_needed(30, 10), 3);\n        assert_eq!(min_buckets_needed(50, 5), 6);\n        assert_eq!(min_buckets_needed(40, 8), 3);    \n    }\n    \n\n}",
    "entry_point": "min_buckets_needed",
    "signature": "fn min_buckets_needed(height: i32, radius: i32) -> i32",
    "docstring": {
      "en": "Calculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3",
      "es": "Calcula el número mínimo de cubos que una jirafa necesita beber para saciar su sed, dada la capacidad de los cubos.\n\n  Una jirafa necesita beber 20 litros de agua para saciar su sed. Esta función determina cuántos cubos de agua necesitaría, basándose en el volumen de cada cubo. Los cubos son de forma cilíndrica, con una altura y un radio dados.\n\n  Argumentos:\n  - height: La altura del cubo en centímetros (entero).\n  - radius: El radio de la base del cubo en centímetros (entero).\n\n  Retorna:\n  - Un entero que representa el número mínimo de cubos necesarios para que la jirafa sacie su sed.\n\n  Ejemplo:\n  - min_buckets_needed(23, 11) devuelve 3\n  - min_buckets_needed(30, 10) devuelve 3",
      "arb": "يحسب الحد الأدنى لعدد الدلاء التي يحتاجها الزرافة للشرب لإرواء عطشه، بالنظر إلى حجم الدلاء.\n\nتحتاج الزرافة إلى شرب 20 لترًا من الماء لإرواء عطشها. تحدد هذه الدالة عدد الدلاء التي ستحتاجها من الماء، بناءً على حجم كل دلو. الدلاء تكون أسطوانية الشكل، مع ارتفاع ونصف قطر معطيين.\n\nالمعطيات:\n- height: ارتفاع الدلو بالسنتيمترات (عدد صحيح).\n- radius: نصف قطر قاعدة الدلو بالسنتيمترات (عدد صحيح).\n\nالقيم المعادة:\n- عدد صحيح يمثل الحد الأدنى لعدد الدلاء اللازمة للزرافة لإرواء عطشها.\n\nمثال:\n- min_buckets_needed(23, 11) يعيد 3\n- min_buckets_needed(30, 10) يعيد 3",
      "sw": "Hesabu idadi ndogo ya ndoo ambazo twiga anahitaji kunywa ili kuzima kiu chake, kutokana na ukubwa wa ndoo.\n\nTwiga anahitaji kunywa lita 20 za maji ili kuzima kiu chake. Kazi hii inaamua ni ndoo ngapi za maji itahitaji, kulingana na ujazo wa kila ndoo. Ndoo ni za umbo la silinda, zikiwa na urefu na kipenyo kilichopewa.\n\nHoja:\n- height: Urefu wa ndoo kwa sentimita (nambari kamili).\n- radius: Kipenyo cha msingi cha ndoo kwa sentimita (nambari kamili).\n\nRudisha:\n- Nambari kamili inayowakilisha idadi ndogo ya ndoo zinazohitajika kwa twiga kuzima kiu chake.\n\nMfano:\n- min_buckets_needed(23, 11) inarudisha 3\n- min_buckets_needed(30, 10) inarudisha 3",
      "tr": "Zürafanın susuzluğunu gidermek için içmesi gereken minimum kova sayısını, kovaların boyutuna göre hesaplar.\n\nBir zürafa susuzluğunu gidermek için 20 litre su içmelidir. Bu fonksiyon, her bir kovadaki su hacmine göre kaç kova suya ihtiyaç duyulacağını belirler. Kovalar, verilen yükseklik ve yarıçapa sahip silindirik şekildedir.\n\nArgümanlar:\n- height: Kovaların yüksekliği santimetre cinsinden (tamsayı).\n- radius: Kovaların taban yarıçapı santimetre cinsinden (tamsayı).\n\nDöndürür:\n- Zürafanın susuzluğunu gidermek için ihtiyaç duyduğu minimum kova sayısını temsil eden bir tamsayı.\n\nÖrnek:\n- min_buckets_needed(23, 11) 3 döndürür\n- min_buckets_needed(30, 10) 3 döndürür",
      "vi": "Tính toán số lượng xô tối thiểu mà một con hươu cao cổ cần uống để giải khát, dựa trên kích thước của các xô.\n\nMột con hươu cao cổ cần uống 20 lít nước để giải khát. Hàm này xác định số lượng xô nước cần thiết, dựa trên thể tích của mỗi xô. Các xô có dạng hình trụ, với chiều cao và bán kính cho trước.\n\nCác đối số:\n- height: Chiều cao của xô tính bằng centimet (số nguyên).\n- radius: Bán kính của đáy xô tính bằng centimet (số nguyên).\n\nTrả về:\n- Một số nguyên đại diện cho số lượng xô tối thiểu cần thiết để con hươu cao cổ giải khát.\n\nVí dụ:\n- min_buckets_needed(23, 11) trả về 3\n- min_buckets_needed(30, 10) trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.9878837453872529",
      "arb": "0.9647850183767057",
      "sw": "0.9714887937366332",
      "tr": "0.9775047120870368",
      "vi": "0.9832348013191313"
    }
  },
  {
    "task_id": "Rust/20",
    "prompt": {
      "en": "/*\n  Calculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "es": "/*\n  Calcula el área de un triángulo dadas las coordenadas de sus vértices.\n\n  Argumentos:\n  - x1, y1: Las coordenadas x e y del primer vértice.\n  - x2, y2: Las coordenadas x e y del segundo vértice.\n  - x3, y3: Las coordenadas x e y del tercer vértice.\n\n  Devuelve:\n  - El área del triángulo, redondeada a dos decimales.\n\n  Ejemplos:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) devuelve 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "arb": "/*\n  يحسب مساحة المثلث بناءً على إحداثيات رؤوسه.\n\n  يعيدالحجج:\n  - x1, y1: إحداثيات x و y للرأس الأول.\n  - x2, y2: إحداثيات x و y للرأس الثاني.\n  - x3, y3: إحداثيات x و y للرأس الثالث.\n\n  يعيد:\n  - مساحة المثلث، مقربة إلى منزلتين عشريتين.\n\n  امثله:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) يعيد 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "sw": "/*\n  Inahesabu eneo la pembetatu kwa kuzingatia kuratibu za vilele vyake.\n\n  Hoja:\n  - x1, y1: Kuratibu za x na y za kilele cha kwanza.\n  - x2, y2: Kuratibu za x na y za kilele cha pili.\n  - x3, y3: Kuratibu za x na y za kilele cha tatu.\n\n  Inarudisha:\n  - Eneo la pembetatu, limezungushwa hadi sehemu mbili za desimali.\n\n  Mifano:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) inarudisha 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "tr": "/*\n  Üçgenin köşelerinin koordinatları verildiğinde alanını hesaplar.\n\n  Argümanlar:\n  - x1, y1: Birinci köşenin x ve y koordinatları.\n  - x2, y2: İkinci köşenin x ve y koordinatları.\n  - x3, y3: Üçüncü köşenin x ve y koordinatları.\n\n  Döndürür:\n  - Üçgenin alanı, iki ondalık basamağa yuvarlanmış olarak.\n\n  Örnekler:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 döndürür\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "vi": "/*\n  Tính diện tích của một tam giác dựa trên tọa độ của các đỉnh.\n\n  Tham số:\n  - x1, y1: Tọa độ x và y của đỉnh thứ nhất.\n  - x2, y2: Tọa độ x và y của đỉnh thứ hai.\n  - x3, y3: Tọa độ x và y của đỉnh thứ ba.\n\n  Trả về:\n  - Diện tích của tam giác, làm tròn đến hai chữ số thập phân.\n\n  Ví dụ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) trả về 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9935089577781608",
      "sw": "0.9935089577781608",
      "tr": "0.9811682508348443",
      "vi": "0.9883298692230572"
    },
    "canonical_solution": "{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}",
    "instruction": {
      "en": "Write a Rust function `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` to solve the following problem:\nCalculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00",
      "es": "Escribe una función en Rust `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` para resolver el siguiente problema:\nCalcula el área de un triángulo dadas las coordenadas de sus vértices.\n\n  Argumentos:\n  - x1, y1: Las coordenadas x e y del primer vértice.\n  - x2, y2: Las coordenadas x e y del segundo vértice.\n  - x3, y3: Las coordenadas x e y del tercer vértice.\n\n  Devuelve:\n  - El área del triángulo, redondeada a dos decimales.\n\n  Ejemplos:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) devuelve 6.00",
      "arb": "اكتب دالة بلغة Rust `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` لحل المشكلة التالية:\nتحسب مساحة المثلث المعطى إحداثيات رؤوسه.\n\n  الوسائط:\n  - x1, y1: إحداثيات x و y للرأس الأول.\n  - x2, y2: إحداثيات x و y للرأس الثاني.\n  - x3, y3: إحداثيات x و y للرأس الثالث.\n\n  يعيد:\n  - مساحة المثلث، مقربة إلى منزلتين عشريتين.\n\n  أمثلة:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) يعيد 6.00",
      "sw": "Andika kazi ya Rust `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` kutatua tatizo lifuatalo:  \nInakokotoa eneo la pembetatu kwa kuzingatia kuratibu za vilele vyake.\n\n  Hoja:\n  - x1, y1: Kuratibu za x na y za kilele cha kwanza.\n  - x2, y2: Kuratibu za x na y za kilele cha pili.\n  - x3, y3: Kuratibu za x na y za kilele cha tatu.\n\n  Inarudisha:\n  - Eneo la pembetatu, limezungushwa hadi sehemu mbili za desimali.\n\n  Mifano:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) inarudisha 6.00",
      "tr": "Bir Rust fonksiyonu `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` yazın ve aşağıdaki problemi çözün:\nKöşelerinin koordinatları verilen bir üçgenin alanını hesaplar.\n\n  Argümanlar:\n  - x1, y1: Birinci köşenin x ve y koordinatları.\n  - x2, y2: İkinci köşenin x ve y koordinatları.\n  - x3, y3: Üçüncü köşenin x ve y koordinatları.\n\n  Döndürür:\n  - Üçgenin alanı, iki ondalık basamağa yuvarlanmış olarak.\n\n  Örnekler:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 döndürür.",
      "vi": "Viết một hàm Rust `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` để giải quyết vấn đề sau:\nTính diện tích của một tam giác dựa trên tọa độ của các đỉnh của nó.\n\n  Tham số:\n  - x1, y1: Tọa độ x và y của đỉnh thứ nhất.\n  - x2, y2: Tọa độ x và y của đỉnh thứ hai.\n  - x3, y3: Tọa độ x và y của đỉnh thứ ba.\n\n  Trả về:\n  - Diện tích của tam giác, làm tròn đến hai chữ số thập phân.\n\n  Ví dụ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) trả về 6.00"
    },
    "instruction_bertscore": {
      "es": "0.9826786362522336",
      "arb": "0.9812836550862256",
      "sw": "0.98887550687976",
      "tr": "0.9964268380755634",
      "vi": "0.9865002847833448"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0), 6.00);\n        assert_eq!(triangle_area(1.0, 2.0, 4.0, 5.0, 6.0, 3.0), 6.00); // Example test case, replace with correct area\n        assert_eq!(triangle_area(0.0, 0.0, 7.0, 8.0, 9.0, 10.0), 1.00); \n    }\n    \n\n}",
    "entry_point": "triangle_area",
    "signature": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32",
    "docstring": {
      "en": "Calculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00",
      "es": "Calcula el área de un triángulo dadas las coordenadas de sus vértices.\n\n  Argumentos:\n  - x1, y1: Las coordenadas x e y del primer vértice.\n  - x2, y2: Las coordenadas x e y del segundo vértice.\n  - x3, y3: Las coordenadas x e y del tercer vértice.\n\n  Devuelve:\n  - El área del triángulo, redondeada a dos decimales.\n\n  Ejemplos:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) devuelve 6.00",
      "arb": "يحسب مساحة المثلث المعطى إحداثيات رؤوسه.\n\n  الحجج:\n  - x1, y1: الإحداثيات السينية والصادية للرأس الأول.\n  - x2, y2: الإحداثيات السينية والصادية للرأس الثاني.\n  - x3, y3: الإحداثيات السينية والصادية للرأس الثالث.\n\n  يعيد:\n  - مساحة المثلث، مقربة إلى منزلتين عشريتين.\n\n  أمثلة:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) يعيد 6.00",
      "sw": "Inakokotoa eneo la pembetatu kwa kuzingatia kuratibu za vilele vyake.\n\n  Hoja:\n  - x1, y1: Kuratibu za x na y za kilele cha kwanza.\n  - x2, y2: Kuratibu za x na y za kilele cha pili.\n  - x3, y3: Kuratibu za x na y za kilele cha tatu.\n\n  Inarejesha:\n  - Eneo la pembetatu, limezungushwa hadi sehemu mbili za desimali.\n\n  Mifano:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) inarejesha 6.00",
      "tr": "Üçgenin köşelerinin koordinatları verildiğinde alanını hesaplar.\n\n  Argümanlar:\n  - x1, y1: Birinci köşenin x ve y koordinatları.\n  - x2, y2: İkinci köşenin x ve y koordinatları.\n  - x3, y3: Üçüncü köşenin x ve y koordinatları.\n\n  Döndürür:\n  - İki ondalık basamağa yuvarlanmış üçgenin alanı.\n\n  Örnekler:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 döndürür.",
      "vi": "Tính diện tích của một tam giác dựa trên tọa độ của các đỉnh của nó.\n\n  Tham số:\n  - x1, y1: Tọa độ x và y của đỉnh thứ nhất.\n  - x2, y2: Tọa độ x và y của đỉnh thứ hai.\n  - x3, y3: Tọa độ x và y của đỉnh thứ ba.\n\n  Trả về:\n  - Diện tích của tam giác, làm tròn đến hai chữ số thập phân.\n\n  Ví dụ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) trả về 6.00"
    },
    "docstring_bertscore": {
      "es": "0.99799621671612",
      "arb": "1",
      "sw": "0.992724367773073",
      "tr": "0.9647266210446814",
      "vi": "0.9832876370004866"
    }
  },
  {
    "task_id": "Rust/21",
    "prompt": {
      "en": "\n/*\n  Calculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "es": "/*\n  Calcula el franqueo basado en el peso de un paquete y si se elige el servicio exprés.\n  El franqueo se calcula de la siguiente manera:\n  - Para un peso de hasta 1000 gramos inclusive, la tarifa base es de 8 unidades.\n  - Por cada 500 gramos adicionales o fracción, se añade una tarifa adicional de 4 unidades.\n  - Si se elige el servicio exprés (denotado por 'y'), se añade una tarifa adicional de 5 unidades.\n  - Si no se elige el servicio exprés (denotado por 'n'), no se añade ninguna tarifa adicional.\n\n  Argumentos:\n  - weight: El peso del paquete en gramos.\n  - express: Un carácter que indica si se elige el servicio exprés ('y' para sí, 'n' para no).\n\n  Retorna:\n  - El costo total del franqueo como un entero sin signo.\n\n  Ejemplos:\n  - calculate_postage(1200, 'y') retorna 17.\n  - calculate_postage(1000, 'n') retorna 8.\n  - calculate_postage(1500, 'y') retorna 17.\n  - calculate_postage(2000, 'n') retorna 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "arb": "/*\n  يحسب رسوم البريد بناءً على وزن الطرد وما إذا تم اختيار خدمة البريد السريع.\n  يتم حساب رسوم البريد كما يلي:\n  - بالنسبة للوزن حتى 1000 جرام، تكون الرسوم الأساسية 8 وحدات.\n  - لكل 500 جرام إضافية أو جزء منها، يتم إضافة رسوم إضافية قدرها 4 وحدات.\n  - إذا تم اختيار خدمة البريد السريع (يشار إليها بـ 'y')، يتم إضافة رسوم إضافية قدرها 5 وحدات.\n  - إذا لم يتم اختيار خدمة البريد السريع (يشار إليها بـ 'n')، لا يتم إضافة رسوم إضافية.\n\n  الوسائط:\n  - weight: وزن الطرد بالجرام.\n  - express: حرف يشير إلى ما إذا تم اختيار خدمة البريد السريع ('y' تعني نعم، 'n' تعني لا).\n\n  يعيد:\n  - إجمالي تكلفة البريد كعدد صحيح غير موقع.\n\n  أمثلة:\n  - calculate_postage(1200, 'y') يعيد 17.\n  - calculate_postage(1000, 'n') يعيد 8.\n  - calculate_postage(1500, 'y') يعيد 17.\n  - calculate_postage(2000, 'n') يعيد 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "sw": "/*\n  Inahesabu gharama ya posta kulingana na uzito wa kifurushi na kama huduma ya haraka imechaguliwa.\n  Gharama ya posta inahesabiwa kama ifuatavyo:\n  - Kwa uzito hadi na ikiwa ni pamoja na gramu 1000, ada ya msingi ni vitengo 8.\n  - Kwa kila gramu 500 za ziada au sehemu yake, ada ya ziada ya vitengo 4 inaongezwa.\n  - Ikiwa huduma ya haraka (inayoonyeshwa na 'y') imechaguliwa, ada ya ziada ya vitengo 5 inaongezwa.\n  - Ikiwa huduma ya haraka haijachaguliwa (inayoonyeshwa na 'n'), hakuna ada ya ziada inayoongezwa.\n\n  Hoja:\n  - weight: Uzito wa kifurushi kwa gramu.\n  - express: Herufi inayoonyesha kama huduma ya haraka imechaguliwa ('y' kwa ndiyo, 'n' kwa hapana).\n\n  Inarudisha:\n  - Jumla ya gharama ya posta kama namba kamili isiyo na alama.\n\n  Mifano:\n  - calculate_postage(1200, 'y') inarudisha 17.\n  - calculate_postage(1000, 'n') inarudisha 8.\n  - calculate_postage(1500, 'y') inarudisha 17.\n  - calculate_postage(2000, 'n') inarudisha 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "tr": "/*\n  Bir paketin ağırlığına ve ekspres hizmetin seçilip seçilmediğine bağlı olarak posta ücretini hesaplar.\n  Posta ücreti aşağıdaki gibi hesaplanır:\n  - Ağırlık 1000 grama kadar ve dahil olmak üzere, temel ücret 8 birimdir.\n  - Her ek 500 gram veya bir kısmı için, ek bir ücret olarak 4 birim eklenir.\n  - Ekspres hizmet seçilirse ( 'y' ile belirtilir), ek bir ücret olarak 5 birim eklenir.\n  - Ekspres hizmet seçilmezse ( 'n' ile belirtilir), ek bir ücret eklenmez.\n\n  Argümanlar:\n  - weight: Paketin ağırlığı gram cinsindendir.\n  - express: Ekspres hizmetin seçilip seçilmediğini belirten bir karakter ('y' evet için, 'n' hayır için).\n\n  Döndürür:\n  - Toplam posta maliyeti olarak işaretsiz bir tamsayı.\n\n  Örnekler:\n  - calculate_postage(1200, 'y') 17 döndürür.\n  - calculate_postage(1000, 'n') 8 döndürür.\n  - calculate_postage(1500, 'y') 17 döndürür.\n  - calculate_postage(2000, 'n') 16 döndürür.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "vi": "/*\n  Tính toán phí bưu điện dựa trên trọng lượng của gói hàng và liệu dịch vụ chuyển phát nhanh có được chọn hay không.\n  Phí bưu điện được tính như sau:\n  - Đối với trọng lượng lên đến và bao gồm 1000 gram, phí cơ bản là 8 đơn vị.\n  - Đối với mỗi 500 gram bổ sung hoặc phần lẻ của nó, một khoản phí bổ sung là 4 đơn vị được thêm vào.\n  - Nếu dịch vụ chuyển phát nhanh (được biểu thị bằng 'y') được chọn, một khoản phí bổ sung là 5 đơn vị được thêm vào.\n  - Nếu dịch vụ chuyển phát nhanh không được chọn (được biểu thị bằng 'n'), không có khoản phí bổ sung nào được thêm vào.\n\n  Tham số:\n  - weight: Trọng lượng của gói hàng tính bằng gram.\n  - express: Một ký tự chỉ định liệu dịch vụ chuyển phát nhanh có được chọn hay không ('y' cho có, 'n' cho không).\n\n  Trả về:\n  - Tổng chi phí bưu điện dưới dạng số nguyên không dấu.\n\n  Ví dụ:\n  - calculate_postage(1200, 'y') trả về 17.\n  - calculate_postage(1000, 'n') trả về 8.\n  - calculate_postage(1500, 'y') trả về 17.\n  - calculate_postage(2000, 'n') trả về 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 "
    },
    "prompt_bertscore": {
      "es": "0.9719448490914893",
      "arb": "0.9620018094776449",
      "sw": "0.9786351175855064",
      "tr": "0.9793795842536251",
      "vi": "0.968043748407964"
    },
    "canonical_solution": "{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}",
    "instruction": {
      "en": "Write a Rust function `fn calculate_postage(weight: u32, express: char) -> u32` to solve the following problem:\nCalculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.",
      "es": "Escribe una función de Rust `fn calculate_postage(weight: u32, express: char) -> u32` para resolver el siguiente problema:\nCalcula el franqueo basado en el peso de un paquete y si se elige el servicio exprés.\n  El franqueo se calcula de la siguiente manera:\n  - Para un peso de hasta 1000 gramos inclusive, la tarifa base es de 8 unidades.\n  - Por cada 500 gramos adicionales o parte de ellos, se añade una tarifa adicional de 4 unidades.\n  - Si se elige el servicio exprés (denotado por 'y'), se añade una tarifa adicional de 5 unidades.\n  - Si no se elige el servicio exprés (denotado por 'n'), no se añade ninguna tarifa adicional.\n\n  Argumentos:\n  - weight: El peso del paquete en gramos.\n  - express: Un carácter que indica si se elige el servicio exprés ('y' para sí, 'n' para no).\n\n  Retorna:\n  - El costo total del franqueo como un entero sin signo.\n\n  Ejemplos:\n  - calculate_postage(1200, 'y') retorna 17.\n  - calculate_postage(1000, 'n') retorna 8.\n  - calculate_postage(1500, 'y') retorna 17.\n  - calculate_postage(2000, 'n') retorna 16.",
      "arb": "اكتب دالة Rust `fn calculate_postage(weight: u32, express: char) -> u32` لحل المشكلة التالية:\nتحسب رسوم البريد بناءً على وزن الطرد وما إذا تم اختيار خدمة البريد السريع.\nيتم حساب رسوم البريد كما يلي:\n- بالنسبة للوزن حتى 1000 جرام بما في ذلك، تكون الرسوم الأساسية 8 وحدات.\n- لكل 500 جرام إضافية أو جزء منها، يتم إضافة رسوم إضافية قدرها 4 وحدات.\n- إذا تم اختيار خدمة البريد السريع (المشار إليها بـ 'y')، يتم إضافة رسوم إضافية قدرها 5 وحدات.\n- إذا لم يتم اختيار خدمة البريد السريع (المشار إليها بـ 'n')، لا يتم إضافة أي رسوم إضافية.\n\nالمعطيات:\n- weight: وزن الطرد بالجرامات.\n- express: حرف يشير إلى ما إذا تم اختيار خدمة البريد السريع ('y' تعني نعم، 'n' تعني لا).\n\nالقيم المعادة:\n- التكلفة الإجمالية للبريد كعدد صحيح غير موقع.\n\nأمثلة:\n- calculate_postage(1200, 'y') تعيد 17.\n- calculate_postage(1000, 'n') تعيد 8.\n- calculate_postage(1500, 'y') تعيد 17.\n- calculate_postage(2000, 'n') تعيد 16.",
      "sw": "Andika kazi ya Rust `fn calculate_postage(weight: u32, express: char) -> u32` kutatua tatizo lifuatalo:\nInakokotoa gharama ya posta kulingana na uzito wa kifurushi na kama huduma ya haraka imechaguliwa.\n  Gharama ya posta inakokotolewa kama ifuatavyo:\n  - Kwa uzito hadi na ikijumuisha gramu 1000, ada ya msingi ni vitengo 8.\n  - Kwa kila gramu 500 za ziada au sehemu yake, ada ya ziada ya vitengo 4 inaongezwa.\n  - Ikiwa huduma ya haraka (inayoonyeshwa na 'y') imechaguliwa, ada ya ziada ya vitengo 5 inaongezwa.\n  - Ikiwa huduma ya haraka haijachaguliwa (inayoonyeshwa na 'n'), hakuna ada ya ziada inayoongezwa.\n\n  Hoja:\n  - weight: Uzito wa kifurushi kwa gramu.\n  - express: Herufi inayoonyesha kama huduma ya haraka imechaguliwa ('y' kwa ndiyo, 'n' kwa hapana).\n\n  Inarejesha:\n  - Jumla ya gharama ya posta kama namba isiyo na ishara.\n\n  Mifano:\n  - calculate_postage(1200, 'y') inarejesha 17.\n  - calculate_postage(1000, 'n') inarejesha 8.\n  - calculate_postage(1500, 'y') inarejesha 17.\n  - calculate_postage(2000, 'n') inarejesha 16.",
      "tr": "Bir Rust fonksiyonu `fn calculate_postage(weight: u32, express: char) -> u32` yazın ve aşağıdaki problemi çözün:\nBir paketin ağırlığına ve hızlı servis seçilip seçilmediğine göre posta ücretini hesaplar.\n  Posta ücreti şu şekilde hesaplanır:\n  - Ağırlık 1000 grama kadar ve dahil olmak üzere, temel ücret 8 birimdir.\n  - Her ek 500 gram veya bunun bir kısmı için ek bir ücret olarak 4 birim eklenir.\n  - Hızlı servis seçilirse (y ile belirtilir), ek bir ücret olarak 5 birim eklenir.\n  - Hızlı servis seçilmezse (n ile belirtilir), ek bir ücret eklenmez.\n\n  Argümanlar:\n  - weight: Paketin ağırlığı gram cinsindendir.\n  - express: Hızlı servis seçilip seçilmediğini belirten bir karakter ('y' evet için, 'n' hayır için).\n\n  Döndürülen:\n  - Toplam posta maliyeti bir işaretsiz tamsayı olarak.\n\n  Örnekler:\n  - calculate_postage(1200, 'y') 17 döndürür.\n  - calculate_postage(1000, 'n') 8 döndürür.\n  - calculate_postage(1500, 'y') 17 döndürür.\n  - calculate_postage(2000, 'n') 16 döndürür.",
      "vi": "Viết một hàm Rust `fn calculate_postage(weight: u32, express: char) -> u32` để giải quyết vấn đề sau:\nTính toán cước phí dựa trên trọng lượng của gói hàng và liệu dịch vụ chuyển phát nhanh có được chọn hay không.\n  Cước phí được tính như sau:\n  - Đối với trọng lượng lên đến và bao gồm 1000 gram, phí cơ bản là 8 đơn vị.\n  - Đối với mỗi 500 gram bổ sung hoặc một phần của nó, một khoản phí bổ sung là 4 đơn vị được thêm vào.\n  - Nếu dịch vụ chuyển phát nhanh (được biểu thị bằng 'y') được chọn, một khoản phí bổ sung là 5 đơn vị được thêm vào.\n  - Nếu dịch vụ chuyển phát nhanh không được chọn (được biểu thị bằng 'n'), không có phí bổ sung nào được thêm vào.\n\n  Tham số:\n  - weight: Trọng lượng của gói hàng tính bằng gram.\n  - express: Một ký tự chỉ định liệu dịch vụ chuyển phát nhanh có được chọn hay không ('y' cho có, 'n' cho không).\n\n  Trả về:\n  - Tổng chi phí cước phí dưới dạng số nguyên không dấu.\n\n  Ví dụ:\n  - calculate_postage(1200, 'y') trả về 17.\n  - calculate_postage(1000, 'n') trả về 8.\n  - calculate_postage(1500, 'y') trả về 17.\n  - calculate_postage(2000, 'n') trả về 16."
    },
    "instruction_bertscore": {
      "es": "0.983944507670569",
      "arb": "0.9560754734290879",
      "sw": "0.980676839272164",
      "tr": "0.9668227674557426",
      "vi": "0.9692768458134287"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_postage(1200, 'y'), 17);\n        assert_eq!(calculate_postage(1000, 'n'), 8);\n        assert_eq!(calculate_postage(1500, 'y'), 17);\n        assert_eq!(calculate_postage(2000, 'n'), 16);\n        \n    }\n    \n\n}",
    "entry_point": "calculate_postage",
    "signature": "fn calculate_postage(weight: u32, express: char) -> u32",
    "docstring": {
      "en": "Calculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.",
      "es": "Calcula el franqueo basado en el peso de un paquete y si se elige el servicio exprés.\n  El franqueo se calcula de la siguiente manera:\n  - Para un peso de hasta 1000 gramos inclusive, la tarifa base es de 8 unidades.\n  - Por cada 500 gramos adicionales o fracción, se añade una tarifa adicional de 4 unidades.\n  - Si se elige el servicio exprés (denotado por 'y'), se añade una tarifa adicional de 5 unidades.\n  - Si no se elige el servicio exprés (denotado por 'n'), no se añade ninguna tarifa adicional.\n\n  Argumentos:\n  - weight: El peso del paquete en gramos.\n  - express: Un carácter que indica si se elige el servicio exprés ('y' para sí, 'n' para no).\n\n  Retorna:\n  - El costo total del franqueo como un entero sin signo.\n\n  Ejemplos:\n  - calculate_postage(1200, 'y') retorna 17.\n  - calculate_postage(1000, 'n') retorna 8.\n  - calculate_postage(1500, 'y') retorna 17.\n  - calculate_postage(2000, 'n') retorna 16.",
      "arb": "يحسب رسوم البريد بناءً على وزن الطرد وما إذا تم اختيار خدمة البريد السريع.\n  يتم حساب رسوم البريد كما يلي:\n  - للوزن حتى 1000 جرام شاملة، تكون الرسوم الأساسية 8 وحدات.\n  - لكل 500 جرام إضافية أو جزء منها، تضاف رسوم إضافية قدرها 4 وحدات.\n  - إذا تم اختيار خدمة البريد السريع (يشار إليها بـ 'y')، تضاف رسوم إضافية قدرها 5 وحدات.\n  - إذا لم يتم اختيار خدمة البريد السريع (يشار إليها بـ 'n')، لا تضاف رسوم إضافية.\n\n  الحجج:\n  - weight: وزن الطرد بالجرامات.\n  - express: حرف يشير إلى ما إذا تم اختيار خدمة البريد السريع ('y' ل نعم، 'n' ل لا).\n\n  يعيد:\n  - إجمالي تكلفة البريد كعدد صحيح غير موقع.\n\n  أمثلة:\n  - calculate_postage(1200, 'y') يعيد 17.\n  - calculate_postage(1000, 'n') يعيد 8.\n  - calculate_postage(1500, 'y') يعيد 17.\n  - calculate_postage(2000, 'n') يعيد 16.",
      "sw": "Hesabu gharama ya posta kulingana na uzito wa kifurushi na kama huduma ya haraka imechaguliwa.\n  Gharama ya posta inahesabiwa kama ifuatavyo:\n  - Kwa uzito hadi na ikiwa ni pamoja na gramu 1000, ada ya msingi ni vitengo 8.\n  - Kwa kila gramu 500 za ziada au sehemu yake, ada ya ziada ya vitengo 4 inaongezwa.\n  - Ikiwa huduma ya haraka (inayoonyeshwa na 'y') imechaguliwa, ada ya ziada ya vitengo 5 inaongezwa.\n  - Ikiwa huduma ya haraka haijachaguliwa (inayoonyeshwa na 'n'), hakuna ada ya ziada inayoongezwa.\n\n  Hoja:\n  - weight: Uzito wa kifurushi kwa gramu.\n  - express: Tabia inayoonyesha kama huduma ya haraka imechaguliwa ('y' kwa ndiyo, 'n' kwa hapana).\n\n  Inarejesha:\n  - Gharama ya jumla ya posta kama namba nzima isiyo na ishara.\n\n  Mifano:\n  - calculate_postage(1200, 'y') inarudisha 17.\n  - calculate_postage(1000, 'n') inarudisha 8.\n  - calculate_postage(1500, 'y') inarudisha 17.\n  - calculate_postage(2000, 'n') inarudisha 16.",
      "tr": "Paketin ağırlığına ve ekspres hizmetin seçilip seçilmediğine göre posta ücreti hesaplar.\n  Posta ücreti aşağıdaki gibi hesaplanır:\n  - Ağırlık 1000 gram veya daha az ise, temel ücret 8 birimdir.\n  - Her ek 500 gram veya kısmı için, ek 4 birim ücret eklenir.\n  - Ekspres hizmet seçilmişse ( 'y' ile belirtilir), ek 5 birim ücret eklenir.\n  - Ekspres hizmet seçilmemişse ( 'n' ile belirtilir), ek ücret eklenmez.\n\n  Argümanlar:\n  - weight: Paketin ağırlığı gram cinsindendir.\n  - express: Ekspres hizmetin seçilip seçilmediğini belirten bir karakter ('y' evet için, 'n' hayır için).\n\n  Döndürür:\n  - Toplam posta maliyeti bir işaretsiz tamsayı olarak.\n\n  Örnekler:\n  - calculate_postage(1200, 'y') 17 döndürür.\n  - calculate_postage(1000, 'n') 8 döndürür.\n  - calculate_postage(1500, 'y') 17 döndürür.\n  - calculate_postage(2000, 'n') 16 döndürür.",
      "vi": "Tính toán cước phí dựa trên trọng lượng của gói hàng và liệu dịch vụ chuyển phát nhanh có được chọn hay không. \n  Cước phí được tính như sau:\n  - Đối với trọng lượng lên đến và bao gồm 1000 gram, phí cơ bản là 8 đơn vị.\n  - Đối với mỗi 500 gram bổ sung hoặc phần lẻ của nó, một khoản phí bổ sung là 4 đơn vị được thêm vào.\n  - Nếu dịch vụ chuyển phát nhanh (được biểu thị bằng 'y') được chọn, một khoản phí bổ sung là 5 đơn vị được thêm vào.\n  - Nếu dịch vụ chuyển phát nhanh không được chọn (được biểu thị bằng 'n'), không có phí bổ sung nào được thêm vào.\n\n  Đối số:\n  - weight: Trọng lượng của gói hàng tính bằng gram.\n  - express: Một ký tự chỉ định liệu dịch vụ chuyển phát nhanh có được chọn hay không ('y' cho có, 'n' cho không).\n\n  Trả về:\n  - Tổng chi phí cước phí dưới dạng số nguyên không âm.\n\n  Ví dụ:\n  - calculate_postage(1200, 'y') trả về 17.\n  - calculate_postage(1000, 'n') trả về 8.\n  - calculate_postage(1500, 'y') trả về 17.\n  - calculate_postage(2000, 'n') trả về 16."
    },
    "docstring_bertscore": {
      "es": "0.9718224927767718",
      "arb": "0.9504460898001782",
      "sw": "0.976856978414482",
      "tr": "0.9655696083817935",
      "vi": "0.9736204949858996"
    }
  },
  {
    "task_id": "Rust/22",
    "prompt": {
      "en": "\n/*\n  Calculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "es": "/*\n  Calcula el número de pacientes que no pueden ser atendidos en función del stock de medicinas disponible y sus solicitudes.\n\n  Argumentos:\n  - total_medicine: La cantidad total de medicina disponible al comienzo del día.\n  - num_patients: El número de pacientes que vienen a buscar medicina.\n  - patient_requests: Un arreglo de usize, cada uno representando la cantidad de medicina solicitada por un paciente, en el orden en que llegan.\n\n  Retorna:\n  - El número de pacientes que no pueden ser atendidos porque el stock de medicinas es insuficiente.\n\n  Ejemplo:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) devuelve 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) devuelve 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) devuelve 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "arb": "/*\n  يحسب عدد المرضى الذين لا يمكن خدمتهم بناءً على مخزون الدواء المتاح وطلباتهم.\n\n  المعطيات:\n  - total_medicine: إجمالي كمية الدواء المتاحة في بداية اليوم.\n  - num_patients: عدد المرضى الذين يأتون للحصول على الدواء.\n  - patient_requests: مصفوفة من usize، تمثل كل عنصر منها كمية الدواء المطلوبة من قبل مريض، بترتيب وصولهم.\n\n  يعيد:\n  - عدد المرضى الذين لا يمكن خدمتهم لأن مخزون الدواء غير كافٍ.\n\n  مثال:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) يعيد 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) يعيد 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) يعيد 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "sw": "/*\n  Hukokotoa idadi ya wagonjwa ambao hawawezi kuhudumiwa kulingana na hisa ya dawa iliyopo na maombi yao.\n\n  Hoja:\n  - total_medicine: Jumla ya kiasi cha dawa kinachopatikana mwanzoni mwa siku.\n  - num_patients: Idadi ya wagonjwa wanaokuja kupata dawa.\n  - patient_requests: Kundi la usize, kila moja ikiwakilisha kiasi cha dawa kinachoombwa na mgonjwa, kwa mpangilio wanaofika.\n\n  Inarudisha:\n  - Idadi ya wagonjwa ambao hawawezi kuhudumiwa kwa sababu hisa ya dawa haitoshi.\n\n  Mfano:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) inarudisha 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) inarudisha 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) inarudisha 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "tr": "/*\n  Mevcut ilaç stoğuna ve hasta taleplerine göre hizmet verilemeyen hasta sayısını hesaplar.\n\n  Argümanlar:\n  - total_medicine: Günün başında mevcut olan toplam ilaç miktarı.\n  - num_patients: İlaç almaya gelen hasta sayısı.\n  - patient_requests: Her bir hastanın geldiği sırayla talep ettiği ilaç miktarını temsil eden usize dizisi.\n\n  Döndürür:\n  - İlaç stoğu yetersiz olduğu için hizmet verilemeyen hasta sayısı.\n\n  Örnek:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 döndürür\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 döndürür\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 döndürür\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "vi": "/*\n  Tính toán số lượng bệnh nhân không thể được phục vụ dựa trên lượng thuốc có sẵn và yêu cầu của họ.\n\n  Tham số:\n  - total_medicine: Tổng lượng thuốc có sẵn vào đầu ngày.\n  - num_patients: Số lượng bệnh nhân đến để lấy thuốc.\n  - patient_requests: Một mảng usize, mỗi phần tử đại diện cho lượng thuốc mà một bệnh nhân yêu cầu, theo thứ tự họ đến.\n\n  Trả về:\n  - Số lượng bệnh nhân không thể được phục vụ vì lượng thuốc không đủ.\n\n  Ví dụ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) trả về 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) trả về 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) trả về 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.9896420215201737",
      "arb": "0.9821107519928549",
      "sw": "0.9892544936467746",
      "tr": "0.9686217628167756",
      "vi": "0.9684487557548942"
    },
    "canonical_solution": "{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` to solve the following problem:\nCalculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1",
      "es": "Escribe una función en Rust `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` para resolver el siguiente problema:\nCalcula el número de pacientes que no pueden ser atendidos en función del stock de medicinas disponible y sus solicitudes.\n\n  Argumentos:\n  - total_medicine: La cantidad total de medicina disponible al comienzo del día.\n  - num_patients: El número de pacientes que vienen a obtener medicina.\n  - patient_requests: Un arreglo de usize, cada uno representando la cantidad de medicina solicitada por un paciente, en el orden en que llegan.\n\n  Devuelve:\n  - El número de pacientes que no pueden ser atendidos porque el stock de medicinas es insuficiente.\n\n  Ejemplo:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) devuelve 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) devuelve 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) devuelve 1",
      "arb": "اكتب دالة بلغة Rust `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` لحل المشكلة التالية:\nتحسب عدد المرضى الذين لا يمكن خدمتهم بناءً على مخزون الدواء المتاح وطلباتهم.\n\n  المعطيات:\n  - total_medicine: إجمالي كمية الدواء المتاحة في بداية اليوم.\n  - num_patients: عدد المرضى الذين يأتون للحصول على الدواء.\n  - patient_requests: مصفوفة من النوع usize، كل عنصر يمثل كمية الدواء المطلوبة من قبل مريض، بترتيب وصولهم.\n\n  المخرجات:\n  - عدد المرضى الذين لا يمكن خدمتهم لأن مخزون الدواء غير كافٍ.\n\n  مثال:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) يعيد 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) يعيد 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) يعيد 1",
      "sw": "Andika kazi ya Rust `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` kutatua tatizo lifuatalo:\nInakokotoa idadi ya wagonjwa ambao hawawezi kuhudumiwa kulingana na hisa ya dawa inayopatikana na maombi yao.\n\n  Hoja:\n  - total_medicine: Kiasi cha jumla cha dawa kinachopatikana mwanzoni mwa siku.\n  - num_patients: Idadi ya wagonjwa wanaokuja kupata dawa.\n  - patient_requests: Mfululizo wa usize, kila moja ikiwakilisha kiasi cha dawa kinachoombwa na mgonjwa, kwa mpangilio wanaofika.\n\n  Inarudisha:\n  - Idadi ya wagonjwa ambao hawawezi kuhudumiwa kwa sababu hisa ya dawa haitoshi.\n\n  Mfano:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) inarudisha 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) inarudisha 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) inarudisha 1",
      "tr": "Bir Rust fonksiyonu `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` yazarak aşağıdaki problemi çözün:\nMevcut ilaç stoğuna ve hastaların taleplerine dayanarak hizmet verilemeyen hasta sayısını hesaplar.\n\n  Argümanlar:\n  - total_medicine: Günün başında mevcut olan toplam ilaç miktarı.\n  - num_patients: İlaç almaya gelen hasta sayısı.\n  - patient_requests: Her biri bir hastanın, geldiği sıraya göre talep ettiği ilaç miktarını temsil eden bir usize dizisi.\n\n  Döndürür:\n  - İlaç stoğu yetersiz olduğu için hizmet verilemeyen hasta sayısı.\n\n  Örnek:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 döndürür\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 döndürür\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 döndürür",
      "vi": "Viết một hàm Rust `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` để giải quyết vấn đề sau:\nTính toán số lượng bệnh nhân không thể được phục vụ dựa trên lượng thuốc có sẵn và yêu cầu của họ.\n\n  Tham số:\n  - total_medicine: Tổng số lượng thuốc có sẵn vào đầu ngày.\n  - num_patients: Số lượng bệnh nhân đến để lấy thuốc.\n  - patient_requests: Một mảng usize, mỗi phần tử đại diện cho lượng thuốc mà một bệnh nhân yêu cầu, theo thứ tự họ đến.\n\n  Trả về:\n  - Số lượng bệnh nhân không thể được phục vụ vì lượng thuốc không đủ.\n\n  Ví dụ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) trả về 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) trả về 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) trả về 1"
    },
    "instruction_bertscore": {
      "es": "0.987748080837006",
      "arb": "0.9670821787333742",
      "sw": "0.9885376366016198",
      "tr": "0.9698578396779557",
      "vi": "0.9792260429690852"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]), 2);\n        assert_eq!(count_unserved_patients(50, 4, &[10, 15, 10, 20]), 1);\n        assert_eq!(count_unserved_patients(10, 3, &[5, 10, 5]), 1);\n        assert_eq!(count_unserved_patients(20, 5, &[4, 5, 7, 3, 2]), 1);\n        \n    }\n    \n\n}",
    "entry_point": "count_unserved_patients",
    "signature": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize",
    "docstring": {
      "en": "Calculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1",
      "es": "Calcula el número de pacientes que no pueden ser atendidos en función del stock de medicamentos disponible y sus solicitudes.\n\n  Argumentos:\n  - total_medicine: La cantidad total de medicamentos disponible al comienzo del día.\n  - num_patients: El número de pacientes que vienen a obtener medicamentos.\n  - patient_requests: Un arreglo de usize, cada uno representando la cantidad de medicamento solicitada por un paciente, en el orden en que llegan.\n\n  Devuelve:\n  - El número de pacientes que no pueden ser atendidos porque el stock de medicamentos es insuficiente.\n\n  Ejemplo:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) devuelve 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) devuelve 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) devuelve 1",
      "arb": "يحسب عدد المرضى الذين لا يمكن خدمتهم بناءً على مخزون الدواء المتاح وطلباتهم.\n\n  الحجج:\n  - total_medicine: إجمالي كمية الدواء المتاحة في بداية اليوم.\n  - num_patients: عدد المرضى الذين يأتون للحصول على الدواء.\n  - patient_requests: مصفوفة من usize، كل عنصر يمثل كمية الدواء المطلوبة من قبل مريض، بترتيب وصولهم.\n\n  يعيد:\n  - عدد المرضى الذين لا يمكن خدمتهم لأن مخزون الدواء غير كافٍ.\n\n  مثال:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) يعيد 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) يعيد 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) يعيد 1",
      "sw": "Hesabu idadi ya wagonjwa ambao hawawezi kuhudumiwa kulingana na hisa ya dawa inayopatikana na maombi yao.\n\n  Hoja:\n  - total_medicine: Jumla ya kiasi cha dawa kinachopatikana mwanzoni mwa siku.\n  - num_patients: Idadi ya wagonjwa wanaokuja kupata dawa.\n  - patient_requests: Safu ya usize, kila moja ikiwakilisha kiasi cha dawa kinachoombwa na mgonjwa, kwa mpangilio wanaofika.\n\n  Inarejesha:\n  - Idadi ya wagonjwa ambao hawawezi kuhudumiwa kwa sababu hisa ya dawa haitoshi.\n\n  Mfano:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) inarejesha 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) inarejesha 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) inarejesha 1",
      "tr": "Hastaların taleplerine ve mevcut ilaç stokuna göre hizmet verilemeyen hasta sayısını hesaplar.\n\n  Argümanlar:\n  - total_medicine: Günün başında mevcut olan toplam ilaç miktarı.\n  - num_patients: İlaç almaya gelen hasta sayısı.\n  - patient_requests: Her biri bir hastanın talep ettiği ilaç miktarını temsil eden, hastaların geldikleri sıraya göre bir usize dizisi.\n\n  Döndürür:\n  - İlaç stoku yetersiz olduğu için hizmet verilemeyen hasta sayısı.\n\n  Örnek:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 döndürür\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 döndürür\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 döndürür",
      "vi": "Tính toán số lượng bệnh nhân không thể phục vụ dựa trên lượng thuốc có sẵn và yêu cầu của họ.\n\n  Tham số:\n  - total_medicine: Tổng lượng thuốc có sẵn vào đầu ngày.\n  - num_patients: Số lượng bệnh nhân đến để lấy thuốc.\n  - patient_requests: Một mảng usize, mỗi phần tử đại diện cho lượng thuốc mà một bệnh nhân yêu cầu, theo thứ tự họ đến.\n\n  Trả về:\n  - Số lượng bệnh nhân không thể phục vụ vì lượng thuốc không đủ.\n\n  Ví dụ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) trả về 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) trả về 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) trả về 1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9754155177393119",
      "sw": "0.9863942161598722",
      "tr": "0.9636111128247895",
      "vi": "0.9723353564206039"
    }
  },
  {
    "task_id": "Rust/23",
    "prompt": {
      "en": "/*\n  Determines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "es": "/*\n  Determina si una secuencia es un \"Jolly Jumper\". Una secuencia se considera un \"Jolly Jumper\" si las diferencias absolutas entre elementos sucesivos, cuando se ordenan, forman una secuencia de números consecutivos comenzando desde 1. Por ejemplo, una secuencia de [3, 1, 4, 2] es un Jolly Jumper porque las diferencias absolutas son 2, 3, 2, formando una secuencia consecutiva 1, 2, 3. Una secuencia con un solo elemento siempre es un Jolly Jumper.\n\n  Argumentos:\n  - sequence: Un segmento de enteros, representando la secuencia.\n\n  Retorna:\n  - Un valor booleano que indica si la secuencia es un Jolly Jumper.\n\n  Ejemplos:\n  - is_jolly_jumper(&[1, 4, 2, 3]) retorna true.\n  - is_jolly_jumper(&[1, 3]) retorna false.\n  - is_jolly_jumper(&[5]) retorna true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "arb": "/*\n  يحدد ما إذا كانت تسلسلاً هو \"Jolly Jumper\". يعتبر التسلسل \"Jolly Jumper\" إذا كانت الفروق المطلقة بين العناصر المتتالية، عند ترتيبها، تشكل تسلسلاً من الأرقام المتتالية بدءًا من 1. على سبيل المثال، تسلسل [3, 1, 4, 2] هو Jolly Jumper لأن الفروق المطلقة هي 2، 3، 2، مما يشكل تسلسلاً متتالياً 1، 2، 3. التسلسل الذي يحتوي على عنصر واحد دائمًا ما يكون Jolly Jumper.\n\n  الوسائط:\n  - sequence: شريحة من الأعداد الصحيحة، تمثل التسلسل.\n\n  يعيد:\n  - قيمة منطقية تشير إلى ما إذا كان التسلسل هو Jolly Jumper.\n\n  أمثلة:\n  - is_jolly_jumper(&[1, 4, 2, 3]) يعيد true.\n  - is_jolly_jumper(&[1, 3]) يعيد false.\n  - is_jolly_jumper(&[5]) يعيد true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "sw": "/*\n  Huamua kama mlolongo ni \"Jolly Jumper\". Mlolongo unachukuliwa kuwa \"Jolly Jumper\" ikiwa tofauti kamili kati ya vipengele vinavyofuatana, zinapopangwa, huunda mlolongo wa namba mfululizo kuanzia 1. Kwa mfano, mlolongo wa [3, 1, 4, 2] ni Jolly Jumper kwa sababu tofauti kamili ni 2, 3, 2, zikifanya mlolongo mfululizo 1, 2, 3. Mlolongo wenye kipengele kimoja daima ni Jolly Jumper.\n\n  Hoja:\n  - sequence: Sehemu ya namba za mzima, inayoashiria mlolongo.\n\n  Inarudisha:\n  - Thamani ya boolean inayoonyesha kama mlolongo ni Jolly Jumper.\n\n  Mifano:\n  - is_jolly_jumper(&[1, 4, 2, 3]) inarudisha true.\n  - is_jolly_jumper(&[1, 3]) inarudisha false.\n  - is_jolly_jumper(&[5]) inarudisha true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "tr": "/*\n  Bir dizinin \"Jolly Jumper\" olup olmadığını belirler. Bir dizi, ardışık elemanlar arasındaki mutlak farklar sıralandığında, 1'den başlayan ardışık sayılar dizisi oluşturuyorsa \"Jolly Jumper\" olarak kabul edilir. Örneğin, [3, 1, 4, 2] dizisi bir Jolly Jumper'dır çünkü mutlak farklar 2, 3, 2 olup, 1, 2, 3 ardışık dizisini oluşturur. Tek bir eleman içeren bir dizi her zaman bir Jolly Jumper'dır.\n\n  Argümanlar:\n  - sequence: Diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizinin bir Jolly Jumper olup olmadığını belirten bir boolean değeri.\n\n  Örnekler:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true döndürür.\n  - is_jolly_jumper(&[1, 3]) false döndürür.\n  - is_jolly_jumper(&[5]) true döndürür.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "vi": "/*\n  Xác định xem một dãy có phải là \"Jolly Jumper\" hay không. Một dãy được coi là \"Jolly Jumper\" nếu các giá trị tuyệt đối của sự khác biệt giữa các phần tử liên tiếp, khi được sắp xếp, tạo thành một dãy số liên tiếp bắt đầu từ 1. Ví dụ, một dãy [3, 1, 4, 2] là một Jolly Jumper vì các giá trị tuyệt đối của sự khác biệt là 2, 3, 2, tạo thành một dãy liên tiếp 1, 2, 3. Một dãy chỉ có một phần tử luôn luôn là một Jolly Jumper.\n\n  Tham số:\n  - sequence: Một dãy số nguyên, đại diện cho dãy số.\n\n  Trả về:\n  - Một giá trị boolean cho biết liệu dãy số có phải là Jolly Jumper hay không.\n\n  Ví dụ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) trả về true.\n  - is_jolly_jumper(&[1, 3]) trả về false.\n  - is_jolly_jumper(&[5]) trả về true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool "
    },
    "prompt_bertscore": {
      "es": "0.9986213065252368",
      "arb": "0.9819965395237598",
      "sw": "0.9900039260744192",
      "tr": "0.9833819864314781",
      "vi": "0.9563229668838574"
    },
    "canonical_solution": "{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}",
    "instruction": {
      "en": "Write a Rust function `fn is_jolly_jumper(sequence: &[i32]) -> bool` to solve the following problem:\nDetermines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.",
      "es": "Escribe una función en Rust `fn is_jolly_jumper(sequence: &[i32]) -> bool` para resolver el siguiente problema:\nDetermina si una secuencia es un \"Jolly Jumper\". Una secuencia se considera un \"Jolly Jumper\" si las diferencias absolutas entre elementos sucesivos, cuando se ordenan, forman una secuencia de números consecutivos comenzando desde 1. Por ejemplo, una secuencia de [3, 1, 4, 2] es un Jolly Jumper porque las diferencias absolutas son 2, 3, 2, formando una secuencia consecutiva 1, 2, 3. Una secuencia con un solo elemento siempre es un Jolly Jumper.\n\n  Argumentos:\n  - sequence: Una porción de enteros, que representa la secuencia.\n\n  Devuelve:\n  - Un valor booleano que indica si la secuencia es un Jolly Jumper.\n\n  Ejemplos:\n  - is_jolly_jumper(&[1, 4, 2, 3]) devuelve true.\n  - is_jolly_jumper(&[1, 3]) devuelve false.\n  - is_jolly_jumper(&[5]) devuelve true.",
      "arb": "اكتب دالة Rust `fn is_jolly_jumper(sequence: &[i32]) -> bool` لحل المشكلة التالية:\nتحديد ما إذا كانت سلسلة ما هي \"Jolly Jumper\". تعتبر السلسلة \"Jolly Jumper\" إذا كانت الفروقات المطلقة بين العناصر المتتالية، عند ترتيبها، تشكل سلسلة من الأرقام المتتالية التي تبدأ من 1. على سبيل المثال، السلسلة [3, 1, 4, 2] هي Jolly Jumper لأن الفروقات المطلقة هي 2, 3, 2، وتشكل سلسلة متتالية 1, 2, 3. السلسلة التي تحتوي على عنصر واحد دائمًا تعتبر Jolly Jumper.\n\n  الوسائط:\n  - sequence: جزء من الأعداد الصحيحة، يمثل السلسلة.\n\n  يعيد:\n  - قيمة منطقية تشير إلى ما إذا كانت السلسلة Jolly Jumper.\n\n  أمثلة:\n  - is_jolly_jumper(&[1, 4, 2, 3]) يعيد true.\n  - is_jolly_jumper(&[1, 3]) يعيد false.\n  - is_jolly_jumper(&[5]) يعيد true.",
      "sw": "Andika kazi ya Rust `fn is_jolly_jumper(sequence: &[i32]) -> bool` kutatua tatizo lifuatalo:\nInabainisha kama mlolongo ni \"Jolly Jumper\". Mlolongo unachukuliwa kuwa \"Jolly Jumper\" ikiwa tofauti za thamani kabisa kati ya vipengele vinavyofuatana, zinapopangwa, zinaunda mlolongo wa namba mfululizo kuanzia 1. Kwa mfano, mlolongo wa [3, 1, 4, 2] ni Jolly Jumper kwa sababu tofauti za thamani kabisa ni 2, 3, 2, zikaunda mlolongo mfululizo 1, 2, 3. Mlolongo wenye kipengele kimoja daima ni Jolly Jumper.\n\n  Hoja:\n  - sequence: Kipande cha namba za mzima, kinachowakilisha mlolongo.\n\n  Inarudisha:\n  - Thamani ya boolean inayoonyesha kama mlolongo ni Jolly Jumper.\n\n  Mifano:\n  - is_jolly_jumper(&[1, 4, 2, 3]) inarudisha true.\n  - is_jolly_jumper(&[1, 3]) inarudisha false.\n  - is_jolly_jumper(&[5]) inarudisha true.",
      "tr": "Bir Rust fonksiyonu `fn is_jolly_jumper(sequence: &[i32]) -> bool` yazın ve aşağıdaki problemi çözün:\nBir dizinin \"Jolly Jumper\" olup olmadığını belirler. Bir dizi, ardışık elemanlar arasındaki mutlak farklar sıralandığında, 1'den başlayan ardışık sayılar dizisi oluşturuyorsa \"Jolly Jumper\" olarak kabul edilir. Örneğin, [3, 1, 4, 2] dizisi bir Jolly Jumper'dır çünkü mutlak farklar 2, 3, 2 olup, 1, 2, 3 ardışık dizisini oluşturur. Tek bir elemanı olan bir dizi her zaman bir Jolly Jumper'dır.\n\n  Argümanlar:\n  - sequence: Diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizinin bir Jolly Jumper olup olmadığını belirten bir boolean değeri.\n\n  Örnekler:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true döndürür.\n  - is_jolly_jumper(&[1, 3]) false döndürür.\n  - is_jolly_jumper(&[5]) true döndürür.",
      "vi": "Viết một hàm Rust `fn is_jolly_jumper(sequence: &[i32]) -> bool` để giải quyết vấn đề sau:\nXác định xem một dãy số có phải là \"Jolly Jumper\" hay không. Một dãy số được coi là \"Jolly Jumper\" nếu các giá trị tuyệt đối của hiệu giữa các phần tử liên tiếp, khi được sắp xếp, tạo thành một dãy số liên tiếp bắt đầu từ 1. Ví dụ, một dãy số [3, 1, 4, 2] là một Jolly Jumper vì các giá trị tuyệt đối của hiệu là 2, 3, 2, tạo thành một dãy liên tiếp 1, 2, 3. Một dãy số với một phần tử duy nhất luôn là Jolly Jumper.\n\n  Tham số:\n  - sequence: Một lát cắt của các số nguyên, đại diện cho dãy số.\n\n  Trả về:\n  - Một giá trị boolean cho biết liệu dãy số có phải là Jolly Jumper hay không.\n\n  Ví dụ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) trả về true.\n  - is_jolly_jumper(&[1, 3]) trả về false.\n  - is_jolly_jumper(&[5]) trả về true."
    },
    "instruction_bertscore": {
      "es": "0.9940015611231274",
      "arb": "0.9811025041787218",
      "sw": "0.9951369323811229",
      "tr": "0.9815049293306984",
      "vi": "0.9671850692707502"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(is_jolly_jumper(&[1, 4, 2, 3]), true);\n        assert_eq!(is_jolly_jumper(&[1, 3]), false);\n        assert_eq!(is_jolly_jumper(&[5]), true);\n        assert_eq!(is_jolly_jumper(&[10, 7, 8, 9]), false);\n    }\n    \n\n}",
    "entry_point": "is_jolly_jumper",
    "signature": "fn is_jolly_jumper(sequence: &[i32]) -> bool",
    "docstring": {
      "en": "Determines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.",
      "es": "Determina si una secuencia es un \"Jolly Jumper\". Una secuencia se considera un \"Jolly Jumper\" si las diferencias absolutas entre elementos sucesivos, cuando se ordenan, forman una secuencia de números consecutivos comenzando desde 1. Por ejemplo, una secuencia de [3, 1, 4, 2] es un Jolly Jumper porque las diferencias absolutas son 2, 3, 2, formando una secuencia consecutiva 1, 2, 3. Una secuencia con un solo elemento siempre es un Jolly Jumper.\n\n  Argumentos:\n  - sequence: Un segmento de enteros, que representa la secuencia.\n\n  Retorna:\n  - Un valor booleano que indica si la secuencia es un Jolly Jumper.\n\n  Ejemplos:\n  - is_jolly_jumper(&[1, 4, 2, 3]) retorna true.\n  - is_jolly_jumper(&[1, 3]) retorna false.\n  - is_jolly_jumper(&[5]) retorna true.",
      "arb": "يحدد ما إذا كانت سلسلة ما هي \"Jolly Jumper\". تعتبر السلسلة \"Jolly Jumper\" إذا كانت الفروق المطلقة بين العناصر المتتالية، عند ترتيبها، تشكل سلسلة من الأرقام المتتالية التي تبدأ من 1. على سبيل المثال، تعتبر السلسلة [3, 1, 4, 2] Jolly Jumper لأن الفروق المطلقة هي 2، 3، 2، مما يشكل سلسلة متتالية 1، 2، 3. السلسلة التي تحتوي على عنصر واحد دائمًا ما تكون Jolly Jumper.\n\n  الحجج:\n  - sequence: شريحة من الأعداد الصحيحة، تمثل السلسلة.\n\n  العوائد:\n  - قيمة منطقية تشير إلى ما إذا كانت السلسلة Jolly Jumper.\n\n  أمثلة:\n  - is_jolly_jumper(&[1, 4, 2, 3]) تعيد true.\n  - is_jolly_jumper(&[1, 3]) تعيد false.\n  - is_jolly_jumper(&[5]) تعيد true.",
      "sw": "Huamua kama mlolongo ni \"Jolly Jumper\". Mlolongo unachukuliwa kuwa \"Jolly Jumper\" ikiwa tofauti za thamani kabisa kati ya vipengele vinavyofuatana, zinapopangwa, huunda mlolongo wa namba zinazofuatana kuanzia 1. Kwa mfano, mlolongo wa [3, 1, 4, 2] ni Jolly Jumper kwa sababu tofauti za thamani kabisa ni 2, 3, 2, zikifanya mlolongo wa namba zinazofuatana 1, 2, 3. Mlolongo wenye kipengele kimoja daima ni Jolly Jumper.\n\n  Hoja:\n  - sequence: Kipande cha namba za mzima, kinachoashiria mlolongo.\n\n  Inarudisha:\n  - Thamani ya boolean inayoonyesha kama mlolongo ni Jolly Jumper.\n\n  Mifano:\n  - is_jolly_jumper(&[1, 4, 2, 3]) inarudisha true.\n  - is_jolly_jumper(&[1, 3]) inarudisha false.\n  - is_jolly_jumper(&[5]) inarudisha true.",
      "tr": "Belirli bir dizinin \"Jolly Jumper\" olup olmadığını belirler. Bir dizi, ardışık elemanlar arasındaki mutlak farklar sıralandığında, 1'den başlayarak ardışık sayılar dizisi oluşturuyorsa \"Jolly Jumper\" olarak kabul edilir. Örneğin, [3, 1, 4, 2] dizisi bir Jolly Jumper'dır çünkü mutlak farklar 2, 3, 2 olup, ardışık bir dizi olan 1, 2, 3'ü oluşturur. Tek bir elemandan oluşan bir dizi her zaman bir Jolly Jumper'dır.\n\n  Argümanlar:\n  - sequence: Diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizinin bir Jolly Jumper olup olmadığını belirten bir boolean değeri.\n\n  Örnekler:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true döndürür.\n  - is_jolly_jumper(&[1, 3]) false döndürür.\n  - is_jolly_jumper(&[5]) true döndürür.",
      "vi": "Xác định xem một dãy có phải là \"Jolly Jumper\" hay không. Một dãy được coi là \"Jolly Jumper\" nếu các chênh lệch tuyệt đối giữa các phần tử liên tiếp, khi được sắp xếp, tạo thành một dãy số liên tiếp bắt đầu từ 1. Ví dụ, một dãy [3, 1, 4, 2] là một Jolly Jumper vì các chênh lệch tuyệt đối là 2, 3, 2, tạo thành một dãy liên tiếp 1, 2, 3. Một dãy với một phần tử duy nhất luôn là Jolly Jumper.\n\n  Tham số:\n  - sequence: Một dãy số nguyên, đại diện cho dãy số.\n\n  Trả về:\n  - Một giá trị boolean cho biết liệu dãy có phải là Jolly Jumper hay không.\n\n  Ví dụ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) trả về true.\n  - is_jolly_jumper(&[1, 3]) trả về false.\n  - is_jolly_jumper(&[5]) trả về true."
    },
    "docstring_bertscore": {
      "es": "0.9950684048996657",
      "arb": "0.9900368987176711",
      "sw": "0.9895307885067941",
      "tr": "0.974556044080574",
      "vi": "0.9636190580400309"
    }
  },
  {
    "task_id": "Rust/24",
    "prompt": {
      "en": "/*\n  Computes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "es": "/*\n  Calcula la transpuesta de una matriz cuadrada dada.\n\n  Argumentos:\n  - matrix: Una matriz cuadrada representada como un vector de vectores de i32.\n\n  Devuelve:\n  - Una nueva matriz que es la transpuesta de la matriz de entrada. En la matriz transpuesta, las filas y columnas de la matriz original se intercambian, de modo que el elemento en la posición (i, j) en la matriz original se mueve a la posición (j, i) en la matriz transpuesta.\n\n  Ejemplo:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) devuelve vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "arb": "/*\n  يحسب المصفوفة المنقولة لمصفوفة مربعة معطاة.\n\n  المعطيات:\n  - matrix: مصفوفة مربعة ممثلة كمتجه من المتجهات من i32.\n\n  يعيد:\n  - مصفوفة جديدة وهي المصفوفة المنقولة للمصفوفة المدخلة. في المصفوفة المنقولة، يتم تبديل الصفوف والأعمدة للمصفوفة الأصلية، بحيث أن العنصر في الموقع (i, j) في المصفوفة الأصلية ينتقل إلى الموقع (j, i) في المصفوفة المنقولة.\n\n  مثال:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) يعيد vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "sw": "/*\n  Inahesabu ubadilishaji wa matrix ya mraba iliyotolewa.\n\n  Hoja:\n  - matrix: Matrix ya mraba inayowakilishwa kama vector ya vectors ya i32.\n\n  Inarudisha:\n  - Matrix mpya ambayo ni ubadilishaji wa matrix ya ingizo. Katika matrix iliyobadilishwa, mistari na safu za matrix ya awali hubadilishwa, ili kipengele kilichopo kwenye (i, j) katika matrix ya awali kinasogea hadi nafasi (j, i) katika matrix iliyobadilishwa.\n\n  Mfano:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) inarudisha vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "tr": "/*\n  Verilen bir kare matrisin transpozunu hesaplar.\n\n  Argümanlar:\n  - matrix: i32 vektörlerinin bir vektörü olarak temsil edilen bir kare matris.\n\n  Döndürür:\n  - Girdi matrisinin transpozu olan yeni bir matris. Transpoze matrisinde, orijinal matrisin satır ve sütunları yer değiştirir, böylece orijinal matrisin (i, j) konumundaki eleman, transpoze matrisin (j, i) konumuna taşınır.\n\n  Örnek:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) vec![vec![1, 3], vec![2, 4]] döndürür\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "vi": "/*\n  Tính chuyển vị của một ma trận vuông cho trước.\n\n  Tham số:\n  - matrix: Một ma trận vuông được biểu diễn dưới dạng một vector của các vector của i32.\n\n  Trả về:\n  - Một ma trận mới là chuyển vị của ma trận đầu vào. Trong ma trận chuyển vị, các hàng và cột của ma trận gốc được hoán đổi, do đó phần tử tại vị trí (i, j) trong ma trận gốc sẽ chuyển đến vị trí (j, i) trong ma trận chuyển vị.\n\n  Ví dụ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) trả về vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> "
    },
    "prompt_bertscore": {
      "es": "0.9860148321320956",
      "arb": "0.9835986921771872",
      "sw": "0.9897564326196497",
      "tr": "0.9883163623571468",
      "vi": "0.9821894096237447"
    },
    "canonical_solution": "{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}",
    "instruction": {
      "en": "Write a Rust function `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` to solve the following problem:\nComputes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]",
      "es": "Escribe una función de Rust `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` para resolver el siguiente problema:\nCalcula la transpuesta de una matriz cuadrada dada.\n\n  Argumentos:\n  - matrix: Una matriz cuadrada representada como un vector de vectores de i32.\n\n  Retorna:\n  - Una nueva matriz que es la transpuesta de la matriz de entrada. En la matriz transpuesta, las filas y columnas de la matriz original se intercambian, de modo que el elemento en (i, j) en la matriz original se mueve a la posición (j, i) en la matriz transpuesta.\n\n  Ejemplo:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) retorna vec![vec![1, 3], vec![2, 4]]",
      "arb": "اكتب دالة بلغة Rust `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` لحل المشكلة التالية:\nتحسب المصفوفة المنقولة لمصفوفة مربعة معطاة.\n\n  الوسائط:\n  - matrix: مصفوفة مربعة ممثلة كمتجه من المتجهات من i32.\n\n  تعيد:\n  - مصفوفة جديدة وهي المصفوفة المنقولة للمصفوفة المدخلة. في المصفوفة المنقولة، يتم تبديل الصفوف والأعمدة للمصفوفة الأصلية، بحيث ينتقل العنصر في الموضع (i, j) في المصفوفة الأصلية إلى الموضع (j, i) في المصفوفة المنقولة.\n\n  مثال:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) تعيد vec![vec![1, 3], vec![2, 4]]",
      "sw": "Andika kazi ya Rust `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` kutatua tatizo lifuatalo: \nHesabu kipeo cha matrix mraba uliotolewa.\n\n  Hoja:\n  - matrix: Matrix mraba inayowakilishwa kama vector ya vectors za i32.\n\n  Inarudisha:\n  - Matrix mpya ambayo ni kipeo cha matrix ya ingizo. Katika matrix iliyogeuzwa, safu na nguzo za matrix ya awali zimebadilishwa, ili kipengele katika (i, j) kwenye matrix ya awali kinahamia nafasi (j, i) kwenye matrix iliyogeuzwa.\n\n  Mfano:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) inarudisha vec![vec![1, 3], vec![2, 4]]",
      "tr": "Bir Rust fonksiyonu `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` yazın ve aşağıdaki problemi çözün:\nVerilen bir kare matrisin transpozunu hesaplar.\n\n  Argümanlar:\n  - matrix: i32 vektörlerinin bir vektörü olarak temsil edilen bir kare matris.\n\n  Döndürür:\n  - Girdi matrisinin transpozu olan yeni bir matris. Transpoze matrisinde, orijinal matrisin satır ve sütunları yer değiştirir, böylece orijinal matristeki (i, j) konumundaki eleman, transpoze matrisinde (j, i) konumuna taşınır.\n\n  Örnek:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) vec![vec![1, 3], vec![2, 4]] döndürür.",
      "vi": "Viết một hàm Rust `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` để giải quyết vấn đề sau:\nTính chuyển vị của một ma trận vuông đã cho.\n\n  Tham số:\n  - matrix: Một ma trận vuông được biểu diễn dưới dạng một vector của các vector của i32.\n\n  Trả về:\n  - Một ma trận mới là chuyển vị của ma trận đầu vào. Trong ma trận chuyển vị, các hàng và cột của ma trận gốc được hoán đổi, sao cho phần tử tại vị trí (i, j) trong ma trận gốc chuyển đến vị trí (j, i) trong ma trận chuyển vị.\n\n  Ví dụ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) trả về vec![vec![1, 3], vec![2, 4]]"
    },
    "instruction_bertscore": {
      "es": "0.9888729246848066",
      "arb": "0.970491867854219",
      "sw": "0.9883932323146073",
      "tr": "0.9811849357868513",
      "vi": "0.9809179765547403"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2], vec![3, 4]]),\n            vec![vec![1, 3], vec![2, 4]]\n        );\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]),\n            vec![vec![1, 4, 7], vec![2, 5, 8], vec![3, 6, 9]]\n        );\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2], vec![1, 2]]),\n            vec![vec![1, 1], vec![2, 2]]\n        );\n    }\n    \n\n}",
    "entry_point": "transpose_matrix",
    "signature": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>",
    "docstring": {
      "en": "Computes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]",
      "es": "Calcula la transposición de una matriz cuadrada dada.\n\n  Argumentos:\n  - matrix: Una matriz cuadrada representada como un vector de vectores de i32.\n\n  Retorna:\n  - Una nueva matriz que es la transposición de la matriz de entrada. En la matriz transpuesta, las filas y columnas de la matriz original se intercambian, de modo que el elemento en (i, j) en la matriz original se mueve a la posición (j, i) en la matriz transpuesta.\n\n  Ejemplo:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) retorna vec![vec![1, 3], vec![2, 4]]",
      "arb": "يحسب المصفوفة المنقولة لمصفوفة مربعة معينة.\n\n  الحجج:\n  - matrix: مصفوفة مربعة ممثلة كمتجه من المتجهات من i32.\n\n  يعيد:\n  - مصفوفة جديدة وهي المصفوفة المنقولة للمصفوفة المدخلة. في المصفوفة المنقولة، يتم تبديل الصفوف والأعمدة للمصفوفة الأصلية، بحيث أن العنصر في (i, j) في المصفوفة الأصلية ينتقل إلى الموضع (j, i) في المصفوفة المنقولة.\n\n  مثال:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) يعيد vec![vec![1, 3], vec![2, 4]]",
      "sw": "Hesabu kipeuo cha matrix mraba uliotolewa.\n\n  Hoja:\n  - matrix: Matrix mraba inayowakilishwa kama vector ya vectors ya i32.\n\n  Inarejesha:\n  - Matrix mpya ambayo ni kipeuo cha matrix ya ingizo. Katika matrix iliyogeuzwa, safu na nguzo za matrix ya awali zimebadilishwa, ili kipengele kilicho kwenye (i, j) katika matrix ya awali kihamie kwenye nafasi (j, i) katika matrix iliyogeuzwa.\n\n  Mfano:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) inarejesha vec![vec![1, 3], vec![2, 4]]",
      "tr": "Verilen bir kare matrisin transpozunu hesaplar.\n\n  Argümanlar:\n  - matrix: i32 vektörlerinin vektörü olarak temsil edilen bir kare matris.\n\n  Döndürür:\n  - Girdi matrisinin transpozu olan yeni bir matris. Transpoze matrisinde, orijinal matrisin satır ve sütunları yer değiştirir, böylece orijinal matristeki (i, j) konumundaki eleman, transpoze matrisin (j, i) konumuna taşınır.\n\n  Örnek:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) döndürür vec![vec![1, 3], vec![2, 4]]",
      "vi": "Tính chuyển vị của một ma trận vuông cho trước.\n\n  Đối số:\n  - matrix: Một ma trận vuông được biểu diễn dưới dạng một vector của các vector của i32.\n\n  Trả về:\n  - Một ma trận mới là chuyển vị của ma trận đầu vào. Trong ma trận chuyển vị, các hàng và cột của ma trận gốc được hoán đổi, do đó phần tử tại vị trí (i, j) trong ma trận gốc sẽ chuyển đến vị trí (j, i) trong ma trận chuyển vị.\n\n  Ví dụ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) trả về vec![vec![1, 3], vec![2, 4]]"
    },
    "docstring_bertscore": {
      "es": "0.9852882421982699",
      "arb": "0.9854107971433685",
      "sw": "0.9837915622771721",
      "tr": "0.9799985165209298",
      "vi": "0.977659047893101"
    }
  },
  {
    "task_id": "Rust/25",
    "prompt": {
      "en": "/*\n    Transforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "es": "/*\n    Transforma una contraseña dada según un algoritmo específico.\n\n    El algoritmo funciona de la siguiente manera:\n    - Las letras minúsculas se transforman en números según el mapeo del teclado telefónico (por ejemplo, abc -> 2, def -> 3, ...).\n    - Las letras mayúsculas se convierten primero a minúsculas y luego se desplazan a la siguiente letra en el alfabeto (por ejemplo, A -> b, Z -> a).\n    - Los números y otros símbolos permanecen sin cambios.\n\n    Argumentos:\n    - input: Una cadena que representa la contraseña a transformar. La longitud de la contraseña no excede los 100 caracteres.\n\n    Devuelve:\n    - Una nueva cadena que representa la contraseña transformada.\n\n    Ejemplos:\n    - transform_password(\"YUANzi1987\") devuelve \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "arb": "/*\n    تحويل كلمة مرور معينة وفقًا لخوارزمية محددة.\n\n    تعمل الخوارزمية كما يلي:\n    - يتم تحويل الأحرف الصغيرة إلى أرقام بناءً على خريطة لوحة مفاتيح الهاتف (مثلًا، abc -> 2، def -> 3، ...).\n    - يتم تحويل الأحرف الكبيرة أولًا إلى أحرف صغيرة ثم يتم تحويلها إلى الحرف التالي في الأبجدية (مثلًا، A -> b، Z -> a).\n    - تبقى الأرقام والرموز الأخرى دون تغيير.\n\n    المعطيات:\n    - input: سلسلة تمثل كلمة المرور التي سيتم تحويلها. لا يتجاوز طول كلمة المرور 100 حرف.\n\n    يعيد:\n    - سلسلة جديدة تمثل كلمة المرور المحولة.\n\n    أمثلة:\n    - transform_password(\"YUANzi1987\") يعيد \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "sw": "/*\n    Hubadilisha nenosiri lililopewa kulingana na algoriti maalum.\n\n    Algoriti inafanya kazi kama ifuatavyo:\n    - Herufi ndogo hubadilishwa kuwa nambari kulingana na ramani ya kibodi ya simu (mfano, abc -> 2, def -> 3, ...).\n    - Herufi kubwa hubadilishwa kwanza kuwa herufi ndogo kisha kuhamishwa kwa herufi inayofuata katika alfabeti (mfano, A -> b, Z -> a).\n    - Nambari na alama zingine hubaki bila kubadilika.\n\n    Hoja:\n    - input: Kamba inayowakilisha nenosiri litakalobadilishwa. Urefu wa nenosiri hauzidi herufi 100.\n\n    Inarudisha:\n    - Kamba mpya inayowakilisha nenosiri lililobadilishwa.\n\n    Mifano:\n    - transform_password(\"YUANzi1987\") inarudisha \"zvbo941987\"\n*/",
      "tr": "/*\n    Belirli bir algoritmaya göre verilen bir şifreyi dönüştürür. \n\n    Algoritma şu şekilde çalışır:\n    - Küçük harfler, telefon tuş takımı eşlemine göre sayılara dönüştürülür (örneğin, abc -> 2, def -> 3, ...).\n    - Büyük harfler önce küçük harfe dönüştürülür ve ardından alfabede bir sonraki harfe kaydırılır (örneğin, A -> b, Z -> a).\n    - Sayılar ve diğer semboller değişmeden kalır.\n\n    Argümanlar:\n    - input: Dönüştürülecek şifreyi temsil eden bir dize. Şifre uzunluğu 100 karakteri geçmez.\n\n    Döndürür:\n    - Dönüştürülmüş şifreyi temsil eden yeni bir dize.\n\n    Örnekler:\n    - transform_password(\"YUANzi1987\") \"zvbo941987\" döndürür\n*/\n\nfn transform_password(input: &str) -> String ",
      "vi": "/*\n    Chuyển đổi một mật khẩu đã cho theo một thuật toán cụ thể.\n\n    Thuật toán hoạt động như sau:\n    - Các chữ cái viết thường được chuyển đổi thành số dựa trên ánh xạ bàn phím điện thoại (ví dụ: abc -> 2, def -> 3, ...).\n    - Các chữ cái viết hoa trước tiên được chuyển thành chữ thường và sau đó chuyển sang chữ cái tiếp theo trong bảng chữ cái (ví dụ: A -> b, Z -> a).\n    - Các số và ký hiệu khác không thay đổi.\n\n    Tham số:\n    - input: Một chuỗi đại diện cho mật khẩu cần được chuyển đổi. Độ dài mật khẩu không vượt quá 100 ký tự.\n\n    Trả về:\n    - Một chuỗi mới đại diện cho mật khẩu đã được chuyển đổi.\n\n    Ví dụ:\n    - transform_password(\"YUANzi1987\") trả về \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String "
    },
    "prompt_bertscore": {
      "es": "0.984832981364938",
      "arb": "0.9780666374349846",
      "sw": "0.9605007596881642",
      "tr": "0.9892745553152591",
      "vi": "0.9774419448866298"
    },
    "canonical_solution": "{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}",
    "instruction": {
      "en": "Write a Rust function `fn transform_password(input: &str) -> String` to solve the following problem:\nTransforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"",
      "es": "Escribe una función de Rust `fn transform_password(input: &str) -> String` para resolver el siguiente problema:\nTransforma una contraseña dada según un algoritmo específico.\n\n    El algoritmo funciona de la siguiente manera:\n    - Las letras minúsculas se transforman en números basados en el mapeo del teclado telefónico (por ejemplo, abc -> 2, def -> 3, ...).\n    - Las letras mayúsculas se convierten primero en minúsculas y luego se desplazan a la siguiente letra en el alfabeto (por ejemplo, A -> b, Z -> a).\n    - Los números y otros símbolos permanecen sin cambios.\n\n    Argumentos:\n    - input: Una cadena que representa la contraseña a transformar. La longitud de la contraseña no excede los 100 caracteres.\n\n    Devuelve:\n    - Una nueva cadena que representa la contraseña transformada.\n\n    Ejemplos:\n    - transform_password(\"YUANzi1987\") devuelve \"zvbo941987\"",
      "arb": "اكتب دالة Rust `fn transform_password(input: &str) -> String` لحل المشكلة التالية:\nتحول كلمة مرور معينة وفقًا لخوارزمية محددة.\n\n    تعمل الخوارزمية كما يلي:\n    - يتم تحويل الأحرف الصغيرة إلى أرقام بناءً على خريطة لوحة مفاتيح الهاتف (مثلًا، abc -> 2، def -> 3، ...).\n    - يتم تحويل الأحرف الكبيرة أولاً إلى أحرف صغيرة ثم يتم تحريكها إلى الحرف التالي في الأبجدية (مثلًا، A -> b، Z -> a).\n    - تبقى الأرقام والرموز الأخرى دون تغيير.\n\n    الوسائط:\n    - input: سلسلة تمثل كلمة المرور المراد تحويلها. لا يتجاوز طول كلمة المرور 100 حرف.\n\n    يعيد:\n    - سلسلة جديدة تمثل كلمة المرور المحولة.\n\n    أمثلة:\n    - transform_password(\"YUANzi1987\") تعيد \"zvbo941987\"",
      "sw": "Andika kazi ya Rust `fn transform_password(input: &str) -> String` kutatua tatizo lifuatalo:\nHubadilisha nenosiri lililopewa kulingana na algoriti maalum.\n\n   Algoriti inafanya kazi kama ifuatavyo:\n   - Herufi ndogo hubadilishwa kuwa namba kulingana na ramani ya kibodi ya simu (mfano, abc -> 2, def -> 3, ...).\n   - Herufi kubwa hubadilishwa kwanza kuwa ndogo na kisha kuhamishwa kwa herufi inayofuata katika alfabeti (mfano, A -> b, Z -> a).\n   - Namba na alama nyingine hubaki bila kubadilishwa.\n\n   Hoja:\n   - input: Mlolongo wa herufi unaowakilisha nenosiri litakalobadilishwa. Urefu wa nenosiri hauzidi herufi 100.\n\n   Inarudisha:\n   - Mlolongo mpya wa herufi unaowakilisha nenosiri lililobadilishwa.\n\n   Mifano:\n   - transform_password(\"YUANzi1987\") inarudisha \"zvbo941987\"",
      "tr": "Bir Rust fonksiyonu `fn transform_password(input: &str) -> String` yazın:\nBelirli bir algoritmaya göre verilen bir şifreyi dönüştürür.\n\n    Algoritma şu şekilde çalışır:\n    - Küçük harfler, telefon tuş takımı eşlemesine göre sayılara dönüştürülür (örneğin, abc -> 2, def -> 3, ...).\n    - Büyük harfler önce küçük harfe dönüştürülür ve ardından alfabede bir sonraki harfe kaydırılır (örneğin, A -> b, Z -> a).\n    - Sayılar ve diğer semboller değişmeden kalır.\n\n    Argümanlar:\n    - input: Dönüştürülecek şifreyi temsil eden bir dize. Şifre uzunluğu 100 karakteri geçmez.\n\n    Döndürür:\n    - Dönüştürülmüş şifreyi temsil eden yeni bir dize.\n\n    Örnekler:\n    - transform_password(\"YUANzi1987\") döndürür \"zvbo941987\"",
      "vi": "Viết một hàm Rust `fn transform_password(input: &str) -> String` để giải quyết vấn đề sau:\nChuyển đổi một mật khẩu đã cho theo một thuật toán cụ thể.\n\n    Thuật toán hoạt động như sau:\n    - Các chữ cái thường được chuyển đổi thành số dựa trên ánh xạ bàn phím điện thoại (ví dụ: abc -> 2, def -> 3, ...).\n    - Các chữ cái hoa trước tiên được chuyển thành chữ thường và sau đó chuyển sang chữ cái tiếp theo trong bảng chữ cái (ví dụ: A -> b, Z -> a).\n    - Các số và ký tự khác không thay đổi.\n\n    Tham số:\n    - input: Một chuỗi đại diện cho mật khẩu cần chuyển đổi. Độ dài mật khẩu không vượt quá 100 ký tự.\n\n    Trả về:\n    - Một chuỗi mới đại diện cho mật khẩu đã được chuyển đổi.\n\n    Ví dụ:\n    - transform_password(\"YUANzi1987\") trả về \"zvbo941987\""
    },
    "instruction_bertscore": {
      "es": "0.9825685950211402",
      "arb": "0.9871076964885496",
      "sw": "0.9888014177476341",
      "tr": "0.976486532753852",
      "vi": "0.9847183716350809"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(transform_password(\"YUANzi1987\"), \"zvbo941987\");\n        assert_eq!(transform_password(\"ABcdE\"), \"bc23f\");\n        assert_eq!(transform_password(\"Zebra123!\"), \"a3272123!\");\n    }\n    \n\n}",
    "entry_point": "transform_password",
    "signature": "fn transform_password(input: &str) -> String",
    "docstring": {
      "en": "Transforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"",
      "es": "Transforma una contraseña dada según un algoritmo específico.\n\n    El algoritmo funciona de la siguiente manera:\n    - Las letras minúsculas se transforman en números basados en el mapeo del teclado telefónico (por ejemplo, abc -> 2, def -> 3, ...).\n    - Las letras mayúsculas se convierten primero en minúsculas y luego se desplazan a la siguiente letra en el alfabeto (por ejemplo, A -> b, Z -> a).\n    - Los números y otros símbolos permanecen sin cambios.\n\n    Argumentos:\n    - input: Una cadena que representa la contraseña a transformar. La longitud de la contraseña no excede los 100 caracteres.\n\n    Retorna:\n    - Una nueva cadena que representa la contraseña transformada.\n\n    Ejemplos:\n    - transform_password(\"YUANzi1987\") devuelve \"zvbo941987\"",
      "arb": "تحول كلمة المرور المعطاة وفقًا لخوارزمية محددة.\n\n    تعمل الخوارزمية على النحو التالي:\n    - يتم تحويل الأحرف الصغيرة إلى أرقام بناءً على خريطة لوحة مفاتيح الهاتف (مثلًا، abc -> 2، def -> 3، ...).\n    - يتم تحويل الأحرف الكبيرة أولاً إلى أحرف صغيرة ثم يتم تحويلها إلى الحرف التالي في الأبجدية (مثلًا، A -> b، Z -> a).\n    - تبقى الأرقام والرموز الأخرى دون تغيير.\n\n    Args:\n    - input: سلسلة تمثل كلمة المرور المراد تحويلها. لا يتجاوز طول كلمة المرور 100 حرف.\n\n    يعيد:\n    - سلسلة جديدة تمثل كلمة المرور المحولة.\n\n    امثله:\n    - transform_password(\"YUANzi1987\") يعيد \"zvbo941987\"",
      "sw": "Hubadilisha nenosiri lililotolewa kulingana na algorithimu maalum.\n\n    Algorithimu inafanya kazi kama ifuatavyo:\n    - Herufi ndogo hubadilishwa kuwa namba kulingana na ramani ya keypad ya simu (mfano, abc -> 2, def -> 3, ...).\n    - Herufi kubwa hubadilishwa kwanza kuwa herufi ndogo kisha kuhamishwa kwa herufi inayofuata katika alfabeti (mfano, A -> b, Z -> a).\n    - Namba na alama nyingine hubaki bila kubadilika.\n\n    Hoja:\n    - input: Mfuatano wa herufi unaowakilisha nenosiri litakalobadilishwa. Urefu wa nenosiri hauzidi herufi 100.\n\n    Inarejesha:\n    - Mfuatano mpya wa herufi unaowakilisha nenosiri lililobadilishwa.\n\n    Mifano:\n    - transform_password(\"YUANzi1987\") inarejesha \"zvbo941987\"",
      "tr": "Belirli bir algoritmaya göre verilen bir şifreyi dönüştürür.\n\n    Algoritma şu şekilde çalışır:\n    - Küçük harfler, telefon tuş takımı eşlemesine göre sayılara dönüştürülür (örneğin, abc -> 2, def -> 3, ...).\n    - Büyük harfler önce küçük harfe dönüştürülür ve ardından alfabede bir sonraki harfe kaydırılır (örneğin, A -> b, Z -> a).\n    - Sayılar ve diğer semboller değişmeden kalır.\n\n    Argümanlar:\n    - input: Dönüştürülecek şifreyi temsil eden bir string. Şifre uzunluğu 100 karakteri geçmez.\n\n    Döndürür:\n    - Dönüştürülmüş şifreyi temsil eden yeni bir string.\n\n    Örnekler:\n    - transform_password(\"YUANzi1987\") \"zvbo941987\" döndürür.",
      "vi": "Chuyển đổi một mật khẩu đã cho theo một thuật toán cụ thể.\n\n    Thuật toán hoạt động như sau:\n    - Các chữ cái thường được chuyển đổi thành số dựa trên ánh xạ bàn phím điện thoại (ví dụ: abc -> 2, def -> 3, ...).\n    - Các chữ cái hoa trước tiên được chuyển thành chữ thường và sau đó chuyển sang chữ cái tiếp theo trong bảng chữ cái (ví dụ: A -> b, Z -> a).\n    - Các số và ký hiệu khác không thay đổi.\n\n    Đối số:\n    - input: Một chuỗi đại diện cho mật khẩu cần được chuyển đổi. Độ dài mật khẩu không vượt quá 100 ký tự.\n\n    Trả về:\n    - Một chuỗi mới đại diện cho mật khẩu đã được chuyển đổi.\n\n    Ví dụ:\n    - transform_password(\"YUANzi1987\") trả về \"zvbo941987\""
    },
    "docstring_bertscore": {
      "es": "0.9760702034752029",
      "arb": "0.9850846460577092",
      "sw": "0.9653735601957121",
      "tr": "0.9902516181595697",
      "vi": "0.9823560605134329"
    }
  },
  {
    "task_id": "Rust/26",
    "prompt": {
      "en": "\n/*\n  Determines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "es": "/*\n  Determina si la secuencia de números dada forma una secuencia aritmética.\n\n  Una secuencia aritmética es una secuencia de números tal que la diferencia entre números consecutivos es constante.\n\n  Argumentos:\n  - sequence: Una porción de matriz de enteros que representa la secuencia a verificar.\n\n  Devuelve:\n  - Un valor booleano que indica si la secuencia forma una secuencia aritmética (`true`) o no (`false`).\n\n  Ejemplos:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) devuelve true (ya que la diferencia es 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) devuelve false (ya que la diferencia no es constante)\n  - is_arithmetic_sequence(&[10, 10, 10]) devuelve true (ya que la diferencia es 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "arb": "/*\n  يحدد ما إذا كانت سلسلة الأرقام المعطاة تشكل متتالية حسابية.\n\n  المتتالية الحسابية هي سلسلة من الأرقام بحيث يكون الفرق بين الأرقام المتتالية ثابتًا.\n\n  الوسائط:\n  - sequence: مقطع من مصفوفة الأعداد الصحيحة يمثل السلسلة المراد التحقق منها.\n\n  يعيد:\n  - قيمة منطقية تشير إلى ما إذا كانت السلسلة تشكل متتالية حسابية (`true`) أم لا (`false`).\n\n  أمثلة:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) يعيد true (حيث أن الفرق هو 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) يعيد false (حيث أن الفرق ليس ثابتًا)\n  - is_arithmetic_sequence(&[10, 10, 10]) يعيد true (حيث أن الفرق هو 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "sw": "/*\n  Huamua kama mlolongo uliotolewa wa nambari unaunda mlolongo wa hesabu.\n\n  Mlolongo wa hesabu ni mlolongo wa nambari ambapo tofauti kati ya nambari mfululizo ni ya kudumu.\n\n  Hoja:\n  - sequence: Kipande cha safu ya nambari nzima kinachowakilisha mlolongo wa kukaguliwa.\n\n  Inarejesha:\n  - Thamani ya boolean inayoonyesha kama mlolongo unaunda mlolongo wa hesabu (`true`) au la (`false`).\n\n  Mifano:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) inarejesha true (kwa kuwa tofauti ni 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) inarejesha false (kwa kuwa tofauti si ya kudumu)\n  - is_arithmetic_sequence(&[10, 10, 10]) inarejesha true (kwa kuwa tofauti ni 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "tr": "/*\n  Verilen sayı dizisinin aritmetik bir dizi oluşturup oluşturmadığını belirler.\n\n  Aritmetik bir dizi, ardışık sayılar arasındaki farkın sabit olduğu bir sayı dizisidir.\n\n  Argümanlar:\n  - sequence: Kontrol edilecek diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizinin aritmetik bir dizi oluşturup oluşturmadığını belirten bir boolean değer (`true` veya `false`).\n\n  Örnekler:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true döndürür (çünkü fark 2'dir)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false döndürür (çünkü fark sabit değildir)\n  - is_arithmetic_sequence(&[10, 10, 10]) true döndürür (çünkü fark 0'dır)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "vi": "/*\n  Xác định xem dãy số đã cho có phải là một dãy số cấp số cộng hay không.\n\n  Một dãy số cấp số cộng là một dãy số mà hiệu giữa các số liên tiếp là không đổi.\n\n  Tham số:\n  - sequence: Một mảng con của các số nguyên đại diện cho dãy số cần kiểm tra.\n\n  Trả về:\n  - Một giá trị boolean cho biết dãy số có phải là dãy số cấp số cộng (`true`) hay không (`false`).\n\n  Ví dụ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) trả về true (vì hiệu là 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) trả về false (vì hiệu không không đổi)\n  - is_arithmetic_sequence(&[10, 10, 10]) trả về true (vì hiệu là 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool "
    },
    "prompt_bertscore": {
      "es": "0.9839268295666569",
      "arb": "0.9803095716976304",
      "sw": "0.9883201363343865",
      "tr": "0.9655622590576952",
      "vi": "0.9607315681909268"
    },
    "canonical_solution": "{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}",
    "instruction": {
      "en": "Write a Rust function `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` to solve the following problem:\nDetermines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)",
      "es": "Escribe una función en Rust `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` para resolver el siguiente problema:\nDetermina si la secuencia de números dada forma una secuencia aritmética.\n\n  Una secuencia aritmética es una secuencia de números tal que la diferencia entre números consecutivos es constante.\n\n  Argumentos:\n  - sequence: Un segmento de matriz de enteros que representa la secuencia a verificar.\n\n  Devuelve:\n  - Un valor booleano que indica si la secuencia forma una secuencia aritmética (`true`) o no (`false`).\n\n  Ejemplos:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) devuelve true (ya que la diferencia es 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) devuelve false (ya que la diferencia no es constante)\n  - is_arithmetic_sequence(&[10, 10, 10]) devuelve true (ya que la diferencia es 0)",
      "arb": "اكتب دالة بلغة Rust `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` لحل المشكلة التالية:\nتحديد ما إذا كانت سلسلة الأرقام المعطاة تشكل تسلسلاً حسابيًا.\n\n  التسلسل الحسابي هو تسلسل من الأرقام بحيث يكون الفرق بين الأرقام المتتالية ثابتًا.\n\n  الوسائط:\n  - sequence: شريحة مصفوفة من الأعداد الصحيحة تمثل التسلسل الذي سيتم التحقق منه.\n\n  يعيد:\n  - قيمة منطقية تشير إلى ما إذا كان التسلسل يشكل تسلسلاً حسابيًا (`true`) أم لا (`false`).\n\n  أمثلة:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) يعيد true (حيث أن الفرق هو 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) يعيد false (حيث أن الفرق ليس ثابتًا)\n  - is_arithmetic_sequence(&[10, 10, 10]) يعيد true (حيث أن الفرق هو 0)",
      "sw": "Andika kazi ya Rust `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` kutatua tatizo lifuatalo:\nInabainisha kama mlolongo uliotolewa wa nambari unaunda mlolongo wa hesabu.\n\n  Mlolongo wa hesabu ni mlolongo wa nambari ambapo tofauti kati ya nambari mfululizo ni thabiti.\n\n  Hoja:\n  - sequence: Kipande cha safu ya nambari nzima kinachowakilisha mlolongo unaopaswa kukaguliwa.\n\n  Inarudisha:\n  - Thamani ya boolean inayoonyesha kama mlolongo unaunda mlolongo wa hesabu (`true`) au la (`false`).\n\n  Mifano:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) inarudisha true (kwa kuwa tofauti ni 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) inarudisha false (kwa kuwa tofauti si thabiti)\n  - is_arithmetic_sequence(&[10, 10, 10]) inarudisha true (kwa kuwa tofauti ni 0)",
      "tr": "Bir Rust fonksiyonu `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` yazın ve aşağıdaki problemi çözün:\nVerilen sayı dizisinin bir aritmetik dizi oluşturup oluşturmadığını belirler.\n\n  Bir aritmetik dizi, ardışık sayılar arasındaki farkın sabit olduğu bir sayı dizisidir.\n\n  Argümanlar:\n  - sequence: Kontrol edilecek diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizinin bir aritmetik dizi oluşturup oluşturmadığını belirten bir boolean değeri (`true` veya `false`).\n\n  Örnekler:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true döndürür (çünkü fark 2'dir)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false döndürür (çünkü fark sabit değildir)\n  - is_arithmetic_sequence(&[10, 10, 10]) true döndürür (çünkü fark 0'dır)",
      "vi": "Viết một hàm Rust `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` để giải quyết vấn đề sau:\nXác định xem dãy số đã cho có tạo thành một dãy số cấp số cộng hay không.\n\n  Một dãy số cấp số cộng là một dãy số mà sự khác biệt giữa các số liên tiếp là không đổi.\n\n  Tham số:\n  - sequence: Một lát cắt mảng của các số nguyên đại diện cho dãy số cần kiểm tra.\n\n  Trả về:\n  - Một giá trị boolean cho biết liệu dãy số có tạo thành một dãy số cấp số cộng (`true`) hay không (`false`).\n\n  Ví dụ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) trả về true (vì sự khác biệt là 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) trả về false (vì sự khác biệt không cố định)\n  - is_arithmetic_sequence(&[10, 10, 10]) trả về true (vì sự khác biệt là 0)"
    },
    "instruction_bertscore": {
      "es": "0.9848429128839897",
      "arb": "0.9798086258766605",
      "sw": "0.9898205902327241",
      "tr": "0.9697491888595297",
      "vi": "0.9710959028429462"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(is_arithmetic_sequence(&[5, 7, 9, 11]), true);  // True, as 2 is the constant difference\n        assert_eq!(is_arithmetic_sequence(&[1, 2, 4, 8]), false);  // False, as difference changes\n        assert_eq!(is_arithmetic_sequence(&[10, 10, 10]), true);   // True, as 0 is the constant difference\n        assert_eq!(is_arithmetic_sequence(&[3, 6, 9, 12, 16]), false); // False, last difference is not 3\n    }\n}",
    "entry_point": "is_arithmetic_sequence",
    "signature": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool",
    "docstring": {
      "en": "Determines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)",
      "es": "Determina si la secuencia de números dada forma una secuencia aritmética.\n\n  Una secuencia aritmética es una secuencia de números tal que la diferencia entre números consecutivos es constante.\n\n  Argumentos:\n  - sequence: Un segmento de matriz de enteros que representa la secuencia a verificar.\n\n  Retorna:\n  - Un valor booleano que indica si la secuencia forma una secuencia aritmética (`true`) o no (`false`).\n\n  Ejemplos:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) retorna true (ya que la diferencia es 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) retorna false (ya que la diferencia no es constante)\n  - is_arithmetic_sequence(&[10, 10, 10]) retorna true (ya que la diferencia es 0)",
      "arb": "يحدد ما إذا كانت سلسلة الأرقام المعطاة تشكل متتالية حسابية.\n\n  المتتالية الحسابية هي سلسلة من الأرقام بحيث يكون الفرق بين الأرقام المتتالية ثابتًا.\n\n  الحجج:\n  - sequence: جزء من مصفوفة من الأعداد الصحيحة تمثل السلسلة التي سيتم التحقق منها.\n\n  يعيد:\n  - قيمة منطقية تشير إلى ما إذا كانت السلسلة تشكل متتالية حسابية (`true`) أو لا (`false`).\n\n  أمثلة:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) يعيد true (حيث أن الفرق هو 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) يعيد false (حيث أن الفرق ليس ثابتًا)\n  - is_arithmetic_sequence(&[10, 10, 10]) يعيد true (حيث أن الفرق هو 0)",
      "sw": "Huamua kama mlolongo uliotolewa wa nambari unaunda mlolongo wa hesabu.\n\n  Mlolongo wa hesabu ni mlolongo wa nambari ambapo tofauti kati ya nambari mfululizo ni thabiti.\n\n  Hoja:\n  - sequence: Kipande cha safu ya nambari nzima kinachowakilisha mlolongo unaopaswa kukaguliwa.\n\n  Inarudisha:\n  - Thamani ya boolean inayoonyesha ikiwa mlolongo unaunda mlolongo wa hesabu (`true`) au la (`false`).\n\n  Mifano:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) inarudisha true (kwa kuwa tofauti ni 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) inarudisha false (kwa kuwa tofauti si thabiti)\n  - is_arithmetic_sequence(&[10, 10, 10]) inarudisha true (kwa kuwa tofauti ni 0)",
      "tr": "Verilen sayı dizisinin bir aritmetik dizi oluşturup oluşturmadığını belirler.\n\n  Bir aritmetik dizi, ardışık sayılar arasındaki farkın sabit olduğu bir sayı dizisidir.\n\n  Argümanlar:\n  - sequence: Kontrol edilecek diziyi temsil eden tamsayıların bir dizi dilimi.\n\n  Döndürür:\n  - Dizinin bir aritmetik dizi oluşturup oluşturmadığını belirten bir boolean değeri (`true`) veya değilse (`false`).\n\n  Örnekler:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true döndürür (fark 2 olduğu için)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false döndürür (fark sabit olmadığı için)\n  - is_arithmetic_sequence(&[10, 10, 10]) true döndürür (fark 0 olduğu için)",
      "vi": "Xác định xem dãy số đã cho có phải là một dãy số cấp số cộng hay không.\n\n  Một dãy số cấp số cộng là một dãy số mà hiệu giữa các số liên tiếp là không đổi.\n\n  Tham số:\n  - sequence: Một mảng con của các số nguyên đại diện cho dãy số cần kiểm tra.\n\n  Trả về:\n  - Một giá trị boolean cho biết liệu dãy số có phải là một dãy số cấp số cộng (`true`) hay không (`false`).\n\n  Ví dụ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) trả về true (vì hiệu là 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) trả về false (vì hiệu không không đổi)\n  - is_arithmetic_sequence(&[10, 10, 10]) trả về true (vì hiệu là 0)"
    },
    "docstring_bertscore": {
      "es": "0.9843366040427318",
      "arb": "0.9778274864562185",
      "sw": "0.9877832384144491",
      "tr": "0.9787681999407998",
      "vi": "0.9523334756807716"
    }
  },
  {
    "task_id": "Rust/27",
    "prompt": {
      "en": "\n/*\n  Calculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "es": "/*\n  Calcula el día del año para una fecha dada en el formato YYYY/MM/DD.\n\n  Argumentos:\n  - date: Una cadena que representa una fecha en el formato YYYY/MM/DD.\n\n  Devuelve:\n  - Ok(usize): El día del año como un número si la fecha es válida.\n  - Err(String): Un mensaje de error si la fecha es inválida.\n\n  Ejemplo:\n  - day_of_year(\"1985/1/20\") devuelve Ok(20)\n  - day_of_year(\"2006/3/12\") devuelve Ok(71)\n  - day_of_year(\"2024/2/30\") devuelve Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "arb": "/*\n  يحسب اليوم من السنة لتاريخ معين بصيغة YYYY/MM/DD.\n\n  المعطيات:\n  - date: سلسلة تمثل تاريخًا بصيغة YYYY/MM/DD.\n\n  يعيد:\n  - Ok(usize): اليوم من السنة كرقم إذا كان التاريخ صالحًا.\n  - Err(String): رسالة خطأ إذا كان التاريخ غير صالح.\n\n  مثال:\n  - day_of_year(\"1985/1/20\") يعيد Ok(20)\n  - day_of_year(\"2006/3/12\") يعيد Ok(71)\n  - day_of_year(\"2024/2/30\") يعيد Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "sw": "/*\n  Inahesabu siku ya mwaka kwa tarehe iliyotolewa katika muundo wa YYYY/MM/DD.\n\n  Hoja:\n  - date: Kamba inayowakilisha tarehe katika muundo wa YYYY/MM/DD.\n\n  Inarejesha:\n  - Ok(usize): Siku ya mwaka kama nambari ikiwa tarehe ni sahihi.\n  - Err(String): Ujumbe wa kosa ikiwa tarehe si sahihi.\n\n  Mfano:\n  - day_of_year(\"1985/1/20\") inarejesha Ok(20)\n  - day_of_year(\"2006/3/12\") inarejesha Ok(71)\n  - day_of_year(\"2024/2/30\") inarejesha Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "tr": "/*\n  YYYY/MM/DD formatındaki bir tarih dizesi için yılın gününü hesaplar.\n\n  Argümanlar:\n  - date: YYYY/MM/DD formatında bir tarihi temsil eden bir dize.\n\n  Döndürür:\n  - Ok(usize): Tarih geçerliyse yılın günü olarak bir sayı.\n  - Err(String): Tarih geçersizse bir hata mesajı.\n\n  Örnek:\n  - day_of_year(\"1985/1/20\") döndürür Ok(20)\n  - day_of_year(\"2006/3/12\") döndürür Ok(71)\n  - day_of_year(\"2024/2/30\") döndürür Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "vi": "/*\n  Tính toán ngày trong năm cho một chuỗi ngày được cung cấp theo định dạng YYYY/MM/DD.\n\n  Tham số:\n  - date: Một chuỗi đại diện cho ngày theo định dạng YYYY/MM/DD.\n\n  Trả về:\n  - Ok(usize): Ngày trong năm dưới dạng số nếu ngày hợp lệ.\n  - Err(String): Một thông báo lỗi nếu ngày không hợp lệ.\n\n  Ví dụ:\n  - day_of_year(\"1985/1/20\") trả về Ok(20)\n  - day_of_year(\"2006/3/12\") trả về Ok(71)\n  - day_of_year(\"2024/2/30\") trả về Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> "
    },
    "prompt_bertscore": {
      "es": "0.9957890359220604",
      "arb": "0.9887553354992339",
      "sw": "0.9943614793735627",
      "tr": "0.9751706064794958",
      "vi": "0.9908252626999985"
    },
    "canonical_solution": "{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}",
    "instruction": {
      "en": "Write a Rust function `fn day_of_year(date: &str) -> Result<usize, String>` to solve the following problem:\nCalculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")",
      "es": "Escribe una función en Rust `fn day_of_year(date: &str) -> Result<usize, String>` para resolver el siguiente problema:\nCalcula el día del año para una cadena de fecha dada en el formato YYYY/MM/DD.\n\n  Argumentos:\n  - date: Una cadena que representa una fecha en el formato YYYY/MM/DD.\n\n  Retorna:\n  - Ok(usize): El día del año como un número si la fecha es válida.\n  - Err(String): Un mensaje de error si la fecha es inválida.\n\n  Ejemplo:\n  - day_of_year(\"1985/1/20\") devuelve Ok(20)\n  - day_of_year(\"2006/3/12\") devuelve Ok(71)\n  - day_of_year(\"2024/2/30\") devuelve Err(\"Invalid\")",
      "arb": "اكتب دالة Rust `fn day_of_year(date: &str) -> Result<usize, String>` لحل المشكلة التالية:\nتحسب اليوم من السنة لتاريخ معين على شكل سلسلة نصية بصيغة YYYY/MM/DD.\n\n  الوسائط:\n  - date: سلسلة نصية تمثل تاريخًا بصيغة YYYY/MM/DD.\n\n  تعيد:\n  - Ok(usize): اليوم من السنة كرقم إذا كان التاريخ صالحًا.\n  - Err(String): رسالة خطأ إذا كان التاريخ غير صالح.\n\n  مثال:\n  - day_of_year(\"1985/1/20\") تعيد Ok(20)\n  - day_of_year(\"2006/3/12\") تعيد Ok(71)\n  - day_of_year(\"2024/2/30\") تعيد Err(\"Invalid\")",
      "sw": "Andika kazi ya Rust `fn day_of_year(date: &str) -> Result<usize, String>` kutatua tatizo lifuatalo:\nHesabu siku ya mwaka kwa tarehe iliyotolewa katika umbizo la YYYY/MM/DD.\n\n  Hoja:\n  - date: Kamba inayowakilisha tarehe katika umbizo la YYYY/MM/DD.\n\n  Inarudi:\n  - Ok(usize): Siku ya mwaka kama nambari ikiwa tarehe ni sahihi.\n  - Err(String): Ujumbe wa kosa ikiwa tarehe si sahihi.\n\n  Mfano:\n  - day_of_year(\"1985/1/20\") inarudi Ok(20)\n  - day_of_year(\"2006/3/12\") inarudi Ok(71)\n  - day_of_year(\"2024/2/30\") inarudi Err(\"Invalid\")",
      "tr": "Bir Rust fonksiyonu `fn day_of_year(date: &str) -> Result<usize, String>` yazarak aşağıdaki problemi çözün:\nYYYY/MM/DD formatındaki bir tarih dizesi için yılın kaçıncı günü olduğunu hesaplar.\n\n  Argümanlar:\n  - date: YYYY/MM/DD formatında bir tarihi temsil eden bir dize.\n\n  Döndürür:\n  - Ok(usize): Tarih geçerliyse yılın günü olarak bir sayı.\n  - Err(String): Tarih geçersizse bir hata mesajı.\n\n  Örnek:\n  - day_of_year(\"1985/1/20\") Ok(20) döndürür\n  - day_of_year(\"2006/3/12\") Ok(71) döndürür\n  - day_of_year(\"2024/2/30\") Err(\"Invalid\") döndürür",
      "vi": "Viết một hàm Rust `fn day_of_year(date: &str) -> Result<usize, String>` để giải quyết vấn đề sau:\nTính toán ngày trong năm cho một chuỗi ngày đã cho theo định dạng YYYY/MM/DD.\n\n  Tham số:\n  - date: Một chuỗi đại diện cho một ngày theo định dạng YYYY/MM/DD.\n\n  Trả về:\n  - Ok(usize): Ngày trong năm dưới dạng một số nếu ngày hợp lệ.\n  - Err(String): Một thông báo lỗi nếu ngày không hợp lệ.\n\n  Ví dụ:\n  - day_of_year(\"1985/1/20\") trả về Ok(20)\n  - day_of_year(\"2006/3/12\") trả về Ok(71)\n  - day_of_year(\"2024/2/30\") trả về Err(\"Invalid\")"
    },
    "instruction_bertscore": {
      "es": "0.995707200205074",
      "arb": "0.9792151182981282",
      "sw": "0.9923167782311895",
      "tr": "0.9833649042187091",
      "vi": "0.9926236621698884"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(day_of_year(\"1985/1/20\"), Ok(20));\n        assert_eq!(day_of_year(\"2006/3/12\"), Ok(71));\n        assert_eq!(day_of_year(\"2024/2/30\"), Err(\"Invalid\".to_string()));\n        assert_eq!(day_of_year(\"2024/13/10\"), Err(\"Invalid\".to_string()));\n        assert_eq!(day_of_year(\"2024/2/29\"), Ok(60)); // Leap year case\n\n    }\n    \n\n}",
    "entry_point": "day_of_year",
    "signature": "fn day_of_year(date: &str) -> Result<usize, String>",
    "docstring": {
      "en": "Calculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")",
      "es": "Calcula el día del año para una cadena de fecha dada en el formato YYYY/MM/DD.\n\n  Argumentos:\n  - date: Una cadena que representa una fecha en el formato YYYY/MM/DD.\n\n  Retorna:\n  - Ok(usize): El día del año como un número si la fecha es válida.\n  - Err(String): Un mensaje de error si la fecha es inválida.\n\n  Ejemplo:\n  - day_of_year(\"1985/1/20\") devuelve Ok(20)\n  - day_of_year(\"2006/3/12\") devuelve Ok(71)\n  - day_of_year(\"2024/2/30\") devuelve Err(\"Invalid\")",
      "arb": "يحسب اليوم من السنة لتاريخ معين في صيغة YYYY/MM/DD.\n\n  الحجج:\n  - date: سلسلة تمثل تاريخًا في الصيغة YYYY/MM/DD.\n\n  يعيد:\n  - Ok(usize): اليوم من السنة كرقم إذا كان التاريخ صالحًا.\n  - Err(String): رسالة خطأ إذا كان التاريخ غير صالح.\n\n  مثال:\n  - day_of_year(\"1985/1/20\") يعيد Ok(20)\n  - day_of_year(\"2006/3/12\") يعيد Ok(71)\n  - day_of_year(\"2024/2/30\") يعيد Err(\"Invalid\")",
      "sw": "Hesabu siku ya mwaka kwa tarehe iliyotolewa katika umbizo la YYYY/MM/DD.\n\n  Hoja:\n  - date: Kamba inayowakilisha tarehe katika umbizo la YYYY/MM/DD.\n\n  Inarudisha:\n  - Ok(usize): Siku ya mwaka kama nambari ikiwa tarehe ni sahihi.\n  - Err(String): Ujumbe wa kosa ikiwa tarehe si sahihi.\n\n  Mfano:\n  - day_of_year(\"1985/1/20\") inarudisha Ok(20)\n  - day_of_year(\"2006/3/12\") inarudisha Ok(71)\n  - day_of_year(\"2024/2/30\") inarudisha Err(\"Invalid\")",
      "tr": "Yılın gününü, YYYY/MM/DD formatındaki bir tarih dizesi için hesaplar.\n\n  Argümanlar:\n  - date: YYYY/MM/DD formatında bir tarihi temsil eden bir dize.\n\n  Döndürür:\n  - Ok(usize): Tarih geçerliyse yılın günü olarak bir sayı.\n  - Err(String): Tarih geçersizse bir hata mesajı.\n\n  Örnek:\n  - day_of_year(\"1985/1/20\") Ok(20) döndürür\n  - day_of_year(\"2006/3/12\") Ok(71) döndürür\n  - day_of_year(\"2024/2/30\") Err(\"Invalid\") döndürür",
      "vi": "Tính toán ngày trong năm cho một chuỗi ngày cho trước theo định dạng YYYY/MM/DD.\n\n  Tham số:\n  - date: Một chuỗi đại diện cho một ngày theo định dạng YYYY/MM/DD.\n\n  Trả về:\n  - Ok(usize): Ngày trong năm dưới dạng số nếu ngày hợp lệ.\n  - Err(String): Một thông báo lỗi nếu ngày không hợp lệ.\n\n  Ví dụ:\n  - day_of_year(\"1985/1/20\") trả về Ok(20)\n  - day_of_year(\"2006/3/12\") trả về Ok(71)\n  - day_of_year(\"2024/2/30\") trả về Err(\"Invalid\")"
    },
    "docstring_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9908479065634365",
      "sw": "0.9906659611344085",
      "tr": "0.9863832914889153",
      "vi": "0.988567232528394"
    }
  },
  {
    "task_id": "Rust/28",
    "prompt": {
      "en": "/*\n  Removes duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "es": "/*\n  Elimina los números duplicados de un vector dado y luego ordena los números restantes en orden ascendente.\n\n  Argumentos:\n  - numbers: Un vector de enteros que varían de 1 a 1000, con una longitud que no excede 100.\n\n  Devuelve:\n  - Un vector que contiene los elementos únicos del vector original, ordenados en orden ascendente.\n\n  Ejemplos:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) devuelve vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) devuelve vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) devuelve vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "arb": "/*\n  يزيل الأرقام المكررة من متجه معين ثم يقوم بترتيب الأرقام المتبقية بترتيب تصاعدي.\n\n  الوسائط:\n  - numbers: متجه من الأعداد الصحيحة تتراوح بين 1 إلى 1000، بطول لا يتجاوز 100.\n\n  يعيد:\n  - متجه يحتوي على العناصر الفريدة من المتجه الأصلي، مرتبة بترتيب تصاعدي.\n\n  أمثلة:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) يعيد vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) يعيد vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) يعيد vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "sw": "/*\n  Huondoa namba zinazojirudia kutoka kwenye vector iliyotolewa na kisha kupanga namba zilizobaki kwa mpangilio wa kupanda.\n\n  Hoja:\n  - numbers: Vector ya namba za mzima kati ya 1 hadi 1000, yenye urefu usiozidi 100.\n\n  Inarudisha:\n  - Vector inayojumuisha vipengele vya kipekee vya vector ya awali, vilivyopangwa kwa mpangilio wa kupanda.\n\n  Mifano:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) inarudisha vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) inarudisha vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) inarudisha vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "tr": "/*\n  Verilen bir vektörden tekrar eden sayıları kaldırır ve ardından kalan sayıları artan sırayla sıralar.\n\n  Argümanlar:\n  - numbers: Uzunluğu 100'ü aşmayan, 1 ile 1000 arasında tamsayılar içeren bir vektör.\n\n  Döndürür:\n  - Orijinal vektörün benzersiz elemanlarını içeren ve artan sırayla sıralanmış bir vektör.\n\n  Örnekler:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) döndürür vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) döndürür vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) döndürür vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "vi": "/*\n  Loại bỏ các số trùng lặp từ một vector cho trước và sau đó sắp xếp các số còn lại theo thứ tự tăng dần.\n\n  Tham số:\n  - numbers: Một vector các số nguyên trong khoảng từ 1 đến 1000, với độ dài không vượt quá 100.\n\n  Trả về:\n  - Một vector chứa các phần tử duy nhất của vector gốc, được sắp xếp theo thứ tự tăng dần.\n\n  Ví dụ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) trả về vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) trả về vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) trả về vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> "
    },
    "prompt_bertscore": {
      "es": "0.9944895959693302",
      "arb": "0.9985090803599521",
      "sw": "0.9917538597313366",
      "tr": "0.9933937521571606",
      "vi": "0.9861099760846113"
    },
    "canonical_solution": "{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}",
    "instruction": {
      "en": "Write a Rust function `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` to solve the following problem:\nRemoves duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]",
      "es": "Escribe una función de Rust `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` para resolver el siguiente problema:\nElimina números duplicados de un vector dado y luego ordena los números restantes en orden ascendente.\n\n  Argumentos:\n  - numbers: Un vector de enteros que varían de 1 a 1000, con una longitud que no excede 100.\n\n  Retorna:\n  - Un vector que contiene los elementos únicos del vector original, ordenados en orden ascendente.\n\n  Ejemplos:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) retorna vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) retorna vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) retorna vec![1, 2, 3, 4, 5]",
      "arb": "اكتب دالة بلغة Rust `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` لحل المشكلة التالية:\nإزالة الأرقام المكررة من المتجه المعطى ثم ترتيب الأرقام المتبقية بترتيب تصاعدي.\n\n  الوسائط:\n  - numbers: متجه من الأعداد الصحيحة يتراوح من 1 إلى 1000، بطول لا يتجاوز 100.\n\n  يعيد:\n  - متجه يحتوي على العناصر الفريدة من المتجه الأصلي، مرتبة بترتيب تصاعدي.\n\n  أمثلة:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) يعيد vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) يعيد vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) يعيد vec![1, 2, 3, 4, 5]",
      "sw": "Andika kazi ya Rust `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` kutatua tatizo lifuatalo:\nHuondoa namba zinazojirudia kutoka kwenye vector iliyotolewa na kisha kupanga namba zilizobaki kwa mpangilio wa kupanda.\n\n  Hoja:\n  - numbers: Vector ya namba za mzima kati ya 1 hadi 1000, yenye urefu usiozidi 100.\n\n  Inarudisha:\n  - Vector inayojumuisha vipengele vya kipekee vya vector ya awali, vilivyopangwa kwa mpangilio wa kupanda.\n\n  Mifano:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) inarudisha vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) inarudisha vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) inarudisha vec![1, 2, 3, 4, 5]",
      "tr": "Bir Rust fonksiyonu `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` yazın ve aşağıdaki problemi çözün:\nVerilen bir vektörden tekrar eden sayıları kaldırır ve kalan sayıları artan sırayla sıralar.\n\n  Argümanlar:\n  - numbers: Uzunluğu 100'ü geçmeyen, 1 ile 1000 arasında tamsayılar içeren bir vektör.\n\n  Döndürür:\n  - Orijinal vektörün benzersiz elemanlarını içeren ve artan sırayla sıralanmış bir vektör.\n\n  Örnekler:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) döndürür vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) döndürür vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) döndürür vec![1, 2, 3, 4, 5]",
      "vi": "Viết một hàm Rust `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` để giải quyết vấn đề sau:\nLoại bỏ các số trùng lặp từ một vector cho trước và sau đó sắp xếp các số còn lại theo thứ tự tăng dần.\n\n  Tham số:\n  - numbers: Một vector các số nguyên trong khoảng từ 1 đến 1000, với độ dài không vượt quá 100.\n\n  Trả về:\n  - Một vector chứa các phần tử duy nhất của vector ban đầu, được sắp xếp theo thứ tự tăng dần.\n\n  Ví dụ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) trả về vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) trả về vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) trả về vec![1, 2, 3, 4, 5]"
    },
    "instruction_bertscore": {
      "es": "0.9955570356370116",
      "arb": "0.9870733334326305",
      "sw": "0.9944691370400836",
      "tr": "0.987582423099223",
      "vi": "0.9882243964907277"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(dedup_and_sort(vec![10, 20, 20, 10, 30]), vec![10, 20, 30]);\n        assert_eq!(dedup_and_sort(vec![5, 4, 3, 2, 1]), vec![1, 2, 3, 4, 5]);\n        assert_eq!(dedup_and_sort(vec![1, 1, 1, 1, 1]), vec![1]);\n        assert_eq!(dedup_and_sort(vec![50]), vec![50]);\n    }\n    \n\n}",
    "entry_point": "dedup_and_sort",
    "signature": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>",
    "docstring": {
      "en": "Removes duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]",
      "es": "Elimina los números duplicados de un vector dado y luego ordena los números restantes en orden ascendente.\n\n  Argumentos:\n  - numbers: Un vector de enteros que van de 1 a 1000, con una longitud que no excede 100.\n\n  Retorna:\n  - Un vector que contiene los elementos únicos del vector original, ordenados en orden ascendente.\n\n  Ejemplos:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) retorna vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) retorna vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) retorna vec![1, 2, 3, 4, 5]",
      "arb": "يزيل الأرقام المكررة من متجه معين ثم يرتب الأرقام المتبقية بترتيب تصاعدي.\n\n  الحجج:\n  - numbers: متجه من الأعداد الصحيحة يتراوح من 1 إلى 1000، بطول لا يتجاوز 100.\n\n  العوائد:\n  - متجه يحتوي على العناصر الفريدة من المتجه الأصلي، مرتبة بترتيب تصاعدي.\n\n  أمثلة:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) يعيد vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) يعيد vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) يعيد vec![1, 2, 3, 4, 5]",
      "sw": "Huondoa namba zinazojirudia kutoka kwenye vector iliyotolewa na kisha kupanga namba zilizobaki kwa mpangilio wa kupanda.\n\n  Hoja:\n  - numbers: Vector ya nambari za mzima kati ya 1 hadi 1000, na urefu usiozidi 100.\n\n  Inarejesha:\n  - Vector inayojumuisha vipengele vya kipekee vya vector ya awali, vilivyopangwa kwa mpangilio wa kupanda.\n\n  Mifano:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) inarejesha vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) inarejesha vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) inarejesha vec![1, 2, 3, 4, 5]",
      "tr": "Tekrarlayan sayıları verilen bir vektörden kaldırır ve ardından kalan sayıları artan sırayla sıralar.\n\n  Argümanlar:\n  - numbers: Uzunluğu 100'ü aşmayan, 1 ile 1000 arasında değişen tamsayıların bulunduğu bir vektör.\n\n  Döndürülen:\n  - Orijinal vektörün benzersiz elemanlarını içeren ve artan sırayla sıralanmış bir vektör.\n\n  Örnekler:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) döndürür vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) döndürür vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) döndürür vec![1, 2, 3, 4, 5]",
      "vi": "Loại bỏ các số trùng lặp khỏi một vector cho trước và sau đó sắp xếp các số còn lại theo thứ tự tăng dần.\n\n  Tham số:\n  - numbers: Một vector các số nguyên trong khoảng từ 1 đến 1000, với độ dài không vượt quá 100.\n\n  Trả về:\n  - Một vector chứa các phần tử duy nhất của vector ban đầu, được sắp xếp theo thứ tự tăng dần.\n\n  Ví dụ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) trả về vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) trả về vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) trả về vec![1, 2, 3, 4, 5]"
    },
    "docstring_bertscore": {
      "es": "0.9899487068284916",
      "arb": "0.9963972421487892",
      "sw": "0.9945817604661303",
      "tr": "0.9954450081021079",
      "vi": "0.981621326733985"
    }
  },
  {
    "task_id": "Rust/29",
    "prompt": {
      "en": "/*\n  Computes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n ≤ 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m ≤ n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "es": "/*\n  Calcula el número de combinaciones C(n, m), que representa el número de formas de elegir m elementos de un conjunto de n elementos distintos.\n\n  Argumentos:\n  - n: Un entero sin signo de 32 bits que representa el número total de elementos (n ≤ 20).\n  - m: Un entero sin signo de 32 bits que representa el número de elementos a elegir (m ≤ n).\n\n  Devuelve:\n  - El número de combinaciones C(n, m).\n\n  Ejemplo:\n  - calculate_combinations(5, 2) devuelve 10\n  - calculate_combinations(18, 13) devuelve 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "arb": "/*\n  يحسب عدد التوافيق C(n, m)، الذي يمثل عدد الطرق لاختيار m عنصرًا من مجموعة مكونة من n عنصرًا مميزًا.\n\n  المعطيات:\n  - n: عدد صحيح غير موقع 32 بت يمثل العدد الإجمالي للعناصر (n ≤ 20).\n  - m: عدد صحيح غير موقع 32 بت يمثل عدد العناصر المراد اختيارها (m ≤ n).\n\n  يعيد:\n  - عدد التوافيق C(n, m).\n\n  مثال:\n  - calculate_combinations(5, 2) يعيد 10\n  - calculate_combinations(18, 13) يعيد 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "sw": "/*\n  Inahesabu nambari ya mchanganyiko C(n, m), ambayo inaonyesha idadi ya njia za kuchagua vipengele m kutoka kwenye seti ya vipengele n tofauti.\n\n  Hoja:\n  - n: Nambari isiyo na ishara ya biti 32 inayowakilisha jumla ya vipengele (n ≤ 20).\n  - m: Nambari isiyo na ishara ya biti 32 inayowakilisha idadi ya vipengele vya kuchagua (m ≤ n).\n\n  Inarudisha:\n  - Nambari ya mchanganyiko C(n, m).\n\n  Mfano:\n  - calculate_combinations(5, 2) inarudisha 10\n  - calculate_combinations(18, 13) inarudisha 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "tr": "/*\n  C(n, m) kombinasyon sayısını hesaplar, bu da n farklı elemandan m eleman seçmenin yollarının sayısını temsil eder.\n\n  Argümanlar:\n  - n: Toplam eleman sayısını temsil eden 32-bit işaretsiz bir tamsayı (n ≤ 20).\n  - m: Seçilecek eleman sayısını temsil eden 32-bit işaretsiz bir tamsayı (m ≤ n).\n\n  Döndürür:\n  - C(n, m) kombinasyon sayısı.\n\n  Örnek:\n  - calculate_combinations(5, 2) 10 döndürür\n  - calculate_combinations(18, 13) 8568 döndürür\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "vi": "/*\n  Tính số tổ hợp C(n, m), đại diện cho số cách chọn m phần tử từ một tập hợp gồm n phần tử khác nhau.\n\n  Tham số:\n  - n: Một số nguyên không dấu 32-bit đại diện cho tổng số phần tử (n ≤ 20).\n  - m: Một số nguyên không dấu 32-bit đại diện cho số phần tử cần chọn (m ≤ n).\n\n  Trả về:\n  - Số tổ hợp C(n, m).\n\n  Ví dụ:\n  - calculate_combinations(5, 2) trả về 10\n  - calculate_combinations(18, 13) trả về 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 "
    },
    "prompt_bertscore": {
      "es": "0.9800674412631489",
      "arb": "0.9686396395510688",
      "sw": "0.983136082019757",
      "tr": "0.969614517461188",
      "vi": "0.9698876342351109"
    },
    "canonical_solution": "{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}",
    "instruction": {
      "en": "Write a Rust function `fn calculate_combinations(n: u32, m: u32) -> u64` to solve the following problem:\nComputes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n ≤ 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m ≤ n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568",
      "es": "Escribe una función en Rust `fn calculate_combinations(n: u32, m: u32) -> u64` para resolver el siguiente problema:\nCalcula el número de combinaciones C(n, m), que representa el número de formas de elegir m elementos de un conjunto de n elementos distintos.\n\n  Argumentos:\n  - n: Un entero sin signo de 32 bits que representa el número total de elementos (n ≤ 20).\n  - m: Un entero sin signo de 32 bits que representa el número de elementos a elegir (m ≤ n).\n\n  Devuelve:\n  - El número de combinaciones C(n, m).\n\n  Ejemplo:\n  - calculate_combinations(5, 2) devuelve 10\n  - calculate_combinations(18, 13) devuelve 8568",
      "arb": "اكتب دالة بلغة Rust `fn calculate_combinations(n: u32, m: u32) -> u64` لحل المشكلة التالية:\nتحسب عدد التوافيق C(n, m)، والذي يمثل عدد الطرق لاختيار m عنصرًا من مجموعة تحتوي على n عنصرًا مميزًا.\n\n  الوسيطات:\n  - n: عدد صحيح غير موقع 32 بت يمثل العدد الإجمالي للعناصر (n ≤ 20).\n  - m: عدد صحيح غير موقع 32 بت يمثل عدد العناصر المراد اختيارها (m ≤ n).\n\n  يعيد:\n  - عدد التوافيق C(n, m).\n\n  مثال:\n  - calculate_combinations(5, 2) يعيد 10\n  - calculate_combinations(18, 13) يعيد 8568",
      "sw": "Andika kazi ya Rust `fn calculate_combinations(n: u32, m: u32) -> u64` kutatua tatizo lifuatalo:\nInahesabu nambari ya mchanganyiko C(n, m), ambayo inawakilisha idadi ya njia za kuchagua vipengele m kutoka kwenye seti ya vipengele n tofauti.\n\n  Hoja:\n  - n: Nambari isiyo na ishara ya biti 32 inayowakilisha jumla ya idadi ya vipengele (n ≤ 20).\n  - m: Nambari isiyo na ishara ya biti 32 inayowakilisha idadi ya vipengele vya kuchagua (m ≤ n).\n\n  Inarudisha:\n  - Nambari ya mchanganyiko C(n, m).\n\n  Mfano:\n  - calculate_combinations(5, 2) inarudisha 10\n  - calculate_combinations(18, 13) inarudisha 8568",
      "tr": "Bir Rust fonksiyonu `fn calculate_combinations(n: u32, m: u32) -> u64` yazın ve aşağıdaki problemi çözün:\nC(n, m) kombinasyon sayısını hesaplar, bu da n farklı elemandan m eleman seçmenin yollarının sayısını temsil eder.\n\n  Argümanlar:\n  - n: Toplam eleman sayısını temsil eden işaretsiz 32-bit tamsayı (n ≤ 20).\n  - m: Seçilecek eleman sayısını temsil eden işaretsiz 32-bit tamsayı (m ≤ n).\n\n  Döndürür:\n  - Kombinasyon sayısı C(n, m).\n\n  Örnek:\n  - calculate_combinations(5, 2) 10 döndürür\n  - calculate_combinations(18, 13) 8568 döndürür",
      "vi": "Viết một hàm Rust `fn calculate_combinations(n: u32, m: u32) -> u64` để giải quyết vấn đề sau:\nTính số tổ hợp C(n, m), đại diện cho số cách chọn m phần tử từ một tập hợp gồm n phần tử khác nhau.\n\n  Tham số:\n  - n: Một số nguyên không dấu 32-bit đại diện cho tổng số phần tử (n ≤ 20).\n  - m: Một số nguyên không dấu 32-bit đại diện cho số phần tử cần chọn (m ≤ n).\n\n  Trả về:\n  - Số tổ hợp C(n, m).\n\n  Ví dụ:\n  - calculate_combinations(5, 2) trả về 10\n  - calculate_combinations(18, 13) trả về 8568"
    },
    "instruction_bertscore": {
      "es": "0.9747832772364778",
      "arb": "0.9720433697604826",
      "sw": "0.980056317961811",
      "tr": "0.9692359279549355",
      "vi": "0.9696743052058795"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_combinations(5, 2), 10);\n        assert_eq!(calculate_combinations(18, 13), 8568);\n        assert_eq!(calculate_combinations(10, 0), 1);\n        assert_eq!(calculate_combinations(20, 20), 1);\n        assert_eq!(calculate_combinations(15, 5), 3003);\n    }\n    \n\n}",
    "entry_point": "calculate_combinations",
    "signature": "fn calculate_combinations(n: u32, m: u32) -> u64",
    "docstring": {
      "en": "Computes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n ≤ 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m ≤ n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568",
      "es": "Calcula el número de combinaciones C(n, m), que representa el número de formas de elegir m elementos de un conjunto de n elementos distintos.\n\n  Argumentos:\n  - n: Un entero sin signo de 32 bits que representa el número total de elementos (n ≤ 20).\n  - m: Un entero sin signo de 32 bits que representa el número de elementos a elegir (m ≤ n).\n\n  Retorna:\n  - El número de combinaciones C(n, m).\n\n  Ejemplo:\n  - calculate_combinations(5, 2) devuelve 10\n  - calculate_combinations(18, 13) devuelve 8568",
      "arb": "يحسب عدد التوافيق C(n, m)، الذي يمثل عدد الطرق لاختيار m عنصرًا من مجموعة مكونة من n عنصرًا مميزًا.\n\n  الحجج:\n  - n: عدد صحيح غير موقع 32 بت يمثل العدد الإجمالي للعناصر (n ≤ 20).\n  - m: عدد صحيح غير موقع 32 بت يمثل عدد العناصر المراد اختيارها (m ≤ n).\n\n  يعيد:\n  - عدد التوافيق C(n, m).\n\n  مثال:\n  - calculate_combinations(5, 2) يعيد 10\n  - calculate_combinations(18, 13) يعيد 8568",
      "sw": "Hesabu nambari ya mchanganyiko C(n, m), ambayo inawakilisha idadi ya njia za kuchagua vipengele m kutoka kwenye seti ya vipengele n tofauti.\n\n  Hoja:\n  - n: Nambari isiyo na ishara ya biti 32 inayowakilisha jumla ya idadi ya vipengele (n ≤ 20).\n  - m: Nambari isiyo na ishara ya biti 32 inayowakilisha idadi ya vipengele vya kuchagua (m ≤ n).\n\n  Inarejesha:\n  - Nambari ya mchanganyiko C(n, m).\n\n  Mfano:\n  - calculate_combinations(5, 2) inarejesha 10\n  - calculate_combinations(18, 13) inarejesha 8568",
      "tr": "n elemanlı bir kümeden m eleman seçmenin kaç farklı yolu olduğunu temsil eden kombinasyon sayısı C(n, m)'yi hesaplar.\n\n  Argümanlar:\n  - n: Toplam eleman sayısını temsil eden işaretsiz 32-bit tamsayı (n ≤ 20).\n  - m: Seçilecek eleman sayısını temsil eden işaretsiz 32-bit tamsayı (m ≤ n).\n\n  Döndürür:\n  - Kombinasyon sayısı C(n, m).\n\n  Örnek:\n  - calculate_combinations(5, 2) 10 döndürür\n  - calculate_combinations(18, 13) 8568 döndürür",
      "vi": "Tính toán số tổ hợp C(n, m), đại diện cho số cách chọn m phần tử từ một tập hợp gồm n phần tử phân biệt.\n\n  Tham số:\n  - n: Một số nguyên không dấu 32-bit đại diện cho tổng số phần tử (n ≤ 20).\n  - m: Một số nguyên không dấu 32-bit đại diện cho số phần tử cần chọn (m ≤ n).\n\n  Trả về:\n  - Số tổ hợp C(n, m).\n\n  Ví dụ:\n  - calculate_combinations(5, 2) trả về 10\n  - calculate_combinations(18, 13) trả về 8568"
    },
    "docstring_bertscore": {
      "es": "0.9736771046444945",
      "arb": "0.971692588507575",
      "sw": "0.9736771046444945",
      "tr": "0.9639487844725488",
      "vi": "0.9669778977833309"
    }
  },
  {
    "task_id": "Rust/30",
    "prompt": {
      "en": "/*\n  Determines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "es": "/*\n  Determina si Yuanzi puede ganar una carrera de caballos contra un oponente organizando óptimamente sus caballos.\n\n  La función compara las velocidades de los caballos de Yuanzi con las de los caballos del oponente. Cada caballo tiene una velocidad fija y no hay empates. Yuanzi gana si gana más de la mitad de las carreras individuales.\n\n  Argumentos:\n  - yuanzi_horses: Un arreglo de enteros que representa las velocidades de los caballos de Yuanzi.\n  - opponent_horses: Un arreglo de enteros que representa las velocidades de los caballos del oponente.\n\n  Devuelve:\n  - Un valor booleano: `true` si Yuanzi puede ganar la carrera, `false` de lo contrario.\n\n  Ejemplos:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) devuelve true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) devuelve false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "arb": "/*\n  يحدد ما إذا كان يمكن ليونزي الفوز بسباق الخيل ضد خصم عن طريق ترتيب خيوله بشكل مثالي.\n\n  تقارن الدالة سرعات خيول يوانزي بسرعات خيول الخصم. كل حصان له سرعة ثابتة ولا توجد تعادلات. يفوز يوانزي إذا فاز في أكثر من نصف السباقات الفردية.\n\n  الوسائط:\n  - yuanzi_horses: مصفوفة من الأعداد الصحيحة تمثل سرعات خيول يوانزي.\n  - opponent_horses: مصفوفة من الأعداد الصحيحة تمثل سرعات خيول الخصم.\n\n  يعيد:\n  - قيمة منطقية: `true` إذا كان يمكن ليونزي الفوز بالسباق، `false` خلاف ذلك.\n\n  أمثلة:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) يعيد true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) يعيد false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "sw": "/*\n  Huamua kama Yuanzi anaweza kushinda mbio za farasi dhidi ya mpinzani kwa kupanga farasi wake kwa ufanisi.\n\n  Kazi inalinganisha kasi za farasi wa Yuanzi na za farasi wa mpinzani. Kila farasi ana kasi iliyowekwa na hakuna sare. Yuanzi anashinda ikiwa anashinda zaidi ya nusu ya mbio za kibinafsi.\n\n  Hoja:\n  - yuanzi_horses: Kundi la nambari za mzima linalowakilisha kasi za farasi wa Yuanzi.\n  - opponent_horses: Kundi la nambari za mzima linalowakilisha kasi za farasi wa mpinzani.\n\n  Inarejesha:\n  - Thamani ya boolean: `true` ikiwa Yuanzi anaweza kushinda mbio, `false` vinginevyo.\n\n  Mifano:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) inarejesha true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) inarejesha false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "tr": "/*\n  Yuanzi'nin rakibine karşı bir at yarışını kazanıp kazanamayacağını, atlarını en iyi şekilde düzenleyerek belirler.\n\n  Fonksiyon, Yuanzi'nin atlarının hızlarını rakibin atlarının hızlarıyla karşılaştırır. Her atın sabit bir hızı vardır ve eşitlik yoktur. Yuanzi, bireysel yarışların yarısından fazlasını kazanırsa kazanır.\n\n  Argümanlar:\n  - yuanzi_horses: Yuanzi'nin atlarının hızlarını temsil eden bir tamsayı dizisi.\n  - opponent_horses: Rakibin atlarının hızlarını temsil eden bir tamsayı dizisi.\n\n  Döndürür:\n  - Bir boolean değer: Yuanzi yarışı kazanabiliyorsa `true`, aksi takdirde `false`.\n\n  Örnekler:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) true döndürür\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) false döndürür\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "vi": "/*\n  Xác định liệu Yuanzi có thể thắng một cuộc đua ngựa chống lại đối thủ bằng cách sắp xếp tối ưu các con ngựa của mình hay không.\n\n  Hàm so sánh tốc độ của các con ngựa của Yuanzi với các con ngựa của đối thủ. Mỗi con ngựa có một tốc độ cố định và không có trường hợp hòa. Yuanzi thắng nếu anh ta thắng hơn một nửa số cuộc đua cá nhân.\n\n  Tham số:\n  - yuanzi_horses: Một mảng số nguyên đại diện cho tốc độ của các con ngựa của Yuanzi.\n  - opponent_horses: Một mảng số nguyên đại diện cho tốc độ của các con ngựa của đối thủ.\n\n  Trả về:\n  - Một giá trị boolean: `true` nếu Yuanzi có thể thắng cuộc đua, `false` nếu không.\n\n  Ví dụ:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) trả về true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) trả về false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool "
    },
    "prompt_bertscore": {
      "es": "0.9987154573258474",
      "arb": "0.9913669277490806",
      "sw": "0.9900142548542331",
      "tr": "0.9757661003618384",
      "vi": "0.9758672032257852"
    },
    "canonical_solution": "{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}",
    "instruction": {
      "en": "Write a Rust function `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` to solve the following problem:\nDetermines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false",
      "es": "Escribe una función en Rust `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` para resolver el siguiente problema:\nDetermina si Yuanzi puede ganar una carrera de caballos contra un oponente organizando óptimamente sus caballos.\n\n  La función compara las velocidades de los caballos de Yuanzi con las de los caballos del oponente. Cada caballo tiene una velocidad fija y no hay empates. Yuanzi gana si gana más de la mitad de las carreras individuales.\n\n  Argumentos:\n  - yuanzi_horses: Un arreglo de enteros que representa las velocidades de los caballos de Yuanzi.\n  - opponent_horses: Un arreglo de enteros que representa las velocidades de los caballos del oponente.\n\n  Retorna:\n  - Un valor booleano: `true` si Yuanzi puede ganar la carrera, `false` en caso contrario.\n\n  Ejemplos:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) retorna true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) retorna false",
      "arb": "اكتب دالة Rust `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` لحل المشكلة التالية:\nتحديد ما إذا كان بإمكان Yuanzi الفوز في سباق الخيل ضد خصم عن طريق ترتيب خيوله بشكل مثالي.\n\nتقوم الدالة بمقارنة سرعات خيول Yuanzi مع سرعات خيول الخصم. كل حصان له سرعة ثابتة ولا توجد تعادلات. يفوز Yuanzi إذا فاز بأكثر من نصف السباقات الفردية.\n\nالمعطيات:\n- yuanzi_horses: مصفوفة من الأعداد الصحيحة تمثل سرعات خيول Yuanzi.\n- opponent_horses: مصفوفة من الأعداد الصحيحة تمثل سرعات خيول الخصم.\n\nالقيم المعادة:\n- قيمة منطقية: `true` إذا كان بإمكان Yuanzi الفوز في السباق، `false` خلاف ذلك.\n\nأمثلة:\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) يعيد true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) يعيد false",
      "sw": "Andika kazi ya Rust `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` kutatua tatizo lifuatalo:\nInabainisha kama Yuanzi anaweza kushinda mbio za farasi dhidi ya mpinzani kwa kupanga farasi wake kwa njia bora.\n\nKazi hii inalinganisha kasi za farasi wa Yuanzi na zile za farasi wa mpinzani. Kila farasi ana kasi iliyowekwa na hakuna sare. Yuanzi anashinda ikiwa anashinda zaidi ya nusu ya mbio za kibinafsi.\n\nHoja:\n- yuanzi_horses: Mfululizo wa namba za mzima zinazoonyesha kasi za farasi wa Yuanzi.\n- opponent_horses: Mfululizo wa namba za mzima zinazoonyesha kasi za farasi wa mpinzani.\n\nInarejesha:\n- Thamani ya boolean: `true` ikiwa Yuanzi anaweza kushinda mbio, `false` vinginevyo.\n\nMifano:\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) inarejesha true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) inarejesha false",
      "tr": "Rust dilinde `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` fonksiyonunu aşağıdaki problemi çözmek için yazın:\nYuanzi'nin atlarını en iyi şekilde düzenleyerek bir rakibe karşı at yarışını kazanıp kazanamayacağını belirler.\n\n  Fonksiyon, Yuanzi'nin atlarının hızlarını rakibin atlarının hızlarıyla karşılaştırır. Her atın sabit bir hızı vardır ve eşitlik durumu yoktur. Yuanzi, bireysel yarışların yarısından fazlasını kazanırsa yarışı kazanır.\n\n  Argümanlar:\n  - yuanzi_horses: Yuanzi'nin atlarının hızlarını temsil eden bir tamsayı dizisi.\n  - opponent_horses: Rakibin atlarının hızlarını temsil eden bir tamsayı dizisi.\n\n  Döndürür:\n  - Bir boolean değeri: Yuanzi yarışı kazanabiliyorsa `true`, aksi takdirde `false`.\n\n  Örnekler:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) true döndürür\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) false döndürür",
      "vi": "Viết một hàm Rust `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` để giải quyết vấn đề sau:\nXác định xem Yuanzi có thể thắng một cuộc đua ngựa chống lại đối thủ bằng cách sắp xếp tối ưu các con ngựa của mình hay không.\n\nHàm so sánh tốc độ của các con ngựa của Yuanzi với các con ngựa của đối thủ. Mỗi con ngựa có một tốc độ cố định và không có trận hòa. Yuanzi thắng nếu anh ta thắng hơn một nửa số cuộc đua cá nhân.\n\nTham số:\n- yuanzi_horses: Một mảng số nguyên đại diện cho tốc độ của các con ngựa của Yuanzi.\n- opponent_horses: Một mảng số nguyên đại diện cho tốc độ của các con ngựa của đối thủ.\n\nTrả về:\n- Một giá trị boolean: `true` nếu Yuanzi có thể thắng cuộc đua, `false` nếu không.\n\nVí dụ:\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) trả về true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) trả về false"
    },
    "instruction_bertscore": {
      "es": "0.9919463325705594",
      "arb": "0.9866059561460554",
      "sw": "0.9848693307246674",
      "tr": "0.9763578202669414",
      "vi": "0.9753050792474565"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]), true);\n        assert_eq!(can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]), false);\n    }\n    \n\n}",
    "entry_point": "can_win_horse_race",
    "signature": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool",
    "docstring": {
      "en": "Determines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false",
      "es": "Determina si Yuanzi puede ganar una carrera de caballos contra un oponente organizando óptimamente sus caballos.\n\n  La función compara las velocidades de los caballos de Yuanzi con las de los caballos del oponente. Cada caballo tiene una velocidad fija y no hay empates. Yuanzi gana si gana más de la mitad de las carreras individuales.\n\n  Argumentos:\n  - yuanzi_horses: Un arreglo de enteros que representa las velocidades de los caballos de Yuanzi.\n  - opponent_horses: Un arreglo de enteros que representa las velocidades de los caballos del oponente.\n\n  Retorna:\n  - Un valor booleano: `true` si Yuanzi puede ganar la carrera, `false` en caso contrario.\n\n  Ejemplos:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) retorna true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) retorna false",
      "arb": "يحدد ما إذا كان بإمكان يوانزي الفوز في سباق الخيل ضد خصم عن طريق ترتيب خيوله بشكل مثالي.\n\nتقارن الدالة سرعات خيول يوانزي مع سرعات خيول الخصم. كل حصان له سرعة ثابتة ولا توجد تعادلات. يفوز يوانزي إذا فاز في أكثر من نصف السباقات الفردية.\n\nالحجج:\n- yuanzi_horses: مصفوفة من الأعداد الصحيحة تمثل سرعات خيول يوانزي.\n- opponent_horses: مصفوفة من الأعداد الصحيحة تمثل سرعات خيول الخصم.\n\nالقيم المعادة:\n- قيمة منطقية: `true` إذا كان بإمكان يوانزي الفوز في السباق، `false` خلاف ذلك.\n\nأمثلة:\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) يعيد true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) يعيد false",
      "sw": "Huamua kama Yuanzi anaweza kushinda mbio za farasi dhidi ya mpinzani kwa kupanga farasi wake kwa ufanisi.\n\n  Kazi hii inalinganisha kasi za farasi wa Yuanzi na wale wa mpinzani. Kila farasi ana kasi iliyowekwa na hakuna sare. Yuanzi anashinda ikiwa atashinda zaidi ya nusu ya mbio za kibinafsi.\n\n  Hoja:\n  - yuanzi_horses: Mfululizo wa nambari za mzima zinazoonyesha kasi za farasi wa Yuanzi.\n  - opponent_horses: Mfululizo wa nambari za mzima zinazoonyesha kasi za farasi wa mpinzani.\n\n  Inarejesha:\n  - Thamani ya boolean: `true` ikiwa Yuanzi anaweza kushinda mbio, `false` vinginevyo.\n\n  Mifano:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) inarejesha true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) inarejesha false",
      "tr": "Yuanzi'nin atlarını en iyi şekilde düzenleyerek bir rakibe karşı at yarışını kazanıp kazanamayacağını belirler.\n\n  Fonksiyon, Yuanzi'nin atlarının hızlarını rakibin atlarının hızlarıyla karşılaştırır. Her atın sabit bir hızı vardır ve eşitlik yoktur. Yuanzi, bireysel yarışların yarısından fazlasını kazanırsa kazanır.\n\n  Argümanlar:\n  - yuanzi_horses: Yuanzi'nin atlarının hızlarını temsil eden bir tamsayı dizisi.\n  - opponent_horses: Rakibin atlarının hızlarını temsil eden bir tamsayı dizisi.\n\n  Döndürür:\n  - Bir boolean değer: Yuanzi yarışı kazanabiliyorsa `true`, aksi takdirde `false`.\n\n  Örnekler:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) true döndürür\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) false döndürür",
      "vi": "Xác định xem Yuanzi có thể thắng một cuộc đua ngựa chống lại đối thủ bằng cách sắp xếp tối ưu các con ngựa của mình hay không.\n\nHàm so sánh tốc độ của các con ngựa của Yuanzi với các con ngựa của đối thủ. Mỗi con ngựa có tốc độ cố định và không có trận hòa. Yuanzi thắng nếu anh ấy thắng hơn một nửa số cuộc đua cá nhân.\n\nCác đối số:\n- yuanzi_horses: Một mảng số nguyên đại diện cho tốc độ của các con ngựa của Yuanzi.\n- opponent_horses: Một mảng số nguyên đại diện cho tốc độ của các con ngựa của đối thủ.\n\nTrả về:\n- Một giá trị boolean: `true` nếu Yuanzi có thể thắng cuộc đua, `false` nếu không.\n\nVí dụ:\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) trả về true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) trả về false"
    },
    "docstring_bertscore": {
      "es": "0.9980307784024202",
      "arb": "0.9906349747949671",
      "sw": "0.9732663370165144",
      "tr": "0.9598272040660749",
      "vi": "0.9820028956959529"
    }
  },
  {
    "task_id": "Rust/31",
    "prompt": {
      "en": "/*\n  Calculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "es": "/*\n  Calcula el número de diferentes maneras de subir una escalera de un número dado de escalones, donde en cada paso, uno puede subir un escalón o dos escalones. Comienzas en el nivel 0.\n\n  Argumentos:\n  - stairs: Un entero que representa el número de escalones en la escalera.\n\n  Devuelve:\n  - Un entero que representa el número de diferentes maneras de subir la escalera.\n\n  Ejemplo:\n  - count_ways_to_climb(2) devuelve 2 (1 escalón + 1 escalón, 2 escalones)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "arb": "/*\n  يحسب عدد الطرق المختلفة لتسلق درج بعدد معين من الدرجات، حيث يمكن في كل خطوة إما تسلق درجة واحدة أو درجتين. تبدأ من المستوى 0.\n\n  المعطيات:\n  - stairs: عدد صحيح يمثل عدد الدرجات في الدرج.\n\n  يعيد:\n  - عدد صحيح يمثل عدد الطرق المختلفة لتسلق الدرج.\n\n  مثال:\n  - count_ways_to_climb(2) يعيد 2 (1 درجة + 1 درجة، درجتين)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ya njia tofauti za kupanda ngazi yenye idadi fulani ya hatua, ambapo katika kila hatua, mtu anaweza kupanda hatua moja au hatua mbili. Unaaanza katika kiwango cha 0.\n\n  Hoja:\n  - stairs: Nambari kamili inayowakilisha idadi ya hatua katika ngazi.\n\n  Inarudisha:\n  - Nambari kamili inayowakilisha idadi ya njia tofauti za kupanda ngazi.\n\n  Mfano:\n  - count_ways_to_climb(2) inarudisha 2 (hatua 1 + hatua 1, hatua 2)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "tr": "/*\n  Belirli bir basamak sayısına sahip bir merdiveni çıkmanın farklı yollarının sayısını hesaplar, burada her adımda bir veya iki basamak çıkılabilir. 0 seviyesinden başlarsınız.\n\n  Argümanlar:\n  - stairs: Merdivendeki basamak sayısını temsil eden bir tamsayı.\n\n  Döndürür:\n  - Merdiveni çıkmanın farklı yollarının sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - count_ways_to_climb(2) 2 döndürür (1 adım + 1 adım, 2 adım)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "vi": "/*\n  Tính toán số cách khác nhau để leo lên một cầu thang với số bậc thang cho trước, trong đó tại mỗi bước, có thể leo lên một bậc hoặc hai bậc. Bạn bắt đầu ở mức 0.\n\n  Tham số:\n  - stairs: Một số nguyên đại diện cho số bậc thang trong cầu thang.\n\n  Trả về:\n  - Một số nguyên đại diện cho số cách khác nhau để leo lên cầu thang.\n\n  Ví dụ:\n  - count_ways_to_climb(2) trả về 2 (1 bước + 1 bước, 2 bước)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9963922763892633",
      "arb": "0.9648744020481714",
      "sw": "0.9745437289969497",
      "tr": "0.9575572560716082",
      "vi": "0.9791841319586868"
    },
    "canonical_solution": "{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_ways_to_climb(stairs: i32) -> i32` to solve the following problem:\nCalculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)",
      "es": "Escribe una función en Rust `fn count_ways_to_climb(stairs: i32) -> i32` para resolver el siguiente problema:\nCalcula el número de diferentes maneras de subir una escalera de un número dado de escalones, donde en cada paso, se puede subir un escalón o dos escalones. Comienzas en el nivel 0.\n\n  Argumentos:\n  - stairs: Un entero que representa el número de escalones en la escalera.\n\n  Devuelve:\n  - Un entero que representa el número de diferentes maneras de subir la escalera.\n\n  Ejemplo:\n  - count_ways_to_climb(2) devuelve 2 (1 paso + 1 paso, 2 pasos)",
      "arb": "اكتب دالة بلغة Rust `fn count_ways_to_climb(stairs: i32) -> i32` لحل المشكلة التالية:\nتحسب عدد الطرق المختلفة لتسلق درج بعدد معين من الدرجات، حيث يمكن في كل خطوة تسلق درجة واحدة أو درجتين. تبدأ من المستوى 0.\n\n  الوسائط:\n  - stairs: عدد صحيح يمثل عدد الدرجات في الدرج.\n\n  يعيد:\n  - عدد صحيح يمثل عدد الطرق المختلفة لتسلق الدرج.\n\n  مثال:\n  - count_ways_to_climb(2) يعيد 2 (1 درجة + 1 درجة، درجتين)",
      "sw": "Andika kazi ya Rust `fn count_ways_to_climb(stairs: i32) -> i32` kutatua tatizo lifuatalo:\nInahesabu idadi ya njia tofauti za kupanda ngazi ya idadi fulani ya hatua, ambapo katika kila hatua, mtu anaweza kupanda hatua moja au hatua mbili. Unaanzia ngazi ya 0.\n\n  Hoja:\n  - stairs: Nambari nzima inayowakilisha idadi ya hatua kwenye ngazi.\n\n  Inarejesha:\n  - Nambari nzima inayowakilisha idadi ya njia tofauti za kupanda ngazi.\n\n  Mfano:\n  - count_ways_to_climb(2) inarejesha 2 (hatua 1 + hatua 1, hatua 2)",
      "tr": "Bir Rust fonksiyonu `fn count_ways_to_climb(stairs: i32) -> i32` yazın ve aşağıdaki problemi çözün:\nBelirli bir basamak sayısına sahip bir merdiveni tırmanmanın farklı yollarının sayısını hesaplar, burada her adımda bir veya iki basamak çıkılabilir. 0 seviyesinden başlarsınız.\n\n  Argümanlar:\n  - stairs: Merdivendeki basamak sayısını temsil eden bir tamsayı.\n\n  Döndürür:\n  - Merdiveni tırmanmanın farklı yollarının sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - count_ways_to_climb(2) 2 döndürür (1 adım + 1 adım, 2 adım)",
      "vi": "Viết một hàm Rust `fn count_ways_to_climb(stairs: i32) -> i32` để giải quyết vấn đề sau:\nTính toán số cách khác nhau để leo lên một cầu thang với số bậc thang cho trước, trong đó ở mỗi bước, có thể leo một bậc hoặc hai bậc. Bạn bắt đầu ở mức 0.\n\n  Tham số:\n  - stairs: Một số nguyên đại diện cho số bậc thang trong cầu thang.\n\n  Trả về:\n  - Một số nguyên đại diện cho số cách khác nhau để leo lên cầu thang.\n\n  Ví dụ:\n  - count_ways_to_climb(2) trả về 2 (1 bước + 1 bước, 2 bước)"
    },
    "instruction_bertscore": {
      "es": "0.9870351963994718",
      "arb": "0.949084279907803",
      "sw": "0.9723462810915608",
      "tr": "0.9693525239886029",
      "vi": "0.9832564520306641"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n  \n    #[test]\n    fn main() {\n      \n        assert_eq!(count_ways_to_climb(2), 2); // 2 ways: (1+1), (2)\n        assert_eq!(count_ways_to_climb(3), 3); // 3 ways: (1+1+1), (1+2), (2+1)\n        assert_eq!(count_ways_to_climb(4), 5); // 5 ways: (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2)\n        assert_eq!(count_ways_to_climb(10), 89); \n        assert_eq!(count_ways_to_climb(24), 75025); \n        println!(\"All test cases passed.\");\n    }\n    \n\n}",
    "entry_point": "count_ways_to_climb",
    "signature": "fn count_ways_to_climb(stairs: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)",
      "es": "Calcula el número de diferentes maneras de subir una escalera de un número dado de escalones, donde en cada paso, se puede subir un escalón o dos escalones. Comienzas en el nivel 0.\n\n  Argumentos:\n  - stairs: Un entero que representa el número de escalones en la escalera.\n\n  Retorna:\n  - Un entero que representa el número de diferentes maneras de subir la escalera.\n\n  Ejemplo:\n  - count_ways_to_climb(2) retorna 2 (1 paso + 1 paso, 2 pasos)",
      "arb": "يحسب عدد الطرق المختلفة لتسلق درج بعدد معين من الدرجات، حيث يمكن في كل خطوة تسلق درجة واحدة أو درجتين. تبدأ من المستوى 0.\n\n  الحجج:\n  - stairs: عدد صحيح يمثل عدد الدرجات في الدرج.\n\n  العوائد:\n  - عدد صحيح يمثل عدد الطرق المختلفة لتسلق الدرج.\n\n  مثال:\n  - count_ways_to_climb(2) يعيد 2 (خطوة واحدة + خطوة واحدة، درجتين)",
      "sw": "Inahesabu idadi ya njia tofauti za kupanda ngazi yenye idadi fulani ya hatua, ambapo katika kila hatua, mtu anaweza kupanda hatua moja au hatua mbili. Unaanzia kwenye kiwango cha 0.\n\n  Hoja:\n  - stairs: Nambari kamili inayowakilisha idadi ya hatua kwenye ngazi.\n\n  Inarudisha:\n  - Nambari kamili inayowakilisha idadi ya njia tofauti za kupanda ngazi.\n\n  Mfano:\n  - count_ways_to_climb(2) inarudisha 2 (hatua 1 + hatua 1, hatua 2)",
      "tr": "Belirli bir basamak sayısına sahip bir merdiveni çıkmanın farklı yollarının sayısını hesaplar. Her adımda, bir veya iki basamak çıkılabilir. 0 seviyesinden başlarsınız.\n\n  Argümanlar:\n  - stairs: Merdivenin basamak sayısını temsil eden bir tamsayı.\n\n  Döndürür:\n  - Merdiveni çıkmanın farklı yollarının sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - count_ways_to_climb(2) 2 döndürür (1 basamak + 1 basamak, 2 basamak)",
      "vi": "Tính toán số cách khác nhau để leo lên một cầu thang với một số bậc thang cho trước, trong đó ở mỗi bậc, bạn có thể leo một bậc hoặc hai bậc. Bạn bắt đầu ở mức 0.\n\n  Tham số:\n  - stairs: Một số nguyên đại diện cho số bậc thang trong cầu thang.\n\n  Trả về:\n  - Một số nguyên đại diện cho số cách khác nhau để leo lên cầu thang.\n\n  Ví dụ:\n  - count_ways_to_climb(2) trả về 2 (1 bước + 1 bước, 2 bước)"
    },
    "docstring_bertscore": {
      "es": "0.9927178129704989",
      "arb": "0.9754077711544515",
      "sw": "0.9563301175775747",
      "tr": "0.9444681098525521",
      "vi": "0.9716959652240525"
    }
  },
  {
    "task_id": "Rust/32",
    "prompt": {
      "en": "\n/*\n  Finds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "es": "/*\n  Encuentra todos los rangos de números naturales consecutivos cuya suma es igual a la suma objetivo dada.\n\n  La función identifica todas las posibles secuencias contiguas de números naturales donde la suma de todos los números en la secuencia es igual a la suma objetivo. La función devuelve un vector de tuplas, cada tupla representa el inicio y el fin de una secuencia.\n\n  Argumentos:\n  - target_sum: Un entero que representa la suma objetivo (10 <= target_sum <= 2,000,000).\n\n  Devuelve:\n  - Un vector de tuplas. Cada tupla contiene dos enteros: el primer y último número en una secuencia contigua que suma la suma objetivo.\n\n  Ejemplo:\n  - find_sum_sequence_ranges(10000) devuelve vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "arb": "/*\n  يجد جميع النطاقات من الأعداد الطبيعية المتتالية التي يساوي مجموعها المجموع المستهدف المعطى.\n\n  تحدد الدالة جميع التسلسلات المتجاورة الممكنة من الأعداد الطبيعية حيث يساوي مجموع جميع الأعداد في التسلسل المجموع المستهدف. تعيد الدالة متجهًا من الأزواج، يمثل كل زوج بداية ونهاية تسلسل.\n\n  الوسائط:\n  - target_sum: عدد صحيح يمثل المجموع المستهدف (10 <= target_sum <= 2,000,000).\n\n  العوائد:\n  - متجه من الأزواج. يحتوي كل زوج على عددين صحيحين: الأول والأخير في تسلسل متجاور يساوي مجموعهم المجموع المستهدف.\n\n  مثال:\n  - find_sum_sequence_ranges(10000) يعيد vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "sw": "/*\n  Inapata safu zote za namba asilia mfululizo ambazo jumla yake ni sawa na jumla lengwa.\n\n  Kazi inatambua mfuatano wote unaowezekana wa namba asilia mfululizo ambapo jumla ya namba zote katika mfuatano ni sawa na jumla lengwa. Kazi inarudisha vekta ya jozi, kila jozi ikiwakilisha mwanzo na mwisho wa mfuatano.\n\n  Hoja:\n  - target_sum: Namba nzima inayowakilisha jumla lengwa (10 <= target_sum <= 2,000,000).\n\n  Inarudisha:\n  - Vekta ya jozi. Kila jozi ina namba mbili nzima: namba ya kwanza na ya mwisho katika mfuatano mfululizo ambao jumla yake ni sawa na jumla lengwa.\n\n  Mfano:\n  - find_sum_sequence_ranges(10000) inarudisha vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "tr": "/*\n  Verilen hedef toplamına eşit olan ardışık doğal sayıların tüm aralıklarını bulur.\n\n  Fonksiyon, tüm sayılarının toplamı hedef toplamına eşit olan olası tüm ardışık doğal sayı dizilerini tanımlar. Fonksiyon, her bir tuple bir dizinin başlangıç ve bitişini temsil eden bir tuple vektörü döndürür.\n\n  Argümanlar:\n  - target_sum: Hedef toplamı temsil eden bir tamsayı (10 <= target_sum <= 2,000,000).\n\n  Döndürülenler:\n  - Bir tuple vektörü. Her bir tuple, hedef toplamına eşit olan ardışık bir dizideki ilk ve son sayıyı içeren iki tamsayı içerir.\n\n  Örnek:\n  - find_sum_sequence_ranges(10000) vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] döndürür\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "vi": "/*\n  Tìm tất cả các dãy số tự nhiên liên tiếp có tổng bằng tổng mục tiêu đã cho.\n\n  Hàm này xác định tất cả các dãy số tự nhiên liên tiếp có thể có mà tổng của tất cả các số trong dãy bằng tổng mục tiêu. Hàm trả về một vector các bộ giá trị, mỗi bộ đại diện cho điểm bắt đầu và kết thúc của một dãy.\n\n  Tham số:\n  - target_sum: Một số nguyên đại diện cho tổng mục tiêu (10 <= target_sum <= 2,000,000).\n\n  Trả về:\n  - Một vector các bộ giá trị. Mỗi bộ chứa hai số nguyên: số đầu tiên và số cuối cùng trong một dãy liên tiếp có tổng bằng tổng mục tiêu.\n\n  Ví dụ:\n  - find_sum_sequence_ranges(10000) trả về vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> "
    },
    "prompt_bertscore": {
      "es": "0.9929746420531771",
      "arb": "0.9677807617834739",
      "sw": "0.9503692198427177",
      "tr": "0.9664817190915057",
      "vi": "0.9426039637265398"
    },
    "canonical_solution": "{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}",
    "instruction": {
      "en": "Write a Rust function `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` to solve the following problem:\nFinds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "es": "Escribe una función de Rust `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` para resolver el siguiente problema:\nEncuentra todos los rangos de números naturales consecutivos cuya suma es igual a la suma objetivo dada.\n\n  La función identifica todas las posibles secuencias contiguas de números naturales donde la suma de todos los números en la secuencia es igual a la suma objetivo. La función devuelve un vector de tuplas, cada tupla representa el inicio y el final de una secuencia.\n\n  Argumentos:\n  - target_sum: Un entero que representa la suma objetivo (10 <= target_sum <= 2,000,000).\n\n  Devuelve:\n  - Un vector de tuplas. Cada tupla contiene dos enteros: el primer y último número en una secuencia contigua que suma la suma objetivo.\n\n  Ejemplo:\n  - find_sum_sequence_ranges(10000) devuelve vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "arb": "اكتب دالة بلغة Rust `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` لحل المشكلة التالية:\nتجد جميع النطاقات من الأعداد الطبيعية المتتالية التي يكون مجموعها مساويًا لمجموع الهدف المعطى.\n\nتحدد الدالة جميع التسلسلات المتجاورة الممكنة للأعداد الطبيعية حيث يكون مجموع جميع الأعداد في التسلسل مساويًا لمجموع الهدف. تُرجع الدالة متجهًا من الأزواج، كل زوج يمثل بداية ونهاية تسلسل.\n\nالمعطيات:\n- target_sum: عدد صحيح يمثل مجموع الهدف (10 <= target_sum <= 2,000,000).\n\nالمخرجات:\n- متجه من الأزواج. يحتوي كل زوج على عددين صحيحين: الرقم الأول والأخير في تسلسل متجاور يكون مجموعهم مساويًا لمجموع الهدف.\n\nمثال:\n- find_sum_sequence_ranges(10000) يعيد vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "sw": "Andika kazi ya Rust `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` kutatua tatizo lifuatalo:\nInapata safu zote za namba za asili zinazofuatana ambazo jumla yake ni sawa na jumla lengwa iliyotolewa.\n\n  Kazi hii inatambua safu zote zinazowezekana za namba za asili zinazofuatana ambapo jumla ya namba zote katika safu ni sawa na jumla lengwa. Kazi hii inarudisha vector ya tuples, kila tuple inawakilisha mwanzo na mwisho wa safu.\n\n  Hoja:\n  - target_sum: Namba nzima inayowakilisha jumla lengwa (10 <= target_sum <= 2,000,000).\n\n  Inarudisha:\n  - Vector ya tuples. Kila tuple ina namba mbili nzima: namba ya kwanza na ya mwisho katika safu inayofuatana ambayo jumla yake ni sawa na jumla lengwa.\n\n  Mfano:\n  - find_sum_sequence_ranges(10000) inarudisha vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "tr": "Bir Rust fonksiyonu `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` yazarak aşağıdaki problemi çözün:\nVerilen hedef toplamına eşit olan ardışık doğal sayıların tüm aralıklarını bulun.\n\n  Fonksiyon, toplamı hedef toplamına eşit olan tüm olası ardışık doğal sayı dizilerini belirler. Fonksiyon, her biri bir dizinin başlangıç ve bitişini temsil eden demetlerden oluşan bir vektör döndürür.\n\n  Argümanlar:\n  - target_sum: Hedef toplamı temsil eden bir tamsayı (10 <= target_sum <= 2,000,000).\n\n  Döndürülenler:\n  - Demetlerden oluşan bir vektör. Her demet, hedef toplamına eşit olan ardışık bir dizideki ilk ve son sayıyı içeren iki tamsayı içerir.\n\n  Örnek:\n  - find_sum_sequence_ranges(10000) `vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]` döndürür.",
      "vi": "Viết một hàm Rust `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` để giải quyết vấn đề sau:\nTìm tất cả các dãy số tự nhiên liên tiếp có tổng bằng tổng mục tiêu đã cho.\n\nHàm xác định tất cả các dãy số liên tiếp có thể có của các số tự nhiên mà tổng của tất cả các số trong dãy bằng tổng mục tiêu. Hàm trả về một vector các bộ giá trị, mỗi bộ giá trị đại diện cho điểm bắt đầu và kết thúc của một dãy.\n\nTham số:\n- target_sum: Một số nguyên đại diện cho tổng mục tiêu (10 <= target_sum <= 2,000,000).\n\nTrả về:\n- Một vector các bộ giá trị. Mỗi bộ giá trị chứa hai số nguyên: số đầu tiên và số cuối cùng trong một dãy liên tiếp có tổng bằng tổng mục tiêu.\n\nVí dụ:\n- find_sum_sequence_ranges(10000) trả về vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]"
    },
    "instruction_bertscore": {
      "es": "0.9877971425411216",
      "arb": "0.9635034551582686",
      "sw": "0.9664221299771952",
      "tr": "0.9550944379771567",
      "vi": "0.9666352603760457"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(find_sum_sequence_ranges(10000), vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]);\n        assert_eq!(find_sum_sequence_ranges(15), vec![(1, 5), (4, 6), (7, 8)]);\n        assert_eq!(find_sum_sequence_ranges(28), vec![(1, 7)]);\n        assert_eq!(find_sum_sequence_ranges(21334), vec![(5332, 5335)]);\n        println!(\"All test cases passed!\");\n    }\n    \n\n}",
    "entry_point": "find_sum_sequence_ranges",
    "signature": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>",
    "docstring": {
      "en": "Finds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "es": "Encuentra todos los rangos de números naturales consecutivos cuya suma es igual a la suma objetivo dada.\n\n  La función identifica todas las posibles secuencias contiguas de números naturales donde la suma de todos los números en la secuencia es igual a la suma objetivo. La función devuelve un vector de tuplas, cada tupla representa el inicio y el fin de una secuencia.\n\n  Argumentos:\n  - target_sum: Un entero que representa la suma objetivo (10 <= target_sum <= 2,000,000).\n\n  Retorna:\n  - Un vector de tuplas. Cada tupla contiene dos enteros: el primer y último número en una secuencia contigua que suma la suma objetivo.\n\n  Ejemplo:\n  - find_sum_sequence_ranges(10000) devuelve vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "arb": "يجد جميع النطاقات من الأعداد الطبيعية المتتالية التي يساوي مجموعها مجموع الهدف المعطى.\n\nتحدد الدالة جميع التسلسلات المتجاورة الممكنة من الأعداد الطبيعية حيث يساوي مجموع جميع الأعداد في التسلسل مجموع الهدف. تعيد الدالة متجهًا من الأزواج، كل زوج يمثل بداية ونهاية تسلسل.\n\nالأوساط:\n- target_sum: عدد صحيح يمثل مجموع الهدف (10 <= target_sum <= 2,000,000).\n\nالإرجاع:\n- متجه من الأزواج. يحتوي كل زوج على عددين صحيحين: الأول والأخير في تسلسل متجاور يجمع إلى مجموع الهدف.\n\nمثال:\n- find_sum_sequence_ranges(10000) يعيد vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "sw": "Inapata safu zote za nambari asilia zinazofuatana ambazo jumla yake ni sawa na jumla lengwa iliyotolewa.\n\n  Kazi hii inatambua mfuatano wote unaowezekana wa nambari asilia ambapo jumla ya nambari zote katika mfuatano ni sawa na jumla lengwa. Kazi hii inarudisha vekta ya jozi, kila jozi inawakilisha mwanzo na mwisho wa mfuatano.\n\n  Hoja:\n  - target_sum: Nambari nzima inayowakilisha jumla lengwa (10 <= target_sum <= 2,000,000).\n\n  Inarudisha:\n  - Vekta ya jozi. Kila jozi ina nambari mbili nzima: nambari ya kwanza na ya mwisho katika mfuatano unaoendelea ambao jumla yake ni sawa na jumla lengwa.\n\n  Mfano:\n  - find_sum_sequence_ranges(10000) inarudisha vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "tr": "Verilen hedef toplamına eşit olan ardışık doğal sayıların tüm aralıklarını bulur.\n\n  Fonksiyon, sayılar dizisindeki tüm sayıların toplamının hedef toplamına eşit olduğu tüm olası ardışık doğal sayı dizilerini tanımlar. Fonksiyon, her bir demetin bir dizinin başlangıç ve bitişini temsil ettiği demetlerin bir vektörünü döndürür.\n\n  Argümanlar:\n  - target_sum: Hedef toplamı temsil eden bir tamsayı (10 <= target_sum <= 2,000,000).\n\n  Döndürür:\n  - Bir demetler vektörü. Her demet, hedef toplamına eşit olan ardışık bir dizideki ilk ve son sayıyı içeren iki tamsayı içerir.\n\n  Örnek:\n  - find_sum_sequence_ranges(10000) vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] döndürür.",
      "vi": "Tìm tất cả các dãy số tự nhiên liên tiếp có tổng bằng tổng mục tiêu đã cho.\n\nHàm này xác định tất cả các dãy số tự nhiên liên tiếp có tổng của tất cả các số trong dãy bằng tổng mục tiêu. Hàm trả về một vector các bộ giá trị, mỗi bộ đại diện cho điểm bắt đầu và kết thúc của một dãy.\n\nCác tham số:\n- target_sum: Một số nguyên đại diện cho tổng mục tiêu (10 <= target_sum <= 2,000,000).\n\nTrả về:\n- Một vector các bộ giá trị. Mỗi bộ chứa hai số nguyên: số đầu tiên và số cuối cùng trong một dãy liên tiếp có tổng bằng tổng mục tiêu.\n\nVí dụ:\n- find_sum_sequence_ranges(10000) trả về vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]"
    },
    "docstring_bertscore": {
      "es": "0.984388843832944",
      "arb": "0.9587951206062176",
      "sw": "0.9497606163552268",
      "tr": "0.9626380225880996",
      "vi": "0.9412683730444612"
    }
  },
  {
    "task_id": "Rust/33",
    "prompt": {
      "en": "/*\n  Converts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "es": "/*\n  Convierte una cadena binaria (que consiste en '0's y '1's) en su forma invertida. \n  Cada '0' en la cadena de entrada se reemplaza con un '1', y cada '1' se reemplaza con un '0'.\n\n  Argumentos:\n  - input: Una cadena que consiste en dígitos binarios ('0' y '1').\n\n  Devuelve:\n  - Una nueva cadena que representa la secuencia binaria invertida de la cadena de entrada.\n\n  Ejemplo:\n  - invert_binary_string(\"0110\") devuelve \"1001\"\n  - invert_binary_string(\"1111\") devuelve \"0000\"\n  - invert_binary_string(\"0000\") devuelve \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "arb": "/*\n  يحول سلسلة ثنائية (تتكون من '0' و '1') إلى شكلها المعكوس.\n  يتم استبدال كل '0' في سلسلة الإدخال بـ '1'، وكل '1' يتم استبداله بـ '0'.\n\n  الحجج:\n  - input: سلسلة تتكون من أرقام ثنائية ('0' و '1').\n\n  يعيد:\n  - سلسلة جديدة تمثل التسلسل الثنائي المعكوس لسلسلة الإدخال.\n\n  مثال:\n  - invert_binary_string(\"0110\") يعيد \"1001\"\n  - invert_binary_string(\"1111\") يعيد \"0000\"\n  - invert_binary_string(\"0000\") يعيد \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "sw": "/*\n  Hubadilisha kamba ya binary (inayojumuisha '0's na '1's) kuwa umbo lake lililogeuzwa. \n  Kila '0' katika kamba ya ingizo hubadilishwa na '1', na kila '1' hubadilishwa na '0'.\n\n  Hoja:\n  - input: Kamba inayojumuisha tarakimu za binary ('0' na '1').\n\n  Inarudisha:\n  - Kamba mpya inayowakilisha mlolongo wa binary uliogeuzwa wa kamba ya ingizo.\n\n  Mfano:\n  - invert_binary_string(\"0110\") inarudisha \"1001\"\n  - invert_binary_string(\"1111\") inarudisha \"0000\"\n  - invert_binary_string(\"0000\") inarudisha \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "tr": "/*\n  İkili bir dizeyi ('0' ve '1'lerden oluşan) ters çevrilmiş biçimine dönüştürür. \n  Giriş dizisindeki her '0' bir '1' ile, her '1' ise bir '0' ile değiştirilir.\n\n  Argümanlar:\n  - input: İkili rakamlardan ('0' ve '1') oluşan bir dize.\n\n  Döndürür:\n  - Giriş dizisinin ters çevrilmiş ikili dizisini temsil eden yeni bir dize.\n\n  Örnek:\n  - invert_binary_string(\"0110\") \"1001\" döndürür\n  - invert_binary_string(\"1111\") \"0000\" döndürür\n  - invert_binary_string(\"0000\") \"1111\" döndürür\n*/\nfn invert_binary_string(input: &str) -> String ",
      "vi": "/*\n  Chuyển đổi một chuỗi nhị phân (bao gồm các ký tự '0' và '1') thành dạng đảo ngược của nó.\n  Mỗi '0' trong chuỗi đầu vào được thay thế bằng '1', và mỗi '1' được thay thế bằng '0'.\n\n  Tham số:\n  - input: Một chuỗi bao gồm các chữ số nhị phân ('0' và '1').\n\n  Trả về:\n  - Một chuỗi mới đại diện cho dãy nhị phân đảo ngược của chuỗi đầu vào.\n\n  Ví dụ:\n  - invert_binary_string(\"0110\") trả về \"1001\"\n  - invert_binary_string(\"1111\") trả về \"0000\"\n  - invert_binary_string(\"0000\") trả về \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String "
    },
    "prompt_bertscore": {
      "es": "0.9977705726032644",
      "arb": "0.9770007868103513",
      "sw": "0.9833915206897679",
      "tr": "0.9921989904152358",
      "vi": "0.9625053374935683"
    },
    "canonical_solution": "{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}",
    "instruction": {
      "en": "Write a Rust function `fn invert_binary_string(input: &str) -> String` to solve the following problem:\nConverts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"",
      "es": "Escribe una función en Rust `fn invert_binary_string(input: &str) -> String` para resolver el siguiente problema:\nConvierte una cadena binaria (que consiste en '0's y '1's) en su forma invertida.\n  Cada '0' en la cadena de entrada se reemplaza con un '1', y cada '1' se reemplaza con un '0'.\n\n  Argumentos:\n  - input: Una cadena que consiste en dígitos binarios ('0' y '1').\n\n  Devuelve:\n  - Una nueva cadena que representa la secuencia binaria invertida de la cadena de entrada.\n\n  Ejemplo:\n  - invert_binary_string(\"0110\") devuelve \"1001\"\n  - invert_binary_string(\"1111\") devuelve \"0000\"\n  - invert_binary_string(\"0000\") devuelve \"1111\"",
      "arb": "اكتب دالة بلغة Rust `fn invert_binary_string(input: &str) -> String` لحل المشكلة التالية:\nتحويل سلسلة ثنائية (تتكون من '0's و '1's) إلى شكلها المعكوس.\nيتم استبدال كل '0' في سلسلة الإدخال بـ '1'، وكل '1' يتم استبداله بـ '0'.\n\nالمعطيات:\n- input: سلسلة تتكون من أرقام ثنائية ('0' و '1').\n\nالقيم المعادة:\n- سلسلة جديدة تمثل التسلسل الثنائي المعكوس لسلسلة الإدخال.\n\nمثال:\n- invert_binary_string(\"0110\") يعيد \"1001\"\n- invert_binary_string(\"1111\") يعيد \"0000\"\n- invert_binary_string(\"0000\") يعيد \"1111\"",
      "sw": "Andika kazi ya Rust `fn invert_binary_string(input: &str) -> String` kutatua tatizo lifuatalo:\nHubadilisha kamba ya binary (inayojumuisha '0's na '1's) kuwa fomu yake iliyogeuzwa. \n  Kila '0' katika kamba ya ingizo inabadilishwa na '1', na kila '1' inabadilishwa na '0'.\n\n  Hoja:\n  - input: Kamba inayojumuisha tarakimu za binary ('0' na '1').\n\n  Inarejesha:\n  - Kamba mpya inayowakilisha mlolongo wa binary uliogeuzwa wa kamba ya ingizo.\n\n  Mfano:\n  - invert_binary_string(\"0110\") inarejesha \"1001\"\n  - invert_binary_string(\"1111\") inarejesha \"0000\"\n  - invert_binary_string(\"0000\") inarejesha \"1111\"",
      "tr": "Bir Rust fonksiyonu `fn invert_binary_string(input: &str) -> String` yazın ve aşağıdaki problemi çözün:\nBir ikili dizgiyi ('0' ve '1'lerden oluşan) tersine çevirir.\n  Girdi dizisindeki her '0' bir '1' ile ve her '1' bir '0' ile değiştirilir.\n\n  Argümanlar:\n  - input: İkili rakamlardan ('0' ve '1') oluşan bir dizgi.\n\n  Döndürür:\n  - Girdi dizisinin tersine çevrilmiş ikili dizisini temsil eden yeni bir dizgi.\n\n  Örnek:\n  - invert_binary_string(\"0110\") \"1001\" döndürür\n  - invert_binary_string(\"1111\") \"0000\" döndürür\n  - invert_binary_string(\"0000\") \"1111\" döndürür",
      "vi": "Viết một hàm Rust `fn invert_binary_string(input: &str) -> String` để giải quyết vấn đề sau:\nChuyển đổi một chuỗi nhị phân (bao gồm các ký tự '0' và '1') thành dạng đảo ngược của nó. \n  Mỗi '0' trong chuỗi đầu vào được thay thế bằng '1', và mỗi '1' được thay thế bằng '0'.\n\n  Tham số:\n  - input: Một chuỗi bao gồm các chữ số nhị phân ('0' và '1').\n\n  Trả về:\n  - Một chuỗi mới đại diện cho chuỗi nhị phân đảo ngược của chuỗi đầu vào.\n\n  Ví dụ:\n  - invert_binary_string(\"0110\") trả về \"1001\"\n  - invert_binary_string(\"1111\") trả về \"0000\"\n  - invert_binary_string(\"0000\") trả về \"1111\""
    },
    "instruction_bertscore": {
      "es": "0.9930447585776824",
      "arb": "0.9785600353014752",
      "sw": "0.9860525719044922",
      "tr": "0.9618778641198791",
      "vi": "0.9682499267434783"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n   \n        assert_eq!(invert_binary_string(\"0110100100100\"), \"1001011011011\");\n        assert_eq!(invert_binary_string(\"1000000010000000000\"), \"0111111101111111111\");\n        assert_eq!(invert_binary_string(\"11110000\"), \"00001111\");\n        assert_eq!(invert_binary_string(\"0000\"), \"1111\");\n        println!(\"All test cases passed!\");\n        \n        \n    }\n    \n\n}",
    "entry_point": "invert_binary_string",
    "signature": "fn invert_binary_string(input: &str) -> String",
    "docstring": {
      "en": "Converts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"",
      "es": "Convierte una cadena binaria (que consiste en '0's y '1's) en su forma invertida. \n  Cada '0' en la cadena de entrada se reemplaza con un '1', y cada '1' se reemplaza con un '0'.\n\n  Argumentos:\n  - input: Una cadena que consiste en dígitos binarios ('0' y '1').\n\n  Retorna:\n  - Una nueva cadena que representa la secuencia binaria invertida de la cadena de entrada.\n\n  Ejemplo:\n  - invert_binary_string(\"0110\") retorna \"1001\"\n  - invert_binary_string(\"1111\") retorna \"0000\"\n  - invert_binary_string(\"0000\") retorna \"1111\"",
      "arb": "يقوم بتحويل سلسلة ثنائية (تتكون من '0' و '1') إلى شكلها المعكوس. \nيتم استبدال كل '0' في سلسلة الإدخال بـ '1'، وكل '1' يتم استبداله بـ '0'.\n\nالأوساط:\n- input: سلسلة تتكون من أرقام ثنائية ('0' و '1').\n\nالإرجاع:\n- سلسلة جديدة تمثل التسلسل الثنائي المعكوس لسلسلة الإدخال.\n\nمثال:\n- invert_binary_string(\"0110\") يعيد \"1001\"\n- invert_binary_string(\"1111\") يعيد \"0000\"\n- invert_binary_string(\"0000\") يعيد \"1111\"",
      "sw": "Hubadilisha kamba ya binary (inayojumuisha '0's na '1's) kuwa umbo lake lililogeuzwa. \n  Kila '0' katika mfuatano wa ingizo hubadilishwa na '1', na kila '1' hubadilishwa na '0'.\n\n  Hoja:\n  - input: Mfuatano wa herufi unaojumuisha tarakimu za binary ('0' na '1').\n\n  Inarudisha:\n  - Mfuatano mpya wa herufi unaowakilisha mfuatano wa binary uliogeuzwa wa mfuatano wa ingizo.\n\n  Mfano:\n  - invert_binary_string(\"0110\") inarudisha \"1001\"\n  - invert_binary_string(\"1111\") inarudisha \"0000\"\n  - invert_binary_string(\"0000\") inarudisha \"1111\"",
      "tr": "İkili bir dizeyi (sadece '0' ve '1'lerden oluşan) ters çevrilmiş biçimine dönüştürür. \n  Giriş dizisindeki her '0', '1' ile ve her '1', '0' ile değiştirilir.\n\n  Argümanlar:\n  - input: İkili rakamlardan ('0' ve '1') oluşan bir dize.\n\n  Döndürür:\n  - Giriş dizisinin ters çevrilmiş ikili dizisini temsil eden yeni bir dize.\n\n  Örnek:\n  - invert_binary_string(\"0110\") \"1001\" döndürür\n  - invert_binary_string(\"1111\") \"0000\" döndürür\n  - invert_binary_string(\"0000\") \"1111\" döndürür",
      "vi": "Chuyển đổi một chuỗi nhị phân (gồm các ký tự '0' và '1') thành dạng đảo ngược của nó. \n  Mỗi '0' trong chuỗi đầu vào được thay thế bằng '1', và mỗi '1' được thay thế bằng '0'.\n\n  Tham số:\n  - input: Một chuỗi gồm các chữ số nhị phân ('0' và '1').\n\n  Trả về:\n  - Một chuỗi mới đại diện cho chuỗi nhị phân đảo ngược của chuỗi đầu vào.\n\n  Ví dụ:\n  - invert_binary_string(\"0110\") trả về \"1001\"\n  - invert_binary_string(\"1111\") trả về \"0000\"\n  - invert_binary_string(\"0000\") trả về \"1111\""
    },
    "docstring_bertscore": {
      "es": "0.9973453049574688",
      "arb": "0.9626243170918082",
      "sw": "0.9707347928102248",
      "tr": "0.9826722800800405",
      "vi": "0.9604342185105175"
    }
  },
  {
    "task_id": "Rust/34",
    "prompt": {
      "en": "/*\n  Calculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "es": "/*\n  Calcula la distancia total mínima desde todos los residentes hasta una oficina de correos ubicada dentro de su ciudad. La ciudad está dispuesta en una cuadrícula, con calles que corren de norte a sur y de este a oeste, formando bloques.\n\n  La distancia entre dos puntos (x1, y1) y (x2, y2) se define como |x1 - x2| + |y1 - y2|.\n\n  Argumentos:\n  - residents: Un slice de tuplas, cada una representando las coordenadas (x, y) de la ubicación de un residente.\n\n  Retorna:\n  - La distancia total mínima desde todos los residentes hasta la oficina de correos.\n\n  Ejemplos:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) devuelve 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) devuelve 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "arb": "/*\n  يحسب الحد الأدنى للمسافة الإجمالية من جميع السكان إلى مكتب بريد يقع داخل مدينتهم. المدينة مرتبة في شبكة، مع شوارع تمتد من الشمال إلى الجنوب ومن الشرق إلى الغرب، مكونة كتل.\n\n  المسافة بين نقطتين (x1, y1) و (x2, y2) تُعرف بأنها |x1 - x2| + |y1 - y2|.\n\n  الوسائط:\n  - residents: مجموعة من الأزواج، كل منها يمثل إحداثيات (x, y) لموقع أحد السكان.\n\n  يعيد:\n  - الحد الأدنى للمسافة الإجمالية من جميع السكان إلى مكتب البريد.\n\n  أمثلة:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) يعيد 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) يعيد 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "sw": "/*\n  Inahesabu umbali wa chini kabisa kutoka kwa wakazi wote hadi ofisi ya posta iliyoko ndani ya jiji lao. Jiji limepangwa katika gridi, na barabara zinaelekea kaskazini-kusini na mashariki-magharibi, zikifanyiza vitalu.\n\n  Umbali kati ya pointi mbili (x1, y1) na (x2, y2) unafafanuliwa kama |x1 - x2| + |y1 - y2|.\n\n  Hoja:\n  - residents: Sehemu ya jozi, kila moja ikiwakilisha kuratibu za (x, y) za eneo la mkazi.\n\n  Inarudisha:\n  - Umbali wa chini kabisa kutoka kwa wakazi wote hadi ofisi ya posta.\n\n  Mifano:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) inarudisha 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) inarudisha 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "tr": "/*\n  Bir şehirde bulunan tüm sakinlerden bir postaneye olan minimum toplam mesafeyi hesaplar. Şehir, kuzey-güney ve doğu-batı yönünde uzanan sokaklarla, bloklar oluşturan bir ızgara şeklinde düzenlenmiştir.\n\n  İki nokta (x1, y1) ve (x2, y2) arasındaki mesafe |x1 - x2| + |y1 - y2| olarak tanımlanır.\n\n  Argümanlar:\n  - residents: Her biri bir sakinin konumunu temsil eden (x, y) koordinatlarından oluşan bir dilim.\n\n  Döndürür:\n  - Tüm sakinlerden postaneye olan minimum toplam mesafe.\n\n  Örnekler:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 döndürür\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 döndürür\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "vi": "/*\n  Tính khoảng cách tổng tối thiểu từ tất cả cư dân đến một bưu điện nằm trong thành phố của họ. Thành phố được bố trí theo dạng lưới, với các con đường chạy theo hướng bắc-nam và đông-tây, tạo thành các khối.\n\n  Khoảng cách giữa hai điểm (x1, y1) và (x2, y2) được định nghĩa là |x1 - x2| + |y1 - y2|.\n\n  Tham số:\n  - residents: Một mảng các bộ giá trị, mỗi bộ đại diện cho tọa độ (x, y) của vị trí cư dân.\n\n  Trả về:\n  - Khoảng cách tổng tối thiểu từ tất cả cư dân đến bưu điện.\n\n  Ví dụ:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) trả về 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) trả về 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9894584870480975",
      "arb": "0.9728758296873998",
      "sw": "0.9858203729890624",
      "tr": "0.9690742428247731",
      "vi": "0.9833607329807074"
    },
    "canonical_solution": "{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}",
    "instruction": {
      "en": "Write a Rust function `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` to solve the following problem:\nCalculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2",
      "es": "Escribe una función en Rust `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` para resolver el siguiente problema:\nCalcula la distancia total mínima desde todos los residentes hasta una oficina de correos ubicada dentro de su ciudad. La ciudad está dispuesta en una cuadrícula, con calles que corren de norte a sur y de este a oeste, formando bloques.\n\n  La distancia entre dos puntos (x1, y1) y (x2, y2) se define como |x1 - x2| + |y1 - y2|.\n\n  Argumentos:\n  - residents: Un slice de tuplas, cada una representando las coordenadas (x, y) de la ubicación de un residente.\n\n  Retorna:\n  - La distancia total mínima desde todos los residentes hasta la oficina de correos.\n\n  Ejemplos:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) retorna 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) retorna 2",
      "arb": "اكتب دالة بلغة Rust `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` لحل المشكلة التالية:\nتحسب الحد الأدنى للمسافة الكلية من جميع السكان إلى مكتب بريد يقع داخل مدينتهم. المدينة مرتبة في شبكة، مع شوارع تمتد من الشمال إلى الجنوب ومن الشرق إلى الغرب، مكونة كتل.\n\nالمسافة بين نقطتين (x1, y1) و (x2, y2) تُعرف بأنها |x1 - x2| + |y1 - y2|.\n\nالمعطيات:\n- residents: مقطع من الأزواج، كل منها يمثل إحداثيات (x, y) لموقع أحد السكان.\n\nالقيم المعادة:\n- الحد الأدنى للمسافة الكلية من جميع السكان إلى مكتب البريد.\n\nأمثلة:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) يعيد 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) يعيد 2",
      "sw": "Andika kazi ya Rust `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` kutatua tatizo lifuatalo:\nHesabu umbali wa chini kabisa wa jumla kutoka kwa wakazi wote hadi ofisi ya posta iliyoko ndani ya mji wao. Mji umewekwa katika gridi, na barabara zinazoenda kaskazini-kusini na mashariki-magharibi, zikifanyiza vitalu.\n\n  Umbali kati ya pointi mbili (x1, y1) na (x2, y2) unafafanuliwa kama |x1 - x2| + |y1 - y2|.\n\n  Hoja:\n  - residents: Kipande cha jozi, kila moja ikiwakilisha kuratibu za (x, y) za eneo la mkazi.\n\n  Inarejesha:\n  - Umbali wa chini kabisa wa jumla kutoka kwa wakazi wote hadi ofisi ya posta.\n\n  Mifano:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) inarejesha 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) inarejesha 2",
      "tr": "Bir Rust fonksiyonu `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` yazarak aşağıdaki problemi çözün:\nTüm sakinlerden şehirlerinde bulunan bir postaneye olan minimum toplam mesafeyi hesaplar. Şehir, kuzey-güney ve doğu-batı yönlerinde uzanan sokaklarla, bloklar oluşturan bir ızgara şeklinde düzenlenmiştir.\n\n  İki nokta arasındaki mesafe (x1, y1) ve (x2, y2) olarak tanımlanır: |x1 - x2| + |y1 - y2|.\n\n  Argümanlar:\n  - residents: Her biri bir sakinin konumunun (x, y) koordinatlarını temsil eden bir dilim.\n\n  Döndürür:\n  - Tüm sakinlerden postaneye olan minimum toplam mesafe.\n\n  Örnekler:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 döndürür\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 döndürür",
      "vi": "Viết một hàm Rust `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` để giải quyết vấn đề sau:\nTính khoảng cách tổng tối thiểu từ tất cả cư dân đến một bưu điện nằm trong thành phố của họ. Thành phố được bố trí theo dạng lưới, với các con đường chạy theo hướng bắc-nam và đông-tây, tạo thành các khối.\n\nKhoảng cách giữa hai điểm (x1, y1) và (x2, y2) được định nghĩa là |x1 - x2| + |y1 - y2|.\n\nTham số:\n- residents: Một mảng các bộ giá trị, mỗi bộ đại diện cho tọa độ (x, y) của vị trí cư dân.\n\nTrả về:\n- Khoảng cách tổng tối thiểu từ tất cả cư dân đến bưu điện.\n\nVí dụ:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) trả về 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9882690883264605",
      "arb": "0.9716892117910974",
      "sw": "0.9899318232461036",
      "tr": "0.9713044647430328",
      "vi": "0.984081364003102"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]), 10);\n        assert_eq!(minimum_distance_to_post_office(&[(0, 0), (1, 1)]), 2);\n    \n    }\n\n}",
    "entry_point": "minimum_distance_to_post_office",
    "signature": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32",
    "docstring": {
      "en": "Calculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2",
      "es": "Calcula la distancia total mínima desde todos los residentes a una oficina de correos ubicada dentro de su ciudad. La ciudad está dispuesta en una cuadrícula, con calles que corren de norte a sur y de este a oeste, formando bloques.\n\n  La distancia entre dos puntos (x1, y1) y (x2, y2) se define como |x1 - x2| + |y1 - y2|.\n\n  Argumentos:\n  - residents: Una porción de tuplas, cada una representando las coordenadas (x, y) de la ubicación de un residente.\n\n  Retorna:\n  - La distancia total mínima desde todos los residentes a la oficina de correos.\n\n  Ejemplos:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) devuelve 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) devuelve 2",
      "arb": "يحسب الحد الأدنى للمسافة الإجمالية من جميع السكان إلى مكتب البريد الموجود داخل مدينتهم. المدينة مرتبة في شبكة، مع شوارع تمتد من الشمال إلى الجنوب ومن الشرق إلى الغرب، مكونة كتل.\n\nالمسافة بين نقطتين (x1, y1) و(x2, y2) تُعرف بأنها |x1 - x2| + |y1 - y2|.\n\nالحجج:\n- residents: جزء من الأزواج، كل منها يمثل إحداثيات (x, y) لموقع أحد السكان.\n\nالقيم المعادة:\n- الحد الأدنى للمسافة الإجمالية من جميع السكان إلى مكتب البريد.\n\nأمثلة:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) يعيد 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) يعيد 2",
      "sw": "Hesabu umbali wa chini kabisa wa jumla kutoka kwa wakazi wote hadi ofisi ya posta iliyoko ndani ya jiji lao. Jiji limepangwa katika gridi, na barabara zinazoenda kaskazini-kusini na mashariki-magharibi, zikifanyiza vitalu.\n\n  Umbali kati ya pointi mbili (x1, y1) na (x2, y2) unafafanuliwa kama |x1 - x2| + |y1 - y2|.\n\n  Hoja:\n  - residents: Sehemu ya jozi, kila moja ikiwakilisha kuratibu (x, y) ya eneo la mkazi.\n\n  Inarudisha:\n  - Umbali wa chini kabisa wa jumla kutoka kwa wakazi wote hadi ofisi ya posta.\n\n  Mifano:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) inarudisha 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) inarudisha 2",
      "tr": "Şehrin içindeki bir postaneye tüm sakinlerden olan minimum toplam mesafeyi hesaplar. Şehir, kuzey-güney ve doğu-batı yönünde uzanan sokaklarla bir ızgara şeklinde düzenlenmiştir ve bloklar oluşturur.\n\nİki nokta (x1, y1) ve (x2, y2) arasındaki mesafe |x1 - x2| + |y1 - y2| olarak tanımlanır.\n\nArgümanlar:\n- residents: Her biri bir sakinin konumunun (x, y) koordinatlarını temsil eden bir dilim.\n\nDöndürür:\n- Tüm sakinlerden postaneye olan minimum toplam mesafe.\n\nÖrnekler:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 döndürür\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 döndürür",
      "vi": "Tính toán khoảng cách tổng tối thiểu từ tất cả cư dân đến một bưu điện nằm trong thành phố của họ. Thành phố được bố trí theo dạng lưới, với các con đường chạy theo hướng bắc-nam và đông-tây, tạo thành các khối.\n\nKhoảng cách giữa hai điểm (x1, y1) và (x2, y2) được định nghĩa là |x1 - x2| + |y1 - y2|.\n\nCác đối số:\n- residents: Một danh sách các bộ giá trị, mỗi bộ đại diện cho tọa độ (x, y) của vị trí cư dân.\n\nTrả về:\n- Khoảng cách tổng tối thiểu từ tất cả cư dân đến bưu điện.\n\nVí dụ:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) trả về 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9922337507319169",
      "arb": "0.980334996386403",
      "sw": "0.978280165094597",
      "tr": "0.9686372559864963",
      "vi": "0.9838942541841671"
    }
  },
  {
    "task_id": "Rust/35",
    "prompt": {
      "en": "/*\n  Calculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "es": "/*\n  Calcula el número máximo de misiles que pueden ser interceptados por el sistema, dadas sus alturas en el orden en que son detectados.\n  El sistema de intercepción puede interceptar cualquier altura para el primer misil, pero las intercepciones subsecuentes deben ser a alturas menores o iguales a la intercepción anterior.\n\n  Argumentos:\n  - heights: Un slice de enteros que representa las alturas de los misiles entrantes.\n\n  Devuelve:\n  - Un entero que representa el número máximo de misiles que pueden ser interceptados.\n\n  Ejemplo:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) devuelve 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) devuelve 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) devuelve 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "arb": "/*\n  يحسب العدد الأقصى من الصواريخ التي يمكن للنظام اعتراضها، بالنظر إلى ارتفاعاتها بالترتيب الذي يتم اكتشافها به.\n  يمكن لنظام الاعتراض اعتراض أي ارتفاع للصاروخ الأول، ولكن يجب أن تكون الاعتراضات اللاحقة عند ارتفاعات أقل من أو تساوي الاعتراض السابق.\n\n  الوسائط:\n  - heights: مجموعة من الأعداد الصحيحة تمثل ارتفاعات الصواريخ القادمة.\n\n  يعيد:\n  - عدد صحيح يمثل العدد الأقصى من الصواريخ التي يمكن اعتراضها.\n\n  مثال:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) يعيد 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) يعيد 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) يعيد 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "sw": "/*\n  Inakokotoa idadi kubwa zaidi ya makombora ambayo yanaweza kuzuiliwa na mfumo, kwa kuzingatia urefu wao katika mpangilio yanavyogunduliwa.\n  Mfumo wa kuzuia unaweza kuzuia urefu wowote kwa kombora la kwanza, lakini vizuizi vinavyofuata lazima viwe kwenye urefu ulio sawa au chini ya kizuizi kilichopita.\n\n  Hoja:\n  - heights: Sehemu ya namba nzima inayowakilisha urefu wa makombora yanayokuja.\n\n  Inarudisha:\n  - Namba nzima inayowakilisha idadi kubwa zaidi ya makombora ambayo yanaweza kuzuiliwa.\n\n  Mfano:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) inarudisha 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) inarudisha 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) inarudisha 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "tr": "/*\n  Sistem tarafından tespit edildikleri sıraya göre yükseklikleri verilen füzelerden en fazla kaç tanesinin engellenebileceğini hesaplar.\n  Önleme sistemi, ilk füze için herhangi bir yüksekliği engelleyebilir, ancak sonraki önlemeler, önceki önleme yüksekliğine eşit veya daha az yükseklikte olmalıdır.\n\n  Argümanlar:\n  - heights: Gelen füzelerin yüksekliklerini temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Engellenebilecek maksimum füze sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 döndürür\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 döndürür\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 döndürür\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "vi": "/*\n  Tính toán số lượng tên lửa tối đa có thể bị hệ thống đánh chặn, dựa trên độ cao của chúng theo thứ tự chúng được phát hiện.\n  Hệ thống đánh chặn có thể đánh chặn bất kỳ độ cao nào cho tên lửa đầu tiên, nhưng các lần đánh chặn tiếp theo phải ở độ cao nhỏ hơn hoặc bằng độ cao của lần đánh chặn trước đó.\n\n  Tham số:\n  - heights: Một mảng số nguyên đại diện cho độ cao của các tên lửa đang đến.\n\n  Trả về:\n  - Một số nguyên đại diện cho số lượng tên lửa tối đa có thể bị đánh chặn.\n\n  Ví dụ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) trả về 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) trả về 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) trả về 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9974317091732189",
      "arb": "0.9752180791405632",
      "sw": "0.9883950199880367",
      "tr": "0.9800745919568662",
      "vi": "0.9606898558109094"
    },
    "canonical_solution": "{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_missiles_intercepted(heights: &[i32]) -> i32` to solve the following problem:\nCalculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1",
      "es": "Escribe una función de Rust `fn max_missiles_intercepted(heights: &[i32]) -> i32` para resolver el siguiente problema:\nCalcula el número máximo de misiles que pueden ser interceptados por el sistema, dadas sus alturas en el orden en que son detectados.\n  El sistema de intercepción puede interceptar cualquier altura para el primer misil, pero las intercepciones posteriores deben ser a alturas menores o iguales a la intercepción anterior.\n\n  Argumentos:\n  - heights: Una porción de enteros que representa las alturas de los misiles entrantes.\n\n  Retorna:\n  - Un entero que representa el número máximo de misiles que pueden ser interceptados.\n\n  Ejemplo:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) devuelve 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) devuelve 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) devuelve 1",
      "arb": "اكتب دالة Rust `fn max_missiles_intercepted(heights: &[i32]) -> i32` لحل المشكلة التالية:\nتحسب الحد الأقصى لعدد الصواريخ التي يمكن للنظام اعتراضها، معطى ارتفاعاتها بالترتيب الذي يتم اكتشافها فيه.\nيمكن لنظام الاعتراض اعتراض أي ارتفاع للصاروخ الأول، ولكن يجب أن تكون الاعتراضات اللاحقة عند ارتفاعات أقل من أو تساوي الاعتراض السابق.\n\nالمعطيات:\n- heights: شريحة من الأعداد الصحيحة تمثل ارتفاعات الصواريخ القادمة.\n\nالقيم المعادة:\n- عدد صحيح يمثل الحد الأقصى لعدد الصواريخ التي يمكن اعتراضها.\n\nمثال:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) يعيد 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) يعيد 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) يعيد 1",
      "sw": "Andika kazi ya Rust `fn max_missiles_intercepted(heights: &[i32]) -> i32` kutatua tatizo lifuatalo:\nHesabu idadi kubwa zaidi ya makombora ambayo yanaweza kuzuiliwa na mfumo, ukizingatia urefu wao kwa mpangilio ambao yanagunduliwa.\n  Mfumo wa kuzuia unaweza kuzuia urefu wowote kwa kombora la kwanza, lakini vizuizi vinavyofuata lazima viwe kwa urefu ulio sawa au chini ya kizuizi kilichotangulia.\n\n  Hoja:\n  - heights: Kipande cha nambari za mzima kinachowakilisha urefu wa makombora yanayokuja.\n\n  Inarudisha:\n  - Nambari ya mzima inayowakilisha idadi kubwa zaidi ya makombora ambayo yanaweza kuzuiliwa.\n\n  Mfano:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) inarudisha 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) inarudisha 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) inarudisha 1",
      "tr": "Bir Rust fonksiyonu `fn max_missiles_intercepted(heights: &[i32]) -> i32` yazın ve aşağıdaki problemi çözün:\nSistem tarafından tespit edildikleri sırayla verilen yüksekliklere göre, sistem tarafından engellenebilecek maksimum füze sayısını hesaplar.\n  Önleme sistemi ilk füze için herhangi bir yüksekliği engelleyebilir, ancak sonraki önlemeler önceki önlemenin yüksekliğine eşit veya daha az yükseklikte olmalıdır.\n\n  Argümanlar:\n  - heights: Gelen füzelerin yüksekliklerini temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Engellenebilecek maksimum füze sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 döndürür\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 döndürür\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 döndürür",
      "vi": "Viết một hàm Rust `fn max_missiles_intercepted(heights: &[i32]) -> i32` để giải quyết vấn đề sau:\nTính toán số lượng tối đa tên lửa có thể bị hệ thống đánh chặn, dựa trên độ cao của chúng theo thứ tự chúng được phát hiện.\n  Hệ thống đánh chặn có thể đánh chặn bất kỳ độ cao nào cho tên lửa đầu tiên, nhưng các lần đánh chặn tiếp theo phải ở độ cao nhỏ hơn hoặc bằng độ cao của lần đánh chặn trước đó.\n\n  Tham số:\n  - heights: Một lát cắt của các số nguyên đại diện cho độ cao của các tên lửa đang đến.\n\n  Trả về:\n  - Một số nguyên đại diện cho số lượng tối đa tên lửa có thể bị đánh chặn.\n\n  Ví dụ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) trả về 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) trả về 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) trả về 1"
    },
    "instruction_bertscore": {
      "es": "0.9959757484802332",
      "arb": "0.9820253409290098",
      "sw": "0.9870409566805218",
      "tr": "0.9794560569503236",
      "vi": "0.9725345826927819"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]), 5);\n        assert_eq!(max_missiles_intercepted(&[500, 400, 300, 200, 100]), 5);\n        assert_eq!(max_missiles_intercepted(&[100, 200, 300, 400, 500]), 1);\n    }\n    \n\n}",
    "entry_point": "max_missiles_intercepted",
    "signature": "fn max_missiles_intercepted(heights: &[i32]) -> i32",
    "docstring": {
      "en": "Calculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1",
      "es": "Calcula el número máximo de misiles que pueden ser interceptados por el sistema, dadas sus alturas en el orden en que son detectados. El sistema de intercepción puede interceptar cualquier altura para el primer misil, pero las intercepciones posteriores deben ser a alturas menores o iguales a la intercepción anterior.\n\n  Argumentos:\n  - heights: Una secuencia de enteros que representa las alturas de los misiles entrantes.\n\n  Retorna:\n  - Un entero que representa el número máximo de misiles que pueden ser interceptados.\n\n  Ejemplo:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) retorna 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) retorna 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) retorna 1",
      "arb": "يحسب الحد الأقصى لعدد الصواريخ التي يمكن اعتراضها بواسطة النظام، بالنظر إلى ارتفاعاتها بالترتيب الذي يتم اكتشافها فيه. يمكن لنظام الاعتراض اعتراض أي ارتفاع للصاروخ الأول، ولكن يجب أن تكون الاعتراضات اللاحقة عند ارتفاعات أقل من أو تساوي الاعتراض السابق.\n\n  الحجج:\n  - heights: شريحة من الأعداد الصحيحة تمثل ارتفاعات الصواريخ القادمة.\n\n  يعيد:\n  - عدد صحيح يمثل الحد الأقصى لعدد الصواريخ التي يمكن اعتراضها.\n\n  مثال:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) يعيد 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) يعيد 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) يعيد 1",
      "sw": "Hesabu idadi kubwa zaidi ya makombora ambayo yanaweza kuzuiwa na mfumo, kutokana na urefu wao kwa mpangilio wanavyogunduliwa. Mfumo wa kuzuia unaweza kuzuia urefu wowote kwa kombora la kwanza, lakini vizuizi vinavyofuata lazima viwe kwenye urefu ulio sawa au chini ya kizuizi kilichopita.\n\nHoja:\n- heights: Sehemu ya nambari za mzima zinazowakilisha urefu wa makombora yanayokuja.\n\nRudisha:\n- Nambari ya mzima inayowakilisha idadi kubwa zaidi ya makombora ambayo yanaweza kuzuiwa.\n\nMfano:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) inarudisha 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) inarudisha 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) inarudisha 1",
      "tr": "Füze sisteminin tespit edildikleri sıraya göre yükseklikleri verilen füzelerden en fazla kaç tanesini engelleyebileceğini hesaplar. \n  Önleme sistemi, ilk füze için herhangi bir yüksekliği engelleyebilir, ancak sonraki önlemeler, önceki önlemeden daha az veya ona eşit yüksekliklerde olmalıdır.\n\n  Argümanlar:\n  - heights: Gelen füzelerin yüksekliklerini temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Engellenebilecek maksimum füze sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 döndürür\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 döndürür\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 döndürür",
      "vi": "Tính toán số lượng tên lửa tối đa có thể bị hệ thống đánh chặn, dựa trên độ cao của chúng theo thứ tự được phát hiện. Hệ thống đánh chặn có thể đánh chặn bất kỳ độ cao nào cho tên lửa đầu tiên, nhưng các lần đánh chặn tiếp theo phải ở độ cao nhỏ hơn hoặc bằng lần đánh chặn trước đó.\n\n  Tham số:\n  - heights: Một mảng số nguyên đại diện cho độ cao của các tên lửa đang tới.\n\n  Trả về:\n  - Một số nguyên đại diện cho số lượng tối đa tên lửa có thể bị đánh chặn.\n\n  Ví dụ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) trả về 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) trả về 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) trả về 1"
    },
    "docstring_bertscore": {
      "es": "0.9948870553617809",
      "arb": "0.9764142312951553",
      "sw": "0.9768939236653545",
      "tr": "0.9803137429356322",
      "vi": "0.9615721719634663"
    }
  },
  {
    "task_id": "Rust/36",
    "prompt": {
      "en": "/*\n  Calculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "es": "/*\n  Calcula el número de caminos que un peón puede tomar para moverse desde el origen (0, 0) hasta un punto dado (n, m) en un tablero de ajedrez,\n  evitando los puntos de control de un caballo estacionario ubicado en (horse_x, horse_y).\n\n  El peón solo puede moverse un paso a la derecha o un paso hacia abajo a la vez. Los puntos de control del caballo incluyen su \n  posición actual y todos los puntos que puede alcanzar en un movimiento. El peón debe evitar estos puntos de control.\n\n  Argumentos:\n  - n: coordenada x del punto de destino, un entero que no excede 15.\n  - m: coordenada y del punto de destino, un entero que no excede 15.\n  - horse_x: coordenada x de la posición del caballo, un entero.\n  - horse_y: coordenada y de la posición del caballo, un entero.\n\n  Retorna:\n  - El número total de caminos válidos desde (0, 0) hasta (n, m) evitando los puntos de control del caballo.\n\n  Ejemplos:\n  - count_paths(6, 6, 3, 3) retorna 6\n  - count_paths(5, 5, 1, 1) retorna 12\n  - count_paths(7, 7, 2, 2) retorna 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "arb": "/*\n  يحسب عدد المسارات التي يمكن أن يأخذها البيدق للانتقال من الأصل (0, 0) إلى نقطة معينة (n, m) على لوحة الشطرنج،\n  متجنبًا نقاط التحكم الخاصة بالحصان الثابت الموجود في (horse_x, horse_y).\n\n  يمكن للبيدق التحرك خطوة واحدة فقط إما إلى اليمين أو إلى الأسفل في كل مرة. تشمل نقاط التحكم الخاصة بالحصان موقعه الحالي\n  وجميع النقاط التي يمكنه الوصول إليها في حركة واحدة. يجب على البيدق تجنب هذه النقاط.\n\n  الوسائط:\n  - n: الإحداثي x للنقطة الهدف، عدد صحيح لا يتجاوز 15.\n  - m: الإحداثي y للنقطة الهدف، عدد صحيح لا يتجاوز 15.\n  - horse_x: الإحداثي x لموقع الحصان، عدد صحيح.\n  - horse_y: الإحداثي y لموقع الحصان، عدد صحيح.\n\n  يعيد:\n  - العدد الإجمالي للمسارات الصالحة من (0, 0) إلى (n, m) متجنبًا نقاط التحكم الخاصة بالحصان.\n\n  أمثلة:\n  - count_paths(6, 6, 3, 3) يعيد 6\n  - count_paths(5, 5, 1, 1) يعيد 12\n  - count_paths(7, 7, 2, 2) يعيد 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "sw": "/*\n  Inahesabu idadi ya njia ambazo pawn inaweza kuchukua kusonga kutoka mwanzo (0, 0) hadi kwenye nukta fulani (n, m) kwenye ubao wa chess,\n  ikiepuka sehemu za udhibiti za farasi aliyesimama aliye katika (horse_x, horse_y).\n\n  Pawn inaweza kusonga hatua moja tu kulia au hatua moja chini kwa wakati mmoja. Sehemu za udhibiti za farasi ni pamoja na nafasi yake ya sasa \n  na pointi zote ambazo inaweza kufikia kwa hatua moja. Pawn lazima iepuke sehemu hizi za udhibiti.\n\n  Hoja:\n  - n: x-kiwianzo cha nukta ya mwisho, namba kamili isiyozidi 15.\n  - m: y-kiwianzo cha nukta ya mwisho, namba kamili isiyozidi 15.\n  - horse_x: x-kiwianzo cha nafasi ya farasi, namba kamili.\n  - horse_y: y-kiwianzo cha nafasi ya farasi, namba kamili.\n\n  Inarudisha:\n  - Jumla ya idadi ya njia halali kutoka (0, 0) hadi (n, m) ikiepuka sehemu za udhibiti za farasi.\n\n  Mifano:\n  - count_paths(6, 6, 3, 3) inarudisha 6\n  - count_paths(5, 5, 1, 1) inarudisha 12\n  - count_paths(7, 7, 2, 2) inarudisha 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "tr": "/*\n  Bir piyonun, bir satranç tahtasında orijinden (0, 0) belirli bir noktaya (n, m) hareket etmek için kaç farklı yol alabileceğini hesaplar,\n  (horse_x, horse_y) konumunda sabit duran bir atın kontrol noktalarından kaçınarak.\n\n  Piyon sadece bir adım sağa veya bir adım aşağıya hareket edebilir. Atın kontrol noktaları, mevcut konumu ve bir hamlede ulaşabileceği tüm noktaları içerir.\n  Piyon bu kontrol noktalarından kaçınmalıdır.\n\n  Argümanlar:\n  - n: Varış noktasının x-koordinatı, 15'i aşmayan bir tam sayı.\n  - m: Varış noktasının y-koordinatı, 15'i aşmayan bir tam sayı.\n  - horse_x: Atın konumunun x-koordinatı, bir tam sayı.\n  - horse_y: Atın konumunun y-koordinatı, bir tam sayı.\n\n  Döndürür:\n  - Atın kontrol noktalarından kaçınarak (0, 0) ile (n, m) arasında geçerli toplam yol sayısı.\n\n  Örnekler:\n  - count_paths(6, 6, 3, 3) 6 döndürür\n  - count_paths(5, 5, 1, 1) 12 döndürür\n  - count_paths(7, 7, 2, 2) 28 döndürür\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "vi": "/*\n  Tính số đường đi mà một quân tốt có thể thực hiện để di chuyển từ điểm gốc (0, 0) đến một điểm cho trước (n, m) trên bàn cờ,\n  tránh các điểm kiểm soát của một con mã đứng yên tại vị trí (horse_x, horse_y).\n\n  Quân tốt chỉ có thể di chuyển một bước sang phải hoặc một bước xuống dưới mỗi lần. Các điểm kiểm soát của con mã bao gồm vị trí hiện tại của nó\n  và tất cả các điểm mà nó có thể đến trong một nước đi. Quân tốt phải tránh các điểm kiểm soát này.\n\n  Tham số:\n  - n: tọa độ x của điểm đích, một số nguyên không vượt quá 15.\n  - m: tọa độ y của điểm đích, một số nguyên không vượt quá 15.\n  - horse_x: tọa độ x của vị trí con mã, một số nguyên.\n  - horse_y: tọa độ y của vị trí con mã, một số nguyên.\n\n  Trả về:\n  - Tổng số đường đi hợp lệ từ (0, 0) đến (n, m) tránh các điểm kiểm soát của con mã.\n\n  Ví dụ:\n  - count_paths(6, 6, 3, 3) trả về 6\n  - count_paths(5, 5, 1, 1) trả về 12\n  - count_paths(7, 7, 2, 2) trả về 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.984223980616685",
      "arb": "0.9606910475931957",
      "sw": "0.9510572754826225",
      "tr": "0.9430337998710993",
      "vi": "0.9660111637188341"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` to solve the following problem:\nCalculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28",
      "es": "Escribe una función en Rust `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` para resolver el siguiente problema:\nCalcula el número de caminos que un peón puede tomar para moverse desde el origen (0, 0) hasta un punto dado (n, m) en un tablero de ajedrez,\nevitando los puntos de control de un caballo estacionario ubicado en (horse_x, horse_y).\n\nEl peón solo puede moverse un paso a la derecha o un paso hacia abajo a la vez. Los puntos de control del caballo incluyen su \nposición actual y todos los puntos a los que puede llegar en un movimiento. El peón debe evitar estos puntos de control.\n\nArgumentos:\n- n: coordenada x del punto de destino, un entero que no excede 15.\n- m: coordenada y del punto de destino, un entero que no excede 15.\n- horse_x: coordenada x de la posición del caballo, un entero.\n- horse_y: coordenada y de la posición del caballo, un entero.\n\nDevuelve:\n- El número total de caminos válidos desde (0, 0) hasta (n, m) evitando los puntos de control del caballo.\n\nEjemplos:\n- count_paths(6, 6, 3, 3) devuelve 6\n- count_paths(5, 5, 1, 1) devuelve 12\n- count_paths(7, 7, 2, 2) devuelve 28",
      "arb": "اكتب دالة بلغة Rust `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` لحل المشكلة التالية:\nتحسب عدد المسارات التي يمكن أن يسلكها بيدق للتحرك من النقطة الأصل (0, 0) إلى نقطة معينة (n, m) على رقعة الشطرنج،\nمع تجنب نقاط التحكم لحصان ثابت يقع في (horse_x, horse_y).\n\nيمكن للبيدق أن يتحرك إما خطوة واحدة إلى اليمين أو خطوة واحدة إلى الأسفل في كل مرة. تشمل نقاط التحكم للحصان موقعه الحالي وجميع النقاط التي يمكنه الوصول إليها في حركة واحدة. يجب على البيدق تجنب هذه النقاط.\n\nالمعطيات:\n- n: الإحداثي السيني للنقطة المستهدفة، عدد صحيح لا يتجاوز 15.\n- m: الإحداثي الصادي للنقطة المستهدفة، عدد صحيح لا يتجاوز 15.\n- horse_x: الإحداثي السيني لموقع الحصان، عدد صحيح.\n- horse_y: الإحداثي الصادي لموقع الحصان، عدد صحيح.\n\nالقيم المعادة:\n- العدد الإجمالي للمسارات الصحيحة من (0, 0) إلى (n, m) مع تجنب نقاط التحكم للحصان.\n\nأمثلة:\n- count_paths(6, 6, 3, 3) يعيد 6\n- count_paths(5, 5, 1, 1) يعيد 12\n- count_paths(7, 7, 2, 2) يعيد 28",
      "sw": "Andika kazi ya Rust `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` kutatua tatizo lifuatalo:\nInahesabu idadi ya njia ambazo pawn inaweza kuchukua kutoka kwenye asili (0, 0) hadi kwenye nukta fulani (n, m) kwenye ubao wa chess,\n  ikiepuka maeneo ya udhibiti ya farasi aliye kwenye (horse_x, horse_y).\n\n  Pawn inaweza kusonga hatua moja tu kulia au hatua moja chini kwa wakati mmoja. Maeneo ya udhibiti ya farasi ni pamoja na \n  nafasi yake ya sasa na maeneo yote ambayo inaweza kufikia kwa hatua moja. Pawn lazima iepuke maeneo haya ya udhibiti.\n\n  Hoja:\n  - n: x-kiwiko cha nukta ya mwisho, namba isiyozidi 15.\n  - m: y-kiwiko cha nukta ya mwisho, namba isiyozidi 15.\n  - horse_x: x-kiwiko cha nafasi ya farasi, namba.\n  - horse_y: y-kiwiko cha nafasi ya farasi, namba.\n\n  Inarudisha:\n  - Jumla ya idadi ya njia halali kutoka (0, 0) hadi (n, m) ikiepuka maeneo ya udhibiti ya farasi.\n\n  Mifano:\n  - count_paths(6, 6, 3, 3) inarudisha 6\n  - count_paths(5, 5, 1, 1) inarudisha 12\n  - count_paths(7, 7, 2, 2) inarudisha 28",
      "tr": "Rust dilinde `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` fonksiyonunu aşağıdaki problemi çözmek için yazın:\nBir piyondan, bir satranç tahtasında başlangıç noktası (0, 0) ile verilen bir nokta (n, m) arasında hareket edebileceği yolların sayısını hesaplar,\n  (horse_x, horse_y) konumunda duran bir atın kontrol noktalarından kaçınarak.\n\n  Piyon sadece bir adım sağa veya bir adım aşağıya hareket edebilir. Atın kontrol noktaları, mevcut konumunu ve bir hamlede ulaşabileceği tüm noktaları içerir. Piyon bu kontrol noktalarından kaçınmalıdır.\n\n  Argümanlar:\n  - n: Varış noktasının x-koordinatı, 15'i aşmayan bir tam sayı.\n  - m: Varış noktasının y-koordinatı, 15'i aşmayan bir tam sayı.\n  - horse_x: Atın konumunun x-koordinatı, bir tam sayı.\n  - horse_y: Atın konumunun y-koordinatı, bir tam sayı.\n\n  Döndürür:\n  - Atın kontrol noktalarından kaçınarak (0, 0) ile (n, m) arasında geçerli yolların toplam sayısı.\n\n  Örnekler:\n  - count_paths(6, 6, 3, 3) 6 döndürür\n  - count_paths(5, 5, 1, 1) 12 döndürür\n  - count_paths(7, 7, 2, 2) 28 döndürür",
      "vi": "Viết một hàm Rust `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` để giải quyết vấn đề sau:\nTính toán số lượng đường đi mà một quân tốt có thể thực hiện để di chuyển từ điểm gốc (0, 0) đến một điểm cho trước (n, m) trên bàn cờ,\ntránh các điểm kiểm soát của một con ngựa đứng yên tại vị trí (horse_x, horse_y).\n\nQuân tốt chỉ có thể di chuyển một bước sang phải hoặc một bước xuống dưới mỗi lần. Các điểm kiểm soát của con ngựa bao gồm vị trí hiện tại của nó và tất cả các điểm mà nó có thể đạt được trong một nước đi. Quân tốt phải tránh các điểm kiểm soát này.\n\nTham số:\n- n: tọa độ x của điểm đích, một số nguyên không vượt quá 15.\n- m: tọa độ y của điểm đích, một số nguyên không vượt quá 15.\n- horse_x: tọa độ x của vị trí con ngựa, một số nguyên.\n- horse_y: tọa độ y của vị trí con ngựa, một số nguyên.\n\nTrả về:\n- Tổng số đường đi hợp lệ từ (0, 0) đến (n, m) tránh các điểm kiểm soát của con ngựa.\n\nVí dụ:\n- count_paths(6, 6, 3, 3) trả về 6\n- count_paths(5, 5, 1, 1) trả về 12\n- count_paths(7, 7, 2, 2) trả về 28"
    },
    "instruction_bertscore": {
      "es": "0.9839655624909587",
      "arb": "0.9489472249448889",
      "sw": "0.9553510684294537",
      "tr": "0.9525938801103084",
      "vi": "0.9806244008515708"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_paths(6, 6, 3, 3), 6);\n        assert_eq!(count_paths(5, 5, 1, 1), 10);\n        assert_eq!(count_paths(7, 7, 2, 2), 0);\n    }\n    \n\n}",
    "entry_point": "count_paths",
    "signature": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize",
    "docstring": {
      "en": "Calculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28",
      "es": "Calcula el número de caminos que un peón puede tomar para moverse desde el origen (0, 0) hasta un punto dado (n, m) en un tablero de ajedrez,\n  evitando los puntos de control de un caballo estacionario ubicado en (horse_x, horse_y).\n\n  El peón solo puede moverse un paso a la derecha o un paso hacia abajo a la vez. Los puntos de control del caballo incluyen su \n  posición actual y todos los puntos a los que puede llegar en un movimiento. El peón debe evitar estos puntos de control.\n\n  Argumentos:\n  - n: coordenada x del punto de destino, un entero que no excede 15.\n  - m: coordenada y del punto de destino, un entero que no excede 15.\n  - horse_x: coordenada x de la posición del caballo, un entero.\n  - horse_y: coordenada y de la posición del caballo, un entero.\n\n  Devuelve:\n  - El número total de caminos válidos desde (0, 0) hasta (n, m) evitando los puntos de control del caballo.\n\n  Ejemplos:\n  - count_paths(6, 6, 3, 3) devuelve 6\n  - count_paths(5, 5, 1, 1) devuelve 12\n  - count_paths(7, 7, 2, 2) devuelve 28",
      "arb": "يحسب عدد المسارات التي يمكن أن يسلكها البيدق للتحرك من الأصل (0, 0) إلى نقطة معينة (n, m) على رقعة الشطرنج، متجنبًا نقاط التحكم لحصان ثابت يقع في (horse_x, horse_y).\n\nيمكن للبيدق التحرك خطوة واحدة فقط إما إلى اليمين أو خطوة واحدة إلى الأسفل في كل مرة. تشمل نقاط التحكم الخاصة بالحصان موقعه الحالي وجميع النقاط التي يمكنه الوصول إليها في حركة واحدة. يجب على البيدق تجنب هذه النقاط.\n\nالمعطيات:\n- n: الإحداثي السيني للنقطة الوجهة، عدد صحيح لا يتجاوز 15.\n- m: الإحداثي الصادي للنقطة الوجهة، عدد صحيح لا يتجاوز 15.\n- horse_x: الإحداثي السيني لموقع الحصان، عدد صحيح.\n- horse_y: الإحداثي الصادي لموقع الحصان، عدد صحيح.\n\nالقيم المعادة:\n- العدد الإجمالي للمسارات الصالحة من (0, 0) إلى (n, m) متجنبًا نقاط التحكم الخاصة بالحصان.\n\nأمثلة:\n- count_paths(6, 6, 3, 3) يعيد 6\n- count_paths(5, 5, 1, 1) يعيد 12\n- count_paths(7, 7, 2, 2) يعيد 28",
      "sw": "Hesabu idadi ya njia ambazo pawn inaweza kuchukua kuhamia kutoka asili (0, 0) hadi kwenye nukta fulani (n, m) kwenye ubao wa chess,\n  kuepuka pointi za udhibiti za farasi aliyesimama mahali pake kwenye (horse_x, horse_y).\n\n  Pawn inaweza kusonga hatua moja tu kulia au hatua moja chini kwa wakati mmoja. Pointi za udhibiti za farasi ni pamoja na nafasi yake ya sasa na pointi zote ambazo inaweza kufikia kwa hatua moja. Pawn lazima iepuke pointi hizi za udhibiti.\n\n  Hoja:\n  - n: x-kiwango cha nukta ya mwisho, namba kamili isiyozidi 15.\n  - m: y-kiwango cha nukta ya mwisho, namba kamili isiyozidi 15.\n  - horse_x: x-kiwango cha nafasi ya farasi, namba kamili.\n  - horse_y: y-kiwango cha nafasi ya farasi, namba kamili.\n\n  Inarejesha:\n  - Jumla ya idadi ya njia halali kutoka (0, 0) hadi (n, m) kuepuka pointi za udhibiti za farasi.\n\n  Mifano:\n  - count_paths(6, 6, 3, 3) inarejesha 6\n  - count_paths(5, 5, 1, 1) inarejesha 12\n  - count_paths(7, 7, 2, 2) inarejesha 28",
      "tr": "Hesaplar, bir piyonun bir satranç tahtasında orijinden (0, 0) verilen bir noktaya (n, m) hareket etmek için kaç farklı yol alabileceğini,\n  (horse_x, horse_y) konumunda duran bir atın kontrol noktalarından kaçınarak.\n\n  Piyon yalnızca bir adım sağa veya bir adım aşağıya hareket edebilir. Atın kontrol noktaları, mevcut konumunu ve bir hamlede ulaşabileceği tüm noktaları içerir. Piyon bu kontrol noktalarından kaçınmalıdır.\n\n  Argümanlar:\n  - n: Varış noktasının x-koordinatı, 15'i geçmeyen bir tamsayı.\n  - m: Varış noktasının y-koordinatı, 15'i geçmeyen bir tamsayı.\n  - horse_x: Atın konumunun x-koordinatı, bir tamsayı.\n  - horse_y: Atın konumunun y-koordinatı, bir tamsayı.\n\n  Döndürür:\n  - Atın kontrol noktalarından kaçınarak (0, 0) ile (n, m) arasındaki geçerli yolların toplam sayısı.\n\n  Örnekler:\n  - count_paths(6, 6, 3, 3) döndürür 6\n  - count_paths(5, 5, 1, 1) döndürür 12\n  - count_paths(7, 7, 2, 2) döndürür 28",
      "vi": "Tính toán số lượng đường đi mà một quân tốt có thể thực hiện để di chuyển từ điểm gốc (0, 0) đến một điểm cho trước (n, m) trên bàn cờ, tránh các điểm kiểm soát của một con ngựa đứng yên tại vị trí (horse_x, horse_y).\n\nQuân tốt chỉ có thể di chuyển một bước sang phải hoặc một bước xuống dưới tại một thời điểm. Các điểm kiểm soát của con ngựa bao gồm vị trí hiện tại của nó và tất cả các điểm mà nó có thể đạt tới trong một nước đi. Quân tốt phải tránh các điểm kiểm soát này.\n\nTham số:\n- n: tọa độ x của điểm đích, một số nguyên không vượt quá 15.\n- m: tọa độ y của điểm đích, một số nguyên không vượt quá 15.\n- horse_x: tọa độ x của vị trí con ngựa, một số nguyên.\n- horse_y: tọa độ y của vị trí con ngựa, một số nguyên.\n\nTrả về:\n- Tổng số đường đi hợp lệ từ (0, 0) đến (n, m) tránh các điểm kiểm soát của con ngựa.\n\nVí dụ:\n- count_paths(6, 6, 3, 3) trả về 6\n- count_paths(5, 5, 1, 1) trả về 12\n- count_paths(7, 7, 2, 2) trả về 28"
    },
    "docstring_bertscore": {
      "es": "0.9819574093386959",
      "arb": "0.9423248880411857",
      "sw": "0.956474521864587",
      "tr": "0.950263151219245",
      "vi": "0.9564028162970334"
    }
  },
  {
    "task_id": "Rust/37",
    "prompt": {
      "en": "\n/*\n  Calculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "es": "/*\n  Calcula la diferencia entre el k-ésimo número más grande y el k-ésimo número más pequeño en una lista dada de enteros.\n  Si el k-ésimo número más grande o más pequeño no existe, la función devuelve None.\n\n  Argumentos:\n  - numbers: Un Vec<i32> que representa la secuencia de enteros no negativos.\n  - k: Un valor usize que representa la posición k-ésima.\n\n  Devuelve:\n  - Un valor Option<i32> que representa la diferencia si ambos números k-ésimo más grande y más pequeño existen, de lo contrario None.\n\n  Ejemplo:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) devuelve Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) devuelve None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "arb": "/*\n  يحسب الفرق بين الرقم الأكبر في المرتبة k والرقم الأصغر في المرتبة k في قائمة معينة من الأعداد الصحيحة.\n  إذا لم يكن هناك رقم أكبر أو أصغر في المرتبة k، فإن الدالة تعيد None.\n\n  الوسائط:\n  - numbers: يمثل Vec<i32> تسلسل الأعداد الصحيحة غير السالبة.\n  - k: قيمة usize تمثل المرتبة k.\n\n  يعيد:\n  - قيمة Option<i32> تمثل الفرق إذا كان كلا الرقمين الأكبر والأصغر في المرتبة k موجودين، وإلا يعيد None.\n\n  مثال:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) يعيد Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) يعيد None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "sw": "/*\n  Inahesabu tofauti kati ya nambari ya k kubwa zaidi na ya k ndogo zaidi katika orodha iliyotolewa ya nambari za mzima.\n  Ikiwa nambari ya k kubwa zaidi au ndogo zaidi haipo, kazi inarudisha None.\n\n  Hoja:\n  - numbers: A Vec<i32> inayowakilisha mlolongo wa nambari zisizo hasi.\n  - k: Thamani ya usize inayowakilisha nafasi ya k.\n\n  Inarudisha:\n  - Thamani ya Option<i32> inayowakilisha tofauti ikiwa nambari zote mbili za k kubwa zaidi na ndogo zaidi zipo, vinginevyo None.\n\n  Mfano:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) inarudisha Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) inarudisha None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "tr": "/*\n  Verilen bir tamsayı listesindeki k. en büyük ve k. en küçük sayı arasındaki farkı hesaplar.\n  Eğer k. en büyük veya en küçük sayı yoksa, fonksiyon None döner.\n\n  Argümanlar:\n  - numbers: Negatif olmayan tamsayıları temsil eden bir Vec<i32>.\n  - k: k. pozisyonu temsil eden bir usize değeri.\n\n  Döner:\n  - Eğer hem k. en büyük hem de en küçük sayılar mevcutsa farkı temsil eden bir Option<i32> değeri, aksi takdirde None.\n\n  Örnek:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) Some(4) döner // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) None döner\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "vi": "/*\n  Tính toán sự khác biệt giữa số lớn thứ k và số nhỏ thứ k trong một danh sách số nguyên đã cho.\n  Nếu số lớn thứ k hoặc số nhỏ thứ k không tồn tại, hàm trả về None.\n\n  Tham số:\n  - numbers: Một Vec<i32> đại diện cho dãy số nguyên không âm.\n  - k: Một giá trị usize đại diện cho vị trí thứ k.\n\n  Trả về:\n  - Một giá trị Option<i32> đại diện cho sự khác biệt nếu cả số lớn thứ k và nhỏ thứ k đều tồn tại, nếu không thì trả về None.\n\n  Ví dụ:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) trả về Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) trả về None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> "
    },
    "prompt_bertscore": {
      "es": "0.97161293772478",
      "arb": "0.9378368345817024",
      "sw": "0.9624785223921286",
      "tr": "0.9773132323997192",
      "vi": "0.9532785590337357"
    },
    "canonical_solution": "{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}",
    "instruction": {
      "en": "Write a Rust function `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` to solve the following problem:\nCalculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None",
      "es": "Escribe una función en Rust `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` para resolver el siguiente problema:\nCalcula la diferencia entre el k-ésimo número más grande y el k-ésimo número más pequeño en una lista dada de enteros.\nSi el k-ésimo número más grande o más pequeño no existe, la función devuelve None.\n\nArgumentos:\n- numbers: Un Vec<i32> que representa la secuencia de enteros no negativos.\n- k: Un valor usize que representa la posición k-ésima.\n\nDevuelve:\n- Un valor Option<i32> que representa la diferencia si ambos números k-ésimo más grande y más pequeño existen, de lo contrario None.\n\nEjemplo:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) devuelve Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) devuelve None",
      "arb": "اكتب دالة بلغة Rust `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` لحل المشكلة التالية:\nتحسب الفرق بين العدد k الأكبر والعدد k الأصغر في قائمة معينة من الأعداد الصحيحة.\nإذا لم يكن العدد k الأكبر أو الأصغر موجودًا، تعيد الدالة None.\n\nالمعاملات:\n- numbers: عبارة عن Vec<i32> تمثل تسلسل الأعداد الصحيحة غير السالبة.\n- k: قيمة من نوع usize تمثل الموضع k.\n\nالقيم المعادة:\n- قيمة من نوع Option<i32> تمثل الفرق إذا كان كلا العددين k الأكبر والأصغر موجودين، وإلا تعيد None.\n\nمثال:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) تعيد Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) تعيد None",
      "sw": "Andika kazi ya Rust `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` kutatua tatizo lifuatalo:  \nHesabu tofauti kati ya nambari ya k kubwa zaidi na ya k ndogo zaidi katika orodha iliyotolewa ya nambari za mzima.  \nIkiwa nambari ya k kubwa au ndogo haipo, kazi inarudisha None.\n\nHoja:  \n- numbers: A Vec<i32> inayoonyesha mlolongo wa nambari zisizo hasi.  \n- k: Thamani ya usize inayoonyesha nafasi ya k.\n\nInarudisha:  \n- Thamani ya Option<i32> inayoonyesha tofauti ikiwa nambari zote za k kubwa na ndogo zipo, vinginevyo None.\n\nMfano:  \n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) inarudisha Some(4) // (5 - 1)  \n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) inarudisha None",
      "tr": "Bir Rust fonksiyonu `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` yazarak aşağıdaki problemi çözün:\nVerilen bir tamsayı listesindeki k. en büyük ve k. en küçük sayıların farkını hesaplar.\n  Eğer k. en büyük veya en küçük sayı mevcut değilse, fonksiyon None döndürür.\n\n  Argümanlar:\n  - numbers: Negatif olmayan tamsayıların dizisini temsil eden bir Vec<i32>.\n  - k: k. pozisyonu temsil eden bir usize değeri.\n\n  Döndürür:\n  - Eğer hem k. en büyük hem de en küçük sayılar mevcutsa farkı temsil eden bir Option<i32> değeri, aksi takdirde None.\n\n  Örnek:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) Some(4) döndürür // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) None döndürür",
      "vi": "Viết một hàm Rust `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` để giải quyết vấn đề sau:\nTính toán sự khác biệt giữa số lớn thứ k và số nhỏ thứ k trong một danh sách các số nguyên đã cho.\nNếu số lớn thứ k hoặc nhỏ thứ k không tồn tại, hàm trả về None.\n\nCác tham số:\n- numbers: Một Vec<i32> đại diện cho dãy số nguyên không âm.\n- k: Một giá trị usize đại diện cho vị trí thứ k.\n\nTrả về:\n- Một giá trị Option<i32> đại diện cho sự khác biệt nếu cả hai số lớn thứ k và nhỏ thứ k tồn tại, nếu không thì trả về None.\n\nVí dụ:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) trả về Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) trả về None"
    },
    "instruction_bertscore": {
      "es": "0.9714701224808159",
      "arb": "0.9603819787203054",
      "sw": "0.9708017312486336",
      "tr": "0.9687059820983344",
      "vi": "0.9589806413821043"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n     \n        assert_eq!(kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2), Some(4)); // 5 - 1 = 4\n        assert_eq!(kth_largest_minus_kth_smallest(vec![10, 20, 30], 4), None);\n        assert_eq!(kth_largest_minus_kth_smallest(vec![7, 7, 7, 7], 1), Some(0)); // 7 - 7 = 0\n        \n        \n    }\n    \n\n}",
    "entry_point": "kth_largest_minus_kth_smallest",
    "signature": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>",
    "docstring": {
      "en": "Calculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None",
      "es": "Calcula la diferencia entre el k-ésimo número más grande y el k-ésimo número más pequeño en una lista dada de enteros.\n  Si el k-ésimo número más grande o más pequeño no existe, la función devuelve None.\n\n  Argumentos:\n  - numbers: Un Vec<i32> que representa la secuencia de enteros no negativos.\n  - k: Un valor usize que representa la posición k-ésima.\n\n  Devuelve:\n  - Un valor Option<i32> que representa la diferencia si ambos números k-ésimo más grande y más pequeño existen, de lo contrario None.\n\n  Ejemplo:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) devuelve Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) devuelve None",
      "arb": "يحسب الفرق بين أكبر عدد في المرتبة k وأصغر عدد في المرتبة k في قائمة معينة من الأعداد الصحيحة.\nإذا لم يكن هناك عدد في المرتبة k كأكبر أو أصغر عدد، فإن الدالة تعيد None.\n\nالأوساط:\n- numbers: نوع Vec<i32> يمثل تسلسل الأعداد الصحيحة غير السالبة.\n- k: قيمة من نوع usize تمثل المرتبة k.\n\nالقيم المعادة:\n- قيمة من نوع Option<i32> تمثل الفرق إذا كان كلا العددين في المرتبة k كأكبر وأصغر عدد موجودين، وإلا تعيد None.\n\nمثال:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) تعيد Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) تعيد None",
      "sw": "Hesabu tofauti kati ya nambari ya kth kubwa zaidi na kth ndogo zaidi katika orodha iliyotolewa ya nambari za mzima.\n\nIkiwa nambari ya kth kubwa zaidi au ndogo zaidi haipo, kazi inarudisha None.\n\nHoja:\n- numbers: A Vec<i32> inayowakilisha mlolongo wa nambari zisizo hasi.\n- k: Thamani ya usize inayowakilisha nafasi ya kth.\n\nRudisha:\n- Thamani ya Option<i32> inayowakilisha tofauti ikiwa nambari zote mbili za kth kubwa zaidi na ndogo zaidi zipo, vinginevyo None.\n\nMfano:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) inarudisha Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) inarudisha None",
      "tr": "Verilen bir tamsayı listesindeki k. en büyük ve k. en küçük sayı arasındaki farkı hesaplar. \n  Eğer k. en büyük veya en küçük sayı mevcut değilse, fonksiyon None döndürür.\n\n  Argümanlar:\n  - numbers: Negatif olmayan tamsayıları temsil eden bir Vec<i32>.\n  - k: k. konumu temsil eden bir usize değeri.\n\n  Döndürür:\n  - Hem k. en büyük hem de en küçük sayı mevcutsa farkı temsil eden bir Option<i32> değeri, aksi takdirde None.\n\n  Örnek:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) Some(4) döndürür // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) None döndürür",
      "vi": "Tính toán sự khác biệt giữa số lớn thứ k và số nhỏ thứ k trong một danh sách số nguyên đã cho. Nếu số lớn thứ k hoặc nhỏ thứ k không tồn tại, hàm trả về None.\n\n  Tham số:\n  - numbers: Một Vec<i32> đại diện cho dãy số nguyên không âm.\n  - k: Một giá trị usize đại diện cho vị trí thứ k.\n\n  Trả về:\n  - Một giá trị Option<i32> đại diện cho sự khác biệt nếu cả số lớn thứ k và nhỏ thứ k tồn tại, nếu không thì trả về None.\n\n  Ví dụ:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) trả về Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) trả về None"
    },
    "docstring_bertscore": {
      "es": "0.9696157092434742",
      "arb": "0.9050030339662544",
      "sw": "0.9950505281653726",
      "tr": "0.9707878271219611",
      "vi": "0.948691587644497"
    }
  },
  {
    "task_id": "Rust/38",
    "prompt": {
      "en": "/*\n  Calculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "es": "/*\n  Calcula el valor total máximo de hierbas que se pueden recolectar dentro de un límite de tiempo dado a partir de un conjunto de hierbas, cada una con su propio requisito de tiempo y valor.\n\n  Argumentos:\n  - total_time: Un u32 que representa el tiempo total disponible para recolectar hierbas.\n  - herbs: Un slice de tuplas, donde cada tupla contiene dos valores u32 que representan el tiempo requerido para recolectar una hierba y su valor, respectivamente.\n\n  Devuelve:\n  - Un u32 que representa el valor total máximo de hierbas que se pueden recolectar dentro del tiempo dado.\n\n  Ejemplos:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) devuelve 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) devuelve 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) devuelve 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "arb": "/*\n  يحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين من مجموعة من الأعشاب، كل منها له متطلباته الزمنية وقيمته الخاصة.\n\n  يعيدالحجج:\n  - total_time: يمثل الوقت الإجمالي المتاح لجمع الأعشاب.\n  - herbs: مجموعة من الأزواج، حيث يحتوي كل زوج على قيمتين تمثلان الوقت المطلوب لجمع عشبة وقيمتها، على التوالي.\n\n  يعيد:\n  - قيمة تمثل القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الوقت المحدد.\n\n  امثله:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) يعيد 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) يعيد 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) يعيد 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "sw": "/*\n  Inahesabu thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya kikomo cha muda kilichopewa kutoka kwa seti ya mimea, kila moja ikiwa na mahitaji yake ya muda na thamani.\n\n  Hoja:\n  - total_time: u32 inayowakilisha muda wote unaopatikana kwa ajili ya kukusanya mimea.\n  - herbs: Kipande cha jozi, ambapo kila jozi ina maadili mawili ya u32 yanayowakilisha muda unaohitajika kukusanya mmea na thamani yake, mtawalia.\n\n  Inarudisha:\n  - u32 inayowakilisha thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\n\n  Mifano:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) inarudisha 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) inarudisha 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) inarudisha 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "tr": "/*\n  Belirli bir süre sınırı içinde, her biri kendi zaman gereksinimi ve değeri olan bir dizi ottan toplanabilecek maksimum toplam ot değerini hesaplar.\n\n  Argümanlar:\n  - total_time: Ot toplamak için mevcut toplam süreyi temsil eden bir u32.\n  - herbs: Her bir demetin bir otu toplamak için gereken zamanı ve değerini temsil eden iki u32 değeri içeren bir dilim.\n\n  Döndürür:\n  - Verilen süre içinde toplanabilecek otların maksimum toplam değerini temsil eden bir u32.\n\n  Örnekler:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 döndürür\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 döndürür\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 döndürür\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "vi": "/*\n  Tính toán giá trị tổng tối đa của các loại thảo mộc có thể thu thập trong một giới hạn thời gian nhất định từ một tập hợp các loại thảo mộc, mỗi loại có yêu cầu thời gian và giá trị riêng.\n\n  Tham số:\n  - total_time: Một u32 đại diện cho tổng thời gian có sẵn để thu thập thảo mộc.\n  - herbs: Một lát cắt của các bộ giá trị, trong đó mỗi bộ chứa hai giá trị u32 đại diện cho thời gian cần thiết để thu thập một loại thảo mộc và giá trị của nó, tương ứng.\n\n  Trả về:\n  - Một u32 đại diện cho giá trị tổng tối đa của các loại thảo mộc có thể thu thập trong thời gian đã cho.\n\n  Ví dụ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) trả về 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) trả về 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) trả về 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 "
    },
    "prompt_bertscore": {
      "es": "0.9993894102086988",
      "arb": "0.9536974705073382",
      "sw": "0.9703482580887308",
      "tr": "0.9596543956345746",
      "vi": "0.9905743925287515"
    },
    "canonical_solution": "{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` to solve the following problem:\nCalculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30",
      "es": "Escribe una función en Rust `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` para resolver el siguiente problema:\nCalcula el valor total máximo de hierbas que se pueden recolectar dentro de un límite de tiempo dado a partir de un conjunto de hierbas, cada una con su propio requisito de tiempo y valor.\n\n  Argumentos:\n  - total_time: Un u32 que representa el tiempo total disponible para recolectar hierbas.\n  - herbs: Una porción de tuplas, donde cada tupla contiene dos valores u32 que representan el tiempo requerido para recolectar una hierba y su valor, respectivamente.\n\n  Retorna:\n  - Un u32 que representa el valor total máximo de hierbas que se pueden recolectar dentro del tiempo dado.\n\n  Ejemplos:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) retorna 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) retorna 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) retorna 30",
      "arb": "اكتب دالة Rust `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` لحل المشكلة التالية:\nتحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين من مجموعة من الأعشاب، كل منها له متطلباته الزمنية وقيمته الخاصة.\n\n  الوسائط:\n  - total_time: قيمة u32 تمثل إجمالي الوقت المتاح لجمع الأعشاب.\n  - herbs: شريحة من الأزواج، حيث يحتوي كل زوج على قيمتين u32 تمثلان الوقت المطلوب لجمع عشبة وقيمتها، على التوالي.\n\n  يعيد:\n  - قيمة u32 تمثل القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الوقت المحدد.\n\n  أمثلة:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) يعيد 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) يعيد 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) يعيد 30",
      "sw": "Andika kazi ya Rust `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` kutatua tatizo lifuatalo:\nHesabu thamani ya juu kabisa ya mimea inayoweza kukusanywa ndani ya kikomo cha muda kilichopewa kutoka kwa seti ya mimea, kila moja ikiwa na mahitaji yake ya muda na thamani.\n\n  Hoja:\n  - total_time: u32 inayowakilisha muda wote unaopatikana kwa ajili ya kukusanya mimea.\n  - herbs: Sehemu ya jozi, ambapo kila jozi ina maadili mawili ya u32 yanayowakilisha muda unaohitajika kukusanya mmea na thamani yake, mtawalia.\n\n  Inarudisha:\n  - u32 inayowakilisha thamani ya juu kabisa ya mimea inayoweza kukusanywa ndani ya muda uliotolewa.\n\n  Mifano:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) inarudisha 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) inarudisha 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) inarudisha 30",
      "tr": "Bir Rust fonksiyonu `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` yazarak aşağıdaki problemi çözün:\nHer birinin kendi zaman gereksinimi ve değeri olan bir dizi ottan, belirli bir zaman sınırı içinde toplanabilecek maksimum toplam ot değerini hesaplar.\n\n  Argümanlar:\n  - total_time: Ot toplamak için mevcut toplam zamanı temsil eden bir u32.\n  - herbs: Her biri bir otu toplamak için gereken zamanı ve değerini temsil eden iki u32 değeri içeren bir dilim.\n\n  Döndürülenler:\n  - Belirtilen zaman içinde toplanabilecek maksimum toplam ot değerini temsil eden bir u32.\n\n  Örnekler:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 döner\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 döner\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 döner",
      "vi": "Viết một hàm Rust `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` để giải quyết vấn đề sau:\nTính toán tổng giá trị tối đa của các loại thảo mộc có thể thu thập được trong một giới hạn thời gian nhất định từ một tập hợp các loại thảo mộc, mỗi loại có yêu cầu thời gian và giá trị riêng.\n\n  Tham số:\n  - total_time: Một u32 đại diện cho tổng thời gian có sẵn để thu thập thảo mộc.\n  - herbs: Một lát cắt của các bộ giá trị, trong đó mỗi bộ chứa hai giá trị u32 đại diện cho thời gian cần thiết để thu thập một loại thảo mộc và giá trị của nó, tương ứng.\n\n  Trả về:\n  - Một u32 đại diện cho tổng giá trị tối đa của các loại thảo mộc có thể thu thập được trong thời gian cho phép.\n\n  Ví dụ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) trả về 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) trả về 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) trả về 30"
    },
    "instruction_bertscore": {
      "es": "0.9954175971095252",
      "arb": "0.9894495486809509",
      "sw": "0.9820563272684513",
      "tr": "0.9654263958770674",
      "vi": "0.9856860988514828"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]), 3);\n        assert_eq!(max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]), 110);\n        assert_eq!(max_herbs_value(5, &[(2, 20), (3, 30)]), 50);\n    }\n    \n\n}",
    "entry_point": "max_herbs_value",
    "signature": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32",
    "docstring": {
      "en": "Calculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30",
      "es": "Calcula el valor total máximo de hierbas que se pueden recolectar dentro de un límite de tiempo dado a partir de un conjunto de hierbas, cada una con su propio requisito de tiempo y valor.\n\n  Argumentos:\n  - total_time: Un u32 que representa el tiempo total disponible para recolectar hierbas.\n  - herbs: Una porción de tuplas, donde cada tupla contiene dos valores u32 que representan el tiempo requerido para recolectar una hierba y su valor, respectivamente.\n\n  Retorna:\n  - Un u32 que representa el valor total máximo de hierbas que se pueden recolectar dentro del tiempo dado.\n\n  Ejemplos:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) devuelve 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) devuelve 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) devuelve 30",
      "arb": "يحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها في حدود زمنية معينة من مجموعة من الأعشاب، كل منها له متطلباته الزمنية وقيمته الخاصة.\n\n  الحجج:\n  - total_time: يمثل u32 الوقت الإجمالي المتاح لجمع الأعشاب.\n  - herbs: شريحة من الأزواج، حيث يحتوي كل زوج على قيمتين من نوع u32 تمثل الوقت المطلوب لجمع عشبة وقيمتها، على التوالي.\n\n  العوائد:\n  - u32 يمثل القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها في الوقت المحدد.\n\n  أمثلة:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) يعيد 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) يعيد 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) يعيد 30",
      "sw": "Hesabu thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliowekwa kutoka kwa seti ya mimea, kila moja ikiwa na mahitaji yake ya muda na thamani.\n\n  Hoja:\n  - total_time: A u32 inayowakilisha muda wote unaopatikana kwa ajili ya kukusanya mimea.\n  - herbs: Kipande cha jozi, ambapo kila jozi ina maadili mawili ya u32 yanayowakilisha muda unaohitajika kukusanya mmea na thamani yake, mtawalia.\n\n  Inarejesha:\n  - A u32 inayowakilisha thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\n\n  Mifano:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) inarejesha 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) inarejesha 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) inarejesha 30",
      "tr": "Belirli bir süre sınırı içinde, her biri kendi zaman gereksinimi ve değeri olan bir dizi ottan toplanabilecek maksimum toplam ot değerini hesaplar.\n\n  Argümanlar:\n  - total_time: Ot toplamak için mevcut toplam zamanı temsil eden bir u32.\n  - herbs: Her biri bir otu toplamak için gereken zamanı ve değerini temsil eden iki u32 değeri içeren bir dilim.\n\n  Döndürür:\n  - Belirtilen süre içinde toplanabilecek otların maksimum toplam değerini temsil eden bir u32.\n\n  Örnekler:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 döndürür\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 döndürür\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 döndürür",
      "vi": "Tính toán giá trị tổng tối đa của các loại thảo mộc có thể được thu thập trong một giới hạn thời gian nhất định từ một tập hợp các loại thảo mộc, mỗi loại có yêu cầu thời gian và giá trị riêng.\n\n  Tham số:\n  - total_time: Một u32 đại diện cho tổng thời gian có sẵn để thu thập thảo mộc.\n  - herbs: Một mảng các bộ giá trị, trong đó mỗi bộ chứa hai giá trị u32 đại diện cho thời gian cần thiết để thu thập một loại thảo mộc và giá trị của nó, tương ứng.\n\n  Trả về:\n  - Một u32 đại diện cho giá trị tổng tối đa của các loại thảo mộc có thể được thu thập trong thời gian đã cho.\n\n  Ví dụ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) trả về 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) trả về 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) trả về 30"
    },
    "docstring_bertscore": {
      "es": "0.9976762231722729",
      "arb": "0.9704795527705949",
      "sw": "0.971948424438348",
      "tr": "0.9557789182702029",
      "vi": "0.9835794250302269"
    }
  },
  {
    "task_id": "Rust/39",
    "prompt": {
      "en": "/*\n  Validates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "es": "/*\n  Valida la corrección de un número ISBN dado.\n\n  Un número ISBN es una cadena con el formato \"x-xxx-xxxxx-x\", donde 'x' representa un dígito, y '-' es un separador. El último dígito es un dígito de control, calculado como la suma de los primeros 9 dígitos, cada uno multiplicado por su posición (1 a 9), módulo 11. Si el resultado es 10, el dígito de control es 'X'.\n\n  Argumentos:\n  - isbn: Una cadena que representa un número ISBN.\n\n  Retorna:\n  - Una respuesta en forma de cadena. Si el ISBN es correcto, retorna \"Right\". De lo contrario, retorna el número ISBN corregido.\n\n  Ejemplo:\n  - validate_isbn(\"0-670-82162-4\") retorna \"Right\"\n  - validate_isbn(\"0-670-82162-0\") retorna \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "arb": "/*\n  يتحقق من صحة رقم ISBN المعطى.\n\n  رقم ISBN هو سلسلة نصية بتنسيق \"x-xxx-xxxxx-x\"، حيث يمثل 'x' رقماً، و'-' هو فاصل. الرقم الأخير هو رقم التحقق، يُحسب كمجموع الأرقام التسعة الأولى كل منها مضروب في موقعه (من 1 إلى 9)، ثم يتم أخذ باقي القسمة على 11. إذا كانت النتيجة 10، فإن رقم التحقق هو 'X'.\n\n  الوسائط:\n  - isbn: سلسلة نصية تمثل رقم ISBN.\n\n  يعيد:\n  - استجابة نصية. إذا كان رقم ISBN صحيحاً، يعيد \"Right\". خلاف ذلك، يعيد رقم ISBN المصحح.\n\n  مثال:\n  - validate_isbn(\"0-670-82162-4\") يعيد \"Right\"\n  - validate_isbn(\"0-670-82162-0\") يعيد \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "sw": "/*\n  Inathibitisha usahihi wa nambari ya ISBN iliyotolewa.\n\n  Nambari ya ISBN ni kamba iliyopangwa kama \"x-xxx-xxxxx-x\", ambapo 'x' inawakilisha tarakimu, na '-' ni kitenganishi. Tarakimu ya mwisho ni tarakimu ya ukaguzi, inayohesabiwa kama jumla ya tarakimu 9 za kwanza kila moja ikizidishwa na nafasi yake (1 hadi 9), modulo 11. Ikiwa matokeo ni 10, tarakimu ya ukaguzi ni 'X'.\n\n  Hoja:\n  - isbn: Kamba inayoonyesha nambari ya ISBN.\n\n  Inarudisha:\n  - Jibu la kamba. Ikiwa ISBN ni sahihi, inarudisha \"Right\". Vinginevyo, inarudisha nambari ya ISBN iliyosahihishwa.\n\n  Mfano:\n  - validate_isbn(\"0-670-82162-4\") inarudisha \"Right\"\n  - validate_isbn(\"0-670-82162-0\") inarudisha \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "tr": "/*\n  Verilen bir ISBN numarasının doğruluğunu kontrol eder.\n\n  Bir ISBN numarası, \"x-xxx-xxxxx-x\" şeklinde biçimlendirilmiş bir dizgidir, burada 'x' bir rakamı ve '-' bir ayırıcıyı temsil eder. Son rakam, ilk 9 rakamın her birinin pozisyonlarıyla (1'den 9'a kadar) çarpılıp toplamının 11 ile mod alınmasıyla hesaplanan bir kontrol rakamıdır. Sonuç 10 ise, kontrol rakamı 'X' olur.\n\n  Argümanlar:\n  - isbn: Bir ISBN numarasını temsil eden bir dizgi.\n\n  Döndürür:\n  - Bir dizgi yanıtı. Eğer ISBN doğruysa, \"Right\" döner. Aksi takdirde, düzeltilmiş ISBN numarasını döner.\n\n  Örnek:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" döner\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" döner\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "vi": "/*\n  Xác thực tính đúng đắn của một số ISBN đã cho.\n\n  Một số ISBN là một chuỗi được định dạng như \"x-xxx-xxxxx-x\", trong đó 'x' đại diện cho một chữ số, và '-' là một dấu phân cách. Chữ số cuối cùng là chữ số kiểm tra, được tính bằng tổng của 9 chữ số đầu tiên mỗi chữ số nhân với vị trí của nó (từ 1 đến 9), lấy modulo 11. Nếu kết quả là 10, chữ số kiểm tra là 'X'.\n\n  Tham số:\n  - isbn: Một chuỗi đại diện cho một số ISBN.\n\n  Trả về:\n  - Một chuỗi phản hồi. Nếu ISBN đúng, trả về \"Right\". Ngược lại, trả về số ISBN đã được sửa.\n\n  Ví dụ:\n  - validate_isbn(\"0-670-82162-4\") trả về \"Right\"\n  - validate_isbn(\"0-670-82162-0\") trả về \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String "
    },
    "prompt_bertscore": {
      "es": "0.9812139358224824",
      "arb": "0.9543102452328309",
      "sw": "0.9881423621433603",
      "tr": "0.9581410307614697",
      "vi": "0.9791267277785677"
    },
    "canonical_solution": "{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}",
    "instruction": {
      "en": "Write a Rust function `fn validate_isbn(isbn: &str) -> String` to solve the following problem:\nValidates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"",
      "es": "Escribe una función en Rust `fn validate_isbn(isbn: &str) -> String` para resolver el siguiente problema:\nValida la corrección de un número ISBN dado.\n\nUn número ISBN es una cadena con el formato \"x-xxx-xxxxx-x\", donde 'x' representa un dígito, y '-' es un separador. El último dígito es un dígito de control, calculado como la suma de los primeros 9 dígitos, cada uno multiplicado por su posición (1 a 9), módulo 11. Si el resultado es 10, el dígito de control es 'X'.\n\nArgumentos:\n- isbn: Una cadena que representa un número ISBN.\n\nRetorna:\n- Una respuesta en forma de cadena. Si el ISBN es correcto, retorna \"Right\". De lo contrario, retorna el número ISBN corregido.\n\nEjemplo:\n- validate_isbn(\"0-670-82162-4\") retorna \"Right\"\n- validate_isbn(\"0-670-82162-0\") retorna \"0-670-82162-4\"",
      "arb": "اكتب دالة Rust `fn validate_isbn(isbn: &str) -> String` لحل المشكلة التالية:\nالتحقق من صحة رقم ISBN المعطى.\n\nرقم ISBN هو سلسلة نصية بتنسيق \"x-xxx-xxxxx-x\"، حيث يمثل 'x' رقمًا، و'-' هو فاصل. الرقم الأخير هو رقم التحقق، يتم حسابه كمجموع الأرقام التسعة الأولى كل منها مضروب في موقعه (من 1 إلى 9)، ثم يؤخذ باقي القسمة على 11. إذا كانت النتيجة 10، فإن رقم التحقق هو 'X'.\n\nالمعطيات:\n- isbn: سلسلة نصية تمثل رقم ISBN.\n\nالقيم المعادة:\n- استجابة نصية. إذا كان ISBN صحيحًا، يعيد \"Right\". خلاف ذلك، يعيد رقم ISBN المصحح.\n\nمثال:\n- validate_isbn(\"0-670-82162-4\") يعيد \"Right\"\n- validate_isbn(\"0-670-82162-0\") يعيد \"0-670-82162-4\"",
      "sw": "Andika kazi ya Rust `fn validate_isbn(isbn: &str) -> String` kutatua tatizo lifuatalo:\nInathibitisha usahihi wa namba ya ISBN iliyotolewa.\n\n  Namba ya ISBN ni kamba iliyopangwa kama \"x-xxx-xxxxx-x\", ambapo 'x' inawakilisha tarakimu, na '-' ni kitenganishi. Tarakimu ya mwisho ni tarakimu ya ukaguzi, inayohesabiwa kama jumla ya tarakimu 9 za kwanza kila moja ikizidishwa na nafasi yake (1 hadi 9), modulo 11. Ikiwa matokeo ni 10, tarakimu ya ukaguzi ni 'X'.\n\n  Hoja:\n  - isbn: Kamba inayowakilisha namba ya ISBN.\n\n  Inarudisha:\n  - Jibu la kamba. Ikiwa ISBN ni sahihi, inarudisha \"Right\". Vinginevyo, inarudisha namba ya ISBN iliyosahihishwa.\n\n  Mfano:\n  - validate_isbn(\"0-670-82162-4\") inarudisha \"Right\"\n  - validate_isbn(\"0-670-82162-0\") inarudisha \"0-670-82162-4\"",
      "tr": "Bir Rust fonksiyonu `fn validate_isbn(isbn: &str) -> String` yazın ve aşağıdaki problemi çözün:\nVerilen bir ISBN numarasının doğruluğunu kontrol eder.\n\n  Bir ISBN numarası \"x-xxx-xxxxx-x\" biçiminde bir stringdir, burada 'x' bir rakamı ve '-' bir ayırıcıyı temsil eder. Son rakam, ilk 9 rakamın her birinin pozisyonları (1'den 9'a kadar) ile çarpılıp, 11 ile mod alınarak hesaplanan bir kontrol rakamıdır. Sonuç 10 ise, kontrol rakamı 'X' olur.\n\n  Argümanlar:\n  - isbn: Bir ISBN numarasını temsil eden bir string.\n\n  Döndürür:\n  - Bir string yanıtı. Eğer ISBN doğruysa, \"Right\" döner. Aksi takdirde, düzeltilmiş ISBN numarasını döner.\n\n  Örnek:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" döner\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" döner",
      "vi": "Viết một hàm Rust `fn validate_isbn(isbn: &str) -> String` để giải quyết vấn đề sau:\nXác thực tính đúng đắn của một số ISBN đã cho.\n\nMột số ISBN là một chuỗi được định dạng như \"x-xxx-xxxxx-x\", trong đó 'x' đại diện cho một chữ số, và '-' là một dấu phân cách. Chữ số cuối cùng là chữ số kiểm tra, được tính bằng tổng của 9 chữ số đầu tiên, mỗi chữ số nhân với vị trí của nó (từ 1 đến 9), sau đó lấy modulo 11. Nếu kết quả là 10, chữ số kiểm tra là 'X'.\n\nTham số:\n- isbn: Một chuỗi đại diện cho một số ISBN.\n\nTrả về:\n- Một chuỗi phản hồi. Nếu ISBN đúng, trả về \"Right\". Ngược lại, trả về số ISBN đã được sửa.\n\nVí dụ:\n- validate_isbn(\"0-670-82162-4\") trả về \"Right\"\n- validate_isbn(\"0-670-82162-0\") trả về \"0-670-82162-4\""
    },
    "instruction_bertscore": {
      "es": "0.9777371096328477",
      "arb": "0.9524226607218563",
      "sw": "0.9854175505763236",
      "tr": "0.9598766630309525",
      "vi": "0.9728871516191188"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(validate_isbn(\"0-670-82162-4\"), \"Right\");\n        assert_eq!(validate_isbn(\"0-670-82162-0\"), \"0-670-82162-4\");\n        assert_eq!(validate_isbn(\"0-123-45678-9\"), \"Right\");\n        assert_eq!(validate_isbn(\"1-234-56789-X\"), \"Right\");\n    }\n    \n\n}",
    "entry_point": "validate_isbn",
    "signature": "fn validate_isbn(isbn: &str) -> String",
    "docstring": {
      "en": "Validates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"",
      "es": "Valida la corrección de un número ISBN dado.\n\n  Un número ISBN es una cadena con el formato \"x-xxx-xxxxx-x\", donde 'x' representa un dígito, y '-' es un separador. El último dígito es un dígito de control, calculado como la suma de los primeros 9 dígitos cada uno multiplicado por su posición (1 a 9), módulo 11. Si el resultado es 10, el dígito de control es 'X'.\n\n  Argumentos:\n  - isbn: Una cadena que representa un número ISBN.\n\n  Retorna:\n  - Una respuesta en forma de cadena. Si el ISBN es correcto, retorna \"Right\". De lo contrario, retorna el número ISBN corregido.\n\n  Ejemplo:\n  - validate_isbn(\"0-670-82162-4\") retorna \"Right\"\n  - validate_isbn(\"0-670-82162-0\") retorna \"0-670-82162-4\"",
      "arb": "يتحقق من صحة رقم ISBN المعطى.\n\nرقم ISBN هو سلسلة نصية بتنسيق \"x-xxx-xxxxx-x\"، حيث يمثل 'x' رقماً، و'-' هو فاصل. الرقم الأخير هو رقم التحقق، يتم حسابه كمجموع الأرقام التسعة الأولى كل منها مضروب في موضعه (من 1 إلى 9)، ثم يؤخذ باقي القسمة على 11. إذا كانت النتيجة 10، فإن رقم التحقق يكون 'X'.\n\nالأطراف:\n- isbn: سلسلة نصية تمثل رقم ISBN.\n\nالقيم المعادة:\n- استجابة نصية. إذا كان ISBN صحيحاً، يعيد \"Right\". خلاف ذلك، يعيد رقم ISBN المصحح.\n\nمثال:\n- validate_isbn(\"0-670-82162-4\") يعيد \"Right\"\n- validate_isbn(\"0-670-82162-0\") يعيد \"0-670-82162-4\"",
      "sw": "Inathibitisha usahihi wa nambari ya ISBN iliyotolewa.\n\n  Nambari ya ISBN ni kamba iliyopangwa kama \"x-xxx-xxxxx-x\", ambapo 'x' inawakilisha tarakimu, na '-' ni kitenganishi. Tarakimu ya mwisho ni tarakimu ya ukaguzi, inayohesabiwa kama jumla ya tarakimu 9 za kwanza kila moja ikizidishwa na nafasi yake (1 hadi 9), modulo 11. Ikiwa matokeo ni 10, tarakimu ya ukaguzi ni 'X'.\n\n  Hoja:\n  - isbn: Kamba inayowakilisha nambari ya ISBN.\n\n  Inarejesha:\n  - Jibu la kamba. Ikiwa ISBN ni sahihi, inarejesha \"Right\". Vinginevyo, inarejesha nambari ya ISBN iliyosahihishwa.\n\n  Mfano:\n  - validate_isbn(\"0-670-82162-4\") inarejesha \"Right\"\n  - validate_isbn(\"0-670-82162-0\") inarejesha \"0-670-82162-4\"",
      "tr": "Verilen bir ISBN numarasının doğruluğunu kontrol eder.\n\n  Bir ISBN numarası \"x-xxx-xxxxx-x\" şeklinde biçimlendirilmiş bir dizgedir, burada 'x' bir rakamı temsil eder ve '-' bir ayırıcıdır. Son rakam, ilk 9 rakamın her birinin pozisyonları (1'den 9'a kadar) ile çarpılıp toplanması, 11 ile mod alınarak hesaplanan bir kontrol rakamıdır. Sonuç 10 ise, kontrol rakamı 'X' olur.\n\n  Argümanlar:\n  - isbn: Bir ISBN numarasını temsil eden bir dizge.\n\n  Döndürülenler:\n  - Bir dizge yanıtı. Eğer ISBN doğruysa, \"Right\" döner. Aksi takdirde, düzeltilmiş ISBN numarasını döner.\n\n  Örnek:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" döner\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" döner",
      "vi": "Xác thực tính đúng đắn của một số ISBN đã cho.\n\nMột số ISBN là một chuỗi được định dạng như \"x-xxx-xxxxx-x\", trong đó 'x' đại diện cho một chữ số, và '-' là một dấu phân cách. Chữ số cuối cùng là một chữ số kiểm tra, được tính bằng tổng của 9 chữ số đầu tiên, mỗi chữ số nhân với vị trí của nó (từ 1 đến 9), sau đó lấy modulo 11. Nếu kết quả là 10, chữ số kiểm tra là 'X'.\n\nTham số:\n- isbn: Một chuỗi đại diện cho một số ISBN.\n\nTrả về:\n- Một chuỗi phản hồi. Nếu ISBN đúng, trả về \"Right\". Ngược lại, trả về số ISBN đã được sửa.\n\nVí dụ:\n- validate_isbn(\"0-670-82162-4\") trả về \"Right\"\n- validate_isbn(\"0-670-82162-0\") trả về \"0-670-82162-4\""
    },
    "docstring_bertscore": {
      "es": "0.9794777076618564",
      "arb": "0.9428351694900644",
      "sw": "0.9777377055239908",
      "tr": "0.9487877247489179",
      "vi": "0.9700372029120302"
    }
  },
  {
    "task_id": "Rust/40",
    "prompt": {
      "en": "/*\n  Calculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "es": "/*\n  Calcula el número de diferentes maneras de pasar una pelota entre 'n' estudiantes parados en un círculo, de tal manera que después de 'm' pases, la pelota regrese al estudiante original.\n\n  Argumentos:\n  - n: El número de estudiantes en el círculo. Es un entero donde 3 <= n <= 30.\n  - m: El número de veces que se pasa la pelota. Es un entero donde 1 <= m <= 30.\n\n  Retorna:\n  - El número de secuencias de pases distintas que devuelven la pelota al estudiante inicial después de 'm' pases.\n\n  Ejemplos:\n  - count_passing_ways(3, 3) devuelve 2\n  - count_passing_ways(4, 2) devuelve 4\n  - count_passing_ways(5, 5) devuelve 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "arb": "/*\n  يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' من الطلاب الواقفين في دائرة، بحيث تعود الكرة بعد 'm' تمريرات إلى الطالب الأصلي.\n\n  الوسائط:\n  - n: عدد الطلاب في الدائرة. وهو عدد صحيح حيث 3 <= n <= 30.\n  - m: عدد المرات التي يتم فيها تمرير الكرة. وهو عدد صحيح حيث 1 <= m <= 30.\n\n  يعيد:\n  - عدد تسلسلات التمرير المميزة التي تعيد الكرة إلى الطالب المبتدئ بعد 'm' تمريرات.\n\n  أمثلة:\n  - count_passing_ways(3, 3) يعيد 2\n  - count_passing_ways(4, 2) يعيد 4\n  - count_passing_ways(5, 5) يعيد 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliokaa kwenye duara, ili baada ya 'm' kupitisha, mpira urudi kwa mwanafunzi wa awali.\n\n  Hoja:\n  - n: Idadi ya wanafunzi kwenye duara. Ni nambari kamili ambapo 3 <= n <= 30.\n  - m: Idadi ya mara mpira unapopitishwa. Ni nambari kamili ambapo 1 <= m <= 30.\n\n  Inarejesha:\n  - Idadi ya mfuatano tofauti ya kupitisha ambayo inarudisha mpira kwa mwanafunzi wa kuanzia baada ya 'm' kupitisha.\n\n  Mifano:\n  - count_passing_ways(3, 3) inarejesha 2\n  - count_passing_ways(4, 2) inarejesha 4\n  - count_passing_ways(5, 5) inarejesha 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "tr": "/*\n  Topun 'n' öğrencinin bir dairede durduğu bir durumda, 'm' pas sonrasında topun orijinal öğrenciye geri dönmesi için farklı yolların sayısını hesaplar.\n\n  Argümanlar:\n  - n: Dairedeki öğrenci sayısı. 3 <= n <= 30 olan bir tam sayıdır.\n  - m: Topun kaç kez paslandığı. 1 <= m <= 30 olan bir tam sayıdır.\n\n  Döndürür:\n  - 'm' pas sonrasında topu başlangıçtaki öğrenciye geri getiren farklı pas dizilerinin sayısı.\n\n  Örnekler:\n  - count_passing_ways(3, 3) 2 döndürür\n  - count_passing_ways(4, 2) 4 döndürür\n  - count_passing_ways(5, 5) 6 döndürür\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "vi": "/*\n  Tính toán số cách khác nhau để chuyền một quả bóng giữa 'n' học sinh đứng thành vòng tròn, sao cho sau 'm' lần chuyền, quả bóng trở về học sinh ban đầu.\n\n  Tham số:\n  - n: Số lượng học sinh trong vòng tròn. Đây là một số nguyên với điều kiện 3 <= n <= 30.\n  - m: Số lần quả bóng được chuyền. Đây là một số nguyên với điều kiện 1 <= m <= 30.\n\n  Trả về:\n  - Số lượng chuỗi chuyền bóng khác nhau mà đưa quả bóng trở về học sinh bắt đầu sau 'm' lần chuyền.\n\n  Ví dụ:\n  - count_passing_ways(3, 3) trả về 2\n  - count_passing_ways(4, 2) trả về 4\n  - count_passing_ways(5, 5) trả về 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9969957154868473",
      "arb": "0.9831871300276829",
      "sw": "0.9848208649116948",
      "tr": "0.965436128765738",
      "vi": "0.973685645750879"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_passing_ways(n: i32, m: i32) -> i32` to solve the following problem:\nCalculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6",
      "es": "Escribe una función de Rust `fn count_passing_ways(n: i32, m: i32) -> i32` para resolver el siguiente problema:\nCalcula el número de diferentes maneras de pasar una pelota entre 'n' estudiantes que están de pie en un círculo, de tal manera que después de 'm' pases, la pelota regrese al estudiante original.\n\n  Argumentos:\n  - n: El número de estudiantes en el círculo. Es un entero donde 3 <= n <= 30.\n  - m: El número de veces que se pasa la pelota. Es un entero donde 1 <= m <= 30.\n\n  Retorna:\n  - El número de secuencias de pases distintas que devuelven la pelota al estudiante inicial después de 'm' pases.\n\n  Ejemplos:\n  - count_passing_ways(3, 3) retorna 2\n  - count_passing_ways(4, 2) retorna 4\n  - count_passing_ways(5, 5) retorna 6",
      "arb": "اكتب دالة Rust `fn count_passing_ways(n: i32, m: i32) -> i32` لحل المشكلة التالية:\nتحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' من الطلاب الواقفين في دائرة، بحيث بعد 'm' تمريرات، تعود الكرة إلى الطالب الأصلي.\n\n  المعطيات:\n  - n: عدد الطلاب في الدائرة. وهو عدد صحيح حيث 3 <= n <= 30.\n  - m: عدد المرات التي يتم فيها تمرير الكرة. وهو عدد صحيح حيث 1 <= m <= 30.\n\n  المخرجات:\n  - عدد تسلسلات التمرير المميزة التي تعيد الكرة إلى الطالب المبتدئ بعد 'm' تمريرات.\n\n  أمثلة:\n  - count_passing_ways(3, 3) يعيد 2\n  - count_passing_ways(4, 2) يعيد 4\n  - count_passing_ways(5, 5) يعيد 6",
      "sw": "Andika kazi ya Rust `fn count_passing_ways(n: i32, m: i32) -> i32` kutatua tatizo lifuatalo:\nHesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliopo kwenye duara, ili baada ya kupitisha 'm', mpira urudi kwa mwanafunzi wa awali.\n\n  Hoja:\n  - n: Idadi ya wanafunzi kwenye duara. Ni nambari kamili ambapo 3 <= n <= 30.\n  - m: Idadi ya mara mpira unapopitishwa. Ni nambari kamili ambapo 1 <= m <= 30.\n\n  Inarudisha:\n  - Idadi ya mfuatano tofauti wa kupitisha ambao unarudisha mpira kwa mwanafunzi wa kuanzia baada ya kupitisha 'm'.\n\n  Mifano:\n  - count_passing_ways(3, 3) inarudisha 2\n  - count_passing_ways(4, 2) inarudisha 4\n  - count_passing_ways(5, 5) inarudisha 6",
      "tr": "Bir Rust fonksiyonu `fn count_passing_ways(n: i32, m: i32) -> i32` yazarak aşağıdaki problemi çözün:\nBir daire şeklinde duran 'n' öğrenci arasında bir topu farklı yollarla paslaşmanın sayısını hesaplar, öyle ki 'm' paslaşmadan sonra top orijinal öğrenciye geri döner.\n\n  Argümanlar:\n  - n: Dairedeki öğrenci sayısı. 3 <= n <= 30 olan bir tam sayıdır.\n  - m: Topun kaç kez paslandığı. 1 <= m <= 30 olan bir tam sayıdır.\n\n  Döndürür:\n  - 'm' paslaşmadan sonra topu başlangıçtaki öğrenciye geri döndüren farklı paslaşma dizilerinin sayısı.\n\n  Örnekler:\n  - count_passing_ways(3, 3) 2 döndürür\n  - count_passing_ways(4, 2) 4 döndürür\n  - count_passing_ways(5, 5) 6 döndürür",
      "vi": "Viết một hàm Rust `fn count_passing_ways(n: i32, m: i32) -> i32` để giải quyết vấn đề sau:\nTính toán số cách khác nhau để chuyền một quả bóng giữa 'n' học sinh đứng thành vòng tròn, sao cho sau 'm' lần chuyền, quả bóng trở về học sinh ban đầu.\n\n  Tham số:\n  - n: Số lượng học sinh trong vòng tròn. Đây là một số nguyên với 3 <= n <= 30.\n  - m: Số lần quả bóng được chuyền. Đây là một số nguyên với 1 <= m <= 30.\n\n  Trả về:\n  - Số lượng chuỗi chuyền bóng khác nhau mà sau 'm' lần chuyền, quả bóng trở về học sinh ban đầu.\n\n  Ví dụ:\n  - count_passing_ways(3, 3) trả về 2\n  - count_passing_ways(4, 2) trả về 4\n  - count_passing_ways(5, 5) trả về 6"
    },
    "instruction_bertscore": {
      "es": "0.9962331734540544",
      "arb": "0.9777466438911373",
      "sw": "0.9891998702919901",
      "tr": "0.9938450403828719",
      "vi": "0.9718882394328944"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_passing_ways(3, 3), 2);\n        assert_eq!(count_passing_ways(4, 2), 2);\n        assert_eq!(count_passing_ways(5, 5), 2);    \n        assert_eq!(count_passing_ways(10, 3), 0);    \n        assert_eq!(count_passing_ways(30, 10), 252);    \n    }\n    \n\n}",
    "entry_point": "count_passing_ways",
    "signature": "fn count_passing_ways(n: i32, m: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6",
      "es": "Calcula el número de formas diferentes de pasar una pelota entre 'n' estudiantes parados en un círculo, de manera que después de 'm' pases, la pelota regrese al estudiante original.\n\n  Argumentos:\n  - n: El número de estudiantes en el círculo. Es un entero donde 3 <= n <= 30.\n  - m: El número de veces que se pasa la pelota. Es un entero donde 1 <= m <= 30.\n\n  Retorna:\n  - El número de secuencias de pases distintas que devuelven la pelota al estudiante inicial después de 'm' pases.\n\n  Ejemplos:\n  - count_passing_ways(3, 3) retorna 2\n  - count_passing_ways(4, 2) retorna 4\n  - count_passing_ways(5, 5) retorna 6",
      "arb": "يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' من الطلاب الواقفين في دائرة، بحيث بعد 'm' من التمريرات، تعود الكرة إلى الطالب الأصلي.\n\n  الحجج:\n  - n: عدد الطلاب في الدائرة. وهو عدد صحيح حيث 3 <= n <= 30.\n  - m: عدد المرات التي يتم فيها تمرير الكرة. وهو عدد صحيح حيث 1 <= m <= 30.\n\n  العوائد:\n  - عدد تسلسلات التمرير المميزة التي تعيد الكرة إلى الطالب المبتدئ بعد 'm' من التمريرات.\n\n  أمثلة:\n  - count_passing_ways(3, 3) يعيد 2\n  - count_passing_ways(4, 2) يعيد 4\n  - count_passing_ways(5, 5) يعيد 6",
      "sw": "Hesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' walioko kwenye duara, ili baada ya 'm' kupitisha, mpira urudi kwa mwanafunzi wa awali.\n\n  Hoja:\n  - n: Idadi ya wanafunzi kwenye duara. Ni nambari kamili ambapo 3 <= n <= 30.\n  - m: Idadi ya mara mpira unapopitishwa. Ni nambari kamili ambapo 1 <= m <= 30.\n\n  Inarudisha:\n  - Idadi ya mpangilio tofauti wa kupitisha mpira unaorudisha mpira kwa mwanafunzi wa kuanzia baada ya 'm' kupitisha.\n\n  Mifano:\n  - count_passing_ways(3, 3) inarudisha 2\n  - count_passing_ways(4, 2) inarudisha 4\n  - count_passing_ways(5, 5) inarudisha 6",
      "tr": "Top şeklinde duran 'n' öğrenci arasında topun kaç farklı şekilde pas edilebileceğini hesaplar, öyle ki 'm' pas sonrasında top tekrar orijinal öğrenciye geri döner.\n\n  Argümanlar:\n  - n: Çemberdeki öğrenci sayısı. 3 <= n <= 30 olan bir tam sayıdır.\n  - m: Topun kaç kez pas edildiği. 1 <= m <= 30 olan bir tam sayıdır.\n\n  Döndürür:\n  - 'm' pas sonrasında topu başlangıçtaki öğrenciye geri getiren farklı pas dizilerinin sayısı.\n\n  Örnekler:\n  - count_passing_ways(3, 3) 2 döndürür\n  - count_passing_ways(4, 2) 4 döndürür\n  - count_passing_ways(5, 5) 6 döndürür",
      "vi": "Tính toán số cách khác nhau để chuyền một quả bóng giữa 'n' học sinh đứng thành vòng tròn, sao cho sau 'm' lần chuyền, quả bóng quay trở lại học sinh ban đầu.\n\n  Tham số:\n  - n: Số lượng học sinh trong vòng tròn. Đây là một số nguyên với 3 <= n <= 30.\n  - m: Số lần quả bóng được chuyền. Đây là một số nguyên với 1 <= m <= 30.\n\n  Trả về:\n  - Số lượng chuỗi chuyền bóng khác nhau mà đưa quả bóng trở lại học sinh bắt đầu sau 'm' lần chuyền.\n\n  Ví dụ:\n  - count_passing_ways(3, 3) trả về 2\n  - count_passing_ways(4, 2) trả về 4\n  - count_passing_ways(5, 5) trả về 6"
    },
    "docstring_bertscore": {
      "es": "0.9964323997262323",
      "arb": "0.9985305324411039",
      "sw": "0.970992615044808",
      "tr": "0.9863912367041567",
      "vi": "0.9788879740605638"
    }
  },
  {
    "task_id": "Rust/41",
    "prompt": {
      "en": "\n/*\n  Calculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "es": "/*\n  Calcula la suma máxima posible de diferencias absolutas entre pares de elementos de dos arreglos.\n  \n  Argumentos:\n  - a: Un arreglo de enteros.\n  - b: Un arreglo de enteros, de la misma longitud que 'a'.\n  \n  Retorna:\n  - La suma máxima de diferencias absolutas que se puede obtener emparejando cada elemento de 'a' con uno de 'b'.\n\n  Ejemplos:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) devuelve 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) devuelve 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) devuelve 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "arb": "/*\n  يحسب أقصى مجموع ممكن للفروق المطلقة بين أزواج العناصر من مصفوفتين.\n  \n  المعطيات:\n  - a: مصفوفة من الأعداد الصحيحة.\n  - b: مصفوفة من الأعداد الصحيحة، لها نفس طول 'a'.\n  \n  يعيد:\n  - أقصى مجموع للفروق المطلقة الذي يمكن الحصول عليه عن طريق إقران كل عنصر من 'a' مع واحد من 'b'.\n\n  أمثلة:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) يعيد 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) يعيد 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) يعيد 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "sw": "/*\n  Inakokotoa jumla ya juu zaidi inayowezekana ya tofauti za thamani kamili kati ya jozi za vipengele kutoka kwa safu mbili.\n  \n  Hoja:\n  - a: Safu ya nambari za mzima.\n  - b: Safu ya nambari za mzima, yenye urefu sawa na 'a'.\n  \n  Inarudisha:\n  - Jumla ya juu zaidi ya tofauti za thamani kamili inayoweza kupatikana kwa kuoanisha kila kipengele kutoka 'a' na kimoja kutoka 'b'.\n\n  Mifano:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) inarudisha 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) inarudisha 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) inarudisha 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "tr": "/*\n  İki dizideki eleman çiftleri arasındaki mutlak farkların maksimum olası toplamını hesaplar.\n  \n  Argümanlar:\n  - a: Bir tamsayı dizisi.\n  - b: 'a' ile aynı uzunlukta bir tamsayı dizisi.\n  \n  Döndürür:\n  - Her bir elemanı 'a'dan bir elemanla eşleştirerek elde edilebilecek mutlak farkların maksimum toplamı.\n\n  Örnekler:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 döndürür.\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 döndürür.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 döndürür.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "vi": "/*\n  Tính tổng lớn nhất có thể của các chênh lệch tuyệt đối giữa các cặp phần tử từ hai mảng.\n  \n  Tham số:\n  - a: Một mảng các số nguyên.\n  - b: Một mảng các số nguyên, có cùng độ dài với 'a'.\n  \n  Trả về:\n  - Tổng lớn nhất của các chênh lệch tuyệt đối có thể đạt được bằng cách ghép từng phần tử từ 'a' với một phần tử từ 'b'.\n\n  Ví dụ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) trả về 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) trả về 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) trả về 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 "
    },
    "prompt_bertscore": {
      "es": "0.997950333098101",
      "arb": "0.9931303682719084",
      "sw": "0.9859276333948213",
      "tr": "0.968726639657962",
      "vi": "0.9902494332253784"
    },
    "canonical_solution": "{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` to solve the following problem:\nCalculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.",
      "es": "Escribe una función de Rust `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` para resolver el siguiente problema:\nCalcula la suma máxima posible de diferencias absolutas entre pares de elementos de dos arreglos.\n  \n  Argumentos:\n  - a: Un arreglo de enteros.\n  - b: Un arreglo de enteros, de la misma longitud que 'a'.\n  \n  Retorna:\n  - La suma máxima de diferencias absolutas que se puede obtener emparejando cada elemento de 'a' con uno de 'b'.\n\n  Ejemplos:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) retorna 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) retorna 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) retorna 60.",
      "arb": "اكتب دالة Rust `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` لحل المشكلة التالية:\nتحسب المجموع الأقصى الممكن لفروق القيم المطلقة بين أزواج العناصر من مصفوفتين.\n\nالحجج:\n- a: مصفوفة من الأعداد الصحيحة.\n- b: مصفوفة من الأعداد الصحيحة، بنفس طول 'a'.\n\nالقيم المعادة:\n- المجموع الأقصى لفروق القيم المطلقة التي يمكن الحصول عليها عن طريق إقران كل عنصر من 'a' مع واحد من 'b'.\n\nأمثلة:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) تعيد 14.\n- max_pairing_difference(&[1, 2], &[3, 4]) تعيد 4.\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) تعيد 60.",
      "sw": "Andika kazi ya Rust `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` kutatua tatizo lifuatalo:\nInakokotoa jumla ya juu zaidi inayowezekana ya tofauti za thamani kamili kati ya jozi za vipengele kutoka safu mbili.\n\nHoja:\n- a: Safu ya nambari za mzima.\n- b: Safu ya nambari za mzima, yenye urefu sawa na 'a'.\n\nInarejesha:\n- Jumla ya juu zaidi ya tofauti za thamani kamili inayoweza kupatikana kwa kuoanisha kila kipengele kutoka 'a' na kimoja kutoka 'b'.\n\nMifano:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) inarejesha 14.\n- max_pairing_difference(&[1, 2], &[3, 4]) inarejesha 4.\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) inarejesha 60.",
      "tr": "Bir Rust fonksiyonu `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` yazın ve aşağıdaki problemi çözün:\nİki dizideki eleman çiftleri arasındaki mutlak farkların maksimum olası toplamını hesaplar.\n\n  Argümanlar:\n  - a: Bir tamsayı dizisi.\n  - b: 'a' ile aynı uzunlukta bir tamsayı dizisi.\n  \n  Döndürür:\n  - Her bir elemanı 'a'dan biriyle eşleştirerek elde edilebilecek mutlak farkların maksimum toplamı.\n\n  Örnekler:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 döndürür.\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 döndürür.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 döndürür.",
      "vi": "Viết một hàm Rust `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` để giải quyết vấn đề sau:\nTính tổng lớn nhất có thể của các chênh lệch tuyệt đối giữa các cặp phần tử từ hai mảng.\n\n  Tham số:\n  - a: Một mảng các số nguyên.\n  - b: Một mảng các số nguyên, có cùng độ dài với 'a'.\n  \n  Trả về:\n  - Tổng lớn nhất của các chênh lệch tuyệt đối có thể đạt được bằng cách ghép mỗi phần tử từ 'a' với một phần tử từ 'b'.\n\n  Ví dụ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) trả về 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) trả về 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) trả về 60."
    },
    "instruction_bertscore": {
      "es": "0.996048447199692",
      "arb": "0.9950209322385984",
      "sw": "0.9954142203930475",
      "tr": "0.9726652814835028",
      "vi": "0.9902273852530835"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]), 14);\n        assert_eq!(max_pairing_difference(&[1, 2], &[3, 4]), 4);\n        assert_eq!(max_pairing_difference(&[10, 20, 30], &[30, 20, 10]), 40);\n    }\n    \n}",
    "entry_point": "max_pairing_difference",
    "signature": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64",
    "docstring": {
      "en": "Calculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.",
      "es": "Calcula la suma máxima posible de diferencias absolutas entre pares de elementos de dos arreglos.\n  \n  Argumentos:\n  - a: Un arreglo de enteros.\n  - b: Un arreglo de enteros, de la misma longitud que 'a'.\n  \n  Retorna:\n  - La suma máxima de diferencias absolutas que se puede obtener emparejando cada elemento de 'a' con uno de 'b'.\n\n  Ejemplos:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) devuelve 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) devuelve 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) devuelve 60.",
      "arb": "يحسب أقصى مجموع ممكن لفروق القيم المطلقة بين أزواج من العناصر من مصفوفتين.\n\n  الحجج:\n  - a: مصفوفة من الأعداد الصحيحة.\n  - b: مصفوفة من الأعداد الصحيحة، لها نفس طول 'a'.\n\n  يعيد:\n  - أقصى مجموع لفروق القيم المطلقة التي يمكن الحصول عليها عن طريق إقران كل عنصر من 'a' مع واحد من 'b'.\n\n  أمثلة:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) يعيد 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) يعيد 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) يعيد 60.",
      "sw": "Inakokotoa jumla ya juu zaidi inayowezekana ya tofauti za thamani kamili kati ya jozi za vipengele kutoka kwa safu mbili.\n\n  Hoja:\n  - a: Safu ya nambari za mzima.\n  - b: Safu ya nambari za mzima, yenye urefu sawa na 'a'.\n  \n  Inarejesha:\n  - Jumla kubwa zaidi ya tofauti za thamani kamili inayoweza kupatikana kwa kuoanisha kila kipengele kutoka 'a' na kimoja kutoka 'b'.\n\n  Mifano:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) inarejesha 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) inarejesha 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) inarejesha 60.",
      "tr": "Mutlak farkların maksimum olası toplamını iki dizideki eleman çiftleri arasında hesaplar.\n\n  Argümanlar:\n  - a: Bir tamsayı dizisi.\n  - b: 'a' ile aynı uzunlukta bir tamsayı dizisi.\n  \n  Döndürür:\n  - Her bir elemanı 'a'dan biriyle eşleştirerek elde edilebilecek mutlak farkların maksimum toplamı.\n\n  Örnekler:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 döndürür.\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 döndürür.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 döndürür.",
      "vi": "Tính tổng lớn nhất có thể của các chênh lệch tuyệt đối giữa các cặp phần tử từ hai mảng.\n\n  Tham số:\n  - a: Một mảng các số nguyên.\n  - b: Một mảng các số nguyên, có cùng độ dài với 'a'.\n  \n  Trả về:\n  - Tổng lớn nhất của các chênh lệch tuyệt đối có thể đạt được bằng cách ghép từng phần tử từ 'a' với một phần tử từ 'b'.\n\n  Ví dụ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) trả về 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) trả về 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) trả về 60."
    },
    "docstring_bertscore": {
      "es": "0.9960172622298694",
      "arb": "0.999999801369619",
      "sw": "0.9877609918117733",
      "tr": "0.9739690913046158",
      "vi": "0.9888506780821307"
    }
  },
  {
    "task_id": "Rust/42",
    "prompt": {
      "en": "/*\n  Finds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "es": "/*\n  Encuentra el número con el mayor factor primo en una lista dada de números.\n\n  La función itera a través de cada número en la lista y calcula su mayor factor primo.\n  Luego compara estos factores para encontrar el número con el mayor factor primo.\n\n  Argumentos:\n  - numbers: Un segmento de enteros.\n\n  Devuelve:\n  - El número de la lista que tiene el mayor factor primo.\n\n  Ejemplos:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) devuelve 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) devuelve 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) devuelve 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "arb": "/*\n  يجد الرقم الذي يحتوي على أكبر عامل أولي في قائمة الأرقام المعطاة.\n\n  تقوم الدالة بالمرور عبر كل رقم في القائمة وتحسب أكبر عامل أولي له.\n  ثم تقارن هذه العوامل للعثور على الرقم الذي يحتوي على أكبر عامل أولي.\n\n  الوسائط:\n  - numbers: شريحة من الأعداد الصحيحة.\n\n  يعيد:\n  - الرقم من القائمة الذي يحتوي على أكبر عامل أولي.\n\n  أمثلة:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) يعيد 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) يعيد 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) يعيد 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "sw": "/*\n  Inapata nambari yenye kigezo kikubwa zaidi cha msingi katika orodha iliyotolewa ya nambari.\n\n  Kazi inazunguka kupitia kila nambari katika orodha na kuhesabu kigezo chake kikubwa zaidi cha msingi.\n  Kisha inalinganisha vigezo hivi ili kupata nambari yenye kigezo kikubwa zaidi cha msingi.\n\n  Hoja:\n  - numbers: Kipande cha nambari za mzima.\n\n  Inarudisha:\n  - Nambari kutoka kwenye orodha ambayo ina kigezo kikubwa zaidi cha msingi.\n\n  Mifano:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) inarudisha 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) inarudisha 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) inarudisha 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "tr": "/*\n  Verilen bir sayı listesindeki en büyük asal çarpana sahip sayıyı bulur.\n\n  Fonksiyon, listedeki her sayıyı iterasyonla dolaşır ve en büyük asal çarpanını hesaplar.\n  Daha sonra bu çarpanları karşılaştırarak en büyük asal çarpana sahip sayıyı bulur.\n\n  Argümanlar:\n  - numbers: Bir dilim tamsayı.\n\n  Döndürür:\n  - Listedeki en büyük asal çarpana sahip sayıyı döndürür.\n\n  Örnekler:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) 38 döndürür\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) 22 döndürür\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) 19 döndürür\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "vi": "/*\n  Tìm số có ước số nguyên tố lớn nhất trong một danh sách các số đã cho.\n\n  Hàm lặp qua từng số trong danh sách và tính toán ước số nguyên tố lớn nhất của nó.\n  Sau đó, so sánh các ước số này để tìm số có ước số nguyên tố lớn nhất.\n\n  Tham số:\n  - numbers: Một mảng các số nguyên.\n\n  Trả về:\n  - Số từ danh sách có ước số nguyên tố lớn nhất.\n\n  Ví dụ:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) trả về 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) trả về 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) trả về 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32"
    },
    "prompt_bertscore": {
      "es": "0.9951824187383799",
      "arb": "0.9976100792553882",
      "sw": "0.987952868759853",
      "tr": "0.9828790543066979",
      "vi": "0.9796332352502067"
    },
    "canonical_solution": "{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` to solve the following problem:\nFinds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "es": "Escribe una función en Rust `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` para resolver el siguiente problema:\nEncuentra el número con el mayor factor primo en una lista dada de números.\n\n  La función itera a través de cada número en la lista y calcula su mayor factor primo. \n  Luego compara estos factores para encontrar el número con el mayor factor primo.\n\n  Argumentos:\n  - numbers: Un slice de enteros.\n\n  Retorna:\n  - El número de la lista que tiene el mayor factor primo.\n\n  Ejemplos:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) devuelve 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) devuelve 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) devuelve 19",
      "arb": "اكتب دالة بلغة Rust `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` لحل المشكلة التالية:\nإيجاد الرقم الذي يحتوي على أكبر عامل أولي في قائمة الأرقام المعطاة.\n\nتقوم الدالة بالمرور عبر كل رقم في القائمة وحساب أكبر عامل أولي له. \nثم تقارن بين هذه العوامل لإيجاد الرقم الذي يحتوي على أكبر عامل أولي.\n\nالمعاملات:\n- numbers: شريحة من الأعداد الصحيحة.\n\nالقيم المعادة:\n- الرقم من القائمة الذي يحتوي على أكبر عامل أولي.\n\nأمثلة:\n- max_prime_factor_in_list(&[36, 38, 40, 42]) يعيد 38\n- max_prime_factor_in_list(&[10, 15, 21, 22]) يعيد 22\n- max_prime_factor_in_list(&[7, 11, 13, 19]) يعيد 19",
      "sw": "Andika kazi ya Rust `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` kutatua tatizo lifuatalo:\nInapata nambari yenye kigezo kikubwa zaidi cha msingi katika orodha iliyotolewa ya nambari.\n\n  Kazi hii inazunguka kila nambari katika orodha na kuhesabu kigezo chake kikubwa zaidi cha msingi. \n  Kisha inalinganisha vigezo hivi ili kupata nambari yenye kigezo kikubwa zaidi cha msingi.\n\n  Hoja:\n  - numbers: Kipande cha nambari nzima.\n\n  Inarudisha:\n  - Nambari kutoka kwenye orodha ambayo ina kigezo kikubwa zaidi cha msingi.\n\n  Mifano:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) inarudisha 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) inarudisha 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) inarudisha 19",
      "tr": "Bir Rust fonksiyonu `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı listesindeki en büyük asal çarpana sahip sayıyı bulun.\n\n  Fonksiyon, listedeki her sayıyı iteratif olarak dolaşır ve en büyük asal çarpanını hesaplar. \n  Daha sonra bu çarpanları karşılaştırarak en büyük asal çarpana sahip sayıyı bulur.\n\n  Argümanlar:\n  - numbers: Bir tamsayı dilimi.\n\n  Döndürür:\n  - Listeden en büyük asal çarpana sahip sayıyı döndürür.\n\n  Örnekler:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) 38 döndürür\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) 22 döndürür\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) 19 döndürür",
      "vi": "Viết một hàm Rust `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` để giải quyết vấn đề sau:\nTìm số có ước số nguyên tố lớn nhất trong một danh sách các số cho trước.\n\nHàm này duyệt qua từng số trong danh sách và tính toán ước số nguyên tố lớn nhất của nó.\nSau đó, nó so sánh các ước số này để tìm ra số có ước số nguyên tố lớn nhất.\n\nTham số:\n- numbers: Một lát cắt của các số nguyên.\n\nTrả về:\n- Số từ danh sách có ước số nguyên tố lớn nhất.\n\nVí dụ:\n- max_prime_factor_in_list(&[36, 38, 40, 42]) trả về 38\n- max_prime_factor_in_list(&[10, 15, 21, 22]) trả về 22\n- max_prime_factor_in_list(&[7, 11, 13, 19]) trả về 19"
    },
    "instruction_bertscore": {
      "es": "0.9932211423560413",
      "arb": "0.9764035052545794",
      "sw": "0.9952866996884231",
      "tr": "0.9859759005774128",
      "vi": "0.9832641986155245"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_prime_factor_in_list(&[36, 38, 40, 42]), 38);\n        assert_eq!(max_prime_factor_in_list(&[10, 15, 21, 22]), 22);\n        assert_eq!(max_prime_factor_in_list(&[7, 11, 13, 19]), 19);\n        assert_eq!(max_prime_factor_in_list(&[2, 3, 5, 7]), 7);\n    }\n    \n\n}",
    "entry_point": "max_prime_factor_in_list",
    "signature": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32",
    "docstring": {
      "en": "Finds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "es": "Encuentra el número con el mayor factor primo en una lista dada de números.\n\n  La función itera a través de cada número en la lista y calcula su mayor factor primo. \n  Luego compara estos factores para encontrar el número con el mayor factor primo.\n\n  Argumentos:\n  - numbers: Una porción de enteros.\n\n  Retorna:\n  - El número de la lista que tiene el mayor factor primo.\n\n  Ejemplos:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) retorna 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) retorna 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) retorna 19",
      "arb": "يجد العدد الذي يحتوي على أكبر عامل أولي في قائمة الأعداد المعطاة.\n\nتقوم الدالة بالمرور عبر كل عدد في القائمة وتحسب أكبر عامل أولي له. ثم تقارن هذه العوامل للعثور على العدد الذي يحتوي على أكبر عامل أولي.\n\nالمعطيات:\n- numbers: شريحة من الأعداد الصحيحة.\n\nالقيم المعادة:\n- العدد من القائمة الذي يحتوي على أكبر عامل أولي.\n\nأمثلة:\n- max_prime_factor_in_list(&[36, 38, 40, 42]) يعيد 38\n- max_prime_factor_in_list(&[10, 15, 21, 22]) يعيد 22\n- max_prime_factor_in_list(&[7, 11, 13, 19]) يعيد 19",
      "sw": "Inapata nambari yenye kipengele kikubwa zaidi cha msingi katika orodha iliyotolewa ya nambari.\n\n  Kazi hii inapitia kila nambari katika orodha na kuhesabu kipengele chake kikubwa zaidi cha msingi. \n  Kisha inalinganisha vipengele hivi ili kupata nambari yenye kipengele kikubwa zaidi cha msingi.\n\n  Hoja:\n  - numbers: Sehemu ya nambari za mzima.\n\n  Inarudisha:\n  - Nambari kutoka kwenye orodha ambayo ina kipengele kikubwa zaidi cha msingi.\n\n  Mifano:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) inarudisha 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) inarudisha 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) inarudisha 19",
      "tr": "Verilen bir sayı listesindeki en büyük asal çarpana sahip sayıyı bulur.\n\n  Fonksiyon, listedeki her sayıyı iteratif olarak dolaşır ve en büyük asal çarpanını hesaplar. \n  Daha sonra bu çarpanları karşılaştırarak en büyük asal çarpana sahip sayıyı bulur.\n\n  Argümanlar:\n  - numbers: Bir tamsayı dilimi.\n\n  Döndürür:\n  - Listedeki en büyük asal çarpana sahip sayıyı.\n\n  Örnekler:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) 38 döndürür\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) 22 döndürür\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) 19 döndürür",
      "vi": "Tìm số có ước số nguyên tố lớn nhất trong một danh sách các số đã cho.\n\nHàm này duyệt qua từng số trong danh sách và tính toán ước số nguyên tố lớn nhất của nó. Sau đó, nó so sánh các ước số này để tìm ra số có ước số nguyên tố lớn nhất.\n\nCác đối số:\n- numbers: Một mảng các số nguyên.\n\nTrả về:\n- Số từ danh sách có ước số nguyên tố lớn nhất.\n\nVí dụ:\n- max_prime_factor_in_list(&[36, 38, 40, 42]) trả về 38\n- max_prime_factor_in_list(&[10, 15, 21, 22]) trả về 22\n- max_prime_factor_in_list(&[7, 11, 13, 19]) trả về 19"
    },
    "docstring_bertscore": {
      "es": "0.9942208490637899",
      "arb": "0.9726829595874149",
      "sw": "0.988363239127071",
      "tr": "0.9825958073833421",
      "vi": "0.9825566771982782"
    }
  },
  {
    "task_id": "Rust/43",
    "prompt": {
      "en": "/*\n  Calculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "es": "/*\n  Calcula la longitud de la subsecuencia no decreciente más larga en una secuencia dada de números.\n  \n  La función toma un vector de enteros y devuelve la longitud de la subsecuencia más larga donde cada elemento no es menor que el anterior.\n\n  Argumentos:\n  - sequence: Un vector de enteros.\n\n  Devuelve:\n  - La longitud de la subsecuencia no decreciente más larga en la secuencia dada.\n\n  Ejemplos:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) devuelve 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) devuelve 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) devuelve 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "arb": "/*\n  يحسب طول أطول سلسلة غير متناقصة في تسلسل معين من الأرقام.\n  \n  تأخذ الدالة متجهًا من الأعداد الصحيحة وتعيد طول أطول سلسلة حيث لا يكون أي عنصر أقل من العنصر السابق.\n\n  الوسائط:\n  - sequence: متجه من الأعداد الصحيحة.\n\n  يعيد:\n  - طول أطول سلسلة غير متناقصة في التسلسل المعطى.\n\n  أمثلة:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) يعيد 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) يعيد 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) يعيد 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "sw": "/*\n  Inahesabu urefu wa mlolongo mrefu zaidi usiopungua katika mlolongo uliotolewa wa namba.\n  \n  Kazi inachukua vekta ya namba nzima na kurudisha urefu wa mlolongo mrefu zaidi ambapo kila kipengele si chini ya kile kilichotangulia.\n\n  Hoja:\n  - sequence: Vekta ya namba nzima.\n\n  Inarudisha:\n  - Urefu wa mlolongo mrefu zaidi usiopungua katika mlolongo uliotolewa.\n\n  Mifano:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) inarudisha 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) inarudisha 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) inarudisha 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "tr": "/*\n  Verilen bir sayı dizisindeki en uzun artmayan alt dizinin uzunluğunu hesaplar.\n  \n  Fonksiyon bir tamsayı vektörü alır ve her elemanın bir öncekinden küçük olmadığı en uzun alt dizinin uzunluğunu döndürür.\n\n  Argümanlar:\n  - sequence: Bir tamsayı vektörü.\n\n  Döndürür:\n  - Verilen dizideki en uzun artmayan alt dizinin uzunluğunu.\n\n  Örnekler:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 döndürür\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 döndürür\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 döndürür\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "vi": "/*\n  Tính độ dài của dãy con không giảm dài nhất trong một dãy số cho trước.\n  \n  Hàm nhận một vector số nguyên và trả về độ dài của dãy con dài nhất mà mỗi phần tử không nhỏ hơn phần tử trước đó.\n\n  Tham số:\n  - sequence: Một vector số nguyên.\n\n  Trả về:\n  - Độ dài của dãy con không giảm dài nhất trong dãy cho trước.\n\n  Ví dụ:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) trả về 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) trả về 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) trả về 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.991784448810016",
      "sw": "0.9874423886805933",
      "tr": "0.9806746543379726",
      "vi": "0.9879461153268978"
    },
    "canonical_solution": "{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}",
    "instruction": {
      "en": "Write a Rust function `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` to solve the following problem:\nCalculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4",
      "es": "Escribe una función en Rust `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` para resolver el siguiente problema:\nCalcula la longitud de la subsecuencia no decreciente más larga en una secuencia dada de números.\n  \n  La función toma un vector de enteros y devuelve la longitud de la subsecuencia más larga donde cada elemento no es menor que el anterior.\n\n  Argumentos:\n  - sequence: Un vector de enteros.\n\n  Devuelve:\n  - La longitud de la subsecuencia no decreciente más larga en la secuencia dada.\n\n  Ejemplos:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) devuelve 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) devuelve 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) devuelve 4",
      "arb": "اكتب دالة Rust `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` لحل المشكلة التالية:\nتحسب طول أطول تسلسل غير تناقصي في تسلسل معين من الأرقام.\n\nتأخذ الدالة متجهًا من الأعداد الصحيحة وتعيد طول أطول تسلسل حيث لا يكون أي عنصر أقل من العنصر السابق.\n\nالمعطيات:\n- sequence: متجه من الأعداد الصحيحة.\n\nالقيم المعادة:\n- طول أطول تسلسل غير تناقصي في التسلسل المعطى.\n\nأمثلة:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) يعيد 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) يعيد 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) يعيد 4",
      "sw": "Andika kazi ya Rust `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` kutatua tatizo lifuatalo:\nInakokotoa urefu wa mlolongo mrefu zaidi usiopungua katika mlolongo uliotolewa wa namba.\n\n  Kazi inachukua vector ya namba nzima na inarudisha urefu wa mlolongo mrefu zaidi ambapo kila kipengele si chini ya kile kilichotangulia.\n\n  Hoja:\n  - sequence: Vector ya namba nzima.\n\n  Inarudisha:\n  - Urefu wa mlolongo mrefu zaidi usiopungua katika mlolongo uliotolewa.\n\n  Mifano:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) inarudisha 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) inarudisha 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) inarudisha 4",
      "tr": "Bir Rust fonksiyonu `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı dizisindeki en uzun azalmayan alt dizinin uzunluğunu hesaplar.\n\nFonksiyon, bir tamsayı vektörü alır ve her bir elemanın bir öncekinden küçük olmadığı en uzun alt dizinin uzunluğunu döndürür.\n\nArgümanlar:\n- sequence: Bir tamsayı vektörü.\n\nDöndürülenler:\n- Verilen dizideki en uzun azalmayan alt dizinin uzunluğu.\n\nÖrnekler:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 döndürür\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 döndürür\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 döndürür",
      "vi": "Viết một hàm Rust `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` để giải quyết vấn đề sau:\nTính độ dài của dãy con không giảm dài nhất trong một dãy số đã cho.\n\nHàm nhận một vector các số nguyên và trả về độ dài của dãy con dài nhất mà mỗi phần tử không nhỏ hơn phần tử trước đó.\n\nTham số:\n- sequence: Một vector các số nguyên.\n\nTrả về:\n- Độ dài của dãy con không giảm dài nhất trong dãy đã cho.\n\nVí dụ:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) trả về 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) trả về 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) trả về 4"
    },
    "instruction_bertscore": {
      "es": "0.9936070811863921",
      "arb": "0.981963765510889",
      "sw": "0.9843628232530284",
      "tr": "0.9866913672099005",
      "vi": "0.9888989452647222"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![1, 2, 3]), 3);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]), 4);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]), 4);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![]), 0);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![10]), 1);        \n    }\n    \n\n}",
    "entry_point": "longest_non_decreasing_subsequence_length",
    "signature": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize",
    "docstring": {
      "en": "Calculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4",
      "es": "Calcula la longitud de la subsecuencia no decreciente más larga en una secuencia dada de números.\n\n  La función toma un vector de enteros y devuelve la longitud de la subsecuencia más larga donde cada elemento no es menor que el anterior.\n\n  Argumentos:\n  - sequence: Un vector de enteros.\n\n  Devuelve:\n  - La longitud de la subsecuencia no decreciente más larga en la secuencia dada.\n\n  Ejemplos:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) devuelve 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) devuelve 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) devuelve 4",
      "arb": "يحسب طول أطول سلسلة غير متناقصة في تسلسل معين من الأرقام.\n\nتأخذ الدالة متجهًا من الأعداد الصحيحة وتعيد طول أطول سلسلة حيث لا يكون أي عنصر أقل من العنصر السابق.\n\nالمعطيات:\n- sequence: متجه من الأعداد الصحيحة.\n\nالقيم المعادة:\n- طول أطول سلسلة غير متناقصة في التسلسل المعطى.\n\nأمثلة:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) يعيد 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) يعيد 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) يعيد 4",
      "sw": "Hesabu urefu wa mlolongo mrefu zaidi usiopungua katika mlolongo uliotolewa wa namba.\n\nKazi hii inachukua vekta ya namba nzima na inarejesha urefu wa mlolongo mrefu zaidi ambapo kila kipengele si kidogo kuliko kile kilichotangulia.\n\nHoja:\n- sequence: Vekta ya namba nzima.\n\nInarejesha:\n- Urefu wa mlolongo mrefu zaidi usiopungua katika mlolongo uliotolewa.\n\nMifano:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) inarejesha 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) inarejesha 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) inarejesha 4",
      "tr": "Verilen bir sayı dizisindeki en uzun artmayan alt dizinin uzunluğunu hesaplar.\n\nFonksiyon, bir tamsayı vektörü alır ve her bir elemanın bir öncekinden küçük olmadığı en uzun alt dizinin uzunluğunu döndürür.\n\nArgümanlar:\n- sequence: Bir tamsayı vektörü.\n\nDöndürülenler:\n- Verilen dizideki en uzun artmayan alt dizinin uzunluğu.\n\nÖrnekler:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 döndürür\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 döndürür\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 döndürür",
      "vi": "Tính độ dài của dãy con không giảm dài nhất trong một dãy số đã cho.\n\nHàm nhận một vector số nguyên và trả về độ dài của dãy con dài nhất mà mỗi phần tử không nhỏ hơn phần tử trước đó.\n\nCác đối số:\n- sequence: Một vector số nguyên.\n\nTrả về:\n- Độ dài của dãy con không giảm dài nhất trong dãy đã cho.\n\nVí dụ:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) trả về 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) trả về 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) trả về 4"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9795370981457858",
      "sw": "0.9925666552505313",
      "tr": "0.9704614774059207",
      "vi": "0.9906776803268896"
    }
  },
  {
    "task_id": "Rust/44",
    "prompt": {
      "en": "/*\n  Counts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "es": "/*\n  Cuenta el número de pares de estudiantes cuyas puntuaciones en cada materia (Chino, Matemáticas, Inglés) difieren en no más de 5 puntos, y cuya diferencia de puntuación total es de no más de 10 puntos. Tales pares se consideran \"igualmente emparejados\".\n\n  Argumentos:\n  - scores: Un vector de tuplas, cada una contiene tres enteros que representan las puntuaciones de un estudiante en Chino, Matemáticas e Inglés, respectivamente.\n\n  Devuelve:\n  - Un entero que representa el número de pares de estudiantes \"igualmente emparejados\".\n\n  Ejemplo:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) devuelve 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "arb": "/*\n  يحسب عدد أزواج الطلاب الذين تختلف درجاتهم في كل مادة (الصينية، الرياضيات، الإنجليزية) بما لا يزيد عن 5 نقاط، والذين يكون فرق مجموع درجاتهم لا يزيد عن 10 نقاط. تعتبر مثل هذه الأزواج \"متكافئة\".\n\n  الوسائط:\n  - scores: متجه من الأزواج، يحتوي كل منها على ثلاثة أعداد صحيحة تمثل درجات الطالب في الصينية، الرياضيات، والإنجليزية على التوالي.\n\n  يعيد:\n  - عدد صحيح يمثل عدد أزواج الطلاب \"المتكافئة\".\n\n  مثال:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) يعيد 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ya jozi za wanafunzi ambao alama zao katika kila somo (Kichina, Hisabati, Kiingereza) zinatofautiana kwa si zaidi ya pointi 5, na tofauti ya jumla ya alama ni si zaidi ya pointi 10. Jozi kama hizo zinachukuliwa kuwa \"zinashabihiana sawa\".\n\n  Hoja:\n  - scores: Vector ya jozi, kila moja ikiwa na nambari tatu za mzima zinazoashiria alama za mwanafunzi katika Kichina, Hisabati, na Kiingereza, mtawalia.\n\n  Inarejesha:\n  - Nambari ya mzima inayowakilisha idadi ya jozi za wanafunzi \"zinazoshabihiana sawa\".\n\n  Mfano:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) inarejesha 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "tr": "/*\n  Her bir dersteki (Çince, Matematik, İngilizce) puanları arasındaki fark 5 puandan fazla olmayan ve toplam puan farkı 10 puandan fazla olmayan öğrenci çiftlerinin sayısını sayar. Bu tür çiftler \"eşit derecede uyumlu\" olarak kabul edilir.\n\n  Argümanlar:\n  - scores: Her biri bir öğrencinin Çince, Matematik ve İngilizce derslerindeki puanlarını temsil eden üç tam sayı içeren bir demet vektörü.\n\n  Döndürür:\n  - \"Eşit derecede uyumlu\" öğrenci çiftlerinin sayısını temsil eden bir tam sayı.\n\n  Örnek:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 döndürür\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "vi": "/*\n  Đếm số cặp học sinh có điểm số trong mỗi môn học (Ngữ văn, Toán, Tiếng Anh) chênh lệch không quá 5 điểm, và tổng điểm chênh lệch không quá 10 điểm. Những cặp như vậy được coi là \"tương xứng\".\n\n  Tham số:\n  - scores: Một vector chứa các bộ ba số nguyên, mỗi bộ ba đại diện cho điểm số của một học sinh trong các môn Ngữ văn, Toán và Tiếng Anh, tương ứng.\n\n  Trả về:\n  - Một số nguyên đại diện cho số cặp học sinh \"tương xứng\".\n\n  Ví dụ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) trả về 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9930185393673857",
      "arb": "0.9554005273943313",
      "sw": "0.9756570522826503",
      "tr": "0.9703665320837861",
      "vi": "0.9318042312792918"
    },
    "canonical_solution": "{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` to solve the following problem:\nCounts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2",
      "es": "Escribe una función en Rust `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` para resolver el siguiente problema:\nCuenta el número de pares de estudiantes cuyas puntuaciones en cada asignatura (Chino, Matemáticas, Inglés) difieren en no más de 5 puntos, y cuya diferencia de puntuación total es de no más de 10 puntos. Tales pares se consideran \"igualmente emparejados\".\n\n  Argumentos:\n  - scores: Un vector de tuplas, cada una contiene tres enteros que representan las puntuaciones de un estudiante en Chino, Matemáticas e Inglés, respectivamente.\n\n  Devuelve:\n  - Un entero que representa el número de pares de estudiantes \"igualmente emparejados\".\n\n  Ejemplo:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) devuelve 2",
      "arb": "اكتب دالة Rust `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` لحل المشكلة التالية:\nتحسب عدد أزواج الطلاب الذين تختلف درجاتهم في كل مادة (الصينية، الرياضيات، الإنجليزية) بما لا يزيد عن 5 نقاط، والذين يكون فرق مجموع درجاتهم لا يزيد عن 10 نقاط. تعتبر مثل هذه الأزواج \"متكافئة\".\n\n  الوسائط:\n  - scores: متجه من الأزواج، يحتوي كل منها على ثلاثة أعداد صحيحة تمثل درجات الطالب في الصينية، الرياضيات، والإنجليزية، على التوالي.\n\n  يعيد:\n  - عدد صحيح يمثل عدد أزواج الطلاب \"المتكافئة\".\n\n  مثال:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) يعيد 2",
      "sw": "Andika kazi ya Rust `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` kutatua tatizo lifuatalo:\nHesabu idadi ya jozi za wanafunzi ambao alama zao katika kila somo (Kichina, Hisabati, Kiingereza) zinatofautiana kwa si zaidi ya pointi 5, na tofauti ya alama zao jumla ni si zaidi ya pointi 10. Jozi kama hizo zinachukuliwa kuwa \"zimefanana sawa\".\n\n  Hoja:\n  - scores: Vector ya tuples, kila moja ikiwa na namba tatu za mzima zinazowakilisha alama za mwanafunzi katika Kichina, Hisabati, na Kiingereza, mtawalia.\n\n  Inarudisha:\n  - Namba ya mzima inayowakilisha idadi ya jozi za wanafunzi \"zilizofanana sawa\".\n\n  Mfano:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) inarudisha 2",
      "tr": "Bir Rust fonksiyonu `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` yazın:\nHer bir dersteki (Çince, Matematik, İngilizce) puanları en fazla 5 puan fark eden ve toplam puan farkı en fazla 10 puan olan öğrenci çiftlerinin sayısını sayar. Bu tür çiftler \"eşit derecede eşleşmiş\" olarak kabul edilir.\n\n  Argümanlar:\n  - scores: Her biri bir öğrencinin Çince, Matematik ve İngilizce'deki puanlarını temsil eden üç tam sayı içeren bir demet vektörü.\n\n  Döndürür:\n  - \"Eşit derecede eşleşmiş\" öğrenci çiftlerinin sayısını temsil eden bir tam sayı.\n\n  Örnek:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 döndürür.",
      "vi": "Viết một hàm Rust `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` để giải quyết vấn đề sau:\nĐếm số cặp học sinh có điểm số trong mỗi môn học (Ngữ văn, Toán, Tiếng Anh) chênh lệch không quá 5 điểm, và tổng điểm chênh lệch không quá 10 điểm. Những cặp như vậy được coi là \"ngang tài ngang sức\".\n\n  Tham số:\n  - scores: Một vector chứa các bộ ba số nguyên, mỗi bộ đại diện cho điểm số của một học sinh trong các môn Ngữ văn, Toán, và Tiếng Anh, theo thứ tự tương ứng.\n\n  Trả về:\n  - Một số nguyên đại diện cho số cặp học sinh \"ngang tài ngang sức\".\n\n  Ví dụ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9910594479192386",
      "arb": "0.967758117920036",
      "sw": "0.969210900526925",
      "tr": "0.9607681161810372",
      "vi": "0.9584546681331239"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]), 2);\n        assert_eq!(count_comparable_pairs(vec![(100, 100, 100), (95, 95, 95), (90, 90, 90)]), 0);\n        assert_eq!(count_comparable_pairs(vec![(90, 85, 80), (80, 85, 90), (70, 75, 80)]), 0);\n        assert_eq!(count_comparable_pairs(vec![(90, 90, 90)]), 0);\n    }\n    \n\n}",
    "entry_point": "count_comparable_pairs",
    "signature": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32",
    "docstring": {
      "en": "Counts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2",
      "es": "Cuenta el número de pares de estudiantes cuyas puntuaciones en cada asignatura (Chino, Matemáticas, Inglés) difieren en no más de 5 puntos, y cuya diferencia de puntuación total no es superior a 10 puntos. Tales pares se consideran \"igualmente emparejados\".\n\n  Argumentos:\n  - scores: Un vector de tuplas, cada una contiene tres enteros que representan las puntuaciones de un estudiante en Chino, Matemáticas e Inglés, respectivamente.\n\n  Devuelve:\n  - Un entero que representa el número de pares de estudiantes \"igualmente emparejados\".\n\n  Ejemplo:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) devuelve 2",
      "arb": "يحسب عدد أزواج الطلاب الذين تختلف درجاتهم في كل مادة (الصينية، الرياضيات، الإنجليزية) بما لا يزيد عن 5 نقاط، والذين يكون فرق مجموع درجاتهم لا يزيد عن 10 نقاط. تعتبر مثل هذه الأزواج \"متكافئة\".\n\n  الحجج:\n  - scores: متجه من الأزواج، يحتوي كل منها على ثلاثة أعداد صحيحة تمثل درجات الطالب في الصينية والرياضيات والإنجليزية، على التوالي.\n\n  يعيد:\n  - عدد صحيح يمثل عدد أزواج الطلاب \"المتكافئة\".\n\n  مثال:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) يعيد 2",
      "sw": "Hesabu idadi ya jozi za wanafunzi ambao alama zao katika kila somo (Kichina, Hisabati, Kiingereza) zinatofautiana kwa si zaidi ya pointi 5, na tofauti ya jumla ya alama zao ni si zaidi ya pointi 10. Jozi kama hizo zinachukuliwa kuwa \"zinazoendana sawa\".\n\n  Hoja:\n  - scores: Vector ya tuples, kila moja ikiwa na namba tatu za mzima zinazoashiria alama za mwanafunzi katika Kichina, Hisabati, na Kiingereza, mtawalia.\n\n  Inarudisha:\n  - Namba ya mzima inayowakilisha idadi ya jozi za wanafunzi \"zinazoendana sawa\".\n\n  Mfano:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) inarudisha 2",
      "tr": "Çin dili, Matematik ve İngilizce derslerinde her bir öğrencinin puanlarının farkı en fazla 5 puan olan ve toplam puan farkı en fazla 10 puan olan öğrenci çiftlerinin sayısını sayar. Bu tür çiftler \"eşit derecede eşleşmiş\" olarak kabul edilir.\n\n  Argümanlar:\n  - scores: Her biri bir öğrencinin sırasıyla Çin dili, Matematik ve İngilizce derslerindeki puanlarını temsil eden üç tam sayı içeren demetlerin bir vektörü.\n\n  Döndürür:\n  - \"Eşit derecede eşleşmiş\" öğrenci çiftlerinin sayısını temsil eden bir tam sayı.\n\n  Örnek:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 döndürür.",
      "vi": "Đếm số cặp học sinh có điểm số trong mỗi môn học (Ngữ văn, Toán, Tiếng Anh) chênh lệch không quá 5 điểm, và tổng điểm chênh lệch không quá 10 điểm. Những cặp như vậy được coi là \"tương xứng\".\n\n  Tham số:\n  - scores: Một vector chứa các bộ ba, mỗi bộ ba bao gồm ba số nguyên đại diện cho điểm số của một học sinh trong các môn Ngữ văn, Toán và Tiếng Anh, tương ứng.\n\n  Trả về:\n  - Một số nguyên đại diện cho số lượng cặp học sinh \"tương xứng\".\n\n  Ví dụ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9907251529879569",
      "arb": "0.9460184199765295",
      "sw": "0.9610835412261206",
      "tr": "0.9511693030175262",
      "vi": "0.9283571996468124"
    }
  },
  {
    "task_id": "Rust/45",
    "prompt": {
      "en": "/*\n  Calculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "es": "/*\n  Calcula el número total de cigarrillos que Peter puede fumar dado un monto inicial y una tasa de conversión de colillas de cigarrillos a nuevos cigarrillos.\n\n  Argumentos:\n  - initial_cigarettes: El número inicial de cigarrillos que tiene Peter.\n  - butts_for_new: El número de colillas de cigarrillos requeridas para intercambiar por un nuevo cigarrillo.\n\n  Devuelve:\n  - El número total de cigarrillos que Peter puede fumar, incluidos aquellos obtenidos al intercambiar colillas por nuevos.\n\n  Ejemplo:\n  - total_smoked_cigarettes(4, 3) devuelve 5\n  - total_smoked_cigarettes(10, 3) devuelve 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "arb": "/*\n  يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بناءً على كمية أولية ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.\n\n  المعطيات:\n  - initial_cigarettes: العدد الأولي للسجائر التي يمتلكها بيتر.\n  - butts_for_new: عدد أعقاب السجائر المطلوبة لتبادلها بسجارة جديدة واحدة.\n\n  يعيد:\n  - العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بما في ذلك تلك التي تم الحصول عليها من خلال تبادل الأعقاب بسجائر جديدة.\n\n  مثال:\n  - total_smoked_cigarettes(4, 3) يعيد 5\n  - total_smoked_cigarettes(10, 3) يعيد 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "sw": "/*\n  Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na kiasi cha awali na kiwango cha kubadilisha vipande vya sigara kuwa sigara mpya.\n\n  Hoja:\n  - initial_cigarettes: Idadi ya awali ya sigara ambazo Peter anazo.\n  - butts_for_new: Idadi ya vipande vya sigara vinavyohitajika kubadilishwa kwa sigara moja mpya.\n\n  Inarudisha:\n  - Jumla ya sigara ambazo Peter anaweza kuvuta ikiwa ni pamoja na zile zinazopatikana kwa kubadilisha vipande kwa mpya.\n\n  Mfano:\n  - total_smoked_cigarettes(4, 3) inarudisha 5\n  - total_smoked_cigarettes(10, 3) inarudisha 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "tr": "/*\n  Peter'ın başlangıç miktarı ve izmaritlerin yeni sigaralara dönüştürülme oranı verildiğinde, toplam kaç sigara içebileceğini hesaplar.\n\n  Argümanlar:\n  - initial_cigarettes: Peter'ın sahip olduğu başlangıç sigara sayısı.\n  - butts_for_new: Bir yeni sigara ile değiştirilebilecek izmarit sayısı.\n\n  Döndürür:\n  - Peter'ın izmaritleri yenileriyle değiştirerek elde ettikleri de dahil olmak üzere içebileceği toplam sigara sayısı.\n\n  Örnek:\n  - total_smoked_cigarettes(4, 3) 5 döndürür\n  - total_smoked_cigarettes(10, 3) 14 döndürür\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "vi": "/*\n  Tính tổng số điếu thuốc mà Peter có thể hút được với số lượng ban đầu và tỷ lệ đổi đầu mẩu thuốc lá thành điếu thuốc mới.\n\n  Tham số:\n  - initial_cigarettes: Số lượng điếu thuốc ban đầu mà Peter có.\n  - butts_for_new: Số lượng đầu mẩu thuốc lá cần thiết để đổi lấy một điếu thuốc mới.\n\n  Trả về:\n  - Tổng số điếu thuốc mà Peter có thể hút bao gồm cả những điếu thuốc có được bằng cách đổi đầu mẩu lấy điếu mới.\n\n  Ví dụ:\n  - total_smoked_cigarettes(4, 3) trả về 5\n  - total_smoked_cigarettes(10, 3) trả về 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9855430849771377",
      "arb": "0.9805215103141948",
      "sw": "0.9725608019030785",
      "tr": "0.9851241735035352",
      "vi": "0.9640627983112628"
    },
    "canonical_solution": "{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}",
    "instruction": {
      "en": "Write a Rust function `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14",
      "es": "Escribe una función en Rust `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` para resolver el siguiente problema:\nCalcula el número total de cigarrillos que Pedro puede fumar dado un monto inicial y una tasa de conversión de colillas de cigarrillo a nuevos cigarrillos.\n\n  Argumentos:\n  - initial_cigarettes: El número inicial de cigarrillos que tiene Pedro.\n  - butts_for_new: El número de colillas de cigarrillo requeridas para intercambiar por un cigarrillo nuevo.\n\n  Devuelve:\n  - El número total de cigarrillos que Pedro puede fumar, incluidos aquellos obtenidos al intercambiar colillas por nuevos.\n\n  Ejemplo:\n  - total_smoked_cigarettes(4, 3) devuelve 5\n  - total_smoked_cigarettes(10, 3) devuelve 14",
      "arb": "اكتب دالة Rust `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` لحل المشكلة التالية:\nتحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر بالنظر إلى كمية ابتدائية ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.\n\n  الوسائط:\n  - initial_cigarettes: العدد الابتدائي للسجائر التي يمتلكها بيتر.\n  - butts_for_new: عدد أعقاب السجائر المطلوبة للتبادل مقابل سيجارة جديدة واحدة.\n\n  يعيد:\n  - العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر بما في ذلك تلك التي تم الحصول عليها عن طريق تبادل الأعقاب للحصول على سجائر جديدة.\n\n  مثال:\n  - total_smoked_cigarettes(4, 3) يعيد 5\n  - total_smoked_cigarettes(10, 3) يعيد 14",
      "sw": "Andika kazi ya Rust `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` kutatua tatizo lifuatalo:\nHesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na kiasi cha awali na kiwango cha ubadilishaji wa vishina vya sigara kuwa sigara mpya.\n\n  Hoja:\n  - initial_cigarettes: Idadi ya awali ya sigara ambazo Peter anazo.\n  - butts_for_new: Idadi ya vishina vya sigara vinavyohitajika kubadilishwa kwa sigara moja mpya.\n\n  Inarudisha:\n  - Jumla ya sigara ambazo Peter anaweza kuvuta ikiwa ni pamoja na zile zilizopatikana kwa kubadilisha vishina kwa sigara mpya.\n\n  Mfano:\n  - total_smoked_cigarettes(4, 3) inarudisha 5\n  - total_smoked_cigarettes(10, 3) inarudisha 14",
      "tr": "Bir Rust fonksiyonu `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` yazarak aşağıdaki problemi çözün:\nPeter'ın başlangıç miktarı ve sigara izmaritlerini yeni sigaralara dönüştürme oranı verildiğinde, toplam içebileceği sigara sayısını hesaplar.\n\n  Argümanlar:\n  - initial_cigarettes: Peter'ın sahip olduğu başlangıç sigara sayısı.\n  - butts_for_new: Bir yeni sigara ile değiştirmek için gereken sigara izmariti sayısı.\n\n  Döndürür:\n  - Peter'ın izmaritleri yeni sigaralarla değiştirerek elde ettikleri de dahil olmak üzere içebileceği toplam sigara sayısı.\n\n  Örnek:\n  - total_smoked_cigarettes(4, 3) 5 döndürür\n  - total_smoked_cigarettes(10, 3) 14 döndürür",
      "vi": "Viết một hàm Rust `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` để giải quyết vấn đề sau:\nTính tổng số điếu thuốc mà Peter có thể hút được với số lượng ban đầu và tỷ lệ chuyển đổi từ đầu lọc thuốc lá thành điếu thuốc mới.\n\n  Tham số:\n  - initial_cigarettes: Số lượng điếu thuốc ban đầu mà Peter có.\n  - butts_for_new: Số lượng đầu lọc thuốc lá cần thiết để đổi lấy một điếu thuốc mới.\n\n  Trả về:\n  - Tổng số điếu thuốc mà Peter có thể hút bao gồm cả những điếu thuốc có được bằng cách đổi đầu lọc lấy điếu mới.\n\n  Ví dụ:\n  - total_smoked_cigarettes(4, 3) trả về 5\n  - total_smoked_cigarettes(10, 3) trả về 14"
    },
    "instruction_bertscore": {
      "es": "0.9768178482294182",
      "arb": "0.9855621534937171",
      "sw": "0.9865831136522364",
      "tr": "0.969836784857566",
      "vi": "0.9733221521535852"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(total_smoked_cigarettes(4, 3), 5);\n        assert_eq!(total_smoked_cigarettes(10, 3), 14);\n        assert_eq!(total_smoked_cigarettes(1, 2), 1); // Edge case: Not enough to exchange\n        assert_eq!(total_smoked_cigarettes(100, 5), 124); // Larger numbers\n    }\n    \n\n}",
    "entry_point": "total_smoked_cigarettes",
    "signature": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14",
      "es": "Calcula el número total de cigarrillos que Peter puede fumar dado un monto inicial y una tasa de conversión de colillas de cigarrillos a nuevos cigarrillos.\n\n  Argumentos:\n  - initial_cigarettes: El número inicial de cigarrillos que Peter tiene.\n  - butts_for_new: El número de colillas de cigarrillos requeridas para intercambiar por un cigarrillo nuevo.\n\n  Retorna:\n  - El número total de cigarrillos que Peter puede fumar, incluyendo aquellos obtenidos al intercambiar colillas por nuevos.\n\n  Ejemplo:\n  - total_smoked_cigarettes(4, 3) devuelve 5\n  - total_smoked_cigarettes(10, 3) devuelve 14",
      "arb": "يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بناءً على كمية ابتدائية ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.\n\n  الحجج:\n  - initial_cigarettes: العدد الابتدائي للسجائر التي يمتلكها بيتر.\n  - butts_for_new: عدد أعقاب السجائر المطلوب لتبادلها بسجارة جديدة واحدة.\n\n  يعيد:\n  - العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بما في ذلك تلك التي تم الحصول عليها عن طريق تبادل الأعقاب بسجائر جديدة.\n\n  مثال:\n  - total_smoked_cigarettes(4, 3) يعيد 5\n  - total_smoked_cigarettes(10, 3) يعيد 14",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na kiasi cha awali na kiwango cha kubadilisha vipande vya sigara kuwa sigara mpya.\n\n  Hoja:\n  - initial_cigarettes: Idadi ya awali ya sigara ambazo Peter anazo.\n  - butts_for_new: Idadi ya vipande vya sigara vinavyohitajika kubadilishwa kwa sigara moja mpya.\n\n  Inarejesha:\n  - Jumla ya sigara ambazo Peter anaweza kuvuta ikiwa ni pamoja na zile zilizopatikana kwa kubadilisha vipande kuwa mpya.\n\n  Mfano:\n  - total_smoked_cigarettes(4, 3) inarejesha 5\n  - total_smoked_cigarettes(10, 3) inarejesha 14",
      "tr": "Peter'ın başlangıç miktarı ve izmaritlerin yeni sigaralara dönüştürülme oranı verildiğinde, içebileceği toplam sigara sayısını hesaplar.\n\n  Argümanlar:\n  - initial_cigarettes: Peter'ın sahip olduğu başlangıç sigara sayısı.\n  - butts_for_new: Bir yeni sigara ile değiştirilebilecek izmarit sayısı.\n\n  Döndürür:\n  - Peter'ın izmaritleri yeni sigaralarla değiştirerek elde ettikleri de dahil olmak üzere içebileceği toplam sigara sayısı.\n\n  Örnek:\n  - total_smoked_cigarettes(4, 3) 5 döndürür\n  - total_smoked_cigarettes(10, 3) 14 döndürür",
      "vi": "Tính tổng số điếu thuốc lá mà Peter có thể hút được với một số lượng ban đầu và tỷ lệ chuyển đổi từ đầu lọc thuốc lá thành điếu thuốc mới.\n\n  Tham số:\n  - initial_cigarettes: Số lượng điếu thuốc ban đầu mà Peter có.\n  - butts_for_new: Số lượng đầu lọc thuốc lá cần thiết để đổi lấy một điếu thuốc mới.\n\n  Trả về:\n  - Tổng số điếu thuốc mà Peter có thể hút bao gồm cả những điếu có được bằng cách đổi đầu lọc lấy điếu mới.\n\n  Ví dụ:\n  - total_smoked_cigarettes(4, 3) trả về 5\n  - total_smoked_cigarettes(10, 3) trả về 14"
    },
    "docstring_bertscore": {
      "es": "0.9830882120979275",
      "arb": "0.9843465355617835",
      "sw": "0.9618762750768308",
      "tr": "0.9345288442159474",
      "vi": "0.9589365454375145"
    }
  },
  {
    "task_id": "Rust/46",
    "prompt": {
      "en": "/*\n  Finds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "es": "/*\n  Encuentra la longitud de la secuencia consecutiva más larga en el arreglo dado de números.\n  Una secuencia consecutiva se define como una secuencia de enteros donde cada número sigue al anterior por exactamente uno.\n  Esta función no requiere que el arreglo de entrada esté ordenado.\n\n  Argumentos:\n  - numbers: Un segmento de enteros que representa la secuencia.\n\n  Retorna:\n  - La longitud de la secuencia consecutiva más larga encontrada en el arreglo.\n\n  Ejemplo:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) retorna 4 (porque la secuencia consecutiva más larga es 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) retorna 5 (porque la secuencia es 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) retorna 4 (porque la secuencia es 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "arb": "/*\n  يجد طول أطول سلسلة متتالية في مصفوفة الأرقام المعطاة.\n  تُعرّف السلسلة المتتالية على أنها سلسلة من الأعداد الصحيحة حيث يتبع كل عدد العدد السابق بفارق واحد بالضبط.\n  لا تتطلب هذه الدالة أن تكون مصفوفة الإدخال مرتبة.\n\n  المعطيات:\n  - numbers: جزء من الأعداد الصحيحة يمثل السلسلة.\n\n  المخرجات:\n  - طول أطول سلسلة متتالية تم العثور عليها في المصفوفة.\n\n  مثال:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) يعيد 4 (لأن أطول سلسلة متتالية هي 1، 2، 3، 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) يعيد 5 (لأن السلسلة هي 1، 2، 3، 4، 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) يعيد 4 (لأن السلسلة هي 1، 2، 3، 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "sw": "/*\n  Inapata urefu wa mlolongo mrefu zaidi wa mfululizo katika safu iliyotolewa ya nambari.\n  Mlolongo wa mfululizo unafafanuliwa kama mlolongo wa nambari za mzima ambapo kila nambari inafuata ile ya awali kwa moja tu.\n  Kazi hii haihitaji safu ya ingizo kupangwa.\n\n  Hoja:\n  - numbers: Sehemu ya nambari za mzima inayoashiria mlolongo.\n\n  Inarejesha:\n  - Urefu wa mlolongo mrefu zaidi wa mfululizo uliopatikana katika safu.\n\n  Mfano:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) inarejesha 4 (kwa sababu mlolongo mrefu zaidi wa mfululizo ni 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) inarejesha 5 (kwa sababu mlolongo ni 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) inarejesha 4 (kwa sababu mlolongo ni 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "tr": "/*\n  Verilen sayı dizisindeki en uzun ardışık dizinin uzunluğunu bulur.\n  Ardışık bir dizi, her sayının bir önceki sayıyı tam olarak bir birim takip ettiği bir tamsayılar dizisi olarak tanımlanır.\n  Bu fonksiyon, giriş dizisinin sıralı olmasını gerektirmez.\n\n  Argümanlar:\n  - numbers: Diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizide bulunan en uzun ardışık dizinin uzunluğu.\n\n  Örnek:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 4 döndürür (çünkü en uzun ardışık dizi 1, 2, 3, 4'tür)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 5 döndürür (çünkü dizi 1, 2, 3, 4, 5'tir)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 4 döndürür (çünkü dizi 1, 2, 3, 4'tür)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "vi": "/*\n  Tìm độ dài của dãy số liên tiếp dài nhất trong mảng số đã cho.\n  Một dãy số liên tiếp được định nghĩa là một dãy số nguyên mà mỗi số theo sau số trước đó đúng một đơn vị.\n  Hàm này không yêu cầu mảng đầu vào phải được sắp xếp.\n\n  Tham số:\n  - numbers: Một lát cắt của các số nguyên đại diện cho dãy số.\n\n  Trả về:\n  - Độ dài của dãy số liên tiếp dài nhất được tìm thấy trong mảng.\n\n  Ví dụ:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) trả về 4 (vì dãy số liên tiếp dài nhất là 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) trả về 5 (vì dãy số là 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) trả về 4 (vì dãy số là 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.9942335614081762",
      "arb": "0.9891418702207279",
      "sw": "1",
      "tr": "0.9942846094161021",
      "vi": "0.9880132523956876"
    },
    "canonical_solution": "{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}",
    "instruction": {
      "en": "Write a Rust function `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` to solve the following problem:\nFinds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)",
      "es": "Escribe una función de Rust `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia consecutiva más larga en el arreglo dado de números.\n  Una secuencia consecutiva se define como una secuencia de enteros donde cada número sigue al anterior por exactamente uno.\n  Esta función no requiere que el arreglo de entrada esté ordenado.\n\n  Argumentos:\n  - numbers: Una porción de enteros que representa la secuencia.\n\n  Retorna:\n  - La longitud de la secuencia consecutiva más larga encontrada en el arreglo.\n\n  Ejemplo:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) retorna 4 (porque la secuencia consecutiva más larga es 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) retorna 5 (porque la secuencia es 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) retorna 4 (porque la secuencia es 1, 2, 3, 4)",
      "arb": "اكتب دالة Rust `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` لحل المشكلة التالية:\nإيجاد طول أطول تسلسل متتابع في مصفوفة الأرقام المعطاة.\nيُعرّف التسلسل المتتابع على أنه تسلسل من الأعداد الصحيحة حيث يتبع كل عدد العدد السابق بفارق واحد بالضبط.\nهذه الدالة لا تتطلب أن تكون مصفوفة الإدخال مرتبة.\n\nالمعاملات:\n- numbers: شريحة من الأعداد الصحيحة تمثل التسلسل.\n\nالقيم المعادة:\n- طول أطول تسلسل متتابع موجود في المصفوفة.\n\nمثال:\n- longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) يعيد 4 (لأن أطول تسلسل متتابع هو 1، 2، 3، 4)\n- longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) يعيد 5 (لأن التسلسل هو 1، 2، 3، 4، 5)\n- longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) يعيد 4 (لأن التسلسل هو 1، 2، 3، 4)",
      "sw": "Andika kazi ya Rust `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` kutatua tatizo lifuatalo:\nInapata urefu wa mlolongo mrefu zaidi wa namba mfululizo katika safu iliyopewa ya namba.\n  Mlolongo mfululizo unafafanuliwa kama mlolongo wa namba ambapo kila namba inafuata iliyotangulia kwa moja tu.\n  Kazi hii haihitaji safu ya ingizo kupangwa.\n\n  Hoja:\n  - numbers: Kipande cha namba kinachowakilisha mlolongo.\n\n  Inarudisha:\n  - Urefu wa mlolongo mrefu zaidi wa namba mfululizo uliopatikana kwenye safu.\n\n  Mfano:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) inarudisha 4 (kwa sababu mlolongo mrefu zaidi wa namba mfululizo ni 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) inarudisha 5 (kwa sababu mlolongo ni 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) inarudisha 4 (kwa sababu mlolongo ni 1, 2, 3, 4)",
      "tr": "Bir Rust fonksiyonu `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` yazın:\nVerilen sayı dizisindeki en uzun ardışık dizinin uzunluğunu bulur.\n  Ardışık bir dizi, her sayının bir önceki sayıyı tam olarak bir birim takip ettiği bir tam sayı dizisi olarak tanımlanır.\n  Bu fonksiyon, giriş dizisinin sıralı olmasını gerektirmez.\n\n  Argümanlar:\n  - numbers: Diziyi temsil eden bir tam sayı dilimi.\n\n  Döndürür:\n  - Dizide bulunan en uzun ardışık dizinin uzunluğu.\n\n  Örnek:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 4 döndürür (çünkü en uzun ardışık dizi 1, 2, 3, 4'tür)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 5 döndürür (çünkü dizi 1, 2, 3, 4, 5'tir)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 4 döndürür (çünkü dizi 1, 2, 3, 4'tür)",
      "vi": "Viết một hàm Rust `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` để giải quyết vấn đề sau:\nTìm độ dài của dãy số liên tiếp dài nhất trong mảng số đã cho.\n  Một dãy số liên tiếp được định nghĩa là một dãy số nguyên mà mỗi số theo sau số trước đó đúng một đơn vị.\n  Hàm này không yêu cầu mảng đầu vào phải được sắp xếp.\n\n  Tham số:\n  - numbers: Một lát cắt của các số nguyên đại diện cho dãy số.\n\n  Trả về:\n  - Độ dài của dãy số liên tiếp dài nhất được tìm thấy trong mảng.\n\n  Ví dụ:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) trả về 4 (bởi vì dãy số liên tiếp dài nhất là 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) trả về 5 (bởi vì dãy số là 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) trả về 4 (bởi vì dãy số là 1, 2, 3, 4)"
    },
    "instruction_bertscore": {
      "es": "0.9969287770484385",
      "arb": "0.9796848791492758",
      "sw": "0.9789074398379052",
      "tr": "0.9512662346434713",
      "vi": "0.987724841082425"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]), 4);\n        assert_eq!(longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]), 5);\n        assert_eq!(longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]), 4);\n        assert_eq!(longest_consecutive_sequence(&[6, 6, 2, 3, 1, 4, 5, 7]), 7);\n    }\n    \n\n}",
    "entry_point": "longest_consecutive_sequence",
    "signature": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)",
      "es": "Encuentra la longitud de la secuencia consecutiva más larga en el arreglo dado de números.\n  Una secuencia consecutiva se define como una secuencia de enteros donde cada número sigue al anterior por exactamente uno.\n  Esta función no requiere que el arreglo de entrada esté ordenado.\n\n  Argumentos:\n  - numbers: Un segmento de enteros que representa la secuencia.\n\n  Retorna:\n  - La longitud de la secuencia consecutiva más larga encontrada en el arreglo.\n\n  Ejemplo:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) retorna 4 (porque la secuencia consecutiva más larga es 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) retorna 5 (porque la secuencia es 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) retorna 4 (porque la secuencia es 1, 2, 3, 4)",
      "arb": "يجد طول أطول تسلسل متتابع في مصفوفة الأرقام المعطاة. يُعرّف التسلسل المتتابع على أنه تسلسل من الأعداد الصحيحة حيث يتبع كل عدد العدد السابق بفارق واحد فقط. لا تتطلب هذه الدالة أن تكون مصفوفة الإدخال مرتبة.\n\n  الحجج:\n  - numbers: جزء من الأعداد الصحيحة التي تمثل التسلسل.\n\n  يعيد:\n  - طول أطول تسلسل متتابع موجود في المصفوفة.\n\n  مثال:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) يعيد 4 (لأن أطول تسلسل متتابع هو 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) يعيد 5 (لأن التسلسل هو 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) يعيد 4 (لأن التسلسل هو 1, 2, 3, 4)",
      "sw": "Finds the length of the longest consecutive sequence in the given array of numbers.\n  Mlolongo mfululizo unafafanuliwa kama mlolongo wa nambari ambapo kila nambari inafuata ile ya awali kwa moja tu.\n  Kazi hii haihitaji safu ya pembejeo kupangwa.\n\n  Hoja:\n  - numbers: Sehemu ya nambari za kipekee zinazowakilisha mlolongo.\n\n  Inarudisha:\n  - Urefu wa mlolongo mrefu zaidi wa mfululizo uliopatikana kwenye safu.\n\n  Mfano:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) inarudisha 4 (kwa sababu mlolongo mrefu zaidi wa mfululizo ni 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) inarudisha 5 (kwa sababu mlolongo ni 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) inarudisha 4 (kwa sababu mlolongo ni 1, 2, 3, 4)",
      "tr": "Verilen sayı dizisindeki en uzun ardışık dizinin uzunluğunu bulur.\n  Ardışık bir dizi, her sayının bir öncekini tam olarak bir birim takip ettiği bir tamsayı dizisi olarak tanımlanır.\n  Bu fonksiyon, giriş dizisinin sıralı olmasını gerektirmez.\n\n  Argümanlar:\n  - numbers: Diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizide bulunan en uzun ardışık dizinin uzunluğu.\n\n  Örnek:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 4 döndürür (çünkü en uzun ardışık dizi 1, 2, 3, 4'tür)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 5 döndürür (çünkü dizi 1, 2, 3, 4, 5'tir)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 4 döndürür (çünkü dizi 1, 2, 3, 4'tür)",
      "vi": "Tìm độ dài của dãy liên tiếp dài nhất trong mảng số đã cho.  \nMột dãy liên tiếp được định nghĩa là một dãy số nguyên mà mỗi số theo sau số trước đó đúng một đơn vị.  \nHàm này không yêu cầu mảng đầu vào phải được sắp xếp.\n\nTham số:  \n- numbers: Một mảng số nguyên đại diện cho dãy số.\n\nReturns:  \n- Độ dài của dãy liên tiếp dài nhất tìm thấy trong mảng.\n\nVí dụ:  \n- longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) trả về 4 (bởi vì dãy liên tiếp dài nhất là 1, 2, 3, 4)  \n- longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) trả về 5 (bởi vì dãy là 1, 2, 3, 4, 5)  \n- longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) trả về 4 (bởi vì dãy là 1, 2, 3, 4)"
    },
    "docstring_bertscore": {
      "es": "0.9917759077036314",
      "arb": "0.9738453445772312",
      "sw": "0.9879518756079478",
      "tr": "0.9795118720873944",
      "vi": "0.982709026700532"
    }
  },
  {
    "task_id": "Rust/47",
    "prompt": {
      "en": "/*\n  Compares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "es": "/*\n  Compara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con dimensiones 'b' x 'c'.\n  Devuelve una cadena que indica si el cuadrado ('Alice') o el rectángulo ('Bob') tiene un área mayor.\n  \n  Argumentos:\n  - a: Un usize que representa la longitud del lado del cuadrado.\n  - b: Un usize que representa la longitud del rectángulo.\n  - c: Un usize que representa el ancho del rectángulo.\n\n  Devuelve:\n  - Una cadena que es 'Alice' si el área del cuadrado es mayor, o 'Bob' si el área del rectángulo es mayor.\n\n  Ejemplo:\n  - compare_area(5, 4, 6) devuelve \"Alice\"\n  - compare_area(7, 5, 10) devuelve \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "arb": "/*\n  يقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأبعاد 'b' x 'c'.\n  يعيد سلسلة نصية تشير إلى ما إذا كان المربع ('Alice') أو المستطيل ('Bob') لديه مساحة أكبر.\n  \n  المعطيات:\n  - a: عدد صحيح غير سالب يمثل طول ضلع المربع.\n  - b: عدد صحيح غير سالب يمثل طول المستطيل.\n  - c: عدد صحيح غير سالب يمثل عرض المستطيل.\n\n  يعيد:\n  - سلسلة نصية تكون إما 'Alice' إذا كانت مساحة المربع أكبر، أو 'Bob' إذا كانت مساحة المستطيل أكبر.\n\n  مثال:\n  - compare_area(5, 4, 6) يعيد \"Alice\"\n  - compare_area(7, 5, 10) يعيد \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "sw": "/*\n  Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye vipimo 'b' x 'c'.\n  Inarudisha kamba inayoonyesha kama mraba ('Alice') au mstatili ('Bob') una eneo kubwa zaidi.\n  \n  Hoja:\n  - a: Usize inayoonyesha urefu wa upande wa mraba.\n  - b: Usize inayoonyesha urefu wa mstatili.\n  - c: Usize inayoonyesha upana wa mstatili.\n\n  Inarudisha:\n  - Kamba ambayo ni 'Alice' ikiwa eneo la mraba ni kubwa zaidi, au 'Bob' ikiwa eneo la mstatili ni kubwa zaidi.\n\n  Mfano:\n  - compare_area(5, 4, 6) inarudisha \"Alice\"\n  - compare_area(7, 5, 10) inarudisha \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "tr": "/*\n  'a' kenar uzunluğuna sahip bir karenin alanını, 'b' x 'c' boyutlarındaki bir dikdörtgenin alanı ile karşılaştırır.\n  Karenin ('Alice') veya dikdörtgenin ('Bob') daha büyük bir alana sahip olup olmadığını belirten bir dize döndürür.\n  \n  Argümanlar:\n  - a: Karenin kenar uzunluğunu temsil eden bir usize.\n  - b: Dikdörtgenin uzunluğunu temsil eden bir usize.\n  - c: Dikdörtgenin genişliğini temsil eden bir usize.\n\n  Döndürür:\n  - Eğer karenin alanı daha büyükse 'Alice', eğer dikdörtgenin alanı daha büyükse 'Bob' olan bir dize.\n\n  Örnek:\n  - compare_area(5, 4, 6) \"Alice\" döndürür\n  - compare_area(7, 5, 10) \"Bob\" döndürür\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "vi": "/*\n  So sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật có kích thước 'b' x 'c'.\n  Trả về một chuỗi chỉ ra liệu hình vuông ('Alice') hay hình chữ nhật ('Bob') có diện tích lớn hơn.\n  \n  Tham số:\n  - a: Một usize đại diện cho độ dài cạnh của hình vuông.\n  - b: Một usize đại diện cho chiều dài của hình chữ nhật.\n  - c: Một usize đại diện cho chiều rộng của hình chữ nhật.\n\n  Trả về:\n  - Một chuỗi là 'Alice' nếu diện tích của hình vuông lớn hơn, hoặc 'Bob' nếu diện tích của hình chữ nhật lớn hơn.\n\n  Ví dụ:\n  - compare_area(5, 4, 6) trả về \"Alice\"\n  - compare_area(7, 5, 10) trả về \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String "
    },
    "prompt_bertscore": {
      "es": "0.9859159142023403",
      "arb": "0.95048482272448",
      "sw": "0.9768984921641184",
      "tr": "0.9890191166452483",
      "vi": "0.9784426447462836"
    },
    "canonical_solution": "{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}",
    "instruction": {
      "en": "Write a Rust function `fn compare_area(a: usize, b: usize, c: usize) -> String` to solve the following problem:\nCompares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"",
      "es": "Escribe una función en Rust `fn compare_area(a: usize, b: usize, c: usize) -> String` para resolver el siguiente problema:\nCompara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con dimensiones 'b' x 'c'.\nDevuelve una cadena que indica si el cuadrado ('Alice') o el rectángulo ('Bob') tiene un área mayor.\n  \n  Argumentos:\n  - a: Un usize que representa la longitud del lado del cuadrado.\n  - b: Un usize que representa la longitud del rectángulo.\n  - c: Un usize que representa el ancho del rectángulo.\n\n  Devuelve:\n  - Una cadena que es 'Alice' si el área del cuadrado es mayor, o 'Bob' si el área del rectángulo es mayor.\n\n  Ejemplo:\n  - compare_area(5, 4, 6) devuelve \"Alice\"\n  - compare_area(7, 5, 10) devuelve \"Bob\"",
      "arb": "اكتب دالة Rust `fn compare_area(a: usize, b: usize, c: usize) -> String` لحل المشكلة التالية:\nيقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأبعاد 'b' x 'c'.\nيعيد سلسلة نصية تشير إلى ما إذا كان المربع ('Alice') أو المستطيل ('Bob') له مساحة أكبر.\n\nالمعطيات:\n- a: قيمة من نوع usize تمثل طول ضلع المربع.\n- b: قيمة من نوع usize تمثل طول المستطيل.\n- c: قيمة من نوع usize تمثل عرض المستطيل.\n\nالقيم المعادة:\n- سلسلة نصية تكون إما 'Alice' إذا كانت مساحة المربع أكبر، أو 'Bob' إذا كانت مساحة المستطيل أكبر.\n\nمثال:\n- compare_area(5, 4, 6) يعيد \"Alice\"\n- compare_area(7, 5, 10) يعيد \"Bob\"",
      "sw": "Andika kazi ya Rust `fn compare_area(a: usize, b: usize, c: usize) -> String` kutatua tatizo lifuatalo:\nInalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye vipimo 'b' x 'c'.\n  Inarudisha kamba inayoonyesha kama mraba ('Alice') au mstatili ('Bob') una eneo kubwa zaidi.\n  \n  Hoja:\n  - a: Urefu wa upande wa mraba kama usize.\n  - b: Urefu wa mstatili kama usize.\n  - c: Upana wa mstatili kama usize.\n\n  Inarudisha:\n  - Kamba ambayo ni 'Alice' ikiwa eneo la mraba ni kubwa zaidi, au 'Bob' ikiwa eneo la mstatili ni kubwa zaidi.\n\n  Mfano:\n  - compare_area(5, 4, 6) inarudisha \"Alice\"\n  - compare_area(7, 5, 10) inarudisha \"Bob\"",
      "tr": "Bir Rust fonksiyonu `fn compare_area(a: usize, b: usize, c: usize) -> String` yazın:\nBir kenar uzunluğu 'a' olan bir karenin alanını, boyutları 'b' x 'c' olan bir dikdörtgenin alanı ile karşılaştırır.\n  Karenin ('Alice') veya dikdörtgenin ('Bob') daha büyük bir alana sahip olduğunu belirten bir dize döndürür.\n  \n  Argümanlar:\n  - a: Karenin kenar uzunluğunu temsil eden bir usize.\n  - b: Dikdörtgenin uzunluğunu temsil eden bir usize.\n  - c: Dikdörtgenin genişliğini temsil eden bir usize.\n\n  Döndürür:\n  - Eğer karenin alanı daha büyükse 'Alice', eğer dikdörtgenin alanı daha büyükse 'Bob' olan bir dize.\n\n  Örnek:\n  - compare_area(5, 4, 6) \"Alice\" döndürür\n  - compare_area(7, 5, 10) \"Bob\" döndürür",
      "vi": "Viết một hàm Rust `fn compare_area(a: usize, b: usize, c: usize) -> String` để giải quyết vấn đề sau:\nSo sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật có kích thước 'b' x 'c'.\nTrả về một chuỗi cho biết liệu hình vuông ('Alice') hay hình chữ nhật ('Bob') có diện tích lớn hơn.\n\nCác tham số:\n- a: Một usize đại diện cho độ dài cạnh của hình vuông.\n- b: Một usize đại diện cho chiều dài của hình chữ nhật.\n- c: Một usize đại diện cho chiều rộng của hình chữ nhật.\n\nTrả về:\n- Một chuỗi là 'Alice' nếu diện tích của hình vuông lớn hơn, hoặc 'Bob' nếu diện tích của hình chữ nhật lớn hơn.\n\nVí dụ:\n- compare_area(5, 4, 6) trả về \"Alice\"\n- compare_area(7, 5, 10) trả về \"Bob\""
    },
    "instruction_bertscore": {
      "es": "0.9801880099044371",
      "arb": "0.9709495122521234",
      "sw": "0.9498263630113493",
      "tr": "0.9407163792155652",
      "vi": "0.9773883146837504"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(compare_area(5, 4, 6), \"Alice\");\n        assert_eq!(compare_area(7, 5, 10), \"Bob\");\n        assert_eq!(compare_area(6, 3, 8), \"Alice\");\n        assert_eq!(compare_area(9, 4, 5), \"Alice\");\n    }\n    \n\n}",
    "entry_point": "compare_area",
    "signature": "fn compare_area(a: usize, b: usize, c: usize) -> String",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"",
      "es": "Compara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con dimensiones 'b' x 'c'. Devuelve una cadena que indica si el cuadrado ('Alice') o el rectángulo ('Bob') tiene un área mayor.\n\n  Argumentos:\n  - a: Un usize que representa la longitud del lado del cuadrado.\n  - b: Un usize que representa la longitud del rectángulo.\n  - c: Un usize que representa el ancho del rectángulo.\n\n  Devuelve:\n  - Una cadena que es 'Alice' si el área del cuadrado es mayor, o 'Bob' si el área del rectángulo es mayor.\n\n  Ejemplo:\n  - compare_area(5, 4, 6) devuelve \"Alice\"\n  - compare_area(7, 5, 10) devuelve \"Bob\"",
      "arb": "يقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأبعاد 'b' x 'c'.  \nيعيد سلسلة نصية تشير إلى ما إذا كان المربع ('Alice') أو المستطيل ('Bob') لديه مساحة أكبر.\n\nالأطراف:\n- a: عدد صحيح غير سالب يمثل طول ضلع المربع.\n- b: عدد صحيح غير سالب يمثل طول المستطيل.\n- c: عدد صحيح غير سالب يمثل عرض المستطيل.\n\nالقيم المعادة:\n- سلسلة نصية تكون إما 'Alice' إذا كانت مساحة المربع أكبر، أو 'Bob' إذا كانت مساحة المستطيل أكبر.\n\nمثال:\n- compare_area(5, 4, 6) يعيد \"Alice\"\n- compare_area(7, 5, 10) يعيد \"Bob\"",
      "sw": "Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye vipimo 'b' x 'c'. Inarudisha kamba inayoonyesha kama mraba ('Alice') au mstatili ('Bob') una eneo kubwa zaidi.\n\nHoja:\n- a: Usize inayoashiria urefu wa upande wa mraba.\n- b: Usize inayoashiria urefu wa mstatili.\n- c: Usize inayoashiria upana wa mstatili.\n\nInarudisha:\n- Kamba ambayo ni 'Alice' ikiwa eneo la mraba ni kubwa zaidi, au 'Bob' ikiwa eneo la mstatili ni kubwa zaidi.\n\nMfano:\n- compare_area(5, 4, 6) inarudisha \"Alice\"\n- compare_area(7, 5, 10) inarudisha \"Bob\"",
      "tr": "Kenar uzunluğu 'a' olan bir karenin alanını, boyutları 'b' x 'c' olan bir dikdörtgenin alanı ile karşılaştırır.\n  Karenin ('Alice') veya dikdörtgenin ('Bob') daha büyük bir alana sahip olduğunu belirten bir dize döndürür.\n  \n  Argümanlar:\n  - a: Karenin kenar uzunluğunu temsil eden bir usize.\n  - b: Dikdörtgenin uzunluğunu temsil eden bir usize.\n  - c: Dikdörtgenin genişliğini temsil eden bir usize.\n\n  Döndürür:\n  - Eğer karenin alanı daha büyükse 'Alice', eğer dikdörtgenin alanı daha büyükse 'Bob' olan bir dize.\n\n  Örnek:\n  - compare_area(5, 4, 6) \"Alice\" döndürür\n  - compare_area(7, 5, 10) \"Bob\" döndürür",
      "vi": "So sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật có kích thước 'b' x 'c'. Trả về một chuỗi cho biết liệu hình vuông ('Alice') hay hình chữ nhật ('Bob') có diện tích lớn hơn.\n\n  Tham số:\n  - a: Một usize đại diện cho độ dài cạnh của hình vuông.\n  - b: Một usize đại diện cho chiều dài của hình chữ nhật.\n  - c: Một usize đại diện cho chiều rộng của hình chữ nhật.\n\n  Trả về:\n  - Một chuỗi là 'Alice' nếu diện tích của hình vuông lớn hơn, hoặc 'Bob' nếu diện tích của hình chữ nhật lớn hơn.\n\n  Ví dụ:\n  - compare_area(5, 4, 6) trả về \"Alice\"\n  - compare_area(7, 5, 10) trả về \"Bob\""
    },
    "docstring_bertscore": {
      "es": "0.9785951928789184",
      "arb": "0.940726707995379",
      "sw": "0.9569577895816449",
      "tr": "0.9817673200640455",
      "vi": "0.9711479440027773"
    }
  },
  {
    "task_id": "Rust/48",
    "prompt": {
      "en": "/*\n  Finds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "es": "/*\n  Encuentra M enteros positivos cuya suma es igual a N y cuyo producto es maximizado, devolviendo la secuencia lexicográficamente más pequeña de estos enteros.\n\n  Argumentos:\n  - n: La suma que los M enteros deben igualar.\n  - m: El número de enteros a encontrar.\n\n  Devuelve:\n  - Un vector de M enteros cuya suma es N y cuyo producto es maximizado.\n\n  Ejemplo:\n  - max_product_partition(6, 3) devuelve vec![2, 2, 2]\n  - max_product_partition(8, 3) devuelve vec![2, 3, 3]\n  - max_product_partition(10, 2) devuelve vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "arb": "/*\n  يجد M من الأعداد الصحيحة الموجبة التي يكون مجموعها مساويًا لـ N والتي يكون حاصل ضربها هو الأقصى، مع إرجاع التسلسل الأصغر لغويًا لهذه الأعداد.\n\n  الحجج:\n  - n: المجموع الذي يجب أن تساويه الأعداد الصحيحة M.\n  - m: عدد الأعداد الصحيحة التي يجب العثور عليها.\n\n  يعيد:\n  - متجه من الأعداد الصحيحة M التي يكون مجموعها N وحاصل ضربها هو الأقصى.\n\n  مثال:\n  - max_product_partition(6, 3) يعيد vec![2, 2, 2]\n  - max_product_partition(8, 3) يعيد vec![2, 3, 3]\n  - max_product_partition(10, 2) يعيد vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "sw": "/*\n  Inapata nambari M ambazo jumla yake ni sawa na N na ambazo bidhaa yake imewezeshwa, ikirejesha mlolongo mdogo zaidi wa leksikografia wa nambari hizi.\n\n  Hoja:\n  - n: Jumla ambayo nambari M lazima iwe sawa nayo.\n  - m: Idadi ya nambari za kupata.\n\n  Inarejesha:\n  - Vector ya nambari M ambazo jumla yake ni N na ambazo bidhaa yake imewezeshwa.\n\n  Mfano:\n  - max_product_partition(6, 3) inarejesha vec![2, 2, 2]\n  - max_product_partition(8, 3) inarejesha vec![2, 3, 3]\n  - max_product_partition(10, 2) inarejesha vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "tr": "/*\n  Toplamı N olan ve çarpımı maksimize edilen M pozitif tam sayıyı bulan, bu tam sayıların sözlük sırasına göre en küçük dizisini döndüren fonksiyon.\n\n  Argümanlar:\n  - n: M tam sayının eşit olması gereken toplam.\n  - m: Bulunacak tam sayıların sayısı.\n\n  Döndürür:\n  - Toplamı N olan ve çarpımı maksimize edilen M tam sayının bir vektörü.\n\n  Örnek:\n  - max_product_partition(6, 3) vec![2, 2, 2] döndürür\n  - max_product_partition(8, 3) vec![2, 3, 3] döndürür\n  - max_product_partition(10, 2) vec![5, 5] döndürür\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "vi": "/*\n  Tìm M số nguyên dương có tổng bằng N và có tích lớn nhất, trả về dãy số nhỏ nhất theo thứ tự từ điển của các số nguyên này.\n\n  Tham số:\n  - n: Tổng mà M số nguyên phải bằng.\n  - m: Số lượng số nguyên cần tìm.\n\n  Trả về:\n  - Một vector gồm M số nguyên có tổng là N và có tích lớn nhất.\n\n  Ví dụ:\n  - max_product_partition(6, 3) trả về vec![2, 2, 2]\n  - max_product_partition(8, 3) trả về vec![2, 3, 3]\n  - max_product_partition(10, 2) trả về vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> "
    },
    "prompt_bertscore": {
      "es": "0.9927972651229129",
      "arb": "0.9845064330185167",
      "sw": "0.9676810493321943",
      "tr": "0.9680763237904538",
      "vi": "0.9510505220496673"
    },
    "canonical_solution": "{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` to solve the following problem:\nFinds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]",
      "es": "Escribe una función de Rust `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` para resolver el siguiente problema:\nEncuentra M enteros positivos cuya suma sea igual a N y cuyo producto sea maximizado, devolviendo la secuencia lexicográficamente más pequeña de estos enteros.\n\n  Argumentos:\n  - n: La suma que los M enteros deben igualar.\n  - m: El número de enteros a encontrar.\n\n  Devuelve:\n  - Un vector de M enteros cuya suma es N y cuyo producto es maximizado.\n\n  Ejemplo:\n  - max_product_partition(6, 3) devuelve vec![2, 2, 2]\n  - max_product_partition(8, 3) devuelve vec![2, 3, 3]\n  - max_product_partition(10, 2) devuelve vec![5, 5]",
      "arb": "اكتب دالة بلغة Rust `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` لحل المشكلة التالية:\nتجد M من الأعداد الصحيحة الموجبة التي يكون مجموعها يساوي N ويكون حاصل ضربها هو الأقصى، وتعيد التسلسل الأصغر لغويًا لهذه الأعداد.\n\n  الوسائط:\n  - n: المجموع الذي يجب أن تساويه الأعداد الصحيحة M.\n  - m: عدد الأعداد الصحيحة المراد إيجادها.\n\n  يعيد:\n  - متجه من M من الأعداد الصحيحة التي يكون مجموعها N ويكون حاصل ضربها هو الأقصى.\n\n  مثال:\n  - max_product_partition(6, 3) يعيد vec![2, 2, 2]\n  - max_product_partition(8, 3) يعيد vec![2, 3, 3]\n  - max_product_partition(10, 2) يعيد vec![5, 5]",
      "sw": "Andika kazi ya Rust `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` kutatua tatizo lifuatalo:\nInapata nambari M ambazo ni chanya na jumla yao ni sawa na N na bidhaa yao imeongezwa, ikirudisha mlolongo mdogo zaidi wa leksikografia wa nambari hizi.\n\n  Hoja:\n  - n: Jumla ambayo nambari M lazima iwe sawa nayo.\n  - m: Idadi ya nambari za kupata.\n\n  Inarudisha:\n  - Vekta ya nambari M ambazo jumla yao ni N na bidhaa yao imeongezwa.\n\n  Mfano:\n  - max_product_partition(6, 3) inarudisha vec![2, 2, 2]\n  - max_product_partition(8, 3) inarudisha vec![2, 3, 3]\n  - max_product_partition(10, 2) inarudisha vec![5, 5]",
      "tr": "Bir Rust fonksiyonu `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` yazarak aşağıdaki problemi çözün:\nToplamı N olan ve çarpımı maksimum olan M pozitif tam sayı bulun ve bu tam sayıların sözlük sırasına göre en küçük dizisini döndürün.\n\n  Argümanlar:\n  - n: M tam sayısının eşit olması gereken toplam.\n  - m: Bulunacak tam sayıların sayısı.\n\n  Döndürülen:\n  - Toplamı N olan ve çarpımı maksimum olan M tam sayısının bir vektörü.\n\n  Örnek:\n  - max_product_partition(6, 3) döndürür vec![2, 2, 2]\n  - max_product_partition(8, 3) döndürür vec![2, 3, 3]\n  - max_product_partition(10, 2) döndürür vec![5, 5]",
      "vi": "Viết một hàm Rust `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` để giải quyết vấn đề sau:\nTìm M số nguyên dương có tổng bằng N và có tích lớn nhất, trả về dãy số nhỏ nhất theo thứ tự từ điển của các số nguyên này.\n\n  Tham số:\n  - n: Tổng mà M số nguyên phải bằng.\n  - m: Số lượng số nguyên cần tìm.\n\n  Trả về:\n  - Một vector gồm M số nguyên có tổng là N và có tích lớn nhất.\n\n  Ví dụ:\n  - max_product_partition(6, 3) trả về vec![2, 2, 2]\n  - max_product_partition(8, 3) trả về vec![2, 3, 3]\n  - max_product_partition(10, 2) trả về vec![5, 5]"
    },
    "instruction_bertscore": {
      "es": "0.9919310380312197",
      "arb": "0.9792798718023457",
      "sw": "0.9654708890824192",
      "tr": "0.9528582571474659",
      "vi": "0.9495840339464867"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_product_partition(6, 3), vec![2, 2, 2]);\n        assert_eq!(max_product_partition(8, 3), vec![2, 3, 3]);\n        assert_eq!(max_product_partition(10, 2), vec![5, 5]);\n        assert_eq!(max_product_partition(7, 3), vec![2, 2, 3]);\n    }\n    \n\n}",
    "entry_point": "max_product_partition",
    "signature": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>",
    "docstring": {
      "en": "Finds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]",
      "es": "Encuentra M enteros positivos cuya suma es igual a N y cuyo producto es maximizado, devolviendo la secuencia lexicográficamente más pequeña de estos enteros.\n\n  Argumentos:\n  - n: La suma a la que los M enteros deben ser iguales.\n  - m: El número de enteros a encontrar.\n\n  Devuelve:\n  - Un vector de M enteros cuya suma es N y cuyo producto es maximizado.\n\n  Ejemplo:\n  - max_product_partition(6, 3) devuelve vec![2, 2, 2]\n  - max_product_partition(8, 3) devuelve vec![2, 3, 3]\n  - max_product_partition(10, 2) devuelve vec![5, 5]",
      "arb": "يجد M من الأعداد الصحيحة الموجبة التي يكون مجموعها يساوي N ويكون حاصل ضربها هو الأقصى، مع إرجاع التسلسل الأصغر ترتيبًا لغويًا لهذه الأعداد.\n\nالأوساط:\n- n: المجموع الذي يجب أن تساويه الأعداد الصحيحة M.\n- m: عدد الأعداد الصحيحة المطلوب إيجادها.\n\nالقيم المعادة:\n- متجه من M من الأعداد الصحيحة التي يكون مجموعها N وحاصل ضربها هو الأقصى.\n\nمثال:\n- max_product_partition(6, 3) يعيد vec![2, 2, 2]\n- max_product_partition(8, 3) يعيد vec![2, 3, 3]\n- max_product_partition(10, 2) يعيد vec![5, 5]",
      "sw": "Inapata nambari M za asili ambazo jumla yake ni sawa na N na ambazo bidhaa yake imewezeshwa, ikirudisha mlolongo mdogo zaidi wa nambari hizi.\n\n  Hoja:\n  - n: Jumla ambayo nambari M lazima iwe sawa nayo.\n  - m: Idadi ya nambari za kupata.\n\n  Inarudisha:\n  - Vekta ya nambari M ambazo jumla yake ni N na bidhaa yake imewezeshwa.\n\n  Mfano:\n  - max_product_partition(6, 3) inarudisha vec![2, 2, 2]\n  - max_product_partition(8, 3) inarudisha vec![2, 3, 3]\n  - max_product_partition(10, 2) inarudisha vec![5, 5]",
      "tr": "M pozitif tamsayısının toplamı N'ye eşit olan ve çarpımı maksimize edilen, bu tamsayıların sözlük sırasına göre en küçük dizisini döndüren fonksiyon.\n\n  Argümanlar:\n  - n: M tamsayısının eşit olması gereken toplam.\n  - m: Bulunacak tamsayıların sayısı.\n\n  Döndürür:\n  - Toplamı N olan ve çarpımı maksimize edilen M tamsayısından oluşan bir vektör.\n\n  Örnek:\n  - max_product_partition(6, 3) vec![2, 2, 2] döndürür\n  - max_product_partition(8, 3) vec![2, 3, 3] döndürür\n  - max_product_partition(10, 2) vec![5, 5] döndürür",
      "vi": "Tìm M số nguyên dương có tổng bằng N và có tích được tối đa hóa, trả về dãy số nhỏ nhất theo thứ tự từ điển của các số nguyên này.\n\n  Đối số:\n  - n: Tổng mà M số nguyên phải bằng.\n  - m: Số lượng số nguyên cần tìm.\n\n  Trả về:\n  - Một vector gồm M số nguyên có tổng là N và có tích được tối đa hóa.\n\n  Ví dụ:\n  - max_product_partition(6, 3) trả về vec![2, 2, 2]\n  - max_product_partition(8, 3) trả về vec![2, 3, 3]\n  - max_product_partition(10, 2) trả về vec![5, 5]"
    },
    "docstring_bertscore": {
      "es": "0.9871676828636221",
      "arb": "0.9571222555371418",
      "sw": "0.9459677692293655",
      "tr": "0.9417768668199105",
      "vi": "0.9783828570015921"
    }
  },
  {
    "task_id": "Rust/49",
    "prompt": {
      "en": "/*\n  Calculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "es": "/*\n  Calcula el número de caracteres en una cadena de título dada, excluyendo espacios y caracteres de nueva línea.\n\n  Argumentos:\n  - title: Una cadena que puede contener letras mayúsculas y minúsculas en inglés, dígitos, espacios y caracteres de nueva línea.\n\n  Devuelve:\n  - El conteo de caracteres en el título, excluyendo espacios y caracteres de nueva línea.\n\n  Ejemplos:\n  - count_title_chars(\"234\") devuelve 3\n  - count_title_chars(\"Ca 45\") devuelve 4\n  - count_title_chars(\"Hello\\nWorld\") devuelve 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "arb": "/*\n  يحسب عدد الأحرف في سلسلة عنوان معينة، باستثناء المسافات وأحرف السطر الجديد.\n\n  الحجج:\n  - title: سلسلة قد تحتوي على أحرف إنجليزية كبيرة وصغيرة، وأرقام، ومسافات، وأحرف السطر الجديد.\n\n  يعيد:\n  - عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.\n\n  أمثلة:\n  - count_title_chars(\"234\") يعيد 3\n  - count_title_chars(\"Ca 45\") يعيد 4\n  - count_title_chars(\"Hello\\nWorld\") يعيد 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "sw": "/*\n  Inahesabu idadi ya herufi katika mfuatano wa herufi wa kichwa kilichopewa, bila kujumuisha nafasi na herufi za kurudi mstari mpya.\n\n  Hoja:\n  - title: Mfuatano wa herufi ambao unaweza kuwa na herufi kubwa na ndogo za Kiingereza, nambari, nafasi, na herufi za kurudi mstari mpya.\n\n  Inarejesha:\n  - Idadi ya herufi katika kichwa, bila kujumuisha nafasi na herufi za kurudi mstari mpya.\n\n  Mifano:\n  - count_title_chars(\"234\") inarejesha 3\n  - count_title_chars(\"Ca 45\") inarejesha 4\n  - count_title_chars(\"Hello\\nWorld\") inarejesha 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "tr": "/*\n  Verilen bir başlık dizgesindeki karakter sayısını, boşluklar ve yeni satır karakterleri hariç tutarak hesaplar.\n\n  Argümanlar:\n  - title: Büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilen bir dizge.\n\n  Döndürür:\n  - Başlıktaki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç tutarak döndürür.\n\n  Örnekler:\n  - count_title_chars(\"234\") 3 döndürür\n  - count_title_chars(\"Ca 45\") 4 döndürür\n  - count_title_chars(\"Hello\\nWorld\") 10 döndürür\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "vi": "/*\n  Tính số ký tự trong một chuỗi tiêu đề đã cho, không bao gồm khoảng trắng và ký tự xuống dòng.\n\n  Tham số:\n  - title: Một chuỗi có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, chữ số, khoảng trắng và ký tự xuống dòng.\n\n  Trả về:\n  - Số lượng ký tự trong tiêu đề, không bao gồm khoảng trắng và ký tự xuống dòng.\n\n  Ví dụ:\n  - count_title_chars(\"234\") trả về 3\n  - count_title_chars(\"Ca 45\") trả về 4\n  - count_title_chars(\"Hello\\nWorld\") trả về 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.9989273959424116",
      "arb": "0.9925438127567123",
      "sw": "0.981570278726059",
      "tr": "0.9883022596000933",
      "vi": "0.9883429788282055"
    },
    "canonical_solution": "{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_title_chars(title: &str) -> usize` to solve the following problem:\nCalculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10",
      "es": "Escribe una función de Rust `fn count_title_chars(title: &str) -> usize` para resolver el siguiente problema:\nCalcula el número de caracteres en una cadena de título dada, excluyendo espacios y caracteres de nueva línea.\n\n  Argumentos:\n  - title: Una cadena que puede contener letras mayúsculas y minúsculas en inglés, dígitos, espacios y caracteres de nueva línea.\n\n  Devuelve:\n  - El conteo de caracteres en el título, excluyendo espacios y caracteres de nueva línea.\n\n  Ejemplos:\n  - count_title_chars(\"234\") devuelve 3\n  - count_title_chars(\"Ca 45\") devuelve 4\n  - count_title_chars(\"Hello\\nWorld\") devuelve 10",
      "arb": "اكتب دالة بلغة Rust `fn count_title_chars(title: &str) -> usize` لحل المشكلة التالية:\nتحسب عدد الأحرف في سلسلة عنوان معينة، باستثناء المسافات وأحرف السطر الجديد.\n\n  الوسائط:\n  - title: سلسلة قد تحتوي على أحرف إنجليزية كبيرة وصغيرة، أرقام، مسافات، وأحرف السطر الجديد.\n\n  يعيد:\n  - عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.\n\n  أمثلة:\n  - count_title_chars(\"234\") يعيد 3\n  - count_title_chars(\"Ca 45\") يعيد 4\n  - count_title_chars(\"Hello\\nWorld\") يعيد 10",
      "sw": "Andika kazi ya Rust `fn count_title_chars(title: &str) -> usize` kutatua tatizo lifuatalo:\nHesabu idadi ya herufi katika mfuatano wa herufi wa kichwa kilichopewa, ukiondoa nafasi na herufi za kurudi mstari mpya.\n\n  Hoja:\n  - title: Mfuatano wa herufi ambao unaweza kuwa na herufi kubwa na ndogo za Kiingereza, nambari, nafasi, na herufi za kurudi mstari mpya.\n\n  Inarudisha:\n  - Idadi ya herufi katika kichwa, ukiondoa nafasi na herufi za kurudi mstari mpya.\n\n  Mifano:\n  - count_title_chars(\"234\") inarudisha 3\n  - count_title_chars(\"Ca 45\") inarudisha 4\n  - count_title_chars(\"Hello\\nWorld\") inarudisha 10",
      "tr": "Bir Rust fonksiyonu `fn count_title_chars(title: &str) -> usize` yazın ve aşağıdaki problemi çözün:\nVerilen bir başlık dizesindeki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç hesaplar.\n\n  Argümanlar:\n  - title: Büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilen bir dize.\n\n  Döndürür:\n  - Başlıktaki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç.\n\n  Örnekler:\n  - count_title_chars(\"234\") 3 döndürür\n  - count_title_chars(\"Ca 45\") 4 döndürür\n  - count_title_chars(\"Hello\\nWorld\") 10 döndürür",
      "vi": "Viết một hàm Rust `fn count_title_chars(title: &str) -> usize` để giải quyết vấn đề sau:\nTính toán số lượng ký tự trong một chuỗi tiêu đề đã cho, ngoại trừ các ký tự khoảng trắng và ký tự xuống dòng.\n\n  Tham số:\n  - title: Một chuỗi có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, chữ số, khoảng trắng và ký tự xuống dòng.\n\n  Trả về:\n  - Số lượng ký tự trong tiêu đề, ngoại trừ các ký tự khoảng trắng và ký tự xuống dòng.\n\n  Ví dụ:\n  - count_title_chars(\"234\") trả về 3\n  - count_title_chars(\"Ca 45\") trả về 4\n  - count_title_chars(\"Hello\\nWorld\") trả về 10"
    },
    "instruction_bertscore": {
      "es": "0.9988513205064753",
      "arb": "0.988402567942516",
      "sw": "0.9829763831934049",
      "tr": "0.9888117465274479",
      "vi": "0.9769344442630857"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_title_chars(\"234\"), 3);\n        assert_eq!(count_title_chars(\"Ca 45\"), 4);\n        assert_eq!(count_title_chars(\"Hello\\nWorld\"), 10);\n    }\n    \n\n}",
    "entry_point": "count_title_chars",
    "signature": "fn count_title_chars(title: &str) -> usize",
    "docstring": {
      "en": "Calculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10",
      "es": "Calcula el número de caracteres en una cadena de título dada, excluyendo espacios y caracteres de nueva línea.\n\n  Argumentos:\n  - title: Una cadena que puede contener letras mayúsculas y minúsculas en inglés, dígitos, espacios y caracteres de nueva línea.\n\n  Retorna:\n  - La cuenta de caracteres en el título, excluyendo espacios y caracteres de nueva línea.\n\n  Ejemplos:\n  - count_title_chars(\"234\") retorna 3\n  - count_title_chars(\"Ca 45\") retorna 4\n  - count_title_chars(\"Hello\\nWorld\") retorna 10",
      "arb": "يحسب عدد الأحرف في سلسلة عنوان معينة، باستثناء المسافات وأحرف السطر الجديد.\n\n  الحجج:\n  - title: سلسلة قد تحتوي على أحرف إنجليزية كبيرة وصغيرة، أرقام، مسافات، وأحرف السطر الجديد.\n\n  العوائد:\n  - عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.\n\n  أمثلة:\n  - count_title_chars(\"234\") يعيد 3\n  - count_title_chars(\"Ca 45\") يعيد 4\n  - count_title_chars(\"Hello\\nWorld\") يعيد 10",
      "sw": "Inahesabu idadi ya herufi katika kamba ya kichwa kilichopewa, bila kujumuisha nafasi na herufi za kurudi mstari mpya.\n\n  Hoja:\n  - title: Kamba ambayo inaweza kuwa na herufi kubwa na ndogo za Kiingereza, tarakimu, nafasi, na herufi za kurudi mstari mpya.\n\n  Inarejesha:\n  - Idadi ya herufi katika kichwa, bila kujumuisha nafasi na herufi za kurudi mstari mpya.\n\n  Mifano:\n  - count_title_chars(\"234\") inarejesha 3\n  - count_title_chars(\"Ca 45\") inarejesha 4\n  - count_title_chars(\"Hello\\nWorld\") inarejesha 10",
      "tr": "Verilen bir başlık dizesindeki karakter sayısını, boşluklar ve yeni satır karakterleri hariç, hesaplar.\n\n  Argümanlar:\n  - title: Büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilen bir dize.\n\n  Döndürür:\n  - Başlıktaki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç, döndürür.\n\n  Örnekler:\n  - count_title_chars(\"234\") 3 döndürür\n  - count_title_chars(\"Ca 45\") 4 döndürür\n  - count_title_chars(\"Hello\\nWorld\") 10 döndürür",
      "vi": "Tính toán số ký tự trong một chuỗi tiêu đề đã cho, không bao gồm các ký tự khoảng trắng và ký tự xuống dòng.\n\n  Tham số:\n  - title: Một chuỗi có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, chữ số, khoảng trắng và ký tự xuống dòng.\n\n  Trả về:\n  - Số lượng ký tự trong tiêu đề, không bao gồm khoảng trắng và ký tự xuống dòng.\n\n  Ví dụ:\n  - count_title_chars(\"234\") trả về 3\n  - count_title_chars(\"Ca 45\") trả về 4\n  - count_title_chars(\"Hello\\nWorld\") trả về 10"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9906039884555257",
      "sw": "0.9838183773786118",
      "tr": "0.9855921466812534",
      "vi": "0.9662296571379725"
    }
  },
  {
    "task_id": "Rust/50",
    "prompt": {
      "en": "/*\n  Counts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "es": "/*\n  Cuenta el número de estudiantes que se han inscrito tanto en el Curso A como en el Curso B.\n\n  Argumentos:\n  - n: El número de estudiantes inscritos en el Curso A.\n  - m: El número de estudiantes inscritos en el Curso B.\n  - a: Un vector que contiene los IDs de los estudiantes inscritos en el Curso A.\n  - b: Un vector que contiene los IDs de los estudiantes inscritos en el Curso B.\n\n  Retorna:\n  - El número de estudiantes que están inscritos en ambos cursos.\n\n  Ejemplo:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) devuelve 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) devuelve 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "arb": "/*\n  يحسب عدد الطلاب الذين سجلوا في كل من الدورة A والدورة B.\n\n  الحجج:\n  - n: عدد الطلاب المسجلين في الدورة A.\n  - m: عدد الطلاب المسجلين في الدورة B.\n  - a: متجه يحتوي على معرفات الطلاب المسجلين في الدورة A.\n  - b: متجه يحتوي على معرفات الطلاب المسجلين في الدورة B.\n\n  يعيد:\n  - عدد الطلاب الذين سجلوا في كلا الدورتين.\n\n  مثال:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) يعيد 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) يعيد 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "sw": "/*\n  Inahesabu idadi ya wanafunzi ambao wamejiandikisha katika Kozi A na Kozi B.\n\n  Hoja:\n  - n: Idadi ya wanafunzi waliojiandikisha katika Kozi A.\n  - m: Idadi ya wanafunzi waliojiandikisha katika Kozi B.\n  - a: Vekta inayobeba vitambulisho vya wanafunzi waliojiandikisha katika Kozi A.\n  - b: Vekta inayobeba vitambulisho vya wanafunzi waliojiandikisha katika Kozi B.\n\n  Inarudisha:\n  - Idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili.\n\n  Mfano:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) inarudisha 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) inarudisha 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "tr": "/*\n  Hem Kurs A'ya hem de Kurs B'ye kayıtlı olan öğrencilerin sayısını sayar.\n\n  Argümanlar:\n  - n: Kurs A'ya kayıtlı öğrenci sayısı.\n  - m: Kurs B'ye kayıtlı öğrenci sayısı.\n  - a: Kurs A'ya kayıtlı öğrencilerin kimliklerini içeren bir vektör.\n  - b: Kurs B'ye kayıtlı öğrencilerin kimliklerini içeren bir vektör.\n\n  Döndürür:\n  - Her iki kursa da kayıtlı olan öğrenci sayısı.\n\n  Örnek:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 4 döndürür\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 0 döndürür\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "vi": "/*\n  Đếm số lượng sinh viên đã đăng ký cả Khóa học A và Khóa học B.\n\n  Tham số:\n  - n: Số lượng sinh viên đã đăng ký Khóa học A.\n  - m: Số lượng sinh viên đã đăng ký Khóa học B.\n  - a: Một vector chứa ID của sinh viên đã đăng ký Khóa học A.\n  - b: Một vector chứa ID của sinh viên đã đăng ký Khóa học B.\n\n  Trả về:\n  - Số lượng sinh viên đã đăng ký cả hai khóa học.\n\n  Ví dụ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) trả về 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) trả về 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9669554525502739",
      "sw": "0.9742241327138647",
      "tr": "0.9758241004331006",
      "vi": "0.9721371233003311"
    },
    "canonical_solution": "{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` to solve the following problem:\nCounts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0",
      "es": "Escribe una función de Rust `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` para resolver el siguiente problema:\nCuenta el número de estudiantes que se han inscrito tanto en el Curso A como en el Curso B.\n\n  Argumentos:\n  - n: El número de estudiantes inscritos en el Curso A.\n  - m: El número de estudiantes inscritos en el Curso B.\n  - a: Un vector que contiene los IDs de los estudiantes inscritos en el Curso A.\n  - b: Un vector que contiene los IDs de los estudiantes inscritos en el Curso B.\n\n  Devuelve:\n  - El número de estudiantes que están inscritos en ambos cursos.\n\n  Ejemplo:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) devuelve 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) devuelve 0",
      "arb": "اكتب دالة بلغة Rust `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` لحل المشكلة التالية:\nتحسب عدد الطلاب الذين سجلوا في كل من الدورة A والدورة B.\n\n  الوسائط:\n  - n: عدد الطلاب المسجلين في الدورة A.\n  - m: عدد الطلاب المسجلين في الدورة B.\n  - a: متجه يحتوي على معرفات الطلاب المسجلين في الدورة A.\n  - b: متجه يحتوي على معرفات الطلاب المسجلين في الدورة B.\n\n  يعيد:\n  - عدد الطلاب الذين سجلوا في كلا الدورتين.\n\n  مثال:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) يعيد 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) يعيد 0",
      "sw": "Andika kazi ya Rust `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` kutatua tatizo lifuatalo:\nHesabu idadi ya wanafunzi ambao wamejiandikisha katika Kozi A na Kozi B.\n\n  Hoja:\n  - n: Idadi ya wanafunzi waliojiandikisha katika Kozi A.\n  - m: Idadi ya wanafunzi waliojiandikisha katika Kozi B.\n  - a: Vector inayobeba vitambulisho vya wanafunzi waliojiandikisha katika Kozi A.\n  - b: Vector inayobeba vitambulisho vya wanafunzi waliojiandikisha katika Kozi B.\n\n  Inarudisha:\n  - Idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili.\n\n  Mfano:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) inarudisha 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) inarudisha 0",
      "tr": "Bir Rust fonksiyonu `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` yazın. Aşağıdaki problemi çözmek için:\nHem A Kursuna hem de B Kursuna kayıtlı olan öğrencilerin sayısını sayar.\n\n  Argümanlar:\n  - n: A Kursuna kayıtlı öğrenci sayısı.\n  - m: B Kursuna kayıtlı öğrenci sayısı.\n  - a: A Kursuna kayıtlı öğrencilerin kimliklerini içeren bir vektör.\n  - b: B Kursuna kayıtlı öğrencilerin kimliklerini içeren bir vektör.\n\n  Döndürür:\n  - Her iki kursa da kayıtlı olan öğrencilerin sayısı.\n\n  Örnek:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 4 döndürür\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 0 döndürür",
      "vi": "Viết một hàm Rust `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` để giải quyết vấn đề sau:\nĐếm số lượng sinh viên đã đăng ký cả Khóa học A và Khóa học B.\n\n  Tham số:\n  - n: Số lượng sinh viên đã đăng ký Khóa học A.\n  - m: Số lượng sinh viên đã đăng ký Khóa học B.\n  - a: Một vector chứa ID của các sinh viên đã đăng ký Khóa học A.\n  - b: Một vector chứa ID của các sinh viên đã đăng ký Khóa học B.\n\n  Trả về:\n  - Số lượng sinh viên đã đăng ký cả hai khóa học.\n\n  Ví dụ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) trả về 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) trả về 0"
    },
    "instruction_bertscore": {
      "es": "0.9955475013787219",
      "arb": "0.9635036537886497",
      "sw": "0.97602551163947",
      "tr": "0.9749300650880626",
      "vi": "0.9750081268278094"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]), 4);\n        assert_eq!(count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]), 0);\n        assert_eq!(count_students_enrolled_in_both(4, 4, vec![1, 3, 5, 7], vec![2, 4, 1, 3]), 2);\n    \n    }\n\n}",
    "entry_point": "count_students_enrolled_in_both",
    "signature": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0",
      "es": "Cuenta el número de estudiantes que se han inscrito tanto en el Curso A como en el Curso B.\n\n  Argumentos:\n  - n: El número de estudiantes inscritos en el Curso A.\n  - m: El número de estudiantes inscritos en el Curso B.\n  - a: Un vector que contiene los IDs de los estudiantes inscritos en el Curso A.\n  - b: Un vector que contiene los IDs de los estudiantes inscritos en el Curso B.\n\n  Retorna:\n  - El número de estudiantes que están inscritos en ambos cursos.\n\n  Ejemplo:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) devuelve 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) devuelve 0",
      "arb": "يحسب عدد الطلاب الذين سجلوا في كل من الدورة A والدورة B.\n\n  الحجج:\n  - n: عدد الطلاب المسجلين في الدورة A.\n  - m: عدد الطلاب المسجلين في الدورة B.\n  - a: متجه يحتوي على معرفات الطلاب المسجلين في الدورة A.\n  - b: متجه يحتوي على معرفات الطلاب المسجلين في الدورة B.\n\n  يعيد:\n  - عدد الطلاب الذين سجلوا في كلا الدورتين.\n\n  مثال:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) يعيد 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) يعيد 0",
      "sw": "Hesabu idadi ya wanafunzi ambao wamejiandikisha katika Kozi A na Kozi B.\n\n  Hoja:\n  - n: Idadi ya wanafunzi waliojiandikisha katika Kozi A.\n  - m: Idadi ya wanafunzi waliojiandikisha katika Kozi B.\n  - a: Vekta inayobeba vitambulisho vya wanafunzi waliojiandikisha katika Kozi A.\n  - b: Vekta inayobeba vitambulisho vya wanafunzi waliojiandikisha katika Kozi B.\n\n  Inarejesha:\n  - Idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili.\n\n  Mfano:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) inarejesha 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) inarejesha 0",
      "tr": "Her iki Kurs A ve Kurs B'ye de kaydolmuş olan öğrencilerin sayısını sayar.\n\n  Argümanlar:\n  - n: Kurs A'ya kaydolmuş öğrenci sayısı.\n  - m: Kurs B'ye kaydolmuş öğrenci sayısı.\n  - a: Kurs A'ya kaydolmuş öğrencilerin kimliklerini içeren bir vektör.\n  - b: Kurs B'ye kaydolmuş öğrencilerin kimliklerini içeren bir vektör.\n\n  Döndürür:\n  - Her iki kursa da kaydolmuş olan öğrencilerin sayısı.\n\n  Örnek:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 4 döndürür\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 0 döndürür",
      "vi": "Đếm số lượng sinh viên đã đăng ký cả Khóa học A và Khóa học B.\n\n  Tham số:\n  - n: Số lượng sinh viên đã đăng ký Khóa học A.\n  - m: Số lượng sinh viên đã đăng ký Khóa học B.\n  - a: Một vector chứa ID của sinh viên đã đăng ký Khóa học A.\n  - b: Một vector chứa ID của sinh viên đã đăng ký Khóa học B.\n\n  Trả về:\n  - Số lượng sinh viên đã đăng ký cả hai khóa học.\n\n  Ví dụ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) trả về 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.9930815051981738",
      "arb": "0.961746370807634",
      "sw": "0.9697990450851693",
      "tr": "0.980955716327137",
      "vi": "0.9687870232937966"
    }
  },
  {
    "task_id": "Rust/51",
    "prompt": {
      "en": "/*\n  Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "es": "/*\n  Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas.\n  Deliv-e-droid gana 50 unidades de dinero por cada entrega exitosa y pierde 10 unidades por cada entrega fallida.\n  Además, si el número de entregas exitosas es mayor que el de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n\n  Argumentos:\n  - delivered: El número de paquetes entregados exitosamente (0 <= delivered <= 100).\n  - failed: El número de entregas fallidas (0 <= failed <= 100).\n\n  Retorna:\n  - Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n\n  Ejemplos:\n  - calculate_droid_earnings(5, 2) devuelve 730.\n  - calculate_droid_earnings(0, 10) devuelve -100.\n  - calculate_droid_earnings(10, 5) devuelve 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "arb": "/*\n  يحسب إجمالي أرباح Deliv-e-droid بناءً على عدد التسليمات الناجحة والفاشلة.\n  يكسب Deliv-e-droid 50 وحدة من المال لكل تسليم ناجح ويفقد 10 وحدات لكل تسليم فاشل.\n  بالإضافة إلى ذلك، إذا كان عدد التسليمات الناجحة أكبر من عدد التسليمات الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n\n  المعطيات:\n  - delivered: عدد الطرود التي تم تسليمها بنجاح (0 <= delivered <= 100).\n  - failed: عدد التسليمات الفاشلة (0 <= failed <= 100).\n\n  يعيد:\n  - إجمالي أرباح Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق المكاسب.\n\n  أمثلة:\n  - calculate_droid_earnings(5, 2) يعيد 730.\n  - calculate_droid_earnings(0, 10) يعيد -100.\n  - calculate_droid_earnings(10, 5) يعيد 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "sw": "/*\n  Inahesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya usafirishaji uliofanikiwa na usafirishaji ulioshindwa.\n  Deliv-e-droid hupata vitengo 50 vya pesa kwa kila usafirishaji uliofanikiwa na hupoteza vitengo 10 kwa kila usafirishaji ulioshindwa.\n  Zaidi ya hayo, ikiwa idadi ya usafirishaji uliofanikiwa ni kubwa kuliko ile ya usafirishaji ulioshindwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n\n  Hoja:\n  - delivered: Idadi ya vifurushi vilivyofikishwa kwa mafanikio (0 <= delivered <= 100).\n  - failed: Idadi ya usafirishaji ulioshindwa (0 <= failed <= 100).\n\n  Inarudisha:\n  - Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara inazidi faida.\n\n  Mifano:\n  - calculate_droid_earnings(5, 2) inarudisha 730.\n  - calculate_droid_earnings(0, 10) inarudisha -100.\n  - calculate_droid_earnings(10, 5) inarudisha 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "tr": "/*\n  Deliv-e-droid'un başarılı teslimatlar ve başarısız teslimatlar sayısına göre toplam kazancını hesaplar.\n  Deliv-e-droid her başarılı teslimat için 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder.\n  Ayrıca, başarılı teslimatların sayısı başarısız olanlardan fazla ise, Deliv-e-droid 500 birim bonus alır.\n\n  Argümanlar:\n  - delivered: Başarıyla teslim edilen paket sayısı (0 <= delivered <= 100).\n  - failed: Başarısız teslimat sayısı (0 <= failed <= 100).\n\n  Döndürür:\n  - Deliv-e-droid'un toplam kazancı, kayıplar kazançlardan fazla ise negatif olabilir.\n\n  Örnekler:\n  - calculate_droid_earnings(5, 2) 730 döndürür.\n  - calculate_droid_earnings(0, 10) -100 döndürür.\n  - calculate_droid_earnings(10, 5) 950 döndürür.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "vi": "/*\n  Tính toán tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại.\n  Deliv-e-droid kiếm được 50 đơn vị tiền cho mỗi lần giao hàng thành công và mất 10 đơn vị cho mỗi lần giao hàng thất bại.\n  Ngoài ra, nếu số lượng giao hàng thành công lớn hơn số lượng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n\n  Tham số:\n  - delivered: Số lượng gói hàng được giao thành công (0 <= delivered <= 100).\n  - failed: Số lượng giao hàng thất bại (0 <= failed <= 100).\n\n  Trả về:\n  - Tổng thu nhập của Deliv-e-droid, có thể âm nếu tổn thất lớn hơn lợi nhuận.\n\n  Ví dụ:\n  - calculate_droid_earnings(5, 2) trả về 730.\n  - calculate_droid_earnings(0, 10) trả về -100.\n  - calculate_droid_earnings(10, 5) trả về 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9854747561260617",
      "arb": "0.97465893461795",
      "sw": "0.9754472986002775",
      "tr": "0.9763631832872294",
      "vi": "0.9717482050142647"
    },
    "canonical_solution": "{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}",
    "instruction": {
      "en": "Write a Rust function `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` to solve the following problem:\nCalculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.",
      "es": "Escribe una función en Rust `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` para resolver el siguiente problema:\nCalcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas.\n  Deliv-e-droid gana 50 unidades de dinero por cada entrega exitosa y pierde 10 unidades por cada entrega fallida.\n  Además, si el número de entregas exitosas es mayor que el número de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n\n  Argumentos:\n  - delivered: El número de paquetes entregados exitosamente (0 <= delivered <= 100).\n  - failed: El número de entregas fallidas (0 <= failed <= 100).\n\n  Retorna:\n  - Las ganancias totales de Deliv-e-droid, las cuales pueden ser negativas si las pérdidas superan las ganancias.\n\n  Ejemplos:\n  - calculate_droid_earnings(5, 2) devuelve 730.\n  - calculate_droid_earnings(0, 10) devuelve -100.\n  - calculate_droid_earnings(10, 5) devuelve 950.",
      "arb": "اكتب دالة Rust `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` لحل المشكلة التالية:\nتحسب إجمالي أرباح Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة.\n  Deliv-e-droid يكسب 50 وحدة من المال لكل عملية تسليم ناجحة ويفقد 10 وحدات لكل عملية تسليم فاشلة.\n  بالإضافة إلى ذلك، إذا كان عدد عمليات التسليم الناجحة أكبر من عدد العمليات الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n\n  الوسائط:\n  - delivered: عدد الطرود التي تم تسليمها بنجاح (0 <= delivered <= 100).\n  - failed: عدد عمليات التسليم الفاشلة (0 <= failed <= 100).\n\n  يعيد:\n  - إجمالي أرباح Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق الأرباح.\n\n  أمثلة:\n  - calculate_droid_earnings(5, 2) يعيد 730.\n  - calculate_droid_earnings(0, 10) يعيد -100.\n  - calculate_droid_earnings(10, 5) يعيد 950.",
      "sw": "Andika kazi ya Rust `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` kutatua tatizo lifuatalo:\nHesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya uwasilishaji uliofanikiwa na uliyoshindwa.\n  Deliv-e-droid hupata vitengo 50 vya pesa kwa kila uwasilishaji uliofanikiwa na hupoteza vitengo 10 kwa kila uwasilishaji ulioshindwa.\n  Zaidi ya hayo, ikiwa idadi ya uwasilishaji uliofanikiwa ni kubwa kuliko ya uliyoshindwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n\n  Hoja:\n  - delivered: Idadi ya vifurushi vilivyowasilishwa kwa mafanikio (0 <= delivered <= 100).\n  - failed: Idadi ya uwasilishaji ulioshindwa (0 <= failed <= 100).\n\n  Inarudisha:\n  - Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara zitazidi mapato.\n\n  Mifano:\n  - calculate_droid_earnings(5, 2) inarudisha 730.\n  - calculate_droid_earnings(0, 10) inarudisha -100.\n  - calculate_droid_earnings(10, 5) inarudisha 950.",
      "tr": "Bir Rust fonksiyonu `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` yazarak aşağıdaki problemi çözün:\nBaşarıyla teslim edilen ve başarısız olan teslimat sayısına göre Deliv-e-droid'in toplam kazancını hesaplar.\n  Deliv-e-droid, her başarılı teslimat için 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder.\n  Ayrıca, başarılı teslimat sayısı başarısız olandan fazlaysa, Deliv-e-droid 500 birim bonus alır.\n\n  Argümanlar:\n  - delivered: Başarıyla teslim edilen paket sayısı (0 <= delivered <= 100).\n  - failed: Başarısız teslimat sayısı (0 <= failed <= 100).\n\n  Döndürür:\n  - Deliv-e-droid'in toplam kazancı, kayıplar kazançlardan fazla ise negatif olabilir.\n\n  Örnekler:\n  - calculate_droid_earnings(5, 2) 730 döndürür.\n  - calculate_droid_earnings(0, 10) -100 döndürür.\n  - calculate_droid_earnings(10, 5) 950 döndürür.",
      "vi": "Viết một hàm Rust `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` để giải quyết vấn đề sau:\nTính toán tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại.\n  Deliv-e-droid kiếm được 50 đơn vị tiền cho mỗi lần giao hàng thành công và mất 10 đơn vị cho mỗi lần giao hàng thất bại.\n  Ngoài ra, nếu số lượng giao hàng thành công lớn hơn số lượng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n\n  Tham số:\n  - delivered: Số lượng gói hàng được giao thành công (0 <= delivered <= 100).\n  - failed: Số lượng giao hàng thất bại (0 <= failed <= 100).\n\n  Trả về:\n  - Tổng thu nhập của Deliv-e-droid, có thể là số âm nếu tổn thất vượt quá lợi nhuận.\n\n  Ví dụ:\n  - calculate_droid_earnings(5, 2) trả về 730.\n  - calculate_droid_earnings(0, 10) trả về -100.\n  - calculate_droid_earnings(10, 5) trả về 950."
    },
    "instruction_bertscore": {
      "es": "0.9913913592859479",
      "arb": "0.9860132430890474",
      "sw": "0.9815951075236883",
      "tr": "0.978450788591906",
      "vi": "0.9760797377334925"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_droid_earnings(5, 2), 730);\n        assert_eq!(calculate_droid_earnings(0, 10), -100);\n        assert_eq!(calculate_droid_earnings(10, 5), 950);\n        assert_eq!(calculate_droid_earnings(3, 3), 120);\n    }\n    \n\n}",
    "entry_point": "calculate_droid_earnings",
    "signature": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32",
    "docstring": {
      "en": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.",
      "es": "Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas.\n  Deliv-e-droid gana 50 unidades de dinero por cada entrega exitosa y pierde 10 unidades por cada entrega fallida.\n  Además, si el número de entregas exitosas es mayor que el número de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n\n  Argumentos:\n  - delivered: El número de paquetes entregados exitosamente (0 <= delivered <= 100).\n  - failed: El número de entregas fallidas (0 <= failed <= 100).\n\n  Retorna:\n  - Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n\n  Ejemplos:\n  - calculate_droid_earnings(5, 2) devuelve 730.\n  - calculate_droid_earnings(0, 10) devuelve -100.\n  - calculate_droid_earnings(10, 5) devuelve 950.",
      "arb": "يحسب إجمالي أرباح Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة. يكسب Deliv-e-droid 50 وحدة من المال لكل عملية تسليم ناجحة ويفقد 10 وحدات لكل عملية تسليم فاشلة. بالإضافة إلى ذلك، إذا كان عدد عمليات التسليم الناجحة أكبر من عدد العمليات الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n\n  الحجج:\n  - delivered: عدد الطرود التي تم تسليمها بنجاح (0 <= delivered <= 100).\n  - failed: عدد عمليات التسليم الفاشلة (0 <= failed <= 100).\n\n  العوائد:\n  - إجمالي أرباح Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق المكاسب.\n\n  أمثلة:\n  - calculate_droid_earnings(5, 2) يعيد 730.\n  - calculate_droid_earnings(0, 10) يعيد -100.\n  - calculate_droid_earnings(10, 5) يعيد 950.",
      "sw": "Hesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya uwasilishaji uliofanikiwa na uliyoshindwa. Deliv-e-droid hupata vitengo 50 vya pesa kwa kila uwasilishaji uliofanikiwa na hupoteza vitengo 10 kwa kila uwasilishaji ulioshindwa. Zaidi ya hayo, ikiwa idadi ya uwasilishaji uliofanikiwa ni kubwa kuliko ile ya uliyoshindwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n\nHoja:\n- delivered: Idadi ya vifurushi vilivyowasilishwa kwa mafanikio (0 <= delivered <= 100).\n- failed: Idadi ya uwasilishaji ulioshindwa (0 <= failed <= 100).\n\nInarejesha:\n- Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara zitazidi faida.\n\nMifano:\n- calculate_droid_earnings(5, 2) inarejesha 730.\n- calculate_droid_earnings(0, 10) inarejesha -100.\n- calculate_droid_earnings(10, 5) inarejesha 950.",
      "tr": "Deliv-e-droid'un başarılı ve başarısız teslimat sayısına göre toplam kazancını hesaplar.\n  Deliv-e-droid, her başarılı teslimat için 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder.\n  Ayrıca, başarılı teslimat sayısı başarısız olanlardan fazlaysa, Deliv-e-droid 500 birim bonus alır.\n\n  Argümanlar:\n  - delivered: Başarıyla teslim edilen paket sayısı (0 <= delivered <= 100).\n  - failed: Başarısız teslimat sayısı (0 <= failed <= 100).\n\n  Döndürür:\n  - Deliv-e-droid'un toplam kazancı, kayıplar kazançlardan fazla ise negatif olabilir.\n\n  Örnekler:\n  - calculate_droid_earnings(5, 2) 730 döndürür.\n  - calculate_droid_earnings(0, 10) -100 döndürür.\n  - calculate_droid_earnings(10, 5) 950 döndürür.",
      "vi": "Tính tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại. Deliv-e-droid kiếm được 50 đơn vị tiền cho mỗi lần giao hàng thành công và mất 10 đơn vị cho mỗi lần giao hàng thất bại. Ngoài ra, nếu số lượng giao hàng thành công lớn hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng là 500 đơn vị.\n\n  Tham số:\n  - delivered: Số lượng gói hàng được giao thành công (0 <= delivered <= 100).\n  - failed: Số lượng giao hàng thất bại (0 <= failed <= 100).\n\n  Trả về:\n  - Tổng thu nhập của Deliv-e-droid, có thể là số âm nếu tổn thất lớn hơn lợi nhuận.\n\n  Ví dụ:\n  - calculate_droid_earnings(5, 2) trả về 730.\n  - calculate_droid_earnings(0, 10) trả về -100.\n  - calculate_droid_earnings(10, 5) trả về 950."
    },
    "docstring_bertscore": {
      "es": "0.9865189560391622",
      "arb": "0.9870147374702252",
      "sw": "0.9760072376444148",
      "tr": "0.9778048425927806",
      "vi": "0.9710637247212185"
    }
  },
  {
    "task_id": "Rust/52",
    "prompt": {
      "en": "/*\n  Finds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "es": "/*\n  Encuentra los números de identificación faltantes y duplicados de una serie de secuencias de identificaciones.\n  Cada secuencia de identificaciones se representa como un vector dentro de un vector más grande, simulando el formato de entrada descrito.\n  Se asume que las identificaciones son parte de un rango continuo pero con una identificación faltante y una identificación duplicada.\n  La función identifica y devuelve tanto la identificación faltante (que ha sido omitida) como la identificación duplicada (que aparece más de una vez).\n\n  Argumentos:\n  - data: Un vector de vectores, donde cada vector interno contiene una secuencia de números de identificación.\n\n  Devuelve:\n  - Una tupla que contiene dos valores usize: el primero es la identificación faltante, y el segundo es la identificación duplicada.\n\n  Ejemplo:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) devuelve (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "arb": "/*\n  يعثر على أرقام الهوية المفقودة والمكررة من سلسلة من تسلسلات الهوية.\n  يتم تمثيل كل تسلسل من أرقام الهوية كمتجه داخل متجه أكبر، مما يحاكي تنسيق الإدخال الموصوف.\n  يُفترض أن أرقام الهوية جزء من نطاق مستمر ولكن مع هوية واحدة مفقودة وهوية واحدة مكررة.\n  تحدد الدالة وتعيد كل من الهوية المفقودة (التي تم تخطيها) والهوية المكررة (التي تظهر أكثر من مرة).\n\n  الوسائط:\n  - data: متجه من المتجهات، حيث يحتوي كل متجه داخلي على تسلسل من أرقام الهوية.\n\n  الإرجاع:\n  - زوج يحتوي على قيمتين من نوع usize: الأولى هي الهوية المفقودة، والثانية هي الهوية المكررة.\n\n  مثال:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) يعيد (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "sw": "/*\n  Inapata namba za ID zilizopotea na zinazojirudia kutoka kwa mfululizo wa misururu ya ID.\n  Kila mfululizo wa ID unawakilishwa kama vekta ndani ya vekta kubwa zaidi, ikisimulia muundo wa pembejeo ulioelezwa.\n  ID zinadhaniwa kuwa sehemu ya safu endelevu lakini zikiwa na ID moja iliyopotea na ID moja inayojirudia.\n  Kazi inatambua na kurudisha zote mbili, ID iliyopotea (ambayo imeachwa) na ID inayojirudia (inayoonekana zaidi ya mara moja).\n\n  Hoja:\n  - data: Vekta ya vekta, ambapo kila vekta ya ndani ina mfululizo wa namba za ID.\n\n  Inarudisha:\n  - Jozi inayojumuisha thamani mbili za usize: ya kwanza ni ID iliyopotea, na ya pili ni ID inayojirudia.\n\n  Mfano:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) inarudisha (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "tr": "/*\n  Bir dizi kimlik numarası dizisinden eksik ve yinelenen kimlik numaralarını bulur.\n  Her kimlik dizisi, açıklanan giriş formatını simüle ederek daha büyük bir vektör içinde bir vektör olarak temsil edilir.\n  Kimliklerin, bir eksik kimlik ve bir yinelenen kimlik ile birlikte kesintisiz bir aralığın parçası olduğu varsayılır.\n  Fonksiyon, atlanan eksik kimliği ve birden fazla kez görünen yinelenen kimliği tanımlar ve döndürür.\n\n  Argümanlar:\n  - data: Her bir iç vektörün bir kimlik numarası dizisi içerdiği bir vektör vektörü.\n\n  Döndürür:\n  - İki usize değer içeren bir demet: birincisi eksik kimlik, ikincisi yinelenen kimliktir.\n\n  Örnek:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) (7, 9) döndürür\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "vi": "/*\n  Tìm số ID bị thiếu và trùng lặp từ một loạt các dãy số ID.\n  Mỗi dãy số ID được biểu diễn dưới dạng một vector trong một vector lớn hơn, mô phỏng định dạng đầu vào được mô tả.\n  Các ID được giả định là một phần của một dãy liên tục nhưng có một ID bị thiếu và một ID trùng lặp.\n  Hàm xác định và trả về cả ID bị thiếu (đã bị bỏ qua) và ID trùng lặp (xuất hiện nhiều hơn một lần).\n\n  Tham số:\n  - data: Một vector của các vector, trong đó mỗi vector con chứa một dãy số ID.\n\n  Trả về:\n  - Một bộ giá trị chứa hai giá trị usize: giá trị đầu tiên là ID bị thiếu, và giá trị thứ hai là ID trùng lặp.\n\n  Ví dụ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) trả về (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) "
    },
    "prompt_bertscore": {
      "es": "0.966659691912913",
      "arb": "0.980158811238425",
      "sw": "0.9636105169336464",
      "tr": "0.9594078953317102",
      "vi": "0.9579563045071073"
    },
    "canonical_solution": "{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}",
    "instruction": {
      "en": "Write a Rust function `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` to solve the following problem:\nFinds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "es": "Escribe una función de Rust `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` para resolver el siguiente problema:\nEncuentra los números de ID faltantes y duplicados de una serie de secuencias de ID.\n  Cada secuencia de IDs se representa como un vector dentro de un vector más grande, simulando el formato de entrada descrito.\n  Se asume que los IDs son parte de un rango continuo pero con un ID faltante y un ID duplicado.\n  La función identifica y devuelve tanto el ID faltante (que ha sido omitido) como el ID duplicado (que aparece más de una vez).\n\n  Argumentos:\n  - data: Un vector de vectores, donde cada vector interno contiene una secuencia de números de ID.\n\n  Devuelve:\n  - Una tupla que contiene dos valores usize: el primero es el ID faltante y el segundo es el ID duplicado.\n\n  Ejemplo:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) devuelve (7, 9)",
      "arb": "اكتب دالة Rust `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` لحل المشكلة التالية:\nتجد أرقام المعرفات المفقودة والمكررة من سلسلة من تسلسلات المعرفات.\n  يتم تمثيل كل تسلسل من المعرفات كمتجه داخل متجه أكبر، مما يحاكي تنسيق الإدخال الموصوف.\n  يُفترض أن تكون المعرفات جزءًا من نطاق مستمر ولكن مع معرف مفقود واحد ومعرف مكرر واحد.\n  تحدد الدالة وتعيد كلا من المعرف المفقود (الذي تم تخطيه) والمعرف المكرر (الذي يظهر أكثر من مرة).\n\n  الوسائط:\n  - data: متجه من المتجهات، حيث يحتوي كل متجه داخلي على تسلسل من أرقام المعرفات.\n\n  يعيد:\n  - زوج يحتوي على قيمتين من نوع usize: الأول هو المعرف المفقود، والثاني هو المعرف المكرر.\n\n  مثال:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) يعيد (7, 9)",
      "sw": "Andika kazi ya Rust `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` kutatua tatizo lifuatalo:\nInapata namba za ID zilizopotea na zilizorudiwa kutoka kwa mfululizo wa mfuatano wa ID.\n  Kila mfuatano wa ID unawakilishwa kama vector ndani ya vector kubwa zaidi, ikisimulia muundo wa pembejeo ulioelezewa.\n  ID zinadhaniwa kuwa sehemu ya safu endelevu lakini na ID moja iliyopotea na ID moja iliyorudiwa.\n  Kazi inatambua na kurudisha ID zote mbili zilizopotea (ambayo imeachwa) na ID iliyorudiwa (ambayo inaonekana zaidi ya mara moja).\n\n  Hoja:\n  - data: Vector ya vectors, ambapo kila vector ya ndani ina mfuatano wa namba za ID.\n\n  Inarudisha:\n  - Jozi inayojumuisha thamani mbili za usize: ya kwanza ni ID iliyopotea, na ya pili ni ID iliyorudiwa.\n\n  Mfano:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) inarudisha (7, 9)",
      "tr": "Rust dilinde `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` fonksiyonunu aşağıdaki problemi çözmek için yazın:\nBir dizi kimlik numarası dizisinden eksik ve yinelenen kimlik numaralarını bulur.\n  Her kimlik dizisi, tanımlanan giriş formatını simüle eden daha büyük bir vektör içinde bir vektör olarak temsil edilir.\n  Kimliklerin, bir eksik kimlik ve bir yinelenen kimlik ile birlikte sürekli bir aralığın parçası olduğu varsayılır.\n  Fonksiyon, hem atlanmış olan eksik kimliği hem de birden fazla kez görünen yinelenen kimliği tanımlar ve döndürür.\n\n  Argümanlar:\n  - data: Her bir iç vektörün bir kimlik numarası dizisi içerdiği bir vektörler vektörü.\n\n  Döndürür:\n  - İki usize değeri içeren bir demet: ilki eksik kimlik, ikincisi ise yinelenen kimliktir.\n\n  Örnek:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) (7, 9) döndürür.",
      "vi": "Viết một hàm Rust `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` để giải quyết vấn đề sau:\nTìm các số ID bị thiếu và trùng lặp từ một loạt các dãy số ID.\n  Mỗi dãy số ID được biểu diễn dưới dạng một vector trong một vector lớn hơn, mô phỏng định dạng đầu vào được mô tả.\n  Các ID được giả định là một phần của một dãy liên tục nhưng có một ID bị thiếu và một ID bị trùng lặp.\n  Hàm xác định và trả về cả ID bị thiếu (đã bị bỏ qua) và ID trùng lặp (xuất hiện nhiều hơn một lần).\n\n  Tham số:\n  - data: Một vector của các vector, trong đó mỗi vector con chứa một dãy số ID.\n\n  Kết quả trả về:\n  - Một tuple chứa hai giá trị usize: giá trị đầu tiên là ID bị thiếu, và giá trị thứ hai là ID trùng lặp.\n\n  Ví dụ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) trả về (7, 9)"
    },
    "instruction_bertscore": {
      "es": "0.9892101990718039",
      "arb": "0.9869914977156441",
      "sw": "0.9761456830199962",
      "tr": "0.9570884883723658",
      "vi": "0.9712961222670293"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]), (7, 9));\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![1, 2, 4, 7], vec![5, 3, 3]]), (6, 3));\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![1, 1, 3, 4, 5]]), (2, 1)); // Edge case with minimal input\n    \n    }\n    \n\n}",
    "entry_point": "find_missing_and_duplicate_ids",
    "signature": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)",
    "docstring": {
      "en": "Finds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "es": "Encuentra los números de ID faltantes y duplicados de una serie de secuencias de ID.  \nCada secuencia de IDs se representa como un vector dentro de un vector más grande, simulando el formato de entrada descrito.  \nSe asume que los IDs son parte de un rango continuo pero con un ID faltante y un ID duplicado.  \nLa función identifica y devuelve tanto el ID faltante (que ha sido omitido) como el ID duplicado (que aparece más de una vez).\n\nArgumentos:\n- data: Un vector de vectores, donde cada vector interno contiene una secuencia de números de ID.\n\nDevuelve:\n- Una tupla que contiene dos valores usize: el primero es el ID faltante, y el segundo es el ID duplicado.\n\nEjemplo:\n- find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) devuelve (7, 9)",
      "arb": "يجد أرقام التعريف المفقودة والمكررة من سلسلة من تسلسلات أرقام التعريف.\n  يتم تمثيل كل تسلسل من أرقام التعريف كمتجه داخل متجه أكبر، مما يحاكي تنسيق الإدخال الموصوف.\n  يُفترض أن أرقام التعريف جزء من نطاق مستمر ولكن مع رقم تعريف مفقود واحد ورقم تعريف مكرر واحد.\n  تحدد الدالة وتعيد كلا من رقم التعريف المفقود (الذي تم تخطيه) ورقم التعريف المكرر (الذي يظهر أكثر من مرة).\n\n  الحجج:\n  - data: متجه من المتجهات، حيث يحتوي كل متجه داخلي على تسلسل من أرقام التعريف.\n\n  يعيد:\n  - زوج يحتوي على قيمتين من نوع usize: الأول هو رقم التعريف المفقود، والثاني هو رقم التعريف المكرر.\n\n  مثال:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) يعيد (7, 9)",
      "sw": "Inapata nambari za ID zilizokosekana na zinazojirudia kutoka kwa mfululizo wa misururu ya ID.\n  Kila mfululizo wa ID unawakilishwa kama vekta ndani ya vekta kubwa zaidi, ikisimulia muundo wa ingizo ulioelezwa.\n  ID zinadhaniwa kuwa sehemu ya safu endelevu lakini zikiwa na ID moja iliyokosekana na ID moja inayojirudia.\n  Kazi inatambua na kurudisha ID zote mbili zilizokosekana (ambayo imeachwa) na ID inayojirudia (inayojitokeza zaidi ya mara moja).\n\n  Hoja:\n  - data: Vekta ya vekta, ambapo kila vekta ya ndani ina mfululizo wa nambari za ID.\n\n  Inarudisha:\n  - Jozi inayo na thamani mbili za usize: ya kwanza ni ID iliyokosekana, na ya pili ni ID inayojirudia.\n\n  Mfano:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) inarudisha (7, 9)",
      "tr": "Eksik ve yinelenen kimlik numaralarını bir dizi kimlik dizisinden bulur. \n  Her kimlik dizisi, açıklanan giriş formatını simüle eden daha büyük bir vektör içinde bir vektör olarak temsil edilir. \n  Kimliklerin sürekli bir aralığın parçası olduğu varsayılır, ancak bir eksik kimlik ve bir yinelenen kimlik vardır. \n  Fonksiyon, hem atlanmış olan eksik kimliği hem de birden fazla kez görünen yinelenen kimliği tanımlar ve döndürür.\n\n  Argümanlar:\n  - data: Her bir iç vektörün bir kimlik numaraları dizisini içerdiği bir vektör vektörü.\n\n  Döndürülenler:\n  - İki usize değeri içeren bir demet: ilki eksik kimlik, ikincisi yinelenen kimliktir.\n\n  Örnek:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) (7, 9) döndürür.",
      "vi": "Tìm các số ID bị thiếu và trùng lặp từ một loạt các chuỗi ID.\n  Mỗi chuỗi ID được biểu diễn dưới dạng một vector trong một vector lớn hơn, mô phỏng định dạng đầu vào đã mô tả.\n  Các ID được giả định là một phần của một phạm vi liên tục nhưng có một ID bị thiếu và một ID trùng lặp.\n  Hàm xác định và trả về cả ID bị thiếu (đã bị bỏ qua) và ID trùng lặp (xuất hiện nhiều hơn một lần).\n\n  Tham số:\n  - data: Một vector của các vector, trong đó mỗi vector con chứa một chuỗi các số ID.\n\n  Trả về:\n  - Một bộ giá trị chứa hai giá trị usize: giá trị đầu tiên là ID bị thiếu, và giá trị thứ hai là ID trùng lặp.\n\n  Ví dụ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) trả về (7, 9)"
    },
    "docstring_bertscore": {
      "es": "0.9886443011162355",
      "arb": "0.9754707369852396",
      "sw": "0.9596281764242779",
      "tr": "0.9600427180294977",
      "vi": "0.9594903269398397"
    }
  },
  {
    "task_id": "Rust/53",
    "prompt": {
      "en": "/*\n  Counts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "es": "/*\n  Cuenta el número de caracteres dígitos, letras minúsculas y letras mayúsculas en una cadena dada de longitud 8.\n  \n  Argumentos:\n  - s: Una cadena de exactamente 8 caracteres que puede incluir dígitos, letras minúsculas y letras mayúsculas.\n\n  Devuelve:\n  - Una tupla que contiene tres valores usize: el conteo de caracteres dígitos, el conteo de letras minúsculas y el conteo de letras mayúsculas en la cadena.\n\n  Ejemplos:\n  - count_chars_types(\"yLOI2022\") devuelve (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") devuelve (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") devuelve (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "arb": "/*\n  يحسب عدد الأحرف الرقمية، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n\n  الوسائط:\n  - s: سلسلة تحتوي على 8 أحرف بالضبط وقد تشمل أرقامًا، أحرفًا صغيرة، وأحرفًا كبيرة.\n\n  يعيد:\n  - زوج من القيم الثلاثة من نوع usize: عدد الأحرف الرقمية، عدد الأحرف الصغيرة، وعدد الأحرف الكبيرة في السلسلة.\n\n  أمثلة:\n  - count_chars_types(\"yLOI2022\") يعيد (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") يعيد (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") يعيد (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "sw": "/*\n  Inahesabu idadi ya herufi za nambari, herufi ndogo, na herufi kubwa katika kamba iliyotolewa ya urefu wa 8.\n  \n  Hoja:\n  - s: Kamba ya herufi nane kamili ambayo inaweza kujumuisha nambari, herufi ndogo, na herufi kubwa.\n\n  Inarejesha:\n  - Jozi yenye thamani tatu za usize: idadi ya herufi za nambari, idadi ya herufi ndogo, na idadi ya herufi kubwa katika kamba.\n\n  Mifano:\n  - count_chars_types(\"yLOI2022\") inarejesha (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") inarejesha (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") inarejesha (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "tr": "/*\n  Belirtilen uzunluğu 8 olan bir stringdeki rakam karakterlerinin, küçük harflerin ve büyük harflerin sayısını sayar.\n  \n  Argümanlar:\n  - s: Rakamlar, küçük harfler ve büyük harfler içerebilen tam olarak 8 karakterlik bir string.\n\n  Döndürür:\n  - Bir tuple döndürür: stringdeki rakam karakterlerinin sayısı, küçük harflerin sayısı ve büyük harflerin sayısı olmak üzere üç usize değeri içerir.\n\n  Örnekler:\n  - count_chars_types(\"yLOI2022\") (4, 1, 3) döndürür\n  - count_chars_types(\"IAKIOIOI\") (0, 0, 8) döndürür\n  - count_chars_types(\"1n2s0e1s\") (4, 4, 0) döndürür\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "vi": "/*\n  Đếm số ký tự chữ số, chữ cái viết thường và chữ cái viết hoa trong một chuỗi có độ dài 8.\n\n  Tham số:\n  - s: Một chuỗi có đúng 8 ký tự có thể bao gồm chữ số, chữ cái viết thường và chữ cái viết hoa.\n\n  Trả về:\n  - Một bộ giá trị chứa ba giá trị usize: số lượng ký tự chữ số, số lượng chữ cái viết thường và số lượng chữ cái viết hoa trong chuỗi.\n\n  Ví dụ:\n  - count_chars_types(\"yLOI2022\") trả về (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") trả về (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") trả về (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) "
    },
    "prompt_bertscore": {
      "es": "0.9986699709685903",
      "arb": "0.9716784857505215",
      "sw": "0.9802777908366649",
      "tr": "0.9723272125749814",
      "vi": "0.9755400589882207"
    },
    "canonical_solution": "{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_chars_types(s: &str) -> (usize, usize, usize)` to solve the following problem:\nCounts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)",
      "es": "Escribe una función en Rust `fn count_chars_types(s: &str) -> (usize, usize, usize)` para resolver el siguiente problema:\nCuenta el número de caracteres que son dígitos, letras minúsculas y letras mayúsculas en una cadena dada de longitud 8.\n  \n  Argumentos:\n  - s: Una cadena de exactamente 8 caracteres que puede incluir dígitos, letras minúsculas y letras mayúsculas.\n\n  Devuelve:\n  - Una tupla que contiene tres valores usize: el conteo de caracteres que son dígitos, el conteo de letras minúsculas y el conteo de letras mayúsculas en la cadena.\n\n  Ejemplos:\n  - count_chars_types(\"yLOI2022\") devuelve (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") devuelve (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") devuelve (4, 4, 0)",
      "arb": "اكتب دالة Rust `fn count_chars_types(s: &str) -> (usize, usize, usize)` لحل المشكلة التالية:\nتحسب عدد الأحرف الرقمية، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n\n  الوسائط:\n  - s: سلسلة تحتوي على 8 أحرف بالضبط قد تشمل أرقامًا، أحرفًا صغيرة، وأحرفًا كبيرة.\n\n  تعيد:\n  - زوج يحتوي على ثلاثة قيم من نوع usize: عدد الأحرف الرقمية، عدد الأحرف الصغيرة، وعدد الأحرف الكبيرة في السلسلة.\n\n  أمثلة:\n  - count_chars_types(\"yLOI2022\") يعيد (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") يعيد (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") يعيد (4, 4, 0)",
      "sw": "Andika kazi ya Rust `fn count_chars_types(s: &str) -> (usize, usize, usize)` kutatua tatizo lifuatalo:\nHesabu idadi ya herufi za namba, herufi ndogo, na herufi kubwa katika kamba iliyo na urefu wa 8.\n\nHoja:\n- s: Kamba yenye herufi 8 kamili ambayo inaweza kujumuisha namba, herufi ndogo, na herufi kubwa.\n\nInarejesha:\n- Nyuzi yenye thamani tatu za usize: idadi ya herufi za namba, idadi ya herufi ndogo, na idadi ya herufi kubwa katika kamba.\n\nMifano:\n- count_chars_types(\"yLOI2022\") inarejesha (4, 1, 3)\n- count_chars_types(\"IAKIOIOI\") inarejesha (0, 0, 8)\n- count_chars_types(\"1n2s0e1s\") inarejesha (4, 4, 0)",
      "tr": "Bir Rust fonksiyonu `fn count_chars_types(s: &str) -> (usize, usize, usize)` yazın ve aşağıdaki problemi çözün:\nVerilen 8 uzunluğundaki bir stringdeki rakam karakterlerinin, küçük harflerin ve büyük harflerin sayısını sayar.\n\n  Argümanlar:\n  - s: Tam olarak 8 karakterden oluşan, rakamlar, küçük harfler ve büyük harfler içerebilen bir string.\n\n  Döndürür:\n  - Bir tuple döndürür, üç usize değeri içerir: stringdeki rakam karakterlerinin sayısı, küçük harflerin sayısı ve büyük harflerin sayısı.\n\n  Örnekler:\n  - count_chars_types(\"yLOI2022\") (4, 1, 3) döndürür\n  - count_chars_types(\"IAKIOIOI\") (0, 0, 8) döndürür\n  - count_chars_types(\"1n2s0e1s\") (4, 4, 0) döndürür",
      "vi": "Viết một hàm Rust `fn count_chars_types(s: &str) -> (usize, usize, usize)` để giải quyết vấn đề sau:\nĐếm số lượng ký tự chữ số, chữ cái thường, và chữ cái hoa trong một chuỗi có độ dài 8.\n\n  Tham số:\n  - s: Một chuỗi có đúng 8 ký tự có thể bao gồm chữ số, chữ cái thường, và chữ cái hoa.\n\n  Trả về:\n  - Một bộ giá trị chứa ba giá trị kiểu usize: số lượng ký tự chữ số, số lượng chữ cái thường, và số lượng chữ cái hoa trong chuỗi.\n\n  Ví dụ:\n  - count_chars_types(\"yLOI2022\") trả về (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") trả về (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") trả về (4, 4, 0)"
    },
    "instruction_bertscore": {
      "es": "0.9798999958519365",
      "arb": "0.9637080444507345",
      "sw": "0.982681019816806",
      "tr": "0.9775674792874439",
      "vi": "0.9739255912511692"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_chars_types(\"yLOI2022\"), (4, 1, 3));\n        assert_eq!(count_chars_types(\"IAKIOIOI\"), (0, 0, 8));\n        assert_eq!(count_chars_types(\"1n2s0e1s\"), (4, 4, 0));\n    }\n    \n\n}",
    "entry_point": "count_chars_types",
    "signature": "fn count_chars_types(s: &str) -> (usize, usize, usize)",
    "docstring": {
      "en": "Counts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)",
      "es": "Cuenta el número de caracteres numéricos, letras minúsculas y letras mayúsculas en una cadena dada de longitud 8.\n\n  Argumentos:\n  - s: Una cadena de exactamente 8 caracteres que puede incluir dígitos, letras minúsculas y letras mayúsculas.\n\n  Retorna:\n  - Una tupla que contiene tres valores usize: el conteo de caracteres numéricos, el conteo de letras minúsculas y el conteo de letras mayúsculas en la cadena.\n\n  Ejemplos:\n  - count_chars_types(\"yLOI2022\") retorna (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") retorna (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") retorna (4, 4, 0)",
      "arb": "يحسب عدد الأحرف الرقمية، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n\n  الحجج:\n  - s: سلسلة مكونة من 8 أحرف بالضبط قد تتضمن أرقامًا، أحرفًا صغيرة، وأحرفًا كبيرة.\n\n  يعيد:\n  - زوج يحتوي على ثلاث قيم من نوع usize: عدد الأحرف الرقمية، عدد الأحرف الصغيرة، وعدد الأحرف الكبيرة في السلسلة.\n\n  أمثلة:\n  - count_chars_types(\"yLOI2022\") يعيد (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") يعيد (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") يعيد (4, 4, 0)",
      "sw": "Hesabu idadi ya herufi za tarakimu, herufi ndogo, na herufi kubwa katika kamba iliyotolewa ya urefu wa 8.\n\n  Hoja:\n  - s: Kamba yenye herufi 8 kamili ambayo inaweza kujumuisha tarakimu, herufi ndogo, na herufi kubwa.\n\n  Inarudisha:\n  - Tupuli inayojumuisha thamani tatu za usize: hesabu ya herufi za tarakimu, hesabu ya herufi ndogo, na hesabu ya herufi kubwa katika kamba.\n\n  Mifano:\n  - count_chars_types(\"yLOI2022\") inarudisha (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") inarudisha (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") inarudisha (4, 4, 0)",
      "tr": "Verilen 8 karakter uzunluğundaki bir stringdeki rakam karakterlerinin, küçük harflerin ve büyük harflerin sayısını sayar.\n\n  Argümanlar:\n  - s: Tam olarak 8 karakterden oluşan, rakamlar, küçük harfler ve büyük harfler içerebilen bir string.\n\n  Döndürülenler:\n  - Bir tuple döndürür, üç usize değeri içerir: stringdeki rakam karakterlerinin sayısı, küçük harflerin sayısı ve büyük harflerin sayısı.\n\n  Örnekler:\n  - count_chars_types(\"yLOI2022\") (4, 1, 3) döndürür\n  - count_chars_types(\"IAKIOIOI\") (0, 0, 8) döndürür\n  - count_chars_types(\"1n2s0e1s\") (4, 4, 0) döndürür",
      "vi": "Đếm số ký tự chữ số, chữ cái thường, và chữ cái hoa trong một chuỗi có độ dài 8.\n\n  Tham số:\n  - s: Một chuỗi có chính xác 8 ký tự có thể bao gồm chữ số, chữ cái thường, và chữ cái hoa.\n\n  Trả về:\n  - Một bộ giá trị chứa ba giá trị usize: số lượng ký tự chữ số, số lượng chữ cái thường, và số lượng chữ cái hoa trong chuỗi.\n\n  Ví dụ:\n  - count_chars_types(\"yLOI2022\") trả về (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") trả về (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") trả về (4, 4, 0)"
    },
    "docstring_bertscore": {
      "es": "0.9925227579363227",
      "arb": "0.9677920837151929",
      "sw": "0.9821476972437273",
      "tr": "0.9655990056781867",
      "vi": "0.9711396015267738"
    }
  }
]